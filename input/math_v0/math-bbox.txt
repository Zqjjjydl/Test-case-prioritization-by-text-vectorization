/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3; import java.util.Random; import org.apache.commons.math3.exception.MathIllegalStateException; import org.junit.Test; import org.junit.runner.RunWith; /** * Test for the "Retry" functionality (retrying Junit test methods). */ @RunWith(RetryRunner.class) public class RetryRunnerTest { final Random rng = new Random(); /** * Shows that an always failing test will fail even if it is retried. */ @Test(expected=MathIllegalStateException.class) @Retry public void testRetryFailAlways() { throw new MathIllegalStateException(); } /** * Shows that a test that sometimes fail might succeed if it is retried. * In this case the high number of retries makes it quite unlikely that * the exception will be thrown by all of the calls. */ @Test @Retry(100) public void testRetryFailSometimes() { if (rng.nextBoolean()) { throw new MathIllegalStateException(); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis; import org.apache.commons.math3.analysis.differentiation.DerivativeStructure; import org.apache.commons.math3.analysis.differentiation.MultivariateDifferentiableFunction; import org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction; import org.apache.commons.math3.analysis.function.Add; import org.apache.commons.math3.analysis.function.Constant; import org.apache.commons.math3.analysis.function.Cos; import org.apache.commons.math3.analysis.function.Cosh; import org.apache.commons.math3.analysis.function.Divide; import org.apache.commons.math3.analysis.function.Identity; import org.apache.commons.math3.analysis.function.Inverse; import org.apache.commons.math3.analysis.function.Log; import org.apache.commons.math3.analysis.function.Max; import org.apache.commons.math3.analysis.function.Min; import org.apache.commons.math3.analysis.function.Minus; import org.apache.commons.math3.analysis.function.Multiply; import org.apache.commons.math3.analysis.function.Pow; import org.apache.commons.math3.analysis.function.Power; import org.apache.commons.math3.analysis.function.Sin; import org.apache.commons.math3.analysis.function.Sinc; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.apache.commons.math3.exception.NumberIsTooLargeException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * Test for {@link FunctionUtils}. */ public class FunctionUtilsTest { private final double EPS = Math.ulp(1d); @Test public void testCompose() { UnivariateFunction id = new Identity(); Assert.assertEquals(3, FunctionUtils.compose(id, id, id).value(3), EPS); UnivariateFunction c = new Constant(4); Assert.assertEquals(4, FunctionUtils.compose(id, c).value(3), EPS); Assert.assertEquals(4, FunctionUtils.compose(c, id).value(3), EPS); UnivariateFunction m = new Minus(); Assert.assertEquals(-3, FunctionUtils.compose(m).value(3), EPS); Assert.assertEquals(3, FunctionUtils.compose(m, m).value(3), EPS); UnivariateFunction inv = new Inverse(); Assert.assertEquals(-0.25, FunctionUtils.compose(inv, m, c, id).value(3), EPS); UnivariateFunction pow = new Power(2); Assert.assertEquals(81, FunctionUtils.compose(pow, pow).value(3), EPS); } @Test public void testComposeDifferentiable() { UnivariateDifferentiableFunction id = new Identity(); Assert.assertEquals(1, FunctionUtils.compose(id, id, id).value(new DerivativeStructure(1, 1, 0, 3)).getPartialDerivative(1), EPS); UnivariateDifferentiableFunction c = new Constant(4); Assert.assertEquals(0, FunctionUtils.compose(id, c).value(new DerivativeStructure(1, 1, 0, 3)).getPartialDerivative(1), EPS); Assert.assertEquals(0, FunctionUtils.compose(c, id).value(new DerivativeStructure(1, 1, 0, 3)).getPartialDerivative(1), EPS); UnivariateDifferentiableFunction m = new Minus(); Assert.assertEquals(-1, FunctionUtils.compose(m).value(new DerivativeStructure(1, 1, 0, 3)).getPartialDerivative(1), EPS); Assert.assertEquals(1, FunctionUtils.compose(m, m).value(new DerivativeStructure(1, 1, 0, 3)).getPartialDerivative(1), EPS); UnivariateDifferentiableFunction inv = new Inverse(); Assert.assertEquals(0.25, FunctionUtils.compose(inv, m, id).value(new DerivativeStructure(1, 1, 0, 2)).getPartialDerivative(1), EPS); UnivariateDifferentiableFunction pow = new Power(2); Assert.assertEquals(108, FunctionUtils.compose(pow, pow).value(new DerivativeStructure(1, 1, 0, 3)).getPartialDerivative(1), EPS); UnivariateDifferentiableFunction log = new Log(); double a = 9876.54321; Assert.assertEquals(pow.value(new DerivativeStructure(1, 1, 0, a)).getPartialDerivative(1) / pow.value(a), FunctionUtils.compose(log, pow).value(new DerivativeStructure(1, 1, 0, a)).getPartialDerivative(1), EPS); } @Test public void testAdd() { UnivariateFunction id = new Identity(); UnivariateFunction c = new Constant(4); UnivariateFunction m = new Minus(); UnivariateFunction inv = new Inverse(); Assert.assertEquals(4.5, FunctionUtils.add(inv, m, c, id).value(2), EPS); Assert.assertEquals(4 + 2, FunctionUtils.add(c, id).value(2), EPS); Assert.assertEquals(4 - 2, FunctionUtils.add(c, FunctionUtils.compose(m, id)).value(2), EPS); } @Test public void testAddDifferentiable() { UnivariateDifferentiableFunction sin = new Sin(); UnivariateDifferentiableFunction c = new Constant(4); UnivariateDifferentiableFunction m = new Minus(); UnivariateDifferentiableFunction inv = new Inverse(); final double a = 123.456; Assert.assertEquals(- 1 / (a * a) -1 + Math.cos(a), FunctionUtils.add(inv, m, c, sin).value(new DerivativeStructure(1, 1, 0, a)).getPartialDerivative(1), EPS); } @Test public void testMultiply() { UnivariateFunction c = new Constant(4); Assert.assertEquals(16, FunctionUtils.multiply(c, c).value(12345), EPS); UnivariateFunction inv = new Inverse(); UnivariateFunction pow = new Power(2); Assert.assertEquals(1, FunctionUtils.multiply(FunctionUtils.compose(inv, pow), pow).value(3.5), EPS); } @Test public void testMultiplyDifferentiable() { UnivariateDifferentiableFunction c = new Constant(4); UnivariateDifferentiableFunction id = new Identity(); final double a = 1.2345678; Assert.assertEquals(8 * a, FunctionUtils.multiply(c, id, id).value(new DerivativeStructure(1, 1, 0, a)).getPartialDerivative(1), EPS); UnivariateDifferentiableFunction inv = new Inverse(); UnivariateDifferentiableFunction pow = new Power(2.5); UnivariateDifferentiableFunction cos = new Cos(); Assert.assertEquals(1.5 * Math.sqrt(a) * Math.cos(a) - Math.pow(a, 1.5) * Math.sin(a), FunctionUtils.multiply(inv, pow, cos).value(new DerivativeStructure(1, 1, 0, a)).getPartialDerivative(1), EPS); UnivariateDifferentiableFunction cosh = new Cosh(); Assert.assertEquals(1.5 * Math.sqrt(a) * Math.cosh(a) + Math.pow(a, 1.5) * Math.sinh(a), FunctionUtils.multiply(inv, pow, cosh).value(new DerivativeStructure(1, 1, 0, a)).getPartialDerivative(1), 8 * EPS); } @Test public void testCombine() { BivariateFunction bi = new Add(); UnivariateFunction id = new Identity(); UnivariateFunction m = new Minus(); UnivariateFunction c = FunctionUtils.combine(bi, id, m); Assert.assertEquals(0, c.value(2.3456), EPS); bi = new Multiply(); UnivariateFunction inv = new Inverse(); c = FunctionUtils.combine(bi, id, inv); Assert.assertEquals(1, c.value(2.3456), EPS); } @Test public void testCollector() { BivariateFunction bi = new Add(); MultivariateFunction coll = FunctionUtils.collector(bi, 0); Assert.assertEquals(10, coll.value(new double[] {1, 2, 3, 4}), EPS); bi = new Multiply(); coll = FunctionUtils.collector(bi, 1); Assert.assertEquals(24, coll.value(new double[] {1, 2, 3, 4}), EPS); bi = new Max(); coll = FunctionUtils.collector(bi, Double.NEGATIVE_INFINITY); Assert.assertEquals(10, coll.value(new double[] {1, -2, 7.5, 10, -24, 9.99}), 0); bi = new Min(); coll = FunctionUtils.collector(bi, Double.POSITIVE_INFINITY); Assert.assertEquals(-24, coll.value(new double[] {1, -2, 7.5, 10, -24, 9.99}), 0); } @Test public void testSinc() { BivariateFunction div = new Divide(); UnivariateFunction sin = new Sin(); UnivariateFunction id = new Identity(); UnivariateFunction sinc1 = FunctionUtils.combine(div, sin, id); UnivariateFunction sinc2 = new Sinc(); for (int i = 0; i < 10; i++) { double x = Math.random(); Assert.assertEquals(sinc1.value(x), sinc2.value(x), EPS); } } @Test public void testFixingArguments() { UnivariateFunction scaler = FunctionUtils.fix1stArgument(new Multiply(), 10); Assert.assertEquals(1.23456, scaler.value(0.123456), EPS); UnivariateFunction pow1 = new Power(2); UnivariateFunction pow2 = FunctionUtils.fix2ndArgument(new Pow(), 2); for (int i = 0; i < 10; i++) { double x = Math.random() * 10; Assert.assertEquals(pow1.value(x), pow2.value(x), 0); } } @Test(expected = NumberIsTooLargeException.class) public void testSampleWrongBounds(){ FunctionUtils.sample(new Sin(), Math.PI, 0.0, 10); } @Test(expected = NotStrictlyPositiveException.class) public void testSampleNegativeNumberOfPoints(){ FunctionUtils.sample(new Sin(), 0.0, Math.PI, -1); } @Test(expected = NotStrictlyPositiveException.class) public void testSampleNullNumberOfPoints(){ FunctionUtils.sample(new Sin(), 0.0, Math.PI, 0); } @Test public void testSample() { final int n = 11; final double min = 0.0; final double max = Math.PI; final double[] actual = FunctionUtils.sample(new Sin(), min, max, n); for (int i = 0; i < n; i++) { final double x = min + (max - min) / n * i; Assert.assertEquals("x = " + x, FastMath.sin(x), actual[i], 0.0); } } @Test @Deprecated public void testToDifferentiableUnivariateFunction() { // Sin implements both UnivariateDifferentiableFunction and DifferentiableUnivariateFunction Sin sin = new Sin(); DifferentiableUnivariateFunction converted = FunctionUtils.toDifferentiableUnivariateFunction(sin); for (double x = 0.1; x < 0.5; x += 0.01) { Assert.assertEquals(sin.value(x), converted.value(x), 1.0e-10); Assert.assertEquals(sin.derivative().value(x), converted.derivative().value(x), 1.0e-10); } } @Test @Deprecated public void testToUnivariateDifferential() { // Sin implements both UnivariateDifferentiableFunction and DifferentiableUnivariateFunction Sin sin = new Sin(); UnivariateDifferentiableFunction converted = FunctionUtils.toUnivariateDifferential(sin); for (double x = 0.1; x < 0.5; x += 0.01) { DerivativeStructure t = new DerivativeStructure(2, 1, x, 1.0, 2.0); Assert.assertEquals(sin.value(t).getValue(), converted.value(t).getValue(), 1.0e-10); Assert.assertEquals(sin.value(t).getPartialDerivative(1, 0), converted.value(t).getPartialDerivative(1, 0), 1.0e-10); Assert.assertEquals(sin.value(t).getPartialDerivative(0, 1), converted.value(t).getPartialDerivative(0, 1), 1.0e-10); } } @Test @Deprecated public void testToDifferentiableMultivariateFunction() { MultivariateDifferentiableFunction hypot = new MultivariateDifferentiableFunction() { public double value(double[] point) { return FastMath.hypot(point[0], point[1]); } public DerivativeStructure value(DerivativeStructure[] point) { return DerivativeStructure.hypot(point[0], point[1]); } }; DifferentiableMultivariateFunction converted = FunctionUtils.toDifferentiableMultivariateFunction(hypot); for (double x = 0.1; x < 0.5; x += 0.01) { for (double y = 0.1; y < 0.5; y += 0.01) { double[] point = new double[] { x, y }; Assert.assertEquals(hypot.value(point), converted.value(point), 1.0e-10); Assert.assertEquals(x / hypot.value(point), converted.gradient().value(point)[0], 1.0e-10); Assert.assertEquals(y / hypot.value(point), converted.gradient().value(point)[1], 1.0e-10); } } } @Test @Deprecated public void testToMultivariateDifferentiableFunction() { DifferentiableMultivariateFunction hypot = new DifferentiableMultivariateFunction() { public double value(double[] point) { return FastMath.hypot(point[0], point[1]); } public MultivariateFunction partialDerivative(final int k) { return new MultivariateFunction() { public double value(double[] point) { return point[k] / FastMath.hypot(point[0], point[1]); } }; } public MultivariateVectorFunction gradient() { return new MultivariateVectorFunction() { public double[] value(double[] point) { final double h = FastMath.hypot(point[0], point[1]); return new double[] { point[0] / h, point[1] / h }; } }; } }; MultivariateDifferentiableFunction converted = FunctionUtils.toMultivariateDifferentiableFunction(hypot); for (double x = 0.1; x < 0.5; x += 0.01) { for (double y = 0.1; y < 0.5; y += 0.01) { DerivativeStructure[] t = new DerivativeStructure[] { new DerivativeStructure(3, 1, x, 1.0, 2.0, 3.0 ), new DerivativeStructure(3, 1, y, 4.0, 5.0, 6.0 ) }; DerivativeStructure h = DerivativeStructure.hypot(t[0], t[1]); Assert.assertEquals(h.getValue(), converted.value(t).getValue(), 1.0e-10); Assert.assertEquals(h.getPartialDerivative(1, 0, 0), converted.value(t).getPartialDerivative(1, 0, 0), 1.0e-10); Assert.assertEquals(h.getPartialDerivative(0, 1, 0), converted.value(t).getPartialDerivative(0, 1, 0), 1.0e-10); Assert.assertEquals(h.getPartialDerivative(0, 0, 1), converted.value(t).getPartialDerivative(0, 0, 1), 1.0e-10); } } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.differentiation; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.util.CombinatoricsUtils; import org.junit.Assert; import org.junit.Test; /** * Test for class {@link DSCompiler}. */ public class DSCompilerTest { @Test public void testSize() { for (int i = 0; i < 6; ++i) { for (int j = 0; j < 6; ++j) { long expected = CombinatoricsUtils.binomialCoefficient(i + j, i); Assert.assertEquals(expected, DSCompiler.getCompiler(i, j).getSize()); Assert.assertEquals(expected, DSCompiler.getCompiler(j, i).getSize()); } } } @Test public void testIndices() { DSCompiler c = DSCompiler.getCompiler(0, 0); checkIndices(c.getPartialDerivativeOrders(0), new int[0]); c = DSCompiler.getCompiler(0, 1); checkIndices(c.getPartialDerivativeOrders(0), new int[0]); c = DSCompiler.getCompiler(1, 0); checkIndices(c.getPartialDerivativeOrders(0), 0); c = DSCompiler.getCompiler(1, 1); checkIndices(c.getPartialDerivativeOrders(0), 0); checkIndices(c.getPartialDerivativeOrders(1), 1); c = DSCompiler.getCompiler(1, 2); checkIndices(c.getPartialDerivativeOrders(0), 0); checkIndices(c.getPartialDerivativeOrders(1), 1); checkIndices(c.getPartialDerivativeOrders(2), 2); c = DSCompiler.getCompiler(2, 1); checkIndices(c.getPartialDerivativeOrders(0), 0, 0); checkIndices(c.getPartialDerivativeOrders(1), 1, 0); checkIndices(c.getPartialDerivativeOrders(2), 0, 1); c = DSCompiler.getCompiler(1, 3); checkIndices(c.getPartialDerivativeOrders(0), 0); checkIndices(c.getPartialDerivativeOrders(1), 1); checkIndices(c.getPartialDerivativeOrders(2), 2); checkIndices(c.getPartialDerivativeOrders(3), 3); c = DSCompiler.getCompiler(2, 2); checkIndices(c.getPartialDerivativeOrders(0), 0, 0); checkIndices(c.getPartialDerivativeOrders(1), 1, 0); checkIndices(c.getPartialDerivativeOrders(2), 2, 0); checkIndices(c.getPartialDerivativeOrders(3), 0, 1); checkIndices(c.getPartialDerivativeOrders(4), 1, 1); checkIndices(c.getPartialDerivativeOrders(5), 0, 2); c = DSCompiler.getCompiler(3, 1); checkIndices(c.getPartialDerivativeOrders(0), 0, 0, 0); checkIndices(c.getPartialDerivativeOrders(1), 1, 0, 0); checkIndices(c.getPartialDerivativeOrders(2), 0, 1, 0); checkIndices(c.getPartialDerivativeOrders(3), 0, 0, 1); c = DSCompiler.getCompiler(1, 4); checkIndices(c.getPartialDerivativeOrders(0), 0); checkIndices(c.getPartialDerivativeOrders(1), 1); checkIndices(c.getPartialDerivativeOrders(2), 2); checkIndices(c.getPartialDerivativeOrders(3), 3); checkIndices(c.getPartialDerivativeOrders(4), 4); c = DSCompiler.getCompiler(2, 3); checkIndices(c.getPartialDerivativeOrders(0), 0, 0); checkIndices(c.getPartialDerivativeOrders(1), 1, 0); checkIndices(c.getPartialDerivativeOrders(2), 2, 0); checkIndices(c.getPartialDerivativeOrders(3), 3, 0); checkIndices(c.getPartialDerivativeOrders(4), 0, 1); checkIndices(c.getPartialDerivativeOrders(5), 1, 1); checkIndices(c.getPartialDerivativeOrders(6), 2, 1); checkIndices(c.getPartialDerivativeOrders(7), 0, 2); checkIndices(c.getPartialDerivativeOrders(8), 1, 2); checkIndices(c.getPartialDerivativeOrders(9), 0, 3); c = DSCompiler.getCompiler(3, 2); checkIndices(c.getPartialDerivativeOrders(0), 0, 0, 0); checkIndices(c.getPartialDerivativeOrders(1), 1, 0, 0); checkIndices(c.getPartialDerivativeOrders(2), 2, 0, 0); checkIndices(c.getPartialDerivativeOrders(3), 0, 1, 0); checkIndices(c.getPartialDerivativeOrders(4), 1, 1, 0); checkIndices(c.getPartialDerivativeOrders(5), 0, 2, 0); checkIndices(c.getPartialDerivativeOrders(6), 0, 0, 1); checkIndices(c.getPartialDerivativeOrders(7), 1, 0, 1); checkIndices(c.getPartialDerivativeOrders(8), 0, 1, 1); checkIndices(c.getPartialDerivativeOrders(9), 0, 0, 2); c = DSCompiler.getCompiler(4, 1); checkIndices(c.getPartialDerivativeOrders(0), 0, 0, 0, 0); checkIndices(c.getPartialDerivativeOrders(1), 1, 0, 0, 0); checkIndices(c.getPartialDerivativeOrders(2), 0, 1, 0, 0); checkIndices(c.getPartialDerivativeOrders(3), 0, 0, 1, 0); checkIndices(c.getPartialDerivativeOrders(4), 0, 0, 0, 1); } @Test(expected=DimensionMismatchException.class) public void testIncompatibleParams() { DSCompiler.getCompiler(3, 2).checkCompatibility(DSCompiler.getCompiler(4, 2)); } @Test(expected=DimensionMismatchException.class) public void testIncompatibleOrder() { DSCompiler.getCompiler(3, 3).checkCompatibility(DSCompiler.getCompiler(3, 2)); } @Test public void testSymmetry() { for (int i = 0; i < 6; ++i) { for (int j = 0; j < 6; ++j) { DSCompiler c = DSCompiler.getCompiler(i, j); for (int k = 0; k < c.getSize(); ++k) { Assert.assertEquals(k, c.getPartialDerivativeIndex(c.getPartialDerivativeOrders(k))); } } } } @Test public void testMultiplicationRules() throws SecurityException, NoSuchFieldException, IllegalArgumentException, IllegalAccessException { Map<String,String> referenceRules = new HashMap<String, String>(); referenceRules.put("(f*g)", "f * g"); referenceRules.put("d(f*g)/dx", "f * dg/dx + df/dx * g"); referenceRules.put("d(f*g)/dy", referenceRules.get("d(f*g)/dx").replaceAll("x", "y")); referenceRules.put("d(f*g)/dz", referenceRules.get("d(f*g)/dx").replaceAll("x", "z")); referenceRules.put("d(f*g)/dt", referenceRules.get("d(f*g)/dx").replaceAll("x", "t")); referenceRules.put("d2(f*g)/dx2", "f * d2g/dx2 + 2 * df/dx * dg/dx + d2f/dx2 * g"); referenceRules.put("d2(f*g)/dy2", referenceRules.get("d2(f*g)/dx2").replaceAll("x", "y")); referenceRules.put("d2(f*g)/dz2", referenceRules.get("d2(f*g)/dx2").replaceAll("x", "z")); referenceRules.put("d2(f*g)/dt2", referenceRules.get("d2(f*g)/dx2").replaceAll("x", "t")); referenceRules.put("d2(f*g)/dxdy", "f * d2g/dxdy + df/dy * dg/dx + df/dx * dg/dy + d2f/dxdy * g"); referenceRules.put("d2(f*g)/dxdz", referenceRules.get("d2(f*g)/dxdy").replaceAll("y", "z")); referenceRules.put("d2(f*g)/dxdt", referenceRules.get("d2(f*g)/dxdy").replaceAll("y", "t")); referenceRules.put("d2(f*g)/dydz", referenceRules.get("d2(f*g)/dxdz").replaceAll("x", "y")); referenceRules.put("d2(f*g)/dydt", referenceRules.get("d2(f*g)/dxdt").replaceAll("x", "y")); referenceRules.put("d2(f*g)/dzdt", referenceRules.get("d2(f*g)/dxdt").replaceAll("x", "z")); referenceRules.put("d3(f*g)/dx3", "f * d3g/dx3 +" + " 3 * df/dx * d2g/dx2 +" + " 3 * d2f/dx2 * dg/dx +" + " d3f/dx3 * g"); referenceRules.put("d3(f*g)/dy3", referenceRules.get("d3(f*g)/dx3").replaceAll("x", "y")); referenceRules.put("d3(f*g)/dz3", referenceRules.get("d3(f*g)/dx3").replaceAll("x", "z")); referenceRules.put("d3(f*g)/dt3", referenceRules.get("d3(f*g)/dx3").replaceAll("x", "t")); referenceRules.put("d3(f*g)/dx2dy", "f * d3g/dx2dy +" + " df/dy * d2g/dx2 +" + " 2 * df/dx * d2g/dxdy +" + " 2 * d2f/dxdy * dg/dx +" + " d2f/dx2 * dg/dy +" + " d3f/dx2dy * g"); referenceRules.put("d3(f*g)/dxdy2", "f * d3g/dxdy2 +" + " 2 * df/dy * d2g/dxdy +" + " d2f/dy2 * dg/dx +" + " df/dx * d2g/dy2 +" + " 2 * d2f/dxdy * dg/dy +" + " d3f/dxdy2 * g"); referenceRules.put("d3(f*g)/dx2dz", referenceRules.get("d3(f*g)/dx2dy").replaceAll("y", "z")); referenceRules.put("d3(f*g)/dy2dz", referenceRules.get("d3(f*g)/dx2dz").replaceAll("x", "y")); referenceRules.put("d3(f*g)/dxdz2", referenceRules.get("d3(f*g)/dxdy2").replaceAll("y", "z")); referenceRules.put("d3(f*g)/dydz2", referenceRules.get("d3(f*g)/dxdz2").replaceAll("x", "y")); referenceRules.put("d3(f*g)/dx2dt", referenceRules.get("d3(f*g)/dx2dz").replaceAll("z", "t")); referenceRules.put("d3(f*g)/dy2dt", referenceRules.get("d3(f*g)/dx2dt").replaceAll("x", "y")); referenceRules.put("d3(f*g)/dz2dt", referenceRules.get("d3(f*g)/dx2dt").replaceAll("x", "z")); referenceRules.put("d3(f*g)/dxdt2", referenceRules.get("d3(f*g)/dxdy2").replaceAll("y", "t")); referenceRules.put("d3(f*g)/dydt2", referenceRules.get("d3(f*g)/dxdt2").replaceAll("x", "y")); referenceRules.put("d3(f*g)/dzdt2", referenceRules.get("d3(f*g)/dxdt2").replaceAll("x", "z")); referenceRules.put("d3(f*g)/dxdydz", "f * d3g/dxdydz +" + " df/dz * d2g/dxdy +" + " df/dy * d2g/dxdz +" + " d2f/dydz * dg/dx +" + " df/dx * d2g/dydz +" + " d2f/dxdz * dg/dy +" + " d2f/dxdy * dg/dz +" + " d3f/dxdydz * g"); referenceRules.put("d3(f*g)/dxdydt", referenceRules.get("d3(f*g)/dxdydz").replaceAll("z", "t")); referenceRules.put("d3(f*g)/dxdzdt", referenceRules.get("d3(f*g)/dxdydt").replaceAll("y", "z")); referenceRules.put("d3(f*g)/dydzdt", referenceRules.get("d3(f*g)/dxdzdt").replaceAll("x", "y")); Field multFieldArrayField = DSCompiler.class.getDeclaredField("multIndirection"); multFieldArrayField.setAccessible(true); for (int i = 0; i < 5; ++i) { for (int j = 0; j < 4; ++j) { DSCompiler compiler = DSCompiler.getCompiler(i, j); int[][][] multIndirection = (int[][][]) multFieldArrayField.get(compiler); for (int k = 0; k < multIndirection.length; ++k) { String product = ordersToString(compiler.getPartialDerivativeOrders(k), "(f*g)", "x", "y", "z", "t"); StringBuilder rule = new StringBuilder(); for (int[] term : multIndirection[k]) { if (rule.length() > 0) { rule.append(" + "); } if (term[0] > 1) { rule.append(term[0]).append(" * "); } rule.append(ordersToString(compiler.getPartialDerivativeOrders(term[1]), "f", "x", "y", "z", "t")); rule.append(" * "); rule.append(ordersToString(compiler.getPartialDerivativeOrders(term[2]), "g", "x", "y", "z", "t")); } Assert.assertEquals(product, referenceRules.get(product), rule.toString()); } } } } @Test public void testCompositionRules() throws SecurityException, NoSuchFieldException, IllegalArgumentException, IllegalAccessException { // the following reference rules have all been computed independently from the library, // using only pencil and paper and some search and replace to handle symmetries Map<String,String> referenceRules = new HashMap<String, String>(); referenceRules.put("(f(g))", "(f(g))"); referenceRules.put("d(f(g))/dx", "d(f(g))/dg * dg/dx"); referenceRules.put("d(f(g))/dy", referenceRules.get("d(f(g))/dx").replaceAll("x", "y")); referenceRules.put("d(f(g))/dz", referenceRules.get("d(f(g))/dx").replaceAll("x", "z")); referenceRules.put("d(f(g))/dt", referenceRules.get("d(f(g))/dx").replaceAll("x", "t")); referenceRules.put("d2(f(g))/dx2", "d2(f(g))/dg2 * dg/dx * dg/dx + d(f(g))/dg * d2g/dx2"); referenceRules.put("d2(f(g))/dy2", referenceRules.get("d2(f(g))/dx2").replaceAll("x", "y")); referenceRules.put("d2(f(g))/dz2", referenceRules.get("d2(f(g))/dx2").replaceAll("x", "z")); referenceRules.put("d2(f(g))/dt2", referenceRules.get("d2(f(g))/dx2").replaceAll("x", "t")); referenceRules.put("d2(f(g))/dxdy", "d2(f(g))/dg2 * dg/dx * dg/dy + d(f(g))/dg * d2g/dxdy"); referenceRules.put("d2(f(g))/dxdz", referenceRules.get("d2(f(g))/dxdy").replaceAll("y", "z")); referenceRules.put("d2(f(g))/dxdt", referenceRules.get("d2(f(g))/dxdy").replaceAll("y", "t")); referenceRules.put("d2(f(g))/dydz", referenceRules.get("d2(f(g))/dxdz").replaceAll("x", "y")); referenceRules.put("d2(f(g))/dydt", referenceRules.get("d2(f(g))/dxdt").replaceAll("x", "y")); referenceRules.put("d2(f(g))/dzdt", referenceRules.get("d2(f(g))/dxdt").replaceAll("x", "z")); referenceRules.put("d3(f(g))/dx3", "d3(f(g))/dg3 * dg/dx * dg/dx * dg/dx +" + " 3 * d2(f(g))/dg2 * dg/dx * d2g/dx2 +" + " d(f(g))/dg * d3g/dx3"); referenceRules.put("d3(f(g))/dy3", referenceRules.get("d3(f(g))/dx3").replaceAll("x", "y")); referenceRules.put("d3(f(g))/dz3", referenceRules.get("d3(f(g))/dx3").replaceAll("x", "z")); referenceRules.put("d3(f(g))/dt3", referenceRules.get("d3(f(g))/dx3").replaceAll("x", "t")); referenceRules.put("d3(f(g))/dxdy2", "d3(f(g))/dg3 * dg/dx * dg/dy * dg/dy +" + " 2 * d2(f(g))/dg2 * dg/dy * d2g/dxdy +" + " d2(f(g))/dg2 * dg/dx * d2g/dy2 +" + " d(f(g))/dg * d3g/dxdy2"); referenceRules.put("d3(f(g))/dxdz2", referenceRules.get("d3(f(g))/dxdy2").replaceAll("y", "z")); referenceRules.put("d3(f(g))/dxdt2", referenceRules.get("d3(f(g))/dxdy2").replaceAll("y", "t")); referenceRules.put("d3(f(g))/dydz2", referenceRules.get("d3(f(g))/dxdz2").replaceAll("x", "y")); referenceRules.put("d3(f(g))/dydt2", referenceRules.get("d3(f(g))/dxdt2").replaceAll("x", "y")); referenceRules.put("d3(f(g))/dzdt2", referenceRules.get("d3(f(g))/dxdt2").replaceAll("x", "z")); referenceRules.put("d3(f(g))/dx2dy", "d3(f(g))/dg3 * dg/dx * dg/dx * dg/dy +" + " 2 * d2(f(g))/dg2 * dg/dx * d2g/dxdy +" + " d2(f(g))/dg2 * d2g/dx2 * dg/dy +" + " d(f(g))/dg * d3g/dx2dy"); referenceRules.put("d3(f(g))/dx2dz", referenceRules.get("d3(f(g))/dx2dy").replaceAll("y", "z")); referenceRules.put("d3(f(g))/dx2dt", referenceRules.get("d3(f(g))/dx2dy").replaceAll("y", "t")); referenceRules.put("d3(f(g))/dy2dz", referenceRules.get("d3(f(g))/dx2dz").replaceAll("x", "y")); referenceRules.put("d3(f(g))/dy2dt", referenceRules.get("d3(f(g))/dx2dt").replaceAll("x", "y")); referenceRules.put("d3(f(g))/dz2dt", referenceRules.get("d3(f(g))/dx2dt").replaceAll("x", "z")); referenceRules.put("d3(f(g))/dxdydz", "d3(f(g))/dg3 * dg/dx * dg/dy * dg/dz +" + " d2(f(g))/dg2 * dg/dy * d2g/dxdz +" + " d2(f(g))/dg2 * dg/dx * d2g/dydz +" + " d2(f(g))/dg2 * d2g/dxdy * dg/dz +" + " d(f(g))/dg * d3g/dxdydz"); referenceRules.put("d3(f(g))/dxdydt", referenceRules.get("d3(f(g))/dxdydz").replaceAll("z", "t")); referenceRules.put("d3(f(g))/dxdzdt", referenceRules.get("d3(f(g))/dxdydt").replaceAll("y", "z")); referenceRules.put("d3(f(g))/dydzdt", referenceRules.get("d3(f(g))/dxdzdt").replaceAll("x", "y")); referenceRules.put("d4(f(g))/dx4", "d4(f(g))/dg4 * dg/dx * dg/dx * dg/dx * dg/dx +" + " 6 * d3(f(g))/dg3 * dg/dx * dg/dx * d2g/dx2 +" + " 3 * d2(f(g))/dg2 * d2g/dx2 * d2g/dx2 +" + " 4 * d2(f(g))/dg2 * dg/dx * d3g/dx3 +" + " d(f(g))/dg * d4g/dx4"); referenceRules.put("d4(f(g))/dy4", referenceRules.get("d4(f(g))/dx4").replaceAll("x", "y")); referenceRules.put("d4(f(g))/dz4", referenceRules.get("d4(f(g))/dx4").replaceAll("x", "z")); referenceRules.put("d4(f(g))/dt4", referenceRules.get("d4(f(g))/dx4").replaceAll("x", "t")); referenceRules.put("d4(f(g))/dx3dy", "d4(f(g))/dg4 * dg/dx * dg/dx * dg/dx * dg/dy +" + " 3 * d3(f(g))/dg3 * dg/dx * dg/dx * d2g/dxdy +" + " 3 * d3(f(g))/dg3 * dg/dx * d2g/dx2 * dg/dy +" + " 3 * d2(f(g))/dg2 * d2g/dx2 * d2g/dxdy +" + " 3 * d2(f(g))/dg2 * dg/dx * d3g/dx2dy +" + " d2(f(g))/dg2 * d3g/dx3 * dg/dy +" + " d(f(g))/dg * d4g/dx3dy"); referenceRules.put("d4(f(g))/dx3dz", referenceRules.get("d4(f(g))/dx3dy").replaceAll("y", "z")); referenceRules.put("d4(f(g))/dx3dt", referenceRules.get("d4(f(g))/dx3dy").replaceAll("y", "t")); referenceRules.put("d4(f(g))/dxdy3", "d4(f(g))/dg4 * dg/dx * dg/dy * dg/dy * dg/dy +" + " 3 * d3(f(g))/dg3 * dg/dy * dg/dy * d2g/dxdy +" + " 3 * d3(f(g))/dg3 * dg/dx * dg/dy * d2g/dy2 +" + " 3 * d2(f(g))/dg2 * d2g/dxdy * d2g/dy2 +" + " 3 * d2(f(g))/dg2 * dg/dy * d3g/dxdy2 +" + " d2(f(g))/dg2 * dg/dx * d3g/dy3 +" + " d(f(g))/dg * d4g/dxdy3"); referenceRules.put("d4(f(g))/dxdz3", referenceRules.get("d4(f(g))/dxdy3").replaceAll("y", "z")); referenceRules.put("d4(f(g))/dxdt3", referenceRules.get("d4(f(g))/dxdy3").replaceAll("y", "t")); referenceRules.put("d4(f(g))/dy3dz", referenceRules.get("d4(f(g))/dx3dz").replaceAll("x", "y")); referenceRules.put("d4(f(g))/dy3dt", referenceRules.get("d4(f(g))/dx3dt").replaceAll("x", "y")); referenceRules.put("d4(f(g))/dydz3", referenceRules.get("d4(f(g))/dxdz3").replaceAll("x", "y")); referenceRules.put("d4(f(g))/dydt3", referenceRules.get("d4(f(g))/dxdt3").replaceAll("x", "y")); referenceRules.put("d4(f(g))/dz3dt", referenceRules.get("d4(f(g))/dx3dt").replaceAll("x", "z")); referenceRules.put("d4(f(g))/dzdt3", referenceRules.get("d4(f(g))/dxdt3").replaceAll("x", "z")); referenceRules.put("d4(f(g))/dx2dy2", "d4(f(g))/dg4 * dg/dx * dg/dx * dg/dy * dg/dy +" + " 4 * d3(f(g))/dg3 * dg/dx * dg/dy * d2g/dxdy +" + " d3(f(g))/dg3 * dg/dx * dg/dx * d2g/dy2 +" + " 2 * d2(f(g))/dg2 * d2g/dxdy * d2g/dxdy +" + " 2 * d2(f(g))/dg2 * dg/dx * d3g/dxdy2 +" + " d3(f(g))/dg3 * d2g/dx2 * dg/dy * dg/dy +" + " 2 * d2(f(g))/dg2 * dg/dy * d3g/dx2dy +" + " d2(f(g))/dg2 * d2g/dx2 * d2g/dy2 +" + " d(f(g))/dg * d4g/dx2dy2"); referenceRules.put("d4(f(g))/dx2dz2", referenceRules.get("d4(f(g))/dx2dy2").replaceAll("y", "z")); referenceRules.put("d4(f(g))/dx2dt2", referenceRules.get("d4(f(g))/dx2dy2").replaceAll("y", "t")); referenceRules.put("d4(f(g))/dy2dz2", referenceRules.get("d4(f(g))/dx2dz2").replaceAll("x", "y")); referenceRules.put("d4(f(g))/dy2dt2", referenceRules.get("d4(f(g))/dx2dt2").replaceAll("x", "y")); referenceRules.put("d4(f(g))/dz2dt2", referenceRules.get("d4(f(g))/dx2dt2").replaceAll("x", "z")); referenceRules.put("d4(f(g))/dx2dydz", "d4(f(g))/dg4 * dg/dx * dg/dx * dg/dy * dg/dz +" + " 2 * d3(f(g))/dg3 * dg/dx * dg/dy * d2g/dxdz +" + " d3(f(g))/dg3 * dg/dx * dg/dx * d2g/dydz +" + " 2 * d3(f(g))/dg3 * dg/dx * d2g/dxdy * dg/dz +" + " 2 * d2(f(g))/dg2 * d2g/dxdy * d2g/dxdz +" + " 2 * d2(f(g))/dg2 * dg/dx * d3g/dxdydz +" + " d3(f(g))/dg3 * d2g/dx2 * dg/dy * dg/dz +" + " d2(f(g))/dg2 * dg/dy * d3g/dx2dz +" + " d2(f(g))/dg2 * d2g/dx2 * d2g/dydz +" + " d2(f(g))/dg2 * d3g/dx2dy * dg/dz +" + " d(f(g))/dg * d4g/dx2dydz"); referenceRules.put("d4(f(g))/dx2dydt", referenceRules.get("d4(f(g))/dx2dydz").replaceAll("z", "t")); referenceRules.put("d4(f(g))/dx2dzdt", referenceRules.get("d4(f(g))/dx2dydt").replaceAll("y", "z")); referenceRules.put("d4(f(g))/dxdy2dz", "d4(f(g))/dg4 * dg/dx * dg/dy * dg/dy * dg/dz +" + " d3(f(g))/dg3 * dg/dy * dg/dy * d2g/dxdz +" + " 2 * d3(f(g))/dg3 * dg/dx * dg/dy * d2g/dydz +" + " 2 * d3(f(g))/dg3 * dg/dy * d2g/dxdy * dg/dz +" + " 2 * d2(f(g))/dg2 * d2g/dxdy * d2g/dydz +" + " 2 * d2(f(g))/dg2 * dg/dy * d3g/dxdydz +" + " d3(f(g))/dg3 * dg/dx * d2g/dy2 * dg/dz +" + " d2(f(g))/dg2 * d2g/dy2 * d2g/dxdz +" + " d2(f(g))/dg2 * dg/dx * d3g/dy2dz +" + " d2(f(g))/dg2 * d3g/dxdy2 * dg/dz +" + " d(f(g))/dg * d4g/dxdy2dz"); referenceRules.put("d4(f(g))/dxdy2dt", referenceRules.get("d4(f(g))/dxdy2dz").replaceAll("z", "t")); referenceRules.put("d4(f(g))/dy2dzdt", referenceRules.get("d4(f(g))/dx2dzdt").replaceAll("x", "y")); referenceRules.put("d4(f(g))/dxdydz2", "d4(f(g))/dg4 * dg/dx * dg/dy * dg/dz * dg/dz +" + " 2 * d3(f(g))/dg3 * dg/dy * dg/dz * d2g/dxdz +" + " 2 * d3(f(g))/dg3 * dg/dx * dg/dz * d2g/dydz +" + " d3(f(g))/dg3 * dg/dx * dg/dy * d2g/dz2 +" + " 2 * d2(f(g))/dg2 * d2g/dxdz * d2g/dydz +" + " d2(f(g))/dg2 * dg/dy * d3g/dxdz2 +" + " d2(f(g))/dg2 * dg/dx * d3g/dydz2 +" + " d3(f(g))/dg3 * d2g/dxdy * dg/dz * dg/dz +" + " 2 * d2(f(g))/dg2 * dg/dz * d3g/dxdydz +" + " d2(f(g))/dg2 * d2g/dxdy * d2g/dz2 +" + " d(f(g))/dg * d4g/dxdydz2"); referenceRules.put("d4(f(g))/dxdz2dt", referenceRules.get("d4(f(g))/dxdy2dt").replaceAll("y", "z")); referenceRules.put("d4(f(g))/dydz2dt", referenceRules.get("d4(f(g))/dxdz2dt").replaceAll("x", "y")); referenceRules.put("d4(f(g))/dxdydt2", referenceRules.get("d4(f(g))/dxdydz2").replaceAll("z", "t")); referenceRules.put("d4(f(g))/dxdzdt2", referenceRules.get("d4(f(g))/dxdydt2").replaceAll("y", "z")); referenceRules.put("d4(f(g))/dydzdt2", referenceRules.get("d4(f(g))/dxdzdt2").replaceAll("x", "y")); referenceRules.put("d4(f(g))/dxdydzdt", "d4(f(g))/dg4 * dg/dx * dg/dy * dg/dz * dg/dt +" + " d3(f(g))/dg3 * dg/dy * dg/dz * d2g/dxdt +" + " d3(f(g))/dg3 * dg/dx * dg/dz * d2g/dydt +" + " d3(f(g))/dg3 * dg/dx * dg/dy * d2g/dzdt +" + " d3(f(g))/dg3 * dg/dy * d2g/dxdz * dg/dt +" + " d2(f(g))/dg2 * d2g/dxdz * d2g/dydt +" + " d2(f(g))/dg2 * dg/dy * d3g/dxdzdt +" + " d3(f(g))/dg3 * dg/dx * d2g/dydz * dg/dt +" + " d2(f(g))/dg2 * d2g/dydz * d2g/dxdt +" + " d2(f(g))/dg2 * dg/dx * d3g/dydzdt +" + " d3(f(g))/dg3 * d2g/dxdy * dg/dz * dg/dt +" + " d2(f(g))/dg2 * dg/dz * d3g/dxdydt +" + " d2(f(g))/dg2 * d2g/dxdy * d2g/dzdt +" + " d2(f(g))/dg2 * d3g/dxdydz * dg/dt +" + " d(f(g))/dg * d4g/dxdydzdt"); Field compFieldArrayField = DSCompiler.class.getDeclaredField("compIndirection"); compFieldArrayField.setAccessible(true); for (int i = 0; i < 5; ++i) { for (int j = 0; j < 5; ++j) { DSCompiler compiler = DSCompiler.getCompiler(i, j); int[][][] compIndirection = (int[][][]) compFieldArrayField.get(compiler); for (int k = 0; k < compIndirection.length; ++k) { String product = ordersToString(compiler.getPartialDerivativeOrders(k), "(f(g))", "x", "y", "z", "t"); StringBuilder rule = new StringBuilder(); for (int[] term : compIndirection[k]) { if (rule.length() > 0) { rule.append(" + "); } if (term[0] > 1) { rule.append(term[0]).append(" * "); } rule.append(orderToString(term[1], "(f(g))", "g")); for (int l = 2; l < term.length; ++l) { rule.append(" * "); rule.append(ordersToString(compiler.getPartialDerivativeOrders(term[l]), "g", "x", "y", "z", "t")); } } Assert.assertEquals(product, referenceRules.get(product), rule.toString()); } } } } private void checkIndices(int[] indices, int ... expected) { Assert.assertEquals(expected.length, indices.length); for (int i = 0; i < expected.length; ++i) { Assert.assertEquals(expected[i], indices[i]); } } private String orderToString(int order, String functionName, String parameterName) { if (order == 0) { return functionName; } else if (order == 1) { return "d" + functionName + "/d" + parameterName; } else { return "d" + order + functionName + "/d" + parameterName + order; } } private String ordersToString(int[] orders, String functionName, String ... parametersNames) { int sumOrders = 0; for (int order : orders) { sumOrders += order; } if (sumOrders == 0) { return functionName; } StringBuilder builder = new StringBuilder(); builder.append('d'); if (sumOrders > 1) { builder.append(sumOrders); } builder.append(functionName).append('/'); for (int i = 0; i < orders.length; ++i) { if (orders[i] > 0) { builder.append('d').append(parametersNames[i]); if (orders[i] > 1) { builder.append(orders[i]); } } } return builder.toString(); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.differentiation; import java.util.Arrays; import java.util.List; import org.apache.commons.math3.ExtendedFieldElementAbstractTest; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.analysis.polynomials.PolynomialFunction; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.NumberIsTooLargeException; import org.apache.commons.math3.random.Well1024a; import org.apache.commons.math3.util.ArithmeticUtils; import org.apache.commons.math3.util.CombinatoricsUtils; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * Test for class {@link DerivativeStructure}. */ public class DerivativeStructureTest extends ExtendedFieldElementAbstractTest<DerivativeStructure> { @Override protected DerivativeStructure build(final double x) { return new DerivativeStructure(2, 1, 0, x); } @Test(expected=NumberIsTooLargeException.class) public void testWrongVariableIndex() { new DerivativeStructure(3, 1, 3, 1.0); } @Test(expected=DimensionMismatchException.class) public void testMissingOrders() { new DerivativeStructure(3, 1, 0, 1.0).getPartialDerivative(0, 1); } @Test(expected=NumberIsTooLargeException.class) public void testTooLargeOrder() { new DerivativeStructure(3, 1, 0, 1.0).getPartialDerivative(1, 1, 2); } @Test public void testVariableWithoutDerivative0() { DerivativeStructure v = new DerivativeStructure(1, 0, 0, 1.0); Assert.assertEquals(1.0, v.getValue(), 1.0e-15); } @Test(expected=NumberIsTooLargeException.class) public void testVariableWithoutDerivative1() { DerivativeStructure v = new DerivativeStructure(1, 0, 0, 1.0); Assert.assertEquals(1.0, v.getPartialDerivative(1), 1.0e-15); } @Test public void testVariable() { for (int maxOrder = 1; maxOrder < 5; ++maxOrder) { checkF0F1(new DerivativeStructure(3, maxOrder, 0, 1.0), 1.0, 1.0, 0.0, 0.0); checkF0F1(new DerivativeStructure(3, maxOrder, 1, 2.0), 2.0, 0.0, 1.0, 0.0); checkF0F1(new DerivativeStructure(3, maxOrder, 2, 3.0), 3.0, 0.0, 0.0, 1.0); } } @Test public void testConstant() { for (int maxOrder = 1; maxOrder < 5; ++maxOrder) { checkF0F1(new DerivativeStructure(3, maxOrder, FastMath.PI), FastMath.PI, 0.0, 0.0, 0.0); } } @Test public void testCreateConstant() { DerivativeStructure a = new DerivativeStructure(3, 2, 0, 1.3); DerivativeStructure b = a.createConstant(2.5); Assert.assertEquals(a.getFreeParameters(), b.getFreeParameters()); Assert.assertEquals(a.getOrder(), b.getOrder()); checkEquals(a.getField().getOne().multiply(2.5), b, 1.0e-15); } @Test public void testPrimitiveAdd() { for (int maxOrder = 1; maxOrder < 5; ++maxOrder) { checkF0F1(new DerivativeStructure(3, maxOrder, 0, 1.0).add(5), 6.0, 1.0, 0.0, 0.0); checkF0F1(new DerivativeStructure(3, maxOrder, 1, 2.0).add(5), 7.0, 0.0, 1.0, 0.0); checkF0F1(new DerivativeStructure(3, maxOrder, 2, 3.0).add(5), 8.0, 0.0, 0.0, 1.0); } } @Test public void testAdd() { for (int maxOrder = 1; maxOrder < 5; ++maxOrder) { DerivativeStructure x = new DerivativeStructure(3, maxOrder, 0, 1.0); DerivativeStructure y = new DerivativeStructure(3, maxOrder, 1, 2.0); DerivativeStructure z = new DerivativeStructure(3, maxOrder, 2, 3.0); DerivativeStructure xyz = x.add(y.add(z)); checkF0F1(xyz, x.getValue() + y.getValue() + z.getValue(), 1.0, 1.0, 1.0); } } @Test public void testPrimitiveSubtract() { for (int maxOrder = 1; maxOrder < 5; ++maxOrder) { checkF0F1(new DerivativeStructure(3, maxOrder, 0, 1.0).subtract(5), -4.0, 1.0, 0.0, 0.0); checkF0F1(new DerivativeStructure(3, maxOrder, 1, 2.0).subtract(5), -3.0, 0.0, 1.0, 0.0); checkF0F1(new DerivativeStructure(3, maxOrder, 2, 3.0).subtract(5), -2.0, 0.0, 0.0, 1.0); } } @Test public void testSubtract() { for (int maxOrder = 1; maxOrder < 5; ++maxOrder) { DerivativeStructure x = new DerivativeStructure(3, maxOrder, 0, 1.0); DerivativeStructure y = new DerivativeStructure(3, maxOrder, 1, 2.0); DerivativeStructure z = new DerivativeStructure(3, maxOrder, 2, 3.0); DerivativeStructure xyz = x.subtract(y.subtract(z)); checkF0F1(xyz, x.getValue() - (y.getValue() - z.getValue()), 1.0, -1.0, 1.0); } } @Test public void testPrimitiveMultiply() { for (int maxOrder = 1; maxOrder < 5; ++maxOrder) { checkF0F1(new DerivativeStructure(3, maxOrder, 0, 1.0).multiply(5), 5.0, 5.0, 0.0, 0.0); checkF0F1(new DerivativeStructure(3, maxOrder, 1, 2.0).multiply(5), 10.0, 0.0, 5.0, 0.0); checkF0F1(new DerivativeStructure(3, maxOrder, 2, 3.0).multiply(5), 15.0, 0.0, 0.0, 5.0); } } @Test public void testMultiply() { for (int maxOrder = 1; maxOrder < 5; ++maxOrder) { DerivativeStructure x = new DerivativeStructure(3, maxOrder, 0, 1.0); DerivativeStructure y = new DerivativeStructure(3, maxOrder, 1, 2.0); DerivativeStructure z = new DerivativeStructure(3, maxOrder, 2, 3.0); DerivativeStructure xyz = x.multiply(y.multiply(z)); for (int i = 0; i <= maxOrder; ++i) { for (int j = 0; j <= maxOrder; ++j) { for (int k = 0; k <= maxOrder; ++k) { if (i + j + k <= maxOrder) { Assert.assertEquals((i == 0 ? x.getValue() : (i == 1 ? 1.0 : 0.0)) * (j == 0 ? y.getValue() : (j == 1 ? 1.0 : 0.0)) * (k == 0 ? z.getValue() : (k == 1 ? 1.0 : 0.0)), xyz.getPartialDerivative(i, j, k), 1.0e-15); } } } } } } @Test public void testNegate() { for (int maxOrder = 1; maxOrder < 5; ++maxOrder) { checkF0F1(new DerivativeStructure(3, maxOrder, 0, 1.0).negate(), -1.0, -1.0, 0.0, 0.0); checkF0F1(new DerivativeStructure(3, maxOrder, 1, 2.0).negate(), -2.0, 0.0, -1.0, 0.0); checkF0F1(new DerivativeStructure(3, maxOrder, 2, 3.0).negate(), -3.0, 0.0, 0.0, -1.0); } } @Test public void testReciprocal() { for (double x = 0.1; x < 1.2; x += 0.1) { DerivativeStructure r = new DerivativeStructure(1, 6, 0, x).reciprocal(); Assert.assertEquals(1 / x, r.getValue(), 1.0e-15); for (int i = 1; i < r.getOrder(); ++i) { double expected = ArithmeticUtils.pow(-1, i) * CombinatoricsUtils.factorial(i) / FastMath.pow(x, i + 1); Assert.assertEquals(expected, r.getPartialDerivative(i), 1.0e-15 * FastMath.abs(expected)); } } } @Test public void testPow() { for (int maxOrder = 1; maxOrder < 5; ++maxOrder) { for (int n = 0; n < 10; ++n) { DerivativeStructure x = new DerivativeStructure(3, maxOrder, 0, 1.0); DerivativeStructure y = new DerivativeStructure(3, maxOrder, 1, 2.0); DerivativeStructure z = new DerivativeStructure(3, maxOrder, 2, 3.0); List<DerivativeStructure> list = Arrays.asList(x, y, z, x.add(y).add(z), x.multiply(y).multiply(z)); if (n == 0) { for (DerivativeStructure ds : list) { checkEquals(ds.getField().getOne(), ds.pow(n), 1.0e-15); } } else if (n == 1) { for (DerivativeStructure ds : list) { checkEquals(ds, ds.pow(n), 1.0e-15); } } else { for (DerivativeStructure ds : list) { DerivativeStructure p = ds.getField().getOne(); for (int i = 0; i < n; ++i) { p = p.multiply(ds); } checkEquals(p, ds.pow(n), 1.0e-15); } } } } } @Test public void testPowDoubleDS() { for (int maxOrder = 1; maxOrder < 5; ++maxOrder) { DerivativeStructure x = new DerivativeStructure(3, maxOrder, 0, 0.1); DerivativeStructure y = new DerivativeStructure(3, maxOrder, 1, 0.2); DerivativeStructure z = new DerivativeStructure(3, maxOrder, 2, 0.3); List<DerivativeStructure> list = Arrays.asList(x, y, z, x.add(y).add(z), x.multiply(y).multiply(z)); for (DerivativeStructure ds : list) { // the special case a = 0 is included here for (double a : new double[] { 0.0, 0.1, 1.0, 2.0, 5.0 }) { DerivativeStructure reference = (a == 0) ? x.getField().getZero() : new DerivativeStructure(3, maxOrder, a).pow(ds); DerivativeStructure result = DerivativeStructure.pow(a, ds); checkEquals(reference, result, 1.0e-15); } } // negative base: -1^x can be evaluated for integers only, so value is sometimes OK, derivatives are always NaN DerivativeStructure negEvenInteger = DerivativeStructure.pow(-2.0, new DerivativeStructure(3, maxOrder, 0, 2.0)); Assert.assertEquals(4.0, negEvenInteger.getValue(), 1.0e-15); Assert.assertTrue(Double.isNaN(negEvenInteger.getPartialDerivative(1, 0, 0))); DerivativeStructure negOddInteger = DerivativeStructure.pow(-2.0, new DerivativeStructure(3, maxOrder, 0, 3.0)); Assert.assertEquals(-8.0, negOddInteger.getValue(), 1.0e-15); Assert.assertTrue(Double.isNaN(negOddInteger.getPartialDerivative(1, 0, 0))); DerivativeStructure negNonInteger = DerivativeStructure.pow(-2.0, new DerivativeStructure(3, maxOrder, 0, 2.001)); Assert.assertTrue(Double.isNaN(negNonInteger.getValue())); Assert.assertTrue(Double.isNaN(negNonInteger.getPartialDerivative(1, 0, 0))); DerivativeStructure zeroNeg = DerivativeStructure.pow(0.0, new DerivativeStructure(3, maxOrder, 0, -1.0)); Assert.assertTrue(Double.isNaN(zeroNeg.getValue())); Assert.assertTrue(Double.isNaN(zeroNeg.getPartialDerivative(1, 0, 0))); DerivativeStructure posNeg = DerivativeStructure.pow(2.0, new DerivativeStructure(3, maxOrder, 0, -2.0)); Assert.assertEquals(1.0 / 4.0, posNeg.getValue(), 1.0e-15); Assert.assertEquals(FastMath.log(2.0) / 4.0, posNeg.getPartialDerivative(1, 0, 0), 1.0e-15); // very special case: a = 0 and power = 0 DerivativeStructure zeroZero = DerivativeStructure.pow(0.0, new DerivativeStructure(3, maxOrder, 0, 0.0)); // this should be OK for simple first derivative with one variable only ... Assert.assertEquals(1.0, zeroZero.getValue(), 1.0e-15); Assert.assertEquals(Double.NEGATIVE_INFINITY, zeroZero.getPartialDerivative(1, 0, 0), 1.0e-15); // the following checks show a LIMITATION of the current implementation // we have no way to tell x is a pure linear variable x = 0 // we only say: "x is a structure with value = 0.0, // first derivative with respect to x = 1.0, and all other derivatives // (first order with respect to y and z and higher derivatives) all 0.0. // Wa have function f(x) = a^x root and x = 0 so we compute: // f(0) = 1, f'(0) = ln(a), f''(0) = ln(a)^2. The limit of these values // when a converges to 0 implies all derivatives keep switching between // +infinity and -infinity. // // Function composition rule for first derivatives is: // d[f(g(x,y,z))]/dy = f'(g(x,y,z)) * dg(x,y,z)/dy // so given that in our case x represents g and does not depend // on y or z, we have dg(x,y,z)/dy = 0 // applying the composition rules gives: // d[f(g(x,y,z))]/dy = f'(g(x,y,z)) * dg(x,y,z)/dy // = -infinity * 0 // = NaN // if we knew x is really the x variable and not the identity // function applied to x, we would not have computed f'(g(x,y,z)) * dg(x,y,z)/dy // and we would have found that the result was 0 and not NaN Assert.assertTrue(Double.isNaN(zeroZero.getPartialDerivative(0, 1, 0))); Assert.assertTrue(Double.isNaN(zeroZero.getPartialDerivative(0, 0, 1))); // Function composition rule for second derivatives is: // d2[f(g(x))]/dx2 = f''(g(x)) * [g'(x)]^2 + f'(g(x)) * g''(x) // when function f is the a^x root and x = 0 we have: // f(0) = 1, f'(0) = ln(a), f''(0) = ln(a)^2 which for a = 0 implies // all derivatives keep switching between +infinity and -infinity // so given that in our case x represents g, we have g(x) = 0, // g'(x) = 1 and g''(x) = 0 // applying the composition rules gives: // d2[f(g(x))]/dx2 = f''(g(x)) * [g'(x)]^2 + f'(g(x)) * g''(x) // = +infinity * 1^2 + -infinity * 0 // = +infinity + NaN // = NaN // if we knew x is really the x variable and not the identity // function applied to x, we would not have computed f'(g(x)) * g''(x) // and we would have found that the result was +infinity and not NaN if (maxOrder > 1) { Assert.assertTrue(Double.isNaN(zeroZero.getPartialDerivative(2, 0, 0))); Assert.assertTrue(Double.isNaN(zeroZero.getPartialDerivative(0, 2, 0))); Assert.assertTrue(Double.isNaN(zeroZero.getPartialDerivative(0, 0, 2))); Assert.assertTrue(Double.isNaN(zeroZero.getPartialDerivative(1, 1, 0))); Assert.assertTrue(Double.isNaN(zeroZero.getPartialDerivative(0, 1, 1))); Assert.assertTrue(Double.isNaN(zeroZero.getPartialDerivative(1, 1, 0))); } } } @Test public void testExpression() { double epsilon = 2.5e-13; for (double x = 0; x < 2; x += 0.2) { DerivativeStructure dsX = new DerivativeStructure(3, 5, 0, x); for (double y = 0; y < 2; y += 0.2) { DerivativeStructure dsY = new DerivativeStructure(3, 5, 1, y); for (double z = 0; z >- 2; z -= 0.2) { DerivativeStructure dsZ = new DerivativeStructure(3, 5, 2, z); // f(x, y, z) = x + 5 x y - 2 z + (8 z x - y)^3 DerivativeStructure ds = new DerivativeStructure(1, dsX, 5, dsX.multiply(dsY), -2, dsZ, 1, new DerivativeStructure(8, dsZ.multiply(dsX), -1, dsY).pow(3)); DerivativeStructure dsOther = new DerivativeStructure(1, dsX, 5, dsX.multiply(dsY), -2, dsZ).add(new DerivativeStructure(8, dsZ.multiply(dsX), -1, dsY).pow(3)); double f = x + 5 * x * y - 2 * z + FastMath.pow(8 * z * x - y, 3); Assert.assertEquals(f, ds.getValue(), FastMath.abs(epsilon * f)); Assert.assertEquals(f, dsOther.getValue(), FastMath.abs(epsilon * f)); // df/dx = 1 + 5 y + 24 (8 z x - y)^2 z double dfdx = 1 + 5 * y + 24 * z * FastMath.pow(8 * z * x - y, 2); Assert.assertEquals(dfdx, ds.getPartialDerivative(1, 0, 0), FastMath.abs(epsilon * dfdx)); Assert.assertEquals(dfdx, dsOther.getPartialDerivative(1, 0, 0), FastMath.abs(epsilon * dfdx)); // df/dxdy = 5 + 48 z*(y - 8 z x) double dfdxdy = 5 + 48 * z * (y - 8 * z * x); Assert.assertEquals(dfdxdy, ds.getPartialDerivative(1, 1, 0), FastMath.abs(epsilon * dfdxdy)); Assert.assertEquals(dfdxdy, dsOther.getPartialDerivative(1, 1, 0), FastMath.abs(epsilon * dfdxdy)); // df/dxdydz = 48 (y - 16 z x) double dfdxdydz = 48 * (y - 16 * z * x); Assert.assertEquals(dfdxdydz, ds.getPartialDerivative(1, 1, 1), FastMath.abs(epsilon * dfdxdydz)); Assert.assertEquals(dfdxdydz, dsOther.getPartialDerivative(1, 1, 1), FastMath.abs(epsilon * dfdxdydz)); } } } } @Test public void testCompositionOneVariableX() { double epsilon = 1.0e-13; for (int maxOrder = 0; maxOrder < 5; ++maxOrder) { for (double x = 0.1; x < 1.2; x += 0.1) { DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x); for (double y = 0.1; y < 1.2; y += 0.1) { DerivativeStructure dsY = new DerivativeStructure(1, maxOrder, y); DerivativeStructure f = dsX.divide(dsY).sqrt(); double f0 = FastMath.sqrt(x / y); Assert.assertEquals(f0, f.getValue(), FastMath.abs(epsilon * f0)); if (f.getOrder() > 0) { double f1 = 1 / (2 * FastMath.sqrt(x * y)); Assert.assertEquals(f1, f.getPartialDerivative(1), FastMath.abs(epsilon * f1)); if (f.getOrder() > 1) { double f2 = -f1 / (2 * x); Assert.assertEquals(f2, f.getPartialDerivative(2), FastMath.abs(epsilon * f2)); if (f.getOrder() > 2) { double f3 = (f0 + x / (2 * y * f0)) / (4 * x * x * x); Assert.assertEquals(f3, f.getPartialDerivative(3), FastMath.abs(epsilon * f3)); } } } } } } } @Test public void testTrigo() { double epsilon = 2.0e-12; for (int maxOrder = 0; maxOrder < 5; ++maxOrder) { for (double x = 0.1; x < 1.2; x += 0.1) { DerivativeStructure dsX = new DerivativeStructure(3, maxOrder, 0, x); for (double y = 0.1; y < 1.2; y += 0.1) { DerivativeStructure dsY = new DerivativeStructure(3, maxOrder, 1, y); for (double z = 0.1; z < 1.2; z += 0.1) { DerivativeStructure dsZ = new DerivativeStructure(3, maxOrder, 2, z); DerivativeStructure f = dsX.divide(dsY.cos().add(dsZ.tan())).sin(); double a = FastMath.cos(y) + FastMath.tan(z); double f0 = FastMath.sin(x / a); Assert.assertEquals(f0, f.getValue(), FastMath.abs(epsilon * f0)); if (f.getOrder() > 0) { double dfdx = FastMath.cos(x / a) / a; Assert.assertEquals(dfdx, f.getPartialDerivative(1, 0, 0), FastMath.abs(epsilon * dfdx)); double dfdy = x * FastMath.sin(y) * dfdx / a; Assert.assertEquals(dfdy, f.getPartialDerivative(0, 1, 0), FastMath.abs(epsilon * dfdy)); double cz = FastMath.cos(z); double cz2 = cz * cz; double dfdz = -x * dfdx / (a * cz2); Assert.assertEquals(dfdz, f.getPartialDerivative(0, 0, 1), FastMath.abs(epsilon * dfdz)); if (f.getOrder() > 1) { double df2dx2 = -(f0 / (a * a)); Assert.assertEquals(df2dx2, f.getPartialDerivative(2, 0, 0), FastMath.abs(epsilon * df2dx2)); double df2dy2 = x * FastMath.cos(y) * dfdx / a - x * x * FastMath.sin(y) * FastMath.sin(y) * f0 / (a * a * a * a) + 2 * FastMath.sin(y) * dfdy / a; Assert.assertEquals(df2dy2, f.getPartialDerivative(0, 2, 0), FastMath.abs(epsilon * df2dy2)); double c4 = cz2 * cz2; double df2dz2 = x * (2 * a * (1 - a * cz * FastMath.sin(z)) * dfdx - x * f0 / a ) / (a * a * a * c4); Assert.assertEquals(df2dz2, f.getPartialDerivative(0, 0, 2), FastMath.abs(epsilon * df2dz2)); double df2dxdy = dfdy / x - x * FastMath.sin(y) * f0 / (a * a * a); Assert.assertEquals(df2dxdy, f.getPartialDerivative(1, 1, 0), FastMath.abs(epsilon * df2dxdy)); } } } } } } } @Test public void testSqrtDefinition() { double[] epsilon = new double[] { 5.0e-16, 5.0e-16, 2.0e-15, 5.0e-14, 2.0e-12 }; for (int maxOrder = 0; maxOrder < 5; ++maxOrder) { for (double x = 0.1; x < 1.2; x += 0.001) { DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x); DerivativeStructure sqrt1 = dsX.pow(0.5); DerivativeStructure sqrt2 = dsX.sqrt(); DerivativeStructure zero = sqrt1.subtract(sqrt2); for (int n = 0; n <= maxOrder; ++n) { Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon[n]); } } } } @Test public void testRootNSingularity() { for (int n = 2; n < 10; ++n) { for (int maxOrder = 0; maxOrder < 12; ++maxOrder) { DerivativeStructure dsZero = new DerivativeStructure(1, maxOrder, 0, 0.0); DerivativeStructure rootN = dsZero.rootN(n); Assert.assertEquals(0.0, rootN.getValue(), 1.0e-20); if (maxOrder > 0) { Assert.assertTrue(Double.isInfinite(rootN.getPartialDerivative(1))); Assert.assertTrue(rootN.getPartialDerivative(1) > 0); for (int order = 2; order <= maxOrder; ++order) { // the following checks shows a LIMITATION of the current implementation // we have no way to tell dsZero is a pure linear variable x = 0 // we only say: "dsZero is a structure with value = 0.0, // first derivative = 1.0, second and higher derivatives = 0.0". // Function composition rule for second derivatives is: // d2[f(g(x))]/dx2 = f''(g(x)) * [g'(x)]^2 + f'(g(x)) * g''(x) // when function f is the nth root and x = 0 we have: // f(0) = 0, f'(0) = +infinity, f''(0) = -infinity (and higher // derivatives keep switching between +infinity and -infinity) // so given that in our case dsZero represents g, we have g(x) = 0, // g'(x) = 1 and g''(x) = 0 // applying the composition rules gives: // d2[f(g(x))]/dx2 = f''(g(x)) * [g'(x)]^2 + f'(g(x)) * g''(x) // = -infinity * 1^2 + +infinity * 0 // = -infinity + NaN // = NaN // if we knew dsZero is really the x variable and not the identity // function applied to x, we would not have computed f'(g(x)) * g''(x) // and we would have found that the result was -infinity and not NaN Assert.assertTrue(Double.isNaN(rootN.getPartialDerivative(order))); } } // the following shows that the limitation explained above is NOT a bug... // if we set up the higher order derivatives for g appropriately, we do // compute the higher order derivatives of the composition correctly double[] gDerivatives = new double[ 1 + maxOrder]; gDerivatives[0] = 0.0; for (int k = 1; k <= maxOrder; ++k) { gDerivatives[k] = FastMath.pow(-1.0, k + 1); } DerivativeStructure correctRoot = new DerivativeStructure(1, maxOrder, gDerivatives).rootN(n); Assert.assertEquals(0.0, correctRoot.getValue(), 1.0e-20); if (maxOrder > 0) { Assert.assertTrue(Double.isInfinite(correctRoot.getPartialDerivative(1))); Assert.assertTrue(correctRoot.getPartialDerivative(1) > 0); for (int order = 2; order <= maxOrder; ++order) { Assert.assertTrue(Double.isInfinite(correctRoot.getPartialDerivative(order))); if ((order % 2) == 0) { Assert.assertTrue(correctRoot.getPartialDerivative(order) < 0); } else { Assert.assertTrue(correctRoot.getPartialDerivative(order) > 0); } } } } } } @Test public void testSqrtPow2() { double[] epsilon = new double[] { 1.0e-16, 3.0e-16, 2.0e-15, 6.0e-14, 6.0e-12 }; for (int maxOrder = 0; maxOrder < 5; ++maxOrder) { for (double x = 0.1; x < 1.2; x += 0.001) { DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x); DerivativeStructure rebuiltX = dsX.multiply(dsX).sqrt(); DerivativeStructure zero = rebuiltX.subtract(dsX); for (int n = 0; n <= maxOrder; ++n) { Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]); } } } } @Test public void testCbrtDefinition() { double[] epsilon = new double[] { 4.0e-16, 9.0e-16, 6.0e-15, 2.0e-13, 4.0e-12 }; for (int maxOrder = 0; maxOrder < 5; ++maxOrder) { for (double x = 0.1; x < 1.2; x += 0.001) { DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x); DerivativeStructure cbrt1 = dsX.pow(1.0 / 3.0); DerivativeStructure cbrt2 = dsX.cbrt(); DerivativeStructure zero = cbrt1.subtract(cbrt2); for (int n = 0; n <= maxOrder; ++n) { Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon[n]); } } } } @Test public void testCbrtPow3() { double[] epsilon = new double[] { 1.0e-16, 5.0e-16, 8.0e-15, 3.0e-13, 4.0e-11 }; for (int maxOrder = 0; maxOrder < 5; ++maxOrder) { for (double x = 0.1; x < 1.2; x += 0.001) { DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x); DerivativeStructure rebuiltX = dsX.multiply(dsX.multiply(dsX)).cbrt(); DerivativeStructure zero = rebuiltX.subtract(dsX); for (int n = 0; n <= maxOrder; ++n) { Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]); } } } } @Test public void testPowReciprocalPow() { double[] epsilon = new double[] { 2.0e-15, 2.0e-14, 3.0e-13, 8.0e-12, 3.0e-10 }; for (int maxOrder = 0; maxOrder < 5; ++maxOrder) { for (double x = 0.1; x < 1.2; x += 0.01) { DerivativeStructure dsX = new DerivativeStructure(2, maxOrder, 0, x); for (double y = 0.1; y < 1.2; y += 0.01) { DerivativeStructure dsY = new DerivativeStructure(2, maxOrder, 1, y); DerivativeStructure rebuiltX = dsX.pow(dsY).pow(dsY.reciprocal()); DerivativeStructure zero = rebuiltX.subtract(dsX); for (int n = 0; n <= maxOrder; ++n) { for (int m = 0; m <= maxOrder; ++m) { if (n + m <= maxOrder) { Assert.assertEquals(0.0, zero.getPartialDerivative(n, m), epsilon[n + m]); } } } } } } } @Test public void testHypotDefinition() { double epsilon = 1.0e-20; for (int maxOrder = 0; maxOrder < 5; ++maxOrder) { for (double x = -1.7; x < 2; x += 0.2) { DerivativeStructure dsX = new DerivativeStructure(2, maxOrder, 0, x); for (double y = -1.7; y < 2; y += 0.2) { DerivativeStructure dsY = new DerivativeStructure(2, maxOrder, 1, y); DerivativeStructure hypot = DerivativeStructure.hypot(dsY, dsX); DerivativeStructure ref = dsX.multiply(dsX).add(dsY.multiply(dsY)).sqrt(); DerivativeStructure zero = hypot.subtract(ref); for (int n = 0; n <= maxOrder; ++n) { for (int m = 0; m <= maxOrder; ++m) { if (n + m <= maxOrder) { Assert.assertEquals(0, zero.getPartialDerivative(n, m), epsilon); } } } } } } } @Test public void testHypotNoOverflow() { DerivativeStructure dsX = new DerivativeStructure(2, 5, 0, +3.0e250); DerivativeStructure dsY = new DerivativeStructure(2, 5, 1, -4.0e250); DerivativeStructure hypot = DerivativeStructure.hypot(dsX, dsY); Assert.assertEquals(5.0e250, hypot.getValue(), 1.0e235); Assert.assertEquals(dsX.getValue() / hypot.getValue(), hypot.getPartialDerivative(1, 0), 1.0e-10); Assert.assertEquals(dsY.getValue() / hypot.getValue(), hypot.getPartialDerivative(0, 1), 1.0e-10); DerivativeStructure sqrt = dsX.multiply(dsX).add(dsY.multiply(dsY)).sqrt(); Assert.assertTrue(Double.isInfinite(sqrt.getValue())); } @Test public void testHypotNeglectible() { DerivativeStructure dsSmall = new DerivativeStructure(2, 5, 0, +3.0e-10); DerivativeStructure dsLarge = new DerivativeStructure(2, 5, 1, -4.0e25); Assert.assertEquals(dsLarge.abs().getValue(), DerivativeStructure.hypot(dsSmall, dsLarge).getValue(), 1.0e-10); Assert.assertEquals(0, DerivativeStructure.hypot(dsSmall, dsLarge).getPartialDerivative(1, 0), 1.0e-10); Assert.assertEquals(-1, DerivativeStructure.hypot(dsSmall, dsLarge).getPartialDerivative(0, 1), 1.0e-10); Assert.assertEquals(dsLarge.abs().getValue(), DerivativeStructure.hypot(dsLarge, dsSmall).getValue(), 1.0e-10); Assert.assertEquals(0, DerivativeStructure.hypot(dsLarge, dsSmall).getPartialDerivative(1, 0), 1.0e-10); Assert.assertEquals(-1, DerivativeStructure.hypot(dsLarge, dsSmall).getPartialDerivative(0, 1), 1.0e-10); } @Test public void testHypotSpecial() { Assert.assertTrue(Double.isNaN(DerivativeStructure.hypot(new DerivativeStructure(2, 5, 0, Double.NaN), new DerivativeStructure(2, 5, 0, +3.0e250)).getValue())); Assert.assertTrue(Double.isNaN(DerivativeStructure.hypot(new DerivativeStructure(2, 5, 0, +3.0e250), new DerivativeStructure(2, 5, 0, Double.NaN)).getValue())); Assert.assertTrue(Double.isInfinite(DerivativeStructure.hypot(new DerivativeStructure(2, 5, 0, Double.POSITIVE_INFINITY), new DerivativeStructure(2, 5, 0, +3.0e250)).getValue())); Assert.assertTrue(Double.isInfinite(DerivativeStructure.hypot(new DerivativeStructure(2, 5, 0, +3.0e250), new DerivativeStructure(2, 5, 0, Double.POSITIVE_INFINITY)).getValue())); } @Test public void testPrimitiveRemainder() { double epsilon = 1.0e-15; for (int maxOrder = 0; maxOrder < 5; ++maxOrder) { for (double x = -1.7; x < 2; x += 0.2) { DerivativeStructure dsX = new DerivativeStructure(2, maxOrder, 0, x); for (double y = -1.7; y < 2; y += 0.2) { DerivativeStructure remainder = dsX.remainder(y); DerivativeStructure ref = dsX.subtract(x - FastMath.IEEEremainder(x, y)); DerivativeStructure zero = remainder.subtract(ref); for (int n = 0; n <= maxOrder; ++n) { for (int m = 0; m <= maxOrder; ++m) { if (n + m <= maxOrder) { Assert.assertEquals(0, zero.getPartialDerivative(n, m), epsilon); } } } } } } } @Test public void testRemainder() { double epsilon = 2.0e-15; for (int maxOrder = 0; maxOrder < 5; ++maxOrder) { for (double x = -1.7; x < 2; x += 0.2) { DerivativeStructure dsX = new DerivativeStructure(2, maxOrder, 0, x); for (double y = -1.7; y < 2; y += 0.2) { DerivativeStructure dsY = new DerivativeStructure(2, maxOrder, 1, y); DerivativeStructure remainder = dsX.remainder(dsY); DerivativeStructure ref = dsX.subtract(dsY.multiply((x - FastMath.IEEEremainder(x, y)) / y)); DerivativeStructure zero = remainder.subtract(ref); for (int n = 0; n <= maxOrder; ++n) { for (int m = 0; m <= maxOrder; ++m) { if (n + m <= maxOrder) { Assert.assertEquals(0, zero.getPartialDerivative(n, m), epsilon); } } } } } } } @Override @Test public void testExp() { double[] epsilon = new double[] { 1.0e-16, 1.0e-16, 1.0e-16, 1.0e-16, 1.0e-16 }; for (int maxOrder = 0; maxOrder < 5; ++maxOrder) { for (double x = 0.1; x < 1.2; x += 0.001) { double refExp = FastMath.exp(x); DerivativeStructure exp = new DerivativeStructure(1, maxOrder, 0, x).exp(); for (int n = 0; n <= maxOrder; ++n) { Assert.assertEquals(refExp, exp.getPartialDerivative(n), epsilon[n]); } } } } @Test public void testExpm1Definition() { double epsilon = 3.0e-16; for (int maxOrder = 0; maxOrder < 5; ++maxOrder) { for (double x = 0.1; x < 1.2; x += 0.001) { DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x); DerivativeStructure expm11 = dsX.expm1(); DerivativeStructure expm12 = dsX.exp().subtract(dsX.getField().getOne()); DerivativeStructure zero = expm11.subtract(expm12); for (int n = 0; n <= maxOrder; ++n) { Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon); } } } } @Override @Test public void testLog() { double[] epsilon = new double[] { 1.0e-16, 1.0e-16, 3.0e-14, 7.0e-13, 3.0e-11 }; for (int maxOrder = 0; maxOrder < 5; ++maxOrder) { for (double x = 0.1; x < 1.2; x += 0.001) { DerivativeStructure log = new DerivativeStructure(1, maxOrder, 0, x).log(); Assert.assertEquals(FastMath.log(x), log.getValue(), epsilon[0]); for (int n = 1; n <= maxOrder; ++n) { double refDer = -CombinatoricsUtils.factorial(n - 1) / FastMath.pow(-x, n); Assert.assertEquals(refDer, log.getPartialDerivative(n), epsilon[n]); } } } } @Test public void testLog1pDefinition() { double epsilon = 3.0e-16; for (int maxOrder = 0; maxOrder < 5; ++maxOrder) { for (double x = 0.1; x < 1.2; x += 0.001) { DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x); DerivativeStructure log1p1 = dsX.log1p(); DerivativeStructure log1p2 = dsX.add(dsX.getField().getOne()).log(); DerivativeStructure zero = log1p1.subtract(log1p2); for (int n = 0; n <= maxOrder; ++n) { Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon); } } } } @Test public void testLog10Definition() { double[] epsilon = new double[] { 3.0e-16, 3.0e-16, 8.0e-15, 3.0e-13, 8.0e-12 }; for (int maxOrder = 0; maxOrder < 5; ++maxOrder) { for (double x = 0.1; x < 1.2; x += 0.001) { DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x); DerivativeStructure log101 = dsX.log10(); DerivativeStructure log102 = dsX.log().divide(FastMath.log(10.0)); DerivativeStructure zero = log101.subtract(log102); for (int n = 0; n <= maxOrder; ++n) { Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon[n]); } } } } @Test public void testLogExp() { double[] epsilon = new double[] { 2.0e-16, 2.0e-16, 3.0e-16, 2.0e-15, 6.0e-15 }; for (int maxOrder = 0; maxOrder < 5; ++maxOrder) { for (double x = 0.1; x < 1.2; x += 0.001) { DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x); DerivativeStructure rebuiltX = dsX.exp().log(); DerivativeStructure zero = rebuiltX.subtract(dsX); for (int n = 0; n <= maxOrder; ++n) { Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]); } } } } @Test public void testLog1pExpm1() { double[] epsilon = new double[] { 6.0e-17, 3.0e-16, 5.0e-16, 9.0e-16, 6.0e-15 }; for (int maxOrder = 0; maxOrder < 5; ++maxOrder) { for (double x = 0.1; x < 1.2; x += 0.001) { DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x); DerivativeStructure rebuiltX = dsX.expm1().log1p(); DerivativeStructure zero = rebuiltX.subtract(dsX); for (int n = 0; n <= maxOrder; ++n) { Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]); } } } } @Test public void testLog10Power() { double[] epsilon = new double[] { 3.0e-16, 3.0e-16, 9.0e-16, 6.0e-15, 6.0e-14 }; for (int maxOrder = 0; maxOrder < 5; ++maxOrder) { for (double x = 0.1; x < 1.2; x += 0.001) { DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x); DerivativeStructure rebuiltX = new DerivativeStructure(1, maxOrder, 10.0).pow(dsX).log10(); DerivativeStructure zero = rebuiltX.subtract(dsX); for (int n = 0; n <= maxOrder; ++n) { Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon[n]); } } } } @Test public void testSinCos() { double epsilon = 5.0e-16; for (int maxOrder = 0; maxOrder < 6; ++maxOrder) { for (double x = 0.1; x < 1.2; x += 0.001) { DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x); DerivativeStructure sin = dsX.sin(); DerivativeStructure cos = dsX.cos(); double s = FastMath.sin(x); double c = FastMath.cos(x); for (int n = 0; n <= maxOrder; ++n) { switch (n % 4) { case 0 : Assert.assertEquals( s, sin.getPartialDerivative(n), epsilon); Assert.assertEquals( c, cos.getPartialDerivative(n), epsilon); break; case 1 : Assert.assertEquals( c, sin.getPartialDerivative(n), epsilon); Assert.assertEquals(-s, cos.getPartialDerivative(n), epsilon); break; case 2 : Assert.assertEquals(-s, sin.getPartialDerivative(n), epsilon); Assert.assertEquals(-c, cos.getPartialDerivative(n), epsilon); break; default : Assert.assertEquals(-c, sin.getPartialDerivative(n), epsilon); Assert.assertEquals( s, cos.getPartialDerivative(n), epsilon); break; } } } } } @Test public void testSinAsin() { double[] epsilon = new double[] { 3.0e-16, 5.0e-16, 3.0e-15, 2.0e-14, 4.0e-13 }; for (int maxOrder = 0; maxOrder < 5; ++maxOrder) { for (double x = 0.1; x < 1.2; x += 0.001) { DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x); DerivativeStructure rebuiltX = dsX.sin().asin(); DerivativeStructure zero = rebuiltX.subtract(dsX); for (int n = 0; n <= maxOrder; ++n) { Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]); } } } } @Test public void testCosAcos() { double[] epsilon = new double[] { 6.0e-16, 6.0e-15, 2.0e-13, 4.0e-12, 2.0e-10 }; for (int maxOrder = 0; maxOrder < 5; ++maxOrder) { for (double x = 0.1; x < 1.2; x += 0.001) { DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x); DerivativeStructure rebuiltX = dsX.cos().acos(); DerivativeStructure zero = rebuiltX.subtract(dsX); for (int n = 0; n <= maxOrder; ++n) { Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]); } } } } @Test public void testTanAtan() { double[] epsilon = new double[] { 6.0e-17, 2.0e-16, 2.0e-15, 4.0e-14, 2.0e-12 }; for (int maxOrder = 0; maxOrder < 5; ++maxOrder) { for (double x = 0.1; x < 1.2; x += 0.001) { DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x); DerivativeStructure rebuiltX = dsX.tan().atan(); DerivativeStructure zero = rebuiltX.subtract(dsX); for (int n = 0; n <= maxOrder; ++n) { Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]); } } } } @Test public void testTangentDefinition() { double[] epsilon = new double[] { 5.0e-16, 2.0e-15, 3.0e-14, 5.0e-13, 2.0e-11 }; for (int maxOrder = 0; maxOrder < 5; ++maxOrder) { for (double x = 0.1; x < 1.2; x += 0.001) { DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x); DerivativeStructure tan1 = dsX.sin().divide(dsX.cos()); DerivativeStructure tan2 = dsX.tan(); DerivativeStructure zero = tan1.subtract(tan2); for (int n = 0; n <= maxOrder; ++n) { Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon[n]); } } } } @Override @Test public void testAtan2() { double[] epsilon = new double[] { 5.0e-16, 3.0e-15, 2.2e-14, 1.0e-12, 8.0e-11 }; for (int maxOrder = 0; maxOrder < 5; ++maxOrder) { for (double x = -1.7; x < 2; x += 0.2) { DerivativeStructure dsX = new DerivativeStructure(2, maxOrder, 0, x); for (double y = -1.7; y < 2; y += 0.2) { DerivativeStructure dsY = new DerivativeStructure(2, maxOrder, 1, y); DerivativeStructure atan2 = DerivativeStructure.atan2(dsY, dsX); DerivativeStructure ref = dsY.divide(dsX).atan(); if (x < 0) { ref = (y < 0) ? ref.subtract(FastMath.PI) : ref.add(FastMath.PI); } DerivativeStructure zero = atan2.subtract(ref); for (int n = 0; n <= maxOrder; ++n) { for (int m = 0; m <= maxOrder; ++m) { if (n + m <= maxOrder) { Assert.assertEquals(0, zero.getPartialDerivative(n, m), epsilon[n + m]); } } } } } } } @Test public void testAtan2SpecialCases() { DerivativeStructure pp = DerivativeStructure.atan2(new DerivativeStructure(2, 2, 1, +0.0), new DerivativeStructure(2, 2, 1, +0.0)); Assert.assertEquals(0, pp.getValue(), 1.0e-15); Assert.assertEquals(+1, FastMath.copySign(1, pp.getValue()), 1.0e-15); DerivativeStructure pn = DerivativeStructure.atan2(new DerivativeStructure(2, 2, 1, +0.0), new DerivativeStructure(2, 2, 1, -0.0)); Assert.assertEquals(FastMath.PI, pn.getValue(), 1.0e-15); DerivativeStructure np = DerivativeStructure.atan2(new DerivativeStructure(2, 2, 1, -0.0), new DerivativeStructure(2, 2, 1, +0.0)); Assert.assertEquals(0, np.getValue(), 1.0e-15); Assert.assertEquals(-1, FastMath.copySign(1, np.getValue()), 1.0e-15); DerivativeStructure nn = DerivativeStructure.atan2(new DerivativeStructure(2, 2, 1, -0.0), new DerivativeStructure(2, 2, 1, -0.0)); Assert.assertEquals(-FastMath.PI, nn.getValue(), 1.0e-15); } @Test public void testSinhDefinition() { double[] epsilon = new double[] { 3.0e-16, 3.0e-16, 5.0e-16, 2.0e-15, 6.0e-15 }; for (int maxOrder = 0; maxOrder < 5; ++maxOrder) { for (double x = 0.1; x < 1.2; x += 0.001) { DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x); DerivativeStructure sinh1 = dsX.exp().subtract(dsX.exp().reciprocal()).multiply(0.5); DerivativeStructure sinh2 = dsX.sinh(); DerivativeStructure zero = sinh1.subtract(sinh2); for (int n = 0; n <= maxOrder; ++n) { Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon[n]); } } } } @Test public void testCoshDefinition() { double[] epsilon = new double[] { 3.0e-16, 3.0e-16, 5.0e-16, 2.0e-15, 6.0e-15 }; for (int maxOrder = 0; maxOrder < 5; ++maxOrder) { for (double x = 0.1; x < 1.2; x += 0.001) { DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x); DerivativeStructure cosh1 = dsX.exp().add(dsX.exp().reciprocal()).multiply(0.5); DerivativeStructure cosh2 = dsX.cosh(); DerivativeStructure zero = cosh1.subtract(cosh2); for (int n = 0; n <= maxOrder; ++n) { Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon[n]); } } } } @Test public void testTanhDefinition() { double[] epsilon = new double[] { 3.0e-16, 5.0e-16, 7.0e-16, 3.0e-15, 2.0e-14 }; for (int maxOrder = 0; maxOrder < 5; ++maxOrder) { for (double x = 0.1; x < 1.2; x += 0.001) { DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x); DerivativeStructure tanh1 = dsX.exp().subtract(dsX.exp().reciprocal()).divide(dsX.exp().add(dsX.exp().reciprocal())); DerivativeStructure tanh2 = dsX.tanh(); DerivativeStructure zero = tanh1.subtract(tanh2); for (int n = 0; n <= maxOrder; ++n) { Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon[n]); } } } } @Test public void testSinhAsinh() { double[] epsilon = new double[] { 3.0e-16, 3.0e-16, 4.0e-16, 7.0e-16, 3.0e-15, 8.0e-15 }; for (int maxOrder = 0; maxOrder < 6; ++maxOrder) { for (double x = 0.1; x < 1.2; x += 0.001) { DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x); DerivativeStructure rebuiltX = dsX.sinh().asinh(); DerivativeStructure zero = rebuiltX.subtract(dsX); for (int n = 0; n <= maxOrder; ++n) { Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]); } } } } @Test public void testCoshAcosh() { double[] epsilon = new double[] { 2.0e-15, 1.0e-14, 2.0e-13, 6.0e-12, 3.0e-10, 2.0e-8 }; for (int maxOrder = 0; maxOrder < 6; ++maxOrder) { for (double x = 0.1; x < 1.2; x += 0.001) { DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x); DerivativeStructure rebuiltX = dsX.cosh().acosh(); DerivativeStructure zero = rebuiltX.subtract(dsX); for (int n = 0; n <= maxOrder; ++n) { Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]); } } } } @Test public void testTanhAtanh() { double[] epsilon = new double[] { 3.0e-16, 2.0e-16, 7.0e-16, 4.0e-15, 3.0e-14, 4.0e-13 }; for (int maxOrder = 0; maxOrder < 6; ++maxOrder) { for (double x = 0.1; x < 1.2; x += 0.001) { DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x); DerivativeStructure rebuiltX = dsX.tanh().atanh(); DerivativeStructure zero = rebuiltX.subtract(dsX); for (int n = 0; n <= maxOrder; ++n) { Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]); } } } } @Test public void testCompositionOneVariableY() { double epsilon = 1.0e-13; for (int maxOrder = 0; maxOrder < 5; ++maxOrder) { for (double x = 0.1; x < 1.2; x += 0.1) { DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, x); for (double y = 0.1; y < 1.2; y += 0.1) { DerivativeStructure dsY = new DerivativeStructure(1, maxOrder, 0, y); DerivativeStructure f = dsX.divide(dsY).sqrt(); double f0 = FastMath.sqrt(x / y); Assert.assertEquals(f0, f.getValue(), FastMath.abs(epsilon * f0)); if (f.getOrder() > 0) { double f1 = -x / (2 * y * y * f0); Assert.assertEquals(f1, f.getPartialDerivative(1), FastMath.abs(epsilon * f1)); if (f.getOrder() > 1) { double f2 = (f0 - x / (4 * y * f0)) / (y * y); Assert.assertEquals(f2, f.getPartialDerivative(2), FastMath.abs(epsilon * f2)); if (f.getOrder() > 2) { double f3 = (x / (8 * y * f0) - 2 * f0) / (y * y * y); Assert.assertEquals(f3, f.getPartialDerivative(3), FastMath.abs(epsilon * f3)); } } } } } } } @Test public void testTaylorPolynomial() { for (double x = 0; x < 1.2; x += 0.1) { DerivativeStructure dsX = new DerivativeStructure(3, 4, 0, x); for (double y = 0; y < 1.2; y += 0.2) { DerivativeStructure dsY = new DerivativeStructure(3, 4, 1, y); for (double z = 0; z < 1.2; z += 0.2) { DerivativeStructure dsZ = new DerivativeStructure(3, 4, 2, z); DerivativeStructure f = dsX.multiply(dsY).add(dsZ).multiply(dsX).multiply(dsY); for (double dx = -0.2; dx < 0.2; dx += 0.2) { for (double dy = -0.2; dy < 0.2; dy += 0.1) { for (double dz = -0.2; dz < 0.2; dz += 0.1) { double ref = (x + dx) * (y + dy) * ((x + dx) * (y + dy) + (z + dz)); Assert.assertEquals(ref, f.taylor(dx, dy, dz), 2.0e-15); } } } } } } } @Test public void testTaylorAtan2() { double[] expected = new double[] { 0.214, 0.0241, 0.00422, 6.48e-4, 8.04e-5 }; double x0 = 0.1; double y0 = -0.3; for (int maxOrder = 0; maxOrder < 5; ++maxOrder) { DerivativeStructure dsX = new DerivativeStructure(2, maxOrder, 0, x0); DerivativeStructure dsY = new DerivativeStructure(2, maxOrder, 1, y0); DerivativeStructure atan2 = DerivativeStructure.atan2(dsY, dsX); double maxError = 0; for (double dx = -0.05; dx < 0.05; dx += 0.001) { for (double dy = -0.05; dy < 0.05; dy += 0.001) { double ref = FastMath.atan2(y0 + dy, x0 + dx); maxError = FastMath.max(maxError, FastMath.abs(ref - atan2.taylor(dx, dy))); } } Assert.assertEquals(0.0, expected[maxOrder] - maxError, 0.01 * expected[maxOrder]); } } @Override @Test public void testAbs() { DerivativeStructure minusOne = new DerivativeStructure(1, 1, 0, -1.0); Assert.assertEquals(+1.0, minusOne.abs().getPartialDerivative(0), 1.0e-15); Assert.assertEquals(-1.0, minusOne.abs().getPartialDerivative(1), 1.0e-15); DerivativeStructure plusOne = new DerivativeStructure(1, 1, 0, +1.0); Assert.assertEquals(+1.0, plusOne.abs().getPartialDerivative(0), 1.0e-15); Assert.assertEquals(+1.0, plusOne.abs().getPartialDerivative(1), 1.0e-15); DerivativeStructure minusZero = new DerivativeStructure(1, 1, 0, -0.0); Assert.assertEquals(+0.0, minusZero.abs().getPartialDerivative(0), 1.0e-15); Assert.assertEquals(-1.0, minusZero.abs().getPartialDerivative(1), 1.0e-15); DerivativeStructure plusZero = new DerivativeStructure(1, 1, 0, +0.0); Assert.assertEquals(+0.0, plusZero.abs().getPartialDerivative(0), 1.0e-15); Assert.assertEquals(+1.0, plusZero.abs().getPartialDerivative(1), 1.0e-15); } @Override @Test public void testSignum() { DerivativeStructure minusOne = new DerivativeStructure(1, 1, 0, -1.0); Assert.assertEquals(-1.0, minusOne.signum().getPartialDerivative(0), 1.0e-15); Assert.assertEquals( 0.0, minusOne.signum().getPartialDerivative(1), 1.0e-15); DerivativeStructure plusOne = new DerivativeStructure(1, 1, 0, +1.0); Assert.assertEquals(+1.0, plusOne.signum().getPartialDerivative(0), 1.0e-15); Assert.assertEquals( 0.0, plusOne.signum().getPartialDerivative(1), 1.0e-15); DerivativeStructure minusZero = new DerivativeStructure(1, 1, 0, -0.0); Assert.assertEquals(-0.0, minusZero.signum().getPartialDerivative(0), 1.0e-15); Assert.assertTrue(Double.doubleToLongBits(minusZero.signum().getValue()) < 0); Assert.assertEquals( 0.0, minusZero.signum().getPartialDerivative(1), 1.0e-15); DerivativeStructure plusZero = new DerivativeStructure(1, 1, 0, +0.0); Assert.assertEquals(+0.0, plusZero.signum().getPartialDerivative(0), 1.0e-15); Assert.assertTrue(Double.doubleToLongBits(plusZero.signum().getValue()) == 0); Assert.assertEquals( 0.0, plusZero.signum().getPartialDerivative(1), 1.0e-15); } @Test public void testCeilFloorRintLong() { DerivativeStructure x = new DerivativeStructure(1, 1, 0, -1.5); Assert.assertEquals(-1.5, x.getPartialDerivative(0), 1.0e-15); Assert.assertEquals(+1.0, x.getPartialDerivative(1), 1.0e-15); Assert.assertEquals(-1.0, x.ceil().getPartialDerivative(0), 1.0e-15); Assert.assertEquals(+0.0, x.ceil().getPartialDerivative(1), 1.0e-15); Assert.assertEquals(-2.0, x.floor().getPartialDerivative(0), 1.0e-15); Assert.assertEquals(+0.0, x.floor().getPartialDerivative(1), 1.0e-15); Assert.assertEquals(-2.0, x.rint().getPartialDerivative(0), 1.0e-15); Assert.assertEquals(+0.0, x.rint().getPartialDerivative(1), 1.0e-15); Assert.assertEquals(-2.0, x.subtract(x.getField().getOne()).rint().getPartialDerivative(0), 1.0e-15); Assert.assertEquals(-1l, x.round()); } @Test public void testCopySign() { DerivativeStructure minusOne = new DerivativeStructure(1, 1, 0, -1.0); Assert.assertEquals(+1.0, minusOne.copySign(+1.0).getPartialDerivative(0), 1.0e-15); Assert.assertEquals(-1.0, minusOne.copySign(+1.0).getPartialDerivative(1), 1.0e-15); Assert.assertEquals(-1.0, minusOne.copySign(-1.0).getPartialDerivative(0), 1.0e-15); Assert.assertEquals(+1.0, minusOne.copySign(-1.0).getPartialDerivative(1), 1.0e-15); Assert.assertEquals(+1.0, minusOne.copySign(+0.0).getPartialDerivative(0), 1.0e-15); Assert.assertEquals(-1.0, minusOne.copySign(+0.0).getPartialDerivative(1), 1.0e-15); Assert.assertEquals(-1.0, minusOne.copySign(-0.0).getPartialDerivative(0), 1.0e-15); Assert.assertEquals(+1.0, minusOne.copySign(-0.0).getPartialDerivative(1), 1.0e-15); Assert.assertEquals(+1.0, minusOne.copySign(Double.NaN).getPartialDerivative(0), 1.0e-15); Assert.assertEquals(-1.0, minusOne.copySign(Double.NaN).getPartialDerivative(1), 1.0e-15); DerivativeStructure plusOne = new DerivativeStructure(1, 1, 0, +1.0); Assert.assertEquals(+1.0, plusOne.copySign(+1.0).getPartialDerivative(0), 1.0e-15); Assert.assertEquals(+1.0, plusOne.copySign(+1.0).getPartialDerivative(1), 1.0e-15); Assert.assertEquals(-1.0, plusOne.copySign(-1.0).getPartialDerivative(0), 1.0e-15); Assert.assertEquals(-1.0, plusOne.copySign(-1.0).getPartialDerivative(1), 1.0e-15); Assert.assertEquals(+1.0, plusOne.copySign(+0.0).getPartialDerivative(0), 1.0e-15); Assert.assertEquals(+1.0, plusOne.copySign(+0.0).getPartialDerivative(1), 1.0e-15); Assert.assertEquals(-1.0, plusOne.copySign(-0.0).getPartialDerivative(0), 1.0e-15); Assert.assertEquals(-1.0, plusOne.copySign(-0.0).getPartialDerivative(1), 1.0e-15); Assert.assertEquals(+1.0, plusOne.copySign(Double.NaN).getPartialDerivative(0), 1.0e-15); Assert.assertEquals(+1.0, plusOne.copySign(Double.NaN).getPartialDerivative(1), 1.0e-15); } @Test public void testToDegreesDefinition() { double epsilon = 3.0e-16; for (int maxOrder = 0; maxOrder < 6; ++maxOrder) { for (double x = 0.1; x < 1.2; x += 0.001) { DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x); Assert.assertEquals(FastMath.toDegrees(x), dsX.toDegrees().getValue(), epsilon); for (int n = 1; n <= maxOrder; ++n) { if (n == 1) { Assert.assertEquals(180 / FastMath.PI, dsX.toDegrees().getPartialDerivative(1), epsilon); } else { Assert.assertEquals(0.0, dsX.toDegrees().getPartialDerivative(n), epsilon); } } } } } @Test public void testToRadiansDefinition() { double epsilon = 3.0e-16; for (int maxOrder = 0; maxOrder < 6; ++maxOrder) { for (double x = 0.1; x < 1.2; x += 0.001) { DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x); Assert.assertEquals(FastMath.toRadians(x), dsX.toRadians().getValue(), epsilon); for (int n = 1; n <= maxOrder; ++n) { if (n == 1) { Assert.assertEquals(FastMath.PI / 180, dsX.toRadians().getPartialDerivative(1), epsilon); } else { Assert.assertEquals(0.0, dsX.toRadians().getPartialDerivative(n), epsilon); } } } } } @Test public void testDegRad() { double epsilon = 3.0e-16; for (int maxOrder = 0; maxOrder < 6; ++maxOrder) { for (double x = 0.1; x < 1.2; x += 0.001) { DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x); DerivativeStructure rebuiltX = dsX.toDegrees().toRadians(); DerivativeStructure zero = rebuiltX.subtract(dsX); for (int n = 0; n <= maxOrder; ++n) { Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon); } } } } @Test(expected=DimensionMismatchException.class) public void testComposeMismatchedDimensions() { new DerivativeStructure(1, 3, 0, 1.2).compose(new double[3]); } @Test public void testCompose() { double[] epsilon = new double[] { 1.0e-20, 5.0e-14, 2.0e-13, 3.0e-13, 2.0e-13, 1.0e-20 }; PolynomialFunction poly = new PolynomialFunction(new double[] { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 }); for (int maxOrder = 0; maxOrder < 6; ++maxOrder) { PolynomialFunction[] p = new PolynomialFunction[maxOrder + 1]; p[0] = poly; for (int i = 1; i <= maxOrder; ++i) { p[i] = p[i - 1].polynomialDerivative(); } for (double x = 0.1; x < 1.2; x += 0.001) { DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x); DerivativeStructure dsY1 = dsX.getField().getZero(); for (int i = poly.degree(); i >= 0; --i) { dsY1 = dsY1.multiply(dsX).add(poly.getCoefficients()[i]); } double[] f = new double[maxOrder + 1]; for (int i = 0; i < f.length; ++i) { f[i] = p[i].value(x); } DerivativeStructure dsY2 = dsX.compose(f); DerivativeStructure zero = dsY1.subtract(dsY2); for (int n = 0; n <= maxOrder; ++n) { Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]); } } } } @Test public void testField() { for (int maxOrder = 1; maxOrder < 5; ++maxOrder) { DerivativeStructure x = new DerivativeStructure(3, maxOrder, 0, 1.0); checkF0F1(x.getField().getZero(), 0.0, 0.0, 0.0, 0.0); checkF0F1(x.getField().getOne(), 1.0, 0.0, 0.0, 0.0); Assert.assertEquals(maxOrder, x.getField().getZero().getOrder()); Assert.assertEquals(3, x.getField().getZero().getFreeParameters()); Assert.assertEquals(DerivativeStructure.class, x.getField().getRuntimeClass()); } } @Test public void testOneParameterConstructor() { double x = 1.2; double cos = FastMath.cos(x); double sin = FastMath.sin(x); DerivativeStructure yRef = new DerivativeStructure(1, 4, 0, x).cos(); try { new DerivativeStructure(1, 4, 0.0, 0.0); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException dme) { // expected } catch (Exception e) { Assert.fail("wrong exceptionc caught " + e.getClass().getName()); } double[] derivatives = new double[] { cos, -sin, -cos, sin, cos }; DerivativeStructure y = new DerivativeStructure(1, 4, derivatives); checkEquals(yRef, y, 1.0e-15); TestUtils.assertEquals(derivatives, y.getAllDerivatives(), 1.0e-15); } @Test public void testOneOrderConstructor() { double x = 1.2; double y = 2.4; double z = 12.5; DerivativeStructure xRef = new DerivativeStructure(3, 1, 0, x); DerivativeStructure yRef = new DerivativeStructure(3, 1, 1, y); DerivativeStructure zRef = new DerivativeStructure(3, 1, 2, z); try { new DerivativeStructure(3, 1, x + y - z, 1.0, 1.0); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException dme) { // expected } catch (Exception e) { Assert.fail("wrong exceptionc caught " + e.getClass().getName()); } double[] derivatives = new double[] { x + y - z, 1.0, 1.0, -1.0 }; DerivativeStructure t = new DerivativeStructure(3, 1, derivatives); checkEquals(xRef.add(yRef.subtract(zRef)), t, 1.0e-15); TestUtils.assertEquals(derivatives, xRef.add(yRef.subtract(zRef)).getAllDerivatives(), 1.0e-15); } @Test public void testLinearCombination1DSDS() { final DerivativeStructure[] a = new DerivativeStructure[] { new DerivativeStructure(6, 1, 0, -1321008684645961.0 / 268435456.0), new DerivativeStructure(6, 1, 1, -5774608829631843.0 / 268435456.0), new DerivativeStructure(6, 1, 2, -7645843051051357.0 / 8589934592.0) }; final DerivativeStructure[] b = new DerivativeStructure[] { new DerivativeStructure(6, 1, 3, -5712344449280879.0 / 2097152.0), new DerivativeStructure(6, 1, 4, -4550117129121957.0 / 2097152.0), new DerivativeStructure(6, 1, 5, 8846951984510141.0 / 131072.0) }; final DerivativeStructure abSumInline = a[0].linearCombination(a[0], b[0], a[1], b[1], a[2], b[2]); final DerivativeStructure abSumArray = a[0].linearCombination(a, b); Assert.assertEquals(abSumInline.getValue(), abSumArray.getValue(), 0); Assert.assertEquals(-1.8551294182586248737720779899, abSumInline.getValue(), 1.0e-15); Assert.assertEquals(b[0].getValue(), abSumInline.getPartialDerivative(1, 0, 0, 0, 0, 0), 1.0e-15); Assert.assertEquals(b[1].getValue(), abSumInline.getPartialDerivative(0, 1, 0, 0, 0, 0), 1.0e-15); Assert.assertEquals(b[2].getValue(), abSumInline.getPartialDerivative(0, 0, 1, 0, 0, 0), 1.0e-15); Assert.assertEquals(a[0].getValue(), abSumInline.getPartialDerivative(0, 0, 0, 1, 0, 0), 1.0e-15); Assert.assertEquals(a[1].getValue(), abSumInline.getPartialDerivative(0, 0, 0, 0, 1, 0), 1.0e-15); Assert.assertEquals(a[2].getValue(), abSumInline.getPartialDerivative(0, 0, 0, 0, 0, 1), 1.0e-15); } @Test public void testLinearCombination1DoubleDS() { final double[] a = new double[] { -1321008684645961.0 / 268435456.0, -5774608829631843.0 / 268435456.0, -7645843051051357.0 / 8589934592.0 }; final DerivativeStructure[] b = new DerivativeStructure[] { new DerivativeStructure(3, 1, 0, -5712344449280879.0 / 2097152.0), new DerivativeStructure(3, 1, 1, -4550117129121957.0 / 2097152.0), new DerivativeStructure(3, 1, 2, 8846951984510141.0 / 131072.0) }; final DerivativeStructure abSumInline = b[0].linearCombination(a[0], b[0], a[1], b[1], a[2], b[2]); final DerivativeStructure abSumArray = b[0].linearCombination(a, b); Assert.assertEquals(abSumInline.getValue(), abSumArray.getValue(), 0); Assert.assertEquals(-1.8551294182586248737720779899, abSumInline.getValue(), 1.0e-15); Assert.assertEquals(a[0], abSumInline.getPartialDerivative(1, 0, 0), 1.0e-15); Assert.assertEquals(a[1], abSumInline.getPartialDerivative(0, 1, 0), 1.0e-15); Assert.assertEquals(a[2], abSumInline.getPartialDerivative(0, 0, 1), 1.0e-15); } @Test public void testLinearCombination2DSDS() { // we compare accurate versus naive dot product implementations // on regular vectors (i.e. not extreme cases like in the previous test) Well1024a random = new Well1024a(0xc6af886975069f11l); for (int i = 0; i < 10000; ++i) { final DerivativeStructure[] u = new DerivativeStructure[4]; final DerivativeStructure[] v = new DerivativeStructure[4]; for (int j = 0; j < u.length; ++j) { u[j] = new DerivativeStructure(u.length, 1, j, 1e17 * random.nextDouble()); v[j] = new DerivativeStructure(u.length, 1, 1e17 * random.nextDouble()); } DerivativeStructure lin = u[0].linearCombination(u[0], v[0], u[1], v[1]); double ref = u[0].getValue() * v[0].getValue() + u[1].getValue() * v[1].getValue(); Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref)); Assert.assertEquals(v[0].getValue(), lin.getPartialDerivative(1, 0, 0, 0), 1.0e-15 * FastMath.abs(v[0].getValue())); Assert.assertEquals(v[1].getValue(), lin.getPartialDerivative(0, 1, 0, 0), 1.0e-15 * FastMath.abs(v[1].getValue())); lin = u[0].linearCombination(u[0], v[0], u[1], v[1], u[2], v[2]); ref = u[0].getValue() * v[0].getValue() + u[1].getValue() * v[1].getValue() + u[2].getValue() * v[2].getValue(); Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref)); Assert.assertEquals(v[0].getValue(), lin.getPartialDerivative(1, 0, 0, 0), 1.0e-15 * FastMath.abs(v[0].getValue())); Assert.assertEquals(v[1].getValue(), lin.getPartialDerivative(0, 1, 0, 0), 1.0e-15 * FastMath.abs(v[1].getValue())); Assert.assertEquals(v[2].getValue(), lin.getPartialDerivative(0, 0, 1, 0), 1.0e-15 * FastMath.abs(v[2].getValue())); lin = u[0].linearCombination(u[0], v[0], u[1], v[1], u[2], v[2], u[3], v[3]); ref = u[0].getValue() * v[0].getValue() + u[1].getValue() * v[1].getValue() + u[2].getValue() * v[2].getValue() + u[3].getValue() * v[3].getValue(); Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref)); Assert.assertEquals(v[0].getValue(), lin.getPartialDerivative(1, 0, 0, 0), 1.0e-15 * FastMath.abs(v[0].getValue())); Assert.assertEquals(v[1].getValue(), lin.getPartialDerivative(0, 1, 0, 0), 1.0e-15 * FastMath.abs(v[1].getValue())); Assert.assertEquals(v[2].getValue(), lin.getPartialDerivative(0, 0, 1, 0), 1.0e-15 * FastMath.abs(v[2].getValue())); Assert.assertEquals(v[3].getValue(), lin.getPartialDerivative(0, 0, 0, 1), 1.0e-15 * FastMath.abs(v[3].getValue())); } } @Test public void testLinearCombination2DoubleDS() { // we compare accurate versus naive dot product implementations // on regular vectors (i.e. not extreme cases like in the previous test) Well1024a random = new Well1024a(0xc6af886975069f11l); for (int i = 0; i < 10000; ++i) { final double[] u = new double[4]; final DerivativeStructure[] v = new DerivativeStructure[4]; for (int j = 0; j < u.length; ++j) { u[j] = 1e17 * random.nextDouble(); v[j] = new DerivativeStructure(u.length, 1, j, 1e17 * random.nextDouble()); } DerivativeStructure lin = v[0].linearCombination(u[0], v[0], u[1], v[1]); double ref = u[0] * v[0].getValue() + u[1] * v[1].getValue(); Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref)); Assert.assertEquals(u[0], lin.getPartialDerivative(1, 0, 0, 0), 1.0e-15 * FastMath.abs(v[0].getValue())); Assert.assertEquals(u[1], lin.getPartialDerivative(0, 1, 0, 0), 1.0e-15 * FastMath.abs(v[1].getValue())); lin = v[0].linearCombination(u[0], v[0], u[1], v[1], u[2], v[2]); ref = u[0] * v[0].getValue() + u[1] * v[1].getValue() + u[2] * v[2].getValue(); Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref)); Assert.assertEquals(u[0], lin.getPartialDerivative(1, 0, 0, 0), 1.0e-15 * FastMath.abs(v[0].getValue())); Assert.assertEquals(u[1], lin.getPartialDerivative(0, 1, 0, 0), 1.0e-15 * FastMath.abs(v[1].getValue())); Assert.assertEquals(u[2], lin.getPartialDerivative(0, 0, 1, 0), 1.0e-15 * FastMath.abs(v[2].getValue())); lin = v[0].linearCombination(u[0], v[0], u[1], v[1], u[2], v[2], u[3], v[3]); ref = u[0] * v[0].getValue() + u[1] * v[1].getValue() + u[2] * v[2].getValue() + u[3] * v[3].getValue(); Assert.assertEquals(ref, lin.getValue(), 1.0e-15 * FastMath.abs(ref)); Assert.assertEquals(u[0], lin.getPartialDerivative(1, 0, 0, 0), 1.0e-15 * FastMath.abs(v[0].getValue())); Assert.assertEquals(u[1], lin.getPartialDerivative(0, 1, 0, 0), 1.0e-15 * FastMath.abs(v[1].getValue())); Assert.assertEquals(u[2], lin.getPartialDerivative(0, 0, 1, 0), 1.0e-15 * FastMath.abs(v[2].getValue())); Assert.assertEquals(u[3], lin.getPartialDerivative(0, 0, 0, 1), 1.0e-15 * FastMath.abs(v[3].getValue())); } } @Test public void testSerialization() { DerivativeStructure a = new DerivativeStructure(3, 2, 0, 1.3); DerivativeStructure b = (DerivativeStructure) TestUtils.serializeAndRecover(a); Assert.assertEquals(a.getFreeParameters(), b.getFreeParameters()); Assert.assertEquals(a.getOrder(), b.getOrder()); checkEquals(a, b, 1.0e-15); } private void checkF0F1(DerivativeStructure ds, double value, double...derivatives) { // check dimension Assert.assertEquals(derivatives.length, ds.getFreeParameters()); // check value, directly and also as 0th order derivative Assert.assertEquals(value, ds.getValue(), 1.0e-15); Assert.assertEquals(value, ds.getPartialDerivative(new int[ds.getFreeParameters()]), 1.0e-15); // check first order derivatives for (int i = 0; i < derivatives.length; ++i) { int[] orders = new int[derivatives.length]; orders[i] = 1; Assert.assertEquals(derivatives[i], ds.getPartialDerivative(orders), 1.0e-15); } } private void checkEquals(DerivativeStructure ds1, DerivativeStructure ds2, double epsilon) { // check dimension Assert.assertEquals(ds1.getFreeParameters(), ds2.getFreeParameters()); Assert.assertEquals(ds1.getOrder(), ds2.getOrder()); int[] derivatives = new int[ds1.getFreeParameters()]; int sum = 0; while (true) { if (sum <= ds1.getOrder()) { Assert.assertEquals(ds1.getPartialDerivative(derivatives), ds2.getPartialDerivative(derivatives), epsilon); } boolean increment = true; sum = 0; for (int i = derivatives.length - 1; i >= 0; --i) { if (increment) { if (derivatives[i] == ds1.getOrder()) { derivatives[i] = 0; } else { derivatives[i]++; increment = false; } } sum += derivatives[i]; } if (increment) { return; } } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.differentiation; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.analysis.QuinticFunction; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.UnivariateMatrixFunction; import org.apache.commons.math3.analysis.UnivariateVectorFunction; import org.apache.commons.math3.analysis.function.Gaussian; import org.apache.commons.math3.analysis.function.Sin; import org.apache.commons.math3.exception.MathInternalError; import org.apache.commons.math3.exception.NotPositiveException; import org.apache.commons.math3.exception.NumberIsTooLargeException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * Test for class {@link FiniteDifferencesDifferentiator}. */ public class FiniteDifferencesDifferentiatorTest { @Test(expected=NumberIsTooSmallException.class) public void testWrongNumberOfPoints() { new FiniteDifferencesDifferentiator(1, 1.0); } @Test(expected=NotPositiveException.class) public void testWrongStepSize() { new FiniteDifferencesDifferentiator(3, 0.0); } @Test public void testSerialization() { FiniteDifferencesDifferentiator differentiator = new FiniteDifferencesDifferentiator(3, 1.0e-3); FiniteDifferencesDifferentiator recovered = (FiniteDifferencesDifferentiator) TestUtils.serializeAndRecover(differentiator); Assert.assertEquals(differentiator.getNbPoints(), recovered.getNbPoints()); Assert.assertEquals(differentiator.getStepSize(), recovered.getStepSize(), 1.0e-15); } @Test public void testConstant() { FiniteDifferencesDifferentiator differentiator = new FiniteDifferencesDifferentiator(5, 0.01); UnivariateDifferentiableFunction f = differentiator.differentiate(new UnivariateFunction() { public double value(double x) { return 42.0; } }); for (double x = -10; x < 10; x += 0.1) { DerivativeStructure y = f.value(new DerivativeStructure(1, 2, 0, x)); Assert.assertEquals(42.0, y.getValue(), 1.0e-15); Assert.assertEquals( 0.0, y.getPartialDerivative(1), 1.0e-15); Assert.assertEquals( 0.0, y.getPartialDerivative(2), 1.0e-15); } } @Test public void testLinear() { FiniteDifferencesDifferentiator differentiator = new FiniteDifferencesDifferentiator(5, 0.01); UnivariateDifferentiableFunction f = differentiator.differentiate(new UnivariateFunction() { public double value(double x) { return 2 - 3 * x; } }); for (double x = -10; x < 10; x += 0.1) { DerivativeStructure y = f.value(new DerivativeStructure(1, 2, 0, x)); Assert.assertEquals("" + (2 - 3 * x - y.getValue()), 2 - 3 * x, y.getValue(), 2.0e-15); Assert.assertEquals(-3.0, y.getPartialDerivative(1), 4.0e-13); Assert.assertEquals( 0.0, y.getPartialDerivative(2), 9.0e-11); } } @Test public void testGaussian() { FiniteDifferencesDifferentiator differentiator = new FiniteDifferencesDifferentiator(9, 0.02); UnivariateDifferentiableFunction gaussian = new Gaussian(1.0, 2.0); UnivariateDifferentiableFunction f = differentiator.differentiate(gaussian); double[] expectedError = new double[] { 6.939e-18, 1.284e-15, 2.477e-13, 1.168e-11, 2.840e-9, 7.971e-8 }; double[] maxError = new double[expectedError.length]; for (double x = -10; x < 10; x += 0.1) { DerivativeStructure dsX = new DerivativeStructure(1, maxError.length - 1, 0, x); DerivativeStructure yRef = gaussian.value(dsX); DerivativeStructure y = f.value(dsX); Assert.assertEquals(f.value(dsX.getValue()), f.value(dsX).getValue(), 1.0e-15); for (int order = 0; order <= yRef.getOrder(); ++order) { maxError[order] = FastMath.max(maxError[order], FastMath.abs(yRef.getPartialDerivative(order) - y.getPartialDerivative(order))); } } for (int i = 0; i < maxError.length; ++i) { Assert.assertEquals(expectedError[i], maxError[i], 0.01 * expectedError[i]); } } @Test public void testStepSizeUnstability() { UnivariateDifferentiableFunction quintic = new QuinticFunction(); UnivariateDifferentiableFunction goodStep = new FiniteDifferencesDifferentiator(7, 0.25).differentiate(quintic); UnivariateDifferentiableFunction badStep = new FiniteDifferencesDifferentiator(7, 1.0e-6).differentiate(quintic); double[] maxErrorGood = new double[7]; double[] maxErrorBad = new double[7]; for (double x = -10; x < 10; x += 0.1) { DerivativeStructure dsX = new DerivativeStructure(1, 6, 0, x); DerivativeStructure yRef = quintic.value(dsX); DerivativeStructure yGood = goodStep.value(dsX); DerivativeStructure yBad = badStep.value(dsX); for (int order = 0; order <= 6; ++order) { maxErrorGood[order] = FastMath.max(maxErrorGood[order], FastMath.abs(yRef.getPartialDerivative(order) - yGood.getPartialDerivative(order))); maxErrorBad[order] = FastMath.max(maxErrorBad[order], FastMath.abs(yRef.getPartialDerivative(order) - yBad.getPartialDerivative(order))); } } // the 0.25 step size is good for finite differences in the quintic on this abscissa range for 7 points // the errors are fair final double[] expectedGood = new double[] { 7.276e-12, 7.276e-11, 9.968e-10, 3.092e-9, 5.432e-8, 8.196e-8, 1.818e-6 }; // the 1.0e-6 step size is far too small for finite differences in the quintic on this abscissa range for 7 points // the errors are huge! final double[] expectedBad = new double[] { 2.910e-11, 2.087e-5, 147.7, 3.820e7, 6.354e14, 6.548e19, 1.543e27 }; for (int i = 0; i < maxErrorGood.length; ++i) { Assert.assertEquals(expectedGood[i], maxErrorGood[i], 0.01 * expectedGood[i]); Assert.assertEquals(expectedBad[i], maxErrorBad[i], 0.01 * expectedBad[i]); } } @Test(expected=NumberIsTooLargeException.class) public void testWrongOrder() { UnivariateDifferentiableFunction f = new FiniteDifferencesDifferentiator(3, 0.01).differentiate(new UnivariateFunction() { public double value(double x) { // this exception should not be thrown because wrong order // should be detected before function call throw new MathInternalError(); } }); f.value(new DerivativeStructure(1, 3, 0, 1.0)); } @Test(expected=NumberIsTooLargeException.class) public void testWrongOrderVector() { UnivariateDifferentiableVectorFunction f = new FiniteDifferencesDifferentiator(3, 0.01).differentiate(new UnivariateVectorFunction() { public double[] value(double x) { // this exception should not be thrown because wrong order // should be detected before function call throw new MathInternalError(); } }); f.value(new DerivativeStructure(1, 3, 0, 1.0)); } @Test(expected=NumberIsTooLargeException.class) public void testWrongOrderMatrix() { UnivariateDifferentiableMatrixFunction f = new FiniteDifferencesDifferentiator(3, 0.01).differentiate(new UnivariateMatrixFunction() { public double[][] value(double x) { // this exception should not be thrown because wrong order // should be detected before function call throw new MathInternalError(); } }); f.value(new DerivativeStructure(1, 3, 0, 1.0)); } @Test(expected=NumberIsTooLargeException.class) public void testTooLargeStep() { new FiniteDifferencesDifferentiator(3, 2.5, 0.0, 1.0); } @Test public void testBounds() { final double slope = 2.5; UnivariateFunction f = new UnivariateFunction() { public double value(double x) { if (x < 0) { throw new NumberIsTooSmallException(x, 0, true); } else if (x > 1) { throw new NumberIsTooLargeException(x, 1, true); } else { return slope * x; } } }; UnivariateDifferentiableFunction missingBounds = new FiniteDifferencesDifferentiator(3, 0.1).differentiate(f); UnivariateDifferentiableFunction properlyBounded = new FiniteDifferencesDifferentiator(3, 0.1, 0.0, 1.0).differentiate(f); DerivativeStructure tLow = new DerivativeStructure(1, 1, 0, 0.05); DerivativeStructure tHigh = new DerivativeStructure(1, 1, 0, 0.95); try { // here, we did not set the bounds, so the differences are evaluated out of domain // using f(-0.05), f(0.05), f(0.15) missingBounds.value(tLow); Assert.fail("an exception should have been thrown"); } catch (NumberIsTooSmallException nse) { Assert.assertEquals(-0.05, nse.getArgument().doubleValue(), 1.0e-10); } catch (Exception e) { Assert.fail("wrong exception caught: " + e.getClass().getName()); } try { // here, we did not set the bounds, so the differences are evaluated out of domain // using f(0.85), f(0.95), f(1.05) missingBounds.value(tHigh); Assert.fail("an exception should have been thrown"); } catch (NumberIsTooLargeException nle) { Assert.assertEquals(1.05, nle.getArgument().doubleValue(), 1.0e-10); } catch (Exception e) { Assert.fail("wrong exception caught: " + e.getClass().getName()); } // here, we did set the bounds, so evaluations are done within domain // using f(0.0), f(0.1), f(0.2) Assert.assertEquals(slope, properlyBounded.value(tLow).getPartialDerivative(1), 1.0e-10); // here, we did set the bounds, so evaluations are done within domain // using f(0.8), f(0.9), f(1.0) Assert.assertEquals(slope, properlyBounded.value(tHigh).getPartialDerivative(1), 1.0e-10); } @Test public void testBoundedSqrt() { UnivariateFunctionDifferentiator differentiator = new FiniteDifferencesDifferentiator(9, 1.0 / 32, 0.0, Double.POSITIVE_INFINITY); UnivariateDifferentiableFunction sqrt = differentiator.differentiate(new UnivariateFunction() { public double value(double x) { return FastMath.sqrt(x); } }); // we are able to compute derivative near 0, but the accuracy is much poorer there DerivativeStructure t001 = new DerivativeStructure(1, 1, 0, 0.01); Assert.assertEquals(0.5 / FastMath.sqrt(t001.getValue()), sqrt.value(t001).getPartialDerivative(1), 1.6); DerivativeStructure t01 = new DerivativeStructure(1, 1, 0, 0.1); Assert.assertEquals(0.5 / FastMath.sqrt(t01.getValue()), sqrt.value(t01).getPartialDerivative(1), 7.0e-3); DerivativeStructure t03 = new DerivativeStructure(1, 1, 0, 0.3); Assert.assertEquals(0.5 / FastMath.sqrt(t03.getValue()), sqrt.value(t03).getPartialDerivative(1), 2.1e-7); } @Test public void testVectorFunction() { FiniteDifferencesDifferentiator differentiator = new FiniteDifferencesDifferentiator(7, 0.01); UnivariateDifferentiableVectorFunction f = differentiator.differentiate(new UnivariateVectorFunction() { public double[] value(double x) { return new double[] { FastMath.cos(x), FastMath.sin(x) }; } }); for (double x = -10; x < 10; x += 0.1) { DerivativeStructure dsX = new DerivativeStructure(1, 2, 0, x); DerivativeStructure[] y = f.value(dsX); double cos = FastMath.cos(x); double sin = FastMath.sin(x); double[] f1 = f.value(dsX.getValue()); DerivativeStructure[] f2 = f.value(dsX); Assert.assertEquals(f1.length, f2.length); for (int i = 0; i < f1.length; ++i) { Assert.assertEquals(f1[i], f2[i].getValue(), 1.0e-15); } Assert.assertEquals( cos, y[0].getValue(), 7.0e-16); Assert.assertEquals( sin, y[1].getValue(), 7.0e-16); Assert.assertEquals(-sin, y[0].getPartialDerivative(1), 6.0e-14); Assert.assertEquals( cos, y[1].getPartialDerivative(1), 6.0e-14); Assert.assertEquals(-cos, y[0].getPartialDerivative(2), 2.0e-11); Assert.assertEquals(-sin, y[1].getPartialDerivative(2), 2.0e-11); } } @Test public void testMatrixFunction() { FiniteDifferencesDifferentiator differentiator = new FiniteDifferencesDifferentiator(7, 0.01); UnivariateDifferentiableMatrixFunction f = differentiator.differentiate(new UnivariateMatrixFunction() { public double[][] value(double x) { return new double[][] { { FastMath.cos(x), FastMath.sin(x) }, { FastMath.cosh(x), FastMath.sinh(x) } }; } }); for (double x = -1; x < 1; x += 0.02) { DerivativeStructure dsX = new DerivativeStructure(1, 2, 0, x); DerivativeStructure[][] y = f.value(dsX); double cos = FastMath.cos(x); double sin = FastMath.sin(x); double cosh = FastMath.cosh(x); double sinh = FastMath.sinh(x); double[][] f1 = f.value(dsX.getValue()); DerivativeStructure[][] f2 = f.value(dsX); Assert.assertEquals(f1.length, f2.length); for (int i = 0; i < f1.length; ++i) { Assert.assertEquals(f1[i].length, f2[i].length); for (int j = 0; j < f1[i].length; ++j) { Assert.assertEquals(f1[i][j], f2[i][j].getValue(), 1.0e-15); } } Assert.assertEquals(cos, y[0][0].getValue(), 7.0e-18); Assert.assertEquals(sin, y[0][1].getValue(), 6.0e-17); Assert.assertEquals(cosh, y[1][0].getValue(), 3.0e-16); Assert.assertEquals(sinh, y[1][1].getValue(), 3.0e-16); Assert.assertEquals(-sin, y[0][0].getPartialDerivative(1), 2.0e-14); Assert.assertEquals( cos, y[0][1].getPartialDerivative(1), 2.0e-14); Assert.assertEquals( sinh, y[1][0].getPartialDerivative(1), 3.0e-14); Assert.assertEquals( cosh, y[1][1].getPartialDerivative(1), 3.0e-14); Assert.assertEquals(-cos, y[0][0].getPartialDerivative(2), 3.0e-12); Assert.assertEquals(-sin, y[0][1].getPartialDerivative(2), 3.0e-12); Assert.assertEquals( cosh, y[1][0].getPartialDerivative(2), 6.0e-12); Assert.assertEquals( sinh, y[1][1].getPartialDerivative(2), 6.0e-12); } } @Test public void testSeveralFreeParameters() { FiniteDifferencesDifferentiator differentiator = new FiniteDifferencesDifferentiator(5, 0.001); UnivariateDifferentiableFunction sine = new Sin(); UnivariateDifferentiableFunction f = differentiator.differentiate(sine); double[] expectedError = new double[] { 6.696e-16, 1.371e-12, 2.007e-8, 1.754e-5 }; double[] maxError = new double[expectedError.length]; for (double x = -2; x < 2; x += 0.1) { for (double y = -2; y < 2; y += 0.1) { DerivativeStructure dsX = new DerivativeStructure(2, maxError.length - 1, 0, x); DerivativeStructure dsY = new DerivativeStructure(2, maxError.length - 1, 1, y); DerivativeStructure dsT = dsX.multiply(3).subtract(dsY.multiply(2)); DerivativeStructure sRef = sine.value(dsT); DerivativeStructure s = f.value(dsT); for (int xOrder = 0; xOrder <= sRef.getOrder(); ++xOrder) { for (int yOrder = 0; yOrder <= sRef.getOrder(); ++yOrder) { if (xOrder + yOrder <= sRef.getOrder()) { maxError[xOrder +yOrder] = FastMath.max(maxError[xOrder + yOrder], FastMath.abs(sRef.getPartialDerivative(xOrder, yOrder) - s.getPartialDerivative(xOrder, yOrder))); } } } } } for (int i = 0; i < maxError.length; ++i) { Assert.assertEquals(expectedError[i], maxError[i], 0.01 * expectedError[i]); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.differentiation; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.util.FastMath; import org.junit.Test; /** * Test for class {@link GradientFunction}. */ public class GradientFunctionTest { @Test public void test2DDistance() { EuclideanDistance f = new EuclideanDistance(); GradientFunction g = new GradientFunction(f); for (double x = -10; x < 10; x += 0.5) { for (double y = -10; y < 10; y += 0.5) { double[] point = new double[] { x, y }; TestUtils.assertEquals(f.gradient(point), g.value(point), 1.0e-15); } } } @Test public void test3DDistance() { EuclideanDistance f = new EuclideanDistance(); GradientFunction g = new GradientFunction(f); for (double x = -10; x < 10; x += 0.5) { for (double y = -10; y < 10; y += 0.5) { for (double z = -10; z < 10; z += 0.5) { double[] point = new double[] { x, y, z }; TestUtils.assertEquals(f.gradient(point), g.value(point), 1.0e-15); } } } } private static class EuclideanDistance implements MultivariateDifferentiableFunction { public double value(double[] point) { double d2 = 0; for (double x : point) { d2 += x * x; } return FastMath.sqrt(d2); } public DerivativeStructure value(DerivativeStructure[] point) throws DimensionMismatchException, MathIllegalArgumentException { DerivativeStructure d2 = point[0].getField().getZero(); for (DerivativeStructure x : point) { d2 = d2.add(x.multiply(x)); } return d2.sqrt(); } public double[] gradient(double[] point) { double[] gradient = new double[point.length]; double d = value(point); for (int i = 0; i < point.length; ++i) { gradient[i] = point[i] / d; } return gradient; } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.differentiation; import org.junit.Assert; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.util.FastMath; import org.junit.Test; /** * Test for class {@link JacobianFunction}. */ public class JacobianFunctionTest { @Test public void testSphere() { SphereMapping f = new SphereMapping(10.0); JacobianFunction j = new JacobianFunction(f); for (double latitude = -1.5; latitude < 1.5; latitude += 0.1) { for (double longitude = -3.1; longitude < 3.1; longitude += 0.1) { double[] point = new double[] { latitude, longitude }; double[][] referenceJacobian = f.jacobian(point); double[][] testJacobian = j.value(point); Assert.assertEquals(referenceJacobian.length, testJacobian.length); for (int i = 0; i < 3; ++i) { TestUtils.assertEquals(referenceJacobian[i], testJacobian[i], 2.0e-15); } } } } /* Maps (latitude, longitude) to (x, y, z) */ private static class SphereMapping implements MultivariateDifferentiableVectorFunction { private final double radius; public SphereMapping(final double radius) { this.radius = radius; } public double[] value(double[] point) { final double cLat = FastMath.cos(point[0]); final double sLat = FastMath.sin(point[0]); final double cLon = FastMath.cos(point[1]); final double sLon = FastMath.sin(point[1]); return new double[] { radius * cLon * cLat, radius * sLon * cLat, radius * sLat }; } public DerivativeStructure[] value(DerivativeStructure[] point) { final DerivativeStructure cLat = point[0].cos(); final DerivativeStructure sLat = point[0].sin(); final DerivativeStructure cLon = point[1].cos(); final DerivativeStructure sLon = point[1].sin(); return new DerivativeStructure[] { cLon.multiply(cLat).multiply(radius), sLon.multiply(cLat).multiply(radius), sLat.multiply(radius) }; } public double[][] jacobian(double[] point) { final double cLat = FastMath.cos(point[0]); final double sLat = FastMath.sin(point[0]); final double cLon = FastMath.cos(point[1]); final double sLon = FastMath.sin(point[1]); return new double[][] { { -radius * cLon * sLat, -radius * sLon * cLat }, { -radius * sLon * sLat, radius * cLon * cLat }, { radius * cLat, 0 } }; } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.function; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.differentiation.DerivativeStructure; import org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.apache.commons.math3.exception.NullArgumentException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * Test for class {@link Gaussian}. */ public class GaussianTest { private final double EPS = Math.ulp(1d); @Test(expected=NotStrictlyPositiveException.class) public void testPreconditions() { new Gaussian(1, 2, -1); } @Test public void testSomeValues() { final UnivariateFunction f = new Gaussian(); Assert.assertEquals(1 / FastMath.sqrt(2 * Math.PI), f.value(0), EPS); } @Test public void testLargeArguments() { final UnivariateFunction f = new Gaussian(); Assert.assertEquals(0, f.value(Double.NEGATIVE_INFINITY), 0); Assert.assertEquals(0, f.value(-Double.MAX_VALUE), 0); Assert.assertEquals(0, f.value(-1e2), 0); Assert.assertEquals(0, f.value(1e2), 0); Assert.assertEquals(0, f.value(Double.MAX_VALUE), 0); Assert.assertEquals(0, f.value(Double.POSITIVE_INFINITY), 0); } @Test public void testDerivatives() { final UnivariateDifferentiableFunction gaussian = new Gaussian(2.0, 0.9, 3.0); final DerivativeStructure dsX = new DerivativeStructure(1, 4, 0, 1.1); final DerivativeStructure dsY = gaussian.value(dsX); Assert.assertEquals( 1.9955604901712128349, dsY.getValue(), EPS); Assert.assertEquals(-0.044345788670471396332, dsY.getPartialDerivative(1), EPS); Assert.assertEquals(-0.22074348138190206174, dsY.getPartialDerivative(2), EPS); Assert.assertEquals( 0.014760030401924800557, dsY.getPartialDerivative(3), EPS); Assert.assertEquals( 0.073253159785035691678, dsY.getPartialDerivative(4), EPS); } @Test public void testDerivativeLargeArguments() { final Gaussian f = new Gaussian(0, 1e-50); Assert.assertEquals(0, f.value(new DerivativeStructure(1, 1, 0, Double.NEGATIVE_INFINITY)).getPartialDerivative(1), 0); Assert.assertEquals(0, f.value(new DerivativeStructure(1, 1, 0, -Double.MAX_VALUE)).getPartialDerivative(1), 0); Assert.assertEquals(0, f.value(new DerivativeStructure(1, 1, 0, -1e50)).getPartialDerivative(1), 0); Assert.assertEquals(0, f.value(new DerivativeStructure(1, 1, 0, -1e2)).getPartialDerivative(1), 0); Assert.assertEquals(0, f.value(new DerivativeStructure(1, 1, 0, 1e2)).getPartialDerivative(1), 0); Assert.assertEquals(0, f.value(new DerivativeStructure(1, 1, 0, 1e50)).getPartialDerivative(1), 0); Assert.assertEquals(0, f.value(new DerivativeStructure(1, 1, 0, Double.MAX_VALUE)).getPartialDerivative(1), 0); Assert.assertEquals(0, f.value(new DerivativeStructure(1, 1, 0, Double.POSITIVE_INFINITY)).getPartialDerivative(1), 0); } @Test public void testDerivativesNaN() { final Gaussian f = new Gaussian(0, 1e-50); final DerivativeStructure fx = f.value(new DerivativeStructure(1, 5, 0, Double.NaN)); for (int i = 0; i <= fx.getOrder(); ++i) { Assert.assertTrue(Double.isNaN(fx.getPartialDerivative(i))); } } @Test(expected=NullArgumentException.class) public void testParametricUsage1() { final Gaussian.Parametric g = new Gaussian.Parametric(); g.value(0, null); } @Test(expected=DimensionMismatchException.class) public void testParametricUsage2() { final Gaussian.Parametric g = new Gaussian.Parametric(); g.value(0, new double[] {0}); } @Test(expected=NotStrictlyPositiveException.class) public void testParametricUsage3() { final Gaussian.Parametric g = new Gaussian.Parametric(); g.value(0, new double[] {0, 1, 0}); } @Test(expected=NullArgumentException.class) public void testParametricUsage4() { final Gaussian.Parametric g = new Gaussian.Parametric(); g.gradient(0, null); } @Test(expected=DimensionMismatchException.class) public void testParametricUsage5() { final Gaussian.Parametric g = new Gaussian.Parametric(); g.gradient(0, new double[] {0}); } @Test(expected=NotStrictlyPositiveException.class) public void testParametricUsage6() { final Gaussian.Parametric g = new Gaussian.Parametric(); g.gradient(0, new double[] {0, 1, 0}); } @Test public void testParametricValue() { final double norm = 2; final double mean = 3; final double sigma = 4; final Gaussian f = new Gaussian(norm, mean, sigma); final Gaussian.Parametric g = new Gaussian.Parametric(); Assert.assertEquals(f.value(-1), g.value(-1, new double[] {norm, mean, sigma}), 0); Assert.assertEquals(f.value(0), g.value(0, new double[] {norm, mean, sigma}), 0); Assert.assertEquals(f.value(2), g.value(2, new double[] {norm, mean, sigma}), 0); } @Test public void testParametricGradient() { final double norm = 2; final double mean = 3; final double sigma = 4; final Gaussian.Parametric f = new Gaussian.Parametric(); final double x = 1; final double[] grad = f.gradient(1, new double[] {norm, mean, sigma}); final double diff = x - mean; final double n = FastMath.exp(-diff * diff / (2 * sigma * sigma)); Assert.assertEquals(n, grad[0], EPS); final double m = norm * n * diff / (sigma * sigma); Assert.assertEquals(m, grad[1], EPS); final double s = m * diff / sigma; Assert.assertEquals(s, grad[2], EPS); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.function; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.differentiation.DerivativeStructure; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.NullArgumentException; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.util.Precision; import org.junit.Assert; import org.junit.Test; /** * Test for class {@link HarmonicOscillator}. */ public class HarmonicOscillatorTest { private final double EPS = Math.ulp(1d); @Test public void testSomeValues() { final double a = -1.2; final double w = 0.34; final double p = 5.6; final UnivariateFunction f = new HarmonicOscillator(a, w, p); final double d = 0.12345; for (int i = 0; i < 10; i++) { final double v = i * d; Assert.assertEquals(a * FastMath.cos(w * v + p), f.value(v), 0); } } @Test public void testDerivative() { final double a = -1.2; final double w = 0.34; final double p = 5.6; final HarmonicOscillator f = new HarmonicOscillator(a, w, p); for (int maxOrder = 0; maxOrder < 6; ++maxOrder) { final double d = 0.12345; for (int i = 0; i < 10; i++) { final double v = i * d; final DerivativeStructure h = f.value(new DerivativeStructure(1, maxOrder, 0, v)); for (int k = 0; k <= maxOrder; ++k) { final double trigo; switch (k % 4) { case 0: trigo = +FastMath.cos(w * v + p); break; case 1: trigo = -FastMath.sin(w * v + p); break; case 2: trigo = -FastMath.cos(w * v + p); break; default: trigo = +FastMath.sin(w * v + p); break; } Assert.assertEquals(a * FastMath.pow(w, k) * trigo, h.getPartialDerivative(k), Precision.EPSILON); } } } } @Test(expected=NullArgumentException.class) public void testParametricUsage1() { final HarmonicOscillator.Parametric g = new HarmonicOscillator.Parametric(); g.value(0, null); } @Test(expected=DimensionMismatchException.class) public void testParametricUsage2() { final HarmonicOscillator.Parametric g = new HarmonicOscillator.Parametric(); g.value(0, new double[] {0}); } @Test(expected=NullArgumentException.class) public void testParametricUsage3() { final HarmonicOscillator.Parametric g = new HarmonicOscillator.Parametric(); g.gradient(0, null); } @Test(expected=DimensionMismatchException.class) public void testParametricUsage4() { final HarmonicOscillator.Parametric g = new HarmonicOscillator.Parametric(); g.gradient(0, new double[] {0}); } @Test public void testParametricValue() { final double amplitude = 2; final double omega = 3; final double phase = 4; final HarmonicOscillator f = new HarmonicOscillator(amplitude, omega, phase); final HarmonicOscillator.Parametric g = new HarmonicOscillator.Parametric(); Assert.assertEquals(f.value(-1), g.value(-1, new double[] {amplitude, omega, phase}), 0); Assert.assertEquals(f.value(0), g.value(0, new double[] {amplitude, omega, phase}), 0); Assert.assertEquals(f.value(2), g.value(2, new double[] {amplitude, omega, phase}), 0); } @Test public void testParametricGradient() { final double amplitude = 2; final double omega = 3; final double phase = 4; final HarmonicOscillator.Parametric f = new HarmonicOscillator.Parametric(); final double x = 1; final double[] grad = f.gradient(1, new double[] {amplitude, omega, phase}); final double xTimesOmegaPlusPhase = omega * x + phase; final double a = FastMath.cos(xTimesOmegaPlusPhase); Assert.assertEquals(a, grad[0], EPS); final double w = -amplitude * x * FastMath.sin(xTimesOmegaPlusPhase); Assert.assertEquals(w, grad[1], EPS); final double p = -amplitude * FastMath.sin(xTimesOmegaPlusPhase); Assert.assertEquals(p, grad[2], EPS); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.function; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.differentiation.DerivativeStructure; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.apache.commons.math3.exception.NullArgumentException; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * Test for class {@link Logistic}. */ public class LogisticTest { private final double EPS = Math.ulp(1d); @Test(expected=NotStrictlyPositiveException.class) public void testPreconditions1() { new Logistic(1, 0, 1, 1, 0, -1); } @Test(expected=NotStrictlyPositiveException.class) public void testPreconditions2() { new Logistic(1, 0, 1, 1, 0, 0); } @Test public void testCompareSigmoid() { final UnivariateFunction sig = new Sigmoid(); final UnivariateFunction sigL = new Logistic(1, 0, 1, 1, 0, 1); final double min = -2; final double max = 2; final int n = 100; final double delta = (max - min) / n; for (int i = 0; i < n; i++) { final double x = min + i * delta; Assert.assertEquals("x=" + x, sig.value(x), sigL.value(x), EPS); } } @Test public void testSomeValues() { final double k = 4; final double m = 5; final double b = 2; final double q = 3; final double a = -1; final double n = 2; final UnivariateFunction f = new Logistic(k, m, b, q, a, n); double x; x = m; Assert.assertEquals("x=" + x, a + (k - a) / FastMath.sqrt(1 + q), f.value(x), EPS); x = Double.NEGATIVE_INFINITY; Assert.assertEquals("x=" + x, a, f.value(x), EPS); x = Double.POSITIVE_INFINITY; Assert.assertEquals("x=" + x, k, f.value(x), EPS); } @Test public void testCompareDerivativeSigmoid() { final double k = 3; final double a = 2; final Logistic f = new Logistic(k, 0, 1, 1, a, 1); final Sigmoid g = new Sigmoid(a, k); final double min = -10; final double max = 10; final double n = 20; final double delta = (max - min) / n; for (int i = 0; i < n; i++) { final DerivativeStructure x = new DerivativeStructure(1, 5, 0, min + i * delta); for (int order = 0; order <= x.getOrder(); ++order) { Assert.assertEquals("x=" + x.getValue(), g.value(x).getPartialDerivative(order), f.value(x).getPartialDerivative(order), 3.0e-15); } } } @Test(expected=NullArgumentException.class) public void testParametricUsage1() { final Logistic.Parametric g = new Logistic.Parametric(); g.value(0, null); } @Test(expected=DimensionMismatchException.class) public void testParametricUsage2() { final Logistic.Parametric g = new Logistic.Parametric(); g.value(0, new double[] {0}); } @Test(expected=NullArgumentException.class) public void testParametricUsage3() { final Logistic.Parametric g = new Logistic.Parametric(); g.gradient(0, null); } @Test(expected=DimensionMismatchException.class) public void testParametricUsage4() { final Logistic.Parametric g = new Logistic.Parametric(); g.gradient(0, new double[] {0}); } @Test(expected=NotStrictlyPositiveException.class) public void testParametricUsage5() { final Logistic.Parametric g = new Logistic.Parametric(); g.value(0, new double[] {1, 0, 1, 1, 0 ,0}); } @Test(expected=NotStrictlyPositiveException.class) public void testParametricUsage6() { final Logistic.Parametric g = new Logistic.Parametric(); g.gradient(0, new double[] {1, 0, 1, 1, 0 ,0}); } @Test public void testGradientComponent0Component4() { final double k = 3; final double a = 2; final Logistic.Parametric f = new Logistic.Parametric(); // Compare using the "Sigmoid" function. final Sigmoid.Parametric g = new Sigmoid.Parametric(); final double x = 0.12345; final double[] gf = f.gradient(x, new double[] {k, 0, 1, 1, a, 1}); final double[] gg = g.gradient(x, new double[] {a, k}); Assert.assertEquals(gg[0], gf[4], EPS); Assert.assertEquals(gg[1], gf[0], EPS); } @Test public void testGradientComponent5() { final double m = 1.2; final double k = 3.4; final double a = 2.3; final double q = 0.567; final double b = -FastMath.log(q); final double n = 3.4; final Logistic.Parametric f = new Logistic.Parametric(); final double x = m - 1; final double qExp1 = 2; final double[] gf = f.gradient(x, new double[] {k, m, b, q, a, n}); Assert.assertEquals((k - a) * FastMath.log(qExp1) / (n * n * FastMath.pow(qExp1, 1 / n)), gf[5], EPS); } @Test public void testGradientComponent1Component2Component3() { final double m = 1.2; final double k = 3.4; final double a = 2.3; final double b = 0.567; final double q = 1 / FastMath.exp(b * m); final double n = 3.4; final Logistic.Parametric f = new Logistic.Parametric(); final double x = 0; final double qExp1 = 2; final double[] gf = f.gradient(x, new double[] {k, m, b, q, a, n}); final double factor = (a - k) / (n * FastMath.pow(qExp1, 1 / n + 1)); Assert.assertEquals(factor * b, gf[1], EPS); Assert.assertEquals(factor * m, gf[2], EPS); Assert.assertEquals(factor / q, gf[3], EPS); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.function; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.FunctionUtils; import org.apache.commons.math3.analysis.differentiation.DerivativeStructure; import org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction; import org.apache.commons.math3.exception.NullArgumentException; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.OutOfRangeException; import org.apache.commons.math3.random.RandomGenerator; import org.apache.commons.math3.random.Well1024a; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * Test for class {@link Logit}. */ public class LogitTest { private final double EPS = Math.ulp(1d); @Test(expected=OutOfRangeException.class) public void testPreconditions1() { final double lo = -1; final double hi = 2; final UnivariateFunction f = new Logit(lo, hi); f.value(lo - 1); } @Test(expected=OutOfRangeException.class) public void testPreconditions2() { final double lo = -1; final double hi = 2; final UnivariateFunction f = new Logit(lo, hi); f.value(hi + 1); } @Test public void testSomeValues() { final double lo = 1; final double hi = 2; final UnivariateFunction f = new Logit(lo, hi); Assert.assertEquals(Double.NEGATIVE_INFINITY, f.value(1), EPS); Assert.assertEquals(Double.POSITIVE_INFINITY, f.value(2), EPS); Assert.assertEquals(0, f.value(1.5), EPS); } @Test public void testDerivative() { final double lo = 1; final double hi = 2; final Logit f = new Logit(lo, hi); final DerivativeStructure f15 = f.value(new DerivativeStructure(1, 1, 0, 1.5)); Assert.assertEquals(4, f15.getPartialDerivative(1), EPS); } @Test public void testDerivativeLargeArguments() { final Logit f = new Logit(1, 2); for (double arg : new double[] { Double.NEGATIVE_INFINITY, -Double.MAX_VALUE, -1e155, 1e155, Double.MAX_VALUE, Double.POSITIVE_INFINITY }) { try { f.value(new DerivativeStructure(1, 1, 0, arg)); Assert.fail("an exception should have been thrown"); } catch (OutOfRangeException ore) { // expected } catch (Exception e) { Assert.fail("wrong exception caught: " + e.getMessage()); } } } @Test public void testDerivativesHighOrder() { DerivativeStructure l = new Logit(1, 3).value(new DerivativeStructure(1, 5, 0, 1.2)); Assert.assertEquals(-2.1972245773362193828, l.getPartialDerivative(0), 1.0e-16); Assert.assertEquals(5.5555555555555555555, l.getPartialDerivative(1), 9.0e-16); Assert.assertEquals(-24.691358024691358025, l.getPartialDerivative(2), 2.0e-14); Assert.assertEquals(250.34293552812071331, l.getPartialDerivative(3), 2.0e-13); Assert.assertEquals(-3749.4284407864654778, l.getPartialDerivative(4), 4.0e-12); Assert.assertEquals(75001.270131585632282, l.getPartialDerivative(5), 8.0e-11); } @Test(expected=NullArgumentException.class) public void testParametricUsage1() { final Logit.Parametric g = new Logit.Parametric(); g.value(0, null); } @Test(expected=DimensionMismatchException.class) public void testParametricUsage2() { final Logit.Parametric g = new Logit.Parametric(); g.value(0, new double[] {0}); } @Test(expected=NullArgumentException.class) public void testParametricUsage3() { final Logit.Parametric g = new Logit.Parametric(); g.gradient(0, null); } @Test(expected=DimensionMismatchException.class) public void testParametricUsage4() { final Logit.Parametric g = new Logit.Parametric(); g.gradient(0, new double[] {0}); } @Test(expected=OutOfRangeException.class) public void testParametricUsage5() { final Logit.Parametric g = new Logit.Parametric(); g.value(-1, new double[] {0, 1}); } @Test(expected=OutOfRangeException.class) public void testParametricUsage6() { final Logit.Parametric g = new Logit.Parametric(); g.value(2, new double[] {0, 1}); } @Test public void testParametricValue() { final double lo = 2; final double hi = 3; final Logit f = new Logit(lo, hi); final Logit.Parametric g = new Logit.Parametric(); Assert.assertEquals(f.value(2), g.value(2, new double[] {lo, hi}), 0); Assert.assertEquals(f.value(2.34567), g.value(2.34567, new double[] {lo, hi}), 0); Assert.assertEquals(f.value(3), g.value(3, new double[] {lo, hi}), 0); } @Test public void testValueWithInverseFunction() { final double lo = 2; final double hi = 3; final Logit f = new Logit(lo, hi); final Sigmoid g = new Sigmoid(lo, hi); RandomGenerator random = new Well1024a(0x49914cdd9f0b8db5l); final UnivariateDifferentiableFunction id = FunctionUtils.compose((UnivariateDifferentiableFunction) g, (UnivariateDifferentiableFunction) f); for (int i = 0; i < 10; i++) { final double x = lo + random.nextDouble() * (hi - lo); Assert.assertEquals(x, id.value(new DerivativeStructure(1, 1, 0, x)).getValue(), EPS); } Assert.assertEquals(lo, id.value(new DerivativeStructure(1, 1, 0, lo)).getValue(), EPS); Assert.assertEquals(hi, id.value(new DerivativeStructure(1, 1, 0, hi)).getValue(), EPS); } @Test public void testDerivativesWithInverseFunction() { double[] epsilon = new double[] { 1.0e-20, 4.0e-16, 3.0e-15, 2.0e-11, 3.0e-9, 1.0e-6 }; final double lo = 2; final double hi = 3; final Logit f = new Logit(lo, hi); final Sigmoid g = new Sigmoid(lo, hi); RandomGenerator random = new Well1024a(0x96885e9c1f81cea5l); final UnivariateDifferentiableFunction id = FunctionUtils.compose((UnivariateDifferentiableFunction) g, (UnivariateDifferentiableFunction) f); for (int maxOrder = 0; maxOrder < 6; ++maxOrder) { double max = 0; for (int i = 0; i < 10; i++) { final double x = lo + random.nextDouble() * (hi - lo); final DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x); max = FastMath.max(max, FastMath.abs(dsX.getPartialDerivative(maxOrder) - id.value(dsX).getPartialDerivative(maxOrder))); Assert.assertEquals(dsX.getPartialDerivative(maxOrder), id.value(dsX).getPartialDerivative(maxOrder), epsilon[maxOrder]); } // each function evaluates correctly near boundaries, // but combination leads to NaN as some intermediate point is infinite final DerivativeStructure dsLo = new DerivativeStructure(1, maxOrder, 0, lo); if (maxOrder == 0) { Assert.assertTrue(Double.isInfinite(f.value(dsLo).getPartialDerivative(maxOrder))); Assert.assertEquals(lo, id.value(dsLo).getPartialDerivative(maxOrder), epsilon[maxOrder]); } else if (maxOrder == 1) { Assert.assertTrue(Double.isInfinite(f.value(dsLo).getPartialDerivative(maxOrder))); Assert.assertTrue(Double.isNaN(id.value(dsLo).getPartialDerivative(maxOrder))); } else { Assert.assertTrue(Double.isNaN(f.value(dsLo).getPartialDerivative(maxOrder))); Assert.assertTrue(Double.isNaN(id.value(dsLo).getPartialDerivative(maxOrder))); } final DerivativeStructure dsHi = new DerivativeStructure(1, maxOrder, 0, hi); if (maxOrder == 0) { Assert.assertTrue(Double.isInfinite(f.value(dsHi).getPartialDerivative(maxOrder))); Assert.assertEquals(hi, id.value(dsHi).getPartialDerivative(maxOrder), epsilon[maxOrder]); } else if (maxOrder == 1) { Assert.assertTrue(Double.isInfinite(f.value(dsHi).getPartialDerivative(maxOrder))); Assert.assertTrue(Double.isNaN(id.value(dsHi).getPartialDerivative(maxOrder))); } else { Assert.assertTrue(Double.isNaN(f.value(dsHi).getPartialDerivative(maxOrder))); Assert.assertTrue(Double.isNaN(id.value(dsHi).getPartialDerivative(maxOrder))); } } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.function; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.differentiation.DerivativeStructure; import org.apache.commons.math3.exception.NullArgumentException; import org.apache.commons.math3.exception.DimensionMismatchException; import org.junit.Assert; import org.junit.Test; /** * Test for class {@link Sigmoid}. */ public class SigmoidTest { private final double EPS = Math.ulp(1d); @Test public void testSomeValues() { final UnivariateFunction f = new Sigmoid(); Assert.assertEquals(0.5, f.value(0), EPS); Assert.assertEquals(0, f.value(Double.NEGATIVE_INFINITY), EPS); Assert.assertEquals(1, f.value(Double.POSITIVE_INFINITY), EPS); } @Test public void testDerivative() { final Sigmoid f = new Sigmoid(); final DerivativeStructure f0 = f.value(new DerivativeStructure(1, 1, 0, 0.0)); Assert.assertEquals(0.25, f0.getPartialDerivative(1), 0); } @Test public void testDerivativesHighOrder() { DerivativeStructure s = new Sigmoid(1, 3).value(new DerivativeStructure(1, 5, 0, 1.2)); Assert.assertEquals(2.5370495669980352859, s.getPartialDerivative(0), 5.0e-16); Assert.assertEquals(0.35578888129361140441, s.getPartialDerivative(1), 6.0e-17); Assert.assertEquals(-0.19107626464144938116, s.getPartialDerivative(2), 6.0e-17); Assert.assertEquals(-0.02396830286286711696, s.getPartialDerivative(3), 4.0e-17); Assert.assertEquals(0.21682059798981049049, s.getPartialDerivative(4), 3.0e-17); Assert.assertEquals(-0.19186320234632658055, s.getPartialDerivative(5), 2.0e-16); } @Test public void testDerivativeLargeArguments() { final Sigmoid f = new Sigmoid(1, 2); Assert.assertEquals(0, f.value(new DerivativeStructure(1, 1, 0, Double.NEGATIVE_INFINITY)).getPartialDerivative(1), 0); Assert.assertEquals(0, f.value(new DerivativeStructure(1, 1, 0, -Double.MAX_VALUE)).getPartialDerivative(1), 0); Assert.assertEquals(0, f.value(new DerivativeStructure(1, 1, 0, -1e50)).getPartialDerivative(1), 0); Assert.assertEquals(0, f.value(new DerivativeStructure(1, 1, 0, -1e3)).getPartialDerivative(1), 0); Assert.assertEquals(0, f.value(new DerivativeStructure(1, 1, 0, 1e3)).getPartialDerivative(1), 0); Assert.assertEquals(0, f.value(new DerivativeStructure(1, 1, 0, 1e50)).getPartialDerivative(1), 0); Assert.assertEquals(0, f.value(new DerivativeStructure(1, 1, 0, Double.MAX_VALUE)).getPartialDerivative(1), 0); Assert.assertEquals(0, f.value(new DerivativeStructure(1, 1, 0, Double.POSITIVE_INFINITY)).getPartialDerivative(1), 0); } @Test(expected=NullArgumentException.class) public void testParametricUsage1() { final Sigmoid.Parametric g = new Sigmoid.Parametric(); g.value(0, null); } @Test(expected=DimensionMismatchException.class) public void testParametricUsage2() { final Sigmoid.Parametric g = new Sigmoid.Parametric(); g.value(0, new double[] {0}); } @Test(expected=NullArgumentException.class) public void testParametricUsage3() { final Sigmoid.Parametric g = new Sigmoid.Parametric(); g.gradient(0, null); } @Test(expected=DimensionMismatchException.class) public void testParametricUsage4() { final Sigmoid.Parametric g = new Sigmoid.Parametric(); g.gradient(0, new double[] {0}); } @Test public void testParametricValue() { final double lo = 2; final double hi = 3; final Sigmoid f = new Sigmoid(lo, hi); final Sigmoid.Parametric g = new Sigmoid.Parametric(); Assert.assertEquals(f.value(-1), g.value(-1, new double[] {lo, hi}), 0); Assert.assertEquals(f.value(0), g.value(0, new double[] {lo, hi}), 0); Assert.assertEquals(f.value(2), g.value(2, new double[] {lo, hi}), 0); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.function; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.differentiation.DerivativeStructure; import org.apache.commons.math3.dfp.Dfp; import org.apache.commons.math3.dfp.DfpField; import org.apache.commons.math3.dfp.DfpMath; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class SincTest { @Test public void testShortcut() { final Sinc s = new Sinc(); final UnivariateFunction f = new UnivariateFunction() { public double value(double x) { Dfp dfpX = new DfpField(25).newDfp(x); return DfpMath.sin(dfpX).divide(dfpX).toDouble(); } }; for (double x = 1e-30; x < 1e10; x *= 2) { final double fX = f.value(x); final double sX = s.value(x); Assert.assertEquals("x=" + x, fX, sX, 2.0e-16); } } @Test public void testCrossings() { final Sinc s = new Sinc(true); final int numCrossings = 1000; final double tol = 2e-16; for (int i = 1; i <= numCrossings; i++) { Assert.assertEquals("i=" + i, 0, s.value(i), tol); } } @Test public void testZero() { final Sinc s = new Sinc(); Assert.assertEquals(1d, s.value(0), 0); } @Test public void testEuler() { final Sinc s = new Sinc(); final double x = 123456.789; double prod = 1; double xOverPow2 = x / 2; while (xOverPow2 > 0) { prod *= FastMath.cos(xOverPow2); xOverPow2 /= 2; } Assert.assertEquals(prod, s.value(x), 1e-13); } @Test public void testDerivativeZero() { final DerivativeStructure s0 = new Sinc(true).value(new DerivativeStructure(1, 1, 0, 0.0)); Assert.assertEquals(0, s0.getPartialDerivative(1), 0); } @Test public void testDerivatives1Dot2Unnormalized() { DerivativeStructure s = new Sinc(false).value(new DerivativeStructure(1, 5, 0, 1.2)); Assert.assertEquals( 0.77669923830602195806, s.getPartialDerivative(0), 1.0e-16); Assert.assertEquals(-0.34528456985779031701, s.getPartialDerivative(1), 1.0e-16); Assert.assertEquals(-0.2012249552097047631, s.getPartialDerivative(2), 1.0e-16); Assert.assertEquals( 0.2010975926270339262, s.getPartialDerivative(3), 4.0e-16); Assert.assertEquals( 0.106373929549242204, s.getPartialDerivative(4), 1.0e-15); Assert.assertEquals(-0.1412599110579478695, s.getPartialDerivative(5), 3.0e-15); } @Test public void testDerivatives1Dot2Normalized() { DerivativeStructure s = new Sinc(true).value(new DerivativeStructure(1, 5, 0, 1.2)); Assert.assertEquals(-0.15591488063143983888, s.getPartialDerivative(0), 6.0e-17); Assert.assertEquals(-0.54425176145292298767, s.getPartialDerivative(1), 2.0e-16); Assert.assertEquals(2.4459044611635856107, s.getPartialDerivative(2), 9.0e-16); Assert.assertEquals(0.5391369206235909586, s.getPartialDerivative(3), 7.0e-16); Assert.assertEquals(-16.984649869728849865, s.getPartialDerivative(4), 8.0e-15); Assert.assertEquals(5.0980327462666316586, s.getPartialDerivative(5), 9.0e-15); } @Test public void testDerivativeShortcut() { final Sinc sinc = new Sinc(); final UnivariateFunction f = new UnivariateFunction() { public double value(double x) { Dfp dfpX = new DfpField(25).newDfp(x); return DfpMath.cos(dfpX).subtract(DfpMath.sin(dfpX).divide(dfpX)).divide(dfpX).toDouble(); } }; for (double x = 1e-30; x < 1e10; x *= 2) { final double fX = f.value(x); final DerivativeStructure sX = sinc.value(new DerivativeStructure(1, 1, 0, x)); Assert.assertEquals("x=" + x, fX, sX.getPartialDerivative(1), 3.0e-13); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.function; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.differentiation.DerivativeStructure; import org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction; import org.apache.commons.math3.util.FastMath; import org.junit.Test; import org.junit.Assert; public class SqrtTest { @Test public void testComparison() { final Sqrt s = new Sqrt(); final UnivariateFunction f = new UnivariateFunction() { public double value(double x) { return Math.sqrt(x); } }; for (double x = 1e-30; x < 1e10; x *= 2) { final double fX = f.value(x); final double sX = s.value(x); Assert.assertEquals("x=" + x, fX, sX, 0); } } @Test public void testDerivativeComparison() { final UnivariateDifferentiableFunction sPrime = new Sqrt(); final UnivariateFunction f = new UnivariateFunction() { public double value(double x) { return 1 / (2 * Math.sqrt(x)); } }; for (double x = 1e-30; x < 1e10; x *= 2) { final double fX = f.value(x); final double sX = sPrime.value(new DerivativeStructure(1, 1, 0, x)).getPartialDerivative(1); Assert.assertEquals("x=" + x, fX, sX, FastMath.ulp(fX)); } } @Test public void testDerivativesHighOrder() { DerivativeStructure s = new Sqrt().value(new DerivativeStructure(1, 5, 0, 1.2)); Assert.assertEquals(1.0954451150103322269, s.getPartialDerivative(0), 1.0e-16); Assert.assertEquals(0.45643546458763842789, s.getPartialDerivative(1), 1.0e-16); Assert.assertEquals(-0.1901814435781826783, s.getPartialDerivative(2), 1.0e-16); Assert.assertEquals(0.23772680447272834785, s.getPartialDerivative(3), 1.0e-16); Assert.assertEquals(-0.49526417598485072465, s.getPartialDerivative(4), 1.0e-16); Assert.assertEquals(1.4445205132891479465, s.getPartialDerivative(5), 5.0e-16); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.function; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.NonMonotonicSequenceException; import org.apache.commons.math3.exception.NullArgumentException; import org.apache.commons.math3.exception.NoDataException; import org.junit.Assert; import org.junit.Test; /** * Test for class {@link StepFunction}. */ public class StepFunctionTest { private final double EPS = Math.ulp(1d); @Test(expected=NullArgumentException.class) public void testPreconditions1() { new StepFunction(null, new double[] {0, -1, -2}); } @Test(expected=NullArgumentException.class) public void testPreconditions2() { new StepFunction(new double[] {0, 1}, null); } @Test(expected=NoDataException.class) public void testPreconditions3() { new StepFunction(new double[] {0}, new double[] {}); } @Test(expected=NoDataException.class) public void testPreconditions4() { new StepFunction(new double[] {}, new double[] {0}); } @Test(expected=DimensionMismatchException.class) public void testPreconditions5() { new StepFunction(new double[] {0, 1}, new double[] {0, -1, -2}); } @Test(expected=NonMonotonicSequenceException.class) public void testPreconditions6() { new StepFunction(new double[] {1, 0, 1}, new double[] {0, -1, -2}); } @Test public void testSomeValues() { final double[] x = { -2, -0.5, 0, 1.9, 7.4, 21.3 }; final double[] y = { 4, -1, -5.5, 0.4, 5.8, 51.2 }; final UnivariateFunction f = new StepFunction(x, y); Assert.assertEquals(4, f.value(Double.NEGATIVE_INFINITY), EPS); Assert.assertEquals(4, f.value(-10), EPS); Assert.assertEquals(-1, f.value(-0.4), EPS); Assert.assertEquals(-5.5, f.value(0), EPS); Assert.assertEquals(0.4, f.value(2), EPS); Assert.assertEquals(5.8, f.value(10), EPS); Assert.assertEquals(51.2, f.value(30), EPS); Assert.assertEquals(51.2, f.value(Double.POSITIVE_INFINITY), EPS); } @Test public void testEndpointBehavior() { final double[] x = {0, 1, 2, 3}; final double[] xp = {-8, 1, 2, 3}; final double[] y = {1, 2, 3, 4}; final UnivariateFunction f = new StepFunction(x, y); final UnivariateFunction fp = new StepFunction(xp, y); Assert.assertEquals(f.value(-8), fp.value(-8), EPS); Assert.assertEquals(f.value(-10), fp.value(-10), EPS); Assert.assertEquals(f.value(0), fp.value(0), EPS); Assert.assertEquals(f.value(0.5), fp.value(0.5), EPS); for (int i = 0; i < x.length; i++) { Assert.assertEquals(y[i], f.value(x[i]), EPS); if (i > 0) { Assert.assertEquals(y[i - 1], f.value(x[i] - 0.5), EPS); } else { Assert.assertEquals(y[0], f.value(x[i] - 0.5), EPS); } } } @Test public void testHeaviside() { final UnivariateFunction h = new StepFunction(new double[] {-1, 0}, new double[] {0, 1}); Assert.assertEquals(0, h.value(Double.NEGATIVE_INFINITY), 0); Assert.assertEquals(0, h.value(-Double.MAX_VALUE), 0); Assert.assertEquals(0, h.value(-2), 0); Assert.assertEquals(0, h.value(-Double.MIN_VALUE), 0); Assert.assertEquals(1, h.value(0), 0); Assert.assertEquals(1, h.value(2), 0); Assert.assertEquals(1, h.value(Double.POSITIVE_INFINITY), 0); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.integration; import java.util.Random; import org.apache.commons.math3.analysis.QuinticFunction; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.function.Sin; import org.apache.commons.math3.analysis.function.Gaussian; import org.apache.commons.math3.analysis.polynomials.PolynomialFunction; import org.apache.commons.math3.exception.TooManyEvaluationsException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class IterativeLegendreGaussIntegratorTest { @Test public void testSinFunction() { UnivariateFunction f = new Sin(); BaseAbstractUnivariateIntegrator integrator = new IterativeLegendreGaussIntegrator(5, 1.0e-14, 1.0e-10, 2, 15); double min, max, expected, result, tolerance; min = 0; max = FastMath.PI; expected = 2; tolerance = FastMath.max(integrator.getAbsoluteAccuracy(), FastMath.abs(expected * integrator.getRelativeAccuracy())); result = integrator.integrate(10000, f, min, max); Assert.assertEquals(expected, result, tolerance); min = -FastMath.PI/3; max = 0; expected = -0.5; tolerance = FastMath.max(integrator.getAbsoluteAccuracy(), FastMath.abs(expected * integrator.getRelativeAccuracy())); result = integrator.integrate(10000, f, min, max); Assert.assertEquals(expected, result, tolerance); } @Test public void testQuinticFunction() { UnivariateFunction f = new QuinticFunction(); UnivariateIntegrator integrator = new IterativeLegendreGaussIntegrator(3, BaseAbstractUnivariateIntegrator.DEFAULT_RELATIVE_ACCURACY, BaseAbstractUnivariateIntegrator.DEFAULT_ABSOLUTE_ACCURACY, BaseAbstractUnivariateIntegrator.DEFAULT_MIN_ITERATIONS_COUNT, 64); double min, max, expected, result; min = 0; max = 1; expected = -1.0/48; result = integrator.integrate(10000, f, min, max); Assert.assertEquals(expected, result, 1.0e-16); min = 0; max = 0.5; expected = 11.0/768; result = integrator.integrate(10000, f, min, max); Assert.assertEquals(expected, result, 1.0e-16); min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48; result = integrator.integrate(10000, f, min, max); Assert.assertEquals(expected, result, 1.0e-16); } @Test public void testExactIntegration() { Random random = new Random(86343623467878363l); for (int n = 2; n < 6; ++n) { IterativeLegendreGaussIntegrator integrator = new IterativeLegendreGaussIntegrator(n, BaseAbstractUnivariateIntegrator.DEFAULT_RELATIVE_ACCURACY, BaseAbstractUnivariateIntegrator.DEFAULT_ABSOLUTE_ACCURACY, BaseAbstractUnivariateIntegrator.DEFAULT_MIN_ITERATIONS_COUNT, 64); // an n points Gauss-Legendre integrator integrates 2n-1 degree polynoms exactly for (int degree = 0; degree <= 2 * n - 1; ++degree) { for (int i = 0; i < 10; ++i) { double[] coeff = new double[degree + 1]; for (int k = 0; k < coeff.length; ++k) { coeff[k] = 2 * random.nextDouble() - 1; } PolynomialFunction p = new PolynomialFunction(coeff); double result = integrator.integrate(10000, p, -5.0, 15.0); double reference = exactIntegration(p, -5.0, 15.0); Assert.assertEquals(n + " " + degree + " " + i, reference, result, 1.0e-12 * (1.0 + FastMath.abs(reference))); } } } } // Cf. MATH-995 @Test public void testNormalDistributionWithLargeSigma() { final double sigma = 1000; final double mean = 0; final double factor = 1 / (sigma * FastMath.sqrt(2 * FastMath.PI)); final UnivariateFunction normal = new Gaussian(factor, mean, sigma); final double tol = 1e-2; final IterativeLegendreGaussIntegrator integrator = new IterativeLegendreGaussIntegrator(5, tol, tol); final double a = -5000; final double b = 5000; final double s = integrator.integrate(50, normal, a, b); Assert.assertEquals(1, s, 1e-5); } @Test public void testIssue464() { final double value = 0.2; UnivariateFunction f = new UnivariateFunction() { public double value(double x) { return (x >= 0 && x <= 5) ? value : 0.0; } }; IterativeLegendreGaussIntegrator gauss = new IterativeLegendreGaussIntegrator(5, 3, 100); // due to the discontinuity, integration implies *many* calls double maxX = 0.32462367623786328; Assert.assertEquals(maxX * value, gauss.integrate(Integer.MAX_VALUE, f, -10, maxX), 1.0e-7); Assert.assertTrue(gauss.getEvaluations() > 37000000); Assert.assertTrue(gauss.getIterations() < 30); // setting up limits prevents such large number of calls try { gauss.integrate(1000, f, -10, maxX); Assert.fail("expected TooManyEvaluationsException"); } catch (TooManyEvaluationsException tmee) { // expected Assert.assertEquals(1000, tmee.getMax()); } // integrating on the two sides should be simpler double sum1 = gauss.integrate(1000, f, -10, 0); int eval1 = gauss.getEvaluations(); double sum2 = gauss.integrate(1000, f, 0, maxX); int eval2 = gauss.getEvaluations(); Assert.assertEquals(maxX * value, sum1 + sum2, 1.0e-7); Assert.assertTrue(eval1 + eval2 < 200); } private double exactIntegration(PolynomialFunction p, double a, double b) { final double[] coeffs = p.getCoefficients(); double yb = coeffs[coeffs.length - 1] / coeffs.length; double ya = yb; for (int i = coeffs.length - 2; i >= 0; --i) { yb = yb * b + coeffs[i] / (i + 1); ya = ya * a + coeffs[i] / (i + 1); } return yb * b - ya * a; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.integration; import java.util.Random; import org.apache.commons.math3.analysis.QuinticFunction; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.function.Sin; import org.apache.commons.math3.analysis.polynomials.PolynomialFunction; import org.apache.commons.math3.exception.TooManyEvaluationsException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; @Deprecated public class LegendreGaussIntegratorTest { @Test public void testSinFunction() { UnivariateFunction f = new Sin(); BaseAbstractUnivariateIntegrator integrator = new LegendreGaussIntegrator(5, 1.0e-14, 1.0e-10, 2, 15); double min, max, expected, result, tolerance; min = 0; max = FastMath.PI; expected = 2; tolerance = FastMath.max(integrator.getAbsoluteAccuracy(), FastMath.abs(expected * integrator.getRelativeAccuracy())); result = integrator.integrate(10000, f, min, max); Assert.assertEquals(expected, result, tolerance); min = -FastMath.PI/3; max = 0; expected = -0.5; tolerance = FastMath.max(integrator.getAbsoluteAccuracy(), FastMath.abs(expected * integrator.getRelativeAccuracy())); result = integrator.integrate(10000, f, min, max); Assert.assertEquals(expected, result, tolerance); } @Test public void testQuinticFunction() { UnivariateFunction f = new QuinticFunction(); UnivariateIntegrator integrator = new LegendreGaussIntegrator(3, BaseAbstractUnivariateIntegrator.DEFAULT_RELATIVE_ACCURACY, BaseAbstractUnivariateIntegrator.DEFAULT_ABSOLUTE_ACCURACY, BaseAbstractUnivariateIntegrator.DEFAULT_MIN_ITERATIONS_COUNT, 64); double min, max, expected, result; min = 0; max = 1; expected = -1.0/48; result = integrator.integrate(10000, f, min, max); Assert.assertEquals(expected, result, 1.0e-16); min = 0; max = 0.5; expected = 11.0/768; result = integrator.integrate(10000, f, min, max); Assert.assertEquals(expected, result, 1.0e-16); min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48; result = integrator.integrate(10000, f, min, max); Assert.assertEquals(expected, result, 1.0e-16); } @Test public void testExactIntegration() { Random random = new Random(86343623467878363l); for (int n = 2; n < 6; ++n) { LegendreGaussIntegrator integrator = new LegendreGaussIntegrator(n, BaseAbstractUnivariateIntegrator.DEFAULT_RELATIVE_ACCURACY, BaseAbstractUnivariateIntegrator.DEFAULT_ABSOLUTE_ACCURACY, BaseAbstractUnivariateIntegrator.DEFAULT_MIN_ITERATIONS_COUNT, 64); // an n points Gauss-Legendre integrator integrates 2n-1 degree polynoms exactly for (int degree = 0; degree <= 2 * n - 1; ++degree) { for (int i = 0; i < 10; ++i) { double[] coeff = new double[degree + 1]; for (int k = 0; k < coeff.length; ++k) { coeff[k] = 2 * random.nextDouble() - 1; } PolynomialFunction p = new PolynomialFunction(coeff); double result = integrator.integrate(10000, p, -5.0, 15.0); double reference = exactIntegration(p, -5.0, 15.0); Assert.assertEquals(n + " " + degree + " " + i, reference, result, 1.0e-12 * (1.0 + FastMath.abs(reference))); } } } } @Test public void testIssue464() { final double value = 0.2; UnivariateFunction f = new UnivariateFunction() { public double value(double x) { return (x >= 0 && x <= 5) ? value : 0.0; } }; LegendreGaussIntegrator gauss = new LegendreGaussIntegrator(5, 3, 100); // due to the discontinuity, integration implies *many* calls double maxX = 0.32462367623786328; Assert.assertEquals(maxX * value, gauss.integrate(Integer.MAX_VALUE, f, -10, maxX), 1.0e-7); Assert.assertTrue(gauss.getEvaluations() > 37000000); Assert.assertTrue(gauss.getIterations() < 30); // setting up limits prevents such large number of calls try { gauss.integrate(1000, f, -10, maxX); Assert.fail("expected TooManyEvaluationsException"); } catch (TooManyEvaluationsException tmee) { // expected Assert.assertEquals(1000, tmee.getMax()); } // integrating on the two sides should be simpler double sum1 = gauss.integrate(1000, f, -10, 0); int eval1 = gauss.getEvaluations(); double sum2 = gauss.integrate(1000, f, 0, maxX); int eval2 = gauss.getEvaluations(); Assert.assertEquals(maxX * value, sum1 + sum2, 1.0e-7); Assert.assertTrue(eval1 + eval2 < 200); } private double exactIntegration(PolynomialFunction p, double a, double b) { final double[] coeffs = p.getCoefficients(); double yb = coeffs[coeffs.length - 1] / coeffs.length; double ya = yb; for (int i = coeffs.length - 2; i >= 0; --i) { yb = yb * b + coeffs[i] / (i + 1); ya = ya * a + coeffs[i] / (i + 1); } return yb * b - ya * a; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.integration; import org.apache.commons.math3.analysis.QuinticFunction; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.function.Sin; import org.apache.commons.math3.exception.NumberIsTooLargeException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * Test case for midpoint integrator. * <p> * Test runs show that for a default relative accuracy of 1E-6, it generally * takes 10 to 15 iterations for the integral to converge. * * @version $Id: MidPointIntegratorTest.java 1374632 2012-08-18 18:11:11Z luc $ */ public final class MidPointIntegratorTest { /** * Test of integrator for the sine function. */ @Test public void testLowAccuracy() { UnivariateFunction f = new QuinticFunction(); UnivariateIntegrator integrator = new MidPointIntegrator(0.01, 1.0e-10, 2, 4); double min = -10; double max = -9; double expected = -3697001.0 / 48.0; double tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy()); double result = integrator.integrate(Integer.MAX_VALUE, f, min, max); Assert.assertTrue(integrator.getEvaluations() < Integer.MAX_VALUE / 2); Assert.assertTrue(integrator.getIterations() < MidPointIntegrator.MIDPOINT_MAX_ITERATIONS_COUNT / 2); Assert.assertEquals(expected, result, tolerance); } /** * Test of integrator for the sine function. */ @Test public void testSinFunction() { UnivariateFunction f = new Sin(); UnivariateIntegrator integrator = new MidPointIntegrator(); double min = 0; double max = FastMath.PI; double expected = 2; double tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy()); double result = integrator.integrate(Integer.MAX_VALUE, f, min, max); Assert.assertTrue(integrator.getEvaluations() < Integer.MAX_VALUE / 2); Assert.assertTrue(integrator.getIterations() < MidPointIntegrator.MIDPOINT_MAX_ITERATIONS_COUNT / 2); Assert.assertEquals(expected, result, tolerance); min = -FastMath.PI/3; max = 0; expected = -0.5; tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy()); result = integrator.integrate(Integer.MAX_VALUE, f, min, max); Assert.assertTrue(integrator.getEvaluations() < Integer.MAX_VALUE / 2); Assert.assertTrue(integrator.getIterations() < MidPointIntegrator.MIDPOINT_MAX_ITERATIONS_COUNT / 2); Assert.assertEquals(expected, result, tolerance); } /** * Test of integrator for the quintic function. */ @Test public void testQuinticFunction() { UnivariateFunction f = new QuinticFunction(); UnivariateIntegrator integrator = new MidPointIntegrator(); double min = 0; double max = 1; double expected = -1.0 / 48; double tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy()); double result = integrator.integrate(Integer.MAX_VALUE, f, min, max); Assert.assertTrue(integrator.getEvaluations() < Integer.MAX_VALUE / 2); Assert.assertTrue(integrator.getIterations() < MidPointIntegrator.MIDPOINT_MAX_ITERATIONS_COUNT / 2); Assert.assertEquals(expected, result, tolerance); min = 0; max = 0.5; expected = 11.0 / 768; tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy()); result = integrator.integrate(Integer.MAX_VALUE, f, min, max); Assert.assertTrue(integrator.getEvaluations() < Integer.MAX_VALUE / 2); Assert.assertTrue(integrator.getIterations() < MidPointIntegrator.MIDPOINT_MAX_ITERATIONS_COUNT / 2); Assert.assertEquals(expected, result, tolerance); min = -1; max = 4; expected = 2048 / 3.0 - 78 + 1.0 / 48; tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy()); result = integrator.integrate(Integer.MAX_VALUE, f, min, max); Assert.assertTrue(integrator.getEvaluations() < Integer.MAX_VALUE / 2); Assert.assertTrue(integrator.getIterations() < MidPointIntegrator.MIDPOINT_MAX_ITERATIONS_COUNT / 2); Assert.assertEquals(expected, result, tolerance); } /** * Test of parameters for the integrator. */ @Test public void testParameters() { UnivariateFunction f = new Sin(); try { // bad interval new MidPointIntegrator().integrate(1000, f, 1, -1); Assert.fail("Expecting NumberIsTooLargeException - bad interval"); } catch (NumberIsTooLargeException ex) { // expected } try { // bad iteration limits new MidPointIntegrator(5, 4); Assert.fail("Expecting NumberIsTooSmallException - bad iteration limits"); } catch (NumberIsTooSmallException ex) { // expected } try { // bad iteration limits new MidPointIntegrator(10, 99); Assert.fail("Expecting NumberIsTooLargeException - bad iteration limits"); } catch (NumberIsTooLargeException ex) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.integration; import org.apache.commons.math3.analysis.QuinticFunction; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.function.Sin; import org.apache.commons.math3.exception.NumberIsTooLargeException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * Test case for Romberg integrator. * <p> * Romberg algorithm is very fast for good behavior integrand. Test runs * show that for a default relative accuracy of 1E-6, it generally takes * takes less than 5 iterations for the integral to converge. * * @version $Id$ */ public final class RombergIntegratorTest { /** * Test of integrator for the sine function. */ @Test public void testSinFunction() { UnivariateFunction f = new Sin(); UnivariateIntegrator integrator = new RombergIntegrator(); double min, max, expected, result, tolerance; min = 0; max = FastMath.PI; expected = 2; tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy()); result = integrator.integrate(100, f, min, max); Assert.assertTrue(integrator.getEvaluations() < 50); Assert.assertTrue(integrator.getIterations() < 10); Assert.assertEquals(expected, result, tolerance); min = -FastMath.PI/3; max = 0; expected = -0.5; tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy()); result = integrator.integrate(100, f, min, max); Assert.assertTrue(integrator.getEvaluations() < 50); Assert.assertTrue(integrator.getIterations() < 10); Assert.assertEquals(expected, result, tolerance); } /** * Test of integrator for the quintic function. */ @Test public void testQuinticFunction() { UnivariateFunction f = new QuinticFunction(); UnivariateIntegrator integrator = new RombergIntegrator(); double min, max, expected, result, tolerance; min = 0; max = 1; expected = -1.0/48; tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy()); result = integrator.integrate(100, f, min, max); Assert.assertTrue(integrator.getEvaluations() < 10); Assert.assertTrue(integrator.getIterations() < 5); Assert.assertEquals(expected, result, tolerance); min = 0; max = 0.5; expected = 11.0/768; tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy()); result = integrator.integrate(100, f, min, max); Assert.assertTrue(integrator.getEvaluations() < 10); Assert.assertTrue(integrator.getIterations() < 5); Assert.assertEquals(expected, result, tolerance); min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48; tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy()); result = integrator.integrate(100, f, min, max); Assert.assertTrue(integrator.getEvaluations() < 10); Assert.assertTrue(integrator.getIterations() < 5); Assert.assertEquals(expected, result, tolerance); } /** * Test of parameters for the integrator. */ @Test public void testParameters() { UnivariateFunction f = new Sin(); try { // bad interval new RombergIntegrator().integrate(1000, f, 1, -1); Assert.fail("Expecting NumberIsTooLargeException - bad interval"); } catch (NumberIsTooLargeException ex) { // expected } try { // bad iteration limits new RombergIntegrator(5, 4); Assert.fail("Expecting NumberIsTooSmallException - bad iteration limits"); } catch (NumberIsTooSmallException ex) { // expected } try { // bad iteration limits new RombergIntegrator(10, 50); Assert.fail("Expecting NumberIsTooLargeException - bad iteration limits"); } catch (NumberIsTooLargeException ex) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.integration; import org.apache.commons.math3.analysis.QuinticFunction; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.function.Sin; import org.apache.commons.math3.exception.NumberIsTooLargeException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * Test case for Simpson integrator. * <p> * Test runs show that for a default relative accuracy of 1E-6, it * generally takes 5 to 10 iterations for the integral to converge. * * @version $Id$ */ public final class SimpsonIntegratorTest { /** * Test of integrator for the sine function. */ @Test public void testSinFunction() { UnivariateFunction f = new Sin(); UnivariateIntegrator integrator = new SimpsonIntegrator(); double min, max, expected, result, tolerance; min = 0; max = FastMath.PI; expected = 2; tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy()); result = integrator.integrate(1000, f, min, max); Assert.assertTrue(integrator.getEvaluations() < 100); Assert.assertTrue(integrator.getIterations() < 10); Assert.assertEquals(expected, result, tolerance); min = -FastMath.PI/3; max = 0; expected = -0.5; tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy()); result = integrator.integrate(1000, f, min, max); Assert.assertTrue(integrator.getEvaluations() < 50); Assert.assertTrue(integrator.getIterations() < 10); Assert.assertEquals(expected, result, tolerance); } /** * Test of integrator for the quintic function. */ @Test public void testQuinticFunction() { UnivariateFunction f = new QuinticFunction(); UnivariateIntegrator integrator = new SimpsonIntegrator(); double min, max, expected, result, tolerance; min = 0; max = 1; expected = -1.0/48; tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy()); result = integrator.integrate(1000, f, min, max); Assert.assertTrue(integrator.getEvaluations() < 150); Assert.assertTrue(integrator.getIterations() < 10); Assert.assertEquals(expected, result, tolerance); min = 0; max = 0.5; expected = 11.0/768; tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy()); result = integrator.integrate(1000, f, min, max); Assert.assertTrue(integrator.getEvaluations() < 100); Assert.assertTrue(integrator.getIterations() < 10); Assert.assertEquals(expected, result, tolerance); min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48; tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy()); result = integrator.integrate(1000, f, min, max); Assert.assertTrue(integrator.getEvaluations() < 150); Assert.assertTrue(integrator.getIterations() < 10); Assert.assertEquals(expected, result, tolerance); } /** * Test of parameters for the integrator. */ @Test public void testParameters() { UnivariateFunction f = new Sin(); try { // bad interval new SimpsonIntegrator().integrate(1000, f, 1, -1); Assert.fail("Expecting NumberIsTooLargeException - bad interval"); } catch (NumberIsTooLargeException ex) { // expected } try { // bad iteration limits new SimpsonIntegrator(5, 4); Assert.fail("Expecting NumberIsTooSmallException - bad iteration limits"); } catch (NumberIsTooSmallException ex) { // expected } try { // bad iteration limits new SimpsonIntegrator(10, 99); Assert.fail("Expecting NumberIsTooLargeException - bad iteration limits"); } catch (NumberIsTooLargeException ex) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.integration; import org.apache.commons.math3.analysis.QuinticFunction; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.function.Sin; import org.apache.commons.math3.exception.NumberIsTooLargeException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * Test case for trapezoid integrator. * <p> * Test runs show that for a default relative accuracy of 1E-6, it * generally takes 10 to 15 iterations for the integral to converge. * * @version $Id$ */ public final class TrapezoidIntegratorTest { /** * Test of integrator for the sine function. */ @Test public void testSinFunction() { UnivariateFunction f = new Sin(); UnivariateIntegrator integrator = new TrapezoidIntegrator(); double min, max, expected, result, tolerance; min = 0; max = FastMath.PI; expected = 2; tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy()); result = integrator.integrate(10000, f, min, max); Assert.assertTrue(integrator.getEvaluations() < 2500); Assert.assertTrue(integrator.getIterations() < 15); Assert.assertEquals(expected, result, tolerance); min = -FastMath.PI/3; max = 0; expected = -0.5; tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy()); result = integrator.integrate(10000, f, min, max); Assert.assertTrue(integrator.getEvaluations() < 2500); Assert.assertTrue(integrator.getIterations() < 15); Assert.assertEquals(expected, result, tolerance); } /** * Test of integrator for the quintic function. */ @Test public void testQuinticFunction() { UnivariateFunction f = new QuinticFunction(); UnivariateIntegrator integrator = new TrapezoidIntegrator(); double min, max, expected, result, tolerance; min = 0; max = 1; expected = -1.0/48; tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy()); result = integrator.integrate(10000, f, min, max); Assert.assertTrue(integrator.getEvaluations() < 5000); Assert.assertTrue(integrator.getIterations() < 15); Assert.assertEquals(expected, result, tolerance); min = 0; max = 0.5; expected = 11.0/768; tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy()); result = integrator.integrate(10000, f, min, max); Assert.assertTrue(integrator.getEvaluations() < 2500); Assert.assertTrue(integrator.getIterations() < 15); Assert.assertEquals(expected, result, tolerance); min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48; tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy()); result = integrator.integrate(10000, f, min, max); Assert.assertTrue(integrator.getEvaluations() < 5000); Assert.assertTrue(integrator.getIterations() < 15); Assert.assertEquals(expected, result, tolerance); } /** * Test of parameters for the integrator. */ @Test public void testParameters() { UnivariateFunction f = new Sin(); try { // bad interval new TrapezoidIntegrator().integrate(1000, f, 1, -1); Assert.fail("Expecting NumberIsTooLargeException - bad interval"); } catch (NumberIsTooLargeException ex) { // expected } try { // bad iteration limits new TrapezoidIntegrator(5, 4); Assert.fail("Expecting NumberIsTooSmallException - bad iteration limits"); } catch (NumberIsTooSmallException ex) { // expected } try { // bad iteration limits new TrapezoidIntegrator(10,99); Assert.fail("Expecting NumberIsTooLargeException - bad iteration limits"); } catch (NumberIsTooLargeException ex) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.integration.gauss; import java.util.List; import java.util.ArrayList; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.TimeUnit; import java.util.concurrent.Callable; import java.util.concurrent.Future; import java.util.concurrent.ExecutionException; import java.util.concurrent.atomic.AtomicInteger; import org.apache.commons.math3.util.Pair; import org.junit.Test; import org.junit.Assert; /** * Test for {@link BaseRuleFactory}. * * @version $Id$ */ public class BaseRuleFactoryTest { /** * Tests that a given rule rule will be computed and added once to the cache * whatever the number of times this rule is called concurrently. */ @Test public void testConcurrentCreation() throws InterruptedException, ExecutionException { // Number of times the same rule will be called. final int numTasks = 20; final ThreadPoolExecutor exec = new ThreadPoolExecutor(3, numTasks, 1, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(2)); final List<Future<Pair<double[], double[]>>> results = new ArrayList<Future<Pair<double[], double[]>>>(); for (int i = 0; i < numTasks; i++) { results.add(exec.submit(new RuleBuilder())); } // Ensure that all computations have completed. for (Future<Pair<double[], double[]>> f : results) { f.get(); } // Assertion would fail if "getRuleInternal" were not "synchronized". final int n = RuleBuilder.getNumberOfCalls(); Assert.assertEquals("Rule computation was called " + n + " times", 1, n); } } class RuleBuilder implements Callable<Pair<double[], double[]>> { private static final DummyRuleFactory factory = new DummyRuleFactory(); public Pair<double[], double[]> call() { final int dummy = 2; // Always request the same rule. return factory.getRule(dummy); } public static int getNumberOfCalls() { return factory.getNumberOfCalls(); } } class DummyRuleFactory extends BaseRuleFactory<Double> { /** Rule computations counter. */ private static AtomicInteger nCalls = new AtomicInteger(); @Override protected Pair<Double[], Double[]> computeRule(int order) { // Tracks whether this computation has been called more than once. nCalls.getAndIncrement(); try { // Sleep to simulate computation time. Thread.sleep(20); } catch (InterruptedException e) { Assert.fail("Unexpected interruption"); } // Dummy rule (but contents must exist). final Double[] p = new Double[order]; final Double[] w = new Double[order]; for (int i = 0; i < order; i++) { p[i] = new Double(i); w[i] = new Double(i); } return new Pair<Double[], Double[]>(p, w); } public int getNumberOfCalls() { return nCalls.get(); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.integration.gauss; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.function.Constant; import org.apache.commons.math3.util.Pair; import org.junit.Test; import org.junit.Assert; /** * Test for {@link GaussIntegrator} class. * * @version $Id$ */ public class GaussIntegratorTest { @Test public void testGetWeights() { final double[] points = { 0, 1.2, 3.4 }; final double[] weights = { 9.8, 7.6, 5.4 }; final GaussIntegrator integrator = new GaussIntegrator(new Pair<double[], double[]>(points, weights)); Assert.assertEquals(weights.length, integrator.getNumberOfPoints()); for (int i = 0; i < integrator.getNumberOfPoints(); i++) { Assert.assertEquals(weights[i], integrator.getWeight(i), 0d); } } @Test public void testGetPoints() { final double[] points = { 0, 1.2, 3.4 }; final double[] weights = { 9.8, 7.6, 5.4 }; final GaussIntegrator integrator = new GaussIntegrator(new Pair<double[], double[]>(points, weights)); Assert.assertEquals(points.length, integrator.getNumberOfPoints()); for (int i = 0; i < integrator.getNumberOfPoints(); i++) { Assert.assertEquals(points[i], integrator.getPoint(i), 0d); } } @Test public void testIntegrate() { final double[] points = { 0, 1, 2, 3, 4, 5 }; final double[] weights = { 1, 1, 1, 1, 1, 1 }; final GaussIntegrator integrator = new GaussIntegrator(new Pair<double[], double[]>(points, weights)); final double val = 123.456; final UnivariateFunction c = new Constant(val); final double s = integrator.integrate(c); Assert.assertEquals(points.length * val, s, 0d); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.integration.gauss; import java.util.ArrayList; import java.util.Collection; import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameters; import org.apache.commons.math3.util.FastMath; /** * Test of the {@link HermiteRuleFactory}. * This parameterized test extends the standard test for Gaussian quadrature * rule, where each monomial is tested in turn. * Parametrization allows to test automatically 0, 1, ... , {@link #MAX_NUM_POINTS} * quadrature rules. * * @version $Id$ */ @RunWith(value=Parameterized.class) public class HermiteParametricTest extends GaussianQuadratureAbstractTest { private static final double SQRT_PI = FastMath.sqrt(Math.PI); private static final GaussIntegratorFactory factory = new GaussIntegratorFactory(); /** * The highest order quadrature rule to be tested. */ public static final int MAX_NUM_POINTS = 30; /** * Creates a new instance of this test, with the specified number of nodes * for the Gauss-Hermite quadrature rule. * * @param numberOfPoints Order of integration rule. * @param maxDegree Maximum degree of monomials to be tested. * @param eps Value of &epsilon;. * @param numUlps Value of the maximum relative error (in ulps). */ public HermiteParametricTest(int numberOfPoints, int maxDegree, double eps, double numUlps) { super(factory.hermite(numberOfPoints), maxDegree, eps, numUlps); } /** * Returns the collection of parameters to be passed to the constructor of * this class. * Gauss-Hermite quadrature rules of order 1, ..., {@link #MAX_NUM_POINTS} * will be constructed. * * @return the collection of parameters for this parameterized test. */ @SuppressWarnings("boxing") // OK here @Parameters public static Collection<Object[]> getParameters() { final ArrayList<Object[]> parameters = new ArrayList<Object[]>(); for (int k = 1; k <= MAX_NUM_POINTS; k++) { parameters.add(new Object[] { k, 2 * k - 1, Math.ulp(1d), 195 }); } return parameters; } @Override public double getExpectedValue(final int n) { if (n % 2 == 1) { return 0; } final int iMax = n / 2; double p = 1; double q = 1; for (int i = 0; i < iMax; i++) { p *= 2 * i + 1; q *= 2; } return p / q * SQRT_PI; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.integration.gauss; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.util.FastMath; import org.junit.Test; import org.junit.Assert; /** * Test of the {@link HermiteRuleFactory}. * * @version $Id$ */ public class HermiteTest { private static final GaussIntegratorFactory factory = new GaussIntegratorFactory(); @Test public void testNormalDistribution() { final double oneOverSqrtPi = 1 / FastMath.sqrt(Math.PI); final double mu = 12345.6789; final double sigma = 987.654321; // By defintion, Gauss-Hermite quadrature readily provides the // integral of the normal distribution density. final int numPoints = 1; // Change of variable: // y = (x - mu) / (sqrt(2) * sigma) // such that the integrand // N(x, mu, sigma) // is transformed to // f(y) * exp(-y^2) final UnivariateFunction f = new UnivariateFunction() { public double value(double y) { return oneOverSqrtPi; // Constant function. } }; final GaussIntegrator integrator = factory.hermite(numPoints); final double result = integrator.integrate(f); final double expected = 1; Assert.assertEquals(expected, result, Math.ulp(expected)); } @Test public void testNormalMean() { final double sqrtTwo = FastMath.sqrt(2); final double oneOverSqrtPi = 1 / FastMath.sqrt(Math.PI); final double mu = 12345.6789; final double sigma = 987.654321; final int numPoints = 5; // Change of variable: // y = (x - mu) / (sqrt(2) * sigma) // such that the integrand // x * N(x, mu, sigma) // is transformed to // f(y) * exp(-y^2) final UnivariateFunction f = new UnivariateFunction() { public double value(double y) { return oneOverSqrtPi * (sqrtTwo * sigma * y + mu); } }; final GaussIntegrator integrator = factory.hermite(numPoints); final double result = integrator.integrate(f); final double expected = mu; Assert.assertEquals(expected, result, Math.ulp(expected)); } @Test public void testNormalVariance() { final double twoOverSqrtPi = 2 / FastMath.sqrt(Math.PI); final double mu = 12345.6789; final double sigma = 987.654321; final double sigma2 = sigma * sigma; final int numPoints = 5; // Change of variable: // y = (x - mu) / (sqrt(2) * sigma) // such that the integrand // (x - mu)^2 * N(x, mu, sigma) // is transformed to // f(y) * exp(-y^2) final UnivariateFunction f = new UnivariateFunction() { public double value(double y) { return twoOverSqrtPi * sigma2 * y * y; } }; final GaussIntegrator integrator = factory.hermite(numPoints); final double result = integrator.integrate(f); final double expected = sigma2; Assert.assertEquals(expected, result, 10 * Math.ulp(expected)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.integration.gauss; import java.util.ArrayList; import java.util.Collection; import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameters; /** * Test of the {@link LegendreHighPrecisionRuleFactory}. * This parameterized test extends the standard test for Gaussian quadrature * rule, where each monomial is tested in turn. * Parametrization allows to test automatically 0, 1, ... , {@link #MAX_NUM_POINTS} * quadrature rules. * * @version $Id$ */ @RunWith(value=Parameterized.class) public class LegendreHighPrecisionParametricTest extends GaussianQuadratureAbstractTest { private static GaussIntegratorFactory factory = new GaussIntegratorFactory(); /** * The highest order quadrature rule to be tested. */ public static final int MAX_NUM_POINTS = 30; /** * Creates a new instance of this test, with the specified number of nodes * for the Gauss-Legendre quadrature rule. * * @param numberOfPoints Order of integration rule. * @param maxDegree Maximum degree of monomials to be tested. * @param eps Value of &epsilon;. * @param numUlps Value of the maximum relative error (in ulps). */ public LegendreHighPrecisionParametricTest(int numberOfPoints, int maxDegree, double eps, double numUlps) { super(factory.legendreHighPrecision(numberOfPoints), maxDegree, eps, numUlps); } /** * Returns the collection of parameters to be passed to the constructor of * this class. * Gauss-Legendre quadrature rules of order 1, ..., {@link #MAX_NUM_POINTS} * will be constructed. * * @return the collection of parameters for this parameterized test. */ @SuppressWarnings("boxing") // OK here @Parameters public static Collection<Object[]> getParameters() { final ArrayList<Object[]> parameters = new ArrayList<Object[]>(); for (int k = 1; k <= MAX_NUM_POINTS; k++) { parameters.add(new Object[] { k, 2 * k - 1, Math.ulp(1d), 13d }); } return parameters; } @Override public double getExpectedValue(final int n) { if (n % 2 == 1) { return 0; } return 2d / (n + 1); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.integration.gauss; import org.apache.commons.math3.analysis.function.Cos; import org.apache.commons.math3.analysis.function.Inverse; import org.apache.commons.math3.analysis.function.Log; import org.apache.commons.math3.analysis.UnivariateFunction; import org.junit.Test; import org.junit.Assert; /** * Test of the {@link LegendreHighPrecisionRuleFactory}. * * @version $Id$ */ public class LegendreHighPrecisionTest { private static GaussIntegratorFactory factory = new GaussIntegratorFactory(); @Test public void testCos() { final UnivariateFunction cos = new Cos(); final GaussIntegrator integrator = factory.legendreHighPrecision(7, 0, Math.PI / 2); final double s = integrator.integrate(cos); // System.out.println("s=" + s + " e=" + 1); Assert.assertEquals(1, s, Math.ulp(1d)); } @Test public void testInverse() { final UnivariateFunction inv = new Inverse(); final UnivariateFunction log = new Log(); final double lo = 12.34; final double hi = 456.78; final GaussIntegrator integrator = factory.legendreHighPrecision(60, lo, hi); final double s = integrator.integrate(inv); final double expected = log.value(hi) - log.value(lo); // System.out.println("s=" + s + " e=" + expected); Assert.assertEquals(expected, s, 1e-15); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.integration.gauss; import java.util.ArrayList; import java.util.Collection; import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameters; /** * Test of the {@link LegendreRuleFactory}. * This parameterized test extends the standard test for Gaussian quadrature * rule, where each monomial is tested in turn. * Parametrization allows to test automatically 0, 1, ... , {@link #MAX_NUM_POINTS} * quadrature rules. * * @version $Id$ */ @RunWith(value=Parameterized.class) public class LegendreParametricTest extends GaussianQuadratureAbstractTest { private static final GaussIntegratorFactory factory = new GaussIntegratorFactory(); /** * The highest order quadrature rule to be tested. */ public static final int MAX_NUM_POINTS = 30; /** * Creates a new instance of this test, with the specified number of nodes * for the Gauss-Legendre quadrature rule. * * @param numberOfPoints Order of integration rule. * @param maxDegree Maximum degree of monomials to be tested. * @param eps Value of &epsilon;. * @param numUlps Value of the maximum relative error (in ulps). */ public LegendreParametricTest(int numberOfPoints, int maxDegree, double eps, double numUlps) { super(factory.legendre(numberOfPoints), maxDegree, eps, numUlps); } /** * Returns the collection of parameters to be passed to the constructor of * this class. * Gauss-Legendre quadrature rules of order 1, ..., {@link #MAX_NUM_POINTS} * will be constructed. * * @return the collection of parameters for this parameterized test. */ @SuppressWarnings("boxing") // OK here @Parameters public static Collection<Object[]> getParameters() { final ArrayList<Object[]> parameters = new ArrayList<Object[]>(); for (int k = 1; k <= MAX_NUM_POINTS; k++) { parameters.add(new Object[] { k, 2 * k - 1, Math.ulp(1d), 91d }); } return parameters; } @Override public double getExpectedValue(final int n) { if (n % 2 == 1) { return 0; } return 2d / (n + 1); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.integration.gauss; import org.apache.commons.math3.analysis.function.Cos; import org.apache.commons.math3.analysis.function.Inverse; import org.apache.commons.math3.analysis.function.Log; import org.apache.commons.math3.analysis.UnivariateFunction; import org.junit.Test; import org.junit.Assert; /** * Test of the {@link LegendreRuleFactory}. * * @version $Id$ */ public class LegendreTest { private static final GaussIntegratorFactory factory = new GaussIntegratorFactory(); @Test public void testCos() { final UnivariateFunction cos = new Cos(); final GaussIntegrator integrator = factory.legendre(7, 0, Math.PI / 2); final double s = integrator.integrate(cos); // System.out.println("s=" + s + " e=" + 1); Assert.assertEquals(1, s, Math.ulp(1d)); } @Test public void testInverse() { final UnivariateFunction inv = new Inverse(); final UnivariateFunction log = new Log(); final double lo = 12.34; final double hi = 456.78; final GaussIntegrator integrator = factory.legendre(60, lo, hi); final double s = integrator.integrate(inv); final double expected = log.value(hi) - log.value(lo); // System.out.println("s=" + s + " e=" + expected); Assert.assertEquals(expected, s, 1e-14); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.interpolation; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.exception.OutOfRangeException; import org.apache.commons.math3.analysis.BivariateFunction; import org.apache.commons.math3.distribution.UniformRealDistribution; import org.apache.commons.math3.random.RandomGenerator; import org.apache.commons.math3.random.Well19937c; import org.junit.Assert; import org.junit.Test; import org.junit.Ignore; /** * Test case for the bicubic function. * * @version $Id$ */ public final class BicubicSplineInterpolatingFunctionTest { /** * Test preconditions. */ @Test public void testPreconditions() { double[] xval = new double[] {3, 4, 5, 6.5}; double[] yval = new double[] {-4, -3, -1, 2.5}; double[][] zval = new double[xval.length][yval.length]; @SuppressWarnings("unused") BivariateFunction bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, zval, zval, zval); double[] wxval = new double[] {3, 2, 5, 6.5}; try { bcf = new BicubicSplineInterpolatingFunction(wxval, yval, zval, zval, zval, zval); Assert.fail("an exception should have been thrown"); } catch (MathIllegalArgumentException e) { // Expected } double[] wyval = new double[] {-4, -1, -1, 2.5}; try { bcf = new BicubicSplineInterpolatingFunction(xval, wyval, zval, zval, zval, zval); Assert.fail("an exception should have been thrown"); } catch (MathIllegalArgumentException e) { // Expected } double[][] wzval = new double[xval.length][yval.length - 1]; try { bcf = new BicubicSplineInterpolatingFunction(xval, yval, wzval, zval, zval, zval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } try { bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, wzval, zval, zval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } try { bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, zval, wzval, zval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } try { bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, zval, zval, wzval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } wzval = new double[xval.length - 1][yval.length]; try { bcf = new BicubicSplineInterpolatingFunction(xval, yval, wzval, zval, zval, zval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } try { bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, wzval, zval, zval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } try { bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, zval, wzval, zval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } try { bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, zval, zval, wzval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } } /** * Test for a plane. * <p> * z = 2 x - 3 y + 5 */ @Ignore@Test public void testPlane() { double[] xval = new double[] {3, 4, 5, 6.5}; double[] yval = new double[] {-4, -3, -1, 2, 2.5}; // Function values BivariateFunction f = new BivariateFunction() { public double value(double x, double y) { return 2 * x - 3 * y + 5; } }; double[][] zval = new double[xval.length][yval.length]; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { zval[i][j] = f.value(xval[i], yval[j]); } } // Partial derivatives with respect to x double[][] dZdX = new double[xval.length][yval.length]; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { dZdX[i][j] = 2; } } // Partial derivatives with respect to y double[][] dZdY = new double[xval.length][yval.length]; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { dZdY[i][j] = -3; } } // Partial cross-derivatives double[][] dZdXdY = new double[xval.length][yval.length]; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { dZdXdY[i][j] = 0; } } BivariateFunction bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, dZdX, dZdY, dZdXdY); double x, y; double expected, result; x = 4; y = -3; expected = f.value(x, y); result = bcf.value(x, y); Assert.assertEquals("On sample point", expected, result, 1e-15); x = 4.5; y = -1.5; expected = f.value(x, y); result = bcf.value(x, y); Assert.assertEquals("Half-way between sample points (middle of the patch)", expected, result, 0.3); x = 3.5; y = -3.5; expected = f.value(x, y); result = bcf.value(x, y); Assert.assertEquals("Half-way between sample points (border of the patch)", expected, result, 0.3); } /** * Test for a paraboloid. * <p> * z = 2 x<sup>2</sup> - 3 y<sup>2</sup> + 4 x y - 5 */ @Ignore@Test public void testParaboloid() { double[] xval = new double[] {3, 4, 5, 6.5}; double[] yval = new double[] {-4, -3, -1, 2, 2.5}; // Function values BivariateFunction f = new BivariateFunction() { public double value(double x, double y) { return 2 * x * x - 3 * y * y + 4 * x * y - 5; } }; double[][] zval = new double[xval.length][yval.length]; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { zval[i][j] = f.value(xval[i], yval[j]); } } // Partial derivatives with respect to x double[][] dZdX = new double[xval.length][yval.length]; BivariateFunction dfdX = new BivariateFunction() { public double value(double x, double y) { return 4 * (x + y); } }; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { dZdX[i][j] = dfdX.value(xval[i], yval[j]); } } // Partial derivatives with respect to y double[][] dZdY = new double[xval.length][yval.length]; BivariateFunction dfdY = new BivariateFunction() { public double value(double x, double y) { return 4 * x - 6 * y; } }; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { dZdY[i][j] = dfdY.value(xval[i], yval[j]); } } // Partial cross-derivatives double[][] dZdXdY = new double[xval.length][yval.length]; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { dZdXdY[i][j] = 4; } } BivariateFunction bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, dZdX, dZdY, dZdXdY); double x, y; double expected, result; x = 4; y = -3; expected = f.value(x, y); result = bcf.value(x, y); Assert.assertEquals("On sample point", expected, result, 1e-15); x = 4.5; y = -1.5; expected = f.value(x, y); result = bcf.value(x, y); Assert.assertEquals("Half-way between sample points (middle of the patch)", expected, result, 2); x = 3.5; y = -3.5; expected = f.value(x, y); result = bcf.value(x, y); Assert.assertEquals("Half-way between sample points (border of the patch)", expected, result, 2); } /** * Test for partial derivatives of {@link BicubicSplineFunction}. * <p> * f(x, y) = &Sigma;<sub>i</sub>&Sigma;<sub>j</sub> (i+1) (j+2) x<sup>i</sup> y<sup>j</sup> */ @Ignore@Test public void testSplinePartialDerivatives() { final int N = 4; final double[] coeff = new double[16]; for (int i = 0; i < N; i++) { for (int j = 0; j < N; j++) { coeff[i + N * j] = (i + 1) * (j + 2); } } final BicubicSplineFunction f = new BicubicSplineFunction(coeff); BivariateFunction derivative; final double x = 0.435; final double y = 0.776; final double tol = 1e-13; derivative = new BivariateFunction() { public double value(double x, double y) { final double x2 = x * x; final double y2 = y * y; final double y3 = y2 * y; final double yFactor = 2 + 3 * y + 4 * y2 + 5 * y3; return yFactor * (2 + 6 * x + 12 * x2); } }; Assert.assertEquals("dFdX", derivative.value(x, y), f.partialDerivativeX().value(x, y), tol); derivative = new BivariateFunction() { public double value(double x, double y) { final double x2 = x * x; final double x3 = x2 * x; final double y2 = y * y; final double xFactor = 1 + 2 * x + 3 * x2 + 4 * x3; return xFactor * (3 + 8 * y + 15 * y2); } }; Assert.assertEquals("dFdY", derivative.value(x, y), f.partialDerivativeY().value(x, y), tol); derivative = new BivariateFunction() { public double value(double x, double y) { final double y2 = y * y; final double y3 = y2 * y; final double yFactor = 2 + 3 * y + 4 * y2 + 5 * y3; return yFactor * (6 + 24 * x); } }; Assert.assertEquals("d2FdX2", derivative.value(x, y), f.partialDerivativeXX().value(x, y), tol); derivative = new BivariateFunction() { public double value(double x, double y) { final double x2 = x * x; final double x3 = x2 * x; final double xFactor = 1 + 2 * x + 3 * x2 + 4 * x3; return xFactor * (8 + 30 * y); } }; Assert.assertEquals("d2FdY2", derivative.value(x, y), f.partialDerivativeYY().value(x, y), tol); derivative = new BivariateFunction() { public double value(double x, double y) { final double x2 = x * x; final double y2 = y * y; final double yFactor = 3 + 8 * y + 15 * y2; return yFactor * (2 + 6 * x + 12 * x2); } }; Assert.assertEquals("d2FdXdY", derivative.value(x, y), f.partialDerivativeXY().value(x, y), tol); } /** * Test that the partial derivatives computed from a * {@link BicubicSplineInterpolatingFunction} match the input data. * <p> * f(x, y) = 5 * - 3 x + 2 y * - x y + 2 x<sup>2</sup> - 3 y<sup>2</sup> * + 4 x<sup>2</sup> y - x y<sup>2</sup> - 3 x<sup>3</sup> + y<sup>3</sup> */ @Ignore@Test public void testMatchingPartialDerivatives() { final int sz = 21; double[] val = new double[sz]; // Coordinate values final double delta = 1d / (sz - 1); for (int i = 0; i < sz; i++) { val[i] = i * delta; } // Function values BivariateFunction f = new BivariateFunction() { public double value(double x, double y) { final double x2 = x * x; final double x3 = x2 * x; final double y2 = y * y; final double y3 = y2 * y; return 5 - 3 * x + 2 * y - x * y + 2 * x2 - 3 * y2 + 4 * x2 * y - x * y2 - 3 * x3 + y3; } }; double[][] fval = new double[sz][sz]; for (int i = 0; i < sz; i++) { for (int j = 0; j < sz; j++) { fval[i][j] = f.value(val[i], val[j]); } } // Partial derivatives with respect to x double[][] dFdX = new double[sz][sz]; BivariateFunction dfdX = new BivariateFunction() { public double value(double x, double y) { final double x2 = x * x; final double y2 = y * y; return - 3 - y + 4 * x + 8 * x * y - y2 - 9 * x2; } }; for (int i = 0; i < sz; i++) { for (int j = 0; j < sz; j++) { dFdX[i][j] = dfdX.value(val[i], val[j]); } } // Partial derivatives with respect to y double[][] dFdY = new double[sz][sz]; BivariateFunction dfdY = new BivariateFunction() { public double value(double x, double y) { final double x2 = x * x; final double y2 = y * y; return 2 - x - 6 * y + 4 * x2 - 2 * x * y + 3 * y2; } }; for (int i = 0; i < sz; i++) { for (int j = 0; j < sz; j++) { dFdY[i][j] = dfdY.value(val[i], val[j]); } } // Partial cross-derivatives double[][] d2FdXdY = new double[sz][sz]; BivariateFunction d2fdXdY = new BivariateFunction() { public double value(double x, double y) { return -1 + 8 * x - 2 * y; } }; for (int i = 0; i < sz; i++) { for (int j = 0; j < sz; j++) { d2FdXdY[i][j] = d2fdXdY.value(val[i], val[j]); } } BicubicSplineInterpolatingFunction bcf = new BicubicSplineInterpolatingFunction(val, val, fval, dFdX, dFdY, d2FdXdY); double x, y; double expected, result; final double tol = 1e-12; for (int i = 0; i < sz; i++) { x = val[i]; for (int j = 0; j < sz; j++) { y = val[j]; expected = dfdX.value(x, y); result = bcf.partialDerivativeX(x, y); Assert.assertEquals(x + " " + y + " dFdX", expected, result, tol); expected = dfdY.value(x, y); result = bcf.partialDerivativeY(x, y); Assert.assertEquals(x + " " + y + " dFdY", expected, result, tol); expected = d2fdXdY.value(x, y); result = bcf.partialDerivativeXY(x, y); Assert.assertEquals(x + " " + y + " d2FdXdY", expected, result, tol); } } } /** * Interpolating a plane. * <p> * z = 2 x - 3 y + 5 */ @Test public void testInterpolation1() { final int sz = 21; double[] xval = new double[sz]; double[] yval = new double[sz]; // Coordinate values final double delta = 1d / (sz - 1); for (int i = 0; i < sz; i++) { xval[i] = -1 + 15 * i * delta; yval[i] = -20 + 30 * i * delta; } // Function values BivariateFunction f = new BivariateFunction() { public double value(double x, double y) { return 2 * x - 3 * y + 5; } }; double[][] zval = new double[xval.length][yval.length]; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { zval[i][j] = f.value(xval[i], yval[j]); } } // Partial derivatives with respect to x double[][] dZdX = new double[xval.length][yval.length]; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { dZdX[i][j] = 2; } } // Partial derivatives with respect to y double[][] dZdY = new double[xval.length][yval.length]; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { dZdY[i][j] = -3; } } // Partial cross-derivatives double[][] dZdXdY = new double[xval.length][yval.length]; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { dZdXdY[i][j] = 0; } } final BivariateFunction bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, dZdX, dZdY, dZdXdY); double x, y; final RandomGenerator rng = new Well19937c(1234567L); // "tol" depends on the seed. final UniformRealDistribution distX = new UniformRealDistribution(rng, xval[0], xval[xval.length - 1]); final UniformRealDistribution distY = new UniformRealDistribution(rng, yval[0], yval[yval.length - 1]); final int numSamples = 50; final double tol = 6; for (int i = 0; i < numSamples; i++) { x = distX.sample(); for (int j = 0; j < numSamples; j++) { y = distY.sample(); // System.out.println(x + " " + y + " " + f.value(x, y) + " " + bcf.value(x, y)); Assert.assertEquals(f.value(x, y), bcf.value(x, y), tol); } // System.out.println(); } } /** * Interpolating a paraboloid. * <p> * z = 2 x<sup>2</sup> - 3 y<sup>2</sup> + 4 x y - 5 */ @Test public void testInterpolation2() { final int sz = 21; double[] xval = new double[sz]; double[] yval = new double[sz]; // Coordinate values final double delta = 1d / (sz - 1); for (int i = 0; i < sz; i++) { xval[i] = -1 + 15 * i * delta; yval[i] = -20 + 30 * i * delta; } // Function values BivariateFunction f = new BivariateFunction() { public double value(double x, double y) { return 2 * x * x - 3 * y * y + 4 * x * y - 5; } }; double[][] zval = new double[xval.length][yval.length]; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { zval[i][j] = f.value(xval[i], yval[j]); } } // Partial derivatives with respect to x double[][] dZdX = new double[xval.length][yval.length]; BivariateFunction dfdX = new BivariateFunction() { public double value(double x, double y) { return 4 * (x + y); } }; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { dZdX[i][j] = dfdX.value(xval[i], yval[j]); } } // Partial derivatives with respect to y double[][] dZdY = new double[xval.length][yval.length]; BivariateFunction dfdY = new BivariateFunction() { public double value(double x, double y) { return 4 * x - 6 * y; } }; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { dZdY[i][j] = dfdY.value(xval[i], yval[j]); } } // Partial cross-derivatives double[][] dZdXdY = new double[xval.length][yval.length]; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { dZdXdY[i][j] = 4; } } BivariateFunction bcf = new BicubicSplineInterpolatingFunction(xval, yval, zval, dZdX, dZdY, dZdXdY); double x, y; final RandomGenerator rng = new Well19937c(1234567L); // "tol" depends on the seed. final UniformRealDistribution distX = new UniformRealDistribution(rng, xval[0], xval[xval.length - 1]); final UniformRealDistribution distY = new UniformRealDistribution(rng, yval[0], yval[yval.length - 1]); final double tol = 224; double max = 0; for (int i = 0; i < sz; i++) { x = distX.sample(); for (int j = 0; j < sz; j++) { y = distY.sample(); // System.out.println(x + " " + y + " " + f.value(x, y) + " " + bcf.value(x, y)); Assert.assertEquals(f.value(x, y), bcf.value(x, y), tol); } // System.out.println(); } } @Test public void testIsValidPoint() { final double xMin = -12; final double xMax = 34; final double yMin = 5; final double yMax = 67; final double[] xval = new double[] { xMin, xMax }; final double[] yval = new double[] { yMin, yMax }; final double[][] f = new double[][] { { 1, 2 }, { 3, 4 } }; final double[][] dFdX = f; final double[][] dFdY = f; final double[][] dFdXdY = f; final BicubicSplineInterpolatingFunction bcf = new BicubicSplineInterpolatingFunction(xval, yval, f, dFdX, dFdY, dFdXdY); double x, y; x = xMin; y = yMin; Assert.assertTrue(bcf.isValidPoint(x, y)); // Ensure that no exception is thrown. bcf.value(x, y); x = xMax; y = yMax; Assert.assertTrue(bcf.isValidPoint(x, y)); // Ensure that no exception is thrown. bcf.value(x, y); final double xRange = xMax - xMin; final double yRange = yMax - yMin; x = xMin + xRange / 3.4; y = yMin + yRange / 1.2; Assert.assertTrue(bcf.isValidPoint(x, y)); // Ensure that no exception is thrown. bcf.value(x, y); final double small = 1e-8; x = xMin - small; y = yMax; Assert.assertFalse(bcf.isValidPoint(x, y)); // Ensure that an exception would have been thrown. try { bcf.value(x, y); Assert.fail("OutOfRangeException expected"); } catch (OutOfRangeException expected) {} x = xMin; y = yMax + small; Assert.assertFalse(bcf.isValidPoint(x, y)); // Ensure that an exception would have been thrown. try { bcf.value(x, y); Assert.fail("OutOfRangeException expected"); } catch (OutOfRangeException expected) {} } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.interpolation; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.analysis.BivariateFunction; import org.apache.commons.math3.distribution.UniformRealDistribution; import org.apache.commons.math3.random.RandomGenerator; import org.apache.commons.math3.random.Well19937c; import org.junit.Assert; import org.junit.Test; /** * Test case for the bicubic interpolator. * * @version $Id$ */ public final class BicubicSplineInterpolatorTest { /** * Test preconditions. */ @Test public void testPreconditions() { double[] xval = new double[] {3, 4, 5, 6.5}; double[] yval = new double[] {-4, -3, -1, 2.5}; double[][] zval = new double[xval.length][yval.length]; BivariateGridInterpolator interpolator = new BicubicSplineInterpolator(); @SuppressWarnings("unused") BivariateFunction p = interpolator.interpolate(xval, yval, zval); double[] wxval = new double[] {3, 2, 5, 6.5}; try { p = interpolator.interpolate(wxval, yval, zval); Assert.fail("an exception should have been thrown"); } catch (MathIllegalArgumentException e) { // Expected } double[] wyval = new double[] {-4, -3, -1, -1}; try { p = interpolator.interpolate(xval, wyval, zval); Assert.fail("an exception should have been thrown"); } catch (MathIllegalArgumentException e) { // Expected } double[][] wzval = new double[xval.length][yval.length + 1]; try { p = interpolator.interpolate(xval, yval, wzval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } wzval = new double[xval.length - 1][yval.length]; try { p = interpolator.interpolate(xval, yval, wzval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } } /** * Interpolating a plane. * <p> * z = 2 x - 3 y + 5 */ @Test public void testInterpolation1() { final int sz = 21; double[] xval = new double[sz]; double[] yval = new double[sz]; // Coordinate values final double delta = 1d / (sz - 1); for (int i = 0; i < sz; i++) { xval[i] = -1 + 15 * i * delta; yval[i] = -20 + 30 * i * delta; } // Function values BivariateFunction f = new BivariateFunction() { public double value(double x, double y) { return 2 * x - 3 * y + 5; } }; double[][] zval = new double[xval.length][yval.length]; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { zval[i][j] = f.value(xval[i], yval[j]); } } BivariateGridInterpolator interpolator = new BicubicSplineInterpolator(); BivariateFunction p = interpolator.interpolate(xval, yval, zval); double x, y; final RandomGenerator rng = new Well19937c(1234567L); // "tol" depends on the seed. final UniformRealDistribution distX = new UniformRealDistribution(rng, xval[0], xval[xval.length - 1]); final UniformRealDistribution distY = new UniformRealDistribution(rng, yval[0], yval[yval.length - 1]); final int numSamples = 50; final double tol = 6; for (int i = 0; i < numSamples; i++) { x = distX.sample(); for (int j = 0; j < numSamples; j++) { y = distY.sample(); // System.out.println(x + " " + y + " " + f.value(x, y) + " " + p.value(x, y)); Assert.assertEquals(f.value(x, y), p.value(x, y), tol); } // System.out.println(); } } /** * Interpolating a paraboloid. * <p> * z = 2 x<sup>2</sup> - 3 y<sup>2</sup> + 4 x y - 5 */ @Test public void testInterpolation2() { final int sz = 21; double[] xval = new double[sz]; double[] yval = new double[sz]; // Coordinate values final double delta = 1d / (sz - 1); for (int i = 0; i < sz; i++) { xval[i] = -1 + 15 * i * delta; yval[i] = -20 + 30 * i * delta; } // Function values BivariateFunction f = new BivariateFunction() { public double value(double x, double y) { return 2 * x * x - 3 * y * y + 4 * x * y - 5; } }; double[][] zval = new double[xval.length][yval.length]; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { zval[i][j] = f.value(xval[i], yval[j]); } } BivariateGridInterpolator interpolator = new BicubicSplineInterpolator(); BivariateFunction p = interpolator.interpolate(xval, yval, zval); double x, y; final RandomGenerator rng = new Well19937c(1234567L); // "tol" depends on the seed. final UniformRealDistribution distX = new UniformRealDistribution(rng, xval[0], xval[xval.length - 1]); final UniformRealDistribution distY = new UniformRealDistribution(rng, yval[0], yval[yval.length - 1]); final int numSamples = 50; final double tol = 251; for (int i = 0; i < numSamples; i++) { x = distX.sample(); for (int j = 0; j < numSamples; j++) { y = distY.sample(); // System.out.println(x + " " + y + " " + f.value(x, y) + " " + p.value(x, y)); Assert.assertEquals(f.value(x, y), p.value(x, y), tol); } // System.out.println(); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.interpolation; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.function.Expm1; import org.apache.commons.math3.analysis.function.Sin; import org.apache.commons.math3.exception.NonMonotonicSequenceException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * Test case for Divided Difference interpolator. * <p> * The error of polynomial interpolation is * f(z) - p(z) = f^(n)(zeta) * (z-x[0])(z-x[1])...(z-x[n-1]) / n! * where f^(n) is the n-th derivative of the approximated function and * zeta is some point in the interval determined by x[] and z. * <p> * Since zeta is unknown, f^(n)(zeta) cannot be calculated. But we can bound * it and use the absolute value upper bound for estimates. For reference, * see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X, chapter 2. * * @version $Id$ */ public final class DividedDifferenceInterpolatorTest { /** * Test of interpolator for the sine function. * <p> * |sin^(n)(zeta)| <= 1.0, zeta in [0, 2*PI] */ @Test public void testSinFunction() { UnivariateFunction f = new Sin(); UnivariateInterpolator interpolator = new DividedDifferenceInterpolator(); double x[], y[], z, expected, result, tolerance; // 6 interpolating points on interval [0, 2*PI] int n = 6; double min = 0.0, max = 2 * FastMath.PI; x = new double[n]; y = new double[n]; for (int i = 0; i < n; i++) { x[i] = min + i * (max - min) / n; y[i] = f.value(x[i]); } double derivativebound = 1.0; UnivariateFunction p = interpolator.interpolate(x, y); z = FastMath.PI / 4; expected = f.value(z); result = p.value(z); tolerance = FastMath.abs(derivativebound * partialerror(x, z)); Assert.assertEquals(expected, result, tolerance); z = FastMath.PI * 1.5; expected = f.value(z); result = p.value(z); tolerance = FastMath.abs(derivativebound * partialerror(x, z)); Assert.assertEquals(expected, result, tolerance); } /** * Test of interpolator for the exponential function. * <p> * |expm1^(n)(zeta)| <= e, zeta in [-1, 1] */ @Test public void testExpm1Function() { UnivariateFunction f = new Expm1(); UnivariateInterpolator interpolator = new DividedDifferenceInterpolator(); double x[], y[], z, expected, result, tolerance; // 5 interpolating points on interval [-1, 1] int n = 5; double min = -1.0, max = 1.0; x = new double[n]; y = new double[n]; for (int i = 0; i < n; i++) { x[i] = min + i * (max - min) / n; y[i] = f.value(x[i]); } double derivativebound = FastMath.E; UnivariateFunction p = interpolator.interpolate(x, y); z = 0.0; expected = f.value(z); result = p.value(z); tolerance = FastMath.abs(derivativebound * partialerror(x, z)); Assert.assertEquals(expected, result, tolerance); z = 0.5; expected = f.value(z); result = p.value(z); tolerance = FastMath.abs(derivativebound * partialerror(x, z)); Assert.assertEquals(expected, result, tolerance); z = -0.5; expected = f.value(z); result = p.value(z); tolerance = FastMath.abs(derivativebound * partialerror(x, z)); Assert.assertEquals(expected, result, tolerance); } /** * Test of parameters for the interpolator. */ @Test public void testParameters() { UnivariateInterpolator interpolator = new DividedDifferenceInterpolator(); try { // bad abscissas array double x[] = { 1.0, 2.0, 2.0, 4.0 }; double y[] = { 0.0, 4.0, 4.0, 2.5 }; UnivariateFunction p = interpolator.interpolate(x, y); p.value(0.0); Assert.fail("Expecting NonMonotonicSequenceException - bad abscissas array"); } catch (NonMonotonicSequenceException ex) { // expected } } /** * Returns the partial error term (z-x[0])(z-x[1])...(z-x[n-1])/n! */ protected double partialerror(double x[], double z) throws IllegalArgumentException { if (x.length < 1) { throw new IllegalArgumentException ("Interpolation array cannot be empty."); } double out = 1; for (int i = 0; i < x.length; i++) { out *= (z - x[i]) / (i + 1); } return out; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.interpolation; import java.util.Random; import org.apache.commons.math3.analysis.polynomials.PolynomialFunction; import org.apache.commons.math3.dfp.Dfp; import org.apache.commons.math3.dfp.DfpField; import org.apache.commons.math3.exception.NoDataException; import org.apache.commons.math3.fraction.BigFraction; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class FieldHermiteInterpolatorTest { @Test public void testZero() { FieldHermiteInterpolator<BigFraction> interpolator = new FieldHermiteInterpolator<BigFraction>(); interpolator.addSamplePoint(new BigFraction(0), new BigFraction[] { new BigFraction(0) }); for (int x = -10; x < 10; x++) { BigFraction y = interpolator.value(new BigFraction(x))[0]; Assert.assertEquals(BigFraction.ZERO, y); BigFraction[][] derivatives = interpolator.derivatives(new BigFraction(x), 1); Assert.assertEquals(BigFraction.ZERO, derivatives[0][0]); Assert.assertEquals(BigFraction.ZERO, derivatives[1][0]); } } @Test public void testQuadratic() { FieldHermiteInterpolator<BigFraction> interpolator = new FieldHermiteInterpolator<BigFraction>(); interpolator.addSamplePoint(new BigFraction(0), new BigFraction[] { new BigFraction(2) }); interpolator.addSamplePoint(new BigFraction(1), new BigFraction[] { new BigFraction(0) }); interpolator.addSamplePoint(new BigFraction(2), new BigFraction[] { new BigFraction(0) }); for (double x = -10; x < 10; x += 1.0) { BigFraction y = interpolator.value(new BigFraction(x))[0]; Assert.assertEquals((x - 1) * (x - 2), y.doubleValue(), 1.0e-15); BigFraction[][] derivatives = interpolator.derivatives(new BigFraction(x), 3); Assert.assertEquals((x - 1) * (x - 2), derivatives[0][0].doubleValue(), 1.0e-15); Assert.assertEquals(2 * x - 3, derivatives[1][0].doubleValue(), 1.0e-15); Assert.assertEquals(2, derivatives[2][0].doubleValue(), 1.0e-15); Assert.assertEquals(0, derivatives[3][0].doubleValue(), 1.0e-15); } } @Test public void testMixedDerivatives() { FieldHermiteInterpolator<BigFraction> interpolator = new FieldHermiteInterpolator<BigFraction>(); interpolator.addSamplePoint(new BigFraction(0), new BigFraction[] { new BigFraction(1) }, new BigFraction[] { new BigFraction(2) }); interpolator.addSamplePoint(new BigFraction(1), new BigFraction[] { new BigFraction(4) }); interpolator.addSamplePoint(new BigFraction(2), new BigFraction[] { new BigFraction(5) }, new BigFraction[] { new BigFraction(2) }); BigFraction[][] derivatives = interpolator.derivatives(new BigFraction(0), 5); Assert.assertEquals(new BigFraction( 1), derivatives[0][0]); Assert.assertEquals(new BigFraction( 2), derivatives[1][0]); Assert.assertEquals(new BigFraction( 8), derivatives[2][0]); Assert.assertEquals(new BigFraction(-24), derivatives[3][0]); Assert.assertEquals(new BigFraction( 24), derivatives[4][0]); Assert.assertEquals(new BigFraction( 0), derivatives[5][0]); derivatives = interpolator.derivatives(new BigFraction(1), 5); Assert.assertEquals(new BigFraction( 4), derivatives[0][0]); Assert.assertEquals(new BigFraction( 2), derivatives[1][0]); Assert.assertEquals(new BigFraction( -4), derivatives[2][0]); Assert.assertEquals(new BigFraction( 0), derivatives[3][0]); Assert.assertEquals(new BigFraction( 24), derivatives[4][0]); Assert.assertEquals(new BigFraction( 0), derivatives[5][0]); derivatives = interpolator.derivatives(new BigFraction(2), 5); Assert.assertEquals(new BigFraction( 5), derivatives[0][0]); Assert.assertEquals(new BigFraction( 2), derivatives[1][0]); Assert.assertEquals(new BigFraction( 8), derivatives[2][0]); Assert.assertEquals(new BigFraction( 24), derivatives[3][0]); Assert.assertEquals(new BigFraction( 24), derivatives[4][0]); Assert.assertEquals(new BigFraction( 0), derivatives[5][0]); } @Test public void testRandomPolynomialsValuesOnly() { Random random = new Random(0x42b1e7dbd361a932l); for (int i = 0; i < 100; ++i) { int maxDegree = 0; PolynomialFunction[] p = new PolynomialFunction[5]; for (int k = 0; k < p.length; ++k) { int degree = random.nextInt(7); p[k] = randomPolynomial(degree, random); maxDegree = FastMath.max(maxDegree, degree); } DfpField field = new DfpField(30); Dfp step = field.getOne().divide(field.newDfp(10)); FieldHermiteInterpolator<Dfp> interpolator = new FieldHermiteInterpolator<Dfp>(); for (int j = 0; j < 1 + maxDegree; ++j) { Dfp x = field.newDfp(j).multiply(step); Dfp[] values = new Dfp[p.length]; for (int k = 0; k < p.length; ++k) { values[k] = field.newDfp(p[k].value(x.getReal())); } interpolator.addSamplePoint(x, values); } for (int j = 0; j < 20; ++j) { Dfp x = field.newDfp(j).multiply(step); Dfp[] values = interpolator.value(x); Assert.assertEquals(p.length, values.length); for (int k = 0; k < p.length; ++k) { Assert.assertEquals(p[k].value(x.getReal()), values[k].getReal(), 1.0e-8 * FastMath.abs(p[k].value(x.getReal()))); } } } } @Test public void testRandomPolynomialsFirstDerivative() { Random random = new Random(0x570803c982ca5d3bl); for (int i = 0; i < 100; ++i) { int maxDegree = 0; PolynomialFunction[] p = new PolynomialFunction[5]; PolynomialFunction[] pPrime = new PolynomialFunction[5]; for (int k = 0; k < p.length; ++k) { int degree = random.nextInt(7); p[k] = randomPolynomial(degree, random); pPrime[k] = p[k].polynomialDerivative(); maxDegree = FastMath.max(maxDegree, degree); } DfpField field = new DfpField(30); Dfp step = field.getOne().divide(field.newDfp(10)); FieldHermiteInterpolator<Dfp> interpolator = new FieldHermiteInterpolator<Dfp>(); for (int j = 0; j < 1 + maxDegree / 2; ++j) { Dfp x = field.newDfp(j).multiply(step); Dfp[] values = new Dfp[p.length]; Dfp[] derivatives = new Dfp[p.length]; for (int k = 0; k < p.length; ++k) { values[k] = field.newDfp(p[k].value(x.getReal())); derivatives[k] = field.newDfp(pPrime[k].value(x.getReal())); } interpolator.addSamplePoint(x, values, derivatives); } Dfp h = step.divide(field.newDfp(100000)); for (int j = 0; j < 20; ++j) { Dfp x = field.newDfp(j).multiply(step); Dfp[] y = interpolator.value(x); Dfp[] yP = interpolator.value(x.add(h)); Dfp[] yM = interpolator.value(x.subtract(h)); Assert.assertEquals(p.length, y.length); for (int k = 0; k < p.length; ++k) { Assert.assertEquals(p[k].value(x.getReal()), y[k].getReal(), 1.0e-8 * FastMath.abs(p[k].value(x.getReal()))); Assert.assertEquals(pPrime[k].value(x.getReal()), yP[k].subtract(yM[k]).divide(h.multiply(2)).getReal(), 4.0e-8 * FastMath.abs(p[k].value(x.getReal()))); } } } } @Test public void testSine() { DfpField field = new DfpField(30); FieldHermiteInterpolator<Dfp> interpolator = new FieldHermiteInterpolator<Dfp>(); for (Dfp x = field.getZero(); x.getReal() < FastMath.PI; x = x.add(0.5)) { interpolator.addSamplePoint(x, new Dfp[] { x.sin() }); } for (Dfp x = field.newDfp(0.1); x.getReal() < 2.9; x = x.add(0.01)) { Dfp y = interpolator.value(x)[0]; Assert.assertEquals( x.sin().getReal(), y.getReal(), 3.5e-5); } } @Test public void testSquareRoot() { DfpField field = new DfpField(30); FieldHermiteInterpolator<Dfp> interpolator = new FieldHermiteInterpolator<Dfp>(); for (Dfp x = field.getOne(); x.getReal() < 3.6; x = x.add(0.5)) { interpolator.addSamplePoint(x, new Dfp[] { x.sqrt() }); } for (Dfp x = field.newDfp(1.1); x.getReal() < 3.5; x = x.add(0.01)) { Dfp y = interpolator.value(x)[0]; Assert.assertEquals(x.sqrt().getReal(), y.getReal(), 1.5e-4); } } @Test public void testWikipedia() { // this test corresponds to the example from Wikipedia page: // http://en.wikipedia.org/wiki/Hermite_interpolation FieldHermiteInterpolator<BigFraction> interpolator = new FieldHermiteInterpolator<BigFraction>(); interpolator.addSamplePoint(new BigFraction(-1), new BigFraction[] { new BigFraction( 2) }, new BigFraction[] { new BigFraction(-8) }, new BigFraction[] { new BigFraction(56) }); interpolator.addSamplePoint(new BigFraction( 0), new BigFraction[] { new BigFraction( 1) }, new BigFraction[] { new BigFraction( 0) }, new BigFraction[] { new BigFraction( 0) }); interpolator.addSamplePoint(new BigFraction( 1), new BigFraction[] { new BigFraction( 2) }, new BigFraction[] { new BigFraction( 8) }, new BigFraction[] { new BigFraction(56) }); for (BigFraction x = new BigFraction(-1); x.doubleValue() <= 1.0; x = x.add(new BigFraction(1, 8))) { BigFraction y = interpolator.value(x)[0]; BigFraction x2 = x.multiply(x); BigFraction x4 = x2.multiply(x2); BigFraction x8 = x4.multiply(x4); Assert.assertEquals(x8.add(new BigFraction(1)), y); } } @Test public void testOnePointParabola() { FieldHermiteInterpolator<BigFraction> interpolator = new FieldHermiteInterpolator<BigFraction>(); interpolator.addSamplePoint(new BigFraction(0), new BigFraction[] { new BigFraction(1) }, new BigFraction[] { new BigFraction(1) }, new BigFraction[] { new BigFraction(2) }); for (BigFraction x = new BigFraction(-1); x.doubleValue() <= 1.0; x = x.add(new BigFraction(1, 8))) { BigFraction y = interpolator.value(x)[0]; Assert.assertEquals(BigFraction.ONE.add(x.multiply(BigFraction.ONE.add(x))), y); } } private PolynomialFunction randomPolynomial(int degree, Random random) { double[] coeff = new double[ 1 + degree]; for (int j = 0; j < degree; ++j) { coeff[j] = random.nextDouble(); } return new PolynomialFunction(coeff); } @Test(expected=NoDataException.class) public void testEmptySampleValue() { new FieldHermiteInterpolator<BigFraction>().value(BigFraction.ZERO); } @Test(expected=NoDataException.class) public void testEmptySampleDerivative() { new FieldHermiteInterpolator<BigFraction>().derivatives(BigFraction.ZERO, 1); } @Test(expected=IllegalArgumentException.class) public void testDuplicatedAbscissa() { FieldHermiteInterpolator<BigFraction> interpolator = new FieldHermiteInterpolator<BigFraction>(); interpolator.addSamplePoint(new BigFraction(1), new BigFraction[] { new BigFraction(0) }); interpolator.addSamplePoint(new BigFraction(1), new BigFraction[] { new BigFraction(1) }); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.interpolation; import java.util.Random; import org.apache.commons.math3.analysis.differentiation.DerivativeStructure; import org.apache.commons.math3.analysis.polynomials.PolynomialFunction; import org.apache.commons.math3.exception.NoDataException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class HermiteInterpolatorTest { @Test public void testZero() { HermiteInterpolator interpolator = new HermiteInterpolator(); interpolator.addSamplePoint(0.0, new double[] { 0.0 }); for (double x = -10; x < 10; x += 1.0) { DerivativeStructure y = interpolator.value(new DerivativeStructure(1, 1, 0, x))[0]; Assert.assertEquals(0.0, y.getValue(), 1.0e-15); Assert.assertEquals(0.0, y.getPartialDerivative(1), 1.0e-15); } checkPolynomial(new PolynomialFunction(new double[] { 0.0 }), interpolator.getPolynomials()[0]); } @Test public void testQuadratic() { HermiteInterpolator interpolator = new HermiteInterpolator(); interpolator.addSamplePoint(0.0, new double[] { 2.0 }); interpolator.addSamplePoint(1.0, new double[] { 0.0 }); interpolator.addSamplePoint(2.0, new double[] { 0.0 }); for (double x = -10; x < 10; x += 1.0) { DerivativeStructure y = interpolator.value(new DerivativeStructure(1, 1, 0, x))[0]; Assert.assertEquals((x - 1.0) * (x - 2.0), y.getValue(), 1.0e-15); Assert.assertEquals(2 * x - 3.0, y.getPartialDerivative(1), 1.0e-15); } checkPolynomial(new PolynomialFunction(new double[] { 2.0, -3.0, 1.0 }), interpolator.getPolynomials()[0]); } @Test public void testMixedDerivatives() { HermiteInterpolator interpolator = new HermiteInterpolator(); interpolator.addSamplePoint(0.0, new double[] { 1.0 }, new double[] { 2.0 }); interpolator.addSamplePoint(1.0, new double[] { 4.0 }); interpolator.addSamplePoint(2.0, new double[] { 5.0 }, new double[] { 2.0 }); Assert.assertEquals(4, interpolator.getPolynomials()[0].degree()); DerivativeStructure y0 = interpolator.value(new DerivativeStructure(1, 1, 0, 0.0))[0]; Assert.assertEquals(1.0, y0.getValue(), 1.0e-15); Assert.assertEquals(2.0, y0.getPartialDerivative(1), 1.0e-15); Assert.assertEquals(4.0, interpolator.value(1.0)[0], 1.0e-15); DerivativeStructure y2 = interpolator.value(new DerivativeStructure(1, 1, 0, 2.0))[0]; Assert.assertEquals(5.0, y2.getValue(), 1.0e-15); Assert.assertEquals(2.0, y2.getPartialDerivative(1), 1.0e-15); checkPolynomial(new PolynomialFunction(new double[] { 1.0, 2.0, 4.0, -4.0, 1.0 }), interpolator.getPolynomials()[0]); } @Test public void testRandomPolynomialsValuesOnly() { Random random = new Random(0x42b1e7dbd361a932l); for (int i = 0; i < 100; ++i) { int maxDegree = 0; PolynomialFunction[] p = new PolynomialFunction[5]; for (int k = 0; k < p.length; ++k) { int degree = random.nextInt(7); p[k] = randomPolynomial(degree, random); maxDegree = FastMath.max(maxDegree, degree); } HermiteInterpolator interpolator = new HermiteInterpolator(); for (int j = 0; j < 1 + maxDegree; ++j) { double x = 0.1 * j; double[] values = new double[p.length]; for (int k = 0; k < p.length; ++k) { values[k] = p[k].value(x); } interpolator.addSamplePoint(x, values); } for (double x = 0; x < 2; x += 0.1) { double[] values = interpolator.value(x); Assert.assertEquals(p.length, values.length); for (int k = 0; k < p.length; ++k) { Assert.assertEquals(p[k].value(x), values[k], 1.0e-8 * FastMath.abs(p[k].value(x))); } } PolynomialFunction[] result = interpolator.getPolynomials(); for (int k = 0; k < p.length; ++k) { checkPolynomial(p[k], result[k]); } } } @Test public void testRandomPolynomialsFirstDerivative() { Random random = new Random(0x570803c982ca5d3bl); for (int i = 0; i < 100; ++i) { int maxDegree = 0; PolynomialFunction[] p = new PolynomialFunction[5]; PolynomialFunction[] pPrime = new PolynomialFunction[5]; for (int k = 0; k < p.length; ++k) { int degree = random.nextInt(7); p[k] = randomPolynomial(degree, random); pPrime[k] = p[k].polynomialDerivative(); maxDegree = FastMath.max(maxDegree, degree); } HermiteInterpolator interpolator = new HermiteInterpolator(); for (int j = 0; j < 1 + maxDegree / 2; ++j) { double x = 0.1 * j; double[] values = new double[p.length]; double[] derivatives = new double[p.length]; for (int k = 0; k < p.length; ++k) { values[k] = p[k].value(x); derivatives[k] = pPrime[k].value(x); } interpolator.addSamplePoint(x, values, derivatives); } for (double x = 0; x < 2; x += 0.1) { DerivativeStructure[] y = interpolator.value(new DerivativeStructure(1, 1, 0, x)); Assert.assertEquals(p.length, y.length); for (int k = 0; k < p.length; ++k) { Assert.assertEquals(p[k].value(x), y[k].getValue(), 1.0e-8 * FastMath.abs(p[k].value(x))); Assert.assertEquals(pPrime[k].value(x), y[k].getPartialDerivative(1), 4.0e-8 * FastMath.abs(p[k].value(x))); } } PolynomialFunction[] result = interpolator.getPolynomials(); for (int k = 0; k < p.length; ++k) { checkPolynomial(p[k], result[k]); } } } @Test public void testSine() { HermiteInterpolator interpolator = new HermiteInterpolator(); for (double x = 0; x < FastMath.PI; x += 0.5) { interpolator.addSamplePoint(x, new double[] { FastMath.sin(x) }); } for (double x = 0.1; x <= 2.9; x += 0.01) { DerivativeStructure y = interpolator.value(new DerivativeStructure(1, 2, 0, x))[0]; Assert.assertEquals( FastMath.sin(x), y.getValue(), 3.5e-5); Assert.assertEquals( FastMath.cos(x), y.getPartialDerivative(1), 1.3e-4); Assert.assertEquals(-FastMath.sin(x), y.getPartialDerivative(2), 2.9e-3); } } @Test public void testSquareRoot() { HermiteInterpolator interpolator = new HermiteInterpolator(); for (double x = 1.0; x < 3.6; x += 0.5) { interpolator.addSamplePoint(x, new double[] { FastMath.sqrt(x) }); } for (double x = 1.1; x < 3.5; x += 0.01) { DerivativeStructure y = interpolator.value(new DerivativeStructure(1, 1, 0, x))[0]; Assert.assertEquals(FastMath.sqrt(x), y.getValue(), 1.5e-4); Assert.assertEquals(0.5 / FastMath.sqrt(x), y.getPartialDerivative(1), 8.5e-4); } } @Test public void testWikipedia() { // this test corresponds to the example from Wikipedia page: // http://en.wikipedia.org/wiki/Hermite_interpolation HermiteInterpolator interpolator = new HermiteInterpolator(); interpolator.addSamplePoint(-1, new double[] { 2 }, new double[] { -8 }, new double[] { 56 }); interpolator.addSamplePoint( 0, new double[] { 1 }, new double[] { 0 }, new double[] { 0 }); interpolator.addSamplePoint( 1, new double[] { 2 }, new double[] { 8 }, new double[] { 56 }); for (double x = -1.0; x <= 1.0; x += 0.125) { DerivativeStructure y = interpolator.value(new DerivativeStructure(1, 1, 0, x))[0]; double x2 = x * x; double x4 = x2 * x2; double x8 = x4 * x4; Assert.assertEquals(x8 + 1, y.getValue(), 1.0e-15); Assert.assertEquals(8 * x4 * x2 * x, y.getPartialDerivative(1), 1.0e-15); } checkPolynomial(new PolynomialFunction(new double[] { 1, 0, 0, 0, 0, 0, 0, 0, 1 }), interpolator.getPolynomials()[0]); } @Test public void testOnePointParabola() { HermiteInterpolator interpolator = new HermiteInterpolator(); interpolator.addSamplePoint(0, new double[] { 1 }, new double[] { 1 }, new double[] { 2 }); for (double x = -1.0; x <= 1.0; x += 0.125) { DerivativeStructure y = interpolator.value(new DerivativeStructure(1, 1, 0, x))[0]; Assert.assertEquals(1 + x * (1 + x), y.getValue(), 1.0e-15); Assert.assertEquals(1 + 2 * x, y.getPartialDerivative(1), 1.0e-15); } checkPolynomial(new PolynomialFunction(new double[] { 1, 1, 1 }), interpolator.getPolynomials()[0]); } private PolynomialFunction randomPolynomial(int degree, Random random) { double[] coeff = new double[ 1 + degree]; for (int j = 0; j < degree; ++j) { coeff[j] = random.nextDouble(); } return new PolynomialFunction(coeff); } @Test(expected=NoDataException.class) public void testEmptySample() { new HermiteInterpolator().value(0.0); } @Test(expected=IllegalArgumentException.class) public void testDuplicatedAbscissa() { HermiteInterpolator interpolator = new HermiteInterpolator(); interpolator.addSamplePoint(1.0, new double[] { 0.0 }); interpolator.addSamplePoint(1.0, new double[] { 1.0 }); } private void checkPolynomial(PolynomialFunction expected, PolynomialFunction result) { Assert.assertTrue(result.degree() >= expected.degree()); double[] cE = expected.getCoefficients(); double[] cR = result.getCoefficients(); for (int i = 0; i < cE.length; ++i) { Assert.assertEquals(cE[i], cR[i], 1.0e-8 * FastMath.abs(cE[i])); } for (int i = cE.length; i < cR.length; ++i) { Assert.assertEquals(0.0, cR[i], 1.0e-9); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.interpolation; import org.apache.commons.math3.exception.NonMonotonicSequenceException; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.polynomials.PolynomialFunction; import org.apache.commons.math3.analysis.polynomials.PolynomialSplineFunction; import org.junit.Assert; import org.junit.Test; /** * Test the LinearInterpolator. */ public class LinearInterpolatorTest { /** error tolerance for spline interpolator value at knot points */ protected double knotTolerance = 1E-12; /** error tolerance for interpolating polynomial coefficients */ protected double coefficientTolerance = 1E-6; /** error tolerance for interpolated values */ protected double interpolationTolerance = 1E-12; @Test public void testInterpolateLinearDegenerateTwoSegment() { double x[] = { 0.0, 0.5, 1.0 }; double y[] = { 0.0, 0.5, 1.0 }; UnivariateInterpolator i = new LinearInterpolator(); UnivariateFunction f = i.interpolate(x, y); verifyInterpolation(f, x, y); // Verify coefficients using analytical values PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials(); double target[] = {y[0], 1d}; TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance); target = new double[]{y[1], 1d}; TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance); // Check interpolation Assert.assertEquals(0.0,f.value(0.0), interpolationTolerance); Assert.assertEquals(0.4,f.value(0.4), interpolationTolerance); Assert.assertEquals(1.0,f.value(1.0), interpolationTolerance); } @Test public void testInterpolateLinearDegenerateThreeSegment() { double x[] = { 0.0, 0.5, 1.0, 1.5 }; double y[] = { 0.0, 0.5, 1.0, 1.5 }; UnivariateInterpolator i = new LinearInterpolator(); UnivariateFunction f = i.interpolate(x, y); verifyInterpolation(f, x, y); // Verify coefficients using analytical values PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials(); double target[] = {y[0], 1d}; TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance); target = new double[]{y[1], 1d}; TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance); target = new double[]{y[2], 1d}; TestUtils.assertEquals(polynomials[2].getCoefficients(), target, coefficientTolerance); // Check interpolation Assert.assertEquals(0,f.value(0), interpolationTolerance); Assert.assertEquals(1.4,f.value(1.4), interpolationTolerance); Assert.assertEquals(1.5,f.value(1.5), interpolationTolerance); } @Test public void testInterpolateLinear() { double x[] = { 0.0, 0.5, 1.0 }; double y[] = { 0.0, 0.5, 0.0 }; UnivariateInterpolator i = new LinearInterpolator(); UnivariateFunction f = i.interpolate(x, y); verifyInterpolation(f, x, y); // Verify coefficients using analytical values PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials(); double target[] = {y[0], 1d}; TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance); target = new double[]{y[1], -1d}; TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance); } @Test public void testIllegalArguments() { // Data set arrays of different size. UnivariateInterpolator i = new LinearInterpolator(); try { double xval[] = { 0.0, 1.0 }; double yval[] = { 0.0, 1.0, 2.0 }; i.interpolate(xval, yval); Assert.fail("Failed to detect data set array with different sizes."); } catch (DimensionMismatchException iae) { // Expected. } // X values not sorted. try { double xval[] = { 0.0, 1.0, 0.5 }; double yval[] = { 0.0, 1.0, 2.0 }; i.interpolate(xval, yval); Assert.fail("Failed to detect unsorted arguments."); } catch (NonMonotonicSequenceException iae) { // Expected. } // Not enough data to interpolate. try { double xval[] = { 0.0 }; double yval[] = { 0.0 }; i.interpolate(xval, yval); Assert.fail("Failed to detect unsorted arguments."); } catch (NumberIsTooSmallException iae) { // Expected. } } /** * verifies that f(x[i]) = y[i] for i = 0..n-1 where n is common length. */ protected void verifyInterpolation(UnivariateFunction f, double x[], double y[]) { for (int i = 0; i < x.length; i++) { Assert.assertEquals(f.value(x[i]), y[i], knotTolerance); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.interpolation; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.exception.OutOfRangeException; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.NoDataException; import org.apache.commons.math3.exception.NonMonotonicSequenceException; import org.apache.commons.math3.exception.NotFiniteNumberException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.junit.Assert; import org.junit.Test; /** * Test of the LoessInterpolator class. */ public class LoessInterpolatorTest { @Test public void testOnOnePoint() { double[] xval = {0.5}; double[] yval = {0.7}; double[] res = new LoessInterpolator().smooth(xval, yval); Assert.assertEquals(1, res.length); Assert.assertEquals(0.7, res[0], 0.0); } @Test public void testOnTwoPoints() { double[] xval = {0.5, 0.6}; double[] yval = {0.7, 0.8}; double[] res = new LoessInterpolator().smooth(xval, yval); Assert.assertEquals(2, res.length); Assert.assertEquals(0.7, res[0], 0.0); Assert.assertEquals(0.8, res[1], 0.0); } @Test public void testOnStraightLine() { double[] xval = {1,2,3,4,5}; double[] yval = {2,4,6,8,10}; LoessInterpolator li = new LoessInterpolator(0.6, 2, 1e-12); double[] res = li.smooth(xval, yval); Assert.assertEquals(5, res.length); for(int i = 0; i < 5; ++i) { Assert.assertEquals(yval[i], res[i], 1e-8); } } @Test public void testOnDistortedSine() { int numPoints = 100; double[] xval = new double[numPoints]; double[] yval = new double[numPoints]; double xnoise = 0.1; double ynoise = 0.2; generateSineData(xval, yval, xnoise, ynoise); LoessInterpolator li = new LoessInterpolator(0.3, 4, 1e-12); double[] res = li.smooth(xval, yval); // Check that the resulting curve differs from // the "real" sine less than the jittered one double noisyResidualSum = 0; double fitResidualSum = 0; for(int i = 0; i < numPoints; ++i) { double expected = FastMath.sin(xval[i]); double noisy = yval[i]; double fit = res[i]; noisyResidualSum += FastMath.pow(noisy - expected, 2); fitResidualSum += FastMath.pow(fit - expected, 2); } Assert.assertTrue(fitResidualSum < noisyResidualSum); } @Test public void testIncreasingBandwidthIncreasesSmoothness() { int numPoints = 100; double[] xval = new double[numPoints]; double[] yval = new double[numPoints]; double xnoise = 0.1; double ynoise = 0.1; generateSineData(xval, yval, xnoise, ynoise); // Check that variance decreases as bandwidth increases double[] bandwidths = {0.1, 0.5, 1.0}; double[] variances = new double[bandwidths.length]; for (int i = 0; i < bandwidths.length; i++) { double bw = bandwidths[i]; LoessInterpolator li = new LoessInterpolator(bw, 4, 1e-12); double[] res = li.smooth(xval, yval); for (int j = 1; j < res.length; ++j) { variances[i] += FastMath.pow(res[j] - res[j-1], 2); } } for(int i = 1; i < variances.length; ++i) { Assert.assertTrue(variances[i] < variances[i-1]); } } @Test public void testIncreasingRobustnessItersIncreasesSmoothnessWithOutliers() { int numPoints = 100; double[] xval = new double[numPoints]; double[] yval = new double[numPoints]; double xnoise = 0.1; double ynoise = 0.1; generateSineData(xval, yval, xnoise, ynoise); // Introduce a couple of outliers yval[numPoints/3] *= 100; yval[2 * numPoints/3] *= -100; // Check that variance decreases as the number of robustness // iterations increases double[] variances = new double[4]; for (int i = 0; i < 4; i++) { LoessInterpolator li = new LoessInterpolator(0.3, i, 1e-12); double[] res = li.smooth(xval, yval); for (int j = 1; j < res.length; ++j) { variances[i] += FastMath.abs(res[j] - res[j-1]); } } for(int i = 1; i < variances.length; ++i) { Assert.assertTrue(variances[i] < variances[i-1]); } } @Test(expected=DimensionMismatchException.class) public void testUnequalSizeArguments() { new LoessInterpolator().smooth(new double[] {1,2,3}, new double[] {1,2,3,4}); } @Test(expected=NoDataException.class) public void testEmptyData() { new LoessInterpolator().smooth(new double[] {}, new double[] {}); } @Test(expected=NonMonotonicSequenceException.class) public void testNonStrictlyIncreasing1() { new LoessInterpolator().smooth(new double[] {4,3,1,2}, new double[] {3,4,5,6}); } @Test(expected=NonMonotonicSequenceException.class) public void testNonStrictlyIncreasing2() { new LoessInterpolator().smooth(new double[] {1,2,2,3}, new double[] {3,4,5,6}); } @Test(expected=NotFiniteNumberException.class) public void testNotAllFiniteReal1() { new LoessInterpolator().smooth(new double[] {1,2,Double.NaN}, new double[] {3,4,5}); } @Test(expected=NotFiniteNumberException.class) public void testNotAllFiniteReal2() { new LoessInterpolator().smooth(new double[] {1,2,Double.POSITIVE_INFINITY}, new double[] {3,4,5}); } @Test(expected=NotFiniteNumberException.class) public void testNotAllFiniteReal3() { new LoessInterpolator().smooth(new double[] {1,2,Double.NEGATIVE_INFINITY}, new double[] {3,4,5}); } @Test(expected=NotFiniteNumberException.class) public void testNotAllFiniteReal4() { new LoessInterpolator().smooth(new double[] {3,4,5}, new double[] {1,2,Double.NaN}); } @Test(expected=NotFiniteNumberException.class) public void testNotAllFiniteReal5() { new LoessInterpolator().smooth(new double[] {3,4,5}, new double[] {1,2,Double.POSITIVE_INFINITY}); } @Test(expected=NotFiniteNumberException.class) public void testNotAllFiniteReal6() { new LoessInterpolator().smooth(new double[] {3,4,5}, new double[] {1,2,Double.NEGATIVE_INFINITY}); } @Test(expected=NumberIsTooSmallException.class) public void testInsufficientBandwidth() { LoessInterpolator li = new LoessInterpolator(0.1, 3, 1e-12); li.smooth(new double[] {1,2,3,4,5,6,7,8,9,10,11,12}, new double[] {1,2,3,4,5,6,7,8,9,10,11,12}); } @Test(expected=OutOfRangeException.class) public void testCompletelyIncorrectBandwidth1() { new LoessInterpolator(-0.2, 3, 1e-12); } @Test(expected=OutOfRangeException.class) public void testCompletelyIncorrectBandwidth2() { new LoessInterpolator(1.1, 3, 1e-12); } @Test public void testMath296withoutWeights() { double[] xval = { 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0}; double[] yval = { 0.47, 0.48, 0.55, 0.56, -0.08, -0.04, -0.07, -0.07, -0.56, -0.46, -0.56, -0.52, -3.03, -3.08, -3.09, -3.04, 3.54, 3.46, 3.36, 3.35}; // Output from R, rounded to .001 double[] yref = { 0.461, 0.499, 0.541, 0.308, 0.175, -0.042, -0.072, -0.196, -0.311, -0.446, -0.557, -1.497, -2.133, -3.08, -3.09, -0.621, 0.982, 3.449, 3.389, 3.336 }; LoessInterpolator li = new LoessInterpolator(0.3, 4, 1e-12); double[] res = li.smooth(xval, yval); Assert.assertEquals(xval.length, res.length); for(int i = 0; i < res.length; ++i) { Assert.assertEquals(yref[i], res[i], 0.02); } } private void generateSineData(double[] xval, double[] yval, double xnoise, double ynoise) { double dx = 2 * FastMath.PI / xval.length; double x = 0; for(int i = 0; i < xval.length; ++i) { xval[i] = x; yval[i] = FastMath.sin(x) + (2 * FastMath.random() - 1) * ynoise; x += dx * (1 + (2 * FastMath.random() - 1) * xnoise); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.interpolation; import org.apache.commons.math3.analysis.MultivariateFunction; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * Test case for the "microsphere projection" interpolator. * * @version $Id$ */ public final class MicrosphereInterpolatorTest { /** * Test of interpolator for a plane. * <p> * y = 2 x<sub>1</sub> - 3 x<sub>2</sub> + 5 */ @Test public void testLinearFunction2D() { MultivariateFunction f = new MultivariateFunction() { public double value(double[] x) { if (x.length != 2) { throw new IllegalArgumentException(); } return 2 * x[0] - 3 * x[1] + 5; } }; MultivariateInterpolator interpolator = new MicrosphereInterpolator(); // Interpolating points in [-1, 1][-1, 1] by steps of 1. final int n = 9; final int dim = 2; double[][] x = new double[n][dim]; double[] y = new double[n]; int index = 0; for (int i = -1; i <= 1; i++) { for (int j = -1; j <= 1; j++) { x[index][0] = i; x[index][1] = j; y[index] = f.value(x[index]); ++index; } } MultivariateFunction p = interpolator.interpolate(x, y); double[] c = new double[dim]; double expected, result; c[0] = 0; c[1] = 0; expected = f.value(c); result = p.value(c); Assert.assertEquals("On sample point", expected, result, FastMath.ulp(1d)); c[0] = 0 + 1e-5; c[1] = 1 - 1e-5; expected = f.value(c); result = p.value(c); Assert.assertEquals("1e-5 away from sample point", expected, result, 1e-4); } /** * Test of interpolator for a quadratic function. * <p> * y = 2 x<sub>1</sub><sup>2</sup> - 3 x<sub>2</sub><sup>2</sup> * + 4 x<sub>1</sub> x<sub>2</sub> - 5 */ @Test public void testParaboloid2D() { MultivariateFunction f = new MultivariateFunction() { public double value(double[] x) { if (x.length != 2) { throw new IllegalArgumentException(); } return 2 * x[0] * x[0] - 3 * x[1] * x[1] + 4 * x[0] * x[1] - 5; } }; MultivariateInterpolator interpolator = new MicrosphereInterpolator(); // Interpolating points in [-10, 10][-10, 10] by steps of 2. final int n = 121; final int dim = 2; double[][] x = new double[n][dim]; double[] y = new double[n]; int index = 0; for (int i = -10; i <= 10; i += 2) { for (int j = -10; j <= 10; j += 2) { x[index][0] = i; x[index][1] = j; y[index] = f.value(x[index]); ++index; } } MultivariateFunction p = interpolator.interpolate(x, y); double[] c = new double[dim]; double expected, result; c[0] = 0; c[1] = 0; expected = f.value(c); result = p.value(c); Assert.assertEquals("On sample point", expected, result, FastMath.ulp(1d)); c[0] = 2 + 1e-5; c[1] = 2 - 1e-5; expected = f.value(c); result = p.value(c); Assert.assertEquals("1e-5 away from sample point", expected, result, 1e-3); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.interpolation; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.function.Expm1; import org.apache.commons.math3.analysis.function.Sin; import org.apache.commons.math3.exception.NonMonotonicSequenceException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * Test case for Neville interpolator. * <p> * The error of polynomial interpolation is * f(z) - p(z) = f^(n)(zeta) * (z-x[0])(z-x[1])...(z-x[n-1]) / n! * where f^(n) is the n-th derivative of the approximated function and * zeta is some point in the interval determined by x[] and z. * <p> * Since zeta is unknown, f^(n)(zeta) cannot be calculated. But we can bound * it and use the absolute value upper bound for estimates. For reference, * see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X, chapter 2. * * @version $Id$ */ public final class NevilleInterpolatorTest { /** * Test of interpolator for the sine function. * <p> * |sin^(n)(zeta)| <= 1.0, zeta in [0, 2*PI] */ @Test public void testSinFunction() { UnivariateFunction f = new Sin(); UnivariateInterpolator interpolator = new NevilleInterpolator(); double x[], y[], z, expected, result, tolerance; // 6 interpolating points on interval [0, 2*PI] int n = 6; double min = 0.0, max = 2 * FastMath.PI; x = new double[n]; y = new double[n]; for (int i = 0; i < n; i++) { x[i] = min + i * (max - min) / n; y[i] = f.value(x[i]); } double derivativebound = 1.0; UnivariateFunction p = interpolator.interpolate(x, y); z = FastMath.PI / 4; expected = f.value(z); result = p.value(z); tolerance = FastMath.abs(derivativebound * partialerror(x, z)); Assert.assertEquals(expected, result, tolerance); z = FastMath.PI * 1.5; expected = f.value(z); result = p.value(z); tolerance = FastMath.abs(derivativebound * partialerror(x, z)); Assert.assertEquals(expected, result, tolerance); } /** * Test of interpolator for the exponential function. * <p> * |expm1^(n)(zeta)| <= e, zeta in [-1, 1] */ @Test public void testExpm1Function() { UnivariateFunction f = new Expm1(); UnivariateInterpolator interpolator = new NevilleInterpolator(); double x[], y[], z, expected, result, tolerance; // 5 interpolating points on interval [-1, 1] int n = 5; double min = -1.0, max = 1.0; x = new double[n]; y = new double[n]; for (int i = 0; i < n; i++) { x[i] = min + i * (max - min) / n; y[i] = f.value(x[i]); } double derivativebound = FastMath.E; UnivariateFunction p = interpolator.interpolate(x, y); z = 0.0; expected = f.value(z); result = p.value(z); tolerance = FastMath.abs(derivativebound * partialerror(x, z)); Assert.assertEquals(expected, result, tolerance); z = 0.5; expected = f.value(z); result = p.value(z); tolerance = FastMath.abs(derivativebound * partialerror(x, z)); Assert.assertEquals(expected, result, tolerance); z = -0.5; expected = f.value(z); result = p.value(z); tolerance = FastMath.abs(derivativebound * partialerror(x, z)); Assert.assertEquals(expected, result, tolerance); } /** * Test of parameters for the interpolator. */ @Test public void testParameters() { UnivariateInterpolator interpolator = new NevilleInterpolator(); try { // bad abscissas array double x[] = { 1.0, 2.0, 2.0, 4.0 }; double y[] = { 0.0, 4.0, 4.0, 2.5 }; UnivariateFunction p = interpolator.interpolate(x, y); p.value(0.0); Assert.fail("Expecting NonMonotonicSequenceException - bad abscissas array"); } catch (NonMonotonicSequenceException ex) { // expected } } /** * Returns the partial error term (z-x[0])(z-x[1])...(z-x[n-1])/n! */ protected double partialerror(double x[], double z) throws IllegalArgumentException { if (x.length < 1) { throw new IllegalArgumentException ("Interpolation array cannot be empty."); } double out = 1; for (int i = 0; i < x.length; i++) { out *= (z - x[i]) / (i + 1); } return out; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.interpolation; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.analysis.BivariateFunction; import org.junit.Assert; import org.junit.Test; /** * Test case for the smoothing bicubic interpolator. * * @version $Id$ */ public final class SmoothingPolynomialBicubicSplineInterpolatorTest { /** * Test preconditions. */ @Test public void testPreconditions() { double[] xval = new double[] {3, 4, 5, 6.5}; double[] yval = new double[] {-4, -3, -1, 2.5}; double[][] zval = new double[xval.length][yval.length]; BivariateGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator(0); @SuppressWarnings("unused") BivariateFunction p = interpolator.interpolate(xval, yval, zval); double[] wxval = new double[] {3, 2, 5, 6.5}; try { p = interpolator.interpolate(wxval, yval, zval); Assert.fail("an exception should have been thrown"); } catch (MathIllegalArgumentException e) { // Expected } double[] wyval = new double[] {-4, -3, -1, -1}; try { p = interpolator.interpolate(xval, wyval, zval); Assert.fail("an exception should have been thrown"); } catch (MathIllegalArgumentException e) { // Expected } double[][] wzval = new double[xval.length][yval.length + 1]; try { p = interpolator.interpolate(xval, yval, wzval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } wzval = new double[xval.length - 1][yval.length]; try { p = interpolator.interpolate(xval, yval, wzval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } wzval = new double[xval.length][yval.length - 1]; try { p = interpolator.interpolate(xval, yval, wzval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } } /** * Test of interpolator for a plane. * <p> * z = 2 x - 3 y + 5 */ @Test public void testPlane() { BivariateFunction f = new BivariateFunction() { public double value(double x, double y) { return 2 * x - 3 * y + 5 + ((int) (FastMath.abs(5 * x + 3 * y)) % 2 == 0 ? 1 : -1); } }; BivariateGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator(1); double[] xval = new double[] {3, 4, 5, 6.5}; double[] yval = new double[] {-4, -3, -1, 2, 2.5}; double[][] zval = new double[xval.length][yval.length]; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { zval[i][j] = f.value(xval[i], yval[j]); } } BivariateFunction p = interpolator.interpolate(xval, yval, zval); double x, y; double expected, result; x = 4; y = -3; expected = f.value(x, y); result = p.value(x, y); Assert.assertEquals("On sample point", expected, result, 2); x = 4.5; y = -1.5; expected = f.value(x, y); result = p.value(x, y); Assert.assertEquals("half-way between sample points (middle of the patch)", expected, result, 2); x = 3.5; y = -3.5; expected = f.value(x, y); result = p.value(x, y); Assert.assertEquals("half-way between sample points (border of the patch)", expected, result, 2); } /** * Test of interpolator for a paraboloid. * <p> * z = 2 x<sup>2</sup> - 3 y<sup>2</sup> + 4 x y - 5 */ @Test public void testParaboloid() { BivariateFunction f = new BivariateFunction() { public double value(double x, double y) { return 2 * x * x - 3 * y * y + 4 * x * y - 5 + ((int) (FastMath.abs(5 * x + 3 * y)) % 2 == 0 ? 1 : -1); } }; BivariateGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator(4); double[] xval = new double[] {3, 4, 5, 6.5}; double[] yval = new double[] {-4, -3, -2, -1, 0.5, 2.5}; double[][] zval = new double[xval.length][yval.length]; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { zval[i][j] = f.value(xval[i], yval[j]); } } BivariateFunction p = interpolator.interpolate(xval, yval, zval); double x, y; double expected, result; x = 5; y = 0.5; expected = f.value(x, y); result = p.value(x, y); Assert.assertEquals("On sample point", expected, result, 2); x = 4.5; y = -1.5; expected = f.value(x, y); result = p.value(x, y); Assert.assertEquals("half-way between sample points (middle of the patch)", expected, result, 2); x = 3.5; y = -3.5; expected = f.value(x, y); result = p.value(x, y); Assert.assertEquals("half-way between sample points (border of the patch)", expected, result, 2); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.interpolation; import org.apache.commons.math3.exception.NonMonotonicSequenceException; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.polynomials.PolynomialFunction; import org.apache.commons.math3.analysis.polynomials.PolynomialSplineFunction; import org.junit.Assert; import org.junit.Test; /** * Test the SplineInterpolator. * * @version $Id$ */ public class SplineInterpolatorTest { /** error tolerance for spline interpolator value at knot points */ protected double knotTolerance = 1E-12; /** error tolerance for interpolating polynomial coefficients */ protected double coefficientTolerance = 1E-6; /** error tolerance for interpolated values -- high value is from sin test */ protected double interpolationTolerance = 1E-2; @Test public void testInterpolateLinearDegenerateTwoSegment() { double x[] = { 0.0, 0.5, 1.0 }; double y[] = { 0.0, 0.5, 1.0 }; UnivariateInterpolator i = new SplineInterpolator(); UnivariateFunction f = i.interpolate(x, y); verifyInterpolation(f, x, y); verifyConsistency((PolynomialSplineFunction) f, x); // Verify coefficients using analytical values PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials(); double target[] = {y[0], 1d}; TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance); target = new double[]{y[1], 1d}; TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance); // Check interpolation Assert.assertEquals(0.0,f.value(0.0), interpolationTolerance); Assert.assertEquals(0.4,f.value(0.4), interpolationTolerance); Assert.assertEquals(1.0,f.value(1.0), interpolationTolerance); } @Test public void testInterpolateLinearDegenerateThreeSegment() { double x[] = { 0.0, 0.5, 1.0, 1.5 }; double y[] = { 0.0, 0.5, 1.0, 1.5 }; UnivariateInterpolator i = new SplineInterpolator(); UnivariateFunction f = i.interpolate(x, y); verifyInterpolation(f, x, y); // Verify coefficients using analytical values PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials(); double target[] = {y[0], 1d}; TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance); target = new double[]{y[1], 1d}; TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance); target = new double[]{y[2], 1d}; TestUtils.assertEquals(polynomials[2].getCoefficients(), target, coefficientTolerance); // Check interpolation Assert.assertEquals(0,f.value(0), interpolationTolerance); Assert.assertEquals(1.4,f.value(1.4), interpolationTolerance); Assert.assertEquals(1.5,f.value(1.5), interpolationTolerance); } @Test public void testInterpolateLinear() { double x[] = { 0.0, 0.5, 1.0 }; double y[] = { 0.0, 0.5, 0.0 }; UnivariateInterpolator i = new SplineInterpolator(); UnivariateFunction f = i.interpolate(x, y); verifyInterpolation(f, x, y); verifyConsistency((PolynomialSplineFunction) f, x); // Verify coefficients using analytical values PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials(); double target[] = {y[0], 1.5d, 0d, -2d}; TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance); target = new double[]{y[1], 0d, -3d, 2d}; TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance); } @Test public void testInterpolateSin() { double x[] = { 0.0, FastMath.PI / 6d, FastMath.PI / 2d, 5d * FastMath.PI / 6d, FastMath.PI, 7d * FastMath.PI / 6d, 3d * FastMath.PI / 2d, 11d * FastMath.PI / 6d, 2.d * FastMath.PI }; double y[] = { 0d, 0.5d, 1d, 0.5d, 0d, -0.5d, -1d, -0.5d, 0d }; UnivariateInterpolator i = new SplineInterpolator(); UnivariateFunction f = i.interpolate(x, y); verifyInterpolation(f, x, y); verifyConsistency((PolynomialSplineFunction) f, x); /* Check coefficients against values computed using R (version 1.8.1, Red Hat Linux 9) * * To replicate in R: * x[1] <- 0 * x[2] <- pi / 6, etc, same for y[] (could use y <- scan() for y values) * g <- splinefun(x, y, "natural") * splinecoef <- eval(expression(z), envir = environment(g)) * print(splinecoef) */ PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials(); double target[] = {y[0], 1.002676d, 0d, -0.17415829d}; TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance); target = new double[]{y[1], 8.594367e-01, -2.735672e-01, -0.08707914}; TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance); target = new double[]{y[2], 1.471804e-17,-5.471344e-01, 0.08707914}; TestUtils.assertEquals(polynomials[2].getCoefficients(), target, coefficientTolerance); target = new double[]{y[3], -8.594367e-01, -2.735672e-01, 0.17415829}; TestUtils.assertEquals(polynomials[3].getCoefficients(), target, coefficientTolerance); target = new double[]{y[4], -1.002676, 6.548562e-17, 0.17415829}; TestUtils.assertEquals(polynomials[4].getCoefficients(), target, coefficientTolerance); target = new double[]{y[5], -8.594367e-01, 2.735672e-01, 0.08707914}; TestUtils.assertEquals(polynomials[5].getCoefficients(), target, coefficientTolerance); target = new double[]{y[6], 3.466465e-16, 5.471344e-01, -0.08707914}; TestUtils.assertEquals(polynomials[6].getCoefficients(), target, coefficientTolerance); target = new double[]{y[7], 8.594367e-01, 2.735672e-01, -0.17415829}; TestUtils.assertEquals(polynomials[7].getCoefficients(), target, coefficientTolerance); //Check interpolation Assert.assertEquals(FastMath.sqrt(2d) / 2d,f.value(FastMath.PI/4d),interpolationTolerance); Assert.assertEquals(FastMath.sqrt(2d) / 2d,f.value(3d*FastMath.PI/4d),interpolationTolerance); } @Test public void testIllegalArguments() { // Data set arrays of different size. UnivariateInterpolator i = new SplineInterpolator(); try { double xval[] = { 0.0, 1.0 }; double yval[] = { 0.0, 1.0, 2.0 }; i.interpolate(xval, yval); Assert.fail("Failed to detect data set array with different sizes."); } catch (DimensionMismatchException iae) { // Expected. } // X values not sorted. try { double xval[] = { 0.0, 1.0, 0.5 }; double yval[] = { 0.0, 1.0, 2.0 }; i.interpolate(xval, yval); Assert.fail("Failed to detect unsorted arguments."); } catch (NonMonotonicSequenceException iae) { // Expected. } // Not enough data to interpolate. try { double xval[] = { 0.0, 1.0 }; double yval[] = { 0.0, 1.0 }; i.interpolate(xval, yval); Assert.fail("Failed to detect unsorted arguments."); } catch (NumberIsTooSmallException iae) { // Expected. } } /** * verifies that f(x[i]) = y[i] for i = 0..n-1 where n is common length. */ protected void verifyInterpolation(UnivariateFunction f, double x[], double y[]) { for (int i = 0; i < x.length; i++) { Assert.assertEquals(f.value(x[i]), y[i], knotTolerance); } } /** * Verifies that interpolating polynomials satisfy consistency requirement: * adjacent polynomials must agree through two derivatives at knot points */ protected void verifyConsistency(PolynomialSplineFunction f, double x[]) { PolynomialFunction polynomials[] = f.getPolynomials(); for (int i = 1; i < x.length - 2; i++) { // evaluate polynomials and derivatives at x[i + 1] Assert.assertEquals(polynomials[i].value(x[i +1] - x[i]), polynomials[i + 1].value(0), 0.1); Assert.assertEquals(polynomials[i].derivative().value(x[i +1] - x[i]), polynomials[i + 1].derivative().value(0), 0.5); Assert.assertEquals(polynomials[i].polynomialDerivative().derivative().value(x[i +1] - x[i]), polynomials[i + 1].polynomialDerivative().derivative().value(0), 0.5); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.interpolation; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.analysis.TrivariateFunction; import org.junit.Assert; import org.junit.Test; /** * Test case for the bicubic function. * * @version $Id$ */ public final class TricubicSplineInterpolatingFunctionTest { /** * Test preconditions. */ @Test public void testPreconditions() { double[] xval = new double[] {3, 4, 5, 6.5}; double[] yval = new double[] {-4, -3, -1, 2.5}; double[] zval = new double[] {-12, -8, -5.5, -3, 0, 2.5}; double[][][] fval = new double[xval.length][yval.length][zval.length]; @SuppressWarnings("unused") TrivariateFunction tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval, fval, fval, fval, fval, fval, fval, fval, fval); double[] wxval = new double[] {3, 2, 5, 6.5}; try { tcf = new TricubicSplineInterpolatingFunction(wxval, yval, zval, fval, fval, fval, fval, fval, fval, fval, fval); Assert.fail("an exception should have been thrown"); } catch (MathIllegalArgumentException e) { // Expected } double[] wyval = new double[] {-4, -1, -1, 2.5}; try { tcf = new TricubicSplineInterpolatingFunction(xval, wyval, zval, fval, fval, fval, fval, fval, fval, fval, fval); Assert.fail("an exception should have been thrown"); } catch (MathIllegalArgumentException e) { // Expected } double[] wzval = new double[] {-12, -8, -9, -3, 0, 2.5}; try { tcf = new TricubicSplineInterpolatingFunction(xval, yval, wzval, fval, fval, fval, fval, fval, fval, fval, fval); Assert.fail("an exception should have been thrown"); } catch (MathIllegalArgumentException e) { // Expected } double[][][] wfval = new double[xval.length - 1][yval.length - 1][zval.length]; try { tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval, wfval, fval, fval, fval, fval, fval, fval, fval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } try { tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval, fval, wfval, fval, fval, fval, fval, fval, fval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } try { tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval, fval, fval, wfval, fval, fval, fval, fval, fval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } try { tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval, fval, fval, fval, wfval, fval, fval, fval, fval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } try { tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval, fval, fval, fval, fval, wfval, fval, fval, fval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } try { tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval, fval, fval, fval, fval, fval, wfval, fval, fval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } try { tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval, fval, fval, fval, fval, fval, fval, wfval, fval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } try { tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval, fval, fval, fval, fval, fval, fval, fval, wfval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } wfval = new double[xval.length][yval.length - 1][zval.length]; try { tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval, wfval, fval, fval, fval, fval, fval, fval, fval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } try { tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval, fval, wfval, fval, fval, fval, fval, fval, fval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } try { tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval, fval, fval, wfval, fval, fval, fval, fval, fval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } try { tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval, fval, fval, fval, wfval, fval, fval, fval, fval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } try { tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval, fval, fval, fval, fval, wfval, fval, fval, fval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } try { tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval, fval, fval, fval, fval, fval, wfval, fval, fval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } try { tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval, fval, fval, fval, fval, fval, fval, wfval, fval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } try { tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval, fval, fval, fval, fval, fval, fval, fval, wfval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } wfval = new double[xval.length][yval.length][zval.length - 1]; try { tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval, wfval, fval, fval, fval, fval, fval, fval, fval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } try { tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval, fval, wfval, fval, fval, fval, fval, fval, fval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } try { tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval, fval, fval, wfval, fval, fval, fval, fval, fval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } try { tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval, fval, fval, fval, wfval, fval, fval, fval, fval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } try { tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval, fval, fval, fval, fval, wfval, fval, fval, fval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } try { tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval, fval, fval, fval, fval, fval, wfval, fval, fval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } try { tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval, fval, fval, fval, fval, fval, fval, wfval, fval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } try { tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval, fval, fval, fval, fval, fval, fval, fval, wfval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } } /** * Test for a plane. * <p> * f(x, y, z) = 2 x - 3 y - 4 z + 5 * </p> */ @Test public void testPlane() { double[] xval = new double[] {3, 4, 5, 6.5}; double[] yval = new double[] {-4, -3, -1, 2, 2.5}; double[] zval = new double[] {-12, -8, -5.5, -3, 0, 2.5}; // Function values TrivariateFunction f = new TrivariateFunction() { public double value(double x, double y, double z) { return 2 * x - 3 * y - 4 * z + 5; } }; double[][][] fval = new double[xval.length][yval.length][zval.length]; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { for (int k = 0; k < zval.length; k++) { fval[i][j][k] = f.value(xval[i], yval[j], zval[k]); } } } // Partial derivatives with respect to x double[][][] dFdX = new double[xval.length][yval.length][zval.length]; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { for (int k = 0; k < zval.length; k++) { dFdX[i][j][k] = 2; } } } // Partial derivatives with respect to y double[][][] dFdY = new double[xval.length][yval.length][zval.length]; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { for (int k = 0; k < zval.length; k++) { dFdY[i][j][k] = -3; } } } // Partial derivatives with respect to z double[][][] dFdZ = new double[xval.length][yval.length][zval.length]; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { for (int k = 0; k < zval.length; k++) { dFdZ[i][j][k] = -4; } } } // Partial cross-derivatives double[][][] d2FdXdY = new double[xval.length][yval.length][zval.length]; double[][][] d2FdXdZ = new double[xval.length][yval.length][zval.length]; double[][][] d2FdYdZ = new double[xval.length][yval.length][zval.length]; double[][][] d3FdXdYdZ = new double[xval.length][yval.length][zval.length]; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { for (int k = 0; k < zval.length; k++) { d2FdXdY[i][j][k] = 0; d2FdXdZ[i][j][k] = 0; d2FdYdZ[i][j][k] = 0; d3FdXdYdZ[i][j][k] = 0; } } } TrivariateFunction tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval, fval, dFdX, dFdY, dFdZ, d2FdXdY, d2FdXdZ, d2FdYdZ, d3FdXdYdZ); double x, y, z; double expected, result; x = 4; y = -3; z = 0; expected = f.value(x, y, z); result = tcf.value(x, y, z); Assert.assertEquals("On sample point", expected, result, 1e-15); x = 4.5; y = -1.5; z = -4.25; expected = f.value(x, y, z); result = tcf.value(x, y, z); Assert.assertEquals("Half-way between sample points (middle of the patch)", expected, result, 0.3); x = 3.5; y = -3.5; z = -10; expected = f.value(x, y, z); result = tcf.value(x, y, z); Assert.assertEquals("Half-way between sample points (border of the patch)", expected, result, 0.3); } /** * Sine wave. * <p> * f(x, y, z) = a cos [&omega; z - k<sub>y</sub> x - k<sub>y</sub> y] * </p> * with A = 0.2, &omega; = 0.5, k<sub>x</sub> = 2, k<sub>y</sub> = 1. */ @Test public void testWave() { double[] xval = new double[] {3, 4, 5, 6.5}; double[] yval = new double[] {-4, -3, -1, 2, 2.5}; double[] zval = new double[] {-12, -8, -5.5, -3, 0, 4}; final double a = 0.2; final double omega = 0.5; final double kx = 2; final double ky = 1; // Function values TrivariateFunction f = new TrivariateFunction() { public double value(double x, double y, double z) { return a * FastMath.cos(omega * z - kx * x - ky * y); } }; double[][][] fval = new double[xval.length][yval.length][zval.length]; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { for (int k = 0; k < zval.length; k++) { fval[i][j][k] = f.value(xval[i], yval[j], zval[k]); } } } // Partial derivatives with respect to x double[][][] dFdX = new double[xval.length][yval.length][zval.length]; TrivariateFunction dFdX_f = new TrivariateFunction() { public double value(double x, double y, double z) { return a * FastMath.sin(omega * z - kx * x - ky * y) * kx; } }; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { for (int k = 0; k < zval.length; k++) { dFdX[i][j][k] = dFdX_f.value(xval[i], yval[j], zval[k]); } } } // Partial derivatives with respect to y double[][][] dFdY = new double[xval.length][yval.length][zval.length]; TrivariateFunction dFdY_f = new TrivariateFunction() { public double value(double x, double y, double z) { return a * FastMath.sin(omega * z - kx * x - ky * y) * ky; } }; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { for (int k = 0; k < zval.length; k++) { dFdY[i][j][k] = dFdY_f.value(xval[i], yval[j], zval[k]); } } } // Partial derivatives with respect to z double[][][] dFdZ = new double[xval.length][yval.length][zval.length]; TrivariateFunction dFdZ_f = new TrivariateFunction() { public double value(double x, double y, double z) { return -a * FastMath.sin(omega * z - kx * x - ky * y) * omega; } }; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { for (int k = 0; k < zval.length; k++) { dFdZ[i][j][k] = dFdZ_f.value(xval[i], yval[j], zval[k]); } } } // Partial second derivatives w.r.t. (x, y) double[][][] d2FdXdY = new double[xval.length][yval.length][zval.length]; TrivariateFunction d2FdXdY_f = new TrivariateFunction() { public double value(double x, double y, double z) { return -a * FastMath.cos(omega * z - kx * x - ky * y) * kx * ky; } }; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { for (int k = 0; k < zval.length; k++) { d2FdXdY[i][j][k] = d2FdXdY_f.value(xval[i], yval[j], zval[k]); } } } // Partial second derivatives w.r.t. (x, z) double[][][] d2FdXdZ = new double[xval.length][yval.length][zval.length]; TrivariateFunction d2FdXdZ_f = new TrivariateFunction() { public double value(double x, double y, double z) { return a * FastMath.cos(omega * z - kx * x - ky * y) * kx * omega; } }; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { for (int k = 0; k < zval.length; k++) { d2FdXdZ[i][j][k] = d2FdXdZ_f.value(xval[i], yval[j], zval[k]); } } } // Partial second derivatives w.r.t. (y, z) double[][][] d2FdYdZ = new double[xval.length][yval.length][zval.length]; TrivariateFunction d2FdYdZ_f = new TrivariateFunction() { public double value(double x, double y, double z) { return a * FastMath.cos(omega * z - kx * x - ky * y) * ky * omega; } }; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { for (int k = 0; k < zval.length; k++) { d2FdYdZ[i][j][k] = d2FdYdZ_f.value(xval[i], yval[j], zval[k]); } } } // Partial third derivatives double[][][] d3FdXdYdZ = new double[xval.length][yval.length][zval.length]; TrivariateFunction d3FdXdYdZ_f = new TrivariateFunction() { public double value(double x, double y, double z) { return a * FastMath.sin(omega * z - kx * x - ky * y) * kx * ky * omega; } }; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { for (int k = 0; k < zval.length; k++) { d3FdXdYdZ[i][j][k] = d3FdXdYdZ_f.value(xval[i], yval[j], zval[k]); } } } TrivariateFunction tcf = new TricubicSplineInterpolatingFunction(xval, yval, zval, fval, dFdX, dFdY, dFdZ, d2FdXdY, d2FdXdZ, d2FdYdZ, d3FdXdYdZ); double x, y, z; double expected, result; x = 4; y = -3; z = 0; expected = f.value(x, y, z); result = tcf.value(x, y, z); Assert.assertEquals("On sample point", expected, result, 1e-14); x = 4.5; y = -1.5; z = -4.25; expected = f.value(x, y, z); result = tcf.value(x, y, z); Assert.assertEquals("Half-way between sample points (middle of the patch)", expected, result, 0.1); x = 3.5; y = -3.5; z = -10; expected = f.value(x, y, z); result = tcf.value(x, y, z); Assert.assertEquals("Half-way between sample points (border of the patch)", expected, result, 0.1); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.interpolation; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.analysis.TrivariateFunction; import org.junit.Assert; import org.junit.Test; import org.junit.Ignore; /** * Test case for the tricubic interpolator. * * @version $Id$ */ public final class TricubicSplineInterpolatorTest { /** * Test preconditions. */ @Test public void testPreconditions() { double[] xval = new double[] {3, 4, 5, 6.5}; double[] yval = new double[] {-4, -3, -1, 2.5}; double[] zval = new double[] {-12, -8, -5.5, -3, 0, 2.5}; double[][][] fval = new double[xval.length][yval.length][zval.length]; TrivariateGridInterpolator interpolator = new TricubicSplineInterpolator(); @SuppressWarnings("unused") TrivariateFunction p = interpolator.interpolate(xval, yval, zval, fval); double[] wxval = new double[] {3, 2, 5, 6.5}; try { p = interpolator.interpolate(wxval, yval, zval, fval); Assert.fail("an exception should have been thrown"); } catch (MathIllegalArgumentException e) { // Expected } double[] wyval = new double[] {-4, -3, -1, -1}; try { p = interpolator.interpolate(xval, wyval, zval, fval); Assert.fail("an exception should have been thrown"); } catch (MathIllegalArgumentException e) { // Expected } double[] wzval = new double[] {-12, -8, -5.5, -3, -4, 2.5}; try { p = interpolator.interpolate(xval, yval, wzval, fval); Assert.fail("an exception should have been thrown"); } catch (MathIllegalArgumentException e) { // Expected } double[][][] wfval = new double[xval.length][yval.length + 1][zval.length]; try { p = interpolator.interpolate(xval, yval, zval, wfval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } wfval = new double[xval.length - 1][yval.length][zval.length]; try { p = interpolator.interpolate(xval, yval, zval, wfval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } wfval = new double[xval.length][yval.length][zval.length - 1]; try { p = interpolator.interpolate(xval, yval, zval, wfval); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException e) { // Expected } } /** * Test of interpolator for a plane. * <p> * f(x, y, z) = 2 x - 3 y - z + 5 */ @Ignore@Test public void testPlane() { TrivariateFunction f = new TrivariateFunction() { public double value(double x, double y, double z) { return 2 * x - 3 * y - z + 5; } }; TrivariateGridInterpolator interpolator = new TricubicSplineInterpolator(); double[] xval = new double[] {3, 4, 5, 6.5}; double[] yval = new double[] {-4, -3, -1, 2, 2.5}; double[] zval = new double[] {-12, -8, -5.5, -3, 0, 2.5}; double[][][] fval = new double[xval.length][yval.length][zval.length]; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { for (int k = 0; k < zval.length; k++) { fval[i][j][k] = f.value(xval[i], yval[j], zval[k]); } } } TrivariateFunction p = interpolator.interpolate(xval, yval, zval, fval); double x, y, z; double expected, result; x = 4; y = -3; z = 0; expected = f.value(x, y, z); result = p.value(x, y, z); Assert.assertEquals("On sample point", expected, result, 1e-15); x = 4.5; y = -1.5; z = -4.25; expected = f.value(x, y, z); result = p.value(x, y, z); Assert.assertEquals("half-way between sample points (middle of the patch)", expected, result, 0.3); x = 3.5; y = -3.5; z = -10; expected = f.value(x, y, z); result = p.value(x, y, z); Assert.assertEquals("half-way between sample points (border of the patch)", expected, result, 0.3); } /** * Test of interpolator for a sine wave. * <p> * <p> * f(x, y, z) = a cos [&omega; z - k<sub>y</sub> x - k<sub>y</sub> y] * </p> * with A = 0.2, &omega; = 0.5, k<sub>x</sub> = 2, k<sub>y</sub> = 1. */ @Ignore@Test public void testWave() { double[] xval = new double[] {3, 4, 5, 6.5}; double[] yval = new double[] {-4, -3, -1, 2, 2.5}; double[] zval = new double[] {-12, -8, -5.5, -3, 0, 4}; final double a = 0.2; final double omega = 0.5; final double kx = 2; final double ky = 1; // Function values TrivariateFunction f = new TrivariateFunction() { public double value(double x, double y, double z) { return a * FastMath.cos(omega * z - kx * x - ky * y); } }; double[][][] fval = new double[xval.length][yval.length][zval.length]; for (int i = 0; i < xval.length; i++) { for (int j = 0; j < yval.length; j++) { for (int k = 0; k < zval.length; k++) { fval[i][j][k] = f.value(xval[i], yval[j], zval[k]); } } } TrivariateGridInterpolator interpolator = new TricubicSplineInterpolator(); TrivariateFunction p = interpolator.interpolate(xval, yval, zval, fval); double x, y, z; double expected, result; x = 4; y = -3; z = 0; expected = f.value(x, y, z); result = p.value(x, y, z); Assert.assertEquals("On sample point", expected, result, 1e-12); x = 4.5; y = -1.5; z = -4.25; expected = f.value(x, y, z); result = p.value(x, y, z); Assert.assertEquals("Half-way between sample points (middle of the patch)", expected, result, 0.1); x = 3.5; y = -3.5; z = -10; expected = f.value(x, y, z); result = p.value(x, y, z); Assert.assertEquals("Half-way between sample points (border of the patch)", expected, result, 0.1); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.interpolation; import java.util.Random; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.exception.NonMonotonicSequenceException; import org.junit.Assert; import org.junit.Test; /** * Test for {@link UnivariatePeriodicInterpolator}. */ public class UnivariatePeriodicInterpolatorTest { private final Random rng = new Random(1224465L); @Test public void testSine() { final int n = 30; final double[] xval = new double[n]; final double[] yval = new double[n]; final double period = 12.3; final double offset = 45.67; double delta = 0; for (int i = 0; i < n; i++) { delta += rng.nextDouble() * period / n; xval[i] = offset + delta; yval[i] = FastMath.sin(xval[i]); } final UnivariateInterpolator inter = new LinearInterpolator(); final UnivariateFunction f = inter.interpolate(xval, yval); final UnivariateInterpolator interP = new UnivariatePeriodicInterpolator(new LinearInterpolator(), period, 1); final UnivariateFunction fP = interP.interpolate(xval, yval); // Comparing with original interpolation algorithm. final double xMin = xval[0]; final double xMax = xval[n - 1]; for (int i = 0; i < n; i++) { final double x = xMin + (xMax - xMin) * rng.nextDouble(); final double y = f.value(x); final double yP = fP.value(x); Assert.assertEquals("x=" + x, y, yP, Math.ulp(1d)); } // Test interpolation outside the primary interval. for (int i = 0; i < n; i++) { final double xIn = offset + rng.nextDouble() * period; final double xOut = xIn + rng.nextInt(123456789) * period; final double yIn = fP.value(xIn); final double yOut = fP.value(xOut); Assert.assertEquals(yIn, yOut, 1e-7); } } @Test public void testLessThanOnePeriodCoverage() { final int n = 30; final double[] xval = new double[n]; final double[] yval = new double[n]; final double period = 12.3; final double offset = 45.67; double delta = period / 2; for (int i = 0; i < n; i++) { delta += period / (2 * n) * rng.nextDouble(); xval[i] = offset + delta; yval[i] = FastMath.sin(xval[i]); } final UnivariateInterpolator interP = new UnivariatePeriodicInterpolator(new LinearInterpolator(), period, 1); final UnivariateFunction fP = interP.interpolate(xval, yval); // Test interpolation outside the sample data interval. for (int i = 0; i < n; i++) { final double xIn = offset + rng.nextDouble() * period; final double xOut = xIn + rng.nextInt(123456789) * period; final double yIn = fP.value(xIn); final double yOut = fP.value(xOut); Assert.assertEquals(yIn, yOut, 1e-7); } } @Test public void testMoreThanOnePeriodCoverage() { final int n = 30; final double[] xval = new double[n]; final double[] yval = new double[n]; final double period = 12.3; final double offset = 45.67; double delta = period / 2; for (int i = 0; i < n; i++) { delta += 10 * period / n * rng.nextDouble(); xval[i] = offset + delta; yval[i] = FastMath.sin(xval[i]); } final UnivariateInterpolator interP = new UnivariatePeriodicInterpolator(new LinearInterpolator(), period, 1); final UnivariateFunction fP = interP.interpolate(xval, yval); // Test interpolation outside the sample data interval. for (int i = 0; i < n; i++) { final double xIn = offset + rng.nextDouble() * period; final double xOut = xIn + rng.nextInt(123456789) * period; final double yIn = fP.value(xIn); final double yOut = fP.value(xOut); Assert.assertEquals(yIn, yOut, 1e-6); } } @Test(expected=NumberIsTooSmallException.class) public void testTooFewSamples() { final double[] xval = { 2, 3, 7 }; final double[] yval = { 1, 6, 5 }; final double period = 10; final UnivariateInterpolator interpolator = new UnivariatePeriodicInterpolator(new LinearInterpolator(), period); interpolator.interpolate(xval, yval); } @Test(expected=NonMonotonicSequenceException.class) public void testUnsortedSamples() { final double[] xval = { 2, 3, 7, 4, 6 }; final double[] yval = { 1, 6, 5, -1, -2 }; final double period = 10; final UnivariateInterpolator interpolator = new UnivariatePeriodicInterpolator(new LinearInterpolator(), period); interpolator.interpolate(xval, yval); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.polynomials; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.junit.Assert; import org.junit.Test; /** * Test case for Lagrange form of polynomial function. * <p> * We use n+1 points to interpolate a polynomial of degree n. This should * give us the exact same polynomial as result. Thus we can use a very * small tolerance to account only for round-off errors. * * @version $Id$ */ public final class PolynomialFunctionLagrangeFormTest { /** * Test of polynomial for the linear function. */ @Test public void testLinearFunction() { PolynomialFunctionLagrangeForm p; double c[], z, expected, result, tolerance = 1E-12; // p(x) = 1.5x - 4 double x[] = { 0.0, 3.0 }; double y[] = { -4.0, 0.5 }; p = new PolynomialFunctionLagrangeForm(x, y); z = 2.0; expected = -1.0; result = p.value(z); Assert.assertEquals(expected, result, tolerance); z = 4.5; expected = 2.75; result = p.value(z); Assert.assertEquals(expected, result, tolerance); z = 6.0; expected = 5.0; result = p.value(z); Assert.assertEquals(expected, result, tolerance); Assert.assertEquals(1, p.degree()); c = p.getCoefficients(); Assert.assertEquals(2, c.length); Assert.assertEquals(-4.0, c[0], tolerance); Assert.assertEquals(1.5, c[1], tolerance); } /** * Test of polynomial for the quadratic function. */ @Test public void testQuadraticFunction() { PolynomialFunctionLagrangeForm p; double c[], z, expected, result, tolerance = 1E-12; // p(x) = 2x^2 + 5x - 3 = (2x - 1)(x + 3) double x[] = { 0.0, -1.0, 0.5 }; double y[] = { -3.0, -6.0, 0.0 }; p = new PolynomialFunctionLagrangeForm(x, y); z = 1.0; expected = 4.0; result = p.value(z); Assert.assertEquals(expected, result, tolerance); z = 2.5; expected = 22.0; result = p.value(z); Assert.assertEquals(expected, result, tolerance); z = -2.0; expected = -5.0; result = p.value(z); Assert.assertEquals(expected, result, tolerance); Assert.assertEquals(2, p.degree()); c = p.getCoefficients(); Assert.assertEquals(3, c.length); Assert.assertEquals(-3.0, c[0], tolerance); Assert.assertEquals(5.0, c[1], tolerance); Assert.assertEquals(2.0, c[2], tolerance); } /** * Test of polynomial for the quintic function. */ @Test public void testQuinticFunction() { PolynomialFunctionLagrangeForm p; double c[], z, expected, result, tolerance = 1E-12; // p(x) = x^5 - x^4 - 7x^3 + x^2 + 6x = x(x^2 - 1)(x + 2)(x - 3) double x[] = { 1.0, -1.0, 2.0, 3.0, -3.0, 0.5 }; double y[] = { 0.0, 0.0, -24.0, 0.0, -144.0, 2.34375 }; p = new PolynomialFunctionLagrangeForm(x, y); z = 0.0; expected = 0.0; result = p.value(z); Assert.assertEquals(expected, result, tolerance); z = -2.0; expected = 0.0; result = p.value(z); Assert.assertEquals(expected, result, tolerance); z = 4.0; expected = 360.0; result = p.value(z); Assert.assertEquals(expected, result, tolerance); Assert.assertEquals(5, p.degree()); c = p.getCoefficients(); Assert.assertEquals(6, c.length); Assert.assertEquals(0.0, c[0], tolerance); Assert.assertEquals(6.0, c[1], tolerance); Assert.assertEquals(1.0, c[2], tolerance); Assert.assertEquals(-7.0, c[3], tolerance); Assert.assertEquals(-1.0, c[4], tolerance); Assert.assertEquals(1.0, c[5], tolerance); } /** * Test of parameters for the polynomial. */ @Test public void testParameters() { try { // bad input array length double x[] = { 1.0 }; double y[] = { 2.0 }; new PolynomialFunctionLagrangeForm(x, y); Assert.fail("Expecting MathIllegalArgumentException - bad input array length"); } catch (MathIllegalArgumentException ex) { // expected } try { // mismatch input arrays double x[] = { 1.0, 2.0, 3.0, 4.0 }; double y[] = { 0.0, -4.0, -24.0 }; new PolynomialFunctionLagrangeForm(x, y); Assert.fail("Expecting MathIllegalArgumentException - mismatch input arrays"); } catch (MathIllegalArgumentException ex) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.polynomials; import org.apache.commons.math3.analysis.differentiation.DerivativeStructure; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.junit.Assert; import org.junit.Test; /** * Test case for Newton form of polynomial function. * <p> * The small tolerance number is used only to account for round-off errors. * * @version $Id$ */ public final class PolynomialFunctionNewtonFormTest { /** * Test of polynomial for the linear function. */ @Test public void testLinearFunction() { PolynomialFunctionNewtonForm p; double coefficients[], z, expected, result, tolerance = 1E-12; // p(x) = 1.5x - 4 = 2 + 1.5(x-4) double a[] = { 2.0, 1.5 }; double c[] = { 4.0 }; p = new PolynomialFunctionNewtonForm(a, c); z = 2.0; expected = -1.0; result = p.value(z); Assert.assertEquals(expected, result, tolerance); z = 4.5; expected = 2.75; result = p.value(z); Assert.assertEquals(expected, result, tolerance); z = 6.0; expected = 5.0; result = p.value(z); Assert.assertEquals(expected, result, tolerance); Assert.assertEquals(1, p.degree()); coefficients = p.getCoefficients(); Assert.assertEquals(2, coefficients.length); Assert.assertEquals(-4.0, coefficients[0], tolerance); Assert.assertEquals(1.5, coefficients[1], tolerance); } /** * Test of polynomial for the quadratic function. */ @Test public void testQuadraticFunction() { PolynomialFunctionNewtonForm p; double coefficients[], z, expected, result, tolerance = 1E-12; // p(x) = 2x^2 + 5x - 3 = 4 + 3(x-1) + 2(x-1)(x+2) double a[] = { 4.0, 3.0, 2.0 }; double c[] = { 1.0, -2.0 }; p = new PolynomialFunctionNewtonForm(a, c); z = 1.0; expected = 4.0; result = p.value(z); Assert.assertEquals(expected, result, tolerance); z = 2.5; expected = 22.0; result = p.value(z); Assert.assertEquals(expected, result, tolerance); z = -2.0; expected = -5.0; result = p.value(z); Assert.assertEquals(expected, result, tolerance); Assert.assertEquals(2, p.degree()); coefficients = p.getCoefficients(); Assert.assertEquals(3, coefficients.length); Assert.assertEquals(-3.0, coefficients[0], tolerance); Assert.assertEquals(5.0, coefficients[1], tolerance); Assert.assertEquals(2.0, coefficients[2], tolerance); } /** * Test of polynomial for the quintic function. */ @Test public void testQuinticFunction() { PolynomialFunctionNewtonForm p; double coefficients[], z, expected, result, tolerance = 1E-12; // p(x) = x^5 - x^4 - 7x^3 + x^2 + 6x // = 6x - 6x^2 -6x^2(x-1) + x^2(x-1)(x+1) + x^2(x-1)(x+1)(x-2) double a[] = { 0.0, 6.0, -6.0, -6.0, 1.0, 1.0 }; double c[] = { 0.0, 0.0, 1.0, -1.0, 2.0 }; p = new PolynomialFunctionNewtonForm(a, c); z = 0.0; expected = 0.0; result = p.value(z); Assert.assertEquals(expected, result, tolerance); z = -2.0; expected = 0.0; result = p.value(z); Assert.assertEquals(expected, result, tolerance); z = 4.0; expected = 360.0; result = p.value(z); Assert.assertEquals(expected, result, tolerance); Assert.assertEquals(5, p.degree()); coefficients = p.getCoefficients(); Assert.assertEquals(6, coefficients.length); Assert.assertEquals(0.0, coefficients[0], tolerance); Assert.assertEquals(6.0, coefficients[1], tolerance); Assert.assertEquals(1.0, coefficients[2], tolerance); Assert.assertEquals(-7.0, coefficients[3], tolerance); Assert.assertEquals(-1.0, coefficients[4], tolerance); Assert.assertEquals(1.0, coefficients[5], tolerance); } /** * Test for derivatives. */ @Test public void testDerivative() { // x^3 = 0 * [1] + 1 * [x] + 3 * [x(x-1)] + 1 * [x(x-1)(x-2)] PolynomialFunctionNewtonForm p = new PolynomialFunctionNewtonForm(new double[] { 0, 1, 3, 1 }, new double[] { 0, 1, 2 }); double eps = 2.0e-14; for (double t = 0.0; t < 10.0; t += 0.1) { DerivativeStructure x = new DerivativeStructure(1, 4, 0, t); DerivativeStructure y = p.value(x); Assert.assertEquals(t * t * t, y.getValue(), eps * t * t * t); Assert.assertEquals(3.0 * t * t, y.getPartialDerivative(1), eps * 3.0 * t * t); Assert.assertEquals(6.0 * t, y.getPartialDerivative(2), eps * 6.0 * t); Assert.assertEquals(6.0, y.getPartialDerivative(3), eps * 6.0); Assert.assertEquals(0.0, y.getPartialDerivative(4), eps); } } /** * Test of parameters for the polynomial. */ @Test public void testParameters() { try { // bad input array length double a[] = { 1.0 }; double c[] = { 2.0 }; new PolynomialFunctionNewtonForm(a, c); Assert.fail("Expecting MathIllegalArgumentException - bad input array length"); } catch (MathIllegalArgumentException ex) { // expected } try { // mismatch input arrays double a[] = { 1.0, 2.0, 3.0, 4.0 }; double c[] = { 4.0, 3.0, 2.0, 1.0 }; new PolynomialFunctionNewtonForm(a, c); Assert.fail("Expecting MathIllegalArgumentException - mismatch input arrays"); } catch (MathIllegalArgumentException ex) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.polynomials; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.util.FastMath; import org.junit.Test; import org.junit.Assert; /** * Tests the PolynomialFunction implementation of a UnivariateFunction. * * @version $Id$ */ public final class PolynomialFunctionTest { /** Error tolerance for tests */ protected double tolerance = 1e-12; /** * tests the value of a constant polynomial. * * <p>value of this is 2.5 everywhere.</p> */ @Test public void testConstants() { double[] c = { 2.5 }; PolynomialFunction f = new PolynomialFunction(c); // verify that we are equal to c[0] at several (nonsymmetric) places Assert.assertEquals(f.value(0), c[0], tolerance); Assert.assertEquals(f.value(-1), c[0], tolerance); Assert.assertEquals(f.value(-123.5), c[0], tolerance); Assert.assertEquals(f.value(3), c[0], tolerance); Assert.assertEquals(f.value(456.89), c[0], tolerance); Assert.assertEquals(f.degree(), 0); Assert.assertEquals(f.derivative().value(0), 0, tolerance); Assert.assertEquals(f.polynomialDerivative().derivative().value(0), 0, tolerance); } /** * tests the value of a linear polynomial. * * <p>This will test the function f(x) = 3*x - 1.5</p> * <p>This will have the values * <tt>f(0) = -1.5, f(-1) = -4.5, f(-2.5) = -9, * f(0.5) = 0, f(1.5) = 3</tt> and <tt>f(3) = 7.5</tt> * </p> */ @Test public void testLinear() { double[] c = { -1.5, 3 }; PolynomialFunction f = new PolynomialFunction(c); // verify that we are equal to c[0] when x=0 Assert.assertEquals(f.value(0), c[0], tolerance); // now check a few other places Assert.assertEquals(-4.5, f.value(-1), tolerance); Assert.assertEquals(-9, f.value(-2.5), tolerance); Assert.assertEquals(0, f.value(0.5), tolerance); Assert.assertEquals(3, f.value(1.5), tolerance); Assert.assertEquals(7.5, f.value(3), tolerance); Assert.assertEquals(f.degree(), 1); Assert.assertEquals(f.polynomialDerivative().derivative().value(0), 0, tolerance); } /** * Tests a second order polynomial. * <p> This will test the function f(x) = 2x^2 - 3x -2 = (2x+1)(x-2)</p> */ @Test public void testQuadratic() { double[] c = { -2, -3, 2 }; PolynomialFunction f = new PolynomialFunction(c); // verify that we are equal to c[0] when x=0 Assert.assertEquals(f.value(0), c[0], tolerance); // now check a few other places Assert.assertEquals(0, f.value(-0.5), tolerance); Assert.assertEquals(0, f.value(2), tolerance); Assert.assertEquals(-2, f.value(1.5), tolerance); Assert.assertEquals(7, f.value(-1.5), tolerance); Assert.assertEquals(265.5312, f.value(12.34), tolerance); } /** * This will test the quintic function * f(x) = x^2(x-5)(x+3)(x-1) = x^5 - 3x^4 -13x^3 + 15x^2</p> */ @Test public void testQuintic() { double[] c = { 0, 0, 15, -13, -3, 1 }; PolynomialFunction f = new PolynomialFunction(c); // verify that we are equal to c[0] when x=0 Assert.assertEquals(f.value(0), c[0], tolerance); // now check a few other places Assert.assertEquals(0, f.value(5), tolerance); Assert.assertEquals(0, f.value(1), tolerance); Assert.assertEquals(0, f.value(-3), tolerance); Assert.assertEquals(54.84375, f.value(-1.5), tolerance); Assert.assertEquals(-8.06637, f.value(1.3), tolerance); Assert.assertEquals(f.degree(), 5); } /** * tests the firstDerivative function by comparison * * <p>This will test the functions * <tt>f(x) = x^3 - 2x^2 + 6x + 3, g(x) = 3x^2 - 4x + 6</tt> * and <tt>h(x) = 6x - 4</tt> */ @Test public void testfirstDerivativeComparison() { double[] f_coeff = { 3, 6, -2, 1 }; double[] g_coeff = { 6, -4, 3 }; double[] h_coeff = { -4, 6 }; PolynomialFunction f = new PolynomialFunction(f_coeff); PolynomialFunction g = new PolynomialFunction(g_coeff); PolynomialFunction h = new PolynomialFunction(h_coeff); // compare f' = g Assert.assertEquals(f.derivative().value(0), g.value(0), tolerance); Assert.assertEquals(f.derivative().value(1), g.value(1), tolerance); Assert.assertEquals(f.derivative().value(100), g.value(100), tolerance); Assert.assertEquals(f.derivative().value(4.1), g.value(4.1), tolerance); Assert.assertEquals(f.derivative().value(-3.25), g.value(-3.25), tolerance); // compare g' = h Assert.assertEquals(g.derivative().value(FastMath.PI), h.value(FastMath.PI), tolerance); Assert.assertEquals(g.derivative().value(FastMath.E), h.value(FastMath.E), tolerance); } @Test public void testString() { PolynomialFunction p = new PolynomialFunction(new double[] { -5, 3, 1 }); checkPolynomial(p, "-5 + 3 x + x^2"); checkPolynomial(new PolynomialFunction(new double[] { 0, -2, 3 }), "-2 x + 3 x^2"); checkPolynomial(new PolynomialFunction(new double[] { 1, -2, 3 }), "1 - 2 x + 3 x^2"); checkPolynomial(new PolynomialFunction(new double[] { 0, 2, 3 }), "2 x + 3 x^2"); checkPolynomial(new PolynomialFunction(new double[] { 1, 2, 3 }), "1 + 2 x + 3 x^2"); checkPolynomial(new PolynomialFunction(new double[] { 1, 0, 3 }), "1 + 3 x^2"); checkPolynomial(new PolynomialFunction(new double[] { 0 }), "0"); } @Test public void testAddition() { PolynomialFunction p1 = new PolynomialFunction(new double[] { -2, 1 }); PolynomialFunction p2 = new PolynomialFunction(new double[] { 2, -1, 0 }); checkNullPolynomial(p1.add(p2)); p2 = p1.add(p1); checkPolynomial(p2, "-4 + 2 x"); p1 = new PolynomialFunction(new double[] { 1, -4, 2 }); p2 = new PolynomialFunction(new double[] { -1, 3, -2 }); p1 = p1.add(p2); Assert.assertEquals(1, p1.degree()); checkPolynomial(p1, "-x"); } @Test public void testSubtraction() { PolynomialFunction p1 = new PolynomialFunction(new double[] { -2, 1 }); checkNullPolynomial(p1.subtract(p1)); PolynomialFunction p2 = new PolynomialFunction(new double[] { -2, 6 }); p2 = p2.subtract(p1); checkPolynomial(p2, "5 x"); p1 = new PolynomialFunction(new double[] { 1, -4, 2 }); p2 = new PolynomialFunction(new double[] { -1, 3, 2 }); p1 = p1.subtract(p2); Assert.assertEquals(1, p1.degree()); checkPolynomial(p1, "2 - 7 x"); } @Test public void testMultiplication() { PolynomialFunction p1 = new PolynomialFunction(new double[] { -3, 2 }); PolynomialFunction p2 = new PolynomialFunction(new double[] { 3, 2, 1 }); checkPolynomial(p1.multiply(p2), "-9 + x^2 + 2 x^3"); p1 = new PolynomialFunction(new double[] { 0, 1 }); p2 = p1; for (int i = 2; i < 10; ++i) { p2 = p2.multiply(p1); checkPolynomial(p2, "x^" + i); } } @Test public void testSerial() { PolynomialFunction p2 = new PolynomialFunction(new double[] { 3, 2, 1 }); Assert.assertEquals(p2, TestUtils.serializeAndRecover(p2)); } /** * tests the firstDerivative function by comparison * * <p>This will test the functions * <tt>f(x) = x^3 - 2x^2 + 6x + 3, g(x) = 3x^2 - 4x + 6</tt> * and <tt>h(x) = 6x - 4</tt> */ @Test public void testMath341() { double[] f_coeff = { 3, 6, -2, 1 }; double[] g_coeff = { 6, -4, 3 }; double[] h_coeff = { -4, 6 }; PolynomialFunction f = new PolynomialFunction(f_coeff); PolynomialFunction g = new PolynomialFunction(g_coeff); PolynomialFunction h = new PolynomialFunction(h_coeff); // compare f' = g Assert.assertEquals(f.derivative().value(0), g.value(0), tolerance); Assert.assertEquals(f.derivative().value(1), g.value(1), tolerance); Assert.assertEquals(f.derivative().value(100), g.value(100), tolerance); Assert.assertEquals(f.derivative().value(4.1), g.value(4.1), tolerance); Assert.assertEquals(f.derivative().value(-3.25), g.value(-3.25), tolerance); // compare g' = h Assert.assertEquals(g.derivative().value(FastMath.PI), h.value(FastMath.PI), tolerance); Assert.assertEquals(g.derivative().value(FastMath.E), h.value(FastMath.E), tolerance); } public void checkPolynomial(PolynomialFunction p, String reference) { Assert.assertEquals(reference, p.toString()); } private void checkNullPolynomial(PolynomialFunction p) { for (double coefficient : p.getCoefficients()) { Assert.assertEquals(0, coefficient, 1e-15); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.polynomials; import java.util.Arrays; import org.apache.commons.math3.exception.OutOfRangeException; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.exception.MathIllegalStateException; import org.junit.Assert; import org.junit.Test; /** * Tests the PolynomialSplineFunction implementation. * * @version $Id$ */ public class PolynomialSplineFunctionTest { /** Error tolerance for tests */ protected double tolerance = 1.0e-12; /** * Quadratic polynomials used in tests: * * x^2 + x [-1, 0) * x^2 + x + 2 [0, 1) * x^2 + x + 4 [1, 2) * * Defined so that evaluation using PolynomialSplineFunction evaluation * algorithm agrees at knot point boundaries. */ protected PolynomialFunction[] polynomials = { new PolynomialFunction(new double[] {0d, 1d, 1d}), new PolynomialFunction(new double[] {2d, 1d, 1d}), new PolynomialFunction(new double[] {4d, 1d, 1d}) }; /** Knot points */ protected double[] knots = {-1, 0, 1, 2}; /** Derivative of test polynomials -- 2x + 1 */ protected PolynomialFunction dp = new PolynomialFunction(new double[] {1d, 2d}); @Test public void testConstructor() { PolynomialSplineFunction spline = new PolynomialSplineFunction(knots, polynomials); Assert.assertTrue(Arrays.equals(knots, spline.getKnots())); Assert.assertEquals(1d, spline.getPolynomials()[0].getCoefficients()[2], 0); Assert.assertEquals(3, spline.getN()); try { // too few knots new PolynomialSplineFunction(new double[] {0}, polynomials); Assert.fail("Expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // expected } try { // too many knots new PolynomialSplineFunction(new double[] {0,1,2,3,4}, polynomials); Assert.fail("Expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // expected } try { // knots not increasing new PolynomialSplineFunction(new double[] {0,1, 3, 2}, polynomials); Assert.fail("Expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // expected } } @Test public void testValues() { PolynomialSplineFunction spline = new PolynomialSplineFunction(knots, polynomials); UnivariateFunction dSpline = spline.derivative(); /** * interior points -- spline value at x should equal p(x - knot) * where knot is the largest knot point less than or equal to x and p * is the polynomial defined over the knot segment to which x belongs. */ double x = -1; int index = 0; for (int i = 0; i < 10; i++) { x+=0.25; index = findKnot(knots, x); Assert.assertEquals("spline function evaluation failed for x=" + x, polynomials[index].value(x - knots[index]), spline.value(x), tolerance); Assert.assertEquals("spline derivative evaluation failed for x=" + x, dp.value(x - knots[index]), dSpline.value(x), tolerance); } // knot points -- centering should zero arguments for (int i = 0; i < 3; i++) { Assert.assertEquals("spline function evaluation failed for knot=" + knots[i], polynomials[i].value(0), spline.value(knots[i]), tolerance); Assert.assertEquals("spline function evaluation failed for knot=" + knots[i], dp.value(0), dSpline.value(knots[i]), tolerance); } try { //outside of domain -- under min x = spline.value(-1.5); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { //outside of domain -- over max x = spline.value(2.5); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testIsValidPoint() { final PolynomialSplineFunction spline = new PolynomialSplineFunction(knots, polynomials); final double xMin = knots[0]; final double xMax = knots[knots.length - 1]; double x; x = xMin; Assert.assertTrue(spline.isValidPoint(x)); // Ensure that no exception is thrown. spline.value(x); x = xMax; Assert.assertTrue(spline.isValidPoint(x)); // Ensure that no exception is thrown. spline.value(x); final double xRange = xMax - xMin; x = xMin + xRange / 3.4; Assert.assertTrue(spline.isValidPoint(x)); // Ensure that no exception is thrown. spline.value(x); final double small = 1e-8; x = xMin - small; Assert.assertFalse(spline.isValidPoint(x)); // Ensure that an exception would have been thrown. try { spline.value(x); Assert.fail("OutOfRangeException expected"); } catch (OutOfRangeException expected) {} } /** * Do linear search to find largest knot point less than or equal to x. * Implementation does binary search. */ protected int findKnot(double[] knots, double x) { if (x < knots[0] || x >= knots[knots.length -1]) { throw new OutOfRangeException(x, knots[0], knots[knots.length -1]); } for (int i = 0; i < knots.length; i++) { if (knots[i] > x) { return i - 1; } } throw new MathIllegalStateException(); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.polynomials; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.integration.IterativeLegendreGaussIntegrator; import org.apache.commons.math3.util.CombinatoricsUtils; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.util.Precision; import org.junit.Assert; import org.junit.Test; /** * Tests the PolynomialsUtils class. * * @version $Id$ */ public class PolynomialsUtilsTest { @Test public void testFirstChebyshevPolynomials() { checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(3), "-3 x + 4 x^3"); checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(2), "-1 + 2 x^2"); checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(1), "x"); checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(0), "1"); checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(7), "-7 x + 56 x^3 - 112 x^5 + 64 x^7"); checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(6), "-1 + 18 x^2 - 48 x^4 + 32 x^6"); checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(5), "5 x - 20 x^3 + 16 x^5"); checkPolynomial(PolynomialsUtils.createChebyshevPolynomial(4), "1 - 8 x^2 + 8 x^4"); } @Test public void testChebyshevBounds() { for (int k = 0; k < 12; ++k) { PolynomialFunction Tk = PolynomialsUtils.createChebyshevPolynomial(k); for (double x = -1; x <= 1; x += 0.02) { Assert.assertTrue(k + " " + Tk.value(x), FastMath.abs(Tk.value(x)) < (1 + 1e-12)); } } } @Test public void testChebyshevDifferentials() { for (int k = 0; k < 12; ++k) { PolynomialFunction Tk0 = PolynomialsUtils.createChebyshevPolynomial(k); PolynomialFunction Tk1 = Tk0.polynomialDerivative(); PolynomialFunction Tk2 = Tk1.polynomialDerivative(); PolynomialFunction g0 = new PolynomialFunction(new double[] { k * k }); PolynomialFunction g1 = new PolynomialFunction(new double[] { 0, -1}); PolynomialFunction g2 = new PolynomialFunction(new double[] { 1, 0, -1 }); PolynomialFunction Tk0g0 = Tk0.multiply(g0); PolynomialFunction Tk1g1 = Tk1.multiply(g1); PolynomialFunction Tk2g2 = Tk2.multiply(g2); checkNullPolynomial(Tk0g0.add(Tk1g1.add(Tk2g2))); } } @Test public void testChebyshevOrthogonality() { UnivariateFunction weight = new UnivariateFunction() { public double value(double x) { return 1 / FastMath.sqrt(1 - x * x); } }; for (int i = 0; i < 10; ++i) { PolynomialFunction pi = PolynomialsUtils.createChebyshevPolynomial(i); for (int j = 0; j <= i; ++j) { PolynomialFunction pj = PolynomialsUtils.createChebyshevPolynomial(j); checkOrthogonality(pi, pj, weight, -0.9999, 0.9999, 1.5, 0.03); } } } @Test public void testFirstHermitePolynomials() { checkPolynomial(PolynomialsUtils.createHermitePolynomial(3), "-12 x + 8 x^3"); checkPolynomial(PolynomialsUtils.createHermitePolynomial(2), "-2 + 4 x^2"); checkPolynomial(PolynomialsUtils.createHermitePolynomial(1), "2 x"); checkPolynomial(PolynomialsUtils.createHermitePolynomial(0), "1"); checkPolynomial(PolynomialsUtils.createHermitePolynomial(7), "-1680 x + 3360 x^3 - 1344 x^5 + 128 x^7"); checkPolynomial(PolynomialsUtils.createHermitePolynomial(6), "-120 + 720 x^2 - 480 x^4 + 64 x^6"); checkPolynomial(PolynomialsUtils.createHermitePolynomial(5), "120 x - 160 x^3 + 32 x^5"); checkPolynomial(PolynomialsUtils.createHermitePolynomial(4), "12 - 48 x^2 + 16 x^4"); } @Test public void testHermiteDifferentials() { for (int k = 0; k < 12; ++k) { PolynomialFunction Hk0 = PolynomialsUtils.createHermitePolynomial(k); PolynomialFunction Hk1 = Hk0.polynomialDerivative(); PolynomialFunction Hk2 = Hk1.polynomialDerivative(); PolynomialFunction g0 = new PolynomialFunction(new double[] { 2 * k }); PolynomialFunction g1 = new PolynomialFunction(new double[] { 0, -2 }); PolynomialFunction g2 = new PolynomialFunction(new double[] { 1 }); PolynomialFunction Hk0g0 = Hk0.multiply(g0); PolynomialFunction Hk1g1 = Hk1.multiply(g1); PolynomialFunction Hk2g2 = Hk2.multiply(g2); checkNullPolynomial(Hk0g0.add(Hk1g1.add(Hk2g2))); } } @Test public void testHermiteOrthogonality() { UnivariateFunction weight = new UnivariateFunction() { public double value(double x) { return FastMath.exp(-x * x); } }; for (int i = 0; i < 10; ++i) { PolynomialFunction pi = PolynomialsUtils.createHermitePolynomial(i); for (int j = 0; j <= i; ++j) { PolynomialFunction pj = PolynomialsUtils.createHermitePolynomial(j); checkOrthogonality(pi, pj, weight, -50, 50, 1.5, 1.0e-8); } } } @Test public void testFirstLaguerrePolynomials() { checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(3), 6l, "6 - 18 x + 9 x^2 - x^3"); checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(2), 2l, "2 - 4 x + x^2"); checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(1), 1l, "1 - x"); checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(0), 1l, "1"); checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(7), 5040l, "5040 - 35280 x + 52920 x^2 - 29400 x^3" + " + 7350 x^4 - 882 x^5 + 49 x^6 - x^7"); checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(6), 720l, "720 - 4320 x + 5400 x^2 - 2400 x^3 + 450 x^4" + " - 36 x^5 + x^6"); checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(5), 120l, "120 - 600 x + 600 x^2 - 200 x^3 + 25 x^4 - x^5"); checkPolynomial(PolynomialsUtils.createLaguerrePolynomial(4), 24l, "24 - 96 x + 72 x^2 - 16 x^3 + x^4"); } @Test public void testLaguerreDifferentials() { for (int k = 0; k < 12; ++k) { PolynomialFunction Lk0 = PolynomialsUtils.createLaguerrePolynomial(k); PolynomialFunction Lk1 = Lk0.polynomialDerivative(); PolynomialFunction Lk2 = Lk1.polynomialDerivative(); PolynomialFunction g0 = new PolynomialFunction(new double[] { k }); PolynomialFunction g1 = new PolynomialFunction(new double[] { 1, -1 }); PolynomialFunction g2 = new PolynomialFunction(new double[] { 0, 1 }); PolynomialFunction Lk0g0 = Lk0.multiply(g0); PolynomialFunction Lk1g1 = Lk1.multiply(g1); PolynomialFunction Lk2g2 = Lk2.multiply(g2); checkNullPolynomial(Lk0g0.add(Lk1g1.add(Lk2g2))); } } @Test public void testLaguerreOrthogonality() { UnivariateFunction weight = new UnivariateFunction() { public double value(double x) { return FastMath.exp(-x); } }; for (int i = 0; i < 10; ++i) { PolynomialFunction pi = PolynomialsUtils.createLaguerrePolynomial(i); for (int j = 0; j <= i; ++j) { PolynomialFunction pj = PolynomialsUtils.createLaguerrePolynomial(j); checkOrthogonality(pi, pj, weight, 0.0, 100.0, 0.99999, 1.0e-13); } } } @Test public void testFirstLegendrePolynomials() { checkPolynomial(PolynomialsUtils.createLegendrePolynomial(3), 2l, "-3 x + 5 x^3"); checkPolynomial(PolynomialsUtils.createLegendrePolynomial(2), 2l, "-1 + 3 x^2"); checkPolynomial(PolynomialsUtils.createLegendrePolynomial(1), 1l, "x"); checkPolynomial(PolynomialsUtils.createLegendrePolynomial(0), 1l, "1"); checkPolynomial(PolynomialsUtils.createLegendrePolynomial(7), 16l, "-35 x + 315 x^3 - 693 x^5 + 429 x^7"); checkPolynomial(PolynomialsUtils.createLegendrePolynomial(6), 16l, "-5 + 105 x^2 - 315 x^4 + 231 x^6"); checkPolynomial(PolynomialsUtils.createLegendrePolynomial(5), 8l, "15 x - 70 x^3 + 63 x^5"); checkPolynomial(PolynomialsUtils.createLegendrePolynomial(4), 8l, "3 - 30 x^2 + 35 x^4"); } @Test public void testLegendreDifferentials() { for (int k = 0; k < 12; ++k) { PolynomialFunction Pk0 = PolynomialsUtils.createLegendrePolynomial(k); PolynomialFunction Pk1 = Pk0.polynomialDerivative(); PolynomialFunction Pk2 = Pk1.polynomialDerivative(); PolynomialFunction g0 = new PolynomialFunction(new double[] { k * (k + 1) }); PolynomialFunction g1 = new PolynomialFunction(new double[] { 0, -2 }); PolynomialFunction g2 = new PolynomialFunction(new double[] { 1, 0, -1 }); PolynomialFunction Pk0g0 = Pk0.multiply(g0); PolynomialFunction Pk1g1 = Pk1.multiply(g1); PolynomialFunction Pk2g2 = Pk2.multiply(g2); checkNullPolynomial(Pk0g0.add(Pk1g1.add(Pk2g2))); } } @Test public void testLegendreOrthogonality() { UnivariateFunction weight = new UnivariateFunction() { public double value(double x) { return 1; } }; for (int i = 0; i < 10; ++i) { PolynomialFunction pi = PolynomialsUtils.createLegendrePolynomial(i); for (int j = 0; j <= i; ++j) { PolynomialFunction pj = PolynomialsUtils.createLegendrePolynomial(j); checkOrthogonality(pi, pj, weight, -1, 1, 0.1, 1.0e-13); } } } @Test public void testHighDegreeLegendre() { PolynomialsUtils.createLegendrePolynomial(40); double[] l40 = PolynomialsUtils.createLegendrePolynomial(40).getCoefficients(); double denominator = 274877906944d; double[] numerators = new double[] { +34461632205d, -28258538408100d, +3847870979902950d, -207785032914759300d, +5929294332103310025d, -103301483474866556880d, +1197358103913226000200d, -9763073770369381232400d, +58171647881784229843050d, -260061484647976556945400d, +888315281771246239250340d, -2345767627188139419665400d, +4819022625419112503443050d, -7710436200670580005508880d, +9566652323054238154983240d, -9104813935044723209570256d, +6516550296251767619752905d, -3391858621221953912598660d, +1211378079007840683070950d, -265365894974690562152100d, +26876802183334044115405d }; for (int i = 0; i < l40.length; ++i) { if (i % 2 == 0) { double ci = numerators[i / 2] / denominator; Assert.assertEquals(ci, l40[i], FastMath.abs(ci) * 1e-15); } else { Assert.assertEquals(0, l40[i], 0); } } } @Test public void testJacobiLegendre() { for (int i = 0; i < 10; ++i) { PolynomialFunction legendre = PolynomialsUtils.createLegendrePolynomial(i); PolynomialFunction jacobi = PolynomialsUtils.createJacobiPolynomial(i, 0, 0); checkNullPolynomial(legendre.subtract(jacobi)); } } @Test public void testJacobiEvaluationAt1() { for (int v = 0; v < 10; ++v) { for (int w = 0; w < 10; ++w) { for (int i = 0; i < 10; ++i) { PolynomialFunction jacobi = PolynomialsUtils.createJacobiPolynomial(i, v, w); double binomial = CombinatoricsUtils.binomialCoefficient(v + i, i); Assert.assertTrue(Precision.equals(binomial, jacobi.value(1.0), 1)); } } } } @Test public void testJacobiOrthogonality() { for (int v = 0; v < 5; ++v) { for (int w = v; w < 5; ++w) { final int vv = v; final int ww = w; UnivariateFunction weight = new UnivariateFunction() { public double value(double x) { return FastMath.pow(1 - x, vv) * FastMath.pow(1 + x, ww); } }; for (int i = 0; i < 10; ++i) { PolynomialFunction pi = PolynomialsUtils.createJacobiPolynomial(i, v, w); for (int j = 0; j <= i; ++j) { PolynomialFunction pj = PolynomialsUtils.createJacobiPolynomial(j, v, w); checkOrthogonality(pi, pj, weight, -1, 1, 0.1, 1.0e-12); } } } } } @Test public void testShift() { // f1(x) = 1 + x + 2 x^2 PolynomialFunction f1x = new PolynomialFunction(new double[] { 1, 1, 2 }); PolynomialFunction f1x1 = new PolynomialFunction(PolynomialsUtils.shift(f1x.getCoefficients(), 1)); checkPolynomial(f1x1, "4 + 5 x + 2 x^2"); PolynomialFunction f1xM1 = new PolynomialFunction(PolynomialsUtils.shift(f1x.getCoefficients(), -1)); checkPolynomial(f1xM1, "2 - 3 x + 2 x^2"); PolynomialFunction f1x3 = new PolynomialFunction(PolynomialsUtils.shift(f1x.getCoefficients(), 3)); checkPolynomial(f1x3, "22 + 13 x + 2 x^2"); // f2(x) = 2 + 3 x^2 + 8 x^3 + 121 x^5 PolynomialFunction f2x = new PolynomialFunction(new double[]{2, 0, 3, 8, 0, 121}); PolynomialFunction f2x1 = new PolynomialFunction(PolynomialsUtils.shift(f2x.getCoefficients(), 1)); checkPolynomial(f2x1, "134 + 635 x + 1237 x^2 + 1218 x^3 + 605 x^4 + 121 x^5"); PolynomialFunction f2x3 = new PolynomialFunction(PolynomialsUtils.shift(f2x.getCoefficients(), 3)); checkPolynomial(f2x3, "29648 + 49239 x + 32745 x^2 + 10898 x^3 + 1815 x^4 + 121 x^5"); } private void checkPolynomial(PolynomialFunction p, long denominator, String reference) { PolynomialFunction q = new PolynomialFunction(new double[] { denominator}); Assert.assertEquals(reference, p.multiply(q).toString()); } private void checkPolynomial(PolynomialFunction p, String reference) { Assert.assertEquals(reference, p.toString()); } private void checkNullPolynomial(PolynomialFunction p) { for (double coefficient : p.getCoefficients()) { Assert.assertEquals(0, coefficient, 1e-13); } } private void checkOrthogonality(final PolynomialFunction p1, final PolynomialFunction p2, final UnivariateFunction weight, final double a, final double b, final double nonZeroThreshold, final double zeroThreshold) { UnivariateFunction f = new UnivariateFunction() { public double value(double x) { return weight.value(x) * p1.value(x) * p2.value(x); } }; double dotProduct = new IterativeLegendreGaussIntegrator(5, 1.0e-9, 1.0e-8, 2, 15).integrate(1000000, f, a, b); if (p1.degree() == p2.degree()) { // integral should be non-zero Assert.assertTrue("I(" + p1.degree() + ", " + p2.degree() + ") = "+ dotProduct, FastMath.abs(dotProduct) > nonZeroThreshold); } else { // integral should be zero Assert.assertEquals("I(" + p1.degree() + ", " + p2.degree() + ") = "+ dotProduct, 0.0, FastMath.abs(dotProduct), zeroThreshold); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.solvers; import org.apache.commons.math3.analysis.QuinticFunction; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.function.Sin; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * @version $Id$ */ public final class BisectionSolverTest { @Test public void testSinZero() { UnivariateFunction f = new Sin(); double result; BisectionSolver solver = new BisectionSolver(); result = solver.solve(100, f, 3, 4); Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, 1, 4); Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy()); } @Test public void testQuinticZero() { UnivariateFunction f = new QuinticFunction(); double result; BisectionSolver solver = new BisectionSolver(); result = solver.solve(100, f, -0.2, 0.2); Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, -0.1, 0.3); Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, -0.3, 0.45); Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, 0.3, 0.7); Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, 0.2, 0.6); Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, 0.05, 0.95); Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, 0.85, 1.25); Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, 0.8, 1.2); Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, 0.85, 1.75); Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, 0.55, 1.45); Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, 0.85, 5); Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); Assert.assertTrue(solver.getEvaluations() > 0); } @Test public void testMath369() { UnivariateFunction f = new Sin(); BisectionSolver solver = new BisectionSolver(); Assert.assertEquals(FastMath.PI, solver.solve(100, f, 3.0, 3.2, 3.1), solver.getAbsoluteAccuracy()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.solvers; import org.apache.commons.math3.analysis.QuinticFunction; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.differentiation.DerivativeStructure; import org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.exception.TooManyEvaluationsException; import org.junit.Assert; import org.junit.Test; /** * Test case for {@link BracketingNthOrderBrentSolver bracketing n<sup>th</sup> order Brent} solver. * * @version $Id$ */ public final class BracketingNthOrderBrentSolverTest extends BaseSecantSolverAbstractTest { /** {@inheritDoc} */ @Override protected UnivariateSolver getSolver() { return new BracketingNthOrderBrentSolver(); } /** {@inheritDoc} */ @Override protected int[] getQuinticEvalCounts() { return new int[] {1, 3, 8, 1, 9, 4, 8, 1, 12, 1, 16}; } @Test(expected=NumberIsTooSmallException.class) public void testInsufficientOrder1() { new BracketingNthOrderBrentSolver(1.0e-10, 1); } @Test(expected=NumberIsTooSmallException.class) public void testInsufficientOrder2() { new BracketingNthOrderBrentSolver(1.0e-10, 1.0e-10, 1); } @Test(expected=NumberIsTooSmallException.class) public void testInsufficientOrder3() { new BracketingNthOrderBrentSolver(1.0e-10, 1.0e-10, 1.0e-10, 1); } @Test public void testConstructorsOK() { Assert.assertEquals(2, new BracketingNthOrderBrentSolver(1.0e-10, 2).getMaximalOrder()); Assert.assertEquals(2, new BracketingNthOrderBrentSolver(1.0e-10, 1.0e-10, 2).getMaximalOrder()); Assert.assertEquals(2, new BracketingNthOrderBrentSolver(1.0e-10, 1.0e-10, 1.0e-10, 2).getMaximalOrder()); } @Test public void testConvergenceOnFunctionAccuracy() { BracketingNthOrderBrentSolver solver = new BracketingNthOrderBrentSolver(1.0e-12, 1.0e-10, 0.001, 3); QuinticFunction f = new QuinticFunction(); double result = solver.solve(20, f, 0.2, 0.9, 0.4, AllowedSolution.BELOW_SIDE); Assert.assertEquals(0, f.value(result), solver.getFunctionValueAccuracy()); Assert.assertTrue(f.value(result) <= 0); Assert.assertTrue(result - 0.5 > solver.getAbsoluteAccuracy()); result = solver.solve(20, f, -0.9, -0.2, -0.4, AllowedSolution.ABOVE_SIDE); Assert.assertEquals(0, f.value(result), solver.getFunctionValueAccuracy()); Assert.assertTrue(f.value(result) >= 0); Assert.assertTrue(result + 0.5 < -solver.getAbsoluteAccuracy()); } @Test public void testIssue716() { BracketingNthOrderBrentSolver solver = new BracketingNthOrderBrentSolver(1.0e-12, 1.0e-10, 1.0e-22, 5); UnivariateFunction sharpTurn = new UnivariateFunction() { public double value(double x) { return (2 * x + 1) / (1.0e9 * (x + 1)); } }; double result = solver.solve(100, sharpTurn, -0.9999999, 30, 15, AllowedSolution.RIGHT_SIDE); Assert.assertEquals(0, sharpTurn.value(result), solver.getFunctionValueAccuracy()); Assert.assertTrue(sharpTurn.value(result) >= 0); Assert.assertEquals(-0.5, result, 1.0e-10); } @Test public void testFasterThanNewton() { // the following test functions come from Beny Neta's paper: // "Several New Methods for solving Equations" // intern J. Computer Math Vol 23 pp 265-282 // available here: http://www.math.nps.navy.mil/~bneta/SeveralNewMethods.PDF // the reference roots have been computed by the Dfp solver to more than // 80 digits and checked with emacs (only the first 20 digits are reproduced here) compare(new TestFunction(0.0, -2, 2) { @Override public DerivativeStructure value(DerivativeStructure x) { return x.sin().subtract(x.multiply(0.5)); } }); compare(new TestFunction(6.3087771299726890947, -5, 10) { @Override public DerivativeStructure value(DerivativeStructure x) { return x.pow(5).add(x).subtract(10000); } }); compare(new TestFunction(9.6335955628326951924, 0.001, 10) { @Override public DerivativeStructure value(DerivativeStructure x) { return x.sqrt().subtract(x.reciprocal()).subtract(3); } }); compare(new TestFunction(2.8424389537844470678, -5, 5) { @Override public DerivativeStructure value(DerivativeStructure x) { return x.exp().add(x).subtract(20); } }); compare(new TestFunction(8.3094326942315717953, 0.001, 10) { @Override public DerivativeStructure value(DerivativeStructure x) { return x.log().add(x.sqrt()).subtract(5); } }); compare(new TestFunction(1.4655712318767680266, -0.5, 1.5) { @Override public DerivativeStructure value(DerivativeStructure x) { return x.subtract(1).multiply(x).multiply(x).subtract(1); } }); } private void compare(TestFunction f) { compare(f, f.getRoot(), f.getMin(), f.getMax()); } private void compare(final UnivariateDifferentiableFunction f, double root, double min, double max) { NewtonRaphsonSolver newton = new NewtonRaphsonSolver(1.0e-12); BracketingNthOrderBrentSolver bracketing = new BracketingNthOrderBrentSolver(1.0e-12, 1.0e-12, 1.0e-18, 5); double resultN; try { resultN = newton.solve(100, f, min, max); } catch (TooManyEvaluationsException tmee) { resultN = Double.NaN; } double resultB; try { resultB = bracketing.solve(100, f, min, max); } catch (TooManyEvaluationsException tmee) { resultB = Double.NaN; } Assert.assertEquals(root, resultN, newton.getAbsoluteAccuracy()); Assert.assertEquals(root, resultB, bracketing.getAbsoluteAccuracy()); // bracketing solver evaluates only function value, we set the weight to 1 final int weightedBracketingEvaluations = bracketing.getEvaluations(); // Newton-Raphson solver evaluates both function value and derivative, we set the weight to 2 final int weightedNewtonEvaluations = 2 * newton.getEvaluations(); Assert.assertTrue(weightedBracketingEvaluations < weightedNewtonEvaluations); } private static abstract class TestFunction implements UnivariateDifferentiableFunction { private final double root; private final double min; private final double max; protected TestFunction(final double root, final double min, final double max) { this.root = root; this.min = min; this.max = max; } public double getRoot() { return root; } public double getMin() { return min; } public double getMax() { return max; } public double value(final double x) { return value(new DerivativeStructure(0, 0, x)).getValue(); } public abstract DerivativeStructure value(final DerivativeStructure t); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.solvers; import org.apache.commons.math3.analysis.FunctionUtils; import org.apache.commons.math3.analysis.MonitoredFunction; import org.apache.commons.math3.analysis.QuinticFunction; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.differentiation.DerivativeStructure; import org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction; import org.apache.commons.math3.analysis.function.Constant; import org.apache.commons.math3.analysis.function.Inverse; import org.apache.commons.math3.analysis.function.Sin; import org.apache.commons.math3.analysis.function.Sqrt; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.exception.NumberIsTooLargeException; import org.apache.commons.math3.exception.TooManyEvaluationsException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * Test case for {@link BrentSolver Brent} solver. * Because Brent-Dekker is guaranteed to converge in less than the default * maximum iteration count due to bisection fallback, it is quite hard to * debug. I include measured iteration counts plus one in order to detect * regressions. On average Brent-Dekker should use 4..5 iterations for the * default absolute accuracy of 10E-8 for sinus and the quintic function around * zero, and 5..10 iterations for the other zeros. * * @version $Id$ */ public final class BrentSolverTest { @Test public void testSinZero() { // The sinus function is behaved well around the root at pi. The second // order derivative is zero, which means linar approximating methods will // still converge quadratically. UnivariateFunction f = new Sin(); double result; UnivariateSolver solver = new BrentSolver(); // Somewhat benign interval. The function is monotone. result = solver.solve(100, f, 3, 4); // System.out.println( // "Root: " + result + " Evaluations: " + solver.getEvaluations()); Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy()); Assert.assertTrue(solver.getEvaluations() <= 7); // Larger and somewhat less benign interval. The function is grows first. result = solver.solve(100, f, 1, 4); // System.out.println( // "Root: " + result + " Evaluations: " + solver.getEvaluations()); Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy()); Assert.assertTrue(solver.getEvaluations() <= 8); } @Test public void testQuinticZero() { // The quintic function has zeros at 0, +-0.5 and +-1. // Around the root of 0 the function is well behaved, with a second derivative // of zero a 0. // The other roots are less well to find, in particular the root at 1, because // the function grows fast for x>1. // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643, // intervals containing these values are harder for the solvers. UnivariateFunction f = new QuinticFunction(); double result; // Brent-Dekker solver. UnivariateSolver solver = new BrentSolver(); // Symmetric bracket around 0. Test whether solvers can handle hitting // the root in the first iteration. result = solver.solve(100, f, -0.2, 0.2); //System.out.println( // "Root: " + result + " Evaluations: " + solver.getEvaluations()); Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy()); Assert.assertTrue(solver.getEvaluations() <= 3); // 1 iterations on i586 JDK 1.4.1. // Asymmetric bracket around 0, just for fun. Contains extremum. result = solver.solve(100, f, -0.1, 0.3); //System.out.println( // "Root: " + result + " Evaluations: " + solver.getEvaluations()); Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy()); // 5 iterations on i586 JDK 1.4.1. Assert.assertTrue(solver.getEvaluations() <= 7); // Large bracket around 0. Contains two extrema. result = solver.solve(100, f, -0.3, 0.45); //System.out.println( // "Root: " + result + " Evaluations: " + solver.getEvaluations()); Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy()); // 6 iterations on i586 JDK 1.4.1. Assert.assertTrue(solver.getEvaluations() <= 8); // Benign bracket around 0.5, function is monotonous. result = solver.solve(100, f, 0.3, 0.7); //System.out.println( // "Root: " + result + " Evaluations: " + solver.getEvaluations()); Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy()); // 6 iterations on i586 JDK 1.4.1. Assert.assertTrue(solver.getEvaluations() <= 9); // Less benign bracket around 0.5, contains one extremum. result = solver.solve(100, f, 0.2, 0.6); // System.out.println( // "Root: " + result + " Evaluations: " + solver.getEvaluations()); Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy()); Assert.assertTrue(solver.getEvaluations() <= 10); // Large, less benign bracket around 0.5, contains both extrema. result = solver.solve(100, f, 0.05, 0.95); //System.out.println( // "Root: " + result + " Evaluations: " + solver.getEvaluations()); Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy()); Assert.assertTrue(solver.getEvaluations() <= 11); // Relatively benign bracket around 1, function is monotonous. Fast growth for x>1 // is still a problem. result = solver.solve(100, f, 0.85, 1.25); //System.out.println( // "Root: " + result + " Evaluations: " + solver.getEvaluations()); Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); Assert.assertTrue(solver.getEvaluations() <= 11); // Less benign bracket around 1 with extremum. result = solver.solve(100, f, 0.8, 1.2); //System.out.println( // "Root: " + result + " Evaluations: " + solver.getEvaluations()); Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); Assert.assertTrue(solver.getEvaluations() <= 11); // Large bracket around 1. Monotonous. result = solver.solve(100, f, 0.85, 1.75); //System.out.println( // "Root: " + result + " Evaluations: " + solver.getEvaluations()); Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); Assert.assertTrue(solver.getEvaluations() <= 13); // Large bracket around 1. Interval contains extremum. result = solver.solve(100, f, 0.55, 1.45); //System.out.println( // "Root: " + result + " Evaluations: " + solver.getEvaluations()); Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); Assert.assertTrue(solver.getEvaluations() <= 10); // Very large bracket around 1 for testing fast growth behaviour. result = solver.solve(100, f, 0.85, 5); //System.out.println( // "Root: " + result + " Evaluations: " + solver.getEvaluations()); Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); Assert.assertTrue(solver.getEvaluations() <= 15); try { result = solver.solve(5, f, 0.85, 5); Assert.fail("Expected TooManyEvaluationsException"); } catch (TooManyEvaluationsException e) { // Expected. } } @Test public void testRootEndpoints() { UnivariateFunction f = new Sin(); BrentSolver solver = new BrentSolver(); // endpoint is root double result = solver.solve(100, f, FastMath.PI, 4); Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, 3, FastMath.PI); Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, FastMath.PI, 4, 3.5); Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, 3, FastMath.PI, 3.07); Assert.assertEquals(FastMath.PI, result, solver.getAbsoluteAccuracy()); } @Test public void testBadEndpoints() { UnivariateFunction f = new Sin(); BrentSolver solver = new BrentSolver(); try { // bad interval solver.solve(100, f, 1, -1); Assert.fail("Expecting NumberIsTooLargeException - bad interval"); } catch (NumberIsTooLargeException ex) { // expected } try { // no bracket solver.solve(100, f, 1, 1.5); Assert.fail("Expecting NoBracketingException - non-bracketing"); } catch (NoBracketingException ex) { // expected } try { // no bracket solver.solve(100, f, 1, 1.5, 1.2); Assert.fail("Expecting NoBracketingException - non-bracketing"); } catch (NoBracketingException ex) { // expected } } @Test public void testInitialGuess() { MonitoredFunction f = new MonitoredFunction(new QuinticFunction()); BrentSolver solver = new BrentSolver(); double result; // no guess result = solver.solve(100, f, 0.6, 7.0); Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); int referenceCallsCount = f.getCallsCount(); Assert.assertTrue(referenceCallsCount >= 13); // invalid guess (it *is* a root, but outside of the range) try { result = solver.solve(100, f, 0.6, 7.0, 0.0); Assert.fail("a NumberIsTooLargeException was expected"); } catch (NumberIsTooLargeException iae) { // expected behaviour } // bad guess f.setCallsCount(0); result = solver.solve(100, f, 0.6, 7.0, 0.61); Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); Assert.assertTrue(f.getCallsCount() > referenceCallsCount); // good guess f.setCallsCount(0); result = solver.solve(100, f, 0.6, 7.0, 0.999999); Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); Assert.assertTrue(f.getCallsCount() < referenceCallsCount); // perfect guess f.setCallsCount(0); result = solver.solve(100, f, 0.6, 7.0, 1.0); Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); Assert.assertEquals(1, solver.getEvaluations()); Assert.assertEquals(1, f.getCallsCount()); } @Test public void testMath832() { final UnivariateFunction f = new UnivariateFunction() { private final UnivariateDifferentiableFunction sqrt = new Sqrt(); private final UnivariateDifferentiableFunction inv = new Inverse(); private final UnivariateDifferentiableFunction func = FunctionUtils.add(FunctionUtils.multiply(new Constant(1e2), sqrt), FunctionUtils.multiply(new Constant(1e6), inv), FunctionUtils.multiply(new Constant(1e4), FunctionUtils.compose(inv, sqrt))); public double value(double x) { return func.value(new DerivativeStructure(1, 1, 0, x)).getPartialDerivative(1); } }; BrentSolver solver = new BrentSolver(); final double result = solver.solve(99, f, 1, 1e30, 1 + 1e-10); Assert.assertEquals(804.93558250, result, 1e-8); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.solvers; /** * Test case for {@link IllinoisSolver Illinois} solver. * * @version $Id$ */ public final class IllinoisSolverTest extends BaseSecantSolverAbstractTest { /** {@inheritDoc} */ @Override protected UnivariateSolver getSolver() { return new IllinoisSolver(); } /** {@inheritDoc} */ @Override protected int[] getQuinticEvalCounts() { return new int[] {3, 7, 9, 10, 10, 10, 12, 12, 14, 15, 20}; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.solvers; import org.apache.commons.math3.analysis.polynomials.PolynomialFunction; import org.apache.commons.math3.exception.NumberIsTooLargeException; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.complex.Complex; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.TestUtils; import org.junit.Assert; import org.junit.Test; /** * Test case for Laguerre solver. * <p> * Laguerre's method is very efficient in solving polynomials. Test runs * show that for a default absolute accuracy of 1E-6, it generally takes * less than 5 iterations to find one root, provided solveAll() is not * invoked, and 15 to 20 iterations to find all roots for quintic function. * * @version $Id$ */ public final class LaguerreSolverTest { /** * Test of solver for the linear function. */ @Test public void testLinearFunction() { double min, max, expected, result, tolerance; // p(x) = 4x - 1 double coefficients[] = { -1.0, 4.0 }; PolynomialFunction f = new PolynomialFunction(coefficients); LaguerreSolver solver = new LaguerreSolver(); min = 0.0; max = 1.0; expected = 0.25; tolerance = FastMath.max(solver.getAbsoluteAccuracy(), FastMath.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(100, f, min, max); Assert.assertEquals(expected, result, tolerance); } /** * Test of solver for the quadratic function. */ @Test public void testQuadraticFunction() { double min, max, expected, result, tolerance; // p(x) = 2x^2 + 5x - 3 = (x+3)(2x-1) double coefficients[] = { -3.0, 5.0, 2.0 }; PolynomialFunction f = new PolynomialFunction(coefficients); LaguerreSolver solver = new LaguerreSolver(); min = 0.0; max = 2.0; expected = 0.5; tolerance = FastMath.max(solver.getAbsoluteAccuracy(), FastMath.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(100, f, min, max); Assert.assertEquals(expected, result, tolerance); min = -4.0; max = -1.0; expected = -3.0; tolerance = FastMath.max(solver.getAbsoluteAccuracy(), FastMath.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(100, f, min, max); Assert.assertEquals(expected, result, tolerance); } /** * Test of solver for the quintic function. */ @Test public void testQuinticFunction() { double min, max, expected, result, tolerance; // p(x) = x^5 - x^4 - 12x^3 + x^2 - x - 12 = (x+1)(x+3)(x-4)(x^2-x+1) double coefficients[] = { -12.0, -1.0, 1.0, -12.0, -1.0, 1.0 }; PolynomialFunction f = new PolynomialFunction(coefficients); LaguerreSolver solver = new LaguerreSolver(); min = -2.0; max = 2.0; expected = -1.0; tolerance = FastMath.max(solver.getAbsoluteAccuracy(), FastMath.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(100, f, min, max); Assert.assertEquals(expected, result, tolerance); min = -5.0; max = -2.5; expected = -3.0; tolerance = FastMath.max(solver.getAbsoluteAccuracy(), FastMath.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(100, f, min, max); Assert.assertEquals(expected, result, tolerance); min = 3.0; max = 6.0; expected = 4.0; tolerance = FastMath.max(solver.getAbsoluteAccuracy(), FastMath.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(100, f, min, max); Assert.assertEquals(expected, result, tolerance); } /** * Test of solver for the quintic function using * {@link LaguerreSolver#solveAllComplex(double[],double) solveAllComplex}. */ @Test public void testQuinticFunction2() { // p(x) = x^5 + 4x^3 + x^2 + 4 = (x+1)(x^2-x+1)(x^2+4) final double[] coefficients = { 4.0, 0.0, 1.0, 4.0, 0.0, 1.0 }; final LaguerreSolver solver = new LaguerreSolver(); final Complex[] result = solver.solveAllComplex(coefficients, 0); for (Complex expected : new Complex[] { new Complex(0, -2), new Complex(0, 2), new Complex(0.5, 0.5 * FastMath.sqrt(3)), new Complex(-1, 0), new Complex(0.5, -0.5 * FastMath.sqrt(3.0)) }) { final double tolerance = FastMath.max(solver.getAbsoluteAccuracy(), FastMath.abs(expected.abs() * solver.getRelativeAccuracy())); TestUtils.assertContains(result, expected, tolerance); } } /** * Test of parameters for the solver. */ @Test public void testParameters() { double coefficients[] = { -3.0, 5.0, 2.0 }; PolynomialFunction f = new PolynomialFunction(coefficients); LaguerreSolver solver = new LaguerreSolver(); try { // bad interval solver.solve(100, f, 1, -1); Assert.fail("Expecting NumberIsTooLargeException - bad interval"); } catch (NumberIsTooLargeException ex) { // expected } try { // no bracketing solver.solve(100, f, 2, 3); Assert.fail("Expecting NoBracketingException - no bracketing"); } catch (NoBracketingException ex) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.solvers; import org.apache.commons.math3.analysis.QuinticFunction; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.function.Expm1; import org.apache.commons.math3.analysis.function.Sin; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.exception.NumberIsTooLargeException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * Test case for {@link MullerSolver2 Muller} solver. * <p> * Muller's method converges almost quadratically near roots, but it can * be very slow in regions far away from zeros. Test runs show that for * reasonably good initial values, for a default absolute accuracy of 1E-6, * it generally takes 5 to 10 iterations for the solver to converge. * <p> * Tests for the exponential function illustrate the situations where * Muller solver performs poorly. * * @version $Id$ */ public final class MullerSolver2Test { /** * Test of solver for the sine function. */ @Test public void testSinFunction() { UnivariateFunction f = new Sin(); UnivariateSolver solver = new MullerSolver2(); double min, max, expected, result, tolerance; min = 3.0; max = 4.0; expected = FastMath.PI; tolerance = FastMath.max(solver.getAbsoluteAccuracy(), FastMath.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(100, f, min, max); Assert.assertEquals(expected, result, tolerance); min = -1.0; max = 1.5; expected = 0.0; tolerance = FastMath.max(solver.getAbsoluteAccuracy(), FastMath.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(100, f, min, max); Assert.assertEquals(expected, result, tolerance); } /** * Test of solver for the quintic function. */ @Test public void testQuinticFunction() { UnivariateFunction f = new QuinticFunction(); UnivariateSolver solver = new MullerSolver2(); double min, max, expected, result, tolerance; min = -0.4; max = 0.2; expected = 0.0; tolerance = FastMath.max(solver.getAbsoluteAccuracy(), FastMath.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(100, f, min, max); Assert.assertEquals(expected, result, tolerance); min = 0.75; max = 1.5; expected = 1.0; tolerance = FastMath.max(solver.getAbsoluteAccuracy(), FastMath.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(100, f, min, max); Assert.assertEquals(expected, result, tolerance); min = -0.9; max = -0.2; expected = -0.5; tolerance = FastMath.max(solver.getAbsoluteAccuracy(), FastMath.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(100, f, min, max); Assert.assertEquals(expected, result, tolerance); } /** * Test of solver for the exponential function. * <p> * It takes 25 to 50 iterations for the last two tests to converge. */ @Test public void testExpm1Function() { UnivariateFunction f = new Expm1(); UnivariateSolver solver = new MullerSolver2(); double min, max, expected, result, tolerance; min = -1.0; max = 2.0; expected = 0.0; tolerance = FastMath.max(solver.getAbsoluteAccuracy(), FastMath.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(100, f, min, max); Assert.assertEquals(expected, result, tolerance); min = -20.0; max = 10.0; expected = 0.0; tolerance = FastMath.max(solver.getAbsoluteAccuracy(), FastMath.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(100, f, min, max); Assert.assertEquals(expected, result, tolerance); min = -50.0; max = 100.0; expected = 0.0; tolerance = FastMath.max(solver.getAbsoluteAccuracy(), FastMath.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(100, f, min, max); Assert.assertEquals(expected, result, tolerance); } /** * Test of parameters for the solver. */ @Test public void testParameters() { UnivariateFunction f = new Sin(); UnivariateSolver solver = new MullerSolver2(); try { // bad interval solver.solve(100, f, 1, -1); Assert.fail("Expecting NumberIsTooLargeException - bad interval"); } catch (NumberIsTooLargeException ex) { // expected } try { // no bracketing solver.solve(100, f, 2, 3); Assert.fail("Expecting NoBracketingException - no bracketing"); } catch (NoBracketingException ex) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.solvers; import org.apache.commons.math3.analysis.QuinticFunction; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.function.Expm1; import org.apache.commons.math3.analysis.function.Sin; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.exception.NumberIsTooLargeException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * Test case for {@link MullerSolver Muller} solver. * <p> * Muller's method converges almost quadratically near roots, but it can * be very slow in regions far away from zeros. Test runs show that for * reasonably good initial values, for a default absolute accuracy of 1E-6, * it generally takes 5 to 10 iterations for the solver to converge. * <p> * Tests for the exponential function illustrate the situations where * Muller solver performs poorly. * * @version $Id$ */ public final class MullerSolverTest { /** * Test of solver for the sine function. */ @Test public void testSinFunction() { UnivariateFunction f = new Sin(); UnivariateSolver solver = new MullerSolver(); double min, max, expected, result, tolerance; min = 3.0; max = 4.0; expected = FastMath.PI; tolerance = FastMath.max(solver.getAbsoluteAccuracy(), FastMath.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(100, f, min, max); Assert.assertEquals(expected, result, tolerance); min = -1.0; max = 1.5; expected = 0.0; tolerance = FastMath.max(solver.getAbsoluteAccuracy(), FastMath.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(100, f, min, max); Assert.assertEquals(expected, result, tolerance); } /** * Test of solver for the quintic function. */ @Test public void testQuinticFunction() { UnivariateFunction f = new QuinticFunction(); UnivariateSolver solver = new MullerSolver(); double min, max, expected, result, tolerance; min = -0.4; max = 0.2; expected = 0.0; tolerance = FastMath.max(solver.getAbsoluteAccuracy(), FastMath.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(100, f, min, max); Assert.assertEquals(expected, result, tolerance); min = 0.75; max = 1.5; expected = 1.0; tolerance = FastMath.max(solver.getAbsoluteAccuracy(), FastMath.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(100, f, min, max); Assert.assertEquals(expected, result, tolerance); min = -0.9; max = -0.2; expected = -0.5; tolerance = FastMath.max(solver.getAbsoluteAccuracy(), FastMath.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(100, f, min, max); Assert.assertEquals(expected, result, tolerance); } /** * Test of solver for the exponential function. * <p> * It takes 10 to 15 iterations for the last two tests to converge. * In fact, if not for the bisection alternative, the solver would * exceed the default maximal iteration of 100. */ @Test public void testExpm1Function() { UnivariateFunction f = new Expm1(); UnivariateSolver solver = new MullerSolver(); double min, max, expected, result, tolerance; min = -1.0; max = 2.0; expected = 0.0; tolerance = FastMath.max(solver.getAbsoluteAccuracy(), FastMath.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(100, f, min, max); Assert.assertEquals(expected, result, tolerance); min = -20.0; max = 10.0; expected = 0.0; tolerance = FastMath.max(solver.getAbsoluteAccuracy(), FastMath.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(100, f, min, max); Assert.assertEquals(expected, result, tolerance); min = -50.0; max = 100.0; expected = 0.0; tolerance = FastMath.max(solver.getAbsoluteAccuracy(), FastMath.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(100, f, min, max); Assert.assertEquals(expected, result, tolerance); } /** * Test of parameters for the solver. */ @Test public void testParameters() { UnivariateFunction f = new Sin(); UnivariateSolver solver = new MullerSolver(); try { // bad interval double root = solver.solve(100, f, 1, -1); System.out.println("root=" + root); Assert.fail("Expecting NumberIsTooLargeException - bad interval"); } catch (NumberIsTooLargeException ex) { // expected } try { // no bracketing solver.solve(100, f, 2, 3); Assert.fail("Expecting NoBracketingException - no bracketing"); } catch (NoBracketingException ex) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.solvers; import org.apache.commons.math3.analysis.QuinticFunction; import org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction; import org.apache.commons.math3.analysis.function.Sin; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * @version $Id$ */ public final class NewtonRaphsonSolverTest { /** * */ @Test public void testSinZero() { UnivariateDifferentiableFunction f = new Sin(); double result; NewtonRaphsonSolver solver = new NewtonRaphsonSolver(); result = solver.solve(100, f, 3, 4); Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, 1, 4); Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy()); Assert.assertTrue(solver.getEvaluations() > 0); } /** * */ @Test public void testQuinticZero() { final UnivariateDifferentiableFunction f = new QuinticFunction(); double result; NewtonRaphsonSolver solver = new NewtonRaphsonSolver(); result = solver.solve(100, f, -0.2, 0.2); Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, -0.1, 0.3); Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, -0.3, 0.45); Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, 0.3, 0.7); Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, 0.2, 0.6); Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, 0.05, 0.95); Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, 0.85, 1.25); Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, 0.8, 1.2); Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, 0.85, 1.75); Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, 0.55, 1.45); Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, 0.85, 5); Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.solvers; import org.apache.commons.math3.analysis.DifferentiableUnivariateFunction; import org.apache.commons.math3.analysis.QuinticFunction; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.differentiation.DerivativeStructure; import org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction; import org.apache.commons.math3.analysis.function.Sin; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * @version $Id$ * @deprecated */ @Deprecated public final class NewtonSolverTest { /** * */ @Test public void testSinZero() { DifferentiableUnivariateFunction f = new Sin(); double result; NewtonSolver solver = new NewtonSolver(); result = solver.solve(100, f, 3, 4); Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, 1, 4); Assert.assertEquals(result, FastMath.PI, solver.getAbsoluteAccuracy()); Assert.assertTrue(solver.getEvaluations() > 0); } /** * */ @Test public void testQuinticZero() { final UnivariateDifferentiableFunction q = new QuinticFunction(); DifferentiableUnivariateFunction f = new DifferentiableUnivariateFunction() { public double value(double x) { return q.value(x); } public UnivariateFunction derivative() { return new UnivariateFunction() { public double value(double x) { return q.value(new DerivativeStructure(1, 1, 0, x)).getPartialDerivative(1); } }; } }; double result; NewtonSolver solver = new NewtonSolver(); result = solver.solve(100, f, -0.2, 0.2); Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, -0.1, 0.3); Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, -0.3, 0.45); Assert.assertEquals(result, 0, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, 0.3, 0.7); Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, 0.2, 0.6); Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, 0.05, 0.95); Assert.assertEquals(result, 0.5, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, 0.85, 1.25); Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, 0.8, 1.2); Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, 0.85, 1.75); Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, 0.55, 1.45); Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); result = solver.solve(100, f, 0.85, 5); Assert.assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.solvers; /** * Test case for {@link PegasusSolver Pegasus} solver. * * @version $Id$ */ public final class PegasusSolverTest extends BaseSecantSolverAbstractTest { /** {@inheritDoc} */ @Override protected UnivariateSolver getSolver() { return new PegasusSolver(); } /** {@inheritDoc} */ @Override protected int[] getQuinticEvalCounts() { return new int[] {3, 7, 9, 8, 9, 8, 10, 10, 12, 16, 18}; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.solvers; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.exception.ConvergenceException; import org.junit.Test; import org.junit.Assert; /** * Test case for {@link RegulaFalsiSolver Regula Falsi} solver. * * @version $Id$ */ public final class RegulaFalsiSolverTest extends BaseSecantSolverAbstractTest { /** {@inheritDoc} */ @Override protected UnivariateSolver getSolver() { return new RegulaFalsiSolver(); } /** {@inheritDoc} */ @Override protected int[] getQuinticEvalCounts() { // While the Regula Falsi method guarantees convergence, convergence // may be extremely slow. The last test case does not converge within // even a million iterations. As such, it was disabled. return new int[] {3, 7, 8, 19, 18, 11, 67, 55, 288, 151, -1}; } @Test(expected=ConvergenceException.class) public void testIssue631() { final UnivariateFunction f = new UnivariateFunction() { /** {@inheritDoc} */ public double value(double x) { return Math.exp(x) - Math.pow(Math.PI, 3.0); } }; final UnivariateSolver solver = new RegulaFalsiSolver(); final double root = solver.solve(3624, f, 1, 10); Assert.assertEquals(3.4341896575482003, root, 1e-15); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.solvers; import org.apache.commons.math3.analysis.QuinticFunction; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.function.Expm1; import org.apache.commons.math3.analysis.function.Sin; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.exception.NumberIsTooLargeException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * Test case for {@link RiddersSolver Ridders} solver. * <p> * Ridders' method converges superlinearly, more specific, its rate of * convergence is sqrt(2). Test runs show that for a default absolute * accuracy of 1E-6, it generally takes less than 5 iterations for close * initial bracket and 5 to 10 iterations for distant initial bracket * to converge. * * @version $Id$ */ public final class RiddersSolverTest { /** * Test of solver for the sine function. */ @Test public void testSinFunction() { UnivariateFunction f = new Sin(); UnivariateSolver solver = new RiddersSolver(); double min, max, expected, result, tolerance; min = 3.0; max = 4.0; expected = FastMath.PI; tolerance = FastMath.max(solver.getAbsoluteAccuracy(), FastMath.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(100, f, min, max); Assert.assertEquals(expected, result, tolerance); min = -1.0; max = 1.5; expected = 0.0; tolerance = FastMath.max(solver.getAbsoluteAccuracy(), FastMath.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(100, f, min, max); Assert.assertEquals(expected, result, tolerance); } /** * Test of solver for the quintic function. */ @Test public void testQuinticFunction() { UnivariateFunction f = new QuinticFunction(); UnivariateSolver solver = new RiddersSolver(); double min, max, expected, result, tolerance; min = -0.4; max = 0.2; expected = 0.0; tolerance = FastMath.max(solver.getAbsoluteAccuracy(), FastMath.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(100, f, min, max); Assert.assertEquals(expected, result, tolerance); min = 0.75; max = 1.5; expected = 1.0; tolerance = FastMath.max(solver.getAbsoluteAccuracy(), FastMath.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(100, f, min, max); Assert.assertEquals(expected, result, tolerance); min = -0.9; max = -0.2; expected = -0.5; tolerance = FastMath.max(solver.getAbsoluteAccuracy(), FastMath.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(100, f, min, max); Assert.assertEquals(expected, result, tolerance); } /** * Test of solver for the exponential function. */ @Test public void testExpm1Function() { UnivariateFunction f = new Expm1(); UnivariateSolver solver = new RiddersSolver(); double min, max, expected, result, tolerance; min = -1.0; max = 2.0; expected = 0.0; tolerance = FastMath.max(solver.getAbsoluteAccuracy(), FastMath.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(100, f, min, max); Assert.assertEquals(expected, result, tolerance); min = -20.0; max = 10.0; expected = 0.0; tolerance = FastMath.max(solver.getAbsoluteAccuracy(), FastMath.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(100, f, min, max); Assert.assertEquals(expected, result, tolerance); min = -50.0; max = 100.0; expected = 0.0; tolerance = FastMath.max(solver.getAbsoluteAccuracy(), FastMath.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(100, f, min, max); Assert.assertEquals(expected, result, tolerance); } /** * Test of parameters for the solver. */ @Test public void testParameters() { UnivariateFunction f = new Sin(); UnivariateSolver solver = new RiddersSolver(); try { // bad interval solver.solve(100, f, 1, -1); Assert.fail("Expecting NumberIsTooLargeException - bad interval"); } catch (NumberIsTooLargeException ex) { // expected } try { // no bracketing solver.solve(100, f, 2, 3); Assert.fail("Expecting NoBracketingException - no bracketing"); } catch (NoBracketingException ex) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.solvers; /** * Test case for {@link SecantSolver Secant} solver. * * @version $Id$ */ public final class SecantSolverTest extends BaseSecantSolverAbstractTest { /** {@inheritDoc} */ @Override protected UnivariateSolver getSolver() { return new SecantSolver(); } /** {@inheritDoc} */ @Override protected int[] getQuinticEvalCounts() { // As the Secant method does not maintain a bracketed solution, // convergence is not guaranteed. Two test cases are disabled (-1) due // to bad solutions. return new int[] {3, 7, -1, 8, 9, 8, 11, 12, 14, -1, 16}; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.analysis.solvers; import org.apache.commons.math3.analysis.QuinticFunction; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.function.Sin; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * @version $Id$ */ public class UnivariateSolverUtilsTest { protected UnivariateFunction sin = new Sin(); @Test(expected=MathIllegalArgumentException.class) public void testSolveNull() { UnivariateSolverUtils.solve(null, 0.0, 4.0); } @Test(expected=MathIllegalArgumentException.class) public void testSolveBadEndpoints() { double root = UnivariateSolverUtils.solve(sin, 4.0, -0.1, 1e-6); System.out.println("root=" + root); } @Test public void testSolveBadAccuracy() { try { // bad accuracy UnivariateSolverUtils.solve(sin, 0.0, 4.0, 0.0); // Assert.fail("Expecting MathIllegalArgumentException"); // TODO needs rework since convergence behaviour was changed } catch (MathIllegalArgumentException ex) { // expected } } @Test public void testSolveSin() { double x = UnivariateSolverUtils.solve(sin, 1.0, 4.0); Assert.assertEquals(FastMath.PI, x, 1.0e-4); } @Test(expected=MathIllegalArgumentException.class) public void testSolveAccuracyNull() { double accuracy = 1.0e-6; UnivariateSolverUtils.solve(null, 0.0, 4.0, accuracy); } @Test public void testSolveAccuracySin() { double accuracy = 1.0e-6; double x = UnivariateSolverUtils.solve(sin, 1.0, 4.0, accuracy); Assert.assertEquals(FastMath.PI, x, accuracy); } @Test(expected=MathIllegalArgumentException.class) public void testSolveNoRoot() { UnivariateSolverUtils.solve(sin, 1.0, 1.5); } @Test public void testBracketSin() { double[] result = UnivariateSolverUtils.bracket(sin, 0.0, -2.0, 2.0); Assert.assertTrue(sin.value(result[0]) < 0); Assert.assertTrue(sin.value(result[1]) > 0); } @Test public void testBracketEndpointRoot() { double[] result = UnivariateSolverUtils.bracket(sin, 1.5, 0, 2.0); Assert.assertEquals(0.0, sin.value(result[0]), 1.0e-15); Assert.assertTrue(sin.value(result[1]) > 0); } @Test(expected=MathIllegalArgumentException.class) public void testNullFunction() { UnivariateSolverUtils.bracket(null, 1.5, 0, 2.0); } @Test(expected=MathIllegalArgumentException.class) public void testBadInitial() { UnivariateSolverUtils.bracket(sin, 2.5, 0, 2.0); } @Test(expected=MathIllegalArgumentException.class) public void testBadEndpoints() { // endpoints not valid UnivariateSolverUtils.bracket(sin, 1.5, 2.0, 1.0); } @Test(expected=MathIllegalArgumentException.class) public void testBadMaximumIterations() { // bad maximum iterations UnivariateSolverUtils.bracket(sin, 1.5, 0, 2.0, 0); } @Test public void testMisc() { UnivariateFunction f = new QuinticFunction(); double result; // Static solve method result = UnivariateSolverUtils.solve(f, -0.2, 0.2); Assert.assertEquals(result, 0, 1E-8); result = UnivariateSolverUtils.solve(f, -0.1, 0.3); Assert.assertEquals(result, 0, 1E-8); result = UnivariateSolverUtils.solve(f, -0.3, 0.45); Assert.assertEquals(result, 0, 1E-6); result = UnivariateSolverUtils.solve(f, 0.3, 0.7); Assert.assertEquals(result, 0.5, 1E-6); result = UnivariateSolverUtils.solve(f, 0.2, 0.6); Assert.assertEquals(result, 0.5, 1E-6); result = UnivariateSolverUtils.solve(f, 0.05, 0.95); Assert.assertEquals(result, 0.5, 1E-6); result = UnivariateSolverUtils.solve(f, 0.85, 1.25); Assert.assertEquals(result, 1.0, 1E-6); result = UnivariateSolverUtils.solve(f, 0.8, 1.2); Assert.assertEquals(result, 1.0, 1E-6); result = UnivariateSolverUtils.solve(f, 0.85, 1.75); Assert.assertEquals(result, 1.0, 1E-6); result = UnivariateSolverUtils.solve(f, 0.55, 1.45); Assert.assertEquals(result, 1.0, 1E-6); result = UnivariateSolverUtils.solve(f, 0.85, 5); Assert.assertEquals(result, 1.0, 1E-6); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.complex; import org.apache.commons.math3.TestUtils; import org.junit.Assert; import org.junit.Test; public class ComplexFieldTest { @Test public void testZero() { Assert.assertEquals(Complex.ZERO, ComplexField.getInstance().getZero()); } @Test public void testOne() { Assert.assertEquals(Complex.ONE, ComplexField.getInstance().getOne()); } @Test public void testSerial() { // deserializing the singleton should give the singleton itself back ComplexField field = ComplexField.getInstance(); Assert.assertTrue(field == TestUtils.serializeAndRecover(field)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.complex; import java.util.Locale; public class ComplexFormatTest extends ComplexFormatAbstractTest { @Override protected char getDecimalCharacter() { return '.'; } @Override protected Locale getLocale() { return Locale.US; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.complex; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.exception.NullArgumentException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; import java.util.List; /** * @version $Id$ */ public class ComplexTest { private double inf = Double.POSITIVE_INFINITY; private double neginf = Double.NEGATIVE_INFINITY; private double nan = Double.NaN; private double pi = FastMath.PI; private Complex oneInf = new Complex(1, inf); private Complex oneNegInf = new Complex(1, neginf); private Complex infOne = new Complex(inf, 1); private Complex infZero = new Complex(inf, 0); private Complex infNaN = new Complex(inf, nan); private Complex infNegInf = new Complex(inf, neginf); private Complex infInf = new Complex(inf, inf); private Complex negInfInf = new Complex(neginf, inf); private Complex negInfZero = new Complex(neginf, 0); private Complex negInfOne = new Complex(neginf, 1); private Complex negInfNaN = new Complex(neginf, nan); private Complex negInfNegInf = new Complex(neginf, neginf); private Complex oneNaN = new Complex(1, nan); private Complex zeroInf = new Complex(0, inf); private Complex zeroNaN = new Complex(0, nan); private Complex nanInf = new Complex(nan, inf); private Complex nanNegInf = new Complex(nan, neginf); private Complex nanZero = new Complex(nan, 0); @Test public void testConstructor() { Complex z = new Complex(3.0, 4.0); Assert.assertEquals(3.0, z.getReal(), 1.0e-5); Assert.assertEquals(4.0, z.getImaginary(), 1.0e-5); } @Test public void testConstructorNaN() { Complex z = new Complex(3.0, Double.NaN); Assert.assertTrue(z.isNaN()); z = new Complex(nan, 4.0); Assert.assertTrue(z.isNaN()); z = new Complex(3.0, 4.0); Assert.assertFalse(z.isNaN()); } @Test public void testAbs() { Complex z = new Complex(3.0, 4.0); Assert.assertEquals(5.0, z.abs(), 1.0e-5); } @Test public void testAbsNaN() { Assert.assertTrue(Double.isNaN(Complex.NaN.abs())); Complex z = new Complex(inf, nan); Assert.assertTrue(Double.isNaN(z.abs())); } @Test public void testAbsInfinite() { Complex z = new Complex(inf, 0); Assert.assertEquals(inf, z.abs(), 0); z = new Complex(0, neginf); Assert.assertEquals(inf, z.abs(), 0); z = new Complex(inf, neginf); Assert.assertEquals(inf, z.abs(), 0); } @Test public void testAdd() { Complex x = new Complex(3.0, 4.0); Complex y = new Complex(5.0, 6.0); Complex z = x.add(y); Assert.assertEquals(8.0, z.getReal(), 1.0e-5); Assert.assertEquals(10.0, z.getImaginary(), 1.0e-5); } @Test public void testAddNaN() { Complex x = new Complex(3.0, 4.0); Complex z = x.add(Complex.NaN); Assert.assertSame(Complex.NaN, z); z = new Complex(1, nan); Complex w = x.add(z); Assert.assertSame(Complex.NaN, w); } @Test public void testAddInf() { Complex x = new Complex(1, 1); Complex z = new Complex(inf, 0); Complex w = x.add(z); Assert.assertEquals(w.getImaginary(), 1, 0); Assert.assertEquals(inf, w.getReal(), 0); x = new Complex(neginf, 0); Assert.assertTrue(Double.isNaN(x.add(z).getReal())); } @Test public void testScalarAdd() { Complex x = new Complex(3.0, 4.0); double yDouble = 2.0; Complex yComplex = new Complex(yDouble); Assert.assertEquals(x.add(yComplex), x.add(yDouble)); } @Test public void testScalarAddNaN() { Complex x = new Complex(3.0, 4.0); double yDouble = Double.NaN; Complex yComplex = new Complex(yDouble); Assert.assertEquals(x.add(yComplex), x.add(yDouble)); } @Test public void testScalarAddInf() { Complex x = new Complex(1, 1); double yDouble = Double.POSITIVE_INFINITY; Complex yComplex = new Complex(yDouble); Assert.assertEquals(x.add(yComplex), x.add(yDouble)); x = new Complex(neginf, 0); Assert.assertEquals(x.add(yComplex), x.add(yDouble)); } @Test public void testConjugate() { Complex x = new Complex(3.0, 4.0); Complex z = x.conjugate(); Assert.assertEquals(3.0, z.getReal(), 1.0e-5); Assert.assertEquals(-4.0, z.getImaginary(), 1.0e-5); } @Test public void testConjugateNaN() { Complex z = Complex.NaN.conjugate(); Assert.assertTrue(z.isNaN()); } @Test public void testConjugateInfiinite() { Complex z = new Complex(0, inf); Assert.assertEquals(neginf, z.conjugate().getImaginary(), 0); z = new Complex(0, neginf); Assert.assertEquals(inf, z.conjugate().getImaginary(), 0); } @Test public void testDivide() { Complex x = new Complex(3.0, 4.0); Complex y = new Complex(5.0, 6.0); Complex z = x.divide(y); Assert.assertEquals(39.0 / 61.0, z.getReal(), 1.0e-5); Assert.assertEquals(2.0 / 61.0, z.getImaginary(), 1.0e-5); } @Test public void testDivideReal() { Complex x = new Complex(2d, 3d); Complex y = new Complex(2d, 0d); Assert.assertEquals(new Complex(1d, 1.5), x.divide(y)); } @Test public void testDivideImaginary() { Complex x = new Complex(2d, 3d); Complex y = new Complex(0d, 2d); Assert.assertEquals(new Complex(1.5d, -1d), x.divide(y)); } @Test public void testDivideInf() { Complex x = new Complex(3, 4); Complex w = new Complex(neginf, inf); Assert.assertTrue(x.divide(w).equals(Complex.ZERO)); Complex z = w.divide(x); Assert.assertTrue(Double.isNaN(z.getReal())); Assert.assertEquals(inf, z.getImaginary(), 0); w = new Complex(inf, inf); z = w.divide(x); Assert.assertTrue(Double.isNaN(z.getImaginary())); Assert.assertEquals(inf, z.getReal(), 0); w = new Complex(1, inf); z = w.divide(w); Assert.assertTrue(Double.isNaN(z.getReal())); Assert.assertTrue(Double.isNaN(z.getImaginary())); } @Test public void testDivideZero() { Complex x = new Complex(3.0, 4.0); Complex z = x.divide(Complex.ZERO); // Assert.assertEquals(z, Complex.INF); // See MATH-657 Assert.assertEquals(z, Complex.NaN); } @Test public void testDivideZeroZero() { Complex x = new Complex(0.0, 0.0); Complex z = x.divide(Complex.ZERO); Assert.assertEquals(z, Complex.NaN); } @Test public void testDivideNaN() { Complex x = new Complex(3.0, 4.0); Complex z = x.divide(Complex.NaN); Assert.assertTrue(z.isNaN()); } @Test public void testDivideNaNInf() { Complex z = oneInf.divide(Complex.ONE); Assert.assertTrue(Double.isNaN(z.getReal())); Assert.assertEquals(inf, z.getImaginary(), 0); z = negInfNegInf.divide(oneNaN); Assert.assertTrue(Double.isNaN(z.getReal())); Assert.assertTrue(Double.isNaN(z.getImaginary())); z = negInfInf.divide(Complex.ONE); Assert.assertTrue(Double.isNaN(z.getReal())); Assert.assertTrue(Double.isNaN(z.getImaginary())); } @Test public void testScalarDivide() { Complex x = new Complex(3.0, 4.0); double yDouble = 2.0; Complex yComplex = new Complex(yDouble); Assert.assertEquals(x.divide(yComplex), x.divide(yDouble)); } @Test public void testScalarDivideNaN() { Complex x = new Complex(3.0, 4.0); double yDouble = Double.NaN; Complex yComplex = new Complex(yDouble); Assert.assertEquals(x.divide(yComplex), x.divide(yDouble)); } @Test public void testScalarDivideInf() { Complex x = new Complex(1,1); double yDouble = Double.POSITIVE_INFINITY; Complex yComplex = new Complex(yDouble); TestUtils.assertEquals(x.divide(yComplex), x.divide(yDouble), 0); yDouble = Double.NEGATIVE_INFINITY; yComplex = new Complex(yDouble); TestUtils.assertEquals(x.divide(yComplex), x.divide(yDouble), 0); x = new Complex(1, Double.NEGATIVE_INFINITY); TestUtils.assertEquals(x.divide(yComplex), x.divide(yDouble), 0); } @Test public void testScalarDivideZero() { Complex x = new Complex(1,1); TestUtils.assertEquals(x.divide(Complex.ZERO), x.divide(0), 0); } @Test public void testReciprocal() { Complex z = new Complex(5.0, 6.0); Complex act = z.reciprocal(); double expRe = 5.0 / 61.0; double expIm = -6.0 / 61.0; Assert.assertEquals(expRe, act.getReal(), FastMath.ulp(expRe)); Assert.assertEquals(expIm, act.getImaginary(), FastMath.ulp(expIm)); } @Test public void testReciprocalReal() { Complex z = new Complex(-2.0, 0.0); Assert.assertEquals(new Complex(-0.5, 0.0), z.reciprocal()); } @Test public void testReciprocalImaginary() { Complex z = new Complex(0.0, -2.0); Assert.assertEquals(new Complex(0.0, 0.5), z.reciprocal()); } @Test public void testReciprocalInf() { Complex z = new Complex(neginf, inf); Assert.assertTrue(z.reciprocal().equals(Complex.ZERO)); z = new Complex(1, inf).reciprocal(); Assert.assertEquals(z, Complex.ZERO); } @Test public void testReciprocalZero() { Assert.assertEquals(Complex.ZERO.reciprocal(), Complex.INF); } @Test public void testReciprocalNaN() { Assert.assertTrue(Complex.NaN.reciprocal().isNaN()); } @Test public void testMultiply() { Complex x = new Complex(3.0, 4.0); Complex y = new Complex(5.0, 6.0); Complex z = x.multiply(y); Assert.assertEquals(-9.0, z.getReal(), 1.0e-5); Assert.assertEquals(38.0, z.getImaginary(), 1.0e-5); } @Test public void testMultiplyNaN() { Complex x = new Complex(3.0, 4.0); Complex z = x.multiply(Complex.NaN); Assert.assertSame(Complex.NaN, z); z = Complex.NaN.multiply(5); Assert.assertSame(Complex.NaN, z); } @Test public void testMultiplyInfInf() { // Assert.assertTrue(infInf.multiply(infInf).isNaN()); // MATH-620 Assert.assertTrue(infInf.multiply(infInf).isInfinite()); } @Test public void testMultiplyNaNInf() { Complex z = new Complex(1,1); Complex w = z.multiply(infOne); Assert.assertEquals(w.getReal(), inf, 0); Assert.assertEquals(w.getImaginary(), inf, 0); // [MATH-164] Assert.assertTrue(new Complex( 1,0).multiply(infInf).equals(Complex.INF)); Assert.assertTrue(new Complex(-1,0).multiply(infInf).equals(Complex.INF)); Assert.assertTrue(new Complex( 1,0).multiply(negInfZero).equals(Complex.INF)); w = oneInf.multiply(oneNegInf); Assert.assertEquals(w.getReal(), inf, 0); Assert.assertEquals(w.getImaginary(), inf, 0); w = negInfNegInf.multiply(oneNaN); Assert.assertTrue(Double.isNaN(w.getReal())); Assert.assertTrue(Double.isNaN(w.getImaginary())); z = new Complex(1, neginf); Assert.assertSame(Complex.INF, z.multiply(z)); } @Test public void testScalarMultiply() { Complex x = new Complex(3.0, 4.0); double yDouble = 2.0; Complex yComplex = new Complex(yDouble); Assert.assertEquals(x.multiply(yComplex), x.multiply(yDouble)); int zInt = -5; Complex zComplex = new Complex(zInt); Assert.assertEquals(x.multiply(zComplex), x.multiply(zInt)); } @Test public void testScalarMultiplyNaN() { Complex x = new Complex(3.0, 4.0); double yDouble = Double.NaN; Complex yComplex = new Complex(yDouble); Assert.assertEquals(x.multiply(yComplex), x.multiply(yDouble)); } @Test public void testScalarMultiplyInf() { Complex x = new Complex(1, 1); double yDouble = Double.POSITIVE_INFINITY; Complex yComplex = new Complex(yDouble); Assert.assertEquals(x.multiply(yComplex), x.multiply(yDouble)); yDouble = Double.NEGATIVE_INFINITY; yComplex = new Complex(yDouble); Assert.assertEquals(x.multiply(yComplex), x.multiply(yDouble)); } @Test public void testNegate() { Complex x = new Complex(3.0, 4.0); Complex z = x.negate(); Assert.assertEquals(-3.0, z.getReal(), 1.0e-5); Assert.assertEquals(-4.0, z.getImaginary(), 1.0e-5); } @Test public void testNegateNaN() { Complex z = Complex.NaN.negate(); Assert.assertTrue(z.isNaN()); } @Test public void testSubtract() { Complex x = new Complex(3.0, 4.0); Complex y = new Complex(5.0, 6.0); Complex z = x.subtract(y); Assert.assertEquals(-2.0, z.getReal(), 1.0e-5); Assert.assertEquals(-2.0, z.getImaginary(), 1.0e-5); } @Test public void testSubtractNaN() { Complex x = new Complex(3.0, 4.0); Complex z = x.subtract(Complex.NaN); Assert.assertSame(Complex.NaN, z); z = new Complex(1, nan); Complex w = x.subtract(z); Assert.assertSame(Complex.NaN, w); } @Test public void testSubtractInf() { Complex x = new Complex(1, 1); Complex z = new Complex(neginf, 0); Complex w = x.subtract(z); Assert.assertEquals(w.getImaginary(), 1, 0); Assert.assertEquals(inf, w.getReal(), 0); x = new Complex(neginf, 0); Assert.assertTrue(Double.isNaN(x.subtract(z).getReal())); } @Test public void testScalarSubtract() { Complex x = new Complex(3.0, 4.0); double yDouble = 2.0; Complex yComplex = new Complex(yDouble); Assert.assertEquals(x.subtract(yComplex), x.subtract(yDouble)); } @Test public void testScalarSubtractNaN() { Complex x = new Complex(3.0, 4.0); double yDouble = Double.NaN; Complex yComplex = new Complex(yDouble); Assert.assertEquals(x.subtract(yComplex), x.subtract(yDouble)); } @Test public void testScalarSubtractInf() { Complex x = new Complex(1, 1); double yDouble = Double.POSITIVE_INFINITY; Complex yComplex = new Complex(yDouble); Assert.assertEquals(x.subtract(yComplex), x.subtract(yDouble)); x = new Complex(neginf, 0); Assert.assertEquals(x.subtract(yComplex), x.subtract(yDouble)); } @Test public void testEqualsNull() { Complex x = new Complex(3.0, 4.0); Assert.assertFalse(x.equals(null)); } @Test public void testEqualsClass() { Complex x = new Complex(3.0, 4.0); Assert.assertFalse(x.equals(this)); } @Test public void testEqualsSame() { Complex x = new Complex(3.0, 4.0); Assert.assertTrue(x.equals(x)); } @Test public void testEqualsTrue() { Complex x = new Complex(3.0, 4.0); Complex y = new Complex(3.0, 4.0); Assert.assertTrue(x.equals(y)); } @Test public void testEqualsRealDifference() { Complex x = new Complex(0.0, 0.0); Complex y = new Complex(0.0 + Double.MIN_VALUE, 0.0); Assert.assertFalse(x.equals(y)); } @Test public void testEqualsImaginaryDifference() { Complex x = new Complex(0.0, 0.0); Complex y = new Complex(0.0, 0.0 + Double.MIN_VALUE); Assert.assertFalse(x.equals(y)); } @Test public void testEqualsNaN() { Complex realNaN = new Complex(Double.NaN, 0.0); Complex imaginaryNaN = new Complex(0.0, Double.NaN); Complex complexNaN = Complex.NaN; Assert.assertTrue(realNaN.equals(imaginaryNaN)); Assert.assertTrue(imaginaryNaN.equals(complexNaN)); Assert.assertTrue(realNaN.equals(complexNaN)); } @Test public void testHashCode() { Complex x = new Complex(0.0, 0.0); Complex y = new Complex(0.0, 0.0 + Double.MIN_VALUE); Assert.assertFalse(x.hashCode()==y.hashCode()); y = new Complex(0.0 + Double.MIN_VALUE, 0.0); Assert.assertFalse(x.hashCode()==y.hashCode()); Complex realNaN = new Complex(Double.NaN, 0.0); Complex imaginaryNaN = new Complex(0.0, Double.NaN); Assert.assertEquals(realNaN.hashCode(), imaginaryNaN.hashCode()); Assert.assertEquals(imaginaryNaN.hashCode(), Complex.NaN.hashCode()); } @Test public void testAcos() { Complex z = new Complex(3, 4); Complex expected = new Complex(0.936812, -2.30551); TestUtils.assertEquals(expected, z.acos(), 1.0e-5); TestUtils.assertEquals(new Complex(FastMath.acos(0), 0), Complex.ZERO.acos(), 1.0e-12); } @Test public void testAcosInf() { TestUtils.assertSame(Complex.NaN, oneInf.acos()); TestUtils.assertSame(Complex.NaN, oneNegInf.acos()); TestUtils.assertSame(Complex.NaN, infOne.acos()); TestUtils.assertSame(Complex.NaN, negInfOne.acos()); TestUtils.assertSame(Complex.NaN, infInf.acos()); TestUtils.assertSame(Complex.NaN, infNegInf.acos()); TestUtils.assertSame(Complex.NaN, negInfInf.acos()); TestUtils.assertSame(Complex.NaN, negInfNegInf.acos()); } @Test public void testAcosNaN() { Assert.assertTrue(Complex.NaN.acos().isNaN()); } @Test public void testAsin() { Complex z = new Complex(3, 4); Complex expected = new Complex(0.633984, 2.30551); TestUtils.assertEquals(expected, z.asin(), 1.0e-5); } @Test public void testAsinNaN() { Assert.assertTrue(Complex.NaN.asin().isNaN()); } @Test public void testAsinInf() { TestUtils.assertSame(Complex.NaN, oneInf.asin()); TestUtils.assertSame(Complex.NaN, oneNegInf.asin()); TestUtils.assertSame(Complex.NaN, infOne.asin()); TestUtils.assertSame(Complex.NaN, negInfOne.asin()); TestUtils.assertSame(Complex.NaN, infInf.asin()); TestUtils.assertSame(Complex.NaN, infNegInf.asin()); TestUtils.assertSame(Complex.NaN, negInfInf.asin()); TestUtils.assertSame(Complex.NaN, negInfNegInf.asin()); } @Test public void testAtan() { Complex z = new Complex(3, 4); Complex expected = new Complex(1.44831, 0.158997); TestUtils.assertEquals(expected, z.atan(), 1.0e-5); } @Test public void testAtanInf() { TestUtils.assertSame(Complex.NaN, oneInf.atan()); TestUtils.assertSame(Complex.NaN, oneNegInf.atan()); TestUtils.assertSame(Complex.NaN, infOne.atan()); TestUtils.assertSame(Complex.NaN, negInfOne.atan()); TestUtils.assertSame(Complex.NaN, infInf.atan()); TestUtils.assertSame(Complex.NaN, infNegInf.atan()); TestUtils.assertSame(Complex.NaN, negInfInf.atan()); TestUtils.assertSame(Complex.NaN, negInfNegInf.atan()); } @Test public void testAtanI() { Assert.assertTrue(Complex.I.atan().isNaN()); } @Test public void testAtanNaN() { Assert.assertTrue(Complex.NaN.atan().isNaN()); } @Test public void testCos() { Complex z = new Complex(3, 4); Complex expected = new Complex(-27.03495, -3.851153); TestUtils.assertEquals(expected, z.cos(), 1.0e-5); } @Test public void testCosNaN() { Assert.assertTrue(Complex.NaN.cos().isNaN()); } @Test public void testCosInf() { TestUtils.assertSame(infNegInf, oneInf.cos()); TestUtils.assertSame(infInf, oneNegInf.cos()); TestUtils.assertSame(Complex.NaN, infOne.cos()); TestUtils.assertSame(Complex.NaN, negInfOne.cos()); TestUtils.assertSame(Complex.NaN, infInf.cos()); TestUtils.assertSame(Complex.NaN, infNegInf.cos()); TestUtils.assertSame(Complex.NaN, negInfInf.cos()); TestUtils.assertSame(Complex.NaN, negInfNegInf.cos()); } @Test public void testCosh() { Complex z = new Complex(3, 4); Complex expected = new Complex(-6.58066, -7.58155); TestUtils.assertEquals(expected, z.cosh(), 1.0e-5); } @Test public void testCoshNaN() { Assert.assertTrue(Complex.NaN.cosh().isNaN()); } @Test public void testCoshInf() { TestUtils.assertSame(Complex.NaN, oneInf.cosh()); TestUtils.assertSame(Complex.NaN, oneNegInf.cosh()); TestUtils.assertSame(infInf, infOne.cosh()); TestUtils.assertSame(infNegInf, negInfOne.cosh()); TestUtils.assertSame(Complex.NaN, infInf.cosh()); TestUtils.assertSame(Complex.NaN, infNegInf.cosh()); TestUtils.assertSame(Complex.NaN, negInfInf.cosh()); TestUtils.assertSame(Complex.NaN, negInfNegInf.cosh()); } @Test public void testExp() { Complex z = new Complex(3, 4); Complex expected = new Complex(-13.12878, -15.20078); TestUtils.assertEquals(expected, z.exp(), 1.0e-5); TestUtils.assertEquals(Complex.ONE, Complex.ZERO.exp(), 10e-12); Complex iPi = Complex.I.multiply(new Complex(pi,0)); TestUtils.assertEquals(Complex.ONE.negate(), iPi.exp(), 10e-12); } @Test public void testExpNaN() { Assert.assertTrue(Complex.NaN.exp().isNaN()); } @Test public void testExpInf() { TestUtils.assertSame(Complex.NaN, oneInf.exp()); TestUtils.assertSame(Complex.NaN, oneNegInf.exp()); TestUtils.assertSame(infInf, infOne.exp()); TestUtils.assertSame(Complex.ZERO, negInfOne.exp()); TestUtils.assertSame(Complex.NaN, infInf.exp()); TestUtils.assertSame(Complex.NaN, infNegInf.exp()); TestUtils.assertSame(Complex.NaN, negInfInf.exp()); TestUtils.assertSame(Complex.NaN, negInfNegInf.exp()); } @Test public void testLog() { Complex z = new Complex(3, 4); Complex expected = new Complex(1.60944, 0.927295); TestUtils.assertEquals(expected, z.log(), 1.0e-5); } @Test public void testLogNaN() { Assert.assertTrue(Complex.NaN.log().isNaN()); } @Test public void testLogInf() { TestUtils.assertEquals(new Complex(inf, pi / 2), oneInf.log(), 10e-12); TestUtils.assertEquals(new Complex(inf, -pi / 2), oneNegInf.log(), 10e-12); TestUtils.assertEquals(infZero, infOne.log(), 10e-12); TestUtils.assertEquals(new Complex(inf, pi), negInfOne.log(), 10e-12); TestUtils.assertEquals(new Complex(inf, pi / 4), infInf.log(), 10e-12); TestUtils.assertEquals(new Complex(inf, -pi / 4), infNegInf.log(), 10e-12); TestUtils.assertEquals(new Complex(inf, 3d * pi / 4), negInfInf.log(), 10e-12); TestUtils.assertEquals(new Complex(inf, - 3d * pi / 4), negInfNegInf.log(), 10e-12); } @Test public void testLogZero() { TestUtils.assertSame(negInfZero, Complex.ZERO.log()); } @Test public void testPow() { Complex x = new Complex(3, 4); Complex y = new Complex(5, 6); Complex expected = new Complex(-1.860893, 11.83677); TestUtils.assertEquals(expected, x.pow(y), 1.0e-5); } @Test public void testPowNaNBase() { Complex x = new Complex(3, 4); Assert.assertTrue(Complex.NaN.pow(x).isNaN()); } @Test public void testPowNaNExponent() { Complex x = new Complex(3, 4); Assert.assertTrue(x.pow(Complex.NaN).isNaN()); } @Test public void testPowInf() { TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(oneInf)); TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(oneNegInf)); TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(infOne)); TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(infInf)); TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(infNegInf)); TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(negInfInf)); TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(negInfNegInf)); TestUtils.assertSame(Complex.NaN,infOne.pow(Complex.ONE)); TestUtils.assertSame(Complex.NaN,negInfOne.pow(Complex.ONE)); TestUtils.assertSame(Complex.NaN,infInf.pow(Complex.ONE)); TestUtils.assertSame(Complex.NaN,infNegInf.pow(Complex.ONE)); TestUtils.assertSame(Complex.NaN,negInfInf.pow(Complex.ONE)); TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(Complex.ONE)); TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(infNegInf)); TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(negInfNegInf)); TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(infInf)); TestUtils.assertSame(Complex.NaN,infInf.pow(infNegInf)); TestUtils.assertSame(Complex.NaN,infInf.pow(negInfNegInf)); TestUtils.assertSame(Complex.NaN,infInf.pow(infInf)); TestUtils.assertSame(Complex.NaN,infNegInf.pow(infNegInf)); TestUtils.assertSame(Complex.NaN,infNegInf.pow(negInfNegInf)); TestUtils.assertSame(Complex.NaN,infNegInf.pow(infInf)); } @Test public void testPowZero() { TestUtils.assertSame(Complex.NaN, Complex.ZERO.pow(Complex.ONE)); TestUtils.assertSame(Complex.NaN, Complex.ZERO.pow(Complex.ZERO)); TestUtils.assertSame(Complex.NaN, Complex.ZERO.pow(Complex.I)); TestUtils.assertEquals(Complex.ONE, Complex.ONE.pow(Complex.ZERO), 10e-12); TestUtils.assertEquals(Complex.ONE, Complex.I.pow(Complex.ZERO), 10e-12); TestUtils.assertEquals(Complex.ONE, new Complex(-1, 3).pow(Complex.ZERO), 10e-12); } @Test public void testScalarPow() { Complex x = new Complex(3, 4); double yDouble = 5.0; Complex yComplex = new Complex(yDouble); Assert.assertEquals(x.pow(yComplex), x.pow(yDouble)); } @Test public void testScalarPowNaNBase() { Complex x = Complex.NaN; double yDouble = 5.0; Complex yComplex = new Complex(yDouble); Assert.assertEquals(x.pow(yComplex), x.pow(yDouble)); } @Test public void testScalarPowNaNExponent() { Complex x = new Complex(3, 4); double yDouble = Double.NaN; Complex yComplex = new Complex(yDouble); Assert.assertEquals(x.pow(yComplex), x.pow(yDouble)); } @Test public void testScalarPowInf() { TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(Double.POSITIVE_INFINITY)); TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(Double.NEGATIVE_INFINITY)); TestUtils.assertSame(Complex.NaN,infOne.pow(1.0)); TestUtils.assertSame(Complex.NaN,negInfOne.pow(1.0)); TestUtils.assertSame(Complex.NaN,infInf.pow(1.0)); TestUtils.assertSame(Complex.NaN,infNegInf.pow(1.0)); TestUtils.assertSame(Complex.NaN,negInfInf.pow(10)); TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(1.0)); TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(Double.POSITIVE_INFINITY)); TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(Double.POSITIVE_INFINITY)); TestUtils.assertSame(Complex.NaN,infInf.pow(Double.POSITIVE_INFINITY)); TestUtils.assertSame(Complex.NaN,infInf.pow(Double.NEGATIVE_INFINITY)); TestUtils.assertSame(Complex.NaN,infNegInf.pow(Double.NEGATIVE_INFINITY)); TestUtils.assertSame(Complex.NaN,infNegInf.pow(Double.POSITIVE_INFINITY)); } @Test public void testScalarPowZero() { TestUtils.assertSame(Complex.NaN, Complex.ZERO.pow(1.0)); TestUtils.assertSame(Complex.NaN, Complex.ZERO.pow(0.0)); TestUtils.assertEquals(Complex.ONE, Complex.ONE.pow(0.0), 10e-12); TestUtils.assertEquals(Complex.ONE, Complex.I.pow(0.0), 10e-12); TestUtils.assertEquals(Complex.ONE, new Complex(-1, 3).pow(0.0), 10e-12); } @Test(expected=NullArgumentException.class) public void testpowNull() { Complex.ONE.pow(null); } @Test public void testSin() { Complex z = new Complex(3, 4); Complex expected = new Complex(3.853738, -27.01681); TestUtils.assertEquals(expected, z.sin(), 1.0e-5); } @Test public void testSinInf() { TestUtils.assertSame(infInf, oneInf.sin()); TestUtils.assertSame(infNegInf, oneNegInf.sin()); TestUtils.assertSame(Complex.NaN, infOne.sin()); TestUtils.assertSame(Complex.NaN, negInfOne.sin()); TestUtils.assertSame(Complex.NaN, infInf.sin()); TestUtils.assertSame(Complex.NaN, infNegInf.sin()); TestUtils.assertSame(Complex.NaN, negInfInf.sin()); TestUtils.assertSame(Complex.NaN, negInfNegInf.sin()); } @Test public void testSinNaN() { Assert.assertTrue(Complex.NaN.sin().isNaN()); } @Test public void testSinh() { Complex z = new Complex(3, 4); Complex expected = new Complex(-6.54812, -7.61923); TestUtils.assertEquals(expected, z.sinh(), 1.0e-5); } @Test public void testSinhNaN() { Assert.assertTrue(Complex.NaN.sinh().isNaN()); } @Test public void testSinhInf() { TestUtils.assertSame(Complex.NaN, oneInf.sinh()); TestUtils.assertSame(Complex.NaN, oneNegInf.sinh()); TestUtils.assertSame(infInf, infOne.sinh()); TestUtils.assertSame(negInfInf, negInfOne.sinh()); TestUtils.assertSame(Complex.NaN, infInf.sinh()); TestUtils.assertSame(Complex.NaN, infNegInf.sinh()); TestUtils.assertSame(Complex.NaN, negInfInf.sinh()); TestUtils.assertSame(Complex.NaN, negInfNegInf.sinh()); } @Test public void testSqrtRealPositive() { Complex z = new Complex(3, 4); Complex expected = new Complex(2, 1); TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5); } @Test public void testSqrtRealZero() { Complex z = new Complex(0.0, 4); Complex expected = new Complex(1.41421, 1.41421); TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5); } @Test public void testSqrtRealNegative() { Complex z = new Complex(-3.0, 4); Complex expected = new Complex(1, 2); TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5); } @Test public void testSqrtImaginaryZero() { Complex z = new Complex(-3.0, 0.0); Complex expected = new Complex(0.0, 1.73205); TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5); } @Test public void testSqrtImaginaryNegative() { Complex z = new Complex(-3.0, -4.0); Complex expected = new Complex(1.0, -2.0); TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5); } @Test public void testSqrtPolar() { double r = 1; for (int i = 0; i < 5; i++) { r += i; double theta = 0; for (int j =0; j < 11; j++) { theta += pi /12; Complex z = ComplexUtils.polar2Complex(r, theta); Complex sqrtz = ComplexUtils.polar2Complex(FastMath.sqrt(r), theta / 2); TestUtils.assertEquals(sqrtz, z.sqrt(), 10e-12); } } } @Test public void testSqrtNaN() { Assert.assertTrue(Complex.NaN.sqrt().isNaN()); } @Test public void testSqrtInf() { TestUtils.assertSame(infNaN, oneInf.sqrt()); TestUtils.assertSame(infNaN, oneNegInf.sqrt()); TestUtils.assertSame(infZero, infOne.sqrt()); TestUtils.assertSame(zeroInf, negInfOne.sqrt()); TestUtils.assertSame(infNaN, infInf.sqrt()); TestUtils.assertSame(infNaN, infNegInf.sqrt()); TestUtils.assertSame(nanInf, negInfInf.sqrt()); TestUtils.assertSame(nanNegInf, negInfNegInf.sqrt()); } @Test public void testSqrt1z() { Complex z = new Complex(3, 4); Complex expected = new Complex(4.08033, -2.94094); TestUtils.assertEquals(expected, z.sqrt1z(), 1.0e-5); } @Test public void testSqrt1zNaN() { Assert.assertTrue(Complex.NaN.sqrt1z().isNaN()); } @Test public void testTan() { Complex z = new Complex(3, 4); Complex expected = new Complex(-0.000187346, 0.999356); TestUtils.assertEquals(expected, z.tan(), 1.0e-5); /* Check that no overflow occurs (MATH-722) */ Complex actual = new Complex(3.0, 1E10).tan(); expected = new Complex(0, 1); TestUtils.assertEquals(expected, actual, 1.0e-5); actual = new Complex(3.0, -1E10).tan(); expected = new Complex(0, -1); TestUtils.assertEquals(expected, actual, 1.0e-5); } @Test public void testTanNaN() { Assert.assertTrue(Complex.NaN.tan().isNaN()); } @Test public void testTanInf() { TestUtils.assertSame(Complex.valueOf(0.0, 1.0), oneInf.tan()); TestUtils.assertSame(Complex.valueOf(0.0, -1.0), oneNegInf.tan()); TestUtils.assertSame(Complex.NaN, infOne.tan()); TestUtils.assertSame(Complex.NaN, negInfOne.tan()); TestUtils.assertSame(Complex.NaN, infInf.tan()); TestUtils.assertSame(Complex.NaN, infNegInf.tan()); TestUtils.assertSame(Complex.NaN, negInfInf.tan()); TestUtils.assertSame(Complex.NaN, negInfNegInf.tan()); } @Test public void testTanCritical() { TestUtils.assertSame(infNaN, new Complex(pi/2, 0).tan()); TestUtils.assertSame(negInfNaN, new Complex(-pi/2, 0).tan()); } @Test public void testTanh() { Complex z = new Complex(3, 4); Complex expected = new Complex(1.00071, 0.00490826); TestUtils.assertEquals(expected, z.tanh(), 1.0e-5); /* Check that no overflow occurs (MATH-722) */ Complex actual = new Complex(1E10, 3.0).tanh(); expected = new Complex(1, 0); TestUtils.assertEquals(expected, actual, 1.0e-5); actual = new Complex(-1E10, 3.0).tanh(); expected = new Complex(-1, 0); TestUtils.assertEquals(expected, actual, 1.0e-5); } @Test public void testTanhNaN() { Assert.assertTrue(Complex.NaN.tanh().isNaN()); } @Test public void testTanhInf() { TestUtils.assertSame(Complex.NaN, oneInf.tanh()); TestUtils.assertSame(Complex.NaN, oneNegInf.tanh()); TestUtils.assertSame(Complex.valueOf(1.0, 0.0), infOne.tanh()); TestUtils.assertSame(Complex.valueOf(-1.0, 0.0), negInfOne.tanh()); TestUtils.assertSame(Complex.NaN, infInf.tanh()); TestUtils.assertSame(Complex.NaN, infNegInf.tanh()); TestUtils.assertSame(Complex.NaN, negInfInf.tanh()); TestUtils.assertSame(Complex.NaN, negInfNegInf.tanh()); } @Test public void testTanhCritical() { TestUtils.assertSame(nanInf, new Complex(0, pi/2).tanh()); } /** test issue MATH-221 */ @Test public void testMath221() { Assert.assertEquals(new Complex(0,-1), new Complex(0,1).multiply(new Complex(-1,0))); } /** * Test: computing <b>third roots</b> of z. * <pre> * <code> * <b>z = -2 + 2 * i</b> * => z_0 = 1 + i * => z_1 = -1.3660 + 0.3660 * i * => z_2 = 0.3660 - 1.3660 * i * </code> * </pre> */ @Test public void testNthRoot_normal_thirdRoot() { // The complex number we want to compute all third-roots for. Complex z = new Complex(-2,2); // The List holding all third roots Complex[] thirdRootsOfZ = z.nthRoot(3).toArray(new Complex[0]); // Returned Collection must not be empty! Assert.assertEquals(3, thirdRootsOfZ.length); // test z_0 Assert.assertEquals(1.0, thirdRootsOfZ[0].getReal(), 1.0e-5); Assert.assertEquals(1.0, thirdRootsOfZ[0].getImaginary(), 1.0e-5); // test z_1 Assert.assertEquals(-1.3660254037844386, thirdRootsOfZ[1].getReal(), 1.0e-5); Assert.assertEquals(0.36602540378443843, thirdRootsOfZ[1].getImaginary(), 1.0e-5); // test z_2 Assert.assertEquals(0.366025403784439, thirdRootsOfZ[2].getReal(), 1.0e-5); Assert.assertEquals(-1.3660254037844384, thirdRootsOfZ[2].getImaginary(), 1.0e-5); } /** * Test: computing <b>fourth roots</b> of z. * <pre> * <code> * <b>z = 5 - 2 * i</b> * => z_0 = 1.5164 - 0.1446 * i * => z_1 = 0.1446 + 1.5164 * i * => z_2 = -1.5164 + 0.1446 * i * => z_3 = -1.5164 - 0.1446 * i * </code> * </pre> */ @Test public void testNthRoot_normal_fourthRoot() { // The complex number we want to compute all third-roots for. Complex z = new Complex(5,-2); // The List holding all fourth roots Complex[] fourthRootsOfZ = z.nthRoot(4).toArray(new Complex[0]); // Returned Collection must not be empty! Assert.assertEquals(4, fourthRootsOfZ.length); // test z_0 Assert.assertEquals(1.5164629308487783, fourthRootsOfZ[0].getReal(), 1.0e-5); Assert.assertEquals(-0.14469266210702247, fourthRootsOfZ[0].getImaginary(), 1.0e-5); // test z_1 Assert.assertEquals(0.14469266210702256, fourthRootsOfZ[1].getReal(), 1.0e-5); Assert.assertEquals(1.5164629308487783, fourthRootsOfZ[1].getImaginary(), 1.0e-5); // test z_2 Assert.assertEquals(-1.5164629308487783, fourthRootsOfZ[2].getReal(), 1.0e-5); Assert.assertEquals(0.14469266210702267, fourthRootsOfZ[2].getImaginary(), 1.0e-5); // test z_3 Assert.assertEquals(-0.14469266210702275, fourthRootsOfZ[3].getReal(), 1.0e-5); Assert.assertEquals(-1.5164629308487783, fourthRootsOfZ[3].getImaginary(), 1.0e-5); } /** * Test: computing <b>third roots</b> of z. * <pre> * <code> * <b>z = 8</b> * => z_0 = 2 * => z_1 = -1 + 1.73205 * i * => z_2 = -1 - 1.73205 * i * </code> * </pre> */ @Test public void testNthRoot_cornercase_thirdRoot_imaginaryPartEmpty() { // The number 8 has three third roots. One we all already know is the number 2. // But there are two more complex roots. Complex z = new Complex(8,0); // The List holding all third roots Complex[] thirdRootsOfZ = z.nthRoot(3).toArray(new Complex[0]); // Returned Collection must not be empty! Assert.assertEquals(3, thirdRootsOfZ.length); // test z_0 Assert.assertEquals(2.0, thirdRootsOfZ[0].getReal(), 1.0e-5); Assert.assertEquals(0.0, thirdRootsOfZ[0].getImaginary(), 1.0e-5); // test z_1 Assert.assertEquals(-1.0, thirdRootsOfZ[1].getReal(), 1.0e-5); Assert.assertEquals(1.7320508075688774, thirdRootsOfZ[1].getImaginary(), 1.0e-5); // test z_2 Assert.assertEquals(-1.0, thirdRootsOfZ[2].getReal(), 1.0e-5); Assert.assertEquals(-1.732050807568877, thirdRootsOfZ[2].getImaginary(), 1.0e-5); } /** * Test: computing <b>third roots</b> of z with real part 0. * <pre> * <code> * <b>z = 2 * i</b> * => z_0 = 1.0911 + 0.6299 * i * => z_1 = -1.0911 + 0.6299 * i * => z_2 = -2.3144 - 1.2599 * i * </code> * </pre> */ @Test public void testNthRoot_cornercase_thirdRoot_realPartZero() { // complex number with only imaginary part Complex z = new Complex(0,2); // The List holding all third roots Complex[] thirdRootsOfZ = z.nthRoot(3).toArray(new Complex[0]); // Returned Collection must not be empty! Assert.assertEquals(3, thirdRootsOfZ.length); // test z_0 Assert.assertEquals(1.0911236359717216, thirdRootsOfZ[0].getReal(), 1.0e-5); Assert.assertEquals(0.6299605249474365, thirdRootsOfZ[0].getImaginary(), 1.0e-5); // test z_1 Assert.assertEquals(-1.0911236359717216, thirdRootsOfZ[1].getReal(), 1.0e-5); Assert.assertEquals(0.6299605249474365, thirdRootsOfZ[1].getImaginary(), 1.0e-5); // test z_2 Assert.assertEquals(-2.3144374213981936E-16, thirdRootsOfZ[2].getReal(), 1.0e-5); Assert.assertEquals(-1.2599210498948732, thirdRootsOfZ[2].getImaginary(), 1.0e-5); } /** * Test cornercases with NaN and Infinity. */ @Test public void testNthRoot_cornercase_NAN_Inf() { // NaN + finite -> NaN List<Complex> roots = oneNaN.nthRoot(3); Assert.assertEquals(1,roots.size()); Assert.assertEquals(Complex.NaN, roots.get(0)); roots = nanZero.nthRoot(3); Assert.assertEquals(1,roots.size()); Assert.assertEquals(Complex.NaN, roots.get(0)); // NaN + infinite -> NaN roots = nanInf.nthRoot(3); Assert.assertEquals(1,roots.size()); Assert.assertEquals(Complex.NaN, roots.get(0)); // finite + infinite -> Inf roots = oneInf.nthRoot(3); Assert.assertEquals(1,roots.size()); Assert.assertEquals(Complex.INF, roots.get(0)); // infinite + infinite -> Inf roots = negInfInf.nthRoot(3); Assert.assertEquals(1,roots.size()); Assert.assertEquals(Complex.INF, roots.get(0)); } /** * Test standard values */ @Test public void testGetArgument() { Complex z = new Complex(1, 0); Assert.assertEquals(0.0, z.getArgument(), 1.0e-12); z = new Complex(1, 1); Assert.assertEquals(FastMath.PI/4, z.getArgument(), 1.0e-12); z = new Complex(0, 1); Assert.assertEquals(FastMath.PI/2, z.getArgument(), 1.0e-12); z = new Complex(-1, 1); Assert.assertEquals(3 * FastMath.PI/4, z.getArgument(), 1.0e-12); z = new Complex(-1, 0); Assert.assertEquals(FastMath.PI, z.getArgument(), 1.0e-12); z = new Complex(-1, -1); Assert.assertEquals(-3 * FastMath.PI/4, z.getArgument(), 1.0e-12); z = new Complex(0, -1); Assert.assertEquals(-FastMath.PI/2, z.getArgument(), 1.0e-12); z = new Complex(1, -1); Assert.assertEquals(-FastMath.PI/4, z.getArgument(), 1.0e-12); } /** * Verify atan2-style handling of infinite parts */ @Test public void testGetArgumentInf() { Assert.assertEquals(FastMath.PI/4, infInf.getArgument(), 1.0e-12); Assert.assertEquals(FastMath.PI/2, oneInf.getArgument(), 1.0e-12); Assert.assertEquals(0.0, infOne.getArgument(), 1.0e-12); Assert.assertEquals(FastMath.PI/2, zeroInf.getArgument(), 1.0e-12); Assert.assertEquals(0.0, infZero.getArgument(), 1.0e-12); Assert.assertEquals(FastMath.PI, negInfOne.getArgument(), 1.0e-12); Assert.assertEquals(-3.0*FastMath.PI/4, negInfNegInf.getArgument(), 1.0e-12); Assert.assertEquals(-FastMath.PI/2, oneNegInf.getArgument(), 1.0e-12); } /** * Verify that either part NaN results in NaN */ @Test public void testGetArgumentNaN() { Assert.assertTrue(Double.isNaN(nanZero.getArgument())); Assert.assertTrue(Double.isNaN(zeroNaN.getArgument())); Assert.assertTrue(Double.isNaN(Complex.NaN.getArgument())); } @Test public void testSerial() { Complex z = new Complex(3.0, 4.0); Assert.assertEquals(z, TestUtils.serializeAndRecover(z)); Complex ncmplx = (Complex)TestUtils.serializeAndRecover(oneNaN); Assert.assertEquals(nanZero, ncmplx); Assert.assertTrue(ncmplx.isNaN()); Complex infcmplx = (Complex)TestUtils.serializeAndRecover(infInf); Assert.assertEquals(infInf, infcmplx); Assert.assertTrue(infcmplx.isInfinite()); TestComplex tz = new TestComplex(3.0, 4.0); Assert.assertEquals(tz, TestUtils.serializeAndRecover(tz)); TestComplex ntcmplx = (TestComplex)TestUtils.serializeAndRecover(new TestComplex(oneNaN)); Assert.assertEquals(nanZero, ntcmplx); Assert.assertTrue(ntcmplx.isNaN()); TestComplex inftcmplx = (TestComplex)TestUtils.serializeAndRecover(new TestComplex(infInf)); Assert.assertEquals(infInf, inftcmplx); Assert.assertTrue(inftcmplx.isInfinite()); } /** * Class to test extending Complex */ public static class TestComplex extends Complex { /** * Serialization identifier. */ private static final long serialVersionUID = 3268726724160389237L; public TestComplex(double real, double imaginary) { super(real, imaginary); } public TestComplex(Complex other){ this(other.getReal(), other.getImaginary()); } @Override protected TestComplex createComplex(double real, double imaginary){ return new TestComplex(real, imaginary); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.complex; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.util.FastMath; import org.junit.Test; import org.junit.Assert; /** * @version $Id$ */ public class ComplexUtilsTest { private double inf = Double.POSITIVE_INFINITY; private double negInf = Double.NEGATIVE_INFINITY; private double nan = Double.NaN; private double pi = FastMath.PI; private Complex negInfInf = new Complex(negInf, inf); private Complex infNegInf = new Complex(inf, negInf); private Complex infInf = new Complex(inf, inf); private Complex negInfNegInf = new Complex(negInf, negInf); private Complex infNaN = new Complex(inf, nan); @Test public void testPolar2Complex() { TestUtils.assertEquals(Complex.ONE, ComplexUtils.polar2Complex(1, 0), 10e-12); TestUtils.assertEquals(Complex.ZERO, ComplexUtils.polar2Complex(0, 1), 10e-12); TestUtils.assertEquals(Complex.ZERO, ComplexUtils.polar2Complex(0, -1), 10e-12); TestUtils.assertEquals(Complex.I, ComplexUtils.polar2Complex(1, pi/2), 10e-12); TestUtils.assertEquals(Complex.I.negate(), ComplexUtils.polar2Complex(1, -pi/2), 10e-12); double r = 0; for (int i = 0; i < 5; i++) { r += i; double theta = 0; for (int j =0; j < 20; j++) { theta += pi / 6; TestUtils.assertEquals(altPolar(r, theta), ComplexUtils.polar2Complex(r, theta), 10e-12); } theta = -2 * pi; for (int j =0; j < 20; j++) { theta -= pi / 6; TestUtils.assertEquals(altPolar(r, theta), ComplexUtils.polar2Complex(r, theta), 10e-12); } } } protected Complex altPolar(double r, double theta) { return Complex.I.multiply(new Complex(theta, 0)).exp().multiply(new Complex(r, 0)); } @Test(expected=IllegalArgumentException.class) public void testPolar2ComplexIllegalModulus() { ComplexUtils.polar2Complex(-1, 0); } @Test public void testPolar2ComplexNaN() { TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(nan, 1)); TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(1, nan)); TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(nan, nan)); } @Test public void testPolar2ComplexInf() { TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(1, inf)); TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(1, negInf)); TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(inf, inf)); TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(inf, negInf)); TestUtils.assertSame(infInf, ComplexUtils.polar2Complex(inf, pi/4)); TestUtils.assertSame(infNaN, ComplexUtils.polar2Complex(inf, 0)); TestUtils.assertSame(infNegInf, ComplexUtils.polar2Complex(inf, -pi/4)); TestUtils.assertSame(negInfInf, ComplexUtils.polar2Complex(inf, 3*pi/4)); TestUtils.assertSame(negInfNegInf, ComplexUtils.polar2Complex(inf, 5*pi/4)); } @Test public void testConvertToComplex() { final double[] real = new double[] { negInf, -123.45, 0, 1, 234.56, pi, inf }; final Complex[] complex = ComplexUtils.convertToComplex(real); for (int i = 0; i < real.length; i++) { Assert.assertEquals(real[i], complex[i].getReal(), 0d); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.complex; import java.util.Locale; public class FrenchComplexFormatTest extends ComplexFormatAbstractTest { @Override protected char getDecimalCharacter() { return ','; } @Override protected Locale getLocale() { return Locale.FRENCH; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.complex; import java.util.Random; import org.apache.commons.math3.complex.Quaternion; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.ZeroException; import org.apache.commons.math3.geometry.euclidean.threed.Rotation; import org.apache.commons.math3.geometry.euclidean.threed.Vector3D; import org.apache.commons.math3.util.FastMath; import org.junit.Test; import org.junit.Assert; public class QuaternionTest { /** Epsilon for double comparison. */ private static final double EPS = Math.ulp(1d); /** Epsilon for double comparison. */ private static final double COMPARISON_EPS = 1e-14; @Test public final void testAccessors1() { final double q0 = 2; final double q1 = 5.4; final double q2 = 17; final double q3 = 0.0005; final Quaternion q = new Quaternion(q0, q1, q2, q3); Assert.assertEquals(q0, q.getQ0(), 0); Assert.assertEquals(q1, q.getQ1(), 0); Assert.assertEquals(q2, q.getQ2(), 0); Assert.assertEquals(q3, q.getQ3(), 0); } @Test public final void testAccessors2() { final double q0 = 2; final double q1 = 5.4; final double q2 = 17; final double q3 = 0.0005; final Quaternion q = new Quaternion(q0, q1, q2, q3); final double sP = q.getScalarPart(); final double[] vP = q.getVectorPart(); Assert.assertEquals(q0, sP, 0); Assert.assertEquals(q1, vP[0], 0); Assert.assertEquals(q2, vP[1], 0); Assert.assertEquals(q3, vP[2], 0); } @Test public final void testAccessors3() { final double q0 = 2; final double q1 = 5.4; final double q2 = 17; final double q3 = 0.0005; final Quaternion q = new Quaternion(q0, new double[] { q1, q2, q3 }); final double sP = q.getScalarPart(); final double[] vP = q.getVectorPart(); Assert.assertEquals(q0, sP, 0); Assert.assertEquals(q1, vP[0], 0); Assert.assertEquals(q2, vP[1], 0); Assert.assertEquals(q3, vP[2], 0); } @Test(expected=DimensionMismatchException.class) public void testWrongDimension() { new Quaternion(new double[] { 1, 2 }); } @Test public final void testConjugate() { final double q0 = 2; final double q1 = 5.4; final double q2 = 17; final double q3 = 0.0005; final Quaternion q = new Quaternion(q0, q1, q2, q3); final Quaternion qConjugate = q.getConjugate(); Assert.assertEquals(q0, qConjugate.getQ0(), 0); Assert.assertEquals(-q1, qConjugate.getQ1(), 0); Assert.assertEquals(-q2, qConjugate.getQ2(), 0); Assert.assertEquals(-q3, qConjugate.getQ3(), 0); } @Test public final void testProductQuaternionQuaternion() { // Case : analytic test case final Quaternion qA = new Quaternion(1, 0.5, -3, 4); final Quaternion qB = new Quaternion(6, 2, 1, -9); final Quaternion qResult = Quaternion.multiply(qA, qB); Assert.assertEquals(44, qResult.getQ0(), EPS); Assert.assertEquals(28, qResult.getQ1(), EPS); Assert.assertEquals(-4.5, qResult.getQ2(), EPS); Assert.assertEquals(21.5, qResult.getQ3(), EPS); // comparison with the result given by the formula : // qResult = (scalarA * scalarB - vectorA . vectorB) + (scalarA * vectorB + scalarB * vectorA + vectorA ^ // vectorB) final Vector3D vectorA = new Vector3D(qA.getVectorPart()); final Vector3D vectorB = new Vector3D(qB.getVectorPart()); final Vector3D vectorResult = new Vector3D(qResult.getVectorPart()); final double scalarPartRef = qA.getScalarPart() * qB.getScalarPart() - Vector3D.dotProduct(vectorA, vectorB); Assert.assertEquals(scalarPartRef, qResult.getScalarPart(), EPS); final Vector3D vectorPartRef = ((vectorA.scalarMultiply(qB.getScalarPart())).add(vectorB.scalarMultiply(qA .getScalarPart()))).add(Vector3D.crossProduct(vectorA, vectorB)); final double norm = (vectorResult.subtract(vectorPartRef)).getNorm(); Assert.assertEquals(0, norm, EPS); // Conjugate of the product of two quaternions and product of their conjugates : // Conj(qA * qB) = Conj(qB) * Conj(qA) final Quaternion conjugateOfProduct = qB.getConjugate().multiply(qA.getConjugate()); final Quaternion productOfConjugate = (qA.multiply(qB)).getConjugate(); Assert.assertEquals(conjugateOfProduct.getQ0(), productOfConjugate.getQ0(), EPS); Assert.assertEquals(conjugateOfProduct.getQ1(), productOfConjugate.getQ1(), EPS); Assert.assertEquals(conjugateOfProduct.getQ2(), productOfConjugate.getQ2(), EPS); Assert.assertEquals(conjugateOfProduct.getQ3(), productOfConjugate.getQ3(), EPS); } @Test public final void testProductQuaternionVector() { // Case : Product between a vector and a quaternion : QxV final Quaternion quaternion = new Quaternion(4, 7, -1, 2); final double[] vector = {2.0, 1.0, 3.0}; final Quaternion qResultQxV = Quaternion.multiply(quaternion, new Quaternion(vector)); Assert.assertEquals(-19, qResultQxV.getQ0(), EPS); Assert.assertEquals(3, qResultQxV.getQ1(), EPS); Assert.assertEquals(-13, qResultQxV.getQ2(), EPS); Assert.assertEquals(21, qResultQxV.getQ3(), EPS); // comparison with the result given by the formula : // qResult = (- vectorQ . vector) + (scalarQ * vector + vectorQ ^ vector) final double[] vectorQ = quaternion.getVectorPart(); final double[] vectorResultQxV = qResultQxV.getVectorPart(); final double scalarPartRefQxV = -Vector3D.dotProduct(new Vector3D(vectorQ), new Vector3D(vector)); Assert.assertEquals(scalarPartRefQxV, qResultQxV.getScalarPart(), EPS); final Vector3D vectorPartRefQxV = (new Vector3D(vector).scalarMultiply(quaternion.getScalarPart())).add(Vector3D .crossProduct(new Vector3D(vectorQ), new Vector3D(vector))); final double normQxV = (new Vector3D(vectorResultQxV).subtract(vectorPartRefQxV)).getNorm(); Assert.assertEquals(0, normQxV, EPS); // Case : Product between a vector and a quaternion : VxQ final Quaternion qResultVxQ = Quaternion.multiply(new Quaternion(vector), quaternion); Assert.assertEquals(-19, qResultVxQ.getQ0(), EPS); Assert.assertEquals(13, qResultVxQ.getQ1(), EPS); Assert.assertEquals(21, qResultVxQ.getQ2(), EPS); Assert.assertEquals(3, qResultVxQ.getQ3(), EPS); final double[] vectorResultVxQ = qResultVxQ.getVectorPart(); // comparison with the result given by the formula : // qResult = (- vector . vectorQ) + (scalarQ * vector + vector ^ vectorQ) final double scalarPartRefVxQ = -Vector3D.dotProduct(new Vector3D(vectorQ), new Vector3D(vector)); Assert.assertEquals(scalarPartRefVxQ, qResultVxQ.getScalarPart(), EPS); final Vector3D vectorPartRefVxQ = (new Vector3D(vector).scalarMultiply(quaternion.getScalarPart())).add(Vector3D .crossProduct(new Vector3D(vector), new Vector3D(vectorQ))); final double normVxQ = (new Vector3D(vectorResultVxQ).subtract(vectorPartRefVxQ)).getNorm(); Assert.assertEquals(0, normVxQ, EPS); } @Test public final void testDotProductQuaternionQuaternion() { // expected output final double expected = -6.; // inputs final Quaternion q1 = new Quaternion(1, 2, 2, 1); final Quaternion q2 = new Quaternion(3, -2, -1, -3); final double actual1 = Quaternion.dotProduct(q1, q2); final double actual2 = q1.dotProduct(q2); Assert.assertEquals(expected, actual1, EPS); Assert.assertEquals(expected, actual2, EPS); } @Test public final void testScalarMultiplyDouble() { // expected outputs final double w = 1.6; final double x = -4.8; final double y = 11.20; final double z = 2.56; // inputs final Quaternion q1 = new Quaternion(0.5, -1.5, 3.5, 0.8); final double a = 3.2; final Quaternion q = q1.multiply(a); Assert.assertEquals(w, q.getQ0(), COMPARISON_EPS); Assert.assertEquals(x, q.getQ1(), COMPARISON_EPS); Assert.assertEquals(y, q.getQ2(), COMPARISON_EPS); Assert.assertEquals(z, q.getQ3(), COMPARISON_EPS); } @Test public final void testAddQuaternionQuaternion() { // expected outputs final double w = 4; final double x = -1; final double y = 2; final double z = -4; // inputs final Quaternion q1 = new Quaternion(1., 2., -2., -1.); final Quaternion q2 = new Quaternion(3., -3., 4., -3.); final Quaternion qa = Quaternion.add(q1, q2); final Quaternion qb = q1.add(q2); Assert.assertEquals(w, qa.getQ0(), EPS); Assert.assertEquals(x, qa.getQ1(), EPS); Assert.assertEquals(y, qa.getQ2(), EPS); Assert.assertEquals(z, qa.getQ3(), EPS); Assert.assertEquals(w, qb.getQ0(), EPS); Assert.assertEquals(x, qb.getQ1(), EPS); Assert.assertEquals(y, qb.getQ2(), EPS); Assert.assertEquals(z, qb.getQ3(), EPS); } @Test public final void testSubtractQuaternionQuaternion() { // expected outputs final double w = -2.; final double x = 5.; final double y = -6.; final double z = 2.; // inputs final Quaternion q1 = new Quaternion(1., 2., -2., -1.); final Quaternion q2 = new Quaternion(3., -3., 4., -3.); final Quaternion qa = Quaternion.subtract(q1, q2); final Quaternion qb = q1.subtract(q2); Assert.assertEquals(w, qa.getQ0(), EPS); Assert.assertEquals(x, qa.getQ1(), EPS); Assert.assertEquals(y, qa.getQ2(), EPS); Assert.assertEquals(z, qa.getQ3(), EPS); Assert.assertEquals(w, qb.getQ0(), EPS); Assert.assertEquals(x, qb.getQ1(), EPS); Assert.assertEquals(y, qb.getQ2(), EPS); Assert.assertEquals(z, qb.getQ3(), EPS); } @Test public final void testNorm() { final double q0 = 2; final double q1 = 1; final double q2 = -4; final double q3 = 3; final Quaternion q = new Quaternion(q0, q1, q2, q3); final double norm = q.getNorm(); Assert.assertEquals(Math.sqrt(30), norm, 0); final double normSquareRef = Quaternion.multiply(q, q.getConjugate()).getScalarPart(); Assert.assertEquals(Math.sqrt(normSquareRef), norm, 0); } @Test public final void testNormalize() { final Quaternion q = new Quaternion(2, 1, -4, -2); final Quaternion versor = q.normalize(); Assert.assertEquals(2.0 / 5.0, versor.getQ0(), 0); Assert.assertEquals(1.0 / 5.0, versor.getQ1(), 0); Assert.assertEquals(-4.0 / 5.0, versor.getQ2(), 0); Assert.assertEquals(-2.0 / 5.0, versor.getQ3(), 0); Assert.assertEquals(1, versor.getNorm(), 0); } @Test(expected=ZeroException.class) public final void testNormalizeFail() { final Quaternion zeroQ = new Quaternion(0, 0, 0, 0); zeroQ.normalize(); } @Test public final void testObjectEquals() { final double one = 1; final Quaternion q1 = new Quaternion(one, one, one, one); Assert.assertTrue(q1.equals(q1)); final Quaternion q2 = new Quaternion(one, one, one, one); Assert.assertTrue(q2.equals(q1)); final Quaternion q3 = new Quaternion(one, FastMath.nextUp(one), one, one); Assert.assertFalse(q3.equals(q1)); } @Test public final void testQuaternionEquals() { final double inc = 1e-5; final Quaternion q1 = new Quaternion(2, 1, -4, -2); final Quaternion q2 = new Quaternion(q1.getQ0() + inc, q1.getQ1(), q1.getQ2(), q1.getQ3()); final Quaternion q3 = new Quaternion(q1.getQ0(), q1.getQ1() + inc, q1.getQ2(), q1.getQ3()); final Quaternion q4 = new Quaternion(q1.getQ0(), q1.getQ1(), q1.getQ2() + inc, q1.getQ3()); final Quaternion q5 = new Quaternion(q1.getQ0(), q1.getQ1(), q1.getQ2(), q1.getQ3() + inc); Assert.assertFalse(q1.equals(q2, 0.9 * inc)); Assert.assertFalse(q1.equals(q3, 0.9 * inc)); Assert.assertFalse(q1.equals(q4, 0.9 * inc)); Assert.assertFalse(q1.equals(q5, 0.9 * inc)); Assert.assertTrue(q1.equals(q2, 1.1 * inc)); Assert.assertTrue(q1.equals(q3, 1.1 * inc)); Assert.assertTrue(q1.equals(q4, 1.1 * inc)); Assert.assertTrue(q1.equals(q5, 1.1 * inc)); } @Test public final void testQuaternionEquals2() { final Quaternion q1 = new Quaternion(1, 4, 2, 3); final double gap = 1e-5; final Quaternion q2 = new Quaternion(1 + gap, 4 + gap, 2 + gap, 3 + gap); Assert.assertTrue(q1.equals(q2, 10 * gap)); Assert.assertFalse(q1.equals(q2, gap)); Assert.assertFalse(q1.equals(q2, gap / 10)); } @Test public final void testIsUnitQuaternion() { final Random r = new Random(48); final int numberOfTrials = 1000; for (int i = 0; i < numberOfTrials; i++) { final Quaternion q1 = new Quaternion(r.nextDouble(), r.nextDouble(), r.nextDouble(), r.nextDouble()); final Quaternion q2 = q1.normalize(); Assert.assertTrue(q2.isUnitQuaternion(COMPARISON_EPS)); } final Quaternion q = new Quaternion(1, 1, 1, 1); Assert.assertFalse(q.isUnitQuaternion(COMPARISON_EPS)); } @Test public final void testIsPureQuaternion() { final Quaternion q1 = new Quaternion(0, 5, 4, 8); Assert.assertTrue(q1.isPureQuaternion(EPS)); final Quaternion q2 = new Quaternion(0 - EPS, 5, 4, 8); Assert.assertTrue(q2.isPureQuaternion(EPS)); final Quaternion q3 = new Quaternion(0 - 1.1 * EPS, 5, 4, 8); Assert.assertFalse(q3.isPureQuaternion(EPS)); final Random r = new Random(48); final double[] v = {r.nextDouble(), r.nextDouble(), r.nextDouble()}; final Quaternion q4 = new Quaternion(v); Assert.assertTrue(q4.isPureQuaternion(0)); final Quaternion q5 = new Quaternion(0, v); Assert.assertTrue(q5.isPureQuaternion(0)); } @Test public final void testPolarForm() { final Random r = new Random(48); final int numberOfTrials = 1000; for (int i = 0; i < numberOfTrials; i++) { final Quaternion q = new Quaternion(2 * (r.nextDouble() - 0.5), 2 * (r.nextDouble() - 0.5), 2 * (r.nextDouble() - 0.5), 2 * (r.nextDouble() - 0.5)); final Quaternion qP = q.getPositivePolarForm(); Assert.assertTrue(qP.isUnitQuaternion(COMPARISON_EPS)); Assert.assertTrue(qP.getQ0() >= 0); final Rotation rot = new Rotation(q.getQ0(), q.getQ1(), q.getQ2(), q.getQ3(), true); final Rotation rotP = new Rotation(qP.getQ0(), qP.getQ1(), qP.getQ2(), qP.getQ3(), true); Assert.assertEquals(rot.getAngle(), rotP.getAngle(), COMPARISON_EPS); Assert.assertEquals(rot.getAxis().getX(), rot.getAxis().getX(), COMPARISON_EPS); Assert.assertEquals(rot.getAxis().getY(), rot.getAxis().getY(), COMPARISON_EPS); Assert.assertEquals(rot.getAxis().getZ(), rot.getAxis().getZ(), COMPARISON_EPS); } } @Test public final void testGetInverse() { final Quaternion q = new Quaternion(1.5, 4, 2, -2.5); final Quaternion inverseQ = q.getInverse(); Assert.assertEquals(1.5 / 28.5, inverseQ.getQ0(), 0); Assert.assertEquals(-4.0 / 28.5, inverseQ.getQ1(), 0); Assert.assertEquals(-2.0 / 28.5, inverseQ.getQ2(), 0); Assert.assertEquals(2.5 / 28.5, inverseQ.getQ3(), 0); final Quaternion product = Quaternion.multiply(inverseQ, q); Assert.assertEquals(1, product.getQ0(), EPS); Assert.assertEquals(0, product.getQ1(), EPS); Assert.assertEquals(0, product.getQ2(), EPS); Assert.assertEquals(0, product.getQ3(), EPS); final Quaternion qNul = new Quaternion(0, 0, 0, 0); try { final Quaternion inverseQNul = qNul.getInverse(); Assert.fail("expecting ZeroException but got : " + inverseQNul); } catch (ZeroException ex) { // expected } } @Test public final void testToString() { final Quaternion q = new Quaternion(1, 2, 3, 4); Assert.assertTrue(q.toString().equals("[1.0 2.0 3.0 4.0]")); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.complex; import org.apache.commons.math3.exception.MathIllegalStateException; import org.apache.commons.math3.exception.ZeroException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * Unit tests for the {@link RootsOfUnity} class. * * @version $Id$ */ public class RootsOfUnityTest { @Test(expected = MathIllegalStateException.class) public void testMathIllegalState1() { final RootsOfUnity roots = new RootsOfUnity(); roots.getReal(0); } @Test(expected = MathIllegalStateException.class) public void testMathIllegalState2() { final RootsOfUnity roots = new RootsOfUnity(); roots.getImaginary(0); } @Test(expected = MathIllegalStateException.class) public void testMathIllegalState3() { final RootsOfUnity roots = new RootsOfUnity(); roots.isCounterClockWise(); } @Test(expected = ZeroException.class) public void testZeroNumberOfRoots() { final RootsOfUnity roots = new RootsOfUnity(); roots.computeRoots(0); } @Test public void testGetNumberOfRoots() { final RootsOfUnity roots = new RootsOfUnity(); Assert.assertEquals("", 0, roots.getNumberOfRoots()); roots.computeRoots(5); Assert.assertEquals("", 5, roots.getNumberOfRoots()); /* * Testing -5 right after 5 is important, as the roots in this case are * not recomputed. */ roots.computeRoots(-5); Assert.assertEquals("", 5, roots.getNumberOfRoots()); roots.computeRoots(6); Assert.assertEquals("", 6, roots.getNumberOfRoots()); } @Test public void testComputeRoots() { final RootsOfUnity roots = new RootsOfUnity(); for (int n = -10; n < 11; n++) { /* * Testing -n right after n is important, as the roots in this case * are not recomputed. */ if (n != 0) { roots.computeRoots(n); doTestComputeRoots(roots); roots.computeRoots(-n); doTestComputeRoots(roots); } } } private void doTestComputeRoots(final RootsOfUnity roots) { final int n = roots.isCounterClockWise() ? roots.getNumberOfRoots() : -roots.getNumberOfRoots(); final double tol = 10 * Math.ulp(1.0); for (int k = 0; k < n; k++) { final double t = 2.0 * FastMath.PI * k / n; @SuppressWarnings("boxing") final String msg = String.format("n = %d, k = %d", n, k); Assert.assertEquals(msg, FastMath.cos(t), roots.getReal(k), tol); Assert.assertEquals(msg, FastMath.sin(t), roots.getImaginary(k), tol); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.dfp; import org.apache.commons.math3.analysis.solvers.AllowedSolution; import org.apache.commons.math3.exception.MathInternalError; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.junit.Assert; import org.junit.Before; import org.junit.Test; /** * Test case for {@link BracketingNthOrderBrentSolverDFP bracketing n<sup>th</sup> order Brent} solver. * * @version $Id$ */ public final class BracketingNthOrderBrentSolverDFPTest { @Test(expected=NumberIsTooSmallException.class) public void testInsufficientOrder3() { new BracketingNthOrderBrentSolverDFP(relativeAccuracy, absoluteAccuracy, functionValueAccuracy, 1); } @Test public void testConstructorOK() { BracketingNthOrderBrentSolverDFP solver = new BracketingNthOrderBrentSolverDFP(relativeAccuracy, absoluteAccuracy, functionValueAccuracy, 2); Assert.assertEquals(2, solver.getMaximalOrder()); } @Test public void testConvergenceOnFunctionAccuracy() { BracketingNthOrderBrentSolverDFP solver = new BracketingNthOrderBrentSolverDFP(relativeAccuracy, absoluteAccuracy, field.newDfp(1.0e-20), 20); UnivariateDfpFunction f = new UnivariateDfpFunction() { public Dfp value(Dfp x) { Dfp one = field.getOne(); Dfp oneHalf = one.divide(2); Dfp xMo = x.subtract(one); Dfp xMh = x.subtract(oneHalf); Dfp xPh = x.add(oneHalf); Dfp xPo = x.add(one); return xMo.multiply(xMh).multiply(x).multiply(xPh).multiply(xPo); } }; Dfp result = solver.solve(20, f, field.newDfp(0.2), field.newDfp(0.9), field.newDfp(0.4), AllowedSolution.BELOW_SIDE); Assert.assertTrue(f.value(result).abs().lessThan(solver.getFunctionValueAccuracy())); Assert.assertTrue(f.value(result).negativeOrNull()); Assert.assertTrue(result.subtract(field.newDfp(0.5)).subtract(solver.getAbsoluteAccuracy()).positiveOrNull()); result = solver.solve(20, f, field.newDfp(-0.9), field.newDfp(-0.2), field.newDfp(-0.4), AllowedSolution.ABOVE_SIDE); Assert.assertTrue(f.value(result).abs().lessThan(solver.getFunctionValueAccuracy())); Assert.assertTrue(f.value(result).positiveOrNull()); Assert.assertTrue(result.add(field.newDfp(0.5)).subtract(solver.getAbsoluteAccuracy()).negativeOrNull()); } @Test public void testNeta() { // the following test functions come from Beny Neta's paper: // "Several New Methods for solving Equations" // intern J. Computer Math Vol 23 pp 265-282 // available here: http://www.math.nps.navy.mil/~bneta/SeveralNewMethods.PDF for (AllowedSolution allowed : AllowedSolution.values()) { check(new UnivariateDfpFunction() { public Dfp value(Dfp x) { return DfpMath.sin(x).subtract(x.divide(2)); } }, 200, -2.0, 2.0, allowed); check(new UnivariateDfpFunction() { public Dfp value(Dfp x) { return DfpMath.pow(x, 5).add(x).subtract(field.newDfp(10000)); } }, 200, -5.0, 10.0, allowed); check(new UnivariateDfpFunction() { public Dfp value(Dfp x) { return x.sqrt().subtract(field.getOne().divide(x)).subtract(field.newDfp(3)); } }, 200, 0.001, 10.0, allowed); check(new UnivariateDfpFunction() { public Dfp value(Dfp x) { return DfpMath.exp(x).add(x).subtract(field.newDfp(20)); } }, 200, -5.0, 5.0, allowed); check(new UnivariateDfpFunction() { public Dfp value(Dfp x) { return DfpMath.log(x).add(x.sqrt()).subtract(field.newDfp(5)); } }, 200, 0.001, 10.0, allowed); check(new UnivariateDfpFunction() { public Dfp value(Dfp x) { return x.subtract(field.getOne()).multiply(x).multiply(x).subtract(field.getOne()); } }, 200, -0.5, 1.5, allowed); } } private void check(UnivariateDfpFunction f, int maxEval, double min, double max, AllowedSolution allowedSolution) { BracketingNthOrderBrentSolverDFP solver = new BracketingNthOrderBrentSolverDFP(relativeAccuracy, absoluteAccuracy, functionValueAccuracy, 20); Dfp xResult = solver.solve(maxEval, f, field.newDfp(min), field.newDfp(max), allowedSolution); Dfp yResult = f.value(xResult); switch (allowedSolution) { case ANY_SIDE : Assert.assertTrue(yResult.abs().lessThan(functionValueAccuracy.multiply(2))); break; case LEFT_SIDE : { boolean increasing = f.value(xResult).add(absoluteAccuracy).greaterThan(yResult); Assert.assertTrue(increasing ? yResult.negativeOrNull() : yResult.positiveOrNull()); break; } case RIGHT_SIDE : { boolean increasing = f.value(xResult).add(absoluteAccuracy).greaterThan(yResult); Assert.assertTrue(increasing ? yResult.positiveOrNull() : yResult.negativeOrNull()); break; } case BELOW_SIDE : Assert.assertTrue(yResult.negativeOrNull()); break; case ABOVE_SIDE : Assert.assertTrue(yResult.positiveOrNull()); break; default : // this should never happen throw new MathInternalError(null); } } @Before public void setUp() { field = new DfpField(50); absoluteAccuracy = field.newDfp(1.0e-45); relativeAccuracy = field.newDfp(1.0e-45); functionValueAccuracy = field.newDfp(1.0e-45); } private DfpField field; private Dfp absoluteAccuracy; private Dfp relativeAccuracy; private Dfp functionValueAccuracy; }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.dfp; import org.junit.After; import org.junit.Assert; import org.junit.Before; import org.junit.Test; public class DfpDecTest { private DfpField field; private Dfp pinf; private Dfp ninf; @Before public void setUp() { // Some basic setup. Define some constants and clear the status flags field = new DfpField(20); pinf = new DfpDec(field, 1).divide(new DfpDec(field, 0)); ninf = new DfpDec(field, -1).divide(new DfpDec(field, 0)); ninf.getField().clearIEEEFlags(); } @After public void tearDown() { field = null; pinf = null; ninf = null; } // Generic test function. Takes params x and y and tests them for // equality. Then checks the status flags against the flags argument. // If the test fail, it prints the desc string private void test(Dfp x, Dfp y, int flags, String desc) { boolean b = x.equals(y); if (!x.equals(y) && !x.unequal(y)) // NaNs involved b = (x.toString().equals(y.toString())); if (x.equals(new DfpDec(field, 0))) // distinguish +/- zero b = (b && (x.toString().equals(y.toString()))); b = (b && x.getField().getIEEEFlags() == flags); if (!b) Assert.assertTrue("assersion failed "+desc+" x = "+x.toString()+" flags = "+x.getField().getIEEEFlags(), b); x.getField().clearIEEEFlags(); } @Test public void testRound() { field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_EVEN); test(new DfpDec(field, "12345678901234567890"), new DfpDec(field, "12345678901234568000"), DfpField.FLAG_INEXACT, "Round #1"); test(new DfpDec(field, "0.12345678901234567890"), new DfpDec(field, "0.12345678901234568"), DfpField.FLAG_INEXACT, "Round #2"); test(new DfpDec(field, "0.12345678901234567500"), new DfpDec(field, "0.12345678901234568"), DfpField.FLAG_INEXACT, "Round #3"); test(new DfpDec(field, "0.12345678901234568500"), new DfpDec(field, "0.12345678901234568"), DfpField.FLAG_INEXACT, "Round #4"); test(new DfpDec(field, "0.12345678901234568501"), new DfpDec(field, "0.12345678901234569"), DfpField.FLAG_INEXACT, "Round #5"); test(new DfpDec(field, "0.12345678901234568499"), new DfpDec(field, "0.12345678901234568"), DfpField.FLAG_INEXACT, "Round #6"); test(new DfpDec(field, "1.2345678901234567890"), new DfpDec(field, "1.2345678901234568"), DfpField.FLAG_INEXACT, "Round #7"); test(new DfpDec(field, "1.2345678901234567500"), new DfpDec(field, "1.2345678901234568"), DfpField.FLAG_INEXACT, "Round #8"); test(new DfpDec(field, "1.2345678901234568500"), new DfpDec(field, "1.2345678901234568"), DfpField.FLAG_INEXACT, "Round #9"); test(new DfpDec(field, "1.2345678901234568000").add(new DfpDec(field, ".0000000000000000501")), new DfpDec(field, "1.2345678901234569"), DfpField.FLAG_INEXACT, "Round #10"); test(new DfpDec(field, "1.2345678901234568499"), new DfpDec(field, "1.2345678901234568"), DfpField.FLAG_INEXACT, "Round #11"); test(new DfpDec(field, "12.345678901234567890"), new DfpDec(field, "12.345678901234568"), DfpField.FLAG_INEXACT, "Round #12"); test(new DfpDec(field, "12.345678901234567500"), new DfpDec(field, "12.345678901234568"), DfpField.FLAG_INEXACT, "Round #13"); test(new DfpDec(field, "12.345678901234568500"), new DfpDec(field, "12.345678901234568"), DfpField.FLAG_INEXACT, "Round #14"); test(new DfpDec(field, "12.345678901234568").add(new DfpDec(field, ".000000000000000501")), new DfpDec(field, "12.345678901234569"), DfpField.FLAG_INEXACT, "Round #15"); test(new DfpDec(field, "12.345678901234568499"), new DfpDec(field, "12.345678901234568"), DfpField.FLAG_INEXACT, "Round #16"); test(new DfpDec(field, "123.45678901234567890"), new DfpDec(field, "123.45678901234568"), DfpField.FLAG_INEXACT, "Round #17"); test(new DfpDec(field, "123.45678901234567500"), new DfpDec(field, "123.45678901234568"), DfpField.FLAG_INEXACT, "Round #18"); test(new DfpDec(field, "123.45678901234568500"), new DfpDec(field, "123.45678901234568"), DfpField.FLAG_INEXACT, "Round #19"); test(new DfpDec(field, "123.456789012345685").add(new DfpDec(field, ".00000000000000501")), new DfpDec(field, "123.45678901234569"), DfpField.FLAG_INEXACT, "Round #20"); test(new DfpDec(field, "123.45678901234568499"), new DfpDec(field, "123.45678901234568"), DfpField.FLAG_INEXACT, "Round #21"); field.setRoundingMode(DfpField.RoundingMode.ROUND_DOWN); // Round down test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.9")), new DfpDec(field, "12345678901234567"), DfpField.FLAG_INEXACT, "Round #22"); test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.99999999")), new DfpDec(field, "12345678901234567"), DfpField.FLAG_INEXACT, "Round #23"); test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.99999999")), new DfpDec(field, "-12345678901234567"), DfpField.FLAG_INEXACT, "Round #24"); field.setRoundingMode(DfpField.RoundingMode.ROUND_UP); // Round up test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.1")), new DfpDec(field, "12345678901234568"), DfpField.FLAG_INEXACT, "Round #25"); test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.0001")), new DfpDec(field, "12345678901234568"), DfpField.FLAG_INEXACT, "Round #26"); test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.1")), new DfpDec(field, "-12345678901234568"), DfpField.FLAG_INEXACT, "Round #27"); test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.0001")), new DfpDec(field, "-12345678901234568"), DfpField.FLAG_INEXACT, "Round #28"); test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "0")), new DfpDec(field, "-12345678901234567"), 0, "Round #28.5"); field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_UP); // Round half up test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.499999999999")), new DfpDec(field, "12345678901234567"), DfpField.FLAG_INEXACT, "Round #29"); test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.50000001")), new DfpDec(field, "12345678901234568"), DfpField.FLAG_INEXACT, "Round #30"); test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.5")), new DfpDec(field, "12345678901234568"), DfpField.FLAG_INEXACT, "Round #30.5"); test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.499999999999")), new DfpDec(field, "-12345678901234567"), DfpField.FLAG_INEXACT, "Round #31"); test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.50000001")), new DfpDec(field, "-12345678901234568"), DfpField.FLAG_INEXACT, "Round #32"); field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_DOWN); // Round half down test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.5001")), new DfpDec(field, "12345678901234568"), DfpField.FLAG_INEXACT, "Round #33"); test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.5000")), new DfpDec(field, "12345678901234567"), DfpField.FLAG_INEXACT, "Round #34"); test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.5001")), new DfpDec(field, "-12345678901234568"), DfpField.FLAG_INEXACT, "Round #35"); test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.6")), new DfpDec(field, "-12345678901234568"), DfpField.FLAG_INEXACT, "Round #35.5"); test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.5000")), new DfpDec(field, "-12345678901234567"), DfpField.FLAG_INEXACT, "Round #36"); field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_ODD); // Round half odd test(new DfpDec(field, "12345678901234568").add(new DfpDec(field, "0.5000")), new DfpDec(field, "12345678901234569"), DfpField.FLAG_INEXACT, "Round #37"); test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.5000")), new DfpDec(field, "12345678901234567"), DfpField.FLAG_INEXACT, "Round #38"); test(new DfpDec(field, "-12345678901234568").add(new DfpDec(field, "-0.5000")), new DfpDec(field, "-12345678901234569"), DfpField.FLAG_INEXACT, "Round #39"); test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.5000")), new DfpDec(field, "-12345678901234567"), DfpField.FLAG_INEXACT, "Round #40"); field.setRoundingMode(DfpField.RoundingMode.ROUND_CEIL); // Round ceil test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.0001")), new DfpDec(field, "12345678901234568"), DfpField.FLAG_INEXACT, "Round #41"); test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.9999")), new DfpDec(field, "-12345678901234567"), DfpField.FLAG_INEXACT, "Round #42"); field.setRoundingMode(DfpField.RoundingMode.ROUND_FLOOR); // Round floor test(new DfpDec(field, "12345678901234567").add(new DfpDec(field, "0.9999")), new DfpDec(field, "12345678901234567"), DfpField.FLAG_INEXACT, "Round #43"); test(new DfpDec(field, "-12345678901234567").add(new DfpDec(field, "-0.0001")), new DfpDec(field, "-12345678901234568"), DfpField.FLAG_INEXACT, "Round #44"); field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_EVEN); // reset } @Test public void testRoundDecimal10() { field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_EVEN); test(new Decimal10(field, "1234567891234567890"), new Decimal10(field, "1234567891000000000"), DfpField.FLAG_INEXACT, "RoundDecimal10 #1"); test(new Decimal10(field, "0.1234567891634567890"), new Decimal10(field, "0.1234567892"), DfpField.FLAG_INEXACT, "RoundDecimal10 #2"); test(new Decimal10(field, "0.1234567891500000000"), new Decimal10(field, "0.1234567892"), DfpField.FLAG_INEXACT, "RoundDecimal10 #3"); test(new Decimal10(field, "0.1234567890500"), new Decimal10(field, "0.1234567890"), DfpField.FLAG_INEXACT, "RoundDecimal10 #4"); test(new Decimal10(field, "0.1234567890501"), new Decimal10(field, "0.1234567891"), DfpField.FLAG_INEXACT, "RoundDecimal10 #5"); test(new Decimal10(field, "0.1234567890499"), new Decimal10(field, "0.1234567890"), DfpField.FLAG_INEXACT, "RoundDecimal10 #6"); test(new Decimal10(field, "1.234567890890"), new Decimal10(field, "1.234567891"), DfpField.FLAG_INEXACT, "RoundDecimal10 #7"); test(new Decimal10(field, "1.234567891500"), new Decimal10(field, "1.234567892"), DfpField.FLAG_INEXACT, "RoundDecimal10 #8"); test(new Decimal10(field, "1.234567890500"), new Decimal10(field, "1.234567890"), DfpField.FLAG_INEXACT, "RoundDecimal10 #9"); test(new Decimal10(field, "1.234567890000").add(new Decimal10(field, ".000000000501")), new Decimal10(field, "1.234567891"), DfpField.FLAG_INEXACT, "RoundDecimal10 #10"); test(new Decimal10(field, "1.234567890499"), new Decimal10(field, "1.234567890"), DfpField.FLAG_INEXACT, "RoundDecimal10 #11"); test(new Decimal10(field, "12.34567890890"), new Decimal10(field, "12.34567891"), DfpField.FLAG_INEXACT, "RoundDecimal10 #12"); test(new Decimal10(field, "12.34567891500"), new Decimal10(field, "12.34567892"), DfpField.FLAG_INEXACT, "RoundDecimal10 #13"); test(new Decimal10(field, "12.34567890500"), new Decimal10(field, "12.34567890"), DfpField.FLAG_INEXACT, "RoundDecimal10 #14"); test(new Decimal10(field, "12.34567890").add(new Decimal10(field, ".00000000501")), new Decimal10(field, "12.34567891"), DfpField.FLAG_INEXACT, "RoundDecimal10 #15"); test(new Decimal10(field, "12.34567890499"), new Decimal10(field, "12.34567890"), DfpField.FLAG_INEXACT, "RoundDecimal10 #16"); test(new Decimal10(field, "123.4567890890"), new Decimal10(field, "123.4567891"), DfpField.FLAG_INEXACT, "RoundDecimal10 #17"); test(new Decimal10(field, "123.4567891500"), new Decimal10(field, "123.4567892"), DfpField.FLAG_INEXACT, "RoundDecimal10 #18"); test(new Decimal10(field, "123.4567890500"), new Decimal10(field, "123.4567890"), DfpField.FLAG_INEXACT, "RoundDecimal10 #19"); test(new Decimal10(field, "123.4567890").add(new Decimal10(field, ".0000000501")), new Decimal10(field, "123.4567891"), DfpField.FLAG_INEXACT, "RoundDecimal10 #20"); test(new Decimal10(field, "123.4567890499"), new Decimal10(field, "123.4567890"), DfpField.FLAG_INEXACT, "RoundDecimal10 #21"); field.setRoundingMode(DfpField.RoundingMode.ROUND_DOWN); // RoundDecimal10 down test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.9")), new Decimal10(field, "1234567890"), DfpField.FLAG_INEXACT, "RoundDecimal10 #22"); test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.99999999")), new Decimal10(field, "1234567890"), DfpField.FLAG_INEXACT, "RoundDecimal10 #23"); test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.99999999")), new Decimal10(field, "-1234567890"), DfpField.FLAG_INEXACT, "RoundDecimal10 #24"); field.setRoundingMode(DfpField.RoundingMode.ROUND_UP); // RoundDecimal10 up test(new Decimal10(field, 1234567890).add(new Decimal10(field, "0.1")), new Decimal10(field, 1234567891l), DfpField.FLAG_INEXACT, "RoundDecimal10 #25"); test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.0001")), new Decimal10(field, "1234567891"), DfpField.FLAG_INEXACT, "RoundDecimal10 #26"); test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.1")), new Decimal10(field, "-1234567891"), DfpField.FLAG_INEXACT, "RoundDecimal10 #27"); test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.0001")), new Decimal10(field, "-1234567891"), DfpField.FLAG_INEXACT, "RoundDecimal10 #28"); test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "0")), new Decimal10(field, "-1234567890"), 0, "RoundDecimal10 #28.5"); field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_UP); // RoundDecimal10 half up test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.4999999999")), new Decimal10(field, "1234567890"), DfpField.FLAG_INEXACT, "RoundDecimal10 #29"); test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.50000001")), new Decimal10(field, "1234567891"), DfpField.FLAG_INEXACT, "RoundDecimal10 #30"); test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.5")), new Decimal10(field, "1234567891"), DfpField.FLAG_INEXACT, "RoundDecimal10 #30.5"); test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.4999999999")), new Decimal10(field, "-1234567890"), DfpField.FLAG_INEXACT, "RoundDecimal10 #31"); test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.50000001")), new Decimal10(field, "-1234567891"), DfpField.FLAG_INEXACT, "RoundDecimal10 #32"); field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_DOWN); // RoundDecimal10 half down test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.5001")), new Decimal10(field, "1234567890"), DfpField.FLAG_INEXACT, "RoundDecimal10 #33"); test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.5000")), new Decimal10(field, "1234567890"), DfpField.FLAG_INEXACT, "RoundDecimal10 #34"); test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.5001")), new Decimal10(field, "-1234567890"), DfpField.FLAG_INEXACT, "RoundDecimal10 #35"); test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.6")), new Decimal10(field, "-1234567891"), DfpField.FLAG_INEXACT, "RoundDecimal10 #35.5"); test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.5000")), new Decimal10(field, "-1234567890"), DfpField.FLAG_INEXACT, "RoundDecimal10 #36"); field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_ODD); // RoundDecimal10 half odd test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.5000")), new Decimal10(field, "1234567891"), DfpField.FLAG_INEXACT, "RoundDecimal10 #37"); test(new Decimal10(field, "1234567891").add(new Decimal10(field, "0.5000")), new Decimal10(field, "1234567891"), DfpField.FLAG_INEXACT, "RoundDecimal10 #38"); test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.5000")), new Decimal10(field, "-1234567891"), DfpField.FLAG_INEXACT, "RoundDecimal10 #39"); test(new Decimal10(field, "-1234567891").add(new Decimal10(field, "-0.5000")), new Decimal10(field, "-1234567891"), DfpField.FLAG_INEXACT, "RoundDecimal10 #40"); field.setRoundingMode(DfpField.RoundingMode.ROUND_CEIL); // RoundDecimal10 ceil test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.0001")), new Decimal10(field, "1234567891"), DfpField.FLAG_INEXACT, "RoundDecimal10 #41"); test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.9999")), new Decimal10(field, "-1234567890"), DfpField.FLAG_INEXACT, "RoundDecimal10 #42"); field.setRoundingMode(DfpField.RoundingMode.ROUND_FLOOR); // RoundDecimal10 floor test(new Decimal10(field, "1234567890").add(new Decimal10(field, "0.9999")), new Decimal10(field, "1234567890"), DfpField.FLAG_INEXACT, "RoundDecimal10 #43"); test(new Decimal10(field, "-1234567890").add(new Decimal10(field, "-0.0001")), new Decimal10(field, "-1234567891"), DfpField.FLAG_INEXACT, "RoundDecimal10 #44"); field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_EVEN); // reset } @Test public void testNextAfter() { test(new DfpDec(field, 1).nextAfter(pinf), new DfpDec(field, "1.0000000000000001"), 0, "NextAfter #1"); test(new DfpDec(field, "1.0000000000000001").nextAfter(ninf), new DfpDec(field, 1), 0, "NextAfter #1.5"); test(new DfpDec(field, 1).nextAfter(ninf), new DfpDec(field, "0.99999999999999999"), 0, "NextAfter #2"); test(new DfpDec(field, "0.99999999999999999").nextAfter(new DfpDec(field, 2)), new DfpDec(field, 1), 0, "NextAfter #3"); test(new DfpDec(field, -1).nextAfter(ninf), new DfpDec(field, "-1.0000000000000001"), 0, "NextAfter #4"); test(new DfpDec(field, -1).nextAfter(pinf), new DfpDec(field, "-0.99999999999999999"), 0, "NextAfter #5"); test(new DfpDec(field, "-0.99999999999999999").nextAfter(new DfpDec(field, -2)), new DfpDec(field, (byte) -1), 0, "NextAfter #6"); test(new DfpDec(field, (byte) 2).nextAfter(new DfpDec(field, 2)), new DfpDec(field, 2l), 0, "NextAfter #7"); test(new DfpDec(field, 0).nextAfter(new DfpDec(field, 0)), new DfpDec(field, 0), 0, "NextAfter #8"); test(new DfpDec(field, -2).nextAfter(new DfpDec(field, -2)), new DfpDec(field, -2), 0, "NextAfter #9"); test(new DfpDec(field, 0).nextAfter(new DfpDec(field, 1)), new DfpDec(field, "1e-131092"), DfpField.FLAG_UNDERFLOW, "NextAfter #10"); test(new DfpDec(field, 0).nextAfter(new DfpDec(field, -1)), new DfpDec(field, "-1e-131092"), DfpField.FLAG_UNDERFLOW, "NextAfter #11"); test(new DfpDec(field, "-1e-131092").nextAfter(pinf), new DfpDec(field, "-0"), DfpField.FLAG_UNDERFLOW|DfpField.FLAG_INEXACT, "Next After #12"); test(new DfpDec(field, "1e-131092").nextAfter(ninf), new DfpDec(field, "0"), DfpField.FLAG_UNDERFLOW|DfpField.FLAG_INEXACT, "Next After #13"); test(new DfpDec(field, "9.9999999999999999e131078").nextAfter(pinf), pinf, DfpField.FLAG_OVERFLOW|DfpField.FLAG_INEXACT, "Next After #14"); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.dfp; import org.junit.After; import org.junit.Assert; import org.junit.Before; import org.junit.Test; public class DfpMathTest { private DfpField factory; private Dfp pinf; private Dfp ninf; private Dfp nan; private Dfp qnan; @Before public void setUp() { // Some basic setup. Define some constants and clear the status flags factory = new DfpField(20); pinf = factory.newDfp("1").divide(factory.newDfp("0")); ninf = factory.newDfp("-1").divide(factory.newDfp("0")); nan = factory.newDfp("0").divide(factory.newDfp("0")); qnan = factory.newDfp((byte)1, Dfp.QNAN); ninf.getField().clearIEEEFlags(); // force loading of dfpmath Dfp pi = factory.getPi(); pi.getField().clearIEEEFlags(); } @After public void tearDown() { pinf = null; ninf = null; nan = null; qnan = null; } // Generic test function. Takes params x and y and tests them for // equality. Then checks the status flags against the flags argument. // If the test fail, it prints the desc string private void test(Dfp x, Dfp y, int flags, String desc) { boolean b = x.equals(y); if (!x.equals(y) && !x.unequal(y)) // NaNs involved b = (x.toString().equals(y.toString())); if (x.equals(factory.newDfp("0"))) // distinguish +/- zero b = (b && (x.toString().equals(y.toString()))); b = (b && x.getField().getIEEEFlags() == flags); if (!b) Assert.assertTrue("assersion failed "+desc+" x = "+x.toString()+" flags = "+x.getField().getIEEEFlags(), b); x.getField().clearIEEEFlags(); } @Test public void testPow() { // Test special cases exponent of zero test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("0")), factory.newDfp("1"), 0, "pow #1"); test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("-0")), factory.newDfp("1"), 0, "pow #2"); test(DfpMath.pow(factory.newDfp("2"), factory.newDfp("0")), factory.newDfp("1"), 0, "pow #3"); test(DfpMath.pow(factory.newDfp("-2"), factory.newDfp("-0")), factory.newDfp("1"), 0, "pow #4"); test(DfpMath.pow(pinf, factory.newDfp("-0")), factory.newDfp("1"), 0, "pow #5"); test(DfpMath.pow(pinf, factory.newDfp("0")), factory.newDfp("1"), 0, "pow #6"); test(DfpMath.pow(ninf, factory.newDfp("-0")), factory.newDfp("1"), 0, "pow #7"); test(DfpMath.pow(ninf, factory.newDfp("0")), factory.newDfp("1"), 0, "pow #8"); test(DfpMath.pow(qnan, factory.newDfp("0")), factory.newDfp("1"), 0, "pow #8"); // exponent of one test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("1")), factory.newDfp("0"), 0, "pow #9"); test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("1")), factory.newDfp("-0"), 0, "pow #10"); test(DfpMath.pow(factory.newDfp("2"), factory.newDfp("1")), factory.newDfp("2"), 0, "pow #11"); test(DfpMath.pow(factory.newDfp("-2"), factory.newDfp("1")), factory.newDfp("-2"), 0, "pow #12"); test(DfpMath.pow(pinf, factory.newDfp("1")), pinf, 0, "pow #13"); test(DfpMath.pow(ninf, factory.newDfp("1")), ninf, 0, "pow #14"); test(DfpMath.pow(qnan, factory.newDfp("1")), qnan, DfpField.FLAG_INVALID, "pow #14.1"); // exponent of NaN test(DfpMath.pow(factory.newDfp("0"), qnan), qnan, DfpField.FLAG_INVALID, "pow #15"); test(DfpMath.pow(factory.newDfp("-0"), qnan), qnan, DfpField.FLAG_INVALID, "pow #16"); test(DfpMath.pow(factory.newDfp("2"), qnan), qnan, DfpField.FLAG_INVALID, "pow #17"); test(DfpMath.pow(factory.newDfp("-2"), qnan), qnan, DfpField.FLAG_INVALID, "pow #18"); test(DfpMath.pow(pinf, qnan), qnan, DfpField.FLAG_INVALID, "pow #19"); test(DfpMath.pow(ninf, qnan), qnan, DfpField.FLAG_INVALID, "pow #20"); test(DfpMath.pow(qnan, qnan), qnan, DfpField.FLAG_INVALID, "pow #21"); // radix of NaN test(DfpMath.pow(qnan, factory.newDfp("1")), qnan, DfpField.FLAG_INVALID, "pow #22"); test(DfpMath.pow(qnan, factory.newDfp("-1")), qnan, DfpField.FLAG_INVALID, "pow #23"); test(DfpMath.pow(qnan, pinf), qnan, DfpField.FLAG_INVALID, "pow #24"); test(DfpMath.pow(qnan, ninf), qnan, DfpField.FLAG_INVALID, "pow #25"); test(DfpMath.pow(qnan, qnan), qnan, DfpField.FLAG_INVALID, "pow #26"); // (x > 1) ^ pinf = pinf, (x < -1) ^ pinf = pinf test(DfpMath.pow(factory.newDfp("2"), pinf), pinf, 0, "pow #27"); test(DfpMath.pow(factory.newDfp("-2"), pinf), pinf, 0, "pow #28"); test(DfpMath.pow(pinf, pinf), pinf, 0, "pow #29"); test(DfpMath.pow(ninf, pinf), pinf, 0, "pow #30"); // (x > 1) ^ ninf = +0, (x < -1) ^ ninf = +0 test(DfpMath.pow(factory.newDfp("2"), ninf), factory.getZero(), 0, "pow #31"); test(DfpMath.pow(factory.newDfp("-2"), ninf), factory.getZero(), 0, "pow #32"); test(DfpMath.pow(pinf, ninf), factory.getZero(), 0, "pow #33"); test(DfpMath.pow(ninf, ninf), factory.getZero(), 0, "pow #34"); // (-1 < x < 1) ^ pinf = 0 test(DfpMath.pow(factory.newDfp("0.5"), pinf), factory.getZero(), 0, "pow #35"); test(DfpMath.pow(factory.newDfp("-0.5"), pinf), factory.getZero(), 0, "pow #36"); // (-1 < x < 1) ^ ninf = pinf test(DfpMath.pow(factory.newDfp("0.5"), ninf), pinf, 0, "pow #37"); test(DfpMath.pow(factory.newDfp("-0.5"), ninf), pinf, 0, "pow #38"); // +/- 1 ^ +/-inf = NaN test(DfpMath.pow(factory.getOne(), pinf), qnan, DfpField.FLAG_INVALID, "pow #39"); test(DfpMath.pow(factory.getOne(), ninf), qnan, DfpField.FLAG_INVALID, "pow #40"); test(DfpMath.pow(factory.newDfp("-1"), pinf), qnan, DfpField.FLAG_INVALID, "pow #41"); test(DfpMath.pow(factory.getOne().negate(), ninf), qnan, DfpField.FLAG_INVALID, "pow #42"); // +0 ^ +anything except 0, NAN = +0 test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("1")), factory.newDfp("0"), 0, "pow #43"); test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("1e30")), factory.newDfp("0"), 0, "pow #44"); test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("1e-30")), factory.newDfp("0"), 0, "pow #45"); test(DfpMath.pow(factory.newDfp("0"), pinf), factory.newDfp("0"), 0, "pow #46"); // -0 ^ +anything except 0, NAN, odd integer = +0 test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("2")), factory.newDfp("0"), 0, "pow #47"); test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("1e30")), factory.newDfp("0"), 0, "pow #48"); test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("1e-30")), factory.newDfp("0"), DfpField.FLAG_INEXACT, "pow #49"); test(DfpMath.pow(factory.newDfp("-0"), pinf), factory.newDfp("0"), 0, "pow #50"); // +0 ^ -anything except 0, NAN = +INF test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("-1")), pinf, 0, "pow #51"); test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("-1e30")), pinf, 0, "pow #52"); test(DfpMath.pow(factory.newDfp("0"), factory.newDfp("-1e-30")), pinf, 0, "pow #53"); test(DfpMath.pow(factory.newDfp("0"), ninf), pinf, 0, "pow #54"); // -0 ^ -anything except 0, NAN, odd integer = +INF test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("-2")), pinf, 0, "pow #55"); test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("-1e30")), pinf, 0, "pow #56"); test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("-1e-30")), pinf, DfpField.FLAG_INEXACT, "pow #57"); test(DfpMath.pow(factory.newDfp("-0"), ninf), pinf, 0, "pow #58"); // -0 ^ -odd integer = -INF test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("-1")), ninf, DfpField.FLAG_INEXACT, "pow #59"); test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("-12345")), ninf, DfpField.FLAG_INEXACT, "pow #60"); // -0 ^ +odd integer = -0 test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("3")), factory.newDfp("-0"), DfpField.FLAG_INEXACT, "pow #61"); test(DfpMath.pow(factory.newDfp("-0"), factory.newDfp("12345")), factory.newDfp("-0"), DfpField.FLAG_INEXACT, "pow #62"); // pinf ^ +anything = pinf test(DfpMath.pow(pinf, factory.newDfp("3")), pinf, 0, "pow #63"); test(DfpMath.pow(pinf, factory.newDfp("1e30")), pinf, 0, "pow #64"); test(DfpMath.pow(pinf, factory.newDfp("1e-30")), pinf, 0, "pow #65"); test(DfpMath.pow(pinf, pinf), pinf, 0, "pow #66"); // pinf ^ -anything = +0 test(DfpMath.pow(pinf, factory.newDfp("-3")), factory.getZero(), 0, "pow #67"); test(DfpMath.pow(pinf, factory.newDfp("-1e30")), factory.getZero(), 0, "pow #68"); test(DfpMath.pow(pinf, factory.newDfp("-1e-30")), factory.getZero(), 0, "pow #69"); test(DfpMath.pow(pinf, ninf), factory.getZero(), 0, "pow #70"); // ninf ^ anything = -0 ^ -anything // ninf ^ -anything except 0, NAN, odd integer = +0 test(DfpMath.pow(ninf, factory.newDfp("-2")), factory.newDfp("0"), 0, "pow #71"); test(DfpMath.pow(ninf, factory.newDfp("-1e30")), factory.newDfp("0"), 0, "pow #72"); test(DfpMath.pow(ninf, factory.newDfp("-1e-30")), factory.newDfp("0"), DfpField.FLAG_INEXACT, "pow #73"); test(DfpMath.pow(ninf, ninf), factory.newDfp("0"), 0, "pow #74"); // ninf ^ +anything except 0, NAN, odd integer = +INF test(DfpMath.pow(ninf, factory.newDfp("2")), pinf, 0, "pow #75"); test(DfpMath.pow(ninf, factory.newDfp("1e30")), pinf, 0, "pow #76"); test(DfpMath.pow(ninf, factory.newDfp("1e-30")), pinf, DfpField.FLAG_INEXACT, "pow #77"); test(DfpMath.pow(ninf, pinf), pinf, 0, "pow #78"); // ninf ^ +odd integer = -INF test(DfpMath.pow(ninf, factory.newDfp("3")), ninf, DfpField.FLAG_INEXACT, "pow #79"); test(DfpMath.pow(ninf, factory.newDfp("12345")), ninf, DfpField.FLAG_INEXACT, "pow #80"); // ninf ^ -odd integer = -0 test(DfpMath.pow(ninf, factory.newDfp("-3")), factory.newDfp("-0"), DfpField.FLAG_INEXACT, "pow #81"); test(DfpMath.pow(ninf, factory.newDfp("-12345")), factory.newDfp("-0"), DfpField.FLAG_INEXACT, "pow #82"); // -anything ^ integer test(DfpMath.pow(factory.newDfp("-2"), factory.newDfp("3")), factory.newDfp("-8"), DfpField.FLAG_INEXACT, "pow #83"); test(DfpMath.pow(factory.newDfp("-2"), factory.newDfp("16")), factory.newDfp("65536"), 0, "pow #84"); test(DfpMath.pow(factory.newDfp("-2"), factory.newDfp("-3")), factory.newDfp("-0.125"), DfpField.FLAG_INEXACT, "pow #85"); test(DfpMath.pow(factory.newDfp("-2"), factory.newDfp("-4")), factory.newDfp("0.0625"), 0, "pow #86"); // -anything ^ noninteger = NaN test(DfpMath.pow(factory.newDfp("-2"), factory.newDfp("-4.1")), qnan, DfpField.FLAG_INVALID|DfpField.FLAG_INEXACT, "pow #87"); // Some fractional cases. test(DfpMath.pow(factory.newDfp("2"),factory.newDfp("1.5")), factory.newDfp("2.8284271247461901"), DfpField.FLAG_INEXACT, "pow #88"); } @Test public void testSin() { test(DfpMath.sin(pinf), nan, DfpField.FLAG_INVALID|DfpField.FLAG_INEXACT, "sin #1"); test(DfpMath.sin(nan), nan, DfpField.FLAG_INVALID|DfpField.FLAG_INEXACT, "sin #2"); test(DfpMath.sin(factory.getZero()), factory.getZero(), DfpField.FLAG_INEXACT, "sin #3"); test(DfpMath.sin(factory.getPi()), factory.getZero(), DfpField.FLAG_INEXACT, "sin #4"); test(DfpMath.sin(factory.getPi().negate()), factory.newDfp("-0"), DfpField.FLAG_INEXACT, "sin #5"); test(DfpMath.sin(factory.getPi().multiply(2)), factory.getZero(), DfpField.FLAG_INEXACT, "sin #6"); test(DfpMath.sin(factory.getPi().divide(2)), factory.getOne(), DfpField.FLAG_INEXACT, "sin #7"); test(DfpMath.sin(factory.getPi().divide(2).negate()), factory.getOne().negate(), DfpField.FLAG_INEXACT, "sin #8"); test(DfpMath.sin(DfpMath.atan(factory.getOne())), // pi/4 factory.newDfp("0.5").sqrt(), DfpField.FLAG_INEXACT, "sin #9"); test(DfpMath.sin(DfpMath.atan(factory.getOne())).negate(), // -pi/4 factory.newDfp("0.5").sqrt().negate(), DfpField.FLAG_INEXACT, "sin #10"); test(DfpMath.sin(DfpMath.atan(factory.getOne())).negate(), // -pi/4 factory.newDfp("0.5").sqrt().negate(), DfpField.FLAG_INEXACT, "sin #11"); test(DfpMath.sin(factory.newDfp("0.1")), factory.newDfp("0.0998334166468281523"), DfpField.FLAG_INEXACT, "sin #12"); test(DfpMath.sin(factory.newDfp("0.2")), factory.newDfp("0.19866933079506121546"), DfpField.FLAG_INEXACT, "sin #13"); test(DfpMath.sin(factory.newDfp("0.3")), factory.newDfp("0.2955202066613395751"), DfpField.FLAG_INEXACT, "sin #14"); test(DfpMath.sin(factory.newDfp("0.4")), factory.newDfp("0.38941834230865049166"), DfpField.FLAG_INEXACT, "sin #15"); test(DfpMath.sin(factory.newDfp("0.5")), factory.newDfp("0.47942553860420300026"), // off by one ULP DfpField.FLAG_INEXACT, "sin #16"); test(DfpMath.sin(factory.newDfp("0.6")), factory.newDfp("0.56464247339503535721"), // off by one ULP DfpField.FLAG_INEXACT, "sin #17"); test(DfpMath.sin(factory.newDfp("0.7")), factory.newDfp("0.64421768723769105367"), DfpField.FLAG_INEXACT, "sin #18"); test(DfpMath.sin(factory.newDfp("0.8")), factory.newDfp("0.71735609089952276163"), DfpField.FLAG_INEXACT, "sin #19"); test(DfpMath.sin(factory.newDfp("0.9")), // off by one ULP factory.newDfp("0.78332690962748338847"), DfpField.FLAG_INEXACT, "sin #20"); test(DfpMath.sin(factory.newDfp("1.0")), factory.newDfp("0.84147098480789650666"), DfpField.FLAG_INEXACT, "sin #21"); test(DfpMath.sin(factory.newDfp("1.1")), factory.newDfp("0.89120736006143533995"), DfpField.FLAG_INEXACT, "sin #22"); test(DfpMath.sin(factory.newDfp("1.2")), factory.newDfp("0.93203908596722634968"), DfpField.FLAG_INEXACT, "sin #23"); test(DfpMath.sin(factory.newDfp("1.3")), factory.newDfp("0.9635581854171929647"), DfpField.FLAG_INEXACT, "sin #24"); test(DfpMath.sin(factory.newDfp("1.4")), factory.newDfp("0.98544972998846018066"), DfpField.FLAG_INEXACT, "sin #25"); test(DfpMath.sin(factory.newDfp("1.5")), factory.newDfp("0.99749498660405443096"), DfpField.FLAG_INEXACT, "sin #26"); test(DfpMath.sin(factory.newDfp("1.6")), factory.newDfp("0.99957360304150516323"), DfpField.FLAG_INEXACT, "sin #27"); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.dfp; import org.apache.commons.math3.ExtendedFieldElementAbstractTest; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.util.Precision; import org.junit.After; import org.junit.Assert; import org.junit.Before; import org.junit.Test; public class DfpTest extends ExtendedFieldElementAbstractTest<Dfp> { @Override protected Dfp build(final double x) { return field.newDfp(x); } private DfpField field; private Dfp pinf; private Dfp ninf; private Dfp nan; private Dfp snan; private Dfp qnan; @Before public void setUp() { // Some basic setup. Define some constants and clear the status flags field = new DfpField(20); pinf = field.newDfp("1").divide(field.newDfp("0")); ninf = field.newDfp("-1").divide(field.newDfp("0")); nan = field.newDfp("0").divide(field.newDfp("0")); snan = field.newDfp((byte)1, Dfp.SNAN); qnan = field.newDfp((byte)1, Dfp.QNAN); ninf.getField().clearIEEEFlags(); } @After public void tearDown() { field = null; pinf = null; ninf = null; nan = null; snan = null; qnan = null; } // Generic test function. Takes params x and y and tests them for // equality. Then checks the status flags against the flags argument. // If the test fail, it prints the desc string private void test(Dfp x, Dfp y, int flags, String desc) { boolean b = x.equals(y); if (!x.equals(y) && !x.unequal(y)) // NaNs involved b = (x.toString().equals(y.toString())); if (x.equals(field.newDfp("0"))) // distinguish +/- zero b = (b && (x.toString().equals(y.toString()))); b = (b && x.getField().getIEEEFlags() == flags); if (!b) Assert.assertTrue("assersion failed "+desc+" x = "+x.toString()+" flags = "+x.getField().getIEEEFlags(), b); x.getField().clearIEEEFlags(); } @Test public void testByteConstructor() { Assert.assertEquals("0.", new Dfp(field, (byte) 0).toString()); Assert.assertEquals("1.", new Dfp(field, (byte) 1).toString()); Assert.assertEquals("-1.", new Dfp(field, (byte) -1).toString()); Assert.assertEquals("-128.", new Dfp(field, Byte.MIN_VALUE).toString()); Assert.assertEquals("127.", new Dfp(field, Byte.MAX_VALUE).toString()); } @Test public void testIntConstructor() { Assert.assertEquals("0.", new Dfp(field, 0).toString()); Assert.assertEquals("1.", new Dfp(field, 1).toString()); Assert.assertEquals("-1.", new Dfp(field, -1).toString()); Assert.assertEquals("1234567890.", new Dfp(field, 1234567890).toString()); Assert.assertEquals("-1234567890.", new Dfp(field, -1234567890).toString()); Assert.assertEquals("-2147483648.", new Dfp(field, Integer.MIN_VALUE).toString()); Assert.assertEquals("2147483647.", new Dfp(field, Integer.MAX_VALUE).toString()); } @Test public void testLongConstructor() { Assert.assertEquals("0.", new Dfp(field, 0l).toString()); Assert.assertEquals("1.", new Dfp(field, 1l).toString()); Assert.assertEquals("-1.", new Dfp(field, -1l).toString()); Assert.assertEquals("1234567890.", new Dfp(field, 1234567890l).toString()); Assert.assertEquals("-1234567890.", new Dfp(field, -1234567890l).toString()); Assert.assertEquals("-9223372036854775808.", new Dfp(field, Long.MIN_VALUE).toString()); Assert.assertEquals("9223372036854775807.", new Dfp(field, Long.MAX_VALUE).toString()); } /* * Test addition */ @Test public void testAdd() { test(field.newDfp("1").add(field.newDfp("1")), // Basic tests 1+1 = 2 field.newDfp("2"), 0, "Add #1"); test(field.newDfp("1").add(field.newDfp("-1")), // 1 + (-1) = 0 field.newDfp("0"), 0, "Add #2"); test(field.newDfp("-1").add(field.newDfp("1")), // (-1) + 1 = 0 field.newDfp("0"), 0, "Add #3"); test(field.newDfp("-1").add(field.newDfp("-1")), // (-1) + (-1) = -2 field.newDfp("-2"), 0, "Add #4"); // rounding mode is round half even test(field.newDfp("1").add(field.newDfp("1e-16")), // rounding on add field.newDfp("1.0000000000000001"), 0, "Add #5"); test(field.newDfp("1").add(field.newDfp("1e-17")), // rounding on add field.newDfp("1"), DfpField.FLAG_INEXACT, "Add #6"); test(field.newDfp("0.90999999999999999999").add(field.newDfp("0.1")), // rounding on add field.newDfp("1.01"), DfpField.FLAG_INEXACT, "Add #7"); test(field.newDfp(".10000000000000005000").add(field.newDfp(".9")), // rounding on add field.newDfp("1."), DfpField.FLAG_INEXACT, "Add #8"); test(field.newDfp(".10000000000000015000").add(field.newDfp(".9")), // rounding on add field.newDfp("1.0000000000000002"), DfpField.FLAG_INEXACT, "Add #9"); test(field.newDfp(".10000000000000014999").add(field.newDfp(".9")), // rounding on add field.newDfp("1.0000000000000001"), DfpField.FLAG_INEXACT, "Add #10"); test(field.newDfp(".10000000000000015001").add(field.newDfp(".9")), // rounding on add field.newDfp("1.0000000000000002"), DfpField.FLAG_INEXACT, "Add #11"); test(field.newDfp(".11111111111111111111").add(field.newDfp("11.1111111111111111")), // rounding on add field.newDfp("11.22222222222222222222"), DfpField.FLAG_INEXACT, "Add #12"); test(field.newDfp(".11111111111111111111").add(field.newDfp("1111111111111111.1111")), // rounding on add field.newDfp("1111111111111111.2222"), DfpField.FLAG_INEXACT, "Add #13"); test(field.newDfp(".11111111111111111111").add(field.newDfp("11111111111111111111")), // rounding on add field.newDfp("11111111111111111111"), DfpField.FLAG_INEXACT, "Add #14"); test(field.newDfp("9.9999999999999999999e131071").add(field.newDfp("-1e131052")), // overflow on add field.newDfp("9.9999999999999999998e131071"), 0, "Add #15"); test(field.newDfp("9.9999999999999999999e131071").add(field.newDfp("1e131052")), // overflow on add pinf, DfpField.FLAG_OVERFLOW, "Add #16"); test(field.newDfp("-9.9999999999999999999e131071").add(field.newDfp("-1e131052")), // overflow on add ninf, DfpField.FLAG_OVERFLOW, "Add #17"); test(field.newDfp("-9.9999999999999999999e131071").add(field.newDfp("1e131052")), // overflow on add field.newDfp("-9.9999999999999999998e131071"), 0, "Add #18"); test(field.newDfp("1e-131072").add(field.newDfp("1e-131072")), // underflow on add field.newDfp("2e-131072"), 0, "Add #19"); test(field.newDfp("1.0000000000000001e-131057").add(field.newDfp("-1e-131057")), // underflow on add field.newDfp("1e-131073"), DfpField.FLAG_UNDERFLOW, "Add #20"); test(field.newDfp("1.1e-131072").add(field.newDfp("-1e-131072")), // underflow on add field.newDfp("1e-131073"), DfpField.FLAG_UNDERFLOW, "Add #21"); test(field.newDfp("1.0000000000000001e-131072").add(field.newDfp("-1e-131072")), // underflow on add field.newDfp("1e-131088"), DfpField.FLAG_UNDERFLOW, "Add #22"); test(field.newDfp("1.0000000000000001e-131078").add(field.newDfp("-1e-131078")), // underflow on add field.newDfp("0"), DfpField.FLAG_UNDERFLOW, "Add #23"); test(field.newDfp("1.0").add(field.newDfp("-1e-20")), // loss of precision on alignment? field.newDfp("0.99999999999999999999"), 0, "Add #23.1"); test(field.newDfp("-0.99999999999999999999").add(field.newDfp("1")), // proper normalization? field.newDfp("0.00000000000000000001"), 0, "Add #23.2"); test(field.newDfp("1").add(field.newDfp("0")), // adding zeros field.newDfp("1"), 0, "Add #24"); test(field.newDfp("0").add(field.newDfp("0")), // adding zeros field.newDfp("0"), 0, "Add #25"); test(field.newDfp("-0").add(field.newDfp("0")), // adding zeros field.newDfp("0"), 0, "Add #26"); test(field.newDfp("0").add(field.newDfp("-0")), // adding zeros field.newDfp("0"), 0, "Add #27"); test(field.newDfp("-0").add(field.newDfp("-0")), // adding zeros field.newDfp("-0"), 0, "Add #28"); test(field.newDfp("1e-20").add(field.newDfp("0")), // adding zeros field.newDfp("1e-20"), 0, "Add #29"); test(field.newDfp("1e-40").add(field.newDfp("0")), // adding zeros field.newDfp("1e-40"), 0, "Add #30"); test(pinf.add(ninf), // adding infinities nan, DfpField.FLAG_INVALID, "Add #31"); test(ninf.add(pinf), // adding infinities nan, DfpField.FLAG_INVALID, "Add #32"); test(ninf.add(ninf), // adding infinities ninf, 0, "Add #33"); test(pinf.add(pinf), // adding infinities pinf, 0, "Add #34"); test(pinf.add(field.newDfp("0")), // adding infinities pinf, 0, "Add #35"); test(pinf.add(field.newDfp("-1e131071")), // adding infinities pinf, 0, "Add #36"); test(pinf.add(field.newDfp("1e131071")), // adding infinities pinf, 0, "Add #37"); test(field.newDfp("0").add(pinf), // adding infinities pinf, 0, "Add #38"); test(field.newDfp("-1e131071").add(pinf), // adding infinities pinf, 0, "Add #39"); test(field.newDfp("1e131071").add(pinf), // adding infinities pinf, 0, "Add #40"); test(ninf.add(field.newDfp("0")), // adding infinities ninf, 0, "Add #41"); test(ninf.add(field.newDfp("-1e131071")), // adding infinities ninf, 0, "Add #42"); test(ninf.add(field.newDfp("1e131071")), // adding infinities ninf, 0, "Add #43"); test(field.newDfp("0").add(ninf), // adding infinities ninf, 0, "Add #44"); test(field.newDfp("-1e131071").add(ninf), // adding infinities ninf, 0, "Add #45"); test(field.newDfp("1e131071").add(ninf), // adding infinities ninf, 0, "Add #46"); test(field.newDfp("9.9999999999999999999e131071").add(field.newDfp("5e131051")), // overflow pinf, DfpField.FLAG_OVERFLOW, "Add #47"); test(field.newDfp("9.9999999999999999999e131071").add(field.newDfp("4.9999999999999999999e131051")), // overflow field.newDfp("9.9999999999999999999e131071"), DfpField.FLAG_INEXACT, "Add #48"); test(nan.add(field.newDfp("1")), nan, 0, "Add #49"); test(field.newDfp("1").add(nan), nan, 0, "Add #50"); test(field.newDfp("12345678123456781234").add(field.newDfp("0.12345678123456781234")), field.newDfp("12345678123456781234"), DfpField.FLAG_INEXACT, "Add #51"); test(field.newDfp("12345678123456781234").add(field.newDfp("123.45678123456781234")), field.newDfp("12345678123456781357"), DfpField.FLAG_INEXACT, "Add #52"); test(field.newDfp("123.45678123456781234").add(field.newDfp("12345678123456781234")), field.newDfp("12345678123456781357"), DfpField.FLAG_INEXACT, "Add #53"); test(field.newDfp("12345678123456781234").add(field.newDfp(".00001234567812345678")), field.newDfp("12345678123456781234"), DfpField.FLAG_INEXACT, "Add #54"); test(field.newDfp("12345678123456781234").add(field.newDfp(".00000000123456781234")), field.newDfp("12345678123456781234"), DfpField.FLAG_INEXACT, "Add #55"); test(field.newDfp("-0").add(field.newDfp("-0")), field.newDfp("-0"), 0, "Add #56"); test(field.newDfp("0").add(field.newDfp("-0")), field.newDfp("0"), 0, "Add #57"); test(field.newDfp("-0").add(field.newDfp("0")), field.newDfp("0"), 0, "Add #58"); test(field.newDfp("0").add(field.newDfp("0")), field.newDfp("0"), 0, "Add #59"); } //////////////////////////////////////////////////////////////////////////////////////////////////////// // Test comparisons // utility function to help test comparisons private void cmptst(Dfp a, Dfp b, String op, boolean result, double num) { if (op == "equal") if (a.equals(b) != result) Assert.fail("assersion failed. "+op+" compare #"+num); if (op == "unequal") if (a.unequal(b) != result) Assert.fail("assersion failed. "+op+" compare #"+num); if (op == "lessThan") if (a.lessThan(b) != result) Assert.fail("assersion failed. "+op+" compare #"+num); if (op == "greaterThan") if (a.greaterThan(b) != result) Assert.fail("assersion failed. "+op+" compare #"+num); } @Test public void testCompare() { // test equal() comparison // check zero vs. zero field.clearIEEEFlags(); cmptst(field.newDfp("0"), field.newDfp("0"), "equal", true, 1); // 0 == 0 cmptst(field.newDfp("0"), field.newDfp("-0"), "equal", true, 2); // 0 == -0 cmptst(field.newDfp("-0"), field.newDfp("-0"), "equal", true, 3); // -0 == -0 cmptst(field.newDfp("-0"), field.newDfp("0"), "equal", true, 4); // -0 == 0 // check zero vs normal numbers cmptst(field.newDfp("0"), field.newDfp("1"), "equal", false, 5); // 0 == 1 cmptst(field.newDfp("1"), field.newDfp("0"), "equal", false, 6); // 1 == 0 cmptst(field.newDfp("-1"), field.newDfp("0"), "equal", false, 7); // -1 == 0 cmptst(field.newDfp("0"), field.newDfp("-1"), "equal", false, 8); // 0 == -1 cmptst(field.newDfp("0"), field.newDfp("1e-131072"), "equal", false, 9); // 0 == 1e-131072 // check flags if (field.getIEEEFlags() != 0) Assert.fail("assersion failed. compare flags = "+field.getIEEEFlags()); cmptst(field.newDfp("0"), field.newDfp("1e-131078"), "equal", false, 10); // 0 == 1e-131078 // check flags -- underflow should be set if (field.getIEEEFlags() != DfpField.FLAG_UNDERFLOW) Assert.fail("assersion failed. compare flags = "+field.getIEEEFlags()); field.clearIEEEFlags(); cmptst(field.newDfp("0"), field.newDfp("1e+131071"), "equal", false, 11); // 0 == 1e+131071 // check zero vs infinities cmptst(field.newDfp("0"), pinf, "equal", false, 12); // 0 == pinf cmptst(field.newDfp("0"), ninf, "equal", false, 13); // 0 == ninf cmptst(field.newDfp("-0"), pinf, "equal", false, 14); // -0 == pinf cmptst(field.newDfp("-0"), ninf, "equal", false, 15); // -0 == ninf cmptst(pinf, field.newDfp("0"), "equal", false, 16); // pinf == 0 cmptst(ninf, field.newDfp("0"), "equal", false, 17); // ninf == 0 cmptst(pinf, field.newDfp("-0"), "equal", false, 18); // pinf == -0 cmptst(ninf, field.newDfp("-0"), "equal", false, 19); // ninf == -0 cmptst(ninf, pinf, "equal", false, 19.10); // ninf == pinf cmptst(pinf, ninf, "equal", false, 19.11); // pinf == ninf cmptst(pinf, pinf, "equal", true, 19.12); // pinf == pinf cmptst(ninf, ninf, "equal", true, 19.13); // ninf == ninf // check some normal numbers cmptst(field.newDfp("1"), field.newDfp("1"), "equal", true, 20); // 1 == 1 cmptst(field.newDfp("1"), field.newDfp("-1"), "equal", false, 21); // 1 == -1 cmptst(field.newDfp("-1"), field.newDfp("-1"), "equal", true, 22); // -1 == -1 cmptst(field.newDfp("1"), field.newDfp("1.0000000000000001"), "equal", false, 23); // 1 == 1.0000000000000001 // The tests below checks to ensure that comparisons don't set FLAG_INEXACT // 100000 == 1.0000000000000001 cmptst(field.newDfp("1e20"), field.newDfp("1.0000000000000001"), "equal", false, 24); if (field.getIEEEFlags() != 0) Assert.fail("assersion failed. compare flags = "+field.getIEEEFlags()); cmptst(field.newDfp("0.000001"), field.newDfp("1e-6"), "equal", true, 25); // check some nans -- nans shouldnt equal anything cmptst(snan, snan, "equal", false, 27); cmptst(qnan, qnan, "equal", false, 28); cmptst(snan, qnan, "equal", false, 29); cmptst(qnan, snan, "equal", false, 30); cmptst(qnan, field.newDfp("0"), "equal", false, 31); cmptst(snan, field.newDfp("0"), "equal", false, 32); cmptst(field.newDfp("0"), snan, "equal", false, 33); cmptst(field.newDfp("0"), qnan, "equal", false, 34); cmptst(qnan, pinf, "equal", false, 35); cmptst(snan, pinf, "equal", false, 36); cmptst(pinf, snan, "equal", false, 37); cmptst(pinf, qnan, "equal", false, 38); cmptst(qnan, ninf, "equal", false, 39); cmptst(snan, ninf, "equal", false, 40); cmptst(ninf, snan, "equal", false, 41); cmptst(ninf, qnan, "equal", false, 42); cmptst(qnan, field.newDfp("-1"), "equal", false, 43); cmptst(snan, field.newDfp("-1"), "equal", false, 44); cmptst(field.newDfp("-1"), snan, "equal", false, 45); cmptst(field.newDfp("-1"), qnan, "equal", false, 46); cmptst(qnan, field.newDfp("1"), "equal", false, 47); cmptst(snan, field.newDfp("1"), "equal", false, 48); cmptst(field.newDfp("1"), snan, "equal", false, 49); cmptst(field.newDfp("1"), qnan, "equal", false, 50); cmptst(snan.negate(), snan, "equal", false, 51); cmptst(qnan.negate(), qnan, "equal", false, 52); // // Tests for un equal -- do it all over again // cmptst(field.newDfp("0"), field.newDfp("0"), "unequal", false, 1); // 0 == 0 cmptst(field.newDfp("0"), field.newDfp("-0"), "unequal", false, 2); // 0 == -0 cmptst(field.newDfp("-0"), field.newDfp("-0"), "unequal", false, 3); // -0 == -0 cmptst(field.newDfp("-0"), field.newDfp("0"), "unequal", false, 4); // -0 == 0 // check zero vs normal numbers cmptst(field.newDfp("0"), field.newDfp("1"), "unequal", true, 5); // 0 == 1 cmptst(field.newDfp("1"), field.newDfp("0"), "unequal", true, 6); // 1 == 0 cmptst(field.newDfp("-1"), field.newDfp("0"), "unequal", true, 7); // -1 == 0 cmptst(field.newDfp("0"), field.newDfp("-1"), "unequal", true, 8); // 0 == -1 cmptst(field.newDfp("0"), field.newDfp("1e-131072"), "unequal", true, 9); // 0 == 1e-131072 // check flags if (field.getIEEEFlags() != 0) Assert.fail("assersion failed. compare flags = "+field.getIEEEFlags()); cmptst(field.newDfp("0"), field.newDfp("1e-131078"), "unequal", true, 10); // 0 == 1e-131078 // check flags -- underflow should be set if (field.getIEEEFlags() != DfpField.FLAG_UNDERFLOW) Assert.fail("assersion failed. compare flags = "+field.getIEEEFlags()); field.clearIEEEFlags(); cmptst(field.newDfp("0"), field.newDfp("1e+131071"), "unequal", true, 11); // 0 == 1e+131071 // check zero vs infinities cmptst(field.newDfp("0"), pinf, "unequal", true, 12); // 0 == pinf cmptst(field.newDfp("0"), ninf, "unequal", true, 13); // 0 == ninf cmptst(field.newDfp("-0"), pinf, "unequal", true, 14); // -0 == pinf cmptst(field.newDfp("-0"), ninf, "unequal", true, 15); // -0 == ninf cmptst(pinf, field.newDfp("0"), "unequal", true, 16); // pinf == 0 cmptst(ninf, field.newDfp("0"), "unequal", true, 17); // ninf == 0 cmptst(pinf, field.newDfp("-0"), "unequal", true, 18); // pinf == -0 cmptst(ninf, field.newDfp("-0"), "unequal", true, 19); // ninf == -0 cmptst(ninf, pinf, "unequal", true, 19.10); // ninf == pinf cmptst(pinf, ninf, "unequal", true, 19.11); // pinf == ninf cmptst(pinf, pinf, "unequal", false, 19.12); // pinf == pinf cmptst(ninf, ninf, "unequal", false, 19.13); // ninf == ninf // check some normal numbers cmptst(field.newDfp("1"), field.newDfp("1"), "unequal", false, 20); // 1 == 1 cmptst(field.newDfp("1"), field.newDfp("-1"), "unequal", true, 21); // 1 == -1 cmptst(field.newDfp("-1"), field.newDfp("-1"), "unequal", false, 22); // -1 == -1 cmptst(field.newDfp("1"), field.newDfp("1.0000000000000001"), "unequal", true, 23); // 1 == 1.0000000000000001 // The tests below checks to ensure that comparisons don't set FLAG_INEXACT // 100000 == 1.0000000000000001 cmptst(field.newDfp("1e20"), field.newDfp("1.0000000000000001"), "unequal", true, 24); if (field.getIEEEFlags() != 0) Assert.fail("assersion failed. compare flags = "+field.getIEEEFlags()); cmptst(field.newDfp("0.000001"), field.newDfp("1e-6"), "unequal", false, 25); // check some nans -- nans shouldnt be unequal to anything cmptst(snan, snan, "unequal", false, 27); cmptst(qnan, qnan, "unequal", false, 28); cmptst(snan, qnan, "unequal", false, 29); cmptst(qnan, snan, "unequal", false, 30); cmptst(qnan, field.newDfp("0"), "unequal", false, 31); cmptst(snan, field.newDfp("0"), "unequal", false, 32); cmptst(field.newDfp("0"), snan, "unequal", false, 33); cmptst(field.newDfp("0"), qnan, "unequal", false, 34); cmptst(qnan, pinf, "unequal", false, 35); cmptst(snan, pinf, "unequal", false, 36); cmptst(pinf, snan, "unequal", false, 37); cmptst(pinf, qnan, "unequal", false, 38); cmptst(qnan, ninf, "unequal", false, 39); cmptst(snan, ninf, "unequal", false, 40); cmptst(ninf, snan, "unequal", false, 41); cmptst(ninf, qnan, "unequal", false, 42); cmptst(qnan, field.newDfp("-1"), "unequal", false, 43); cmptst(snan, field.newDfp("-1"), "unequal", false, 44); cmptst(field.newDfp("-1"), snan, "unequal", false, 45); cmptst(field.newDfp("-1"), qnan, "unequal", false, 46); cmptst(qnan, field.newDfp("1"), "unequal", false, 47); cmptst(snan, field.newDfp("1"), "unequal", false, 48); cmptst(field.newDfp("1"), snan, "unequal", false, 49); cmptst(field.newDfp("1"), qnan, "unequal", false, 50); cmptst(snan.negate(), snan, "unequal", false, 51); cmptst(qnan.negate(), qnan, "unequal", false, 52); if (field.getIEEEFlags() != 0) Assert.fail("assersion failed. compare unequal flags = "+field.getIEEEFlags()); // // Tests for lessThan -- do it all over again // cmptst(field.newDfp("0"), field.newDfp("0"), "lessThan", false, 1); // 0 < 0 cmptst(field.newDfp("0"), field.newDfp("-0"), "lessThan", false, 2); // 0 < -0 cmptst(field.newDfp("-0"), field.newDfp("-0"), "lessThan", false, 3); // -0 < -0 cmptst(field.newDfp("-0"), field.newDfp("0"), "lessThan", false, 4); // -0 < 0 // check zero vs normal numbers cmptst(field.newDfp("0"), field.newDfp("1"), "lessThan", true, 5); // 0 < 1 cmptst(field.newDfp("1"), field.newDfp("0"), "lessThan", false, 6); // 1 < 0 cmptst(field.newDfp("-1"), field.newDfp("0"), "lessThan", true, 7); // -1 < 0 cmptst(field.newDfp("0"), field.newDfp("-1"), "lessThan", false, 8); // 0 < -1 cmptst(field.newDfp("0"), field.newDfp("1e-131072"), "lessThan", true, 9); // 0 < 1e-131072 // check flags if (field.getIEEEFlags() != 0) Assert.fail("assersion failed. compare flags = "+field.getIEEEFlags()); cmptst(field.newDfp("0"), field.newDfp("1e-131078"), "lessThan", true, 10); // 0 < 1e-131078 // check flags -- underflow should be set if (field.getIEEEFlags() != DfpField.FLAG_UNDERFLOW) Assert.fail("assersion failed. compare flags = "+field.getIEEEFlags()); field.clearIEEEFlags(); cmptst(field.newDfp("0"), field.newDfp("1e+131071"), "lessThan", true, 11); // 0 < 1e+131071 // check zero vs infinities cmptst(field.newDfp("0"), pinf, "lessThan", true, 12); // 0 < pinf cmptst(field.newDfp("0"), ninf, "lessThan", false, 13); // 0 < ninf cmptst(field.newDfp("-0"), pinf, "lessThan", true, 14); // -0 < pinf cmptst(field.newDfp("-0"), ninf, "lessThan", false, 15); // -0 < ninf cmptst(pinf, field.newDfp("0"), "lessThan", false, 16); // pinf < 0 cmptst(ninf, field.newDfp("0"), "lessThan", true, 17); // ninf < 0 cmptst(pinf, field.newDfp("-0"), "lessThan", false, 18); // pinf < -0 cmptst(ninf, field.newDfp("-0"), "lessThan", true, 19); // ninf < -0 cmptst(ninf, pinf, "lessThan", true, 19.10); // ninf < pinf cmptst(pinf, ninf, "lessThan", false, 19.11); // pinf < ninf cmptst(pinf, pinf, "lessThan", false, 19.12); // pinf < pinf cmptst(ninf, ninf, "lessThan", false, 19.13); // ninf < ninf // check some normal numbers cmptst(field.newDfp("1"), field.newDfp("1"), "lessThan", false, 20); // 1 < 1 cmptst(field.newDfp("1"), field.newDfp("-1"), "lessThan", false, 21); // 1 < -1 cmptst(field.newDfp("-1"), field.newDfp("-1"), "lessThan", false, 22); // -1 < -1 cmptst(field.newDfp("1"), field.newDfp("1.0000000000000001"), "lessThan", true, 23); // 1 < 1.0000000000000001 // The tests below checks to ensure that comparisons don't set FLAG_INEXACT // 100000 < 1.0000000000000001 cmptst(field.newDfp("1e20"), field.newDfp("1.0000000000000001"), "lessThan", false, 24); if (field.getIEEEFlags() != 0) Assert.fail("assersion failed. compare flags = "+field.getIEEEFlags()); cmptst(field.newDfp("0.000001"), field.newDfp("1e-6"), "lessThan", false, 25); // check some nans -- nans shouldnt be lessThan to anything cmptst(snan, snan, "lessThan", false, 27); cmptst(qnan, qnan, "lessThan", false, 28); cmptst(snan, qnan, "lessThan", false, 29); cmptst(qnan, snan, "lessThan", false, 30); cmptst(qnan, field.newDfp("0"), "lessThan", false, 31); cmptst(snan, field.newDfp("0"), "lessThan", false, 32); cmptst(field.newDfp("0"), snan, "lessThan", false, 33); cmptst(field.newDfp("0"), qnan, "lessThan", false, 34); cmptst(qnan, pinf, "lessThan", false, 35); cmptst(snan, pinf, "lessThan", false, 36); cmptst(pinf, snan, "lessThan", false, 37); cmptst(pinf, qnan, "lessThan", false, 38); cmptst(qnan, ninf, "lessThan", false, 39); cmptst(snan, ninf, "lessThan", false, 40); cmptst(ninf, snan, "lessThan", false, 41); cmptst(ninf, qnan, "lessThan", false, 42); cmptst(qnan, field.newDfp("-1"), "lessThan", false, 43); cmptst(snan, field.newDfp("-1"), "lessThan", false, 44); cmptst(field.newDfp("-1"), snan, "lessThan", false, 45); cmptst(field.newDfp("-1"), qnan, "lessThan", false, 46); cmptst(qnan, field.newDfp("1"), "lessThan", false, 47); cmptst(snan, field.newDfp("1"), "lessThan", false, 48); cmptst(field.newDfp("1"), snan, "lessThan", false, 49); cmptst(field.newDfp("1"), qnan, "lessThan", false, 50); cmptst(snan.negate(), snan, "lessThan", false, 51); cmptst(qnan.negate(), qnan, "lessThan", false, 52); //lessThan compares with nans should raise FLAG_INVALID if (field.getIEEEFlags() != DfpField.FLAG_INVALID) Assert.fail("assersion failed. compare lessThan flags = "+field.getIEEEFlags()); field.clearIEEEFlags(); // // Tests for greaterThan -- do it all over again // cmptst(field.newDfp("0"), field.newDfp("0"), "greaterThan", false, 1); // 0 > 0 cmptst(field.newDfp("0"), field.newDfp("-0"), "greaterThan", false, 2); // 0 > -0 cmptst(field.newDfp("-0"), field.newDfp("-0"), "greaterThan", false, 3); // -0 > -0 cmptst(field.newDfp("-0"), field.newDfp("0"), "greaterThan", false, 4); // -0 > 0 // check zero vs normal numbers cmptst(field.newDfp("0"), field.newDfp("1"), "greaterThan", false, 5); // 0 > 1 cmptst(field.newDfp("1"), field.newDfp("0"), "greaterThan", true, 6); // 1 > 0 cmptst(field.newDfp("-1"), field.newDfp("0"), "greaterThan", false, 7); // -1 > 0 cmptst(field.newDfp("0"), field.newDfp("-1"), "greaterThan", true, 8); // 0 > -1 cmptst(field.newDfp("0"), field.newDfp("1e-131072"), "greaterThan", false, 9); // 0 > 1e-131072 // check flags if (field.getIEEEFlags() != 0) Assert.fail("assersion failed. compare flags = "+field.getIEEEFlags()); cmptst(field.newDfp("0"), field.newDfp("1e-131078"), "greaterThan", false, 10); // 0 > 1e-131078 // check flags -- underflow should be set if (field.getIEEEFlags() != DfpField.FLAG_UNDERFLOW) Assert.fail("assersion failed. compare flags = "+field.getIEEEFlags()); field.clearIEEEFlags(); cmptst(field.newDfp("0"), field.newDfp("1e+131071"), "greaterThan", false, 11); // 0 > 1e+131071 // check zero vs infinities cmptst(field.newDfp("0"), pinf, "greaterThan", false, 12); // 0 > pinf cmptst(field.newDfp("0"), ninf, "greaterThan", true, 13); // 0 > ninf cmptst(field.newDfp("-0"), pinf, "greaterThan", false, 14); // -0 > pinf cmptst(field.newDfp("-0"), ninf, "greaterThan", true, 15); // -0 > ninf cmptst(pinf, field.newDfp("0"), "greaterThan", true, 16); // pinf > 0 cmptst(ninf, field.newDfp("0"), "greaterThan", false, 17); // ninf > 0 cmptst(pinf, field.newDfp("-0"), "greaterThan", true, 18); // pinf > -0 cmptst(ninf, field.newDfp("-0"), "greaterThan", false, 19); // ninf > -0 cmptst(ninf, pinf, "greaterThan", false, 19.10); // ninf > pinf cmptst(pinf, ninf, "greaterThan", true, 19.11); // pinf > ninf cmptst(pinf, pinf, "greaterThan", false, 19.12); // pinf > pinf cmptst(ninf, ninf, "greaterThan", false, 19.13); // ninf > ninf // check some normal numbers cmptst(field.newDfp("1"), field.newDfp("1"), "greaterThan", false, 20); // 1 > 1 cmptst(field.newDfp("1"), field.newDfp("-1"), "greaterThan", true, 21); // 1 > -1 cmptst(field.newDfp("-1"), field.newDfp("-1"), "greaterThan", false, 22); // -1 > -1 cmptst(field.newDfp("1"), field.newDfp("1.0000000000000001"), "greaterThan", false, 23); // 1 > 1.0000000000000001 // The tests below checks to ensure that comparisons don't set FLAG_INEXACT // 100000 > 1.0000000000000001 cmptst(field.newDfp("1e20"), field.newDfp("1.0000000000000001"), "greaterThan", true, 24); if (field.getIEEEFlags() != 0) Assert.fail("assersion failed. compare flags = "+field.getIEEEFlags()); cmptst(field.newDfp("0.000001"), field.newDfp("1e-6"), "greaterThan", false, 25); // check some nans -- nans shouldnt be greaterThan to anything cmptst(snan, snan, "greaterThan", false, 27); cmptst(qnan, qnan, "greaterThan", false, 28); cmptst(snan, qnan, "greaterThan", false, 29); cmptst(qnan, snan, "greaterThan", false, 30); cmptst(qnan, field.newDfp("0"), "greaterThan", false, 31); cmptst(snan, field.newDfp("0"), "greaterThan", false, 32); cmptst(field.newDfp("0"), snan, "greaterThan", false, 33); cmptst(field.newDfp("0"), qnan, "greaterThan", false, 34); cmptst(qnan, pinf, "greaterThan", false, 35); cmptst(snan, pinf, "greaterThan", false, 36); cmptst(pinf, snan, "greaterThan", false, 37); cmptst(pinf, qnan, "greaterThan", false, 38); cmptst(qnan, ninf, "greaterThan", false, 39); cmptst(snan, ninf, "greaterThan", false, 40); cmptst(ninf, snan, "greaterThan", false, 41); cmptst(ninf, qnan, "greaterThan", false, 42); cmptst(qnan, field.newDfp("-1"), "greaterThan", false, 43); cmptst(snan, field.newDfp("-1"), "greaterThan", false, 44); cmptst(field.newDfp("-1"), snan, "greaterThan", false, 45); cmptst(field.newDfp("-1"), qnan, "greaterThan", false, 46); cmptst(qnan, field.newDfp("1"), "greaterThan", false, 47); cmptst(snan, field.newDfp("1"), "greaterThan", false, 48); cmptst(field.newDfp("1"), snan, "greaterThan", false, 49); cmptst(field.newDfp("1"), qnan, "greaterThan", false, 50); cmptst(snan.negate(), snan, "greaterThan", false, 51); cmptst(qnan.negate(), qnan, "greaterThan", false, 52); //greaterThan compares with nans should raise FLAG_INVALID if (field.getIEEEFlags() != DfpField.FLAG_INVALID) Assert.fail("assersion failed. compare greaterThan flags = "+field.getIEEEFlags()); field.clearIEEEFlags(); } // // Test multiplication // @Test public void testMultiply() { test(field.newDfp("1").multiply(field.newDfp("1")), // Basic tests 1*1 = 1 field.newDfp("1"), 0, "Multiply #1"); test(field.newDfp("1").multiply(1), // Basic tests 1*1 = 1 field.newDfp("1"), 0, "Multiply #2"); test(field.newDfp("-1").multiply(field.newDfp("1")), // Basic tests -1*1 = -1 field.newDfp("-1"), 0, "Multiply #3"); test(field.newDfp("-1").multiply(1), // Basic tests -1*1 = -1 field.newDfp("-1"), 0, "Multiply #4"); // basic tests with integers test(field.newDfp("2").multiply(field.newDfp("3")), field.newDfp("6"), 0, "Multiply #5"); test(field.newDfp("2").multiply(3), field.newDfp("6"), 0, "Multiply #6"); test(field.newDfp("-2").multiply(field.newDfp("3")), field.newDfp("-6"), 0, "Multiply #7"); test(field.newDfp("-2").multiply(3), field.newDfp("-6"), 0, "Multiply #8"); test(field.newDfp("2").multiply(field.newDfp("-3")), field.newDfp("-6"), 0, "Multiply #9"); test(field.newDfp("-2").multiply(field.newDfp("-3")), field.newDfp("6"), 0, "Multiply #10"); //multiply by zero test(field.newDfp("-2").multiply(field.newDfp("0")), field.newDfp("-0"), 0, "Multiply #11"); test(field.newDfp("-2").multiply(0), field.newDfp("-0"), 0, "Multiply #12"); test(field.newDfp("2").multiply(field.newDfp("0")), field.newDfp("0"), 0, "Multiply #13"); test(field.newDfp("2").multiply(0), field.newDfp("0"), 0, "Multiply #14"); test(field.newDfp("2").multiply(pinf), pinf, 0, "Multiply #15"); test(field.newDfp("2").multiply(ninf), ninf, 0, "Multiply #16"); test(field.newDfp("-2").multiply(pinf), ninf, 0, "Multiply #17"); test(field.newDfp("-2").multiply(ninf), pinf, 0, "Multiply #18"); test(ninf.multiply(field.newDfp("-2")), pinf, 0, "Multiply #18.1"); test(field.newDfp("5e131071").multiply(2), pinf, DfpField.FLAG_OVERFLOW, "Multiply #19"); test(field.newDfp("5e131071").multiply(field.newDfp("1.999999999999999")), field.newDfp("9.9999999999999950000e131071"), 0, "Multiply #20"); test(field.newDfp("-5e131071").multiply(2), ninf, DfpField.FLAG_OVERFLOW, "Multiply #22"); test(field.newDfp("-5e131071").multiply(field.newDfp("1.999999999999999")), field.newDfp("-9.9999999999999950000e131071"), 0, "Multiply #23"); test(field.newDfp("1e-65539").multiply(field.newDfp("1e-65539")), field.newDfp("1e-131078"), DfpField.FLAG_UNDERFLOW, "Multiply #24"); test(field.newDfp("1").multiply(nan), nan, 0, "Multiply #25"); test(nan.multiply(field.newDfp("1")), nan, 0, "Multiply #26"); test(nan.multiply(pinf), nan, 0, "Multiply #27"); test(pinf.multiply(nan), nan, 0, "Multiply #27"); test(pinf.multiply(field.newDfp("0")), nan, DfpField.FLAG_INVALID, "Multiply #28"); test(field.newDfp("0").multiply(pinf), nan, DfpField.FLAG_INVALID, "Multiply #29"); test(pinf.multiply(pinf), pinf, 0, "Multiply #30"); test(ninf.multiply(pinf), ninf, 0, "Multiply #31"); test(pinf.multiply(ninf), ninf, 0, "Multiply #32"); test(ninf.multiply(ninf), pinf, 0, "Multiply #33"); test(pinf.multiply(1), pinf, 0, "Multiply #34"); test(pinf.multiply(0), nan, DfpField.FLAG_INVALID, "Multiply #35"); test(nan.multiply(1), nan, 0, "Multiply #36"); test(field.newDfp("1").multiply(10000), field.newDfp("10000"), 0, "Multiply #37"); test(field.newDfp("2").multiply(1000000), field.newDfp("2000000"), 0, "Multiply #38"); test(field.newDfp("1").multiply(-1), field.newDfp("-1"), 0, "Multiply #39"); } @Test public void testDivide() { test(field.newDfp("1").divide(nan), // divide by NaN = NaN nan, 0, "Divide #1"); test(nan.divide(field.newDfp("1")), // NaN / number = NaN nan, 0, "Divide #2"); test(pinf.divide(field.newDfp("1")), pinf, 0, "Divide #3"); test(pinf.divide(field.newDfp("-1")), ninf, 0, "Divide #4"); test(pinf.divide(pinf), nan, DfpField.FLAG_INVALID, "Divide #5"); test(ninf.divide(pinf), nan, DfpField.FLAG_INVALID, "Divide #6"); test(pinf.divide(ninf), nan, DfpField.FLAG_INVALID, "Divide #7"); test(ninf.divide(ninf), nan, DfpField.FLAG_INVALID, "Divide #8"); test(field.newDfp("0").divide(field.newDfp("0")), nan, DfpField.FLAG_DIV_ZERO, "Divide #9"); test(field.newDfp("1").divide(field.newDfp("0")), pinf, DfpField.FLAG_DIV_ZERO, "Divide #10"); test(field.newDfp("1").divide(field.newDfp("-0")), ninf, DfpField.FLAG_DIV_ZERO, "Divide #11"); test(field.newDfp("-1").divide(field.newDfp("0")), ninf, DfpField.FLAG_DIV_ZERO, "Divide #12"); test(field.newDfp("-1").divide(field.newDfp("-0")), pinf, DfpField.FLAG_DIV_ZERO, "Divide #13"); test(field.newDfp("1").divide(field.newDfp("3")), field.newDfp("0.33333333333333333333"), DfpField.FLAG_INEXACT, "Divide #14"); test(field.newDfp("1").divide(field.newDfp("6")), field.newDfp("0.16666666666666666667"), DfpField.FLAG_INEXACT, "Divide #15"); test(field.newDfp("10").divide(field.newDfp("6")), field.newDfp("1.6666666666666667"), DfpField.FLAG_INEXACT, "Divide #16"); test(field.newDfp("100").divide(field.newDfp("6")), field.newDfp("16.6666666666666667"), DfpField.FLAG_INEXACT, "Divide #17"); test(field.newDfp("1000").divide(field.newDfp("6")), field.newDfp("166.6666666666666667"), DfpField.FLAG_INEXACT, "Divide #18"); test(field.newDfp("10000").divide(field.newDfp("6")), field.newDfp("1666.6666666666666667"), DfpField.FLAG_INEXACT, "Divide #19"); test(field.newDfp("1").divide(field.newDfp("1")), field.newDfp("1"), 0, "Divide #20"); test(field.newDfp("1").divide(field.newDfp("-1")), field.newDfp("-1"), 0, "Divide #21"); test(field.newDfp("-1").divide(field.newDfp("1")), field.newDfp("-1"), 0, "Divide #22"); test(field.newDfp("-1").divide(field.newDfp("-1")), field.newDfp("1"), 0, "Divide #23"); test(field.newDfp("1e-65539").divide(field.newDfp("1e65539")), field.newDfp("1e-131078"), DfpField.FLAG_UNDERFLOW, "Divide #24"); test(field.newDfp("1e65539").divide(field.newDfp("1e-65539")), pinf, DfpField.FLAG_OVERFLOW, "Divide #24"); test(field.newDfp("2").divide(field.newDfp("1.5")), // test trial-divisor too high field.newDfp("1.3333333333333333"), DfpField.FLAG_INEXACT, "Divide #25"); test(field.newDfp("2").divide(pinf), field.newDfp("0"), 0, "Divide #26"); test(field.newDfp("2").divide(ninf), field.newDfp("-0"), 0, "Divide #27"); test(field.newDfp("0").divide(field.newDfp("1")), field.newDfp("0"), 0, "Divide #28"); } @Test public void testReciprocal() { test(nan.reciprocal(), nan, 0, "Reciprocal #1"); test(field.newDfp("0").reciprocal(), pinf, DfpField.FLAG_DIV_ZERO, "Reciprocal #2"); test(field.newDfp("-0").reciprocal(), ninf, DfpField.FLAG_DIV_ZERO, "Reciprocal #3"); test(field.newDfp("3").reciprocal(), field.newDfp("0.33333333333333333333"), DfpField.FLAG_INEXACT, "Reciprocal #4"); test(field.newDfp("6").reciprocal(), field.newDfp("0.16666666666666666667"), DfpField.FLAG_INEXACT, "Reciprocal #5"); test(field.newDfp("1").reciprocal(), field.newDfp("1"), 0, "Reciprocal #6"); test(field.newDfp("-1").reciprocal(), field.newDfp("-1"), 0, "Reciprocal #7"); test(pinf.reciprocal(), field.newDfp("0"), 0, "Reciprocal #8"); test(ninf.reciprocal(), field.newDfp("-0"), 0, "Reciprocal #9"); } @Test public void testDivideInt() { test(nan.divide(1), // NaN / number = NaN nan, 0, "DivideInt #1"); test(pinf.divide(1), pinf, 0, "DivideInt #2"); test(field.newDfp("0").divide(0), nan, DfpField.FLAG_DIV_ZERO, "DivideInt #3"); test(field.newDfp("1").divide(0), pinf, DfpField.FLAG_DIV_ZERO, "DivideInt #4"); test(field.newDfp("-1").divide(0), ninf, DfpField.FLAG_DIV_ZERO, "DivideInt #5"); test(field.newDfp("1").divide(3), field.newDfp("0.33333333333333333333"), DfpField.FLAG_INEXACT, "DivideInt #6"); test(field.newDfp("1").divide(6), field.newDfp("0.16666666666666666667"), DfpField.FLAG_INEXACT, "DivideInt #7"); test(field.newDfp("10").divide(6), field.newDfp("1.6666666666666667"), DfpField.FLAG_INEXACT, "DivideInt #8"); test(field.newDfp("100").divide(6), field.newDfp("16.6666666666666667"), DfpField.FLAG_INEXACT, "DivideInt #9"); test(field.newDfp("1000").divide(6), field.newDfp("166.6666666666666667"), DfpField.FLAG_INEXACT, "DivideInt #10"); test(field.newDfp("10000").divide(6), field.newDfp("1666.6666666666666667"), DfpField.FLAG_INEXACT, "DivideInt #20"); test(field.newDfp("1").divide(1), field.newDfp("1"), 0, "DivideInt #21"); test(field.newDfp("1e-131077").divide(10), field.newDfp("1e-131078"), DfpField.FLAG_UNDERFLOW, "DivideInt #22"); test(field.newDfp("0").divide(1), field.newDfp("0"), 0, "DivideInt #23"); test(field.newDfp("1").divide(10000), nan, DfpField.FLAG_INVALID, "DivideInt #24"); test(field.newDfp("1").divide(-1), nan, DfpField.FLAG_INVALID, "DivideInt #25"); } @Test public void testNextAfter() { test(field.newDfp("1").nextAfter(pinf), field.newDfp("1.0000000000000001"), 0, "NextAfter #1"); test(field.newDfp("1.0000000000000001").nextAfter(ninf), field.newDfp("1"), 0, "NextAfter #1.5"); test(field.newDfp("1").nextAfter(ninf), field.newDfp("0.99999999999999999999"), 0, "NextAfter #2"); test(field.newDfp("0.99999999999999999999").nextAfter(field.newDfp("2")), field.newDfp("1"), 0, "NextAfter #3"); test(field.newDfp("-1").nextAfter(ninf), field.newDfp("-1.0000000000000001"), 0, "NextAfter #4"); test(field.newDfp("-1").nextAfter(pinf), field.newDfp("-0.99999999999999999999"), 0, "NextAfter #5"); test(field.newDfp("-0.99999999999999999999").nextAfter(field.newDfp("-2")), field.newDfp("-1"), 0, "NextAfter #6"); test(field.newDfp("2").nextAfter(field.newDfp("2")), field.newDfp("2"), 0, "NextAfter #7"); test(field.newDfp("0").nextAfter(field.newDfp("0")), field.newDfp("0"), 0, "NextAfter #8"); test(field.newDfp("-2").nextAfter(field.newDfp("-2")), field.newDfp("-2"), 0, "NextAfter #9"); test(field.newDfp("0").nextAfter(field.newDfp("1")), field.newDfp("1e-131092"), DfpField.FLAG_UNDERFLOW, "NextAfter #10"); test(field.newDfp("0").nextAfter(field.newDfp("-1")), field.newDfp("-1e-131092"), DfpField.FLAG_UNDERFLOW, "NextAfter #11"); test(field.newDfp("-1e-131092").nextAfter(pinf), field.newDfp("-0"), DfpField.FLAG_UNDERFLOW|DfpField.FLAG_INEXACT, "Next After #12"); test(field.newDfp("1e-131092").nextAfter(ninf), field.newDfp("0"), DfpField.FLAG_UNDERFLOW|DfpField.FLAG_INEXACT, "Next After #13"); test(field.newDfp("9.9999999999999999999e131078").nextAfter(pinf), pinf, DfpField.FLAG_OVERFLOW|DfpField.FLAG_INEXACT, "Next After #14"); } @Test public void testToString() { Assert.assertEquals("toString #1", "Infinity", pinf.toString()); Assert.assertEquals("toString #2", "-Infinity", ninf.toString()); Assert.assertEquals("toString #3", "NaN", nan.toString()); Assert.assertEquals("toString #4", "NaN", field.newDfp((byte) 1, Dfp.QNAN).toString()); Assert.assertEquals("toString #5", "NaN", field.newDfp((byte) 1, Dfp.SNAN).toString()); Assert.assertEquals("toString #6", "1.2300000000000000e100", field.newDfp("1.23e100").toString()); Assert.assertEquals("toString #7", "-1.2300000000000000e100", field.newDfp("-1.23e100").toString()); Assert.assertEquals("toString #8", "12345678.1234", field.newDfp("12345678.1234").toString()); Assert.assertEquals("toString #9", "0.00001234", field.newDfp("0.00001234").toString()); } @Override @Test public void testRound() { field.setRoundingMode(DfpField.RoundingMode.ROUND_DOWN); // Round down test(field.newDfp("12345678901234567890").add(field.newDfp("0.9")), field.newDfp("12345678901234567890"), DfpField.FLAG_INEXACT, "Round #1"); test(field.newDfp("12345678901234567890").add(field.newDfp("0.99999999")), field.newDfp("12345678901234567890"), DfpField.FLAG_INEXACT, "Round #2"); test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.99999999")), field.newDfp("-12345678901234567890"), DfpField.FLAG_INEXACT, "Round #3"); field.setRoundingMode(DfpField.RoundingMode.ROUND_UP); // Round up test(field.newDfp("12345678901234567890").add(field.newDfp("0.1")), field.newDfp("12345678901234567891"), DfpField.FLAG_INEXACT, "Round #4"); test(field.newDfp("12345678901234567890").add(field.newDfp("0.0001")), field.newDfp("12345678901234567891"), DfpField.FLAG_INEXACT, "Round #5"); test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.1")), field.newDfp("-12345678901234567891"), DfpField.FLAG_INEXACT, "Round #6"); test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.0001")), field.newDfp("-12345678901234567891"), DfpField.FLAG_INEXACT, "Round #7"); field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_UP); // Round half up test(field.newDfp("12345678901234567890").add(field.newDfp("0.4999")), field.newDfp("12345678901234567890"), DfpField.FLAG_INEXACT, "Round #8"); test(field.newDfp("12345678901234567890").add(field.newDfp("0.5000")), field.newDfp("12345678901234567891"), DfpField.FLAG_INEXACT, "Round #9"); test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.4999")), field.newDfp("-12345678901234567890"), DfpField.FLAG_INEXACT, "Round #10"); test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.5000")), field.newDfp("-12345678901234567891"), DfpField.FLAG_INEXACT, "Round #11"); field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_DOWN); // Round half down test(field.newDfp("12345678901234567890").add(field.newDfp("0.5001")), field.newDfp("12345678901234567891"), DfpField.FLAG_INEXACT, "Round #12"); test(field.newDfp("12345678901234567890").add(field.newDfp("0.5000")), field.newDfp("12345678901234567890"), DfpField.FLAG_INEXACT, "Round #13"); test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.5001")), field.newDfp("-12345678901234567891"), DfpField.FLAG_INEXACT, "Round #14"); test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.5000")), field.newDfp("-12345678901234567890"), DfpField.FLAG_INEXACT, "Round #15"); field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_ODD); // Round half odd test(field.newDfp("12345678901234567890").add(field.newDfp("0.5000")), field.newDfp("12345678901234567891"), DfpField.FLAG_INEXACT, "Round #16"); test(field.newDfp("12345678901234567891").add(field.newDfp("0.5000")), field.newDfp("12345678901234567891"), DfpField.FLAG_INEXACT, "Round #17"); test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.5000")), field.newDfp("-12345678901234567891"), DfpField.FLAG_INEXACT, "Round #18"); test(field.newDfp("-12345678901234567891").add(field.newDfp("-0.5000")), field.newDfp("-12345678901234567891"), DfpField.FLAG_INEXACT, "Round #19"); field.setRoundingMode(DfpField.RoundingMode.ROUND_CEIL); // Round ceil test(field.newDfp("12345678901234567890").add(field.newDfp("0.0001")), field.newDfp("12345678901234567891"), DfpField.FLAG_INEXACT, "Round #20"); test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.9999")), field.newDfp("-12345678901234567890"), DfpField.FLAG_INEXACT, "Round #21"); field.setRoundingMode(DfpField.RoundingMode.ROUND_FLOOR); // Round floor test(field.newDfp("12345678901234567890").add(field.newDfp("0.9999")), field.newDfp("12345678901234567890"), DfpField.FLAG_INEXACT, "Round #22"); test(field.newDfp("-12345678901234567890").add(field.newDfp("-0.0001")), field.newDfp("-12345678901234567891"), DfpField.FLAG_INEXACT, "Round #23"); field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_EVEN); // reset } @Override @Test public void testCeil() { test(field.newDfp("1234.0000000000000001").ceil(), field.newDfp("1235"), DfpField.FLAG_INEXACT, "Ceil #1"); } @Override @Test public void testFloor() { test(field.newDfp("1234.9999999999999999").floor(), field.newDfp("1234"), DfpField.FLAG_INEXACT, "Floor #1"); } @Override @Test public void testRint() { test(field.newDfp("1234.50000000001").rint(), field.newDfp("1235"), DfpField.FLAG_INEXACT, "Rint #1"); test(field.newDfp("1234.5000").rint(), field.newDfp("1234"), DfpField.FLAG_INEXACT, "Rint #2"); test(field.newDfp("1235.5000").rint(), field.newDfp("1236"), DfpField.FLAG_INEXACT, "Rint #3"); } @Test public void testCopySign() { test(Dfp.copysign(field.newDfp("1234."), field.newDfp("-1")), field.newDfp("-1234"), 0, "CopySign #1"); test(Dfp.copysign(field.newDfp("-1234."), field.newDfp("-1")), field.newDfp("-1234"), 0, "CopySign #2"); test(Dfp.copysign(field.newDfp("-1234."), field.newDfp("1")), field.newDfp("1234"), 0, "CopySign #3"); test(Dfp.copysign(field.newDfp("1234."), field.newDfp("1")), field.newDfp("1234"), 0, "CopySign #4"); } @Test public void testIntValue() { Assert.assertEquals("intValue #1", 1234, field.newDfp("1234").intValue()); Assert.assertEquals("intValue #2", -1234, field.newDfp("-1234").intValue()); Assert.assertEquals("intValue #3", 1234, field.newDfp("1234.5").intValue()); Assert.assertEquals("intValue #4", 1235, field.newDfp("1234.500001").intValue()); Assert.assertEquals("intValue #5", 2147483647, field.newDfp("1e1000").intValue()); Assert.assertEquals("intValue #6", -2147483648, field.newDfp("-1e1000").intValue()); } @Test public void testLog10K() { Assert.assertEquals("log10K #1", 1, field.newDfp("123456").log10K()); Assert.assertEquals("log10K #2", 2, field.newDfp("123456789").log10K()); Assert.assertEquals("log10K #3", 0, field.newDfp("2").log10K()); Assert.assertEquals("log10K #3", 0, field.newDfp("1").log10K()); Assert.assertEquals("log10K #4", -1, field.newDfp("0.1").log10K()); } @Test public void testPower10K() { Dfp d = field.newDfp(); test(d.power10K(0), field.newDfp("1"), 0, "Power10 #1"); test(d.power10K(1), field.newDfp("10000"), 0, "Power10 #2"); test(d.power10K(2), field.newDfp("100000000"), 0, "Power10 #3"); test(d.power10K(-1), field.newDfp("0.0001"), 0, "Power10 #4"); test(d.power10K(-2), field.newDfp("0.00000001"), 0, "Power10 #5"); test(d.power10K(-3), field.newDfp("0.000000000001"), 0, "Power10 #6"); } @Test public void testLog10() { Assert.assertEquals("log10 #1", 1, field.newDfp("12").intLog10()); Assert.assertEquals("log10 #2", 2, field.newDfp("123").intLog10()); Assert.assertEquals("log10 #3", 3, field.newDfp("1234").intLog10()); Assert.assertEquals("log10 #4", 4, field.newDfp("12345").intLog10()); Assert.assertEquals("log10 #5", 5, field.newDfp("123456").intLog10()); Assert.assertEquals("log10 #6", 6, field.newDfp("1234567").intLog10()); Assert.assertEquals("log10 #6", 7, field.newDfp("12345678").intLog10()); Assert.assertEquals("log10 #7", 8, field.newDfp("123456789").intLog10()); Assert.assertEquals("log10 #8", 9, field.newDfp("1234567890").intLog10()); Assert.assertEquals("log10 #9", 10, field.newDfp("12345678901").intLog10()); Assert.assertEquals("log10 #10", 11, field.newDfp("123456789012").intLog10()); Assert.assertEquals("log10 #11", 12, field.newDfp("1234567890123").intLog10()); Assert.assertEquals("log10 #12", 0, field.newDfp("2").intLog10()); Assert.assertEquals("log10 #13", 0, field.newDfp("1").intLog10()); Assert.assertEquals("log10 #14", -1, field.newDfp("0.12").intLog10()); Assert.assertEquals("log10 #15", -2, field.newDfp("0.012").intLog10()); } @Test public void testPower10() { Dfp d = field.newDfp(); test(d.power10(0), field.newDfp("1"), 0, "Power10 #1"); test(d.power10(1), field.newDfp("10"), 0, "Power10 #2"); test(d.power10(2), field.newDfp("100"), 0, "Power10 #3"); test(d.power10(3), field.newDfp("1000"), 0, "Power10 #4"); test(d.power10(4), field.newDfp("10000"), 0, "Power10 #5"); test(d.power10(5), field.newDfp("100000"), 0, "Power10 #6"); test(d.power10(6), field.newDfp("1000000"), 0, "Power10 #7"); test(d.power10(7), field.newDfp("10000000"), 0, "Power10 #8"); test(d.power10(8), field.newDfp("100000000"), 0, "Power10 #9"); test(d.power10(9), field.newDfp("1000000000"), 0, "Power10 #10"); test(d.power10(-1), field.newDfp(".1"), 0, "Power10 #11"); test(d.power10(-2), field.newDfp(".01"), 0, "Power10 #12"); test(d.power10(-3), field.newDfp(".001"), 0, "Power10 #13"); test(d.power10(-4), field.newDfp(".0001"), 0, "Power10 #14"); test(d.power10(-5), field.newDfp(".00001"), 0, "Power10 #15"); test(d.power10(-6), field.newDfp(".000001"), 0, "Power10 #16"); test(d.power10(-7), field.newDfp(".0000001"), 0, "Power10 #17"); test(d.power10(-8), field.newDfp(".00000001"), 0, "Power10 #18"); test(d.power10(-9), field.newDfp(".000000001"), 0, "Power10 #19"); test(d.power10(-10), field.newDfp(".0000000001"), 0, "Power10 #20"); } @Test public void testRemainder() { test(field.newDfp("10").remainder(field.newDfp("3")), field.newDfp("1"), DfpField.FLAG_INEXACT, "Remainder #1"); test(field.newDfp("9").remainder(field.newDfp("3")), field.newDfp("0"), 0, "Remainder #2"); test(field.newDfp("-9").remainder(field.newDfp("3")), field.newDfp("-0"), 0, "Remainder #3"); } @Override @Test public void testSqrt() { test(field.newDfp("0").sqrt(), field.newDfp("0"), 0, "Sqrt #1"); test(field.newDfp("-0").sqrt(), field.newDfp("-0"), 0, "Sqrt #2"); test(field.newDfp("1").sqrt(), field.newDfp("1"), 0, "Sqrt #3"); test(field.newDfp("2").sqrt(), field.newDfp("1.4142135623730950"), DfpField.FLAG_INEXACT, "Sqrt #4"); test(field.newDfp("3").sqrt(), field.newDfp("1.7320508075688773"), DfpField.FLAG_INEXACT, "Sqrt #5"); test(field.newDfp("5").sqrt(), field.newDfp("2.2360679774997897"), DfpField.FLAG_INEXACT, "Sqrt #6"); test(field.newDfp("500").sqrt(), field.newDfp("22.3606797749978970"), DfpField.FLAG_INEXACT, "Sqrt #6.2"); test(field.newDfp("50000").sqrt(), field.newDfp("223.6067977499789696"), DfpField.FLAG_INEXACT, "Sqrt #6.3"); test(field.newDfp("-1").sqrt(), nan, DfpField.FLAG_INVALID, "Sqrt #7"); test(pinf.sqrt(), pinf, 0, "Sqrt #8"); test(field.newDfp((byte) 1, Dfp.QNAN).sqrt(), nan, 0, "Sqrt #9"); test(field.newDfp((byte) 1, Dfp.SNAN).sqrt(), nan, DfpField.FLAG_INVALID, "Sqrt #9"); } @Test public void testIssue567() { DfpField field = new DfpField(100); Assert.assertEquals(0.0, field.getZero().toDouble(), Precision.SAFE_MIN); Assert.assertEquals(0.0, field.newDfp(0.0).toDouble(), Precision.SAFE_MIN); Assert.assertEquals(-1, FastMath.copySign(1, field.newDfp(-0.0).toDouble()), Precision.EPSILON); Assert.assertEquals(+1, FastMath.copySign(1, field.newDfp(+0.0).toDouble()), Precision.EPSILON); } @Test public void testIsZero() { Assert.assertTrue(field.getZero().isZero()); Assert.assertTrue(field.getZero().negate().isZero()); Assert.assertTrue(field.newDfp(+0.0).isZero()); Assert.assertTrue(field.newDfp(-0.0).isZero()); Assert.assertFalse(field.newDfp(1.0e-90).isZero()); Assert.assertFalse(nan.isZero()); Assert.assertFalse(nan.negate().isZero()); Assert.assertFalse(pinf.isZero()); Assert.assertFalse(pinf.negate().isZero()); Assert.assertFalse(ninf.isZero()); Assert.assertFalse(ninf.negate().isZero()); } @Test public void testSignPredicates() { Assert.assertTrue(field.getZero().negativeOrNull()); Assert.assertTrue(field.getZero().positiveOrNull()); Assert.assertFalse(field.getZero().strictlyNegative()); Assert.assertFalse(field.getZero().strictlyPositive()); Assert.assertTrue(field.getZero().negate().negativeOrNull()); Assert.assertTrue(field.getZero().negate().positiveOrNull()); Assert.assertFalse(field.getZero().negate().strictlyNegative()); Assert.assertFalse(field.getZero().negate().strictlyPositive()); Assert.assertFalse(field.getOne().negativeOrNull()); Assert.assertTrue(field.getOne().positiveOrNull()); Assert.assertFalse(field.getOne().strictlyNegative()); Assert.assertTrue(field.getOne().strictlyPositive()); Assert.assertTrue(field.getOne().negate().negativeOrNull()); Assert.assertFalse(field.getOne().negate().positiveOrNull()); Assert.assertTrue(field.getOne().negate().strictlyNegative()); Assert.assertFalse(field.getOne().negate().strictlyPositive()); Assert.assertFalse(nan.negativeOrNull()); Assert.assertFalse(nan.positiveOrNull()); Assert.assertFalse(nan.strictlyNegative()); Assert.assertFalse(nan.strictlyPositive()); Assert.assertFalse(nan.negate().negativeOrNull()); Assert.assertFalse(nan.negate().positiveOrNull()); Assert.assertFalse(nan.negate().strictlyNegative()); Assert.assertFalse(nan.negate().strictlyPositive()); Assert.assertFalse(pinf.negativeOrNull()); Assert.assertTrue(pinf.positiveOrNull()); Assert.assertFalse(pinf.strictlyNegative()); Assert.assertTrue(pinf.strictlyPositive()); Assert.assertTrue(pinf.negate().negativeOrNull()); Assert.assertFalse(pinf.negate().positiveOrNull()); Assert.assertTrue(pinf.negate().strictlyNegative()); Assert.assertFalse(pinf.negate().strictlyPositive()); Assert.assertTrue(ninf.negativeOrNull()); Assert.assertFalse(ninf.positiveOrNull()); Assert.assertTrue(ninf.strictlyNegative()); Assert.assertFalse(ninf.strictlyPositive()); Assert.assertFalse(ninf.negate().negativeOrNull()); Assert.assertTrue(ninf.negate().positiveOrNull()); Assert.assertFalse(ninf.negate().strictlyNegative()); Assert.assertTrue(ninf.negate().strictlyPositive()); } @Test public void testSpecialConstructors() { Assert.assertEquals(ninf, field.newDfp(Double.NEGATIVE_INFINITY)); Assert.assertEquals(ninf, field.newDfp("-Infinity")); Assert.assertEquals(pinf, field.newDfp(Double.POSITIVE_INFINITY)); Assert.assertEquals(pinf, field.newDfp("Infinity")); Assert.assertTrue(field.newDfp(Double.NaN).isNaN()); Assert.assertTrue(field.newDfp("NaN").isNaN()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.distribution; import org.junit.Assert; import org.junit.Test; public class BetaDistributionTest { @Test public void testCumulative() { double[] x = new double[]{-0.1, 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1}; // all test data computed using R 2.5 checkCumulative(0.1, 0.1, x, new double[]{ 0.0000000000, 0.0000000000, 0.4063850939, 0.4397091902, 0.4628041861, 0.4821200456, 0.5000000000, 0.5178799544, 0.5371958139, 0.5602908098, 0.5936149061, 1.0000000000, 1.0000000000}); checkCumulative(0.1, 0.5, x, new double[]{ 0.0000000000, 0.0000000000, 0.7048336221, 0.7593042194, 0.7951765304, 0.8234948385, 0.8480017124, 0.8706034370, 0.8926585878, 0.9156406404, 0.9423662883, 1.0000000000, 1.0000000000}); checkCumulative(0.1, 1.0, x, new double[]{ 0.0000000000, 0.0000000000, 0.7943282347, 0.8513399225, 0.8865681506, 0.9124435366, 0.9330329915, 0.9502002165, 0.9649610951, 0.9779327685, 0.9895192582, 1.0000000000, 1.0000000000}); checkCumulative(0.1, 2.0, x, new double[]{ 0.0000000000, 0.0000000000, 0.8658177758, 0.9194471163, 0.9486279211, 0.9671901487, 0.9796846411, 0.9882082252, 0.9939099280, 0.9974914239, 0.9994144508, 1.0000000000, 1.0000000000}); checkCumulative(0.1, 4.0, x, new double[]{ 0.0000000000, 0.0000000000, 0.9234991121, 0.9661958941, 0.9842285085, 0.9928444112, 0.9970040660, 0.9989112804, 0.9996895625, 0.9999440793, 0.9999967829, 1.0000000000, 1.0000000000}); checkCumulative(0.5, 0.1, x, new double[]{ 0.00000000000, 0.00000000000, 0.05763371168, 0.08435935962, 0.10734141216, 0.12939656302, 0.15199828760, 0.17650516146, 0.20482346963, 0.24069578055, 0.29516637795, 1.00000000000, 1.00000000000}); checkCumulative(0.5, 0.5, x, new double[]{ 0.0000000000, 0.0000000000, 0.2048327647, 0.2951672353, 0.3690101196, 0.4359057832, 0.5000000000, 0.5640942168, 0.6309898804, 0.7048327647, 0.7951672353, 1.0000000000, 1.0000000000}); checkCumulative(0.5, 1.0, x, new double[]{ 0.0000000000, 0.0000000000, 0.3162277660, 0.4472135955, 0.5477225575, 0.6324555320, 0.7071067812, 0.7745966692, 0.8366600265, 0.8944271910, 0.9486832981, 1.0000000000, 1.0000000000}); checkCumulative(0.5, 2.0, x, new double[]{ 0.0000000000, 0.0000000000, 0.4585302607, 0.6260990337, 0.7394254526, 0.8221921916, 0.8838834765, 0.9295160031, 0.9621590305, 0.9838699101, 0.9961174630, 1.0000000000, 1.0000000000}); checkCumulative(0.5, 4.0, x, new double[]{ 0.0000000000, 0.0000000000, 0.6266250826, 0.8049844719, 0.8987784842, 0.9502644369, 0.9777960959, 0.9914837366, 0.9974556254, 0.9995223859, 0.9999714889, 1.0000000000, 1.0000000000}); checkCumulative(1.0, 0.1, x, new double[]{ 0.00000000000, 0.00000000000, 0.01048074179, 0.02206723146, 0.03503890488, 0.04979978349, 0.06696700846, 0.08755646344, 0.11343184943, 0.14866007748, 0.20567176528, 1.00000000000, 1.00000000000}); checkCumulative(1.0, 0.5, x, new double[]{ 0.00000000000, 0.00000000000, 0.05131670195, 0.10557280900, 0.16333997347, 0.22540333076, 0.29289321881, 0.36754446797, 0.45227744249, 0.55278640450, 0.68377223398, 1.00000000000, 1.00000000000}); checkCumulative(1, 1, x, new double[]{ 0.0, 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.0}); checkCumulative(1, 2, x, new double[]{ 0.00, 0.00, 0.19, 0.36, 0.51, 0.64, 0.75, 0.84, 0.91, 0.96, 0.99, 1.00, 1.00}); checkCumulative(1, 4, x, new double[]{ 0.0000, 0.0000, 0.3439, 0.5904, 0.7599, 0.8704, 0.9375, 0.9744, 0.9919, 0.9984, 0.9999, 1.0000, 1.0000}); checkCumulative(2.0, 0.1, x, new double[]{ 0.0000000000000, 0.0000000000000, 0.0005855492117, 0.0025085760862, 0.0060900720266, 0.0117917748341, 0.0203153588864, 0.0328098512512, 0.0513720788952, 0.0805528836776, 0.1341822241505, 1.0000000000000, 1.0000000000000}); checkCumulative(2, 1, x, new double[]{ 0.00, 0.00, 0.01, 0.04, 0.09, 0.16, 0.25, 0.36, 0.49, 0.64, 0.81, 1.00, 1.00}); checkCumulative(2.0, 0.5, x, new double[]{ 0.000000000000, 0.000000000000, 0.003882537047, 0.016130089900, 0.037840969486, 0.070483996910, 0.116116523517, 0.177807808356, 0.260574547368, 0.373900966300, 0.541469739276, 1.000000000000, 1.000000000000}); checkCumulative(2, 2, x, new double[]{ 0.000, 0.000, 0.028, 0.104, 0.216, 0.352, 0.500, 0.648, 0.784, 0.896, 0.972, 1.000, 1.000}); checkCumulative(2, 4, x, new double[]{ 0.00000, 0.00000, 0.08146, 0.26272, 0.47178, 0.66304, 0.81250, 0.91296, 0.96922, 0.99328, 0.99954, 1.00000, 1.00000}); checkCumulative(4.0, 0.1, x, new double[]{ 0.000000000e+00, 0.000000000e+00, 3.217128269e-06, 5.592070271e-05, 3.104375474e-04, 1.088719595e-03, 2.995933981e-03, 7.155588777e-03, 1.577149153e-02, 3.380410585e-02, 7.650088789e-02, 1.000000000e+00, 1.000000000e+00}); checkCumulative(4.0, 0.5, x, new double[]{ 0.000000000e+00, 0.000000000e+00, 2.851114863e-05, 4.776140576e-04, 2.544374616e-03, 8.516263371e-03, 2.220390414e-02, 4.973556312e-02, 1.012215158e-01, 1.950155281e-01, 3.733749174e-01, 1.000000000e+00, 1.000000000e+00}); checkCumulative(4, 1, x, new double[]{ 0.0000, 0.0000, 0.0001, 0.0016, 0.0081, 0.0256, 0.0625, 0.1296, 0.2401, 0.4096, 0.6561, 1.0000, 1.0000}); checkCumulative(4, 2, x, new double[]{ 0.00000, 0.00000, 0.00046, 0.00672, 0.03078, 0.08704, 0.18750, 0.33696, 0.52822, 0.73728, 0.91854, 1.00000, 1.00000}); checkCumulative(4, 4, x, new double[]{ 0.000000, 0.000000, 0.002728, 0.033344, 0.126036, 0.289792, 0.500000, 0.710208, 0.873964, 0.966656, 0.997272, 1.000000, 1.000000}); } private void checkCumulative(double alpha, double beta, double[] x, double[] cumes) { BetaDistribution d = new BetaDistribution(alpha, beta); for (int i = 0; i < x.length; i++) { Assert.assertEquals(cumes[i], d.cumulativeProbability(x[i]), 1e-8); } for (int i = 1; i < x.length - 1; i++) { Assert.assertEquals(x[i], d.inverseCumulativeProbability(cumes[i]), 1e-5); } } @Test public void testDensity() { double[] x = new double[]{1e-6, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9}; checkDensity(0.1, 0.1, x, new double[]{ 12741.2357380649, 0.4429889586665234, 2.639378715e-01, 2.066393611e-01, 1.832401831e-01, 1.766302780e-01, 1.832404579e-01, 2.066400696e-01, 2.639396531e-01, 4.429925026e-01}); checkDensity(0.1, 0.5, x, new double[]{ 2.218377102e+04, 7.394524202e-01, 4.203020268e-01, 3.119435533e-01, 2.600787829e-01, 2.330648626e-01, 2.211408259e-01, 2.222728708e-01, 2.414013907e-01, 3.070567405e-01}); checkDensity(0.1, 1.0, x, new double[]{ 2.511886432e+04, 7.943210858e-01, 4.256680458e-01, 2.955218303e-01, 2.281103709e-01, 1.866062624e-01, 1.583664652e-01, 1.378514078e-01, 1.222414585e-01, 1.099464743e-01}); checkDensity(0.1, 2.0, x, new double[]{ 2.763072312e+04, 7.863770012e-01, 3.745874120e-01, 2.275514842e-01, 1.505525939e-01, 1.026332391e-01, 6.968107049e-02, 4.549081293e-02, 2.689298641e-02, 1.209399123e-02}); checkDensity(0.1, 4.0, x, new double[]{ 2.997927462e+04, 6.911058917e-01, 2.601128486e-01, 1.209774010e-01, 5.880564714e-02, 2.783915474e-02, 1.209657335e-02, 4.442148268e-03, 1.167143939e-03, 1.312171805e-04}); checkDensity(0.5, 0.1, x, new double[]{ 88.3152184726, 0.3070542841, 0.2414007269, 0.2222727015, 0.2211409364, 0.2330652355, 0.2600795198, 0.3119449793, 0.4203052841, 0.7394649088}); checkDensity(0.5, 0.5, x, new double[]{ 318.3100453389, 1.0610282383, 0.7957732234, 0.6946084565, 0.6497470636, 0.6366197724, 0.6497476051, 0.6946097796, 0.7957762075, 1.0610376697}); checkDensity(0.5, 1.0, x, new double[]{ 500.0000000000, 1.5811309244, 1.1180311937, 0.9128694077, 0.7905684268, 0.7071060741, 0.6454966865, 0.5976138778, 0.5590166450, 0.5270459839}); checkDensity(0.5, 2.0, x, new double[]{ 749.99925000000, 2.134537420613655, 1.34163575536, 0.95851150881, 0.71151039830, 0.53032849490, 0.38729704363, 0.26892534859, 0.16770415497, 0.07905610701}); checkDensity(0.5, 4.0, x, new double[]{ 1.093746719e+03, 2.52142232809988, 1.252190241e+00, 6.849343920e-01, 3.735417140e-01, 1.933481570e-01, 9.036885833e-02, 3.529621669e-02, 9.782644546e-03, 1.152878503e-03}); checkDensity(1.0, 0.1, x, new double[]{ 0.1000000900, 0.1099466942, 0.1222417336, 0.1378517623, 0.1583669403, 0.1866069342, 0.2281113974, 0.2955236034, 0.4256718768, 0.7943353837}); checkDensity(1.0, 0.5, x, new double[]{ 0.5000002500, 0.5270465695, 0.5590173438, 0.5976147315, 0.6454977623, 0.7071074883, 0.7905704033, 0.9128724506, 1.1180367838, 1.5811467358}); checkDensity(1, 1, x, new double[]{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}); checkDensity(1, 2, x, new double[]{ 1.999998, 1.799998, 1.599998, 1.399998, 1.199998, 0.999998, 0.799998, 0.599998, 0.399998, 0.199998}); checkDensity(1, 4, x, new double[]{ 3.999988000012, 2.915990280011, 2.047992320010, 1.371994120008, 0.863995680007, 0.499997000006, 0.255998080005, 0.107998920004, 0.031999520002, 0.003999880001}); checkDensity(2.0, 0.1, x, new double[]{ 1.100000990e-07, 1.209425730e-02, 2.689331586e-02, 4.549123318e-02, 6.968162794e-02, 1.026340191e-01, 1.505537732e-01, 2.275534997e-01, 3.745917198e-01, 7.863929037e-01}); checkDensity(2.0, 0.5, x, new double[]{ 7.500003750e-07, 7.905777599e-02, 1.677060417e-01, 2.689275256e-01, 3.872996256e-01, 5.303316769e-01, 7.115145488e-01, 9.585174425e-01, 1.341645818e+00, 2.134537420613655}); checkDensity(2, 1, x, new double[]{ 0.000002, 0.200002, 0.400002, 0.600002, 0.800002, 1.000002, 1.200002, 1.400002, 1.600002, 1.800002}); checkDensity(2, 2, x, new double[]{ 5.9999940e-06, 5.4000480e-01, 9.6000360e-01, 1.2600024e+00, 1.4400012e+00, 1.5000000e+00, 1.4399988e+00, 1.2599976e+00, 9.5999640e-01, 5.3999520e-01}); checkDensity(2, 4, x, new double[]{ 0.00001999994, 1.45800971996, 2.04800255997, 2.05799803998, 1.72799567999, 1.24999500000, 0.76799552000, 0.37799676001, 0.12799824001, 0.01799948000}); checkDensity(4.0, 0.1, x, new double[]{ 1.193501074e-19, 1.312253162e-04, 1.167181580e-03, 4.442248535e-03, 1.209679109e-02, 2.783958903e-02, 5.880649983e-02, 1.209791638e-01, 2.601171405e-01, 6.911229392e-01}); checkDensity(4.0, 0.5, x, new double[]{ 1.093750547e-18, 1.152948959e-03, 9.782950259e-03, 3.529697305e-02, 9.037036449e-02, 1.933508639e-01, 3.735463833e-01, 6.849425461e-01, 1.252205894e+00, 2.52142232809988}); checkDensity(4, 1, x, new double[]{ 4.000000000e-18, 4.000120001e-03, 3.200048000e-02, 1.080010800e-01, 2.560019200e-01, 5.000030000e-01, 8.640043200e-01, 1.372005880e+00, 2.048007680e+00, 2.916009720e+00}); checkDensity(4, 2, x, new double[]{ 1.999998000e-17, 1.800052000e-02, 1.280017600e-01, 3.780032400e-01, 7.680044800e-01, 1.250005000e+00, 1.728004320e+00, 2.058001960e+00, 2.047997440e+00, 1.457990280e+00}); checkDensity(4, 4, x, new double[]{ 1.399995800e-16, 1.020627216e-01, 5.734464512e-01, 1.296547409e+00, 1.935364838e+00, 2.187500000e+00, 1.935355162e+00, 1.296532591e+00, 5.734335488e-01, 1.020572784e-01}); } @SuppressWarnings("boxing") private void checkDensity(double alpha, double beta, double[] x, double[] expected) { BetaDistribution d = new BetaDistribution(alpha, beta); for (int i = 0; i < x.length; i++) { Assert.assertEquals(String.format("density at x=%.1f for alpha=%.1f, beta=%.1f", x[i], alpha, beta), expected[i], d.density(x[i]), 1e-5); } } @Test public void testMoments() { final double tol = 1e-9; BetaDistribution dist; dist = new BetaDistribution(1, 1); Assert.assertEquals(dist.getNumericalMean(), 0.5, tol); Assert.assertEquals(dist.getNumericalVariance(), 1.0 / 12.0, tol); dist = new BetaDistribution(2, 5); Assert.assertEquals(dist.getNumericalMean(), 2.0 / 7.0, tol); Assert.assertEquals(dist.getNumericalVariance(), 10.0 / (49.0 * 8.0), tol); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */ package org.apache.commons.math3.distribution; import org.junit.Assert; import org.junit.Test; /** * Test cases for BinomialDistribution. Extends IntegerDistributionAbstractTest. * See class javadoc for IntegerDistributionAbstractTest for details. * * @version $Id$ */ public class BinomialDistributionTest extends IntegerDistributionAbstractTest { // -------------- Implementations for abstract methods // ----------------------- /** Creates the default discrete distribution instance to use in tests. */ @Override public IntegerDistribution makeDistribution() { return new BinomialDistribution(10, 0.70); } /** Creates the default probability density test input values */ @Override public int[] makeDensityTestPoints() { return new int[] { -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 }; } /** Creates the default probability density test expected values */ @Override public double[] makeDensityTestValues() { return new double[] { 0d, 0.0000059049d, 0.000137781d, 0.0014467d, 0.00900169d, 0.0367569d, 0.102919d, 0.200121d, 0.266828d, 0.233474d, 0.121061d, 0.0282475d, 0d }; } /** Creates the default cumulative probability density test input values */ @Override public int[] makeCumulativeTestPoints() { return makeDensityTestPoints(); } /** Creates the default cumulative probability density test expected values */ @Override public double[] makeCumulativeTestValues() { return new double[] { 0d, 0.0000d, 0.0001d, 0.0016d, 0.0106d, 0.0473d, 0.1503d, 0.3504d, 0.6172d, 0.8507d, 0.9718d, 1d, 1d }; } /** Creates the default inverse cumulative probability test input values */ @Override public double[] makeInverseCumulativeTestPoints() { return new double[] { 0, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d, 0.990d, 0.975d, 0.950d, 0.900d, 1 }; } /** * Creates the default inverse cumulative probability density test expected * values */ @Override public int[] makeInverseCumulativeTestValues() { return new int[] { 0, 2, 3, 4, 5, 5, 10, 10, 10, 9, 9, 10 }; } // ----------------- Additional test cases --------------------------------- /** Test degenerate case p = 0 */ @Test public void testDegenerate0() { BinomialDistribution dist = new BinomialDistribution(5, 0.0d); setDistribution(dist); setCumulativeTestPoints(new int[] { -1, 0, 1, 5, 10 }); setCumulativeTestValues(new double[] { 0d, 1d, 1d, 1d, 1d }); setDensityTestPoints(new int[] { -1, 0, 1, 10, 11 }); setDensityTestValues(new double[] { 0d, 1d, 0d, 0d, 0d }); setInverseCumulativeTestPoints(new double[] { 0.1d, 0.5d }); setInverseCumulativeTestValues(new int[] { 0, 0 }); verifyDensities(); verifyCumulativeProbabilities(); verifyInverseCumulativeProbabilities(); Assert.assertEquals(dist.getSupportLowerBound(), 0); Assert.assertEquals(dist.getSupportUpperBound(), 0); } /** Test degenerate case p = 1 */ @Test public void testDegenerate1() { BinomialDistribution dist = new BinomialDistribution(5, 1.0d); setDistribution(dist); setCumulativeTestPoints(new int[] { -1, 0, 1, 2, 5, 10 }); setCumulativeTestValues(new double[] { 0d, 0d, 0d, 0d, 1d, 1d }); setDensityTestPoints(new int[] { -1, 0, 1, 2, 5, 10 }); setDensityTestValues(new double[] { 0d, 0d, 0d, 0d, 1d, 0d }); setInverseCumulativeTestPoints(new double[] { 0.1d, 0.5d }); setInverseCumulativeTestValues(new int[] { 5, 5 }); verifyDensities(); verifyCumulativeProbabilities(); verifyInverseCumulativeProbabilities(); Assert.assertEquals(dist.getSupportLowerBound(), 5); Assert.assertEquals(dist.getSupportUpperBound(), 5); } @Test public void testMoments() { final double tol = 1e-9; BinomialDistribution dist; dist = new BinomialDistribution(10, 0.5); Assert.assertEquals(dist.getNumericalMean(), 10d * 0.5d, tol); Assert.assertEquals(dist.getNumericalVariance(), 10d * 0.5d * 0.5d, tol); dist = new BinomialDistribution(30, 0.3); Assert.assertEquals(dist.getNumericalMean(), 30d * 0.3d, tol); Assert.assertEquals(dist.getNumericalVariance(), 30d * 0.3d * (1d - 0.3d), tol); } @Test public void testMath718() { // for large trials the evaluation of ContinuedFraction was inaccurate // do a sweep over several large trials to test if the current implementation is // numerically stable. for (int trials = 500000; trials < 20000000; trials += 100000) { BinomialDistribution dist = new BinomialDistribution(trials, 0.5); int p = dist.inverseCumulativeProbability(0.5); Assert.assertEquals(trials / 2, p); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.distribution; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.junit.Assert; import org.junit.Test; /** * Test cases for CauchyDistribution. * Extends ContinuousDistributionAbstractTest. See class javadoc for * ContinuousDistributionAbstractTest for details. * * @version $Id$ */ public class CauchyDistributionTest extends RealDistributionAbstractTest { // --------------------- Override tolerance -------------- protected double defaultTolerance = NormalDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY; @Override public void setUp() { super.setUp(); setTolerance(defaultTolerance); } //-------------- Implementations for abstract methods ----------------------- /** Creates the default continuous distribution instance to use in tests. */ @Override public CauchyDistribution makeDistribution() { return new CauchyDistribution(1.2, 2.1); } /** Creates the default cumulative probability distribution test input values */ @Override public double[] makeCumulativeTestPoints() { // quantiles computed using R 2.9.2 return new double[] {-667.24856187, -65.6230835029, -25.4830299460, -12.0588781808, -5.26313542807, 669.64856187, 68.0230835029, 27.8830299460, 14.4588781808, 7.66313542807}; } /** Creates the default cumulative probability density test expected values */ @Override public double[] makeCumulativeTestValues() { return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999, 0.990, 0.975, 0.950, 0.900}; } /** Creates the default probability density test expected values */ @Override public double[] makeDensityTestValues() { return new double[] {1.49599158008e-06, 0.000149550440335, 0.000933076881878, 0.00370933207799, 0.0144742330437, 1.49599158008e-06, 0.000149550440335, 0.000933076881878, 0.00370933207799, 0.0144742330437}; } //---------------------------- Additional test cases ------------------------- @Test public void testInverseCumulativeProbabilityExtremes() { setInverseCumulativeTestPoints(new double[] {0.0, 1.0}); setInverseCumulativeTestValues( new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY}); verifyInverseCumulativeProbabilities(); } @Test public void testMedian() { CauchyDistribution distribution = (CauchyDistribution) getDistribution(); Assert.assertEquals(1.2, distribution.getMedian(), 0.0); } @Test public void testScale() { CauchyDistribution distribution = (CauchyDistribution) getDistribution(); Assert.assertEquals(2.1, distribution.getScale(), 0.0); } @Test public void testPreconditions() { try { new CauchyDistribution(0, 0); Assert.fail("Cannot have zero scale"); } catch (NotStrictlyPositiveException ex) { // Expected. } try { new CauchyDistribution(0, -1); Assert.fail("Cannot have negative scale"); } catch (NotStrictlyPositiveException ex) { // Expected. } } @Test public void testMoments() { CauchyDistribution dist; dist = new CauchyDistribution(10.2, 0.15); Assert.assertTrue(Double.isNaN(dist.getNumericalMean())); Assert.assertTrue(Double.isNaN(dist.getNumericalVariance())); dist = new CauchyDistribution(23.12, 2.12); Assert.assertTrue(Double.isNaN(dist.getNumericalMean())); Assert.assertTrue(Double.isNaN(dist.getNumericalVariance())); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.distribution; import org.junit.Assert; import org.junit.Test; /** * Test cases for {@link ChiSquaredDistribution}. * * @see RealDistributionAbstractTest * @version $Id$ */ public class ChiSquaredDistributionTest extends RealDistributionAbstractTest { //-------------- Implementations for abstract methods ----------------------- /** Creates the default continuous distribution instance to use in tests. */ @Override public ChiSquaredDistribution makeDistribution() { return new ChiSquaredDistribution(5.0); } /** Creates the default cumulative probability distribution test input values */ @Override public double[] makeCumulativeTestPoints() { // quantiles computed using R version 2.9.2 return new double[] {0.210212602629, 0.554298076728, 0.831211613487, 1.14547622606, 1.61030798696, 20.5150056524, 15.0862724694, 12.8325019940, 11.0704976935, 9.23635689978}; } /** Creates the default cumulative probability density test expected values */ @Override public double[] makeCumulativeTestValues() { return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999, 0.990, 0.975, 0.950, 0.900}; } /** Creates the default inverse cumulative probability test input values */ @Override public double[] makeInverseCumulativeTestPoints() { return new double[] {0, 0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d, 0.990d, 0.975d, 0.950d, 0.900d, 1}; } /** Creates the default inverse cumulative probability density test expected values */ @Override public double[] makeInverseCumulativeTestValues() { return new double[] {0, 0.210212602629, 0.554298076728, 0.831211613487, 1.14547622606, 1.61030798696, 20.5150056524, 15.0862724694, 12.8325019940, 11.0704976935, 9.23635689978, Double.POSITIVE_INFINITY}; } /** Creates the default probability density test expected values */ @Override public double[] makeDensityTestValues() { return new double[] {0.0115379817652, 0.0415948507811, 0.0665060119842, 0.0919455953114, 0.121472591024, 0.000433630076361, 0.00412780610309, 0.00999340341045, 0.0193246438937, 0.0368460089216}; } // --------------------- Override tolerance -------------- @Override public void setUp() { super.setUp(); setTolerance(1e-9); } //---------------------------- Additional test cases ------------------------- @Test public void testSmallDf() { setDistribution(new ChiSquaredDistribution(0.1d)); setTolerance(1E-4); // quantiles computed using R version 1.8.1 (linux version) setCumulativeTestPoints(new double[] {1.168926E-60, 1.168926E-40, 1.063132E-32, 1.144775E-26, 1.168926E-20, 5.472917, 2.175255, 1.13438, 0.5318646, 0.1526342}); setInverseCumulativeTestValues(getCumulativeTestPoints()); setInverseCumulativeTestPoints(getCumulativeTestValues()); verifyCumulativeProbabilities(); verifyInverseCumulativeProbabilities(); } @Test public void testDfAccessors() { ChiSquaredDistribution distribution = (ChiSquaredDistribution) getDistribution(); Assert.assertEquals(5d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE); } @Test public void testDensity() { double[] x = new double[]{-0.1, 1e-6, 0.5, 1, 2, 5}; //R 2.5: print(dchisq(x, df=1), digits=10) checkDensity(1, x, new double[]{0.00000000000, 398.94208093034, 0.43939128947, 0.24197072452, 0.10377687436, 0.01464498256}); //R 2.5: print(dchisq(x, df=0.1), digits=10) checkDensity(0.1, x, new double[]{0.000000000e+00, 2.486453997e+04, 7.464238732e-02, 3.009077718e-02, 9.447299159e-03, 8.827199396e-04}); //R 2.5: print(dchisq(x, df=2), digits=10) checkDensity(2, x, new double[]{0.00000000000, 0.49999975000, 0.38940039154, 0.30326532986, 0.18393972059, 0.04104249931}); //R 2.5: print(dchisq(x, df=10), digits=10) checkDensity(10, x, new double[]{0.000000000e+00, 1.302082682e-27, 6.337896998e-05, 7.897534632e-04, 7.664155024e-03, 6.680094289e-02}); } private void checkDensity(double df, double[] x, double[] expected) { ChiSquaredDistribution d = new ChiSquaredDistribution(df); for (int i = 0; i < x.length; i++) { Assert.assertEquals(expected[i], d.density(x[i]), 1e-5); } } @Test public void testMoments() { final double tol = 1e-9; ChiSquaredDistribution dist; dist = new ChiSquaredDistribution(1500); Assert.assertEquals(dist.getNumericalMean(), 1500, tol); Assert.assertEquals(dist.getNumericalVariance(), 3000, tol); dist = new ChiSquaredDistribution(1.12); Assert.assertEquals(dist.getNumericalMean(), 1.12, tol); Assert.assertEquals(dist.getNumericalVariance(), 2.24, tol); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.distribution; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MathArithmeticException; import org.apache.commons.math3.exception.NotANumberException; import org.apache.commons.math3.exception.NotFiniteNumberException; import org.apache.commons.math3.exception.NotPositiveException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * Test class for {@link EnumeratedIntegerDistribution}. * * @version $Id$ */ public class EnumeratedIntegerDistributionTest { /** * The distribution object used for testing. */ private final EnumeratedIntegerDistribution testDistribution; /** * Creates the default distribution object used for testing. */ public EnumeratedIntegerDistributionTest() { // Non-sorted singleton array with duplicates should be allowed. // Values with zero-probability do not extend the support. testDistribution = new EnumeratedIntegerDistribution( new int[]{3, -1, 3, 7, -2, 8}, new double[]{0.2, 0.2, 0.3, 0.3, 0.0, 0.0}); } /** * Tests if the EnumeratedIntegerDistribution constructor throws * exceptions for invalid data. */ @Test public void testExceptions() { EnumeratedIntegerDistribution invalid = null; try { new EnumeratedIntegerDistribution(new int[]{1, 2}, new double[]{0.0}); Assert.fail("Expected DimensionMismatchException"); } catch (DimensionMismatchException e) { } try { new EnumeratedIntegerDistribution(new int[]{1, 2}, new double[]{0.0, -1.0}); Assert.fail("Expected NotPositiveException"); } catch (NotPositiveException e) { } try { new EnumeratedIntegerDistribution(new int[]{1, 2}, new double[]{0.0, 0.0}); Assert.fail("Expected MathArithmeticException"); } catch (MathArithmeticException e) { } try { new EnumeratedIntegerDistribution(new int[]{1, 2}, new double[]{0.0, Double.NaN}); Assert.fail("Expected NotANumberException"); } catch (NotANumberException e) { } try { new EnumeratedIntegerDistribution(new int[]{1, 2}, new double[]{0.0, Double.POSITIVE_INFINITY}); Assert.fail("Expected NotFiniteNumberException"); } catch (NotFiniteNumberException e) { } Assert.assertNull("Expected non-initialized DiscreteRealDistribution", invalid); } /** * Tests if the distribution returns proper probability values. */ @Test public void testProbability() { int[] points = new int[]{-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8}; double[] results = new double[]{0, 0.2, 0, 0, 0, 0.5, 0, 0, 0, 0.3, 0}; for (int p = 0; p < points.length; p++) { double probability = testDistribution.probability(points[p]); Assert.assertEquals(results[p], probability, 0.0); } } /** * Tests if the distribution returns proper cumulative probability values. */ @Test public void testCumulativeProbability() { int[] points = new int[]{-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8}; double[] results = new double[]{0, 0.2, 0.2, 0.2, 0.2, 0.7, 0.7, 0.7, 0.7, 1.0, 1.0}; for (int p = 0; p < points.length; p++) { double probability = testDistribution.cumulativeProbability(points[p]); Assert.assertEquals(results[p], probability, 1e-10); } } /** * Tests if the distribution returns proper mean value. */ @Test public void testGetNumericalMean() { Assert.assertEquals(3.4, testDistribution.getNumericalMean(), 1e-10); } /** * Tests if the distribution returns proper variance. */ @Test public void testGetNumericalVariance() { Assert.assertEquals(7.84, testDistribution.getNumericalVariance(), 1e-10); } /** * Tests if the distribution returns proper lower bound. */ @Test public void testGetSupportLowerBound() { Assert.assertEquals(-1, testDistribution.getSupportLowerBound()); } /** * Tests if the distribution returns proper upper bound. */ @Test public void testGetSupportUpperBound() { Assert.assertEquals(7, testDistribution.getSupportUpperBound()); } /** * Tests if the distribution returns properly that the support is connected. */ @Test public void testIsSupportConnected() { Assert.assertTrue(testDistribution.isSupportConnected()); } /** * Tests sampling. */ @Test public void testSample() { final int n = 1000000; testDistribution.reseedRandomGenerator(-334759360); // fixed seed final int[] samples = testDistribution.sample(n); Assert.assertEquals(n, samples.length); double sum = 0; double sumOfSquares = 0; for (int i = 0; i < samples.length; i++) { sum += samples[i]; sumOfSquares += samples[i] * samples[i]; } Assert.assertEquals(testDistribution.getNumericalMean(), sum / n, 1e-2); Assert.assertEquals(testDistribution.getNumericalVariance(), sumOfSquares / n - FastMath.pow(sum / n, 2), 1e-2); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.distribution; import java.util.ArrayList; import java.util.List; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MathArithmeticException; import org.apache.commons.math3.exception.NotANumberException; import org.apache.commons.math3.exception.NotFiniteNumberException; import org.apache.commons.math3.exception.NotPositiveException; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.util.Pair; import org.junit.Assert; import org.junit.Test; /** * Test class for {@link EnumeratedRealDistribution}. * * @version $Id$ */ public class EnumeratedRealDistributionTest { /** * The distribution object used for testing. */ private final EnumeratedRealDistribution testDistribution; /** * Creates the default distribution object used for testing. */ public EnumeratedRealDistributionTest() { // Non-sorted singleton array with duplicates should be allowed. // Values with zero-probability do not extend the support. testDistribution = new EnumeratedRealDistribution( new double[]{3.0, -1.0, 3.0, 7.0, -2.0, 8.0}, new double[]{0.2, 0.2, 0.3, 0.3, 0.0, 0.0}); } /** * Tests if the {@link EnumeratedRealDistribution} constructor throws * exceptions for invalid data. */ @Test public void testExceptions() { EnumeratedRealDistribution invalid = null; try { invalid = new EnumeratedRealDistribution(new double[]{1.0, 2.0}, new double[]{0.0}); Assert.fail("Expected DimensionMismatchException"); } catch (DimensionMismatchException e) { } try{ invalid = new EnumeratedRealDistribution(new double[]{1.0, 2.0}, new double[]{0.0, -1.0}); Assert.fail("Expected NotPositiveException"); } catch (NotPositiveException e) { } try { invalid = new EnumeratedRealDistribution(new double[]{1.0, 2.0}, new double[]{0.0, 0.0}); Assert.fail("Expected MathArithmeticException"); } catch (MathArithmeticException e) { } try { invalid = new EnumeratedRealDistribution(new double[]{1.0, 2.0}, new double[]{0.0, Double.NaN}); Assert.fail("Expected NotANumberException"); } catch (NotANumberException e) { } try { invalid = new EnumeratedRealDistribution(new double[]{1.0, 2.0}, new double[]{0.0, Double.POSITIVE_INFINITY}); Assert.fail("Expected NotFiniteNumberException"); } catch (NotFiniteNumberException e) { } Assert.assertNull("Expected non-initialized DiscreteRealDistribution", invalid); } /** * Tests if the distribution returns proper probability values. */ @Test public void testProbability() { double[] points = new double[]{-2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0}; double[] results = new double[]{0, 0.2, 0, 0, 0, 0.5, 0, 0, 0, 0.3, 0}; for (int p = 0; p < points.length; p++) { double density = testDistribution.probability(points[p]); Assert.assertEquals(results[p], density, 0.0); } } /** * Tests if the distribution returns proper density values. */ @Test public void testDensity() { double[] points = new double[]{-2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0}; double[] results = new double[]{0, 0.2, 0, 0, 0, 0.5, 0, 0, 0, 0.3, 0}; for (int p = 0; p < points.length; p++) { double density = testDistribution.density(points[p]); Assert.assertEquals(results[p], density, 0.0); } } /** * Tests if the distribution returns proper cumulative probability values. */ @Test public void testCumulativeProbability() { double[] points = new double[]{-2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0}; double[] results = new double[]{0, 0.2, 0.2, 0.2, 0.2, 0.7, 0.7, 0.7, 0.7, 1.0, 1.0}; for (int p = 0; p < points.length; p++) { double probability = testDistribution.cumulativeProbability(points[p]); Assert.assertEquals(results[p], probability, 1e-10); } } /** * Tests if the distribution returns proper mean value. */ @Test public void testGetNumericalMean() { Assert.assertEquals(3.4, testDistribution.getNumericalMean(), 1e-10); } /** * Tests if the distribution returns proper variance. */ @Test public void testGetNumericalVariance() { Assert.assertEquals(7.84, testDistribution.getNumericalVariance(), 1e-10); } /** * Tests if the distribution returns proper lower bound. */ @Test public void testGetSupportLowerBound() { Assert.assertEquals(-1, testDistribution.getSupportLowerBound(), 0); } /** * Tests if the distribution returns proper upper bound. */ @Test public void testGetSupportUpperBound() { Assert.assertEquals(7, testDistribution.getSupportUpperBound(), 0); } /** * Tests if the distribution returns properly that the support includes the * lower bound. */ @Test public void testIsSupportLowerBoundInclusive() { Assert.assertTrue(testDistribution.isSupportLowerBoundInclusive()); } /** * Tests if the distribution returns properly that the support includes the * upper bound. */ @Test public void testIsSupportUpperBoundInclusive() { Assert.assertTrue(testDistribution.isSupportUpperBoundInclusive()); } /** * Tests if the distribution returns properly that the support is connected. */ @Test public void testIsSupportConnected() { Assert.assertTrue(testDistribution.isSupportConnected()); } /** * Tests sampling. */ @Test public void testSample() { final int n = 1000000; testDistribution.reseedRandomGenerator(-334759360); // fixed seed final double[] samples = testDistribution.sample(n); Assert.assertEquals(n, samples.length); double sum = 0; double sumOfSquares = 0; for (int i = 0; i < samples.length; i++) { sum += samples[i]; sumOfSquares += samples[i] * samples[i]; } Assert.assertEquals(testDistribution.getNumericalMean(), sum / n, 1e-2); Assert.assertEquals(testDistribution.getNumericalVariance(), sumOfSquares / n - FastMath.pow(sum / n, 2), 1e-2); } @Test public void testIssue942() { List<Pair<Object,Double>> list = new ArrayList<Pair<Object, Double>>(); list.add(new Pair<Object, Double>(new Object() {}, new Double(0))); list.add(new Pair<Object, Double>(new Object() {}, new Double(1))); Assert.assertEquals(1, new EnumeratedDistribution<Object>(list).sample(1).length); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.distribution; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.util.Precision; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.junit.Assert; import org.junit.Test; /** * Test cases for ExponentialDistribution. * Extends ContinuousDistributionAbstractTest. See class javadoc for * ContinuousDistributionAbstractTest for details. * * @version $Id$ */ public class ExponentialDistributionTest extends RealDistributionAbstractTest { // --------------------- Override tolerance -------------- @Override public void setUp() { super.setUp(); setTolerance(1E-9); } //-------------- Implementations for abstract methods ----------------------- /** Creates the default continuous distribution instance to use in tests. */ @Override public ExponentialDistribution makeDistribution() { return new ExponentialDistribution(5.0); } /** Creates the default cumulative probability distribution test input values */ @Override public double[] makeCumulativeTestPoints() { // quantiles computed using R version 2.9.2 return new double[] {0.00500250166792, 0.0502516792675, 0.126589039921, 0.256466471938, 0.526802578289, 34.5387763949, 23.0258509299, 18.4443972706, 14.9786613678, 11.5129254650}; } /** Creates the default cumulative probability density test expected values */ @Override public double[] makeCumulativeTestValues() { return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999, 0.990, 0.975, 0.950, 0.900}; } /** Creates the default probability density test expected values */ @Override public double[] makeDensityTestValues() { return new double[] {0.1998, 0.198, 0.195, 0.19, 0.18, 0.000200000000000, 0.00200000000002, 0.00499999999997, 0.00999999999994, 0.0199999999999}; } //------------ Additional tests ------------------------------------------- @Test public void testCumulativeProbabilityExtremes() { setCumulativeTestPoints(new double[] {-2, 0}); setCumulativeTestValues(new double[] {0, 0}); verifyCumulativeProbabilities(); } @Test public void testInverseCumulativeProbabilityExtremes() { setInverseCumulativeTestPoints(new double[] {0, 1}); setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY}); verifyInverseCumulativeProbabilities(); } @Test public void testCumulativeProbability2() { double actual = getDistribution().cumulativeProbability(0.25, 0.75); Assert.assertEquals(0.0905214, actual, 10e-4); } @Test public void testDensity() { ExponentialDistribution d1 = new ExponentialDistribution(1); Assert.assertTrue(Precision.equals(0.0, d1.density(-1e-9), 1)); Assert.assertTrue(Precision.equals(1.0, d1.density(0.0), 1)); Assert.assertTrue(Precision.equals(0.0, d1.density(1000.0), 1)); Assert.assertTrue(Precision.equals(FastMath.exp(-1), d1.density(1.0), 1)); Assert.assertTrue(Precision.equals(FastMath.exp(-2), d1.density(2.0), 1)); ExponentialDistribution d2 = new ExponentialDistribution(3); Assert.assertTrue(Precision.equals(1/3.0, d2.density(0.0), 1)); // computed using print(dexp(1, rate=1/3), digits=10) in R 2.5 Assert.assertEquals(0.2388437702, d2.density(1.0), 1e-8); // computed using print(dexp(2, rate=1/3), digits=10) in R 2.5 Assert.assertEquals(0.1711390397, d2.density(2.0), 1e-8); } @Test public void testMeanAccessors() { ExponentialDistribution distribution = (ExponentialDistribution) getDistribution(); Assert.assertEquals(5d, distribution.getMean(), Double.MIN_VALUE); } @Test(expected=NotStrictlyPositiveException.class) public void testPreconditions() { new ExponentialDistribution(0); } @Test public void testMoments() { final double tol = 1e-9; ExponentialDistribution dist; dist = new ExponentialDistribution(11d); Assert.assertEquals(dist.getNumericalMean(), 11d, tol); Assert.assertEquals(dist.getNumericalVariance(), 11d * 11d, tol); dist = new ExponentialDistribution(10.5d); Assert.assertEquals(dist.getNumericalMean(), 10.5d, tol); Assert.assertEquals(dist.getNumericalVariance(), 10.5d * 10.5d, tol); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.distribution; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.junit.Assert; import org.junit.Test; /** * Test cases for FDistribution. * Extends ContinuousDistributionAbstractTest. See class javadoc for * ContinuousDistributionAbstractTest for details. * * @version $Id$ */ public class FDistributionTest extends RealDistributionAbstractTest { //-------------- Implementations for abstract methods ----------------------- /** Creates the default continuous distribution instance to use in tests. */ @Override public FDistribution makeDistribution() { return new FDistribution(5.0, 6.0); } /** Creates the default cumulative probability distribution test input values */ @Override public double[] makeCumulativeTestPoints() { // quantiles computed using R version 2.9.2 return new double[] {0.0346808448626, 0.0937009113303, 0.143313661184, 0.202008445998, 0.293728320107, 20.8026639595, 8.74589525602, 5.98756512605, 4.38737418741, 3.10751166664}; } /** Creates the default cumulative probability density test expected values */ @Override public double[] makeCumulativeTestValues() { return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999, 0.990, 0.975, 0.950, 0.900}; } /** Creates the default probability density test expected values */ @Override public double[] makeDensityTestValues() { return new double[] {0.0689156576706, 0.236735653193, 0.364074131941, 0.481570789649, 0.595880479994, 0.000133443915657, 0.00286681303403, 0.00969192007502, 0.0242883861471, 0.0605491314658}; } // --------------------- Override tolerance -------------- @Override public void setUp() { super.setUp(); setTolerance(1e-9); } //---------------------------- Additional test cases ------------------------- @Test public void testCumulativeProbabilityExtremes() { setCumulativeTestPoints(new double[] {-2, 0}); setCumulativeTestValues(new double[] {0, 0}); verifyCumulativeProbabilities(); } @Test public void testInverseCumulativeProbabilityExtremes() { setInverseCumulativeTestPoints(new double[] {0, 1}); setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY}); verifyInverseCumulativeProbabilities(); } @Test public void testDfAccessors() { FDistribution dist = (FDistribution) getDistribution(); Assert.assertEquals(5d, dist.getNumeratorDegreesOfFreedom(), Double.MIN_VALUE); Assert.assertEquals(6d, dist.getDenominatorDegreesOfFreedom(), Double.MIN_VALUE); } @Test public void testPreconditions() { try { new FDistribution(0, 1); Assert.fail("Expecting NotStrictlyPositiveException for df = 0"); } catch (NotStrictlyPositiveException ex) { // Expected. } try { new FDistribution(1, 0); Assert.fail("Expecting NotStrictlyPositiveException for df = 0"); } catch (NotStrictlyPositiveException ex) { // Expected. } } @Test public void testLargeDegreesOfFreedom() { FDistribution fd = new FDistribution(100000, 100000); double p = fd.cumulativeProbability(.999); double x = fd.inverseCumulativeProbability(p); Assert.assertEquals(.999, x, 1.0e-5); } @Test public void testSmallDegreesOfFreedom() { FDistribution fd = new FDistribution(1, 1); double p = fd.cumulativeProbability(0.975); double x = fd.inverseCumulativeProbability(p); Assert.assertEquals(0.975, x, 1.0e-5); fd = new FDistribution(1, 2); p = fd.cumulativeProbability(0.975); x = fd.inverseCumulativeProbability(p); Assert.assertEquals(0.975, x, 1.0e-5); } @Test public void testMoments() { final double tol = 1e-9; FDistribution dist; dist = new FDistribution(1, 2); Assert.assertTrue(Double.isNaN(dist.getNumericalMean())); Assert.assertTrue(Double.isNaN(dist.getNumericalVariance())); dist = new FDistribution(1, 3); Assert.assertEquals(dist.getNumericalMean(), 3d / (3d - 2d), tol); Assert.assertTrue(Double.isNaN(dist.getNumericalVariance())); dist = new FDistribution(1, 5); Assert.assertEquals(dist.getNumericalMean(), 5d / (5d - 2d), tol); Assert.assertEquals(dist.getNumericalVariance(), (2d * 5d * 5d * 4d) / 9d, tol); } @Test public void testMath785() { // this test was failing due to inaccurate results from ContinuedFraction. try { double prob = 0.01; FDistribution f = new FDistribution(200000, 200000); double result = f.inverseCumulativeProbability(prob); Assert.assertTrue(result < 1.0); } catch (Exception e) { Assert.fail("Failing to calculate inverse cumulative probability"); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.distribution; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.apache.commons.math3.special.Gamma; import org.apache.commons.math3.stat.descriptive.SummaryStatistics; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * Test cases for GammaDistribution. * Extends ContinuousDistributionAbstractTest. See class javadoc for * ContinuousDistributionAbstractTest for details. * * @version $Id$ */ public class GammaDistributionTest extends RealDistributionAbstractTest { //-------------- Implementations for abstract methods ----------------------- /** Creates the default continuous distribution instance to use in tests. */ @Override public GammaDistribution makeDistribution() { return new GammaDistribution(4d, 2d); } /** Creates the default cumulative probability distribution test input values */ @Override public double[] makeCumulativeTestPoints() { // quantiles computed using R version 2.9.2 return new double[] {0.857104827257, 1.64649737269, 2.17973074725, 2.7326367935, 3.48953912565, 26.1244815584, 20.0902350297, 17.5345461395, 15.5073130559, 13.3615661365}; } /** Creates the default cumulative probability density test expected values */ @Override public double[] makeCumulativeTestValues() { return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999, 0.990, 0.975, 0.950, 0.900}; } /** Creates the default probability density test expected values */ @Override public double[] makeDensityTestValues() { return new double[] {0.00427280075546, 0.0204117166709, 0.0362756163658, 0.0542113174239, 0.0773195272491, 0.000394468852816, 0.00366559696761, 0.00874649473311, 0.0166712508128, 0.0311798227954}; } // --------------------- Override tolerance -------------- @Override public void setUp() { super.setUp(); setTolerance(1e-9); } //---------------------------- Additional test cases ------------------------- @Test public void testParameterAccessors() { GammaDistribution distribution = (GammaDistribution) getDistribution(); Assert.assertEquals(4d, distribution.getAlpha(), 0); Assert.assertEquals(2d, distribution.getBeta(), 0); } @Test public void testPreconditions() { try { new GammaDistribution(0, 1); Assert.fail("Expecting NotStrictlyPositiveException for alpha = 0"); } catch (NotStrictlyPositiveException ex) { // Expected. } try { new GammaDistribution(1, 0); Assert.fail("Expecting NotStrictlyPositiveException for alpha = 0"); } catch (NotStrictlyPositiveException ex) { // Expected. } } @Test public void testProbabilities() { testProbability(-1.000, 4.0, 2.0, .0000); testProbability(15.501, 4.0, 2.0, .9499); testProbability(0.504, 4.0, 1.0, .0018); testProbability(10.011, 1.0, 2.0, .9933); testProbability(5.000, 2.0, 2.0, .7127); } @Test public void testValues() { testValue(15.501, 4.0, 2.0, .9499); testValue(0.504, 4.0, 1.0, .0018); testValue(10.011, 1.0, 2.0, .9933); testValue(5.000, 2.0, 2.0, .7127); } private void testProbability(double x, double a, double b, double expected) { GammaDistribution distribution = new GammaDistribution( a, b ); double actual = distribution.cumulativeProbability(x); Assert.assertEquals("probability for " + x, expected, actual, 10e-4); } private void testValue(double expected, double a, double b, double p) { GammaDistribution distribution = new GammaDistribution( a, b ); double actual = distribution.inverseCumulativeProbability(p); Assert.assertEquals("critical value for " + p, expected, actual, 10e-4); } @Test public void testDensity() { double[] x = new double[]{-0.1, 1e-6, 0.5, 1, 2, 5}; // R2.5: print(dgamma(x, shape=1, rate=1), digits=10) checkDensity(1, 1, x, new double[]{0.000000000000, 0.999999000001, 0.606530659713, 0.367879441171, 0.135335283237, 0.006737946999}); // R2.5: print(dgamma(x, shape=2, rate=1), digits=10) checkDensity(2, 1, x, new double[]{0.000000000000, 0.000000999999, 0.303265329856, 0.367879441171, 0.270670566473, 0.033689734995}); // R2.5: print(dgamma(x, shape=4, rate=1), digits=10) checkDensity(4, 1, x, new double[]{0.000000000e+00, 1.666665000e-19, 1.263605541e-02, 6.131324020e-02, 1.804470443e-01, 1.403738958e-01}); // R2.5: print(dgamma(x, shape=4, rate=10), digits=10) checkDensity(4, 10, x, new double[]{0.000000000e+00, 1.666650000e-15, 1.403738958e+00, 7.566654960e-02, 2.748204830e-05, 4.018228850e-17}); // R2.5: print(dgamma(x, shape=.1, rate=10), digits=10) checkDensity(0.1, 10, x, new double[]{0.000000000e+00, 3.323953832e+04, 1.663849010e-03, 6.007786726e-06, 1.461647647e-10, 5.996008322e-24}); // R2.5: print(dgamma(x, shape=.1, rate=20), digits=10) checkDensity(0.1, 20, x, new double[]{0.000000000e+00, 3.562489883e+04, 1.201557345e-05, 2.923295295e-10, 3.228910843e-19, 1.239484589e-45}); // R2.5: print(dgamma(x, shape=.1, rate=4), digits=10) checkDensity(0.1, 4, x, new double[]{0.000000000e+00, 3.032938388e+04, 3.049322494e-02, 2.211502311e-03, 2.170613371e-05, 5.846590589e-11}); // R2.5: print(dgamma(x, shape=.1, rate=1), digits=10) checkDensity(0.1, 1, x, new double[]{0.000000000e+00, 2.640334143e+04, 1.189704437e-01, 3.866916944e-02, 7.623306235e-03, 1.663849010e-04}); } private void checkDensity(double alpha, double rate, double[] x, double[] expected) { GammaDistribution d = new GammaDistribution(alpha, 1 / rate); for (int i = 0; i < x.length; i++) { Assert.assertEquals(expected[i], d.density(x[i]), 1e-5); } } @Test public void testInverseCumulativeProbabilityExtremes() { setInverseCumulativeTestPoints(new double[] {0, 1}); setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY}); verifyInverseCumulativeProbabilities(); } @Test public void testMoments() { final double tol = 1e-9; GammaDistribution dist; dist = new GammaDistribution(1, 2); Assert.assertEquals(dist.getNumericalMean(), 2, tol); Assert.assertEquals(dist.getNumericalVariance(), 4, tol); dist = new GammaDistribution(1.1, 4.2); Assert.assertEquals(dist.getNumericalMean(), 1.1d * 4.2d, tol); Assert.assertEquals(dist.getNumericalVariance(), 1.1d * 4.2d * 4.2d, tol); } private static final double HALF_LOG_2_PI = 0.5 * FastMath.log(2.0 * FastMath.PI); public static double logGamma(double x) { /* * This is a copy of * double Gamma.logGamma(double) * prior to MATH-849 */ double ret; if (Double.isNaN(x) || (x <= 0.0)) { ret = Double.NaN; } else { double sum = Gamma.lanczos(x); double tmp = x + Gamma.LANCZOS_G + .5; ret = ((x + .5) * FastMath.log(tmp)) - tmp + HALF_LOG_2_PI + FastMath.log(sum / x); } return ret; } public static double density(final double x, final double shape, final double scale) { /* * This is a copy of * double GammaDistribution.density(double) * prior to MATH-753. */ if (x < 0) { return 0; } return FastMath.pow(x / scale, shape - 1) / scale * FastMath.exp(-x / scale) / FastMath.exp(logGamma(shape)); } /* * MATH-753: large values of x or shape parameter cause density(double) to * overflow. Reference data is generated with the Maxima script * gamma-distribution.mac, which can be found in * src/test/resources/org/apache/commons/math3/distribution. */ private void doTestMath753(final double shape, final double meanNoOF, final double sdNoOF, final double meanOF, final double sdOF, final String resourceName) throws IOException { final GammaDistribution distribution = new GammaDistribution(shape, 1.0); final SummaryStatistics statOld = new SummaryStatistics(); final SummaryStatistics statNewNoOF = new SummaryStatistics(); final SummaryStatistics statNewOF = new SummaryStatistics(); final InputStream resourceAsStream; resourceAsStream = this.getClass().getResourceAsStream(resourceName); Assert.assertNotNull("Could not find resource " + resourceName, resourceAsStream); final BufferedReader in; in = new BufferedReader(new InputStreamReader(resourceAsStream)); try { for (String line = in.readLine(); line != null; line = in.readLine()) { if (line.startsWith("#")) { continue; } final String[] tokens = line.split(", "); Assert.assertTrue("expected two floating-point values", tokens.length == 2); final double x = Double.parseDouble(tokens[0]); final String msg = "x = " + x + ", shape = " + shape + ", scale = 1.0"; final double expected = Double.parseDouble(tokens[1]); final double ulp = FastMath.ulp(expected); final double actualOld = density(x, shape, 1.0); final double actualNew = distribution.density(x); final double errOld, errNew; errOld = FastMath.abs((actualOld - expected) / ulp); errNew = FastMath.abs((actualNew - expected) / ulp); if (Double.isNaN(actualOld) || Double.isInfinite(actualOld)) { Assert.assertFalse(msg, Double.isNaN(actualNew)); Assert.assertFalse(msg, Double.isInfinite(actualNew)); statNewOF.addValue(errNew); } else { statOld.addValue(errOld); statNewNoOF.addValue(errNew); } } if (statOld.getN() != 0) { /* * If no overflow occurs, check that new implementation is * better than old one. */ final StringBuilder sb = new StringBuilder("shape = "); sb.append(shape); sb.append(", scale = 1.0\n"); sb.append("Old implementation\n"); sb.append("------------------\n"); sb.append(statOld.toString()); sb.append("New implementation\n"); sb.append("------------------\n"); sb.append(statNewNoOF.toString()); final String msg = sb.toString(); final double oldMin = statOld.getMin(); final double newMin = statNewNoOF.getMin(); Assert.assertTrue(msg, newMin <= oldMin); final double oldMax = statOld.getMax(); final double newMax = statNewNoOF.getMax(); Assert.assertTrue(msg, newMax <= oldMax); final double oldMean = statOld.getMean(); final double newMean = statNewNoOF.getMean(); Assert.assertTrue(msg, newMean <= oldMean); final double oldSd = statOld.getStandardDeviation(); final double newSd = statNewNoOF.getStandardDeviation(); Assert.assertTrue(msg, newSd <= oldSd); Assert.assertTrue(msg, newMean <= meanNoOF); Assert.assertTrue(msg, newSd <= sdNoOF); } if (statNewOF.getN() != 0) { final double newMean = statNewOF.getMean(); final double newSd = statNewOF.getStandardDeviation(); final StringBuilder sb = new StringBuilder("shape = "); sb.append(shape); sb.append(", scale = 1.0"); sb.append(", max. mean error (ulps) = "); sb.append(meanOF); sb.append(", actual mean error (ulps) = "); sb.append(newMean); sb.append(", max. sd of error (ulps) = "); sb.append(sdOF); sb.append(", actual sd of error (ulps) = "); sb.append(newSd); final String msg = sb.toString(); Assert.assertTrue(msg, newMean <= meanOF); Assert.assertTrue(msg, newSd <= sdOF); } } catch (IOException e) { Assert.fail(e.getMessage()); } finally { in.close(); } } @Test public void testMath753Shape1() throws IOException { doTestMath753(1.0, 1.5, 0.5, 0.0, 0.0, "gamma-distribution-shape-1.csv"); } @Test public void testMath753Shape8() throws IOException { doTestMath753(8.0, 1.5, 1.0, 0.0, 0.0, "gamma-distribution-shape-8.csv"); } @Test public void testMath753Shape10() throws IOException { doTestMath753(10.0, 1.0, 1.0, 0.0, 0.0, "gamma-distribution-shape-10.csv"); } @Test public void testMath753Shape100() throws IOException { doTestMath753(100.0, 1.5, 1.0, 0.0, 0.0, "gamma-distribution-shape-100.csv"); } @Test public void testMath753Shape142() throws IOException { doTestMath753(142.0, 0.5, 1.5, 40.0, 40.0, "gamma-distribution-shape-142.csv"); } @Test public void testMath753Shape1000() throws IOException { doTestMath753(1000.0, 1.0, 1.0, 160.0, 220.0, "gamma-distribution-shape-1000.csv"); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */ package org.apache.commons.math3.distribution; import org.junit.Assert; import org.junit.Test; /** * Test cases for GeometricDistribution. * <p> * See class javadoc for IntegerDistributionAbstractTest for details. * * @version $Id$ * @since 3.3 */ public class GeometricDistributionTest extends IntegerDistributionAbstractTest { // -------------- Implementations for abstract methods -------------------- /** Creates the default discrete distribution instance to use in tests. */ @Override public IntegerDistribution makeDistribution() { return new GeometricDistribution(0.40); } /** Creates the default probability density test input values */ @Override public int[] makeDensityTestPoints() { return new int[] { -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 29, 20, 21, 22, 23, 24, 25, 26, 27, 28 }; } /** Creates the default probability density test expected values */ @Override public double[] makeDensityTestValues() { return new double[] { 0.000000e+00, 4.000000e-01, 2.400000e-01, 1.440000e-01, 8.640000e-02, 5.184000e-02, 3.110400e-02, 1.866240e-02, 1.119744e-02, 6.718464e-03, 4.031078e-03, 2.418647e-03, 1.451188e-03, 8.707129e-04, 5.224278e-04, 3.134567e-04, 1.880740e-04, 1.128444e-04, 6.770664e-05, 4.062398e-05, 2.437439e-05, 1.462463e-05, 8.774780e-06, 5.264868e-06, 3.158921e-06, 1.895353e-06, 1.137212e-06, 6.823269e-07, 4.093961e-07, 2.456377e-07 }; } /** Creates the default cumulative probability density test input values */ @Override public int[] makeCumulativeTestPoints() { return makeDensityTestPoints(); } /** Creates the default cumulative probability density test expected values */ @Override public double[] makeCumulativeTestValues() { return new double[] { 0.0000000, 0.4000000, 0.6400000, 0.7840000, 0.8704000, 0.9222400, 0.9533440, 0.9720064, 0.9832038, 0.9899223, 0.9939534, 0.9963720, 0.9978232, 0.9986939, 0.9992164, 0.9995298, 0.9997179, 0.9998307, 0.9998984, 0.9999391, 0.9999634, 0.9999781, 0.9999868, 0.9999921, 0.9999953, 0.9999972, 0.9999983, 0.9999990, 0.9999994, 0.9999996 }; } /** Creates the default inverse cumulative probability test input values */ @Override public double[] makeInverseCumulativeTestPoints() { return new double[] { 0.000, 0.005, 0.010, 0.015, 0.020, 0.025, 0.030, 0.035, 0.040, 0.045, 0.050, 0.055, 0.060, 0.065, 0.070, 0.075, 0.080, 0.085, 0.090, 0.095, 0.100, 0.105, 0.110, 0.115, 0.120, 0.125, 0.130, 0.135, 0.140, 0.145, 0.150, 0.155, 0.160, 0.165, 0.170, 0.175, 0.180, 0.185, 0.190, 0.195, 0.200, 0.205, 0.210, 0.215, 0.220, 0.225, 0.230, 0.235, 0.240, 0.245, 0.250, 0.255, 0.260, 0.265, 0.270, 0.275, 0.280, 0.285, 0.290, 0.295, 0.300, 0.305, 0.310, 0.315, 0.320, 0.325, 0.330, 0.335, 0.340, 0.345, 0.350, 0.355, 0.360, 0.365, 0.370, 0.375, 0.380, 0.385, 0.390, 0.395, 0.400, 0.405, 0.410, 0.415, 0.420, 0.425, 0.430, 0.435, 0.440, 0.445, 0.450, 0.455, 0.460, 0.465, 0.470, 0.475, 0.480, 0.485, 0.490, 0.495, 0.500, 0.505, 0.510, 0.515, 0.520, 0.525, 0.530, 0.535, 0.540, 0.545, 0.550, 0.555, 0.560, 0.565, 0.570, 0.575, 0.580, 0.585, 0.590, 0.595, 0.600, 0.605, 0.610, 0.615, 0.620, 0.625, 0.630, 0.635, 0.640, 0.645, 0.650, 0.655, 0.660, 0.665, 0.670, 0.675, 0.680, 0.685, 0.690, 0.695, 0.700, 0.705, 0.710, 0.715, 0.720, 0.725, 0.730, 0.735, 0.740, 0.745, 0.750, 0.755, 0.760, 0.765, 0.770, 0.775, 0.780, 0.785, 0.790, 0.795, 0.800, 0.805, 0.810, 0.815, 0.820, 0.825, 0.830, 0.835, 0.840, 0.845, 0.850, 0.855, 0.860, 0.865, 0.870, 0.875, 0.880, 0.885, 0.890, 0.895, 0.900, 0.905, 0.910, 0.915, 0.920, 0.925, 0.930, 0.935, 0.940, 0.945, 0.950, 0.955, 0.960, 0.965, 0.970, 0.975, 0.980, 0.985, 0.990, 0.995 }; } /** * Creates the default inverse cumulative probability density test expected * values */ @Override public int[] makeInverseCumulativeTestValues() { return new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 8, 9, 10 }; } // ----------------- Additional test cases --------------------------------- @Test public void testMoments() { final double tol = 1e-9; GeometricDistribution dist; dist = new GeometricDistribution(0.5); Assert.assertEquals(dist.getNumericalMean(), (1.0d - 0.5d) / 0.5d, tol); Assert.assertEquals(dist.getNumericalVariance(), (1.0d - 0.5d) / (0.5d * 0.5d), tol); dist = new GeometricDistribution(0.3); Assert.assertEquals(dist.getNumericalMean(), (1.0d - 0.3d) / 0.3d, tol); Assert.assertEquals(dist.getNumericalVariance(), (1.0d - 0.3d) / (0.3d * 0.3d), tol); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.distribution; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.exception.NotPositiveException; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.apache.commons.math3.exception.NumberIsTooLargeException; import org.apache.commons.math3.util.Precision; import org.junit.Assert; import org.junit.Test; /** * Test cases for HyperGeometriclDistribution. * Extends IntegerDistributionAbstractTest. See class javadoc for * IntegerDistributionAbstractTest for details. * * @version $Id$ */ public class HypergeometricDistributionTest extends IntegerDistributionAbstractTest { //-------------- Implementations for abstract methods ----------------------- /** Creates the default discrete distribution instance to use in tests. */ @Override public IntegerDistribution makeDistribution() { return new HypergeometricDistribution(10, 5, 5); } /** Creates the default probability density test input values */ @Override public int[] makeDensityTestPoints() { return new int[] {-1, 0, 1, 2, 3, 4, 5, 10}; } /** Creates the default probability density test expected values */ @Override public double[] makeDensityTestValues() { return new double[] {0d, 0.003968d, 0.099206d, 0.396825d, 0.396825d, 0.099206d, 0.003968d, 0d}; } /** Creates the default cumulative probability density test input values */ @Override public int[] makeCumulativeTestPoints() { return makeDensityTestPoints(); } /** Creates the default cumulative probability density test expected values */ @Override public double[] makeCumulativeTestValues() { return new double[] {0d, .003968d, .103175d, .50000d, .896825d, .996032d, 1.00000d, 1d}; } /** Creates the default inverse cumulative probability test input values */ @Override public double[] makeInverseCumulativeTestPoints() { return new double[] {0d, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d, 0.990d, 0.975d, 0.950d, 0.900d, 1d}; } /** Creates the default inverse cumulative probability density test expected values */ @Override public int[] makeInverseCumulativeTestValues() { return new int[] {0, 0, 1, 1, 1, 1, 5, 4, 4, 4, 4, 5}; } //-------------------- Additional test cases ------------------------------ /** Verify that if there are no failures, mass is concentrated on sampleSize */ @Test public void testDegenerateNoFailures() { HypergeometricDistribution dist = new HypergeometricDistribution(5,5,3); setDistribution(dist); setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 }); setCumulativeTestValues(new double[] {0d, 0d, 0d, 1d, 1d}); setDensityTestPoints(new int[] {-1, 0, 1, 3, 10}); setDensityTestValues(new double[] {0d, 0d, 0d, 1d, 0d}); setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d}); setInverseCumulativeTestValues(new int[] {3, 3}); verifyDensities(); verifyCumulativeProbabilities(); verifyInverseCumulativeProbabilities(); Assert.assertEquals(dist.getSupportLowerBound(), 3); Assert.assertEquals(dist.getSupportUpperBound(), 3); } /** Verify that if there are no successes, mass is concentrated on 0 */ @Test public void testDegenerateNoSuccesses() { HypergeometricDistribution dist = new HypergeometricDistribution(5,0,3); setDistribution(dist); setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 }); setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d}); setDensityTestPoints(new int[] {-1, 0, 1, 3, 10}); setDensityTestValues(new double[] {0d, 1d, 0d, 0d, 0d}); setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d}); setInverseCumulativeTestValues(new int[] {0, 0}); verifyDensities(); verifyCumulativeProbabilities(); verifyInverseCumulativeProbabilities(); Assert.assertEquals(dist.getSupportLowerBound(), 0); Assert.assertEquals(dist.getSupportUpperBound(), 0); } /** Verify that if sampleSize = populationSize, mass is concentrated on numberOfSuccesses */ @Test public void testDegenerateFullSample() { HypergeometricDistribution dist = new HypergeometricDistribution(5,3,5); setDistribution(dist); setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 }); setCumulativeTestValues(new double[] {0d, 0d, 0d, 1d, 1d}); setDensityTestPoints(new int[] {-1, 0, 1, 3, 10}); setDensityTestValues(new double[] {0d, 0d, 0d, 1d, 0d}); setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d}); setInverseCumulativeTestValues(new int[] {3, 3}); verifyDensities(); verifyCumulativeProbabilities(); verifyInverseCumulativeProbabilities(); Assert.assertEquals(dist.getSupportLowerBound(), 3); Assert.assertEquals(dist.getSupportUpperBound(), 3); } @Test public void testPreconditions() { try { new HypergeometricDistribution(0, 3, 5); Assert.fail("negative population size. NotStrictlyPositiveException expected"); } catch(NotStrictlyPositiveException ex) { // Expected. } try { new HypergeometricDistribution(5, -1, 5); Assert.fail("negative number of successes. NotPositiveException expected"); } catch(NotPositiveException ex) { // Expected. } try { new HypergeometricDistribution(5, 3, -1); Assert.fail("negative sample size. NotPositiveException expected"); } catch(NotPositiveException ex) { // Expected. } try { new HypergeometricDistribution(5, 6, 5); Assert.fail("numberOfSuccesses > populationSize. NumberIsTooLargeException expected"); } catch(NumberIsTooLargeException ex) { // Expected. } try { new HypergeometricDistribution(5, 3, 6); Assert.fail("sampleSize > populationSize. NumberIsTooLargeException expected"); } catch(NumberIsTooLargeException ex) { // Expected. } } @Test public void testAccessors() { HypergeometricDistribution dist = new HypergeometricDistribution(5, 3, 4); Assert.assertEquals(5, dist.getPopulationSize()); Assert.assertEquals(3, dist.getNumberOfSuccesses()); Assert.assertEquals(4, dist.getSampleSize()); } @Test public void testLargeValues() { int populationSize = 3456; int sampleSize = 789; int numberOfSucceses = 101; double[][] data = { {0.0, 2.75646034603961e-12, 2.75646034603961e-12, 1.0}, {1.0, 8.55705370142386e-11, 8.83269973602783e-11, 0.999999999997244}, {2.0, 1.31288129219665e-9, 1.40120828955693e-9, 0.999999999911673}, {3.0, 1.32724172984193e-8, 1.46736255879763e-8, 0.999999998598792}, {4.0, 9.94501711734089e-8, 1.14123796761385e-7, 0.999999985326375}, {5.0, 5.89080768883643e-7, 7.03204565645028e-7, 0.999999885876203}, {20.0, 0.0760051397707708, 0.27349758476299, 0.802507555007781}, {21.0, 0.087144222047629, 0.360641806810619, 0.72650241523701}, {22.0, 0.0940378846881819, 0.454679691498801, 0.639358193189381}, {23.0, 0.0956897500614809, 0.550369441560282, 0.545320308501199}, {24.0, 0.0919766921922999, 0.642346133752582, 0.449630558439718}, {25.0, 0.083641637261095, 0.725987771013677, 0.357653866247418}, {96.0, 5.93849188852098e-57, 1.0, 6.01900244560712e-57}, {97.0, 7.96593036832547e-59, 1.0, 8.05105570861321e-59}, {98.0, 8.44582921934367e-61, 1.0, 8.5125340287733e-61}, {99.0, 6.63604297068222e-63, 1.0, 6.670480942963e-63}, {100.0, 3.43501099007557e-65, 1.0, 3.4437972280786e-65}, {101.0, 8.78623800302957e-68, 1.0, 8.78623800302957e-68}, }; testHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data); } private void testHypergeometricDistributionProbabilities(int populationSize, int sampleSize, int numberOfSucceses, double[][] data) { HypergeometricDistribution dist = new HypergeometricDistribution(populationSize, numberOfSucceses, sampleSize); for (int i = 0; i < data.length; ++i) { int x = (int)data[i][0]; double pmf = data[i][1]; double actualPmf = dist.probability(x); TestUtils.assertRelativelyEquals("Expected equals for <"+x+"> pmf",pmf, actualPmf, 1.0e-9); double cdf = data[i][2]; double actualCdf = dist.cumulativeProbability(x); TestUtils.assertRelativelyEquals("Expected equals for <"+x+"> cdf",cdf, actualCdf, 1.0e-9); double cdf1 = data[i][3]; double actualCdf1 = dist.upperCumulativeProbability(x); TestUtils.assertRelativelyEquals("Expected equals for <"+x+"> cdf1",cdf1, actualCdf1, 1.0e-9); } } @Test public void testMoreLargeValues() { int populationSize = 26896; int sampleSize = 895; int numberOfSucceses = 55; double[][] data = { {0.0, 0.155168304750504, 0.155168304750504, 1.0}, {1.0, 0.29437545000746, 0.449543754757964, 0.844831695249496}, {2.0, 0.273841321577003, 0.723385076334967, 0.550456245242036}, {3.0, 0.166488572570786, 0.889873648905753, 0.276614923665033}, {4.0, 0.0743969744713231, 0.964270623377076, 0.110126351094247}, {5.0, 0.0260542785784855, 0.990324901955562, 0.0357293766229237}, {20.0, 3.57101101678792e-16, 1.0, 3.78252101622096e-16}, {21.0, 2.00551638598312e-17, 1.0, 2.11509999433041e-17}, {22.0, 1.04317070180562e-18, 1.0, 1.09583608347287e-18}, {23.0, 5.03153504903308e-20, 1.0, 5.266538166725e-20}, {24.0, 2.2525984149695e-21, 1.0, 2.35003117691919e-21}, {25.0, 9.3677424515947e-23, 1.0, 9.74327619496943e-23}, {50.0, 9.83633962945521e-69, 1.0, 9.8677629437617e-69}, {51.0, 3.13448949497553e-71, 1.0, 3.14233143064882e-71}, {52.0, 7.82755221928122e-74, 1.0, 7.84193567329055e-74}, {53.0, 1.43662126065532e-76, 1.0, 1.43834540093295e-76}, {54.0, 1.72312692517348e-79, 1.0, 1.7241402776278e-79}, {55.0, 1.01335245432581e-82, 1.0, 1.01335245432581e-82}, }; testHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data); } @Test public void testMoments() { final double tol = 1e-9; HypergeometricDistribution dist; dist = new HypergeometricDistribution(1500, 40, 100); Assert.assertEquals(dist.getNumericalMean(), 40d * 100d / 1500d, tol); Assert.assertEquals(dist.getNumericalVariance(), ( 100d * 40d * (1500d - 100d) * (1500d - 40d) ) / ( (1500d * 1500d * 1499d) ), tol); dist = new HypergeometricDistribution(3000, 55, 200); Assert.assertEquals(dist.getNumericalMean(), 55d * 200d / 3000d, tol); Assert.assertEquals(dist.getNumericalVariance(), ( 200d * 55d * (3000d - 200d) * (3000d - 55d) ) / ( (3000d * 3000d * 2999d) ), tol); } @Test public void testMath644() { int N = 14761461; // population int m = 1035; // successes in population int n = 1841; // number of trials int k = 0; final HypergeometricDistribution dist = new HypergeometricDistribution(N, m, n); Assert.assertTrue(Precision.compareTo(1.0, dist.upperCumulativeProbability(k), 1) == 0); Assert.assertTrue(Precision.compareTo(dist.cumulativeProbability(k), 0.0, 1) > 0); // another way to calculate the upper cumulative probability double upper = 1.0 - dist.cumulativeProbability(k) + dist.probability(k); Assert.assertTrue(Precision.compareTo(1.0, upper, 1) == 0); } @Test public void testMath1021() { final int N = 43130568; final int m = 42976365; final int n = 50; final HypergeometricDistribution dist = new HypergeometricDistribution(N, m, n); for (int i = 0; i < 100; i++) { final int sample = dist.sample(); Assert.assertTrue("sample=" + sample, 0 <= sample); Assert.assertTrue("sample=" + sample, sample <= n); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.distribution; import org.junit.Assert; import org.junit.Test; /** * Test cases for {@link KolmogorovSmirnovDistribution}. * * @version $Id$ */ public class KolmogorovSmirnovDistributionTest { private static final double TOLERANCE = 10e-10; @Test public void testCumulativeDensityFunction() { KolmogorovSmirnovDistribution dist; /* The code below is generated using the R-script located in * /src/test/R/KolmogorovSmirnovDistributionTestCases.R */ /* R version 2.11.1 (2010-05-31) */ /* formatC(.C("pkolmogorov2x", p = as.double(0.005), n = as.integer(200), PACKAGE = "stats")$p, 40) gives * 4.907829957616471622388047046469198862537e-86 */ dist = new KolmogorovSmirnovDistribution(200); Assert.assertEquals(4.907829957616471622388047046469198862537e-86, dist.cdf(0.005, false), TOLERANCE); /* formatC(.C("pkolmogorov2x", p = as.double(0.02), n = as.integer(200), PACKAGE = "stats")$p, 40) gives * 5.151982014280041957199687829849210629618e-06 */ dist = new KolmogorovSmirnovDistribution(200); Assert.assertEquals(5.151982014280041957199687829849210629618e-06, dist.cdf(0.02, false), TOLERANCE); /* formatC(.C("pkolmogorov2x", p = as.double(0.031111), n = as.integer(200), PACKAGE = "stats")$p, 40) gives * 0.01291614648162886340443389343590752105229 */ dist = new KolmogorovSmirnovDistribution(200); Assert.assertEquals(0.01291614648162886340443389343590752105229, dist.cdf(0.031111, false), TOLERANCE); /* formatC(.C("pkolmogorov2x", p = as.double(0.04), n = as.integer(200), PACKAGE = "stats")$p, 40) gives * 0.1067137011362679355208626930107129737735 */ dist = new KolmogorovSmirnovDistribution(200); Assert.assertEquals(0.1067137011362679355208626930107129737735, dist.cdf(0.04, false), TOLERANCE); /* formatC(.C("pkolmogorov2x", p = as.double(0.005), n = as.integer(341), PACKAGE = "stats")$p, 40) gives * 1.914734701559404553985102395145063418825e-53 */ dist = new KolmogorovSmirnovDistribution(341); Assert.assertEquals(1.914734701559404553985102395145063418825e-53, dist.cdf(0.005, false), TOLERANCE); /* formatC(.C("pkolmogorov2x", p = as.double(0.02), n = as.integer(341), PACKAGE = "stats")$p, 40) gives * 0.001171328985781981343872182321774744195864 */ dist = new KolmogorovSmirnovDistribution(341); Assert.assertEquals(0.001171328985781981343872182321774744195864, dist.cdf(0.02, false), TOLERANCE); /* formatC(.C("pkolmogorov2x", p = as.double(0.031111), n = as.integer(341), PACKAGE = "stats")$p, 40) gives * 0.1142955196267499418105728636874118819833 */ dist = new KolmogorovSmirnovDistribution(341); Assert.assertEquals(0.1142955196267499418105728636874118819833, dist.cdf(0.031111, false), TOLERANCE); /* formatC(.C("pkolmogorov2x", p = as.double(0.04), n = as.integer(341), PACKAGE = "stats")$p, 40) gives * 0.3685529520496805266915885113121476024389 */ dist = new KolmogorovSmirnovDistribution(341); Assert.assertEquals(0.3685529520496805266915885113121476024389, dist.cdf(0.04, false), TOLERANCE); /* formatC(.C("pkolmogorov2x", p = as.double(0.005), n = as.integer(389), PACKAGE = "stats")$p, 40) gives * 1.810657144595055888918455512707637574637e-47 */ dist = new KolmogorovSmirnovDistribution(389); Assert.assertEquals(1.810657144595055888918455512707637574637e-47, dist.cdf(0.005, false), TOLERANCE); /* formatC(.C("pkolmogorov2x", p = as.double(0.02), n = as.integer(389), PACKAGE = "stats")$p, 40) gives * 0.003068542559702356568168690742481885536108 */ dist = new KolmogorovSmirnovDistribution(389); Assert.assertEquals(0.003068542559702356568168690742481885536108, dist.cdf(0.02, false), TOLERANCE); /* formatC(.C("pkolmogorov2x", p = as.double(0.031111), n = as.integer(389), PACKAGE = "stats")$p, 40) gives * 0.1658291700122746237244797384846606291831 */ dist = new KolmogorovSmirnovDistribution(389); Assert.assertEquals(0.1658291700122746237244797384846606291831, dist.cdf(0.031111, false), TOLERANCE); /* formatC(.C("pkolmogorov2x", p = as.double(0.04), n = as.integer(389), PACKAGE = "stats")$p, 40) gives * 0.4513143712128902529379104180407011881471 */ dist = new KolmogorovSmirnovDistribution(389); Assert.assertEquals(0.4513143712128902529379104180407011881471, dist.cdf(0.04, false), TOLERANCE); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.distribution; import org.apache.commons.math3.random.Well19937a; import org.apache.commons.math3.util.Precision; import org.junit.Assert; import org.junit.Test; public class LevyDistributionTest extends RealDistributionAbstractTest { @Test public void testParameters() { LevyDistribution d = makeDistribution(); Assert.assertEquals(1.2, d.getLocation(), Precision.EPSILON); Assert.assertEquals(0.4, d.getScale(), Precision.EPSILON); } @Test public void testSupport() { LevyDistribution d = makeDistribution(); Assert.assertEquals(d.getLocation(), d.getSupportLowerBound(), Precision.EPSILON); Assert.assertTrue(Double.isInfinite(d.getSupportUpperBound())); Assert.assertTrue(d.isSupportConnected()); } @Override public LevyDistribution makeDistribution() { return new LevyDistribution(new Well19937a(0xc5a5506bbb17e57al), 1.2, 0.4); } @Override public double[] makeCumulativeTestPoints() { return new double[] { 1.2001, 1.21, 1.225, 1.25, 1.3, 1.9, 3.4, 5.6 }; } @Override public double[] makeCumulativeTestValues() { // values computed with R and function plevy from rmutil package return new double[] { 0, 2.53962850749e-10, 6.33424836662e-05, 0.00467773498105, 0.0455002638964, 0.449691797969, 0.669815357599, 0.763024600553 }; } @Override public double[] makeDensityTestValues() { // values computed with R and function dlevy from rmutil package return new double[] { 0, 5.20056373765e-07, 0.0214128361224, 0.413339707082, 1.07981933026, 0.323749319161, 0.0706032550094, 0.026122839884 }; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.distribution; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.junit.Assert; import org.junit.Test; /** * Test cases for {@link LogNormalDistribution}. Extends * {@link RealDistributionAbstractTest}. See class javadoc of that class * for details. * * @version $Id$ * @since 3.0 */ public class LogNormalDistributionTest extends RealDistributionAbstractTest { //-------------- Implementations for abstract methods ----------------------- /** Creates the default real distribution instance to use in tests. */ @Override public LogNormalDistribution makeDistribution() { return new LogNormalDistribution(2.1, 1.4); } /** Creates the default cumulative probability distribution test input values */ @Override public double[] makeCumulativeTestPoints() { // quantiles computed using R return new double[] { -2.226325228634938, -1.156887023657177, -0.643949578356075, -0.2027950777320613, 0.305827808237559, 6.42632522863494, 5.35688702365718, 4.843949578356074, 4.40279507773206, 3.89417219176244 }; } /** Creates the default cumulative probability density test expected values */ @Override public double[] makeCumulativeTestValues() { return new double[] { 0, 0, 0, 0, 0.00948199951485, 0.432056525076, 0.381648158697, 0.354555726206, 0.329513316888, 0.298422824228 }; } /** Creates the default probability density test expected values */ @Override public double[] makeDensityTestValues() { return new double[] { 0, 0, 0, 0, 0.0594218160072, 0.0436977691036, 0.0508364857798, 0.054873528325, 0.0587182664085, 0.0636229042785 }; } /** * Creates the default inverse cumulative probability distribution test * input values. */ @Override public double[] makeInverseCumulativeTestPoints() { // Exclude the test points less than zero, as they have cumulative // probability of zero, meaning the inverse returns zero, and not the // points less than zero. double[] points = makeCumulativeTestValues(); double[] points2 = new double[points.length - 4]; System.arraycopy(points, 4, points2, 0, points2.length - 4); return points2; //return Arrays.copyOfRange(points, 4, points.length - 4); } /** * Creates the default inverse cumulative probability test expected * values. */ @Override public double[] makeInverseCumulativeTestValues() { // Exclude the test points less than zero, as they have cumulative // probability of zero, meaning the inverse returns zero, and not the // points less than zero. double[] points = makeCumulativeTestPoints(); double[] points2 = new double[points.length - 4]; System.arraycopy(points, 4, points2, 0, points2.length - 4); return points2; //return Arrays.copyOfRange(points, 1, points.length - 4); } // --------------------- Override tolerance -------------- @Override public void setUp() { super.setUp(); setTolerance(LogNormalDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY); } //---------------------------- Additional test cases ------------------------- private void verifyQuantiles() { LogNormalDistribution distribution = (LogNormalDistribution)getDistribution(); double mu = distribution.getScale(); double sigma = distribution.getShape(); setCumulativeTestPoints( new double[] { mu - 2 *sigma, mu - sigma, mu, mu + sigma, mu + 2 * sigma, mu + 3 * sigma,mu + 4 * sigma, mu + 5 * sigma }); verifyCumulativeProbabilities(); } @Test public void testQuantiles() { setCumulativeTestValues(new double[] {0, 0.0396495152787, 0.16601209243, 0.272533253269, 0.357618409638, 0.426488363093, 0.483255136841, 0.530823013877}); setDensityTestValues(new double[] {0, 0.0873055825147, 0.0847676303432, 0.0677935186237, 0.0544105523058, 0.0444614628804, 0.0369750288945, 0.0312206409653}); verifyQuantiles(); verifyDensities(); setDistribution(new LogNormalDistribution(0, 1)); setCumulativeTestValues(new double[] {0, 0, 0, 0.5, 0.755891404214, 0.864031392359, 0.917171480998, 0.946239689548}); setDensityTestValues(new double[] {0, 0, 0, 0.398942280401, 0.156874019279, 0.07272825614, 0.0381534565119, 0.0218507148303}); verifyQuantiles(); verifyDensities(); setDistribution(new LogNormalDistribution(0, 0.1)); setCumulativeTestValues(new double[] {0, 0, 0, 1.28417563064e-117, 1.39679883412e-58, 1.09839325447e-33, 2.52587961726e-20, 2.0824223487e-12}); setDensityTestValues(new double[] {0, 0, 0, 2.96247992535e-114, 1.1283370232e-55, 4.43812313223e-31, 5.85346445002e-18, 2.9446618076e-10}); verifyQuantiles(); verifyDensities(); } @Test public void testInverseCumulativeProbabilityExtremes() { setInverseCumulativeTestPoints(new double[] {0, 1}); setInverseCumulativeTestValues( new double[] {0, Double.POSITIVE_INFINITY}); verifyInverseCumulativeProbabilities(); } @Test public void testGetScale() { LogNormalDistribution distribution = (LogNormalDistribution)getDistribution(); Assert.assertEquals(2.1, distribution.getScale(), 0); } @Test public void testGetShape() { LogNormalDistribution distribution = (LogNormalDistribution)getDistribution(); Assert.assertEquals(1.4, distribution.getShape(), 0); } @Test(expected=NotStrictlyPositiveException.class) public void testPreconditions() { new LogNormalDistribution(1, 0); } @Test public void testDensity() { double [] x = new double[]{-2, -1, 0, 1, 2}; // R 2.13: print(dlnorm(c(-2,-1,0,1,2)), digits=10) checkDensity(0, 1, x, new double[] { 0.0000000000, 0.0000000000, 0.0000000000, 0.3989422804, 0.1568740193 }); // R 2.13: print(dlnorm(c(-2,-1,0,1,2), mean=1.1), digits=10) checkDensity(1.1, 1, x, new double[] { 0.0000000000, 0.0000000000, 0.0000000000, 0.2178521770, 0.1836267118}); } private void checkDensity(double scale, double shape, double[] x, double[] expected) { LogNormalDistribution d = new LogNormalDistribution(scale, shape); for (int i = 0; i < x.length; i++) { Assert.assertEquals(expected[i], d.density(x[i]), 1e-9); } } /** * Check to make sure top-coding of extreme values works correctly. * Verifies fixes for JIRA MATH-167, MATH-414 */ @Test public void testExtremeValues() { LogNormalDistribution d = new LogNormalDistribution(0, 1); for (int i = 0; i < 1e5; i++) { // make sure no convergence exception double upperTail = d.cumulativeProbability(i); if (i <= 72) { // make sure not top-coded Assert.assertTrue(upperTail < 1.0d); } else { // make sure top coding not reversed Assert.assertTrue(upperTail > 0.99999); } } Assert.assertEquals(d.cumulativeProbability(Double.MAX_VALUE), 1, 0); Assert.assertEquals(d.cumulativeProbability(-Double.MAX_VALUE), 0, 0); Assert.assertEquals(d.cumulativeProbability(Double.POSITIVE_INFINITY), 1, 0); Assert.assertEquals(d.cumulativeProbability(Double.NEGATIVE_INFINITY), 0, 0); } @Test public void testMeanVariance() { final double tol = 1e-9; LogNormalDistribution dist; dist = new LogNormalDistribution(0, 1); Assert.assertEquals(dist.getNumericalMean(), 1.6487212707001282, tol); Assert.assertEquals(dist.getNumericalVariance(), 4.670774270471604, tol); dist = new LogNormalDistribution(2.2, 1.4); Assert.assertEquals(dist.getNumericalMean(), 24.046753552064498, tol); Assert.assertEquals(dist.getNumericalVariance(), 3526.913651880464, tol); dist = new LogNormalDistribution(-2000.9, 10.4); Assert.assertEquals(dist.getNumericalMean(), 0.0, tol); Assert.assertEquals(dist.getNumericalVariance(), 0.0, tol); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.distribution; import org.apache.commons.math3.stat.correlation.Covariance; import org.apache.commons.math3.linear.RealMatrix; import java.util.Random; import org.junit.Assert; import org.junit.Test; /** * Test cases for {@link MultivariateNormalDistribution}. */ public class MultivariateNormalDistributionTest { /** * Test the ability of the distribution to report its mean value parameter. */ @Test public void testGetMean() { final double[] mu = { -1.5, 2 }; final double[][] sigma = { { 2, -1.1 }, { -1.1, 2 } }; final MultivariateNormalDistribution d = new MultivariateNormalDistribution(mu, sigma); final double[] m = d.getMeans(); for (int i = 0; i < m.length; i++) { Assert.assertEquals(mu[i], m[i], 0); } } /** * Test the ability of the distribution to report its covariance matrix parameter. */ @Test public void testGetCovarianceMatrix() { final double[] mu = { -1.5, 2 }; final double[][] sigma = { { 2, -1.1 }, { -1.1, 2 } }; final MultivariateNormalDistribution d = new MultivariateNormalDistribution(mu, sigma); final RealMatrix s = d.getCovariances(); final int dim = d.getDimension(); for (int i = 0; i < dim; i++) { for (int j = 0; j < dim; j++) { Assert.assertEquals(sigma[i][j], s.getEntry(i, j), 0); } } } /** * Test the accuracy of sampling from the distribution. */ @Test public void testSampling() { final double[] mu = { -1.5, 2 }; final double[][] sigma = { { 2, -1.1 }, { -1.1, 2 } }; final MultivariateNormalDistribution d = new MultivariateNormalDistribution(mu, sigma); d.reseedRandomGenerator(50); final int n = 500000; final double[][] samples = d.sample(n); final int dim = d.getDimension(); final double[] sampleMeans = new double[dim]; for (int i = 0; i < samples.length; i++) { for (int j = 0; j < dim; j++) { sampleMeans[j] += samples[i][j]; } } final double sampledValueTolerance = 1e-2; for (int j = 0; j < dim; j++) { sampleMeans[j] /= samples.length; Assert.assertEquals(mu[j], sampleMeans[j], sampledValueTolerance); } final double[][] sampleSigma = new Covariance(samples).getCovarianceMatrix().getData(); for (int i = 0; i < dim; i++) { for (int j = 0; j < dim; j++) { Assert.assertEquals(sigma[i][j], sampleSigma[i][j], sampledValueTolerance); } } } /** * Test the accuracy of the distribution when calculating densities. */ @Test public void testDensities() { final double[] mu = { -1.5, 2 }; final double[][] sigma = { { 2, -1.1 }, { -1.1, 2 } }; final MultivariateNormalDistribution d = new MultivariateNormalDistribution(mu, sigma); final double[][] testValues = { { -1.5, 2 }, { 4, 4 }, { 1.5, -2 }, { 0, 0 } }; final double[] densities = new double[testValues.length]; for (int i = 0; i < densities.length; i++) { densities[i] = d.density(testValues[i]); } // From dmvnorm function in R 2.15 CRAN package Mixtools v0.4.5 final double[] correctDensities = { 0.09528357207691344, 5.80932710124009e-09, 0.001387448895173267, 0.03309922090210541 }; for (int i = 0; i < testValues.length; i++) { Assert.assertEquals(correctDensities[i], densities[i], 1e-16); } } /** * Test the accuracy of the distribution when calculating densities. */ @Test public void testUnivariateDistribution() { final double[] mu = { -1.5 }; final double[][] sigma = { { 1 } }; final MultivariateNormalDistribution multi = new MultivariateNormalDistribution(mu, sigma); final NormalDistribution uni = new NormalDistribution(mu[0], sigma[0][0]); final Random rng = new Random(); final int numCases = 100; final double tol = Math.ulp(1d); for (int i = 0; i < numCases; i++) { final double v = rng.nextDouble() * 10 - 5; Assert.assertEquals(uni.density(v), multi.density(new double[] { v }), tol); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.distribution; import java.util.List; import java.util.ArrayList; import org.apache.commons.math3.exception.NotPositiveException; import org.apache.commons.math3.exception.MathArithmeticException; import org.apache.commons.math3.util.Pair; import org.junit.Assert; import org.junit.Test; /** * Test that demonstrates the use of {@link MixtureMultivariateRealDistribution} * in order to create a mixture model composed of {@link MultivariateNormalDistribution * normal distributions}. */ public class MultivariateNormalMixtureModelDistributionTest { @Test public void testNonUnitWeightSum() { final double[] weights = { 1, 2 }; final double[][] means = { { -1.5, 2.0 }, { 4.0, 8.2 } }; final double[][][] covariances = { { { 2.0, -1.1 }, { -1.1, 2.0 } }, { { 3.5, 1.5 }, { 1.5, 3.5 } } }; final MultivariateNormalMixtureModelDistribution d = create(weights, means, covariances); final List<Pair<Double, MultivariateNormalDistribution>> comp = d.getComponents(); Assert.assertEquals(1d / 3, comp.get(0).getFirst().doubleValue(), Math.ulp(1d)); Assert.assertEquals(2d / 3, comp.get(1).getFirst().doubleValue(), Math.ulp(1d)); } @Test(expected=MathArithmeticException.class) public void testWeightSumOverFlow() { final double[] weights = { 0.5 * Double.MAX_VALUE, 0.51 * Double.MAX_VALUE }; final double[][] means = { { -1.5, 2.0 }, { 4.0, 8.2 } }; final double[][][] covariances = { { { 2.0, -1.1 }, { -1.1, 2.0 } }, { { 3.5, 1.5 }, { 1.5, 3.5 } } }; final MultivariateNormalMixtureModelDistribution d = create(weights, means, covariances); } @Test(expected=NotPositiveException.class) public void testPreconditionPositiveWeights() { final double[] negativeWeights = { -0.5, 1.5 }; final double[][] means = { { -1.5, 2.0 }, { 4.0, 8.2 } }; final double[][][] covariances = { { { 2.0, -1.1 }, { -1.1, 2.0 } }, { { 3.5, 1.5 }, { 1.5, 3.5 } } }; final MultivariateNormalMixtureModelDistribution d = create(negativeWeights, means, covariances); } /** * Test the accuracy of the density calculation. */ @Test public void testDensities() { final double[] weights = { 0.3, 0.7 }; final double[][] means = { { -1.5, 2.0 }, { 4.0, 8.2 } }; final double[][][] covariances = { { { 2.0, -1.1 }, { -1.1, 2.0 } }, { { 3.5, 1.5 }, { 1.5, 3.5 } } }; final MultivariateNormalMixtureModelDistribution d = create(weights, means, covariances); // Test vectors final double[][] testValues = { { -1.5, 2 }, { 4, 8.2 }, { 1.5, -2 }, { 0, 0 } }; // Densities that we should get back. // Calculated by assigning weights to multivariate normal distribution // and summing // values from dmvnorm function in R 2.15 CRAN package Mixtools v0.4. // Like: .3*dmvnorm(val,mu1,sigma1)+.7*dmvnorm(val,mu2,sigma2) final double[] correctDensities = { 0.02862037278930575, 0.03523044847314091, 0.000416241365629767, 0.009932042831700297 }; for (int i = 0; i < testValues.length; i++) { Assert.assertEquals(correctDensities[i], d.density(testValues[i]), Math.ulp(1d)); } } /** * Test the accuracy of sampling from the distribution. */ @Test public void testSampling() { final double[] weights = { 0.3, 0.7 }; final double[][] means = { { -1.5, 2.0 }, { 4.0, 8.2 } }; final double[][][] covariances = { { { 2.0, -1.1 }, { -1.1, 2.0 } }, { { 3.5, 1.5 }, { 1.5, 3.5 } } }; final MultivariateNormalMixtureModelDistribution d = create(weights, means, covariances); d.reseedRandomGenerator(50); final double[][] correctSamples = getCorrectSamples(); final int n = correctSamples.length; final double[][] samples = d.sample(n); for (int i = 0; i < n; i++) { for (int j = 0; j < samples[i].length; j++) { Assert.assertEquals(correctSamples[i][j], samples[i][j], 1e-16); } } } /** * Creates a mixture of Gaussian distributions. * * @param weights Weights. * @param means Means. * @param covariances Covariances. * @return the mixture distribution. */ private MultivariateNormalMixtureModelDistribution create(double[] weights, double[][] means, double[][][] covariances) { final List<Pair<Double, MultivariateNormalDistribution>> mvns = new ArrayList<Pair<Double, MultivariateNormalDistribution>>(); for (int i = 0; i < weights.length; i++) { final MultivariateNormalDistribution dist = new MultivariateNormalDistribution(means[i], covariances[i]); mvns.add(new Pair<Double, MultivariateNormalDistribution>(weights[i], dist)); } return new MultivariateNormalMixtureModelDistribution(mvns); } /** * Values used in {@link #testSampling()}. */ private double[][] getCorrectSamples() { // These were sampled from the MultivariateNormalMixtureModelDistribution class // with seed 50. // // They were then fit to a MVN mixture model in R using mixtools. // // The optimal parameters were: // - component weights: {0.3595186, 0.6404814} // - mean vectors: {-1.645879, 1.989797}, {3.474328, 7.782232} // - covariance matrices: // { 1.397738 -1.167732 // -1.167732 1.801782 } // and // { 3.934593 2.354787 // 2.354787 4.428024 } // // It is considered fairly close to the actual test parameters, // considering that the sample size is only 100. return new double[][] { { 6.259990922080121, 11.972954175355897 }, { -2.5296544304801847, 1.0031292519854365 }, { 0.49037886081440396, 0.9758251727325711 }, { 5.022970993312015, 9.289348879616787 }, { -1.686183146603914, 2.007244382745706 }, { -1.4729253946002685, 2.762166644212484 }, { 4.329788143963888, 11.514016497132253 }, { 3.008674596114442, 4.960246550446107 }, { 3.342379304090846, 5.937630105198625 }, { 2.6993068328674754, 7.42190871572571 }, { -2.446569340219571, 1.9687117791378763 }, { 1.922417883170056, 4.917616702617099 }, { -1.1969741543898518, 2.4576126277884387 }, { 2.4216948702967196, 8.227710158117134 }, { 6.701424725804463, 9.098666475042428 }, { 2.9890253545698964, 9.643807939324331 }, { 0.7162632354907799, 8.978811120287553 }, { -2.7548699149775877, 4.1354812280794215 }, { 8.304528180745018, 11.602319388898287 }, { -2.7633253389165926, 2.786173883989795 }, { 1.3322228389460813, 5.447481218602913 }, { -1.8120096092851508, 1.605624499560037 }, { 3.6546253437206504, 8.195304526564376 }, { -2.312349539658588, 1.868941220444169 }, { -1.882322136356522, 2.033795570464242 }, { 4.562770714939441, 7.414967958885031 }, { 4.731882017875329, 8.890676665580747 }, { 3.492186010427425, 8.9005225241848 }, { -1.619700190174894, 3.314060142479045 }, { 3.5466090064003315, 7.75182101001913 }, { 5.455682472787392, 8.143119287755635 }, { -2.3859602945473197, 1.8826732217294837 }, { 3.9095306088680015, 9.258129209626317 }, { 7.443020189508173, 7.837840713329312 }, { 2.136004873917428, 6.917636475958297 }, { -1.7203379410395119, 2.3212878757611524 }, { 4.618991257611526, 12.095065976419436 }, { -0.4837044029854387, 0.8255970441255125 }, { -4.438938966557163, 4.948666297280241 }, { -0.4539625134045906, 4.700922454655341 }, { 2.1285488271265356, 8.457941480487563 }, { 3.4873561871454393, 11.99809827845933 }, { 4.723049431412658, 7.813095742563365 }, { 1.1245583037967455, 5.20587873556688 }, { 1.3411933634409197, 6.069796875785409 }, { 4.585119332463686, 7.967669543767418 }, { 1.3076522817963823, -0.647431033653445 }, { -1.4449446442803178, 1.9400424267464862 }, { -2.069794456383682, 3.5824162107496544 }, { -0.15959481421417276, 1.5466782303315405 }, { -2.0823081278810136, 3.0914366458581437 }, { 3.521944615248141, 10.276112932926408 }, { 1.0164326704884257, 4.342329556442856 }, { 5.3718868590295275, 8.374761158360922 }, { 0.3673656866959396, 8.75168581694866 }, { -2.250268955954753, 1.4610850300996527 }, { -2.312739727403522, 1.5921126297576362 }, { 3.138993360831055, 6.7338392374947365 }, { 2.6978650950790115, 7.941857288979095 }, { 4.387985088655384, 8.253499976968 }, { -1.8928961721456705, 0.23631082388724223 }, { 4.43509029544109, 8.565290285488782 }, { 4.904728034106502, 5.79936660133754 }, { -1.7640371853739507, 2.7343727594167433 }, { 2.4553674733053463, 7.875871017408807 }, { -2.6478965122565006, 4.465127753193949 }, { 3.493873671142299, 10.443093773532448 }, { 1.1321916197409103, 7.127108479263268 }, { -1.7335075535240392, 2.550629648463023 }, { -0.9772679734368084, 4.377196298969238 }, { 3.6388366973980357, 6.947299283206256 }, { 0.27043799318823325, 6.587978599614367 }, { 5.356782352010253, 7.388957912116327 }, { -0.09187745751354681, 0.23612399246659743 }, { 2.903203580353435, 3.8076727621794415 }, { 5.297014824937293, 8.650985262326508 }, { 4.934508602170976, 9.164571423190052 }, { -1.0004911869654256, 4.797064194444461 }, { 6.782491700298046, 11.852373338280497 }, { 2.8983678524536014, 8.303837362117521 }, { 4.805003269830865, 6.790462904325329 }, { -0.8815799740744226, 1.3015810062131394 }, { 5.115138859802104, 6.376895810201089 }, { 4.301239328205988, 8.60546337560793 }, { 3.276423626317666, 9.889429652591947 }, { -4.001924973153122, 4.3353864592328515 }, { 3.9571892554119517, 4.500569057308562 }, { 4.783067027436208, 7.451125480601317 }, { 4.79065438272821, 9.614122776979698 }, { 2.677655270279617, 6.8875223698210135 }, { -1.3714746289327362, 2.3992153193382437 }, { 3.240136859745249, 7.748339397522042 }, { 5.107885374416291, 8.508324480583724 }, { -1.5830830226666048, 0.9139127045208315 }, { -1.1596156791652918, -0.04502759384531929 }, { -0.4670021307952068, 3.6193633227841624 }, { -0.7026065228267798, 0.4811423031997131 }, { -2.719979836732917, 2.5165041618080104 }, { 1.0336754331123372, -0.34966029029320644 }, { 4.743217291882213, 5.750060115251131 } }; } } /** * Class that implements a mixture of Gaussian ditributions. */ class MultivariateNormalMixtureModelDistribution extends MixtureMultivariateRealDistribution<MultivariateNormalDistribution> { public MultivariateNormalMixtureModelDistribution(List<Pair<Double, MultivariateNormalDistribution>> components) { super(components); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.distribution; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.junit.Assert; import org.junit.Test; /** * Test cases for {@link NormalDistribution}. Extends * {@link RealDistributionAbstractTest}. See class javadoc of that class * for details. * * @version $Id$ */ public class NormalDistributionTest extends RealDistributionAbstractTest { //-------------- Implementations for abstract methods ----------------------- /** Creates the default real distribution instance to use in tests. */ @Override public NormalDistribution makeDistribution() { return new NormalDistribution(2.1, 1.4); } /** Creates the default cumulative probability distribution test input values */ @Override public double[] makeCumulativeTestPoints() { // quantiles computed using R return new double[] {-2.226325228634938d, -1.156887023657177d, -0.643949578356075d, -0.2027950777320613d, 0.305827808237559d, 6.42632522863494d, 5.35688702365718d, 4.843949578356074d, 4.40279507773206d, 3.89417219176244d}; } /** Creates the default cumulative probability density test expected values */ @Override public double[] makeCumulativeTestValues() { return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d, 0.990d, 0.975d, 0.950d, 0.900d}; } /** Creates the default probability density test expected values */ @Override public double[] makeDensityTestValues() { return new double[] {0.00240506434076, 0.0190372444310, 0.0417464784322, 0.0736683145538, 0.125355951380, 0.00240506434076, 0.0190372444310, 0.0417464784322, 0.0736683145538, 0.125355951380}; } // --------------------- Override tolerance -------------- protected double defaultTolerance = NormalDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY; @Override public void setUp() { super.setUp(); setTolerance(defaultTolerance); } //---------------------------- Additional test cases ------------------------- private void verifyQuantiles() { NormalDistribution distribution = (NormalDistribution) getDistribution(); double mu = distribution.getMean(); double sigma = distribution.getStandardDeviation(); setCumulativeTestPoints( new double[] {mu - 2 *sigma, mu - sigma, mu, mu + sigma, mu + 2 * sigma, mu + 3 * sigma, mu + 4 * sigma, mu + 5 * sigma}); // Quantiles computed using R (same as Mathematica) setCumulativeTestValues(new double[] {0.02275013194817921, 0.158655253931457, 0.5, 0.841344746068543, 0.977249868051821, 0.99865010196837, 0.999968328758167, 0.999999713348428}); verifyCumulativeProbabilities(); } @Test public void testQuantiles() { setDensityTestValues(new double[] {0.0385649760808, 0.172836231799, 0.284958771715, 0.172836231799, 0.0385649760808, 0.00316560600853, 9.55930184035e-05, 1.06194251052e-06}); verifyQuantiles(); verifyDensities(); setDistribution(new NormalDistribution(0, 1)); setDensityTestValues(new double[] {0.0539909665132, 0.241970724519, 0.398942280401, 0.241970724519, 0.0539909665132, 0.00443184841194, 0.000133830225765, 1.48671951473e-06}); verifyQuantiles(); verifyDensities(); setDistribution(new NormalDistribution(0, 0.1)); setDensityTestValues(new double[] {0.539909665132, 2.41970724519, 3.98942280401, 2.41970724519, 0.539909665132, 0.0443184841194, 0.00133830225765, 1.48671951473e-05}); verifyQuantiles(); verifyDensities(); } @Test public void testInverseCumulativeProbabilityExtremes() { setInverseCumulativeTestPoints(new double[] {0, 1}); setInverseCumulativeTestValues( new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY}); verifyInverseCumulativeProbabilities(); } @Test public void testGetMean() { NormalDistribution distribution = (NormalDistribution) getDistribution(); Assert.assertEquals(2.1, distribution.getMean(), 0); } @Test public void testGetStandardDeviation() { NormalDistribution distribution = (NormalDistribution) getDistribution(); Assert.assertEquals(1.4, distribution.getStandardDeviation(), 0); } @Test(expected=NotStrictlyPositiveException.class) public void testPreconditions() { new NormalDistribution(1, 0); } @Test public void testDensity() { double [] x = new double[]{-2, -1, 0, 1, 2}; // R 2.5: print(dnorm(c(-2,-1,0,1,2)), digits=10) checkDensity(0, 1, x, new double[]{0.05399096651, 0.24197072452, 0.39894228040, 0.24197072452, 0.05399096651}); // R 2.5: print(dnorm(c(-2,-1,0,1,2), mean=1.1), digits=10) checkDensity(1.1, 1, x, new double[]{0.003266819056,0.043983595980,0.217852177033,0.396952547477,0.266085249899}); } private void checkDensity(double mean, double sd, double[] x, double[] expected) { NormalDistribution d = new NormalDistribution(mean, sd); for (int i = 0; i < x.length; i++) { Assert.assertEquals(expected[i], d.density(x[i]), 1e-9); } } /** * Check to make sure top-coding of extreme values works correctly. * Verifies fixes for JIRA MATH-167, MATH-414 */ @Test public void testExtremeValues() { NormalDistribution distribution = new NormalDistribution(0, 1); for (int i = 0; i < 100; i++) { // make sure no convergence exception double lowerTail = distribution.cumulativeProbability(-i); double upperTail = distribution.cumulativeProbability(i); if (i < 9) { // make sure not top-coded // For i = 10, due to bad tail precision in erf (MATH-364), 1 is returned // TODO: once MATH-364 is resolved, replace 9 with 30 Assert.assertTrue(lowerTail > 0.0d); Assert.assertTrue(upperTail < 1.0d); } else { // make sure top coding not reversed Assert.assertTrue(lowerTail < 0.00001); Assert.assertTrue(upperTail > 0.99999); } } Assert.assertEquals(distribution.cumulativeProbability(Double.MAX_VALUE), 1, 0); Assert.assertEquals(distribution.cumulativeProbability(-Double.MAX_VALUE), 0, 0); Assert.assertEquals(distribution.cumulativeProbability(Double.POSITIVE_INFINITY), 1, 0); Assert.assertEquals(distribution.cumulativeProbability(Double.NEGATIVE_INFINITY), 0, 0); } @Test public void testMath280() { NormalDistribution normal = new NormalDistribution(0,1); double result = normal.inverseCumulativeProbability(0.9986501019683698); Assert.assertEquals(3.0, result, defaultTolerance); result = normal.inverseCumulativeProbability(0.841344746068543); Assert.assertEquals(1.0, result, defaultTolerance); result = normal.inverseCumulativeProbability(0.9999683287581673); Assert.assertEquals(4.0, result, defaultTolerance); result = normal.inverseCumulativeProbability(0.9772498680518209); Assert.assertEquals(2.0, result, defaultTolerance); } @Test public void testMoments() { final double tol = 1e-9; NormalDistribution dist; dist = new NormalDistribution(0, 1); Assert.assertEquals(dist.getNumericalMean(), 0, tol); Assert.assertEquals(dist.getNumericalVariance(), 1, tol); dist = new NormalDistribution(2.2, 1.4); Assert.assertEquals(dist.getNumericalMean(), 2.2, tol); Assert.assertEquals(dist.getNumericalVariance(), 1.4 * 1.4, tol); dist = new NormalDistribution(-2000.9, 10.4); Assert.assertEquals(dist.getNumericalMean(), -2000.9, tol); Assert.assertEquals(dist.getNumericalVariance(), 10.4 * 10.4, tol); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.distribution; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.junit.Assert; import org.junit.Test; /** * Test cases for {@link ParetoDistribution}. * <p> * Extends {@link RealDistributionAbstractTest}. See class javadoc of that class for details. * * @version $Id$ * @since 3.3 */ public class ParetoDistributionTest extends RealDistributionAbstractTest { //-------------- Implementations for abstract methods ----------------------- /** Creates the default real distribution instance to use in tests. */ @Override public ParetoDistribution makeDistribution() { return new ParetoDistribution(2.1, 1.4); } /** Creates the default cumulative probability distribution test input values */ @Override public double[] makeCumulativeTestPoints() { // quantiles computed using R return new double[] { -2.226325228634938, -1.156887023657177, -0.643949578356075, -0.2027950777320613, 0.305827808237559, +6.42632522863494, 5.35688702365718, 4.843949578356074, 4.40279507773206, 3.89417219176244 }; } /** Creates the default cumulative probability density test expected values */ @Override public double[] makeCumulativeTestValues() { return new double[] { 0, 0, 0, 0, 0, 0.791089998892, 0.730456085931, 0.689667290488, 0.645278794701, 0.578763688757 }; } /** Creates the default probability density test expected values */ @Override public double[] makeDensityTestValues() { return new double[] { 0, 0, 0, 0, 0, 0.0455118580441, 0.070444173646, 0.0896924681582, 0.112794186114, 0.151439332084 }; } /** * Creates the default inverse cumulative probability distribution test input values. */ @Override public double[] makeInverseCumulativeTestPoints() { // Exclude the test points less than zero, as they have cumulative // probability of zero, meaning the inverse returns zero, and not the // points less than zero. double[] points = makeCumulativeTestValues(); double[] points2 = new double[points.length - 5]; System.arraycopy(points, 5, points2, 0, points.length - 5); return points2; } /** * Creates the default inverse cumulative probability test expected values. */ @Override public double[] makeInverseCumulativeTestValues() { // Exclude the test points less than zero, as they have cumulative // probability of zero, meaning the inverse returns zero, and not the // points less than zero. double[] points = makeCumulativeTestPoints(); double[] points2 = new double[points.length - 5]; System.arraycopy(points, 5, points2, 0, points.length - 5); return points2; } // --------------------- Override tolerance -------------- @Override public void setUp() { super.setUp(); setTolerance(ParetoDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY); } //---------------------------- Additional test cases ------------------------- private void verifyQuantiles() { ParetoDistribution distribution = (ParetoDistribution)getDistribution(); double mu = distribution.getScale(); double sigma = distribution.getShape(); setCumulativeTestPoints( new double[] { mu - 2 *sigma, mu - sigma, mu, mu + sigma, mu + 2 * sigma, mu + 3 * sigma, mu + 4 * sigma, mu + 5 * sigma }); verifyCumulativeProbabilities(); } @Test public void testQuantiles() { setCumulativeTestValues(new double[] {0, 0, 0, 0.510884134236, 0.694625688662, 0.785201995008, 0.837811522357, 0.871634279326}); setDensityTestValues(new double[] {0, 0, 0.666666666, 0.195646346305, 0.0872498032394, 0.0477328899983, 0.0294888141169, 0.0197485724114}); verifyQuantiles(); verifyDensities(); setDistribution(new ParetoDistribution(1, 1)); setCumulativeTestValues(new double[] {0, 0, 0, 0.5, 0.666666666667, 0.75, 0.8, 0.833333333333}); setDensityTestValues(new double[] {0, 0, 1.0, 0.25, 0.111111111111, 0.0625, 0.04, 0.0277777777778}); verifyQuantiles(); verifyDensities(); setDistribution(new ParetoDistribution(0.1, 0.1)); setCumulativeTestValues(new double[] {0, 0, 0, 0.0669670084632, 0.104041540159, 0.129449436704, 0.148660077479, 0.164041197922}); setDensityTestValues(new double[] {0, 0, 1.0, 0.466516495768, 0.298652819947, 0.217637640824, 0.170267984504, 0.139326467013}); verifyQuantiles(); verifyDensities(); } @Test public void testInverseCumulativeProbabilityExtremes() { setInverseCumulativeTestPoints(new double[] {0, 1}); setInverseCumulativeTestValues(new double[] {2.1, Double.POSITIVE_INFINITY}); verifyInverseCumulativeProbabilities(); } @Test public void testGetScale() { ParetoDistribution distribution = (ParetoDistribution)getDistribution(); Assert.assertEquals(2.1, distribution.getScale(), 0); } @Test public void testGetShape() { ParetoDistribution distribution = (ParetoDistribution)getDistribution(); Assert.assertEquals(1.4, distribution.getShape(), 0); } @Test(expected=NotStrictlyPositiveException.class) public void testPreconditions() { new ParetoDistribution(1, 0); } @Test public void testDensity() { double [] x = new double[]{-2, -1, 0, 1, 2}; // R 2.14: print(dpareto(c(-2,-1,0,1,2), scale=1, shape=1), digits=10) checkDensity(1, 1, x, new double[] { 0.00, 0.00, 0.00, 1.00, 0.25 }); // R 2.14: print(dpareto(c(-2,-1,0,1,2), scale=1.1, shape=1), digits=10) checkDensity(1.1, 1, x, new double[] { 0.000, 0.000, 0.000, 0.000, 0.275 }); } private void checkDensity(double scale, double shape, double[] x, double[] expected) { ParetoDistribution d = new ParetoDistribution(scale, shape); for (int i = 0; i < x.length; i++) { Assert.assertEquals(expected[i], d.density(x[i]), 1e-9); } } /** * Check to make sure top-coding of extreme values works correctly. */ @Test public void testExtremeValues() { ParetoDistribution d = new ParetoDistribution(1, 1); for (int i = 0; i < 1e5; i++) { // make sure no convergence exception double upperTail = d.cumulativeProbability(i); if (i <= 1000) { // make sure not top-coded Assert.assertTrue(upperTail < 1.0d); } else { // make sure top coding not reversed Assert.assertTrue(upperTail > 0.999); } } Assert.assertEquals(d.cumulativeProbability(Double.MAX_VALUE), 1, 0); Assert.assertEquals(d.cumulativeProbability(-Double.MAX_VALUE), 0, 0); Assert.assertEquals(d.cumulativeProbability(Double.POSITIVE_INFINITY), 1, 0); Assert.assertEquals(d.cumulativeProbability(Double.NEGATIVE_INFINITY), 0, 0); } @Test public void testMeanVariance() { final double tol = 1e-9; ParetoDistribution dist; dist = new ParetoDistribution(1, 1); Assert.assertEquals(dist.getNumericalMean(), Double.POSITIVE_INFINITY, tol); Assert.assertEquals(dist.getNumericalVariance(), Double.POSITIVE_INFINITY, tol); dist = new ParetoDistribution(2.2, 2.4); Assert.assertEquals(dist.getNumericalMean(), 3.771428571428, tol); Assert.assertEquals(dist.getNumericalVariance(), 14.816326530, tol); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.distribution; import org.junit.Assert; import org.junit.Test; /** * Test cases for PascalDistribution. * Extends IntegerDistributionAbstractTest. See class javadoc for * IntegerDistributionAbstractTest for details. * * @version $Id$ */ public class PascalDistributionTest extends IntegerDistributionAbstractTest { // --------------------- Override tolerance -------------- protected double defaultTolerance = NormalDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY; @Override public void setUp() { super.setUp(); setTolerance(defaultTolerance); } //-------------- Implementations for abstract methods ----------------------- /** Creates the default discrete distribution instance to use in tests. */ @Override public IntegerDistribution makeDistribution() { return new PascalDistribution(10,0.70); } /** Creates the default probability density test input values */ @Override public int[] makeDensityTestPoints() { return new int[] {-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}; } /** Creates the default probability density test expected values */ @Override public double[] makeDensityTestValues() { return new double[] {0, 0.0282475249, 0.0847425747, 0.139825248255, 0.167790297906, 0.163595540458, 0.137420253985, 0.103065190489, 0.070673273478, 0.0450542118422, 0.0270325271053, 0.0154085404500, 0.0084046584273}; } /** Creates the default cumulative probability density test input values */ @Override public int[] makeCumulativeTestPoints() { return makeDensityTestPoints(); } /** Creates the default cumulative probability density test expected values */ @Override public double[] makeCumulativeTestValues() { return new double[] {0, 0.0282475249, 0.1129900996, 0.252815347855, 0.420605645761, 0.584201186219, 0.721621440204, 0.824686630693, 0.895359904171, 0.940414116013, 0.967446643119, 0.982855183569, 0.991259841996}; } /** Creates the default inverse cumulative probability test input values */ @Override public double[] makeInverseCumulativeTestPoints() { return new double[] {0.0, 0.001, 0.010, 0.025, 0.050, 0.100, 0.999, 0.990, 0.975, 0.950, 0.900, 1.0}; } /** Creates the default inverse cumulative probability density test expected values */ @Override public int[] makeInverseCumulativeTestValues() { return new int[] {0, 0, 0, 0, 1, 1, 14, 11, 10, 9, 8, Integer.MAX_VALUE}; } //----------------- Additional test cases --------------------------------- /** Test degenerate case p = 0 */ @Test public void testDegenerate0() { setDistribution(new PascalDistribution(5, 0.0d)); setCumulativeTestPoints(new int[] {-1, 0, 1, 5, 10 }); setCumulativeTestValues(new double[] {0d, 0d, 0d, 0d, 0d}); setDensityTestPoints(new int[] {-1, 0, 1, 10, 11}); setDensityTestValues(new double[] {0d, 0d, 0d, 0d, 0d}); setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d}); setInverseCumulativeTestValues(new int[] {Integer.MAX_VALUE, Integer.MAX_VALUE}); verifyDensities(); verifyCumulativeProbabilities(); verifyInverseCumulativeProbabilities(); } /** Test degenerate case p = 1 */ @Test public void testDegenerate1() { setDistribution(new PascalDistribution(5, 1.0d)); setCumulativeTestPoints(new int[] {-1, 0, 1, 2, 5, 10 }); setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d, 1d}); setDensityTestPoints(new int[] {-1, 0, 1, 2, 5, 10}); setDensityTestValues(new double[] {0d, 1d, 0d, 0d, 0d, 0d}); setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d}); setInverseCumulativeTestValues(new int[] {0, 0}); verifyDensities(); verifyCumulativeProbabilities(); verifyInverseCumulativeProbabilities(); } @Test public void testMoments() { final double tol = 1e-9; PascalDistribution dist; dist = new PascalDistribution(10, 0.5); Assert.assertEquals(dist.getNumericalMean(), ( 10d * 0.5d ) / 0.5d, tol); Assert.assertEquals(dist.getNumericalVariance(), ( 10d * 0.5d ) / (0.5d * 0.5d), tol); dist = new PascalDistribution(25, 0.7); Assert.assertEquals(dist.getNumericalMean(), ( 25d * 0.3d ) / 0.7d, tol); Assert.assertEquals(dist.getNumericalVariance(), ( 25d * 0.3d ) / (0.7d * 0.7d), tol); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.distribution; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.junit.Assert; import org.junit.Test; /** * <code>PoissonDistributionTest</code> * * @version $Id$ */ public class PoissonDistributionTest extends IntegerDistributionAbstractTest { /** * Poisson parameter value for the test distribution. */ private static final double DEFAULT_TEST_POISSON_PARAMETER = 4.0; /** * Constructor. */ public PoissonDistributionTest() { setTolerance(1e-12); } /** * Creates the default discrete distribution instance to use in tests. */ @Override public IntegerDistribution makeDistribution() { return new PoissonDistribution(DEFAULT_TEST_POISSON_PARAMETER); } /** * Creates the default probability density test input values. */ @Override public int[] makeDensityTestPoints() { return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20}; } /** * Creates the default probability density test expected values. * These and all other test values are generated by R, version 1.8.1 */ @Override public double[] makeDensityTestValues() { return new double[] { 0d, 0.0183156388887d, 0.073262555555d, 0.14652511111d, 0.195366814813d, 0.195366814813, 0.156293451851d, 0.00529247667642d, 8.27746364655e-09}; } /** * Creates the default cumulative probability density test input values. */ @Override public int[] makeCumulativeTestPoints() { return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20 }; } /** * Creates the default cumulative probability density test expected values. */ @Override public double[] makeCumulativeTestValues() { return new double[] { 0d, 0.0183156388887d, 0.0915781944437d, 0.238103305554d, 0.433470120367d, 0.62883693518, 0.78513038703d, 0.99716023388d, 0.999999998077 }; } /** * Creates the default inverse cumulative probability test input values. */ @Override public double[] makeInverseCumulativeTestPoints() { IntegerDistribution dist = getDistribution(); return new double[] { 0d, 0.018315638886d, 0.018315638890d, 0.091578194441d, 0.091578194445d, 0.238103305552d, 0.238103305556d, dist.cumulativeProbability(3), dist.cumulativeProbability(4), dist.cumulativeProbability(5), dist.cumulativeProbability(10), dist.cumulativeProbability(20)}; } /** * Creates the default inverse cumulative probability density test expected values. */ @Override public int[] makeInverseCumulativeTestValues() { return new int[] { 0, 0, 1, 1, 2, 2, 3, 3, 4, 5, 10, 20}; } /** * Test the normal approximation of the Poisson distribution by * calculating P(90 &le; X &le; 110) for X = Po(100) and * P(9900 &le; X &le; 10200) for X = Po(10000) */ @Test public void testNormalApproximateProbability() { PoissonDistribution dist = new PoissonDistribution(100); double result = dist.normalApproximateProbability(110) - dist.normalApproximateProbability(89); Assert.assertEquals(0.706281887248, result, 1E-10); dist = new PoissonDistribution(10000); result = dist.normalApproximateProbability(10200) - dist.normalApproximateProbability(9899); Assert.assertEquals(0.820070051552, result, 1E-10); } /** * Test the degenerate cases of a 0.0 and 1.0 inverse cumulative probability. */ @Test public void testDegenerateInverseCumulativeProbability() { PoissonDistribution dist = new PoissonDistribution(DEFAULT_TEST_POISSON_PARAMETER); Assert.assertEquals(Integer.MAX_VALUE, dist.inverseCumulativeProbability(1.0d)); Assert.assertEquals(0, dist.inverseCumulativeProbability(0d)); } @Test(expected=NotStrictlyPositiveException.class) public void testNegativeMean() { new PoissonDistribution(-1); } @Test public void testMean() { PoissonDistribution dist = new PoissonDistribution(10.0); Assert.assertEquals(10.0, dist.getMean(), 0.0); } @Test public void testLargeMeanCumulativeProbability() { double mean = 1.0; while (mean <= 10000000.0) { PoissonDistribution dist = new PoissonDistribution(mean); double x = mean * 2.0; double dx = x / 10.0; double p = Double.NaN; double sigma = FastMath.sqrt(mean); while (x >= 0) { try { p = dist.cumulativeProbability((int) x); Assert.assertFalse("NaN cumulative probability returned for mean = " + mean + " x = " + x,Double.isNaN(p)); if (x > mean - 2 * sigma) { Assert.assertTrue("Zero cum probaility returned for mean = " + mean + " x = " + x, p > 0); } } catch (Exception ex) { Assert.fail("mean of " + mean + " and x of " + x + " caused " + ex.getMessage()); } x -= dx; } mean *= 10.0; } } /** * JIRA: MATH-282 */ @Test public void testCumulativeProbabilitySpecial() { PoissonDistribution dist; dist = new PoissonDistribution(9120); checkProbability(dist, 9075); checkProbability(dist, 9102); dist = new PoissonDistribution(5058); checkProbability(dist, 5044); dist = new PoissonDistribution(6986); checkProbability(dist, 6950); } private void checkProbability(PoissonDistribution dist, int x) { double p = dist.cumulativeProbability(x); Assert.assertFalse("NaN cumulative probability returned for mean = " + dist.getMean() + " x = " + x, Double.isNaN(p)); Assert.assertTrue("Zero cum probability returned for mean = " + dist.getMean() + " x = " + x, p > 0); } @Test public void testLargeMeanInverseCumulativeProbability() { double mean = 1.0; while (mean <= 100000.0) { // Extended test value: 1E7. Reduced to limit run time. PoissonDistribution dist = new PoissonDistribution(mean); double p = 0.1; double dp = p; while (p < .99) { try { int ret = dist.inverseCumulativeProbability(p); // Verify that returned value satisties definition Assert.assertTrue(p <= dist.cumulativeProbability(ret)); Assert.assertTrue(p > dist.cumulativeProbability(ret - 1)); } catch (Exception ex) { Assert.fail("mean of " + mean + " and p of " + p + " caused " + ex.getMessage()); } p += dp; } mean *= 10.0; } } @Test public void testMoments() { final double tol = 1e-9; PoissonDistribution dist; dist = new PoissonDistribution(1); Assert.assertEquals(dist.getNumericalMean(), 1, tol); Assert.assertEquals(dist.getNumericalVariance(), 1, tol); dist = new PoissonDistribution(11.23); Assert.assertEquals(dist.getNumericalMean(), 11.23, tol); Assert.assertEquals(dist.getNumericalVariance(), 11.23, tol); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.distribution; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.junit.Assert; import org.junit.Test; import org.apache.commons.math3.TestUtils; /** * Test cases for TDistribution. * Extends ContinuousDistributionAbstractTest. See class javadoc for * ContinuousDistributionAbstractTest for details. * * @version $Id$ */ public class TDistributionTest extends RealDistributionAbstractTest { //-------------- Implementations for abstract methods ----------------------- /** Creates the default continuous distribution instance to use in tests. */ @Override public TDistribution makeDistribution() { return new TDistribution(5.0); } /** Creates the default cumulative probability distribution test input values */ @Override public double[] makeCumulativeTestPoints() { // quantiles computed using R version 2.9.2 return new double[] {-5.89342953136, -3.36492999891, -2.57058183564, -2.01504837333, -1.47588404882, 5.89342953136, 3.36492999891, 2.57058183564, 2.01504837333, 1.47588404882}; } /** Creates the default cumulative probability density test expected values */ @Override public double[] makeCumulativeTestValues() { return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999, 0.990, 0.975, 0.950, 0.900}; } /** Creates the default probability density test expected values */ @Override public double[] makeDensityTestValues() { return new double[] {0.000756494565517, 0.0109109752919, 0.0303377878006, 0.0637967988952, 0.128289492005, 0.000756494565517, 0.0109109752919, 0.0303377878006, 0.0637967988952, 0.128289492005}; } // --------------------- Override tolerance -------------- @Override public void setUp() { super.setUp(); setTolerance(1E-9); } //---------------------------- Additional test cases ------------------------- /** * @see <a href="http://issues.apache.org/bugzilla/show_bug.cgi?id=27243"> * Bug report that prompted this unit test.</a> */ @Test public void testCumulativeProbabilityAgainstStackOverflow() { TDistribution td = new TDistribution(5.); td.cumulativeProbability(.1); td.cumulativeProbability(.01); } @Test public void testSmallDf() { setDistribution(new TDistribution(1d)); // quantiles computed using R version 2.9.2 setCumulativeTestPoints(new double[] {-318.308838986, -31.8205159538, -12.7062047362, -6.31375151468, -3.07768353718, 318.308838986, 31.8205159538, 12.7062047362, 6.31375151468, 3.07768353718}); setDensityTestValues(new double[] {3.14158231817e-06, 0.000314055924703, 0.00195946145194, 0.00778959736375, 0.0303958893917, 3.14158231817e-06, 0.000314055924703, 0.00195946145194, 0.00778959736375, 0.0303958893917}); setInverseCumulativeTestValues(getCumulativeTestPoints()); verifyCumulativeProbabilities(); verifyInverseCumulativeProbabilities(); verifyDensities(); } @Test public void testInverseCumulativeProbabilityExtremes() { setInverseCumulativeTestPoints(new double[] {0, 1}); setInverseCumulativeTestValues( new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY}); verifyInverseCumulativeProbabilities(); } @Test public void testDfAccessors() { TDistribution dist = (TDistribution) getDistribution(); Assert.assertEquals(5d, dist.getDegreesOfFreedom(), Double.MIN_VALUE); } @Test(expected=NotStrictlyPositiveException.class) public void testPreconditions() { new TDistribution(0); } @Test public void testMoments() { final double tol = 1e-9; TDistribution dist; dist = new TDistribution(1); Assert.assertTrue(Double.isNaN(dist.getNumericalMean())); Assert.assertTrue(Double.isNaN(dist.getNumericalVariance())); dist = new TDistribution(1.5); Assert.assertEquals(dist.getNumericalMean(), 0, tol); Assert.assertTrue(Double.isInfinite(dist.getNumericalVariance())); dist = new TDistribution(5); Assert.assertEquals(dist.getNumericalMean(), 0, tol); Assert.assertEquals(dist.getNumericalVariance(), 5d / (5d - 2d), tol); } /* * Adding this test to benchmark against tables published by NIST * http://itl.nist.gov/div898/handbook/eda/section3/eda3672.htm * Have chosen tabulated results for degrees of freedom 2,10,30,100 * Have chosen problevels from 0.10 to 0.001 */ @Test public void nistData(){ double[] prob = new double[]{ 0.10,0.05,0.025,0.01,0.005,0.001}; double[] args2 = new double[]{1.886,2.920,4.303,6.965,9.925,22.327}; double[] args10 = new double[]{1.372,1.812,2.228,2.764,3.169,4.143}; double[] args30 = new double[]{1.310,1.697,2.042,2.457,2.750,3.385}; double[] args100= new double[]{1.290,1.660,1.984,2.364,2.626,3.174}; TestUtils.assertEquals(prob, makeNistResults(args2, 2), 1.0e-4); TestUtils.assertEquals(prob, makeNistResults(args10, 10), 1.0e-4); TestUtils.assertEquals(prob, makeNistResults(args30, 30), 1.0e-4); TestUtils.assertEquals(prob, makeNistResults(args100, 100), 1.0e-4); return; } private double[] makeNistResults(double[] args, int df){ TDistribution td = new TDistribution(df); double[] res = new double[ args.length ]; for( int i = 0 ; i < res.length ; i++){ res[i] = 1.0 - td.cumulativeProbability(args[i]); } return res; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.distribution; import org.apache.commons.math3.exception.NumberIsTooLargeException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.junit.Assert; import org.junit.Test; /** * Test cases for {@link TriangularDistribution}. See class javadoc for * {@link RealDistributionAbstractTest} for further details. */ public class TriangularDistributionTest extends RealDistributionAbstractTest { // --- Override tolerance ------------------------------------------------- @Override public void setUp() { super.setUp(); setTolerance(1e-4); } //--- Implementations for abstract methods -------------------------------- /** * Creates the default triangular distribution instance to use in tests. */ @Override public TriangularDistribution makeDistribution() { // Left side 5 wide, right side 10 wide. return new TriangularDistribution(-3, 2, 12); } /** * Creates the default cumulative probability distribution test input * values. */ @Override public double[] makeCumulativeTestPoints() { return new double[] { -3.0001, // below lower limit -3.0, // at lower limit -2.0, -1.0, 0.0, 1.0, // on lower side 2.0, // at mode 3.0, 4.0, 10.0, 11.0, // on upper side 12.0, // at upper limit 12.0001 // above upper limit }; } /** * Creates the default cumulative probability density test expected values. */ @Override public double[] makeCumulativeTestValues() { // Top at 2 / (b - a) = 2 / (12 - -3) = 2 / 15 = 7.5 // Area left = 7.5 * 5 * 0.5 = 18.75 (1/3 of the total area) // Area right = 7.5 * 10 * 0.5 = 37.5 (2/3 of the total area) // Area total = 18.75 + 37.5 = 56.25 // Derivative left side = 7.5 / 5 = 1.5 // Derivative right side = -7.5 / 10 = -0.75 double third = 1 / 3.0; double left = 18.75; double area = 56.25; return new double[] { 0.0, 0.0, 0.75 / area, 3 / area, 6.75 / area, 12 / area, third, (left + 7.125) / area, (left + 13.5) / area, (left + 36) / area, (left + 37.125) / area, 1.0, 1.0 }; } /** * Creates the default inverse cumulative probability distribution test * input values. */ @Override public double[] makeInverseCumulativeTestPoints() { // Exclude the points outside the limits, as they have cumulative // probability of zero and one, meaning the inverse returns the // limits and not the points outside the limits. double[] points = makeCumulativeTestValues(); double[] points2 = new double[points.length-2]; System.arraycopy(points, 1, points2, 0, points2.length); return points2; //return Arrays.copyOfRange(points, 1, points.length - 1); } /** * Creates the default inverse cumulative probability density test expected * values. */ @Override public double[] makeInverseCumulativeTestValues() { // Exclude the points outside the limits, as they have cumulative // probability of zero and one, meaning the inverse returns the // limits and not the points outside the limits. double[] points = makeCumulativeTestPoints(); double[] points2 = new double[points.length-2]; System.arraycopy(points, 1, points2, 0, points2.length); return points2; //return Arrays.copyOfRange(points, 1, points.length - 1); } /** Creates the default probability density test expected values. */ @Override public double[] makeDensityTestValues() { return new double[] { 0, 0, 2 / 75.0, 4 / 75.0, 6 / 75.0, 8 / 75.0, 10 / 75.0, 9 / 75.0, 8 / 75.0, 2 / 75.0, 1 / 75.0, 0, 0 }; } //--- Additional test cases ----------------------------------------------- /** Test lower bound getter. */ @Test public void testGetLowerBound() { TriangularDistribution distribution = makeDistribution(); Assert.assertEquals(-3.0, distribution.getSupportLowerBound(), 0); } /** Test upper bound getter. */ @Test public void testGetUpperBound() { TriangularDistribution distribution = makeDistribution(); Assert.assertEquals(12.0, distribution.getSupportUpperBound(), 0); } /** Test pre-condition for equal lower/upper limit. */ @Test(expected=NumberIsTooLargeException.class) public void testPreconditions1() { new TriangularDistribution(0, 0, 0); } /** Test pre-condition for lower limit larger than upper limit. */ @Test(expected=NumberIsTooLargeException.class) public void testPreconditions2() { new TriangularDistribution(1, 1, 0); } /** Test pre-condition for mode larger than upper limit. */ @Test(expected=NumberIsTooLargeException.class) public void testPreconditions3() { new TriangularDistribution(0, 2, 1); } /** Test pre-condition for mode smaller than lower limit. */ @Test(expected=NumberIsTooSmallException.class) public void testPreconditions4() { new TriangularDistribution(2, 1, 3); } /** Test mean/variance. */ @Test public void testMeanVariance() { TriangularDistribution dist; dist = new TriangularDistribution(0, 0.5, 1.0); Assert.assertEquals(dist.getNumericalMean(), 0.5, 0); Assert.assertEquals(dist.getNumericalVariance(), 1 / 24.0, 0); dist = new TriangularDistribution(0, 1, 1); Assert.assertEquals(dist.getNumericalMean(), 2 / 3.0, 0); Assert.assertEquals(dist.getNumericalVariance(), 1 / 18.0, 0); dist = new TriangularDistribution(-3, 2, 12); Assert.assertEquals(dist.getNumericalMean(), 3 + (2 / 3.0), 0); Assert.assertEquals(dist.getNumericalVariance(), 175 / 18.0, 0); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.distribution; import org.junit.Assert; import org.junit.Test; /** * Test cases for UniformIntegerDistribution. See class javadoc for * {@link IntegerDistributionAbstractTest} for further details. */ public class UniformIntegerDistributionTest extends IntegerDistributionAbstractTest { // --- Override tolerance ------------------------------------------------- @Override public void setUp() { super.setUp(); setTolerance(1e-9); } //--- Implementations for abstract methods -------------------------------- /** Creates the default discrete distribution instance to use in tests. */ @Override public IntegerDistribution makeDistribution() { return new UniformIntegerDistribution(-3, 5); } /** Creates the default probability density test input values. */ @Override public int[] makeDensityTestPoints() { return new int[] {-4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6}; } /** Creates the default probability density test expected values. */ @Override public double[] makeDensityTestValues() { double d = 1.0 / (5 - -3 + 1); return new double[] {0, d, d, d, d, d, d, d, d, d, 0}; } /** Creates the default cumulative probability density test input values. */ @Override public int[] makeCumulativeTestPoints() { return makeDensityTestPoints(); } /** Creates the default cumulative probability density test expected values. */ @Override public double[] makeCumulativeTestValues() { return new double[] {0, 1 / 9.0, 2 / 9.0, 3 / 9.0, 4 / 9.0, 5 / 9.0, 6 / 9.0, 7 / 9.0, 8 / 9.0, 1, 1}; } /** Creates the default inverse cumulative probability test input values */ @Override public double[] makeInverseCumulativeTestPoints() { return new double[] {0, 0.001, 0.010, 0.025, 0.050, 0.100, 0.200, 0.5, 0.999, 0.990, 0.975, 0.950, 0.900, 1}; } /** Creates the default inverse cumulative probability density test expected values */ @Override public int[] makeInverseCumulativeTestValues() { return new int[] {-3, -3, -3, -3, -3, -3, -2, 1, 5, 5, 5, 5, 5, 5}; } //--- Additional test cases ----------------------------------------------- /** Test mean/variance. */ @Test public void testMoments() { UniformIntegerDistribution dist; dist = new UniformIntegerDistribution(0, 5); Assert.assertEquals(dist.getNumericalMean(), 2.5, 0); Assert.assertEquals(dist.getNumericalVariance(), 35 / 12.0, 0); dist = new UniformIntegerDistribution(0, 1); Assert.assertEquals(dist.getNumericalMean(), 0.5, 0); Assert.assertEquals(dist.getNumericalVariance(), 3 / 12.0, 0); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.distribution; import org.apache.commons.math3.exception.NumberIsTooLargeException; import org.junit.Assert; import org.junit.Test; /** * Test cases for UniformRealDistribution. See class javadoc for * {@link RealDistributionAbstractTest} for further details. */ public class UniformRealDistributionTest extends RealDistributionAbstractTest { // --- Override tolerance ------------------------------------------------- @Override public void setUp() { super.setUp(); setTolerance(1e-4); } //--- Implementations for abstract methods -------------------------------- /** Creates the default uniform real distribution instance to use in tests. */ @Override public UniformRealDistribution makeDistribution() { return new UniformRealDistribution(-0.5, 1.25); } /** Creates the default cumulative probability distribution test input values */ @Override public double[] makeCumulativeTestPoints() { return new double[] {-0.5001, -0.5, -0.4999, -0.25, -0.0001, 0.0, 0.0001, 0.25, 1.0, 1.2499, 1.25, 1.2501}; } /** Creates the default cumulative probability density test expected values */ @Override public double[] makeCumulativeTestValues() { return new double[] {0.0, 0.0, 0.0001, 0.25/1.75, 0.4999/1.75, 0.5/1.75, 0.5001/1.75, 0.75/1.75, 1.5/1.75, 1.7499/1.75, 1.0, 1.0}; } /** Creates the default probability density test expected values */ @Override public double[] makeDensityTestValues() { double d = 1 / 1.75; return new double[] {0, d, d, d, d, d, d, d, d, d, d, 0}; } //--- Additional test cases ----------------------------------------------- /** Test lower bound getter. */ @Test public void testGetLowerBound() { UniformRealDistribution distribution = makeDistribution(); Assert.assertEquals(-0.5, distribution.getSupportLowerBound(), 0); } /** Test upper bound getter. */ @Test public void testGetUpperBound() { UniformRealDistribution distribution = makeDistribution(); Assert.assertEquals(1.25, distribution.getSupportUpperBound(), 0); } /** Test pre-condition for equal lower/upper bound. */ @Test(expected=NumberIsTooLargeException.class) public void testPreconditions1() { new UniformRealDistribution(0, 0); } /** Test pre-condition for lower bound larger than upper bound. */ @Test(expected=NumberIsTooLargeException.class) public void testPreconditions2() { new UniformRealDistribution(1, 0); } /** Test mean/variance. */ @Test public void testMeanVariance() { UniformRealDistribution dist; dist = new UniformRealDistribution(0, 1); Assert.assertEquals(dist.getNumericalMean(), 0.5, 0); Assert.assertEquals(dist.getNumericalVariance(), 1/12.0, 0); dist = new UniformRealDistribution(-1.5, 0.6); Assert.assertEquals(dist.getNumericalMean(), -0.45, 0); Assert.assertEquals(dist.getNumericalVariance(), 0.3675, 0); dist = new UniformRealDistribution(-0.5, 1.25); Assert.assertEquals(dist.getNumericalMean(), 0.375, 0); Assert.assertEquals(dist.getNumericalVariance(), 0.2552083333333333, 0); } /** * Check accuracy of analytical inverse CDF. Fails if a solver is used * with the default accuracy. */ @Test public void testInverseCumulativeDistribution() { UniformRealDistribution dist = new UniformRealDistribution(0, 1e-9); Assert.assertEquals(2.5e-10, dist.inverseCumulativeProbability(0.25), 0); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.distribution; import org.apache.commons.math3.special.Gamma; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.junit.Assert; import org.junit.Test; /** * Test cases for WeibullDistribution. * Extends ContinuousDistributionAbstractTest. See class javadoc for * ContinuousDistributionAbstractTest for details. * * @version $Id$ */ public class WeibullDistributionTest extends RealDistributionAbstractTest { //-------------- Implementations for abstract methods ----------------------- /** Creates the default continuous distribution instance to use in tests. */ @Override public WeibullDistribution makeDistribution() { return new WeibullDistribution(1.2, 2.1); } /** Creates the default cumulative probability distribution test input values */ @Override public double[] makeCumulativeTestPoints() { // quantiles computed using R version 2.9.2 return new double[] {0.00664355180993, 0.0454328283309, 0.0981162737374, 0.176713524579, 0.321946865392, 10.5115496887, 7.4976304671, 6.23205600701, 5.23968436955, 4.2079028257}; } /** Creates the default cumulative probability density test expected values */ @Override public double[] makeCumulativeTestValues() { return new double[] {0.001, 0.01, 0.025, 0.05, 0.1, 0.999, 0.990, 0.975, 0.950, 0.900}; } /** Creates the default probability density test expected values */ @Override public double[] makeDensityTestValues() { return new double[] {0.180535929306, 0.262801138133, 0.301905425199, 0.330899152971, 0.353441418887, 0.000788590320203, 0.00737060094841, 0.0177576041516, 0.0343043442574, 0.065664589369}; } //---------------------------- Additional test cases ------------------------- @Test public void testInverseCumulativeProbabilityExtremes() { setInverseCumulativeTestPoints(new double[] {0.0, 1.0}); setInverseCumulativeTestValues( new double[] {0.0, Double.POSITIVE_INFINITY}); verifyInverseCumulativeProbabilities(); } @Test public void testAlpha() { WeibullDistribution dist = new WeibullDistribution(1, 2); Assert.assertEquals(1, dist.getShape(), 0); try { new WeibullDistribution(0, 2); Assert.fail("NotStrictlyPositiveException expected"); } catch (NotStrictlyPositiveException e) { // Expected. } } @Test public void testBeta() { WeibullDistribution dist = new WeibullDistribution(1, 2); Assert.assertEquals(2, dist.getScale(), 0); try { new WeibullDistribution(1, 0); Assert.fail("NotStrictlyPositiveException expected"); } catch (NotStrictlyPositiveException e) { // Expected. } } @Test public void testMoments() { final double tol = 1e-9; WeibullDistribution dist; dist = new WeibullDistribution(2.5, 3.5); // In R: 3.5*gamma(1+(1/2.5)) (or emperically: mean(rweibull(10000, 2.5, 3.5))) Assert.assertEquals(dist.getNumericalMean(), 3.5 * FastMath.exp(Gamma.logGamma(1 + (1 / 2.5))), tol); Assert.assertEquals(dist.getNumericalVariance(), (3.5 * 3.5) * FastMath.exp(Gamma.logGamma(1 + (2 / 2.5))) - (dist.getNumericalMean() * dist.getNumericalMean()), tol); dist = new WeibullDistribution(10.4, 2.222); Assert.assertEquals(dist.getNumericalMean(), 2.222 * FastMath.exp(Gamma.logGamma(1 + (1 / 10.4))), tol); Assert.assertEquals(dist.getNumericalVariance(), (2.222 * 2.222) * FastMath.exp(Gamma.logGamma(1 + (2 / 10.4))) - (dist.getNumericalMean() * dist.getNumericalMean()), tol); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.distribution; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * Test cases for {@link ZipfDistribution}. * Extends IntegerDistributionAbstractTest. See class javadoc for * IntegerDistributionAbstractTest for details. * * @version $Id$ */ public class ZipfDistributionTest extends IntegerDistributionAbstractTest { @Test(expected=NotStrictlyPositiveException.class) public void testPreconditions1() { new ZipfDistribution(0, 1); } @Test(expected=NotStrictlyPositiveException.class) public void testPreconditions2() { new ZipfDistribution(1, 0); } //-------------- Implementations for abstract methods ----------------------- /** Creates the default discrete distribution instance to use in tests. */ @Override public IntegerDistribution makeDistribution() { return new ZipfDistribution(10, 1); } /** Creates the default probability density test input values */ @Override public int[] makeDensityTestPoints() { return new int[] {-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}; } /** Creates the default probability density test expected values */ @Override public double[] makeDensityTestValues() { return new double[] {0d, 0d, 0.3414d, 0.1707d, 0.1138d, 0.0854d, 0.0683d, 0.0569d, 0.0488d, 0.0427d, 0.0379d, 0.0341d, 0d}; } /** Creates the default cumulative probability density test input values */ @Override public int[] makeCumulativeTestPoints() { return makeDensityTestPoints(); } /** Creates the default cumulative probability density test expected values */ @Override public double[] makeCumulativeTestValues() { return new double[] {0d, 0.0000d, 0.3414d, 0.5121d, 0.6259d, 0.7113d, 0.7796d, 0.8365d, 0.8852d, 0.9279d, 0.9659d, 1d, 1d}; } /** Creates the default inverse cumulative probability test input values */ @Override public double[] makeInverseCumulativeTestPoints() { return new double[] {0d, 0.001d, 0.010d, 0.025d, 0.050d, 0.3413d, 0.3415d, 0.999d, 0.990d, 0.975d, 0.950d, 0.900d, 1d}; } /** Creates the default inverse cumulative probability density test expected values */ @Override public int[] makeInverseCumulativeTestValues() { return new int[] {1, 1, 1, 1, 1, 1, 2, 10, 10, 10, 9, 8, 10}; } @Test public void testMoments() { final double tol = 1e-9; ZipfDistribution dist; dist = new ZipfDistribution(2, 0.5); Assert.assertEquals(dist.getNumericalMean(), FastMath.sqrt(2), tol); Assert.assertEquals(dist.getNumericalVariance(), 0.24264068711928521, tol); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the * License for the specific language governing permissions and limitations under * the License. */ package org.apache.commons.math3.distribution.fitting; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import org.apache.commons.math3.distribution.MixtureMultivariateNormalDistribution; import org.apache.commons.math3.distribution.MultivariateNormalDistribution; import org.apache.commons.math3.exception.ConvergenceException; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.linear.Array2DRowRealMatrix; import org.apache.commons.math3.linear.RealMatrix; import org.apache.commons.math3.util.Pair; import org.junit.Assert; import org.junit.Test; /** * Test that demonstrates the use of * {@link MultivariateNormalMixtureExpectationMaximization}. */ public class MultivariateNormalMixtureExpectationMaximizationTest { @Test(expected = NotStrictlyPositiveException.class) public void testNonEmptyData() { // Should not accept empty data new MultivariateNormalMixtureExpectationMaximization(new double[][] {}); } @Test(expected = DimensionMismatchException.class) public void testNonJaggedData() { // Reject data with nonconstant numbers of columns double[][] data = new double[][] { { 1, 2, 3 }, { 4, 5, 6, 7 }, }; new MultivariateNormalMixtureExpectationMaximization(data); } @Test(expected = NumberIsTooSmallException.class) public void testMultipleColumnsRequired() { // Data should have at least 2 columns double[][] data = new double[][] { { 1 }, { 2 } }; new MultivariateNormalMixtureExpectationMaximization(data); } @Test(expected = NotStrictlyPositiveException.class) public void testMaxIterationsPositive() { // Maximum iterations for fit must be positive integer double[][] data = getTestSamples(); MultivariateNormalMixtureExpectationMaximization fitter = new MultivariateNormalMixtureExpectationMaximization(data); MixtureMultivariateNormalDistribution initialMix = MultivariateNormalMixtureExpectationMaximization.estimate(data, 2); fitter.fit(initialMix, 0, 1E-5); } @Test(expected = NotStrictlyPositiveException.class) public void testThresholdPositive() { // Maximum iterations for fit must be positive double[][] data = getTestSamples(); MultivariateNormalMixtureExpectationMaximization fitter = new MultivariateNormalMixtureExpectationMaximization( data); MixtureMultivariateNormalDistribution initialMix = MultivariateNormalMixtureExpectationMaximization.estimate(data, 2); fitter.fit(initialMix, 1000, 0); } @Test(expected = ConvergenceException.class) public void testConvergenceException() { // ConvergenceException thrown if fit terminates before threshold met double[][] data = getTestSamples(); MultivariateNormalMixtureExpectationMaximization fitter = new MultivariateNormalMixtureExpectationMaximization(data); MixtureMultivariateNormalDistribution initialMix = MultivariateNormalMixtureExpectationMaximization.estimate(data, 2); // 5 iterations not enough to meet convergence threshold fitter.fit(initialMix, 5, 1E-5); } @Test(expected = DimensionMismatchException.class) public void testIncompatibleIntialMixture() { // Data has 3 columns double[][] data = new double[][] { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; double[] weights = new double[] { 0.5, 0.5 }; // These distributions are compatible with 2-column data, not 3-column // data MultivariateNormalDistribution[] mvns = new MultivariateNormalDistribution[2]; mvns[0] = new MultivariateNormalDistribution(new double[] { -0.0021722935000328823, 3.5432892936887908 }, new double[][] { { 4.537422569229048, 3.5266152281729304 }, { 3.5266152281729304, 6.175448814169779 } }); mvns[1] = new MultivariateNormalDistribution(new double[] { 5.090902706507635, 8.68540656355283 }, new double[][] { { 2.886778573963039, 1.5257474543463154 }, { 1.5257474543463154, 3.3794567673616918 } }); // Create components and mixture List<Pair<Double, MultivariateNormalDistribution>> components = new ArrayList<Pair<Double, MultivariateNormalDistribution>>(); components.add(new Pair<Double, MultivariateNormalDistribution>( weights[0], mvns[0])); components.add(new Pair<Double, MultivariateNormalDistribution>( weights[1], mvns[1])); MixtureMultivariateNormalDistribution badInitialMix = new MixtureMultivariateNormalDistribution(components); MultivariateNormalMixtureExpectationMaximization fitter = new MultivariateNormalMixtureExpectationMaximization(data); fitter.fit(badInitialMix); } @Test public void testInitialMixture() { // Testing initial mixture estimated from data final double[] correctWeights = new double[] { 0.5, 0.5 }; final double[][] correctMeans = new double[][] { {-0.0021722935000328823, 3.5432892936887908}, {5.090902706507635, 8.68540656355283}, }; final RealMatrix[] correctCovMats = new Array2DRowRealMatrix[2]; correctCovMats[0] = new Array2DRowRealMatrix(new double[][] { { 4.537422569229048, 3.5266152281729304 }, { 3.5266152281729304, 6.175448814169779 } }); correctCovMats[1] = new Array2DRowRealMatrix( new double[][] { { 2.886778573963039, 1.5257474543463154 }, { 1.5257474543463154, 3.3794567673616918 } }); final MultivariateNormalDistribution[] correctMVNs = new MultivariateNormalDistribution[2]; correctMVNs[0] = new MultivariateNormalDistribution(correctMeans[0], correctCovMats[0].getData()); correctMVNs[1] = new MultivariateNormalDistribution(correctMeans[1], correctCovMats[1].getData()); final MixtureMultivariateNormalDistribution initialMix = MultivariateNormalMixtureExpectationMaximization.estimate(getTestSamples(), 2); int i = 0; for (Pair<Double, MultivariateNormalDistribution> component : initialMix .getComponents()) { Assert.assertEquals(correctWeights[i], component.getFirst(), Math.ulp(1d)); final double[] means = component.getValue().getMeans(); Assert.assertTrue(Arrays.equals(correctMeans[i], means)); final RealMatrix covMat = component.getValue().getCovariances(); Assert.assertEquals(correctCovMats[i], covMat); i++; } } @Test public void testFit() { // Test that the loglikelihood, weights, and models are determined and // fitted correctly final double[][] data = getTestSamples(); final double correctLogLikelihood = -4.292431006791994; final double[] correctWeights = new double[] { 0.2962324189652912, 0.7037675810347089 }; final double[][] correctMeans = new double[][]{ {-1.4213112715121132, 1.6924690505757753}, {4.213612224374709, 7.975621325853645} }; final RealMatrix[] correctCovMats = new Array2DRowRealMatrix[2]; correctCovMats[0] = new Array2DRowRealMatrix(new double[][] { { 1.739356907285747, -0.5867644251487614 }, { -0.5867644251487614, 1.0232932029324642 } } ); correctCovMats[1] = new Array2DRowRealMatrix(new double[][] { { 4.245384898007161, 2.5797798966382155 }, { 2.5797798966382155, 3.9200272522448367 } }); final MultivariateNormalDistribution[] correctMVNs = new MultivariateNormalDistribution[2]; correctMVNs[0] = new MultivariateNormalDistribution(correctMeans[0], correctCovMats[0].getData()); correctMVNs[1] = new MultivariateNormalDistribution(correctMeans[1], correctCovMats[1].getData()); MultivariateNormalMixtureExpectationMaximization fitter = new MultivariateNormalMixtureExpectationMaximization(data); MixtureMultivariateNormalDistribution initialMix = MultivariateNormalMixtureExpectationMaximization.estimate(data, 2); fitter.fit(initialMix); MixtureMultivariateNormalDistribution fittedMix = fitter.getFittedModel(); List<Pair<Double, MultivariateNormalDistribution>> components = fittedMix.getComponents(); Assert.assertEquals(correctLogLikelihood, fitter.getLogLikelihood(), Math.ulp(1d)); int i = 0; for (Pair<Double, MultivariateNormalDistribution> component : components) { final double weight = component.getFirst(); final MultivariateNormalDistribution mvn = component.getSecond(); final double[] mean = mvn.getMeans(); final RealMatrix covMat = mvn.getCovariances(); Assert.assertEquals(correctWeights[i], weight, Math.ulp(1d)); Assert.assertTrue(Arrays.equals(correctMeans[i], mean)); Assert.assertEquals(correctCovMats[i], covMat); i++; } } private double[][] getTestSamples() { // generated using R Mixtools rmvnorm with mean vectors [-1.5, 2] and // [4, 8.2] return new double[][] { { 7.358553610469948, 11.31260831446758 }, { 7.175770420124739, 8.988812210204454 }, { 4.324151905768422, 6.837727899051482 }, { 2.157832219173036, 6.317444585521968 }, { -1.890157421896651, 1.74271202875498 }, { 0.8922409354455803, 1.999119343923781 }, { 3.396949764787055, 6.813170372579068 }, { -2.057498232686068, -0.002522983830852255 }, { 6.359932157365045, 8.343600029975851 }, { 3.353102234276168, 7.087541882898689 }, { -1.763877221595639, 0.9688890460330644 }, { 6.151457185125111, 9.075011757431174 }, { 4.281597398048899, 5.953270070976117 }, { 3.549576703974894, 8.616038155992861 }, { 6.004706732349854, 8.959423391087469 }, { 2.802915014676262, 6.285676742173564 }, { -0.6029879029880616, 1.083332958357485 }, { 3.631827105398369, 6.743428504049444 }, { 6.161125014007315, 9.60920569689001 }, { -1.049582894255342, 0.2020017892080281 }, { 3.910573022688315, 8.19609909534937 }, { 8.180454017634863, 7.861055769719962 }, { 1.488945440439716, 8.02699903761247 }, { 4.813750847823778, 12.34416881332515 }, { 0.0443208501259158, 5.901148093240691 }, { 4.416417235068346, 4.465243084006094 }, { 4.0002433603072, 6.721937850166174 }, { 3.190113818788205, 10.51648348411058 }, { 4.493600914967883, 7.938224231022314 }, { -3.675669533266189, 4.472845076673303 }, { 6.648645511703989, 12.03544085965724 }, { -1.330031331404445, 1.33931042964811 }, { -3.812111460708707, 2.50534195568356 }, { 5.669339356648331, 6.214488981177026 }, { 1.006596727153816, 1.51165463112716 }, { 5.039466365033024, 7.476532610478689 }, { 4.349091929968925, 7.446356406259756 }, { -1.220289665119069, 3.403926955951437 }, { 5.553003979122395, 6.886518211202239 }, { 2.274487732222856, 7.009541508533196 }, { 4.147567059965864, 7.34025244349202 }, { 4.083882618965819, 6.362852861075623 }, { 2.203122344647599, 7.260295257904624 }, { -2.147497550770442, 1.262293431529498 }, { 2.473700950426512, 6.558900135505638 }, { 8.267081298847554, 12.10214104577748 }, { 6.91977329776865, 9.91998488301285 }, { 0.1680479852730894, 6.28286034168897 }, { -1.268578659195158, 2.326711221485755 }, { 1.829966451374701, 6.254187605304518 }, { 5.648849025754848, 9.330002040750291 }, { -2.302874793257666, 3.585545172776065 }, { -2.629218791709046, 2.156215538500288 }, { 4.036618140700114, 10.2962785719958 }, { 0.4616386422783874, 0.6782756325806778 }, { -0.3447896073408363, 0.4999834691645118 }, { -0.475281453118318, 1.931470384180492 }, { 2.382509690609731, 6.071782429815853 }, { -3.203934441889096, 2.572079552602468 }, { 8.465636032165087, 13.96462998683518 }, { 2.36755660870416, 5.7844595007273 }, { 0.5935496528993371, 1.374615871358943 }, { -2.467481505748694, 2.097224634713005 }, { 4.27867444328542, 10.24772361238549 }, { -2.013791907543137, 2.013799426047639 }, { 6.424588084404173, 9.185334939684516 }, { -0.8448238876802175, 0.5447382022282812 }, { 1.342955703473923, 8.645456317633556 }, { 3.108712208751979, 8.512156853800064 }, { 4.343205178315472, 8.056869549234374 }, { -2.971767642212396, 3.201180146824761 }, { 2.583820931523672, 5.459873414473854 }, { 4.209139115268925, 8.171098193546225 }, { 0.4064909057902746, 1.454390775518743 }, { 3.068642411145223, 6.959485153620035 }, { 6.085968972900461, 7.391429799500965 }, { -1.342265795764202, 1.454550012997143 }, { 6.249773274516883, 6.290269880772023 }, { 4.986225847822566, 7.75266344868907 }, { 7.642443254378944, 10.19914817500263 }, { 6.438181159163673, 8.464396764810347 }, { 2.520859761025108, 7.68222425260111 }, { 2.883699944257541, 6.777960331348503 }, { 2.788004550956599, 6.634735386652733 }, { 3.331661231995638, 5.794191300046592 }, { 3.526172276645504, 6.710802266815884 }, { 3.188298528138741, 10.34495528210205 }, { 0.7345539486114623, 5.807604004180681 }, { 1.165044595880125, 7.830121829295257 }, { 7.146962523500671, 11.62995162065415 }, { 7.813872137162087, 10.62827008714735 }, { 3.118099164870063, 8.286003148186371 }, { -1.708739286262571, 1.561026755374264 }, { 1.786163047580084, 4.172394388214604 }, { 3.718506403232386, 7.807752990130349 }, { 6.167414046828899, 10.01104941031293 }, { -1.063477247689196, 1.61176085846339 }, { -3.396739609433642, 0.7127911050002151 }, { 2.438885945896797, 7.353011138689225 }, { -0.2073204144780931, 0.850771146627012 }, }; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.exception; import org.junit.Assert; import org.junit.Test; /** * Test for {@link DimensionMismatchException}. * * @version $Id$ */ public class DimensionMismatchExceptionTest { @Test public void testAccessors() { final DimensionMismatchException e = new DimensionMismatchException(1, 2); Assert.assertEquals(1, e.getArgument()); Assert.assertEquals(2, e.getDimension()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.exception; import org.junit.Assert; import org.junit.Test; /** * Test for {@link MaxCountExceededException}. * * @version $Id$ */ public class MaxCountExceededExceptionTest { @Test public void testAccessors() { final MaxCountExceededException e = new MaxCountExceededException(10); Assert.assertEquals(10, e.getMax()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.exception; import org.apache.commons.math3.util.MathArrays; import org.junit.Assert; import org.junit.Test; /** * Test for {@link NonMonotonicSequenceException}. * * @version $Id$ */ public class NonMonotonicSequenceExceptionTest { @Test public void testAccessors() { NonMonotonicSequenceException e = new NonMonotonicSequenceException(0, -1, 1, MathArrays.OrderDirection.DECREASING, false); Assert.assertEquals(0, e.getArgument()); Assert.assertEquals(-1, e.getPrevious()); Assert.assertEquals(1, e.getIndex()); Assert.assertTrue(e.getDirection() == MathArrays.OrderDirection.DECREASING); Assert.assertFalse(e.getStrict()); e = new NonMonotonicSequenceException(-1, 0, 1); Assert.assertEquals(-1, e.getArgument()); Assert.assertEquals(0, e.getPrevious()); Assert.assertEquals(1, e.getIndex()); Assert.assertTrue(e.getDirection() == MathArrays.OrderDirection.INCREASING); Assert.assertTrue(e.getStrict()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.exception; import org.junit.Assert; import org.junit.Test; /** * Test for {@link NotPositiveException}. * * @version $Id$ */ public class NotPositiveExceptionTest { @Test public void testAccessors() { final NotPositiveException e = new NotPositiveException(-1); Assert.assertEquals(-1, e.getArgument()); Assert.assertEquals(0, e.getMin()); Assert.assertTrue(e.getBoundIsAllowed()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.exception; import org.junit.Assert; import org.junit.Test; /** * Test for {@link NotStrictlyPositiveException}. * * @version $Id$ */ public class NotStrictlyPositiveExceptionTest { @Test public void testAccessors() { final NotStrictlyPositiveException e = new NotStrictlyPositiveException(0); Assert.assertEquals(0, e.getArgument()); Assert.assertEquals(0, e.getMin()); Assert.assertFalse(e.getBoundIsAllowed()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.exception; import org.junit.Assert; import org.junit.Test; /** * Test for {@link NumberIsTooLargeException}. * * @version $Id$ */ public class NumberIsTooLargeExceptionTest { @Test public void testAccessors() { final NumberIsTooLargeException e = new NumberIsTooLargeException(1, 0, true); Assert.assertEquals(1, e.getArgument()); Assert.assertEquals(0, e.getMax()); Assert.assertTrue(e.getBoundIsAllowed()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.exception; import org.junit.Assert; import org.junit.Test; /** * Test for {@link NumberIsTooSmallException}. * * @version $Id$ */ public class NumberIsTooSmallExceptionTest { @Test public void testAccessors() { final NumberIsTooSmallException e = new NumberIsTooSmallException(0, 0, false); Assert.assertEquals(0, e.getArgument()); Assert.assertEquals(0, e.getMin()); Assert.assertFalse(e.getBoundIsAllowed()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.exception; import org.junit.Assert; import org.junit.Test; /** * Test for {@link OutOfRangeException}. * * @version $Id$ */ public class OutOfRangeExceptionTest { @Test public void testAccessors() { final OutOfRangeException e = new OutOfRangeException(-1, 0, 2); Assert.assertEquals(-1, e.getArgument()); Assert.assertEquals(0, e.getLo()); Assert.assertEquals(2, e.getHi()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.exception; import java.text.MessageFormat; import org.junit.Assert; import org.junit.Test; /** * Test for {@link TooManyEvaluationsException}. * * @version $Id$ */ public class TooManyEvaluationsExceptionTest { @Test public void testMessage() { final int max = 12345; final TooManyEvaluationsException e = new TooManyEvaluationsException(max); final String msg = e.getLocalizedMessage(); Assert.assertTrue(msg, msg.matches(".*?" + MessageFormat.format("{0}", max) + ".*")); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.exception.util; import java.util.List; import java.util.ArrayList; import org.junit.Assert; import org.junit.Test; /** * Test for {@link ArgUtils}. * * @version $Id$ */ public class ArgUtilsTest { @Test public void testFlatten() { final List<Object> orig = new ArrayList<Object>(); final Object[] struct = new Object[] { new Object[] { new Object[] { create(orig), create(orig), }, create(orig), new Object[] { create(orig), } }, create(orig), new Object[] { create(orig), new Object[] { create(orig), create(orig), } }, create(orig), }; Object[] flat = ArgUtils.flatten(struct); Assert.assertEquals(flat.length, orig.size()); for (int i = 0, max = orig.size(); i < max; i++) { Assert.assertEquals(orig.get(i), flat[i]); } } /** * Create and store an {@code Object}. * * @param list List to store to. * @return the stored object. */ private Object create(List<Object> list) { final Object o = new Object(); list.add(o); return o; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.exception.util; import java.util.Locale; import java.util.Arrays; import java.io.IOException; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.ByteArrayOutputStream; import java.io.ByteArrayInputStream; import org.junit.Assert; import org.junit.Test; /** * Test for {@link ExceptionContext}. * * @version $Id$ */ public class ExceptionContextTest { @Test public void testMessageChain() { final ExceptionContext c = new ExceptionContext(new Exception("oops")); final String sep = " | "; // Non-default separator. final String m1 = "column index (0)"; c.addMessage(LocalizedFormats.COLUMN_INDEX, 0); final String m2 = "got 1x2 but expected 3x4"; c.addMessage(LocalizedFormats.DIMENSIONS_MISMATCH_2x2, 1, 2, 3, 4); final String m3 = "It didn't work out"; c.addMessage(LocalizedFormats.SIMPLE_MESSAGE, m3); Assert.assertEquals(c.getMessage(Locale.US, sep), m1 + sep + m2 + sep + m3); } @Test public void testNoArgAddMessage() { final ExceptionContext c = new ExceptionContext(new Exception("hello")); c.addMessage(LocalizedFormats.SIMPLE_MESSAGE); Assert.assertEquals(c.getMessage(), "{0}"); } @Test public void testContext() { final ExceptionContext c = new ExceptionContext(new Exception("bye")); final String[] keys = {"Key 1", "Key 2"}; final Object[] values = {"Value 1", Integer.valueOf(2)}; for (int i = 0; i < keys.length; i++) { c.setValue(keys[i], values[i]); } // Check that all keys are present. Assert.assertTrue(c.getKeys().containsAll(Arrays.asList(keys))); // Check that all values are correctly stored. for (int i = 0; i < keys.length; i++) { Assert.assertEquals(values[i], c.getValue(keys[i])); } // Check behaviour on missing key. Assert.assertNull(c.getValue("xyz")); } @Test public void testSerialize() throws IOException, ClassNotFoundException { final ExceptionContext cOut = new ExceptionContext(new Exception("Apache")); cOut.addMessage(LocalizedFormats.COLUMN_INDEX, 0); cOut.setValue("Key 1", Integer.valueOf(0)); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(cOut); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); ExceptionContext cIn = (ExceptionContext) ois.readObject(); Assert.assertTrue(cOut.getMessage().equals(cIn.getMessage())); for (String key : cIn.getKeys()) { Assert.assertTrue(cOut.getValue(key).equals(cIn.getValue(key))); } } @Test public void testSerializeUnserializable() throws Exception { final ExceptionContext cOut = new ExceptionContext(new Exception("Apache Commons Math")); cOut.addMessage(LocalizedFormats.SIMPLE_MESSAGE, "OK"); cOut.addMessage(LocalizedFormats.SIMPLE_MESSAGE, new Unserializable()); String key = "Key 1"; cOut.setValue(key, new Unserializable()); { ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(cOut); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); ExceptionContext cIn = (ExceptionContext) ois.readObject(); String nsObjStr = (String) cIn.getValue(key); Assert.assertTrue(nsObjStr.matches(".*could not be serialized.*")); } } /** * Class used by {@link #testSerializeUnserializable()}. */ private static class Unserializable { Unserializable() {} } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.exception.util; import java.text.MessageFormat; import java.util.Enumeration; import java.util.Locale; import java.util.ResourceBundle; import org.junit.Assert; import org.junit.Test; public class LocalizedFormatsTest { @Test public void testMessageNumber() { Assert.assertEquals(313, LocalizedFormats.values().length); } @Test public void testAllKeysPresentInPropertiesFiles() { final String path = LocalizedFormats.class.getName().replaceAll("\\.", "/"); for (final String language : new String[] { "fr" } ) { ResourceBundle bundle = ResourceBundle.getBundle("assets/" + path, new Locale(language)); for (LocalizedFormats message : LocalizedFormats.values()) { final String messageKey = message.toString(); boolean keyPresent = false; for (final Enumeration<String> keys = bundle.getKeys(); keys.hasMoreElements();) { keyPresent |= messageKey.equals(keys.nextElement()); } Assert.assertTrue("missing key \"" + message.name() + "\" for language " + language, keyPresent); } Assert.assertEquals(language, bundle.getLocale().getLanguage()); } } @Test public void testAllPropertiesCorrespondToKeys() { final String path = LocalizedFormats.class.getName().replaceAll("\\.", "/"); for (final String language : new String[] { "fr" } ) { ResourceBundle bundle = ResourceBundle.getBundle("assets/" + path, new Locale(language)); for (final Enumeration<String> keys = bundle.getKeys(); keys.hasMoreElements();) { final String propertyKey = keys.nextElement(); try { Assert.assertNotNull(LocalizedFormats.valueOf(propertyKey)); } catch (IllegalArgumentException iae) { Assert.fail("unknown key \"" + propertyKey + "\" in language " + language); } } Assert.assertEquals(language, bundle.getLocale().getLanguage()); } } @Test public void testNoMissingFrenchTranslation() { for (LocalizedFormats message : LocalizedFormats.values()) { String translated = message.getLocalizedString(Locale.FRENCH); Assert.assertFalse(message.name(), translated.toLowerCase().contains("missing translation")); } } @Test public void testNoOpEnglishTranslation() { for (LocalizedFormats message : LocalizedFormats.values()) { String translated = message.getLocalizedString(Locale.ENGLISH); Assert.assertEquals(message.getSourceString(), translated); } } @Test public void testVariablePartsConsistency() { for (final String language : new String[] { "fr" } ) { Locale locale = new Locale(language); for (LocalizedFormats message : LocalizedFormats.values()) { MessageFormat source = new MessageFormat(message.getSourceString()); MessageFormat translated = new MessageFormat(message.getLocalizedString(locale)); Assert.assertEquals(message.name() + " (" + language + ")", source.getFormatsByArgumentIndex().length, translated.getFormatsByArgumentIndex().length); } } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */ package org.apache.commons.math3.filter; import org.apache.commons.math3.linear.Array2DRowRealMatrix; import org.apache.commons.math3.linear.ArrayRealVector; import org.apache.commons.math3.linear.MatrixDimensionMismatchException; import org.apache.commons.math3.linear.RealMatrix; import org.apache.commons.math3.linear.RealVector; import org.apache.commons.math3.random.JDKRandomGenerator; import org.apache.commons.math3.random.RandomGenerator; import org.apache.commons.math3.util.Precision; import org.junit.Assert; import org.junit.Test; /** * Tests for {@link KalmanFilter}. * * @version $Id$ */ public class KalmanFilterTest { @Test(expected=MatrixDimensionMismatchException.class) public void testTransitionMeasurementMatrixMismatch() { // A and H matrix do not match in dimensions // A = [ 1 ] RealMatrix A = new Array2DRowRealMatrix(new double[] { 1d }); // no control input RealMatrix B = null; // H = [ 1 1 ] RealMatrix H = new Array2DRowRealMatrix(new double[] { 1d, 1d }); // Q = [ 0 ] RealMatrix Q = new Array2DRowRealMatrix(new double[] { 0 }); // R = [ 0 ] RealMatrix R = new Array2DRowRealMatrix(new double[] { 0 }); ProcessModel pm = new DefaultProcessModel(A, B, Q, new ArrayRealVector(new double[] { 0 }), null); MeasurementModel mm = new DefaultMeasurementModel(H, R); new KalmanFilter(pm, mm); Assert.fail("transition and measurement matrix should not be compatible"); } @Test(expected=MatrixDimensionMismatchException.class) public void testTransitionControlMatrixMismatch() { // A and B matrix do not match in dimensions // A = [ 1 ] RealMatrix A = new Array2DRowRealMatrix(new double[] { 1d }); // B = [ 1 1 ] RealMatrix B = new Array2DRowRealMatrix(new double[] { 1d, 1d }); // H = [ 1 ] RealMatrix H = new Array2DRowRealMatrix(new double[] { 1d }); // Q = [ 0 ] RealMatrix Q = new Array2DRowRealMatrix(new double[] { 0 }); // R = [ 0 ] RealMatrix R = new Array2DRowRealMatrix(new double[] { 0 }); ProcessModel pm = new DefaultProcessModel(A, B, Q, new ArrayRealVector(new double[] { 0 }), null); MeasurementModel mm = new DefaultMeasurementModel(H, R); new KalmanFilter(pm, mm); Assert.fail("transition and control matrix should not be compatible"); } @Test public void testConstant() { // simulates a simple process with a constant state and no control input double constantValue = 10d; double measurementNoise = 0.1d; double processNoise = 1e-5d; // A = [ 1 ] RealMatrix A = new Array2DRowRealMatrix(new double[] { 1d }); // no control input RealMatrix B = null; // H = [ 1 ] RealMatrix H = new Array2DRowRealMatrix(new double[] { 1d }); // x = [ 10 ] RealVector x = new ArrayRealVector(new double[] { constantValue }); // Q = [ 1e-5 ] RealMatrix Q = new Array2DRowRealMatrix(new double[] { processNoise }); // R = [ 0.1 ] RealMatrix R = new Array2DRowRealMatrix(new double[] { measurementNoise }); ProcessModel pm = new DefaultProcessModel(A, B, Q, new ArrayRealVector(new double[] { constantValue }), null); MeasurementModel mm = new DefaultMeasurementModel(H, R); KalmanFilter filter = new KalmanFilter(pm, mm); Assert.assertEquals(1, filter.getMeasurementDimension()); Assert.assertEquals(1, filter.getStateDimension()); assertMatrixEquals(Q.getData(), filter.getErrorCovariance()); // check the initial state double[] expectedInitialState = new double[] { constantValue }; assertVectorEquals(expectedInitialState, filter.getStateEstimation()); RealVector pNoise = new ArrayRealVector(1); RealVector mNoise = new ArrayRealVector(1); RandomGenerator rand = new JDKRandomGenerator(); // iterate 60 steps for (int i = 0; i < 60; i++) { filter.predict(); // Simulate the process pNoise.setEntry(0, processNoise * rand.nextGaussian()); // x = A * x + p_noise x = A.operate(x).add(pNoise); // Simulate the measurement mNoise.setEntry(0, measurementNoise * rand.nextGaussian()); // z = H * x + m_noise RealVector z = H.operate(x).add(mNoise); filter.correct(z); // state estimate shouldn't be larger than measurement noise double diff = Math.abs(constantValue - filter.getStateEstimation()[0]); // System.out.println(diff); Assert.assertTrue(Precision.compareTo(diff, measurementNoise, 1e-6) < 0); } // error covariance should be already very low (< 0.02) Assert.assertTrue(Precision.compareTo(filter.getErrorCovariance()[0][0], 0.02d, 1e-6) < 0); } @Test public void testConstantAcceleration() { // simulates a vehicle, accelerating at a constant rate (0.1 m/s) // discrete time interval double dt = 0.1d; // position measurement noise (meter) double measurementNoise = 10d; // acceleration noise (meter/sec^2) double accelNoise = 0.2d; // A = [ 1 dt ] // [ 0 1 ] RealMatrix A = new Array2DRowRealMatrix(new double[][] { { 1, dt }, { 0, 1 } }); // B = [ dt^2/2 ] // [ dt ] RealMatrix B = new Array2DRowRealMatrix( new double[][] { { Math.pow(dt, 2d) / 2d }, { dt } }); // H = [ 1 0 ] RealMatrix H = new Array2DRowRealMatrix(new double[][] { { 1d, 0d } }); // x = [ 0 0 ] RealVector x = new ArrayRealVector(new double[] { 0, 0 }); RealMatrix tmp = new Array2DRowRealMatrix( new double[][] { { Math.pow(dt, 4d) / 4d, Math.pow(dt, 3d) / 2d }, { Math.pow(dt, 3d) / 2d, Math.pow(dt, 2d) } }); // Q = [ dt^4/4 dt^3/2 ] // [ dt^3/2 dt^2 ] RealMatrix Q = tmp.scalarMultiply(Math.pow(accelNoise, 2)); // P0 = [ 1 1 ] // [ 1 1 ] RealMatrix P0 = new Array2DRowRealMatrix(new double[][] { { 1, 1 }, { 1, 1 } }); // R = [ measurementNoise^2 ] RealMatrix R = new Array2DRowRealMatrix( new double[] { Math.pow(measurementNoise, 2) }); // constant control input, increase velocity by 0.1 m/s per cycle RealVector u = new ArrayRealVector(new double[] { 0.1d }); ProcessModel pm = new DefaultProcessModel(A, B, Q, x, P0); MeasurementModel mm = new DefaultMeasurementModel(H, R); KalmanFilter filter = new KalmanFilter(pm, mm); Assert.assertEquals(1, filter.getMeasurementDimension()); Assert.assertEquals(2, filter.getStateDimension()); assertMatrixEquals(P0.getData(), filter.getErrorCovariance()); // check the initial state double[] expectedInitialState = new double[] { 0.0, 0.0 }; assertVectorEquals(expectedInitialState, filter.getStateEstimation()); RandomGenerator rand = new JDKRandomGenerator(); RealVector tmpPNoise = new ArrayRealVector( new double[] { Math.pow(dt, 2d) / 2d, dt }); RealVector mNoise = new ArrayRealVector(1); // iterate 60 steps for (int i = 0; i < 60; i++) { filter.predict(u); // Simulate the process RealVector pNoise = tmpPNoise.mapMultiply(accelNoise * rand.nextGaussian()); // x = A * x + B * u + pNoise x = A.operate(x).add(B.operate(u)).add(pNoise); // Simulate the measurement mNoise.setEntry(0, measurementNoise * rand.nextGaussian()); // z = H * x + m_noise RealVector z = H.operate(x).add(mNoise); filter.correct(z); // state estimate shouldn't be larger than the measurement noise double diff = Math.abs(x.getEntry(0) - filter.getStateEstimation()[0]); Assert.assertTrue(Precision.compareTo(diff, measurementNoise, 1e-6) < 0); } // error covariance of the velocity should be already very low (< 0.1) Assert.assertTrue(Precision.compareTo(filter.getErrorCovariance()[1][1], 0.1d, 1e-6) < 0); } private void assertVectorEquals(double[] expected, double[] result) { Assert.assertEquals("Wrong number of rows.", expected.length, result.length); for (int i = 0; i < expected.length; i++) { Assert.assertEquals("Wrong value at position [" + i + "]", expected[i], result[i], 1.0e-6); } } private void assertMatrixEquals(double[][] expected, double[][] result) { Assert.assertEquals("Wrong number of rows.", expected.length, result.length); for (int i = 0; i < expected.length; i++) { Assert.assertEquals("Wrong number of columns.", expected[i].length, result[i].length); for (int j = 0; j < expected[i].length; j++) { Assert.assertEquals("Wrong value at position [" + i + "," + j + "]", expected[i][j], result[i][j], 1.0e-6); } } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.fitting; import org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer; import org.apache.commons.math3.analysis.ParametricUnivariateFunction; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class CurveFitterTest { @Test public void testMath303() { LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer(); CurveFitter<ParametricUnivariateFunction> fitter = new CurveFitter<ParametricUnivariateFunction>(optimizer); fitter.addObservedPoint(2.805d, 0.6934785852953367d); fitter.addObservedPoint(2.74333333333333d, 0.6306772025518496d); fitter.addObservedPoint(1.655d, 0.9474675497289684); fitter.addObservedPoint(1.725d, 0.9013594835804194d); ParametricUnivariateFunction sif = new SimpleInverseFunction(); double[] initialguess1 = new double[1]; initialguess1[0] = 1.0d; Assert.assertEquals(1, fitter.fit(sif, initialguess1).length); double[] initialguess2 = new double[2]; initialguess2[0] = 1.0d; initialguess2[1] = .5d; Assert.assertEquals(2, fitter.fit(sif, initialguess2).length); } @Test public void testMath304() { LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer(); CurveFitter<ParametricUnivariateFunction> fitter = new CurveFitter<ParametricUnivariateFunction>(optimizer); fitter.addObservedPoint(2.805d, 0.6934785852953367d); fitter.addObservedPoint(2.74333333333333d, 0.6306772025518496d); fitter.addObservedPoint(1.655d, 0.9474675497289684); fitter.addObservedPoint(1.725d, 0.9013594835804194d); ParametricUnivariateFunction sif = new SimpleInverseFunction(); double[] initialguess1 = new double[1]; initialguess1[0] = 1.0d; Assert.assertEquals(1.6357215104109237, fitter.fit(sif, initialguess1)[0], 1.0e-14); double[] initialguess2 = new double[1]; initialguess2[0] = 10.0d; Assert.assertEquals(1.6357215104109237, fitter.fit(sif, initialguess1)[0], 1.0e-14); } @Test public void testMath372() { LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer(); CurveFitter<ParametricUnivariateFunction> curveFitter = new CurveFitter<ParametricUnivariateFunction>(optimizer); curveFitter.addObservedPoint( 15, 4443); curveFitter.addObservedPoint( 31, 8493); curveFitter.addObservedPoint( 62, 17586); curveFitter.addObservedPoint(125, 30582); curveFitter.addObservedPoint(250, 45087); curveFitter.addObservedPoint(500, 50683); ParametricUnivariateFunction f = new ParametricUnivariateFunction() { public double value(double x, double ... parameters) { double a = parameters[0]; double b = parameters[1]; double c = parameters[2]; double d = parameters[3]; return d + ((a - d) / (1 + FastMath.pow(x / c, b))); } public double[] gradient(double x, double ... parameters) { double a = parameters[0]; double b = parameters[1]; double c = parameters[2]; double d = parameters[3]; double[] gradients = new double[4]; double den = 1 + FastMath.pow(x / c, b); // derivative with respect to a gradients[0] = 1 / den; // derivative with respect to b // in the reported (invalid) issue, there was a sign error here gradients[1] = -((a - d) * FastMath.pow(x / c, b) * FastMath.log(x / c)) / (den * den); // derivative with respect to c gradients[2] = (b * FastMath.pow(x / c, b - 1) * (x / (c * c)) * (a - d)) / (den * den); // derivative with respect to d gradients[3] = 1 - (1 / den); return gradients; } }; double[] initialGuess = new double[] { 1500, 0.95, 65, 35000 }; double[] estimatedParameters = curveFitter.fit(f, initialGuess); Assert.assertEquals( 2411.00, estimatedParameters[0], 500.00); Assert.assertEquals( 1.62, estimatedParameters[1], 0.04); Assert.assertEquals( 111.22, estimatedParameters[2], 0.30); Assert.assertEquals(55347.47, estimatedParameters[3], 300.00); Assert.assertTrue(optimizer.getRMS() < 600.0); } private static class SimpleInverseFunction implements ParametricUnivariateFunction { public double value(double x, double ... parameters) { return parameters[0] / x + (parameters.length < 2 ? 0 : parameters[1]); } public double[] gradient(double x, double ... doubles) { double[] gradientVector = new double[doubles.length]; gradientVector[0] = 1 / x; if (doubles.length >= 2) { gradientVector[1] = 1; } return gradientVector; } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.fitting; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.exception.TooManyIterationsException; import org.junit.Assert; import org.junit.Test; /** * Tests {@link GaussianCurveFitter}. * * @version $Id$ */ public class GaussianCurveFitterTest { /** Good data. */ protected static final double[][] DATASET1 = new double[][] { {4.0254623, 531026.0}, {4.02804905, 664002.0}, {4.02934242, 787079.0}, {4.03128248, 984167.0}, {4.03386923, 1294546.0}, {4.03580929, 1560230.0}, {4.03839603, 1887233.0}, {4.0396894, 2113240.0}, {4.04162946, 2375211.0}, {4.04421621, 2687152.0}, {4.04550958, 2862644.0}, {4.04744964, 3078898.0}, {4.05003639, 3327238.0}, {4.05132976, 3461228.0}, {4.05326982, 3580526.0}, {4.05585657, 3576946.0}, {4.05779662, 3439750.0}, {4.06038337, 3220296.0}, {4.06167674, 3070073.0}, {4.0636168, 2877648.0}, {4.06620355, 2595848.0}, {4.06749692, 2390157.0}, {4.06943698, 2175960.0}, {4.07202373, 1895104.0}, {4.0733171, 1687576.0}, {4.07525716, 1447024.0}, {4.0778439, 1130879.0}, {4.07978396, 904900.0}, {4.08237071, 717104.0}, {4.08366408, 620014.0} }; /** Poor data: right of peak not symmetric with left of peak. */ protected static final double[][] DATASET2 = new double[][] { {-20.15, 1523.0}, {-19.65, 1566.0}, {-19.15, 1592.0}, {-18.65, 1927.0}, {-18.15, 3089.0}, {-17.65, 6068.0}, {-17.15, 14239.0}, {-16.65, 34124.0}, {-16.15, 64097.0}, {-15.65, 110352.0}, {-15.15, 164742.0}, {-14.65, 209499.0}, {-14.15, 267274.0}, {-13.65, 283290.0}, {-13.15, 275363.0}, {-12.65, 258014.0}, {-12.15, 225000.0}, {-11.65, 200000.0}, {-11.15, 190000.0}, {-10.65, 185000.0}, {-10.15, 180000.0}, { -9.65, 179000.0}, { -9.15, 178000.0}, { -8.65, 177000.0}, { -8.15, 176000.0}, { -7.65, 175000.0}, { -7.15, 174000.0}, { -6.65, 173000.0}, { -6.15, 172000.0}, { -5.65, 171000.0}, { -5.15, 170000.0} }; /** Poor data: long tails. */ protected static final double[][] DATASET3 = new double[][] { {-90.15, 1513.0}, {-80.15, 1514.0}, {-70.15, 1513.0}, {-60.15, 1514.0}, {-50.15, 1513.0}, {-40.15, 1514.0}, {-30.15, 1513.0}, {-20.15, 1523.0}, {-19.65, 1566.0}, {-19.15, 1592.0}, {-18.65, 1927.0}, {-18.15, 3089.0}, {-17.65, 6068.0}, {-17.15, 14239.0}, {-16.65, 34124.0}, {-16.15, 64097.0}, {-15.65, 110352.0}, {-15.15, 164742.0}, {-14.65, 209499.0}, {-14.15, 267274.0}, {-13.65, 283290.0}, {-13.15, 275363.0}, {-12.65, 258014.0}, {-12.15, 214073.0}, {-11.65, 182244.0}, {-11.15, 136419.0}, {-10.65, 97823.0}, {-10.15, 58930.0}, { -9.65, 35404.0}, { -9.15, 16120.0}, { -8.65, 9823.0}, { -8.15, 5064.0}, { -7.65, 2575.0}, { -7.15, 1642.0}, { -6.65, 1101.0}, { -6.15, 812.0}, { -5.65, 690.0}, { -5.15, 565.0}, { 5.15, 564.0}, { 15.15, 565.0}, { 25.15, 564.0}, { 35.15, 565.0}, { 45.15, 564.0}, { 55.15, 565.0}, { 65.15, 564.0}, { 75.15, 565.0} }; /** Poor data: right of peak is missing. */ protected static final double[][] DATASET4 = new double[][] { {-20.15, 1523.0}, {-19.65, 1566.0}, {-19.15, 1592.0}, {-18.65, 1927.0}, {-18.15, 3089.0}, {-17.65, 6068.0}, {-17.15, 14239.0}, {-16.65, 34124.0}, {-16.15, 64097.0}, {-15.65, 110352.0}, {-15.15, 164742.0}, {-14.65, 209499.0}, {-14.15, 267274.0}, {-13.65, 283290.0} }; /** Good data, but few points. */ protected static final double[][] DATASET5 = new double[][] { {4.0254623, 531026.0}, {4.03128248, 984167.0}, {4.03839603, 1887233.0}, {4.04421621, 2687152.0}, {4.05132976, 3461228.0}, {4.05326982, 3580526.0}, {4.05779662, 3439750.0}, {4.0636168, 2877648.0}, {4.06943698, 2175960.0}, {4.07525716, 1447024.0}, {4.08237071, 717104.0}, {4.08366408, 620014.0} }; /** * Basic. */ @Test public void testFit01() { GaussianCurveFitter fitter = GaussianCurveFitter.create(); double[] parameters = fitter.fit(createDataset(DATASET1).toList()); Assert.assertEquals(3496978.1837704973, parameters[0], 1e-4); Assert.assertEquals(4.054933085999146, parameters[1], 1e-4); Assert.assertEquals(0.015039355620304326, parameters[2], 1e-4); } @Test public void testWithMaxIterations1() { final int maxIter = 20; final double[] init = { 3.5e6, 4.2, 0.1 }; GaussianCurveFitter fitter = GaussianCurveFitter.create(); double[] parameters = fitter .withMaxIterations(maxIter) .withStartPoint(init) .fit(createDataset(DATASET1).toList()); Assert.assertEquals(3496978.1837704973, parameters[0], 1e-2); Assert.assertEquals(4.054933085999146, parameters[1], 1e-4); Assert.assertEquals(0.015039355620304326, parameters[2], 1e-4); } @Test(expected=TooManyIterationsException.class) public void testWithMaxIterations2() { final int maxIter = 1; // Too few iterations. final double[] init = { 3.5e6, 4.2, 0.1 }; GaussianCurveFitter fitter = GaussianCurveFitter.create(); double[] parameters = fitter .withMaxIterations(maxIter) .withStartPoint(init) .fit(createDataset(DATASET1).toList()); } @Test public void testWithStartPoint() { final double[] init = { 3.5e6, 4.2, 0.1 }; GaussianCurveFitter fitter = GaussianCurveFitter.create(); double[] parameters = fitter .withStartPoint(init) .fit(createDataset(DATASET1).toList()); Assert.assertEquals(3496978.1837704973, parameters[0], 1e-2); Assert.assertEquals(4.054933085999146, parameters[1], 1e-4); Assert.assertEquals(0.015039355620304326, parameters[2], 1e-4); } /** * Zero points is not enough observed points. */ @Test(expected=MathIllegalArgumentException.class) public void testFit02() { GaussianCurveFitter.create().fit(new WeightedObservedPoints().toList()); } /** * Two points is not enough observed points. */ @Test(expected=MathIllegalArgumentException.class) public void testFit03() { GaussianCurveFitter fitter = GaussianCurveFitter.create(); fitter.fit(createDataset(new double[][] { {4.0254623, 531026.0}, {4.02804905, 664002.0} }).toList()); } /** * Poor data: right of peak not symmetric with left of peak. */ @Test public void testFit04() { GaussianCurveFitter fitter = GaussianCurveFitter.create(); double[] parameters = fitter.fit(createDataset(DATASET2).toList()); Assert.assertEquals(233003.2967252038, parameters[0], 1e-4); Assert.assertEquals(-10.654887521095983, parameters[1], 1e-4); Assert.assertEquals(4.335937353196641, parameters[2], 1e-4); } /** * Poor data: long tails. */ @Test public void testFit05() { GaussianCurveFitter fitter = GaussianCurveFitter.create(); double[] parameters = fitter.fit(createDataset(DATASET3).toList()); Assert.assertEquals(283863.81929180305, parameters[0], 1e-4); Assert.assertEquals(-13.29641995105174, parameters[1], 1e-4); Assert.assertEquals(1.7297330293549908, parameters[2], 1e-4); } /** * Poor data: right of peak is missing. */ @Test public void testFit06() { GaussianCurveFitter fitter = GaussianCurveFitter.create(); double[] parameters = fitter.fit(createDataset(DATASET4).toList()); Assert.assertEquals(285250.66754309234, parameters[0], 1e-4); Assert.assertEquals(-13.528375695228455, parameters[1], 1e-4); Assert.assertEquals(1.5204344894331614, parameters[2], 1e-4); } /** * Basic with smaller dataset. */ @Test public void testFit07() { GaussianCurveFitter fitter = GaussianCurveFitter.create(); double[] parameters = fitter.fit(createDataset(DATASET5).toList()); Assert.assertEquals(3514384.729342235, parameters[0], 1e-4); Assert.assertEquals(4.054970307455625, parameters[1], 1e-4); Assert.assertEquals(0.015029412832160017, parameters[2], 1e-4); } @Test public void testMath519() { // The optimizer will try negative sigma values but "GaussianCurveFitter" // will catch the raised exceptions and return NaN values instead. final double[] data = { 1.1143831578403364E-29, 4.95281403484594E-28, 1.1171347211930288E-26, 1.7044813962636277E-25, 1.9784716574832164E-24, 1.8630236407866774E-23, 1.4820532905097742E-22, 1.0241963854632831E-21, 6.275077366673128E-21, 3.461808994532493E-20, 1.7407124684715706E-19, 8.056687953553974E-19, 3.460193945992071E-18, 1.3883326374011525E-17, 5.233894983671116E-17, 1.8630791465263745E-16, 6.288759227922111E-16, 2.0204433920597856E-15, 6.198768938576155E-15, 1.821419346860626E-14, 5.139176445538471E-14, 1.3956427429045787E-13, 3.655705706448139E-13, 9.253753324779779E-13, 2.267636001476696E-12, 5.3880460095836855E-12, 1.2431632654852931E-11 }; final WeightedObservedPoints obs = new WeightedObservedPoints(); for (int i = 0; i < data.length; i++) { obs.add(i, data[i]); } final double[] p = GaussianCurveFitter.create().fit(obs.toList()); Assert.assertEquals(53.1572792, p[1], 1e-7); Assert.assertEquals(5.75214622, p[2], 1e-8); } @Test public void testMath798() { // When the data points are not commented out below, the fit stalls. // This is expected however, since the whole dataset hardly looks like // a Gaussian. // When commented out, the fit proceeds fine. final WeightedObservedPoints obs = new WeightedObservedPoints(); obs.add(0.23, 395.0); //obs.add(0.68, 0.0); obs.add(1.14, 376.0); //obs.add(1.59, 0.0); obs.add(2.05, 163.0); //obs.add(2.50, 0.0); obs.add(2.95, 49.0); //obs.add(3.41, 0.0); obs.add(3.86, 16.0); //obs.add(4.32, 0.0); obs.add(4.77, 1.0); final double[] p = GaussianCurveFitter.create().fit(obs.toList()); // Values are copied from a previous run of this test. Assert.assertEquals(420.8397296167364, p[0], 1e-12); Assert.assertEquals(0.603770729862231, p[1], 1e-15); Assert.assertEquals(1.0786447936766612, p[2], 1e-14); } /** * Adds the specified points to specified <code>GaussianCurveFitter</code> * instance. * * @param points Data points where first dimension is a point index and * second dimension is an array of length two representing the point * with the first value corresponding to X and the second value * corresponding to Y. * @return the collection of observed points. */ private static WeightedObservedPoints createDataset(double[][] points) { final WeightedObservedPoints obs = new WeightedObservedPoints(); for (int i = 0; i < points.length; i++) { obs.add(points[i][0], points[i][1]); } return obs; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.fitting; import org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.junit.Assert; import org.junit.Test; /** * Tests {@link GaussianFitter}. * * @since 2.2 * @version $Id: GaussianFitterTest.java 1349707 2012-06-13 09:30:56Z erans $ */ public class GaussianFitterTest { /** Good data. */ protected static final double[][] DATASET1 = new double[][] { {4.0254623, 531026.0}, {4.02804905, 664002.0}, {4.02934242, 787079.0}, {4.03128248, 984167.0}, {4.03386923, 1294546.0}, {4.03580929, 1560230.0}, {4.03839603, 1887233.0}, {4.0396894, 2113240.0}, {4.04162946, 2375211.0}, {4.04421621, 2687152.0}, {4.04550958, 2862644.0}, {4.04744964, 3078898.0}, {4.05003639, 3327238.0}, {4.05132976, 3461228.0}, {4.05326982, 3580526.0}, {4.05585657, 3576946.0}, {4.05779662, 3439750.0}, {4.06038337, 3220296.0}, {4.06167674, 3070073.0}, {4.0636168, 2877648.0}, {4.06620355, 2595848.0}, {4.06749692, 2390157.0}, {4.06943698, 2175960.0}, {4.07202373, 1895104.0}, {4.0733171, 1687576.0}, {4.07525716, 1447024.0}, {4.0778439, 1130879.0}, {4.07978396, 904900.0}, {4.08237071, 717104.0}, {4.08366408, 620014.0} }; /** Poor data: right of peak not symmetric with left of peak. */ protected static final double[][] DATASET2 = new double[][] { {-20.15, 1523.0}, {-19.65, 1566.0}, {-19.15, 1592.0}, {-18.65, 1927.0}, {-18.15, 3089.0}, {-17.65, 6068.0}, {-17.15, 14239.0}, {-16.65, 34124.0}, {-16.15, 64097.0}, {-15.65, 110352.0}, {-15.15, 164742.0}, {-14.65, 209499.0}, {-14.15, 267274.0}, {-13.65, 283290.0}, {-13.15, 275363.0}, {-12.65, 258014.0}, {-12.15, 225000.0}, {-11.65, 200000.0}, {-11.15, 190000.0}, {-10.65, 185000.0}, {-10.15, 180000.0}, { -9.65, 179000.0}, { -9.15, 178000.0}, { -8.65, 177000.0}, { -8.15, 176000.0}, { -7.65, 175000.0}, { -7.15, 174000.0}, { -6.65, 173000.0}, { -6.15, 172000.0}, { -5.65, 171000.0}, { -5.15, 170000.0} }; /** Poor data: long tails. */ protected static final double[][] DATASET3 = new double[][] { {-90.15, 1513.0}, {-80.15, 1514.0}, {-70.15, 1513.0}, {-60.15, 1514.0}, {-50.15, 1513.0}, {-40.15, 1514.0}, {-30.15, 1513.0}, {-20.15, 1523.0}, {-19.65, 1566.0}, {-19.15, 1592.0}, {-18.65, 1927.0}, {-18.15, 3089.0}, {-17.65, 6068.0}, {-17.15, 14239.0}, {-16.65, 34124.0}, {-16.15, 64097.0}, {-15.65, 110352.0}, {-15.15, 164742.0}, {-14.65, 209499.0}, {-14.15, 267274.0}, {-13.65, 283290.0}, {-13.15, 275363.0}, {-12.65, 258014.0}, {-12.15, 214073.0}, {-11.65, 182244.0}, {-11.15, 136419.0}, {-10.65, 97823.0}, {-10.15, 58930.0}, { -9.65, 35404.0}, { -9.15, 16120.0}, { -8.65, 9823.0}, { -8.15, 5064.0}, { -7.65, 2575.0}, { -7.15, 1642.0}, { -6.65, 1101.0}, { -6.15, 812.0}, { -5.65, 690.0}, { -5.15, 565.0}, { 5.15, 564.0}, { 15.15, 565.0}, { 25.15, 564.0}, { 35.15, 565.0}, { 45.15, 564.0}, { 55.15, 565.0}, { 65.15, 564.0}, { 75.15, 565.0} }; /** Poor data: right of peak is missing. */ protected static final double[][] DATASET4 = new double[][] { {-20.15, 1523.0}, {-19.65, 1566.0}, {-19.15, 1592.0}, {-18.65, 1927.0}, {-18.15, 3089.0}, {-17.65, 6068.0}, {-17.15, 14239.0}, {-16.65, 34124.0}, {-16.15, 64097.0}, {-15.65, 110352.0}, {-15.15, 164742.0}, {-14.65, 209499.0}, {-14.15, 267274.0}, {-13.65, 283290.0} }; /** Good data, but few points. */ protected static final double[][] DATASET5 = new double[][] { {4.0254623, 531026.0}, {4.03128248, 984167.0}, {4.03839603, 1887233.0}, {4.04421621, 2687152.0}, {4.05132976, 3461228.0}, {4.05326982, 3580526.0}, {4.05779662, 3439750.0}, {4.0636168, 2877648.0}, {4.06943698, 2175960.0}, {4.07525716, 1447024.0}, {4.08237071, 717104.0}, {4.08366408, 620014.0} }; /** * Basic. */ @Test public void testFit01() { GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer()); addDatasetToGaussianFitter(DATASET1, fitter); double[] parameters = fitter.fit(); Assert.assertEquals(3496978.1837704973, parameters[0], 1e-4); Assert.assertEquals(4.054933085999146, parameters[1], 1e-4); Assert.assertEquals(0.015039355620304326, parameters[2], 1e-4); } /** * Zero points is not enough observed points. */ @Test(expected=MathIllegalArgumentException.class) public void testFit02() { GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer()); fitter.fit(); } /** * Two points is not enough observed points. */ @Test(expected=MathIllegalArgumentException.class) public void testFit03() { GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer()); addDatasetToGaussianFitter(new double[][] { {4.0254623, 531026.0}, {4.02804905, 664002.0}}, fitter); fitter.fit(); } /** * Poor data: right of peak not symmetric with left of peak. */ @Test public void testFit04() { GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer()); addDatasetToGaussianFitter(DATASET2, fitter); double[] parameters = fitter.fit(); Assert.assertEquals(233003.2967252038, parameters[0], 1e-4); Assert.assertEquals(-10.654887521095983, parameters[1], 1e-4); Assert.assertEquals(4.335937353196641, parameters[2], 1e-4); } /** * Poor data: long tails. */ @Test public void testFit05() { GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer()); addDatasetToGaussianFitter(DATASET3, fitter); double[] parameters = fitter.fit(); Assert.assertEquals(283863.81929180305, parameters[0], 1e-4); Assert.assertEquals(-13.29641995105174, parameters[1], 1e-4); Assert.assertEquals(1.7297330293549908, parameters[2], 1e-4); } /** * Poor data: right of peak is missing. */ @Test public void testFit06() { GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer()); addDatasetToGaussianFitter(DATASET4, fitter); double[] parameters = fitter.fit(); Assert.assertEquals(285250.66754309234, parameters[0], 1e-4); Assert.assertEquals(-13.528375695228455, parameters[1], 1e-4); Assert.assertEquals(1.5204344894331614, parameters[2], 1e-4); } /** * Basic with smaller dataset. */ @Test public void testFit07() { GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer()); addDatasetToGaussianFitter(DATASET5, fitter); double[] parameters = fitter.fit(); Assert.assertEquals(3514384.729342235, parameters[0], 1e-4); Assert.assertEquals(4.054970307455625, parameters[1], 1e-4); Assert.assertEquals(0.015029412832160017, parameters[2], 1e-4); } @Test public void testMath519() { // The optimizer will try negative sigma values but "GaussianFitter" // will catch the raised exceptions and return NaN values instead. final double[] data = { 1.1143831578403364E-29, 4.95281403484594E-28, 1.1171347211930288E-26, 1.7044813962636277E-25, 1.9784716574832164E-24, 1.8630236407866774E-23, 1.4820532905097742E-22, 1.0241963854632831E-21, 6.275077366673128E-21, 3.461808994532493E-20, 1.7407124684715706E-19, 8.056687953553974E-19, 3.460193945992071E-18, 1.3883326374011525E-17, 5.233894983671116E-17, 1.8630791465263745E-16, 6.288759227922111E-16, 2.0204433920597856E-15, 6.198768938576155E-15, 1.821419346860626E-14, 5.139176445538471E-14, 1.3956427429045787E-13, 3.655705706448139E-13, 9.253753324779779E-13, 2.267636001476696E-12, 5.3880460095836855E-12, 1.2431632654852931E-11 }; GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer()); for (int i = 0; i < data.length; i++) { fitter.addObservedPoint(i, data[i]); } final double[] p = fitter.fit(); Assert.assertEquals(53.1572792, p[1], 1e-7); Assert.assertEquals(5.75214622, p[2], 1e-8); } @Test public void testMath798() { final GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer()); // When the data points are not commented out below, the fit stalls. // This is expected however, since the whole dataset hardly looks like // a Gaussian. // When commented out, the fit proceeds fine. fitter.addObservedPoint(0.23, 395.0); //fitter.addObservedPoint(0.68, 0.0); fitter.addObservedPoint(1.14, 376.0); //fitter.addObservedPoint(1.59, 0.0); fitter.addObservedPoint(2.05, 163.0); //fitter.addObservedPoint(2.50, 0.0); fitter.addObservedPoint(2.95, 49.0); //fitter.addObservedPoint(3.41, 0.0); fitter.addObservedPoint(3.86, 16.0); //fitter.addObservedPoint(4.32, 0.0); fitter.addObservedPoint(4.77, 1.0); final double[] p = fitter.fit(); // Values are copied from a previous run of this test. Assert.assertEquals(420.8397296167364, p[0], 1e-12); Assert.assertEquals(0.603770729862231, p[1], 1e-15); Assert.assertEquals(1.0786447936766612, p[2], 1e-14); } /** * Adds the specified points to specified <code>GaussianFitter</code> * instance. * * @param points data points where first dimension is a point index and * second dimension is an array of length two representing the point * with the first value corresponding to X and the second value * corresponding to Y * @param fitter fitter to which the points in <code>points</code> should be * added as observed points */ protected static void addDatasetToGaussianFitter(double[][] points, GaussianFitter fitter) { for (int i = 0; i < points.length; i++) { fitter.addObservedPoint(points[i][0], points[i][1]); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.fitting; import java.util.Random; import org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer; import org.apache.commons.math3.analysis.function.HarmonicOscillator; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.exception.MathIllegalStateException; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.util.MathUtils; import org.junit.Test; import org.junit.Assert; public class HarmonicFitterTest { @Test(expected=NumberIsTooSmallException.class) public void testPreconditions1() { HarmonicFitter fitter = new HarmonicFitter(new LevenbergMarquardtOptimizer()); fitter.fit(); } @Test public void testNoError() { final double a = 0.2; final double w = 3.4; final double p = 4.1; HarmonicOscillator f = new HarmonicOscillator(a, w, p); HarmonicFitter fitter = new HarmonicFitter(new LevenbergMarquardtOptimizer()); for (double x = 0.0; x < 1.3; x += 0.01) { fitter.addObservedPoint(1, x, f.value(x)); } final double[] fitted = fitter.fit(); Assert.assertEquals(a, fitted[0], 1.0e-13); Assert.assertEquals(w, fitted[1], 1.0e-13); Assert.assertEquals(p, MathUtils.normalizeAngle(fitted[2], p), 1e-13); HarmonicOscillator ff = new HarmonicOscillator(fitted[0], fitted[1], fitted[2]); for (double x = -1.0; x < 1.0; x += 0.01) { Assert.assertTrue(FastMath.abs(f.value(x) - ff.value(x)) < 1e-13); } } @Test public void test1PercentError() { Random randomizer = new Random(64925784252l); final double a = 0.2; final double w = 3.4; final double p = 4.1; HarmonicOscillator f = new HarmonicOscillator(a, w, p); HarmonicFitter fitter = new HarmonicFitter(new LevenbergMarquardtOptimizer()); for (double x = 0.0; x < 10.0; x += 0.1) { fitter.addObservedPoint(1, x, f.value(x) + 0.01 * randomizer.nextGaussian()); } final double[] fitted = fitter.fit(); Assert.assertEquals(a, fitted[0], 7.6e-4); Assert.assertEquals(w, fitted[1], 2.7e-3); Assert.assertEquals(p, MathUtils.normalizeAngle(fitted[2], p), 1.3e-2); } @Test public void testTinyVariationsData() { Random randomizer = new Random(64925784252l); HarmonicFitter fitter = new HarmonicFitter(new LevenbergMarquardtOptimizer()); for (double x = 0.0; x < 10.0; x += 0.1) { fitter.addObservedPoint(1, x, 1e-7 * randomizer.nextGaussian()); } fitter.fit(); // This test serves to cover the part of the code of "guessAOmega" // when the algorithm using integrals fails. } @Test public void testInitialGuess() { Random randomizer = new Random(45314242l); final double a = 0.2; final double w = 3.4; final double p = 4.1; HarmonicOscillator f = new HarmonicOscillator(a, w, p); HarmonicFitter fitter = new HarmonicFitter(new LevenbergMarquardtOptimizer()); for (double x = 0.0; x < 10.0; x += 0.1) { fitter.addObservedPoint(1, x, f.value(x) + 0.01 * randomizer.nextGaussian()); } final double[] fitted = fitter.fit(new double[] { 0.15, 3.6, 4.5 }); Assert.assertEquals(a, fitted[0], 1.2e-3); Assert.assertEquals(w, fitted[1], 3.3e-3); Assert.assertEquals(p, MathUtils.normalizeAngle(fitted[2], p), 1.7e-2); } @Test public void testUnsorted() { Random randomizer = new Random(64925784252l); final double a = 0.2; final double w = 3.4; final double p = 4.1; HarmonicOscillator f = new HarmonicOscillator(a, w, p); HarmonicFitter fitter = new HarmonicFitter(new LevenbergMarquardtOptimizer()); // build a regularly spaced array of measurements int size = 100; double[] xTab = new double[size]; double[] yTab = new double[size]; for (int i = 0; i < size; ++i) { xTab[i] = 0.1 * i; yTab[i] = f.value(xTab[i]) + 0.01 * randomizer.nextGaussian(); } // shake it for (int i = 0; i < size; ++i) { int i1 = randomizer.nextInt(size); int i2 = randomizer.nextInt(size); double xTmp = xTab[i1]; double yTmp = yTab[i1]; xTab[i1] = xTab[i2]; yTab[i1] = yTab[i2]; xTab[i2] = xTmp; yTab[i2] = yTmp; } // pass it to the fitter for (int i = 0; i < size; ++i) { fitter.addObservedPoint(1, xTab[i], yTab[i]); } final double[] fitted = fitter.fit(); Assert.assertEquals(a, fitted[0], 7.6e-4); Assert.assertEquals(w, fitted[1], 3.5e-3); Assert.assertEquals(p, MathUtils.normalizeAngle(fitted[2], p), 1.5e-2); } @Test(expected=MathIllegalStateException.class) public void testMath844() { final double[] y = { 0, 1, 2, 3, 2, 1, 0, -1, -2, -3, -2, -1, 0, 1, 2, 3, 2, 1, 0, -1, -2, -3, -2, -1, 0, 1, 2, 3, 2, 1, 0 }; final int len = y.length; final WeightedObservedPoint[] points = new WeightedObservedPoint[len]; for (int i = 0; i < len; i++) { points[i] = new WeightedObservedPoint(1, i, y[i]); } // The guesser fails because the function is far from an harmonic // function: It is a triangular periodic function with amplitude 3 // and period 12, and all sample points are taken at integer abscissae // so function values all belong to the integer subset {-3, -2, -1, 0, // 1, 2, 3}. new HarmonicFitter.ParameterGuesser(points); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.fitting; import java.util.Random; import org.apache.commons.math3.analysis.polynomials.PolynomialFunction; import org.apache.commons.math3.analysis.polynomials.PolynomialFunction.Parametric; import org.apache.commons.math3.exception.ConvergenceException; import org.apache.commons.math3.exception.TooManyEvaluationsException; import org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer; import org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer; import org.apache.commons.math3.optim.nonlinear.vector.jacobian.GaussNewtonOptimizer; import org.apache.commons.math3.optim.SimpleVectorValueChecker; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.distribution.RealDistribution; import org.apache.commons.math3.distribution.UniformRealDistribution; import org.apache.commons.math3.TestUtils; import org.junit.Test; import org.junit.Assert; /** * Test for class {@link CurveFitter} where the function to fit is a * polynomial. */ public class PolynomialFitterTest { @Test public void testFit() { final RealDistribution rng = new UniformRealDistribution(-100, 100); rng.reseedRandomGenerator(64925784252L); final LevenbergMarquardtOptimizer optim = new LevenbergMarquardtOptimizer(); final PolynomialFitter fitter = new PolynomialFitter(optim); final double[] coeff = { 12.9, -3.4, 2.1 }; // 12.9 - 3.4 x + 2.1 x^2 final PolynomialFunction f = new PolynomialFunction(coeff); // Collect data from a known polynomial. for (int i = 0; i < 100; i++) { final double x = rng.sample(); fitter.addObservedPoint(x, f.value(x)); } // Start fit from initial guesses that are far from the optimal values. final double[] best = fitter.fit(new double[] { -1e-20, 3e15, -5e25 }); TestUtils.assertEquals("best != coeff", coeff, best, 1e-12); } @Test public void testNoError() { Random randomizer = new Random(64925784252l); for (int degree = 1; degree < 10; ++degree) { PolynomialFunction p = buildRandomPolynomial(degree, randomizer); PolynomialFitter fitter = new PolynomialFitter(new LevenbergMarquardtOptimizer()); for (int i = 0; i <= degree; ++i) { fitter.addObservedPoint(1.0, i, p.value(i)); } final double[] init = new double[degree + 1]; PolynomialFunction fitted = new PolynomialFunction(fitter.fit(init)); for (double x = -1.0; x < 1.0; x += 0.01) { double error = FastMath.abs(p.value(x) - fitted.value(x)) / (1.0 + FastMath.abs(p.value(x))); Assert.assertEquals(0.0, error, 1.0e-6); } } } @Test public void testSmallError() { Random randomizer = new Random(53882150042l); double maxError = 0; for (int degree = 0; degree < 10; ++degree) { PolynomialFunction p = buildRandomPolynomial(degree, randomizer); PolynomialFitter fitter = new PolynomialFitter(new LevenbergMarquardtOptimizer()); for (double x = -1.0; x < 1.0; x += 0.01) { fitter.addObservedPoint(1.0, x, p.value(x) + 0.1 * randomizer.nextGaussian()); } final double[] init = new double[degree + 1]; PolynomialFunction fitted = new PolynomialFunction(fitter.fit(init)); for (double x = -1.0; x < 1.0; x += 0.01) { double error = FastMath.abs(p.value(x) - fitted.value(x)) / (1.0 + FastMath.abs(p.value(x))); maxError = FastMath.max(maxError, error); Assert.assertTrue(FastMath.abs(error) < 0.1); } } Assert.assertTrue(maxError > 0.01); } @Test public void testMath798() { final double tol = 1e-14; final SimpleVectorValueChecker checker = new SimpleVectorValueChecker(tol, tol); final double[] init = new double[] { 0, 0 }; final int maxEval = 3; final double[] lm = doMath798(new LevenbergMarquardtOptimizer(checker), maxEval, init); final double[] gn = doMath798(new GaussNewtonOptimizer(checker), maxEval, init); for (int i = 0; i <= 1; i++) { Assert.assertEquals(lm[i], gn[i], tol); } } /** * This test shows that the user can set the maximum number of iterations * to avoid running for too long. * But in the test case, the real problem is that the tolerance is way too * stringent. */ @Test(expected=TooManyEvaluationsException.class) public void testMath798WithToleranceTooLow() { final double tol = 1e-100; final SimpleVectorValueChecker checker = new SimpleVectorValueChecker(tol, tol); final double[] init = new double[] { 0, 0 }; final int maxEval = 10000; // Trying hard to fit. @SuppressWarnings("unused") final double[] gn = doMath798(new GaussNewtonOptimizer(checker), maxEval, init); } /** * This test shows that the user can set the maximum number of iterations * to avoid running for too long. * Even if the real problem is that the tolerance is way too stringent, it * is possible to get the best solution so far, i.e. a checker will return * the point when the maximum iteration count has been reached. */ @Test public void testMath798WithToleranceTooLowButNoException() { final double tol = 1e-100; final double[] init = new double[] { 0, 0 }; final int maxEval = 10000; // Trying hard to fit. final SimpleVectorValueChecker checker = new SimpleVectorValueChecker(tol, tol, maxEval); final double[] lm = doMath798(new LevenbergMarquardtOptimizer(checker), maxEval, init); final double[] gn = doMath798(new GaussNewtonOptimizer(checker), maxEval, init); for (int i = 0; i <= 1; i++) { Assert.assertEquals(lm[i], gn[i], 1e-15); } } /** * @param optimizer Optimizer. * @param maxEval Maximum number of function evaluations. * @param init First guess. * @return the solution found by the given optimizer. */ private double[] doMath798(MultivariateVectorOptimizer optimizer, int maxEval, double[] init) { final CurveFitter<Parametric> fitter = new CurveFitter<Parametric>(optimizer); fitter.addObservedPoint(-0.2, -7.12442E-13); fitter.addObservedPoint(-0.199, -4.33397E-13); fitter.addObservedPoint(-0.198, -2.823E-13); fitter.addObservedPoint(-0.197, -1.40405E-13); fitter.addObservedPoint(-0.196, -7.80821E-15); fitter.addObservedPoint(-0.195, 6.20484E-14); fitter.addObservedPoint(-0.194, 7.24673E-14); fitter.addObservedPoint(-0.193, 1.47152E-13); fitter.addObservedPoint(-0.192, 1.9629E-13); fitter.addObservedPoint(-0.191, 2.12038E-13); fitter.addObservedPoint(-0.19, 2.46906E-13); fitter.addObservedPoint(-0.189, 2.77495E-13); fitter.addObservedPoint(-0.188, 2.51281E-13); fitter.addObservedPoint(-0.187, 2.64001E-13); fitter.addObservedPoint(-0.186, 2.8882E-13); fitter.addObservedPoint(-0.185, 3.13604E-13); fitter.addObservedPoint(-0.184, 3.14248E-13); fitter.addObservedPoint(-0.183, 3.1172E-13); fitter.addObservedPoint(-0.182, 3.12912E-13); fitter.addObservedPoint(-0.181, 3.06761E-13); fitter.addObservedPoint(-0.18, 2.8559E-13); fitter.addObservedPoint(-0.179, 2.86806E-13); fitter.addObservedPoint(-0.178, 2.985E-13); fitter.addObservedPoint(-0.177, 2.67148E-13); fitter.addObservedPoint(-0.176, 2.94173E-13); fitter.addObservedPoint(-0.175, 3.27528E-13); fitter.addObservedPoint(-0.174, 3.33858E-13); fitter.addObservedPoint(-0.173, 2.97511E-13); fitter.addObservedPoint(-0.172, 2.8615E-13); fitter.addObservedPoint(-0.171, 2.84624E-13); final double[] coeff = fitter.fit(maxEval, new PolynomialFunction.Parametric(), init); return coeff; } @Test public void testRedundantSolvable() { // Levenberg-Marquardt should handle redundant information gracefully checkUnsolvableProblem(new LevenbergMarquardtOptimizer(), true); } @Test public void testRedundantUnsolvable() { // Gauss-Newton should not be able to solve redundant information checkUnsolvableProblem(new GaussNewtonOptimizer(true, new SimpleVectorValueChecker(1e-15, 1e-15)), false); } @Test public void testLargeSample() { Random randomizer = new Random(0x5551480dca5b369bl); double maxError = 0; for (int degree = 0; degree < 10; ++degree) { PolynomialFunction p = buildRandomPolynomial(degree, randomizer); PolynomialFitter fitter = new PolynomialFitter(new LevenbergMarquardtOptimizer()); for (int i = 0; i < 40000; ++i) { double x = -1.0 + i / 20000.0; fitter.addObservedPoint(1.0, x, p.value(x) + 0.1 * randomizer.nextGaussian()); } final double[] init = new double[degree + 1]; PolynomialFunction fitted = new PolynomialFunction(fitter.fit(init)); for (double x = -1.0; x < 1.0; x += 0.01) { double error = FastMath.abs(p.value(x) - fitted.value(x)) / (1.0 + FastMath.abs(p.value(x))); maxError = FastMath.max(maxError, error); Assert.assertTrue(FastMath.abs(error) < 0.01); } } Assert.assertTrue(maxError > 0.001); } private void checkUnsolvableProblem(MultivariateVectorOptimizer optimizer, boolean solvable) { Random randomizer = new Random(1248788532l); for (int degree = 0; degree < 10; ++degree) { PolynomialFunction p = buildRandomPolynomial(degree, randomizer); PolynomialFitter fitter = new PolynomialFitter(optimizer); // reusing the same point over and over again does not bring // information, the problem cannot be solved in this case for // degrees greater than 1 (but one point is sufficient for // degree 0) for (double x = -1.0; x < 1.0; x += 0.01) { fitter.addObservedPoint(1.0, 0.0, p.value(0.0)); } try { final double[] init = new double[degree + 1]; fitter.fit(init); Assert.assertTrue(solvable || (degree == 0)); } catch(ConvergenceException e) { Assert.assertTrue((! solvable) && (degree > 0)); } } } private PolynomialFunction buildRandomPolynomial(int degree, Random randomizer) { final double[] coefficients = new double[degree + 1]; for (int i = 0; i <= degree; ++i) { coefficients[i] = randomizer.nextGaussian(); } return new PolynomialFunction(coefficients); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.fitting; import java.util.List; import org.junit.Assert; import org.junit.Test; import org.apache.commons.math3.util.Precision; /** * Tests {@link WeightedObservedPoints}. * * @version $Id$ */ public class WeightedObservedPointsTest { @Test public void testAdd1() { final WeightedObservedPoints store = new WeightedObservedPoints(); final double x = 1.2; final double y = 34.56; final double w = 0.789; store.add(w, x, y); Assert.assertTrue(lastElementIsSame(store, new WeightedObservedPoint(w, x, y))); } @Test public void testAdd2() { final WeightedObservedPoints store = new WeightedObservedPoints(); final double x = 1.2; final double y = 34.56; final double w = 0.789; store.add(new WeightedObservedPoint(w, x, y)); Assert.assertTrue(lastElementIsSame(store, new WeightedObservedPoint(w, x, y))); } @Test public void testAdd3() { final WeightedObservedPoints store = new WeightedObservedPoints(); final double x = 1.2; final double y = 34.56; store.add(x, y); Assert.assertTrue(lastElementIsSame(store, new WeightedObservedPoint(1, x, y))); } @Test public void testClear() { final WeightedObservedPoints store = new WeightedObservedPoints(); store.add(new WeightedObservedPoint(1, 2, 3)); store.add(new WeightedObservedPoint(2, -1, -2)); Assert.assertTrue(store.toList().size() == 2); store.clear(); Assert.assertTrue(store.toList().size() == 0); } // Ensure that an instance returned by "toList()" is independent from // the original container. @Test public void testToListCopy() { final WeightedObservedPoints store = new WeightedObservedPoints(); store.add(new WeightedObservedPoint(1, 2, 3)); store.add(new WeightedObservedPoint(2, -3, -4)); final List<WeightedObservedPoint> list = store.toList(); Assert.assertTrue(list.size() == 2); // Adding an element to "list" has no impact on "store". list.add(new WeightedObservedPoint(1.2, 3.4, 5.6)); Assert.assertFalse(list.size() == store.toList().size()); // Clearing "store" has no impact on "list". store.clear(); Assert.assertFalse(list.size() == 0); } /** * Checks that the contents of the last element is equal to the * contents of {@code p}. * * @param store Container. * @param point Observation. * @return {@code true} if both elements have the same contents. */ private boolean lastElementIsSame(WeightedObservedPoints store, WeightedObservedPoint point) { final List<WeightedObservedPoint> list = store.toList(); final WeightedObservedPoint lastPoint = list.get(list.size() - 1); if (!Precision.equals(lastPoint.getX(), point.getX())) { return false; } if (!Precision.equals(lastPoint.getY(), point.getY())) { return false; } if (!Precision.equals(lastPoint.getWeight(), point.getWeight())) { return false; } return true; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.fitting.leastsquares; import java.io.IOException; import org.apache.commons.math3.exception.ConvergenceException; import org.apache.commons.math3.exception.TooManyEvaluationsException; import org.apache.commons.math3.exception.MathUnsupportedOperationException; import org.apache.commons.math3.optim.SimpleVectorValueChecker; import org.apache.commons.math3.linear.DiagonalMatrix; import org.junit.Test; import org.junit.Assert; /** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files. * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>/ * * @version $Id$ */ public class GaussNewtonOptimizerTest extends AbstractLeastSquaresOptimizerAbstractTest<GaussNewtonOptimizer> { @Override public GaussNewtonOptimizer createOptimizer() { return GaussNewtonOptimizer.create() .withConvergenceChecker(new SimpleVectorValueChecker(1e-6, 1e-6)); } @Override public int getMaxIterations() { return 1000; } @Override @Test public void testShallowCopy() { super.testShallowCopy(); // Test copy of parent. final boolean useLU1 = false; final GaussNewtonOptimizer optim1 = createOptimizer() .withLU(useLU1); final GaussNewtonOptimizer optim2 = optim1.shallowCopy(); // Check that all fields have the same values. Assert.assertTrue(optim1.getLU() == optim2.getLU()); // Change "optim2". final boolean useLU2 = true; optim2.withLU(useLU2); // Check that all fields now have different values. Assert.assertFalse(optim1.getLU() == optim2.getLU()); } @Override @Test(expected=ConvergenceException.class) public void testMoreEstimatedParametersSimple() { /* * Exception is expected with this optimizer */ super.testMoreEstimatedParametersSimple(); } @Override @Test(expected=ConvergenceException.class) public void testMoreEstimatedParametersUnsorted() { /* * Exception is expected with this optimizer */ super.testMoreEstimatedParametersUnsorted(); } @Test(expected=TooManyEvaluationsException.class) public void testMaxEvaluations() throws Exception { CircleVectorial circle = new CircleVectorial(); circle.addPoint( 30.0, 68.0); circle.addPoint( 50.0, -6.0); circle.addPoint(110.0, -20.0); circle.addPoint( 35.0, 15.0); circle.addPoint( 45.0, 97.0); GaussNewtonOptimizer optimizer = createOptimizer() .withConvergenceChecker(new SimpleVectorValueChecker(1e-30, 1e-30)) .withMaxIterations(Integer.MAX_VALUE) .withMaxEvaluations(100) .withModelAndJacobian(circle.getModelFunction(), circle.getModelFunctionJacobian()) .withTarget(new double[] { 0, 0, 0, 0, 0 }) .withWeight(new DiagonalMatrix(new double[] { 1, 1, 1, 1, 1 })) .withStartPoint(new double[] { 98.680, 47.345 }); optimizer.optimize(); } @Override @Test(expected=ConvergenceException.class) public void testCircleFittingBadInit() { /* * This test does not converge with this optimizer. */ super.testCircleFittingBadInit(); } @Override @Test(expected=ConvergenceException.class) public void testHahn1() throws IOException { /* * TODO This test leads to a singular problem with the Gauss-Newton * optimizer. This should be inquired. */ super.testHahn1(); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.fitting.leastsquares; import java.io.Serializable; import java.util.ArrayList; import java.util.List; import org.apache.commons.math3.optim.PointVectorValuePair; import org.apache.commons.math3.analysis.MultivariateVectorFunction; import org.apache.commons.math3.analysis.MultivariateMatrixFunction; import org.apache.commons.math3.exception.ConvergenceException; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.TooManyEvaluationsException; import org.apache.commons.math3.exception.MathUnsupportedOperationException; import org.apache.commons.math3.geometry.euclidean.twod.Vector2D; import org.apache.commons.math3.linear.SingularMatrixException; import org.apache.commons.math3.linear.DiagonalMatrix; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.util.Precision; import org.junit.Assert; import org.junit.Test; import org.junit.Ignore; /** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files. * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>. * * @version $Id$ */ public class LevenbergMarquardtOptimizerTest extends AbstractLeastSquaresOptimizerAbstractTest<LevenbergMarquardtOptimizer> { @Override public LevenbergMarquardtOptimizer createOptimizer() { return LevenbergMarquardtOptimizer.create(); } @Override public int getMaxIterations() { return 25; } @Override @Test public void testShallowCopy() { super.testShallowCopy(); // Test copy of parent. final double initStep1 = 1e-1; final double costTol1 = 1e-1; final double parTol1 = 1e-1; final double orthoTol1 = 1e-1; final double threshold1 = 1e-1; final LevenbergMarquardtOptimizer optim1 = createOptimizer() .withInitialStepBoundFactor(initStep1) .withCostRelativeTolerance(costTol1) .withParameterRelativeTolerance(parTol1) .withOrthoTolerance(orthoTol1) .withRankingThreshold(threshold1); final LevenbergMarquardtOptimizer optim2 = optim1.shallowCopy(); // Check that all fields have the same values. Assert.assertTrue(optim1.getInitialStepBoundFactor() == optim2.getInitialStepBoundFactor()); Assert.assertTrue(optim1.getCostRelativeTolerance() == optim2.getCostRelativeTolerance()); Assert.assertTrue(optim1.getParameterRelativeTolerance() == optim2.getParameterRelativeTolerance()); Assert.assertTrue(optim1.getOrthoTolerance() == optim2.getOrthoTolerance()); Assert.assertTrue(optim1.getRankingThreshold() == optim2.getRankingThreshold()); // Change "optim2". final double initStep2 = 2e-1; final double costTol2 = 2e-1; final double parTol2 = 2e-1; final double orthoTol2 = 2e-1; final double threshold2 = 2e-1; optim2 .withInitialStepBoundFactor(initStep2) .withCostRelativeTolerance(costTol2) .withParameterRelativeTolerance(parTol2) .withOrthoTolerance(orthoTol2) .withRankingThreshold(threshold2); // Check that all fields now have different values. Assert.assertFalse(optim1.getInitialStepBoundFactor() == optim2.getInitialStepBoundFactor()); Assert.assertFalse(optim1.getCostRelativeTolerance() == optim2.getCostRelativeTolerance()); Assert.assertFalse(optim1.getParameterRelativeTolerance() == optim2.getParameterRelativeTolerance()); Assert.assertFalse(optim1.getOrthoTolerance() == optim2.getOrthoTolerance()); Assert.assertFalse(optim1.getRankingThreshold() == optim2.getRankingThreshold()); } @Override @Test(expected=SingularMatrixException.class) public void testNonInvertible() { /* * Overrides the method from parent class, since the default singularity * threshold (1e-14) does not trigger the expected exception. */ LinearProblem problem = new LinearProblem(new double[][] { { 1, 2, -3 }, { 2, 1, 3 }, { -3, 0, -9 } }, new double[] { 1, 1, 1 }); final LevenbergMarquardtOptimizer optimizer = createOptimizer() .withMaxEvaluations(100) .withMaxIterations(20) .withModelAndJacobian(problem.getModelFunction(), problem.getModelFunctionJacobian()) .withTarget(problem.getTarget()) .withWeight(new DiagonalMatrix(new double[] { 1, 1, 1 })) .withStartPoint(new double[] { 0, 0, 0 }); final double[] optimum = optimizer.optimize().getPoint(); Assert.assertTrue(FastMath.sqrt(optimizer.getTarget().length) * optimizer.computeRMS(optimum) > 0.6); optimizer.computeCovariances(optimum, 1.5e-14); } @Test public void testControlParameters() { CircleVectorial circle = new CircleVectorial(); circle.addPoint( 30.0, 68.0); circle.addPoint( 50.0, -6.0); circle.addPoint(110.0, -20.0); circle.addPoint( 35.0, 15.0); circle.addPoint( 45.0, 97.0); checkEstimate(circle.getModelFunction(), circle.getModelFunctionJacobian(), 0.1, 10, 1.0e-14, 1.0e-16, 1.0e-10, false); checkEstimate(circle.getModelFunction(), circle.getModelFunctionJacobian(), 0.1, 10, 1.0e-15, 1.0e-17, 1.0e-10, true); checkEstimate(circle.getModelFunction(), circle.getModelFunctionJacobian(), 0.1, 5, 1.0e-15, 1.0e-16, 1.0e-10, true); circle.addPoint(300, -300); checkEstimate(circle.getModelFunction(), circle.getModelFunctionJacobian(), 0.1, 20, 1.0e-18, 1.0e-16, 1.0e-10, true); } private void checkEstimate(MultivariateVectorFunction problem, MultivariateMatrixFunction problemJacobian, double initialStepBoundFactor, int maxCostEval, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, boolean shouldFail) { try { final LevenbergMarquardtOptimizer optimizer = LevenbergMarquardtOptimizer.create() .withInitialStepBoundFactor(initialStepBoundFactor) .withCostRelativeTolerance(costRelativeTolerance) .withParameterRelativeTolerance(parRelativeTolerance) .withOrthoTolerance(orthoTolerance) .withRankingThreshold(Precision.SAFE_MIN) .withMaxEvaluations(maxCostEval) .withMaxIterations(100) .withModelAndJacobian(problem, problemJacobian) .withTarget(new double[] { 0, 0, 0, 0, 0 }) .withWeight(new DiagonalMatrix(new double[] { 1, 1, 1, 1, 1 })) .withStartPoint(new double[] { 98.680, 47.345 }); optimizer.optimize(); Assert.assertTrue(!shouldFail); } catch (DimensionMismatchException ee) { Assert.assertTrue(shouldFail); } catch (TooManyEvaluationsException ee) { Assert.assertTrue(shouldFail); } } /** * Non-linear test case: fitting of decay curve (from Chapter 8 of * Bevington's textbook, "Data reduction and analysis for the physical sciences"). * XXX The expected ("reference") values may not be accurate and the tolerance too * relaxed for this test to be currently really useful (the issue is under * investigation). */ @Test public void testBevington() { final double[][] dataPoints = { // column 1 = times { 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180, 195, 210, 225, 240, 255, 270, 285, 300, 315, 330, 345, 360, 375, 390, 405, 420, 435, 450, 465, 480, 495, 510, 525, 540, 555, 570, 585, 600, 615, 630, 645, 660, 675, 690, 705, 720, 735, 750, 765, 780, 795, 810, 825, 840, 855, 870, 885, }, // column 2 = measured counts { 775, 479, 380, 302, 185, 157, 137, 119, 110, 89, 74, 61, 66, 68, 48, 54, 51, 46, 55, 29, 28, 37, 49, 26, 35, 29, 31, 24, 25, 35, 24, 30, 26, 28, 21, 18, 20, 27, 17, 17, 14, 17, 24, 11, 22, 17, 12, 10, 13, 16, 9, 9, 14, 21, 17, 13, 12, 18, 10, }, }; final BevingtonProblem problem = new BevingtonProblem(); final int len = dataPoints[0].length; final double[] weights = new double[len]; for (int i = 0; i < len; i++) { problem.addPoint(dataPoints[0][i], dataPoints[1][i]); weights[i] = 1 / dataPoints[1][i]; } final LevenbergMarquardtOptimizer optimizer = LevenbergMarquardtOptimizer.create() .withMaxEvaluations(100) .withMaxIterations(20) .withModelAndJacobian(problem.getModelFunction(), problem.getModelFunctionJacobian()) .withTarget(dataPoints[1]) .withWeight(new DiagonalMatrix(weights)) .withStartPoint(new double[] { 10, 900, 80, 27, 225 }); final PointVectorValuePair optimum = optimizer.optimize(); final double[] solution = optimum.getPoint(); final double[] expectedSolution = { 10.4, 958.3, 131.4, 33.9, 205.0 }; final double[][] covarMatrix = optimizer.computeCovariances(solution, 1e-14); final double[][] expectedCovarMatrix = { { 3.38, -3.69, 27.98, -2.34, -49.24 }, { -3.69, 2492.26, 81.89, -69.21, -8.9 }, { 27.98, 81.89, 468.99, -44.22, -615.44 }, { -2.34, -69.21, -44.22, 6.39, 53.80 }, { -49.24, -8.9, -615.44, 53.8, 929.45 } }; final int numParams = expectedSolution.length; // Check that the computed solution is within the reference error range. for (int i = 0; i < numParams; i++) { final double error = FastMath.sqrt(expectedCovarMatrix[i][i]); Assert.assertEquals("Parameter " + i, expectedSolution[i], solution[i], error); } // Check that each entry of the computed covariance matrix is within 10% // of the reference matrix entry. for (int i = 0; i < numParams; i++) { for (int j = 0; j < numParams; j++) { Assert.assertEquals("Covariance matrix [" + i + "][" + j + "]", expectedCovarMatrix[i][j], covarMatrix[i][j], FastMath.abs(0.1 * expectedCovarMatrix[i][j])); } } } @Test public void testCircleFitting2() { final double xCenter = 123.456; final double yCenter = 654.321; final double xSigma = 10; final double ySigma = 15; final double radius = 111.111; // The test is extremely sensitive to the seed. final long seed = 59421061L; final RandomCirclePointGenerator factory = new RandomCirclePointGenerator(xCenter, yCenter, radius, xSigma, ySigma, seed); final CircleProblem circle = new CircleProblem(xSigma, ySigma); final int numPoints = 10; for (Vector2D p : factory.generate(numPoints)) { circle.addPoint(p.getX(), p.getY()); } // First guess for the center's coordinates and radius. final double[] init = { 90, 659, 115 }; final LevenbergMarquardtOptimizer optimizer = LevenbergMarquardtOptimizer.create() .withMaxEvaluations(100) .withMaxIterations(50) .withModelAndJacobian(circle.getModelFunction(), circle.getModelFunctionJacobian()) .withTarget(circle.target()) .withWeight(new DiagonalMatrix(circle.weight())) .withStartPoint(init); final PointVectorValuePair optimum = optimizer.optimize(); final double[] paramFound = optimum.getPoint(); // Retrieve errors estimation. final double[] asymptoticStandardErrorFound = optimizer.computeSigma(paramFound, 1e-14); // Check that the parameters are found within the assumed error bars. Assert.assertEquals(xCenter, paramFound[0], asymptoticStandardErrorFound[0]); Assert.assertEquals(yCenter, paramFound[1], asymptoticStandardErrorFound[1]); Assert.assertEquals(radius, paramFound[2], asymptoticStandardErrorFound[2]); } private static class QuadraticProblem { private List<Double> x; private List<Double> y; public QuadraticProblem() { x = new ArrayList<Double>(); y = new ArrayList<Double>(); } public void addPoint(double x, double y) { this.x.add(x); this.y.add(y); } public MultivariateVectorFunction getModelFunction() { return new MultivariateVectorFunction() { public double[] value(double[] variables) { double[] values = new double[x.size()]; for (int i = 0; i < values.length; ++i) { values[i] = (variables[0] * x.get(i) + variables[1]) * x.get(i) + variables[2]; } return values; } }; } public MultivariateMatrixFunction getModelFunctionJacobian() { return new MultivariateMatrixFunction() { public double[][] value(double[] params) { double[][] jacobian = new double[x.size()][3]; for (int i = 0; i < jacobian.length; ++i) { jacobian[i][0] = x.get(i) * x.get(i); jacobian[i][1] = x.get(i); jacobian[i][2] = 1.0; } return jacobian; } }; } } private static class BevingtonProblem { private List<Double> time; private List<Double> count; public BevingtonProblem() { time = new ArrayList<Double>(); count = new ArrayList<Double>(); } public void addPoint(double t, double c) { time.add(t); count.add(c); } public MultivariateVectorFunction getModelFunction() { return new MultivariateVectorFunction() { public double[] value(double[] params) { double[] values = new double[time.size()]; for (int i = 0; i < values.length; ++i) { final double t = time.get(i); values[i] = params[0] + params[1] * Math.exp(-t / params[3]) + params[2] * Math.exp(-t / params[4]); } return values; } }; } public MultivariateMatrixFunction getModelFunctionJacobian() { return new MultivariateMatrixFunction() { public double[][] value(double[] params) { double[][] jacobian = new double[time.size()][5]; for (int i = 0; i < jacobian.length; ++i) { final double t = time.get(i); jacobian[i][0] = 1; final double p3 = params[3]; final double p4 = params[4]; final double tOp3 = t / p3; final double tOp4 = t / p4; jacobian[i][1] = Math.exp(-tOp3); jacobian[i][2] = Math.exp(-tOp4); jacobian[i][3] = params[1] * Math.exp(-tOp3) * tOp3 / p3; jacobian[i][4] = params[2] * Math.exp(-tOp4) * tOp4 / p4; } return jacobian; } }; } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.fitting.leastsquares; import java.io.Serializable; import java.util.Arrays; import org.apache.commons.math3.exception.TooManyEvaluationsException; import org.apache.commons.math3.analysis.MultivariateVectorFunction; import org.apache.commons.math3.analysis.MultivariateMatrixFunction; import org.apache.commons.math3.optim.PointVectorValuePair; import org.apache.commons.math3.linear.DiagonalMatrix; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files. * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> * Minpack Copyright Notice (1999) University of Chicago. * All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> * <li>Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above * copyright notice, this list of conditions and the following * disclaimer in the documentation and/or other materials provided * with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, * must include the following acknowledgment: * <code>This product includes software developed by the University of * Chicago, as Operator of Argonne National Laboratory.</code> * Alternately, this acknowledgment may appear in the software itself, * if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" * WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE * UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND * THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE * OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY * OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR * USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF * THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) * DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION * UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL * BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT * HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF * ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, * INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF * ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF * PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER * SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT * (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, * EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE * POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */ public class MinpackTest { @Test public void testMinpackLinearFullRank() { minpackTest(new LinearFullRankFunction(10, 5, 1.0, 5.0, 2.23606797749979), false); minpackTest(new LinearFullRankFunction(50, 5, 1.0, 8.06225774829855, 6.70820393249937), false); } @Test public void testMinpackLinearRank1() { minpackTest(new LinearRank1Function(10, 5, 1.0, 291.521868819476, 1.4638501094228), false); minpackTest(new LinearRank1Function(50, 5, 1.0, 3101.60039334535, 3.48263016573496), false); } @Test public void testMinpackLinearRank1ZeroColsAndRows() { minpackTest(new LinearRank1ZeroColsAndRowsFunction(10, 5, 1.0), false); minpackTest(new LinearRank1ZeroColsAndRowsFunction(50, 5, 1.0), false); } @Test public void testMinpackRosenbrok() { minpackTest(new RosenbrockFunction(new double[] { -1.2, 1.0 }, FastMath.sqrt(24.2)), false); minpackTest(new RosenbrockFunction(new double[] { -12.0, 10.0 }, FastMath.sqrt(1795769.0)), false); minpackTest(new RosenbrockFunction(new double[] { -120.0, 100.0 }, 11.0 * FastMath.sqrt(169000121.0)), false); } @Test public void testMinpackHelicalValley() { minpackTest(new HelicalValleyFunction(new double[] { -1.0, 0.0, 0.0 }, 50.0), false); minpackTest(new HelicalValleyFunction(new double[] { -10.0, 0.0, 0.0 }, 102.95630140987), false); minpackTest(new HelicalValleyFunction(new double[] { -100.0, 0.0, 0.0}, 991.261822123701), false); } @Test public void testMinpackPowellSingular() { minpackTest(new PowellSingularFunction(new double[] { 3.0, -1.0, 0.0, 1.0 }, 14.6628782986152), false); minpackTest(new PowellSingularFunction(new double[] { 30.0, -10.0, 0.0, 10.0 }, 1270.9838708654), false); minpackTest(new PowellSingularFunction(new double[] { 300.0, -100.0, 0.0, 100.0 }, 126887.903284750), false); } @Test public void testMinpackFreudensteinRoth() { minpackTest(new FreudensteinRothFunction(new double[] { 0.5, -2.0 }, 20.0124960961895, 6.99887517584575, new double[] { 11.4124844654993, -0.896827913731509 }), false); minpackTest(new FreudensteinRothFunction(new double[] { 5.0, -20.0 }, 12432.833948863, 6.9988751744895, new double[] { 11.41300466147456, -0.896796038685959 }), false); minpackTest(new FreudensteinRothFunction(new double[] { 50.0, -200.0 }, 11426454.595762, 6.99887517242903, new double[] { 11.412781785788564, -0.8968051074920405 }), false); } @Test public void testMinpackBard() { minpackTest(new BardFunction(1.0, 6.45613629515967, 0.0906359603390466, new double[] { 0.0824105765758334, 1.1330366534715, 2.34369463894115 }), false); minpackTest(new BardFunction(10.0, 36.1418531596785, 4.17476870138539, new double[] { 0.840666673818329, -158848033.259565, -164378671.653535 }), false); minpackTest(new BardFunction(100.0, 384.114678637399, 4.17476870135969, new double[] { 0.840666673867645, -158946167.205518, -164464906.857771 }), false); } @Test public void testMinpackKowalikOsborne() { minpackTest(new KowalikOsborneFunction(new double[] { 0.25, 0.39, 0.415, 0.39 }, 0.0728915102882945, 0.017535837721129, new double[] { 0.192807810476249, 0.191262653354071, 0.123052801046931, 0.136053221150517 }), false); minpackTest(new KowalikOsborneFunction(new double[] { 2.5, 3.9, 4.15, 3.9 }, 2.97937007555202, 0.032052192917937, new double[] { 728675.473768287, -14.0758803129393, -32977797.7841797, -20571594.1977912 }), false); minpackTest(new KowalikOsborneFunction(new double[] { 25.0, 39.0, 41.5, 39.0 }, 29.9590617016037, 0.0175364017658228, new double[] { 0.192948328597594, 0.188053165007911, 0.122430604321144, 0.134575665392506 }), false); } @Test public void testMinpackMeyer() { minpackTest(new MeyerFunction(new double[] { 0.02, 4000.0, 250.0 }, 41153.4665543031, 9.37794514651874, new double[] { 0.00560963647102661, 6181.34634628659, 345.223634624144 }), false); minpackTest(new MeyerFunction(new double[] { 0.2, 40000.0, 2500.0 }, 4168216.89130846, 792.917871779501, new double[] { 1.42367074157994e-11, 33695.7133432541, 901.268527953801 }), true); } @Test public void testMinpackWatson() { minpackTest(new WatsonFunction(6, 0.0, 5.47722557505166, 0.0478295939097601, new double[] { -0.0157249615083782, 1.01243488232965, -0.232991722387673, 1.26043101102818, -1.51373031394421, 0.99299727291842 }), false); minpackTest(new WatsonFunction(6, 10.0, 6433.12578950026, 0.0478295939096951, new double[] { -0.0157251901386677, 1.01243485860105, -0.232991545843829, 1.26042932089163, -1.51372776706575, 0.99299573426328 }), false); minpackTest(new WatsonFunction(6, 100.0, 674256.040605213, 0.047829593911544, new double[] { -0.0157247019712586, 1.01243490925658, -0.232991922761641, 1.26043292929555, -1.51373320452707, 0.99299901922322 }), false); minpackTest(new WatsonFunction(9, 0.0, 5.47722557505166, 0.00118311459212420, new double[] { -0.153070644166722e-4, 0.999789703934597, 0.0147639634910978, 0.146342330145992, 1.00082109454817, -2.61773112070507, 4.10440313943354, -3.14361226236241, 1.05262640378759 }), false); minpackTest(new WatsonFunction(9, 10.0, 12088.127069307, 0.00118311459212513, new double[] { -0.153071334849279e-4, 0.999789703941234, 0.0147639629786217, 0.146342334818836, 1.00082107321386, -2.61773107084722, 4.10440307655564, -3.14361222178686, 1.05262639322589 }), false); minpackTest(new WatsonFunction(9, 100.0, 1269109.29043834, 0.00118311459212384, new double[] { -0.153069523352176e-4, 0.999789703958371, 0.0147639625185392, 0.146342341096326, 1.00082104729164, -2.61773101573645, 4.10440301427286, -3.14361218602503, 1.05262638516774 }), false); minpackTest(new WatsonFunction(12, 0.0, 5.47722557505166, 0.217310402535861e-4, new double[] { -0.660266001396382e-8, 1.00000164411833, -0.000563932146980154, 0.347820540050756, -0.156731500244233, 1.05281515825593, -3.24727109519451, 7.2884347837505, -10.271848098614, 9.07411353715783, -4.54137541918194, 1.01201187975044 }), false); minpackTest(new WatsonFunction(12, 10.0, 19220.7589790951, 0.217310402518509e-4, new double[] { -0.663710223017410e-8, 1.00000164411787, -0.000563932208347327, 0.347820540486998, -0.156731503955652, 1.05281517654573, -3.2472711515214, 7.28843489430665, -10.2718482369638, 9.07411364383733, -4.54137546533666, 1.01201188830857 }), false); minpackTest(new WatsonFunction(12, 100.0, 2018918.04462367, 0.217310402539845e-4, new double[] { -0.663806046485249e-8, 1.00000164411786, -0.000563932210324959, 0.347820540503588, -0.156731504091375, 1.05281517718031, -3.24727115337025, 7.28843489775302, -10.2718482410813, 9.07411364688464, -4.54137546660822, 1.0120118885369 }), false); } @Test public void testMinpackBox3Dimensional() { minpackTest(new Box3DimensionalFunction(10, new double[] { 0.0, 10.0, 20.0 }, 32.1115837449572), false); } @Test public void testMinpackJennrichSampson() { minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 }, 64.5856498144943, 11.1517793413499, new double[] { // 0.2578330049, 0.257829976764542 0.2578199266368004, 0.25782997676455244 }), false); } @Test public void testMinpackBrownDennis() { minpackTest(new BrownDennisFunction(20, new double[] { 25.0, 5.0, -5.0, -1.0 }, 2815.43839161816, 292.954288244866, new double[] { -11.59125141003, 13.2024883984741, -0.403574643314272, 0.236736269844604 }), false); minpackTest(new BrownDennisFunction(20, new double[] { 250.0, 50.0, -50.0, -10.0 }, 555073.354173069, 292.954270581415, new double[] { -11.5959274272203, 13.2041866926242, -0.403417362841545, 0.236771143410386 }), false); minpackTest(new BrownDennisFunction(20, new double[] { 2500.0, 500.0, -500.0, -100.0 }, 61211252.2338581, 292.954306151134, new double[] { -11.5902596937374, 13.2020628854665, -0.403688070279258, 0.236665033746463 }), false); } @Test public void testMinpackChebyquad() { minpackTest(new ChebyquadFunction(1, 8, 1.0, 1.88623796907732, 1.88623796907732, new double[] { 0.5 }), false); minpackTest(new ChebyquadFunction(1, 8, 10.0, 5383344372.34005, 1.88424820499951, new double[] { 0.9817314924684 }), false); minpackTest(new ChebyquadFunction(1, 8, 100.0, 0.118088726698392e19, 1.88424820499347, new double[] { 0.9817314852934 }), false); minpackTest(new ChebyquadFunction(8, 8, 1.0, 0.196513862833975, 0.0593032355046727, new double[] { 0.0431536648587336, 0.193091637843267, 0.266328593812698, 0.499999334628884, 0.500000665371116, 0.733671406187302, 0.806908362156733, 0.956846335141266 }), false); minpackTest(new ChebyquadFunction(9, 9, 1.0, 0.16994993465202, 0.0, new double[] { 0.0442053461357828, 0.199490672309881, 0.23561910847106, 0.416046907892598, 0.5, 0.583953092107402, 0.764380891528940, 0.800509327690119, 0.955794653864217 }), false); minpackTest(new ChebyquadFunction(10, 10, 1.0, 0.183747831178711, 0.0806471004038253, new double[] { 0.0596202671753563, 0.166708783805937, 0.239171018813509, 0.398885290346268, 0.398883667870681, 0.601116332129320, 0.60111470965373, 0.760828981186491, 0.833291216194063, 0.940379732824644 }), false); } @Test public void testMinpackBrownAlmostLinear() { minpackTest(new BrownAlmostLinearFunction(10, 0.5, 16.5302162063499, 0.0, new double[] { 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 1.20569696650138 }), false); minpackTest(new BrownAlmostLinearFunction(10, 5.0, 9765624.00089211, 0.0, new double[] { 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 1.20569696650135 }), false); minpackTest(new BrownAlmostLinearFunction(10, 50.0, 0.9765625e17, 0.0, new double[] { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 }), false); minpackTest(new BrownAlmostLinearFunction(30, 0.5, 83.476044467848, 0.0, new double[] { 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 1.06737350671578 }), false); minpackTest(new BrownAlmostLinearFunction(40, 0.5, 128.026364472323, 0.0, new double[] { 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 0.999999999999121 }), false); } @Test public void testMinpackOsborne1() { minpackTest(new Osborne1Function(new double[] { 0.5, 1.5, -1.0, 0.01, 0.02, }, 0.937564021037838, 0.00739249260904843, new double[] { 0.375410049244025, 1.93584654543108, -1.46468676748716, 0.0128675339110439, 0.0221227011813076 }), false); } @Test public void testMinpackOsborne2() { minpackTest(new Osborne2Function(new double[] { 1.3, 0.65, 0.65, 0.7, 0.6, 3.0, 5.0, 7.0, 2.0, 4.5, 5.5 }, 1.44686540984712, 0.20034404483314, new double[] { 1.30997663810096, 0.43155248076, 0.633661261602859, 0.599428560991695, 0.754179768272449, 0.904300082378518, 1.36579949521007, 4.82373199748107, 2.39868475104871, 4.56887554791452, 5.67534206273052 }), false); } private void minpackTest(MinpackFunction function, boolean exceptionExpected) { final double tol = 2.22044604926e-16; final double sqrtTol = FastMath.sqrt(tol); LevenbergMarquardtOptimizer optimizer = LevenbergMarquardtOptimizer.create(); optimizer = optimizer .withInitialStepBoundFactor(optimizer.getInitialStepBoundFactor()) .withCostRelativeTolerance(sqrtTol) .withParameterRelativeTolerance(sqrtTol) .withOrthoTolerance(tol) .withRankingThreshold(optimizer.getRankingThreshold()) .withMaxEvaluations(400 * (function.getN() + 1)) .withMaxIterations(2000) .withModelAndJacobian(function.getModelFunction(), function.getModelFunctionJacobian()) .withTarget(function.getTarget()) .withWeight(new DiagonalMatrix(function.getWeight())) .withStartPoint(function.getStartPoint()); try { final double[] optimum = optimizer.optimize().getPoint(); Assert.assertFalse(exceptionExpected); function.checkTheoreticalMinCost(optimizer.computeRMS(optimum)); function.checkTheoreticalMinParams(optimum); } catch (TooManyEvaluationsException e) { Assert.assertTrue(exceptionExpected); } } private static abstract class MinpackFunction { protected int n; protected int m; protected double[] startParams; protected double theoreticalMinCost; protected double[] theoreticalMinParams; protected double costAccuracy; protected double paramsAccuracy; protected MinpackFunction(int m, double[] startParams, double theoreticalMinCost, double[] theoreticalMinParams) { this.m = m; this.n = startParams.length; this.startParams = startParams.clone(); this.theoreticalMinCost = theoreticalMinCost; this.theoreticalMinParams = theoreticalMinParams; this.costAccuracy = 1.0e-8; this.paramsAccuracy = 1.0e-5; } protected static double[] buildArray(int n, double x) { double[] array = new double[n]; Arrays.fill(array, x); return array; } public double[] getTarget() { return buildArray(m, 0.0); } public double[] getWeight() { return buildArray(m, 1.0); } public double[] getStartPoint() { return startParams.clone(); } protected void setCostAccuracy(double costAccuracy) { this.costAccuracy = costAccuracy; } protected void setParamsAccuracy(double paramsAccuracy) { this.paramsAccuracy = paramsAccuracy; } public int getN() { return startParams.length; } public void checkTheoreticalMinCost(double rms) { double threshold = costAccuracy * (1.0 + theoreticalMinCost); Assert.assertEquals(theoreticalMinCost, FastMath.sqrt(m) * rms, threshold); } public void checkTheoreticalMinParams(double[] params) { if (theoreticalMinParams != null) { for (int i = 0; i < theoreticalMinParams.length; ++i) { double mi = theoreticalMinParams[i]; double vi = params[i]; Assert.assertEquals(mi, vi, paramsAccuracy * (1.0 + FastMath.abs(mi))); } } } public MultivariateVectorFunction getModelFunction() { return new MultivariateVectorFunction() { public double[] value(double[] point) { return computeValue(point); } }; } public MultivariateMatrixFunction getModelFunctionJacobian() { return new MultivariateMatrixFunction() { public double[][] value(double[] point) { return computeJacobian(point); } }; } public abstract double[][] computeJacobian(double[] variables); public abstract double[] computeValue(double[] variables); } private static class LinearFullRankFunction extends MinpackFunction { private static final long serialVersionUID = -9030323226268039536L; public LinearFullRankFunction(int m, int n, double x0, double theoreticalStartCost, double theoreticalMinCost) { super(m, buildArray(n, x0), theoreticalMinCost, buildArray(n, -1.0)); } @Override public double[][] computeJacobian(double[] variables) { double t = 2.0 / m; double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { jacobian[i] = new double[n]; for (int j = 0; j < n; ++j) { jacobian[i][j] = (i == j) ? (1 - t) : -t; } } return jacobian; } @Override public double[] computeValue(double[] variables) { double sum = 0; for (int i = 0; i < n; ++i) { sum += variables[i]; } double t = 1 + 2 * sum / m; double[] f = new double[m]; for (int i = 0; i < n; ++i) { f[i] = variables[i] - t; } Arrays.fill(f, n, m, -t); return f; } } private static class LinearRank1Function extends MinpackFunction { private static final long serialVersionUID = 8494863245104608300L; public LinearRank1Function(int m, int n, double x0, double theoreticalStartCost, double theoreticalMinCost) { super(m, buildArray(n, x0), theoreticalMinCost, null); } @Override public double[][] computeJacobian(double[] variables) { double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { jacobian[i] = new double[n]; for (int j = 0; j < n; ++j) { jacobian[i][j] = (i + 1) * (j + 1); } } return jacobian; } @Override public double[] computeValue(double[] variables) { double[] f = new double[m]; double sum = 0; for (int i = 0; i < n; ++i) { sum += (i + 1) * variables[i]; } for (int i = 0; i < m; ++i) { f[i] = (i + 1) * sum - 1; } return f; } } private static class LinearRank1ZeroColsAndRowsFunction extends MinpackFunction { private static final long serialVersionUID = -3316653043091995018L; public LinearRank1ZeroColsAndRowsFunction(int m, int n, double x0) { super(m, buildArray(n, x0), FastMath.sqrt((m * (m + 3) - 6) / (2.0 * (2 * m - 3))), null); } @Override public double[][] computeJacobian(double[] variables) { double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { jacobian[i] = new double[n]; jacobian[i][0] = 0; for (int j = 1; j < (n - 1); ++j) { if (i == 0) { jacobian[i][j] = 0; } else if (i != (m - 1)) { jacobian[i][j] = i * (j + 1); } else { jacobian[i][j] = 0; } } jacobian[i][n - 1] = 0; } return jacobian; } @Override public double[] computeValue(double[] variables) { double[] f = new double[m]; double sum = 0; for (int i = 1; i < (n - 1); ++i) { sum += (i + 1) * variables[i]; } for (int i = 0; i < (m - 1); ++i) { f[i] = i * sum - 1; } f[m - 1] = -1; return f; } } private static class RosenbrockFunction extends MinpackFunction { private static final long serialVersionUID = 2893438180956569134L; public RosenbrockFunction(double[] startParams, double theoreticalStartCost) { super(2, startParams, 0.0, buildArray(2, 1.0)); } @Override public double[][] computeJacobian(double[] variables) { double x1 = variables[0]; return new double[][] { { -20 * x1, 10 }, { -1, 0 } }; } @Override public double[] computeValue(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; return new double[] { 10 * (x2 - x1 * x1), 1 - x1 }; } } private static class HelicalValleyFunction extends MinpackFunction { private static final long serialVersionUID = 220613787843200102L; public HelicalValleyFunction(double[] startParams, double theoreticalStartCost) { super(3, startParams, 0.0, new double[] { 1.0, 0.0, 0.0 }); } @Override public double[][] computeJacobian(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; double tmpSquare = x1 * x1 + x2 * x2; double tmp1 = twoPi * tmpSquare; double tmp2 = FastMath.sqrt(tmpSquare); return new double[][] { { 100 * x2 / tmp1, -100 * x1 / tmp1, 10 }, { 10 * x1 / tmp2, 10 * x2 / tmp2, 0 }, { 0, 0, 1 } }; } @Override public double[] computeValue(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; double x3 = variables[2]; double tmp1; if (x1 == 0) { tmp1 = (x2 >= 0) ? 0.25 : -0.25; } else { tmp1 = FastMath.atan(x2 / x1) / twoPi; if (x1 < 0) { tmp1 += 0.5; } } double tmp2 = FastMath.sqrt(x1 * x1 + x2 * x2); return new double[] { 10.0 * (x3 - 10 * tmp1), 10.0 * (tmp2 - 1), x3 }; } private static final double twoPi = 2.0 * FastMath.PI; } private static class PowellSingularFunction extends MinpackFunction { private static final long serialVersionUID = 7298364171208142405L; public PowellSingularFunction(double[] startParams, double theoreticalStartCost) { super(4, startParams, 0.0, buildArray(4, 0.0)); } @Override public double[][] computeJacobian(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; double x3 = variables[2]; double x4 = variables[3]; return new double[][] { { 1, 10, 0, 0 }, { 0, 0, sqrt5, -sqrt5 }, { 0, 2 * (x2 - 2 * x3), -4 * (x2 - 2 * x3), 0 }, { 2 * sqrt10 * (x1 - x4), 0, 0, -2 * sqrt10 * (x1 - x4) } }; } @Override public double[] computeValue(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; double x3 = variables[2]; double x4 = variables[3]; return new double[] { x1 + 10 * x2, sqrt5 * (x3 - x4), (x2 - 2 * x3) * (x2 - 2 * x3), sqrt10 * (x1 - x4) * (x1 - x4) }; } private static final double sqrt5 = FastMath.sqrt( 5.0); private static final double sqrt10 = FastMath.sqrt(10.0); } private static class FreudensteinRothFunction extends MinpackFunction { private static final long serialVersionUID = 2892404999344244214L; public FreudensteinRothFunction(double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(2, startParams, theoreticalMinCost, theoreticalMinParams); } @Override public double[][] computeJacobian(double[] variables) { double x2 = variables[1]; return new double[][] { { 1, x2 * (10 - 3 * x2) - 2 }, { 1, x2 * ( 2 + 3 * x2) - 14, } }; } @Override public double[] computeValue(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; return new double[] { -13.0 + x1 + ((5.0 - x2) * x2 - 2.0) * x2, -29.0 + x1 + ((1.0 + x2) * x2 - 14.0) * x2 }; } } private static class BardFunction extends MinpackFunction { private static final long serialVersionUID = 5990442612572087668L; public BardFunction(double x0, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(15, buildArray(3, x0), theoreticalMinCost, theoreticalMinParams); } @Override public double[][] computeJacobian(double[] variables) { double x2 = variables[1]; double x3 = variables[2]; double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { double tmp1 = i + 1; double tmp2 = 15 - i; double tmp3 = (i <= 7) ? tmp1 : tmp2; double tmp4 = x2 * tmp2 + x3 * tmp3; tmp4 *= tmp4; jacobian[i] = new double[] { -1, tmp1 * tmp2 / tmp4, tmp1 * tmp3 / tmp4 }; } return jacobian; } @Override public double[] computeValue(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; double x3 = variables[2]; double[] f = new double[m]; for (int i = 0; i < m; ++i) { double tmp1 = i + 1; double tmp2 = 15 - i; double tmp3 = (i <= 7) ? tmp1 : tmp2; f[i] = y[i] - (x1 + tmp1 / (x2 * tmp2 + x3 * tmp3)); } return f; } private static final double[] y = { 0.14, 0.18, 0.22, 0.25, 0.29, 0.32, 0.35, 0.39, 0.37, 0.58, 0.73, 0.96, 1.34, 2.10, 4.39 }; } private static class KowalikOsborneFunction extends MinpackFunction { private static final long serialVersionUID = -4867445739880495801L; public KowalikOsborneFunction(double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(11, startParams, theoreticalMinCost, theoreticalMinParams); if (theoreticalStartCost > 20.0) { setCostAccuracy(2.0e-4); setParamsAccuracy(5.0e-3); } } @Override public double[][] computeJacobian(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; double x3 = variables[2]; double x4 = variables[3]; double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { double tmp = v[i] * (v[i] + x3) + x4; double j1 = -v[i] * (v[i] + x2) / tmp; double j2 = -v[i] * x1 / tmp; double j3 = j1 * j2; double j4 = j3 / v[i]; jacobian[i] = new double[] { j1, j2, j3, j4 }; } return jacobian; } @Override public double[] computeValue(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; double x3 = variables[2]; double x4 = variables[3]; double[] f = new double[m]; for (int i = 0; i < m; ++i) { f[i] = y[i] - x1 * (v[i] * (v[i] + x2)) / (v[i] * (v[i] + x3) + x4); } return f; } private static final double[] v = { 4.0, 2.0, 1.0, 0.5, 0.25, 0.167, 0.125, 0.1, 0.0833, 0.0714, 0.0625 }; private static final double[] y = { 0.1957, 0.1947, 0.1735, 0.1600, 0.0844, 0.0627, 0.0456, 0.0342, 0.0323, 0.0235, 0.0246 }; } private static class MeyerFunction extends MinpackFunction { private static final long serialVersionUID = -838060619150131027L; public MeyerFunction(double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(16, startParams, theoreticalMinCost, theoreticalMinParams); if (theoreticalStartCost > 1.0e6) { setCostAccuracy(7.0e-3); setParamsAccuracy(2.0e-2); } } @Override public double[][] computeJacobian(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; double x3 = variables[2]; double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { double temp = 5.0 * (i + 1) + 45.0 + x3; double tmp1 = x2 / temp; double tmp2 = FastMath.exp(tmp1); double tmp3 = x1 * tmp2 / temp; jacobian[i] = new double[] { tmp2, tmp3, -tmp1 * tmp3 }; } return jacobian; } @Override public double[] computeValue(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; double x3 = variables[2]; double[] f = new double[m]; for (int i = 0; i < m; ++i) { f[i] = x1 * FastMath.exp(x2 / (5.0 * (i + 1) + 45.0 + x3)) - y[i]; } return f; } private static final double[] y = { 34780.0, 28610.0, 23650.0, 19630.0, 16370.0, 13720.0, 11540.0, 9744.0, 8261.0, 7030.0, 6005.0, 5147.0, 4427.0, 3820.0, 3307.0, 2872.0 }; } private static class WatsonFunction extends MinpackFunction { private static final long serialVersionUID = -9034759294980218927L; public WatsonFunction(int n, double x0, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(31, buildArray(n, x0), theoreticalMinCost, theoreticalMinParams); } @Override public double[][] computeJacobian(double[] variables) { double[][] jacobian = new double[m][]; for (int i = 0; i < (m - 2); ++i) { double div = (i + 1) / 29.0; double s2 = 0.0; double dx = 1.0; for (int j = 0; j < n; ++j) { s2 += dx * variables[j]; dx *= div; } double temp= 2 * div * s2; dx = 1.0 / div; jacobian[i] = new double[n]; for (int j = 0; j < n; ++j) { jacobian[i][j] = dx * (j - temp); dx *= div; } } jacobian[m - 2] = new double[n]; jacobian[m - 2][0] = 1; jacobian[m - 1] = new double[n]; jacobian[m - 1][0]= -2 * variables[0]; jacobian[m - 1][1]= 1; return jacobian; } @Override public double[] computeValue(double[] variables) { double[] f = new double[m]; for (int i = 0; i < (m - 2); ++i) { double div = (i + 1) / 29.0; double s1 = 0; double dx = 1; for (int j = 1; j < n; ++j) { s1 += j * dx * variables[j]; dx *= div; } double s2 = 0; dx = 1; for (int j = 0; j < n; ++j) { s2 += dx * variables[j]; dx *= div; } f[i] = s1 - s2 * s2 - 1; } double x1 = variables[0]; double x2 = variables[1]; f[m - 2] = x1; f[m - 1] = x2 - x1 * x1 - 1; return f; } } private static class Box3DimensionalFunction extends MinpackFunction { private static final long serialVersionUID = 5511403858142574493L; public Box3DimensionalFunction(int m, double[] startParams, double theoreticalStartCost) { super(m, startParams, 0.0, new double[] { 1.0, 10.0, 1.0 }); } @Override public double[][] computeJacobian(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { double tmp = (i + 1) / 10.0; jacobian[i] = new double[] { -tmp * FastMath.exp(-tmp * x1), tmp * FastMath.exp(-tmp * x2), FastMath.exp(-i - 1) - FastMath.exp(-tmp) }; } return jacobian; } @Override public double[] computeValue(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; double x3 = variables[2]; double[] f = new double[m]; for (int i = 0; i < m; ++i) { double tmp = (i + 1) / 10.0; f[i] = FastMath.exp(-tmp * x1) - FastMath.exp(-tmp * x2) + (FastMath.exp(-i - 1) - FastMath.exp(-tmp)) * x3; } return f; } } private static class JennrichSampsonFunction extends MinpackFunction { private static final long serialVersionUID = -2489165190443352947L; public JennrichSampsonFunction(int m, double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(m, startParams, theoreticalMinCost, theoreticalMinParams); } @Override public double[][] computeJacobian(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { double t = i + 1; jacobian[i] = new double[] { -t * FastMath.exp(t * x1), -t * FastMath.exp(t * x2) }; } return jacobian; } @Override public double[] computeValue(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; double[] f = new double[m]; for (int i = 0; i < m; ++i) { double temp = i + 1; f[i] = 2 + 2 * temp - FastMath.exp(temp * x1) - FastMath.exp(temp * x2); } return f; } } private static class BrownDennisFunction extends MinpackFunction { private static final long serialVersionUID = 8340018645694243910L; public BrownDennisFunction(int m, double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(m, startParams, theoreticalMinCost, theoreticalMinParams); setCostAccuracy(2.5e-8); } @Override public double[][] computeJacobian(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; double x3 = variables[2]; double x4 = variables[3]; double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { double temp = (i + 1) / 5.0; double ti = FastMath.sin(temp); double tmp1 = x1 + temp * x2 - FastMath.exp(temp); double tmp2 = x3 + ti * x4 - FastMath.cos(temp); jacobian[i] = new double[] { 2 * tmp1, 2 * temp * tmp1, 2 * tmp2, 2 * ti * tmp2 }; } return jacobian; } @Override public double[] computeValue(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; double x3 = variables[2]; double x4 = variables[3]; double[] f = new double[m]; for (int i = 0; i < m; ++i) { double temp = (i + 1) / 5.0; double tmp1 = x1 + temp * x2 - FastMath.exp(temp); double tmp2 = x3 + FastMath.sin(temp) * x4 - FastMath.cos(temp); f[i] = tmp1 * tmp1 + tmp2 * tmp2; } return f; } } private static class ChebyquadFunction extends MinpackFunction { private static final long serialVersionUID = -2394877275028008594L; private static double[] buildChebyquadArray(int n, double factor) { double[] array = new double[n]; double inv = factor / (n + 1); for (int i = 0; i < n; ++i) { array[i] = (i + 1) * inv; } return array; } public ChebyquadFunction(int n, int m, double factor, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(m, buildChebyquadArray(n, factor), theoreticalMinCost, theoreticalMinParams); } @Override public double[][] computeJacobian(double[] variables) { double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { jacobian[i] = new double[n]; } double dx = 1.0 / n; for (int j = 0; j < n; ++j) { double tmp1 = 1; double tmp2 = 2 * variables[j] - 1; double temp = 2 * tmp2; double tmp3 = 0; double tmp4 = 2; for (int i = 0; i < m; ++i) { jacobian[i][j] = dx * tmp4; double ti = 4 * tmp2 + temp * tmp4 - tmp3; tmp3 = tmp4; tmp4 = ti; ti = temp * tmp2 - tmp1; tmp1 = tmp2; tmp2 = ti; } } return jacobian; } @Override public double[] computeValue(double[] variables) { double[] f = new double[m]; for (int j = 0; j < n; ++j) { double tmp1 = 1; double tmp2 = 2 * variables[j] - 1; double temp = 2 * tmp2; for (int i = 0; i < m; ++i) { f[i] += tmp2; double ti = temp * tmp2 - tmp1; tmp1 = tmp2; tmp2 = ti; } } double dx = 1.0 / n; boolean iev = false; for (int i = 0; i < m; ++i) { f[i] *= dx; if (iev) { f[i] += 1.0 / (i * (i + 2)); } iev = ! iev; } return f; } } private static class BrownAlmostLinearFunction extends MinpackFunction { private static final long serialVersionUID = 8239594490466964725L; public BrownAlmostLinearFunction(int m, double factor, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(m, buildArray(m, factor), theoreticalMinCost, theoreticalMinParams); } @Override public double[][] computeJacobian(double[] variables) { double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { jacobian[i] = new double[n]; } double prod = 1; for (int j = 0; j < n; ++j) { prod *= variables[j]; for (int i = 0; i < n; ++i) { jacobian[i][j] = 1; } jacobian[j][j] = 2; } for (int j = 0; j < n; ++j) { double temp = variables[j]; if (temp == 0) { temp = 1; prod = 1; for (int k = 0; k < n; ++k) { if (k != j) { prod *= variables[k]; } } } jacobian[n - 1][j] = prod / temp; } return jacobian; } @Override public double[] computeValue(double[] variables) { double[] f = new double[m]; double sum = -(n + 1); double prod = 1; for (int j = 0; j < n; ++j) { sum += variables[j]; prod *= variables[j]; } for (int i = 0; i < n; ++i) { f[i] = variables[i] + sum; } f[n - 1] = prod - 1; return f; } } private static class Osborne1Function extends MinpackFunction { private static final long serialVersionUID = 4006743521149849494L; public Osborne1Function(double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(33, startParams, theoreticalMinCost, theoreticalMinParams); } @Override public double[][] computeJacobian(double[] variables) { double x2 = variables[1]; double x3 = variables[2]; double x4 = variables[3]; double x5 = variables[4]; double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { double temp = 10.0 * i; double tmp1 = FastMath.exp(-temp * x4); double tmp2 = FastMath.exp(-temp * x5); jacobian[i] = new double[] { -1, -tmp1, -tmp2, temp * x2 * tmp1, temp * x3 * tmp2 }; } return jacobian; } @Override public double[] computeValue(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; double x3 = variables[2]; double x4 = variables[3]; double x5 = variables[4]; double[] f = new double[m]; for (int i = 0; i < m; ++i) { double temp = 10.0 * i; double tmp1 = FastMath.exp(-temp * x4); double tmp2 = FastMath.exp(-temp * x5); f[i] = y[i] - (x1 + x2 * tmp1 + x3 * tmp2); } return f; } private static final double[] y = { 0.844, 0.908, 0.932, 0.936, 0.925, 0.908, 0.881, 0.850, 0.818, 0.784, 0.751, 0.718, 0.685, 0.658, 0.628, 0.603, 0.580, 0.558, 0.538, 0.522, 0.506, 0.490, 0.478, 0.467, 0.457, 0.448, 0.438, 0.431, 0.424, 0.420, 0.414, 0.411, 0.406 }; } private static class Osborne2Function extends MinpackFunction { private static final long serialVersionUID = -8418268780389858746L; public Osborne2Function(double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(65, startParams, theoreticalMinCost, theoreticalMinParams); } @Override public double[][] computeJacobian(double[] variables) { double x01 = variables[0]; double x02 = variables[1]; double x03 = variables[2]; double x04 = variables[3]; double x05 = variables[4]; double x06 = variables[5]; double x07 = variables[6]; double x08 = variables[7]; double x09 = variables[8]; double x10 = variables[9]; double x11 = variables[10]; double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { double temp = i / 10.0; double tmp1 = FastMath.exp(-x05 * temp); double tmp2 = FastMath.exp(-x06 * (temp - x09) * (temp - x09)); double tmp3 = FastMath.exp(-x07 * (temp - x10) * (temp - x10)); double tmp4 = FastMath.exp(-x08 * (temp - x11) * (temp - x11)); jacobian[i] = new double[] { -tmp1, -tmp2, -tmp3, -tmp4, temp * x01 * tmp1, x02 * (temp - x09) * (temp - x09) * tmp2, x03 * (temp - x10) * (temp - x10) * tmp3, x04 * (temp - x11) * (temp - x11) * tmp4, -2 * x02 * x06 * (temp - x09) * tmp2, -2 * x03 * x07 * (temp - x10) * tmp3, -2 * x04 * x08 * (temp - x11) * tmp4 }; } return jacobian; } @Override public double[] computeValue(double[] variables) { double x01 = variables[0]; double x02 = variables[1]; double x03 = variables[2]; double x04 = variables[3]; double x05 = variables[4]; double x06 = variables[5]; double x07 = variables[6]; double x08 = variables[7]; double x09 = variables[8]; double x10 = variables[9]; double x11 = variables[10]; double[] f = new double[m]; for (int i = 0; i < m; ++i) { double temp = i / 10.0; double tmp1 = FastMath.exp(-x05 * temp); double tmp2 = FastMath.exp(-x06 * (temp - x09) * (temp - x09)); double tmp3 = FastMath.exp(-x07 * (temp - x10) * (temp - x10)); double tmp4 = FastMath.exp(-x08 * (temp - x11) * (temp - x11)); f[i] = y[i] - (x01 * tmp1 + x02 * tmp2 + x03 * tmp3 + x04 * tmp4); } return f; } private static final double[] y = { 1.366, 1.191, 1.112, 1.013, 0.991, 0.885, 0.831, 0.847, 0.786, 0.725, 0.746, 0.679, 0.608, 0.655, 0.616, 0.606, 0.602, 0.626, 0.651, 0.724, 0.649, 0.649, 0.694, 0.644, 0.624, 0.661, 0.612, 0.558, 0.533, 0.495, 0.500, 0.423, 0.395, 0.375, 0.372, 0.391, 0.396, 0.405, 0.428, 0.429, 0.523, 0.562, 0.607, 0.653, 0.672, 0.708, 0.633, 0.668, 0.645, 0.632, 0.591, 0.559, 0.597, 0.625, 0.739, 0.710, 0.729, 0.720, 0.636, 0.581, 0.428, 0.292, 0.162, 0.098, 0.054 }; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.fraction; import org.apache.commons.math3.TestUtils; import org.junit.Assert; import org.junit.Test; public class BigFractionFieldTest { @Test public void testZero() { Assert.assertEquals(BigFraction.ZERO, BigFractionField.getInstance().getZero()); } @Test public void testOne() { Assert.assertEquals(BigFraction.ONE, BigFractionField.getInstance().getOne()); } @Test public void testSerial() { // deserializing the singleton should give the singleton itself back BigFractionField field = BigFractionField.getInstance(); Assert.assertTrue(field == TestUtils.serializeAndRecover(field)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.fraction; import java.math.BigDecimal; import java.math.BigInteger; import java.text.NumberFormat; import java.util.Locale; import org.apache.commons.math3.exception.MathParseException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Before; import org.junit.Test; public class BigFractionFormatTest { BigFractionFormat properFormat = null; BigFractionFormat improperFormat = null; protected Locale getLocale() { return Locale.getDefault(); } @Before public void setUp() { properFormat = BigFractionFormat.getProperInstance(getLocale()); improperFormat = BigFractionFormat.getImproperInstance(getLocale()); } @Test public void testFormat() { BigFraction c = new BigFraction(1, 2); String expected = "1 / 2"; String actual = properFormat.format(c); Assert.assertEquals(expected, actual); actual = improperFormat.format(c); Assert.assertEquals(expected, actual); } @Test public void testFormatNegative() { BigFraction c = new BigFraction(-1, 2); String expected = "-1 / 2"; String actual = properFormat.format(c); Assert.assertEquals(expected, actual); actual = improperFormat.format(c); Assert.assertEquals(expected, actual); } @Test public void testFormatZero() { BigFraction c = new BigFraction(0, 1); String expected = "0 / 1"; String actual = properFormat.format(c); Assert.assertEquals(expected, actual); actual = improperFormat.format(c); Assert.assertEquals(expected, actual); } @Test public void testFormatImproper() { BigFraction c = new BigFraction(5, 3); String actual = properFormat.format(c); Assert.assertEquals("1 2 / 3", actual); actual = improperFormat.format(c); Assert.assertEquals("5 / 3", actual); } @Test public void testFormatImproperNegative() { BigFraction c = new BigFraction(-5, 3); String actual = properFormat.format(c); Assert.assertEquals("-1 2 / 3", actual); actual = improperFormat.format(c); Assert.assertEquals("-5 / 3", actual); } @Test public void testParse() { String source = "1 / 2"; { BigFraction c = properFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(BigInteger.ONE, c.getNumerator()); Assert.assertEquals(BigInteger.valueOf(2l), c.getDenominator()); c = improperFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(BigInteger.ONE, c.getNumerator()); Assert.assertEquals(BigInteger.valueOf(2l), c.getDenominator()); } } @Test public void testParseInteger() { String source = "10"; { BigFraction c = properFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(BigInteger.TEN, c.getNumerator()); Assert.assertEquals(BigInteger.ONE, c.getDenominator()); } { BigFraction c = improperFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(BigInteger.TEN, c.getNumerator()); Assert.assertEquals(BigInteger.ONE, c.getDenominator()); } } @Test public void testParseInvalid() { String source = "a"; String msg = "should not be able to parse '10 / a'."; try { properFormat.parse(source); Assert.fail(msg); } catch (MathParseException ex) { // success } try { improperFormat.parse(source); Assert.fail(msg); } catch (MathParseException ex) { // success } } @Test public void testParseInvalidDenominator() { String source = "10 / a"; String msg = "should not be able to parse '10 / a'."; try { properFormat.parse(source); Assert.fail(msg); } catch (MathParseException ex) { // success } try { improperFormat.parse(source); Assert.fail(msg); } catch (MathParseException ex) { // success } } @Test public void testParseNegative() { { String source = "-1 / 2"; BigFraction c = properFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(-1, c.getNumeratorAsInt()); Assert.assertEquals(2, c.getDenominatorAsInt()); c = improperFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(-1, c.getNumeratorAsInt()); Assert.assertEquals(2, c.getDenominatorAsInt()); source = "1 / -2"; c = properFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(-1, c.getNumeratorAsInt()); Assert.assertEquals(2, c.getDenominatorAsInt()); c = improperFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(-1, c.getNumeratorAsInt()); Assert.assertEquals(2, c.getDenominatorAsInt()); } } @Test public void testParseProper() { String source = "1 2 / 3"; { BigFraction c = properFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(5, c.getNumeratorAsInt()); Assert.assertEquals(3, c.getDenominatorAsInt()); } try { improperFormat.parse(source); Assert.fail("invalid improper fraction."); } catch (MathParseException ex) { // success } } @Test public void testParseProperNegative() { String source = "-1 2 / 3"; { BigFraction c = properFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(-5, c.getNumeratorAsInt()); Assert.assertEquals(3, c.getDenominatorAsInt()); } try { improperFormat.parse(source); Assert.fail("invalid improper fraction."); } catch (MathParseException ex) { // success } } @Test public void testParseProperInvalidMinus() { String source = "2 -2 / 3"; try { properFormat.parse(source); Assert.fail("invalid minus in improper fraction."); } catch (MathParseException ex) { // expected } source = "2 2 / -3"; try { properFormat.parse(source); Assert.fail("invalid minus in improper fraction."); } catch (MathParseException ex) { // expected } } @Test public void testParseBig() { BigFraction f1 = improperFormat.parse("167213075789791382630275400487886041651764456874403" + " / " + "53225575123090058458126718248444563466137046489291"); Assert.assertEquals(FastMath.PI, f1.doubleValue(), 0.0); BigFraction f2 = properFormat.parse("3 " + "7536350420521207255895245742552351253353317406530" + " / " + "53225575123090058458126718248444563466137046489291"); Assert.assertEquals(FastMath.PI, f2.doubleValue(), 0.0); Assert.assertEquals(f1, f2); BigDecimal pi = new BigDecimal("3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068"); Assert.assertEquals(pi, f1.bigDecimalValue(99, BigDecimal.ROUND_HALF_EVEN)); } @Test public void testNumeratorFormat() { NumberFormat old = properFormat.getNumeratorFormat(); NumberFormat nf = NumberFormat.getInstance(); nf.setParseIntegerOnly(true); properFormat.setNumeratorFormat(nf); Assert.assertEquals(nf, properFormat.getNumeratorFormat()); properFormat.setNumeratorFormat(old); old = improperFormat.getNumeratorFormat(); nf = NumberFormat.getInstance(); nf.setParseIntegerOnly(true); improperFormat.setNumeratorFormat(nf); Assert.assertEquals(nf, improperFormat.getNumeratorFormat()); improperFormat.setNumeratorFormat(old); } @Test public void testDenominatorFormat() { NumberFormat old = properFormat.getDenominatorFormat(); NumberFormat nf = NumberFormat.getInstance(); nf.setParseIntegerOnly(true); properFormat.setDenominatorFormat(nf); Assert.assertEquals(nf, properFormat.getDenominatorFormat()); properFormat.setDenominatorFormat(old); old = improperFormat.getDenominatorFormat(); nf = NumberFormat.getInstance(); nf.setParseIntegerOnly(true); improperFormat.setDenominatorFormat(nf); Assert.assertEquals(nf, improperFormat.getDenominatorFormat()); improperFormat.setDenominatorFormat(old); } @Test public void testWholeFormat() { ProperBigFractionFormat format = (ProperBigFractionFormat)properFormat; NumberFormat old = format.getWholeFormat(); NumberFormat nf = NumberFormat.getInstance(); nf.setParseIntegerOnly(true); format.setWholeFormat(nf); Assert.assertEquals(nf, format.getWholeFormat()); format.setWholeFormat(old); } @Test public void testLongFormat() { Assert.assertEquals("10 / 1", improperFormat.format(10l)); } @Test public void testDoubleFormat() { Assert.assertEquals("1 / 16", improperFormat.format(0.0625)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.fraction; import java.math.BigDecimal; import java.math.BigInteger; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.exception.ConvergenceException; import org.apache.commons.math3.exception.MathArithmeticException; import org.apache.commons.math3.exception.NullArgumentException; import org.apache.commons.math3.exception.ZeroException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class BigFractionTest { private void assertFraction(int expectedNumerator, int expectedDenominator, BigFraction actual) { Assert.assertEquals(expectedNumerator, actual.getNumeratorAsInt()); Assert.assertEquals(expectedDenominator, actual.getDenominatorAsInt()); } private void assertFraction(long expectedNumerator, long expectedDenominator, BigFraction actual) { Assert.assertEquals(expectedNumerator, actual.getNumeratorAsLong()); Assert.assertEquals(expectedDenominator, actual.getDenominatorAsLong()); } @Test public void testConstructor() { assertFraction(0, 1, new BigFraction(0, 1)); assertFraction(0, 1, new BigFraction(0l, 2l)); assertFraction(0, 1, new BigFraction(0, -1)); assertFraction(1, 2, new BigFraction(1, 2)); assertFraction(1, 2, new BigFraction(2, 4)); assertFraction(-1, 2, new BigFraction(-1, 2)); assertFraction(-1, 2, new BigFraction(1, -2)); assertFraction(-1, 2, new BigFraction(-2, 4)); assertFraction(-1, 2, new BigFraction(2, -4)); assertFraction(11, 1, new BigFraction(11)); assertFraction(11, 1, new BigFraction(11l)); assertFraction(11, 1, new BigFraction(new BigInteger("11"))); assertFraction(0, 1, new BigFraction(0.00000000000001, 1.0e-5, 100)); assertFraction(2, 5, new BigFraction(0.40000000000001, 1.0e-5, 100)); assertFraction(15, 1, new BigFraction(15.0000000000001, 1.0e-5, 100)); Assert.assertEquals(0.00000000000001, new BigFraction(0.00000000000001).doubleValue(), 0.0); Assert.assertEquals(0.40000000000001, new BigFraction(0.40000000000001).doubleValue(), 0.0); Assert.assertEquals(15.0000000000001, new BigFraction(15.0000000000001).doubleValue(), 0.0); assertFraction(3602879701896487l, 9007199254740992l, new BigFraction(0.40000000000001)); assertFraction(1055531162664967l, 70368744177664l, new BigFraction(15.0000000000001)); try { new BigFraction(null, BigInteger.ONE); Assert.fail("Expecting NullArgumentException"); } catch (NullArgumentException npe) { // expected } try { new BigFraction(BigInteger.ONE, null); Assert.fail("Expecting NullArgumentException"); } catch (NullArgumentException npe) { // expected } try { new BigFraction(BigInteger.ONE, BigInteger.ZERO); Assert.fail("Expecting ZeroException"); } catch (ZeroException npe) { // expected } try { new BigFraction(2.0 * Integer.MAX_VALUE, 1.0e-5, 100000); Assert.fail("Expecting FractionConversionException"); } catch (FractionConversionException fce) { // expected } } @Test(expected=ConvergenceException.class) public void testGoldenRatio() { // the golden ratio is notoriously a difficult number for continuous fraction new BigFraction((1 + FastMath.sqrt(5)) / 2, 1.0e-12, 25); } // MATH-179 @Test public void testDoubleConstructor() throws ConvergenceException { assertFraction(1, 2, new BigFraction((double) 1 / (double) 2, 1.0e-5, 100)); assertFraction(1, 3, new BigFraction((double) 1 / (double) 3, 1.0e-5, 100)); assertFraction(2, 3, new BigFraction((double) 2 / (double) 3, 1.0e-5, 100)); assertFraction(1, 4, new BigFraction((double) 1 / (double) 4, 1.0e-5, 100)); assertFraction(3, 4, new BigFraction((double) 3 / (double) 4, 1.0e-5, 100)); assertFraction(1, 5, new BigFraction((double) 1 / (double) 5, 1.0e-5, 100)); assertFraction(2, 5, new BigFraction((double) 2 / (double) 5, 1.0e-5, 100)); assertFraction(3, 5, new BigFraction((double) 3 / (double) 5, 1.0e-5, 100)); assertFraction(4, 5, new BigFraction((double) 4 / (double) 5, 1.0e-5, 100)); assertFraction(1, 6, new BigFraction((double) 1 / (double) 6, 1.0e-5, 100)); assertFraction(5, 6, new BigFraction((double) 5 / (double) 6, 1.0e-5, 100)); assertFraction(1, 7, new BigFraction((double) 1 / (double) 7, 1.0e-5, 100)); assertFraction(2, 7, new BigFraction((double) 2 / (double) 7, 1.0e-5, 100)); assertFraction(3, 7, new BigFraction((double) 3 / (double) 7, 1.0e-5, 100)); assertFraction(4, 7, new BigFraction((double) 4 / (double) 7, 1.0e-5, 100)); assertFraction(5, 7, new BigFraction((double) 5 / (double) 7, 1.0e-5, 100)); assertFraction(6, 7, new BigFraction((double) 6 / (double) 7, 1.0e-5, 100)); assertFraction(1, 8, new BigFraction((double) 1 / (double) 8, 1.0e-5, 100)); assertFraction(3, 8, new BigFraction((double) 3 / (double) 8, 1.0e-5, 100)); assertFraction(5, 8, new BigFraction((double) 5 / (double) 8, 1.0e-5, 100)); assertFraction(7, 8, new BigFraction((double) 7 / (double) 8, 1.0e-5, 100)); assertFraction(1, 9, new BigFraction((double) 1 / (double) 9, 1.0e-5, 100)); assertFraction(2, 9, new BigFraction((double) 2 / (double) 9, 1.0e-5, 100)); assertFraction(4, 9, new BigFraction((double) 4 / (double) 9, 1.0e-5, 100)); assertFraction(5, 9, new BigFraction((double) 5 / (double) 9, 1.0e-5, 100)); assertFraction(7, 9, new BigFraction((double) 7 / (double) 9, 1.0e-5, 100)); assertFraction(8, 9, new BigFraction((double) 8 / (double) 9, 1.0e-5, 100)); assertFraction(1, 10, new BigFraction((double) 1 / (double) 10, 1.0e-5, 100)); assertFraction(3, 10, new BigFraction((double) 3 / (double) 10, 1.0e-5, 100)); assertFraction(7, 10, new BigFraction((double) 7 / (double) 10, 1.0e-5, 100)); assertFraction(9, 10, new BigFraction((double) 9 / (double) 10, 1.0e-5, 100)); assertFraction(1, 11, new BigFraction((double) 1 / (double) 11, 1.0e-5, 100)); assertFraction(2, 11, new BigFraction((double) 2 / (double) 11, 1.0e-5, 100)); assertFraction(3, 11, new BigFraction((double) 3 / (double) 11, 1.0e-5, 100)); assertFraction(4, 11, new BigFraction((double) 4 / (double) 11, 1.0e-5, 100)); assertFraction(5, 11, new BigFraction((double) 5 / (double) 11, 1.0e-5, 100)); assertFraction(6, 11, new BigFraction((double) 6 / (double) 11, 1.0e-5, 100)); assertFraction(7, 11, new BigFraction((double) 7 / (double) 11, 1.0e-5, 100)); assertFraction(8, 11, new BigFraction((double) 8 / (double) 11, 1.0e-5, 100)); assertFraction(9, 11, new BigFraction((double) 9 / (double) 11, 1.0e-5, 100)); assertFraction(10, 11, new BigFraction((double) 10 / (double) 11, 1.0e-5, 100)); } // MATH-181 @Test public void testDigitLimitConstructor() throws ConvergenceException { assertFraction(2, 5, new BigFraction(0.4, 9)); assertFraction(2, 5, new BigFraction(0.4, 99)); assertFraction(2, 5, new BigFraction(0.4, 999)); assertFraction(3, 5, new BigFraction(0.6152, 9)); assertFraction(8, 13, new BigFraction(0.6152, 99)); assertFraction(510, 829, new BigFraction(0.6152, 999)); assertFraction(769, 1250, new BigFraction(0.6152, 9999)); // MATH-996 assertFraction(1, 2, new BigFraction(0.5000000001, 10)); } @Test public void testEpsilonLimitConstructor() throws ConvergenceException { assertFraction(2, 5, new BigFraction(0.4, 1.0e-5, 100)); assertFraction(3, 5, new BigFraction(0.6152, 0.02, 100)); assertFraction(8, 13, new BigFraction(0.6152, 1.0e-3, 100)); assertFraction(251, 408, new BigFraction(0.6152, 1.0e-4, 100)); assertFraction(251, 408, new BigFraction(0.6152, 1.0e-5, 100)); assertFraction(510, 829, new BigFraction(0.6152, 1.0e-6, 100)); assertFraction(769, 1250, new BigFraction(0.6152, 1.0e-7, 100)); } @Test public void testCompareTo() { BigFraction first = new BigFraction(1, 2); BigFraction second = new BigFraction(1, 3); BigFraction third = new BigFraction(1, 2); Assert.assertEquals(0, first.compareTo(first)); Assert.assertEquals(0, first.compareTo(third)); Assert.assertEquals(1, first.compareTo(second)); Assert.assertEquals(-1, second.compareTo(first)); // these two values are different approximations of PI // the first one is approximately PI - 3.07e-18 // the second one is approximately PI + 1.936e-17 BigFraction pi1 = new BigFraction(1068966896, 340262731); BigFraction pi2 = new BigFraction( 411557987, 131002976); Assert.assertEquals(-1, pi1.compareTo(pi2)); Assert.assertEquals( 1, pi2.compareTo(pi1)); Assert.assertEquals(0.0, pi1.doubleValue() - pi2.doubleValue(), 1.0e-20); } @Test public void testDoubleValue() { BigFraction first = new BigFraction(1, 2); BigFraction second = new BigFraction(1, 3); Assert.assertEquals(0.5, first.doubleValue(), 0.0); Assert.assertEquals(1.0 / 3.0, second.doubleValue(), 0.0); } // MATH-744 @Test public void testDoubleValueForLargeNumeratorAndDenominator() { final BigInteger pow400 = BigInteger.TEN.pow(400); final BigInteger pow401 = BigInteger.TEN.pow(401); final BigInteger two = new BigInteger("2"); final BigFraction large = new BigFraction(pow401.add(BigInteger.ONE), pow400.multiply(two)); Assert.assertEquals(5, large.doubleValue(), 1e-15); } // MATH-744 @Test public void testFloatValueForLargeNumeratorAndDenominator() { final BigInteger pow400 = BigInteger.TEN.pow(400); final BigInteger pow401 = BigInteger.TEN.pow(401); final BigInteger two = new BigInteger("2"); final BigFraction large = new BigFraction(pow401.add(BigInteger.ONE), pow400.multiply(two)); Assert.assertEquals(5, large.floatValue(), 1e-15); } @Test public void testFloatValue() { BigFraction first = new BigFraction(1, 2); BigFraction second = new BigFraction(1, 3); Assert.assertEquals(0.5f, first.floatValue(), 0.0f); Assert.assertEquals((float) (1.0 / 3.0), second.floatValue(), 0.0f); } @Test public void testIntValue() { BigFraction first = new BigFraction(1, 2); BigFraction second = new BigFraction(3, 2); Assert.assertEquals(0, first.intValue()); Assert.assertEquals(1, second.intValue()); } @Test public void testLongValue() { BigFraction first = new BigFraction(1, 2); BigFraction second = new BigFraction(3, 2); Assert.assertEquals(0L, first.longValue()); Assert.assertEquals(1L, second.longValue()); } @Test public void testConstructorDouble() { assertFraction(1, 2, new BigFraction(0.5)); assertFraction(6004799503160661l, 18014398509481984l, new BigFraction(1.0 / 3.0)); assertFraction(6124895493223875l, 36028797018963968l, new BigFraction(17.0 / 100.0)); assertFraction(1784551352345559l, 562949953421312l, new BigFraction(317.0 / 100.0)); assertFraction(-1, 2, new BigFraction(-0.5)); assertFraction(-6004799503160661l, 18014398509481984l, new BigFraction(-1.0 / 3.0)); assertFraction(-6124895493223875l, 36028797018963968l, new BigFraction(17.0 / -100.0)); assertFraction(-1784551352345559l, 562949953421312l, new BigFraction(-317.0 / 100.0)); for (double v : new double[] { Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY}) { try { new BigFraction(v); Assert.fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException iae) { // expected } } Assert.assertEquals(1l, new BigFraction(Double.MAX_VALUE).getDenominatorAsLong()); Assert.assertEquals(1l, new BigFraction(Double.longBitsToDouble(0x0010000000000000L)).getNumeratorAsLong()); Assert.assertEquals(1l, new BigFraction(Double.MIN_VALUE).getNumeratorAsLong()); } @Test public void testAbs() { BigFraction a = new BigFraction(10, 21); BigFraction b = new BigFraction(-10, 21); BigFraction c = new BigFraction(10, -21); assertFraction(10, 21, a.abs()); assertFraction(10, 21, b.abs()); assertFraction(10, 21, c.abs()); } @Test public void testReciprocal() { BigFraction f = null; f = new BigFraction(50, 75); f = f.reciprocal(); Assert.assertEquals(3, f.getNumeratorAsInt()); Assert.assertEquals(2, f.getDenominatorAsInt()); f = new BigFraction(4, 3); f = f.reciprocal(); Assert.assertEquals(3, f.getNumeratorAsInt()); Assert.assertEquals(4, f.getDenominatorAsInt()); f = new BigFraction(-15, 47); f = f.reciprocal(); Assert.assertEquals(-47, f.getNumeratorAsInt()); Assert.assertEquals(15, f.getDenominatorAsInt()); f = new BigFraction(0, 3); try { f = f.reciprocal(); Assert.fail("expecting ZeroException"); } catch (ZeroException ex) { } // large values f = new BigFraction(Integer.MAX_VALUE, 1); f = f.reciprocal(); Assert.assertEquals(1, f.getNumeratorAsInt()); Assert.assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt()); } @Test public void testNegate() { BigFraction f = null; f = new BigFraction(50, 75); f = f.negate(); Assert.assertEquals(-2, f.getNumeratorAsInt()); Assert.assertEquals(3, f.getDenominatorAsInt()); f = new BigFraction(-50, 75); f = f.negate(); Assert.assertEquals(2, f.getNumeratorAsInt()); Assert.assertEquals(3, f.getDenominatorAsInt()); // large values f = new BigFraction(Integer.MAX_VALUE - 1, Integer.MAX_VALUE); f = f.negate(); Assert.assertEquals(Integer.MIN_VALUE + 2, f.getNumeratorAsInt()); Assert.assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt()); } @Test public void testAdd() { BigFraction a = new BigFraction(1, 2); BigFraction b = new BigFraction(2, 3); assertFraction(1, 1, a.add(a)); assertFraction(7, 6, a.add(b)); assertFraction(7, 6, b.add(a)); assertFraction(4, 3, b.add(b)); BigFraction f1 = new BigFraction(Integer.MAX_VALUE - 1, 1); BigFraction f2 = BigFraction.ONE; BigFraction f = f1.add(f2); Assert.assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt()); Assert.assertEquals(1, f.getDenominatorAsInt()); f1 = new BigFraction(-1, 13 * 13 * 2 * 2); f2 = new BigFraction(-2, 13 * 17 * 2); f = f1.add(f2); Assert.assertEquals(13 * 13 * 17 * 2 * 2, f.getDenominatorAsInt()); Assert.assertEquals(-17 - 2 * 13 * 2, f.getNumeratorAsInt()); try { f.add((BigFraction) null); Assert.fail("expecting NullArgumentException"); } catch (NullArgumentException ex) { } // if this fraction is added naively, it will overflow. // check that it doesn't. f1 = new BigFraction(1, 32768 * 3); f2 = new BigFraction(1, 59049); f = f1.add(f2); Assert.assertEquals(52451, f.getNumeratorAsInt()); Assert.assertEquals(1934917632, f.getDenominatorAsInt()); f1 = new BigFraction(Integer.MIN_VALUE, 3); f2 = new BigFraction(1, 3); f = f1.add(f2); Assert.assertEquals(Integer.MIN_VALUE + 1, f.getNumeratorAsInt()); Assert.assertEquals(3, f.getDenominatorAsInt()); f1 = new BigFraction(Integer.MAX_VALUE - 1, 1); f = f1.add(BigInteger.ONE); Assert.assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt()); Assert.assertEquals(1, f.getDenominatorAsInt()); f = f.add(BigInteger.ZERO); Assert.assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt()); Assert.assertEquals(1, f.getDenominatorAsInt()); f1 = new BigFraction(Integer.MAX_VALUE - 1, 1); f = f1.add(1); Assert.assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt()); Assert.assertEquals(1, f.getDenominatorAsInt()); f = f.add(0); Assert.assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt()); Assert.assertEquals(1, f.getDenominatorAsInt()); f1 = new BigFraction(Integer.MAX_VALUE - 1, 1); f = f1.add(1l); Assert.assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt()); Assert.assertEquals(1, f.getDenominatorAsInt()); f = f.add(0l); Assert.assertEquals(Integer.MAX_VALUE, f.getNumeratorAsInt()); Assert.assertEquals(1, f.getDenominatorAsInt()); } @Test public void testDivide() { BigFraction a = new BigFraction(1, 2); BigFraction b = new BigFraction(2, 3); assertFraction(1, 1, a.divide(a)); assertFraction(3, 4, a.divide(b)); assertFraction(4, 3, b.divide(a)); assertFraction(1, 1, b.divide(b)); BigFraction f1 = new BigFraction(3, 5); BigFraction f2 = BigFraction.ZERO; try { f1.divide(f2); Assert.fail("expecting MathArithmeticException"); } catch (MathArithmeticException ex) { } f1 = new BigFraction(0, 5); f2 = new BigFraction(2, 7); BigFraction f = f1.divide(f2); Assert.assertSame(BigFraction.ZERO, f); f1 = new BigFraction(2, 7); f2 = BigFraction.ONE; f = f1.divide(f2); Assert.assertEquals(2, f.getNumeratorAsInt()); Assert.assertEquals(7, f.getDenominatorAsInt()); f1 = new BigFraction(1, Integer.MAX_VALUE); f = f1.divide(f1); Assert.assertEquals(1, f.getNumeratorAsInt()); Assert.assertEquals(1, f.getDenominatorAsInt()); f1 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE); f2 = new BigFraction(1, Integer.MAX_VALUE); f = f1.divide(f2); Assert.assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt()); Assert.assertEquals(1, f.getDenominatorAsInt()); try { f.divide((BigFraction) null); Assert.fail("expecting NullArgumentException"); } catch (NullArgumentException ex) { } f1 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE); f = f1.divide(BigInteger.valueOf(Integer.MIN_VALUE)); Assert.assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt()); Assert.assertEquals(1, f.getNumeratorAsInt()); f1 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE); f = f1.divide(Integer.MIN_VALUE); Assert.assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt()); Assert.assertEquals(1, f.getNumeratorAsInt()); f1 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE); f = f1.divide((long) Integer.MIN_VALUE); Assert.assertEquals(Integer.MAX_VALUE, f.getDenominatorAsInt()); Assert.assertEquals(1, f.getNumeratorAsInt()); } @Test public void testMultiply() { BigFraction a = new BigFraction(1, 2); BigFraction b = new BigFraction(2, 3); assertFraction(1, 4, a.multiply(a)); assertFraction(1, 3, a.multiply(b)); assertFraction(1, 3, b.multiply(a)); assertFraction(4, 9, b.multiply(b)); BigFraction f1 = new BigFraction(Integer.MAX_VALUE, 1); BigFraction f2 = new BigFraction(Integer.MIN_VALUE, Integer.MAX_VALUE); BigFraction f = f1.multiply(f2); Assert.assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt()); Assert.assertEquals(1, f.getDenominatorAsInt()); f = f2.multiply(Integer.MAX_VALUE); Assert.assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt()); Assert.assertEquals(1, f.getDenominatorAsInt()); f = f2.multiply((long) Integer.MAX_VALUE); Assert.assertEquals(Integer.MIN_VALUE, f.getNumeratorAsInt()); Assert.assertEquals(1, f.getDenominatorAsInt()); try { f.multiply((BigFraction) null); Assert.fail("expecting NullArgumentException"); } catch (NullArgumentException ex) { } } @Test public void testSubtract() { BigFraction a = new BigFraction(1, 2); BigFraction b = new BigFraction(2, 3); assertFraction(0, 1, a.subtract(a)); assertFraction(-1, 6, a.subtract(b)); assertFraction(1, 6, b.subtract(a)); assertFraction(0, 1, b.subtract(b)); BigFraction f = new BigFraction(1, 1); try { f.subtract((BigFraction) null); Assert.fail("expecting NullArgumentException"); } catch (NullArgumentException ex) { } // if this fraction is subtracted naively, it will overflow. // check that it doesn't. BigFraction f1 = new BigFraction(1, 32768 * 3); BigFraction f2 = new BigFraction(1, 59049); f = f1.subtract(f2); Assert.assertEquals(-13085, f.getNumeratorAsInt()); Assert.assertEquals(1934917632, f.getDenominatorAsInt()); f1 = new BigFraction(Integer.MIN_VALUE, 3); f2 = new BigFraction(1, 3).negate(); f = f1.subtract(f2); Assert.assertEquals(Integer.MIN_VALUE + 1, f.getNumeratorAsInt()); Assert.assertEquals(3, f.getDenominatorAsInt()); f1 = new BigFraction(Integer.MAX_VALUE, 1); f2 = BigFraction.ONE; f = f1.subtract(f2); Assert.assertEquals(Integer.MAX_VALUE - 1, f.getNumeratorAsInt()); Assert.assertEquals(1, f.getDenominatorAsInt()); } @Test public void testBigDecimalValue() { Assert.assertEquals(new BigDecimal(0.5), new BigFraction(1, 2).bigDecimalValue()); Assert.assertEquals(new BigDecimal("0.0003"), new BigFraction(3, 10000).bigDecimalValue()); Assert.assertEquals(new BigDecimal("0"), new BigFraction(1, 3).bigDecimalValue(BigDecimal.ROUND_DOWN)); Assert.assertEquals(new BigDecimal("0.333"), new BigFraction(1, 3).bigDecimalValue(3, BigDecimal.ROUND_DOWN)); } @Test public void testEqualsAndHashCode() { BigFraction zero = new BigFraction(0, 1); BigFraction nullFraction = null; Assert.assertTrue(zero.equals(zero)); Assert.assertFalse(zero.equals(nullFraction)); Assert.assertFalse(zero.equals(Double.valueOf(0))); BigFraction zero2 = new BigFraction(0, 2); Assert.assertTrue(zero.equals(zero2)); Assert.assertEquals(zero.hashCode(), zero2.hashCode()); BigFraction one = new BigFraction(1, 1); Assert.assertFalse((one.equals(zero) || zero.equals(one))); Assert.assertTrue(one.equals(BigFraction.ONE)); } @Test public void testGetReducedFraction() { BigFraction threeFourths = new BigFraction(3, 4); Assert.assertTrue(threeFourths.equals(BigFraction.getReducedFraction(6, 8))); Assert.assertTrue(BigFraction.ZERO.equals(BigFraction.getReducedFraction(0, -1))); try { BigFraction.getReducedFraction(1, 0); Assert.fail("expecting ZeroException"); } catch (ZeroException ex) { // expected } Assert.assertEquals(BigFraction.getReducedFraction(2, Integer.MIN_VALUE).getNumeratorAsInt(), -1); Assert.assertEquals(BigFraction.getReducedFraction(1, -1).getNumeratorAsInt(), -1); } @Test public void testPercentage() { Assert.assertEquals(50.0, new BigFraction(1, 2).percentageValue(), 1.0e-15); } @Test public void testPow() { Assert.assertEquals(new BigFraction(8192, 1594323), new BigFraction(2, 3).pow(13)); Assert.assertEquals(new BigFraction(8192, 1594323), new BigFraction(2, 3).pow(13l)); Assert.assertEquals(new BigFraction(8192, 1594323), new BigFraction(2, 3).pow(BigInteger.valueOf(13l))); Assert.assertEquals(BigFraction.ONE, new BigFraction(2, 3).pow(0)); Assert.assertEquals(BigFraction.ONE, new BigFraction(2, 3).pow(0l)); Assert.assertEquals(BigFraction.ONE, new BigFraction(2, 3).pow(BigInteger.valueOf(0l))); Assert.assertEquals(new BigFraction(1594323, 8192), new BigFraction(2, 3).pow(-13)); Assert.assertEquals(new BigFraction(1594323, 8192), new BigFraction(2, 3).pow(-13l)); Assert.assertEquals(new BigFraction(1594323, 8192), new BigFraction(2, 3).pow(BigInteger.valueOf(-13l))); } @Test public void testMath340() { BigFraction fractionA = new BigFraction(0.00131); BigFraction fractionB = new BigFraction(.37).reciprocal(); BigFraction errorResult = fractionA.multiply(fractionB); BigFraction correctResult = new BigFraction(fractionA.getNumerator().multiply(fractionB.getNumerator()), fractionA.getDenominator().multiply(fractionB.getDenominator())); Assert.assertEquals(correctResult, errorResult); } @Test public void testSerial() throws FractionConversionException { BigFraction[] fractions = { new BigFraction(3, 4), BigFraction.ONE, BigFraction.ZERO, new BigFraction(17), new BigFraction(FastMath.PI, 1000), new BigFraction(-5, 2) }; for (BigFraction fraction : fractions) { Assert.assertEquals(fraction, TestUtils.serializeAndRecover(fraction)); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.fraction; import org.apache.commons.math3.TestUtils; import org.junit.Assert; import org.junit.Test; public class FractionFieldTest { @Test public void testZero() { Assert.assertEquals(Fraction.ZERO, FractionField.getInstance().getZero()); } @Test public void testOne() { Assert.assertEquals(Fraction.ONE, FractionField.getInstance().getOne()); } @Test public void testSerial() { // deserializing the singleton should give the singleton itself back FractionField field = FractionField.getInstance(); Assert.assertTrue(field == TestUtils.serializeAndRecover(field)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.fraction; import java.text.NumberFormat; import java.util.Locale; import org.apache.commons.math3.exception.MathParseException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Before; import org.junit.Test; public class FractionFormatTest { FractionFormat properFormat = null; FractionFormat improperFormat = null; protected Locale getLocale() { return Locale.getDefault(); } @Before public void setUp() { properFormat = FractionFormat.getProperInstance(getLocale()); improperFormat = FractionFormat.getImproperInstance(getLocale()); } @Test public void testFormat() { Fraction c = new Fraction(1, 2); String expected = "1 / 2"; String actual = properFormat.format(c); Assert.assertEquals(expected, actual); actual = improperFormat.format(c); Assert.assertEquals(expected, actual); } @Test public void testFormatNegative() { Fraction c = new Fraction(-1, 2); String expected = "-1 / 2"; String actual = properFormat.format(c); Assert.assertEquals(expected, actual); actual = improperFormat.format(c); Assert.assertEquals(expected, actual); } @Test public void testFormatZero() { Fraction c = new Fraction(0, 1); String expected = "0 / 1"; String actual = properFormat.format(c); Assert.assertEquals(expected, actual); actual = improperFormat.format(c); Assert.assertEquals(expected, actual); } @Test public void testFormatImproper() { Fraction c = new Fraction(5, 3); String actual = properFormat.format(c); Assert.assertEquals("1 2 / 3", actual); actual = improperFormat.format(c); Assert.assertEquals("5 / 3", actual); } @Test public void testFormatImproperNegative() { Fraction c = new Fraction(-5, 3); String actual = properFormat.format(c); Assert.assertEquals("-1 2 / 3", actual); actual = improperFormat.format(c); Assert.assertEquals("-5 / 3", actual); } @Test public void testParse() { String source = "1 / 2"; try { Fraction c = properFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(1, c.getNumerator()); Assert.assertEquals(2, c.getDenominator()); c = improperFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(1, c.getNumerator()); Assert.assertEquals(2, c.getDenominator()); } catch (MathParseException ex) { Assert.fail(ex.getMessage()); } } @Test public void testParseInteger() { String source = "10"; { Fraction c = properFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(10, c.getNumerator()); Assert.assertEquals(1, c.getDenominator()); } { Fraction c = improperFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(10, c.getNumerator()); Assert.assertEquals(1, c.getDenominator()); } } @Test public void testParseOne1() { String source = "1 / 1"; Fraction c = properFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(1, c.getNumerator()); Assert.assertEquals(1, c.getDenominator()); } @Test public void testParseOne2() { String source = "10 / 10"; Fraction c = properFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(1, c.getNumerator()); Assert.assertEquals(1, c.getDenominator()); } @Test public void testParseZero1() { String source = "0 / 1"; Fraction c = properFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(0, c.getNumerator()); Assert.assertEquals(1, c.getDenominator()); } @Test public void testParseZero2() { String source = "-0 / 1"; Fraction c = properFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(0, c.getNumerator()); Assert.assertEquals(1, c.getDenominator()); // This test shows that the sign is not preserved. Assert.assertEquals(Double.POSITIVE_INFINITY, 1d / c.doubleValue(), 0); } @Test public void testParseInvalid() { String source = "a"; String msg = "should not be able to parse '10 / a'."; try { properFormat.parse(source); Assert.fail(msg); } catch (MathParseException ex) { // success } try { improperFormat.parse(source); Assert.fail(msg); } catch (MathParseException ex) { // success } } @Test public void testParseInvalidDenominator() { String source = "10 / a"; String msg = "should not be able to parse '10 / a'."; try { properFormat.parse(source); Assert.fail(msg); } catch (MathParseException ex) { // success } try { improperFormat.parse(source); Assert.fail(msg); } catch (MathParseException ex) { // success } } @Test public void testParseNegative() { { String source = "-1 / 2"; Fraction c = properFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(-1, c.getNumerator()); Assert.assertEquals(2, c.getDenominator()); c = improperFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(-1, c.getNumerator()); Assert.assertEquals(2, c.getDenominator()); source = "1 / -2"; c = properFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(-1, c.getNumerator()); Assert.assertEquals(2, c.getDenominator()); c = improperFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(-1, c.getNumerator()); Assert.assertEquals(2, c.getDenominator()); } } @Test public void testParseProper() { String source = "1 2 / 3"; { Fraction c = properFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(5, c.getNumerator()); Assert.assertEquals(3, c.getDenominator()); } try { improperFormat.parse(source); Assert.fail("invalid improper fraction."); } catch (MathParseException ex) { // success } } @Test public void testParseProperNegative() { String source = "-1 2 / 3"; { Fraction c = properFormat.parse(source); Assert.assertNotNull(c); Assert.assertEquals(-5, c.getNumerator()); Assert.assertEquals(3, c.getDenominator()); } try { improperFormat.parse(source); Assert.fail("invalid improper fraction."); } catch (MathParseException ex) { // success } } @Test public void testParseProperInvalidMinus() { String source = "2 -2 / 3"; try { properFormat.parse(source); Assert.fail("invalid minus in improper fraction."); } catch (MathParseException ex) { // expected } source = "2 2 / -3"; try { properFormat.parse(source); Assert.fail("invalid minus in improper fraction."); } catch (MathParseException ex) { // expected } } @Test public void testNumeratorFormat() { NumberFormat old = properFormat.getNumeratorFormat(); NumberFormat nf = NumberFormat.getInstance(); nf.setParseIntegerOnly(true); properFormat.setNumeratorFormat(nf); Assert.assertEquals(nf, properFormat.getNumeratorFormat()); properFormat.setNumeratorFormat(old); old = improperFormat.getNumeratorFormat(); nf = NumberFormat.getInstance(); nf.setParseIntegerOnly(true); improperFormat.setNumeratorFormat(nf); Assert.assertEquals(nf, improperFormat.getNumeratorFormat()); improperFormat.setNumeratorFormat(old); } @Test public void testDenominatorFormat() { NumberFormat old = properFormat.getDenominatorFormat(); NumberFormat nf = NumberFormat.getInstance(); nf.setParseIntegerOnly(true); properFormat.setDenominatorFormat(nf); Assert.assertEquals(nf, properFormat.getDenominatorFormat()); properFormat.setDenominatorFormat(old); old = improperFormat.getDenominatorFormat(); nf = NumberFormat.getInstance(); nf.setParseIntegerOnly(true); improperFormat.setDenominatorFormat(nf); Assert.assertEquals(nf, improperFormat.getDenominatorFormat()); improperFormat.setDenominatorFormat(old); } @Test public void testWholeFormat() { ProperFractionFormat format = (ProperFractionFormat)properFormat; NumberFormat old = format.getWholeFormat(); NumberFormat nf = NumberFormat.getInstance(); nf.setParseIntegerOnly(true); format.setWholeFormat(nf); Assert.assertEquals(nf, format.getWholeFormat()); format.setWholeFormat(old); } @Test public void testLongFormat() { Assert.assertEquals("10 / 1", improperFormat.format(10l)); } @Test public void testDoubleFormat() { Assert.assertEquals("355 / 113", improperFormat.format(FastMath.PI)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.fraction; import org.apache.commons.math3.exception.ConvergenceException; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.exception.MathArithmeticException; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * @version $Id$ */ public class FractionTest { private void assertFraction(int expectedNumerator, int expectedDenominator, Fraction actual) { Assert.assertEquals(expectedNumerator, actual.getNumerator()); Assert.assertEquals(expectedDenominator, actual.getDenominator()); } @Test public void testConstructor() { assertFraction(0, 1, new Fraction(0, 1)); assertFraction(0, 1, new Fraction(0, 2)); assertFraction(0, 1, new Fraction(0, -1)); assertFraction(1, 2, new Fraction(1, 2)); assertFraction(1, 2, new Fraction(2, 4)); assertFraction(-1, 2, new Fraction(-1, 2)); assertFraction(-1, 2, new Fraction(1, -2)); assertFraction(-1, 2, new Fraction(-2, 4)); assertFraction(-1, 2, new Fraction(2, -4)); // overflow try { new Fraction(Integer.MIN_VALUE, -1); Assert.fail(); } catch (MathArithmeticException ex) { // success } try { new Fraction(1, Integer.MIN_VALUE); Assert.fail(); } catch (MathArithmeticException ex) { // success } assertFraction(0, 1, new Fraction(0.00000000000001)); assertFraction(2, 5, new Fraction(0.40000000000001)); assertFraction(15, 1, new Fraction(15.0000000000001)); } @Test(expected=ConvergenceException.class) public void testGoldenRatio() { // the golden ratio is notoriously a difficult number for continuous fraction new Fraction((1 + FastMath.sqrt(5)) / 2, 1.0e-12, 25); } // MATH-179 @Test public void testDoubleConstructor() throws ConvergenceException { assertFraction(1, 2, new Fraction((double)1 / (double)2)); assertFraction(1, 3, new Fraction((double)1 / (double)3)); assertFraction(2, 3, new Fraction((double)2 / (double)3)); assertFraction(1, 4, new Fraction((double)1 / (double)4)); assertFraction(3, 4, new Fraction((double)3 / (double)4)); assertFraction(1, 5, new Fraction((double)1 / (double)5)); assertFraction(2, 5, new Fraction((double)2 / (double)5)); assertFraction(3, 5, new Fraction((double)3 / (double)5)); assertFraction(4, 5, new Fraction((double)4 / (double)5)); assertFraction(1, 6, new Fraction((double)1 / (double)6)); assertFraction(5, 6, new Fraction((double)5 / (double)6)); assertFraction(1, 7, new Fraction((double)1 / (double)7)); assertFraction(2, 7, new Fraction((double)2 / (double)7)); assertFraction(3, 7, new Fraction((double)3 / (double)7)); assertFraction(4, 7, new Fraction((double)4 / (double)7)); assertFraction(5, 7, new Fraction((double)5 / (double)7)); assertFraction(6, 7, new Fraction((double)6 / (double)7)); assertFraction(1, 8, new Fraction((double)1 / (double)8)); assertFraction(3, 8, new Fraction((double)3 / (double)8)); assertFraction(5, 8, new Fraction((double)5 / (double)8)); assertFraction(7, 8, new Fraction((double)7 / (double)8)); assertFraction(1, 9, new Fraction((double)1 / (double)9)); assertFraction(2, 9, new Fraction((double)2 / (double)9)); assertFraction(4, 9, new Fraction((double)4 / (double)9)); assertFraction(5, 9, new Fraction((double)5 / (double)9)); assertFraction(7, 9, new Fraction((double)7 / (double)9)); assertFraction(8, 9, new Fraction((double)8 / (double)9)); assertFraction(1, 10, new Fraction((double)1 / (double)10)); assertFraction(3, 10, new Fraction((double)3 / (double)10)); assertFraction(7, 10, new Fraction((double)7 / (double)10)); assertFraction(9, 10, new Fraction((double)9 / (double)10)); assertFraction(1, 11, new Fraction((double)1 / (double)11)); assertFraction(2, 11, new Fraction((double)2 / (double)11)); assertFraction(3, 11, new Fraction((double)3 / (double)11)); assertFraction(4, 11, new Fraction((double)4 / (double)11)); assertFraction(5, 11, new Fraction((double)5 / (double)11)); assertFraction(6, 11, new Fraction((double)6 / (double)11)); assertFraction(7, 11, new Fraction((double)7 / (double)11)); assertFraction(8, 11, new Fraction((double)8 / (double)11)); assertFraction(9, 11, new Fraction((double)9 / (double)11)); assertFraction(10, 11, new Fraction((double)10 / (double)11)); } // MATH-181 @Test public void testDigitLimitConstructor() throws ConvergenceException { assertFraction(2, 5, new Fraction(0.4, 9)); assertFraction(2, 5, new Fraction(0.4, 99)); assertFraction(2, 5, new Fraction(0.4, 999)); assertFraction(3, 5, new Fraction(0.6152, 9)); assertFraction(8, 13, new Fraction(0.6152, 99)); assertFraction(510, 829, new Fraction(0.6152, 999)); assertFraction(769, 1250, new Fraction(0.6152, 9999)); // MATH-996 assertFraction(1, 2, new Fraction(0.5000000001, 10)); } @Test public void testIntegerOverflow() { checkIntegerOverflow(0.75000000001455192); checkIntegerOverflow(1.0e10); checkIntegerOverflow(-1.0e10); checkIntegerOverflow(-43979.60679604749); } private void checkIntegerOverflow(double a) { try { @SuppressWarnings("unused") Fraction f = new Fraction(a, 1.0e-12, 1000); //System.out.println(f.getNumerator() + "/" + f.getDenominator()); Assert.fail("an exception should have been thrown"); } catch (ConvergenceException ce) { // expected behavior } } @Test public void testEpsilonLimitConstructor() throws ConvergenceException { assertFraction(2, 5, new Fraction(0.4, 1.0e-5, 100)); assertFraction(3, 5, new Fraction(0.6152, 0.02, 100)); assertFraction(8, 13, new Fraction(0.6152, 1.0e-3, 100)); assertFraction(251, 408, new Fraction(0.6152, 1.0e-4, 100)); assertFraction(251, 408, new Fraction(0.6152, 1.0e-5, 100)); assertFraction(510, 829, new Fraction(0.6152, 1.0e-6, 100)); assertFraction(769, 1250, new Fraction(0.6152, 1.0e-7, 100)); } @Test public void testCompareTo() { Fraction first = new Fraction(1, 2); Fraction second = new Fraction(1, 3); Fraction third = new Fraction(1, 2); Assert.assertEquals(0, first.compareTo(first)); Assert.assertEquals(0, first.compareTo(third)); Assert.assertEquals(1, first.compareTo(second)); Assert.assertEquals(-1, second.compareTo(first)); // these two values are different approximations of PI // the first one is approximately PI - 3.07e-18 // the second one is approximately PI + 1.936e-17 Fraction pi1 = new Fraction(1068966896, 340262731); Fraction pi2 = new Fraction( 411557987, 131002976); Assert.assertEquals(-1, pi1.compareTo(pi2)); Assert.assertEquals( 1, pi2.compareTo(pi1)); Assert.assertEquals(0.0, pi1.doubleValue() - pi2.doubleValue(), 1.0e-20); } @Test public void testDoubleValue() { Fraction first = new Fraction(1, 2); Fraction second = new Fraction(1, 3); Assert.assertEquals(0.5, first.doubleValue(), 0.0); Assert.assertEquals(1.0 / 3.0, second.doubleValue(), 0.0); } @Test public void testFloatValue() { Fraction first = new Fraction(1, 2); Fraction second = new Fraction(1, 3); Assert.assertEquals(0.5f, first.floatValue(), 0.0f); Assert.assertEquals((float)(1.0 / 3.0), second.floatValue(), 0.0f); } @Test public void testIntValue() { Fraction first = new Fraction(1, 2); Fraction second = new Fraction(3, 2); Assert.assertEquals(0, first.intValue()); Assert.assertEquals(1, second.intValue()); } @Test public void testLongValue() { Fraction first = new Fraction(1, 2); Fraction second = new Fraction(3, 2); Assert.assertEquals(0L, first.longValue()); Assert.assertEquals(1L, second.longValue()); } @Test public void testConstructorDouble() { assertFraction(1, 2, new Fraction(0.5)); assertFraction(1, 3, new Fraction(1.0 / 3.0)); assertFraction(17, 100, new Fraction(17.0 / 100.0)); assertFraction(317, 100, new Fraction(317.0 / 100.0)); assertFraction(-1, 2, new Fraction(-0.5)); assertFraction(-1, 3, new Fraction(-1.0 / 3.0)); assertFraction(-17, 100, new Fraction(17.0 / -100.0)); assertFraction(-317, 100, new Fraction(-317.0 / 100.0)); } @Test public void testAbs() { Fraction a = new Fraction(10, 21); Fraction b = new Fraction(-10, 21); Fraction c = new Fraction(10, -21); assertFraction(10, 21, a.abs()); assertFraction(10, 21, b.abs()); assertFraction(10, 21, c.abs()); } @Test public void testPercentage() { Assert.assertEquals(50.0, new Fraction(1, 2).percentageValue(), 1.0e-15); } @Test public void testMath835() { final int numer = Integer.MAX_VALUE / 99; final int denom = 1; final double percentage = 100 * ((double) numer) / denom; final Fraction frac = new Fraction(numer, denom); // With the implementation that preceded the fix suggested in MATH-835, // this test was failing, due to overflow. Assert.assertEquals(percentage, frac.percentageValue(), Math.ulp(percentage)); } @Test public void testReciprocal() { Fraction f = null; f = new Fraction(50, 75); f = f.reciprocal(); Assert.assertEquals(3, f.getNumerator()); Assert.assertEquals(2, f.getDenominator()); f = new Fraction(4, 3); f = f.reciprocal(); Assert.assertEquals(3, f.getNumerator()); Assert.assertEquals(4, f.getDenominator()); f = new Fraction(-15, 47); f = f.reciprocal(); Assert.assertEquals(-47, f.getNumerator()); Assert.assertEquals(15, f.getDenominator()); f = new Fraction(0, 3); try { f = f.reciprocal(); Assert.fail("expecting MathArithmeticException"); } catch (MathArithmeticException ex) {} // large values f = new Fraction(Integer.MAX_VALUE, 1); f = f.reciprocal(); Assert.assertEquals(1, f.getNumerator()); Assert.assertEquals(Integer.MAX_VALUE, f.getDenominator()); } @Test public void testNegate() { Fraction f = null; f = new Fraction(50, 75); f = f.negate(); Assert.assertEquals(-2, f.getNumerator()); Assert.assertEquals(3, f.getDenominator()); f = new Fraction(-50, 75); f = f.negate(); Assert.assertEquals(2, f.getNumerator()); Assert.assertEquals(3, f.getDenominator()); // large values f = new Fraction(Integer.MAX_VALUE-1, Integer.MAX_VALUE); f = f.negate(); Assert.assertEquals(Integer.MIN_VALUE+2, f.getNumerator()); Assert.assertEquals(Integer.MAX_VALUE, f.getDenominator()); f = new Fraction(Integer.MIN_VALUE, 1); try { f = f.negate(); Assert.fail("expecting MathArithmeticException"); } catch (MathArithmeticException ex) {} } @Test public void testAdd() { Fraction a = new Fraction(1, 2); Fraction b = new Fraction(2, 3); assertFraction(1, 1, a.add(a)); assertFraction(7, 6, a.add(b)); assertFraction(7, 6, b.add(a)); assertFraction(4, 3, b.add(b)); Fraction f1 = new Fraction(Integer.MAX_VALUE - 1, 1); Fraction f2 = Fraction.ONE; Fraction f = f1.add(f2); Assert.assertEquals(Integer.MAX_VALUE, f.getNumerator()); Assert.assertEquals(1, f.getDenominator()); f = f1.add(1); Assert.assertEquals(Integer.MAX_VALUE, f.getNumerator()); Assert.assertEquals(1, f.getDenominator()); f1 = new Fraction(-1, 13*13*2*2); f2 = new Fraction(-2, 13*17*2); f = f1.add(f2); Assert.assertEquals(13*13*17*2*2, f.getDenominator()); Assert.assertEquals(-17 - 2*13*2, f.getNumerator()); try { f.add(null); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) {} // if this fraction is added naively, it will overflow. // check that it doesn't. f1 = new Fraction(1,32768*3); f2 = new Fraction(1,59049); f = f1.add(f2); Assert.assertEquals(52451, f.getNumerator()); Assert.assertEquals(1934917632, f.getDenominator()); f1 = new Fraction(Integer.MIN_VALUE, 3); f2 = new Fraction(1,3); f = f1.add(f2); Assert.assertEquals(Integer.MIN_VALUE+1, f.getNumerator()); Assert.assertEquals(3, f.getDenominator()); f1 = new Fraction(Integer.MAX_VALUE - 1, 1); f2 = Fraction.ONE; f = f1.add(f2); Assert.assertEquals(Integer.MAX_VALUE, f.getNumerator()); Assert.assertEquals(1, f.getDenominator()); try { f = f.add(Fraction.ONE); // should overflow Assert.fail("expecting MathArithmeticException but got: " + f.toString()); } catch (MathArithmeticException ex) {} // denominator should not be a multiple of 2 or 3 to trigger overflow f1 = new Fraction(Integer.MIN_VALUE, 5); f2 = new Fraction(-1,5); try { f = f1.add(f2); // should overflow Assert.fail("expecting MathArithmeticException but got: " + f.toString()); } catch (MathArithmeticException ex) {} try { f= new Fraction(-Integer.MAX_VALUE, 1); f = f.add(f); Assert.fail("expecting MathArithmeticException"); } catch (MathArithmeticException ex) {} try { f= new Fraction(-Integer.MAX_VALUE, 1); f = f.add(f); Assert.fail("expecting MathArithmeticException"); } catch (MathArithmeticException ex) {} f1 = new Fraction(3,327680); f2 = new Fraction(2,59049); try { f = f1.add(f2); // should overflow Assert.fail("expecting MathArithmeticException but got: " + f.toString()); } catch (MathArithmeticException ex) {} } @Test public void testDivide() { Fraction a = new Fraction(1, 2); Fraction b = new Fraction(2, 3); assertFraction(1, 1, a.divide(a)); assertFraction(3, 4, a.divide(b)); assertFraction(4, 3, b.divide(a)); assertFraction(1, 1, b.divide(b)); Fraction f1 = new Fraction(3, 5); Fraction f2 = Fraction.ZERO; try { f1.divide(f2); Assert.fail("expecting MathArithmeticException"); } catch (MathArithmeticException ex) {} f1 = new Fraction(0, 5); f2 = new Fraction(2, 7); Fraction f = f1.divide(f2); Assert.assertSame(Fraction.ZERO, f); f1 = new Fraction(2, 7); f2 = Fraction.ONE; f = f1.divide(f2); Assert.assertEquals(2, f.getNumerator()); Assert.assertEquals(7, f.getDenominator()); f1 = new Fraction(1, Integer.MAX_VALUE); f = f1.divide(f1); Assert.assertEquals(1, f.getNumerator()); Assert.assertEquals(1, f.getDenominator()); f1 = new Fraction(Integer.MIN_VALUE, Integer.MAX_VALUE); f2 = new Fraction(1, Integer.MAX_VALUE); f = f1.divide(f2); Assert.assertEquals(Integer.MIN_VALUE, f.getNumerator()); Assert.assertEquals(1, f.getDenominator()); try { f.divide(null); Assert.fail("MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) {} try { f1 = new Fraction(1, Integer.MAX_VALUE); f = f1.divide(f1.reciprocal()); // should overflow Assert.fail("expecting MathArithmeticException"); } catch (MathArithmeticException ex) {} try { f1 = new Fraction(1, -Integer.MAX_VALUE); f = f1.divide(f1.reciprocal()); // should overflow Assert.fail("expecting MathArithmeticException"); } catch (MathArithmeticException ex) {} f1 = new Fraction(6, 35); f = f1.divide(15); Assert.assertEquals(2, f.getNumerator()); Assert.assertEquals(175, f.getDenominator()); } @Test public void testMultiply() { Fraction a = new Fraction(1, 2); Fraction b = new Fraction(2, 3); assertFraction(1, 4, a.multiply(a)); assertFraction(1, 3, a.multiply(b)); assertFraction(1, 3, b.multiply(a)); assertFraction(4, 9, b.multiply(b)); Fraction f1 = new Fraction(Integer.MAX_VALUE, 1); Fraction f2 = new Fraction(Integer.MIN_VALUE, Integer.MAX_VALUE); Fraction f = f1.multiply(f2); Assert.assertEquals(Integer.MIN_VALUE, f.getNumerator()); Assert.assertEquals(1, f.getDenominator()); try { f.multiply(null); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) {} f1 = new Fraction(6, 35); f = f1.multiply(15); Assert.assertEquals(18, f.getNumerator()); Assert.assertEquals(7, f.getDenominator()); } @Test public void testSubtract() { Fraction a = new Fraction(1, 2); Fraction b = new Fraction(2, 3); assertFraction(0, 1, a.subtract(a)); assertFraction(-1, 6, a.subtract(b)); assertFraction(1, 6, b.subtract(a)); assertFraction(0, 1, b.subtract(b)); Fraction f = new Fraction(1,1); try { f.subtract(null); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) {} // if this fraction is subtracted naively, it will overflow. // check that it doesn't. Fraction f1 = new Fraction(1,32768*3); Fraction f2 = new Fraction(1,59049); f = f1.subtract(f2); Assert.assertEquals(-13085, f.getNumerator()); Assert.assertEquals(1934917632, f.getDenominator()); f1 = new Fraction(Integer.MIN_VALUE, 3); f2 = new Fraction(1,3).negate(); f = f1.subtract(f2); Assert.assertEquals(Integer.MIN_VALUE+1, f.getNumerator()); Assert.assertEquals(3, f.getDenominator()); f1 = new Fraction(Integer.MAX_VALUE, 1); f2 = Fraction.ONE; f = f1.subtract(f2); Assert.assertEquals(Integer.MAX_VALUE-1, f.getNumerator()); Assert.assertEquals(1, f.getDenominator()); f = f1.subtract(1); Assert.assertEquals(Integer.MAX_VALUE-1, f.getNumerator()); Assert.assertEquals(1, f.getDenominator()); try { f1 = new Fraction(1, Integer.MAX_VALUE); f2 = new Fraction(1, Integer.MAX_VALUE - 1); f = f1.subtract(f2); Assert.fail("expecting MathArithmeticException"); //should overflow } catch (MathArithmeticException ex) {} // denominator should not be a multiple of 2 or 3 to trigger overflow f1 = new Fraction(Integer.MIN_VALUE, 5); f2 = new Fraction(1,5); try { f = f1.subtract(f2); // should overflow Assert.fail("expecting MathArithmeticException but got: " + f.toString()); } catch (MathArithmeticException ex) {} try { f= new Fraction(Integer.MIN_VALUE, 1); f = f.subtract(Fraction.ONE); Assert.fail("expecting MathArithmeticException"); } catch (MathArithmeticException ex) {} try { f= new Fraction(Integer.MAX_VALUE, 1); f = f.subtract(Fraction.ONE.negate()); Assert.fail("expecting MathArithmeticException"); } catch (MathArithmeticException ex) {} f1 = new Fraction(3,327680); f2 = new Fraction(2,59049); try { f = f1.subtract(f2); // should overflow Assert.fail("expecting MathArithmeticException but got: " + f.toString()); } catch (MathArithmeticException ex) {} } @Test public void testEqualsAndHashCode() { Fraction zero = new Fraction(0,1); Fraction nullFraction = null; Assert.assertTrue( zero.equals(zero)); Assert.assertFalse(zero.equals(nullFraction)); Assert.assertFalse(zero.equals(Double.valueOf(0))); Fraction zero2 = new Fraction(0,2); Assert.assertTrue(zero.equals(zero2)); Assert.assertEquals(zero.hashCode(), zero2.hashCode()); Fraction one = new Fraction(1,1); Assert.assertFalse((one.equals(zero) ||zero.equals(one))); } @Test public void testGetReducedFraction() { Fraction threeFourths = new Fraction(3, 4); Assert.assertTrue(threeFourths.equals(Fraction.getReducedFraction(6, 8))); Assert.assertTrue(Fraction.ZERO.equals(Fraction.getReducedFraction(0, -1))); try { Fraction.getReducedFraction(1, 0); Assert.fail("expecting MathArithmeticException"); } catch (MathArithmeticException ex) { // expected } Assert.assertEquals(Fraction.getReducedFraction (2, Integer.MIN_VALUE).getNumerator(),-1); Assert.assertEquals(Fraction.getReducedFraction (1, -1).getNumerator(), -1); } @Test public void testToString() { Assert.assertEquals("0", new Fraction(0, 3).toString()); Assert.assertEquals("3", new Fraction(6, 2).toString()); Assert.assertEquals("2 / 3", new Fraction(18, 27).toString()); } @Test public void testSerial() throws FractionConversionException { Fraction[] fractions = { new Fraction(3, 4), Fraction.ONE, Fraction.ZERO, new Fraction(17), new Fraction(FastMath.PI, 1000), new Fraction(-5, 2) }; for (Fraction fraction : fractions) { Assert.assertEquals(fraction, TestUtils.serializeAndRecover(fraction)); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.genetics; import org.junit.Assert; import org.junit.Test; public class BinaryChromosomeTest { @Test public void testInvalidConstructor() { Integer[][] reprs = new Integer[][] { new Integer[] {0,1,0,1,2}, new Integer[] {0,1,0,1,-1} }; for (Integer[] repr : reprs) { try { new DummyBinaryChromosome(repr); Assert.fail("Exception not caught"); } catch (IllegalArgumentException e) { // Expected } } } @Test public void testRandomConstructor() { for (int i=0; i<20; i++) { new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(10)); } } @Test public void testIsSame() { Chromosome c1 = new DummyBinaryChromosome(new Integer[] {0,1,0,1,0,1}); Chromosome c2 = new DummyBinaryChromosome(new Integer[] {0,1,1,0,1}); Chromosome c3 = new DummyBinaryChromosome(new Integer[] {0,1,0,1,0,1,1}); Chromosome c4 = new DummyBinaryChromosome(new Integer[] {1,1,0,1,0,1}); Chromosome c5 = new DummyBinaryChromosome(new Integer[] {0,1,0,1,0,0}); Chromosome c6 = new DummyBinaryChromosome(new Integer[] {0,1,0,1,0,1}); Assert.assertFalse(c1.isSame(c2)); Assert.assertFalse(c1.isSame(c3)); Assert.assertFalse(c1.isSame(c4)); Assert.assertFalse(c1.isSame(c5)); Assert.assertTrue(c1.isSame(c6)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.genetics; import org.junit.Assert; import org.junit.Test; public class BinaryMutationTest { @Test public void testMutate() { BinaryMutation mutation = new BinaryMutation(); // stochastic testing :) for (int i=0; i<20; i++) { DummyBinaryChromosome original = new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(10)); DummyBinaryChromosome mutated = (DummyBinaryChromosome) mutation.mutate(original); // one gene should be different int numDifferent = 0; for (int j=0; j<original.getRepresentation().size(); j++) { if (original.getRepresentation().get(j) != mutated.getRepresentation().get(j)) numDifferent++; } Assert.assertEquals(1, numDifferent); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.genetics; import java.util.ArrayList; import java.util.List; import org.junit.Assert; import org.junit.Test; public class ChromosomeTest { @Test public void testCompareTo() { Chromosome c1 = new Chromosome() { public double fitness() { return 0; } }; Chromosome c2 = new Chromosome() { public double fitness() { return 10; } }; Chromosome c3 = new Chromosome() { public double fitness() { return 10; } }; Assert.assertTrue(c1.compareTo(c2) < 0); Assert.assertTrue(c2.compareTo(c1) > 0); Assert.assertEquals(0,c3.compareTo(c2)); Assert.assertEquals(0,c2.compareTo(c3)); } private abstract static class DummyChromosome extends Chromosome { private final int repr; public DummyChromosome(final int repr) { this.repr = repr; } @Override protected boolean isSame(Chromosome another) { return ((DummyChromosome) another).repr == repr; } } @Test public void testFindSameChromosome() { Chromosome c1 = new DummyChromosome(1) { public double fitness() { return 1; } }; Chromosome c2 = new DummyChromosome(2) { public double fitness() { return 2; } }; Chromosome c3 = new DummyChromosome(3) { public double fitness() { return 3; } }; Chromosome c4 = new DummyChromosome(1) { public double fitness() { return 5; } }; Chromosome c5 = new DummyChromosome(15) { public double fitness() { return 15; } }; List<Chromosome> popChr = new ArrayList<Chromosome>(); popChr.add(c1); popChr.add(c2); popChr.add(c3); Population pop = new ListPopulation(popChr,3) { public Population nextGeneration() { // not important return null; } }; Assert.assertNull(c5.findSameChromosome(pop)); Assert.assertEquals(c1, c4.findSameChromosome(pop)); c4.searchForFitnessUpdate(pop); Assert.assertEquals(1, c4.getFitness(),0); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.genetics; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.junit.Assert; import org.junit.Test; public class CycleCrossoverTest { @Test public void testCrossoverExample() { // taken from http://www.rubicite.com/Tutorials/GeneticAlgorithms/CrossoverOperators/CycleCrossoverOperator.aspx final Integer[] p1 = new Integer[] { 8, 4, 7, 3, 6, 2, 5, 1, 9, 0 }; final Integer[] p2 = new Integer[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; final DummyListChromosome p1c = new DummyListChromosome(p1); final DummyListChromosome p2c = new DummyListChromosome(p2); final CrossoverPolicy cp = new CycleCrossover<Integer>(); final ChromosomePair pair = cp.crossover(p1c, p2c); final Integer[] c1 = ((DummyListChromosome) pair.getFirst()).getRepresentation().toArray(new Integer[p1.length]); final Integer[] c2 = ((DummyListChromosome) pair.getSecond()).getRepresentation().toArray(new Integer[p2.length]); final Integer[] c1e = new Integer[] { 8, 1, 2, 3, 4, 5, 6, 7, 9, 0 }; final Integer[] c2e = new Integer[] { 0, 4, 7, 3, 6, 2, 5, 1, 8, 9 }; Assert.assertArrayEquals(c1e, c1); Assert.assertArrayEquals(c2e, c2); } @Test public void testCrossoverExample2() { // taken from http://www.scribd.com/doc/54206412/32/Cycle-crossover final Integer[] p1 = new Integer[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; final Integer[] p2 = new Integer[] { 9, 3, 7, 8, 2, 6, 5, 1, 4}; final DummyListChromosome p1c = new DummyListChromosome(p1); final DummyListChromosome p2c = new DummyListChromosome(p2); final CrossoverPolicy cp = new CycleCrossover<Integer>(); final ChromosomePair pair = cp.crossover(p1c, p2c); final Integer[] c1 = ((DummyListChromosome) pair.getFirst()).getRepresentation().toArray(new Integer[p1.length]); final Integer[] c2 = ((DummyListChromosome) pair.getSecond()).getRepresentation().toArray(new Integer[p2.length]); final Integer[] c1e = new Integer[] { 1, 3, 7, 4, 2, 6, 5, 8, 9 }; final Integer[] c2e = new Integer[] { 9, 2, 3, 8, 5, 6, 7, 1, 4 }; Assert.assertArrayEquals(c1e, c1); Assert.assertArrayEquals(c2e, c2); } @Test public void testCrossover() { final Integer[] p1 = new Integer[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; final Integer[] p2 = new Integer[] { 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 }; final DummyListChromosome p1c = new DummyListChromosome(p1); final DummyListChromosome p2c = new DummyListChromosome(p2); final CrossoverPolicy cp = new CycleCrossover<Integer>(true); for (int i = 0; i < 20; i++) { final ChromosomePair pair = cp.crossover(p1c, p2c); final Integer[] c1 = ((DummyListChromosome) pair.getFirst()).getRepresentation().toArray(new Integer[p1.length]); final Integer[] c2 = ((DummyListChromosome) pair.getSecond()).getRepresentation().toArray(new Integer[p2.length]); int index = 0; // Determine if it is in the same spot as in the first parent, if // not it comes from the second parent. for (final Integer j : c1) { if (!p1[index].equals(j)) { Assert.assertEquals(j, p2[index]); } else { Assert.assertEquals(j, p1[index]); } index++; } // Same as above only for the second parent. index = 0; for (final Integer k : c2) { if (p2[index] != k) { Assert.assertEquals(k, p1[index]); } else { Assert.assertEquals(k, p2[index]); } index++; } } } @Test(expected = DimensionMismatchException.class) public void testCrossoverDimensionMismatchException() { final Integer[] p1 = new Integer[] { 1, 0, 1, 0, 0, 1, 0, 1, 1 }; final Integer[] p2 = new Integer[] { 0, 1, 1, 0, 1 }; final BinaryChromosome p1c = new DummyBinaryChromosome(p1); final BinaryChromosome p2c = new DummyBinaryChromosome(p2); final CrossoverPolicy cp = new CycleCrossover<Integer>(); cp.crossover(p1c, p2c); } @Test(expected = MathIllegalArgumentException.class) public void testCrossoverInvalidFixedLengthChromosomeFirst() { final Integer[] p1 = new Integer[] { 1, 0, 1, 0, 0, 1, 0, 1, 1 }; final BinaryChromosome p1c = new DummyBinaryChromosome(p1); final Chromosome p2c = new Chromosome() { public double fitness() { // Not important return 0; } }; final CrossoverPolicy cp = new CycleCrossover<Integer>(); cp.crossover(p1c, p2c); } @Test(expected = MathIllegalArgumentException.class) public void testCrossoverInvalidFixedLengthChromosomeSecond() { final Integer[] p1 = new Integer[] { 1, 0, 1, 0, 0, 1, 0, 1, 1 }; final BinaryChromosome p2c = new DummyBinaryChromosome(p1); final Chromosome p1c = new Chromosome() { public double fitness() { // Not important return 0; } }; final CrossoverPolicy cp = new CycleCrossover<Integer>(); cp.crossover(p1c, p2c); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.genetics; import java.util.Collections; import java.util.List; import org.apache.commons.math3.exception.OutOfRangeException; import org.junit.Assert; import org.junit.Test; public class ElitisticListPopulationTest { private static int counter = 0; @Test public void testNextGeneration() { ElitisticListPopulation pop = new ElitisticListPopulation(100, 0.203); for (int i=0; i<pop.getPopulationLimit(); i++) { pop.addChromosome(new DummyChromosome()); } Population nextGeneration = pop.nextGeneration(); Assert.assertEquals(20, nextGeneration.getPopulationSize()); } @Test public void testSetElitismRate() { final double rate = 0.25; final ElitisticListPopulation pop = new ElitisticListPopulation(100, 0.203); pop.setElitismRate(rate); Assert.assertEquals(rate, pop.getElitismRate(), 1e-6); } @Test(expected = OutOfRangeException.class) public void testSetElitismRateTooLow() { final double rate = -0.25; final ElitisticListPopulation pop = new ElitisticListPopulation(100, 0.203); pop.setElitismRate(rate); } @Test(expected = OutOfRangeException.class) public void testSetElitismRateTooHigh() { final double rate = 1.25; final ElitisticListPopulation pop = new ElitisticListPopulation(100, 0.203); pop.setElitismRate(rate); } @Test(expected = OutOfRangeException.class) public void testConstructorTooLow() { final double rate = -0.25; new ElitisticListPopulation(100, rate); } @Test(expected = OutOfRangeException.class) public void testConstructorTooHigh() { final double rate = 1.25; new ElitisticListPopulation(100, rate); } @Test(expected = OutOfRangeException.class) public void testChromosomeListConstructorTooLow() { final List<Chromosome> chromosomes = Collections.emptyList(); final double rate = -0.25; new ElitisticListPopulation(chromosomes, 100, rate); } @Test(expected = OutOfRangeException.class) public void testChromosomeListConstructorTooHigh() { final List<Chromosome> chromosomes = Collections.emptyList(); final double rate = 1.25; new ElitisticListPopulation(chromosomes, 100, rate); } private static class DummyChromosome extends Chromosome { private final int fitness; public DummyChromosome() { this.fitness = counter; counter++; } public double fitness() { return this.fitness; } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.genetics; import java.util.LinkedList; import java.util.List; import org.junit.Assert; import org.junit.Test; public class FitnessCachingTest { // parameters for the GA private static final int DIMENSION = 50; private static final double CROSSOVER_RATE = 1; private static final double MUTATION_RATE = 0.1; private static final int TOURNAMENT_ARITY = 5; private static final int POPULATION_SIZE = 10; private static final int NUM_GENERATIONS = 50; private static final double ELITISM_RATE = 0.2; // how many times was the fitness computed private static int fitnessCalls = 0; @Test public void testFitnessCaching() { // initialize a new genetic algorithm GeneticAlgorithm ga = new GeneticAlgorithm( new OnePointCrossover<Integer>(), CROSSOVER_RATE, // all selected chromosomes will be recombined (=crosssover) new BinaryMutation(), MUTATION_RATE, // no mutation new TournamentSelection(TOURNAMENT_ARITY) ); // initial population Population initial = randomPopulation(); // stopping conditions StoppingCondition stopCond = new FixedGenerationCount(NUM_GENERATIONS); // run the algorithm ga.evolve(initial, stopCond); int neededCalls = POPULATION_SIZE /*initial population*/ + (NUM_GENERATIONS - 1) /*for each population*/ * (int)(POPULATION_SIZE * (1.0 - ELITISM_RATE)) /*some chromosomes are copied*/ ; Assert.assertTrue(fitnessCalls <= neededCalls); // some chromosomes after crossover may be the same os old ones } /** * Initializes a random population. */ private static ElitisticListPopulation randomPopulation() { List<Chromosome> popList = new LinkedList<Chromosome>(); for (int i=0; i<POPULATION_SIZE; i++) { BinaryChromosome randChrom = new DummyCountingBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(DIMENSION)); popList.add(randChrom); } return new ElitisticListPopulation(popList, popList.size(), ELITISM_RATE); } private static class DummyCountingBinaryChromosome extends DummyBinaryChromosome { public DummyCountingBinaryChromosome(List<Integer> representation) { super(representation); } @Override public double fitness() { fitnessCalls++; return 0; } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.genetics; import java.util.Iterator; import java.util.concurrent.TimeUnit; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class FixedElapsedTimeTest { @Test public void testIsSatisfied() { final Population pop = new Population() { public void addChromosome(final Chromosome chromosome) { // unimportant } public Chromosome getFittestChromosome() { // unimportant return null; } public int getPopulationLimit() { // unimportant return 0; } public int getPopulationSize() { // unimportant return 0; } public Population nextGeneration() { // unimportant return null; } public Iterator<Chromosome> iterator() { // unimportant return null; } }; final long start = System.nanoTime(); final long duration = 3; final FixedElapsedTime tec = new FixedElapsedTime(duration, TimeUnit.SECONDS); while (!tec.isSatisfied(pop)) { try { Thread.sleep(50); } catch (InterruptedException e) { // ignore } } final long end = System.nanoTime(); final long elapsedTime = end - start; final long diff = FastMath.abs(elapsedTime - TimeUnit.SECONDS.toNanos(duration)); Assert.assertTrue(diff < TimeUnit.MILLISECONDS.toNanos(100)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.genetics; import java.util.Iterator; import org.junit.Assert; import org.junit.Test; public class FixedGenerationCountTest { @Test public void testIsSatisfied() { FixedGenerationCount fgc = new FixedGenerationCount(20); int cnt = 0; Population pop = new Population() { public void addChromosome(Chromosome chromosome) { // unimportant } public Chromosome getFittestChromosome() { // unimportant return null; } public int getPopulationLimit() { // unimportant return 0; } public int getPopulationSize() { // unimportant return 0; } public Population nextGeneration() { // unimportant return null; } public Iterator<Chromosome> iterator() { // unimportant return null; } }; while (!fgc.isSatisfied(pop)) { cnt++; } Assert.assertEquals(20, cnt); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.genetics; import java.util.LinkedList; import java.util.List; import org.junit.Assert; import org.junit.Test; /** * This is also an example of usage. */ public class GeneticAlgorithmTestBinary { // parameters for the GA private static final int DIMENSION = 50; private static final int POPULATION_SIZE = 50; private static final int NUM_GENERATIONS = 50; private static final double ELITISM_RATE = 0.2; private static final double CROSSOVER_RATE = 1; private static final double MUTATION_RATE = 0.1; private static final int TOURNAMENT_ARITY = 2; @Test public void test() { // to test a stochastic algorithm is hard, so this will rather be an usage example // initialize a new genetic algorithm GeneticAlgorithm ga = new GeneticAlgorithm( new OnePointCrossover<Integer>(), CROSSOVER_RATE, // all selected chromosomes will be recombined (=crosssover) new BinaryMutation(), MUTATION_RATE, new TournamentSelection(TOURNAMENT_ARITY) ); Assert.assertEquals(0, ga.getGenerationsEvolved()); // initial population Population initial = randomPopulation(); // stopping conditions StoppingCondition stopCond = new FixedGenerationCount(NUM_GENERATIONS); // best initial chromosome Chromosome bestInitial = initial.getFittestChromosome(); // run the algorithm Population finalPopulation = ga.evolve(initial, stopCond); // best chromosome from the final population Chromosome bestFinal = finalPopulation.getFittestChromosome(); // the only thing we can test is whether the final solution is not worse than the initial one // however, for some implementations of GA, this need not be true :) Assert.assertTrue(bestFinal.compareTo(bestInitial) > 0); Assert.assertEquals(NUM_GENERATIONS, ga.getGenerationsEvolved()); } /** * Initializes a random population. */ private static ElitisticListPopulation randomPopulation() { List<Chromosome> popList = new LinkedList<Chromosome>(); for (int i=0; i<POPULATION_SIZE; i++) { BinaryChromosome randChrom = new FindOnes(BinaryChromosome.randomBinaryRepresentation(DIMENSION)); popList.add(randChrom); } return new ElitisticListPopulation(popList, popList.size(), ELITISM_RATE); } /** * Chromosomes represented by a binary chromosome. * * The goal is to set all bits (genes) to 1. */ private static class FindOnes extends BinaryChromosome { public FindOnes(List<Integer> representation) { super(representation); } /** * Returns number of elements != 0 */ public double fitness() { int num = 0; for (int val : this.getRepresentation()) { if (val != 0) num++; } // number of elements >= 0 return num; } @Override public AbstractListChromosome<Integer> newFixedLengthChromosome(List<Integer> chromosomeRepresentation) { return new FindOnes(chromosomeRepresentation); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.genetics; import java.util.ArrayList; import java.util.List; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * This is also an example of usage. * * This algorithm does "stochastic sorting" of a sequence 0,...,N. * */ public class GeneticAlgorithmTestPermutations { // parameters for the GA private static final int DIMENSION = 20; private static final int POPULATION_SIZE = 80; private static final int NUM_GENERATIONS = 200; private static final double ELITISM_RATE = 0.2; private static final double CROSSOVER_RATE = 1; private static final double MUTATION_RATE = 0.08; private static final int TOURNAMENT_ARITY = 2; // numbers from 0 to N-1 private static final List<Integer> sequence = new ArrayList<Integer>(); static { for (int i=0; i<DIMENSION; i++) { sequence.add(i); } } @Test public void test() { // to test a stochastic algorithm is hard, so this will rather be an usage example // initialize a new genetic algorithm GeneticAlgorithm ga = new GeneticAlgorithm( new OnePointCrossover<Integer>(), CROSSOVER_RATE, new RandomKeyMutation(), MUTATION_RATE, new TournamentSelection(TOURNAMENT_ARITY) ); // initial population Population initial = randomPopulation(); // stopping conditions StoppingCondition stopCond = new FixedGenerationCount(NUM_GENERATIONS); // best initial chromosome Chromosome bestInitial = initial.getFittestChromosome(); // run the algorithm Population finalPopulation = ga.evolve(initial, stopCond); // best chromosome from the final population Chromosome bestFinal = finalPopulation.getFittestChromosome(); // the only thing we can test is whether the final solution is not worse than the initial one // however, for some implementations of GA, this need not be true :) Assert.assertTrue(bestFinal.compareTo(bestInitial) > 0); //System.out.println(bestInitial); //System.out.println(bestFinal); } /** * Initializes a random population */ private static ElitisticListPopulation randomPopulation() { List<Chromosome> popList = new ArrayList<Chromosome>(); for (int i=0; i<POPULATION_SIZE; i++) { Chromosome randChrom = new MinPermutations(RandomKey.randomPermutation(DIMENSION)); popList.add(randChrom); } return new ElitisticListPopulation(popList, popList.size(), ELITISM_RATE); } /** * Chromosomes representing a permutation of (0,1,2,...,DIMENSION-1). * * The goal is to sort the sequence. */ private static class MinPermutations extends RandomKey<Integer> { public MinPermutations(List<Double> representation) { super(representation); } public double fitness() { int res = 0; List<Integer> decoded = decode(sequence); for (int i=0; i<decoded.size(); i++) { int value = decoded.get(i); if (value != i) { // bad position found res += FastMath.abs(value - i); } } // the most fitted chromosome is the one with minimal error // therefore we must return negative value return -res; } @Override public AbstractListChromosome<Double> newFixedLengthChromosome(List<Double> chromosomeRepresentation) { return new MinPermutations(chromosomeRepresentation); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.genetics; import java.util.ArrayList; import java.util.Iterator; import org.apache.commons.math3.exception.NotPositiveException; import org.apache.commons.math3.exception.NumberIsTooLargeException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.junit.Assert; import org.junit.Test; public class ListPopulationTest { @Test public void testGetFittestChromosome() { Chromosome c1 = new Chromosome() { public double fitness() { return 0; } }; Chromosome c2 = new Chromosome() { public double fitness() { return 10; } }; Chromosome c3 = new Chromosome() { public double fitness() { return 15; } }; ArrayList<Chromosome> chromosomes = new ArrayList<Chromosome> (); chromosomes.add(c1); chromosomes.add(c2); chromosomes.add(c3); ListPopulation population = new ListPopulation(chromosomes, 10) { public Population nextGeneration() { // not important return null; } }; Assert.assertEquals(c3, population.getFittestChromosome()); } @Test public void testChromosomes() { final ArrayList<Chromosome> chromosomes = new ArrayList<Chromosome> (); chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3))); chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3))); chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3))); final ListPopulation population = new ListPopulation(10) { public Population nextGeneration() { // not important return null; } }; population.addChromosomes(chromosomes); Assert.assertEquals(chromosomes, population.getChromosomes()); Assert.assertEquals(chromosomes.toString(), population.toString()); population.setPopulationLimit(50); Assert.assertEquals(50, population.getPopulationLimit()); } @Test(expected = NotPositiveException.class) public void testSetPopulationLimit() { final ListPopulation population = new ListPopulation(10) { public Population nextGeneration() { // not important return null; } }; population.setPopulationLimit(-50); } @Test(expected = NotPositiveException.class) public void testConstructorPopulationLimitNotPositive() { new ListPopulation(-10) { public Population nextGeneration() { // not important return null; } }; } @Test(expected = NotPositiveException.class) public void testChromosomeListConstructorPopulationLimitNotPositive() { final ArrayList<Chromosome> chromosomes = new ArrayList<Chromosome> (); chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3))); new ListPopulation(chromosomes, -10) { public Population nextGeneration() { // not important return null; } }; } @Test(expected = NumberIsTooLargeException.class) public void testConstructorListOfChromosomesBiggerThanPopulationSize() { final ArrayList<Chromosome> chromosomes = new ArrayList<Chromosome> (); chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3))); chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3))); chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3))); new ListPopulation(chromosomes, 1) { public Population nextGeneration() { // not important return null; } }; } @Test(expected=NumberIsTooLargeException.class) public void testAddTooManyChromosomes() { final ArrayList<Chromosome> chromosomes = new ArrayList<Chromosome> (); chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3))); chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3))); chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3))); final ListPopulation population = new ListPopulation(2) { public Population nextGeneration() { // not important return null; } }; population.addChromosomes(chromosomes); } @Test(expected=NumberIsTooLargeException.class) public void testAddTooManyChromosomesSingleCall() { final ListPopulation population = new ListPopulation(2) { public Population nextGeneration() { // not important return null; } }; for (int i = 0; i <= population.getPopulationLimit(); i++) { population.addChromosome(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3))); } } @Test(expected = UnsupportedOperationException.class) public void testIterator() { final ArrayList<Chromosome> chromosomes = new ArrayList<Chromosome>(); chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3))); chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3))); chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3))); final ListPopulation population = new ListPopulation(10) { public Population nextGeneration() { // not important return null; } }; population.addChromosomes(chromosomes); final Iterator<Chromosome> iter = population.iterator(); while (iter.hasNext()) { iter.next(); iter.remove(); } } @Test(expected=NumberIsTooSmallException.class) public void testSetPopulationLimitTooSmall() { final ArrayList<Chromosome> chromosomes = new ArrayList<Chromosome> (); chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3))); chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3))); chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3))); final ListPopulation population = new ListPopulation(chromosomes, 3) { public Population nextGeneration() { // not important return null; } }; population.setPopulationLimit(2); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.genetics; import java.util.List; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.exception.NumberIsTooLargeException; import org.junit.Assert; import org.junit.Test; public class NPointCrossoverTest { @Test(expected = DimensionMismatchException.class) public void testCrossoverDimensionMismatchException() { final Integer[] p1 = new Integer[] {1,0,1,0,0,1,0,1,1}; final Integer[] p2 = new Integer[] {0,1,1,0,1}; final BinaryChromosome p1c = new DummyBinaryChromosome(p1); final BinaryChromosome p2c = new DummyBinaryChromosome(p2); final CrossoverPolicy cp = new NPointCrossover<Integer>(1); cp.crossover(p1c,p2c); } @Test(expected = NumberIsTooLargeException.class) public void testNumberIsTooLargeException() { final Integer[] p1 = new Integer[] {1,0,1,0,0,1,0,1,1}; final Integer[] p2 = new Integer[] {0,1,1,0,1,0,1,1,1}; final BinaryChromosome p1c = new DummyBinaryChromosome(p1); final BinaryChromosome p2c = new DummyBinaryChromosome(p2); final CrossoverPolicy cp = new NPointCrossover<Integer>(15); cp.crossover(p1c,p2c); } @Test(expected = MathIllegalArgumentException.class) public void testCrossoverInvalidFixedLengthChromosomeFirst() { final Integer[] p1 = new Integer[] {1,0,1,0,0,1,0,1,1}; final BinaryChromosome p1c = new DummyBinaryChromosome(p1); final Chromosome p2c = new Chromosome() { public double fitness() { // Not important return 0; } }; final CrossoverPolicy cp = new NPointCrossover<Integer>(1); cp.crossover(p1c,p2c); } @Test(expected = MathIllegalArgumentException.class) public void testCrossoverInvalidFixedLengthChromosomeSecond() { final Integer[] p1 = new Integer[] {1,0,1,0,0,1,0,1,1}; final BinaryChromosome p2c = new DummyBinaryChromosome(p1); final Chromosome p1c = new Chromosome() { public double fitness() { // Not important return 0; } }; final CrossoverPolicy cp = new NPointCrossover<Integer>(1); cp.crossover(p1c,p2c); } @Test public void testCrossover() { Integer[] p1 = new Integer[] {1,0,1,0,1,0,1,0,1}; Integer[] p2 = new Integer[] {0,1,0,1,0,1,0,1,0}; BinaryChromosome p1c = new DummyBinaryChromosome(p1); BinaryChromosome p2c = new DummyBinaryChromosome(p2); final int order = 3; NPointCrossover<Integer> npc = new NPointCrossover<Integer>(order); // the two parent chromosomes are different at each position, so it is easy to detect // the number of crossovers that happened for each child for (int i=0; i<20; i++) { ChromosomePair pair = npc.crossover(p1c,p2c); Integer[] c1 = new Integer[p1.length]; Integer[] c2 = new Integer[p2.length]; c1 = ((BinaryChromosome) pair.getFirst()).getRepresentation().toArray(c1); c2 = ((BinaryChromosome) pair.getSecond()).getRepresentation().toArray(c2); Assert.assertEquals(order, detectCrossoverPoints(p1c, p2c, (BinaryChromosome) pair.getFirst())); Assert.assertEquals(order, detectCrossoverPoints(p2c, p1c, (BinaryChromosome) pair.getSecond())); } } private int detectCrossoverPoints(BinaryChromosome p1, BinaryChromosome p2, BinaryChromosome c) { int crossovers = 0; final int length = p1.getLength(); final List<Integer> p1Rep = p1.getRepresentation(); final List<Integer> p2Rep = p2.getRepresentation(); final List<Integer> cRep = c.getRepresentation(); List<Integer> rep = p1Rep; for (int i = 0; i < length; i++) { if (rep.get(i) != cRep.get(i)) { crossovers++; rep = rep == p1Rep ? p2Rep : p1Rep; } } return crossovers; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.genetics; import org.junit.Assert; import org.junit.Test; public class OnePointCrossoverTest { @Test public void testCrossover() { @SuppressWarnings("boxing") Integer[] p1 = new Integer[] {1,0,1,0,0,1,0,1,1}; @SuppressWarnings("boxing") Integer[] p2 = new Integer[] {0,1,1,0,1,0,1,1,1}; BinaryChromosome p1c = new DummyBinaryChromosome(p1); BinaryChromosome p2c = new DummyBinaryChromosome(p2); OnePointCrossover<Integer> opc = new OnePointCrossover<Integer>(); // how to test a stochastic method? for (int i=0; i<20; i++) { ChromosomePair pair = opc.crossover(p1c,p2c); Integer[] c1 = new Integer[p1.length]; Integer[] c2 = new Integer[p2.length]; c1 = ((BinaryChromosome) pair.getFirst()).getRepresentation().toArray(c1); c2 = ((BinaryChromosome) pair.getSecond()).getRepresentation().toArray(c2); // first and last values will be the same Assert.assertEquals(p1[0], c1[0]); Assert.assertEquals(p2[0], c2[0]); Assert.assertEquals(p1[p1.length-1], c1[c1.length-1]); Assert.assertEquals(p2[p2.length-1], c2[c2.length-1]); // moreover, in the above setting, the 2nd, 3rd and 7th values will be the same Assert.assertEquals(p1[2], c1[2]); Assert.assertEquals(p2[2], c2[2]); Assert.assertEquals(p1[3], c1[3]); Assert.assertEquals(p2[3], c2[3]); Assert.assertEquals(p1[7], c1[7]); Assert.assertEquals(p2[7], c2[7]); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.genetics; import java.util.Arrays; import java.util.HashSet; import java.util.Set; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.junit.Assert; import org.junit.Test; public class OrderedCrossoverTest { @Test public void testCrossover() { final Integer[] p1 = new Integer[] { 8, 4, 7, 3, 6, 2, 5, 1, 9, 0 }; final Integer[] p2 = new Integer[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; final DummyListChromosome p1c = new DummyListChromosome(p1); final DummyListChromosome p2c = new DummyListChromosome(p2); final CrossoverPolicy cp = new OrderedCrossover<Integer>(); for (int i = 0; i < 20; i++) { final Set<Integer> parentSet1 = new HashSet<Integer>(Arrays.asList(p1)); final Set<Integer> parentSet2 = new HashSet<Integer>(Arrays.asList(p2)); final ChromosomePair pair = cp.crossover(p1c, p2c); final Integer[] c1 = ((DummyListChromosome) pair.getFirst()).getRepresentation().toArray(new Integer[p1.length]); final Integer[] c2 = ((DummyListChromosome) pair.getSecond()).getRepresentation().toArray(new Integer[p2.length]); Assert.assertNotSame(p1c, pair.getFirst()); Assert.assertNotSame(p2c, pair.getSecond()); // make sure that the children have exactly the same elements as their parents for (int j = 0; j < c1.length; j++) { Assert.assertTrue(parentSet1.contains(c1[j])); parentSet1.remove(c1[j]); Assert.assertTrue(parentSet2.contains(c2[j])); parentSet2.remove(c2[j]); } } } @Test(expected = DimensionMismatchException.class) public void testCrossoverDimensionMismatchException() { final Integer[] p1 = new Integer[] { 1, 0, 1, 0, 0, 1, 0, 1, 1 }; final Integer[] p2 = new Integer[] { 0, 1, 1, 0, 1 }; final BinaryChromosome p1c = new DummyBinaryChromosome(p1); final BinaryChromosome p2c = new DummyBinaryChromosome(p2); final CrossoverPolicy cp = new OrderedCrossover<Integer>(); cp.crossover(p1c, p2c); } @Test(expected = MathIllegalArgumentException.class) public void testCrossoverInvalidFixedLengthChromosomeFirst() { final Integer[] p1 = new Integer[] { 1, 0, 1, 0, 0, 1, 0, 1, 1 }; final BinaryChromosome p1c = new DummyBinaryChromosome(p1); final Chromosome p2c = new Chromosome() { public double fitness() { // Not important return 0; } }; final CrossoverPolicy cp = new OrderedCrossover<Integer>(); cp.crossover(p1c, p2c); } @Test(expected = MathIllegalArgumentException.class) public void testCrossoverInvalidFixedLengthChromosomeSecond() { final Integer[] p1 = new Integer[] { 1, 0, 1, 0, 0, 1, 0, 1, 1 }; final BinaryChromosome p2c = new DummyBinaryChromosome(p1); final Chromosome p1c = new Chromosome() { public double fitness() { // Not important return 0; } }; final CrossoverPolicy cp = new OrderedCrossover<Integer>(); cp.crossover(p1c, p2c); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.genetics; import org.junit.Assert; import org.junit.Test; public class RandomKeyMutationTest { @Test public void testMutate() { MutationPolicy mutation = new RandomKeyMutation(); int l=10; for (int i=0; i<20; i++) { DummyRandomKey origRk = new DummyRandomKey(RandomKey.randomPermutation(l)); Chromosome mutated = mutation.mutate(origRk); DummyRandomKey mutatedRk = (DummyRandomKey) mutated; int changes = 0; for (int j=0; j<origRk.getLength(); j++) { if (origRk.getRepresentation().get(j) != mutatedRk.getRepresentation().get(j)) { changes++; } } Assert.assertEquals(1,changes); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.genetics; import java.util.Arrays; import java.util.Comparator; import java.util.List; import org.junit.Assert; import org.junit.Test; @SuppressWarnings("boxing") public class RandomKeyTest { @Test(expected=IllegalArgumentException.class) public void testConstructor1() { new DummyRandomKey(new Double[] {0.2, 0.3, 1.2}); } @Test(expected=IllegalArgumentException.class) public void testConstructor2() { new DummyRandomKey(new Double[] {0.2, 0.3, -0.2}); } @Test public void testIsSame() { DummyRandomKey drk1 = new DummyRandomKey(new Double[] {0.4, 0.1, 0.5, 0.8, 0.2}); DummyRandomKey drk2 = new DummyRandomKey(new Double[] {0.4, 0.1, 0.5, 0.8, 0.2}); DummyRandomKey drk3 = new DummyRandomKey(new Double[] {0.4, 0.15, 0.5, 0.8, 0.2}); DummyRandomKey drk4 = new DummyRandomKey(new Double[] {0.4, 0.25, 0.5, 0.8, 0.2}); DummyRandomKey drk5 = new DummyRandomKey(new Double[] {0.4, 0.25, 0.5, 0.8, 0.2, 0.5}); Assert.assertTrue(drk1.isSame(drk2)); Assert.assertTrue(drk2.isSame(drk3)); Assert.assertFalse(drk3.isSame(drk4)); Assert.assertFalse(drk4.isSame(drk5)); } @Test public void testDecode() { DummyRandomKey drk = new DummyRandomKey(new Double[] {0.4, 0.1, 0.5, 0.8, 0.2}); List<String> decoded = drk.decode(Arrays.asList(new String[] {"a", "b", "c", "d", "e"})); Assert.assertEquals("b", decoded.get(0)); Assert.assertEquals("e", decoded.get(1)); Assert.assertEquals("a", decoded.get(2)); Assert.assertEquals("c", decoded.get(3)); Assert.assertEquals("d", decoded.get(4)); } @Test(expected=IllegalArgumentException.class) public void testInvalidRepresentation() { new DummyRandomKey(new Double[] {0.1, 0.1, 2d, 0.8, 0.2}); } @Test public void testRandomPermutation() { // never generate an invalid one for (int i=0; i<10; i++) { DummyRandomKey drk = new DummyRandomKey(RandomKey.randomPermutation(20)); Assert.assertNotNull(drk); } } @Test public void testIdentityPermutation() { DummyRandomKey drk = new DummyRandomKey(RandomKey.identityPermutation(5)); List<String> decoded = drk.decode(Arrays.asList(new String[] {"a", "b", "c", "d", "e"})); Assert.assertEquals("a", decoded.get(0)); Assert.assertEquals("b", decoded.get(1)); Assert.assertEquals("c", decoded.get(2)); Assert.assertEquals("d", decoded.get(3)); Assert.assertEquals("e", decoded.get(4)); } @Test public void testComparatorPermutation() { List<String> data = Arrays.asList(new String[] {"x", "b", "c", "z", "b"}); List<Double> permutation = RandomKey.comparatorPermutation(data, new Comparator<String>() { public int compare(String o1, String o2) { return o1.compareTo(o2); } }); Double[] permArr = new Double[data.size()]; permArr = permutation.toArray(permArr); Assert.assertArrayEquals(new Double[] {0.6,0.0,0.4,0.8,0.2}, permArr); List<String> decodedData = new DummyRandomKey(permutation).decode(data); Assert.assertEquals("b", decodedData.get(0)); Assert.assertEquals("b", decodedData.get(1)); Assert.assertEquals("c", decodedData.get(2)); Assert.assertEquals("x", decodedData.get(3)); Assert.assertEquals("z", decodedData.get(4)); permutation = RandomKey.comparatorPermutation(data, new Comparator<String>() { public int compare(String o1, String o2) { return o2.compareTo(o1); } }); permArr = new Double[data.size()]; permArr = permutation.toArray(permArr); Assert.assertArrayEquals(new Double[] {0.2,0.6,0.4,0.0,0.8}, permArr); decodedData = new DummyRandomKey(permutation).decode(data); Assert.assertEquals("z", decodedData.get(0)); Assert.assertEquals("x", decodedData.get(1)); Assert.assertEquals("c", decodedData.get(2)); Assert.assertEquals("b", decodedData.get(3)); Assert.assertEquals("b", decodedData.get(4)); } @Test public void testInducedPermutation() { List<String> origData = Arrays.asList(new String[] {"a", "b", "c", "d", "d"}); List<String> permutedData = Arrays.asList(new String[] {"d", "b", "c", "a", "d"}); DummyRandomKey drk = new DummyRandomKey(RandomKey.inducedPermutation(origData, permutedData)); List<String> decoded = drk.decode(origData); Assert.assertEquals("d", decoded.get(0)); Assert.assertEquals("b", decoded.get(1)); Assert.assertEquals("c", decoded.get(2)); Assert.assertEquals("a", decoded.get(3)); Assert.assertEquals("d", decoded.get(4)); try { RandomKey.inducedPermutation( Arrays.asList(new String[] {"a", "b", "c", "d", "d"}), Arrays.asList(new String[] {"a", "b", "c", "d"}) ); Assert.fail("Uncaught exception"); } catch (IllegalArgumentException e) { // no-op } try { RandomKey.inducedPermutation( Arrays.asList(new String[] {"a", "b", "c", "d", "d"}), Arrays.asList(new String[] {"a", "b", "c", "d", "f"}) ); Assert.fail("Uncaught exception"); } catch (IllegalArgumentException e) { // no-op } } @Test public void testEqualRepr() { DummyRandomKey drk = new DummyRandomKey(new Double[] {0.2, 0.2, 0.5}); List<String> decodedData = drk.decode(Arrays.asList(new String[] {"a", "b", "c"})); Assert.assertEquals("a", decodedData.get(0)); Assert.assertEquals("b", decodedData.get(1)); Assert.assertEquals("c", decodedData.get(2)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.genetics; import org.junit.Assert; import org.junit.Test; public class TournamentSelectionTest { private static int counter = 0; @Test public void testSelect() { TournamentSelection ts = new TournamentSelection(2); ElitisticListPopulation pop = new ElitisticListPopulation(100, 0.203); for (int i=0; i<pop.getPopulationLimit(); i++) { pop.addChromosome(new DummyChromosome()); } // how to write a test for stochastic method? for (int i=0; i<20; i++) { ChromosomePair pair = ts.select(pop); // the worst chromosome should NEVER be selected Assert.assertTrue(pair.getFirst().getFitness() > 0); Assert.assertTrue(pair.getSecond().getFitness() > 0); } } private static class DummyChromosome extends Chromosome { private final int fitness; public DummyChromosome() { this.fitness = counter; counter++; } public double fitness() { return this.fitness; } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.genetics; import java.util.ArrayList; import java.util.List; import org.junit.Assert; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.exception.OutOfRangeException; import org.junit.BeforeClass; import org.junit.Test; public class UniformCrossoverTest { private static final int LEN = 10000; private static final List<Integer> p1 = new ArrayList<Integer>(LEN); private static final List<Integer> p2 = new ArrayList<Integer>(LEN); @SuppressWarnings("boxing") @BeforeClass public static void setUpBeforeClass() { for (int i = 0; i < LEN; i++) { p1.add(0); p2.add(1); } } @Test(expected = OutOfRangeException.class) public void testRatioTooLow() { new UniformCrossover<Integer>(-0.5d); } @Test(expected = OutOfRangeException.class) public void testRatioTooHigh() { new UniformCrossover<Integer>(1.5d); } @Test public void testCrossover() { // test crossover with different ratios performCrossover(0.5); performCrossover(0.7); performCrossover(0.2); } private void performCrossover(double ratio) { final DummyBinaryChromosome p1c = new DummyBinaryChromosome(p1); final DummyBinaryChromosome p2c = new DummyBinaryChromosome(p2); final CrossoverPolicy cp = new UniformCrossover<Integer>(ratio); // make a number of rounds for (int i = 0; i < 20; i++) { final ChromosomePair pair = cp.crossover(p1c, p2c); final List<Integer> c1 = ((DummyBinaryChromosome) pair.getFirst()).getRepresentation(); final List<Integer> c2 = ((DummyBinaryChromosome) pair.getSecond()).getRepresentation(); int from1 = 0; int from2 = 0; // check first child for (int val : c1) { if (val == 0) { from1++; } else { from2++; } } Assert.assertEquals(1.0 - ratio, (double) from1 / LEN, 0.1); Assert.assertEquals(ratio, (double) from2 / LEN, 0.1); from1 = 0; from2 = 0; // check second child for (int val : c2) { if (val == 0) { from1++; } else { from2++; } } Assert.assertEquals(ratio, (double) from1 / LEN, 0.1); Assert.assertEquals(1.0 - ratio, (double) from2 / LEN, 0.1); } } @Test(expected = DimensionMismatchException.class) public void testCrossoverDimensionMismatchException(){ @SuppressWarnings("boxing") final Integer[] p1 = new Integer[] {1,0,1,0,0,1,0,1,1}; @SuppressWarnings("boxing") final Integer[] p2 = new Integer[] {0,1,1,0,1}; final BinaryChromosome p1c = new DummyBinaryChromosome(p1); final BinaryChromosome p2c = new DummyBinaryChromosome(p2); final CrossoverPolicy cp = new UniformCrossover<Integer>(0.5d); cp.crossover(p1c, p2c); } @Test(expected = MathIllegalArgumentException.class) public void testCrossoverInvalidFixedLengthChromosomeFirst() { @SuppressWarnings("boxing") final Integer[] p1 = new Integer[] {1,0,1,0,0,1,0,1,1}; final BinaryChromosome p1c = new DummyBinaryChromosome(p1); final Chromosome p2c = new Chromosome() { public double fitness() { // Not important return 0; } }; final CrossoverPolicy cp = new UniformCrossover<Integer>(0.5d); cp.crossover(p1c, p2c); } @Test(expected = MathIllegalArgumentException.class) public void testCrossoverInvalidFixedLengthChromosomeSecond() { @SuppressWarnings("boxing") final Integer[] p1 = new Integer[] {1,0,1,0,0,1,0,1,1}; final BinaryChromosome p2c = new DummyBinaryChromosome(p1); final Chromosome p1c = new Chromosome() { public double fitness() { // Not important return 0; } }; final CrossoverPolicy cp = new UniformCrossover<Integer>(0.5d); cp.crossover(p1c, p2c); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.geometry.euclidean.oned; import org.apache.commons.math3.geometry.partitioning.Region; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.util.Precision; import org.junit.Assert; import org.junit.Test; public class IntervalTest { @Test public void testInterval() { Interval interval = new Interval(2.3, 5.7); Assert.assertEquals(3.4, interval.getSize(), 1.0e-10); Assert.assertEquals(4.0, interval.getBarycenter(), 1.0e-10); Assert.assertEquals(Region.Location.BOUNDARY, interval.checkPoint(2.3, 1.0e-10)); Assert.assertEquals(Region.Location.BOUNDARY, interval.checkPoint(5.7, 1.0e-10)); Assert.assertEquals(Region.Location.OUTSIDE, interval.checkPoint(1.2, 1.0e-10)); Assert.assertEquals(Region.Location.OUTSIDE, interval.checkPoint(8.7, 1.0e-10)); Assert.assertEquals(Region.Location.INSIDE, interval.checkPoint(3.0, 1.0e-10)); Assert.assertEquals(2.3, interval.getInf(), 1.0e-10); Assert.assertEquals(5.7, interval.getSup(), 1.0e-10); } @Test public void testTolerance() { Interval interval = new Interval(2.3, 5.7); Assert.assertEquals(Region.Location.OUTSIDE, interval.checkPoint(1.2, 1.0)); Assert.assertEquals(Region.Location.BOUNDARY, interval.checkPoint(1.2, 1.2)); Assert.assertEquals(Region.Location.OUTSIDE, interval.checkPoint(8.7, 2.9)); Assert.assertEquals(Region.Location.BOUNDARY, interval.checkPoint(8.7, 3.1)); Assert.assertEquals(Region.Location.INSIDE, interval.checkPoint(3.0, 0.6)); Assert.assertEquals(Region.Location.BOUNDARY, interval.checkPoint(3.0, 0.8)); } @Test public void testInfinite() { Interval interval = new Interval(9.0, Double.POSITIVE_INFINITY); Assert.assertEquals(Region.Location.BOUNDARY, interval.checkPoint(9.0, 1.0e-10)); Assert.assertEquals(Region.Location.OUTSIDE, interval.checkPoint(8.4, 1.0e-10)); for (double e = 1.0; e <= 6.0; e += 1.0) { Assert.assertEquals(Region.Location.INSIDE, interval.checkPoint(FastMath.pow(10.0, e), 1.0e-10)); } Assert.assertTrue(Double.isInfinite(interval.getSize())); Assert.assertEquals(9.0, interval.getInf(), 1.0e-10); Assert.assertTrue(Double.isInfinite(interval.getSup())); } @Test public void testSinglePoint() { Interval interval = new Interval(1.0, 1.0); Assert.assertEquals(0.0, interval.getSize(), Precision.SAFE_MIN); Assert.assertEquals(1.0, interval.getBarycenter(), Precision.EPSILON); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.geometry.euclidean.oned; import java.util.List; import org.apache.commons.math3.geometry.euclidean.oned.Interval; import org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet; import org.apache.commons.math3.geometry.euclidean.oned.Vector1D; import org.apache.commons.math3.geometry.partitioning.Region; import org.apache.commons.math3.geometry.partitioning.RegionFactory; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.util.Precision; import org.junit.Assert; import org.junit.Test; public class IntervalsSetTest { @Test public void testInterval() { IntervalsSet set = new IntervalsSet(2.3, 5.7); Assert.assertEquals(3.4, set.getSize(), 1.0e-10); Assert.assertEquals(4.0, ((Vector1D) set.getBarycenter()).getX(), 1.0e-10); Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Vector1D(2.3))); Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Vector1D(5.7))); Assert.assertEquals(Region.Location.OUTSIDE, set.checkPoint(new Vector1D(1.2))); Assert.assertEquals(Region.Location.OUTSIDE, set.checkPoint(new Vector1D(8.7))); Assert.assertEquals(Region.Location.INSIDE, set.checkPoint(new Vector1D(3.0))); Assert.assertEquals(2.3, set.getInf(), 1.0e-10); Assert.assertEquals(5.7, set.getSup(), 1.0e-10); } @Test public void testInfinite() { IntervalsSet set = new IntervalsSet(9.0, Double.POSITIVE_INFINITY); Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Vector1D(9.0))); Assert.assertEquals(Region.Location.OUTSIDE, set.checkPoint(new Vector1D(8.4))); for (double e = 1.0; e <= 6.0; e += 1.0) { Assert.assertEquals(Region.Location.INSIDE, set.checkPoint(new Vector1D(FastMath.pow(10.0, e)))); } Assert.assertTrue(Double.isInfinite(set.getSize())); Assert.assertEquals(9.0, set.getInf(), 1.0e-10); Assert.assertTrue(Double.isInfinite(set.getSup())); set = (IntervalsSet) new RegionFactory<Euclidean1D>().getComplement(set); Assert.assertEquals(9.0, set.getSup(), 1.0e-10); Assert.assertTrue(Double.isInfinite(set.getInf())); } @Test public void testMultiple() { RegionFactory<Euclidean1D> factory = new RegionFactory<Euclidean1D>(); IntervalsSet set = (IntervalsSet) factory.intersection(factory.union(factory.difference(new IntervalsSet(1.0, 6.0), new IntervalsSet(3.0, 5.0)), new IntervalsSet(9.0, Double.POSITIVE_INFINITY)), new IntervalsSet(Double.NEGATIVE_INFINITY, 11.0)); Assert.assertEquals(5.0, set.getSize(), 1.0e-10); Assert.assertEquals(5.9, ((Vector1D) set.getBarycenter()).getX(), 1.0e-10); Assert.assertEquals(Region.Location.OUTSIDE, set.checkPoint(new Vector1D(0.0))); Assert.assertEquals(Region.Location.OUTSIDE, set.checkPoint(new Vector1D(4.0))); Assert.assertEquals(Region.Location.OUTSIDE, set.checkPoint(new Vector1D(8.0))); Assert.assertEquals(Region.Location.OUTSIDE, set.checkPoint(new Vector1D(12.0))); Assert.assertEquals(Region.Location.INSIDE, set.checkPoint(new Vector1D(1.2))); Assert.assertEquals(Region.Location.INSIDE, set.checkPoint(new Vector1D(5.9))); Assert.assertEquals(Region.Location.INSIDE, set.checkPoint(new Vector1D(9.01))); Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Vector1D(5.0))); Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Vector1D(11.0))); Assert.assertEquals( 1.0, set.getInf(), 1.0e-10); Assert.assertEquals(11.0, set.getSup(), 1.0e-10); List<Interval> list = set.asList(); Assert.assertEquals(3, list.size()); Assert.assertEquals( 1.0, list.get(0).getInf(), 1.0e-10); Assert.assertEquals( 3.0, list.get(0).getSup(), 1.0e-10); Assert.assertEquals( 5.0, list.get(1).getInf(), 1.0e-10); Assert.assertEquals( 6.0, list.get(1).getSup(), 1.0e-10); Assert.assertEquals( 9.0, list.get(2).getInf(), 1.0e-10); Assert.assertEquals(11.0, list.get(2).getSup(), 1.0e-10); } @Test public void testSinglePoint() { IntervalsSet set = new IntervalsSet(1.0, 1.0); Assert.assertEquals(0.0, set.getSize(), Precision.SAFE_MIN); Assert.assertEquals(1.0, ((Vector1D) set.getBarycenter()).getX(), Precision.EPSILON); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.geometry.euclidean.threed; import org.apache.commons.math3.analysis.differentiation.DerivativeStructure; import org.apache.commons.math3.exception.MathArithmeticException; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.linear.MatrixUtils; import org.apache.commons.math3.linear.RealMatrix; import org.apache.commons.math3.random.UnitSphereRandomVectorGenerator; import org.apache.commons.math3.random.Well1024a; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.util.MathUtils; import org.junit.Assert; import org.junit.Test; public class FieldRotationDSTest { @Test public void testIdentity() { FieldRotation<DerivativeStructure> r = createRotation(1, 0, 0, 0, false); checkVector(r.applyTo(createVector(1, 0, 0)), createVector(1, 0, 0)); checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 1, 0)); checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 0, 1)); checkAngle(r.getAngle(), 0); r = createRotation(-1, 0, 0, 0, false); checkVector(r.applyTo(createVector(1, 0, 0)), createVector(1, 0, 0)); checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 1, 0)); checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 0, 1)); checkAngle(r.getAngle(), 0); r = createRotation(42, 0, 0, 0, true); checkVector(r.applyTo(createVector(1, 0, 0)), createVector(1, 0, 0)); checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 1, 0)); checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 0, 1)); checkAngle(r.getAngle(), 0); } @Test public void testAxisAngle() throws MathIllegalArgumentException { FieldRotation<DerivativeStructure> r = new FieldRotation<DerivativeStructure>(createAxis(10, 10, 10), createAngle(2 * FastMath.PI / 3)); checkVector(r.applyTo(createVector(1, 0, 0)), createVector(0, 1, 0)); checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 0, 1)); checkVector(r.applyTo(createVector(0, 0, 1)), createVector(1, 0, 0)); double s = 1 / FastMath.sqrt(3); checkVector(r.getAxis(), createVector(s, s, s)); checkAngle(r.getAngle(), 2 * FastMath.PI / 3); try { new FieldRotation<DerivativeStructure>(createAxis(0, 0, 0), createAngle(2 * FastMath.PI / 3)); Assert.fail("an exception should have been thrown"); } catch (MathIllegalArgumentException e) { } r = new FieldRotation<DerivativeStructure>(createAxis(0, 0, 1), createAngle(1.5 * FastMath.PI)); checkVector(r.getAxis(), createVector(0, 0, -1)); checkAngle(r.getAngle(), 0.5 * FastMath.PI); r = new FieldRotation<DerivativeStructure>(createAxis(0, 1, 0), createAngle(FastMath.PI)); checkVector(r.getAxis(), createVector(0, 1, 0)); checkAngle(r.getAngle(), FastMath.PI); checkVector(createRotation(1, 0, 0, 0, false).getAxis(), createVector(1, 0, 0)); } @Test public void testRevert() { double a = 0.001; double b = 0.36; double c = 0.48; double d = 0.8; FieldRotation<DerivativeStructure> r = createRotation(a, b, c, d, true); double a2 = a * a; double b2 = b * b; double c2 = c * c; double d2 = d * d; double den = (a2 + b2 + c2 + d2) * FastMath.sqrt(a2 + b2 + c2 + d2); Assert.assertEquals((b2 + c2 + d2) / den, r.getQ0().getPartialDerivative(1, 0, 0, 0), 1.0e-15); Assert.assertEquals(-a * b / den, r.getQ0().getPartialDerivative(0, 1, 0, 0), 1.0e-15); Assert.assertEquals(-a * c / den, r.getQ0().getPartialDerivative(0, 0, 1, 0), 1.0e-15); Assert.assertEquals(-a * d / den, r.getQ0().getPartialDerivative(0, 0, 0, 1), 1.0e-15); Assert.assertEquals(-b * a / den, r.getQ1().getPartialDerivative(1, 0, 0, 0), 1.0e-15); Assert.assertEquals((a2 + c2 + d2) / den, r.getQ1().getPartialDerivative(0, 1, 0, 0), 1.0e-15); Assert.assertEquals(-b * c / den, r.getQ1().getPartialDerivative(0, 0, 1, 0), 1.0e-15); Assert.assertEquals(-b * d / den, r.getQ1().getPartialDerivative(0, 0, 0, 1), 1.0e-15); Assert.assertEquals(-c * a / den, r.getQ2().getPartialDerivative(1, 0, 0, 0), 1.0e-15); Assert.assertEquals(-c * b / den, r.getQ2().getPartialDerivative(0, 1, 0, 0), 1.0e-15); Assert.assertEquals((a2 + b2 + d2) / den, r.getQ2().getPartialDerivative(0, 0, 1, 0), 1.0e-15); Assert.assertEquals(-c * d / den, r.getQ2().getPartialDerivative(0, 0, 0, 1), 1.0e-15); Assert.assertEquals(-d * a / den, r.getQ3().getPartialDerivative(1, 0, 0, 0), 1.0e-15); Assert.assertEquals(-d * b / den, r.getQ3().getPartialDerivative(0, 1, 0, 0), 1.0e-15); Assert.assertEquals(-d * c / den, r.getQ3().getPartialDerivative(0, 0, 1, 0), 1.0e-15); Assert.assertEquals((a2 + b2 + c2) / den, r.getQ3().getPartialDerivative(0, 0, 0, 1), 1.0e-15); FieldRotation<DerivativeStructure> reverted = r.revert(); FieldRotation<DerivativeStructure> rrT = r.applyTo(reverted); checkRotationDS(rrT, 1, 0, 0, 0); Assert.assertEquals(0, rrT.getQ0().getPartialDerivative(1, 0, 0, 0), 1.0e-15); Assert.assertEquals(0, rrT.getQ0().getPartialDerivative(0, 1, 0, 0), 1.0e-15); Assert.assertEquals(0, rrT.getQ0().getPartialDerivative(0, 0, 1, 0), 1.0e-15); Assert.assertEquals(0, rrT.getQ0().getPartialDerivative(0, 0, 0, 1), 1.0e-15); Assert.assertEquals(0, rrT.getQ1().getPartialDerivative(1, 0, 0, 0), 1.0e-15); Assert.assertEquals(0, rrT.getQ1().getPartialDerivative(0, 1, 0, 0), 1.0e-15); Assert.assertEquals(0, rrT.getQ1().getPartialDerivative(0, 0, 1, 0), 1.0e-15); Assert.assertEquals(0, rrT.getQ1().getPartialDerivative(0, 0, 0, 1), 1.0e-15); Assert.assertEquals(0, rrT.getQ2().getPartialDerivative(1, 0, 0, 0), 1.0e-15); Assert.assertEquals(0, rrT.getQ2().getPartialDerivative(0, 1, 0, 0), 1.0e-15); Assert.assertEquals(0, rrT.getQ2().getPartialDerivative(0, 0, 1, 0), 1.0e-15); Assert.assertEquals(0, rrT.getQ2().getPartialDerivative(0, 0, 0, 1), 1.0e-15); Assert.assertEquals(0, rrT.getQ3().getPartialDerivative(1, 0, 0, 0), 1.0e-15); Assert.assertEquals(0, rrT.getQ3().getPartialDerivative(0, 1, 0, 0), 1.0e-15); Assert.assertEquals(0, rrT.getQ3().getPartialDerivative(0, 0, 1, 0), 1.0e-15); Assert.assertEquals(0, rrT.getQ3().getPartialDerivative(0, 0, 0, 1), 1.0e-15); FieldRotation<DerivativeStructure> rTr = reverted.applyTo(r); checkRotationDS(rTr, 1, 0, 0, 0); Assert.assertEquals(0, rTr.getQ0().getPartialDerivative(1, 0, 0, 0), 1.0e-15); Assert.assertEquals(0, rTr.getQ0().getPartialDerivative(0, 1, 0, 0), 1.0e-15); Assert.assertEquals(0, rTr.getQ0().getPartialDerivative(0, 0, 1, 0), 1.0e-15); Assert.assertEquals(0, rTr.getQ0().getPartialDerivative(0, 0, 0, 1), 1.0e-15); Assert.assertEquals(0, rTr.getQ1().getPartialDerivative(1, 0, 0, 0), 1.0e-15); Assert.assertEquals(0, rTr.getQ1().getPartialDerivative(0, 1, 0, 0), 1.0e-15); Assert.assertEquals(0, rTr.getQ1().getPartialDerivative(0, 0, 1, 0), 1.0e-15); Assert.assertEquals(0, rTr.getQ1().getPartialDerivative(0, 0, 0, 1), 1.0e-15); Assert.assertEquals(0, rTr.getQ2().getPartialDerivative(1, 0, 0, 0), 1.0e-15); Assert.assertEquals(0, rTr.getQ2().getPartialDerivative(0, 1, 0, 0), 1.0e-15); Assert.assertEquals(0, rTr.getQ2().getPartialDerivative(0, 0, 1, 0), 1.0e-15); Assert.assertEquals(0, rTr.getQ2().getPartialDerivative(0, 0, 0, 1), 1.0e-15); Assert.assertEquals(0, rTr.getQ3().getPartialDerivative(1, 0, 0, 0), 1.0e-15); Assert.assertEquals(0, rTr.getQ3().getPartialDerivative(0, 1, 0, 0), 1.0e-15); Assert.assertEquals(0, rTr.getQ3().getPartialDerivative(0, 0, 1, 0), 1.0e-15); Assert.assertEquals(0, rTr.getQ3().getPartialDerivative(0, 0, 0, 1), 1.0e-15); Assert.assertEquals(r.getAngle().getReal(), reverted.getAngle().getReal(), 1.0e-15); Assert.assertEquals(-1, FieldVector3D.dotProduct(r.getAxis(), reverted.getAxis()).getReal(), 1.0e-15); } @Test public void testVectorOnePair() throws MathArithmeticException { FieldVector3D<DerivativeStructure> u = createVector(3, 2, 1); FieldVector3D<DerivativeStructure> v = createVector(-4, 2, 2); FieldRotation<DerivativeStructure> r = new FieldRotation<DerivativeStructure>(u, v); checkVector(r.applyTo(u.scalarMultiply(v.getNorm())), v.scalarMultiply(u.getNorm())); checkAngle(new FieldRotation<DerivativeStructure>(u, u.negate()).getAngle(), FastMath.PI); try { new FieldRotation<DerivativeStructure>(u, createVector(0, 0, 0)); Assert.fail("an exception should have been thrown"); } catch (MathArithmeticException e) { // expected behavior } } @Test public void testVectorTwoPairs() throws MathArithmeticException { FieldVector3D<DerivativeStructure> u1 = createVector(3, 0, 0); FieldVector3D<DerivativeStructure> u2 = createVector(0, 5, 0); FieldVector3D<DerivativeStructure> v1 = createVector(0, 0, 2); FieldVector3D<DerivativeStructure> v2 = createVector(-2, 0, 2); FieldRotation<DerivativeStructure> r = new FieldRotation<DerivativeStructure>(u1, u2, v1, v2); checkVector(r.applyTo(createVector(1, 0, 0)), createVector(0, 0, 1)); checkVector(r.applyTo(createVector(0, 1, 0)), createVector(-1, 0, 0)); r = new FieldRotation<DerivativeStructure>(u1, u2, u1.negate(), u2.negate()); FieldVector3D<DerivativeStructure> axis = r.getAxis(); if (FieldVector3D.dotProduct(axis, createVector(0, 0, 1)).getReal() > 0) { checkVector(axis, createVector(0, 0, 1)); } else { checkVector(axis, createVector(0, 0, -1)); } checkAngle(r.getAngle(), FastMath.PI); double sqrt = FastMath.sqrt(2) / 2; r = new FieldRotation<DerivativeStructure>(createVector(1, 0, 0), createVector(0, 1, 0), createVector(0.5, 0.5, sqrt), createVector(0.5, 0.5, -sqrt)); checkRotationDS(r, sqrt, 0.5, 0.5, 0); r = new FieldRotation<DerivativeStructure>(u1, u2, u1, FieldVector3D.crossProduct(u1, u2)); checkRotationDS(r, sqrt, -sqrt, 0, 0); checkRotationDS(new FieldRotation<DerivativeStructure>(u1, u2, u1, u2), 1, 0, 0, 0); try { new FieldRotation<DerivativeStructure>(u1, u2, createVector(0, 0, 0), v2); Assert.fail("an exception should have been thrown"); } catch (MathArithmeticException e) { // expected behavior } } @Test public void testMatrix() throws NotARotationMatrixException { try { createRotation(new double[][] { { 0.0, 1.0, 0.0 }, { 1.0, 0.0, 0.0 } }, 1.0e-7); Assert.fail("Expecting NotARotationMatrixException"); } catch (NotARotationMatrixException nrme) { // expected behavior } try { createRotation(new double[][] { { 0.445888, 0.797184, -0.407040 }, { 0.821760, -0.184320, 0.539200 }, { -0.354816, 0.574912, 0.737280 } }, 1.0e-7); Assert.fail("Expecting NotARotationMatrixException"); } catch (NotARotationMatrixException nrme) { // expected behavior } try { createRotation(new double[][] { { 0.4, 0.8, -0.4 }, { -0.4, 0.6, 0.7 }, { 0.8, -0.2, 0.5 } }, 1.0e-15); Assert.fail("Expecting NotARotationMatrixException"); } catch (NotARotationMatrixException nrme) { // expected behavior } checkRotationDS(createRotation(new double[][] { { 0.445888, 0.797184, -0.407040 }, { -0.354816, 0.574912, 0.737280 }, { 0.821760, -0.184320, 0.539200 } }, 1.0e-10), 0.8, 0.288, 0.384, 0.36); checkRotationDS(createRotation(new double[][] { { 0.539200, 0.737280, 0.407040 }, { 0.184320, -0.574912, 0.797184 }, { 0.821760, -0.354816, -0.445888 } }, 1.0e-10), 0.36, 0.8, 0.288, 0.384); checkRotationDS(createRotation(new double[][] { { -0.445888, 0.797184, -0.407040 }, { 0.354816, 0.574912, 0.737280 }, { 0.821760, 0.184320, -0.539200 } }, 1.0e-10), 0.384, 0.36, 0.8, 0.288); checkRotationDS(createRotation(new double[][] { { -0.539200, 0.737280, 0.407040 }, { -0.184320, -0.574912, 0.797184 }, { 0.821760, 0.354816, 0.445888 } }, 1.0e-10), 0.288, 0.384, 0.36, 0.8); double[][] m1 = { { 0.0, 1.0, 0.0 }, { 0.0, 0.0, 1.0 }, { 1.0, 0.0, 0.0 } }; FieldRotation<DerivativeStructure> r = createRotation(m1, 1.0e-7); checkVector(r.applyTo(createVector(1, 0, 0)), createVector(0, 0, 1)); checkVector(r.applyTo(createVector(0, 1, 0)), createVector(1, 0, 0)); checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 1, 0)); double[][] m2 = { { 0.83203, -0.55012, -0.07139 }, { 0.48293, 0.78164, -0.39474 }, { 0.27296, 0.29396, 0.91602 } }; r = createRotation(m2, 1.0e-12); DerivativeStructure[][] m3 = r.getMatrix(); double d00 = m2[0][0] - m3[0][0].getReal(); double d01 = m2[0][1] - m3[0][1].getReal(); double d02 = m2[0][2] - m3[0][2].getReal(); double d10 = m2[1][0] - m3[1][0].getReal(); double d11 = m2[1][1] - m3[1][1].getReal(); double d12 = m2[1][2] - m3[1][2].getReal(); double d20 = m2[2][0] - m3[2][0].getReal(); double d21 = m2[2][1] - m3[2][1].getReal(); double d22 = m2[2][2] - m3[2][2].getReal(); Assert.assertTrue(FastMath.abs(d00) < 6.0e-6); Assert.assertTrue(FastMath.abs(d01) < 6.0e-6); Assert.assertTrue(FastMath.abs(d02) < 6.0e-6); Assert.assertTrue(FastMath.abs(d10) < 6.0e-6); Assert.assertTrue(FastMath.abs(d11) < 6.0e-6); Assert.assertTrue(FastMath.abs(d12) < 6.0e-6); Assert.assertTrue(FastMath.abs(d20) < 6.0e-6); Assert.assertTrue(FastMath.abs(d21) < 6.0e-6); Assert.assertTrue(FastMath.abs(d22) < 6.0e-6); Assert.assertTrue(FastMath.abs(d00) > 4.0e-7); Assert.assertTrue(FastMath.abs(d01) > 4.0e-7); Assert.assertTrue(FastMath.abs(d02) > 4.0e-7); Assert.assertTrue(FastMath.abs(d10) > 4.0e-7); Assert.assertTrue(FastMath.abs(d11) > 4.0e-7); Assert.assertTrue(FastMath.abs(d12) > 4.0e-7); Assert.assertTrue(FastMath.abs(d20) > 4.0e-7); Assert.assertTrue(FastMath.abs(d21) > 4.0e-7); Assert.assertTrue(FastMath.abs(d22) > 4.0e-7); for (int i = 0; i < 3; ++i) { for (int j = 0; j < 3; ++j) { double m3tm3 = m3[i][0].getReal() * m3[j][0].getReal() + m3[i][1].getReal() * m3[j][1].getReal() + m3[i][2].getReal() * m3[j][2].getReal(); if (i == j) { Assert.assertTrue(FastMath.abs(m3tm3 - 1.0) < 1.0e-10); } else { Assert.assertTrue(FastMath.abs(m3tm3) < 1.0e-10); } } } checkVector(r.applyTo(createVector(1, 0, 0)), new FieldVector3D<DerivativeStructure>(m3[0][0], m3[1][0], m3[2][0])); checkVector(r.applyTo(createVector(0, 1, 0)), new FieldVector3D<DerivativeStructure>(m3[0][1], m3[1][1], m3[2][1])); checkVector(r.applyTo(createVector(0, 0, 1)), new FieldVector3D<DerivativeStructure>(m3[0][2], m3[1][2], m3[2][2])); double[][] m4 = { { 1.0, 0.0, 0.0 }, { 0.0, -1.0, 0.0 }, { 0.0, 0.0, -1.0 } }; r = createRotation(m4, 1.0e-7); checkAngle(r.getAngle(), FastMath.PI); try { double[][] m5 = { { 0.0, 0.0, 1.0 }, { 0.0, 1.0, 0.0 }, { 1.0, 0.0, 0.0 } }; r = createRotation(m5, 1.0e-7); Assert.fail("got " + r + ", should have caught an exception"); } catch (NotARotationMatrixException e) { // expected } } @Test public void testAngles() throws CardanEulerSingularityException { RotationOrder[] CardanOrders = { RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ, RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX }; for (int i = 0; i < CardanOrders.length; ++i) { for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) { for (double alpha2 = -1.55; alpha2 < 1.55; alpha2 += 0.3) { for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) { FieldRotation<DerivativeStructure> r = new FieldRotation<DerivativeStructure>(CardanOrders[i], new DerivativeStructure(3, 1, 0, alpha1), new DerivativeStructure(3, 1, 1, alpha2), new DerivativeStructure(3, 1, 2, alpha3)); DerivativeStructure[] angles = r.getAngles(CardanOrders[i]); checkAngle(angles[0], alpha1); checkAngle(angles[1], alpha2); checkAngle(angles[2], alpha3); } } } } RotationOrder[] EulerOrders = { RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY, RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ }; for (int i = 0; i < EulerOrders.length; ++i) { for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) { for (double alpha2 = 0.05; alpha2 < 3.1; alpha2 += 0.3) { for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) { FieldRotation<DerivativeStructure> r = new FieldRotation<DerivativeStructure>(EulerOrders[i], new DerivativeStructure(3, 1, 0, alpha1), new DerivativeStructure(3, 1, 1, alpha2), new DerivativeStructure(3, 1, 2, alpha3)); DerivativeStructure[] angles = r.getAngles(EulerOrders[i]); checkAngle(angles[0], alpha1); checkAngle(angles[1], alpha2); checkAngle(angles[2], alpha3); } } } } } @Test public void testSingularities() { RotationOrder[] CardanOrders = { RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ, RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX }; double[] singularCardanAngle = { FastMath.PI / 2, -FastMath.PI / 2 }; for (int i = 0; i < CardanOrders.length; ++i) { for (int j = 0; j < singularCardanAngle.length; ++j) { FieldRotation<DerivativeStructure> r = new FieldRotation<DerivativeStructure>(CardanOrders[i], new DerivativeStructure(3, 1, 0, 0.1), new DerivativeStructure(3, 1, 1, singularCardanAngle[j]), new DerivativeStructure(3, 1, 2, 0.3)); try { r.getAngles(CardanOrders[i]); Assert.fail("an exception should have been caught"); } catch (CardanEulerSingularityException cese) { // expected behavior } } } RotationOrder[] EulerOrders = { RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY, RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ }; double[] singularEulerAngle = { 0, FastMath.PI }; for (int i = 0; i < EulerOrders.length; ++i) { for (int j = 0; j < singularEulerAngle.length; ++j) { FieldRotation<DerivativeStructure> r = new FieldRotation<DerivativeStructure>(EulerOrders[i], new DerivativeStructure(3, 1, 0, 0.1), new DerivativeStructure(3, 1, 1, singularEulerAngle[j]), new DerivativeStructure(3, 1, 2, 0.3)); try { r.getAngles(EulerOrders[i]); Assert.fail("an exception should have been caught"); } catch (CardanEulerSingularityException cese) { // expected behavior } } } } @Test public void testQuaternion() throws MathIllegalArgumentException { FieldRotation<DerivativeStructure> r1 = new FieldRotation<DerivativeStructure>(createVector(2, -3, 5), createAngle(1.7)); double n = 23.5; FieldRotation<DerivativeStructure> r2 = new FieldRotation<DerivativeStructure>(r1.getQ0().multiply(n), r1.getQ1().multiply(n), r1.getQ2().multiply(n), r1.getQ3().multiply(n), true); for (double x = -0.9; x < 0.9; x += 0.2) { for (double y = -0.9; y < 0.9; y += 0.2) { for (double z = -0.9; z < 0.9; z += 0.2) { FieldVector3D<DerivativeStructure> u = createVector(x, y, z); checkVector(r2.applyTo(u), r1.applyTo(u)); } } } r1 = createRotation(0.288, 0.384, 0.36, 0.8, false); checkRotationDS(r1, -r1.getQ0().getReal(), -r1.getQ1().getReal(), -r1.getQ2().getReal(), -r1.getQ3().getReal()); Assert.assertEquals(0.288, r1.toRotation().getQ0(), 1.0e-15); Assert.assertEquals(0.384, r1.toRotation().getQ1(), 1.0e-15); Assert.assertEquals(0.36, r1.toRotation().getQ2(), 1.0e-15); Assert.assertEquals(0.8, r1.toRotation().getQ3(), 1.0e-15); } @Test public void testCompose() throws MathIllegalArgumentException { FieldRotation<DerivativeStructure> r1 = new FieldRotation<DerivativeStructure>(createVector(2, -3, 5), createAngle(1.7)); FieldRotation<DerivativeStructure> r2 = new FieldRotation<DerivativeStructure>(createVector(-1, 3, 2), createAngle(0.3)); FieldRotation<DerivativeStructure> r3 = r2.applyTo(r1); FieldRotation<DerivativeStructure> r3Double = r2.applyTo(new Rotation(r1.getQ0().getReal(), r1.getQ1().getReal(), r1.getQ2().getReal(), r1.getQ3().getReal(), false)); for (double x = -0.9; x < 0.9; x += 0.2) { for (double y = -0.9; y < 0.9; y += 0.2) { for (double z = -0.9; z < 0.9; z += 0.2) { FieldVector3D<DerivativeStructure> u = createVector(x, y, z); checkVector(r2.applyTo(r1.applyTo(u)), r3.applyTo(u)); checkVector(r2.applyTo(r1.applyTo(u)), r3Double.applyTo(u)); } } } } @Test public void testComposeInverse() throws MathIllegalArgumentException { FieldRotation<DerivativeStructure> r1 = new FieldRotation<DerivativeStructure>(createVector(2, -3, 5), createAngle(1.7)); FieldRotation<DerivativeStructure> r2 = new FieldRotation<DerivativeStructure>(createVector(-1, 3, 2), createAngle(0.3)); FieldRotation<DerivativeStructure> r3 = r2.applyInverseTo(r1); FieldRotation<DerivativeStructure> r3Double = r2.applyInverseTo(new Rotation(r1.getQ0().getReal(), r1.getQ1().getReal(), r1.getQ2().getReal(), r1.getQ3().getReal(), false)); for (double x = -0.9; x < 0.9; x += 0.2) { for (double y = -0.9; y < 0.9; y += 0.2) { for (double z = -0.9; z < 0.9; z += 0.2) { FieldVector3D<DerivativeStructure> u = createVector(x, y, z); checkVector(r2.applyInverseTo(r1.applyTo(u)), r3.applyTo(u)); checkVector(r2.applyInverseTo(r1.applyTo(u)), r3Double.applyTo(u)); } } } } @Test public void testDoubleVectors() throws MathIllegalArgumentException { Well1024a random = new Well1024a(0x180b41cfeeffaf67l); UnitSphereRandomVectorGenerator g = new UnitSphereRandomVectorGenerator(3, random); for (int i = 0; i < 10; ++i) { double[] unit = g.nextVector(); FieldRotation<DerivativeStructure> r = new FieldRotation<DerivativeStructure>(createVector(unit[0], unit[1], unit[2]), createAngle(random.nextDouble())); for (double x = -0.9; x < 0.9; x += 0.2) { for (double y = -0.9; y < 0.9; y += 0.2) { for (double z = -0.9; z < 0.9; z += 0.2) { FieldVector3D<DerivativeStructure> uds = createVector(x, y, z); FieldVector3D<DerivativeStructure> ruds = r.applyTo(uds); FieldVector3D<DerivativeStructure> rIuds = r.applyInverseTo(uds); Vector3D u = new Vector3D(x, y, z); FieldVector3D<DerivativeStructure> ru = r.applyTo(u); FieldVector3D<DerivativeStructure> rIu = r.applyInverseTo(u); DerivativeStructure[] ruArray = new DerivativeStructure[3]; r.applyTo(new double[] { x, y, z}, ruArray); DerivativeStructure[] rIuArray = new DerivativeStructure[3]; r.applyInverseTo(new double[] { x, y, z}, rIuArray); checkVector(ruds, ru); checkVector(ruds, new FieldVector3D<DerivativeStructure>(ruArray)); checkVector(rIuds, rIu); checkVector(rIuds, new FieldVector3D<DerivativeStructure>(rIuArray)); } } } } } @Test public void testDoubleRotations() throws MathIllegalArgumentException { Well1024a random = new Well1024a(0x180b41cfeeffaf67l); UnitSphereRandomVectorGenerator g = new UnitSphereRandomVectorGenerator(3, random); for (int i = 0; i < 10; ++i) { double[] unit1 = g.nextVector(); Rotation r1 = new Rotation(new Vector3D(unit1[0], unit1[1], unit1[2]), random.nextDouble()); FieldRotation<DerivativeStructure> r1Prime = new FieldRotation<DerivativeStructure>(new DerivativeStructure(4, 1, 0, r1.getQ0()), new DerivativeStructure(4, 1, 1, r1.getQ1()), new DerivativeStructure(4, 1, 2, r1.getQ2()), new DerivativeStructure(4, 1, 3, r1.getQ3()), false); double[] unit2 = g.nextVector(); FieldRotation<DerivativeStructure> r2 = new FieldRotation<DerivativeStructure>(createVector(unit2[0], unit2[1], unit2[2]), createAngle(random.nextDouble())); FieldRotation<DerivativeStructure> rA = FieldRotation.applyTo(r1, r2); FieldRotation<DerivativeStructure> rB = r1Prime.applyTo(r2); FieldRotation<DerivativeStructure> rC = FieldRotation.applyInverseTo(r1, r2); FieldRotation<DerivativeStructure> rD = r1Prime.applyInverseTo(r2); for (double x = -0.9; x < 0.9; x += 0.2) { for (double y = -0.9; y < 0.9; y += 0.2) { for (double z = -0.9; z < 0.9; z += 0.2) { FieldVector3D<DerivativeStructure> uds = createVector(x, y, z); checkVector(r1Prime.applyTo(uds), FieldRotation.applyTo(r1, uds)); checkVector(r1Prime.applyInverseTo(uds), FieldRotation.applyInverseTo(r1, uds)); checkVector(rA.applyTo(uds), rB.applyTo(uds)); checkVector(rA.applyInverseTo(uds), rB.applyInverseTo(uds)); checkVector(rC.applyTo(uds), rD.applyTo(uds)); checkVector(rC.applyInverseTo(uds), rD.applyInverseTo(uds)); } } } } } @Test public void testDerivatives() { double eps = 5.0e-16; double kx = 2; double ky = -3; double kz = 5; double n2 = kx * kx + ky * ky + kz * kz; double n = FastMath.sqrt(n2); double theta = 1.7; double cosTheta = FastMath.cos(theta); double sinTheta = FastMath.sin(theta); FieldRotation<DerivativeStructure> r = new FieldRotation<DerivativeStructure>(createAxis(kx, ky, kz), createAngle(theta)); Vector3D a = new Vector3D(kx / n, ky / n, kz / n); // Jacobian of the normalized rotation axis a with respect to the Cartesian vector k RealMatrix dadk = MatrixUtils.createRealMatrix(new double[][] { { (ky * ky + kz * kz) / ( n * n2), -kx * ky / ( n * n2), -kx * kz / ( n * n2) }, { -kx * ky / ( n * n2), (kx * kx + kz * kz) / ( n * n2), -ky * kz / ( n * n2) }, { -kx * kz / ( n * n2), -ky * kz / ( n * n2), (kx * kx + ky * ky) / ( n * n2) } }); for (double x = -0.9; x < 0.9; x += 0.2) { for (double y = -0.9; y < 0.9; y += 0.2) { for (double z = -0.9; z < 0.9; z += 0.2) { Vector3D u = new Vector3D(x, y, z); FieldVector3D<DerivativeStructure> v = r.applyTo(createVector(x, y, z)); // explicit formula for rotation of vector u around axis a with angle theta double dot = Vector3D.dotProduct(u, a); Vector3D cross = Vector3D.crossProduct(a, u); double c1 = 1 - cosTheta; double c2 = c1 * dot; Vector3D rt = new Vector3D(cosTheta, u, c2, a, sinTheta, cross); Assert.assertEquals(rt.getX(), v.getX().getReal(), eps); Assert.assertEquals(rt.getY(), v.getY().getReal(), eps); Assert.assertEquals(rt.getZ(), v.getZ().getReal(), eps); // Jacobian of the image v = r(u) with respect to rotation axis a // (analytical differentiation of the explicit formula) RealMatrix dvda = MatrixUtils.createRealMatrix(new double[][] { { c1 * x * a.getX() + c2, c1 * y * a.getX() + sinTheta * z, c1 * z * a.getX() - sinTheta * y }, { c1 * x * a.getY() - sinTheta * z, c1 * y * a.getY() + c2, c1 * z * a.getY() + sinTheta * x }, { c1 * x * a.getZ() + sinTheta * y, c1 * y * a.getZ() - sinTheta * x, c1 * z * a.getZ() + c2 } }); // compose Jacobians RealMatrix dvdk = dvda.multiply(dadk); // derivatives with respect to un-normalized axis Assert.assertEquals(dvdk.getEntry(0, 0), v.getX().getPartialDerivative(1, 0, 0, 0), eps); Assert.assertEquals(dvdk.getEntry(0, 1), v.getX().getPartialDerivative(0, 1, 0, 0), eps); Assert.assertEquals(dvdk.getEntry(0, 2), v.getX().getPartialDerivative(0, 0, 1, 0), eps); Assert.assertEquals(dvdk.getEntry(1, 0), v.getY().getPartialDerivative(1, 0, 0, 0), eps); Assert.assertEquals(dvdk.getEntry(1, 1), v.getY().getPartialDerivative(0, 1, 0, 0), eps); Assert.assertEquals(dvdk.getEntry(1, 2), v.getY().getPartialDerivative(0, 0, 1, 0), eps); Assert.assertEquals(dvdk.getEntry(2, 0), v.getZ().getPartialDerivative(1, 0, 0, 0), eps); Assert.assertEquals(dvdk.getEntry(2, 1), v.getZ().getPartialDerivative(0, 1, 0, 0), eps); Assert.assertEquals(dvdk.getEntry(2, 2), v.getZ().getPartialDerivative(0, 0, 1, 0), eps); // derivative with respect to rotation angle // (analytical differentiation of the explicit formula) Vector3D dvdTheta = new Vector3D(-sinTheta, u, sinTheta * dot, a, cosTheta, cross); Assert.assertEquals(dvdTheta.getX(), v.getX().getPartialDerivative(0, 0, 0, 1), eps); Assert.assertEquals(dvdTheta.getY(), v.getY().getPartialDerivative(0, 0, 0, 1), eps); Assert.assertEquals(dvdTheta.getZ(), v.getZ().getPartialDerivative(0, 0, 0, 1), eps); } } } } @Test public void testArray() throws MathIllegalArgumentException { FieldRotation<DerivativeStructure> r = new FieldRotation<DerivativeStructure>(createAxis(2, -3, 5), createAngle(1.7)); for (double x = -0.9; x < 0.9; x += 0.2) { for (double y = -0.9; y < 0.9; y += 0.2) { for (double z = -0.9; z < 0.9; z += 0.2) { FieldVector3D<DerivativeStructure> u = createVector(x, y, z); FieldVector3D<DerivativeStructure> v = r.applyTo(u); DerivativeStructure[] out = new DerivativeStructure[3]; r.applyTo(new DerivativeStructure[] { u.getX(), u.getY(), u.getZ() }, out); Assert.assertEquals(v.getX().getReal(), out[0].getReal(), 1.0e-10); Assert.assertEquals(v.getY().getReal(), out[1].getReal(), 1.0e-10); Assert.assertEquals(v.getZ().getReal(), out[2].getReal(), 1.0e-10); r.applyInverseTo(out, out); Assert.assertEquals(u.getX().getReal(), out[0].getReal(), 1.0e-10); Assert.assertEquals(u.getY().getReal(), out[1].getReal(), 1.0e-10); Assert.assertEquals(u.getZ().getReal(), out[2].getReal(), 1.0e-10); } } } } @Test public void testApplyInverseTo() throws MathIllegalArgumentException { DerivativeStructure[] in = new DerivativeStructure[3]; DerivativeStructure[] out = new DerivativeStructure[3]; DerivativeStructure[] rebuilt = new DerivativeStructure[3]; FieldRotation<DerivativeStructure> r = new FieldRotation<DerivativeStructure>(createVector(2, -3, 5), createAngle(1.7)); for (double lambda = 0; lambda < 6.2; lambda += 0.2) { for (double phi = -1.55; phi < 1.55; phi += 0.2) { FieldVector3D<DerivativeStructure> u = createVector(FastMath.cos(lambda) * FastMath.cos(phi), FastMath.sin(lambda) * FastMath.cos(phi), FastMath.sin(phi)); r.applyInverseTo(r.applyTo(u)); checkVector(u, r.applyInverseTo(r.applyTo(u))); checkVector(u, r.applyTo(r.applyInverseTo(u))); in[0] = u.getX(); in[1] = u.getY(); in[2] = u.getZ(); r.applyTo(in, out); r.applyInverseTo(out, rebuilt); Assert.assertEquals(in[0].getReal(), rebuilt[0].getReal(), 1.0e-12); Assert.assertEquals(in[1].getReal(), rebuilt[1].getReal(), 1.0e-12); Assert.assertEquals(in[2].getReal(), rebuilt[2].getReal(), 1.0e-12); } } r = createRotation(1, 0, 0, 0, false); for (double lambda = 0; lambda < 6.2; lambda += 0.2) { for (double phi = -1.55; phi < 1.55; phi += 0.2) { FieldVector3D<DerivativeStructure> u = createVector(FastMath.cos(lambda) * FastMath.cos(phi), FastMath.sin(lambda) * FastMath.cos(phi), FastMath.sin(phi)); checkVector(u, r.applyInverseTo(r.applyTo(u))); checkVector(u, r.applyTo(r.applyInverseTo(u))); } } r = new FieldRotation<DerivativeStructure>(createVector(0, 0, 1), createAngle(FastMath.PI)); for (double lambda = 0; lambda < 6.2; lambda += 0.2) { for (double phi = -1.55; phi < 1.55; phi += 0.2) { FieldVector3D<DerivativeStructure> u = createVector(FastMath.cos(lambda) * FastMath.cos(phi), FastMath.sin(lambda) * FastMath.cos(phi), FastMath.sin(phi)); checkVector(u, r.applyInverseTo(r.applyTo(u))); checkVector(u, r.applyTo(r.applyInverseTo(u))); } } } @Test public void testIssue639() throws MathArithmeticException{ FieldVector3D<DerivativeStructure> u1 = createVector(-1321008684645961.0 / 268435456.0, -5774608829631843.0 / 268435456.0, -3822921525525679.0 / 4294967296.0); FieldVector3D<DerivativeStructure> u2 =createVector( -5712344449280879.0 / 2097152.0, -2275058564560979.0 / 1048576.0, 4423475992255071.0 / 65536.0); FieldRotation<DerivativeStructure> rot = new FieldRotation<DerivativeStructure>(u1, u2, createVector(1, 0, 0),createVector(0, 0, 1)); Assert.assertEquals( 0.6228370359608200639829222, rot.getQ0().getReal(), 1.0e-15); Assert.assertEquals( 0.0257707621456498790029987, rot.getQ1().getReal(), 1.0e-15); Assert.assertEquals(-0.0000000002503012255839931, rot.getQ2().getReal(), 1.0e-15); Assert.assertEquals(-0.7819270390861109450724902, rot.getQ3().getReal(), 1.0e-15); } @Test public void testIssue801() throws MathArithmeticException { FieldVector3D<DerivativeStructure> u1 = createVector(0.9999988431610581, -0.0015210774290851095, 0.0); FieldVector3D<DerivativeStructure> u2 = createVector(0.0, 0.0, 1.0); FieldVector3D<DerivativeStructure> v1 = createVector(0.9999999999999999, 0.0, 0.0); FieldVector3D<DerivativeStructure> v2 = createVector(0.0, 0.0, -1.0); FieldRotation<DerivativeStructure> quat = new FieldRotation<DerivativeStructure>(u1, u2, v1, v2); double q2 = quat.getQ0().getReal() * quat.getQ0().getReal() + quat.getQ1().getReal() * quat.getQ1().getReal() + quat.getQ2().getReal() * quat.getQ2().getReal() + quat.getQ3().getReal() * quat.getQ3().getReal(); Assert.assertEquals(1.0, q2, 1.0e-14); Assert.assertEquals(0.0, FieldVector3D.angle(v1, quat.applyTo(u1)).getReal(), 1.0e-14); Assert.assertEquals(0.0, FieldVector3D.angle(v2, quat.applyTo(u2)).getReal(), 1.0e-14); } private void checkAngle(DerivativeStructure a1, double a2) { Assert.assertEquals(a1.getReal(), MathUtils.normalizeAngle(a2, a1.getReal()), 1.0e-10); } private void checkRotationDS(FieldRotation<DerivativeStructure> r, double q0, double q1, double q2, double q3) { FieldRotation<DerivativeStructure> rPrime = createRotation(q0, q1, q2, q3, false); Assert.assertEquals(0, FieldRotation.distance(r, rPrime).getReal(), 1.0e-12); } private FieldRotation<DerivativeStructure> createRotation(double q0, double q1, double q2, double q3, boolean needsNormalization) { return new FieldRotation<DerivativeStructure>(new DerivativeStructure(4, 1, 0, q0), new DerivativeStructure(4, 1, 1, q1), new DerivativeStructure(4, 1, 2, q2), new DerivativeStructure(4, 1, 3, q3), needsNormalization); } private FieldRotation<DerivativeStructure> createRotation(double[][] m, double threshold) { DerivativeStructure[][] mds = new DerivativeStructure[m.length][m[0].length]; int index = 0; for (int i = 0; i < m.length; ++i) { for (int j = 0; j < m[i].length; ++j) { mds[i][j] = new DerivativeStructure(4, 1, index, m[i][j]); index = (index + 1) % 4; } } return new FieldRotation<DerivativeStructure>(mds, threshold); } private FieldVector3D<DerivativeStructure> createVector(double x, double y, double z) { return new FieldVector3D<DerivativeStructure>(new DerivativeStructure(4, 1, x), new DerivativeStructure(4, 1, y), new DerivativeStructure(4, 1, z)); } private FieldVector3D<DerivativeStructure> createAxis(double x, double y, double z) { return new FieldVector3D<DerivativeStructure>(new DerivativeStructure(4, 1, 0, x), new DerivativeStructure(4, 1, 1, y), new DerivativeStructure(4, 1, 2, z)); } private DerivativeStructure createAngle(double alpha) { return new DerivativeStructure(4, 1, 3, alpha); } private void checkVector(FieldVector3D<DerivativeStructure> u, FieldVector3D<DerivativeStructure> v) { Assert.assertEquals(u.getX().getReal(), v.getX().getReal(), 1.0e-12); Assert.assertEquals(u.getY().getReal(), v.getY().getReal(), 1.0e-12); Assert.assertEquals(u.getZ().getReal(), v.getZ().getReal(), 1.0e-12); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.geometry.euclidean.threed; import org.apache.commons.math3.dfp.Dfp; import org.apache.commons.math3.dfp.DfpField; import org.apache.commons.math3.exception.MathArithmeticException; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.random.UnitSphereRandomVectorGenerator; import org.apache.commons.math3.random.Well1024a; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.util.MathUtils; import org.junit.Assert; import org.junit.Test; public class FieldRotationDfpTest { @Test public void testIdentity() { FieldRotation<Dfp> r = createRotation(1, 0, 0, 0, false); checkVector(r.applyTo(createVector(1, 0, 0)), createVector(1, 0, 0)); checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 1, 0)); checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 0, 1)); checkAngle(r.getAngle(), 0); r = createRotation(-1, 0, 0, 0, false); checkVector(r.applyTo(createVector(1, 0, 0)), createVector(1, 0, 0)); checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 1, 0)); checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 0, 1)); checkAngle(r.getAngle(), 0); r = createRotation(42, 0, 0, 0, true); checkVector(r.applyTo(createVector(1, 0, 0)), createVector(1, 0, 0)); checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 1, 0)); checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 0, 1)); checkAngle(r.getAngle(), 0); } @Test public void testAxisAngle() throws MathIllegalArgumentException { FieldRotation<Dfp> r = new FieldRotation<Dfp>(createAxis(10, 10, 10), createAngle(2 * FastMath.PI / 3)); checkVector(r.applyTo(createVector(1, 0, 0)), createVector(0, 1, 0)); checkVector(r.applyTo(createVector(0, 1, 0)), createVector(0, 0, 1)); checkVector(r.applyTo(createVector(0, 0, 1)), createVector(1, 0, 0)); double s = 1 / FastMath.sqrt(3); checkVector(r.getAxis(), createVector(s, s, s)); checkAngle(r.getAngle(), 2 * FastMath.PI / 3); try { new FieldRotation<Dfp>(createAxis(0, 0, 0), createAngle(2 * FastMath.PI / 3)); Assert.fail("an exception should have been thrown"); } catch (MathIllegalArgumentException e) { } r = new FieldRotation<Dfp>(createAxis(0, 0, 1), createAngle(1.5 * FastMath.PI)); checkVector(r.getAxis(), createVector(0, 0, -1)); checkAngle(r.getAngle(), 0.5 * FastMath.PI); r = new FieldRotation<Dfp>(createAxis(0, 1, 0), createAngle(FastMath.PI)); checkVector(r.getAxis(), createVector(0, 1, 0)); checkAngle(r.getAngle(), FastMath.PI); checkVector(createRotation(1, 0, 0, 0, false).getAxis(), createVector(1, 0, 0)); } @Test public void testRevert() { double a = 0.001; double b = 0.36; double c = 0.48; double d = 0.8; FieldRotation<Dfp> r = createRotation(a, b, c, d, true); FieldRotation<Dfp> reverted = r.revert(); FieldRotation<Dfp> rrT = r.applyTo(reverted); checkRotationDS(rrT, 1, 0, 0, 0); FieldRotation<Dfp> rTr = reverted.applyTo(r); checkRotationDS(rTr, 1, 0, 0, 0); Assert.assertEquals(r.getAngle().getReal(), reverted.getAngle().getReal(), 1.0e-15); Assert.assertEquals(-1, FieldVector3D.dotProduct(r.getAxis(), reverted.getAxis()).getReal(), 1.0e-15); } @Test public void testVectorOnePair() throws MathArithmeticException { FieldVector3D<Dfp> u = createVector(3, 2, 1); FieldVector3D<Dfp> v = createVector(-4, 2, 2); FieldRotation<Dfp> r = new FieldRotation<Dfp>(u, v); checkVector(r.applyTo(u.scalarMultiply(v.getNorm())), v.scalarMultiply(u.getNorm())); checkAngle(new FieldRotation<Dfp>(u, u.negate()).getAngle(), FastMath.PI); try { new FieldRotation<Dfp>(u, createVector(0, 0, 0)); Assert.fail("an exception should have been thrown"); } catch (MathArithmeticException e) { // expected behavior } } @Test public void testVectorTwoPairs() throws MathArithmeticException { FieldVector3D<Dfp> u1 = createVector(3, 0, 0); FieldVector3D<Dfp> u2 = createVector(0, 5, 0); FieldVector3D<Dfp> v1 = createVector(0, 0, 2); FieldVector3D<Dfp> v2 = createVector(-2, 0, 2); FieldRotation<Dfp> r = new FieldRotation<Dfp>(u1, u2, v1, v2); checkVector(r.applyTo(createVector(1, 0, 0)), createVector(0, 0, 1)); checkVector(r.applyTo(createVector(0, 1, 0)), createVector(-1, 0, 0)); r = new FieldRotation<Dfp>(u1, u2, u1.negate(), u2.negate()); FieldVector3D<Dfp> axis = r.getAxis(); if (FieldVector3D.dotProduct(axis, createVector(0, 0, 1)).getReal() > 0) { checkVector(axis, createVector(0, 0, 1)); } else { checkVector(axis, createVector(0, 0, -1)); } checkAngle(r.getAngle(), FastMath.PI); double sqrt = FastMath.sqrt(2) / 2; r = new FieldRotation<Dfp>(createVector(1, 0, 0), createVector(0, 1, 0), createVector(0.5, 0.5, sqrt), createVector(0.5, 0.5, -sqrt)); checkRotationDS(r, sqrt, 0.5, 0.5, 0); r = new FieldRotation<Dfp>(u1, u2, u1, FieldVector3D.crossProduct(u1, u2)); checkRotationDS(r, sqrt, -sqrt, 0, 0); checkRotationDS(new FieldRotation<Dfp>(u1, u2, u1, u2), 1, 0, 0, 0); try { new FieldRotation<Dfp>(u1, u2, createVector(0, 0, 0), v2); Assert.fail("an exception should have been thrown"); } catch (MathArithmeticException e) { // expected behavior } } @Test public void testMatrix() throws NotARotationMatrixException { try { createRotation(new double[][] { { 0.0, 1.0, 0.0 }, { 1.0, 0.0, 0.0 } }, 1.0e-7); Assert.fail("Expecting NotARotationMatrixException"); } catch (NotARotationMatrixException nrme) { // expected behavior } try { createRotation(new double[][] { { 0.445888, 0.797184, -0.407040 }, { 0.821760, -0.184320, 0.539200 }, { -0.354816, 0.574912, 0.737280 } }, 1.0e-7); Assert.fail("Expecting NotARotationMatrixException"); } catch (NotARotationMatrixException nrme) { // expected behavior } try { createRotation(new double[][] { { 0.4, 0.8, -0.4 }, { -0.4, 0.6, 0.7 }, { 0.8, -0.2, 0.5 } }, 1.0e-15); Assert.fail("Expecting NotARotationMatrixException"); } catch (NotARotationMatrixException nrme) { // expected behavior } checkRotationDS(createRotation(new double[][] { { 0.445888, 0.797184, -0.407040 }, { -0.354816, 0.574912, 0.737280 }, { 0.821760, -0.184320, 0.539200 } }, 1.0e-10), 0.8, 0.288, 0.384, 0.36); checkRotationDS(createRotation(new double[][] { { 0.539200, 0.737280, 0.407040 }, { 0.184320, -0.574912, 0.797184 }, { 0.821760, -0.354816, -0.445888 } }, 1.0e-10), 0.36, 0.8, 0.288, 0.384); checkRotationDS(createRotation(new double[][] { { -0.445888, 0.797184, -0.407040 }, { 0.354816, 0.574912, 0.737280 }, { 0.821760, 0.184320, -0.539200 } }, 1.0e-10), 0.384, 0.36, 0.8, 0.288); checkRotationDS(createRotation(new double[][] { { -0.539200, 0.737280, 0.407040 }, { -0.184320, -0.574912, 0.797184 }, { 0.821760, 0.354816, 0.445888 } }, 1.0e-10), 0.288, 0.384, 0.36, 0.8); double[][] m1 = { { 0.0, 1.0, 0.0 }, { 0.0, 0.0, 1.0 }, { 1.0, 0.0, 0.0 } }; FieldRotation<Dfp> r = createRotation(m1, 1.0e-7); checkVector(r.applyTo(createVector(1, 0, 0)), createVector(0, 0, 1)); checkVector(r.applyTo(createVector(0, 1, 0)), createVector(1, 0, 0)); checkVector(r.applyTo(createVector(0, 0, 1)), createVector(0, 1, 0)); double[][] m2 = { { 0.83203, -0.55012, -0.07139 }, { 0.48293, 0.78164, -0.39474 }, { 0.27296, 0.29396, 0.91602 } }; r = createRotation(m2, 1.0e-12); Dfp[][] m3 = r.getMatrix(); double d00 = m2[0][0] - m3[0][0].getReal(); double d01 = m2[0][1] - m3[0][1].getReal(); double d02 = m2[0][2] - m3[0][2].getReal(); double d10 = m2[1][0] - m3[1][0].getReal(); double d11 = m2[1][1] - m3[1][1].getReal(); double d12 = m2[1][2] - m3[1][2].getReal(); double d20 = m2[2][0] - m3[2][0].getReal(); double d21 = m2[2][1] - m3[2][1].getReal(); double d22 = m2[2][2] - m3[2][2].getReal(); Assert.assertTrue(FastMath.abs(d00) < 6.0e-6); Assert.assertTrue(FastMath.abs(d01) < 6.0e-6); Assert.assertTrue(FastMath.abs(d02) < 6.0e-6); Assert.assertTrue(FastMath.abs(d10) < 6.0e-6); Assert.assertTrue(FastMath.abs(d11) < 6.0e-6); Assert.assertTrue(FastMath.abs(d12) < 6.0e-6); Assert.assertTrue(FastMath.abs(d20) < 6.0e-6); Assert.assertTrue(FastMath.abs(d21) < 6.0e-6); Assert.assertTrue(FastMath.abs(d22) < 6.0e-6); Assert.assertTrue(FastMath.abs(d00) > 4.0e-7); Assert.assertTrue(FastMath.abs(d01) > 4.0e-7); Assert.assertTrue(FastMath.abs(d02) > 4.0e-7); Assert.assertTrue(FastMath.abs(d10) > 4.0e-7); Assert.assertTrue(FastMath.abs(d11) > 4.0e-7); Assert.assertTrue(FastMath.abs(d12) > 4.0e-7); Assert.assertTrue(FastMath.abs(d20) > 4.0e-7); Assert.assertTrue(FastMath.abs(d21) > 4.0e-7); Assert.assertTrue(FastMath.abs(d22) > 4.0e-7); for (int i = 0; i < 3; ++i) { for (int j = 0; j < 3; ++j) { double m3tm3 = m3[i][0].getReal() * m3[j][0].getReal() + m3[i][1].getReal() * m3[j][1].getReal() + m3[i][2].getReal() * m3[j][2].getReal(); if (i == j) { Assert.assertTrue(FastMath.abs(m3tm3 - 1.0) < 1.0e-10); } else { Assert.assertTrue(FastMath.abs(m3tm3) < 1.0e-10); } } } checkVector(r.applyTo(createVector(1, 0, 0)), new FieldVector3D<Dfp>(m3[0][0], m3[1][0], m3[2][0])); checkVector(r.applyTo(createVector(0, 1, 0)), new FieldVector3D<Dfp>(m3[0][1], m3[1][1], m3[2][1])); checkVector(r.applyTo(createVector(0, 0, 1)), new FieldVector3D<Dfp>(m3[0][2], m3[1][2], m3[2][2])); double[][] m4 = { { 1.0, 0.0, 0.0 }, { 0.0, -1.0, 0.0 }, { 0.0, 0.0, -1.0 } }; r = createRotation(m4, 1.0e-7); checkAngle(r.getAngle(), FastMath.PI); try { double[][] m5 = { { 0.0, 0.0, 1.0 }, { 0.0, 1.0, 0.0 }, { 1.0, 0.0, 0.0 } }; r = createRotation(m5, 1.0e-7); Assert.fail("got " + r + ", should have caught an exception"); } catch (NotARotationMatrixException e) { // expected } } @Test public void testAngles() throws CardanEulerSingularityException { DfpField field = new DfpField(15); RotationOrder[] CardanOrders = { RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ, RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX }; for (int i = 0; i < CardanOrders.length; ++i) { for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 2.0) { for (double alpha2 = -1.55; alpha2 < 1.55; alpha2 += 0.8) { for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 2.0) { FieldRotation<Dfp> r = new FieldRotation<Dfp>(CardanOrders[i], field.newDfp(alpha1), field.newDfp(alpha2), field.newDfp(alpha3)); Dfp[] angles = r.getAngles(CardanOrders[i]); checkAngle(angles[0], alpha1); checkAngle(angles[1], alpha2); checkAngle(angles[2], alpha3); } } } } RotationOrder[] EulerOrders = { RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY, RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ }; for (int i = 0; i < EulerOrders.length; ++i) { for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 2.0) { for (double alpha2 = 0.05; alpha2 < 3.1; alpha2 += 0.8) { for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 2.0) { FieldRotation<Dfp> r = new FieldRotation<Dfp>(EulerOrders[i], field.newDfp(alpha1), field.newDfp(alpha2), field.newDfp(alpha3)); Dfp[] angles = r.getAngles(EulerOrders[i]); checkAngle(angles[0], alpha1); checkAngle(angles[1], alpha2); checkAngle(angles[2], alpha3); } } } } } @Test public void testSingularities() { DfpField field = new DfpField(20); RotationOrder[] CardanOrders = { RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ, RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX }; double[] singularCardanAngle = { FastMath.PI / 2, -FastMath.PI / 2 }; for (int i = 0; i < CardanOrders.length; ++i) { for (int j = 0; j < singularCardanAngle.length; ++j) { FieldRotation<Dfp> r = new FieldRotation<Dfp>(CardanOrders[i], field.newDfp(0.1), field.newDfp(singularCardanAngle[j]), field.newDfp(0.3)); try { r.getAngles(CardanOrders[i]); Assert.fail("an exception should have been caught"); } catch (CardanEulerSingularityException cese) { // expected behavior } } } RotationOrder[] EulerOrders = { RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY, RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ }; double[] singularEulerAngle = { 0, FastMath.PI }; for (int i = 0; i < EulerOrders.length; ++i) { for (int j = 0; j < singularEulerAngle.length; ++j) { FieldRotation<Dfp> r = new FieldRotation<Dfp>(EulerOrders[i], field.newDfp(0.1), field.newDfp(singularEulerAngle[j]), field.newDfp(0.3)); try { r.getAngles(EulerOrders[i]); Assert.fail("an exception should have been caught"); } catch (CardanEulerSingularityException cese) { // expected behavior } } } } @Test public void testQuaternion() throws MathIllegalArgumentException { FieldRotation<Dfp> r1 = new FieldRotation<Dfp>(createVector(2, -3, 5), createAngle(1.7)); double n = 23.5; FieldRotation<Dfp> r2 = new FieldRotation<Dfp>(r1.getQ0().multiply(n), r1.getQ1().multiply(n), r1.getQ2().multiply(n), r1.getQ3().multiply(n), true); for (double x = -0.9; x < 0.9; x += 0.2) { for (double y = -0.9; y < 0.9; y += 0.2) { for (double z = -0.9; z < 0.9; z += 0.2) { FieldVector3D<Dfp> u = createVector(x, y, z); checkVector(r2.applyTo(u), r1.applyTo(u)); } } } r1 = createRotation(0.288, 0.384, 0.36, 0.8, false); checkRotationDS(r1, -r1.getQ0().getReal(), -r1.getQ1().getReal(), -r1.getQ2().getReal(), -r1.getQ3().getReal()); } @Test public void testCompose() throws MathIllegalArgumentException { FieldRotation<Dfp> r1 = new FieldRotation<Dfp>(createVector(2, -3, 5), createAngle(1.7)); FieldRotation<Dfp> r2 = new FieldRotation<Dfp>(createVector(-1, 3, 2), createAngle(0.3)); FieldRotation<Dfp> r3 = r2.applyTo(r1); FieldRotation<Dfp> r3Double = r2.applyTo(new Rotation(r1.getQ0().getReal(), r1.getQ1().getReal(), r1.getQ2().getReal(), r1.getQ3().getReal(), false)); for (double x = -0.9; x < 0.9; x += 0.2) { for (double y = -0.9; y < 0.9; y += 0.2) { for (double z = -0.9; z < 0.9; z += 0.2) { FieldVector3D<Dfp> u = createVector(x, y, z); checkVector(r2.applyTo(r1.applyTo(u)), r3.applyTo(u)); checkVector(r2.applyTo(r1.applyTo(u)), r3Double.applyTo(u)); } } } } @Test public void testComposeInverse() throws MathIllegalArgumentException { FieldRotation<Dfp> r1 = new FieldRotation<Dfp>(createVector(2, -3, 5), createAngle(1.7)); FieldRotation<Dfp> r2 = new FieldRotation<Dfp>(createVector(-1, 3, 2), createAngle(0.3)); FieldRotation<Dfp> r3 = r2.applyInverseTo(r1); FieldRotation<Dfp> r3Double = r2.applyInverseTo(new Rotation(r1.getQ0().getReal(), r1.getQ1().getReal(), r1.getQ2().getReal(), r1.getQ3().getReal(), false)); for (double x = -0.9; x < 0.9; x += 0.2) { for (double y = -0.9; y < 0.9; y += 0.2) { for (double z = -0.9; z < 0.9; z += 0.2) { FieldVector3D<Dfp> u = createVector(x, y, z); checkVector(r2.applyInverseTo(r1.applyTo(u)), r3.applyTo(u)); checkVector(r2.applyInverseTo(r1.applyTo(u)), r3Double.applyTo(u)); } } } } @Test public void testDoubleVectors() throws MathIllegalArgumentException { Well1024a random = new Well1024a(0x180b41cfeeffaf67l); UnitSphereRandomVectorGenerator g = new UnitSphereRandomVectorGenerator(3, random); for (int i = 0; i < 10; ++i) { double[] unit = g.nextVector(); FieldRotation<Dfp> r = new FieldRotation<Dfp>(createVector(unit[0], unit[1], unit[2]), createAngle(random.nextDouble())); for (double x = -0.9; x < 0.9; x += 0.4) { for (double y = -0.9; y < 0.9; y += 0.4) { for (double z = -0.9; z < 0.9; z += 0.4) { FieldVector3D<Dfp> uds = createVector(x, y, z); FieldVector3D<Dfp> ruds = r.applyTo(uds); FieldVector3D<Dfp> rIuds = r.applyInverseTo(uds); Vector3D u = new Vector3D(x, y, z); FieldVector3D<Dfp> ru = r.applyTo(u); FieldVector3D<Dfp> rIu = r.applyInverseTo(u); Dfp[] ruArray = new Dfp[3]; r.applyTo(new double[] { x, y, z}, ruArray); Dfp[] rIuArray = new Dfp[3]; r.applyInverseTo(new double[] { x, y, z}, rIuArray); checkVector(ruds, ru); checkVector(ruds, new FieldVector3D<Dfp>(ruArray)); checkVector(rIuds, rIu); checkVector(rIuds, new FieldVector3D<Dfp>(rIuArray)); } } } } } @Test public void testDoubleRotations() throws MathIllegalArgumentException { DfpField field = new DfpField(20); Well1024a random = new Well1024a(0x180b41cfeeffaf67l); UnitSphereRandomVectorGenerator g = new UnitSphereRandomVectorGenerator(3, random); for (int i = 0; i < 10; ++i) { double[] unit1 = g.nextVector(); Rotation r1 = new Rotation(new Vector3D(unit1[0], unit1[1], unit1[2]), random.nextDouble()); FieldRotation<Dfp> r1Prime = new FieldRotation<Dfp>(field.newDfp(r1.getQ0()), field.newDfp(r1.getQ1()), field.newDfp(r1.getQ2()), field.newDfp(r1.getQ3()), false); double[] unit2 = g.nextVector(); FieldRotation<Dfp> r2 = new FieldRotation<Dfp>(createVector(unit2[0], unit2[1], unit2[2]), createAngle(random.nextDouble())); FieldRotation<Dfp> rA = FieldRotation.applyTo(r1, r2); FieldRotation<Dfp> rB = r1Prime.applyTo(r2); FieldRotation<Dfp> rC = FieldRotation.applyInverseTo(r1, r2); FieldRotation<Dfp> rD = r1Prime.applyInverseTo(r2); for (double x = -0.9; x < 0.9; x += 0.4) { for (double y = -0.9; y < 0.9; y += 0.4) { for (double z = -0.9; z < 0.9; z += 0.4) { FieldVector3D<Dfp> uds = createVector(x, y, z); checkVector(r1Prime.applyTo(uds), FieldRotation.applyTo(r1, uds)); checkVector(r1Prime.applyInverseTo(uds), FieldRotation.applyInverseTo(r1, uds)); checkVector(rA.applyTo(uds), rB.applyTo(uds)); checkVector(rA.applyInverseTo(uds), rB.applyInverseTo(uds)); checkVector(rC.applyTo(uds), rD.applyTo(uds)); checkVector(rC.applyInverseTo(uds), rD.applyInverseTo(uds)); } } } } } @Test public void testArray() throws MathIllegalArgumentException { FieldRotation<Dfp> r = new FieldRotation<Dfp>(createAxis(2, -3, 5), createAngle(1.7)); for (double x = -0.9; x < 0.9; x += 0.2) { for (double y = -0.9; y < 0.9; y += 0.2) { for (double z = -0.9; z < 0.9; z += 0.2) { FieldVector3D<Dfp> u = createVector(x, y, z); FieldVector3D<Dfp> v = r.applyTo(u); Dfp[] out = new Dfp[3]; r.applyTo(new Dfp[] { u.getX(), u.getY(), u.getZ() }, out); Assert.assertEquals(v.getX().getReal(), out[0].getReal(), 1.0e-10); Assert.assertEquals(v.getY().getReal(), out[1].getReal(), 1.0e-10); Assert.assertEquals(v.getZ().getReal(), out[2].getReal(), 1.0e-10); r.applyInverseTo(out, out); Assert.assertEquals(u.getX().getReal(), out[0].getReal(), 1.0e-10); Assert.assertEquals(u.getY().getReal(), out[1].getReal(), 1.0e-10); Assert.assertEquals(u.getZ().getReal(), out[2].getReal(), 1.0e-10); } } } } @Test public void testApplyInverseTo() throws MathIllegalArgumentException { Dfp[] in = new Dfp[3]; Dfp[] out = new Dfp[3]; Dfp[] rebuilt = new Dfp[3]; FieldRotation<Dfp> r = new FieldRotation<Dfp>(createVector(2, -3, 5), createAngle(1.7)); for (double lambda = 0; lambda < 6.2; lambda += 0.2) { for (double phi = -1.55; phi < 1.55; phi += 0.2) { FieldVector3D<Dfp> u = createVector(FastMath.cos(lambda) * FastMath.cos(phi), FastMath.sin(lambda) * FastMath.cos(phi), FastMath.sin(phi)); r.applyInverseTo(r.applyTo(u)); checkVector(u, r.applyInverseTo(r.applyTo(u))); checkVector(u, r.applyTo(r.applyInverseTo(u))); in[0] = u.getX(); in[1] = u.getY(); in[2] = u.getZ(); r.applyTo(in, out); r.applyInverseTo(out, rebuilt); Assert.assertEquals(in[0].getReal(), rebuilt[0].getReal(), 1.0e-12); Assert.assertEquals(in[1].getReal(), rebuilt[1].getReal(), 1.0e-12); Assert.assertEquals(in[2].getReal(), rebuilt[2].getReal(), 1.0e-12); } } r = createRotation(1, 0, 0, 0, false); for (double lambda = 0; lambda < 6.2; lambda += 0.2) { for (double phi = -1.55; phi < 1.55; phi += 0.2) { FieldVector3D<Dfp> u = createVector(FastMath.cos(lambda) * FastMath.cos(phi), FastMath.sin(lambda) * FastMath.cos(phi), FastMath.sin(phi)); checkVector(u, r.applyInverseTo(r.applyTo(u))); checkVector(u, r.applyTo(r.applyInverseTo(u))); } } r = new FieldRotation<Dfp>(createVector(0, 0, 1), createAngle(FastMath.PI)); for (double lambda = 0; lambda < 6.2; lambda += 0.2) { for (double phi = -1.55; phi < 1.55; phi += 0.2) { FieldVector3D<Dfp> u = createVector(FastMath.cos(lambda) * FastMath.cos(phi), FastMath.sin(lambda) * FastMath.cos(phi), FastMath.sin(phi)); checkVector(u, r.applyInverseTo(r.applyTo(u))); checkVector(u, r.applyTo(r.applyInverseTo(u))); } } } @Test public void testIssue639() throws MathArithmeticException{ FieldVector3D<Dfp> u1 = createVector(-1321008684645961.0 / 268435456.0, -5774608829631843.0 / 268435456.0, -3822921525525679.0 / 4294967296.0); FieldVector3D<Dfp> u2 =createVector( -5712344449280879.0 / 2097152.0, -2275058564560979.0 / 1048576.0, 4423475992255071.0 / 65536.0); FieldRotation<Dfp> rot = new FieldRotation<Dfp>(u1, u2, createVector(1, 0, 0),createVector(0, 0, 1)); Assert.assertEquals( 0.6228370359608200639829222, rot.getQ0().getReal(), 1.0e-15); Assert.assertEquals( 0.0257707621456498790029987, rot.getQ1().getReal(), 1.0e-15); Assert.assertEquals(-0.0000000002503012255839931, rot.getQ2().getReal(), 1.0e-15); Assert.assertEquals(-0.7819270390861109450724902, rot.getQ3().getReal(), 1.0e-15); } @Test public void testIssue801() throws MathArithmeticException { FieldVector3D<Dfp> u1 = createVector(0.9999988431610581, -0.0015210774290851095, 0.0); FieldVector3D<Dfp> u2 = createVector(0.0, 0.0, 1.0); FieldVector3D<Dfp> v1 = createVector(0.9999999999999999, 0.0, 0.0); FieldVector3D<Dfp> v2 = createVector(0.0, 0.0, -1.0); FieldRotation<Dfp> quat = new FieldRotation<Dfp>(u1, u2, v1, v2); double q2 = quat.getQ0().getReal() * quat.getQ0().getReal() + quat.getQ1().getReal() * quat.getQ1().getReal() + quat.getQ2().getReal() * quat.getQ2().getReal() + quat.getQ3().getReal() * quat.getQ3().getReal(); Assert.assertEquals(1.0, q2, 1.0e-14); Assert.assertEquals(0.0, FieldVector3D.angle(v1, quat.applyTo(u1)).getReal(), 1.0e-14); Assert.assertEquals(0.0, FieldVector3D.angle(v2, quat.applyTo(u2)).getReal(), 1.0e-14); } private void checkAngle(Dfp a1, double a2) { Assert.assertEquals(a1.getReal(), MathUtils.normalizeAngle(a2, a1.getReal()), 1.0e-10); } private void checkRotationDS(FieldRotation<Dfp> r, double q0, double q1, double q2, double q3) { FieldRotation<Dfp> rPrime = createRotation(q0, q1, q2, q3, false); Assert.assertEquals(0, FieldRotation.distance(r, rPrime).getReal(), 1.0e-12); } private FieldRotation<Dfp> createRotation(double q0, double q1, double q2, double q3, boolean needsNormalization) { DfpField field = new DfpField(20); return new FieldRotation<Dfp>(field.newDfp(q0), field.newDfp(q1), field.newDfp(q2), field.newDfp(q3), needsNormalization); } private FieldRotation<Dfp> createRotation(double[][] m, double threshold) { DfpField field = new DfpField(20); Dfp[][] mds = new Dfp[m.length][m[0].length]; for (int i = 0; i < m.length; ++i) { for (int j = 0; j < m[i].length; ++j) { mds[i][j] = field.newDfp(m[i][j]); } } return new FieldRotation<Dfp>(mds, threshold); } private FieldVector3D<Dfp> createVector(double x, double y, double z) { DfpField field = new DfpField(20); return new FieldVector3D<Dfp>(field.newDfp(x), field.newDfp(y), field.newDfp(z)); } private FieldVector3D<Dfp> createAxis(double x, double y, double z) { DfpField field = new DfpField(20); return new FieldVector3D<Dfp>(field.newDfp(x), field.newDfp(y), field.newDfp(z)); } private Dfp createAngle(double alpha) { return new DfpField(20).newDfp(alpha); } private void checkVector(FieldVector3D<Dfp> u, FieldVector3D<Dfp> v) { Assert.assertEquals(u.getX().getReal(), v.getX().getReal(), 1.0e-12); Assert.assertEquals(u.getY().getReal(), v.getY().getReal(), 1.0e-12); Assert.assertEquals(u.getZ().getReal(), v.getZ().getReal(), 1.0e-12); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.geometry.euclidean.threed; import java.text.DecimalFormat; import java.text.DecimalFormatSymbols; import java.text.NumberFormat; import java.util.Locale; import org.apache.commons.math3.analysis.differentiation.DerivativeStructure; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MathArithmeticException; import org.apache.commons.math3.random.Well1024a; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.util.Precision; import org.junit.Assert; import org.junit.Test; public class FieldVector3DTest { @Test public void testConstructors() throws DimensionMismatchException { double cosAlpha = 1 / 2.0; double sinAlpha = FastMath.sqrt(3) / 2.0; double cosDelta = FastMath.sqrt(2) / 2.0; double sinDelta = -FastMath.sqrt(2) / 2.0; FieldVector3D<DerivativeStructure> u = new FieldVector3D<DerivativeStructure>(2, new FieldVector3D<DerivativeStructure>(new DerivativeStructure(2, 1, 0, FastMath.PI / 3), new DerivativeStructure(2, 1, 1, -FastMath.PI / 4))); checkVector(u, 2 * cosAlpha * cosDelta, 2 * sinAlpha * cosDelta, 2 * sinDelta); Assert.assertEquals(-2 * sinAlpha * cosDelta, u.getX().getPartialDerivative(1, 0), 1.0e-12); Assert.assertEquals(+2 * cosAlpha * cosDelta, u.getY().getPartialDerivative(1, 0), 1.0e-12); Assert.assertEquals(0, u.getZ().getPartialDerivative(1, 0), 1.0e-12); Assert.assertEquals(-2 * cosAlpha * sinDelta, u.getX().getPartialDerivative(0, 1), 1.0e-12); Assert.assertEquals(-2 * sinAlpha * sinDelta, u.getY().getPartialDerivative(0, 1), 1.0e-12); Assert.assertEquals(2 * cosDelta, u.getZ().getPartialDerivative(0, 1), 1.0e-12); checkVector(new FieldVector3D<DerivativeStructure>(2, createVector(1, 0, 0, 3)), 2, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2); checkVector(new FieldVector3D<DerivativeStructure>(new DerivativeStructure(4, 1, 3, 2.0), createVector(1, 0, 0, 4)), 2, 0, 0, 2, 0, 0, 1, 0, 2, 0, 0, 0, 0, 2, 0); checkVector(new FieldVector3D<DerivativeStructure>(new DerivativeStructure(4, 1, 3, 2.0), new Vector3D(1, 0, 0)), 2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0); checkVector(new FieldVector3D<DerivativeStructure>(2, createVector(1, 0, 0, 3), -3, createVector(0, 0, -1, 3)), 2, 0, 3, -1, 0, 0, 0, -1, 0, 0, 0, -1); checkVector(new FieldVector3D<DerivativeStructure>(new DerivativeStructure(4, 1, 3, 2.0), createVector(1, 0, 0, 4), new DerivativeStructure(4, 1, 3, -3.0), createVector(0, 0, -1, 4)), 2, 0, 3, -1, 0, 0, 1, 0, -1, 0, 0, 0, 0, -1, -1); checkVector(new FieldVector3D<DerivativeStructure>(new DerivativeStructure(4, 1, 3, 2.0), new Vector3D(1, 0, 0), new DerivativeStructure(4, 1, 3, -3.0), new Vector3D(0, 0, -1)), 2, 0, 3, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1); checkVector(new FieldVector3D<DerivativeStructure>(2, createVector(1, 0, 0, 3), 5, createVector(0, 1, 0, 3), -3, createVector(0, 0, -1, 3)), 2, 5, 3, 4, 0, 0, 0, 4, 0, 0, 0, 4); checkVector(new FieldVector3D<DerivativeStructure>(new DerivativeStructure(4, 1, 3, 2.0), createVector(1, 0, 0, 4), new DerivativeStructure(4, 1, 3, 5.0), createVector(0, 1, 0, 4), new DerivativeStructure(4, 1, 3, -3.0), createVector(0, 0, -1, 4)), 2, 5, 3, 4, 0, 0, 1, 0, 4, 0, 1, 0, 0, 4, -1); checkVector(new FieldVector3D<DerivativeStructure>(new DerivativeStructure(4, 1, 3, 2.0), new Vector3D(1, 0, 0), new DerivativeStructure(4, 1, 3, 5.0), new Vector3D(0, 1, 0), new DerivativeStructure(4, 1, 3, -3.0), new Vector3D(0, 0, -1)), 2, 5, 3, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, -1); checkVector(new FieldVector3D<DerivativeStructure>(2, createVector(1, 0, 0, 3), 5, createVector(0, 1, 0, 3), 5, createVector(0, -1, 0, 3), -3, createVector(0, 0, -1, 3)), 2, 0, 3, 9, 0, 0, 0, 9, 0, 0, 0, 9); checkVector(new FieldVector3D<DerivativeStructure>(new DerivativeStructure(4, 1, 3, 2.0), createVector(1, 0, 0, 4), new DerivativeStructure(4, 1, 3, 5.0), createVector(0, 1, 0, 4), new DerivativeStructure(4, 1, 3, 5.0), createVector(0, -1, 0, 4), new DerivativeStructure(4, 1, 3, -3.0), createVector(0, 0, -1, 4)), 2, 0, 3, 9, 0, 0, 1, 0, 9, 0, 0, 0, 0, 9, -1); checkVector(new FieldVector3D<DerivativeStructure>(new DerivativeStructure(4, 1, 3, 2.0), new Vector3D(1, 0, 0), new DerivativeStructure(4, 1, 3, 5.0), new Vector3D(0, 1, 0), new DerivativeStructure(4, 1, 3, 5.0), new Vector3D(0, -1, 0), new DerivativeStructure(4, 1, 3, -3.0), new Vector3D(0, 0, -1)), 2, 0, 3, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1); checkVector(new FieldVector3D<DerivativeStructure>(new DerivativeStructure[] { new DerivativeStructure(3, 1, 2, 2), new DerivativeStructure(3, 1, 1, 5), new DerivativeStructure(3, 1, 0, -3) }), 2, 5, -3, 0, 0, 1, 0, 1, 0, 1, 0, 0); } @Test public void testEquals() { FieldVector3D<DerivativeStructure> u1 = createVector(1, 2, 3, 3); FieldVector3D<DerivativeStructure> v = createVector(1, 2, 3 + 10 * Precision.EPSILON, 3); Assert.assertTrue(u1.equals(u1)); Assert.assertTrue(u1.equals(new FieldVector3D<DerivativeStructure>(new DerivativeStructure(3, 1, 0, 1.0), new DerivativeStructure(3, 1, 1, 2.0), new DerivativeStructure(3, 1, 2, 3.0)))); Assert.assertFalse(u1.equals(new FieldVector3D<DerivativeStructure>(new DerivativeStructure(3, 1, 1.0), new DerivativeStructure(3, 1, 1, 2.0), new DerivativeStructure(3, 1, 2, 3.0)))); Assert.assertFalse(u1.equals(new FieldVector3D<DerivativeStructure>(new DerivativeStructure(3, 1, 0, 1.0), new DerivativeStructure(3, 1, 2.0), new DerivativeStructure(3, 1, 2, 3.0)))); Assert.assertFalse(u1.equals(new FieldVector3D<DerivativeStructure>(new DerivativeStructure(3, 1, 0, 1.0), new DerivativeStructure(3, 1, 1, 2.0), new DerivativeStructure(3, 1, 3.0)))); Assert.assertFalse(u1.equals(v)); Assert.assertFalse(u1.equals(u1.toVector3D())); Assert.assertTrue(createVector(0, Double.NaN, 0, 3).equals(createVector(0, 0, Double.NaN, 3))); } @Test public void testHash() { Assert.assertEquals(createVector(0, Double.NaN, 0, 3).hashCode(), createVector(0, 0, Double.NaN, 3).hashCode()); FieldVector3D<DerivativeStructure> u = createVector(1, 2, 3, 3); FieldVector3D<DerivativeStructure> v = createVector(1, 2, 3 + 10 * Precision.EPSILON, 3); Assert.assertTrue(u.hashCode() != v.hashCode()); } @Test public void testInfinite() { Assert.assertTrue(createVector(1, 1, Double.NEGATIVE_INFINITY, 3).isInfinite()); Assert.assertTrue(createVector(1, Double.NEGATIVE_INFINITY, 1, 3).isInfinite()); Assert.assertTrue(createVector(Double.NEGATIVE_INFINITY, 1, 1, 3).isInfinite()); Assert.assertFalse(createVector(1, 1, 2, 3).isInfinite()); Assert.assertFalse(createVector(1, Double.NaN, Double.NEGATIVE_INFINITY, 3).isInfinite()); } @Test public void testNaN() { Assert.assertTrue(createVector(1, 1, Double.NaN, 3).isNaN()); Assert.assertTrue(createVector(1, Double.NaN, 1, 3).isNaN()); Assert.assertTrue(createVector(Double.NaN, 1, 1, 3).isNaN()); Assert.assertFalse(createVector(1, 1, 2, 3).isNaN()); Assert.assertFalse(createVector(1, 1, Double.NEGATIVE_INFINITY, 3).isNaN()); } @Test public void testToString() { Assert.assertEquals("{3; 2; 1}", createVector(3, 2, 1, 3).toString()); NumberFormat format = new DecimalFormat("0.000", new DecimalFormatSymbols(Locale.US)); Assert.assertEquals("{3.000; 2.000; 1.000}", createVector(3, 2, 1, 3).toString(format)); } @Test(expected=DimensionMismatchException.class) public void testWrongDimension() throws DimensionMismatchException { new FieldVector3D<DerivativeStructure>(new DerivativeStructure[] { new DerivativeStructure(3, 1, 0, 2), new DerivativeStructure(3, 1, 0, 5) }); } @Test public void testCoordinates() { FieldVector3D<DerivativeStructure> v = createVector(1, 2, 3, 3); Assert.assertTrue(FastMath.abs(v.getX().getReal() - 1) < 1.0e-12); Assert.assertTrue(FastMath.abs(v.getY().getReal() - 2) < 1.0e-12); Assert.assertTrue(FastMath.abs(v.getZ().getReal() - 3) < 1.0e-12); DerivativeStructure[] coordinates = v.toArray(); Assert.assertTrue(FastMath.abs(coordinates[0].getReal() - 1) < 1.0e-12); Assert.assertTrue(FastMath.abs(coordinates[1].getReal() - 2) < 1.0e-12); Assert.assertTrue(FastMath.abs(coordinates[2].getReal() - 3) < 1.0e-12); } @Test public void testNorm1() { Assert.assertEquals( 0.0, createVector(0, 0, 0, 3).getNorm1().getReal(), 0); Assert.assertEquals( 6.0, createVector(1, -2, 3, 3).getNorm1().getReal(), 0); Assert.assertEquals( 1.0, createVector(1, -2, 3, 3).getNorm1().getPartialDerivative(1, 0, 0), 0); Assert.assertEquals(-1.0, createVector(1, -2, 3, 3).getNorm1().getPartialDerivative(0, 1, 0), 0); Assert.assertEquals( 1.0, createVector(1, -2, 3, 3).getNorm1().getPartialDerivative(0, 0, 1), 0); } @Test public void testNorm() { double r = FastMath.sqrt(14); Assert.assertEquals(0.0, createVector(0, 0, 0, 3).getNorm().getReal(), 0); Assert.assertEquals(r, createVector(1, 2, 3, 3).getNorm().getReal(), 1.0e-12); Assert.assertEquals( 1.0 / r, createVector(1, 2, 3, 3).getNorm().getPartialDerivative(1, 0, 0), 0); Assert.assertEquals( 2.0 / r, createVector(1, 2, 3, 3).getNorm().getPartialDerivative(0, 1, 0), 0); Assert.assertEquals( 3.0 / r, createVector(1, 2, 3, 3).getNorm().getPartialDerivative(0, 0, 1), 0); } @Test public void testNormSq() { Assert.assertEquals(0.0, createVector(0, 0, 0, 3).getNormSq().getReal(), 0); Assert.assertEquals(14, createVector(1, 2, 3, 3).getNormSq().getReal(), 1.0e-12); Assert.assertEquals( 2, createVector(1, 2, 3, 3).getNormSq().getPartialDerivative(1, 0, 0), 0); Assert.assertEquals( 4, createVector(1, 2, 3, 3).getNormSq().getPartialDerivative(0, 1, 0), 0); Assert.assertEquals( 6, createVector(1, 2, 3, 3).getNormSq().getPartialDerivative(0, 0, 1), 0); } @Test public void testNormInf() { Assert.assertEquals( 0.0, createVector(0, 0, 0, 3).getNormInf().getReal(), 0); Assert.assertEquals( 3.0, createVector(1, -2, 3, 3).getNormInf().getReal(), 0); Assert.assertEquals( 0.0, createVector(1, -2, 3, 3).getNormInf().getPartialDerivative(1, 0, 0), 0); Assert.assertEquals( 0.0, createVector(1, -2, 3, 3).getNormInf().getPartialDerivative(0, 1, 0), 0); Assert.assertEquals( 1.0, createVector(1, -2, 3, 3).getNormInf().getPartialDerivative(0, 0, 1), 0); Assert.assertEquals( 3.0, createVector(2, -1, 3, 3).getNormInf().getReal(), 0); Assert.assertEquals( 0.0, createVector(2, -1, 3, 3).getNormInf().getPartialDerivative(1, 0, 0), 0); Assert.assertEquals( 0.0, createVector(2, -1, 3, 3).getNormInf().getPartialDerivative(0, 1, 0), 0); Assert.assertEquals( 1.0, createVector(2, -1, 3, 3).getNormInf().getPartialDerivative(0, 0, 1), 0); Assert.assertEquals( 3.0, createVector(1, -3, 2, 3).getNormInf().getReal(), 0); Assert.assertEquals( 0.0, createVector(1, -3, 2, 3).getNormInf().getPartialDerivative(1, 0, 0), 0); Assert.assertEquals(-1.0, createVector(1, -3, 2, 3).getNormInf().getPartialDerivative(0, 1, 0), 0); Assert.assertEquals( 0.0, createVector(1, -3, 2, 3).getNormInf().getPartialDerivative(0, 0, 1), 0); Assert.assertEquals( 3.0, createVector(2, -3, 1, 3).getNormInf().getReal(), 0); Assert.assertEquals( 0.0, createVector(2, -3, 1, 3).getNormInf().getPartialDerivative(1, 0, 0), 0); Assert.assertEquals(-1.0, createVector(2, -3, 1, 3).getNormInf().getPartialDerivative(0, 1, 0), 0); Assert.assertEquals( 0.0, createVector(2, -3, 1, 3).getNormInf().getPartialDerivative(0, 0, 1), 0); Assert.assertEquals( 3.0, createVector(3, -1, 2, 3).getNormInf().getReal(), 0); Assert.assertEquals( 1.0, createVector(3, -1, 2, 3).getNormInf().getPartialDerivative(1, 0, 0), 0); Assert.assertEquals( 0.0, createVector(3, -1, 2, 3).getNormInf().getPartialDerivative(0, 1, 0), 0); Assert.assertEquals( 0.0, createVector(3, -1, 2, 3).getNormInf().getPartialDerivative(0, 0, 1), 0); Assert.assertEquals( 3.0, createVector(3, -2, 1, 3).getNormInf().getReal(), 0); Assert.assertEquals( 1.0, createVector(3, -2, 1, 3).getNormInf().getPartialDerivative(1, 0, 0), 0); Assert.assertEquals( 0.0, createVector(3, -2, 1, 3).getNormInf().getPartialDerivative(0, 1, 0), 0); Assert.assertEquals( 0.0, createVector(3, -2, 1, 3).getNormInf().getPartialDerivative(0, 0, 1), 0); } @Test public void testDistance1() { FieldVector3D<DerivativeStructure> v1 = createVector(1, -2, 3, 3); FieldVector3D<DerivativeStructure> v2 = createVector(-4, 2, 0, 3); Assert.assertEquals(0.0, FieldVector3D.distance1(createVector(-1, 0, 0, 3), createVector(-1, 0, 0, 3)).getReal(), 0); DerivativeStructure distance = FieldVector3D.distance1(v1, v2); Assert.assertEquals(12.0, distance.getReal(), 1.0e-12); Assert.assertEquals(0, distance.getPartialDerivative(1, 0, 0), 1.0e-12); Assert.assertEquals(0, distance.getPartialDerivative(0, 1, 0), 1.0e-12); Assert.assertEquals(0, distance.getPartialDerivative(0, 0, 1), 1.0e-12); distance = FieldVector3D.distance1(v1, new Vector3D(-4, 2, 0)); Assert.assertEquals(12.0, distance.getReal(), 1.0e-12); Assert.assertEquals( 1, distance.getPartialDerivative(1, 0, 0), 1.0e-12); Assert.assertEquals(-1, distance.getPartialDerivative(0, 1, 0), 1.0e-12); Assert.assertEquals( 1, distance.getPartialDerivative(0, 0, 1), 1.0e-12); distance = FieldVector3D.distance1(new Vector3D(-4, 2, 0), v1); Assert.assertEquals(12.0, distance.getReal(), 1.0e-12); Assert.assertEquals( 1, distance.getPartialDerivative(1, 0, 0), 1.0e-12); Assert.assertEquals(-1, distance.getPartialDerivative(0, 1, 0), 1.0e-12); Assert.assertEquals( 1, distance.getPartialDerivative(0, 0, 1), 1.0e-12); } @Test public void testDistance() { FieldVector3D<DerivativeStructure> v1 = createVector(1, -2, 3, 3); FieldVector3D<DerivativeStructure> v2 = createVector(-4, 2, 0, 3); Assert.assertEquals(0.0, FieldVector3D.distance(createVector(-1, 0, 0, 3), createVector(-1, 0, 0, 3)).getReal(), 0); DerivativeStructure distance = FieldVector3D.distance(v1, v2); Assert.assertEquals(FastMath.sqrt(50), distance.getReal(), 1.0e-12); Assert.assertEquals(0, distance.getPartialDerivative(1, 0, 0), 1.0e-12); Assert.assertEquals(0, distance.getPartialDerivative(0, 1, 0), 1.0e-12); Assert.assertEquals(0, distance.getPartialDerivative(0, 0, 1), 1.0e-12); distance = FieldVector3D.distance(v1, new Vector3D(-4, 2, 0)); Assert.assertEquals(FastMath.sqrt(50), distance.getReal(), 1.0e-12); Assert.assertEquals( 5 / FastMath.sqrt(50), distance.getPartialDerivative(1, 0, 0), 1.0e-12); Assert.assertEquals(-4 / FastMath.sqrt(50), distance.getPartialDerivative(0, 1, 0), 1.0e-12); Assert.assertEquals( 3 / FastMath.sqrt(50), distance.getPartialDerivative(0, 0, 1), 1.0e-12); distance = FieldVector3D.distance(new Vector3D(-4, 2, 0), v1); Assert.assertEquals(FastMath.sqrt(50), distance.getReal(), 1.0e-12); Assert.assertEquals( 5 / FastMath.sqrt(50), distance.getPartialDerivative(1, 0, 0), 1.0e-12); Assert.assertEquals(-4 / FastMath.sqrt(50), distance.getPartialDerivative(0, 1, 0), 1.0e-12); Assert.assertEquals( 3 / FastMath.sqrt(50), distance.getPartialDerivative(0, 0, 1), 1.0e-12); } @Test public void testDistanceSq() { FieldVector3D<DerivativeStructure> v1 = createVector(1, -2, 3, 3); FieldVector3D<DerivativeStructure> v2 = createVector(-4, 2, 0, 3); Assert.assertEquals(0.0, FieldVector3D.distanceSq(createVector(-1, 0, 0, 3), createVector(-1, 0, 0, 3)).getReal(), 0); DerivativeStructure distanceSq = FieldVector3D.distanceSq(v1, v2); Assert.assertEquals(50.0, distanceSq.getReal(), 1.0e-12); Assert.assertEquals(0, distanceSq.getPartialDerivative(1, 0, 0), 1.0e-12); Assert.assertEquals(0, distanceSq.getPartialDerivative(0, 1, 0), 1.0e-12); Assert.assertEquals(0, distanceSq.getPartialDerivative(0, 0, 1), 1.0e-12); distanceSq = FieldVector3D.distanceSq(v1, new Vector3D(-4, 2, 0)); Assert.assertEquals(50.0, distanceSq.getReal(), 1.0e-12); Assert.assertEquals(10, distanceSq.getPartialDerivative(1, 0, 0), 1.0e-12); Assert.assertEquals(-8, distanceSq.getPartialDerivative(0, 1, 0), 1.0e-12); Assert.assertEquals( 6, distanceSq.getPartialDerivative(0, 0, 1), 1.0e-12); distanceSq = FieldVector3D.distanceSq(new Vector3D(-4, 2, 0), v1); Assert.assertEquals(50.0, distanceSq.getReal(), 1.0e-12); Assert.assertEquals(10, distanceSq.getPartialDerivative(1, 0, 0), 1.0e-12); Assert.assertEquals(-8, distanceSq.getPartialDerivative(0, 1, 0), 1.0e-12); Assert.assertEquals( 6, distanceSq.getPartialDerivative(0, 0, 1), 1.0e-12); } @Test public void testDistanceInf() { FieldVector3D<DerivativeStructure> v1 = createVector(1, -2, 3, 3); FieldVector3D<DerivativeStructure> v2 = createVector(-4, 2, 0, 3); Assert.assertEquals(0.0, FieldVector3D.distanceInf(createVector(-1, 0, 0, 3), createVector(-1, 0, 0, 3)).getReal(), 0); DerivativeStructure distance = FieldVector3D.distanceInf(v1, v2); Assert.assertEquals(5.0, distance.getReal(), 1.0e-12); Assert.assertEquals(0, distance.getPartialDerivative(1, 0, 0), 1.0e-12); Assert.assertEquals(0, distance.getPartialDerivative(0, 1, 0), 1.0e-12); Assert.assertEquals(0, distance.getPartialDerivative(0, 0, 1), 1.0e-12); distance = FieldVector3D.distanceInf(v1, new Vector3D(-4, 2, 0)); Assert.assertEquals(5.0, distance.getReal(), 1.0e-12); Assert.assertEquals(1, distance.getPartialDerivative(1, 0, 0), 1.0e-12); Assert.assertEquals(0, distance.getPartialDerivative(0, 1, 0), 1.0e-12); Assert.assertEquals(0, distance.getPartialDerivative(0, 0, 1), 1.0e-12); distance = FieldVector3D.distanceInf(new Vector3D(-4, 2, 0), v1); Assert.assertEquals(5.0, distance.getReal(), 1.0e-12); Assert.assertEquals(1, distance.getPartialDerivative(1, 0, 0), 1.0e-12); Assert.assertEquals(0, distance.getPartialDerivative(0, 1, 0), 1.0e-12); Assert.assertEquals(0, distance.getPartialDerivative(0, 0, 1), 1.0e-12); Assert.assertEquals(v1.subtract(v2).getNormInf().getReal(), FieldVector3D.distanceInf(v1, v2).getReal(), 1.0e-12); Assert.assertEquals(5.0, FieldVector3D.distanceInf(createVector( 1, -2, 3, 3), createVector(-4, 2, 0, 3)).getReal(), 1.0e-12); Assert.assertEquals(5.0, FieldVector3D.distanceInf(createVector( 1, 3, -2, 3), createVector(-4, 0, 2, 3)).getReal(), 1.0e-12); Assert.assertEquals(5.0, FieldVector3D.distanceInf(createVector(-2, 1, 3, 3), createVector( 2, -4, 0, 3)).getReal(), 1.0e-12); Assert.assertEquals(5.0, FieldVector3D.distanceInf(createVector(-2, 3, 1, 3), createVector( 2, 0, -4, 3)).getReal(), 1.0e-12); Assert.assertEquals(5.0, FieldVector3D.distanceInf(createVector(3, -2, 1, 3), createVector(0, 2, -4, 3)).getReal(), 1.0e-12); Assert.assertEquals(5.0, FieldVector3D.distanceInf(createVector(3, 1, -2, 3), createVector(0, -4, 2, 3)).getReal(), 1.0e-12); Assert.assertEquals(5.0, FieldVector3D.distanceInf(createVector( 1, -2, 3, 3), new Vector3D(-4, 2, 0)).getReal(), 1.0e-12); Assert.assertEquals(5.0, FieldVector3D.distanceInf(createVector( 1, 3, -2, 3), new Vector3D(-4, 0, 2)).getReal(), 1.0e-12); Assert.assertEquals(5.0, FieldVector3D.distanceInf(createVector(-2, 1, 3, 3), new Vector3D( 2, -4, 0)).getReal(), 1.0e-12); Assert.assertEquals(5.0, FieldVector3D.distanceInf(createVector(-2, 3, 1, 3), new Vector3D( 2, 0, -4)).getReal(), 1.0e-12); Assert.assertEquals(5.0, FieldVector3D.distanceInf(createVector(3, -2, 1, 3), new Vector3D(0, 2, -4)).getReal(), 1.0e-12); Assert.assertEquals(5.0, FieldVector3D.distanceInf(createVector(3, 1, -2, 3), new Vector3D(0, -4, 2)).getReal(), 1.0e-12); } @Test public void testSubtract() { FieldVector3D<DerivativeStructure> v1 = createVector(1, 2, 3, 3); FieldVector3D<DerivativeStructure> v2 = createVector(-3, -2, -1, 3); v1 = v1.subtract(v2); checkVector(v1, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0); checkVector(v2.subtract(v1), -7, -6, -5, 1, 0, 0, 0, 1, 0, 0, 0, 1); checkVector(v2.subtract(new Vector3D(4, 4, 4)), -7, -6, -5, 1, 0, 0, 0, 1, 0, 0, 0, 1); checkVector(v2.subtract(3, v1), -15, -14, -13, 1, 0, 0, 0, 1, 0, 0, 0, 1); checkVector(v2.subtract(3, new Vector3D(4, 4, 4)), -15, -14, -13, 1, 0, 0, 0, 1, 0, 0, 0, 1); checkVector(v2.subtract(new DerivativeStructure(3, 1, 2, 3), new Vector3D(4, 4, 4)), -15, -14, -13, 1, 0, -4, 0, 1, -4, 0, 0, -3); checkVector(createVector(1, 2, 3, 4).subtract(new DerivativeStructure(4, 1, 3, 5.0), createVector(3, -2, 1, 4)), -14, 12, -2, -4, 0, 0, -3, 0, -4, 0, 2, 0, 0, -4, -1); } @Test public void testAdd() { FieldVector3D<DerivativeStructure> v1 = createVector(1, 2, 3, 3); FieldVector3D<DerivativeStructure> v2 = createVector(-3, -2, -1, 3); v1 = v1.add(v2); checkVector(v1, -2, 0, 2, 2, 0, 0, 0, 2, 0, 0, 0, 2); checkVector(v2.add(v1), -5, -2, 1, 3, 0, 0, 0, 3, 0, 0, 0, 3); checkVector(v2.add(new Vector3D(-2, 0, 2)), -5, -2, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1); checkVector(v2.add(3, v1), -9, -2, 5, 7, 0, 0, 0, 7, 0, 0, 0, 7); checkVector(v2.add(3, new Vector3D(-2, 0, 2)), -9, -2, 5, 1, 0, 0, 0, 1, 0, 0, 0, 1); checkVector(v2.add(new DerivativeStructure(3, 1, 2, 3), new Vector3D(-2, 0, 2)), -9, -2, 5, 1, 0, -2, 0, 1, 0, 0, 0, 3); checkVector(createVector(1, 2, 3, 4).add(new DerivativeStructure(4, 1, 3, 5.0), createVector(3, -2, 1, 4)), 16, -8, 8, 6, 0, 0, 3, 0, 6, 0, -2, 0, 0, 6, 1); } @Test public void testScalarProduct() { FieldVector3D<DerivativeStructure> v = createVector(1, 2, 3, 3); v = v.scalarMultiply(3); checkVector(v, 3, 6, 9); checkVector(v.scalarMultiply(0.5), 1.5, 3, 4.5); } @Test public void testVectorialProducts() { FieldVector3D<DerivativeStructure> v1 = createVector(2, 1, -4, 3); FieldVector3D<DerivativeStructure> v2 = createVector(3, 1, -1, 3); Assert.assertTrue(FastMath.abs(FieldVector3D.dotProduct(v1, v2).getReal() - 11) < 1.0e-12); Assert.assertTrue(FastMath.abs(FieldVector3D.dotProduct(v1, v2.toVector3D()).getReal() - 11) < 1.0e-12); Assert.assertTrue(FastMath.abs(FieldVector3D.dotProduct(v1.toVector3D(), v2).getReal() - 11) < 1.0e-12); FieldVector3D<DerivativeStructure> v3 = FieldVector3D.crossProduct(v1, v2); checkVector(v3, 3, -10, -1); Assert.assertTrue(FastMath.abs(FieldVector3D.dotProduct(v1, v3).getReal()) < 1.0e-12); Assert.assertTrue(FastMath.abs(FieldVector3D.dotProduct(v2, v3).getReal()) < 1.0e-12); v3 = FieldVector3D.crossProduct(v1, v2.toVector3D()); checkVector(v3, 3, -10, -1); Assert.assertTrue(FastMath.abs(FieldVector3D.dotProduct(v1, v3).getReal()) < 1.0e-12); Assert.assertTrue(FastMath.abs(FieldVector3D.dotProduct(v2, v3).getReal()) < 1.0e-12); v3 = FieldVector3D.crossProduct(v1.toVector3D(), v2); checkVector(v3, 3, -10, -1); Assert.assertTrue(FastMath.abs(FieldVector3D.dotProduct(v1, v3).getReal()) < 1.0e-12); Assert.assertTrue(FastMath.abs(FieldVector3D.dotProduct(v2, v3).getReal()) < 1.0e-12); } @Test public void testCrossProductCancellation() { FieldVector3D<DerivativeStructure> v1 = createVector(9070467121.0, 4535233560.0, 1, 3); FieldVector3D<DerivativeStructure> v2 = createVector(9070467123.0, 4535233561.0, 1, 3); checkVector(FieldVector3D.crossProduct(v1, v2), -1, 2, 1); double scale = FastMath.scalb(1.0, 100); FieldVector3D<DerivativeStructure> big1 = new FieldVector3D<DerivativeStructure>(scale, v1); FieldVector3D<DerivativeStructure> small2 = new FieldVector3D<DerivativeStructure>(1 / scale, v2); checkVector(FieldVector3D.crossProduct(big1, small2), -1, 2, 1); } @Test public void testAngular() { Assert.assertEquals(0, createVector(1, 0, 0, 3).getAlpha().getReal(), 1.0e-10); Assert.assertEquals(0, createVector(1, 0, 0, 3).getDelta().getReal(), 1.0e-10); Assert.assertEquals(FastMath.PI / 2, createVector(0, 1, 0, 3).getAlpha().getReal(), 1.0e-10); Assert.assertEquals(0, createVector(0, 1, 0, 3).getDelta().getReal(), 1.0e-10); Assert.assertEquals(FastMath.PI / 2, createVector(0, 0, 1, 3).getDelta().getReal(), 1.0e-10); FieldVector3D<DerivativeStructure> u = createVector(-1, 1, -1, 3); Assert.assertEquals(3 * FastMath.PI /4, u.getAlpha().getReal(), 1.0e-10); Assert.assertEquals(-1.0 / FastMath.sqrt(3), u.getDelta().sin().getReal(), 1.0e-10); } @Test public void testAngularSeparation() throws MathArithmeticException { FieldVector3D<DerivativeStructure> v1 = createVector(2, -1, 4, 3); FieldVector3D<DerivativeStructure> k = v1.normalize(); FieldVector3D<DerivativeStructure> i = k.orthogonal(); FieldVector3D<DerivativeStructure> v2 = k.scalarMultiply(FastMath.cos(1.2)).add(i.scalarMultiply(FastMath.sin(1.2))); Assert.assertTrue(FastMath.abs(FieldVector3D.angle(v1, v2).getReal() - 1.2) < 1.0e-12); Assert.assertTrue(FastMath.abs(FieldVector3D.angle(v1, v2.toVector3D()).getReal() - 1.2) < 1.0e-12); Assert.assertTrue(FastMath.abs(FieldVector3D.angle(v1.toVector3D(), v2).getReal() - 1.2) < 1.0e-12); try { FieldVector3D.angle(v1, Vector3D.ZERO); Assert.fail("an exception should have been thrown"); } catch (MathArithmeticException mae) { // expected } Assert.assertEquals(0.0, FieldVector3D.angle(v1, v1.toVector3D()).getReal(), 1.0e-15); Assert.assertEquals(FastMath.PI, FieldVector3D.angle(v1, v1.negate().toVector3D()).getReal(), 1.0e-15); } @Test public void testNormalize() throws MathArithmeticException { Assert.assertEquals(1.0, createVector(5, -4, 2, 3).normalize().getNorm().getReal(), 1.0e-12); try { createVector(0, 0, 0, 3).normalize(); Assert.fail("an exception should have been thrown"); } catch (MathArithmeticException ae) { // expected behavior } } @Test public void testNegate() { checkVector(createVector(0.1, 2.5, 1.3, 3).negate(), -0.1, -2.5, -1.3, -1, 0, 0, 0, -1, 0, 0, 0, -1); } @Test public void testOrthogonal() throws MathArithmeticException { FieldVector3D<DerivativeStructure> v1 = createVector(0.1, 2.5, 1.3, 3); Assert.assertEquals(0.0, FieldVector3D.dotProduct(v1, v1.orthogonal()).getReal(), 1.0e-12); FieldVector3D<DerivativeStructure> v2 = createVector(2.3, -0.003, 7.6, 3); Assert.assertEquals(0.0, FieldVector3D.dotProduct(v2, v2.orthogonal()).getReal(), 1.0e-12); FieldVector3D<DerivativeStructure> v3 = createVector(-1.7, 1.4, 0.2, 3); Assert.assertEquals(0.0, FieldVector3D.dotProduct(v3, v3.orthogonal()).getReal(), 1.0e-12); FieldVector3D<DerivativeStructure> v4 = createVector(4.2, 0.1, -1.8, 3); Assert.assertEquals(0.0, FieldVector3D.dotProduct(v4, v4.orthogonal()).getReal(), 1.0e-12); try { createVector(0, 0, 0, 3).orthogonal(); Assert.fail("an exception should have been thrown"); } catch (MathArithmeticException ae) { // expected behavior } } @Test public void testAngle() throws MathArithmeticException { Assert.assertEquals(0.22572612855273393616, FieldVector3D.angle(createVector(1, 2, 3, 3), createVector(4, 5, 6, 3)).getReal(), 1.0e-12); Assert.assertEquals(7.98595620686106654517199e-8, FieldVector3D.angle(createVector(1, 2, 3, 3), createVector(2, 4, 6.000001, 3)).getReal(), 1.0e-12); Assert.assertEquals(3.14159257373023116985197793156, FieldVector3D.angle(createVector(1, 2, 3, 3), createVector(-2, -4, -6.000001, 3)).getReal(), 1.0e-12); try { FieldVector3D.angle(createVector(0, 0, 0, 3), createVector(1, 0, 0, 3)); Assert.fail("an exception should have been thrown"); } catch (MathArithmeticException ae) { // expected behavior } } @Test public void testAccurateDotProduct() { // the following two vectors are nearly but not exactly orthogonal // naive dot product (i.e. computing u1.x * u2.x + u1.y * u2.y + u1.z * u2.z // leads to a result of 0.0, instead of the correct -1.855129... FieldVector3D<DerivativeStructure> u1 = createVector(-1321008684645961.0 / 268435456.0, -5774608829631843.0 / 268435456.0, -7645843051051357.0 / 8589934592.0, 3); FieldVector3D<DerivativeStructure> u2 = createVector(-5712344449280879.0 / 2097152.0, -4550117129121957.0 / 2097152.0, 8846951984510141.0 / 131072.0, 3); DerivativeStructure sNaive = u1.getX().multiply(u2.getX()).add(u1.getY().multiply(u2.getY())).add(u1.getZ().multiply(u2.getZ())); DerivativeStructure sAccurate = FieldVector3D.dotProduct(u1, u2); Assert.assertEquals(0.0, sNaive.getReal(), 1.0e-30); Assert.assertEquals(-2088690039198397.0 / 1125899906842624.0, sAccurate.getReal(), 1.0e-16); } @Test public void testDotProduct() { // we compare accurate versus naive dot product implementations // on regular vectors (i.e. not extreme cases like in the previous test) Well1024a random = new Well1024a(553267312521321234l); for (int i = 0; i < 10000; ++i) { double ux = 10000 * random.nextDouble(); double uy = 10000 * random.nextDouble(); double uz = 10000 * random.nextDouble(); double vx = 10000 * random.nextDouble(); double vy = 10000 * random.nextDouble(); double vz = 10000 * random.nextDouble(); double sNaive = ux * vx + uy * vy + uz * vz; FieldVector3D<DerivativeStructure> uds = createVector(ux, uy, uz, 3); FieldVector3D<DerivativeStructure> vds = createVector(vx, vy, vz, 3); Vector3D v = new Vector3D(vx, vy, vz); DerivativeStructure sAccurate = FieldVector3D.dotProduct(uds, vds); Assert.assertEquals(sNaive, sAccurate.getReal(), 2.5e-16 * sNaive); Assert.assertEquals(ux + vx, sAccurate.getPartialDerivative(1, 0, 0), 2.5e-16 * sNaive); Assert.assertEquals(uy + vy, sAccurate.getPartialDerivative(0, 1, 0), 2.5e-16 * sNaive); Assert.assertEquals(uz + vz, sAccurate.getPartialDerivative(0, 0, 1), 2.5e-16 * sNaive); sAccurate = FieldVector3D.dotProduct(uds, v); Assert.assertEquals(sNaive, sAccurate.getReal(), 2.5e-16 * sNaive); Assert.assertEquals(vx, sAccurate.getPartialDerivative(1, 0, 0), 2.5e-16 * sNaive); Assert.assertEquals(vy, sAccurate.getPartialDerivative(0, 1, 0), 2.5e-16 * sNaive); Assert.assertEquals(vz, sAccurate.getPartialDerivative(0, 0, 1), 2.5e-16 * sNaive); } } @Test public void testAccurateCrossProduct() { // the vectors u1 and u2 are nearly but not exactly anti-parallel // (7.31e-16 degrees from 180 degrees) naive cross product (i.e. // computing u1.x * u2.x + u1.y * u2.y + u1.z * u2.z // leads to a result of [0.0009765, -0.0001220, -0.0039062], // instead of the correct [0.0006913, -0.0001254, -0.0007909] final FieldVector3D<DerivativeStructure> u1 = createVector(-1321008684645961.0 / 268435456.0, -5774608829631843.0 / 268435456.0, -7645843051051357.0 / 8589934592.0, 3); final FieldVector3D<DerivativeStructure> u2 = createVector( 1796571811118507.0 / 2147483648.0, 7853468008299307.0 / 2147483648.0, 2599586637357461.0 / 17179869184.0, 3); final FieldVector3D<DerivativeStructure> u3 = createVector(12753243807587107.0 / 18446744073709551616.0, -2313766922703915.0 / 18446744073709551616.0, -227970081415313.0 / 288230376151711744.0, 3); FieldVector3D<DerivativeStructure> cNaive = new FieldVector3D<DerivativeStructure>(u1.getY().multiply(u2.getZ()).subtract(u1.getZ().multiply(u2.getY())), u1.getZ().multiply(u2.getX()).subtract(u1.getX().multiply(u2.getZ())), u1.getX().multiply(u2.getY()).subtract(u1.getY().multiply(u2.getX()))); FieldVector3D<DerivativeStructure> cAccurate = FieldVector3D.crossProduct(u1, u2); Assert.assertTrue(FieldVector3D.distance(u3, cNaive).getReal() > 2.9 * u3.getNorm().getReal()); Assert.assertEquals(0.0, FieldVector3D.distance(u3, cAccurate).getReal(), 1.0e-30 * cAccurate.getNorm().getReal()); } @Test public void testCrossProduct() { // we compare accurate versus naive cross product implementations // on regular vectors (i.e. not extreme cases like in the previous test) Well1024a random = new Well1024a(885362227452043214l); for (int i = 0; i < 10000; ++i) { double ux = random.nextDouble(); double uy = random.nextDouble(); double uz = random.nextDouble(); double vx = random.nextDouble(); double vy = random.nextDouble(); double vz = random.nextDouble(); Vector3D cNaive = new Vector3D(uy * vz - uz * vy, uz * vx - ux * vz, ux * vy - uy * vx); FieldVector3D<DerivativeStructure> uds = createVector(ux, uy, uz, 3); FieldVector3D<DerivativeStructure> vds = createVector(vx, vy, vz, 3); Vector3D v = new Vector3D(vx, vy, vz); checkVector(FieldVector3D.crossProduct(uds, vds), cNaive.getX(), cNaive.getY(), cNaive.getZ(), 0, vz - uz, uy - vy, uz - vz, 0, vx - ux, vy - uy, ux - vx, 0); checkVector(FieldVector3D.crossProduct(uds, v), cNaive.getX(), cNaive.getY(), cNaive.getZ(), 0, vz, -vy, -vz, 0, vx, vy, -vx, 0); } } private FieldVector3D<DerivativeStructure> createVector(double x, double y, double z, int params) { return new FieldVector3D<DerivativeStructure>(new DerivativeStructure(params, 1, 0, x), new DerivativeStructure(params, 1, 1, y), new DerivativeStructure(params, 1, 2, z)); } private void checkVector(FieldVector3D<DerivativeStructure> v, double x, double y, double z) { Assert.assertEquals(x, v.getX().getReal(), 1.0e-12); Assert.assertEquals(y, v.getY().getReal(), 1.0e-12); Assert.assertEquals(z, v.getZ().getReal(), 1.0e-12); } private void checkVector(FieldVector3D<DerivativeStructure> v, double x, double y, double z, double dxdx, double dxdy, double dxdz, double dydx, double dydy, double dydz, double dzdx, double dzdy, double dzdz) { Assert.assertEquals(x, v.getX().getReal(), 1.0e-12); Assert.assertEquals(y, v.getY().getReal(), 1.0e-12); Assert.assertEquals(z, v.getZ().getReal(), 1.0e-12); Assert.assertEquals(dxdx, v.getX().getPartialDerivative(1, 0, 0), 1.0e-12); Assert.assertEquals(dxdy, v.getX().getPartialDerivative(0, 1, 0), 1.0e-12); Assert.assertEquals(dxdz, v.getX().getPartialDerivative(0, 0, 1), 1.0e-12); Assert.assertEquals(dydx, v.getY().getPartialDerivative(1, 0, 0), 1.0e-12); Assert.assertEquals(dydy, v.getY().getPartialDerivative(0, 1, 0), 1.0e-12); Assert.assertEquals(dydz, v.getY().getPartialDerivative(0, 0, 1), 1.0e-12); Assert.assertEquals(dzdx, v.getZ().getPartialDerivative(1, 0, 0), 1.0e-12); Assert.assertEquals(dzdy, v.getZ().getPartialDerivative(0, 1, 0), 1.0e-12); Assert.assertEquals(dzdz, v.getZ().getPartialDerivative(0, 0, 1), 1.0e-12); } private void checkVector(FieldVector3D<DerivativeStructure> v, double x, double y, double z, double dxdx, double dxdy, double dxdz, double dxdt, double dydx, double dydy, double dydz, double dydt, double dzdx, double dzdy, double dzdz, double dzdt) { Assert.assertEquals(x, v.getX().getReal(), 1.0e-12); Assert.assertEquals(y, v.getY().getReal(), 1.0e-12); Assert.assertEquals(z, v.getZ().getReal(), 1.0e-12); Assert.assertEquals(dxdx, v.getX().getPartialDerivative(1, 0, 0, 0), 1.0e-12); Assert.assertEquals(dxdy, v.getX().getPartialDerivative(0, 1, 0, 0), 1.0e-12); Assert.assertEquals(dxdz, v.getX().getPartialDerivative(0, 0, 1, 0), 1.0e-12); Assert.assertEquals(dxdt, v.getX().getPartialDerivative(0, 0, 0, 1), 1.0e-12); Assert.assertEquals(dydx, v.getY().getPartialDerivative(1, 0, 0, 0), 1.0e-12); Assert.assertEquals(dydy, v.getY().getPartialDerivative(0, 1, 0, 0), 1.0e-12); Assert.assertEquals(dydz, v.getY().getPartialDerivative(0, 0, 1, 0), 1.0e-12); Assert.assertEquals(dydt, v.getY().getPartialDerivative(0, 0, 0, 1), 1.0e-12); Assert.assertEquals(dzdx, v.getZ().getPartialDerivative(1, 0, 0, 0), 1.0e-12); Assert.assertEquals(dzdy, v.getZ().getPartialDerivative(0, 1, 0, 0), 1.0e-12); Assert.assertEquals(dzdz, v.getZ().getPartialDerivative(0, 0, 1, 0), 1.0e-12); Assert.assertEquals(dzdt, v.getZ().getPartialDerivative(0, 0, 0, 1), 1.0e-12); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.geometry.euclidean.threed; import java.util.Locale; public class FrenchVector3DFormatTest extends Vector3DFormatAbstractTest { @Override protected char getDecimalCharacter() { return ','; } @Override protected Locale getLocale() { return Locale.FRENCH; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.geometry.euclidean.threed; import org.apache.commons.math3.exception.MathArithmeticException; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.geometry.euclidean.threed.Line; import org.apache.commons.math3.geometry.euclidean.threed.Vector3D; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class LineTest { @Test public void testContains() throws MathIllegalArgumentException, MathArithmeticException { Vector3D p1 = new Vector3D(0, 0, 1); Line l = new Line(p1, new Vector3D(0, 0, 2)); Assert.assertTrue(l.contains(p1)); Assert.assertTrue(l.contains(new Vector3D(1.0, p1, 0.3, l.getDirection()))); Vector3D u = l.getDirection().orthogonal(); Vector3D v = Vector3D.crossProduct(l.getDirection(), u); for (double alpha = 0; alpha < 2 * FastMath.PI; alpha += 0.3) { Assert.assertTrue(! l.contains(p1.add(new Vector3D(FastMath.cos(alpha), u, FastMath.sin(alpha), v)))); } } @Test public void testSimilar() throws MathIllegalArgumentException, MathArithmeticException { Vector3D p1 = new Vector3D (1.2, 3.4, -5.8); Vector3D p2 = new Vector3D (3.4, -5.8, 1.2); Line lA = new Line(p1, p2); Line lB = new Line(p2, p1); Assert.assertTrue(lA.isSimilarTo(lB)); Assert.assertTrue(! lA.isSimilarTo(new Line(p1, p1.add(lA.getDirection().orthogonal())))); } @Test public void testPointDistance() throws MathIllegalArgumentException { Line l = new Line(new Vector3D(0, 1, 1), new Vector3D(0, 2, 2)); Assert.assertEquals(FastMath.sqrt(3.0 / 2.0), l.distance(new Vector3D(1, 0, 1)), 1.0e-10); Assert.assertEquals(0, l.distance(new Vector3D(0, -4, -4)), 1.0e-10); } @Test public void testLineDistance() throws MathIllegalArgumentException { Line l = new Line(new Vector3D(0, 1, 1), new Vector3D(0, 2, 2)); Assert.assertEquals(1.0, l.distance(new Line(new Vector3D(1, 0, 1), new Vector3D(1, 0, 2))), 1.0e-10); Assert.assertEquals(0.5, l.distance(new Line(new Vector3D(-0.5, 0, 0), new Vector3D(-0.5, -1, -1))), 1.0e-10); Assert.assertEquals(0.0, l.distance(l), 1.0e-10); Assert.assertEquals(0.0, l.distance(new Line(new Vector3D(0, -4, -4), new Vector3D(0, -5, -5))), 1.0e-10); Assert.assertEquals(0.0, l.distance(new Line(new Vector3D(0, -4, -4), new Vector3D(0, -3, -4))), 1.0e-10); Assert.assertEquals(0.0, l.distance(new Line(new Vector3D(0, -4, -4), new Vector3D(1, -4, -4))), 1.0e-10); Assert.assertEquals(FastMath.sqrt(8), l.distance(new Line(new Vector3D(0, -4, 0), new Vector3D(1, -4, 0))), 1.0e-10); } @Test public void testClosest() throws MathIllegalArgumentException { Line l = new Line(new Vector3D(0, 1, 1), new Vector3D(0, 2, 2)); Assert.assertEquals(0.0, l.closestPoint(new Line(new Vector3D(1, 0, 1), new Vector3D(1, 0, 2))).distance(new Vector3D(0, 0, 0)), 1.0e-10); Assert.assertEquals(0.5, l.closestPoint(new Line(new Vector3D(-0.5, 0, 0), new Vector3D(-0.5, -1, -1))).distance(new Vector3D(-0.5, 0, 0)), 1.0e-10); Assert.assertEquals(0.0, l.closestPoint(l).distance(new Vector3D(0, 0, 0)), 1.0e-10); Assert.assertEquals(0.0, l.closestPoint(new Line(new Vector3D(0, -4, -4), new Vector3D(0, -5, -5))).distance(new Vector3D(0, 0, 0)), 1.0e-10); Assert.assertEquals(0.0, l.closestPoint(new Line(new Vector3D(0, -4, -4), new Vector3D(0, -3, -4))).distance(new Vector3D(0, -4, -4)), 1.0e-10); Assert.assertEquals(0.0, l.closestPoint(new Line(new Vector3D(0, -4, -4), new Vector3D(1, -4, -4))).distance(new Vector3D(0, -4, -4)), 1.0e-10); Assert.assertEquals(0.0, l.closestPoint(new Line(new Vector3D(0, -4, 0), new Vector3D(1, -4, 0))).distance(new Vector3D(0, -2, -2)), 1.0e-10); } @Test public void testIntersection() throws MathIllegalArgumentException { Line l = new Line(new Vector3D(0, 1, 1), new Vector3D(0, 2, 2)); Assert.assertNull(l.intersection(new Line(new Vector3D(1, 0, 1), new Vector3D(1, 0, 2)))); Assert.assertNull(l.intersection(new Line(new Vector3D(-0.5, 0, 0), new Vector3D(-0.5, -1, -1)))); Assert.assertEquals(0.0, l.intersection(l).distance(new Vector3D(0, 0, 0)), 1.0e-10); Assert.assertEquals(0.0, l.intersection(new Line(new Vector3D(0, -4, -4), new Vector3D(0, -5, -5))).distance(new Vector3D(0, 0, 0)), 1.0e-10); Assert.assertEquals(0.0, l.intersection(new Line(new Vector3D(0, -4, -4), new Vector3D(0, -3, -4))).distance(new Vector3D(0, -4, -4)), 1.0e-10); Assert.assertEquals(0.0, l.intersection(new Line(new Vector3D(0, -4, -4), new Vector3D(1, -4, -4))).distance(new Vector3D(0, -4, -4)), 1.0e-10); Assert.assertNull(l.intersection(new Line(new Vector3D(0, -4, 0), new Vector3D(1, -4, 0)))); } @Test public void testRevert() { // setup Line line = new Line(new Vector3D(1653345.6696423641, 6170370.041579291, 90000), new Vector3D(1650757.5050732433, 6160710.879908984, 0.9)); Vector3D expected = line.getDirection().negate(); // action Line reverted = line.revert(); // verify Assert.assertArrayEquals(expected.toArray(), reverted.getDirection().toArray(), 0); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.geometry.euclidean.threed; import org.apache.commons.math3.exception.MathArithmeticException; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.geometry.euclidean.threed.Line; import org.apache.commons.math3.geometry.euclidean.threed.Plane; import org.apache.commons.math3.geometry.euclidean.threed.Rotation; import org.apache.commons.math3.geometry.euclidean.threed.Vector3D; import org.junit.Assert; import org.junit.Test; public class PlaneTest { @Test public void testContains() throws MathArithmeticException { Plane p = new Plane(new Vector3D(0, 0, 1), new Vector3D(0, 0, 1)); Assert.assertTrue(p.contains(new Vector3D(0, 0, 1))); Assert.assertTrue(p.contains(new Vector3D(17, -32, 1))); Assert.assertTrue(! p.contains(new Vector3D(17, -32, 1.001))); } @Test public void testOffset() throws MathArithmeticException { Vector3D p1 = new Vector3D(1, 1, 1); Plane p = new Plane(p1, new Vector3D(0.2, 0, 0)); Assert.assertEquals(-5.0, p.getOffset(new Vector3D(-4, 0, 0)), 1.0e-10); Assert.assertEquals(+5.0, p.getOffset(new Vector3D(6, 10, -12)), 1.0e-10); Assert.assertEquals(0.3, p.getOffset(new Vector3D(1.0, p1, 0.3, p.getNormal())), 1.0e-10); Assert.assertEquals(-0.3, p.getOffset(new Vector3D(1.0, p1, -0.3, p.getNormal())), 1.0e-10); } @Test public void testPoint() throws MathArithmeticException { Plane p = new Plane(new Vector3D(2, -3, 1), new Vector3D(1, 4, 9)); Assert.assertTrue(p.contains(p.getOrigin())); } @Test public void testThreePoints() throws MathArithmeticException { Vector3D p1 = new Vector3D(1.2, 3.4, -5.8); Vector3D p2 = new Vector3D(3.4, -5.8, 1.2); Vector3D p3 = new Vector3D(-2.0, 4.3, 0.7); Plane p = new Plane(p1, p2, p3); Assert.assertTrue(p.contains(p1)); Assert.assertTrue(p.contains(p2)); Assert.assertTrue(p.contains(p3)); } @Test public void testRotate() throws MathArithmeticException, MathIllegalArgumentException { Vector3D p1 = new Vector3D(1.2, 3.4, -5.8); Vector3D p2 = new Vector3D(3.4, -5.8, 1.2); Vector3D p3 = new Vector3D(-2.0, 4.3, 0.7); Plane p = new Plane(p1, p2, p3); Vector3D oldNormal = p.getNormal(); p = p.rotate(p2, new Rotation(p2.subtract(p1), 1.7)); Assert.assertTrue(p.contains(p1)); Assert.assertTrue(p.contains(p2)); Assert.assertTrue(! p.contains(p3)); p = p.rotate(p2, new Rotation(oldNormal, 0.1)); Assert.assertTrue(! p.contains(p1)); Assert.assertTrue(p.contains(p2)); Assert.assertTrue(! p.contains(p3)); p = p.rotate(p1, new Rotation(oldNormal, 0.1)); Assert.assertTrue(! p.contains(p1)); Assert.assertTrue(! p.contains(p2)); Assert.assertTrue(! p.contains(p3)); } @Test public void testTranslate() throws MathArithmeticException { Vector3D p1 = new Vector3D(1.2, 3.4, -5.8); Vector3D p2 = new Vector3D(3.4, -5.8, 1.2); Vector3D p3 = new Vector3D(-2.0, 4.3, 0.7); Plane p = new Plane(p1, p2, p3); p = p.translate(new Vector3D(2.0, p.getU(), -1.5, p.getV())); Assert.assertTrue(p.contains(p1)); Assert.assertTrue(p.contains(p2)); Assert.assertTrue(p.contains(p3)); p = p.translate(new Vector3D(-1.2, p.getNormal())); Assert.assertTrue(! p.contains(p1)); Assert.assertTrue(! p.contains(p2)); Assert.assertTrue(! p.contains(p3)); p = p.translate(new Vector3D(+1.2, p.getNormal())); Assert.assertTrue(p.contains(p1)); Assert.assertTrue(p.contains(p2)); Assert.assertTrue(p.contains(p3)); } @Test public void testIntersection() throws MathArithmeticException, MathIllegalArgumentException { Plane p = new Plane(new Vector3D(1, 2, 3), new Vector3D(-4, 1, -5)); Line l = new Line(new Vector3D(0.2, -3.5, 0.7), new Vector3D(1.2, -2.5, -0.3)); Vector3D point = p.intersection(l); Assert.assertTrue(p.contains(point)); Assert.assertTrue(l.contains(point)); Assert.assertNull(p.intersection(new Line(new Vector3D(10, 10, 10), new Vector3D(10, 10, 10).add(p.getNormal().orthogonal())))); } @Test public void testIntersection2() throws MathArithmeticException { Vector3D p1 = new Vector3D (1.2, 3.4, -5.8); Vector3D p2 = new Vector3D (3.4, -5.8, 1.2); Plane pA = new Plane(p1, p2, new Vector3D (-2.0, 4.3, 0.7)); Plane pB = new Plane(p1, new Vector3D (11.4, -3.8, 5.1), p2); Line l = pA.intersection(pB); Assert.assertTrue(l.contains(p1)); Assert.assertTrue(l.contains(p2)); Assert.assertNull(pA.intersection(pA)); } @Test public void testIntersection3() throws MathArithmeticException { Vector3D reference = new Vector3D (1.2, 3.4, -5.8); Plane p1 = new Plane(reference, new Vector3D(1, 3, 3)); Plane p2 = new Plane(reference, new Vector3D(-2, 4, 0)); Plane p3 = new Plane(reference, new Vector3D(7, 0, -4)); Vector3D p = Plane.intersection(p1, p2, p3); Assert.assertEquals(reference.getX(), p.getX(), 1.0e-10); Assert.assertEquals(reference.getY(), p.getY(), 1.0e-10); Assert.assertEquals(reference.getZ(), p.getZ(), 1.0e-10); } @Test public void testSimilar() throws MathArithmeticException { Vector3D p1 = new Vector3D (1.2, 3.4, -5.8); Vector3D p2 = new Vector3D (3.4, -5.8, 1.2); Vector3D p3 = new Vector3D (-2.0, 4.3, 0.7); Plane pA = new Plane(p1, p2, p3); Plane pB = new Plane(p1, new Vector3D (11.4, -3.8, 5.1), p2); Assert.assertTrue(! pA.isSimilarTo(pB)); Assert.assertTrue(pA.isSimilarTo(pA)); Assert.assertTrue(pA.isSimilarTo(new Plane(p1, p3, p2))); Vector3D shift = new Vector3D(0.3, pA.getNormal()); Assert.assertTrue(! pA.isSimilarTo(new Plane(p1.add(shift), p3.add(shift), p2.add(shift)))); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.geometry.euclidean.threed; import java.util.ArrayList; import org.apache.commons.math3.exception.MathArithmeticException; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.geometry.euclidean.twod.Euclidean2D; import org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet; import org.apache.commons.math3.geometry.euclidean.twod.SubLine; import org.apache.commons.math3.geometry.euclidean.twod.Vector2D; import org.apache.commons.math3.geometry.partitioning.BSPTree; import org.apache.commons.math3.geometry.partitioning.BSPTreeVisitor; import org.apache.commons.math3.geometry.partitioning.BoundaryAttribute; import org.apache.commons.math3.geometry.partitioning.Region; import org.apache.commons.math3.geometry.partitioning.RegionFactory; import org.apache.commons.math3.geometry.partitioning.SubHyperplane; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class PolyhedronsSetTest { @Test public void testBox() { PolyhedronsSet tree = new PolyhedronsSet(0, 1, 0, 1, 0, 1); Assert.assertEquals(1.0, tree.getSize(), 1.0e-10); Assert.assertEquals(6.0, tree.getBoundarySize(), 1.0e-10); Vector3D barycenter = (Vector3D) tree.getBarycenter(); Assert.assertEquals(0.5, barycenter.getX(), 1.0e-10); Assert.assertEquals(0.5, barycenter.getY(), 1.0e-10); Assert.assertEquals(0.5, barycenter.getZ(), 1.0e-10); for (double x = -0.25; x < 1.25; x += 0.1) { boolean xOK = (x >= 0.0) && (x <= 1.0); for (double y = -0.25; y < 1.25; y += 0.1) { boolean yOK = (y >= 0.0) && (y <= 1.0); for (double z = -0.25; z < 1.25; z += 0.1) { boolean zOK = (z >= 0.0) && (z <= 1.0); Region.Location expected = (xOK && yOK && zOK) ? Region.Location.INSIDE : Region.Location.OUTSIDE; Assert.assertEquals(expected, tree.checkPoint(new Vector3D(x, y, z))); } } } checkPoints(Region.Location.BOUNDARY, tree, new Vector3D[] { new Vector3D(0.0, 0.5, 0.5), new Vector3D(1.0, 0.5, 0.5), new Vector3D(0.5, 0.0, 0.5), new Vector3D(0.5, 1.0, 0.5), new Vector3D(0.5, 0.5, 0.0), new Vector3D(0.5, 0.5, 1.0) }); checkPoints(Region.Location.OUTSIDE, tree, new Vector3D[] { new Vector3D(0.0, 1.2, 1.2), new Vector3D(1.0, 1.2, 1.2), new Vector3D(1.2, 0.0, 1.2), new Vector3D(1.2, 1.0, 1.2), new Vector3D(1.2, 1.2, 0.0), new Vector3D(1.2, 1.2, 1.0) }); } @Test public void testTetrahedron() throws MathArithmeticException { Vector3D vertex1 = new Vector3D(1, 2, 3); Vector3D vertex2 = new Vector3D(2, 2, 4); Vector3D vertex3 = new Vector3D(2, 3, 3); Vector3D vertex4 = new Vector3D(1, 3, 4); @SuppressWarnings("unchecked") PolyhedronsSet tree = (PolyhedronsSet) new RegionFactory<Euclidean3D>().buildConvex( new Plane(vertex3, vertex2, vertex1), new Plane(vertex2, vertex3, vertex4), new Plane(vertex4, vertex3, vertex1), new Plane(vertex1, vertex2, vertex4)); Assert.assertEquals(1.0 / 3.0, tree.getSize(), 1.0e-10); Assert.assertEquals(2.0 * FastMath.sqrt(3.0), tree.getBoundarySize(), 1.0e-10); Vector3D barycenter = (Vector3D) tree.getBarycenter(); Assert.assertEquals(1.5, barycenter.getX(), 1.0e-10); Assert.assertEquals(2.5, barycenter.getY(), 1.0e-10); Assert.assertEquals(3.5, barycenter.getZ(), 1.0e-10); double third = 1.0 / 3.0; checkPoints(Region.Location.BOUNDARY, tree, new Vector3D[] { vertex1, vertex2, vertex3, vertex4, new Vector3D(third, vertex1, third, vertex2, third, vertex3), new Vector3D(third, vertex2, third, vertex3, third, vertex4), new Vector3D(third, vertex3, third, vertex4, third, vertex1), new Vector3D(third, vertex4, third, vertex1, third, vertex2) }); checkPoints(Region.Location.OUTSIDE, tree, new Vector3D[] { new Vector3D(1, 2, 4), new Vector3D(2, 2, 3), new Vector3D(2, 3, 4), new Vector3D(1, 3, 3) }); } @Test public void testIsometry() throws MathArithmeticException, MathIllegalArgumentException { Vector3D vertex1 = new Vector3D(1.1, 2.2, 3.3); Vector3D vertex2 = new Vector3D(2.0, 2.4, 4.2); Vector3D vertex3 = new Vector3D(2.8, 3.3, 3.7); Vector3D vertex4 = new Vector3D(1.0, 3.6, 4.5); @SuppressWarnings("unchecked") PolyhedronsSet tree = (PolyhedronsSet) new RegionFactory<Euclidean3D>().buildConvex( new Plane(vertex3, vertex2, vertex1), new Plane(vertex2, vertex3, vertex4), new Plane(vertex4, vertex3, vertex1), new Plane(vertex1, vertex2, vertex4)); Vector3D barycenter = (Vector3D) tree.getBarycenter(); Vector3D s = new Vector3D(10.2, 4.3, -6.7); Vector3D c = new Vector3D(-0.2, 2.1, -3.2); Rotation r = new Rotation(new Vector3D(6.2, -4.4, 2.1), 0.12); tree = tree.rotate(c, r).translate(s); Vector3D newB = new Vector3D(1.0, s, 1.0, c, 1.0, r.applyTo(barycenter.subtract(c))); Assert.assertEquals(0.0, newB.subtract(tree.getBarycenter()).getNorm(), 1.0e-10); final Vector3D[] expectedV = new Vector3D[] { new Vector3D(1.0, s, 1.0, c, 1.0, r.applyTo(vertex1.subtract(c))), new Vector3D(1.0, s, 1.0, c, 1.0, r.applyTo(vertex2.subtract(c))), new Vector3D(1.0, s, 1.0, c, 1.0, r.applyTo(vertex3.subtract(c))), new Vector3D(1.0, s, 1.0, c, 1.0, r.applyTo(vertex4.subtract(c))) }; tree.getTree(true).visit(new BSPTreeVisitor<Euclidean3D>() { public Order visitOrder(BSPTree<Euclidean3D> node) { return Order.MINUS_SUB_PLUS; } public void visitInternalNode(BSPTree<Euclidean3D> node) { @SuppressWarnings("unchecked") BoundaryAttribute<Euclidean3D> attribute = (BoundaryAttribute<Euclidean3D>) node.getAttribute(); if (attribute.getPlusOutside() != null) { checkFacet((SubPlane) attribute.getPlusOutside()); } if (attribute.getPlusInside() != null) { checkFacet((SubPlane) attribute.getPlusInside()); } } public void visitLeafNode(BSPTree<Euclidean3D> node) { } private void checkFacet(SubPlane facet) { Plane plane = (Plane) facet.getHyperplane(); Vector2D[][] vertices = ((PolygonsSet) facet.getRemainingRegion()).getVertices(); Assert.assertEquals(1, vertices.length); for (int i = 0; i < vertices[0].length; ++i) { Vector3D v = plane.toSpace(vertices[0][i]); double d = Double.POSITIVE_INFINITY; for (int k = 0; k < expectedV.length; ++k) { d = FastMath.min(d, v.subtract(expectedV[k]).getNorm()); } Assert.assertEquals(0, d, 1.0e-10); } } }); } @Test public void testBuildBox() { double x = 1.0; double y = 2.0; double z = 3.0; double w = 0.1; double l = 1.0; PolyhedronsSet tree = new PolyhedronsSet(x - l, x + l, y - w, y + w, z - w, z + w); Vector3D barycenter = (Vector3D) tree.getBarycenter(); Assert.assertEquals(x, barycenter.getX(), 1.0e-10); Assert.assertEquals(y, barycenter.getY(), 1.0e-10); Assert.assertEquals(z, barycenter.getZ(), 1.0e-10); Assert.assertEquals(8 * l * w * w, tree.getSize(), 1.0e-10); Assert.assertEquals(8 * w * (2 * l + w), tree.getBoundarySize(), 1.0e-10); } @Test public void testCross() { double x = 1.0; double y = 2.0; double z = 3.0; double w = 0.1; double l = 1.0; PolyhedronsSet xBeam = new PolyhedronsSet(x - l, x + l, y - w, y + w, z - w, z + w); PolyhedronsSet yBeam = new PolyhedronsSet(x - w, x + w, y - l, y + l, z - w, z + w); PolyhedronsSet zBeam = new PolyhedronsSet(x - w, x + w, y - w, y + w, z - l, z + l); RegionFactory<Euclidean3D> factory = new RegionFactory<Euclidean3D>(); PolyhedronsSet tree = (PolyhedronsSet) factory.union(xBeam, factory.union(yBeam, zBeam)); Vector3D barycenter = (Vector3D) tree.getBarycenter(); Assert.assertEquals(x, barycenter.getX(), 1.0e-10); Assert.assertEquals(y, barycenter.getY(), 1.0e-10); Assert.assertEquals(z, barycenter.getZ(), 1.0e-10); Assert.assertEquals(8 * w * w * (3 * l - 2 * w), tree.getSize(), 1.0e-10); Assert.assertEquals(24 * w * (2 * l - w), tree.getBoundarySize(), 1.0e-10); } @Test public void testIssue780() throws MathArithmeticException { float[] coords = { 1.000000f, -1.000000f, -1.000000f, 1.000000f, -1.000000f, 1.000000f, -1.000000f, -1.000000f, 1.000000f, -1.000000f, -1.000000f, -1.000000f, 1.000000f, 1.000000f, -1f, 0.999999f, 1.000000f, 1.000000f, // 1.000000f, 1.000000f, 1.000000f, -1.000000f, 1.000000f, 1.000000f, -1.000000f, 1.000000f, -1.000000f}; int[] indices = { 0, 1, 2, 0, 2, 3, 4, 7, 6, 4, 6, 5, 0, 4, 5, 0, 5, 1, 1, 5, 6, 1, 6, 2, 2, 6, 7, 2, 7, 3, 4, 0, 3, 4, 3, 7}; ArrayList<SubHyperplane<Euclidean3D>> subHyperplaneList = new ArrayList<SubHyperplane<Euclidean3D>>(); for (int idx = 0; idx < indices.length; idx += 3) { int idxA = indices[idx] * 3; int idxB = indices[idx + 1] * 3; int idxC = indices[idx + 2] * 3; Vector3D v_1 = new Vector3D(coords[idxA], coords[idxA + 1], coords[idxA + 2]); Vector3D v_2 = new Vector3D(coords[idxB], coords[idxB + 1], coords[idxB + 2]); Vector3D v_3 = new Vector3D(coords[idxC], coords[idxC + 1], coords[idxC + 2]); Vector3D[] vertices = {v_1, v_2, v_3}; Plane polyPlane = new Plane(v_1, v_2, v_3); ArrayList<SubHyperplane<Euclidean2D>> lines = new ArrayList<SubHyperplane<Euclidean2D>>(); Vector2D[] projPts = new Vector2D[vertices.length]; for (int ptIdx = 0; ptIdx < projPts.length; ptIdx++) { projPts[ptIdx] = polyPlane.toSubSpace(vertices[ptIdx]); } SubLine lineInPlane = null; for (int ptIdx = 0; ptIdx < projPts.length; ptIdx++) { lineInPlane = new SubLine(projPts[ptIdx], projPts[(ptIdx + 1) % projPts.length]); lines.add(lineInPlane); } Region<Euclidean2D> polyRegion = new PolygonsSet(lines); SubPlane polygon = new SubPlane(polyPlane, polyRegion); subHyperplaneList.add(polygon); } PolyhedronsSet polyhedronsSet = new PolyhedronsSet(subHyperplaneList); Assert.assertEquals( 8.0, polyhedronsSet.getSize(), 3.0e-6); Assert.assertEquals(24.0, polyhedronsSet.getBoundarySize(), 5.0e-6); } private void checkPoints(Region.Location expected, PolyhedronsSet tree, Vector3D[] points) { for (int i = 0; i < points.length; ++i) { Assert.assertEquals(expected, tree.checkPoint(points[i])); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.geometry.euclidean.threed; import org.apache.commons.math3.exception.MathArithmeticException; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.util.MathUtils; import org.junit.Assert; import org.junit.Test; public class RotationTest { @Test public void testIdentity() { Rotation r = Rotation.IDENTITY; checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I); checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J); checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K); checkAngle(r.getAngle(), 0); r = new Rotation(-1, 0, 0, 0, false); checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I); checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J); checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K); checkAngle(r.getAngle(), 0); r = new Rotation(42, 0, 0, 0, true); checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I); checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J); checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K); checkAngle(r.getAngle(), 0); } @Test public void testAxisAngle() throws MathIllegalArgumentException { Rotation r = new Rotation(new Vector3D(10, 10, 10), 2 * FastMath.PI / 3); checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_J); checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_K); checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_I); double s = 1 / FastMath.sqrt(3); checkVector(r.getAxis(), new Vector3D(s, s, s)); checkAngle(r.getAngle(), 2 * FastMath.PI / 3); try { new Rotation(new Vector3D(0, 0, 0), 2 * FastMath.PI / 3); Assert.fail("an exception should have been thrown"); } catch (MathIllegalArgumentException e) { } r = new Rotation(Vector3D.PLUS_K, 1.5 * FastMath.PI); checkVector(r.getAxis(), new Vector3D(0, 0, -1)); checkAngle(r.getAngle(), 0.5 * FastMath.PI); r = new Rotation(Vector3D.PLUS_J, FastMath.PI); checkVector(r.getAxis(), Vector3D.PLUS_J); checkAngle(r.getAngle(), FastMath.PI); checkVector(Rotation.IDENTITY.getAxis(), Vector3D.PLUS_I); } @Test public void testRevert() { Rotation r = new Rotation(0.001, 0.36, 0.48, 0.8, true); Rotation reverted = r.revert(); checkRotation(r.applyTo(reverted), 1, 0, 0, 0); checkRotation(reverted.applyTo(r), 1, 0, 0, 0); Assert.assertEquals(r.getAngle(), reverted.getAngle(), 1.0e-12); Assert.assertEquals(-1, Vector3D.dotProduct(r.getAxis(), reverted.getAxis()), 1.0e-12); } @Test public void testVectorOnePair() throws MathArithmeticException { Vector3D u = new Vector3D(3, 2, 1); Vector3D v = new Vector3D(-4, 2, 2); Rotation r = new Rotation(u, v); checkVector(r.applyTo(u.scalarMultiply(v.getNorm())), v.scalarMultiply(u.getNorm())); checkAngle(new Rotation(u, u.negate()).getAngle(), FastMath.PI); try { new Rotation(u, Vector3D.ZERO); Assert.fail("an exception should have been thrown"); } catch (MathArithmeticException e) { // expected behavior } } @Test public void testVectorTwoPairs() throws MathArithmeticException { Vector3D u1 = new Vector3D(3, 0, 0); Vector3D u2 = new Vector3D(0, 5, 0); Vector3D v1 = new Vector3D(0, 0, 2); Vector3D v2 = new Vector3D(-2, 0, 2); Rotation r = new Rotation(u1, u2, v1, v2); checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_K); checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.MINUS_I); r = new Rotation(u1, u2, u1.negate(), u2.negate()); Vector3D axis = r.getAxis(); if (Vector3D.dotProduct(axis, Vector3D.PLUS_K) > 0) { checkVector(axis, Vector3D.PLUS_K); } else { checkVector(axis, Vector3D.MINUS_K); } checkAngle(r.getAngle(), FastMath.PI); double sqrt = FastMath.sqrt(2) / 2; r = new Rotation(Vector3D.PLUS_I, Vector3D.PLUS_J, new Vector3D(0.5, 0.5, sqrt), new Vector3D(0.5, 0.5, -sqrt)); checkRotation(r, sqrt, 0.5, 0.5, 0); r = new Rotation(u1, u2, u1, Vector3D.crossProduct(u1, u2)); checkRotation(r, sqrt, -sqrt, 0, 0); checkRotation(new Rotation(u1, u2, u1, u2), 1, 0, 0, 0); try { new Rotation(u1, u2, Vector3D.ZERO, v2); Assert.fail("an exception should have been thrown"); } catch (MathArithmeticException e) { // expected behavior } } @Test public void testMatrix() throws NotARotationMatrixException { try { new Rotation(new double[][] { { 0.0, 1.0, 0.0 }, { 1.0, 0.0, 0.0 } }, 1.0e-7); Assert.fail("Expecting NotARotationMatrixException"); } catch (NotARotationMatrixException nrme) { // expected behavior } try { new Rotation(new double[][] { { 0.445888, 0.797184, -0.407040 }, { 0.821760, -0.184320, 0.539200 }, { -0.354816, 0.574912, 0.737280 } }, 1.0e-7); Assert.fail("Expecting NotARotationMatrixException"); } catch (NotARotationMatrixException nrme) { // expected behavior } try { new Rotation(new double[][] { { 0.4, 0.8, -0.4 }, { -0.4, 0.6, 0.7 }, { 0.8, -0.2, 0.5 } }, 1.0e-15); Assert.fail("Expecting NotARotationMatrixException"); } catch (NotARotationMatrixException nrme) { // expected behavior } checkRotation(new Rotation(new double[][] { { 0.445888, 0.797184, -0.407040 }, { -0.354816, 0.574912, 0.737280 }, { 0.821760, -0.184320, 0.539200 } }, 1.0e-10), 0.8, 0.288, 0.384, 0.36); checkRotation(new Rotation(new double[][] { { 0.539200, 0.737280, 0.407040 }, { 0.184320, -0.574912, 0.797184 }, { 0.821760, -0.354816, -0.445888 } }, 1.0e-10), 0.36, 0.8, 0.288, 0.384); checkRotation(new Rotation(new double[][] { { -0.445888, 0.797184, -0.407040 }, { 0.354816, 0.574912, 0.737280 }, { 0.821760, 0.184320, -0.539200 } }, 1.0e-10), 0.384, 0.36, 0.8, 0.288); checkRotation(new Rotation(new double[][] { { -0.539200, 0.737280, 0.407040 }, { -0.184320, -0.574912, 0.797184 }, { 0.821760, 0.354816, 0.445888 } }, 1.0e-10), 0.288, 0.384, 0.36, 0.8); double[][] m1 = { { 0.0, 1.0, 0.0 }, { 0.0, 0.0, 1.0 }, { 1.0, 0.0, 0.0 } }; Rotation r = new Rotation(m1, 1.0e-7); checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_K); checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_I); checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_J); double[][] m2 = { { 0.83203, -0.55012, -0.07139 }, { 0.48293, 0.78164, -0.39474 }, { 0.27296, 0.29396, 0.91602 } }; r = new Rotation(m2, 1.0e-12); double[][] m3 = r.getMatrix(); double d00 = m2[0][0] - m3[0][0]; double d01 = m2[0][1] - m3[0][1]; double d02 = m2[0][2] - m3[0][2]; double d10 = m2[1][0] - m3[1][0]; double d11 = m2[1][1] - m3[1][1]; double d12 = m2[1][2] - m3[1][2]; double d20 = m2[2][0] - m3[2][0]; double d21 = m2[2][1] - m3[2][1]; double d22 = m2[2][2] - m3[2][2]; Assert.assertTrue(FastMath.abs(d00) < 6.0e-6); Assert.assertTrue(FastMath.abs(d01) < 6.0e-6); Assert.assertTrue(FastMath.abs(d02) < 6.0e-6); Assert.assertTrue(FastMath.abs(d10) < 6.0e-6); Assert.assertTrue(FastMath.abs(d11) < 6.0e-6); Assert.assertTrue(FastMath.abs(d12) < 6.0e-6); Assert.assertTrue(FastMath.abs(d20) < 6.0e-6); Assert.assertTrue(FastMath.abs(d21) < 6.0e-6); Assert.assertTrue(FastMath.abs(d22) < 6.0e-6); Assert.assertTrue(FastMath.abs(d00) > 4.0e-7); Assert.assertTrue(FastMath.abs(d01) > 4.0e-7); Assert.assertTrue(FastMath.abs(d02) > 4.0e-7); Assert.assertTrue(FastMath.abs(d10) > 4.0e-7); Assert.assertTrue(FastMath.abs(d11) > 4.0e-7); Assert.assertTrue(FastMath.abs(d12) > 4.0e-7); Assert.assertTrue(FastMath.abs(d20) > 4.0e-7); Assert.assertTrue(FastMath.abs(d21) > 4.0e-7); Assert.assertTrue(FastMath.abs(d22) > 4.0e-7); for (int i = 0; i < 3; ++i) { for (int j = 0; j < 3; ++j) { double m3tm3 = m3[i][0] * m3[j][0] + m3[i][1] * m3[j][1] + m3[i][2] * m3[j][2]; if (i == j) { Assert.assertTrue(FastMath.abs(m3tm3 - 1.0) < 1.0e-10); } else { Assert.assertTrue(FastMath.abs(m3tm3) < 1.0e-10); } } } checkVector(r.applyTo(Vector3D.PLUS_I), new Vector3D(m3[0][0], m3[1][0], m3[2][0])); checkVector(r.applyTo(Vector3D.PLUS_J), new Vector3D(m3[0][1], m3[1][1], m3[2][1])); checkVector(r.applyTo(Vector3D.PLUS_K), new Vector3D(m3[0][2], m3[1][2], m3[2][2])); double[][] m4 = { { 1.0, 0.0, 0.0 }, { 0.0, -1.0, 0.0 }, { 0.0, 0.0, -1.0 } }; r = new Rotation(m4, 1.0e-7); checkAngle(r.getAngle(), FastMath.PI); try { double[][] m5 = { { 0.0, 0.0, 1.0 }, { 0.0, 1.0, 0.0 }, { 1.0, 0.0, 0.0 } }; r = new Rotation(m5, 1.0e-7); Assert.fail("got " + r + ", should have caught an exception"); } catch (NotARotationMatrixException e) { // expected } } @Test public void testAngles() throws CardanEulerSingularityException { RotationOrder[] CardanOrders = { RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ, RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX }; for (int i = 0; i < CardanOrders.length; ++i) { for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) { for (double alpha2 = -1.55; alpha2 < 1.55; alpha2 += 0.3) { for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) { Rotation r = new Rotation(CardanOrders[i], alpha1, alpha2, alpha3); double[] angles = r.getAngles(CardanOrders[i]); checkAngle(angles[0], alpha1); checkAngle(angles[1], alpha2); checkAngle(angles[2], alpha3); } } } } RotationOrder[] EulerOrders = { RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY, RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ }; for (int i = 0; i < EulerOrders.length; ++i) { for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) { for (double alpha2 = 0.05; alpha2 < 3.1; alpha2 += 0.3) { for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) { Rotation r = new Rotation(EulerOrders[i], alpha1, alpha2, alpha3); double[] angles = r.getAngles(EulerOrders[i]); checkAngle(angles[0], alpha1); checkAngle(angles[1], alpha2); checkAngle(angles[2], alpha3); } } } } } @Test public void testSingularities() { RotationOrder[] CardanOrders = { RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ, RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX }; double[] singularCardanAngle = { FastMath.PI / 2, -FastMath.PI / 2 }; for (int i = 0; i < CardanOrders.length; ++i) { for (int j = 0; j < singularCardanAngle.length; ++j) { Rotation r = new Rotation(CardanOrders[i], 0.1, singularCardanAngle[j], 0.3); try { r.getAngles(CardanOrders[i]); Assert.fail("an exception should have been caught"); } catch (CardanEulerSingularityException cese) { // expected behavior } } } RotationOrder[] EulerOrders = { RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY, RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ }; double[] singularEulerAngle = { 0, FastMath.PI }; for (int i = 0; i < EulerOrders.length; ++i) { for (int j = 0; j < singularEulerAngle.length; ++j) { Rotation r = new Rotation(EulerOrders[i], 0.1, singularEulerAngle[j], 0.3); try { r.getAngles(EulerOrders[i]); Assert.fail("an exception should have been caught"); } catch (CardanEulerSingularityException cese) { // expected behavior } } } } @Test public void testQuaternion() throws MathIllegalArgumentException { Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7); double n = 23.5; Rotation r2 = new Rotation(n * r1.getQ0(), n * r1.getQ1(), n * r1.getQ2(), n * r1.getQ3(), true); for (double x = -0.9; x < 0.9; x += 0.2) { for (double y = -0.9; y < 0.9; y += 0.2) { for (double z = -0.9; z < 0.9; z += 0.2) { Vector3D u = new Vector3D(x, y, z); checkVector(r2.applyTo(u), r1.applyTo(u)); } } } r1 = new Rotation( 0.288, 0.384, 0.36, 0.8, false); checkRotation(r1, -r1.getQ0(), -r1.getQ1(), -r1.getQ2(), -r1.getQ3()); } @Test public void testCompose() throws MathIllegalArgumentException { Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7); Rotation r2 = new Rotation(new Vector3D(-1, 3, 2), 0.3); Rotation r3 = r2.applyTo(r1); for (double x = -0.9; x < 0.9; x += 0.2) { for (double y = -0.9; y < 0.9; y += 0.2) { for (double z = -0.9; z < 0.9; z += 0.2) { Vector3D u = new Vector3D(x, y, z); checkVector(r2.applyTo(r1.applyTo(u)), r3.applyTo(u)); } } } } @Test public void testComposeInverse() throws MathIllegalArgumentException { Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7); Rotation r2 = new Rotation(new Vector3D(-1, 3, 2), 0.3); Rotation r3 = r2.applyInverseTo(r1); for (double x = -0.9; x < 0.9; x += 0.2) { for (double y = -0.9; y < 0.9; y += 0.2) { for (double z = -0.9; z < 0.9; z += 0.2) { Vector3D u = new Vector3D(x, y, z); checkVector(r2.applyInverseTo(r1.applyTo(u)), r3.applyTo(u)); } } } } @Test public void testArray() throws MathIllegalArgumentException { Rotation r = new Rotation(new Vector3D(2, -3, 5), 1.7); for (double x = -0.9; x < 0.9; x += 0.2) { for (double y = -0.9; y < 0.9; y += 0.2) { for (double z = -0.9; z < 0.9; z += 0.2) { Vector3D u = new Vector3D(x, y, z); Vector3D v = r.applyTo(u); double[] inOut = new double[] { x, y, z }; r.applyTo(inOut, inOut); Assert.assertEquals(v.getX(), inOut[0], 1.0e-10); Assert.assertEquals(v.getY(), inOut[1], 1.0e-10); Assert.assertEquals(v.getZ(), inOut[2], 1.0e-10); r.applyInverseTo(inOut, inOut); Assert.assertEquals(u.getX(), inOut[0], 1.0e-10); Assert.assertEquals(u.getY(), inOut[1], 1.0e-10); Assert.assertEquals(u.getZ(), inOut[2], 1.0e-10); } } } } @Test public void testApplyInverseTo() throws MathIllegalArgumentException { Rotation r = new Rotation(new Vector3D(2, -3, 5), 1.7); for (double lambda = 0; lambda < 6.2; lambda += 0.2) { for (double phi = -1.55; phi < 1.55; phi += 0.2) { Vector3D u = new Vector3D(FastMath.cos(lambda) * FastMath.cos(phi), FastMath.sin(lambda) * FastMath.cos(phi), FastMath.sin(phi)); r.applyInverseTo(r.applyTo(u)); checkVector(u, r.applyInverseTo(r.applyTo(u))); checkVector(u, r.applyTo(r.applyInverseTo(u))); } } r = Rotation.IDENTITY; for (double lambda = 0; lambda < 6.2; lambda += 0.2) { for (double phi = -1.55; phi < 1.55; phi += 0.2) { Vector3D u = new Vector3D(FastMath.cos(lambda) * FastMath.cos(phi), FastMath.sin(lambda) * FastMath.cos(phi), FastMath.sin(phi)); checkVector(u, r.applyInverseTo(r.applyTo(u))); checkVector(u, r.applyTo(r.applyInverseTo(u))); } } r = new Rotation(Vector3D.PLUS_K, FastMath.PI); for (double lambda = 0; lambda < 6.2; lambda += 0.2) { for (double phi = -1.55; phi < 1.55; phi += 0.2) { Vector3D u = new Vector3D(FastMath.cos(lambda) * FastMath.cos(phi), FastMath.sin(lambda) * FastMath.cos(phi), FastMath.sin(phi)); checkVector(u, r.applyInverseTo(r.applyTo(u))); checkVector(u, r.applyTo(r.applyInverseTo(u))); } } } @Test public void testIssue639() throws MathArithmeticException{ Vector3D u1 = new Vector3D(-1321008684645961.0 / 268435456.0, -5774608829631843.0 / 268435456.0, -3822921525525679.0 / 4294967296.0); Vector3D u2 =new Vector3D( -5712344449280879.0 / 2097152.0, -2275058564560979.0 / 1048576.0, 4423475992255071.0 / 65536.0); Rotation rot = new Rotation(u1, u2, Vector3D.PLUS_I,Vector3D.PLUS_K); Assert.assertEquals( 0.6228370359608200639829222, rot.getQ0(), 1.0e-15); Assert.assertEquals( 0.0257707621456498790029987, rot.getQ1(), 1.0e-15); Assert.assertEquals(-0.0000000002503012255839931, rot.getQ2(), 1.0e-15); Assert.assertEquals(-0.7819270390861109450724902, rot.getQ3(), 1.0e-15); } @Test public void testIssue801() throws MathArithmeticException { Vector3D u1 = new Vector3D(0.9999988431610581, -0.0015210774290851095, 0.0); Vector3D u2 = new Vector3D(0.0, 0.0, 1.0); Vector3D v1 = new Vector3D(0.9999999999999999, 0.0, 0.0); Vector3D v2 = new Vector3D(0.0, 0.0, -1.0); Rotation quat = new Rotation(u1, u2, v1, v2); double q2 = quat.getQ0() * quat.getQ0() + quat.getQ1() * quat.getQ1() + quat.getQ2() * quat.getQ2() + quat.getQ3() * quat.getQ3(); Assert.assertEquals(1.0, q2, 1.0e-14); Assert.assertEquals(0.0, Vector3D.angle(v1, quat.applyTo(u1)), 1.0e-14); Assert.assertEquals(0.0, Vector3D.angle(v2, quat.applyTo(u2)), 1.0e-14); } private void checkVector(Vector3D v1, Vector3D v2) { Assert.assertTrue(v1.subtract(v2).getNorm() < 1.0e-10); } private void checkAngle(double a1, double a2) { Assert.assertEquals(a1, MathUtils.normalizeAngle(a2, a1), 1.0e-10); } private void checkRotation(Rotation r, double q0, double q1, double q2, double q3) { Assert.assertEquals(0, Rotation.distance(r, new Rotation(q0, q1, q2, q3, false)), 1.0e-12); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.geometry.euclidean.threed; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.analysis.differentiation.DerivativeStructure; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class SphericalCoordinatesTest { @Test public void testCoordinatesStoC() throws DimensionMismatchException { double piO2 = 0.5 * FastMath.PI; SphericalCoordinates sc1 = new SphericalCoordinates(2.0, 0, piO2); Assert.assertEquals(0, sc1.getCartesian().distance(new Vector3D(2, 0, 0)), 1.0e-10); SphericalCoordinates sc2 = new SphericalCoordinates(2.0, piO2, piO2); Assert.assertEquals(0, sc2.getCartesian().distance(new Vector3D(0, 2, 0)), 1.0e-10); SphericalCoordinates sc3 = new SphericalCoordinates(2.0, FastMath.PI, piO2); Assert.assertEquals(0, sc3.getCartesian().distance(new Vector3D(-2, 0, 0)), 1.0e-10); SphericalCoordinates sc4 = new SphericalCoordinates(2.0, -piO2, piO2); Assert.assertEquals(0, sc4.getCartesian().distance(new Vector3D(0, -2, 0)), 1.0e-10); SphericalCoordinates sc5 = new SphericalCoordinates(2.0, 1.23456, 0); Assert.assertEquals(0, sc5.getCartesian().distance(new Vector3D(0, 0, 2)), 1.0e-10); SphericalCoordinates sc6 = new SphericalCoordinates(2.0, 6.54321, FastMath.PI); Assert.assertEquals(0, sc6.getCartesian().distance(new Vector3D(0, 0, -2)), 1.0e-10); } @Test public void testCoordinatesCtoS() throws DimensionMismatchException { double piO2 = 0.5 * FastMath.PI; SphericalCoordinates sc1 = new SphericalCoordinates(new Vector3D(2, 0, 0)); Assert.assertEquals(2, sc1.getR(), 1.0e-10); Assert.assertEquals(0, sc1.getTheta(), 1.0e-10); Assert.assertEquals(piO2, sc1.getPhi(), 1.0e-10); SphericalCoordinates sc2 = new SphericalCoordinates(new Vector3D(0, 2, 0)); Assert.assertEquals(2, sc2.getR(), 1.0e-10); Assert.assertEquals(piO2, sc2.getTheta(), 1.0e-10); Assert.assertEquals(piO2, sc2.getPhi(), 1.0e-10); SphericalCoordinates sc3 = new SphericalCoordinates(new Vector3D(-2, 0, 0)); Assert.assertEquals(2, sc3.getR(), 1.0e-10); Assert.assertEquals(FastMath.PI, sc3.getTheta(), 1.0e-10); Assert.assertEquals(piO2, sc3.getPhi(), 1.0e-10); SphericalCoordinates sc4 = new SphericalCoordinates(new Vector3D(0, -2, 0)); Assert.assertEquals(2, sc4.getR(), 1.0e-10); Assert.assertEquals(-piO2, sc4.getTheta(), 1.0e-10); Assert.assertEquals(piO2, sc4.getPhi(), 1.0e-10); SphericalCoordinates sc5 = new SphericalCoordinates(new Vector3D(0, 0, 2)); Assert.assertEquals(2, sc5.getR(), 1.0e-10); // don't check theta on poles, as it is singular Assert.assertEquals(0, sc5.getPhi(), 1.0e-10); SphericalCoordinates sc6 = new SphericalCoordinates(new Vector3D(0, 0, -2)); Assert.assertEquals(2, sc6.getR(), 1.0e-10); // don't check theta on poles, as it is singular Assert.assertEquals(FastMath.PI, sc6.getPhi(), 1.0e-10); } @Test public void testGradient() { for (double r = 0.2; r < 10; r += 0.5) { for (double theta = 0; theta < 2 * FastMath.PI; theta += 0.1) { for (double phi = 0.1; phi < FastMath.PI; phi += 0.1) { SphericalCoordinates sc = new SphericalCoordinates(r, theta, phi); DerivativeStructure svalue = valueSpherical(new DerivativeStructure(3, 1, 0, r), new DerivativeStructure(3, 1, 1, theta), new DerivativeStructure(3, 1, 2, phi)); double[] sGradient = new double[] { svalue.getPartialDerivative(1, 0, 0), svalue.getPartialDerivative(0, 1, 0), svalue.getPartialDerivative(0, 0, 1), }; DerivativeStructure cvalue = valueCartesian(new DerivativeStructure(3, 1, 0, sc.getCartesian().getX()), new DerivativeStructure(3, 1, 1, sc.getCartesian().getY()), new DerivativeStructure(3, 1, 2, sc.getCartesian().getZ())); Vector3D refCGradient = new Vector3D(cvalue.getPartialDerivative(1, 0, 0), cvalue.getPartialDerivative(0, 1, 0), cvalue.getPartialDerivative(0, 0, 1)); Vector3D testCGradient = new Vector3D(sc.toCartesianGradient(sGradient)); Assert.assertEquals(0, testCGradient.distance(refCGradient) / refCGradient.getNorm(), 5.0e-14); } } } } @Test public void testHessian() { for (double r = 0.2; r < 10; r += 0.5) { for (double theta = 0; theta < 2 * FastMath.PI; theta += 0.2) { for (double phi = 0.1; phi < FastMath.PI; phi += 0.2) { SphericalCoordinates sc = new SphericalCoordinates(r, theta, phi); DerivativeStructure svalue = valueSpherical(new DerivativeStructure(3, 2, 0, r), new DerivativeStructure(3, 2, 1, theta), new DerivativeStructure(3, 2, 2, phi)); double[] sGradient = new double[] { svalue.getPartialDerivative(1, 0, 0), svalue.getPartialDerivative(0, 1, 0), svalue.getPartialDerivative(0, 0, 1), }; double[][] sHessian = new double[3][3]; sHessian[0][0] = svalue.getPartialDerivative(2, 0, 0); // d2F/dR2 sHessian[1][0] = svalue.getPartialDerivative(1, 1, 0); // d2F/dRdTheta sHessian[2][0] = svalue.getPartialDerivative(1, 0, 1); // d2F/dRdPhi sHessian[0][1] = Double.NaN; // just to check upper-right part is not used sHessian[1][1] = svalue.getPartialDerivative(0, 2, 0); // d2F/dTheta2 sHessian[2][1] = svalue.getPartialDerivative(0, 1, 1); // d2F/dThetadPhi sHessian[0][2] = Double.NaN; // just to check upper-right part is not used sHessian[1][2] = Double.NaN; // just to check upper-right part is not used sHessian[2][2] = svalue.getPartialDerivative(0, 0, 2); // d2F/dPhi2 DerivativeStructure cvalue = valueCartesian(new DerivativeStructure(3, 2, 0, sc.getCartesian().getX()), new DerivativeStructure(3, 2, 1, sc.getCartesian().getY()), new DerivativeStructure(3, 2, 2, sc.getCartesian().getZ())); double[][] refCHessian = new double[3][3]; refCHessian[0][0] = cvalue.getPartialDerivative(2, 0, 0); // d2F/dX2 refCHessian[1][0] = cvalue.getPartialDerivative(1, 1, 0); // d2F/dXdY refCHessian[2][0] = cvalue.getPartialDerivative(1, 0, 1); // d2F/dXdZ refCHessian[0][1] = refCHessian[1][0]; refCHessian[1][1] = cvalue.getPartialDerivative(0, 2, 0); // d2F/dY2 refCHessian[2][1] = cvalue.getPartialDerivative(0, 1, 1); // d2F/dYdZ refCHessian[0][2] = refCHessian[2][0]; refCHessian[1][2] = refCHessian[2][1]; refCHessian[2][2] = cvalue.getPartialDerivative(0, 0, 2); // d2F/dZ2 double norm = 0; for (int i = 0; i < 3; ++i) { for (int j = 0; j < 3; ++j) { norm = FastMath.max(norm, FastMath.abs(refCHessian[i][j])); } } double[][] testCHessian = sc.toCartesianHessian(sHessian, sGradient); for (int i = 0; i < 3; ++i) { for (int j = 0; j < 3; ++j) { Assert.assertEquals("" + FastMath.abs((refCHessian[i][j] - testCHessian[i][j]) / norm), refCHessian[i][j], testCHessian[i][j], 1.0e-14 * norm); } } } } } } public DerivativeStructure valueCartesian(DerivativeStructure x, DerivativeStructure y, DerivativeStructure z) { return x.divide(y.multiply(5).add(10)).multiply(z.pow(3)); } public DerivativeStructure valueSpherical(DerivativeStructure r, DerivativeStructure theta, DerivativeStructure phi) { return valueCartesian(r.multiply(theta.cos()).multiply(phi.sin()), r.multiply(theta.sin()).multiply(phi.sin()), r.multiply(phi.cos())); } @Test public void testSerialization() { SphericalCoordinates a = new SphericalCoordinates(3, 2, 1); SphericalCoordinates b = (SphericalCoordinates) TestUtils.serializeAndRecover(a); Assert.assertEquals(0, a.getCartesian().distance(b.getCartesian()), 1.0e-10); Assert.assertEquals(a.getR(), b.getR(), 1.0e-10); Assert.assertEquals(a.getTheta(), b.getTheta(), 1.0e-10); Assert.assertEquals(a.getPhi(), b.getPhi(), 1.0e-10); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.geometry.euclidean.threed; import java.util.List; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D; import org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet; import org.apache.commons.math3.geometry.partitioning.RegionFactory; import org.junit.Assert; import org.junit.Test; public class SubLineTest { @Test public void testEndPoints() throws MathIllegalArgumentException { Vector3D p1 = new Vector3D(-1, -7, 2); Vector3D p2 = new Vector3D(7, -1, 0); Segment segment = new Segment(p1, p2, new Line(p1, p2)); SubLine sub = new SubLine(segment); List<Segment> segments = sub.getSegments(); Assert.assertEquals(1, segments.size()); Assert.assertEquals(0.0, new Vector3D(-1, -7, 2).distance(segments.get(0).getStart()), 1.0e-10); Assert.assertEquals(0.0, new Vector3D( 7, -1, 0).distance(segments.get(0).getEnd()), 1.0e-10); } @Test public void testNoEndPoints() throws MathIllegalArgumentException { SubLine wholeLine = new Line(new Vector3D(-1, 7, 2), new Vector3D(7, 1, 0)).wholeLine(); List<Segment> segments = wholeLine.getSegments(); Assert.assertEquals(1, segments.size()); Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getX()) && segments.get(0).getStart().getX() < 0); Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getY()) && segments.get(0).getStart().getY() > 0); Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getZ()) && segments.get(0).getStart().getZ() > 0); Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getX()) && segments.get(0).getEnd().getX() > 0); Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getY()) && segments.get(0).getEnd().getY() < 0); Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getZ()) && segments.get(0).getEnd().getZ() < 0); } @Test public void testNoSegments() throws MathIllegalArgumentException { SubLine empty = new SubLine(new Line(new Vector3D(-1, -7, 2), new Vector3D(7, -1, 0)), (IntervalsSet) new RegionFactory<Euclidean1D>().getComplement(new IntervalsSet())); List<Segment> segments = empty.getSegments(); Assert.assertEquals(0, segments.size()); } @Test public void testSeveralSegments() throws MathIllegalArgumentException { SubLine twoSubs = new SubLine(new Line(new Vector3D(-1, -7, 2), new Vector3D(7, -1, 0)), (IntervalsSet) new RegionFactory<Euclidean1D>().union(new IntervalsSet(1, 2), new IntervalsSet(3, 4))); List<Segment> segments = twoSubs.getSegments(); Assert.assertEquals(2, segments.size()); } @Test public void testHalfInfiniteNeg() throws MathIllegalArgumentException { SubLine empty = new SubLine(new Line(new Vector3D(-1, -7, 2), new Vector3D(7, -1, -2)), new IntervalsSet(Double.NEGATIVE_INFINITY, 0.0)); List<Segment> segments = empty.getSegments(); Assert.assertEquals(1, segments.size()); Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getX()) && segments.get(0).getStart().getX() < 0); Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getY()) && segments.get(0).getStart().getY() < 0); Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getZ()) && segments.get(0).getStart().getZ() > 0); Assert.assertEquals(0.0, new Vector3D(3, -4, 0).distance(segments.get(0).getEnd()), 1.0e-10); } @Test public void testHalfInfinitePos() throws MathIllegalArgumentException { SubLine empty = new SubLine(new Line(new Vector3D(-1, -7, 2), new Vector3D(7, -1, -2)), new IntervalsSet(0.0, Double.POSITIVE_INFINITY)); List<Segment> segments = empty.getSegments(); Assert.assertEquals(1, segments.size()); Assert.assertEquals(0.0, new Vector3D(3, -4, 0).distance(segments.get(0).getStart()), 1.0e-10); Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getX()) && segments.get(0).getEnd().getX() > 0); Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getY()) && segments.get(0).getEnd().getY() > 0); Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getZ()) && segments.get(0).getEnd().getZ() < 0); } @Test public void testIntersectionInsideInside() throws MathIllegalArgumentException { SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(3, 1, 1)); SubLine sub2 = new SubLine(new Vector3D(2, 0, 0), new Vector3D(2, 2, 2)); Assert.assertEquals(0.0, new Vector3D(2, 1, 1).distance(sub1.intersection(sub2, true)), 1.0e-12); Assert.assertEquals(0.0, new Vector3D(2, 1, 1).distance(sub1.intersection(sub2, false)), 1.0e-12); } @Test public void testIntersectionInsideBoundary() throws MathIllegalArgumentException { SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(3, 1, 1)); SubLine sub2 = new SubLine(new Vector3D(2, 0, 0), new Vector3D(2, 1, 1)); Assert.assertEquals(0.0, new Vector3D(2, 1, 1).distance(sub1.intersection(sub2, true)), 1.0e-12); Assert.assertNull(sub1.intersection(sub2, false)); } @Test public void testIntersectionInsideOutside() throws MathIllegalArgumentException { SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(3, 1, 1)); SubLine sub2 = new SubLine(new Vector3D(2, 0, 0), new Vector3D(2, 0.5, 0.5)); Assert.assertNull(sub1.intersection(sub2, true)); Assert.assertNull(sub1.intersection(sub2, false)); } @Test public void testIntersectionBoundaryBoundary() throws MathIllegalArgumentException { SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(2, 1, 1)); SubLine sub2 = new SubLine(new Vector3D(2, 0, 0), new Vector3D(2, 1, 1)); Assert.assertEquals(0.0, new Vector3D(2, 1, 1).distance(sub1.intersection(sub2, true)), 1.0e-12); Assert.assertNull(sub1.intersection(sub2, false)); } @Test public void testIntersectionBoundaryOutside() throws MathIllegalArgumentException { SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(2, 1, 1)); SubLine sub2 = new SubLine(new Vector3D(2, 0, 0), new Vector3D(2, 0.5, 0.5)); Assert.assertNull(sub1.intersection(sub2, true)); Assert.assertNull(sub1.intersection(sub2, false)); } @Test public void testIntersectionOutsideOutside() throws MathIllegalArgumentException { SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(1.5, 1, 1)); SubLine sub2 = new SubLine(new Vector3D(2, 0, 0), new Vector3D(2, 0.5, 0.5)); Assert.assertNull(sub1.intersection(sub2, true)); Assert.assertNull(sub1.intersection(sub2, false)); } @Test public void testIntersectionNotIntersecting() throws MathIllegalArgumentException { SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(1.5, 1, 1)); SubLine sub2 = new SubLine(new Vector3D(2, 3, 0), new Vector3D(2, 3, 0.5)); Assert.assertNull(sub1.intersection(sub2, true)); Assert.assertNull(sub1.intersection(sub2, false)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.geometry.euclidean.threed; import java.util.Locale; public class Vector3DFormatTest extends Vector3DFormatAbstractTest { @Override protected char getDecimalCharacter() { return '.'; } @Override protected Locale getLocale() { return Locale.US; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.geometry.euclidean.threed; import java.text.DecimalFormat; import java.text.DecimalFormatSymbols; import java.text.NumberFormat; import java.util.Locale; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MathArithmeticException; import org.apache.commons.math3.geometry.Space; import org.apache.commons.math3.random.Well1024a; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.util.Precision; import org.junit.Assert; import org.junit.Test; public class Vector3DTest { @Test public void testConstructors() throws DimensionMismatchException { double r = FastMath.sqrt(2) /2; checkVector(new Vector3D(2, new Vector3D(FastMath.PI / 3, -FastMath.PI / 4)), r, r * FastMath.sqrt(3), -2 * r); checkVector(new Vector3D(2, Vector3D.PLUS_I, -3, Vector3D.MINUS_K), 2, 0, 3); checkVector(new Vector3D(2, Vector3D.PLUS_I, 5, Vector3D.PLUS_J, -3, Vector3D.MINUS_K), 2, 5, 3); checkVector(new Vector3D(2, Vector3D.PLUS_I, 5, Vector3D.PLUS_J, 5, Vector3D.MINUS_J, -3, Vector3D.MINUS_K), 2, 0, 3); checkVector(new Vector3D(new double[] { 2, 5, -3 }), 2, 5, -3); } @Test public void testSpace() { Space space = new Vector3D(1, 2, 2).getSpace(); Assert.assertEquals(3, space.getDimension()); Assert.assertEquals(2, space.getSubSpace().getDimension()); Space deserialized = (Space) TestUtils.serializeAndRecover(space); Assert.assertTrue(space == deserialized); } @Test public void testZero() { Assert.assertEquals(0, new Vector3D(1, 2, 2).getZero().getNorm(), 1.0e-15); } @Test public void testEquals() { Vector3D u1 = new Vector3D(1, 2, 3); Vector3D u2 = new Vector3D(1, 2, 3); Assert.assertTrue(u1.equals(u1)); Assert.assertTrue(u1.equals(u2)); Assert.assertFalse(u1.equals(new Rotation(1, 0, 0, 0, false))); Assert.assertFalse(u1.equals(new Vector3D(1, 2, 3 + 10 * Precision.EPSILON))); Assert.assertFalse(u1.equals(new Vector3D(1, 2 + 10 * Precision.EPSILON, 3))); Assert.assertFalse(u1.equals(new Vector3D(1 + 10 * Precision.EPSILON, 2, 3))); Assert.assertTrue(new Vector3D(0, Double.NaN, 0).equals(new Vector3D(0, 0, Double.NaN))); } @Test public void testHash() { Assert.assertEquals(new Vector3D(0, Double.NaN, 0).hashCode(), new Vector3D(0, 0, Double.NaN).hashCode()); Vector3D u = new Vector3D(1, 2, 3); Vector3D v = new Vector3D(1, 2, 3 + 10 * Precision.EPSILON); Assert.assertTrue(u.hashCode() != v.hashCode()); } @Test public void testInfinite() { Assert.assertTrue(new Vector3D(1, 1, Double.NEGATIVE_INFINITY).isInfinite()); Assert.assertTrue(new Vector3D(1, Double.NEGATIVE_INFINITY, 1).isInfinite()); Assert.assertTrue(new Vector3D(Double.NEGATIVE_INFINITY, 1, 1).isInfinite()); Assert.assertFalse(new Vector3D(1, 1, 2).isInfinite()); Assert.assertFalse(new Vector3D(1, Double.NaN, Double.NEGATIVE_INFINITY).isInfinite()); } @Test public void testNaN() { Assert.assertTrue(new Vector3D(1, 1, Double.NaN).isNaN()); Assert.assertTrue(new Vector3D(1, Double.NaN, 1).isNaN()); Assert.assertTrue(new Vector3D(Double.NaN, 1, 1).isNaN()); Assert.assertFalse(new Vector3D(1, 1, 2).isNaN()); Assert.assertFalse(new Vector3D(1, 1, Double.NEGATIVE_INFINITY).isNaN()); } @Test public void testToString() { Assert.assertEquals("{3; 2; 1}", new Vector3D(3, 2, 1).toString()); NumberFormat format = new DecimalFormat("0.000", new DecimalFormatSymbols(Locale.US)); Assert.assertEquals("{3.000; 2.000; 1.000}", new Vector3D(3, 2, 1).toString(format)); } @Test(expected=DimensionMismatchException.class) public void testWrongDimension() throws DimensionMismatchException { new Vector3D(new double[] { 2, 5 }); } @Test public void testCoordinates() { Vector3D v = new Vector3D(1, 2, 3); Assert.assertTrue(FastMath.abs(v.getX() - 1) < 1.0e-12); Assert.assertTrue(FastMath.abs(v.getY() - 2) < 1.0e-12); Assert.assertTrue(FastMath.abs(v.getZ() - 3) < 1.0e-12); double[] coordinates = v.toArray(); Assert.assertTrue(FastMath.abs(coordinates[0] - 1) < 1.0e-12); Assert.assertTrue(FastMath.abs(coordinates[1] - 2) < 1.0e-12); Assert.assertTrue(FastMath.abs(coordinates[2] - 3) < 1.0e-12); } @Test public void testNorm1() { Assert.assertEquals(0.0, Vector3D.ZERO.getNorm1(), 0); Assert.assertEquals(6.0, new Vector3D(1, -2, 3).getNorm1(), 0); } @Test public void testNorm() { Assert.assertEquals(0.0, Vector3D.ZERO.getNorm(), 0); Assert.assertEquals(FastMath.sqrt(14), new Vector3D(1, 2, 3).getNorm(), 1.0e-12); } @Test public void testNormSq() { Assert.assertEquals(0.0, new Vector3D(0, 0, 0).getNormSq(), 0); Assert.assertEquals(14, new Vector3D(1, 2, 3).getNormSq(), 1.0e-12); } @Test public void testNormInf() { Assert.assertEquals(0.0, Vector3D.ZERO.getNormInf(), 0); Assert.assertEquals(3.0, new Vector3D(1, -2, 3).getNormInf(), 0); } @Test public void testDistance1() { Vector3D v1 = new Vector3D(1, -2, 3); Vector3D v2 = new Vector3D(-4, 2, 0); Assert.assertEquals(0.0, Vector3D.distance1(Vector3D.MINUS_I, Vector3D.MINUS_I), 0); Assert.assertEquals(12.0, Vector3D.distance1(v1, v2), 1.0e-12); Assert.assertEquals(v1.subtract(v2).getNorm1(), Vector3D.distance1(v1, v2), 1.0e-12); } @Test public void testDistance() { Vector3D v1 = new Vector3D(1, -2, 3); Vector3D v2 = new Vector3D(-4, 2, 0); Assert.assertEquals(0.0, Vector3D.distance(Vector3D.MINUS_I, Vector3D.MINUS_I), 0); Assert.assertEquals(FastMath.sqrt(50), Vector3D.distance(v1, v2), 1.0e-12); Assert.assertEquals(v1.subtract(v2).getNorm(), Vector3D.distance(v1, v2), 1.0e-12); } @Test public void testDistanceSq() { Vector3D v1 = new Vector3D(1, -2, 3); Vector3D v2 = new Vector3D(-4, 2, 0); Assert.assertEquals(0.0, Vector3D.distanceSq(Vector3D.MINUS_I, Vector3D.MINUS_I), 0); Assert.assertEquals(50.0, Vector3D.distanceSq(v1, v2), 1.0e-12); Assert.assertEquals(Vector3D.distance(v1, v2) * Vector3D.distance(v1, v2), Vector3D.distanceSq(v1, v2), 1.0e-12); } @Test public void testDistanceInf() { Vector3D v1 = new Vector3D(1, -2, 3); Vector3D v2 = new Vector3D(-4, 2, 0); Assert.assertEquals(0.0, Vector3D.distanceInf(Vector3D.MINUS_I, Vector3D.MINUS_I), 0); Assert.assertEquals(5.0, Vector3D.distanceInf(v1, v2), 1.0e-12); Assert.assertEquals(v1.subtract(v2).getNormInf(), Vector3D.distanceInf(v1, v2), 1.0e-12); } @Test public void testSubtract() { Vector3D v1 = new Vector3D(1, 2, 3); Vector3D v2 = new Vector3D(-3, -2, -1); v1 = v1.subtract(v2); checkVector(v1, 4, 4, 4); checkVector(v2.subtract(v1), -7, -6, -5); checkVector(v2.subtract(3, v1), -15, -14, -13); } @Test public void testAdd() { Vector3D v1 = new Vector3D(1, 2, 3); Vector3D v2 = new Vector3D(-3, -2, -1); v1 = v1.add(v2); checkVector(v1, -2, 0, 2); checkVector(v2.add(v1), -5, -2, 1); checkVector(v2.add(3, v1), -9, -2, 5); } @Test public void testScalarProduct() { Vector3D v = new Vector3D(1, 2, 3); v = v.scalarMultiply(3); checkVector(v, 3, 6, 9); checkVector(v.scalarMultiply(0.5), 1.5, 3, 4.5); } @Test public void testVectorialProducts() { Vector3D v1 = new Vector3D(2, 1, -4); Vector3D v2 = new Vector3D(3, 1, -1); Assert.assertTrue(FastMath.abs(Vector3D.dotProduct(v1, v2) - 11) < 1.0e-12); Vector3D v3 = Vector3D.crossProduct(v1, v2); checkVector(v3, 3, -10, -1); Assert.assertTrue(FastMath.abs(Vector3D.dotProduct(v1, v3)) < 1.0e-12); Assert.assertTrue(FastMath.abs(Vector3D.dotProduct(v2, v3)) < 1.0e-12); } @Test public void testCrossProductCancellation() { Vector3D v1 = new Vector3D(9070467121.0, 4535233560.0, 1); Vector3D v2 = new Vector3D(9070467123.0, 4535233561.0, 1); checkVector(Vector3D.crossProduct(v1, v2), -1, 2, 1); double scale = FastMath.scalb(1.0, 100); Vector3D big1 = new Vector3D(scale, v1); Vector3D small2 = new Vector3D(1 / scale, v2); checkVector(Vector3D.crossProduct(big1, small2), -1, 2, 1); } @Test public void testAngular() { Assert.assertEquals(0, Vector3D.PLUS_I.getAlpha(), 1.0e-10); Assert.assertEquals(0, Vector3D.PLUS_I.getDelta(), 1.0e-10); Assert.assertEquals(FastMath.PI / 2, Vector3D.PLUS_J.getAlpha(), 1.0e-10); Assert.assertEquals(0, Vector3D.PLUS_J.getDelta(), 1.0e-10); Assert.assertEquals(0, Vector3D.PLUS_K.getAlpha(), 1.0e-10); Assert.assertEquals(FastMath.PI / 2, Vector3D.PLUS_K.getDelta(), 1.0e-10); Vector3D u = new Vector3D(-1, 1, -1); Assert.assertEquals(3 * FastMath.PI /4, u.getAlpha(), 1.0e-10); Assert.assertEquals(-1.0 / FastMath.sqrt(3), FastMath.sin(u.getDelta()), 1.0e-10); } @Test public void testAngularSeparation() throws MathArithmeticException { Vector3D v1 = new Vector3D(2, -1, 4); Vector3D k = v1.normalize(); Vector3D i = k.orthogonal(); Vector3D v2 = k.scalarMultiply(FastMath.cos(1.2)).add(i.scalarMultiply(FastMath.sin(1.2))); Assert.assertTrue(FastMath.abs(Vector3D.angle(v1, v2) - 1.2) < 1.0e-12); } @Test public void testNormalize() throws MathArithmeticException { Assert.assertEquals(1.0, new Vector3D(5, -4, 2).normalize().getNorm(), 1.0e-12); try { Vector3D.ZERO.normalize(); Assert.fail("an exception should have been thrown"); } catch (MathArithmeticException ae) { // expected behavior } } @Test public void testNegate() { checkVector(new Vector3D(0.1, 2.5, 1.3).negate(), -0.1, -2.5, -1.3); } @Test public void testOrthogonal() throws MathArithmeticException { Vector3D v1 = new Vector3D(0.1, 2.5, 1.3); Assert.assertEquals(0.0, Vector3D.dotProduct(v1, v1.orthogonal()), 1.0e-12); Vector3D v2 = new Vector3D(2.3, -0.003, 7.6); Assert.assertEquals(0.0, Vector3D.dotProduct(v2, v2.orthogonal()), 1.0e-12); Vector3D v3 = new Vector3D(-1.7, 1.4, 0.2); Assert.assertEquals(0.0, Vector3D.dotProduct(v3, v3.orthogonal()), 1.0e-12); Vector3D v4 = new Vector3D(4.2, 0.1, -1.8); Assert.assertEquals(0.0, Vector3D.dotProduct(v4, v4.orthogonal()), 1.0e-12); try { new Vector3D(0, 0, 0).orthogonal(); Assert.fail("an exception should have been thrown"); } catch (MathArithmeticException ae) { // expected behavior } } @Test public void testAngle() throws MathArithmeticException { Assert.assertEquals(0.22572612855273393616, Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(4, 5, 6)), 1.0e-12); Assert.assertEquals(7.98595620686106654517199e-8, Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(2, 4, 6.000001)), 1.0e-12); Assert.assertEquals(3.14159257373023116985197793156, Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(-2, -4, -6.000001)), 1.0e-12); try { Vector3D.angle(Vector3D.ZERO, Vector3D.PLUS_I); Assert.fail("an exception should have been thrown"); } catch (MathArithmeticException ae) { // expected behavior } } @Test public void testAccurateDotProduct() { // the following two vectors are nearly but not exactly orthogonal // naive dot product (i.e. computing u1.x * u2.x + u1.y * u2.y + u1.z * u2.z // leads to a result of 0.0, instead of the correct -1.855129... Vector3D u1 = new Vector3D(-1321008684645961.0 / 268435456.0, -5774608829631843.0 / 268435456.0, -7645843051051357.0 / 8589934592.0); Vector3D u2 = new Vector3D(-5712344449280879.0 / 2097152.0, -4550117129121957.0 / 2097152.0, 8846951984510141.0 / 131072.0); double sNaive = u1.getX() * u2.getX() + u1.getY() * u2.getY() + u1.getZ() * u2.getZ(); double sAccurate = u1.dotProduct(u2); Assert.assertEquals(0.0, sNaive, 1.0e-30); Assert.assertEquals(-2088690039198397.0 / 1125899906842624.0, sAccurate, 1.0e-16); } @Test public void testDotProduct() { // we compare accurate versus naive dot product implementations // on regular vectors (i.e. not extreme cases like in the previous test) Well1024a random = new Well1024a(553267312521321234l); for (int i = 0; i < 10000; ++i) { double ux = 10000 * random.nextDouble(); double uy = 10000 * random.nextDouble(); double uz = 10000 * random.nextDouble(); double vx = 10000 * random.nextDouble(); double vy = 10000 * random.nextDouble(); double vz = 10000 * random.nextDouble(); double sNaive = ux * vx + uy * vy + uz * vz; double sAccurate = new Vector3D(ux, uy, uz).dotProduct(new Vector3D(vx, vy, vz)); Assert.assertEquals(sNaive, sAccurate, 2.5e-16 * sAccurate); } } @Test public void testAccurateCrossProduct() { // the vectors u1 and u2 are nearly but not exactly anti-parallel // (7.31e-16 degrees from 180 degrees) naive cross product (i.e. // computing u1.x * u2.x + u1.y * u2.y + u1.z * u2.z // leads to a result of [0.0009765, -0.0001220, -0.0039062], // instead of the correct [0.0006913, -0.0001254, -0.0007909] final Vector3D u1 = new Vector3D(-1321008684645961.0 / 268435456.0, -5774608829631843.0 / 268435456.0, -7645843051051357.0 / 8589934592.0); final Vector3D u2 = new Vector3D( 1796571811118507.0 / 2147483648.0, 7853468008299307.0 / 2147483648.0, 2599586637357461.0 / 17179869184.0); final Vector3D u3 = new Vector3D(12753243807587107.0 / 18446744073709551616.0, -2313766922703915.0 / 18446744073709551616.0, -227970081415313.0 / 288230376151711744.0); Vector3D cNaive = new Vector3D(u1.getY() * u2.getZ() - u1.getZ() * u2.getY(), u1.getZ() * u2.getX() - u1.getX() * u2.getZ(), u1.getX() * u2.getY() - u1.getY() * u2.getX()); Vector3D cAccurate = u1.crossProduct(u2); Assert.assertTrue(u3.distance(cNaive) > 2.9 * u3.getNorm()); Assert.assertEquals(0.0, u3.distance(cAccurate), 1.0e-30 * cAccurate.getNorm()); } @Test public void testCrossProduct() { // we compare accurate versus naive cross product implementations // on regular vectors (i.e. not extreme cases like in the previous test) Well1024a random = new Well1024a(885362227452043214l); for (int i = 0; i < 10000; ++i) { double ux = 10000 * random.nextDouble(); double uy = 10000 * random.nextDouble(); double uz = 10000 * random.nextDouble(); double vx = 10000 * random.nextDouble(); double vy = 10000 * random.nextDouble(); double vz = 10000 * random.nextDouble(); Vector3D cNaive = new Vector3D(uy * vz - uz * vy, uz * vx - ux * vz, ux * vy - uy * vx); Vector3D cAccurate = new Vector3D(ux, uy, uz).crossProduct(new Vector3D(vx, vy, vz)); Assert.assertEquals(0.0, cAccurate.distance(cNaive), 6.0e-15 * cAccurate.getNorm()); } } private void checkVector(Vector3D v, double x, double y, double z) { Assert.assertEquals(x, v.getX(), 1.0e-12); Assert.assertEquals(y, v.getY(), 1.0e-12); Assert.assertEquals(z, v.getZ(), 1.0e-12); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.geometry.euclidean.twod; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D; import org.apache.commons.math3.geometry.euclidean.oned.Vector1D; import org.apache.commons.math3.geometry.euclidean.twod.Line; import org.apache.commons.math3.geometry.euclidean.twod.Vector2D; import org.apache.commons.math3.geometry.partitioning.Transform; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; import java.awt.geom.AffineTransform; public class LineTest { @Test public void testContains() { Line l = new Line(new Vector2D(0, 1), new Vector2D(1, 2)); Assert.assertTrue(l.contains(new Vector2D(0, 1))); Assert.assertTrue(l.contains(new Vector2D(1, 2))); Assert.assertTrue(l.contains(new Vector2D(7, 8))); Assert.assertTrue(! l.contains(new Vector2D(8, 7))); } @Test public void testAbscissa() { Line l = new Line(new Vector2D(2, 1), new Vector2D(-2, -2)); Assert.assertEquals(0.0, (l.toSubSpace(new Vector2D(-3, 4))).getX(), 1.0e-10); Assert.assertEquals(0.0, (l.toSubSpace(new Vector2D( 3, -4))).getX(), 1.0e-10); Assert.assertEquals(-5.0, (l.toSubSpace(new Vector2D( 7, -1))).getX(), 1.0e-10); Assert.assertEquals( 5.0, (l.toSubSpace(new Vector2D(-1, -7))).getX(), 1.0e-10); } @Test public void testOffset() { Line l = new Line(new Vector2D(2, 1), new Vector2D(-2, -2)); Assert.assertEquals(-5.0, l.getOffset(new Vector2D(5, -3)), 1.0e-10); Assert.assertEquals(+5.0, l.getOffset(new Vector2D(-5, 2)), 1.0e-10); } @Test public void testDistance() { Line l = new Line(new Vector2D(2, 1), new Vector2D(-2, -2)); Assert.assertEquals(+5.0, l.distance(new Vector2D(5, -3)), 1.0e-10); Assert.assertEquals(+5.0, l.distance(new Vector2D(-5, 2)), 1.0e-10); } @Test public void testPointAt() { Line l = new Line(new Vector2D(2, 1), new Vector2D(-2, -2)); for (double a = -2.0; a < 2.0; a += 0.2) { Vector1D pA = new Vector1D(a); Vector2D point = l.toSpace(pA); Assert.assertEquals(a, (l.toSubSpace(point)).getX(), 1.0e-10); Assert.assertEquals(0.0, l.getOffset(point), 1.0e-10); for (double o = -2.0; o < 2.0; o += 0.2) { point = l.getPointAt(pA, o); Assert.assertEquals(a, (l.toSubSpace(point)).getX(), 1.0e-10); Assert.assertEquals(o, l.getOffset(point), 1.0e-10); } } } @Test public void testOriginOffset() { Line l1 = new Line(new Vector2D(0, 1), new Vector2D(1, 2)); Assert.assertEquals(FastMath.sqrt(0.5), l1.getOriginOffset(), 1.0e-10); Line l2 = new Line(new Vector2D(1, 2), new Vector2D(0, 1)); Assert.assertEquals(-FastMath.sqrt(0.5), l2.getOriginOffset(), 1.0e-10); } @Test public void testParallel() { Line l1 = new Line(new Vector2D(0, 1), new Vector2D(1, 2)); Line l2 = new Line(new Vector2D(2, 2), new Vector2D(3, 3)); Assert.assertTrue(l1.isParallelTo(l2)); Line l3 = new Line(new Vector2D(1, 0), new Vector2D(0.5, -0.5)); Assert.assertTrue(l1.isParallelTo(l3)); Line l4 = new Line(new Vector2D(1, 0), new Vector2D(0.5, -0.51)); Assert.assertTrue(! l1.isParallelTo(l4)); } @Test public void testTransform() throws MathIllegalArgumentException { Line l1 = new Line(new Vector2D(1.0 ,1.0), new Vector2D(4.0 ,1.0)); Transform<Euclidean2D, Euclidean1D> t1 = Line.getTransform(new AffineTransform(0.0, 0.5, -1.0, 0.0, 1.0, 1.5)); Assert.assertEquals(0.5 * FastMath.PI, ((Line) t1.apply(l1)).getAngle(), 1.0e-10); Line l2 = new Line(new Vector2D(0.0, 0.0), new Vector2D(1.0, 1.0)); Transform<Euclidean2D, Euclidean1D> t2 = Line.getTransform(new AffineTransform(0.0, 0.5, -1.0, 0.0, 1.0, 1.5)); Assert.assertEquals(FastMath.atan2(1.0, -2.0), ((Line) t2.apply(l2)).getAngle(), 1.0e-10); } @Test public void testIntersection() { Line l1 = new Line(new Vector2D( 0, 1), new Vector2D(1, 2)); Line l2 = new Line(new Vector2D(-1, 2), new Vector2D(2, 1)); Vector2D p = l1.intersection(l2); Assert.assertEquals(0.5, p.getX(), 1.0e-10); Assert.assertEquals(1.5, p.getY(), 1.0e-10); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.geometry.euclidean.twod; import java.util.ArrayList; import java.util.List; import org.apache.commons.math3.geometry.euclidean.oned.Interval; import org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet; import org.apache.commons.math3.geometry.euclidean.oned.Vector1D; import org.apache.commons.math3.geometry.partitioning.BSPTree; import org.apache.commons.math3.geometry.partitioning.Region; import org.apache.commons.math3.geometry.partitioning.Region.Location; import org.apache.commons.math3.geometry.partitioning.RegionFactory; import org.apache.commons.math3.geometry.partitioning.SubHyperplane; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class PolygonsSetTest { @Test public void testSimplyConnected() { Vector2D[][] vertices = new Vector2D[][] { new Vector2D[] { new Vector2D(36.0, 22.0), new Vector2D(39.0, 32.0), new Vector2D(19.0, 32.0), new Vector2D( 6.0, 16.0), new Vector2D(31.0, 10.0), new Vector2D(42.0, 16.0), new Vector2D(34.0, 20.0), new Vector2D(29.0, 19.0), new Vector2D(23.0, 22.0), new Vector2D(33.0, 25.0) } }; PolygonsSet set = buildSet(vertices); Assert.assertEquals(Region.Location.OUTSIDE, set.checkPoint(new Vector2D(50.0, 30.0))); checkPoints(Region.Location.INSIDE, set, new Vector2D[] { new Vector2D(30.0, 15.0), new Vector2D(15.0, 20.0), new Vector2D(24.0, 25.0), new Vector2D(35.0, 30.0), new Vector2D(19.0, 17.0) }); checkPoints(Region.Location.OUTSIDE, set, new Vector2D[] { new Vector2D(50.0, 30.0), new Vector2D(30.0, 35.0), new Vector2D(10.0, 25.0), new Vector2D(10.0, 10.0), new Vector2D(40.0, 10.0), new Vector2D(50.0, 15.0), new Vector2D(30.0, 22.0) }); checkPoints(Region.Location.BOUNDARY, set, new Vector2D[] { new Vector2D(30.0, 32.0), new Vector2D(34.0, 20.0) }); checkVertices(set.getVertices(), vertices); } @Test public void testStair() { Vector2D[][] vertices = new Vector2D[][] { new Vector2D[] { new Vector2D( 0.0, 0.0), new Vector2D( 0.0, 2.0), new Vector2D(-0.1, 2.0), new Vector2D(-0.1, 1.0), new Vector2D(-0.3, 1.0), new Vector2D(-0.3, 1.5), new Vector2D(-1.3, 1.5), new Vector2D(-1.3, 2.0), new Vector2D(-1.8, 2.0), new Vector2D(-1.8 - 1.0 / FastMath.sqrt(2.0), 2.0 - 1.0 / FastMath.sqrt(2.0)) } }; PolygonsSet set = buildSet(vertices); checkVertices(set.getVertices(), vertices); Assert.assertEquals(1.1 + 0.95 * FastMath.sqrt(2.0), set.getSize(), 1.0e-10); } @Test public void testHole() { Vector2D[][] vertices = new Vector2D[][] { new Vector2D[] { new Vector2D(0.0, 0.0), new Vector2D(3.0, 0.0), new Vector2D(3.0, 3.0), new Vector2D(0.0, 3.0) }, new Vector2D[] { new Vector2D(1.0, 2.0), new Vector2D(2.0, 2.0), new Vector2D(2.0, 1.0), new Vector2D(1.0, 1.0) } }; PolygonsSet set = buildSet(vertices); checkPoints(Region.Location.INSIDE, set, new Vector2D[] { new Vector2D(0.5, 0.5), new Vector2D(1.5, 0.5), new Vector2D(2.5, 0.5), new Vector2D(0.5, 1.5), new Vector2D(2.5, 1.5), new Vector2D(0.5, 2.5), new Vector2D(1.5, 2.5), new Vector2D(2.5, 2.5), new Vector2D(0.5, 1.0) }); checkPoints(Region.Location.OUTSIDE, set, new Vector2D[] { new Vector2D(1.5, 1.5), new Vector2D(3.5, 1.0), new Vector2D(4.0, 1.5), new Vector2D(6.0, 6.0) }); checkPoints(Region.Location.BOUNDARY, set, new Vector2D[] { new Vector2D(1.0, 1.0), new Vector2D(1.5, 0.0), new Vector2D(1.5, 1.0), new Vector2D(1.5, 2.0), new Vector2D(1.5, 3.0), new Vector2D(3.0, 3.0) }); checkVertices(set.getVertices(), vertices); } @Test public void testDisjointPolygons() { Vector2D[][] vertices = new Vector2D[][] { new Vector2D[] { new Vector2D(0.0, 1.0), new Vector2D(2.0, 1.0), new Vector2D(1.0, 2.0) }, new Vector2D[] { new Vector2D(4.0, 0.0), new Vector2D(5.0, 1.0), new Vector2D(3.0, 1.0) } }; PolygonsSet set = buildSet(vertices); Assert.assertEquals(Region.Location.INSIDE, set.checkPoint(new Vector2D(1.0, 1.5))); checkPoints(Region.Location.INSIDE, set, new Vector2D[] { new Vector2D(1.0, 1.5), new Vector2D(4.5, 0.8) }); checkPoints(Region.Location.OUTSIDE, set, new Vector2D[] { new Vector2D(1.0, 0.0), new Vector2D(3.5, 1.2), new Vector2D(2.5, 1.0), new Vector2D(3.0, 4.0) }); checkPoints(Region.Location.BOUNDARY, set, new Vector2D[] { new Vector2D(1.0, 1.0), new Vector2D(3.5, 0.5), new Vector2D(0.0, 1.0) }); checkVertices(set.getVertices(), vertices); } @Test public void testOppositeHyperplanes() { Vector2D[][] vertices = new Vector2D[][] { new Vector2D[] { new Vector2D(1.0, 0.0), new Vector2D(2.0, 1.0), new Vector2D(3.0, 1.0), new Vector2D(2.0, 2.0), new Vector2D(1.0, 1.0), new Vector2D(0.0, 1.0) } }; PolygonsSet set = buildSet(vertices); checkVertices(set.getVertices(), vertices); } @Test public void testSingularPoint() { Vector2D[][] vertices = new Vector2D[][] { new Vector2D[] { new Vector2D( 0.0, 0.0), new Vector2D( 1.0, 0.0), new Vector2D( 1.0, 1.0), new Vector2D( 0.0, 1.0), new Vector2D( 0.0, 0.0), new Vector2D(-1.0, 0.0), new Vector2D(-1.0, -1.0), new Vector2D( 0.0, -1.0) } }; PolygonsSet set = buildSet(vertices); checkVertices(set.getVertices(), vertices); } @Test public void testLineIntersection() { Vector2D[][] vertices = new Vector2D[][] { new Vector2D[] { new Vector2D( 0.0, 0.0), new Vector2D( 2.0, 0.0), new Vector2D( 2.0, 1.0), new Vector2D( 3.0, 1.0), new Vector2D( 3.0, 3.0), new Vector2D( 1.0, 3.0), new Vector2D( 1.0, 2.0), new Vector2D( 0.0, 2.0) } }; PolygonsSet set = buildSet(vertices); Line l1 = new Line(new Vector2D(-1.5, 0.0), FastMath.PI / 4); SubLine s1 = (SubLine) set.intersection(l1.wholeHyperplane()); List<Interval> i1 = ((IntervalsSet) s1.getRemainingRegion()).asList(); Assert.assertEquals(2, i1.size()); Interval v10 = i1.get(0); Vector2D p10Lower = l1.toSpace(new Vector1D(v10.getInf())); Assert.assertEquals(0.0, p10Lower.getX(), 1.0e-10); Assert.assertEquals(1.5, p10Lower.getY(), 1.0e-10); Vector2D p10Upper = l1.toSpace(new Vector1D(v10.getSup())); Assert.assertEquals(0.5, p10Upper.getX(), 1.0e-10); Assert.assertEquals(2.0, p10Upper.getY(), 1.0e-10); Interval v11 = i1.get(1); Vector2D p11Lower = l1.toSpace(new Vector1D(v11.getInf())); Assert.assertEquals(1.0, p11Lower.getX(), 1.0e-10); Assert.assertEquals(2.5, p11Lower.getY(), 1.0e-10); Vector2D p11Upper = l1.toSpace(new Vector1D(v11.getSup())); Assert.assertEquals(1.5, p11Upper.getX(), 1.0e-10); Assert.assertEquals(3.0, p11Upper.getY(), 1.0e-10); Line l2 = new Line(new Vector2D(-1.0, 2.0), 0); SubLine s2 = (SubLine) set.intersection(l2.wholeHyperplane()); List<Interval> i2 = ((IntervalsSet) s2.getRemainingRegion()).asList(); Assert.assertEquals(1, i2.size()); Interval v20 = i2.get(0); Vector2D p20Lower = l2.toSpace(new Vector1D(v20.getInf())); Assert.assertEquals(1.0, p20Lower.getX(), 1.0e-10); Assert.assertEquals(2.0, p20Lower.getY(), 1.0e-10); Vector2D p20Upper = l2.toSpace(new Vector1D(v20.getSup())); Assert.assertEquals(3.0, p20Upper.getX(), 1.0e-10); Assert.assertEquals(2.0, p20Upper.getY(), 1.0e-10); } @Test public void testUnlimitedSubHyperplane() { Vector2D[][] vertices1 = new Vector2D[][] { new Vector2D[] { new Vector2D(0.0, 0.0), new Vector2D(4.0, 0.0), new Vector2D(1.4, 1.5), new Vector2D(0.0, 3.5) } }; PolygonsSet set1 = buildSet(vertices1); Vector2D[][] vertices2 = new Vector2D[][] { new Vector2D[] { new Vector2D(1.4, 0.2), new Vector2D(2.8, -1.2), new Vector2D(2.5, 0.6) } }; PolygonsSet set2 = buildSet(vertices2); PolygonsSet set = (PolygonsSet) new RegionFactory<Euclidean2D>().union(set1.copySelf(), set2.copySelf()); checkVertices(set1.getVertices(), vertices1); checkVertices(set2.getVertices(), vertices2); checkVertices(set.getVertices(), new Vector2D[][] { new Vector2D[] { new Vector2D(0.0, 0.0), new Vector2D(1.6, 0.0), new Vector2D(2.8, -1.2), new Vector2D(2.6, 0.0), new Vector2D(4.0, 0.0), new Vector2D(1.4, 1.5), new Vector2D(0.0, 3.5) } }); } @Test public void testUnion() { Vector2D[][] vertices1 = new Vector2D[][] { new Vector2D[] { new Vector2D( 0.0, 0.0), new Vector2D( 2.0, 0.0), new Vector2D( 2.0, 2.0), new Vector2D( 0.0, 2.0) } }; PolygonsSet set1 = buildSet(vertices1); Vector2D[][] vertices2 = new Vector2D[][] { new Vector2D[] { new Vector2D( 1.0, 1.0), new Vector2D( 3.0, 1.0), new Vector2D( 3.0, 3.0), new Vector2D( 1.0, 3.0) } }; PolygonsSet set2 = buildSet(vertices2); PolygonsSet set = (PolygonsSet) new RegionFactory<Euclidean2D>().union(set1.copySelf(), set2.copySelf()); checkVertices(set1.getVertices(), vertices1); checkVertices(set2.getVertices(), vertices2); checkVertices(set.getVertices(), new Vector2D[][] { new Vector2D[] { new Vector2D( 0.0, 0.0), new Vector2D( 2.0, 0.0), new Vector2D( 2.0, 1.0), new Vector2D( 3.0, 1.0), new Vector2D( 3.0, 3.0), new Vector2D( 1.0, 3.0), new Vector2D( 1.0, 2.0), new Vector2D( 0.0, 2.0) } }); checkPoints(Region.Location.INSIDE, set, new Vector2D[] { new Vector2D(1.0, 1.0), new Vector2D(0.5, 0.5), new Vector2D(2.0, 2.0), new Vector2D(2.5, 2.5), new Vector2D(0.5, 1.5), new Vector2D(1.5, 1.5), new Vector2D(1.5, 0.5), new Vector2D(1.5, 2.5), new Vector2D(2.5, 1.5), new Vector2D(2.5, 2.5) }); checkPoints(Region.Location.OUTSIDE, set, new Vector2D[] { new Vector2D(-0.5, 0.5), new Vector2D( 0.5, 2.5), new Vector2D( 2.5, 0.5), new Vector2D( 3.5, 2.5) }); checkPoints(Region.Location.BOUNDARY, set, new Vector2D[] { new Vector2D(0.0, 0.0), new Vector2D(0.5, 2.0), new Vector2D(2.0, 0.5), new Vector2D(2.5, 1.0), new Vector2D(3.0, 2.5) }); } @Test public void testIntersection() { Vector2D[][] vertices1 = new Vector2D[][] { new Vector2D[] { new Vector2D( 0.0, 0.0), new Vector2D( 2.0, 0.0), new Vector2D( 2.0, 2.0), new Vector2D( 0.0, 2.0) } }; PolygonsSet set1 = buildSet(vertices1); Vector2D[][] vertices2 = new Vector2D[][] { new Vector2D[] { new Vector2D( 1.0, 1.0), new Vector2D( 3.0, 1.0), new Vector2D( 3.0, 3.0), new Vector2D( 1.0, 3.0) } }; PolygonsSet set2 = buildSet(vertices2); PolygonsSet set = (PolygonsSet) new RegionFactory<Euclidean2D>().intersection(set1.copySelf(), set2.copySelf()); checkVertices(set1.getVertices(), vertices1); checkVertices(set2.getVertices(), vertices2); checkVertices(set.getVertices(), new Vector2D[][] { new Vector2D[] { new Vector2D( 1.0, 1.0), new Vector2D( 2.0, 1.0), new Vector2D( 2.0, 2.0), new Vector2D( 1.0, 2.0) } }); checkPoints(Region.Location.INSIDE, set, new Vector2D[] { new Vector2D(1.5, 1.5) }); checkPoints(Region.Location.OUTSIDE, set, new Vector2D[] { new Vector2D(0.5, 1.5), new Vector2D(2.5, 1.5), new Vector2D(1.5, 0.5), new Vector2D(0.5, 0.5) }); checkPoints(Region.Location.BOUNDARY, set, new Vector2D[] { new Vector2D(1.0, 1.0), new Vector2D(2.0, 2.0), new Vector2D(1.0, 1.5), new Vector2D(1.5, 2.0) }); } @Test public void testXor() { Vector2D[][] vertices1 = new Vector2D[][] { new Vector2D[] { new Vector2D( 0.0, 0.0), new Vector2D( 2.0, 0.0), new Vector2D( 2.0, 2.0), new Vector2D( 0.0, 2.0) } }; PolygonsSet set1 = buildSet(vertices1); Vector2D[][] vertices2 = new Vector2D[][] { new Vector2D[] { new Vector2D( 1.0, 1.0), new Vector2D( 3.0, 1.0), new Vector2D( 3.0, 3.0), new Vector2D( 1.0, 3.0) } }; PolygonsSet set2 = buildSet(vertices2); PolygonsSet set = (PolygonsSet) new RegionFactory<Euclidean2D>().xor(set1.copySelf(), set2.copySelf()); checkVertices(set1.getVertices(), vertices1); checkVertices(set2.getVertices(), vertices2); checkVertices(set.getVertices(), new Vector2D[][] { new Vector2D[] { new Vector2D( 0.0, 0.0), new Vector2D( 2.0, 0.0), new Vector2D( 2.0, 1.0), new Vector2D( 3.0, 1.0), new Vector2D( 3.0, 3.0), new Vector2D( 1.0, 3.0), new Vector2D( 1.0, 2.0), new Vector2D( 0.0, 2.0) }, new Vector2D[] { new Vector2D( 1.0, 1.0), new Vector2D( 1.0, 2.0), new Vector2D( 2.0, 2.0), new Vector2D( 2.0, 1.0) } }); checkPoints(Region.Location.INSIDE, set, new Vector2D[] { new Vector2D(0.5, 0.5), new Vector2D(2.5, 2.5), new Vector2D(0.5, 1.5), new Vector2D(1.5, 0.5), new Vector2D(1.5, 2.5), new Vector2D(2.5, 1.5), new Vector2D(2.5, 2.5) }); checkPoints(Region.Location.OUTSIDE, set, new Vector2D[] { new Vector2D(-0.5, 0.5), new Vector2D( 0.5, 2.5), new Vector2D( 2.5, 0.5), new Vector2D( 1.5, 1.5), new Vector2D( 3.5, 2.5) }); checkPoints(Region.Location.BOUNDARY, set, new Vector2D[] { new Vector2D(1.0, 1.0), new Vector2D(2.0, 2.0), new Vector2D(1.5, 1.0), new Vector2D(2.0, 1.5), new Vector2D(0.0, 0.0), new Vector2D(0.5, 2.0), new Vector2D(2.0, 0.5), new Vector2D(2.5, 1.0), new Vector2D(3.0, 2.5) }); } @Test public void testDifference() { Vector2D[][] vertices1 = new Vector2D[][] { new Vector2D[] { new Vector2D( 0.0, 0.0), new Vector2D( 2.0, 0.0), new Vector2D( 2.0, 2.0), new Vector2D( 0.0, 2.0) } }; PolygonsSet set1 = buildSet(vertices1); Vector2D[][] vertices2 = new Vector2D[][] { new Vector2D[] { new Vector2D( 1.0, 1.0), new Vector2D( 3.0, 1.0), new Vector2D( 3.0, 3.0), new Vector2D( 1.0, 3.0) } }; PolygonsSet set2 = buildSet(vertices2); PolygonsSet set = (PolygonsSet) new RegionFactory<Euclidean2D>().difference(set1.copySelf(), set2.copySelf()); checkVertices(set1.getVertices(), vertices1); checkVertices(set2.getVertices(), vertices2); checkVertices(set.getVertices(), new Vector2D[][] { new Vector2D[] { new Vector2D( 0.0, 0.0), new Vector2D( 2.0, 0.0), new Vector2D( 2.0, 1.0), new Vector2D( 1.0, 1.0), new Vector2D( 1.0, 2.0), new Vector2D( 0.0, 2.0) } }); checkPoints(Region.Location.INSIDE, set, new Vector2D[] { new Vector2D(0.5, 0.5), new Vector2D(0.5, 1.5), new Vector2D(1.5, 0.5) }); checkPoints(Region.Location.OUTSIDE, set, new Vector2D[] { new Vector2D( 2.5, 2.5), new Vector2D(-0.5, 0.5), new Vector2D( 0.5, 2.5), new Vector2D( 2.5, 0.5), new Vector2D( 1.5, 1.5), new Vector2D( 3.5, 2.5), new Vector2D( 1.5, 2.5), new Vector2D( 2.5, 1.5), new Vector2D( 2.0, 1.5), new Vector2D( 2.0, 2.0), new Vector2D( 2.5, 1.0), new Vector2D( 2.5, 2.5), new Vector2D( 3.0, 2.5) }); checkPoints(Region.Location.BOUNDARY, set, new Vector2D[] { new Vector2D(1.0, 1.0), new Vector2D(1.5, 1.0), new Vector2D(0.0, 0.0), new Vector2D(0.5, 2.0), new Vector2D(2.0, 0.5) }); } @Test public void testEmptyDifference() { Vector2D[][] vertices1 = new Vector2D[][] { new Vector2D[] { new Vector2D( 0.5, 3.5), new Vector2D( 0.5, 4.5), new Vector2D(-0.5, 4.5), new Vector2D(-0.5, 3.5) } }; PolygonsSet set1 = buildSet(vertices1); Vector2D[][] vertices2 = new Vector2D[][] { new Vector2D[] { new Vector2D( 1.0, 2.0), new Vector2D( 1.0, 8.0), new Vector2D(-1.0, 8.0), new Vector2D(-1.0, 2.0) } }; PolygonsSet set2 = buildSet(vertices2); Assert.assertTrue(new RegionFactory<Euclidean2D>().difference(set1.copySelf(), set2.copySelf()).isEmpty()); } @Test public void testChoppedHexagon() { double pi6 = FastMath.PI / 6.0; double sqrt3 = FastMath.sqrt(3.0); SubLine[] hyp = { new Line(new Vector2D( 0.0, 1.0), 5 * pi6).wholeHyperplane(), new Line(new Vector2D(-sqrt3, 1.0), 7 * pi6).wholeHyperplane(), new Line(new Vector2D(-sqrt3, 1.0), 9 * pi6).wholeHyperplane(), new Line(new Vector2D(-sqrt3, 0.0), 11 * pi6).wholeHyperplane(), new Line(new Vector2D( 0.0, 0.0), 13 * pi6).wholeHyperplane(), new Line(new Vector2D( 0.0, 1.0), 3 * pi6).wholeHyperplane(), new Line(new Vector2D(-5.0 * sqrt3 / 6.0, 0.0), 9 * pi6).wholeHyperplane() }; hyp[1] = (SubLine) hyp[1].split(hyp[0].getHyperplane()).getMinus(); hyp[2] = (SubLine) hyp[2].split(hyp[1].getHyperplane()).getMinus(); hyp[3] = (SubLine) hyp[3].split(hyp[2].getHyperplane()).getMinus(); hyp[4] = (SubLine) hyp[4].split(hyp[3].getHyperplane()).getMinus().split(hyp[0].getHyperplane()).getMinus(); hyp[5] = (SubLine) hyp[5].split(hyp[4].getHyperplane()).getMinus().split(hyp[0].getHyperplane()).getMinus(); hyp[6] = (SubLine) hyp[6].split(hyp[3].getHyperplane()).getMinus().split(hyp[1].getHyperplane()).getMinus(); BSPTree<Euclidean2D> tree = new BSPTree<Euclidean2D>(Boolean.TRUE); for (int i = hyp.length - 1; i >= 0; --i) { tree = new BSPTree<Euclidean2D>(hyp[i], new BSPTree<Euclidean2D>(Boolean.FALSE), tree, null); } PolygonsSet set = new PolygonsSet(tree); SubLine splitter = new Line(new Vector2D(-2.0 * sqrt3 / 3.0, 0.0), 9 * pi6).wholeHyperplane(); PolygonsSet slice = new PolygonsSet(new BSPTree<Euclidean2D>(splitter, set.getTree(false).split(splitter).getPlus(), new BSPTree<Euclidean2D>(Boolean.FALSE), null)); Assert.assertEquals(Region.Location.OUTSIDE, slice.checkPoint(new Vector2D(0.1, 0.5))); Assert.assertEquals(11.0 / 3.0, slice.getBoundarySize(), 1.0e-10); } @Test public void testConcentric() { double h = FastMath.sqrt(3.0) / 2.0; Vector2D[][] vertices1 = new Vector2D[][] { new Vector2D[] { new Vector2D( 0.00, 0.1 * h), new Vector2D( 0.05, 0.1 * h), new Vector2D( 0.10, 0.2 * h), new Vector2D( 0.05, 0.3 * h), new Vector2D(-0.05, 0.3 * h), new Vector2D(-0.10, 0.2 * h), new Vector2D(-0.05, 0.1 * h) } }; PolygonsSet set1 = buildSet(vertices1); Vector2D[][] vertices2 = new Vector2D[][] { new Vector2D[] { new Vector2D( 0.00, 0.0 * h), new Vector2D( 0.10, 0.0 * h), new Vector2D( 0.20, 0.2 * h), new Vector2D( 0.10, 0.4 * h), new Vector2D(-0.10, 0.4 * h), new Vector2D(-0.20, 0.2 * h), new Vector2D(-0.10, 0.0 * h) } }; PolygonsSet set2 = buildSet(vertices2); Assert.assertTrue(set2.contains(set1)); } @Test public void testBug20040520() { BSPTree<Euclidean2D> a0 = new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.85, -0.05), new Vector2D(0.90, -0.10)), new BSPTree<Euclidean2D>(Boolean.FALSE), new BSPTree<Euclidean2D>(Boolean.TRUE), null); BSPTree<Euclidean2D> a1 = new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.85, -0.10), new Vector2D(0.90, -0.10)), new BSPTree<Euclidean2D>(Boolean.FALSE), a0, null); BSPTree<Euclidean2D> a2 = new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.90, -0.05), new Vector2D(0.85, -0.05)), new BSPTree<Euclidean2D>(Boolean.FALSE), a1, null); BSPTree<Euclidean2D> a3 = new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.82, -0.05), new Vector2D(0.82, -0.08)), new BSPTree<Euclidean2D>(Boolean.FALSE), new BSPTree<Euclidean2D>(Boolean.TRUE), null); BSPTree<Euclidean2D> a4 = new BSPTree<Euclidean2D>(buildHalfLine(new Vector2D(0.85, -0.05), new Vector2D(0.80, -0.05), false), new BSPTree<Euclidean2D>(Boolean.FALSE), a3, null); BSPTree<Euclidean2D> a5 = new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.82, -0.08), new Vector2D(0.82, -0.18)), new BSPTree<Euclidean2D>(Boolean.FALSE), new BSPTree<Euclidean2D>(Boolean.TRUE), null); BSPTree<Euclidean2D> a6 = new BSPTree<Euclidean2D>(buildHalfLine(new Vector2D(0.82, -0.18), new Vector2D(0.85, -0.15), true), new BSPTree<Euclidean2D>(Boolean.FALSE), a5, null); BSPTree<Euclidean2D> a7 = new BSPTree<Euclidean2D>(buildHalfLine(new Vector2D(0.85, -0.05), new Vector2D(0.82, -0.08), false), a4, a6, null); BSPTree<Euclidean2D> a8 = new BSPTree<Euclidean2D>(buildLine(new Vector2D(0.85, -0.25), new Vector2D(0.85, 0.05)), a2, a7, null); BSPTree<Euclidean2D> a9 = new BSPTree<Euclidean2D>(buildLine(new Vector2D(0.90, 0.05), new Vector2D(0.90, -0.50)), a8, new BSPTree<Euclidean2D>(Boolean.FALSE), null); BSPTree<Euclidean2D> b0 = new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.92, -0.12), new Vector2D(0.92, -0.08)), new BSPTree<Euclidean2D>(Boolean.FALSE), new BSPTree<Euclidean2D>(Boolean.TRUE), null); BSPTree<Euclidean2D> b1 = new BSPTree<Euclidean2D>(buildHalfLine(new Vector2D(0.92, -0.08), new Vector2D(0.90, -0.10), true), new BSPTree<Euclidean2D>(Boolean.FALSE), b0, null); BSPTree<Euclidean2D> b2 = new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.92, -0.18), new Vector2D(0.92, -0.12)), new BSPTree<Euclidean2D>(Boolean.FALSE), new BSPTree<Euclidean2D>(Boolean.TRUE), null); BSPTree<Euclidean2D> b3 = new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.85, -0.15), new Vector2D(0.90, -0.20)), new BSPTree<Euclidean2D>(Boolean.FALSE), b2, null); BSPTree<Euclidean2D> b4 = new BSPTree<Euclidean2D>(buildSegment(new Vector2D(0.95, -0.15), new Vector2D(0.85, -0.05)), b1, b3, null); BSPTree<Euclidean2D> b5 = new BSPTree<Euclidean2D>(buildHalfLine(new Vector2D(0.85, -0.05), new Vector2D(0.85, -0.25), true), new BSPTree<Euclidean2D>(Boolean.FALSE), b4, null); BSPTree<Euclidean2D> b6 = new BSPTree<Euclidean2D>(buildLine(new Vector2D(0.0, -1.10), new Vector2D(1.0, -0.10)), new BSPTree<Euclidean2D>(Boolean.FALSE), b5, null); PolygonsSet c = (PolygonsSet) new RegionFactory<Euclidean2D>().union(new PolygonsSet(a9), new PolygonsSet(b6)); checkPoints(Region.Location.INSIDE, c, new Vector2D[] { new Vector2D(0.83, -0.06), new Vector2D(0.83, -0.15), new Vector2D(0.88, -0.15), new Vector2D(0.88, -0.09), new Vector2D(0.88, -0.07), new Vector2D(0.91, -0.18), new Vector2D(0.91, -0.10) }); checkPoints(Region.Location.OUTSIDE, c, new Vector2D[] { new Vector2D(0.80, -0.10), new Vector2D(0.83, -0.50), new Vector2D(0.83, -0.20), new Vector2D(0.83, -0.02), new Vector2D(0.87, -0.50), new Vector2D(0.87, -0.20), new Vector2D(0.87, -0.02), new Vector2D(0.91, -0.20), new Vector2D(0.91, -0.08), new Vector2D(0.93, -0.15) }); checkVertices(c.getVertices(), new Vector2D[][] { new Vector2D[] { new Vector2D(0.85, -0.15), new Vector2D(0.90, -0.20), new Vector2D(0.92, -0.18), new Vector2D(0.92, -0.08), new Vector2D(0.90, -0.10), new Vector2D(0.90, -0.05), new Vector2D(0.82, -0.05), new Vector2D(0.82, -0.18), } }); } @Test public void testBug20041003() { Line[] l = { new Line(new Vector2D(0.0, 0.625000007541172), new Vector2D(1.0, 0.625000007541172)), new Line(new Vector2D(-0.19204433621902645, 0.0), new Vector2D(-0.19204433621902645, 1.0)), new Line(new Vector2D(-0.40303524786887, 0.4248364535319128), new Vector2D(-1.12851149797877, -0.2634107480798909)), new Line(new Vector2D(0.0, 2.0), new Vector2D(1.0, 2.0)) }; BSPTree<Euclidean2D> node1 = new BSPTree<Euclidean2D>(new SubLine(l[0], new IntervalsSet(intersectionAbscissa(l[0], l[1]), intersectionAbscissa(l[0], l[2]))), new BSPTree<Euclidean2D>(Boolean.TRUE), new BSPTree<Euclidean2D>(Boolean.FALSE), null); BSPTree<Euclidean2D> node2 = new BSPTree<Euclidean2D>(new SubLine(l[1], new IntervalsSet(intersectionAbscissa(l[1], l[2]), intersectionAbscissa(l[1], l[3]))), node1, new BSPTree<Euclidean2D>(Boolean.FALSE), null); BSPTree<Euclidean2D> node3 = new BSPTree<Euclidean2D>(new SubLine(l[2], new IntervalsSet(intersectionAbscissa(l[2], l[3]), Double.POSITIVE_INFINITY)), node2, new BSPTree<Euclidean2D>(Boolean.FALSE), null); BSPTree<Euclidean2D> node4 = new BSPTree<Euclidean2D>(l[3].wholeHyperplane(), node3, new BSPTree<Euclidean2D>(Boolean.FALSE), null); PolygonsSet set = new PolygonsSet(node4); Assert.assertEquals(0, set.getVertices().length); } @Test public void testSqueezedHexa() { PolygonsSet set = new PolygonsSet(1.0e-10, new Vector2D(-6, -4), new Vector2D(-8, -8), new Vector2D( 8, -8), new Vector2D( 6, -4), new Vector2D(10, 4), new Vector2D(-10, 4)); Assert.assertEquals(Location.OUTSIDE, set.checkPoint(new Vector2D(0, 6))); } @Test public void testIssue880Simplified() { Vector2D[] vertices1 = new Vector2D[] { new Vector2D( 90.13595870833188, 38.33604606376991), new Vector2D( 90.14047850603913, 38.34600084496253), new Vector2D( 90.11045289492762, 38.36801537312368), new Vector2D( 90.10871471476526, 38.36878044144294), new Vector2D( 90.10424901707671, 38.374300101757), new Vector2D( 90.0979455456843, 38.373578376172475), new Vector2D( 90.09081227075944, 38.37526295920463), new Vector2D( 90.09081378927135, 38.375193883266434) }; PolygonsSet set1 = new PolygonsSet(1.0e-10, vertices1); Assert.assertEquals(Location.OUTSIDE, set1.checkPoint(new Vector2D(90.12, 38.32))); Assert.assertEquals(Location.OUTSIDE, set1.checkPoint(new Vector2D(90.135, 38.355))); } @Test public void testIssue880Complete() { Vector2D[] vertices1 = new Vector2D[] { new Vector2D( 90.08714908223715, 38.370299337260235), new Vector2D( 90.08709517675004, 38.3702895991413), new Vector2D( 90.08401538704919, 38.368849330127944), new Vector2D( 90.08258210430711, 38.367634558585564), new Vector2D( 90.08251455106665, 38.36763409247078), new Vector2D( 90.08106599752608, 38.36761621664249), new Vector2D( 90.08249585300035, 38.36753627557965), new Vector2D( 90.09075743352184, 38.35914647644972), new Vector2D( 90.09099945896571, 38.35896264724079), new Vector2D( 90.09269383800086, 38.34595756121246), new Vector2D( 90.09638631543191, 38.3457988093121), new Vector2D( 90.09666417351019, 38.34523360999418), new Vector2D( 90.1297082145872, 38.337670454923625), new Vector2D( 90.12971687748956, 38.337669827794684), new Vector2D( 90.1240820219179, 38.34328502001131), new Vector2D( 90.13084259656404, 38.34017811765017), new Vector2D( 90.13378567942857, 38.33860579180606), new Vector2D( 90.13519557833206, 38.33621054663689), new Vector2D( 90.13545616732307, 38.33614965452864), new Vector2D( 90.13553111202748, 38.33613962818305), new Vector2D( 90.1356903436448, 38.33610227127048), new Vector2D( 90.13576283227428, 38.33609255422783), new Vector2D( 90.13595870833188, 38.33604606376991), new Vector2D( 90.1361556630693, 38.3360024198866), new Vector2D( 90.13622408795709, 38.335987048115726), new Vector2D( 90.13696189099994, 38.33581914328681), new Vector2D( 90.13746655304897, 38.33616706665265), new Vector2D( 90.13845973716064, 38.33650776167099), new Vector2D( 90.13950901827667, 38.3368469456463), new Vector2D( 90.14393814424852, 38.337591835857495), new Vector2D( 90.14483839716831, 38.337076122362475), new Vector2D( 90.14565474433601, 38.33769000964429), new Vector2D( 90.14569421179482, 38.3377117256905), new Vector2D( 90.14577067124333, 38.33770883625908), new Vector2D( 90.14600350631684, 38.337714326520995), new Vector2D( 90.14600355139731, 38.33771435193319), new Vector2D( 90.14600369112401, 38.33771443882085), new Vector2D( 90.14600382486884, 38.33771453466096), new Vector2D( 90.14600395205912, 38.33771463904344), new Vector2D( 90.14600407214999, 38.337714751520764), new Vector2D( 90.14600418462749, 38.337714871611695), new Vector2D( 90.14600422249327, 38.337714915811034), new Vector2D( 90.14867838361471, 38.34113888210675), new Vector2D( 90.14923750157374, 38.341582537502575), new Vector2D( 90.14877083250991, 38.34160685841391), new Vector2D( 90.14816667319519, 38.34244232585684), new Vector2D( 90.14797696744586, 38.34248455284745), new Vector2D( 90.14484318014337, 38.34385573215269), new Vector2D( 90.14477919958296, 38.3453797747614), new Vector2D( 90.14202393306448, 38.34464324839456), new Vector2D( 90.14198920640195, 38.344651155237216), new Vector2D( 90.14155207025175, 38.34486424263724), new Vector2D( 90.1415196143314, 38.344871730519), new Vector2D( 90.14128611910814, 38.34500196593859), new Vector2D( 90.14047850603913, 38.34600084496253), new Vector2D( 90.14045907000337, 38.34601860032171), new Vector2D( 90.14039496493928, 38.346223030432384), new Vector2D( 90.14037626063737, 38.346240203360026), new Vector2D( 90.14030005823724, 38.34646920000705), new Vector2D( 90.13799164754806, 38.34903093011013), new Vector2D( 90.11045289492762, 38.36801537312368), new Vector2D( 90.10871471476526, 38.36878044144294), new Vector2D( 90.10424901707671, 38.374300101757), new Vector2D( 90.10263482039932, 38.37310041316073), new Vector2D( 90.09834601753448, 38.373615053823414), new Vector2D( 90.0979455456843, 38.373578376172475), new Vector2D( 90.09086514328669, 38.37527884194668), new Vector2D( 90.09084931407364, 38.37590801712463), new Vector2D( 90.09081227075944, 38.37526295920463), new Vector2D( 90.09081378927135, 38.375193883266434) }; PolygonsSet set1 = new PolygonsSet(1.0e-8, vertices1); Assert.assertEquals(Location.OUTSIDE, set1.checkPoint(new Vector2D(90.0905, 38.3755))); Assert.assertEquals(Location.INSIDE, set1.checkPoint(new Vector2D(90.09084, 38.3755))); Assert.assertEquals(Location.OUTSIDE, set1.checkPoint(new Vector2D(90.0913, 38.3755))); Assert.assertEquals(Location.INSIDE, set1.checkPoint(new Vector2D(90.1042, 38.3739))); Assert.assertEquals(Location.INSIDE, set1.checkPoint(new Vector2D(90.1111, 38.3673))); Assert.assertEquals(Location.OUTSIDE, set1.checkPoint(new Vector2D(90.0959, 38.3457))); Vector2D[] vertices2 = new Vector2D[] { new Vector2D( 90.13067558880044, 38.36977255037573), new Vector2D( 90.12907570488, 38.36817308242706), new Vector2D( 90.1342774136516, 38.356886880294724), new Vector2D( 90.13090330629757, 38.34664392676211), new Vector2D( 90.13078571364593, 38.344904617518466), new Vector2D( 90.1315602208914, 38.3447185040846), new Vector2D( 90.1316336226821, 38.34470643148342), new Vector2D( 90.134020944832, 38.340936644972885), new Vector2D( 90.13912536387306, 38.335497255122334), new Vector2D( 90.1396178806582, 38.334878075552126), new Vector2D( 90.14083049696671, 38.33316530644106), new Vector2D( 90.14145252901329, 38.33152722916191), new Vector2D( 90.1404779335565, 38.32863516047786), new Vector2D( 90.14282712131586, 38.327504432532066), new Vector2D( 90.14616669875488, 38.3237354115015), new Vector2D( 90.14860976050608, 38.315714862457924), new Vector2D( 90.14999277782437, 38.3164932507504), new Vector2D( 90.15005207194997, 38.316534677663356), new Vector2D( 90.15508513859612, 38.31878731691609), new Vector2D( 90.15919938519221, 38.31852743183782), new Vector2D( 90.16093758658837, 38.31880662005153), new Vector2D( 90.16099420184912, 38.318825953291594), new Vector2D( 90.1665411125756, 38.31859497874757), new Vector2D( 90.16999653861313, 38.32505772048029), new Vector2D( 90.17475243391698, 38.32594398441148), new Vector2D( 90.17940844844992, 38.327427213761325), new Vector2D( 90.20951909541378, 38.330616833491774), new Vector2D( 90.2155400467941, 38.331746223670336), new Vector2D( 90.21559881391778, 38.33175551425302), new Vector2D( 90.21916646426041, 38.332584299620805), new Vector2D( 90.23863749852285, 38.34778978875795), new Vector2D( 90.25459855175802, 38.357790570608984), new Vector2D( 90.25964298227257, 38.356918010203174), new Vector2D( 90.26024593994703, 38.361692743151366), new Vector2D( 90.26146187570015, 38.36311080550837), new Vector2D( 90.26614159359622, 38.36510808579902), new Vector2D( 90.26621342936448, 38.36507942500333), new Vector2D( 90.26652190211962, 38.36494042196722), new Vector2D( 90.26621240678867, 38.365113172030874), new Vector2D( 90.26614057102057, 38.365141832826794), new Vector2D( 90.26380080055299, 38.3660381760273), new Vector2D( 90.26315345241, 38.36670658276421), new Vector2D( 90.26251574942881, 38.367490323488084), new Vector2D( 90.26247873448426, 38.36755266444749), new Vector2D( 90.26234628016698, 38.36787989125406), new Vector2D( 90.26214559424784, 38.36945909356126), new Vector2D( 90.25861728442555, 38.37200753430875), new Vector2D( 90.23905557537864, 38.375405314295904), new Vector2D( 90.22517251874075, 38.38984691662256), new Vector2D( 90.22549955153215, 38.3911564273979), new Vector2D( 90.22434386063355, 38.391476432092134), new Vector2D( 90.22147729457276, 38.39134652252034), new Vector2D( 90.22142070120117, 38.391349167741964), new Vector2D( 90.20665060751588, 38.39475580900313), new Vector2D( 90.20042268367109, 38.39842558622888), new Vector2D( 90.17423771242085, 38.402727751805344), new Vector2D( 90.16756796257476, 38.40913898597597), new Vector2D( 90.16728283954308, 38.411255399912875), new Vector2D( 90.16703538220418, 38.41136059866693), new Vector2D( 90.16725865657685, 38.41013618805954), new Vector2D( 90.16746107640665, 38.40902614307544), new Vector2D( 90.16122795307462, 38.39773101873203) }; PolygonsSet set2 = new PolygonsSet(1.0e-8, vertices2); PolygonsSet set = (PolygonsSet) new RegionFactory<Euclidean2D>().difference(set1.copySelf(), set2.copySelf()); Vector2D[][] verticies = set.getVertices(); Assert.assertTrue(verticies[0][0] != null); Assert.assertEquals(1, verticies.length); } private PolygonsSet buildSet(Vector2D[][] vertices) { ArrayList<SubHyperplane<Euclidean2D>> edges = new ArrayList<SubHyperplane<Euclidean2D>>(); for (int i = 0; i < vertices.length; ++i) { int l = vertices[i].length; for (int j = 0; j < l; ++j) { edges.add(buildSegment(vertices[i][j], vertices[i][(j + 1) % l])); } } return new PolygonsSet(edges); } private SubHyperplane<Euclidean2D> buildLine(Vector2D start, Vector2D end) { return new Line(start, end).wholeHyperplane(); } private double intersectionAbscissa(Line l0, Line l1) { Vector2D p = l0.intersection(l1); return (l0.toSubSpace(p)).getX(); } private SubHyperplane<Euclidean2D> buildHalfLine(Vector2D start, Vector2D end, boolean startIsVirtual) { Line line = new Line(start, end); double lower = startIsVirtual ? Double.NEGATIVE_INFINITY : (line.toSubSpace(start)).getX(); double upper = startIsVirtual ? (line.toSubSpace(end)).getX() : Double.POSITIVE_INFINITY; return new SubLine(line, new IntervalsSet(lower, upper)); } private SubHyperplane<Euclidean2D> buildSegment(Vector2D start, Vector2D end) { Line line = new Line(start, end); double lower = (line.toSubSpace(start)).getX(); double upper = (line.toSubSpace(end)).getX(); return new SubLine(line, new IntervalsSet(lower, upper)); } private void checkPoints(Region.Location expected, PolygonsSet set, Vector2D[] points) { for (int i = 0; i < points.length; ++i) { Assert.assertEquals(expected, set.checkPoint(points[i])); } } private boolean checkInSegment(Vector2D p, Vector2D p1, Vector2D p2, double tolerance) { Line line = new Line(p1, p2); if (line.getOffset(p) < tolerance) { double x = (line.toSubSpace(p)).getX(); double x1 = (line.toSubSpace(p1)).getX(); double x2 = (line.toSubSpace(p2)).getX(); return (((x - x1) * (x - x2) <= 0.0) || (p1.distance(p) < tolerance) || (p2.distance(p) < tolerance)); } else { return false; } } private void checkVertices(Vector2D[][] rebuiltVertices, Vector2D[][] vertices) { // each rebuilt vertex should be in a segment joining two original vertices for (int i = 0; i < rebuiltVertices.length; ++i) { for (int j = 0; j < rebuiltVertices[i].length; ++j) { boolean inSegment = false; Vector2D p = rebuiltVertices[i][j]; for (int k = 0; k < vertices.length; ++k) { Vector2D[] loop = vertices[k]; int length = loop.length; for (int l = 0; (! inSegment) && (l < length); ++l) { inSegment = checkInSegment(p, loop[l], loop[(l + 1) % length], 1.0e-10); } } Assert.assertTrue(inSegment); } } // each original vertex should have a corresponding rebuilt vertex for (int k = 0; k < vertices.length; ++k) { for (int l = 0; l < vertices[k].length; ++l) { double min = Double.POSITIVE_INFINITY; for (int i = 0; i < rebuiltVertices.length; ++i) { for (int j = 0; j < rebuiltVertices[i].length; ++j) { min = FastMath.min(vertices[k][l].distance(rebuiltVertices[i][j]), min); } } Assert.assertEquals(0.0, min, 1.0e-10); } } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.geometry.euclidean.twod; import org.apache.commons.math3.geometry.euclidean.twod.Line; import org.apache.commons.math3.geometry.euclidean.twod.Vector2D; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class SegmentTest { @Test public void testDistance() { Vector2D start = new Vector2D(2, 2); Vector2D end = new Vector2D(-2, -2); Segment segment = new Segment(start, end, new Line(start, end)); // distance to center of segment Assert.assertEquals(FastMath.sqrt(2), segment.distance(new Vector2D(1, -1)), 1.0e-10); // distance a point on segment Assert.assertEquals(FastMath.sin(Math.PI / 4.0), segment.distance(new Vector2D(0, -1)), 1.0e-10); // distance to end point Assert.assertEquals(FastMath.sqrt(8), segment.distance(new Vector2D(0, 4)), 1.0e-10); // distance to start point Assert.assertEquals(FastMath.sqrt(8), segment.distance(new Vector2D(0, -4)), 1.0e-10); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.geometry.euclidean.twod; import java.util.List; import org.apache.commons.math3.geometry.euclidean.oned.Euclidean1D; import org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet; import org.apache.commons.math3.geometry.partitioning.RegionFactory; import org.junit.Assert; import org.junit.Test; public class SubLineTest { @Test public void testEndPoints() { Vector2D p1 = new Vector2D(-1, -7); Vector2D p2 = new Vector2D(7, -1); Segment segment = new Segment(p1, p2, new Line(p1, p2)); SubLine sub = new SubLine(segment); List<Segment> segments = sub.getSegments(); Assert.assertEquals(1, segments.size()); Assert.assertEquals(0.0, new Vector2D(-1, -7).distance(segments.get(0).getStart()), 1.0e-10); Assert.assertEquals(0.0, new Vector2D( 7, -1).distance(segments.get(0).getEnd()), 1.0e-10); } @Test public void testNoEndPoints() { SubLine wholeLine = new Line(new Vector2D(-1, 7), new Vector2D(7, 1)).wholeHyperplane(); List<Segment> segments = wholeLine.getSegments(); Assert.assertEquals(1, segments.size()); Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getX()) && segments.get(0).getStart().getX() < 0); Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getY()) && segments.get(0).getStart().getY() > 0); Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getX()) && segments.get(0).getEnd().getX() > 0); Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getY()) && segments.get(0).getEnd().getY() < 0); } @Test public void testNoSegments() { SubLine empty = new SubLine(new Line(new Vector2D(-1, -7), new Vector2D(7, -1)), new RegionFactory<Euclidean1D>().getComplement(new IntervalsSet())); List<Segment> segments = empty.getSegments(); Assert.assertEquals(0, segments.size()); } @Test public void testSeveralSegments() { SubLine twoSubs = new SubLine(new Line(new Vector2D(-1, -7), new Vector2D(7, -1)), new RegionFactory<Euclidean1D>().union(new IntervalsSet(1, 2), new IntervalsSet(3, 4))); List<Segment> segments = twoSubs.getSegments(); Assert.assertEquals(2, segments.size()); } @Test public void testHalfInfiniteNeg() { SubLine empty = new SubLine(new Line(new Vector2D(-1, -7), new Vector2D(7, -1)), new IntervalsSet(Double.NEGATIVE_INFINITY, 0.0)); List<Segment> segments = empty.getSegments(); Assert.assertEquals(1, segments.size()); Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getX()) && segments.get(0).getStart().getX() < 0); Assert.assertTrue(Double.isInfinite(segments.get(0).getStart().getY()) && segments.get(0).getStart().getY() < 0); Assert.assertEquals(0.0, new Vector2D(3, -4).distance(segments.get(0).getEnd()), 1.0e-10); } @Test public void testHalfInfinitePos() { SubLine empty = new SubLine(new Line(new Vector2D(-1, -7), new Vector2D(7, -1)), new IntervalsSet(0.0, Double.POSITIVE_INFINITY)); List<Segment> segments = empty.getSegments(); Assert.assertEquals(1, segments.size()); Assert.assertEquals(0.0, new Vector2D(3, -4).distance(segments.get(0).getStart()), 1.0e-10); Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getX()) && segments.get(0).getEnd().getX() > 0); Assert.assertTrue(Double.isInfinite(segments.get(0).getEnd().getY()) && segments.get(0).getEnd().getY() > 0); } @Test public void testIntersectionInsideInside() { SubLine sub1 = new SubLine(new Vector2D(1, 1), new Vector2D(3, 1)); SubLine sub2 = new SubLine(new Vector2D(2, 0), new Vector2D(2, 2)); Assert.assertEquals(0.0, new Vector2D(2, 1).distance(sub1.intersection(sub2, true)), 1.0e-12); Assert.assertEquals(0.0, new Vector2D(2, 1).distance(sub1.intersection(sub2, false)), 1.0e-12); } @Test public void testIntersectionInsideBoundary() { SubLine sub1 = new SubLine(new Vector2D(1, 1), new Vector2D(3, 1)); SubLine sub2 = new SubLine(new Vector2D(2, 0), new Vector2D(2, 1)); Assert.assertEquals(0.0, new Vector2D(2, 1).distance(sub1.intersection(sub2, true)), 1.0e-12); Assert.assertNull(sub1.intersection(sub2, false)); } @Test public void testIntersectionInsideOutside() { SubLine sub1 = new SubLine(new Vector2D(1, 1), new Vector2D(3, 1)); SubLine sub2 = new SubLine(new Vector2D(2, 0), new Vector2D(2, 0.5)); Assert.assertNull(sub1.intersection(sub2, true)); Assert.assertNull(sub1.intersection(sub2, false)); } @Test public void testIntersectionBoundaryBoundary() { SubLine sub1 = new SubLine(new Vector2D(1, 1), new Vector2D(2, 1)); SubLine sub2 = new SubLine(new Vector2D(2, 0), new Vector2D(2, 1)); Assert.assertEquals(0.0, new Vector2D(2, 1).distance(sub1.intersection(sub2, true)), 1.0e-12); Assert.assertNull(sub1.intersection(sub2, false)); } @Test public void testIntersectionBoundaryOutside() { SubLine sub1 = new SubLine(new Vector2D(1, 1), new Vector2D(2, 1)); SubLine sub2 = new SubLine(new Vector2D(2, 0), new Vector2D(2, 0.5)); Assert.assertNull(sub1.intersection(sub2, true)); Assert.assertNull(sub1.intersection(sub2, false)); } @Test public void testIntersectionOutsideOutside() { SubLine sub1 = new SubLine(new Vector2D(1, 1), new Vector2D(1.5, 1)); SubLine sub2 = new SubLine(new Vector2D(2, 0), new Vector2D(2, 0.5)); Assert.assertNull(sub1.intersection(sub2, true)); Assert.assertNull(sub1.intersection(sub2, false)); } @Test public void testIntersectionParallel() { final SubLine sub1 = new SubLine(new Vector2D(0, 1), new Vector2D(0, 2)); final SubLine sub2 = new SubLine(new Vector2D(66, 3), new Vector2D(66, 4)); Assert.assertNull(sub1.intersection(sub2, true)); Assert.assertNull(sub1.intersection(sub2, false)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.geometry.partitioning.utilities; import org.apache.commons.math3.geometry.partitioning.utilities.AVLTree; import org.junit.Assert; import org.junit.Test; public class AVLTreeTest { @Test public void testInsert() { // this array in this order allows to pass in all branches // of the insertion algorithm int[] array = { 16, 13, 15, 14, 2, 0, 12, 9, 8, 5, 11, 18, 19, 17, 4, 7, 1, 3, 6, 10 }; AVLTree<Integer> tree = buildTree(array); Assert.assertEquals(array.length, tree.size()); for (int i = 0; i < array.length; ++i) { Assert.assertEquals(array[i], value(tree.getNotSmaller(new Integer(array[i])))); } checkOrder(tree); } @Test public void testDelete1() { int[][][] arrays = { { { 16, 13, 15, 14, 2, 0, 12, 9, 8, 5, 11, 18, 19, 17, 4, 7, 1, 3, 6, 10 }, { 11, 10, 9, 12, 16, 15, 13, 18, 5, 0, 3, 2, 14, 6, 19, 17, 8, 4, 7, 1 } }, { { 16, 13, 15, 14, 2, 0, 12, 9, 8, 5, 11, 18, 19, 17, 4, 7, 1, 3, 6, 10 }, { 0, 17, 14, 15, 16, 18, 6 } }, { { 6, 2, 7, 8, 1, 4, 3, 5 }, { 8 } }, { { 6, 2, 7, 8, 1, 4, 5 }, { 8 } }, { { 3, 7, 2, 1, 5, 8, 4 }, { 1 } }, { { 3, 7, 2, 1, 5, 8, 6 }, { 1 } } }; for (int i = 0; i < arrays.length; ++i) { AVLTree<Integer> tree = buildTree(arrays[i][0]); Assert.assertTrue(! tree.delete(new Integer(-2000))); for (int j = 0; j < arrays[i][1].length; ++j) { Assert.assertTrue(tree.delete(tree.getNotSmaller(new Integer(arrays[i][1][j])).getElement())); Assert.assertEquals(arrays[i][0].length - j - 1, tree.size()); } } } @Test public void testNavigation() { int[] array = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; AVLTree<Integer> tree = buildTree(array); AVLTree<Integer>.Node node = tree.getSmallest(); Assert.assertEquals(array[0], value(node)); for (int i = 0; i < array.length; ++i) { Assert.assertEquals(array[i], value(node)); node = node.getNext(); } Assert.assertNull(node); node = tree.getLargest(); Assert.assertEquals(array[array.length - 1], value(node)); for (int i = array.length - 1; i >= 0; --i) { Assert.assertEquals(array[i], value(node)); node = node.getPrevious(); } Assert.assertNull(node); checkOrder(tree); } @Test public void testSearch() { int[] array = { 2, 4, 6, 8, 10, 12, 14 }; AVLTree<Integer> tree = buildTree(array); Assert.assertNull(tree.getNotLarger(new Integer(array[0] - 1))); Assert.assertNull(tree.getNotSmaller(new Integer(array[array.length - 1] + 1))); for (int i = 0; i < array.length; ++i) { Assert.assertEquals(array[i], value(tree.getNotSmaller(new Integer(array[i] - 1)))); Assert.assertEquals(array[i], value(tree.getNotLarger(new Integer(array[i] + 1)))); } checkOrder(tree); } @Test public void testRepetition() { int[] array = { 1, 1, 3, 3, 4, 5, 6, 7, 7, 7, 7, 7 }; AVLTree<Integer> tree = buildTree(array); Assert.assertEquals(array.length, tree.size()); AVLTree<Integer>.Node node = tree.getNotSmaller(new Integer(3)); Assert.assertEquals(3, value(node)); Assert.assertEquals(1, value(node.getPrevious())); Assert.assertEquals(3, value(node.getNext())); Assert.assertEquals(4, value(node.getNext().getNext())); node = tree.getNotLarger(new Integer(2)); Assert.assertEquals(1, value(node)); Assert.assertEquals(1, value(node.getPrevious())); Assert.assertEquals(3, value(node.getNext())); Assert.assertNull(node.getPrevious().getPrevious()); AVLTree<Integer>.Node otherNode = tree.getNotSmaller(new Integer(1)); Assert.assertTrue(node != otherNode); Assert.assertEquals(1, value(otherNode)); Assert.assertNull(otherNode.getPrevious()); node = tree.getNotLarger(new Integer(10)); Assert.assertEquals(7, value(node)); Assert.assertNull(node.getNext()); node = node.getPrevious(); Assert.assertEquals(7, value(node)); node = node.getPrevious(); Assert.assertEquals(7, value(node)); node = node.getPrevious(); Assert.assertEquals(7, value(node)); node = node.getPrevious(); Assert.assertEquals(7, value(node)); node = node.getPrevious(); Assert.assertEquals(6, value(node)); checkOrder(tree); } private AVLTree<Integer> buildTree(int[] array) { AVLTree<Integer> tree = new AVLTree<Integer>(); for (int i = 0; i < array.length; ++i) { tree.insert(new Integer(array[i])); tree.insert(null); } return tree; } private int value(AVLTree<Integer>.Node node) { return node.getElement().intValue(); } private void checkOrder(AVLTree<Integer> tree) { AVLTree<Integer>.Node next = null; for (AVLTree<Integer>.Node node = tree.getSmallest(); node != null; node = next) { next = node.getNext(); if (next != null) { Assert.assertTrue(node.getElement().compareTo(next.getElement()) <= 0); } } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import org.junit.Test; import org.junit.Assert; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.NullArgumentException; import org.apache.commons.math3.exception.OutOfRangeException; import org.apache.commons.math3.exception.NoDataException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.exception.MathIllegalStateException; /** * Test cases for the {@link Array2DRowRealMatrix} class. * * @version $Id$ */ public final class Array2DRowRealMatrixTest { // 3 x 3 identity matrix protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} }; // Test data for group operations protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} }; protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}}; protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} }; protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d}, {-1d,0d,-8d} }; protected double[] testDataRow1 = {1d,2d,3d}; protected double[] testDataCol3 = {3d,3d,8d}; protected double[][] testDataInv = { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} }; protected double[] preMultTest = {8,12,33}; protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}}; protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}}; protected double[][] testDataPlusInv = { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} }; // lu decomposition tests protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} }; protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d}, {0.33333333333333,0d,0.33333333333333} }; // singular matrices protected double[][] singular = { {2d,3d}, {2d,3d} }; protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d}, {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} }; protected double[][] detData2 = { {1d, 3d}, {2d, 4d}}; // vectors protected double[] testVector = {1,2,3}; protected double[] testVector2 = {1,2,3,4}; // submatrix accessor tests protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5}, {2, 4, 6, 8}, {4, 5, 6, 7}}; // array selections protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}}; protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}}; protected double[][] subRows03Cols123 = { {2, 3, 4} , {5, 6, 7}}; // effective permutations protected double[][] subRows20Cols123 = { {4, 6, 8} , {2, 3, 4}}; protected double[][] subRows31Cols31 = {{7, 5}, {4.5, 2.5}}; // contiguous ranges protected double[][] subRows01Cols23 = {{3,4} , {3.5, 4.5}}; protected double[][] subRows23Cols00 = {{2} , {4}}; protected double[][] subRows00Cols33 = {{4}}; // row matrices protected double[][] subRow0 = {{1,2,3,4}}; protected double[][] subRow3 = {{4,5,6,7}}; // column matrices protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}}; protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}}; // tolerances protected double entryTolerance = 10E-16; protected double normTolerance = 10E-14; protected double powerTolerance = 10E-16; /** test dimensions */ @Test public void testDimensions() { Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData); Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2); Assert.assertEquals("testData row dimension",3,m.getRowDimension()); Assert.assertEquals("testData column dimension",3,m.getColumnDimension()); Assert.assertTrue("testData is square",m.isSquare()); Assert.assertEquals("testData2 row dimension",m2.getRowDimension(),2); Assert.assertEquals("testData2 column dimension",m2.getColumnDimension(),3); Assert.assertTrue("testData2 is not square",!m2.isSquare()); } /** test copy functions */ @Test public void testCopyFunctions() { Array2DRowRealMatrix m1 = new Array2DRowRealMatrix(testData); Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(m1.getData()); Assert.assertEquals(m2,m1); Array2DRowRealMatrix m3 = new Array2DRowRealMatrix(testData); Array2DRowRealMatrix m4 = new Array2DRowRealMatrix(m3.getData(), false); Assert.assertEquals(m4,m3); } /** test add */ @Test public void testAdd() { Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData); Array2DRowRealMatrix mInv = new Array2DRowRealMatrix(testDataInv); RealMatrix mPlusMInv = m.add(mInv); double[][] sumEntries = mPlusMInv.getData(); for (int row = 0; row < m.getRowDimension(); row++) { for (int col = 0; col < m.getColumnDimension(); col++) { Assert.assertEquals("sum entry entry", testDataPlusInv[row][col],sumEntries[row][col], entryTolerance); } } } /** test add failure */ @Test public void testAddFail() { Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData); Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2); try { m.add(m2); Assert.fail("MathIllegalArgumentException expected"); } catch (MathIllegalArgumentException ex) { // ignored } } /** test norm */ @Test public void testNorm() { Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData); Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2); Assert.assertEquals("testData norm",14d,m.getNorm(),entryTolerance); Assert.assertEquals("testData2 norm",7d,m2.getNorm(),entryTolerance); } /** test Frobenius norm */ @Test public void testFrobeniusNorm() { Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData); Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2); Assert.assertEquals("testData Frobenius norm", FastMath.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance); Assert.assertEquals("testData2 Frobenius norm", FastMath.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance); } /** test m-n = m + -n */ @Test public void testPlusMinus() { Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData); Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testDataInv); TestUtils.assertEquals("m-n = m + -n",m.subtract(m2), m2.scalarMultiply(-1d).add(m),entryTolerance); try { m.subtract(new Array2DRowRealMatrix(testData2)); Assert.fail("Expecting illegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } } /** test multiply */ @Test public void testMultiply() { Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData); Array2DRowRealMatrix mInv = new Array2DRowRealMatrix(testDataInv); Array2DRowRealMatrix identity = new Array2DRowRealMatrix(id); Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testData2); TestUtils.assertEquals("inverse multiply",m.multiply(mInv), identity,entryTolerance); TestUtils.assertEquals("inverse multiply",mInv.multiply(m), identity,entryTolerance); TestUtils.assertEquals("identity multiply",m.multiply(identity), m,entryTolerance); TestUtils.assertEquals("identity multiply",identity.multiply(mInv), mInv,entryTolerance); TestUtils.assertEquals("identity multiply",m2.multiply(identity), m2,entryTolerance); try { m.multiply(new Array2DRowRealMatrix(bigSingular)); Assert.fail("Expecting illegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } } //Additional Test for Array2DRowRealMatrixTest.testMultiply private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}}; private double[][] d4 = new double[][] {{1},{2},{3},{4}}; private double[][] d5 = new double[][] {{30},{70}}; @Test public void testMultiply2() { RealMatrix m3 = new Array2DRowRealMatrix(d3); RealMatrix m4 = new Array2DRowRealMatrix(d4); RealMatrix m5 = new Array2DRowRealMatrix(d5); TestUtils.assertEquals("m3*m4=m5", m3.multiply(m4), m5, entryTolerance); } @Test public void testPower() { Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData); Array2DRowRealMatrix mInv = new Array2DRowRealMatrix(testDataInv); Array2DRowRealMatrix mPlusInv = new Array2DRowRealMatrix(testDataPlusInv); Array2DRowRealMatrix identity = new Array2DRowRealMatrix(id); TestUtils.assertEquals("m^0", m.power(0), identity, entryTolerance); TestUtils.assertEquals("mInv^0", mInv.power(0), identity, entryTolerance); TestUtils.assertEquals("mPlusInv^0", mPlusInv.power(0), identity, entryTolerance); TestUtils.assertEquals("m^1", m.power(1), m, entryTolerance); TestUtils.assertEquals("mInv^1", mInv.power(1), mInv, entryTolerance); TestUtils.assertEquals("mPlusInv^1", mPlusInv.power(1), mPlusInv, entryTolerance); RealMatrix C1 = m.copy(); RealMatrix C2 = mInv.copy(); RealMatrix C3 = mPlusInv.copy(); for (int i = 2; i <= 10; ++i) { C1 = C1.multiply(m); C2 = C2.multiply(mInv); C3 = C3.multiply(mPlusInv); TestUtils.assertEquals("m^" + i, m.power(i), C1, entryTolerance); TestUtils.assertEquals("mInv^" + i, mInv.power(i), C2, entryTolerance); TestUtils.assertEquals("mPlusInv^" + i, mPlusInv.power(i), C3, entryTolerance); } try { Array2DRowRealMatrix mNotSquare = new Array2DRowRealMatrix(testData2T); mNotSquare.power(2); Assert.fail("Expecting NonSquareMatrixException"); } catch (NonSquareMatrixException ex) { // ignored } try { m.power(-1); Assert.fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // ignored } } /** test trace */ @Test public void testTrace() { RealMatrix m = new Array2DRowRealMatrix(id); Assert.assertEquals("identity trace",3d,m.getTrace(),entryTolerance); m = new Array2DRowRealMatrix(testData2); try { m.getTrace(); Assert.fail("Expecting NonSquareMatrixException"); } catch (NonSquareMatrixException ex) { // ignored } } /** test sclarAdd */ @Test public void testScalarAdd() { RealMatrix m = new Array2DRowRealMatrix(testData); TestUtils.assertEquals("scalar add",new Array2DRowRealMatrix(testDataPlus2), m.scalarAdd(2d),entryTolerance); } /** test operate */ @Test public void testOperate() { RealMatrix m = new Array2DRowRealMatrix(id); TestUtils.assertEquals("identity operate", testVector, m.operate(testVector), entryTolerance); TestUtils.assertEquals("identity operate", testVector, m.operate(new ArrayRealVector(testVector)).toArray(), entryTolerance); m = new Array2DRowRealMatrix(bigSingular); try { m.operate(testVector); Assert.fail("Expecting illegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } } /** test issue MATH-209 */ @Test public void testMath209() { RealMatrix a = new Array2DRowRealMatrix(new double[][] { { 1, 2 }, { 3, 4 }, { 5, 6 } }, false); double[] b = a.operate(new double[] { 1, 1 }); Assert.assertEquals(a.getRowDimension(), b.length); Assert.assertEquals( 3.0, b[0], 1.0e-12); Assert.assertEquals( 7.0, b[1], 1.0e-12); Assert.assertEquals(11.0, b[2], 1.0e-12); } /** test transpose */ @Test public void testTranspose() { RealMatrix m = new Array2DRowRealMatrix(testData); RealMatrix mIT = new LUDecomposition(m).getSolver().getInverse().transpose(); RealMatrix mTI = new LUDecomposition(m.transpose()).getSolver().getInverse(); TestUtils.assertEquals("inverse-transpose", mIT, mTI, normTolerance); m = new Array2DRowRealMatrix(testData2); RealMatrix mt = new Array2DRowRealMatrix(testData2T); TestUtils.assertEquals("transpose",mt,m.transpose(),normTolerance); } /** test preMultiply by vector */ @Test public void testPremultiplyVector() { RealMatrix m = new Array2DRowRealMatrix(testData); TestUtils.assertEquals("premultiply", m.preMultiply(testVector), preMultTest, normTolerance); TestUtils.assertEquals("premultiply", m.preMultiply(new ArrayRealVector(testVector).toArray()), preMultTest, normTolerance); m = new Array2DRowRealMatrix(bigSingular); try { m.preMultiply(testVector); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } } @Test public void testPremultiply() { RealMatrix m3 = new Array2DRowRealMatrix(d3); RealMatrix m4 = new Array2DRowRealMatrix(d4); RealMatrix m5 = new Array2DRowRealMatrix(d5); TestUtils.assertEquals("m3*m4=m5", m4.preMultiply(m3), m5, entryTolerance); Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData); Array2DRowRealMatrix mInv = new Array2DRowRealMatrix(testDataInv); Array2DRowRealMatrix identity = new Array2DRowRealMatrix(id); TestUtils.assertEquals("inverse multiply",m.preMultiply(mInv), identity,entryTolerance); TestUtils.assertEquals("inverse multiply",mInv.preMultiply(m), identity,entryTolerance); TestUtils.assertEquals("identity multiply",m.preMultiply(identity), m,entryTolerance); TestUtils.assertEquals("identity multiply",identity.preMultiply(mInv), mInv,entryTolerance); try { m.preMultiply(new Array2DRowRealMatrix(bigSingular)); Assert.fail("Expecting illegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } } @Test public void testGetVectors() { RealMatrix m = new Array2DRowRealMatrix(testData); TestUtils.assertEquals("get row",m.getRow(0),testDataRow1,entryTolerance); TestUtils.assertEquals("get col",m.getColumn(2),testDataCol3,entryTolerance); try { m.getRow(10); Assert.fail("expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // ignored } try { m.getColumn(-1); Assert.fail("expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // ignored } } @Test public void testGetEntry() { RealMatrix m = new Array2DRowRealMatrix(testData); Assert.assertEquals("get entry",m.getEntry(0,1),2d,entryTolerance); try { m.getEntry(10, 4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } /** test examples in user guide */ @Test public void testExamples() { // Create a real matrix with two rows and three columns double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}}; RealMatrix m = new Array2DRowRealMatrix(matrixData); // One more with three rows, two columns double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}}; RealMatrix n = new Array2DRowRealMatrix(matrixData2); // Now multiply m by n RealMatrix p = m.multiply(n); Assert.assertEquals(2, p.getRowDimension()); Assert.assertEquals(2, p.getColumnDimension()); // Invert p RealMatrix pInverse = new LUDecomposition(p).getSolver().getInverse(); Assert.assertEquals(2, pInverse.getRowDimension()); Assert.assertEquals(2, pInverse.getColumnDimension()); // Solve example double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}}; RealMatrix coefficients = new Array2DRowRealMatrix(coefficientsData); RealVector constants = new ArrayRealVector(new double[]{1, -2, 1}, false); RealVector solution = new LUDecomposition(coefficients).getSolver().solve(constants); final double cst0 = constants.getEntry(0); final double cst1 = constants.getEntry(1); final double cst2 = constants.getEntry(2); final double sol0 = solution.getEntry(0); final double sol1 = solution.getEntry(1); final double sol2 = solution.getEntry(2); Assert.assertEquals(2 * sol0 + 3 * sol1 -2 * sol2, cst0, 1E-12); Assert.assertEquals(-1 * sol0 + 7 * sol1 + 6 * sol2, cst1, 1E-12); Assert.assertEquals(4 * sol0 - 3 * sol1 -5 * sol2, cst2, 1E-12); } // test submatrix accessors @Test public void testGetSubMatrix() { RealMatrix m = new Array2DRowRealMatrix(subTestData); checkGetSubMatrix(m, subRows23Cols00, 2 , 3 , 0, 0, false); checkGetSubMatrix(m, subRows00Cols33, 0 , 0 , 3, 3, false); checkGetSubMatrix(m, subRows01Cols23, 0 , 1 , 2, 3, false); checkGetSubMatrix(m, subRows02Cols13, new int[] { 0, 2 }, new int[] { 1, 3 }, false); checkGetSubMatrix(m, subRows03Cols12, new int[] { 0, 3 }, new int[] { 1, 2 }, false); checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); checkGetSubMatrix(m, subRows31Cols31, new int[] { 3, 1 }, new int[] { 3, 1 }, false); checkGetSubMatrix(m, subRows31Cols31, new int[] { 3, 1 }, new int[] { 3, 1 }, false); checkGetSubMatrix(m, null, 1, 0, 2, 4, true); checkGetSubMatrix(m, null, -1, 1, 2, 2, true); checkGetSubMatrix(m, null, 1, 0, 2, 2, true); checkGetSubMatrix(m, null, 1, 0, 2, 4, true); checkGetSubMatrix(m, null, new int[] {}, new int[] { 0 }, true); checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 }, true); } private void checkGetSubMatrix(RealMatrix m, double[][] reference, int startRow, int endRow, int startColumn, int endColumn, boolean mustFail) { try { RealMatrix sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn); Assert.assertEquals(new Array2DRowRealMatrix(reference), sub); if (mustFail) { Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException"); } } catch (OutOfRangeException e) { if (!mustFail) { throw e; } } catch (NumberIsTooSmallException e) { if (!mustFail) { throw e; } } catch (NoDataException e) { if (!mustFail) { throw e; } } } private void checkGetSubMatrix(RealMatrix m, double[][] reference, int[] selectedRows, int[] selectedColumns, boolean mustFail) { try { RealMatrix sub = m.getSubMatrix(selectedRows, selectedColumns); Assert.assertEquals(new Array2DRowRealMatrix(reference), sub); if (mustFail) { Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException"); } } catch (OutOfRangeException e) { if (!mustFail) { throw e; } } catch (NumberIsTooSmallException e) { if (!mustFail) { throw e; } } catch (NoDataException e) { if (!mustFail) { throw e; } } } @Test public void testCopySubMatrix() { RealMatrix m = new Array2DRowRealMatrix(subTestData); checkCopy(m, subRows23Cols00, 2 , 3 , 0, 0, false); checkCopy(m, subRows00Cols33, 0 , 0 , 3, 3, false); checkCopy(m, subRows01Cols23, 0 , 1 , 2, 3, false); checkCopy(m, subRows02Cols13, new int[] { 0, 2 }, new int[] { 1, 3 }, false); checkCopy(m, subRows03Cols12, new int[] { 0, 3 }, new int[] { 1, 2 }, false); checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); checkCopy(m, subRows31Cols31, new int[] { 3, 1 }, new int[] { 3, 1 }, false); checkCopy(m, subRows31Cols31, new int[] { 3, 1 }, new int[] { 3, 1 }, false); checkCopy(m, null, 1, 0, 2, 4, true); checkCopy(m, null, -1, 1, 2, 2, true); checkCopy(m, null, 1, 0, 2, 2, true); checkCopy(m, null, 1, 0, 2, 4, true); checkCopy(m, null, new int[] {}, new int[] { 0 }, true); checkCopy(m, null, new int[] { 0 }, new int[] { 4 }, true); // rectangular check double[][] copy = new double[][] { { 0, 0, 0 }, { 0, 0 } }; checkCopy(m, copy, 0, 1, 0, 2, true); checkCopy(m, copy, new int[] { 0, 1 }, new int[] { 0, 1, 2 }, true); } private void checkCopy(RealMatrix m, double[][] reference, int startRow, int endRow, int startColumn, int endColumn, boolean mustFail) { try { double[][] sub = (reference == null) ? new double[1][1] : createIdenticalCopy(reference); m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub); Assert.assertEquals(new Array2DRowRealMatrix(reference), new Array2DRowRealMatrix(sub)); if (mustFail) { Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException"); } } catch (OutOfRangeException e) { if (!mustFail) { throw e; } } catch (NumberIsTooSmallException e) { if (!mustFail) { throw e; } } catch (NoDataException e) { if (!mustFail) { throw e; } } catch (MatrixDimensionMismatchException e) { if (!mustFail) { throw e; } } } private void checkCopy(RealMatrix m, double[][] reference, int[] selectedRows, int[] selectedColumns, boolean mustFail) { try { double[][] sub = (reference == null) ? new double[1][1] : createIdenticalCopy(reference); m.copySubMatrix(selectedRows, selectedColumns, sub); Assert.assertEquals(new Array2DRowRealMatrix(reference), new Array2DRowRealMatrix(sub)); if (mustFail) { Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException"); } } catch (OutOfRangeException e) { if (!mustFail) { throw e; } } catch (NumberIsTooSmallException e) { if (!mustFail) { throw e; } } catch (NoDataException e) { if (!mustFail) { throw e; } } catch (MatrixDimensionMismatchException e) { if (!mustFail) { throw e; } } } private double[][] createIdenticalCopy(final double[][] matrix) { final double[][] matrixCopy = new double[matrix.length][]; for (int i = 0; i < matrixCopy.length; i++) { matrixCopy[i] = new double[matrix[i].length]; } return matrixCopy; } @Test public void testGetRowMatrix() { RealMatrix m = new Array2DRowRealMatrix(subTestData); RealMatrix mRow0 = new Array2DRowRealMatrix(subRow0); RealMatrix mRow3 = new Array2DRowRealMatrix(subRow3); Assert.assertEquals("Row0", mRow0, m.getRowMatrix(0)); Assert.assertEquals("Row3", mRow3, m.getRowMatrix(3)); try { m.getRowMatrix(-1); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getRowMatrix(4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testSetRowMatrix() { RealMatrix m = new Array2DRowRealMatrix(subTestData); RealMatrix mRow3 = new Array2DRowRealMatrix(subRow3); Assert.assertNotSame(mRow3, m.getRowMatrix(0)); m.setRowMatrix(0, mRow3); Assert.assertEquals(mRow3, m.getRowMatrix(0)); try { m.setRowMatrix(-1, mRow3); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.setRowMatrix(0, m); Assert.fail("Expecting MatrixDimensionMismatchException"); } catch (MatrixDimensionMismatchException ex) { // expected } } @Test public void testGetColumnMatrix() { RealMatrix m = new Array2DRowRealMatrix(subTestData); RealMatrix mColumn1 = new Array2DRowRealMatrix(subColumn1); RealMatrix mColumn3 = new Array2DRowRealMatrix(subColumn3); Assert.assertEquals("Column1", mColumn1, m.getColumnMatrix(1)); Assert.assertEquals("Column3", mColumn3, m.getColumnMatrix(3)); try { m.getColumnMatrix(-1); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getColumnMatrix(4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testSetColumnMatrix() { RealMatrix m = new Array2DRowRealMatrix(subTestData); RealMatrix mColumn3 = new Array2DRowRealMatrix(subColumn3); Assert.assertNotSame(mColumn3, m.getColumnMatrix(1)); m.setColumnMatrix(1, mColumn3); Assert.assertEquals(mColumn3, m.getColumnMatrix(1)); try { m.setColumnMatrix(-1, mColumn3); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.setColumnMatrix(0, m); Assert.fail("Expecting MatrixDimensionMismatchException"); } catch (MatrixDimensionMismatchException ex) { // expected } } @Test public void testGetRowVector() { RealMatrix m = new Array2DRowRealMatrix(subTestData); RealVector mRow0 = new ArrayRealVector(subRow0[0]); RealVector mRow3 = new ArrayRealVector(subRow3[0]); Assert.assertEquals("Row0", mRow0, m.getRowVector(0)); Assert.assertEquals("Row3", mRow3, m.getRowVector(3)); try { m.getRowVector(-1); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getRowVector(4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testSetRowVector() { RealMatrix m = new Array2DRowRealMatrix(subTestData); RealVector mRow3 = new ArrayRealVector(subRow3[0]); Assert.assertNotSame(mRow3, m.getRowMatrix(0)); m.setRowVector(0, mRow3); Assert.assertEquals(mRow3, m.getRowVector(0)); try { m.setRowVector(-1, mRow3); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.setRowVector(0, new ArrayRealVector(5)); Assert.fail("Expecting MatrixDimensionMismatchException"); } catch (MatrixDimensionMismatchException ex) { // expected } } @Test public void testGetColumnVector() { RealMatrix m = new Array2DRowRealMatrix(subTestData); RealVector mColumn1 = columnToVector(subColumn1); RealVector mColumn3 = columnToVector(subColumn3); Assert.assertEquals("Column1", mColumn1, m.getColumnVector(1)); Assert.assertEquals("Column3", mColumn3, m.getColumnVector(3)); try { m.getColumnVector(-1); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getColumnVector(4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testSetColumnVector() { RealMatrix m = new Array2DRowRealMatrix(subTestData); RealVector mColumn3 = columnToVector(subColumn3); Assert.assertNotSame(mColumn3, m.getColumnVector(1)); m.setColumnVector(1, mColumn3); Assert.assertEquals(mColumn3, m.getColumnVector(1)); try { m.setColumnVector(-1, mColumn3); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.setColumnVector(0, new ArrayRealVector(5)); Assert.fail("Expecting MatrixDimensionMismatchException"); } catch (MatrixDimensionMismatchException ex) { // expected } } private RealVector columnToVector(double[][] column) { double[] data = new double[column.length]; for (int i = 0; i < data.length; ++i) { data[i] = column[i][0]; } return new ArrayRealVector(data, false); } @Test public void testGetRow() { RealMatrix m = new Array2DRowRealMatrix(subTestData); checkArrays(subRow0[0], m.getRow(0)); checkArrays(subRow3[0], m.getRow(3)); try { m.getRow(-1); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getRow(4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testSetRow() { RealMatrix m = new Array2DRowRealMatrix(subTestData); Assert.assertTrue(subRow3[0][0] != m.getRow(0)[0]); m.setRow(0, subRow3[0]); checkArrays(subRow3[0], m.getRow(0)); try { m.setRow(-1, subRow3[0]); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.setRow(0, new double[5]); Assert.fail("Expecting MatrixDimensionMismatchException"); } catch (MatrixDimensionMismatchException ex) { // expected } } @Test public void testGetColumn() { RealMatrix m = new Array2DRowRealMatrix(subTestData); double[] mColumn1 = columnToArray(subColumn1); double[] mColumn3 = columnToArray(subColumn3); checkArrays(mColumn1, m.getColumn(1)); checkArrays(mColumn3, m.getColumn(3)); try { m.getColumn(-1); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getColumn(4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testSetColumn() { RealMatrix m = new Array2DRowRealMatrix(subTestData); double[] mColumn3 = columnToArray(subColumn3); Assert.assertTrue(mColumn3[0] != m.getColumn(1)[0]); m.setColumn(1, mColumn3); checkArrays(mColumn3, m.getColumn(1)); try { m.setColumn(-1, mColumn3); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.setColumn(0, new double[5]); Assert.fail("Expecting MatrixDimensionMismatchException"); } catch (MatrixDimensionMismatchException ex) { // expected } } private double[] columnToArray(double[][] column) { double[] data = new double[column.length]; for (int i = 0; i < data.length; ++i) { data[i] = column[i][0]; } return data; } private void checkArrays(double[] expected, double[] actual) { Assert.assertEquals(expected.length, actual.length); for (int i = 0; i < expected.length; ++i) { Assert.assertEquals(expected[i], actual[i], 0); } } @Test public void testEqualsAndHashCode() { Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData); Array2DRowRealMatrix m1 = (Array2DRowRealMatrix) m.copy(); Array2DRowRealMatrix mt = (Array2DRowRealMatrix) m.transpose(); Assert.assertTrue(m.hashCode() != mt.hashCode()); Assert.assertEquals(m.hashCode(), m1.hashCode()); Assert.assertEquals(m, m); Assert.assertEquals(m, m1); Assert.assertFalse(m.equals(null)); Assert.assertFalse(m.equals(mt)); Assert.assertFalse(m.equals(new Array2DRowRealMatrix(bigSingular))); } @Test public void testToString() { Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData); Assert.assertEquals("Array2DRowRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}", m.toString()); m = new Array2DRowRealMatrix(); Assert.assertEquals("Array2DRowRealMatrix{}", m.toString()); } @Test public void testSetSubMatrix() { Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData); m.setSubMatrix(detData2,1,1); RealMatrix expected = MatrixUtils.createRealMatrix (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}}); Assert.assertEquals(expected, m); m.setSubMatrix(detData2,0,0); expected = MatrixUtils.createRealMatrix (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}}); Assert.assertEquals(expected, m); m.setSubMatrix(testDataPlus2,0,0); expected = MatrixUtils.createRealMatrix (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}}); Assert.assertEquals(expected, m); // dimension overflow try { m.setSubMatrix(testData,1,1); Assert.fail("expecting OutOfRangeException"); } catch (OutOfRangeException e) { // expected } // dimension underflow try { m.setSubMatrix(testData,-1,1); Assert.fail("expecting OutOfRangeException"); } catch (OutOfRangeException e) { // expected } try { m.setSubMatrix(testData,1,-1); Assert.fail("expecting OutOfRangeException"); } catch (OutOfRangeException e) { // expected } // null try { m.setSubMatrix(null,1,1); Assert.fail("expecting NullArgumentException"); } catch (NullArgumentException e) { // expected } Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(); try { m2.setSubMatrix(testData,0,1); Assert.fail("expecting MathIllegalStateException"); } catch (MathIllegalStateException e) { // expected } try { m2.setSubMatrix(testData,1,0); Assert.fail("expecting MathIllegalStateException"); } catch (MathIllegalStateException e) { // expected } // ragged try { m.setSubMatrix(new double[][] {{1}, {2, 3}}, 0, 0); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException e) { // expected } // empty try { m.setSubMatrix(new double[][] {{}}, 0, 0); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException e) { // expected } } @Test public void testWalk() { int rows = 150; int columns = 75; RealMatrix m = new Array2DRowRealMatrix(rows, columns); m.walkInRowOrder(new SetVisitor()); GetVisitor getVisitor = new GetVisitor(); m.walkInOptimizedOrder(getVisitor); Assert.assertEquals(rows * columns, getVisitor.getCount()); m = new Array2DRowRealMatrix(rows, columns); m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2); getVisitor = new GetVisitor(); m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2); Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount()); for (int i = 0; i < rows; ++i) { Assert.assertEquals(0.0, m.getEntry(i, 0), 0); Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0); } for (int j = 0; j < columns; ++j) { Assert.assertEquals(0.0, m.getEntry(0, j), 0); Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0); } m = new Array2DRowRealMatrix(rows, columns); m.walkInColumnOrder(new SetVisitor()); getVisitor = new GetVisitor(); m.walkInOptimizedOrder(getVisitor); Assert.assertEquals(rows * columns, getVisitor.getCount()); m = new Array2DRowRealMatrix(rows, columns); m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2); getVisitor = new GetVisitor(); m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2); Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount()); for (int i = 0; i < rows; ++i) { Assert.assertEquals(0.0, m.getEntry(i, 0), 0); Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0); } for (int j = 0; j < columns; ++j) { Assert.assertEquals(0.0, m.getEntry(0, j), 0); Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0); } m = new Array2DRowRealMatrix(rows, columns); m.walkInOptimizedOrder(new SetVisitor()); getVisitor = new GetVisitor(); m.walkInRowOrder(getVisitor); Assert.assertEquals(rows * columns, getVisitor.getCount()); m = new Array2DRowRealMatrix(rows, columns); m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2); getVisitor = new GetVisitor(); m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2); Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount()); for (int i = 0; i < rows; ++i) { Assert.assertEquals(0.0, m.getEntry(i, 0), 0); Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0); } for (int j = 0; j < columns; ++j) { Assert.assertEquals(0.0, m.getEntry(0, j), 0); Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0); } m = new Array2DRowRealMatrix(rows, columns); m.walkInOptimizedOrder(new SetVisitor()); getVisitor = new GetVisitor(); m.walkInColumnOrder(getVisitor); Assert.assertEquals(rows * columns, getVisitor.getCount()); m = new Array2DRowRealMatrix(rows, columns); m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2); getVisitor = new GetVisitor(); m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2); Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount()); for (int i = 0; i < rows; ++i) { Assert.assertEquals(0.0, m.getEntry(i, 0), 0); Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0); } for (int j = 0; j < columns; ++j) { Assert.assertEquals(0.0, m.getEntry(0, j), 0); Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0); } } @Test public void testSerial() { Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData); Assert.assertEquals(m,TestUtils.serializeAndRecover(m)); } private static class SetVisitor extends DefaultRealMatrixChangingVisitor { @Override public double visit(int i, int j, double value) { return i + j / 1024.0; } } private static class GetVisitor extends DefaultRealMatrixPreservingVisitor { private int count = 0; @Override public void visit(int i, int j, double value) { ++count; Assert.assertEquals(i + j / 1024.0, value, 0.0); } public int getCount() { return count; } } //--------------- -----------------Protected methods /** extracts the l and u matrices from compact lu representation */ protected void splitLU(RealMatrix lu, double[][] lowerData, double[][] upperData) { if (!lu.isSquare()) { throw new NonSquareMatrixException(lu.getRowDimension(), lu.getColumnDimension()); } if (lowerData.length != lowerData[0].length) { throw new DimensionMismatchException(lowerData.length, lowerData[0].length); } if (upperData.length != upperData[0].length) { throw new DimensionMismatchException(upperData.length, upperData[0].length); } if (lowerData.length != upperData.length) { throw new DimensionMismatchException(lowerData.length, upperData.length); } if (lowerData.length != lu.getRowDimension()) { throw new DimensionMismatchException(lowerData.length, lu.getRowDimension()); } int n = lu.getRowDimension(); for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { if (j < i) { lowerData[i][j] = lu.getEntry(i, j); upperData[i][j] = 0d; } else if (i == j) { lowerData[i][j] = 1d; upperData[i][j] = lu.getEntry(i, j); } else { lowerData[i][j] = 0d; upperData[i][j] = lu.getEntry(i, j); } } } } /** Returns the result of applying the given row permutation to the matrix */ protected RealMatrix permuteRows(RealMatrix matrix, int[] permutation) { if (!matrix.isSquare()) { throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension()); } if (matrix.getRowDimension() != permutation.length) { throw new DimensionMismatchException(matrix.getRowDimension(), permutation.length); } int n = matrix.getRowDimension(); int m = matrix.getColumnDimension(); double out[][] = new double[m][n]; for (int i = 0; i < n; i++) { for (int j = 0; j < m; j++) { out[i][j] = matrix.getEntry(permutation[i], j); } } return new Array2DRowRealMatrix(out); } // /** Useful for debugging */ // private void dumpMatrix(RealMatrix m) { // for (int i = 0; i < m.getRowDimension(); i++) { // String os = ""; // for (int j = 0; j < m.getColumnDimension(); j++) { // os += m.getEntry(i, j) + " "; // } // System.out.println(os); // } // } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import java.io.Serializable; import java.lang.reflect.Array; import org.apache.commons.math3.Field; import org.apache.commons.math3.FieldElement; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.exception.OutOfRangeException; import org.apache.commons.math3.fraction.Fraction; import org.apache.commons.math3.fraction.FractionField; import org.junit.Assert; import org.junit.Test; /** * Test cases for the {@link ArrayFieldVector} class. * * @version $Id$ */ public class ArrayFieldVectorTest { // protected Fraction[][] ma1 = { {new Fraction(1), new Fraction(2), new Fraction(3)}, {new Fraction(4), new Fraction(5), new Fraction(6)}, {new Fraction(7), new Fraction(8), new Fraction(9)} }; protected Fraction[] vec1 = {new Fraction(1), new Fraction(2), new Fraction(3)}; protected Fraction[] vec2 = {new Fraction(4), new Fraction(5), new Fraction(6)}; protected Fraction[] vec3 = {new Fraction(7), new Fraction(8), new Fraction(9)}; protected Fraction[] vec4 = { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8), new Fraction(9)}; protected Fraction[] vec_null = {new Fraction(0), new Fraction(0), new Fraction(0)}; protected Fraction[] dvec1 = {new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8), new Fraction(9)}; protected Fraction[][] mat1 = { {new Fraction(1), new Fraction(2), new Fraction(3)}, {new Fraction(4), new Fraction(5), new Fraction(6)}, {new Fraction(7), new Fraction(8), new Fraction(9)} }; // Testclass to test the FieldVector<Fraction> interface // only with enough content to support the test public static class FieldVectorTestImpl<T extends FieldElement<T>> implements FieldVector<T>, Serializable { private static final long serialVersionUID = 3970959016014158539L; private final Field<T> field; /** Entries of the vector. */ protected T[] data; /** Build an array of elements. * @param length size of the array to build * @return a new array */ @SuppressWarnings("unchecked") // field is of type T private T[] buildArray(final int length) { return (T[]) Array.newInstance(field.getRuntimeClass(), length); } public FieldVectorTestImpl(T[] d) { field = d[0].getField(); data = d.clone(); } public Field<T> getField() { return field; } private UnsupportedOperationException unsupported() { return new UnsupportedOperationException("Not supported, unneeded for test purposes"); } public FieldVector<T> copy() { throw unsupported(); } public FieldVector<T> add(FieldVector<T> v) { throw unsupported(); } public FieldVector<T> add(T[] v) { throw unsupported(); } public FieldVector<T> subtract(FieldVector<T> v) { throw unsupported(); } public FieldVector<T> subtract(T[] v) { throw unsupported(); } public FieldVector<T> mapAdd(T d) { throw unsupported(); } public FieldVector<T> mapAddToSelf(T d) { throw unsupported(); } public FieldVector<T> mapSubtract(T d) { throw unsupported(); } public FieldVector<T> mapSubtractToSelf(T d) { throw unsupported(); } public FieldVector<T> mapMultiply(T d) { T[] out = buildArray(data.length); for (int i = 0; i < data.length; i++) { out[i] = data[i].multiply(d); } return new FieldVectorTestImpl<T>(out); } public FieldVector<T> mapMultiplyToSelf(T d) { throw unsupported(); } public FieldVector<T> mapDivide(T d) { throw unsupported(); } public FieldVector<T> mapDivideToSelf(T d) { throw unsupported(); } public FieldVector<T> mapInv() { throw unsupported(); } public FieldVector<T> mapInvToSelf() { throw unsupported(); } public FieldVector<T> ebeMultiply(FieldVector<T> v) { throw unsupported(); } public FieldVector<T> ebeMultiply(T[] v) { throw unsupported(); } public FieldVector<T> ebeDivide(FieldVector<T> v) { throw unsupported(); } public FieldVector<T> ebeDivide(T[] v) { throw unsupported(); } public T[] getData() { return data.clone(); } public T dotProduct(FieldVector<T> v) { T dot = field.getZero(); for (int i = 0; i < data.length; i++) { dot = dot.add(data[i].multiply(v.getEntry(i))); } return dot; } public T dotProduct(T[] v) { T dot = field.getZero(); for (int i = 0; i < data.length; i++) { dot = dot.add(data[i].multiply(v[i])); } return dot; } public FieldVector<T> projection(FieldVector<T> v) { throw unsupported(); } public FieldVector<T> projection(T[] v) { throw unsupported(); } public FieldMatrix<T> outerProduct(FieldVector<T> v) { throw unsupported(); } public FieldMatrix<T> outerProduct(T[] v) { throw unsupported(); } public T getEntry(int index) { return data[index]; } public int getDimension() { return data.length; } public FieldVector<T> append(FieldVector<T> v) { throw unsupported(); } public FieldVector<T> append(T d) { throw unsupported(); } public FieldVector<T> append(T[] a) { throw unsupported(); } public FieldVector<T> getSubVector(int index, int n) { throw unsupported(); } public void setEntry(int index, T value) { throw unsupported(); } public void setSubVector(int index, FieldVector<T> v) { throw unsupported(); } public void setSubVector(int index, T[] v) { throw unsupported(); } public void set(T value) { throw unsupported(); } public T[] toArray() { throw unsupported(); } } @Test public void testConstructors() { ArrayFieldVector<Fraction> v0 = new ArrayFieldVector<Fraction>(FractionField.getInstance()); Assert.assertEquals(0, v0.getDimension()); ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(FractionField.getInstance(), 7); Assert.assertEquals(7, v1.getDimension()); Assert.assertEquals(new Fraction(0), v1.getEntry(6)); ArrayFieldVector<Fraction> v2 = new ArrayFieldVector<Fraction>(5, new Fraction(123, 100)); Assert.assertEquals(5, v2.getDimension()); Assert.assertEquals(new Fraction(123, 100), v2.getEntry(4)); ArrayFieldVector<Fraction> v3 = new ArrayFieldVector<Fraction>(FractionField.getInstance(), vec1); Assert.assertEquals(3, v3.getDimension()); Assert.assertEquals(new Fraction(2), v3.getEntry(1)); ArrayFieldVector<Fraction> v4 = new ArrayFieldVector<Fraction>(FractionField.getInstance(), vec4, 3, 2); Assert.assertEquals(2, v4.getDimension()); Assert.assertEquals(new Fraction(4), v4.getEntry(0)); try { new ArrayFieldVector<Fraction>(vec4, 8, 3); Assert.fail("MathIllegalArgumentException expected"); } catch (MathIllegalArgumentException ex) { // expected behavior } FieldVector<Fraction> v5_i = new ArrayFieldVector<Fraction>(dvec1); Assert.assertEquals(9, v5_i.getDimension()); Assert.assertEquals(new Fraction(9), v5_i.getEntry(8)); ArrayFieldVector<Fraction> v5 = new ArrayFieldVector<Fraction>(dvec1); Assert.assertEquals(9, v5.getDimension()); Assert.assertEquals(new Fraction(9), v5.getEntry(8)); ArrayFieldVector<Fraction> v6 = new ArrayFieldVector<Fraction>(dvec1, 3, 2); Assert.assertEquals(2, v6.getDimension()); Assert.assertEquals(new Fraction(4), v6.getEntry(0)); try { new ArrayFieldVector<Fraction>(dvec1, 8, 3); Assert.fail("MathIllegalArgumentException expected"); } catch (MathIllegalArgumentException ex) { // expected behavior } ArrayFieldVector<Fraction> v7 = new ArrayFieldVector<Fraction>(v1); Assert.assertEquals(7, v7.getDimension()); Assert.assertEquals(new Fraction(0), v7.getEntry(6)); FieldVectorTestImpl<Fraction> v7_i = new FieldVectorTestImpl<Fraction>(vec1); ArrayFieldVector<Fraction> v7_2 = new ArrayFieldVector<Fraction>(v7_i); Assert.assertEquals(3, v7_2.getDimension()); Assert.assertEquals(new Fraction(2), v7_2.getEntry(1)); ArrayFieldVector<Fraction> v8 = new ArrayFieldVector<Fraction>(v1, true); Assert.assertEquals(7, v8.getDimension()); Assert.assertEquals(new Fraction(0), v8.getEntry(6)); Assert.assertNotSame("testData not same object ", v1.getDataRef(), v8.getDataRef()); ArrayFieldVector<Fraction> v8_2 = new ArrayFieldVector<Fraction>(v1, false); Assert.assertEquals(7, v8_2.getDimension()); Assert.assertEquals(new Fraction(0), v8_2.getEntry(6)); Assert.assertArrayEquals(v1.getDataRef(), v8_2.getDataRef()); ArrayFieldVector<Fraction> v9 = new ArrayFieldVector<Fraction>(v1, v3); Assert.assertEquals(10, v9.getDimension()); Assert.assertEquals(new Fraction(1), v9.getEntry(7)); } @Test public void testDataInOut() { ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(vec1); ArrayFieldVector<Fraction> v2 = new ArrayFieldVector<Fraction>(vec2); ArrayFieldVector<Fraction> v4 = new ArrayFieldVector<Fraction>(vec4); FieldVectorTestImpl<Fraction> v2_t = new FieldVectorTestImpl<Fraction>(vec2); FieldVector<Fraction> v_append_1 = v1.append(v2); Assert.assertEquals(6, v_append_1.getDimension()); Assert.assertEquals(new Fraction(4), v_append_1.getEntry(3)); FieldVector<Fraction> v_append_2 = v1.append(new Fraction(2)); Assert.assertEquals(4, v_append_2.getDimension()); Assert.assertEquals(new Fraction(2), v_append_2.getEntry(3)); FieldVector<Fraction> v_append_4 = v1.append(v2_t); Assert.assertEquals(6, v_append_4.getDimension()); Assert.assertEquals(new Fraction(4), v_append_4.getEntry(3)); FieldVector<Fraction> v_copy = v1.copy(); Assert.assertEquals(3, v_copy.getDimension()); Assert.assertNotSame("testData not same object ", v1.getDataRef(), v_copy.getData()); Fraction[] a_frac = v1.toArray(); Assert.assertEquals(3, a_frac.length); Assert.assertNotSame("testData not same object ", v1.getDataRef(), a_frac); // ArrayFieldVector<Fraction> vout4 = (ArrayFieldVector<Fraction>) v1.clone(); // Assert.assertEquals(3, vout4.getDimension()); // Assert.assertEquals(v1.getDataRef(), vout4.getDataRef()); FieldVector<Fraction> vout5 = v4.getSubVector(3, 3); Assert.assertEquals(3, vout5.getDimension()); Assert.assertEquals(new Fraction(5), vout5.getEntry(1)); try { v4.getSubVector(3, 7); Assert.fail("OutOfRangeException expected"); } catch (OutOfRangeException ex) { // expected behavior } ArrayFieldVector<Fraction> v_set1 = (ArrayFieldVector<Fraction>) v1.copy(); v_set1.setEntry(1, new Fraction(11)); Assert.assertEquals(new Fraction(11), v_set1.getEntry(1)); try { v_set1.setEntry(3, new Fraction(11)); Assert.fail("OutOfRangeException expected"); } catch (OutOfRangeException ex) { // expected behavior } ArrayFieldVector<Fraction> v_set2 = (ArrayFieldVector<Fraction>) v4.copy(); v_set2.set(3, v1); Assert.assertEquals(new Fraction(1), v_set2.getEntry(3)); Assert.assertEquals(new Fraction(7), v_set2.getEntry(6)); try { v_set2.set(7, v1); Assert.fail("OutOfRangeException expected"); } catch (OutOfRangeException ex) { // expected behavior } ArrayFieldVector<Fraction> v_set3 = (ArrayFieldVector<Fraction>) v1.copy(); v_set3.set(new Fraction(13)); Assert.assertEquals(new Fraction(13), v_set3.getEntry(2)); try { v_set3.getEntry(23); Assert.fail("ArrayIndexOutOfBoundsException expected"); } catch (ArrayIndexOutOfBoundsException ex) { // expected behavior } ArrayFieldVector<Fraction> v_set4 = (ArrayFieldVector<Fraction>) v4.copy(); v_set4.setSubVector(3, v2_t); Assert.assertEquals(new Fraction(4), v_set4.getEntry(3)); Assert.assertEquals(new Fraction(7), v_set4.getEntry(6)); try { v_set4.setSubVector(7, v2_t); Assert.fail("OutOfRangeException expected"); } catch (OutOfRangeException ex) { // expected behavior } ArrayFieldVector<Fraction> vout10 = (ArrayFieldVector<Fraction>) v1.copy(); ArrayFieldVector<Fraction> vout10_2 = (ArrayFieldVector<Fraction>) v1.copy(); Assert.assertEquals(vout10, vout10_2); vout10_2.setEntry(0, new Fraction(11, 10)); Assert.assertNotSame(vout10, vout10_2); } @Test public void testMapFunctions() { ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(vec1); //octave = v1 .+ 2.0 FieldVector<Fraction> v_mapAdd = v1.mapAdd(new Fraction(2)); Fraction[] result_mapAdd = {new Fraction(3), new Fraction(4), new Fraction(5)}; checkArray("compare vectors" ,result_mapAdd,v_mapAdd.getData()); //octave = v1 .+ 2.0 FieldVector<Fraction> v_mapAddToSelf = v1.copy(); v_mapAddToSelf.mapAddToSelf(new Fraction(2)); Fraction[] result_mapAddToSelf = {new Fraction(3), new Fraction(4), new Fraction(5)}; checkArray("compare vectors" ,result_mapAddToSelf,v_mapAddToSelf.getData()); //octave = v1 .- 2.0 FieldVector<Fraction> v_mapSubtract = v1.mapSubtract(new Fraction(2)); Fraction[] result_mapSubtract = {new Fraction(-1), new Fraction(0), new Fraction(1)}; checkArray("compare vectors" ,result_mapSubtract,v_mapSubtract.getData()); //octave = v1 .- 2.0 FieldVector<Fraction> v_mapSubtractToSelf = v1.copy(); v_mapSubtractToSelf.mapSubtractToSelf(new Fraction(2)); Fraction[] result_mapSubtractToSelf = {new Fraction(-1), new Fraction(0), new Fraction(1)}; checkArray("compare vectors" ,result_mapSubtractToSelf,v_mapSubtractToSelf.getData()); //octave = v1 .* 2.0 FieldVector<Fraction> v_mapMultiply = v1.mapMultiply(new Fraction(2)); Fraction[] result_mapMultiply = {new Fraction(2), new Fraction(4), new Fraction(6)}; checkArray("compare vectors" ,result_mapMultiply,v_mapMultiply.getData()); //octave = v1 .* 2.0 FieldVector<Fraction> v_mapMultiplyToSelf = v1.copy(); v_mapMultiplyToSelf.mapMultiplyToSelf(new Fraction(2)); Fraction[] result_mapMultiplyToSelf = {new Fraction(2), new Fraction(4), new Fraction(6)}; checkArray("compare vectors" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData()); //octave = v1 ./ 2.0 FieldVector<Fraction> v_mapDivide = v1.mapDivide(new Fraction(2)); Fraction[] result_mapDivide = {new Fraction(1, 2), new Fraction(1), new Fraction(3, 2)}; checkArray("compare vectors" ,result_mapDivide,v_mapDivide.getData()); //octave = v1 ./ 2.0 FieldVector<Fraction> v_mapDivideToSelf = v1.copy(); v_mapDivideToSelf.mapDivideToSelf(new Fraction(2)); Fraction[] result_mapDivideToSelf = {new Fraction(1, 2), new Fraction(1), new Fraction(3, 2)}; checkArray("compare vectors" ,result_mapDivideToSelf,v_mapDivideToSelf.getData()); //octave = v1 .^-1 FieldVector<Fraction> v_mapInv = v1.mapInv(); Fraction[] result_mapInv = {new Fraction(1),new Fraction(1, 2),new Fraction(1, 3)}; checkArray("compare vectors" ,result_mapInv,v_mapInv.getData()); //octave = v1 .^-1 FieldVector<Fraction> v_mapInvToSelf = v1.copy(); v_mapInvToSelf.mapInvToSelf(); Fraction[] result_mapInvToSelf = {new Fraction(1),new Fraction(1, 2),new Fraction(1, 3)}; checkArray("compare vectors" ,result_mapInvToSelf,v_mapInvToSelf.getData()); } @Test public void testBasicFunctions() { ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(vec1); ArrayFieldVector<Fraction> v2 = new ArrayFieldVector<Fraction>(vec2); new ArrayFieldVector<Fraction>(vec_null); FieldVectorTestImpl<Fraction> v2_t = new FieldVectorTestImpl<Fraction>(vec2); //octave = v1 + v2 ArrayFieldVector<Fraction> v_add = v1.add(v2); Fraction[] result_add = {new Fraction(5), new Fraction(7), new Fraction(9)}; checkArray("compare vect" ,v_add.getData(),result_add); FieldVectorTestImpl<Fraction> vt2 = new FieldVectorTestImpl<Fraction>(vec2); FieldVector<Fraction> v_add_i = v1.add(vt2); Fraction[] result_add_i = {new Fraction(5), new Fraction(7), new Fraction(9)}; checkArray("compare vect" ,v_add_i.getData(),result_add_i); //octave = v1 - v2 ArrayFieldVector<Fraction> v_subtract = v1.subtract(v2); Fraction[] result_subtract = {new Fraction(-3), new Fraction(-3), new Fraction(-3)}; checkArray("compare vect" ,v_subtract.getData(),result_subtract); FieldVector<Fraction> v_subtract_i = v1.subtract(vt2); Fraction[] result_subtract_i = {new Fraction(-3), new Fraction(-3), new Fraction(-3)}; checkArray("compare vect" ,v_subtract_i.getData(),result_subtract_i); // octave v1 .* v2 ArrayFieldVector<Fraction> v_ebeMultiply = v1.ebeMultiply(v2); Fraction[] result_ebeMultiply = {new Fraction(4), new Fraction(10), new Fraction(18)}; checkArray("compare vect" ,v_ebeMultiply.getData(),result_ebeMultiply); FieldVector<Fraction> v_ebeMultiply_2 = v1.ebeMultiply(v2_t); Fraction[] result_ebeMultiply_2 = {new Fraction(4), new Fraction(10), new Fraction(18)}; checkArray("compare vect" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2); // octave v1 ./ v2 ArrayFieldVector<Fraction> v_ebeDivide = v1.ebeDivide(v2); Fraction[] result_ebeDivide = {new Fraction(1, 4), new Fraction(2, 5), new Fraction(1, 2)}; checkArray("compare vect" ,v_ebeDivide.getData(),result_ebeDivide); FieldVector<Fraction> v_ebeDivide_2 = v1.ebeDivide(v2_t); Fraction[] result_ebeDivide_2 = {new Fraction(1, 4), new Fraction(2, 5), new Fraction(1, 2)}; checkArray("compare vect" ,v_ebeDivide_2.getData(),result_ebeDivide_2); // octave dot(v1,v2) Fraction dot = v1.dotProduct(v2); Assert.assertEquals("compare val ",new Fraction(32), dot); // octave dot(v1,v2_t) Fraction dot_2 = v1.dotProduct(v2_t); Assert.assertEquals("compare val ",new Fraction(32), dot_2); FieldMatrix<Fraction> m_outerProduct = v1.outerProduct(v2); Assert.assertEquals("compare val ",new Fraction(4), m_outerProduct.getEntry(0,0)); FieldMatrix<Fraction> m_outerProduct_2 = v1.outerProduct(v2_t); Assert.assertEquals("compare val ",new Fraction(4), m_outerProduct_2.getEntry(0,0)); ArrayFieldVector<Fraction> v_projection = v1.projection(v2); Fraction[] result_projection = {new Fraction(128, 77), new Fraction(160, 77), new Fraction(192, 77)}; checkArray("compare vect", v_projection.getData(), result_projection); FieldVector<Fraction> v_projection_2 = v1.projection(v2_t); Fraction[] result_projection_2 = {new Fraction(128, 77), new Fraction(160, 77), new Fraction(192, 77)}; checkArray("compare vect", v_projection_2.getData(), result_projection_2); } @Test public void testMisc() { ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(vec1); ArrayFieldVector<Fraction> v4 = new ArrayFieldVector<Fraction>(vec4); FieldVector<Fraction> v4_2 = new ArrayFieldVector<Fraction>(vec4); String out1 = v1.toString(); Assert.assertTrue("some output ", out1.length()!=0); /* Fraction[] dout1 = v1.copyOut(); Assert.assertEquals(3, dout1.length); assertNotSame("testData not same object ", v1.getDataRef(), dout1); */ try { v1.checkVectorDimensions(2); Assert.fail("MathIllegalArgumentException expected"); } catch (MathIllegalArgumentException ex) { // expected behavior } try { v1.checkVectorDimensions(v4); Assert.fail("MathIllegalArgumentException expected"); } catch (MathIllegalArgumentException ex) { // expected behavior } try { v1.checkVectorDimensions(v4_2); Assert.fail("MathIllegalArgumentException expected"); } catch (MathIllegalArgumentException ex) { // expected behavior } } @Test public void testSerial() { ArrayFieldVector<Fraction> v = new ArrayFieldVector<Fraction>(vec1); Assert.assertEquals(v,TestUtils.serializeAndRecover(v)); } @Test public void testZeroVectors() { // when the field is not specified, array cannot be empty try { new ArrayFieldVector<Fraction>(new Fraction[0]); Assert.fail("MathIllegalArgumentException expected"); } catch (MathIllegalArgumentException ex) { // expected behavior } try { new ArrayFieldVector<Fraction>(new Fraction[0], true); Assert.fail("MathIllegalArgumentException expected"); } catch (MathIllegalArgumentException ex) { // expected behavior } try { new ArrayFieldVector<Fraction>(new Fraction[0], false); Assert.fail("MathIllegalArgumentException expected"); } catch (MathIllegalArgumentException ex) { // expected behavior } // when the field is specified, array can be empty Assert.assertEquals(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), new Fraction[0]).getDimension()); Assert.assertEquals(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), new Fraction[0], true).getDimension()); Assert.assertEquals(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), new Fraction[0], false).getDimension()); } @Test public void testOuterProduct() { final ArrayFieldVector<Fraction> u = new ArrayFieldVector<Fraction>(FractionField.getInstance(), new Fraction[] {new Fraction(1), new Fraction(2), new Fraction(-3)}); final ArrayFieldVector<Fraction> v = new ArrayFieldVector<Fraction>(FractionField.getInstance(), new Fraction[] {new Fraction(4), new Fraction(-2)}); final FieldMatrix<Fraction> uv = u.outerProduct(v); final double tol = Math.ulp(1d); Assert.assertEquals(new Fraction(4).doubleValue(), uv.getEntry(0, 0).doubleValue(), tol); Assert.assertEquals(new Fraction(-2).doubleValue(), uv.getEntry(0, 1).doubleValue(), tol); Assert.assertEquals(new Fraction(8).doubleValue(), uv.getEntry(1, 0).doubleValue(), tol); Assert.assertEquals(new Fraction(-4).doubleValue(), uv.getEntry(1, 1).doubleValue(), tol); Assert.assertEquals(new Fraction(-12).doubleValue(), uv.getEntry(2, 0).doubleValue(), tol); Assert.assertEquals(new Fraction(6).doubleValue(), uv.getEntry(2, 1).doubleValue(), tol); } /** verifies that two vectors are equals */ protected void checkArray(String msg, Fraction[] m, Fraction[] n) { if (m.length != n.length) { Assert.fail("vectors have different lengths"); } for (int i = 0; i < m.length; i++) { Assert.assertEquals(msg + " " + i + " elements differ", m[i],n[i]); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.junit.Assert; import org.junit.Test; /** * Test cases for the {@link ArrayRealVector} class. * * @version $Id$ */ public class ArrayRealVectorTest extends RealVectorAbstractTest { @Override public RealVector create(final double[] data) { return new ArrayRealVector(data, true); } @Test public void testConstructors() { final double[] vec1 = {1d, 2d, 3d}; final double[] vec3 = {7d, 8d, 9d}; final double[] vec4 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d}; final Double[] dvec1 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d}; ArrayRealVector v0 = new ArrayRealVector(); Assert.assertEquals("testData len", 0, v0.getDimension()); ArrayRealVector v1 = new ArrayRealVector(7); Assert.assertEquals("testData len", 7, v1.getDimension()); Assert.assertEquals("testData is 0.0 ", 0.0, v1.getEntry(6), 0); ArrayRealVector v2 = new ArrayRealVector(5, 1.23); Assert.assertEquals("testData len", 5, v2.getDimension()); Assert.assertEquals("testData is 1.23 ", 1.23, v2.getEntry(4), 0); ArrayRealVector v3 = new ArrayRealVector(vec1); Assert.assertEquals("testData len", 3, v3.getDimension()); Assert.assertEquals("testData is 2.0 ", 2.0, v3.getEntry(1), 0); ArrayRealVector v3_bis = new ArrayRealVector(vec1, true); Assert.assertEquals("testData len", 3, v3_bis.getDimension()); Assert.assertEquals("testData is 2.0 ", 2.0, v3_bis.getEntry(1), 0); Assert.assertNotSame(v3_bis.getDataRef(), vec1); Assert.assertNotSame(v3_bis.toArray(), vec1); ArrayRealVector v3_ter = new ArrayRealVector(vec1, false); Assert.assertEquals("testData len", 3, v3_ter.getDimension()); Assert.assertEquals("testData is 2.0 ", 2.0, v3_ter.getEntry(1), 0); Assert.assertSame(v3_ter.getDataRef(), vec1); Assert.assertNotSame(v3_ter.toArray(), vec1); ArrayRealVector v4 = new ArrayRealVector(vec4, 3, 2); Assert.assertEquals("testData len", 2, v4.getDimension()); Assert.assertEquals("testData is 4.0 ", 4.0, v4.getEntry(0), 0); try { new ArrayRealVector(vec4, 8, 3); Assert.fail("MathIllegalArgumentException expected"); } catch (MathIllegalArgumentException ex) { // expected behavior } RealVector v5_i = new ArrayRealVector(dvec1); Assert.assertEquals("testData len", 9, v5_i.getDimension()); Assert.assertEquals("testData is 9.0 ", 9.0, v5_i.getEntry(8), 0); ArrayRealVector v5 = new ArrayRealVector(dvec1); Assert.assertEquals("testData len", 9, v5.getDimension()); Assert.assertEquals("testData is 9.0 ", 9.0, v5.getEntry(8), 0); ArrayRealVector v6 = new ArrayRealVector(dvec1, 3, 2); Assert.assertEquals("testData len", 2, v6.getDimension()); Assert.assertEquals("testData is 4.0 ", 4.0, v6.getEntry(0), 0); try { new ArrayRealVector(dvec1, 8, 3); Assert.fail("MathIllegalArgumentException expected"); } catch (MathIllegalArgumentException ex) { // expected behavior } ArrayRealVector v7 = new ArrayRealVector(v1); Assert.assertEquals("testData len", 7, v7.getDimension()); Assert.assertEquals("testData is 0.0 ", 0.0, v7.getEntry(6), 0); RealVectorTestImpl v7_i = new RealVectorTestImpl(vec1); ArrayRealVector v7_2 = new ArrayRealVector(v7_i); Assert.assertEquals("testData len", 3, v7_2.getDimension()); Assert.assertEquals("testData is 0.0 ", 2.0d, v7_2.getEntry(1), 0); ArrayRealVector v8 = new ArrayRealVector(v1, true); Assert.assertEquals("testData len", 7, v8.getDimension()); Assert.assertEquals("testData is 0.0 ", 0.0, v8.getEntry(6), 0); Assert.assertNotSame("testData not same object ", v1.getDataRef(), v8.getDataRef()); ArrayRealVector v8_2 = new ArrayRealVector(v1, false); Assert.assertEquals("testData len", 7, v8_2.getDimension()); Assert.assertEquals("testData is 0.0 ", 0.0, v8_2.getEntry(6), 0); Assert.assertEquals("testData same object ", v1.getDataRef(), v8_2.getDataRef()); ArrayRealVector v9 = new ArrayRealVector(v1, v3); Assert.assertEquals("testData len", 10, v9.getDimension()); Assert.assertEquals("testData is 1.0 ", 1.0, v9.getEntry(7), 0); ArrayRealVector v10 = new ArrayRealVector(v2, new RealVectorTestImpl(vec3)); Assert.assertEquals("testData len", 8, v10.getDimension()); Assert.assertEquals("testData is 1.23 ", 1.23, v10.getEntry(4), 0); Assert.assertEquals("testData is 7.0 ", 7.0, v10.getEntry(5), 0); ArrayRealVector v11 = new ArrayRealVector(new RealVectorTestImpl(vec3), v2); Assert.assertEquals("testData len", 8, v11.getDimension()); Assert.assertEquals("testData is 9.0 ", 9.0, v11.getEntry(2), 0); Assert.assertEquals("testData is 1.23 ", 1.23, v11.getEntry(3), 0); ArrayRealVector v12 = new ArrayRealVector(v2, vec3); Assert.assertEquals("testData len", 8, v12.getDimension()); Assert.assertEquals("testData is 1.23 ", 1.23, v12.getEntry(4), 0); Assert.assertEquals("testData is 7.0 ", 7.0, v12.getEntry(5), 0); ArrayRealVector v13 = new ArrayRealVector(vec3, v2); Assert.assertEquals("testData len", 8, v13.getDimension()); Assert.assertEquals("testData is 9.0 ", 9.0, v13.getEntry(2), 0); Assert.assertEquals("testData is 1.23 ", 1.23, v13.getEntry(3), 0); ArrayRealVector v14 = new ArrayRealVector(vec3, vec4); Assert.assertEquals("testData len", 12, v14.getDimension()); Assert.assertEquals("testData is 9.0 ", 9.0, v14.getEntry(2), 0); Assert.assertEquals("testData is 1.0 ", 1.0, v14.getEntry(3), 0); } @Test public void testGetDataRef() { final double[] data = {1d, 2d, 3d, 4d}; final ArrayRealVector v = new ArrayRealVector(data); v.getDataRef()[0] = 0d; Assert.assertEquals("", 0d, v.getEntry(0), 0); } @Test public void testPredicates() { Assert.assertEquals(create(new double[] { Double.NaN, 1, 2 }).hashCode(), create(new double[] { 0, Double.NaN, 2 }).hashCode()); Assert.assertTrue(create(new double[] { Double.NaN, 1, 2 }).hashCode() != create(new double[] { 0, 1, 2 }).hashCode()); } @Test public void testZeroVectors() { Assert.assertEquals(0, new ArrayRealVector(new double[0]).getDimension()); Assert.assertEquals(0, new ArrayRealVector(new double[0], true).getDimension()); Assert.assertEquals(0, new ArrayRealVector(new double[0], false).getDimension()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import org.apache.commons.math3.linear.BiDiagonalTransformer; import org.apache.commons.math3.linear.MatrixUtils; import org.apache.commons.math3.linear.RealMatrix; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class BiDiagonalTransformerTest { private double[][] testSquare = { { 24.0 / 25.0, 43.0 / 25.0 }, { 57.0 / 25.0, 24.0 / 25.0 } }; private double[][] testNonSquare = { { -540.0 / 625.0, 963.0 / 625.0, -216.0 / 625.0 }, { -1730.0 / 625.0, -744.0 / 625.0, 1008.0 / 625.0 }, { -720.0 / 625.0, 1284.0 / 625.0, -288.0 / 625.0 }, { -360.0 / 625.0, 192.0 / 625.0, 1756.0 / 625.0 }, }; @Test public void testDimensions() { checkdimensions(MatrixUtils.createRealMatrix(testSquare)); checkdimensions(MatrixUtils.createRealMatrix(testNonSquare)); checkdimensions(MatrixUtils.createRealMatrix(testNonSquare).transpose()); } private void checkdimensions(RealMatrix matrix) { final int m = matrix.getRowDimension(); final int n = matrix.getColumnDimension(); BiDiagonalTransformer transformer = new BiDiagonalTransformer(matrix); Assert.assertEquals(m, transformer.getU().getRowDimension()); Assert.assertEquals(m, transformer.getU().getColumnDimension()); Assert.assertEquals(m, transformer.getB().getRowDimension()); Assert.assertEquals(n, transformer.getB().getColumnDimension()); Assert.assertEquals(n, transformer.getV().getRowDimension()); Assert.assertEquals(n, transformer.getV().getColumnDimension()); } @Test public void testAEqualUSVt() { checkAEqualUSVt(MatrixUtils.createRealMatrix(testSquare)); checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare)); checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare).transpose()); } private void checkAEqualUSVt(RealMatrix matrix) { BiDiagonalTransformer transformer = new BiDiagonalTransformer(matrix); RealMatrix u = transformer.getU(); RealMatrix b = transformer.getB(); RealMatrix v = transformer.getV(); double norm = u.multiply(b).multiply(v.transpose()).subtract(matrix).getNorm(); Assert.assertEquals(0, norm, 1.0e-14); } @Test public void testUOrthogonal() { checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare)).getU()); checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare)).getU()); checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getU()); } @Test public void testVOrthogonal() { checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare)).getV()); checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare)).getV()); checkOrthogonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getV()); } private void checkOrthogonal(RealMatrix m) { RealMatrix mTm = m.transpose().multiply(m); RealMatrix id = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension()); Assert.assertEquals(0, mTm.subtract(id).getNorm(), 1.0e-14); } @Test public void testBBiDiagonal() { checkBiDiagonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare)).getB()); checkBiDiagonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare)).getB()); checkBiDiagonal(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getB()); } private void checkBiDiagonal(RealMatrix m) { final int rows = m.getRowDimension(); final int cols = m.getColumnDimension(); for (int i = 0; i < rows; ++i) { for (int j = 0; j < cols; ++j) { if (rows < cols) { if ((i < j) || (i > j + 1)) { Assert.assertEquals(0, m.getEntry(i, j), 1.0e-16); } } else { if ((i < j - 1) || (i > j)) { Assert.assertEquals(0, m.getEntry(i, j), 1.0e-16); } } } } } @Test public void testSingularMatrix() { BiDiagonalTransformer transformer = new BiDiagonalTransformer(MatrixUtils.createRealMatrix(new double[][] { { 1.0, 2.0, 3.0 }, { 2.0, 3.0, 4.0 }, { 3.0, 5.0, 7.0 } })); final double s3 = FastMath.sqrt(3.0); final double s14 = FastMath.sqrt(14.0); final double s1553 = FastMath.sqrt(1553.0); RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] { { -1.0 / s14, 5.0 / (s3 * s14), 1.0 / s3 }, { -2.0 / s14, -4.0 / (s3 * s14), 1.0 / s3 }, { -3.0 / s14, 1.0 / (s3 * s14), -1.0 / s3 } }); RealMatrix bRef = MatrixUtils.createRealMatrix(new double[][] { { -s14, s1553 / s14, 0.0 }, { 0.0, -87 * s3 / (s14 * s1553), -s3 * s14 / s1553 }, { 0.0, 0.0, 0.0 } }); RealMatrix vRef = MatrixUtils.createRealMatrix(new double[][] { { 1.0, 0.0, 0.0 }, { 0.0, -23 / s1553, 32 / s1553 }, { 0.0, -32 / s1553, -23 / s1553 } }); // check values against known references RealMatrix u = transformer.getU(); Assert.assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-14); RealMatrix b = transformer.getB(); Assert.assertEquals(0, b.subtract(bRef).getNorm(), 1.0e-14); RealMatrix v = transformer.getV(); Assert.assertEquals(0, v.subtract(vRef).getNorm(), 1.0e-14); // check the same cached instance is returned the second time Assert.assertTrue(u == transformer.getU()); Assert.assertTrue(b == transformer.getB()); Assert.assertTrue(v == transformer.getV()); } @Test public void testMatricesValues() { BiDiagonalTransformer transformer = new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare)); final double s17 = FastMath.sqrt(17.0); RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] { { -8 / (5 * s17), 19 / (5 * s17) }, { -19 / (5 * s17), -8 / (5 * s17) } }); RealMatrix bRef = MatrixUtils.createRealMatrix(new double[][] { { -3 * s17 / 5, 32 * s17 / 85 }, { 0.0, -5 * s17 / 17 } }); RealMatrix vRef = MatrixUtils.createRealMatrix(new double[][] { { 1.0, 0.0 }, { 0.0, -1.0 } }); // check values against known references RealMatrix u = transformer.getU(); Assert.assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-14); RealMatrix b = transformer.getB(); Assert.assertEquals(0, b.subtract(bRef).getNorm(), 1.0e-14); RealMatrix v = transformer.getV(); Assert.assertEquals(0, v.subtract(vRef).getNorm(), 1.0e-14); // check the same cached instance is returned the second time Assert.assertTrue(u == transformer.getU()); Assert.assertTrue(b == transformer.getB()); Assert.assertTrue(v == transformer.getV()); } @Test public void testUpperOrLower() { Assert.assertTrue(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare)).isUpperBiDiagonal()); Assert.assertTrue(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare)).isUpperBiDiagonal()); Assert.assertFalse(new BiDiagonalTransformer(MatrixUtils.createRealMatrix(testNonSquare).transpose()).isUpperBiDiagonal()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import java.util.Arrays; import java.util.Random; import org.junit.Test; import org.junit.Assert; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.fraction.Fraction; import org.apache.commons.math3.fraction.FractionField; import org.apache.commons.math3.exception.NoDataException; import org.apache.commons.math3.exception.NullArgumentException; import org.apache.commons.math3.exception.OutOfRangeException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.apache.commons.math3.exception.MathIllegalArgumentException; /** * Test cases for the {@link BlockFieldMatrix} class. * * @version $Id$ */ public final class BlockFieldMatrixTest { // 3 x 3 identity matrix protected Fraction[][] id = { {new Fraction(1),new Fraction(0),new Fraction(0)}, {new Fraction(0),new Fraction(1),new Fraction(0)}, {new Fraction(0),new Fraction(0),new Fraction(1)} }; // Test data for group operations protected Fraction[][] testData = { {new Fraction(1),new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(5),new Fraction(3)}, {new Fraction(1),new Fraction(0),new Fraction(8)} }; protected Fraction[][] testDataLU = { {new Fraction(2), new Fraction(5), new Fraction(3)}, {new Fraction(1, 2), new Fraction(-5, 2), new Fraction(13, 2)}, {new Fraction(1, 2), new Fraction(1, 5), new Fraction(1, 5)} }; protected Fraction[][] testDataPlus2 = { {new Fraction(3),new Fraction(4),new Fraction(5)}, {new Fraction(4),new Fraction(7),new Fraction(5)}, {new Fraction(3),new Fraction(2),new Fraction(10)} }; protected Fraction[][] testDataMinus = { {new Fraction(-1),new Fraction(-2),new Fraction(-3)}, {new Fraction(-2),new Fraction(-5),new Fraction(-3)}, {new Fraction(-1),new Fraction(0),new Fraction(-8)} }; protected Fraction[] testDataRow1 = {new Fraction(1),new Fraction(2),new Fraction(3)}; protected Fraction[] testDataCol3 = {new Fraction(3),new Fraction(3),new Fraction(8)}; protected Fraction[][] testDataInv = { {new Fraction(-40),new Fraction(16),new Fraction(9)}, {new Fraction(13),new Fraction(-5),new Fraction(-3)}, {new Fraction(5),new Fraction(-2),new Fraction(-1)} }; protected Fraction[] preMultTest = {new Fraction(8), new Fraction(12), new Fraction(33)}; protected Fraction[][] testData2 = { {new Fraction(1),new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(5),new Fraction(3)} }; protected Fraction[][] testData2T = { {new Fraction(1),new Fraction(2)}, {new Fraction(2),new Fraction(5)}, {new Fraction(3),new Fraction(3)} }; protected Fraction[][] testDataPlusInv = { {new Fraction(-39),new Fraction(18),new Fraction(12)}, {new Fraction(15),new Fraction(0),new Fraction(0)}, {new Fraction(6),new Fraction(-2),new Fraction(7)} }; // lu decomposition tests protected Fraction[][] luData = { {new Fraction(2),new Fraction(3),new Fraction(3)}, {new Fraction(0),new Fraction(5),new Fraction(7)}, {new Fraction(6),new Fraction(9),new Fraction(8)} }; protected Fraction[][] luDataLUDecomposition = { {new Fraction(6),new Fraction(9),new Fraction(8)}, {new Fraction(0),new Fraction(5),new Fraction(7)}, {new Fraction(1, 3),new Fraction(0),new Fraction(1, 3)} }; // singular matrices protected Fraction[][] singular = { {new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(3)} }; protected Fraction[][] bigSingular = { {new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)}, {new Fraction(2),new Fraction(5),new Fraction(3),new Fraction(4)}, {new Fraction(7),new Fraction(3),new Fraction(256),new Fraction(1930)}, {new Fraction(3),new Fraction(7),new Fraction(6),new Fraction(8)} }; // 4th row = 1st + 2nd protected Fraction[][] detData = { {new Fraction(1),new Fraction(2),new Fraction(3)}, {new Fraction(4),new Fraction(5),new Fraction(6)}, {new Fraction(7),new Fraction(8),new Fraction(10)} }; protected Fraction[][] detData2 = { {new Fraction(1), new Fraction(3)}, {new Fraction(2), new Fraction(4)}}; // vectors protected Fraction[] testVector = {new Fraction(1),new Fraction(2),new Fraction(3)}; protected Fraction[] testVector2 = {new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)}; // submatrix accessor tests protected Fraction[][] subTestData = { {new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4)}, {new Fraction(3, 2), new Fraction(5, 2), new Fraction(7, 2), new Fraction(9, 2)}, {new Fraction(2), new Fraction(4), new Fraction(6), new Fraction(8)}, {new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7)} }; // array selections protected Fraction[][] subRows02Cols13 = { {new Fraction(2), new Fraction(4)}, {new Fraction(4), new Fraction(8)}}; protected Fraction[][] subRows03Cols12 = { {new Fraction(2), new Fraction(3)}, {new Fraction(5), new Fraction(6)}}; protected Fraction[][] subRows03Cols123 = { {new Fraction(2), new Fraction(3), new Fraction(4)}, {new Fraction(5), new Fraction(6), new Fraction(7)} }; // effective permutations protected Fraction[][] subRows20Cols123 = { {new Fraction(4), new Fraction(6), new Fraction(8)}, {new Fraction(2), new Fraction(3), new Fraction(4)} }; protected Fraction[][] subRows31Cols31 = {{new Fraction(7), new Fraction(5)}, {new Fraction(9, 2), new Fraction(5, 2)}}; // contiguous ranges protected Fraction[][] subRows01Cols23 = {{new Fraction(3),new Fraction(4)} , {new Fraction(7, 2), new Fraction(9, 2)}}; protected Fraction[][] subRows23Cols00 = {{new Fraction(2)} , {new Fraction(4)}}; protected Fraction[][] subRows00Cols33 = {{new Fraction(4)}}; // row matrices protected Fraction[][] subRow0 = {{new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)}}; protected Fraction[][] subRow3 = {{new Fraction(4),new Fraction(5),new Fraction(6),new Fraction(7)}}; // column matrices protected Fraction[][] subColumn1 = {{new Fraction(2)}, {new Fraction(5, 2)}, {new Fraction(4)}, {new Fraction(5)}}; protected Fraction[][] subColumn3 = {{new Fraction(4)}, {new Fraction(9, 2)}, {new Fraction(8)}, {new Fraction(7)}}; // tolerances protected double entryTolerance = 10E-16; protected double normTolerance = 10E-14; /** test dimensions */ @Test public void testDimensions() { BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testData2); Assert.assertEquals("testData row dimension",3,m.getRowDimension()); Assert.assertEquals("testData column dimension",3,m.getColumnDimension()); Assert.assertTrue("testData is square",m.isSquare()); Assert.assertEquals("testData2 row dimension",m2.getRowDimension(),2); Assert.assertEquals("testData2 column dimension",m2.getColumnDimension(),3); Assert.assertTrue("testData2 is not square",!m2.isSquare()); } /** test copy functions */ @Test public void testCopyFunctions() { Random r = new Random(66636328996002l); BlockFieldMatrix<Fraction> m1 = createRandomMatrix(r, 47, 83); BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(m1.getData()); Assert.assertEquals(m1, m2); BlockFieldMatrix<Fraction> m3 = new BlockFieldMatrix<Fraction>(testData); BlockFieldMatrix<Fraction> m4 = new BlockFieldMatrix<Fraction>(m3.getData()); Assert.assertEquals(m3, m4); } /** test add */ @Test public void testAdd() { BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); BlockFieldMatrix<Fraction> mInv = new BlockFieldMatrix<Fraction>(testDataInv); FieldMatrix<Fraction> mPlusMInv = m.add(mInv); Fraction[][] sumEntries = mPlusMInv.getData(); for (int row = 0; row < m.getRowDimension(); row++) { for (int col = 0; col < m.getColumnDimension(); col++) { Assert.assertEquals(testDataPlusInv[row][col],sumEntries[row][col]); } } } /** test add failure */ @Test public void testAddFail() { BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testData2); try { m.add(m2); Assert.fail("MathIllegalArgumentException expected"); } catch (MathIllegalArgumentException ex) { // ignored } } /** test m-n = m + -n */ @Test public void testPlusMinus() { BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testDataInv); TestUtils.assertEquals(m.subtract(m2), m2.scalarMultiply(new Fraction(-1)).add(m)); try { m.subtract(new BlockFieldMatrix<Fraction>(testData2)); Assert.fail("Expecting illegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } } /** test multiply */ @Test public void testMultiply() { BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); BlockFieldMatrix<Fraction> mInv = new BlockFieldMatrix<Fraction>(testDataInv); BlockFieldMatrix<Fraction> identity = new BlockFieldMatrix<Fraction>(id); BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testData2); TestUtils.assertEquals(m.multiply(mInv), identity); TestUtils.assertEquals(mInv.multiply(m), identity); TestUtils.assertEquals(m.multiply(identity), m); TestUtils.assertEquals(identity.multiply(mInv), mInv); TestUtils.assertEquals(m2.multiply(identity), m2); try { m.multiply(new BlockFieldMatrix<Fraction>(bigSingular)); Assert.fail("Expecting illegalArgumentException"); } catch (MathIllegalArgumentException ex) { // expected } } @Test public void testSeveralBlocks() { FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), 37, 41); for (int i = 0; i < m.getRowDimension(); ++i) { for (int j = 0; j < m.getColumnDimension(); ++j) { m.setEntry(i, j, new Fraction(i * 11 + j, 11)); } } FieldMatrix<Fraction> mT = m.transpose(); Assert.assertEquals(m.getRowDimension(), mT.getColumnDimension()); Assert.assertEquals(m.getColumnDimension(), mT.getRowDimension()); for (int i = 0; i < mT.getRowDimension(); ++i) { for (int j = 0; j < mT.getColumnDimension(); ++j) { Assert.assertEquals(m.getEntry(j, i), mT.getEntry(i, j)); } } FieldMatrix<Fraction> mPm = m.add(m); for (int i = 0; i < mPm.getRowDimension(); ++i) { for (int j = 0; j < mPm.getColumnDimension(); ++j) { Assert.assertEquals(m.getEntry(i, j).multiply(new Fraction(2)), mPm.getEntry(i, j)); } } FieldMatrix<Fraction> mPmMm = mPm.subtract(m); for (int i = 0; i < mPmMm.getRowDimension(); ++i) { for (int j = 0; j < mPmMm.getColumnDimension(); ++j) { Assert.assertEquals(m.getEntry(i, j), mPmMm.getEntry(i, j)); } } FieldMatrix<Fraction> mTm = mT.multiply(m); for (int i = 0; i < mTm.getRowDimension(); ++i) { for (int j = 0; j < mTm.getColumnDimension(); ++j) { Fraction sum = Fraction.ZERO; for (int k = 0; k < mT.getColumnDimension(); ++k) { sum = sum.add(new Fraction(k * 11 + i, 11).multiply(new Fraction(k * 11 + j, 11))); } Assert.assertEquals(sum, mTm.getEntry(i, j)); } } FieldMatrix<Fraction> mmT = m.multiply(mT); for (int i = 0; i < mmT.getRowDimension(); ++i) { for (int j = 0; j < mmT.getColumnDimension(); ++j) { Fraction sum = Fraction.ZERO; for (int k = 0; k < m.getColumnDimension(); ++k) { sum = sum.add(new Fraction(i * 11 + k, 11).multiply(new Fraction(j * 11 + k, 11))); } Assert.assertEquals(sum, mmT.getEntry(i, j)); } } FieldMatrix<Fraction> sub1 = m.getSubMatrix(2, 9, 5, 20); for (int i = 0; i < sub1.getRowDimension(); ++i) { for (int j = 0; j < sub1.getColumnDimension(); ++j) { Assert.assertEquals(new Fraction((i + 2) * 11 + (j + 5), 11), sub1.getEntry(i, j)); } } FieldMatrix<Fraction> sub2 = m.getSubMatrix(10, 12, 3, 40); for (int i = 0; i < sub2.getRowDimension(); ++i) { for (int j = 0; j < sub2.getColumnDimension(); ++j) { Assert.assertEquals(new Fraction((i + 10) * 11 + (j + 3), 11), sub2.getEntry(i, j)); } } FieldMatrix<Fraction> sub3 = m.getSubMatrix(30, 34, 0, 5); for (int i = 0; i < sub3.getRowDimension(); ++i) { for (int j = 0; j < sub3.getColumnDimension(); ++j) { Assert.assertEquals(new Fraction((i + 30) * 11 + (j + 0), 11), sub3.getEntry(i, j)); } } FieldMatrix<Fraction> sub4 = m.getSubMatrix(30, 32, 32, 35); for (int i = 0; i < sub4.getRowDimension(); ++i) { for (int j = 0; j < sub4.getColumnDimension(); ++j) { Assert.assertEquals(new Fraction((i + 30) * 11 + (j + 32), 11), sub4.getEntry(i, j)); } } } //Additional Test for BlockFieldMatrix<Fraction>Test.testMultiply private Fraction[][] d3 = new Fraction[][] { {new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)}, {new Fraction(5),new Fraction(6),new Fraction(7),new Fraction(8)} }; private Fraction[][] d4 = new Fraction[][] { {new Fraction(1)}, {new Fraction(2)}, {new Fraction(3)}, {new Fraction(4)} }; private Fraction[][] d5 = new Fraction[][] {{new Fraction(30)},{new Fraction(70)}}; @Test public void testMultiply2() { FieldMatrix<Fraction> m3 = new BlockFieldMatrix<Fraction>(d3); FieldMatrix<Fraction> m4 = new BlockFieldMatrix<Fraction>(d4); FieldMatrix<Fraction> m5 = new BlockFieldMatrix<Fraction>(d5); TestUtils.assertEquals(m3.multiply(m4), m5); } /** test trace */ @Test public void testTrace() { FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(id); Assert.assertEquals(new Fraction(3),m.getTrace()); m = new BlockFieldMatrix<Fraction>(testData2); try { m.getTrace(); Assert.fail("Expecting NonSquareMatrixException"); } catch (NonSquareMatrixException ex) { // ignored } } /** test scalarAdd */ @Test public void testScalarAdd() { FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); TestUtils.assertEquals(new BlockFieldMatrix<Fraction>(testDataPlus2), m.scalarAdd(new Fraction(2))); } /** test operate */ @Test public void testOperate() { FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(id); TestUtils.assertEquals(testVector, m.operate(testVector)); TestUtils.assertEquals(testVector, m.operate(new ArrayFieldVector<Fraction>(testVector)).getData()); m = new BlockFieldMatrix<Fraction>(bigSingular); try { m.operate(testVector); Assert.fail("Expecting illegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } } @Test public void testOperateLarge() { int p = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10; int q = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10; int r = BlockFieldMatrix.BLOCK_SIZE / 2; Random random = new Random(111007463902334l); FieldMatrix<Fraction> m1 = createRandomMatrix(random, p, q); FieldMatrix<Fraction> m2 = createRandomMatrix(random, q, r); FieldMatrix<Fraction> m1m2 = m1.multiply(m2); for (int i = 0; i < r; ++i) { TestUtils.assertEquals(m1m2.getColumn(i), m1.operate(m2.getColumn(i))); } } @Test public void testOperatePremultiplyLarge() { int p = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10; int q = (11 * BlockFieldMatrix.BLOCK_SIZE) / 10; int r = BlockFieldMatrix.BLOCK_SIZE / 2; Random random = new Random(111007463902334l); FieldMatrix<Fraction> m1 = createRandomMatrix(random, p, q); FieldMatrix<Fraction> m2 = createRandomMatrix(random, q, r); FieldMatrix<Fraction> m1m2 = m1.multiply(m2); for (int i = 0; i < p; ++i) { TestUtils.assertEquals(m1m2.getRow(i), m2.preMultiply(m1.getRow(i))); } } /** test issue MATH-209 */ @Test public void testMath209() { FieldMatrix<Fraction> a = new BlockFieldMatrix<Fraction>(new Fraction[][] { { new Fraction(1), new Fraction(2) }, { new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6) } }); Fraction[] b = a.operate(new Fraction[] { new Fraction(1), new Fraction(1) }); Assert.assertEquals(a.getRowDimension(), b.length); Assert.assertEquals( new Fraction(3), b[0]); Assert.assertEquals( new Fraction(7), b[1]); Assert.assertEquals(new Fraction(11), b[2]); } /** test transpose */ @Test public void testTranspose() { FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); FieldMatrix<Fraction> mIT = new FieldLUDecomposition<Fraction>(m).getSolver().getInverse().transpose(); FieldMatrix<Fraction> mTI = new FieldLUDecomposition<Fraction>(m.transpose()).getSolver().getInverse(); TestUtils.assertEquals(mIT, mTI); m = new BlockFieldMatrix<Fraction>(testData2); FieldMatrix<Fraction> mt = new BlockFieldMatrix<Fraction>(testData2T); TestUtils.assertEquals(mt, m.transpose()); } /** test preMultiply by vector */ @Test public void testPremultiplyVector() { FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); TestUtils.assertEquals(m.preMultiply(testVector), preMultTest); TestUtils.assertEquals(m.preMultiply(new ArrayFieldVector<Fraction>(testVector).getData()), preMultTest); m = new BlockFieldMatrix<Fraction>(bigSingular); try { m.preMultiply(testVector); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } } @Test public void testPremultiply() { FieldMatrix<Fraction> m3 = new BlockFieldMatrix<Fraction>(d3); FieldMatrix<Fraction> m4 = new BlockFieldMatrix<Fraction>(d4); FieldMatrix<Fraction> m5 = new BlockFieldMatrix<Fraction>(d5); TestUtils.assertEquals(m4.preMultiply(m3), m5); BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); BlockFieldMatrix<Fraction> mInv = new BlockFieldMatrix<Fraction>(testDataInv); BlockFieldMatrix<Fraction> identity = new BlockFieldMatrix<Fraction>(id); TestUtils.assertEquals(m.preMultiply(mInv), identity); TestUtils.assertEquals(mInv.preMultiply(m), identity); TestUtils.assertEquals(m.preMultiply(identity), m); TestUtils.assertEquals(identity.preMultiply(mInv), mInv); try { m.preMultiply(new BlockFieldMatrix<Fraction>(bigSingular)); Assert.fail("Expecting illegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } } @Test public void testGetVectors() { FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); TestUtils.assertEquals(m.getRow(0), testDataRow1); TestUtils.assertEquals(m.getColumn(2), testDataCol3); try { m.getRow(10); Assert.fail("expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // ignored } try { m.getColumn(-1); Assert.fail("expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // ignored } } @Test public void testGetEntry() { FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); Assert.assertEquals(m.getEntry(0,1),new Fraction(2)); try { m.getEntry(10, 4); Assert.fail ("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } /** test examples in user guide */ @Test public void testExamples() { // Create a real matrix with two rows and three columns Fraction[][] matrixData = { {new Fraction(1),new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(5),new Fraction(3)} }; FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(matrixData); // One more with three rows, two columns Fraction[][] matrixData2 = { {new Fraction(1),new Fraction(2)}, {new Fraction(2),new Fraction(5)}, {new Fraction(1), new Fraction(7)} }; FieldMatrix<Fraction> n = new BlockFieldMatrix<Fraction>(matrixData2); // Now multiply m by n FieldMatrix<Fraction> p = m.multiply(n); Assert.assertEquals(2, p.getRowDimension()); Assert.assertEquals(2, p.getColumnDimension()); // Invert p FieldMatrix<Fraction> pInverse = new FieldLUDecomposition<Fraction>(p).getSolver().getInverse(); Assert.assertEquals(2, pInverse.getRowDimension()); Assert.assertEquals(2, pInverse.getColumnDimension()); // Solve example Fraction[][] coefficientsData = { {new Fraction(2), new Fraction(3), new Fraction(-2)}, {new Fraction(-1), new Fraction(7), new Fraction(6)}, {new Fraction(4), new Fraction(-3), new Fraction(-5)} }; FieldMatrix<Fraction> coefficients = new BlockFieldMatrix<Fraction>(coefficientsData); Fraction[] constants = { new Fraction(1), new Fraction(-2), new Fraction(1) }; Fraction[] solution; solution = new FieldLUDecomposition<Fraction>(coefficients) .getSolver() .solve(new ArrayFieldVector<Fraction>(constants, false)).toArray(); Assert.assertEquals(new Fraction(2).multiply(solution[0]). add(new Fraction(3).multiply(solution[1])). subtract(new Fraction(2).multiply(solution[2])), constants[0]); Assert.assertEquals(new Fraction(-1).multiply(solution[0]). add(new Fraction(7).multiply(solution[1])). add(new Fraction(6).multiply(solution[2])), constants[1]); Assert.assertEquals(new Fraction(4).multiply(solution[0]). subtract(new Fraction(3).multiply(solution[1])). subtract(new Fraction(5).multiply(solution[2])), constants[2]); } // test submatrix accessors @Test public void testGetSubMatrix() { FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData); checkGetSubMatrix(m, subRows23Cols00, 2 , 3 , 0, 0); checkGetSubMatrix(m, subRows00Cols33, 0 , 0 , 3, 3); checkGetSubMatrix(m, subRows01Cols23, 0 , 1 , 2, 3); checkGetSubMatrix(m, subRows02Cols13, new int[] { 0, 2 }, new int[] { 1, 3 }); checkGetSubMatrix(m, subRows03Cols12, new int[] { 0, 3 }, new int[] { 1, 2 }); checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }); checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }); checkGetSubMatrix(m, subRows31Cols31, new int[] { 3, 1 }, new int[] { 3, 1 }); checkGetSubMatrix(m, subRows31Cols31, new int[] { 3, 1 }, new int[] { 3, 1 }); checkGetSubMatrix(m, null, 1, 0, 2, 4); checkGetSubMatrix(m, null, -1, 1, 2, 2); checkGetSubMatrix(m, null, 1, 0, 2, 2); checkGetSubMatrix(m, null, 1, 0, 2, 4); checkGetSubMatrix(m, null, new int[] {}, new int[] { 0 }); checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 }); } private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference, int startRow, int endRow, int startColumn, int endColumn) { try { FieldMatrix<Fraction> sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn); if (reference != null) { Assert.assertEquals(new BlockFieldMatrix<Fraction>(reference), sub); } else { Assert.fail("Expecting OutOfRangeException or NotStrictlyPositiveException" + " or NumberIsTooSmallException or NoDataException"); } } catch (OutOfRangeException e) { if (reference != null) { throw e; } } catch (NotStrictlyPositiveException e) { if (reference != null) { throw e; } } catch (NumberIsTooSmallException e) { if (reference != null) { throw e; } } catch (NoDataException e) { if (reference != null) { throw e; } } } private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference, int[] selectedRows, int[] selectedColumns) { try { FieldMatrix<Fraction> sub = m.getSubMatrix(selectedRows, selectedColumns); if (reference != null) { Assert.assertEquals(new BlockFieldMatrix<Fraction>(reference), sub); } else { Assert.fail("Expecting OutOfRangeException"); } } catch (OutOfRangeException e) { if (reference != null) { throw e; } } catch (NotStrictlyPositiveException e) { if (reference != null) { throw e; } } catch (NumberIsTooSmallException e) { if (reference != null) { throw e; } } catch (NoDataException e) { if (reference != null) { throw e; } } } @Test public void testGetSetMatrixLarge() { int n = 3 * BlockFieldMatrix.BLOCK_SIZE; FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n); FieldMatrix<Fraction> sub = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n - 4, n - 4).scalarAdd(new Fraction(1)); m.setSubMatrix(sub.getData(), 2, 2); for (int i = 0; i < n; ++i) { for (int j = 0; j < n; ++j) { if ((i < 2) || (i > n - 3) || (j < 2) || (j > n - 3)) { Assert.assertEquals(new Fraction(0), m.getEntry(i, j)); } else { Assert.assertEquals(new Fraction(1), m.getEntry(i, j)); } } } Assert.assertEquals(sub, m.getSubMatrix(2, n - 3, 2, n - 3)); } @Test public void testCopySubMatrix() { FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData); checkCopy(m, subRows23Cols00, 2 , 3 , 0, 0); checkCopy(m, subRows00Cols33, 0 , 0 , 3, 3); checkCopy(m, subRows01Cols23, 0 , 1 , 2, 3); checkCopy(m, subRows02Cols13, new int[] { 0, 2 }, new int[] { 1, 3 }); checkCopy(m, subRows03Cols12, new int[] { 0, 3 }, new int[] { 1, 2 }); checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }); checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }); checkCopy(m, subRows31Cols31, new int[] { 3, 1 }, new int[] { 3, 1 }); checkCopy(m, subRows31Cols31, new int[] { 3, 1 }, new int[] { 3, 1 }); checkCopy(m, null, 1, 0, 2, 4); checkCopy(m, null, -1, 1, 2, 2); checkCopy(m, null, 1, 0, 2, 2); checkCopy(m, null, 1, 0, 2, 4); checkCopy(m, null, new int[] {}, new int[] { 0 }); checkCopy(m, null, new int[] { 0 }, new int[] { 4 }); } private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference, int startRow, int endRow, int startColumn, int endColumn) { try { Fraction[][] sub = (reference == null) ? new Fraction[1][1] : new Fraction[reference.length][reference[0].length]; m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub); if (reference != null) { Assert.assertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub)); } else { Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException"); } } catch (OutOfRangeException e) { if (reference != null) { throw e; } } catch (NumberIsTooSmallException e) { if (reference != null) { throw e; } } catch (NoDataException e) { if (reference != null) { throw e; } } } private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference, int[] selectedRows, int[] selectedColumns) { try { Fraction[][] sub = (reference == null) ? new Fraction[1][1] : new Fraction[reference.length][reference[0].length]; m.copySubMatrix(selectedRows, selectedColumns, sub); if (reference != null) { Assert.assertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub)); } else { Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException"); } } catch (OutOfRangeException e) { if (reference != null) { throw e; } } catch (NumberIsTooSmallException e) { if (reference != null) { throw e; } } catch (NoDataException e) { if (reference != null) { throw e; } } } @Test public void testGetRowMatrix() { FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData); FieldMatrix<Fraction> mRow0 = new BlockFieldMatrix<Fraction>(subRow0); FieldMatrix<Fraction> mRow3 = new BlockFieldMatrix<Fraction>(subRow3); Assert.assertEquals("Row0", mRow0, m.getRowMatrix(0)); Assert.assertEquals("Row3", mRow3, m.getRowMatrix(3)); try { m.getRowMatrix(-1); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getRowMatrix(4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testSetRowMatrix() { FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData); FieldMatrix<Fraction> mRow3 = new BlockFieldMatrix<Fraction>(subRow3); Assert.assertNotSame(mRow3, m.getRowMatrix(0)); m.setRowMatrix(0, mRow3); Assert.assertEquals(mRow3, m.getRowMatrix(0)); try { m.setRowMatrix(-1, mRow3); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.setRowMatrix(0, m); Assert.fail("Expecting MatrixDimensionMismatchException"); } catch (MatrixDimensionMismatchException ex) { // expected } } @Test public void testGetSetRowMatrixLarge() { int n = 3 * BlockFieldMatrix.BLOCK_SIZE; FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n); FieldMatrix<Fraction> sub = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), 1, n).scalarAdd(new Fraction(1)); m.setRowMatrix(2, sub); for (int i = 0; i < n; ++i) { for (int j = 0; j < n; ++j) { if (i != 2) { Assert.assertEquals(new Fraction(0), m.getEntry(i, j)); } else { Assert.assertEquals(new Fraction(1), m.getEntry(i, j)); } } } Assert.assertEquals(sub, m.getRowMatrix(2)); } @Test public void testGetColumnMatrix() { FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData); FieldMatrix<Fraction> mColumn1 = new BlockFieldMatrix<Fraction>(subColumn1); FieldMatrix<Fraction> mColumn3 = new BlockFieldMatrix<Fraction>(subColumn3); Assert.assertEquals(mColumn1, m.getColumnMatrix(1)); Assert.assertEquals(mColumn3, m.getColumnMatrix(3)); try { m.getColumnMatrix(-1); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getColumnMatrix(4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testSetColumnMatrix() { FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData); FieldMatrix<Fraction> mColumn3 = new BlockFieldMatrix<Fraction>(subColumn3); Assert.assertNotSame(mColumn3, m.getColumnMatrix(1)); m.setColumnMatrix(1, mColumn3); Assert.assertEquals(mColumn3, m.getColumnMatrix(1)); try { m.setColumnMatrix(-1, mColumn3); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.setColumnMatrix(0, m); Assert.fail("Expecting MatrixDimensionMismatchException"); } catch (MatrixDimensionMismatchException ex) { // expected } } @Test public void testGetSetColumnMatrixLarge() { int n = 3 * BlockFieldMatrix.BLOCK_SIZE; FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n); FieldMatrix<Fraction> sub = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, 1).scalarAdd(new Fraction(1)); m.setColumnMatrix(2, sub); for (int i = 0; i < n; ++i) { for (int j = 0; j < n; ++j) { if (j != 2) { Assert.assertEquals(new Fraction(0), m.getEntry(i, j)); } else { Assert.assertEquals(new Fraction(1), m.getEntry(i, j)); } } } Assert.assertEquals(sub, m.getColumnMatrix(2)); } @Test public void testGetRowVector() { FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData); FieldVector<Fraction> mRow0 = new ArrayFieldVector<Fraction>(subRow0[0]); FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]); Assert.assertEquals(mRow0, m.getRowVector(0)); Assert.assertEquals(mRow3, m.getRowVector(3)); try { m.getRowVector(-1); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getRowVector(4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testSetRowVector() { FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData); FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]); Assert.assertNotSame(mRow3, m.getRowMatrix(0)); m.setRowVector(0, mRow3); Assert.assertEquals(mRow3, m.getRowVector(0)); try { m.setRowVector(-1, mRow3); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.setRowVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5)); Assert.fail("Expecting MatrixDimensionMismatchException"); } catch (MatrixDimensionMismatchException ex) { // expected } } @Test public void testGetSetRowVectorLarge() { int n = 3 * BlockFieldMatrix.BLOCK_SIZE; FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n); FieldVector<Fraction> sub = new ArrayFieldVector<Fraction>(n, new Fraction(1)); m.setRowVector(2, sub); for (int i = 0; i < n; ++i) { for (int j = 0; j < n; ++j) { if (i != 2) { Assert.assertEquals(new Fraction(0), m.getEntry(i, j)); } else { Assert.assertEquals(new Fraction(1), m.getEntry(i, j)); } } } Assert.assertEquals(sub, m.getRowVector(2)); } @Test public void testGetColumnVector() { FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData); FieldVector<Fraction> mColumn1 = columnToVector(subColumn1); FieldVector<Fraction> mColumn3 = columnToVector(subColumn3); Assert.assertEquals(mColumn1, m.getColumnVector(1)); Assert.assertEquals(mColumn3, m.getColumnVector(3)); try { m.getColumnVector(-1); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getColumnVector(4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testSetColumnVector() { FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData); FieldVector<Fraction> mColumn3 = columnToVector(subColumn3); Assert.assertNotSame(mColumn3, m.getColumnVector(1)); m.setColumnVector(1, mColumn3); Assert.assertEquals(mColumn3, m.getColumnVector(1)); try { m.setColumnVector(-1, mColumn3); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.setColumnVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5)); Assert.fail("Expecting MatrixDimensionMismatchException"); } catch (MatrixDimensionMismatchException ex) { // expected } } @Test public void testGetSetColumnVectorLarge() { int n = 3 * BlockFieldMatrix.BLOCK_SIZE; FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n); FieldVector<Fraction> sub = new ArrayFieldVector<Fraction>(n, new Fraction(1)); m.setColumnVector(2, sub); for (int i = 0; i < n; ++i) { for (int j = 0; j < n; ++j) { if (j != 2) { Assert.assertEquals(new Fraction(0), m.getEntry(i, j)); } else { Assert.assertEquals(new Fraction(1), m.getEntry(i, j)); } } } Assert.assertEquals(sub, m.getColumnVector(2)); } private FieldVector<Fraction> columnToVector(Fraction[][] column) { Fraction[] data = new Fraction[column.length]; for (int i = 0; i < data.length; ++i) { data[i] = column[i][0]; } return new ArrayFieldVector<Fraction>(data, false); } @Test public void testGetRow() { FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData); checkArrays(subRow0[0], m.getRow(0)); checkArrays(subRow3[0], m.getRow(3)); try { m.getRow(-1); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getRow(4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testSetRow() { FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData); Assert.assertTrue(subRow3[0][0] != m.getRow(0)[0]); m.setRow(0, subRow3[0]); checkArrays(subRow3[0], m.getRow(0)); try { m.setRow(-1, subRow3[0]); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.setRow(0, new Fraction[5]); Assert.fail("Expecting MatrixDimensionMismatchException"); } catch (MatrixDimensionMismatchException ex) { // expected } } @Test public void testGetSetRowLarge() { int n = 3 * BlockFieldMatrix.BLOCK_SIZE; FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n); Fraction[] sub = new Fraction[n]; Arrays.fill(sub, new Fraction(1)); m.setRow(2, sub); for (int i = 0; i < n; ++i) { for (int j = 0; j < n; ++j) { if (i != 2) { Assert.assertEquals(new Fraction(0), m.getEntry(i, j)); } else { Assert.assertEquals(new Fraction(1), m.getEntry(i, j)); } } } checkArrays(sub, m.getRow(2)); } @Test public void testGetColumn() { FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData); Fraction[] mColumn1 = columnToArray(subColumn1); Fraction[] mColumn3 = columnToArray(subColumn3); checkArrays(mColumn1, m.getColumn(1)); checkArrays(mColumn3, m.getColumn(3)); try { m.getColumn(-1); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getColumn(4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testSetColumn() { FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData); Fraction[] mColumn3 = columnToArray(subColumn3); Assert.assertTrue(mColumn3[0] != m.getColumn(1)[0]); m.setColumn(1, mColumn3); checkArrays(mColumn3, m.getColumn(1)); try { m.setColumn(-1, mColumn3); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.setColumn(0, new Fraction[5]); Assert.fail("Expecting MatrixDimensionMismatchException"); } catch (MatrixDimensionMismatchException ex) { // expected } } @Test public void testGetSetColumnLarge() { int n = 3 * BlockFieldMatrix.BLOCK_SIZE; FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n); Fraction[] sub = new Fraction[n]; Arrays.fill(sub, new Fraction(1)); m.setColumn(2, sub); for (int i = 0; i < n; ++i) { for (int j = 0; j < n; ++j) { if (j != 2) { Assert.assertEquals(new Fraction(0), m.getEntry(i, j)); } else { Assert.assertEquals(new Fraction(1), m.getEntry(i, j)); } } } checkArrays(sub, m.getColumn(2)); } private Fraction[] columnToArray(Fraction[][] column) { Fraction[] data = new Fraction[column.length]; for (int i = 0; i < data.length; ++i) { data[i] = column[i][0]; } return data; } private void checkArrays(Fraction[] expected, Fraction[] actual) { Assert.assertEquals(expected.length, actual.length); for (int i = 0; i < expected.length; ++i) { Assert.assertEquals(expected[i], actual[i]); } } @Test public void testEqualsAndHashCode() { BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); BlockFieldMatrix<Fraction> m1 = (BlockFieldMatrix<Fraction>) m.copy(); BlockFieldMatrix<Fraction> mt = (BlockFieldMatrix<Fraction>) m.transpose(); Assert.assertTrue(m.hashCode() != mt.hashCode()); Assert.assertEquals(m.hashCode(), m1.hashCode()); Assert.assertEquals(m, m); Assert.assertEquals(m, m1); Assert.assertFalse(m.equals(null)); Assert.assertFalse(m.equals(mt)); Assert.assertFalse(m.equals(new BlockFieldMatrix<Fraction>(bigSingular))); } @Test public void testToString() { BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); Assert.assertEquals("BlockFieldMatrix{{1,2,3},{2,5,3},{1,0,8}}", m.toString()); } @Test public void testSetSubMatrix() { BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); m.setSubMatrix(detData2,1,1); FieldMatrix<Fraction> expected = new BlockFieldMatrix<Fraction> (new Fraction[][] {{new Fraction(1),new Fraction(2),new Fraction(3)},{new Fraction(2),new Fraction(1),new Fraction(3)},{new Fraction(1),new Fraction(2),new Fraction(4)}}); Assert.assertEquals(expected, m); m.setSubMatrix(detData2,0,0); expected = new BlockFieldMatrix<Fraction> (new Fraction[][] {{new Fraction(1),new Fraction(3),new Fraction(3)},{new Fraction(2),new Fraction(4),new Fraction(3)},{new Fraction(1),new Fraction(2),new Fraction(4)}}); Assert.assertEquals(expected, m); m.setSubMatrix(testDataPlus2,0,0); expected = new BlockFieldMatrix<Fraction> (new Fraction[][] {{new Fraction(3),new Fraction(4),new Fraction(5)},{new Fraction(4),new Fraction(7),new Fraction(5)},{new Fraction(3),new Fraction(2),new Fraction(10)}}); Assert.assertEquals(expected, m); // javadoc example BlockFieldMatrix<Fraction> matrix = new BlockFieldMatrix<Fraction>(new Fraction[][] { {new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4)}, {new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8)}, {new Fraction(9), new Fraction(0), new Fraction(1) , new Fraction(2)} }); matrix.setSubMatrix(new Fraction[][] { {new Fraction(3), new Fraction(4)}, {new Fraction(5), new Fraction(6)} }, 1, 1); expected = new BlockFieldMatrix<Fraction>(new Fraction[][] { {new Fraction(1), new Fraction(2), new Fraction(3),new Fraction(4)}, {new Fraction(5), new Fraction(3), new Fraction(4), new Fraction(8)}, {new Fraction(9), new Fraction(5) ,new Fraction(6), new Fraction(2)} }); Assert.assertEquals(expected, matrix); // dimension overflow try { m.setSubMatrix(testData,1,1); Assert.fail("expecting OutOfRangeException"); } catch (OutOfRangeException e) { // expected } // dimension underflow try { m.setSubMatrix(testData,-1,1); Assert.fail("expecting OutOfRangeException"); } catch (OutOfRangeException e) { // expected } try { m.setSubMatrix(testData,1,-1); Assert.fail("expecting OutOfRangeException"); } catch (OutOfRangeException e) { // expected } // null try { m.setSubMatrix(null,1,1); Assert.fail("expecting NullArgumentException"); } catch (NullArgumentException e) { // expected } // ragged try { m.setSubMatrix(new Fraction[][] {{new Fraction(1)}, {new Fraction(2), new Fraction(3)}}, 0, 0); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException e) { // expected } // empty try { m.setSubMatrix(new Fraction[][] {{}}, 0, 0); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException e) { // expected } } @Test public void testWalk() { int rows = 150; int columns = 75; FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns); m.walkInRowOrder(new SetVisitor()); GetVisitor getVisitor = new GetVisitor(); m.walkInOptimizedOrder(getVisitor); Assert.assertEquals(rows * columns, getVisitor.getCount()); m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns); m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2); getVisitor = new GetVisitor(); m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2); Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount()); for (int i = 0; i < rows; ++i) { Assert.assertEquals(new Fraction(0), m.getEntry(i, 0)); Assert.assertEquals(new Fraction(0), m.getEntry(i, columns - 1)); } for (int j = 0; j < columns; ++j) { Assert.assertEquals(new Fraction(0), m.getEntry(0, j)); Assert.assertEquals(new Fraction(0), m.getEntry(rows - 1, j)); } m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns); m.walkInColumnOrder(new SetVisitor()); getVisitor = new GetVisitor(); m.walkInOptimizedOrder(getVisitor); Assert.assertEquals(rows * columns, getVisitor.getCount()); m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns); m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2); getVisitor = new GetVisitor(); m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2); Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount()); for (int i = 0; i < rows; ++i) { Assert.assertEquals(new Fraction(0), m.getEntry(i, 0)); Assert.assertEquals(new Fraction(0), m.getEntry(i, columns - 1)); } for (int j = 0; j < columns; ++j) { Assert.assertEquals(new Fraction(0), m.getEntry(0, j)); Assert.assertEquals(new Fraction(0), m.getEntry(rows - 1, j)); } m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns); m.walkInOptimizedOrder(new SetVisitor()); getVisitor = new GetVisitor(); m.walkInRowOrder(getVisitor); Assert.assertEquals(rows * columns, getVisitor.getCount()); m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns); m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2); getVisitor = new GetVisitor(); m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2); Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount()); for (int i = 0; i < rows; ++i) { Assert.assertEquals(new Fraction(0), m.getEntry(i, 0)); Assert.assertEquals(new Fraction(0), m.getEntry(i, columns - 1)); } for (int j = 0; j < columns; ++j) { Assert.assertEquals(new Fraction(0), m.getEntry(0, j)); Assert.assertEquals(new Fraction(0), m.getEntry(rows - 1, j)); } m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns); m.walkInOptimizedOrder(new SetVisitor()); getVisitor = new GetVisitor(); m.walkInColumnOrder(getVisitor); Assert.assertEquals(rows * columns, getVisitor.getCount()); m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns); m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2); getVisitor = new GetVisitor(); m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2); Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount()); for (int i = 0; i < rows; ++i) { Assert.assertEquals(new Fraction(0), m.getEntry(i, 0)); Assert.assertEquals(new Fraction(0), m.getEntry(i, columns - 1)); } for (int j = 0; j < columns; ++j) { Assert.assertEquals(new Fraction(0), m.getEntry(0, j)); Assert.assertEquals(new Fraction(0), m.getEntry(rows - 1, j)); } } @Test public void testSerial() { BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); Assert.assertEquals(m,TestUtils.serializeAndRecover(m)); } private static class SetVisitor extends DefaultFieldMatrixChangingVisitor<Fraction> { public SetVisitor() { super(Fraction.ZERO); } @Override public Fraction visit(int i, int j, Fraction value) { return new Fraction(i * 11 + j, 11); } } private static class GetVisitor extends DefaultFieldMatrixPreservingVisitor<Fraction> { private int count; public GetVisitor() { super(Fraction.ZERO); count = 0; } @Override public void visit(int i, int j, Fraction value) { ++count; Assert.assertEquals(new Fraction(i * 11 + j, 11), value); } public int getCount() { return count; } } private BlockFieldMatrix<Fraction> createRandomMatrix(Random r, int rows, int columns) { BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns); for (int i = 0; i < rows; ++i) { for (int j = 0; j < columns; ++j) { int p = r.nextInt(20) - 10; int q = r.nextInt(20) - 10; if (q == 0) { q = 1; } m.setEntry(i, j, new Fraction(p, q)); } } return m; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import java.util.Arrays; import java.util.Random; import org.junit.Test; import org.junit.Assert; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.exception.NullArgumentException; import org.apache.commons.math3.exception.OutOfRangeException; import org.apache.commons.math3.exception.NoDataException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.exception.MathIllegalArgumentException; /** * Test cases for the {@link BlockRealMatrix} class. * * @version $Id$ */ public final class BlockRealMatrixTest { // 3 x 3 identity matrix protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} }; // Test data for group operations protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} }; protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}}; protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} }; protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d}, {-1d,0d,-8d} }; protected double[] testDataRow1 = {1d,2d,3d}; protected double[] testDataCol3 = {3d,3d,8d}; protected double[][] testDataInv = { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} }; protected double[] preMultTest = {8,12,33}; protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}}; protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}}; protected double[][] testDataPlusInv = { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} }; // lu decomposition tests protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} }; protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d}, {0.33333333333333,0d,0.33333333333333} }; // singular matrices protected double[][] singular = { {2d,3d}, {2d,3d} }; protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d}, {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} }; protected double[][] detData2 = { {1d, 3d}, {2d, 4d}}; // vectors protected double[] testVector = {1,2,3}; protected double[] testVector2 = {1,2,3,4}; // submatrix accessor tests protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5}, {2, 4, 6, 8}, {4, 5, 6, 7}}; // array selections protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}}; protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}}; protected double[][] subRows03Cols123 = { {2, 3, 4} , {5, 6, 7}}; // effective permutations protected double[][] subRows20Cols123 = { {4, 6, 8} , {2, 3, 4}}; protected double[][] subRows31Cols31 = {{7, 5}, {4.5, 2.5}}; // contiguous ranges protected double[][] subRows01Cols23 = {{3,4} , {3.5, 4.5}}; protected double[][] subRows23Cols00 = {{2} , {4}}; protected double[][] subRows00Cols33 = {{4}}; // row matrices protected double[][] subRow0 = {{1,2,3,4}}; protected double[][] subRow3 = {{4,5,6,7}}; // column matrices protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}}; protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}}; // tolerances protected double entryTolerance = 10E-16; protected double normTolerance = 10E-14; /** test dimensions */ @Test public void testDimensions() { BlockRealMatrix m = new BlockRealMatrix(testData); BlockRealMatrix m2 = new BlockRealMatrix(testData2); Assert.assertEquals("testData row dimension",3,m.getRowDimension()); Assert.assertEquals("testData column dimension",3,m.getColumnDimension()); Assert.assertTrue("testData is square",m.isSquare()); Assert.assertEquals("testData2 row dimension",m2.getRowDimension(),2); Assert.assertEquals("testData2 column dimension",m2.getColumnDimension(),3); Assert.assertTrue("testData2 is not square",!m2.isSquare()); } /** test copy functions */ @Test public void testCopyFunctions() { Random r = new Random(66636328996002l); BlockRealMatrix m1 = createRandomMatrix(r, 47, 83); BlockRealMatrix m2 = new BlockRealMatrix(m1.getData()); Assert.assertEquals(m1, m2); BlockRealMatrix m3 = new BlockRealMatrix(testData); BlockRealMatrix m4 = new BlockRealMatrix(m3.getData()); Assert.assertEquals(m3, m4); } /** test add */ @Test public void testAdd() { BlockRealMatrix m = new BlockRealMatrix(testData); BlockRealMatrix mInv = new BlockRealMatrix(testDataInv); RealMatrix mPlusMInv = m.add(mInv); double[][] sumEntries = mPlusMInv.getData(); for (int row = 0; row < m.getRowDimension(); row++) { for (int col = 0; col < m.getColumnDimension(); col++) { Assert.assertEquals("sum entry entry", testDataPlusInv[row][col],sumEntries[row][col], entryTolerance); } } } /** test add failure */ @Test public void testAddFail() { BlockRealMatrix m = new BlockRealMatrix(testData); BlockRealMatrix m2 = new BlockRealMatrix(testData2); try { m.add(m2); Assert.fail("MathIllegalArgumentException expected"); } catch (MathIllegalArgumentException ex) { // ignored } } /** test norm */ @Test public void testNorm() { BlockRealMatrix m = new BlockRealMatrix(testData); BlockRealMatrix m2 = new BlockRealMatrix(testData2); Assert.assertEquals("testData norm",14d,m.getNorm(),entryTolerance); Assert.assertEquals("testData2 norm",7d,m2.getNorm(),entryTolerance); } /** test Frobenius norm */ @Test public void testFrobeniusNorm() { BlockRealMatrix m = new BlockRealMatrix(testData); BlockRealMatrix m2 = new BlockRealMatrix(testData2); Assert.assertEquals("testData Frobenius norm", FastMath.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance); Assert.assertEquals("testData2 Frobenius norm", FastMath.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance); } /** test m-n = m + -n */ @Test public void testPlusMinus() { BlockRealMatrix m = new BlockRealMatrix(testData); BlockRealMatrix m2 = new BlockRealMatrix(testDataInv); assertClose(m.subtract(m2), m2.scalarMultiply(-1d).add(m), entryTolerance); try { m.subtract(new BlockRealMatrix(testData2)); Assert.fail("Expecting illegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } } /** test multiply */ @Test public void testMultiply() { BlockRealMatrix m = new BlockRealMatrix(testData); BlockRealMatrix mInv = new BlockRealMatrix(testDataInv); BlockRealMatrix identity = new BlockRealMatrix(id); BlockRealMatrix m2 = new BlockRealMatrix(testData2); assertClose(m.multiply(mInv), identity, entryTolerance); assertClose(mInv.multiply(m), identity, entryTolerance); assertClose(m.multiply(identity), m, entryTolerance); assertClose(identity.multiply(mInv), mInv, entryTolerance); assertClose(m2.multiply(identity), m2, entryTolerance); try { m.multiply(new BlockRealMatrix(bigSingular)); Assert.fail("Expecting illegalArgumentException"); } catch (MathIllegalArgumentException ex) { // expected } } @Test public void testSeveralBlocks() { RealMatrix m = new BlockRealMatrix(35, 71); for (int i = 0; i < m.getRowDimension(); ++i) { for (int j = 0; j < m.getColumnDimension(); ++j) { m.setEntry(i, j, i + j / 1024.0); } } RealMatrix mT = m.transpose(); Assert.assertEquals(m.getRowDimension(), mT.getColumnDimension()); Assert.assertEquals(m.getColumnDimension(), mT.getRowDimension()); for (int i = 0; i < mT.getRowDimension(); ++i) { for (int j = 0; j < mT.getColumnDimension(); ++j) { Assert.assertEquals(m.getEntry(j, i), mT.getEntry(i, j), 0); } } RealMatrix mPm = m.add(m); for (int i = 0; i < mPm.getRowDimension(); ++i) { for (int j = 0; j < mPm.getColumnDimension(); ++j) { Assert.assertEquals(2 * m.getEntry(i, j), mPm.getEntry(i, j), 0); } } RealMatrix mPmMm = mPm.subtract(m); for (int i = 0; i < mPmMm.getRowDimension(); ++i) { for (int j = 0; j < mPmMm.getColumnDimension(); ++j) { Assert.assertEquals(m.getEntry(i, j), mPmMm.getEntry(i, j), 0); } } RealMatrix mTm = mT.multiply(m); for (int i = 0; i < mTm.getRowDimension(); ++i) { for (int j = 0; j < mTm.getColumnDimension(); ++j) { double sum = 0; for (int k = 0; k < mT.getColumnDimension(); ++k) { sum += (k + i / 1024.0) * (k + j / 1024.0); } Assert.assertEquals(sum, mTm.getEntry(i, j), 0); } } RealMatrix mmT = m.multiply(mT); for (int i = 0; i < mmT.getRowDimension(); ++i) { for (int j = 0; j < mmT.getColumnDimension(); ++j) { double sum = 0; for (int k = 0; k < m.getColumnDimension(); ++k) { sum += (i + k / 1024.0) * (j + k / 1024.0); } Assert.assertEquals(sum, mmT.getEntry(i, j), 0); } } RealMatrix sub1 = m.getSubMatrix(2, 9, 5, 20); for (int i = 0; i < sub1.getRowDimension(); ++i) { for (int j = 0; j < sub1.getColumnDimension(); ++j) { Assert.assertEquals((i + 2) + (j + 5) / 1024.0, sub1.getEntry(i, j), 0); } } RealMatrix sub2 = m.getSubMatrix(10, 12, 3, 70); for (int i = 0; i < sub2.getRowDimension(); ++i) { for (int j = 0; j < sub2.getColumnDimension(); ++j) { Assert.assertEquals((i + 10) + (j + 3) / 1024.0, sub2.getEntry(i, j), 0); } } RealMatrix sub3 = m.getSubMatrix(30, 34, 0, 5); for (int i = 0; i < sub3.getRowDimension(); ++i) { for (int j = 0; j < sub3.getColumnDimension(); ++j) { Assert.assertEquals((i + 30) + (j + 0) / 1024.0, sub3.getEntry(i, j), 0); } } RealMatrix sub4 = m.getSubMatrix(30, 32, 62, 65); for (int i = 0; i < sub4.getRowDimension(); ++i) { for (int j = 0; j < sub4.getColumnDimension(); ++j) { Assert.assertEquals((i + 30) + (j + 62) / 1024.0, sub4.getEntry(i, j), 0); } } } //Additional Test for BlockRealMatrixTest.testMultiply private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}}; private double[][] d4 = new double[][] {{1},{2},{3},{4}}; private double[][] d5 = new double[][] {{30},{70}}; @Test public void testMultiply2() { RealMatrix m3 = new BlockRealMatrix(d3); RealMatrix m4 = new BlockRealMatrix(d4); RealMatrix m5 = new BlockRealMatrix(d5); assertClose(m3.multiply(m4), m5, entryTolerance); } /** test trace */ @Test public void testTrace() { RealMatrix m = new BlockRealMatrix(id); Assert.assertEquals("identity trace",3d,m.getTrace(),entryTolerance); m = new BlockRealMatrix(testData2); try { m.getTrace(); Assert.fail("Expecting NonSquareMatrixException"); } catch (NonSquareMatrixException ex) { // ignored } } /** test scalarAdd */ @Test public void testScalarAdd() { RealMatrix m = new BlockRealMatrix(testData); assertClose(new BlockRealMatrix(testDataPlus2), m.scalarAdd(2d), entryTolerance); } /** test operate */ @Test public void testOperate() { RealMatrix m = new BlockRealMatrix(id); assertClose(testVector, m.operate(testVector), entryTolerance); assertClose(testVector, m.operate(new ArrayRealVector(testVector)).toArray(), entryTolerance); m = new BlockRealMatrix(bigSingular); try { m.operate(testVector); Assert.fail("Expecting illegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } } @Test public void testOperateLarge() { int p = (7 * BlockRealMatrix.BLOCK_SIZE) / 2; int q = (5 * BlockRealMatrix.BLOCK_SIZE) / 2; int r = 3 * BlockRealMatrix.BLOCK_SIZE; Random random = new Random(111007463902334l); RealMatrix m1 = createRandomMatrix(random, p, q); RealMatrix m2 = createRandomMatrix(random, q, r); RealMatrix m1m2 = m1.multiply(m2); for (int i = 0; i < r; ++i) { checkArrays(m1m2.getColumn(i), m1.operate(m2.getColumn(i))); } } @Test public void testOperatePremultiplyLarge() { int p = (7 * BlockRealMatrix.BLOCK_SIZE) / 2; int q = (5 * BlockRealMatrix.BLOCK_SIZE) / 2; int r = 3 * BlockRealMatrix.BLOCK_SIZE; Random random = new Random(111007463902334l); RealMatrix m1 = createRandomMatrix(random, p, q); RealMatrix m2 = createRandomMatrix(random, q, r); RealMatrix m1m2 = m1.multiply(m2); for (int i = 0; i < p; ++i) { checkArrays(m1m2.getRow(i), m2.preMultiply(m1.getRow(i))); } } /** test issue MATH-209 */ @Test public void testMath209() { RealMatrix a = new BlockRealMatrix(new double[][] { { 1, 2 }, { 3, 4 }, { 5, 6 } }); double[] b = a.operate(new double[] { 1, 1 }); Assert.assertEquals(a.getRowDimension(), b.length); Assert.assertEquals( 3.0, b[0], 1.0e-12); Assert.assertEquals( 7.0, b[1], 1.0e-12); Assert.assertEquals(11.0, b[2], 1.0e-12); } /** test transpose */ @Test public void testTranspose() { RealMatrix m = new BlockRealMatrix(testData); RealMatrix mIT = new LUDecomposition(m).getSolver().getInverse().transpose(); RealMatrix mTI = new LUDecomposition(m.transpose()).getSolver().getInverse(); assertClose(mIT, mTI, normTolerance); m = new BlockRealMatrix(testData2); RealMatrix mt = new BlockRealMatrix(testData2T); assertClose(mt, m.transpose(), normTolerance); } /** test preMultiply by vector */ @Test public void testPremultiplyVector() { RealMatrix m = new BlockRealMatrix(testData); assertClose(m.preMultiply(testVector), preMultTest, normTolerance); assertClose(m.preMultiply(new ArrayRealVector(testVector).toArray()), preMultTest, normTolerance); m = new BlockRealMatrix(bigSingular); try { m.preMultiply(testVector); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } } @Test public void testPremultiply() { RealMatrix m3 = new BlockRealMatrix(d3); RealMatrix m4 = new BlockRealMatrix(d4); RealMatrix m5 = new BlockRealMatrix(d5); assertClose(m4.preMultiply(m3), m5, entryTolerance); BlockRealMatrix m = new BlockRealMatrix(testData); BlockRealMatrix mInv = new BlockRealMatrix(testDataInv); BlockRealMatrix identity = new BlockRealMatrix(id); assertClose(m.preMultiply(mInv), identity, entryTolerance); assertClose(mInv.preMultiply(m), identity, entryTolerance); assertClose(m.preMultiply(identity), m, entryTolerance); assertClose(identity.preMultiply(mInv), mInv, entryTolerance); try { m.preMultiply(new BlockRealMatrix(bigSingular)); Assert.fail("Expecting illegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } } @Test public void testGetVectors() { RealMatrix m = new BlockRealMatrix(testData); assertClose(m.getRow(0), testDataRow1, entryTolerance); assertClose(m.getColumn(2), testDataCol3, entryTolerance); try { m.getRow(10); Assert.fail("expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // ignored } try { m.getColumn(-1); Assert.fail("expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // ignored } } @Test public void testGetEntry() { RealMatrix m = new BlockRealMatrix(testData); Assert.assertEquals("get entry",m.getEntry(0,1),2d,entryTolerance); try { m.getEntry(10, 4); Assert.fail ("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } /** test examples in user guide */ @Test public void testExamples() { // Create a real matrix with two rows and three columns double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}}; RealMatrix m = new BlockRealMatrix(matrixData); // One more with three rows, two columns double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}}; RealMatrix n = new BlockRealMatrix(matrixData2); // Now multiply m by n RealMatrix p = m.multiply(n); Assert.assertEquals(2, p.getRowDimension()); Assert.assertEquals(2, p.getColumnDimension()); // Invert p RealMatrix pInverse = new LUDecomposition(p).getSolver().getInverse(); Assert.assertEquals(2, pInverse.getRowDimension()); Assert.assertEquals(2, pInverse.getColumnDimension()); // Solve example double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}}; RealMatrix coefficients = new BlockRealMatrix(coefficientsData); RealVector constants = new ArrayRealVector(new double[]{1, -2, 1}, false); RealVector solution = new LUDecomposition(coefficients).getSolver().solve(constants); final double cst0 = constants.getEntry(0); final double cst1 = constants.getEntry(1); final double cst2 = constants.getEntry(2); final double sol0 = solution.getEntry(0); final double sol1 = solution.getEntry(1); final double sol2 = solution.getEntry(2); Assert.assertEquals(2 * sol0 + 3 * sol1 -2 * sol2, cst0, 1E-12); Assert.assertEquals(-1 * sol0 + 7 * sol1 + 6 * sol2, cst1, 1E-12); Assert.assertEquals(4 * sol0 - 3 * sol1 -5 * sol2, cst2, 1E-12); } // test submatrix accessors @Test public void testGetSubMatrix() { RealMatrix m = new BlockRealMatrix(subTestData); checkGetSubMatrix(m, subRows23Cols00, 2 , 3 , 0, 0); checkGetSubMatrix(m, subRows00Cols33, 0 , 0 , 3, 3); checkGetSubMatrix(m, subRows01Cols23, 0 , 1 , 2, 3); checkGetSubMatrix(m, subRows02Cols13, new int[] { 0, 2 }, new int[] { 1, 3 }); checkGetSubMatrix(m, subRows03Cols12, new int[] { 0, 3 }, new int[] { 1, 2 }); checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }); checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }); checkGetSubMatrix(m, subRows31Cols31, new int[] { 3, 1 }, new int[] { 3, 1 }); checkGetSubMatrix(m, subRows31Cols31, new int[] { 3, 1 }, new int[] { 3, 1 }); checkGetSubMatrix(m, null, 1, 0, 2, 4); checkGetSubMatrix(m, null, -1, 1, 2, 2); checkGetSubMatrix(m, null, 1, 0, 2, 2); checkGetSubMatrix(m, null, 1, 0, 2, 4); checkGetSubMatrix(m, null, new int[] {}, new int[] { 0 }); checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 }); } private void checkGetSubMatrix(RealMatrix m, double[][] reference, int startRow, int endRow, int startColumn, int endColumn) { try { RealMatrix sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn); if (reference != null) { Assert.assertEquals(new BlockRealMatrix(reference), sub); } else { Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException"); } } catch (OutOfRangeException e) { if (reference != null) { throw e; } } catch (NumberIsTooSmallException e) { if (reference != null) { throw e; } } catch (NoDataException e) { if (reference != null) { throw e; } } } private void checkGetSubMatrix(RealMatrix m, double[][] reference, int[] selectedRows, int[] selectedColumns) { try { RealMatrix sub = m.getSubMatrix(selectedRows, selectedColumns); if (reference != null) { Assert.assertEquals(new BlockRealMatrix(reference), sub); } else { Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallExceptiono r NoDataException"); } } catch (OutOfRangeException e) { if (reference != null) { throw e; } } catch (NumberIsTooSmallException e) { if (reference != null) { throw e; } } catch (NoDataException e) { if (reference != null) { throw e; } } } @Test public void testGetSetMatrixLarge() { int n = 3 * BlockRealMatrix.BLOCK_SIZE; RealMatrix m = new BlockRealMatrix(n, n); RealMatrix sub = new BlockRealMatrix(n - 4, n - 4).scalarAdd(1); m.setSubMatrix(sub.getData(), 2, 2); for (int i = 0; i < n; ++i) { for (int j = 0; j < n; ++j) { if ((i < 2) || (i > n - 3) || (j < 2) || (j > n - 3)) { Assert.assertEquals(0.0, m.getEntry(i, j), 0.0); } else { Assert.assertEquals(1.0, m.getEntry(i, j), 0.0); } } } Assert.assertEquals(sub, m.getSubMatrix(2, n - 3, 2, n - 3)); } @Test public void testCopySubMatrix() { RealMatrix m = new BlockRealMatrix(subTestData); checkCopy(m, subRows23Cols00, 2 , 3 , 0, 0); checkCopy(m, subRows00Cols33, 0 , 0 , 3, 3); checkCopy(m, subRows01Cols23, 0 , 1 , 2, 3); checkCopy(m, subRows02Cols13, new int[] { 0, 2 }, new int[] { 1, 3 }); checkCopy(m, subRows03Cols12, new int[] { 0, 3 }, new int[] { 1, 2 }); checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }); checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }); checkCopy(m, subRows31Cols31, new int[] { 3, 1 }, new int[] { 3, 1 }); checkCopy(m, subRows31Cols31, new int[] { 3, 1 }, new int[] { 3, 1 }); checkCopy(m, null, 1, 0, 2, 4); checkCopy(m, null, -1, 1, 2, 2); checkCopy(m, null, 1, 0, 2, 2); checkCopy(m, null, 1, 0, 2, 4); checkCopy(m, null, new int[] {}, new int[] { 0 }); checkCopy(m, null, new int[] { 0 }, new int[] { 4 }); } private void checkCopy(RealMatrix m, double[][] reference, int startRow, int endRow, int startColumn, int endColumn) { try { double[][] sub = (reference == null) ? new double[1][1] : new double[reference.length][reference[0].length]; m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub); if (reference != null) { Assert.assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub)); } else { Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException"); } } catch (OutOfRangeException e) { if (reference != null) { throw e; } } catch (NumberIsTooSmallException e) { if (reference != null) { throw e; } } catch (NoDataException e) { if (reference != null) { throw e; } } } private void checkCopy(RealMatrix m, double[][] reference, int[] selectedRows, int[] selectedColumns) { try { double[][] sub = (reference == null) ? new double[1][1] : new double[reference.length][reference[0].length]; m.copySubMatrix(selectedRows, selectedColumns, sub); if (reference != null) { Assert.assertEquals(new BlockRealMatrix(reference), new BlockRealMatrix(sub)); } else { Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException"); } } catch (OutOfRangeException e) { if (reference != null) { throw e; } } catch (NumberIsTooSmallException e) { if (reference != null) { throw e; } } catch (NoDataException e) { if (reference != null) { throw e; } } } @Test public void testGetRowMatrix() { RealMatrix m = new BlockRealMatrix(subTestData); RealMatrix mRow0 = new BlockRealMatrix(subRow0); RealMatrix mRow3 = new BlockRealMatrix(subRow3); Assert.assertEquals("Row0", mRow0, m.getRowMatrix(0)); Assert.assertEquals("Row3", mRow3, m.getRowMatrix(3)); try { m.getRowMatrix(-1); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getRowMatrix(4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testSetRowMatrix() { RealMatrix m = new BlockRealMatrix(subTestData); RealMatrix mRow3 = new BlockRealMatrix(subRow3); Assert.assertNotSame(mRow3, m.getRowMatrix(0)); m.setRowMatrix(0, mRow3); Assert.assertEquals(mRow3, m.getRowMatrix(0)); try { m.setRowMatrix(-1, mRow3); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.setRowMatrix(0, m); Assert.fail("Expecting MatrixDimensionMismatchException"); } catch (MatrixDimensionMismatchException ex) { // expected } } @Test public void testGetSetRowMatrixLarge() { int n = 3 * BlockRealMatrix.BLOCK_SIZE; RealMatrix m = new BlockRealMatrix(n, n); RealMatrix sub = new BlockRealMatrix(1, n).scalarAdd(1); m.setRowMatrix(2, sub); for (int i = 0; i < n; ++i) { for (int j = 0; j < n; ++j) { if (i != 2) { Assert.assertEquals(0.0, m.getEntry(i, j), 0.0); } else { Assert.assertEquals(1.0, m.getEntry(i, j), 0.0); } } } Assert.assertEquals(sub, m.getRowMatrix(2)); } @Test public void testGetColumnMatrix() { RealMatrix m = new BlockRealMatrix(subTestData); RealMatrix mColumn1 = new BlockRealMatrix(subColumn1); RealMatrix mColumn3 = new BlockRealMatrix(subColumn3); Assert.assertEquals(mColumn1, m.getColumnMatrix(1)); Assert.assertEquals(mColumn3, m.getColumnMatrix(3)); try { m.getColumnMatrix(-1); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getColumnMatrix(4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testSetColumnMatrix() { RealMatrix m = new BlockRealMatrix(subTestData); RealMatrix mColumn3 = new BlockRealMatrix(subColumn3); Assert.assertNotSame(mColumn3, m.getColumnMatrix(1)); m.setColumnMatrix(1, mColumn3); Assert.assertEquals(mColumn3, m.getColumnMatrix(1)); try { m.setColumnMatrix(-1, mColumn3); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.setColumnMatrix(0, m); Assert.fail("Expecting MatrixDimensionMismatchException"); } catch (MatrixDimensionMismatchException ex) { // expected } } @Test public void testGetSetColumnMatrixLarge() { int n = 3 * BlockRealMatrix.BLOCK_SIZE; RealMatrix m = new BlockRealMatrix(n, n); RealMatrix sub = new BlockRealMatrix(n, 1).scalarAdd(1); m.setColumnMatrix(2, sub); for (int i = 0; i < n; ++i) { for (int j = 0; j < n; ++j) { if (j != 2) { Assert.assertEquals(0.0, m.getEntry(i, j), 0.0); } else { Assert.assertEquals(1.0, m.getEntry(i, j), 0.0); } } } Assert.assertEquals(sub, m.getColumnMatrix(2)); } @Test public void testGetRowVector() { RealMatrix m = new BlockRealMatrix(subTestData); RealVector mRow0 = new ArrayRealVector(subRow0[0]); RealVector mRow3 = new ArrayRealVector(subRow3[0]); Assert.assertEquals(mRow0, m.getRowVector(0)); Assert.assertEquals(mRow3, m.getRowVector(3)); try { m.getRowVector(-1); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getRowVector(4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testSetRowVector() { RealMatrix m = new BlockRealMatrix(subTestData); RealVector mRow3 = new ArrayRealVector(subRow3[0]); Assert.assertNotSame(mRow3, m.getRowMatrix(0)); m.setRowVector(0, mRow3); Assert.assertEquals(mRow3, m.getRowVector(0)); try { m.setRowVector(-1, mRow3); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.setRowVector(0, new ArrayRealVector(5)); Assert.fail("Expecting MatrixDimensionMismatchException"); } catch (MatrixDimensionMismatchException ex) { // expected } } @Test public void testGetSetRowVectorLarge() { int n = 3 * BlockRealMatrix.BLOCK_SIZE; RealMatrix m = new BlockRealMatrix(n, n); RealVector sub = new ArrayRealVector(n, 1.0); m.setRowVector(2, sub); for (int i = 0; i < n; ++i) { for (int j = 0; j < n; ++j) { if (i != 2) { Assert.assertEquals(0.0, m.getEntry(i, j), 0.0); } else { Assert.assertEquals(1.0, m.getEntry(i, j), 0.0); } } } Assert.assertEquals(sub, m.getRowVector(2)); } @Test public void testGetColumnVector() { RealMatrix m = new BlockRealMatrix(subTestData); RealVector mColumn1 = columnToVector(subColumn1); RealVector mColumn3 = columnToVector(subColumn3); Assert.assertEquals(mColumn1, m.getColumnVector(1)); Assert.assertEquals(mColumn3, m.getColumnVector(3)); try { m.getColumnVector(-1); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getColumnVector(4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testSetColumnVector() { RealMatrix m = new BlockRealMatrix(subTestData); RealVector mColumn3 = columnToVector(subColumn3); Assert.assertNotSame(mColumn3, m.getColumnVector(1)); m.setColumnVector(1, mColumn3); Assert.assertEquals(mColumn3, m.getColumnVector(1)); try { m.setColumnVector(-1, mColumn3); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.setColumnVector(0, new ArrayRealVector(5)); Assert.fail("Expecting MatrixDimensionMismatchException"); } catch (MatrixDimensionMismatchException ex) { // expected } } @Test public void testGetSetColumnVectorLarge() { int n = 3 * BlockRealMatrix.BLOCK_SIZE; RealMatrix m = new BlockRealMatrix(n, n); RealVector sub = new ArrayRealVector(n, 1.0); m.setColumnVector(2, sub); for (int i = 0; i < n; ++i) { for (int j = 0; j < n; ++j) { if (j != 2) { Assert.assertEquals(0.0, m.getEntry(i, j), 0.0); } else { Assert.assertEquals(1.0, m.getEntry(i, j), 0.0); } } } Assert.assertEquals(sub, m.getColumnVector(2)); } private RealVector columnToVector(double[][] column) { double[] data = new double[column.length]; for (int i = 0; i < data.length; ++i) { data[i] = column[i][0]; } return new ArrayRealVector(data, false); } @Test public void testGetRow() { RealMatrix m = new BlockRealMatrix(subTestData); checkArrays(subRow0[0], m.getRow(0)); checkArrays(subRow3[0], m.getRow(3)); try { m.getRow(-1); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getRow(4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testSetRow() { RealMatrix m = new BlockRealMatrix(subTestData); Assert.assertTrue(subRow3[0][0] != m.getRow(0)[0]); m.setRow(0, subRow3[0]); checkArrays(subRow3[0], m.getRow(0)); try { m.setRow(-1, subRow3[0]); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.setRow(0, new double[5]); Assert.fail("Expecting MatrixDimensionMismatchException"); } catch (MatrixDimensionMismatchException ex) { // expected } } @Test public void testGetSetRowLarge() { int n = 3 * BlockRealMatrix.BLOCK_SIZE; RealMatrix m = new BlockRealMatrix(n, n); double[] sub = new double[n]; Arrays.fill(sub, 1.0); m.setRow(2, sub); for (int i = 0; i < n; ++i) { for (int j = 0; j < n; ++j) { if (i != 2) { Assert.assertEquals(0.0, m.getEntry(i, j), 0.0); } else { Assert.assertEquals(1.0, m.getEntry(i, j), 0.0); } } } checkArrays(sub, m.getRow(2)); } @Test public void testGetColumn() { RealMatrix m = new BlockRealMatrix(subTestData); double[] mColumn1 = columnToArray(subColumn1); double[] mColumn3 = columnToArray(subColumn3); checkArrays(mColumn1, m.getColumn(1)); checkArrays(mColumn3, m.getColumn(3)); try { m.getColumn(-1); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getColumn(4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testSetColumn() { RealMatrix m = new BlockRealMatrix(subTestData); double[] mColumn3 = columnToArray(subColumn3); Assert.assertTrue(mColumn3[0] != m.getColumn(1)[0]); m.setColumn(1, mColumn3); checkArrays(mColumn3, m.getColumn(1)); try { m.setColumn(-1, mColumn3); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.setColumn(0, new double[5]); Assert.fail("Expecting MatrixDimensionMismatchException"); } catch (MatrixDimensionMismatchException ex) { // expected } } @Test public void testGetSetColumnLarge() { int n = 3 * BlockRealMatrix.BLOCK_SIZE; RealMatrix m = new BlockRealMatrix(n, n); double[] sub = new double[n]; Arrays.fill(sub, 1.0); m.setColumn(2, sub); for (int i = 0; i < n; ++i) { for (int j = 0; j < n; ++j) { if (j != 2) { Assert.assertEquals(0.0, m.getEntry(i, j), 0.0); } else { Assert.assertEquals(1.0, m.getEntry(i, j), 0.0); } } } checkArrays(sub, m.getColumn(2)); } private double[] columnToArray(double[][] column) { double[] data = new double[column.length]; for (int i = 0; i < data.length; ++i) { data[i] = column[i][0]; } return data; } private void checkArrays(double[] expected, double[] actual) { Assert.assertEquals(expected.length, actual.length); for (int i = 0; i < expected.length; ++i) { Assert.assertEquals(expected[i], actual[i], 0); } } @Test public void testEqualsAndHashCode() { BlockRealMatrix m = new BlockRealMatrix(testData); BlockRealMatrix m1 = m.copy(); BlockRealMatrix mt = m.transpose(); Assert.assertTrue(m.hashCode() != mt.hashCode()); Assert.assertEquals(m.hashCode(), m1.hashCode()); Assert.assertEquals(m, m); Assert.assertEquals(m, m1); Assert.assertFalse(m.equals(null)); Assert.assertFalse(m.equals(mt)); Assert.assertFalse(m.equals(new BlockRealMatrix(bigSingular))); } @Test public void testToString() { BlockRealMatrix m = new BlockRealMatrix(testData); Assert.assertEquals("BlockRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}", m.toString()); } @Test public void testSetSubMatrix() { BlockRealMatrix m = new BlockRealMatrix(testData); m.setSubMatrix(detData2,1,1); RealMatrix expected = new BlockRealMatrix (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}}); Assert.assertEquals(expected, m); m.setSubMatrix(detData2,0,0); expected = new BlockRealMatrix (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}}); Assert.assertEquals(expected, m); m.setSubMatrix(testDataPlus2,0,0); expected = new BlockRealMatrix (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}}); Assert.assertEquals(expected, m); // javadoc example BlockRealMatrix matrix = new BlockRealMatrix (new double[][] {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 0, 1 , 2}}); matrix.setSubMatrix(new double[][] {{3, 4}, {5, 6}}, 1, 1); expected = new BlockRealMatrix (new double[][] {{1, 2, 3, 4}, {5, 3, 4, 8}, {9, 5 ,6, 2}}); Assert.assertEquals(expected, matrix); // dimension overflow try { m.setSubMatrix(testData,1,1); Assert.fail("expecting OutOfRangeException"); } catch (OutOfRangeException e) { // expected } // dimension underflow try { m.setSubMatrix(testData,-1,1); Assert.fail("expecting OutOfRangeException"); } catch (OutOfRangeException e) { // expected } try { m.setSubMatrix(testData,1,-1); Assert.fail("expecting OutOfRangeException"); } catch (OutOfRangeException e) { // expected } // null try { m.setSubMatrix(null,1,1); Assert.fail("expecting NullArgumentException"); } catch (NullArgumentException e) { // expected } // ragged try { m.setSubMatrix(new double[][] {{1}, {2, 3}}, 0, 0); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException e) { // expected } // empty try { m.setSubMatrix(new double[][] {{}}, 0, 0); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException e) { // expected } } @Test public void testWalk() { int rows = 150; int columns = 75; RealMatrix m = new BlockRealMatrix(rows, columns); m.walkInRowOrder(new SetVisitor()); GetVisitor getVisitor = new GetVisitor(); m.walkInOptimizedOrder(getVisitor); Assert.assertEquals(rows * columns, getVisitor.getCount()); m = new BlockRealMatrix(rows, columns); m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2); getVisitor = new GetVisitor(); m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2); Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount()); for (int i = 0; i < rows; ++i) { Assert.assertEquals(0.0, m.getEntry(i, 0), 0); Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0); } for (int j = 0; j < columns; ++j) { Assert.assertEquals(0.0, m.getEntry(0, j), 0); Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0); } m = new BlockRealMatrix(rows, columns); m.walkInColumnOrder(new SetVisitor()); getVisitor = new GetVisitor(); m.walkInOptimizedOrder(getVisitor); Assert.assertEquals(rows * columns, getVisitor.getCount()); m = new BlockRealMatrix(rows, columns); m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2); getVisitor = new GetVisitor(); m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2); Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount()); for (int i = 0; i < rows; ++i) { Assert.assertEquals(0.0, m.getEntry(i, 0), 0); Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0); } for (int j = 0; j < columns; ++j) { Assert.assertEquals(0.0, m.getEntry(0, j), 0); Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0); } m = new BlockRealMatrix(rows, columns); m.walkInOptimizedOrder(new SetVisitor()); getVisitor = new GetVisitor(); m.walkInRowOrder(getVisitor); Assert.assertEquals(rows * columns, getVisitor.getCount()); m = new BlockRealMatrix(rows, columns); m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2); getVisitor = new GetVisitor(); m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2); Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount()); for (int i = 0; i < rows; ++i) { Assert.assertEquals(0.0, m.getEntry(i, 0), 0); Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0); } for (int j = 0; j < columns; ++j) { Assert.assertEquals(0.0, m.getEntry(0, j), 0); Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0); } m = new BlockRealMatrix(rows, columns); m.walkInOptimizedOrder(new SetVisitor()); getVisitor = new GetVisitor(); m.walkInColumnOrder(getVisitor); Assert.assertEquals(rows * columns, getVisitor.getCount()); m = new BlockRealMatrix(rows, columns); m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2); getVisitor = new GetVisitor(); m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2); Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount()); for (int i = 0; i < rows; ++i) { Assert.assertEquals(0.0, m.getEntry(i, 0), 0); Assert.assertEquals(0.0, m.getEntry(i, columns - 1), 0); } for (int j = 0; j < columns; ++j) { Assert.assertEquals(0.0, m.getEntry(0, j), 0); Assert.assertEquals(0.0, m.getEntry(rows - 1, j), 0); } } @Test public void testSerial() { BlockRealMatrix m = new BlockRealMatrix(testData); Assert.assertEquals(m,TestUtils.serializeAndRecover(m)); } private static class SetVisitor extends DefaultRealMatrixChangingVisitor { @Override public double visit(int i, int j, double value) { return i + j / 1024.0; } } private static class GetVisitor extends DefaultRealMatrixPreservingVisitor { private int count = 0; @Override public void visit(int i, int j, double value) { ++count; Assert.assertEquals(i + j / 1024.0, value, 0.0); } public int getCount() { return count; } } //--------------- -----------------Protected methods /** verifies that two matrices are close (1-norm) */ protected void assertClose(RealMatrix m, RealMatrix n, double tolerance) { Assert.assertTrue(m.subtract(n).getNorm() < tolerance); } /** verifies that two vectors are close (sup norm) */ protected void assertClose(double[] m, double[] n, double tolerance) { if (m.length != n.length) { Assert.fail("vectors not same length"); } for (int i = 0; i < m.length; i++) { Assert.assertEquals(m[i], n[i], tolerance); } } private BlockRealMatrix createRandomMatrix(Random r, int rows, int columns) { BlockRealMatrix m = new BlockRealMatrix(rows, columns); for (int i = 0; i < rows; ++i) { for (int j = 0; j < columns; ++j) { m.setEntry(i, j, 200 * r.nextDouble() - 100); } } return m; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import org.junit.Test; import org.junit.Assert; public class CholeskyDecompositionTest { private double[][] testData = new double[][] { { 1, 2, 4, 7, 11 }, { 2, 13, 23, 38, 58 }, { 4, 23, 77, 122, 182 }, { 7, 38, 122, 294, 430 }, { 11, 58, 182, 430, 855 } }; /** test dimensions */ @Test public void testDimensions() { CholeskyDecomposition llt = new CholeskyDecomposition(MatrixUtils.createRealMatrix(testData)); Assert.assertEquals(testData.length, llt.getL().getRowDimension()); Assert.assertEquals(testData.length, llt.getL().getColumnDimension()); Assert.assertEquals(testData.length, llt.getLT().getRowDimension()); Assert.assertEquals(testData.length, llt.getLT().getColumnDimension()); } /** test non-square matrix */ @Test(expected = NonSquareMatrixException.class) public void testNonSquare() { new CholeskyDecomposition(MatrixUtils.createRealMatrix(new double[3][2])); } /** test non-symmetric matrix */ @Test(expected = NonSymmetricMatrixException.class) public void testNotSymmetricMatrixException() { double[][] changed = testData.clone(); changed[0][changed[0].length - 1] += 1.0e-5; new CholeskyDecomposition(MatrixUtils.createRealMatrix(changed)); } /** test non positive definite matrix */ @Test(expected = NonPositiveDefiniteMatrixException.class) public void testNotPositiveDefinite() { new CholeskyDecomposition(MatrixUtils.createRealMatrix(new double[][] { { 14, 11, 13, 15, 24 }, { 11, 34, 13, 8, 25 }, { 13, 13, 14, 15, 21 }, { 15, 8, 15, 18, 23 }, { 24, 25, 21, 23, 45 } })); } @Test(expected = NonPositiveDefiniteMatrixException.class) public void testMath274() { new CholeskyDecomposition(MatrixUtils.createRealMatrix(new double[][] { { 0.40434286, -0.09376327, 0.30328980, 0.04909388 }, {-0.09376327, 0.10400408, 0.07137959, 0.04762857 }, { 0.30328980, 0.07137959, 0.30458776, 0.04882449 }, { 0.04909388, 0.04762857, 0.04882449, 0.07543265 } })); } /** test A = LLT */ @Test public void testAEqualLLT() { RealMatrix matrix = MatrixUtils.createRealMatrix(testData); CholeskyDecomposition llt = new CholeskyDecomposition(matrix); RealMatrix l = llt.getL(); RealMatrix lt = llt.getLT(); double norm = l.multiply(lt).subtract(matrix).getNorm(); Assert.assertEquals(0, norm, 1.0e-15); } /** test that L is lower triangular */ @Test public void testLLowerTriangular() { RealMatrix matrix = MatrixUtils.createRealMatrix(testData); RealMatrix l = new CholeskyDecomposition(matrix).getL(); for (int i = 0; i < l.getRowDimension(); i++) { for (int j = i + 1; j < l.getColumnDimension(); j++) { Assert.assertEquals(0.0, l.getEntry(i, j), 0.0); } } } /** test that LT is transpose of L */ @Test public void testLTTransposed() { RealMatrix matrix = MatrixUtils.createRealMatrix(testData); CholeskyDecomposition llt = new CholeskyDecomposition(matrix); RealMatrix l = llt.getL(); RealMatrix lt = llt.getLT(); double norm = l.subtract(lt.transpose()).getNorm(); Assert.assertEquals(0, norm, 1.0e-15); } /** test matrices values */ @Test public void testMatricesValues() { RealMatrix lRef = MatrixUtils.createRealMatrix(new double[][] { { 1, 0, 0, 0, 0 }, { 2, 3, 0, 0, 0 }, { 4, 5, 6, 0, 0 }, { 7, 8, 9, 10, 0 }, { 11, 12, 13, 14, 15 } }); CholeskyDecomposition llt = new CholeskyDecomposition(MatrixUtils.createRealMatrix(testData)); // check values against known references RealMatrix l = llt.getL(); Assert.assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13); RealMatrix lt = llt.getLT(); Assert.assertEquals(0, lt.subtract(lRef.transpose()).getNorm(), 1.0e-13); // check the same cached instance is returned the second time Assert.assertTrue(l == llt.getL()); Assert.assertTrue(lt == llt.getLT()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.junit.Assert; import org.junit.Test; public class CholeskySolverTest { private double[][] testData = new double[][] { { 1, 2, 4, 7, 11 }, { 2, 13, 23, 38, 58 }, { 4, 23, 77, 122, 182 }, { 7, 38, 122, 294, 430 }, { 11, 58, 182, 430, 855 } }; /** test solve dimension errors */ @Test public void testSolveDimensionErrors() { DecompositionSolver solver = new CholeskyDecomposition(MatrixUtils.createRealMatrix(testData)).getSolver(); RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]); try { solver.solve(b); Assert.fail("an exception should have been thrown"); } catch (MathIllegalArgumentException iae) { // expected behavior } try { solver.solve(b.getColumnVector(0)); Assert.fail("an exception should have been thrown"); } catch (MathIllegalArgumentException iae) { // expected behavior } try { solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0))); Assert.fail("an exception should have been thrown"); } catch (MathIllegalArgumentException iae) { // expected behavior } } /** test solve */ @Test public void testSolve() { DecompositionSolver solver = new CholeskyDecomposition(MatrixUtils.createRealMatrix(testData)).getSolver(); RealMatrix b = MatrixUtils.createRealMatrix(new double[][] { { 78, -13, 1 }, { 414, -62, -1 }, { 1312, -202, -37 }, { 2989, -542, 145 }, { 5510, -1465, 201 } }); RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] { { 1, 0, 1 }, { 0, 1, 1 }, { 2, 1, -4 }, { 2, 2, 2 }, { 5, -3, 0 } }); // using RealMatrix Assert.assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 1.0e-13); // using ArrayRealVector for (int i = 0; i < b.getColumnDimension(); ++i) { Assert.assertEquals(0, solver.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(), 1.0e-13); } // using RealVector with an alternate implementation for (int i = 0; i < b.getColumnDimension(); ++i) { ArrayRealVectorTest.RealVectorTestImpl v = new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i)); Assert.assertEquals(0, solver.solve(v).subtract(xRef.getColumnVector(i)).getNorm(), 1.0e-13); } } /** test determinant */ @Test public void testDeterminant() { Assert.assertEquals(7290000.0, getDeterminant(MatrixUtils.createRealMatrix(testData)), 1.0e-15); } private double getDeterminant(RealMatrix m) { return new CholeskyDecomposition(m).getDeterminant(); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import java.util.Arrays; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MathUnsupportedOperationException; import org.apache.commons.math3.exception.MaxCountExceededException; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.util.IterationEvent; import org.apache.commons.math3.util.IterationListener; import org.junit.Assert; import org.junit.Test; public class ConjugateGradientTest { @Test(expected = NonSquareOperatorException.class) public void testNonSquareOperator() { final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 3); final IterativeLinearSolver solver; solver = new ConjugateGradient(10, 0., false); final ArrayRealVector b = new ArrayRealVector(a.getRowDimension()); final ArrayRealVector x = new ArrayRealVector(a.getColumnDimension()); solver.solve(a, b, x); } @Test(expected = DimensionMismatchException.class) public void testDimensionMismatchRightHandSide() { final Array2DRowRealMatrix a = new Array2DRowRealMatrix(3, 3); final IterativeLinearSolver solver; solver = new ConjugateGradient(10, 0., false); final ArrayRealVector b = new ArrayRealVector(2); final ArrayRealVector x = new ArrayRealVector(3); solver.solve(a, b, x); } @Test(expected = DimensionMismatchException.class) public void testDimensionMismatchSolution() { final Array2DRowRealMatrix a = new Array2DRowRealMatrix(3, 3); final IterativeLinearSolver solver; solver = new ConjugateGradient(10, 0., false); final ArrayRealVector b = new ArrayRealVector(3); final ArrayRealVector x = new ArrayRealVector(2); solver.solve(a, b, x); } @Test(expected = NonPositiveDefiniteOperatorException.class) public void testNonPositiveDefiniteLinearOperator() { final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 2); a.setEntry(0, 0, -1.); a.setEntry(0, 1, 2.); a.setEntry(1, 0, 3.); a.setEntry(1, 1, 4.); final IterativeLinearSolver solver; solver = new ConjugateGradient(10, 0., true); final ArrayRealVector b = new ArrayRealVector(2); b.setEntry(0, -1.); b.setEntry(1, -1.); final ArrayRealVector x = new ArrayRealVector(2); solver.solve(a, b, x); } @Test public void testUnpreconditionedSolution() { final int n = 5; final int maxIterations = 100; final RealLinearOperator a = new HilbertMatrix(n); final InverseHilbertMatrix ainv = new InverseHilbertMatrix(n); final IterativeLinearSolver solver; solver = new ConjugateGradient(maxIterations, 1E-10, true); final RealVector b = new ArrayRealVector(n); for (int j = 0; j < n; j++) { b.set(0.); b.setEntry(j, 1.); final RealVector x = solver.solve(a, b); for (int i = 0; i < n; i++) { final double actual = x.getEntry(i); final double expected = ainv.getEntry(i, j); final double delta = 1E-10 * Math.abs(expected); final String msg = String.format("entry[%d][%d]", i, j); Assert.assertEquals(msg, expected, actual, delta); } } } @Test public void testUnpreconditionedInPlaceSolutionWithInitialGuess() { final int n = 5; final int maxIterations = 100; final RealLinearOperator a = new HilbertMatrix(n); final InverseHilbertMatrix ainv = new InverseHilbertMatrix(n); final IterativeLinearSolver solver; solver = new ConjugateGradient(maxIterations, 1E-10, true); final RealVector b = new ArrayRealVector(n); for (int j = 0; j < n; j++) { b.set(0.); b.setEntry(j, 1.); final RealVector x0 = new ArrayRealVector(n); x0.set(1.); final RealVector x = solver.solveInPlace(a, b, x0); Assert.assertSame("x should be a reference to x0", x0, x); for (int i = 0; i < n; i++) { final double actual = x.getEntry(i); final double expected = ainv.getEntry(i, j); final double delta = 1E-10 * Math.abs(expected); final String msg = String.format("entry[%d][%d)", i, j); Assert.assertEquals(msg, expected, actual, delta); } } } @Test public void testUnpreconditionedSolutionWithInitialGuess() { final int n = 5; final int maxIterations = 100; final RealLinearOperator a = new HilbertMatrix(n); final InverseHilbertMatrix ainv = new InverseHilbertMatrix(n); final IterativeLinearSolver solver; solver = new ConjugateGradient(maxIterations, 1E-10, true); final RealVector b = new ArrayRealVector(n); for (int j = 0; j < n; j++) { b.set(0.); b.setEntry(j, 1.); final RealVector x0 = new ArrayRealVector(n); x0.set(1.); final RealVector x = solver.solve(a, b, x0); Assert.assertNotSame("x should not be a reference to x0", x0, x); for (int i = 0; i < n; i++) { final double actual = x.getEntry(i); final double expected = ainv.getEntry(i, j); final double delta = 1E-10 * Math.abs(expected); final String msg = String.format("entry[%d][%d]", i, j); Assert.assertEquals(msg, expected, actual, delta); Assert.assertEquals(msg, x0.getEntry(i), 1., Math.ulp(1.)); } } } /** * Check whether the estimate of the (updated) residual corresponds to the * exact residual. This fails to be true for a large number of iterations, * due to the loss of orthogonality of the successive search directions. * Therefore, in the present test, the number of iterations is limited. */ @Test public void testUnpreconditionedResidual() { final int n = 10; final int maxIterations = n; final RealLinearOperator a = new HilbertMatrix(n); final ConjugateGradient solver; solver = new ConjugateGradient(maxIterations, 1E-15, true); final RealVector r = new ArrayRealVector(n); final RealVector x = new ArrayRealVector(n); final IterationListener listener = new IterationListener() { public void terminationPerformed(final IterationEvent e) { // Do nothing } public void iterationStarted(final IterationEvent e) { // Do nothing } public void iterationPerformed(final IterationEvent e) { final IterativeLinearSolverEvent evt; evt = (IterativeLinearSolverEvent) e; RealVector v = evt.getResidual(); r.setSubVector(0, v); v = evt.getSolution(); x.setSubVector(0, v); } public void initializationPerformed(final IterationEvent e) { // Do nothing } }; solver.getIterationManager().addIterationListener(listener); final RealVector b = new ArrayRealVector(n); for (int j = 0; j < n; j++) { b.set(0.); b.setEntry(j, 1.); boolean caught = false; try { solver.solve(a, b); } catch (MaxCountExceededException e) { caught = true; final RealVector y = a.operate(x); for (int i = 0; i < n; i++) { final double actual = b.getEntry(i) - y.getEntry(i); final double expected = r.getEntry(i); final double delta = 1E-6 * Math.abs(expected); final String msg = String .format("column %d, residual %d", i, j); Assert.assertEquals(msg, expected, actual, delta); } } Assert .assertTrue("MaxCountExceededException should have been caught", caught); } } @Test(expected = NonSquareOperatorException.class) public void testNonSquarePreconditioner() { final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 2); final RealLinearOperator m = new RealLinearOperator() { @Override public RealVector operate(final RealVector x) { throw new UnsupportedOperationException(); } @Override public int getRowDimension() { return 2; } @Override public int getColumnDimension() { return 3; } }; final PreconditionedIterativeLinearSolver solver; solver = new ConjugateGradient(10, 0d, false); final ArrayRealVector b = new ArrayRealVector(a.getRowDimension()); solver.solve(a, m, b); } @Test(expected = DimensionMismatchException.class) public void testMismatchedOperatorDimensions() { final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 2); final RealLinearOperator m = new RealLinearOperator() { @Override public RealVector operate(final RealVector x) { throw new UnsupportedOperationException(); } @Override public int getRowDimension() { return 3; } @Override public int getColumnDimension() { return 3; } }; final PreconditionedIterativeLinearSolver solver; solver = new ConjugateGradient(10, 0d, false); final ArrayRealVector b = new ArrayRealVector(a.getRowDimension()); solver.solve(a, m, b); } @Test(expected = NonPositiveDefiniteOperatorException.class) public void testNonPositiveDefinitePreconditioner() { final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 2); a.setEntry(0, 0, 1d); a.setEntry(0, 1, 2d); a.setEntry(1, 0, 3d); a.setEntry(1, 1, 4d); final RealLinearOperator m = new RealLinearOperator() { @Override public RealVector operate(final RealVector x) { final ArrayRealVector y = new ArrayRealVector(2); y.setEntry(0, -x.getEntry(0)); y.setEntry(1, x.getEntry(1)); return y; } @Override public int getRowDimension() { return 2; } @Override public int getColumnDimension() { return 2; } }; final PreconditionedIterativeLinearSolver solver; solver = new ConjugateGradient(10, 0d, true); final ArrayRealVector b = new ArrayRealVector(2); b.setEntry(0, -1d); b.setEntry(1, -1d); solver.solve(a, m, b); } @Test public void testPreconditionedSolution() { final int n = 8; final int maxIterations = 100; final RealLinearOperator a = new HilbertMatrix(n); final InverseHilbertMatrix ainv = new InverseHilbertMatrix(n); final RealLinearOperator m = JacobiPreconditioner.create(a); final PreconditionedIterativeLinearSolver solver; solver = new ConjugateGradient(maxIterations, 1E-15, true); final RealVector b = new ArrayRealVector(n); for (int j = 0; j < n; j++) { b.set(0.); b.setEntry(j, 1.); final RealVector x = solver.solve(a, m, b); for (int i = 0; i < n; i++) { final double actual = x.getEntry(i); final double expected = ainv.getEntry(i, j); final double delta = 1E-6 * Math.abs(expected); final String msg = String.format("coefficient (%d, %d)", i, j); Assert.assertEquals(msg, expected, actual, delta); } } } @Test public void testPreconditionedResidual() { final int n = 10; final int maxIterations = n; final RealLinearOperator a = new HilbertMatrix(n); final RealLinearOperator m = JacobiPreconditioner.create(a); final ConjugateGradient solver; solver = new ConjugateGradient(maxIterations, 1E-15, true); final RealVector r = new ArrayRealVector(n); final RealVector x = new ArrayRealVector(n); final IterationListener listener = new IterationListener() { public void terminationPerformed(final IterationEvent e) { // Do nothing } public void iterationStarted(final IterationEvent e) { // Do nothing } public void iterationPerformed(final IterationEvent e) { final IterativeLinearSolverEvent evt; evt = (IterativeLinearSolverEvent) e; RealVector v = evt.getResidual(); r.setSubVector(0, v); v = evt.getSolution(); x.setSubVector(0, v); } public void initializationPerformed(final IterationEvent e) { // Do nothing } }; solver.getIterationManager().addIterationListener(listener); final RealVector b = new ArrayRealVector(n); for (int j = 0; j < n; j++) { b.set(0.); b.setEntry(j, 1.); boolean caught = false; try { solver.solve(a, m, b); } catch (MaxCountExceededException e) { caught = true; final RealVector y = a.operate(x); for (int i = 0; i < n; i++) { final double actual = b.getEntry(i) - y.getEntry(i); final double expected = r.getEntry(i); final double delta = 1E-6 * Math.abs(expected); final String msg = String .format("column %d, residual %d", i, j); Assert.assertEquals(msg, expected, actual, delta); } } Assert .assertTrue("MaxCountExceededException should have been caught", caught); } } @Test public void testPreconditionedSolution2() { final int n = 100; final int maxIterations = 100000; final Array2DRowRealMatrix a = new Array2DRowRealMatrix(n, n); double daux = 1.; for (int i = 0; i < n; i++) { a.setEntry(i, i, daux); daux *= 1.2; for (int j = i + 1; j < n; j++) { if (i == j) { } else { final double value = 1.0; a.setEntry(i, j, value); a.setEntry(j, i, value); } } } final RealLinearOperator m = JacobiPreconditioner.create(a); final PreconditionedIterativeLinearSolver pcg; final IterativeLinearSolver cg; pcg = new ConjugateGradient(maxIterations, 1E-6, true); cg = new ConjugateGradient(maxIterations, 1E-6, true); final RealVector b = new ArrayRealVector(n); final String pattern = "preconditioned gradient (%d iterations) should" + " have been faster than unpreconditioned (%d iterations)"; String msg; for (int j = 0; j < 1; j++) { b.set(0.); b.setEntry(j, 1.); final RealVector px = pcg.solve(a, m, b); final RealVector x = cg.solve(a, b); final int npcg = pcg.getIterationManager().getIterations(); final int ncg = cg.getIterationManager().getIterations(); msg = String.format(pattern, npcg, ncg); Assert.assertTrue(msg, npcg < ncg); for (int i = 0; i < n; i++) { msg = String.format("row %d, column %d", i, j); final double expected = x.getEntry(i); final double actual = px.getEntry(i); final double delta = 1E-6 * Math.abs(expected); Assert.assertEquals(msg, expected, actual, delta); } } } @Test public void testEventManagement() { final int n = 5; final int maxIterations = 100; final RealLinearOperator a = new HilbertMatrix(n); final IterativeLinearSolver solver; /* * count[0] = number of calls to initializationPerformed * count[1] = number of calls to iterationStarted * count[2] = number of calls to iterationPerformed * count[3] = number of calls to terminationPerformed */ final int[] count = new int[] {0, 0, 0, 0}; final IterationListener listener = new IterationListener() { private void doTestVectorsAreUnmodifiable(final IterationEvent e) { final IterativeLinearSolverEvent evt; evt = (IterativeLinearSolverEvent) e; try { evt.getResidual().set(0.0); Assert.fail("r is modifiable"); } catch (MathUnsupportedOperationException exc){ // Expected behavior } try { evt.getRightHandSideVector().set(0.0); Assert.fail("b is modifiable"); } catch (MathUnsupportedOperationException exc){ // Expected behavior } try { evt.getSolution().set(0.0); Assert.fail("x is modifiable"); } catch (MathUnsupportedOperationException exc){ // Expected behavior } } public void initializationPerformed(final IterationEvent e) { ++count[0]; doTestVectorsAreUnmodifiable(e); } public void iterationPerformed(final IterationEvent e) { ++count[2]; Assert.assertEquals("iteration performed", count[2], e.getIterations() - 1); doTestVectorsAreUnmodifiable(e); } public void iterationStarted(final IterationEvent e) { ++count[1]; Assert.assertEquals("iteration started", count[1], e.getIterations() - 1); doTestVectorsAreUnmodifiable(e); } public void terminationPerformed(final IterationEvent e) { ++count[3]; doTestVectorsAreUnmodifiable(e); } }; solver = new ConjugateGradient(maxIterations, 1E-10, true); solver.getIterationManager().addIterationListener(listener); final RealVector b = new ArrayRealVector(n); for (int j = 0; j < n; j++) { Arrays.fill(count, 0); b.set(0.); b.setEntry(j, 1.); solver.solve(a, b); String msg = String.format("column %d (initialization)", j); Assert.assertEquals(msg, 1, count[0]); msg = String.format("column %d (finalization)", j); Assert.assertEquals(msg, 1, count[3]); } } @Test public void testUnpreconditionedNormOfResidual() { final int n = 5; final int maxIterations = 100; final RealLinearOperator a = new HilbertMatrix(n); final IterativeLinearSolver solver; final IterationListener listener = new IterationListener() { private void doTestNormOfResidual(final IterationEvent e) { final IterativeLinearSolverEvent evt; evt = (IterativeLinearSolverEvent) e; final RealVector x = evt.getSolution(); final RealVector b = evt.getRightHandSideVector(); final RealVector r = b.subtract(a.operate(x)); final double rnorm = r.getNorm(); Assert.assertEquals("iteration performed (residual)", rnorm, evt.getNormOfResidual(), FastMath.max(1E-5 * rnorm, 1E-10)); } public void initializationPerformed(final IterationEvent e) { doTestNormOfResidual(e); } public void iterationPerformed(final IterationEvent e) { doTestNormOfResidual(e); } public void iterationStarted(final IterationEvent e) { doTestNormOfResidual(e); } public void terminationPerformed(final IterationEvent e) { doTestNormOfResidual(e); } }; solver = new ConjugateGradient(maxIterations, 1E-10, true); solver.getIterationManager().addIterationListener(listener); final RealVector b = new ArrayRealVector(n); for (int j = 0; j < n; j++) { b.set(0.); b.setEntry(j, 1.); solver.solve(a, b); } } @Test public void testPreconditionedNormOfResidual() { final int n = 5; final int maxIterations = 100; final RealLinearOperator a = new HilbertMatrix(n); final RealLinearOperator m = JacobiPreconditioner.create(a); final PreconditionedIterativeLinearSolver solver; final IterationListener listener = new IterationListener() { private void doTestNormOfResidual(final IterationEvent e) { final IterativeLinearSolverEvent evt; evt = (IterativeLinearSolverEvent) e; final RealVector x = evt.getSolution(); final RealVector b = evt.getRightHandSideVector(); final RealVector r = b.subtract(a.operate(x)); final double rnorm = r.getNorm(); Assert.assertEquals("iteration performed (residual)", rnorm, evt.getNormOfResidual(), FastMath.max(1E-5 * rnorm, 1E-10)); } public void initializationPerformed(final IterationEvent e) { doTestNormOfResidual(e); } public void iterationPerformed(final IterationEvent e) { doTestNormOfResidual(e); } public void iterationStarted(final IterationEvent e) { doTestNormOfResidual(e); } public void terminationPerformed(final IterationEvent e) { doTestNormOfResidual(e); } }; solver = new ConjugateGradient(maxIterations, 1E-10, true); solver.getIterationManager().addIterationListener(listener); final RealVector b = new ArrayRealVector(n); for (int j = 0; j < n; j++) { b.set(0.); b.setEntry(j, 1.); solver.solve(a, m, b); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.NullArgumentException; import org.apache.commons.math3.exception.NumberIsTooLargeException; import org.apache.commons.math3.exception.OutOfRangeException; import org.apache.commons.math3.util.Precision; import org.junit.Assert; import org.junit.Test; /** * Test cases for the {@link DiagonalMatrix} class. */ public class DiagonalMatrixTest { @Test public void testConstructor1() { final int dim = 3; final DiagonalMatrix m = new DiagonalMatrix(dim); Assert.assertEquals(dim, m.getRowDimension()); Assert.assertEquals(dim, m.getColumnDimension()); } @Test public void testConstructor2() { final double[] d = { -1.2, 3.4, 5 }; final DiagonalMatrix m = new DiagonalMatrix(d); for (int i = 0; i < m.getRowDimension(); i++) { for (int j = 0; j < m.getRowDimension(); j++) { if (i == j) { Assert.assertEquals(d[i], m.getEntry(i, j), 0d); } else { Assert.assertEquals(0d, m.getEntry(i, j), 0d); } } } // Check that the underlying was copied. d[0] = 0; Assert.assertFalse(d[0] == m.getEntry(0, 0)); } @Test public void testConstructor3() { final double[] d = { -1.2, 3.4, 5 }; final DiagonalMatrix m = new DiagonalMatrix(d, false); for (int i = 0; i < m.getRowDimension(); i++) { for (int j = 0; j < m.getRowDimension(); j++) { if (i == j) { Assert.assertEquals(d[i], m.getEntry(i, j), 0d); } else { Assert.assertEquals(0d, m.getEntry(i, j), 0d); } } } // Check that the underlying is referenced. d[0] = 0; Assert.assertTrue(d[0] == m.getEntry(0, 0)); } @Test(expected=DimensionMismatchException.class) public void testCreateError() { final double[] d = { -1.2, 3.4, 5 }; final DiagonalMatrix m = new DiagonalMatrix(d, false); m.createMatrix(5, 3); } @Test public void testCreate() { final double[] d = { -1.2, 3.4, 5 }; final DiagonalMatrix m = new DiagonalMatrix(d, false); final RealMatrix p = m.createMatrix(5, 5); Assert.assertTrue(p instanceof DiagonalMatrix); Assert.assertEquals(5, p.getRowDimension()); Assert.assertEquals(5, p.getColumnDimension()); } @Test public void testCopy() { final double[] d = { -1.2, 3.4, 5 }; final DiagonalMatrix m = new DiagonalMatrix(d, false); final DiagonalMatrix p = (DiagonalMatrix) m.copy(); for (int i = 0; i < m.getRowDimension(); ++i) { Assert.assertEquals(m.getEntry(i, i), p.getEntry(i, i), 1.0e-20); } } @Test public void testGetData() { final double[] data = { -1.2, 3.4, 5 }; final int dim = 3; final DiagonalMatrix m = new DiagonalMatrix(dim); for (int i = 0; i < dim; i++) { m.setEntry(i, i, data[i]); } final double[][] out = m.getData(); Assert.assertEquals(dim, out.length); for (int i = 0; i < m.getRowDimension(); i++) { Assert.assertEquals(dim, out[i].length); for (int j = 0; j < m.getRowDimension(); j++) { if (i == j) { Assert.assertEquals(data[i], out[i][j], 0d); } else { Assert.assertEquals(0d, out[i][j], 0d); } } } } @Test public void testAdd() { final double[] data1 = { -1.2, 3.4, 5 }; final DiagonalMatrix m1 = new DiagonalMatrix(data1); final double[] data2 = { 10.1, 2.3, 45 }; final DiagonalMatrix m2 = new DiagonalMatrix(data2); final DiagonalMatrix result = m1.add(m2); Assert.assertEquals(m1.getRowDimension(), result.getRowDimension()); for (int i = 0; i < result.getRowDimension(); i++) { for (int j = 0; j < result.getRowDimension(); j++) { if (i == j) { Assert.assertEquals(data1[i] + data2[i], result.getEntry(i, j), 0d); } else { Assert.assertEquals(0d, result.getEntry(i, j), 0d); } } } } @Test public void testSubtract() { final double[] data1 = { -1.2, 3.4, 5 }; final DiagonalMatrix m1 = new DiagonalMatrix(data1); final double[] data2 = { 10.1, 2.3, 45 }; final DiagonalMatrix m2 = new DiagonalMatrix(data2); final DiagonalMatrix result = m1.subtract(m2); Assert.assertEquals(m1.getRowDimension(), result.getRowDimension()); for (int i = 0; i < result.getRowDimension(); i++) { for (int j = 0; j < result.getRowDimension(); j++) { if (i == j) { Assert.assertEquals(data1[i] - data2[i], result.getEntry(i, j), 0d); } else { Assert.assertEquals(0d, result.getEntry(i, j), 0d); } } } } @Test public void testAddToEntry() { final double[] data = { -1.2, 3.4, 5 }; final DiagonalMatrix m = new DiagonalMatrix(data); for (int i = 0; i < m.getRowDimension(); i++) { m.addToEntry(i, i, i); Assert.assertEquals(data[i] + i, m.getEntry(i, i), 0d); } } @Test public void testMultiplyEntry() { final double[] data = { -1.2, 3.4, 5 }; final DiagonalMatrix m = new DiagonalMatrix(data); for (int i = 0; i < m.getRowDimension(); i++) { m.multiplyEntry(i, i, i); Assert.assertEquals(data[i] * i, m.getEntry(i, i), 0d); } } @Test public void testMultiply1() { final double[] data1 = { -1.2, 3.4, 5 }; final DiagonalMatrix m1 = new DiagonalMatrix(data1); final double[] data2 = { 10.1, 2.3, 45 }; final DiagonalMatrix m2 = new DiagonalMatrix(data2); final DiagonalMatrix result = (DiagonalMatrix) m1.multiply((RealMatrix) m2); Assert.assertEquals(m1.getRowDimension(), result.getRowDimension()); for (int i = 0; i < result.getRowDimension(); i++) { for (int j = 0; j < result.getRowDimension(); j++) { if (i == j) { Assert.assertEquals(data1[i] * data2[i], result.getEntry(i, j), 0d); } else { Assert.assertEquals(0d, result.getEntry(i, j), 0d); } } } } @Test public void testMultiply2() { final double[] data1 = { -1.2, 3.4, 5 }; final DiagonalMatrix diag1 = new DiagonalMatrix(data1); final double[][] data2 = { { -1.2, 3.4 }, { -5.6, 7.8 }, { 9.1, 2.3 } }; final RealMatrix dense2 = new Array2DRowRealMatrix(data2); final RealMatrix dense1 = new Array2DRowRealMatrix(diag1.getData()); final RealMatrix diagResult = diag1.multiply(dense2); final RealMatrix denseResult = dense1.multiply(dense2); for (int i = 0; i < dense1.getRowDimension(); i++) { for (int j = 0; j < dense2.getColumnDimension(); j++) { Assert.assertEquals(denseResult.getEntry(i, j), diagResult.getEntry(i, j), 0d); } } } @Test public void testOperate() { final double[] data = { -1.2, 3.4, 5 }; final DiagonalMatrix diag = new DiagonalMatrix(data); final RealMatrix dense = new Array2DRowRealMatrix(diag.getData()); final double[] v = { 6.7, 890.1, 23.4 }; final double[] diagResult = diag.operate(v); final double[] denseResult = dense.operate(v); TestUtils.assertEquals(diagResult, denseResult, 0d); } @Test public void testPreMultiply() { final double[] data = { -1.2, 3.4, 5 }; final DiagonalMatrix diag = new DiagonalMatrix(data); final RealMatrix dense = new Array2DRowRealMatrix(diag.getData()); final double[] v = { 6.7, 890.1, 23.4 }; final double[] diagResult = diag.preMultiply(v); final double[] denseResult = dense.preMultiply(v); TestUtils.assertEquals(diagResult, denseResult, 0d); } @Test public void testPreMultiplyVector() { final double[] data = { -1.2, 3.4, 5 }; final DiagonalMatrix diag = new DiagonalMatrix(data); final RealMatrix dense = new Array2DRowRealMatrix(diag.getData()); final double[] v = { 6.7, 890.1, 23.4 }; final RealVector vector = MatrixUtils.createRealVector(v); final RealVector diagResult = diag.preMultiply(vector); final RealVector denseResult = dense.preMultiply(vector); TestUtils.assertEquals("preMultiply(Vector) returns wrong result", diagResult, denseResult, 0d); } @Test(expected=NumberIsTooLargeException.class) public void testSetNonDiagonalEntry() { final DiagonalMatrix diag = new DiagonalMatrix(3); diag.setEntry(1, 2, 3.4); } @Test public void testSetNonDiagonalZero() { final DiagonalMatrix diag = new DiagonalMatrix(3); diag.setEntry(1, 2, 0.0); Assert.assertEquals(0.0, diag.getEntry(1, 2), Precision.SAFE_MIN); } @Test(expected=NumberIsTooLargeException.class) public void testAddNonDiagonalEntry() { final DiagonalMatrix diag = new DiagonalMatrix(3); diag.addToEntry(1, 2, 3.4); } @Test public void testAddNonDiagonalZero() { final DiagonalMatrix diag = new DiagonalMatrix(3); diag.addToEntry(1, 2, 0.0); Assert.assertEquals(0.0, diag.getEntry(1, 2), Precision.SAFE_MIN); } @Test public void testMultiplyNonDiagonalEntry() { final DiagonalMatrix diag = new DiagonalMatrix(3); diag.multiplyEntry(1, 2, 3.4); Assert.assertEquals(0.0, diag.getEntry(1, 2), Precision.SAFE_MIN); } @Test public void testMultiplyNonDiagonalZero() { final DiagonalMatrix diag = new DiagonalMatrix(3); diag.multiplyEntry(1, 2, 0.0); Assert.assertEquals(0.0, diag.getEntry(1, 2), Precision.SAFE_MIN); } @Test(expected=OutOfRangeException.class) public void testSetEntryOutOfRange() { final DiagonalMatrix diag = new DiagonalMatrix(3); diag.setEntry(3, 3, 3.4); } @Test(expected=NullArgumentException.class) public void testNull() { new DiagonalMatrix(null, false); } @Test(expected=NumberIsTooLargeException.class) public void testSetSubMatrixError() { final double[] data = { -1.2, 3.4, 5 }; final DiagonalMatrix diag = new DiagonalMatrix(data); diag.setSubMatrix(new double[][] { {1.0, 1.0}, {1.0, 1.0}}, 1, 1); } @Test public void testSetSubMatrix() { final double[] data = { -1.2, 3.4, 5 }; final DiagonalMatrix diag = new DiagonalMatrix(data); diag.setSubMatrix(new double[][] { {0.0, 5.0, 0.0}, {0.0, 0.0, 6.0}}, 1, 0); Assert.assertEquals(-1.2, diag.getEntry(0, 0), 1.0e-20); Assert.assertEquals( 5.0, diag.getEntry(1, 1), 1.0e-20); Assert.assertEquals( 6.0, diag.getEntry(2, 2), 1.0e-20); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import java.util.Arrays; import java.util.Random; import org.apache.commons.math3.distribution.NormalDistribution; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.util.Precision; import org.apache.commons.math3.exception.MathUnsupportedOperationException; import org.junit.After; import org.junit.Assert; import org.junit.Before; import org.junit.Ignore; import org.junit.Test; public class EigenDecompositionTest { private double[] refValues; private RealMatrix matrix; @Test public void testDimension1() { RealMatrix matrix = MatrixUtils.createRealMatrix(new double[][] { { 1.5 } }); EigenDecomposition ed; ed = new EigenDecomposition(matrix); Assert.assertEquals(1.5, ed.getRealEigenvalue(0), 1.0e-15); } @Test public void testDimension2() { RealMatrix matrix = MatrixUtils.createRealMatrix(new double[][] { { 59.0, 12.0 }, { 12.0, 66.0 } }); EigenDecomposition ed; ed = new EigenDecomposition(matrix); Assert.assertEquals(75.0, ed.getRealEigenvalue(0), 1.0e-15); Assert.assertEquals(50.0, ed.getRealEigenvalue(1), 1.0e-15); } @Test public void testDimension3() { RealMatrix matrix = MatrixUtils.createRealMatrix(new double[][] { { 39632.0, -4824.0, -16560.0 }, { -4824.0, 8693.0, 7920.0 }, { -16560.0, 7920.0, 17300.0 } }); EigenDecomposition ed; ed = new EigenDecomposition(matrix); Assert.assertEquals(50000.0, ed.getRealEigenvalue(0), 3.0e-11); Assert.assertEquals(12500.0, ed.getRealEigenvalue(1), 3.0e-11); Assert.assertEquals( 3125.0, ed.getRealEigenvalue(2), 3.0e-11); } @Test public void testDimension3MultipleRoot() { RealMatrix matrix = MatrixUtils.createRealMatrix(new double[][] { { 5, 10, 15 }, { 10, 20, 30 }, { 15, 30, 45 } }); EigenDecomposition ed; ed = new EigenDecomposition(matrix); Assert.assertEquals(70.0, ed.getRealEigenvalue(0), 3.0e-11); Assert.assertEquals(0.0, ed.getRealEigenvalue(1), 3.0e-11); Assert.assertEquals(0.0, ed.getRealEigenvalue(2), 3.0e-11); } @Test public void testDimension4WithSplit() { RealMatrix matrix = MatrixUtils.createRealMatrix(new double[][] { { 0.784, -0.288, 0.000, 0.000 }, { -0.288, 0.616, 0.000, 0.000 }, { 0.000, 0.000, 0.164, -0.048 }, { 0.000, 0.000, -0.048, 0.136 } }); EigenDecomposition ed; ed = new EigenDecomposition(matrix); Assert.assertEquals(1.0, ed.getRealEigenvalue(0), 1.0e-15); Assert.assertEquals(0.4, ed.getRealEigenvalue(1), 1.0e-15); Assert.assertEquals(0.2, ed.getRealEigenvalue(2), 1.0e-15); Assert.assertEquals(0.1, ed.getRealEigenvalue(3), 1.0e-15); } @Test public void testDimension4WithoutSplit() { RealMatrix matrix = MatrixUtils.createRealMatrix(new double[][] { { 0.5608, -0.2016, 0.1152, -0.2976 }, { -0.2016, 0.4432, -0.2304, 0.1152 }, { 0.1152, -0.2304, 0.3088, -0.1344 }, { -0.2976, 0.1152, -0.1344, 0.3872 } }); EigenDecomposition ed; ed = new EigenDecomposition(matrix); Assert.assertEquals(1.0, ed.getRealEigenvalue(0), 1.0e-15); Assert.assertEquals(0.4, ed.getRealEigenvalue(1), 1.0e-15); Assert.assertEquals(0.2, ed.getRealEigenvalue(2), 1.0e-15); Assert.assertEquals(0.1, ed.getRealEigenvalue(3), 1.0e-15); } // the following test triggered an ArrayIndexOutOfBoundsException in commons-math 2.0 @Test public void testMath308() { double[] mainTridiagonal = { 22.330154644539597, 46.65485522478641, 17.393672330044705, 54.46687435351116, 80.17800767709437 }; double[] secondaryTridiagonal = { 13.04450406501361, -5.977590941539671, 2.9040909856707517, 7.1570352792841225 }; // the reference values have been computed using routine DSTEMR // from the fortran library LAPACK version 3.2.1 double[] refEigenValues = { 82.044413207204002, 53.456697699894512, 52.536278520113882, 18.847969733754262, 14.138204224043099 }; RealVector[] refEigenVectors = { new ArrayRealVector(new double[] { -0.000462690386766, -0.002118073109055, 0.011530080757413, 0.252322434584915, 0.967572088232592 }), new ArrayRealVector(new double[] { 0.314647769490148, 0.750806415553905, -0.167700312025760, -0.537092972407375, 0.143854968127780 }), new ArrayRealVector(new double[] { 0.222368839324646, 0.514921891363332, -0.021377019336614, 0.801196801016305, -0.207446991247740 }), new ArrayRealVector(new double[] { -0.713933751051495, 0.190582113553930, -0.671410443368332, 0.056056055955050, -0.006541576993581 }), new ArrayRealVector(new double[] { -0.584677060845929, 0.367177264979103, 0.721453187784497, -0.052971054621812, 0.005740715188257 }) }; EigenDecomposition decomposition; decomposition = new EigenDecomposition(mainTridiagonal, secondaryTridiagonal); double[] eigenValues = decomposition.getRealEigenvalues(); for (int i = 0; i < refEigenValues.length; ++i) { Assert.assertEquals(refEigenValues[i], eigenValues[i], 1.0e-5); Assert.assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 2.0e-7); } } @Test public void testMathpbx02() { double[] mainTridiagonal = { 7484.860960227216, 18405.28129035345, 13855.225609560746, 10016.708722343366, 559.8117399576674, 6750.190788301587, 71.21428769782159 }; double[] secondaryTridiagonal = { -4175.088570476366,1975.7955858241994,5193.178422374075, 1995.286659169179,75.34535882933804,-234.0808002076056 }; // the reference values have been computed using routine DSTEMR // from the fortran library LAPACK version 3.2.1 double[] refEigenValues = { 20654.744890306974412,16828.208208485466457, 6893.155912634994820,6757.083016675340332, 5887.799885688558788,64.309089923240379, 57.992628792736340 }; RealVector[] refEigenVectors = { new ArrayRealVector(new double[] {-0.270356342026904, 0.852811091326997, 0.399639490702077, 0.198794657813990, 0.019739323307666, 0.000106983022327, -0.000001216636321}), new ArrayRealVector(new double[] {0.179995273578326,-0.402807848153042,0.701870993525734,0.555058211014888,0.068079148898236,0.000509139115227,-0.000007112235617}), new ArrayRealVector(new double[] {-0.399582721284727,-0.056629954519333,-0.514406488522827,0.711168164518580,0.225548081276367,0.125943999652923,-0.004321507456014}), new ArrayRealVector(new double[] {0.058515721572821,0.010200130057739,0.063516274916536,-0.090696087449378,-0.017148420432597,0.991318870265707,-0.034707338554096}), new ArrayRealVector(new double[] {0.855205995537564,0.327134656629775,-0.265382397060548,0.282690729026706,0.105736068025572,-0.009138126622039,0.000367751821196}), new ArrayRealVector(new double[] {-0.002913069901144,-0.005177515777101,0.041906334478672,-0.109315918416258,0.436192305456741,0.026307315639535,0.891797507436344}), new ArrayRealVector(new double[] {-0.005738311176435,-0.010207611670378,0.082662420517928,-0.215733886094368,0.861606487840411,-0.025478530652759,-0.451080697503958}) }; // the following line triggers the exception EigenDecomposition decomposition; decomposition = new EigenDecomposition(mainTridiagonal, secondaryTridiagonal); double[] eigenValues = decomposition.getRealEigenvalues(); for (int i = 0; i < refEigenValues.length; ++i) { Assert.assertEquals(refEigenValues[i], eigenValues[i], 1.0e-3); if (refEigenVectors[i].dotProduct(decomposition.getEigenvector(i)) < 0) { Assert.assertEquals(0, refEigenVectors[i].add(decomposition.getEigenvector(i)).getNorm(), 1.0e-5); } else { Assert.assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 1.0e-5); } } } @Test public void testMathpbx03() { double[] mainTridiagonal = { 1809.0978259647177,3395.4763425956166,1832.1894584712693,3804.364873592377, 806.0482458637571,2403.656427234185,28.48691431556015 }; double[] secondaryTridiagonal = { -656.8932064545833,-469.30804108920734,-1021.7714889369421, -1152.540497328983,-939.9765163817368,-12.885877015422391 }; // the reference values have been computed using routine DSTEMR // from the fortran library LAPACK version 3.2.1 double[] refEigenValues = { 4603.121913685183245,3691.195818048970978,2743.442955402465032,1657.596442107321764, 1336.797819095331306,30.129865209677519,17.035352085224986 }; RealVector[] refEigenVectors = { new ArrayRealVector(new double[] {-0.036249830202337,0.154184732411519,-0.346016328392363,0.867540105133093,-0.294483395433451,0.125854235969548,-0.000354507444044}), new ArrayRealVector(new double[] {-0.318654191697157,0.912992309960507,-0.129270874079777,-0.184150038178035,0.096521712579439,-0.070468788536461,0.000247918177736}), new ArrayRealVector(new double[] {-0.051394668681147,0.073102235876933,0.173502042943743,-0.188311980310942,-0.327158794289386,0.905206581432676,-0.004296342252659}), new ArrayRealVector(new double[] {0.838150199198361,0.193305209055716,-0.457341242126146,-0.166933875895419,0.094512811358535,0.119062381338757,-0.000941755685226}), new ArrayRealVector(new double[] {0.438071395458547,0.314969169786246,0.768480630802146,0.227919171600705,-0.193317045298647,-0.170305467485594,0.001677380536009}), new ArrayRealVector(new double[] {-0.003726503878741,-0.010091946369146,-0.067152015137611,-0.113798146542187,-0.313123000097908,-0.118940107954918,0.932862311396062}), new ArrayRealVector(new double[] {0.009373003194332,0.025570377559400,0.170955836081348,0.291954519805750,0.807824267665706,0.320108347088646,0.360202112392266}), }; // the following line triggers the exception EigenDecomposition decomposition; decomposition = new EigenDecomposition(mainTridiagonal, secondaryTridiagonal); double[] eigenValues = decomposition.getRealEigenvalues(); for (int i = 0; i < refEigenValues.length; ++i) { Assert.assertEquals(refEigenValues[i], eigenValues[i], 1.0e-4); if (refEigenVectors[i].dotProduct(decomposition.getEigenvector(i)) < 0) { Assert.assertEquals(0, refEigenVectors[i].add(decomposition.getEigenvector(i)).getNorm(), 1.0e-5); } else { Assert.assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 1.0e-5); } } } /** test a matrix already in tridiagonal form. */ @Test public void testTridiagonal() { Random r = new Random(4366663527842l); double[] ref = new double[30]; for (int i = 0; i < ref.length; ++i) { if (i < 5) { ref[i] = 2 * r.nextDouble() - 1; } else { ref[i] = 0.0001 * r.nextDouble() + 6; } } Arrays.sort(ref); TriDiagonalTransformer t = new TriDiagonalTransformer(createTestMatrix(r, ref)); EigenDecomposition ed; ed = new EigenDecomposition(t.getMainDiagonalRef(), t.getSecondaryDiagonalRef()); double[] eigenValues = ed.getRealEigenvalues(); Assert.assertEquals(ref.length, eigenValues.length); for (int i = 0; i < ref.length; ++i) { Assert.assertEquals(ref[ref.length - i - 1], eigenValues[i], 2.0e-14); } } /** test dimensions */ @Test public void testDimensions() { final int m = matrix.getRowDimension(); EigenDecomposition ed; ed = new EigenDecomposition(matrix); Assert.assertEquals(m, ed.getV().getRowDimension()); Assert.assertEquals(m, ed.getV().getColumnDimension()); Assert.assertEquals(m, ed.getD().getColumnDimension()); Assert.assertEquals(m, ed.getD().getColumnDimension()); Assert.assertEquals(m, ed.getVT().getRowDimension()); Assert.assertEquals(m, ed.getVT().getColumnDimension()); } /** test eigenvalues */ @Test public void testEigenvalues() { EigenDecomposition ed; ed = new EigenDecomposition(matrix); double[] eigenValues = ed.getRealEigenvalues(); Assert.assertEquals(refValues.length, eigenValues.length); for (int i = 0; i < refValues.length; ++i) { Assert.assertEquals(refValues[i], eigenValues[i], 3.0e-15); } } /** test eigenvalues for a big matrix. */ @Test public void testBigMatrix() { Random r = new Random(17748333525117l); double[] bigValues = new double[200]; for (int i = 0; i < bigValues.length; ++i) { bigValues[i] = 2 * r.nextDouble() - 1; } Arrays.sort(bigValues); EigenDecomposition ed; ed = new EigenDecomposition(createTestMatrix(r, bigValues)); double[] eigenValues = ed.getRealEigenvalues(); Assert.assertEquals(bigValues.length, eigenValues.length); for (int i = 0; i < bigValues.length; ++i) { Assert.assertEquals(bigValues[bigValues.length - i - 1], eigenValues[i], 2.0e-14); } } @Test public void testSymmetric() { RealMatrix symmetric = MatrixUtils.createRealMatrix(new double[][] { {4, 1, 1}, {1, 2, 3}, {1, 3, 6} }); EigenDecomposition ed; ed = new EigenDecomposition(symmetric); RealMatrix d = ed.getD(); RealMatrix v = ed.getV(); RealMatrix vT = ed.getVT(); double norm = v.multiply(d).multiply(vT).subtract(symmetric).getNorm(); Assert.assertEquals(0, norm, 6.0e-13); } @Test public void testSquareRoot() { final double[][] data = { { 33, 24, 7 }, { 24, 57, 11 }, { 7, 11, 9 } }; final EigenDecomposition dec = new EigenDecomposition(MatrixUtils.createRealMatrix(data)); final RealMatrix sqrtM = dec.getSquareRoot(); // Reconstruct initial matrix. final RealMatrix m = sqrtM.multiply(sqrtM); final int dim = data.length; for (int r = 0; r < dim; r++) { for (int c = 0; c < dim; c++) { Assert.assertEquals("m[" + r + "][" + c + "]", data[r][c], m.getEntry(r, c), 1e-13); } } } @Test(expected=MathUnsupportedOperationException.class) public void testSquareRootNonSymmetric() { final double[][] data = { { 1, 2, 4 }, { 2, 3, 5 }, { 11, 5, 9 } }; final EigenDecomposition dec = new EigenDecomposition(MatrixUtils.createRealMatrix(data)); @SuppressWarnings("unused") final RealMatrix sqrtM = dec.getSquareRoot(); } @Test(expected=MathUnsupportedOperationException.class) public void testSquareRootNonPositiveDefinite() { final double[][] data = { { 1, 2, 4 }, { 2, 3, 5 }, { 4, 5, -9 } }; final EigenDecomposition dec = new EigenDecomposition(MatrixUtils.createRealMatrix(data)); @SuppressWarnings("unused") final RealMatrix sqrtM = dec.getSquareRoot(); } @Test public void testUnsymmetric() { // Vandermonde matrix V(x;i,j) = x_i^{n - j} with x = (-1,-2,3,4) double[][] vData = { { -1.0, 1.0, -1.0, 1.0 }, { -8.0, 4.0, -2.0, 1.0 }, { 27.0, 9.0, 3.0, 1.0 }, { 64.0, 16.0, 4.0, 1.0 } }; checkUnsymmetricMatrix(MatrixUtils.createRealMatrix(vData)); RealMatrix randMatrix = MatrixUtils.createRealMatrix(new double[][] { {0, 1, 0, 0}, {1, 0, 2.e-7, 0}, {0, -2.e-7, 0, 1}, {0, 0, 1, 0} }); checkUnsymmetricMatrix(randMatrix); // from http://eigen.tuxfamily.org/dox/classEigen_1_1RealSchur.html double[][] randData2 = { { 0.680, -0.3300, -0.2700, -0.717, -0.687, 0.0259 }, { -0.211, 0.5360, 0.0268, 0.214, -0.198, 0.6780 }, { 0.566, -0.4440, 0.9040, -0.967, -0.740, 0.2250 }, { 0.597, 0.1080, 0.8320, -0.514, -0.782, -0.4080 }, { 0.823, -0.0452, 0.2710, -0.726, 0.998, 0.2750 }, { -0.605, 0.2580, 0.4350, 0.608, -0.563, 0.0486 } }; checkUnsymmetricMatrix(MatrixUtils.createRealMatrix(randData2)); } @Test @Ignore public void testRandomUnsymmetricMatrix() { for (int run = 0; run < 100; run++) { Random r = new Random(System.currentTimeMillis()); // matrix size int size = r.nextInt(20) + 4; double[][] data = new double[size][size]; for (int i = 0; i < size; i++) { for (int j = 0; j < size; j++) { data[i][j] = r.nextInt(100); } } RealMatrix m = MatrixUtils.createRealMatrix(data); checkUnsymmetricMatrix(m); } } @Test @Ignore public void testNormalDistributionUnsymmetricMatrix() { for (int run = 0; run < 100; run++) { Random r = new Random(System.currentTimeMillis()); NormalDistribution dist = new NormalDistribution(0.0, r.nextDouble() * 5); // matrix size int size = r.nextInt(20) + 4; double[][] data = new double[size][size]; for (int i = 0; i < size; i++) { for (int j = 0; j < size; j++) { data[i][j] = dist.sample(); } } RealMatrix m = MatrixUtils.createRealMatrix(data); checkUnsymmetricMatrix(m); } } @Test public void testMath848() { double[][] data = { { 0.1849449280, -0.0646971046, 0.0774755812, -0.0969651755, -0.0692648806, 0.3282344352, -0.0177423074, 0.2063136340}, {-0.0742700134, -0.0289063030, -0.0017269460, -0.0375550146, -0.0487737922, -0.2616837868, -0.0821201295, -0.2530000167}, { 0.2549910127, 0.0995733692, -0.0009718388, 0.0149282808, 0.1791878897, -0.0823182816, 0.0582629256, 0.3219545182}, {-0.0694747557, -0.1880649148, -0.2740630911, 0.0720096468, -0.1800836914, -0.3518996425, 0.2486747833, 0.6257938167}, { 0.0536360918, -0.1339297778, 0.2241579764, -0.0195327484, -0.0054103808, 0.0347564518, 0.5120802482, -0.0329902864}, {-0.5933332356, -0.2488721082, 0.2357173629, 0.0177285473, 0.0856630593, -0.3567126300, -0.1600668126, -0.1010899621}, {-0.0514349819, -0.0854319435, 0.1125050061, 0.0063453560, -0.2250000688, -0.2209343090, 0.1964623477, -0.1512329924}, { 0.0197395947, -0.1997170581, -0.1425959019, -0.2749477910, -0.0969467073, 0.0603688520, -0.2826905192, 0.1794315473}}; RealMatrix m = MatrixUtils.createRealMatrix(data); checkUnsymmetricMatrix(m); } /** * Checks that the eigen decomposition of a general (unsymmetric) matrix is valid by * checking: A*V = V*D */ private void checkUnsymmetricMatrix(final RealMatrix m) { try { EigenDecomposition ed = new EigenDecomposition(m); RealMatrix d = ed.getD(); RealMatrix v = ed.getV(); //RealMatrix vT = ed.getVT(); RealMatrix x = m.multiply(v); RealMatrix y = v.multiply(d); double diffNorm = x.subtract(y).getNorm(); Assert.assertTrue("The norm of (X-Y) is too large: " + diffNorm + ", matrix=" + m.toString(), x.subtract(y).getNorm() < 1000 * Precision.EPSILON * FastMath.max(x.getNorm(), y.getNorm())); RealMatrix invV = new LUDecomposition(v).getSolver().getInverse(); double norm = v.multiply(d).multiply(invV).subtract(m).getNorm(); Assert.assertEquals(0.0, norm, 1.0e-10); } catch (Exception e) { Assert.fail("Failed to create EigenDecomposition for matrix " + m.toString() + ", ex=" + e.toString()); } } /** test eigenvectors */ @Test public void testEigenvectors() { EigenDecomposition ed; ed = new EigenDecomposition(matrix); for (int i = 0; i < matrix.getRowDimension(); ++i) { double lambda = ed.getRealEigenvalue(i); RealVector v = ed.getEigenvector(i); RealVector mV = matrix.operate(v); Assert.assertEquals(0, mV.subtract(v.mapMultiplyToSelf(lambda)).getNorm(), 1.0e-13); } } /** test A = VDVt */ @Test public void testAEqualVDVt() { EigenDecomposition ed; ed = new EigenDecomposition(matrix); RealMatrix v = ed.getV(); RealMatrix d = ed.getD(); RealMatrix vT = ed.getVT(); double norm = v.multiply(d).multiply(vT).subtract(matrix).getNorm(); Assert.assertEquals(0, norm, 6.0e-13); } /** test that V is orthogonal */ @Test public void testVOrthogonal() { RealMatrix v = new EigenDecomposition(matrix).getV(); RealMatrix vTv = v.transpose().multiply(v); RealMatrix id = MatrixUtils.createRealIdentityMatrix(vTv.getRowDimension()); Assert.assertEquals(0, vTv.subtract(id).getNorm(), 2.0e-13); } /** test diagonal matrix */ @Test public void testDiagonal() { double[] diagonal = new double[] { -3.0, -2.0, 2.0, 5.0 }; RealMatrix m = MatrixUtils.createRealDiagonalMatrix(diagonal); EigenDecomposition ed; ed = new EigenDecomposition(m); Assert.assertEquals(diagonal[0], ed.getRealEigenvalue(3), 2.0e-15); Assert.assertEquals(diagonal[1], ed.getRealEigenvalue(2), 2.0e-15); Assert.assertEquals(diagonal[2], ed.getRealEigenvalue(1), 2.0e-15); Assert.assertEquals(diagonal[3], ed.getRealEigenvalue(0), 2.0e-15); } /** * Matrix with eigenvalues {8, -1, -1} */ @Test public void testRepeatedEigenvalue() { RealMatrix repeated = MatrixUtils.createRealMatrix(new double[][] { {3, 2, 4}, {2, 0, 2}, {4, 2, 3} }); EigenDecomposition ed; ed = new EigenDecomposition(repeated); checkEigenValues((new double[] {8, -1, -1}), ed, 1E-12); checkEigenVector((new double[] {2, 1, 2}), ed, 1E-12); } /** * Matrix with eigenvalues {2, 0, 12} */ @Test public void testDistinctEigenvalues() { RealMatrix distinct = MatrixUtils.createRealMatrix(new double[][] { {3, 1, -4}, {1, 3, -4}, {-4, -4, 8} }); EigenDecomposition ed; ed = new EigenDecomposition(distinct); checkEigenValues((new double[] {2, 0, 12}), ed, 1E-12); checkEigenVector((new double[] {1, -1, 0}), ed, 1E-12); checkEigenVector((new double[] {1, 1, 1}), ed, 1E-12); checkEigenVector((new double[] {-1, -1, 2}), ed, 1E-12); } /** * Verifies operation on indefinite matrix */ @Test public void testZeroDivide() { RealMatrix indefinite = MatrixUtils.createRealMatrix(new double [][] { { 0.0, 1.0, -1.0 }, { 1.0, 1.0, 0.0 }, { -1.0,0.0, 1.0 } }); EigenDecomposition ed; ed = new EigenDecomposition(indefinite); checkEigenValues((new double[] {2, 1, -1}), ed, 1E-12); double isqrt3 = 1/FastMath.sqrt(3.0); checkEigenVector((new double[] {isqrt3,isqrt3,-isqrt3}), ed, 1E-12); double isqrt2 = 1/FastMath.sqrt(2.0); checkEigenVector((new double[] {0.0,-isqrt2,-isqrt2}), ed, 1E-12); double isqrt6 = 1/FastMath.sqrt(6.0); checkEigenVector((new double[] {2*isqrt6,-isqrt6,isqrt6}), ed, 1E-12); } /** * Verifies that the given EigenDecomposition has eigenvalues equivalent to * the targetValues, ignoring the order of the values and allowing * values to differ by tolerance. */ protected void checkEigenValues(double[] targetValues, EigenDecomposition ed, double tolerance) { double[] observed = ed.getRealEigenvalues(); for (int i = 0; i < observed.length; i++) { Assert.assertTrue(isIncludedValue(observed[i], targetValues, tolerance)); Assert.assertTrue(isIncludedValue(targetValues[i], observed, tolerance)); } } /** * Returns true iff there is an entry within tolerance of value in * searchArray. */ private boolean isIncludedValue(double value, double[] searchArray, double tolerance) { boolean found = false; int i = 0; while (!found && i < searchArray.length) { if (FastMath.abs(value - searchArray[i]) < tolerance) { found = true; } i++; } return found; } /** * Returns true iff eigenVector is a scalar multiple of one of the columns * of ed.getV(). Does not try linear combinations - i.e., should only be * used to find vectors in one-dimensional eigenspaces. */ protected void checkEigenVector(double[] eigenVector, EigenDecomposition ed, double tolerance) { Assert.assertTrue(isIncludedColumn(eigenVector, ed.getV(), tolerance)); } /** * Returns true iff there is a column that is a scalar multiple of column * in searchMatrix (modulo tolerance) */ private boolean isIncludedColumn(double[] column, RealMatrix searchMatrix, double tolerance) { boolean found = false; int i = 0; while (!found && i < searchMatrix.getColumnDimension()) { double multiplier = 1.0; boolean matching = true; int j = 0; while (matching && j < searchMatrix.getRowDimension()) { double colEntry = searchMatrix.getEntry(j, i); // Use the first entry where both are non-zero as scalar if (FastMath.abs(multiplier - 1.0) <= FastMath.ulp(1.0) && FastMath.abs(colEntry) > 1E-14 && FastMath.abs(column[j]) > 1e-14) { multiplier = colEntry / column[j]; } if (FastMath.abs(column[j] * multiplier - colEntry) > tolerance) { matching = false; } j++; } found = matching; i++; } return found; } @Before public void setUp() { refValues = new double[] { 2.003, 2.002, 2.001, 1.001, 1.000, 0.001 }; matrix = createTestMatrix(new Random(35992629946426l), refValues); } @After public void tearDown() { refValues = null; matrix = null; } static RealMatrix createTestMatrix(final Random r, final double[] eigenValues) { final int n = eigenValues.length; final RealMatrix v = createOrthogonalMatrix(r, n); final RealMatrix d = MatrixUtils.createRealDiagonalMatrix(eigenValues); return v.multiply(d).multiply(v.transpose()); } public static RealMatrix createOrthogonalMatrix(final Random r, final int size) { final double[][] data = new double[size][size]; for (int i = 0; i < size; ++i) { final double[] dataI = data[i]; double norm2 = 0; do { // generate randomly row I for (int j = 0; j < size; ++j) { dataI[j] = 2 * r.nextDouble() - 1; } // project the row in the subspace orthogonal to previous rows for (int k = 0; k < i; ++k) { final double[] dataK = data[k]; double dotProduct = 0; for (int j = 0; j < size; ++j) { dotProduct += dataI[j] * dataK[j]; } for (int j = 0; j < size; ++j) { dataI[j] -= dotProduct * dataK[j]; } } // normalize the row norm2 = 0; for (final double dataIJ : dataI) { norm2 += dataIJ * dataIJ; } final double inv = 1.0 / FastMath.sqrt(norm2); for (int j = 0; j < size; ++j) { dataI[j] *= inv; } } while (norm2 * size < 0.01); } return MatrixUtils.createRealMatrix(data); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import java.util.Random; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.junit.Test; import org.junit.Assert; public class EigenSolverTest { /** test non invertible matrix */ @Test public void testNonInvertible() { Random r = new Random(9994100315209l); RealMatrix m = EigenDecompositionTest.createTestMatrix(r, new double[] { 1.0, 0.0, -1.0, -2.0, -3.0 }); DecompositionSolver es = new EigenDecomposition(m).getSolver(); Assert.assertFalse(es.isNonSingular()); try { es.getInverse(); Assert.fail("an exception should have been thrown"); } catch (SingularMatrixException ime) { // expected behavior } } /** test invertible matrix */ @Test public void testInvertible() { Random r = new Random(9994100315209l); RealMatrix m = EigenDecompositionTest.createTestMatrix(r, new double[] { 1.0, 0.5, -1.0, -2.0, -3.0 }); DecompositionSolver es = new EigenDecomposition(m).getSolver(); Assert.assertTrue(es.isNonSingular()); RealMatrix inverse = es.getInverse(); RealMatrix error = m.multiply(inverse).subtract(MatrixUtils.createRealIdentityMatrix(m.getRowDimension())); Assert.assertEquals(0, error.getNorm(), 4.0e-15); } /** test solve dimension errors */ @Test public void testSolveDimensionErrors() { final double[] refValues = new double[] { 2.003, 2.002, 2.001, 1.001, 1.000, 0.001 }; final RealMatrix matrix = EigenDecompositionTest.createTestMatrix(new Random(35992629946426l), refValues); DecompositionSolver es = new EigenDecomposition(matrix).getSolver(); RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]); try { es.solve(b); Assert.fail("an exception should have been thrown"); } catch (MathIllegalArgumentException iae) { // expected behavior } try { es.solve(b.getColumnVector(0)); Assert.fail("an exception should have been thrown"); } catch (MathIllegalArgumentException iae) { // expected behavior } try { es.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0))); Assert.fail("an exception should have been thrown"); } catch (MathIllegalArgumentException iae) { // expected behavior } } /** test solve */ @Test public void testSolve() { RealMatrix m = MatrixUtils.createRealMatrix(new double[][] { { 91, 5, 29, 32, 40, 14 }, { 5, 34, -1, 0, 2, -1 }, { 29, -1, 12, 9, 21, 8 }, { 32, 0, 9, 14, 9, 0 }, { 40, 2, 21, 9, 51, 19 }, { 14, -1, 8, 0, 19, 14 } }); DecompositionSolver es = new EigenDecomposition(m).getSolver(); RealMatrix b = MatrixUtils.createRealMatrix(new double[][] { { 1561, 269, 188 }, { 69, -21, 70 }, { 739, 108, 63 }, { 324, 86, 59 }, { 1624, 194, 107 }, { 796, 69, 36 } }); RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] { { 1, 2, 1 }, { 2, -1, 2 }, { 4, 2, 3 }, { 8, -1, 0 }, { 16, 2, 0 }, { 32, -1, 0 } }); // using RealMatrix RealMatrix solution=es.solve(b); Assert.assertEquals(0, solution.subtract(xRef).getNorm(), 2.5e-12); // using RealVector for (int i = 0; i < b.getColumnDimension(); ++i) { Assert.assertEquals(0, es.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(), 2.0e-11); } // using RealVector with an alternate implementation for (int i = 0; i < b.getColumnDimension(); ++i) { ArrayRealVectorTest.RealVectorTestImpl v = new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i)); Assert.assertEquals(0, es.solve(v).subtract(xRef.getColumnVector(i)).getNorm(), 2.0e-11); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import org.junit.Test; import org.junit.Assert; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.fraction.Fraction; import org.apache.commons.math3.fraction.FractionField; public class FieldLUDecompositionTest { private Fraction[][] testData = { { new Fraction(1), new Fraction(2), new Fraction(3)}, { new Fraction(2), new Fraction(5), new Fraction(3)}, { new Fraction(1), new Fraction(0), new Fraction(8)} }; private Fraction[][] testDataMinus = { { new Fraction(-1), new Fraction(-2), new Fraction(-3)}, { new Fraction(-2), new Fraction(-5), new Fraction(-3)}, { new Fraction(-1), new Fraction(0), new Fraction(-8)} }; private Fraction[][] luData = { { new Fraction(2), new Fraction(3), new Fraction(3) }, { new Fraction(2), new Fraction(3), new Fraction(7) }, { new Fraction(6), new Fraction(6), new Fraction(8) } }; // singular matrices private Fraction[][] singular = { { new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(3) } }; private Fraction[][] bigSingular = { { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(2), new Fraction(5), new Fraction(3), new Fraction(4) }, { new Fraction(7), new Fraction(3), new Fraction(256), new Fraction(1930) }, { new Fraction(3), new Fraction(7), new Fraction(6), new Fraction(8) } }; // 4th row = 1st + 2nd /** test dimensions */ @Test public void testDimensions() { FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData); FieldLUDecomposition<Fraction> LU = new FieldLUDecomposition<Fraction>(matrix); Assert.assertEquals(testData.length, LU.getL().getRowDimension()); Assert.assertEquals(testData.length, LU.getL().getColumnDimension()); Assert.assertEquals(testData.length, LU.getU().getRowDimension()); Assert.assertEquals(testData.length, LU.getU().getColumnDimension()); Assert.assertEquals(testData.length, LU.getP().getRowDimension()); Assert.assertEquals(testData.length, LU.getP().getColumnDimension()); } /** test non-square matrix */ @Test public void testNonSquare() { try { // we don't use FractionField.getInstance() for testing purposes new FieldLUDecomposition<Fraction>(new Array2DRowFieldMatrix<Fraction>(new Fraction[][] { { Fraction.ZERO, Fraction.ZERO }, { Fraction.ZERO, Fraction.ZERO }, { Fraction.ZERO, Fraction.ZERO } })); Assert.fail("Expected NonSquareMatrixException"); } catch (NonSquareMatrixException ime) { // expected behavior } } /** test PA = LU */ @Test public void testPAEqualLU() { FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData); FieldLUDecomposition<Fraction> lu = new FieldLUDecomposition<Fraction>(matrix); FieldMatrix<Fraction> l = lu.getL(); FieldMatrix<Fraction> u = lu.getU(); FieldMatrix<Fraction> p = lu.getP(); TestUtils.assertEquals(p.multiply(matrix), l.multiply(u)); matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testDataMinus); lu = new FieldLUDecomposition<Fraction>(matrix); l = lu.getL(); u = lu.getU(); p = lu.getP(); TestUtils.assertEquals(p.multiply(matrix), l.multiply(u)); matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), 17, 17); for (int i = 0; i < matrix.getRowDimension(); ++i) { matrix.setEntry(i, i, Fraction.ONE); } lu = new FieldLUDecomposition<Fraction>(matrix); l = lu.getL(); u = lu.getU(); p = lu.getP(); TestUtils.assertEquals(p.multiply(matrix), l.multiply(u)); matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), singular); lu = new FieldLUDecomposition<Fraction>(matrix); Assert.assertFalse(lu.getSolver().isNonSingular()); Assert.assertNull(lu.getL()); Assert.assertNull(lu.getU()); Assert.assertNull(lu.getP()); matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), bigSingular); lu = new FieldLUDecomposition<Fraction>(matrix); Assert.assertFalse(lu.getSolver().isNonSingular()); Assert.assertNull(lu.getL()); Assert.assertNull(lu.getU()); Assert.assertNull(lu.getP()); } /** test that L is lower triangular with unit diagonal */ @Test public void testLLowerTriangular() { FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData); FieldMatrix<Fraction> l = new FieldLUDecomposition<Fraction>(matrix).getL(); for (int i = 0; i < l.getRowDimension(); i++) { Assert.assertEquals(Fraction.ONE, l.getEntry(i, i)); for (int j = i + 1; j < l.getColumnDimension(); j++) { Assert.assertEquals(Fraction.ZERO, l.getEntry(i, j)); } } } /** test that U is upper triangular */ @Test public void testUUpperTriangular() { FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData); FieldMatrix<Fraction> u = new FieldLUDecomposition<Fraction>(matrix).getU(); for (int i = 0; i < u.getRowDimension(); i++) { for (int j = 0; j < i; j++) { Assert.assertEquals(Fraction.ZERO, u.getEntry(i, j)); } } } /** test that P is a permutation matrix */ @Test public void testPPermutation() { FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData); FieldMatrix<Fraction> p = new FieldLUDecomposition<Fraction>(matrix).getP(); FieldMatrix<Fraction> ppT = p.multiply(p.transpose()); FieldMatrix<Fraction> id = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), p.getRowDimension(), p.getRowDimension()); for (int i = 0; i < id.getRowDimension(); ++i) { id.setEntry(i, i, Fraction.ONE); } TestUtils.assertEquals(id, ppT); for (int i = 0; i < p.getRowDimension(); i++) { int zeroCount = 0; int oneCount = 0; int otherCount = 0; for (int j = 0; j < p.getColumnDimension(); j++) { final Fraction e = p.getEntry(i, j); if (e.equals(Fraction.ZERO)) { ++zeroCount; } else if (e.equals(Fraction.ONE)) { ++oneCount; } else { ++otherCount; } } Assert.assertEquals(p.getColumnDimension() - 1, zeroCount); Assert.assertEquals(1, oneCount); Assert.assertEquals(0, otherCount); } for (int j = 0; j < p.getColumnDimension(); j++) { int zeroCount = 0; int oneCount = 0; int otherCount = 0; for (int i = 0; i < p.getRowDimension(); i++) { final Fraction e = p.getEntry(i, j); if (e.equals(Fraction.ZERO)) { ++zeroCount; } else if (e.equals(Fraction.ONE)) { ++oneCount; } else { ++otherCount; } } Assert.assertEquals(p.getRowDimension() - 1, zeroCount); Assert.assertEquals(1, oneCount); Assert.assertEquals(0, otherCount); } } /** test singular */ @Test public void testSingular() { FieldLUDecomposition<Fraction> lu = new FieldLUDecomposition<Fraction>(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData)); Assert.assertTrue(lu.getSolver().isNonSingular()); lu = new FieldLUDecomposition<Fraction>(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), singular)); Assert.assertFalse(lu.getSolver().isNonSingular()); lu = new FieldLUDecomposition<Fraction>(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), bigSingular)); Assert.assertFalse(lu.getSolver().isNonSingular()); } /** test matrices values */ @Test public void testMatricesValues1() { FieldLUDecomposition<Fraction> lu = new FieldLUDecomposition<Fraction>(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData)); FieldMatrix<Fraction> lRef = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), new Fraction[][] { { new Fraction(1), new Fraction(0), new Fraction(0) }, { new Fraction(2), new Fraction(1), new Fraction(0) }, { new Fraction(1), new Fraction(-2), new Fraction(1) } }); FieldMatrix<Fraction> uRef = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), new Fraction[][] { { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(0), new Fraction(1), new Fraction(-3) }, { new Fraction(0), new Fraction(0), new Fraction(-1) } }); FieldMatrix<Fraction> pRef = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), new Fraction[][] { { new Fraction(1), new Fraction(0), new Fraction(0) }, { new Fraction(0), new Fraction(1), new Fraction(0) }, { new Fraction(0), new Fraction(0), new Fraction(1) } }); int[] pivotRef = { 0, 1, 2 }; // check values against known references FieldMatrix<Fraction> l = lu.getL(); TestUtils.assertEquals(lRef, l); FieldMatrix<Fraction> u = lu.getU(); TestUtils.assertEquals(uRef, u); FieldMatrix<Fraction> p = lu.getP(); TestUtils.assertEquals(pRef, p); int[] pivot = lu.getPivot(); for (int i = 0; i < pivotRef.length; ++i) { Assert.assertEquals(pivotRef[i], pivot[i]); } // check the same cached instance is returned the second time Assert.assertTrue(l == lu.getL()); Assert.assertTrue(u == lu.getU()); Assert.assertTrue(p == lu.getP()); } /** test matrices values */ @Test public void testMatricesValues2() { FieldLUDecomposition<Fraction> lu = new FieldLUDecomposition<Fraction>(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), luData)); FieldMatrix<Fraction> lRef = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), new Fraction[][] { { new Fraction(1), new Fraction(0), new Fraction(0) }, { new Fraction(3), new Fraction(1), new Fraction(0) }, { new Fraction(1), new Fraction(0), new Fraction(1) } }); FieldMatrix<Fraction> uRef = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), new Fraction[][] { { new Fraction(2), new Fraction(3), new Fraction(3) }, { new Fraction(0), new Fraction(-3), new Fraction(-1) }, { new Fraction(0), new Fraction(0), new Fraction(4) } }); FieldMatrix<Fraction> pRef = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), new Fraction[][] { { new Fraction(1), new Fraction(0), new Fraction(0) }, { new Fraction(0), new Fraction(0), new Fraction(1) }, { new Fraction(0), new Fraction(1), new Fraction(0) } }); int[] pivotRef = { 0, 2, 1 }; // check values against known references FieldMatrix<Fraction> l = lu.getL(); TestUtils.assertEquals(lRef, l); FieldMatrix<Fraction> u = lu.getU(); TestUtils.assertEquals(uRef, u); FieldMatrix<Fraction> p = lu.getP(); TestUtils.assertEquals(pRef, p); int[] pivot = lu.getPivot(); for (int i = 0; i < pivotRef.length; ++i) { Assert.assertEquals(pivotRef[i], pivot[i]); } // check the same cached instance is returned the second time Assert.assertTrue(l == lu.getL()); Assert.assertTrue(u == lu.getU()); Assert.assertTrue(p == lu.getP()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.fraction.Fraction; import org.apache.commons.math3.fraction.FractionField; import org.junit.Assert; import org.junit.Test; public class FieldLUSolverTest { private int[][] testData = { { 1, 2, 3}, { 2, 5, 3}, { 1, 0, 8} }; private int[][] luData = { { 2, 3, 3 }, { 0, 5, 7 }, { 6, 9, 8 } }; // singular matrices private int[][] singular = { { 2, 3 }, { 2, 3 } }; private int[][] bigSingular = { { 1, 2, 3, 4 }, { 2, 5, 3, 4 }, { 7, 3, 256, 1930 }, { 3, 7, 6, 8 } }; // 4th row = 1st + 2nd public static FieldMatrix<Fraction> createFractionMatrix(final int[][] data) { final int numRows = data.length; final int numCols = data[0].length; final Array2DRowFieldMatrix<Fraction> m; m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), numRows, numCols); for (int i = 0; i < numRows; i++) { for (int j = 0; j < numCols; j++) { m.setEntry(i, j, new Fraction(data[i][j], 1)); } } return m; } /** test singular */ @Test public void testSingular() { FieldDecompositionSolver<Fraction> solver; solver = new FieldLUDecomposition<Fraction>(createFractionMatrix(testData)) .getSolver(); Assert.assertTrue(solver.isNonSingular()); solver = new FieldLUDecomposition<Fraction>(createFractionMatrix(singular)) .getSolver(); Assert.assertFalse(solver.isNonSingular()); solver = new FieldLUDecomposition<Fraction>(createFractionMatrix(bigSingular)) .getSolver(); Assert.assertFalse(solver.isNonSingular()); } /** test solve dimension errors */ @Test public void testSolveDimensionErrors() { FieldDecompositionSolver<Fraction> solver; solver = new FieldLUDecomposition<Fraction>(createFractionMatrix(testData)) .getSolver(); FieldMatrix<Fraction> b = createFractionMatrix(new int[2][2]); try { solver.solve(b); Assert.fail("an exception should have been thrown"); } catch (MathIllegalArgumentException iae) { // expected behavior } try { solver.solve(b.getColumnVector(0)); Assert.fail("an exception should have been thrown"); } catch (MathIllegalArgumentException iae) { // expected behavior } } /** test solve singularity errors */ @Test public void testSolveSingularityErrors() { FieldDecompositionSolver<Fraction> solver; solver = new FieldLUDecomposition<Fraction>(createFractionMatrix(singular)) .getSolver(); FieldMatrix<Fraction> b = createFractionMatrix(new int[2][2]); try { solver.solve(b); Assert.fail("an exception should have been thrown"); } catch (SingularMatrixException ime) { // expected behavior } try { solver.solve(b.getColumnVector(0)); Assert.fail("an exception should have been thrown"); } catch (SingularMatrixException ime) { // expected behavior } } /** test solve */ @Test public void testSolve() { FieldDecompositionSolver<Fraction> solver; solver = new FieldLUDecomposition<Fraction>(createFractionMatrix(testData)) .getSolver(); FieldMatrix<Fraction> b = createFractionMatrix(new int[][] { { 1, 0 }, { 2, -5 }, { 3, 1 } }); FieldMatrix<Fraction> xRef = createFractionMatrix(new int[][] { { 19, -71 }, { -6, 22 }, { -2, 9 } }); // using FieldMatrix FieldMatrix<Fraction> x = solver.solve(b); for (int i = 0; i < x.getRowDimension(); i++){ for (int j = 0; j < x.getColumnDimension(); j++){ Assert.assertEquals("(" + i + ", " + j + ")", xRef.getEntry(i, j), x.getEntry(i, j)); } } // using ArrayFieldVector for (int j = 0; j < b.getColumnDimension(); j++) { final FieldVector<Fraction> xj = solver.solve(b.getColumnVector(j)); for (int i = 0; i < xj.getDimension(); i++){ Assert.assertEquals("(" + i + ", " + j + ")", xRef.getEntry(i, j), xj.getEntry(i)); } } // using SparseFieldVector for (int j = 0; j < b.getColumnDimension(); j++) { final SparseFieldVector<Fraction> bj; bj = new SparseFieldVector<Fraction>(FractionField.getInstance(), b.getColumn(j)); final FieldVector<Fraction> xj = solver.solve(bj); for (int i = 0; i < xj.getDimension(); i++) { Assert.assertEquals("(" + i + ", " + j + ")", xRef.getEntry(i, j), xj.getEntry(i)); } } } /** test determinant */ @Test public void testDeterminant() { Assert.assertEquals( -1, getDeterminant(createFractionMatrix(testData)), 1E-15); Assert.assertEquals(-10, getDeterminant(createFractionMatrix(luData)), 1E-14); Assert.assertEquals( 0, getDeterminant(createFractionMatrix(singular)), 1E-15); Assert.assertEquals( 0, getDeterminant(createFractionMatrix(bigSingular)), 1E-15); } private double getDeterminant(final FieldMatrix<Fraction> m) { return new FieldLUDecomposition<Fraction>(m).getDeterminant().doubleValue(); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import org.junit.Test; import org.junit.Assert; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.fraction.Fraction; import org.apache.commons.math3.fraction.FractionField; import org.apache.commons.math3.exception.MathIllegalStateException; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.NoDataException; import org.apache.commons.math3.exception.OutOfRangeException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.apache.commons.math3.exception.NullArgumentException; import org.apache.commons.math3.exception.MathIllegalArgumentException; /** * Test cases for the {@link Array2DRowFieldMatrix} class. * * @version $Id$ */ public final class FieldMatrixImplTest { // 3 x 3 identity matrix protected Fraction[][] id = { {new Fraction(1),new Fraction(0),new Fraction(0)}, {new Fraction(0),new Fraction(1),new Fraction(0)}, {new Fraction(0),new Fraction(0),new Fraction(1)} }; // Test data for group operations protected Fraction[][] testData = { {new Fraction(1),new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(5),new Fraction(3)}, {new Fraction(1),new Fraction(0),new Fraction(8)} }; protected Fraction[][] testDataLU = {{new Fraction(2), new Fraction(5), new Fraction(3)}, {new Fraction(1, 2), new Fraction(-5, 2), new Fraction(13, 2)}, {new Fraction(1, 2), new Fraction(1, 5), new Fraction(1, 5)}}; protected Fraction[][] testDataPlus2 = { {new Fraction(3),new Fraction(4),new Fraction(5)}, {new Fraction(4),new Fraction(7),new Fraction(5)}, {new Fraction(3),new Fraction(2),new Fraction(10)} }; protected Fraction[][] testDataMinus = { {new Fraction(-1),new Fraction(-2),new Fraction(-3)}, {new Fraction(-2),new Fraction(-5),new Fraction(-3)}, {new Fraction(-1),new Fraction(0),new Fraction(-8)} }; protected Fraction[] testDataRow1 = {new Fraction(1),new Fraction(2),new Fraction(3)}; protected Fraction[] testDataCol3 = {new Fraction(3),new Fraction(3),new Fraction(8)}; protected Fraction[][] testDataInv = { {new Fraction(-40),new Fraction(16),new Fraction(9)}, {new Fraction(13),new Fraction(-5),new Fraction(-3)}, {new Fraction(5),new Fraction(-2),new Fraction(-1)} }; protected Fraction[] preMultTest = {new Fraction(8),new Fraction(12),new Fraction(33)}; protected Fraction[][] testData2 ={ {new Fraction(1),new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(5),new Fraction(3)}}; protected Fraction[][] testData2T = { {new Fraction(1),new Fraction(2)}, {new Fraction(2),new Fraction(5)}, {new Fraction(3),new Fraction(3)}}; protected Fraction[][] testDataPlusInv = { {new Fraction(-39),new Fraction(18),new Fraction(12)}, {new Fraction(15),new Fraction(0),new Fraction(0)}, {new Fraction(6),new Fraction(-2),new Fraction(7)} }; // lu decomposition tests protected Fraction[][] luData = { {new Fraction(2),new Fraction(3),new Fraction(3)}, {new Fraction(0),new Fraction(5),new Fraction(7)}, {new Fraction(6),new Fraction(9),new Fraction(8)} }; protected Fraction[][] luDataLUDecomposition = { {new Fraction(6),new Fraction(9),new Fraction(8)}, {new Fraction(0),new Fraction(5),new Fraction(7)}, {new Fraction(1, 3),new Fraction(0),new Fraction(1, 3)} }; // singular matrices protected Fraction[][] singular = { {new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(3)} }; protected Fraction[][] bigSingular = {{new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)}, {new Fraction(2),new Fraction(5),new Fraction(3),new Fraction(4)}, {new Fraction(7),new Fraction(3),new Fraction(256),new Fraction(1930)}, {new Fraction(3),new Fraction(7),new Fraction(6),new Fraction(8)}}; // 4th row = 1st + 2nd protected Fraction[][] detData = { {new Fraction(1),new Fraction(2),new Fraction(3)}, {new Fraction(4),new Fraction(5),new Fraction(6)}, {new Fraction(7),new Fraction(8),new Fraction(10)} }; protected Fraction[][] detData2 = { {new Fraction(1), new Fraction(3)}, {new Fraction(2), new Fraction(4)}}; // vectors protected Fraction[] testVector = {new Fraction(1),new Fraction(2),new Fraction(3)}; protected Fraction[] testVector2 = {new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)}; // submatrix accessor tests protected Fraction[][] subTestData = {{new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4)}, {new Fraction(3, 2), new Fraction(5, 2), new Fraction(7, 2), new Fraction(9, 2)}, {new Fraction(2), new Fraction(4), new Fraction(6), new Fraction(8)}, {new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7)}}; // array selections protected Fraction[][] subRows02Cols13 = { {new Fraction(2), new Fraction(4)}, {new Fraction(4), new Fraction(8)}}; protected Fraction[][] subRows03Cols12 = { {new Fraction(2), new Fraction(3)}, {new Fraction(5), new Fraction(6)}}; protected Fraction[][] subRows03Cols123 = { {new Fraction(2), new Fraction(3), new Fraction(4)} , {new Fraction(5), new Fraction(6), new Fraction(7)}}; // effective permutations protected Fraction[][] subRows20Cols123 = { {new Fraction(4), new Fraction(6), new Fraction(8)} , {new Fraction(2), new Fraction(3), new Fraction(4)}}; protected Fraction[][] subRows31Cols31 = {{new Fraction(7), new Fraction(5)}, {new Fraction(9, 2), new Fraction(5, 2)}}; // contiguous ranges protected Fraction[][] subRows01Cols23 = {{new Fraction(3),new Fraction(4)} , {new Fraction(7, 2), new Fraction(9, 2)}}; protected Fraction[][] subRows23Cols00 = {{new Fraction(2)} , {new Fraction(4)}}; protected Fraction[][] subRows00Cols33 = {{new Fraction(4)}}; // row matrices protected Fraction[][] subRow0 = {{new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)}}; protected Fraction[][] subRow3 = {{new Fraction(4),new Fraction(5),new Fraction(6),new Fraction(7)}}; // column matrices protected Fraction[][] subColumn1 = {{new Fraction(2)}, {new Fraction(5, 2)}, {new Fraction(4)}, {new Fraction(5)}}; protected Fraction[][] subColumn3 = {{new Fraction(4)}, {new Fraction(9, 2)}, {new Fraction(8)}, {new Fraction(7)}}; // tolerances protected double entryTolerance = 10E-16; protected double normTolerance = 10E-14; /** test dimensions */ @Test public void testDimensions() { Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData); Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(testData2); Assert.assertEquals("testData row dimension",3,m.getRowDimension()); Assert.assertEquals("testData column dimension",3,m.getColumnDimension()); Assert.assertTrue("testData is square",m.isSquare()); Assert.assertEquals("testData2 row dimension",m2.getRowDimension(),2); Assert.assertEquals("testData2 column dimension",m2.getColumnDimension(),3); Assert.assertTrue("testData2 is not square",!m2.isSquare()); } /** test copy functions */ @Test public void testCopyFunctions() { Array2DRowFieldMatrix<Fraction> m1 = new Array2DRowFieldMatrix<Fraction>(testData); Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(m1.getData()); Assert.assertEquals(m2,m1); Array2DRowFieldMatrix<Fraction> m3 = new Array2DRowFieldMatrix<Fraction>(testData); Array2DRowFieldMatrix<Fraction> m4 = new Array2DRowFieldMatrix<Fraction>(m3.getData(), false); Assert.assertEquals(m4,m3); } /** test add */ @Test public void testAdd() { Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData); Array2DRowFieldMatrix<Fraction> mInv = new Array2DRowFieldMatrix<Fraction>(testDataInv); FieldMatrix<Fraction> mPlusMInv = m.add(mInv); Fraction[][] sumEntries = mPlusMInv.getData(); for (int row = 0; row < m.getRowDimension(); row++) { for (int col = 0; col < m.getColumnDimension(); col++) { Assert.assertEquals(testDataPlusInv[row][col],sumEntries[row][col]); } } } /** test add failure */ @Test public void testAddFail() { Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData); Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(testData2); try { m.add(m2); Assert.fail("MathIllegalArgumentException expected"); } catch (MathIllegalArgumentException ex) { // ignored } } /** test m-n = m + -n */ @Test public void testPlusMinus() { Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData); Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(testDataInv); TestUtils.assertEquals(m.subtract(m2),m2.scalarMultiply(new Fraction(-1)).add(m)); try { m.subtract(new Array2DRowFieldMatrix<Fraction>(testData2)); Assert.fail("Expecting illegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } } /** test multiply */ @Test public void testMultiply() { Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData); Array2DRowFieldMatrix<Fraction> mInv = new Array2DRowFieldMatrix<Fraction>(testDataInv); Array2DRowFieldMatrix<Fraction> identity = new Array2DRowFieldMatrix<Fraction>(id); Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(testData2); TestUtils.assertEquals(m.multiply(mInv), identity); TestUtils.assertEquals(mInv.multiply(m), identity); TestUtils.assertEquals(m.multiply(identity), m); TestUtils.assertEquals(identity.multiply(mInv), mInv); TestUtils.assertEquals(m2.multiply(identity), m2); try { m.multiply(new Array2DRowFieldMatrix<Fraction>(bigSingular)); Assert.fail("Expecting illegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } } //Additional Test for Array2DRowFieldMatrix<Fraction>Test.testMultiply private Fraction[][] d3 = new Fraction[][] {{new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)},{new Fraction(5),new Fraction(6),new Fraction(7),new Fraction(8)}}; private Fraction[][] d4 = new Fraction[][] {{new Fraction(1)},{new Fraction(2)},{new Fraction(3)},{new Fraction(4)}}; private Fraction[][] d5 = new Fraction[][] {{new Fraction(30)},{new Fraction(70)}}; @Test public void testMultiply2() { FieldMatrix<Fraction> m3 = new Array2DRowFieldMatrix<Fraction>(d3); FieldMatrix<Fraction> m4 = new Array2DRowFieldMatrix<Fraction>(d4); FieldMatrix<Fraction> m5 = new Array2DRowFieldMatrix<Fraction>(d5); TestUtils.assertEquals(m3.multiply(m4), m5); } @Test public void testPower() { FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData); FieldMatrix<Fraction> mInv = new Array2DRowFieldMatrix<Fraction>(testDataInv); FieldMatrix<Fraction> mPlusInv = new Array2DRowFieldMatrix<Fraction>(testDataPlusInv); FieldMatrix<Fraction> identity = new Array2DRowFieldMatrix<Fraction>(id); TestUtils.assertEquals(m.power(0), identity); TestUtils.assertEquals(mInv.power(0), identity); TestUtils.assertEquals(mPlusInv.power(0), identity); TestUtils.assertEquals(m.power(1), m); TestUtils.assertEquals(mInv.power(1), mInv); TestUtils.assertEquals(mPlusInv.power(1), mPlusInv); FieldMatrix<Fraction> C1 = m.copy(); FieldMatrix<Fraction> C2 = mInv.copy(); FieldMatrix<Fraction> C3 = mPlusInv.copy(); // stop at 5 to avoid overflow for (int i = 2; i <= 5; ++i) { C1 = C1.multiply(m); C2 = C2.multiply(mInv); C3 = C3.multiply(mPlusInv); TestUtils.assertEquals(m.power(i), C1); TestUtils.assertEquals(mInv.power(i), C2); TestUtils.assertEquals(mPlusInv.power(i), C3); } try { FieldMatrix<Fraction> mNotSquare = new Array2DRowFieldMatrix<Fraction>(testData2T); mNotSquare.power(2); Assert.fail("Expecting NonSquareMatrixException"); } catch (NonSquareMatrixException ex) { // ignored } try { m.power(-1); Assert.fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // ignored } } /** test trace */ @Test public void testTrace() { FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(id); Assert.assertEquals("identity trace",new Fraction(3),m.getTrace()); m = new Array2DRowFieldMatrix<Fraction>(testData2); try { m.getTrace(); Assert.fail("Expecting NonSquareMatrixException"); } catch (NonSquareMatrixException ex) { // ignored } } /** test sclarAdd */ @Test public void testScalarAdd() { FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData); TestUtils.assertEquals(new Array2DRowFieldMatrix<Fraction>(testDataPlus2), m.scalarAdd(new Fraction(2))); } /** test operate */ @Test public void testOperate() { FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(id); TestUtils.assertEquals(testVector, m.operate(testVector)); TestUtils.assertEquals(testVector, m.operate(new ArrayFieldVector<Fraction>(testVector)).getData()); m = new Array2DRowFieldMatrix<Fraction>(bigSingular); try { m.operate(testVector); Assert.fail("Expecting illegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } } /** test issue MATH-209 */ @Test public void testMath209() { FieldMatrix<Fraction> a = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] { { new Fraction(1), new Fraction(2) }, { new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6) } }, false); Fraction[] b = a.operate(new Fraction[] { new Fraction(1), new Fraction(1) }); Assert.assertEquals(a.getRowDimension(), b.length); Assert.assertEquals( new Fraction(3), b[0]); Assert.assertEquals( new Fraction(7), b[1]); Assert.assertEquals(new Fraction(11), b[2]); } /** test transpose */ @Test public void testTranspose() { FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData); FieldMatrix<Fraction> mIT = new FieldLUDecomposition<Fraction>(m).getSolver().getInverse().transpose(); FieldMatrix<Fraction> mTI = new FieldLUDecomposition<Fraction>(m.transpose()).getSolver().getInverse(); TestUtils.assertEquals(mIT, mTI); m = new Array2DRowFieldMatrix<Fraction>(testData2); FieldMatrix<Fraction> mt = new Array2DRowFieldMatrix<Fraction>(testData2T); TestUtils.assertEquals(mt, m.transpose()); } /** test preMultiply by vector */ @Test public void testPremultiplyVector() { FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData); TestUtils.assertEquals(m.preMultiply(testVector), preMultTest); TestUtils.assertEquals(m.preMultiply(new ArrayFieldVector<Fraction>(testVector).getData()), preMultTest); m = new Array2DRowFieldMatrix<Fraction>(bigSingular); try { m.preMultiply(testVector); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } } @Test public void testPremultiply() { FieldMatrix<Fraction> m3 = new Array2DRowFieldMatrix<Fraction>(d3); FieldMatrix<Fraction> m4 = new Array2DRowFieldMatrix<Fraction>(d4); FieldMatrix<Fraction> m5 = new Array2DRowFieldMatrix<Fraction>(d5); TestUtils.assertEquals(m4.preMultiply(m3), m5); Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData); Array2DRowFieldMatrix<Fraction> mInv = new Array2DRowFieldMatrix<Fraction>(testDataInv); Array2DRowFieldMatrix<Fraction> identity = new Array2DRowFieldMatrix<Fraction>(id); TestUtils.assertEquals(m.preMultiply(mInv), identity); TestUtils.assertEquals(mInv.preMultiply(m), identity); TestUtils.assertEquals(m.preMultiply(identity), m); TestUtils.assertEquals(identity.preMultiply(mInv), mInv); try { m.preMultiply(new Array2DRowFieldMatrix<Fraction>(bigSingular)); Assert.fail("Expecting illegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } } @Test public void testGetVectors() { FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData); TestUtils.assertEquals(m.getRow(0), testDataRow1); TestUtils.assertEquals(m.getColumn(2), testDataCol3); try { m.getRow(10); Assert.fail("expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // ignored } try { m.getColumn(-1); Assert.fail("expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // ignored } } @Test public void testGetEntry() { FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData); Assert.assertEquals("get entry", m.getEntry(0,1), new Fraction(2)); try { m.getEntry(10, 4); Assert.fail ("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } /** test examples in user guide */ @Test public void testExamples() { // Create a real matrix with two rows and three columns Fraction[][] matrixData = { {new Fraction(1),new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(5),new Fraction(3)} }; FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(matrixData); // One more with three rows, two columns Fraction[][] matrixData2 = { {new Fraction(1),new Fraction(2)}, {new Fraction(2),new Fraction(5)}, {new Fraction(1), new Fraction(7)} }; FieldMatrix<Fraction> n = new Array2DRowFieldMatrix<Fraction>(matrixData2); // Now multiply m by n FieldMatrix<Fraction> p = m.multiply(n); Assert.assertEquals(2, p.getRowDimension()); Assert.assertEquals(2, p.getColumnDimension()); // Invert p FieldMatrix<Fraction> pInverse = new FieldLUDecomposition<Fraction>(p).getSolver().getInverse(); Assert.assertEquals(2, pInverse.getRowDimension()); Assert.assertEquals(2, pInverse.getColumnDimension()); // Solve example Fraction[][] coefficientsData = { {new Fraction(2), new Fraction(3), new Fraction(-2)}, {new Fraction(-1), new Fraction(7), new Fraction(6)}, {new Fraction(4), new Fraction(-3), new Fraction(-5)} }; FieldMatrix<Fraction> coefficients = new Array2DRowFieldMatrix<Fraction>(coefficientsData); Fraction[] constants = { new Fraction(1), new Fraction(-2), new Fraction(1) }; Fraction[] solution; solution = new FieldLUDecomposition<Fraction>(coefficients) .getSolver() .solve(new ArrayFieldVector<Fraction>(constants, false)).toArray(); Assert.assertEquals(new Fraction(2).multiply(solution[0]). add(new Fraction(3).multiply(solution[1])). subtract(new Fraction(2).multiply(solution[2])), constants[0]); Assert.assertEquals(new Fraction(-1).multiply(solution[0]). add(new Fraction(7).multiply(solution[1])). add(new Fraction(6).multiply(solution[2])), constants[1]); Assert.assertEquals(new Fraction(4).multiply(solution[0]). subtract(new Fraction(3).multiply(solution[1])). subtract(new Fraction(5).multiply(solution[2])), constants[2]); } // test submatrix accessors @Test public void testGetSubMatrix() { FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData); checkGetSubMatrix(m, subRows23Cols00, 2 , 3 , 0, 0); checkGetSubMatrix(m, subRows00Cols33, 0 , 0 , 3, 3); checkGetSubMatrix(m, subRows01Cols23, 0 , 1 , 2, 3); checkGetSubMatrix(m, subRows02Cols13, new int[] { 0, 2 }, new int[] { 1, 3 }); checkGetSubMatrix(m, subRows03Cols12, new int[] { 0, 3 }, new int[] { 1, 2 }); checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }); checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }); checkGetSubMatrix(m, subRows31Cols31, new int[] { 3, 1 }, new int[] { 3, 1 }); checkGetSubMatrix(m, subRows31Cols31, new int[] { 3, 1 }, new int[] { 3, 1 }); checkGetSubMatrix(m, null, 1, 0, 2, 4); checkGetSubMatrix(m, null, -1, 1, 2, 2); checkGetSubMatrix(m, null, 1, 0, 2, 2); checkGetSubMatrix(m, null, 1, 0, 2, 4); checkGetSubMatrix(m, null, new int[] {}, new int[] { 0 }); checkGetSubMatrix(m, null, new int[] { 0 }, new int[] { 4 }); } private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference, int startRow, int endRow, int startColumn, int endColumn) { try { FieldMatrix<Fraction> sub = m.getSubMatrix(startRow, endRow, startColumn, endColumn); if (reference != null) { Assert.assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), sub); } else { Assert.fail("Expecting OutOfRangeException or NotStrictlyPositiveException" + " or NumberIsTooSmallException or NoDataException"); } } catch (OutOfRangeException e) { if (reference != null) { throw e; } } catch (NotStrictlyPositiveException e) { if (reference != null) { throw e; } } catch (NumberIsTooSmallException e) { if (reference != null) { throw e; } } catch (NoDataException e) { if (reference != null) { throw e; } } } private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference, int[] selectedRows, int[] selectedColumns) { try { FieldMatrix<Fraction> sub = m.getSubMatrix(selectedRows, selectedColumns); if (reference != null) { Assert.assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), sub); } else { Assert.fail("Expecting OutOfRangeException or NotStrictlyPositiveException" + " or NumberIsTooSmallException or NoDataException"); } } catch (OutOfRangeException e) { if (reference != null) { throw e; } } catch (NotStrictlyPositiveException e) { if (reference != null) { throw e; } } catch (NumberIsTooSmallException e) { if (reference != null) { throw e; } } catch (NoDataException e) { if (reference != null) { throw e; } } } @Test public void testCopySubMatrix() { FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData); checkCopy(m, subRows23Cols00, 2 , 3 , 0, 0); checkCopy(m, subRows00Cols33, 0 , 0 , 3, 3); checkCopy(m, subRows01Cols23, 0 , 1 , 2, 3); checkCopy(m, subRows02Cols13, new int[] { 0, 2 }, new int[] { 1, 3 }); checkCopy(m, subRows03Cols12, new int[] { 0, 3 }, new int[] { 1, 2 }); checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }); checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }); checkCopy(m, subRows31Cols31, new int[] { 3, 1 }, new int[] { 3, 1 }); checkCopy(m, subRows31Cols31, new int[] { 3, 1 }, new int[] { 3, 1 }); checkCopy(m, null, 1, 0, 2, 4); checkCopy(m, null, -1, 1, 2, 2); checkCopy(m, null, 1, 0, 2, 2); checkCopy(m, null, 1, 0, 2, 4); checkCopy(m, null, new int[] {}, new int[] { 0 }); checkCopy(m, null, new int[] { 0 }, new int[] { 4 }); } private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference, int startRow, int endRow, int startColumn, int endColumn) { try { Fraction[][] sub = (reference == null) ? new Fraction[1][1] : new Fraction[reference.length][reference[0].length]; m.copySubMatrix(startRow, endRow, startColumn, endColumn, sub); if (reference != null) { Assert.assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), new Array2DRowFieldMatrix<Fraction>(sub)); } else { Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException"); } } catch (OutOfRangeException e) { if (reference != null) { throw e; } } catch (NumberIsTooSmallException e) { if (reference != null) { throw e; } } catch (NoDataException e) { if (reference != null) { throw e; } } } private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference, int[] selectedRows, int[] selectedColumns) { try { Fraction[][] sub = (reference == null) ? new Fraction[1][1] : new Fraction[reference.length][reference[0].length]; m.copySubMatrix(selectedRows, selectedColumns, sub); if (reference != null) { Assert.assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), new Array2DRowFieldMatrix<Fraction>(sub)); } else { Assert.fail("Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException"); } } catch (OutOfRangeException e) { if (reference != null) { throw e; } } catch (NumberIsTooSmallException e) { if (reference != null) { throw e; } } catch (NoDataException e) { if (reference != null) { throw e; } } } @Test public void testGetRowMatrix() { FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData); FieldMatrix<Fraction> mRow0 = new Array2DRowFieldMatrix<Fraction>(subRow0); FieldMatrix<Fraction> mRow3 = new Array2DRowFieldMatrix<Fraction>(subRow3); Assert.assertEquals("Row0", mRow0, m.getRowMatrix(0)); Assert.assertEquals("Row3", mRow3, m.getRowMatrix(3)); try { m.getRowMatrix(-1); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getRowMatrix(4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testSetRowMatrix() { FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData); FieldMatrix<Fraction> mRow3 = new Array2DRowFieldMatrix<Fraction>(subRow3); Assert.assertNotSame(mRow3, m.getRowMatrix(0)); m.setRowMatrix(0, mRow3); Assert.assertEquals(mRow3, m.getRowMatrix(0)); try { m.setRowMatrix(-1, mRow3); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.setRowMatrix(0, m); Assert.fail("Expecting MatrixDimensionMismatchException"); } catch (MatrixDimensionMismatchException ex) { // expected } } @Test public void testGetColumnMatrix() { FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData); FieldMatrix<Fraction> mColumn1 = new Array2DRowFieldMatrix<Fraction>(subColumn1); FieldMatrix<Fraction> mColumn3 = new Array2DRowFieldMatrix<Fraction>(subColumn3); Assert.assertEquals("Column1", mColumn1, m.getColumnMatrix(1)); Assert.assertEquals("Column3", mColumn3, m.getColumnMatrix(3)); try { m.getColumnMatrix(-1); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getColumnMatrix(4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testSetColumnMatrix() { FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData); FieldMatrix<Fraction> mColumn3 = new Array2DRowFieldMatrix<Fraction>(subColumn3); Assert.assertNotSame(mColumn3, m.getColumnMatrix(1)); m.setColumnMatrix(1, mColumn3); Assert.assertEquals(mColumn3, m.getColumnMatrix(1)); try { m.setColumnMatrix(-1, mColumn3); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.setColumnMatrix(0, m); Assert.fail("Expecting MatrixDimensionMismatchException"); } catch (MatrixDimensionMismatchException ex) { // expected } } @Test public void testGetRowVector() { FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData); FieldVector<Fraction> mRow0 = new ArrayFieldVector<Fraction>(subRow0[0]); FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]); Assert.assertEquals("Row0", mRow0, m.getRowVector(0)); Assert.assertEquals("Row3", mRow3, m.getRowVector(3)); try { m.getRowVector(-1); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getRowVector(4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testSetRowVector() { FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData); FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]); Assert.assertNotSame(mRow3, m.getRowMatrix(0)); m.setRowVector(0, mRow3); Assert.assertEquals(mRow3, m.getRowVector(0)); try { m.setRowVector(-1, mRow3); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.setRowVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5)); Assert.fail("Expecting MatrixDimensionMismatchException"); } catch (MatrixDimensionMismatchException ex) { // expected } } @Test public void testGetColumnVector() { FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData); FieldVector<Fraction> mColumn1 = columnToVector(subColumn1); FieldVector<Fraction> mColumn3 = columnToVector(subColumn3); Assert.assertEquals("Column1", mColumn1, m.getColumnVector(1)); Assert.assertEquals("Column3", mColumn3, m.getColumnVector(3)); try { m.getColumnVector(-1); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getColumnVector(4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testSetColumnVector() { FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData); FieldVector<Fraction> mColumn3 = columnToVector(subColumn3); Assert.assertNotSame(mColumn3, m.getColumnVector(1)); m.setColumnVector(1, mColumn3); Assert.assertEquals(mColumn3, m.getColumnVector(1)); try { m.setColumnVector(-1, mColumn3); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.setColumnVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5)); Assert.fail("Expecting MatrixDimensionMismatchException"); } catch (MatrixDimensionMismatchException ex) { // expected } } private FieldVector<Fraction> columnToVector(Fraction[][] column) { Fraction[] data = new Fraction[column.length]; for (int i = 0; i < data.length; ++i) { data[i] = column[i][0]; } return new ArrayFieldVector<Fraction>(data, false); } @Test public void testGetRow() { FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData); checkArrays(subRow0[0], m.getRow(0)); checkArrays(subRow3[0], m.getRow(3)); try { m.getRow(-1); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getRow(4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testSetRow() { FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData); Assert.assertTrue(subRow3[0][0] != m.getRow(0)[0]); m.setRow(0, subRow3[0]); checkArrays(subRow3[0], m.getRow(0)); try { m.setRow(-1, subRow3[0]); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.setRow(0, new Fraction[5]); Assert.fail("Expecting MatrixDimensionMismatchException"); } catch (MatrixDimensionMismatchException ex) { // expected } } @Test public void testGetColumn() { FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData); Fraction[] mColumn1 = columnToArray(subColumn1); Fraction[] mColumn3 = columnToArray(subColumn3); checkArrays(mColumn1, m.getColumn(1)); checkArrays(mColumn3, m.getColumn(3)); try { m.getColumn(-1); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getColumn(4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testSetColumn() { FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData); Fraction[] mColumn3 = columnToArray(subColumn3); Assert.assertTrue(mColumn3[0] != m.getColumn(1)[0]); m.setColumn(1, mColumn3); checkArrays(mColumn3, m.getColumn(1)); try { m.setColumn(-1, mColumn3); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.setColumn(0, new Fraction[5]); Assert.fail("Expecting MatrixDimensionMismatchException"); } catch (MatrixDimensionMismatchException ex) { // expected } } private Fraction[] columnToArray(Fraction[][] column) { Fraction[] data = new Fraction[column.length]; for (int i = 0; i < data.length; ++i) { data[i] = column[i][0]; } return data; } private void checkArrays(Fraction[] expected, Fraction[] actual) { Assert.assertEquals(expected.length, actual.length); for (int i = 0; i < expected.length; ++i) { Assert.assertEquals(expected[i], actual[i]); } } @Test public void testEqualsAndHashCode() { Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData); Array2DRowFieldMatrix<Fraction> m1 = (Array2DRowFieldMatrix<Fraction>) m.copy(); Array2DRowFieldMatrix<Fraction> mt = (Array2DRowFieldMatrix<Fraction>) m.transpose(); Assert.assertTrue(m.hashCode() != mt.hashCode()); Assert.assertEquals(m.hashCode(), m1.hashCode()); Assert.assertEquals(m, m); Assert.assertEquals(m, m1); Assert.assertFalse(m.equals(null)); Assert.assertFalse(m.equals(mt)); Assert.assertFalse(m.equals(new Array2DRowFieldMatrix<Fraction>(bigSingular))); } @Test public void testToString() { Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData); Assert.assertEquals("Array2DRowFieldMatrix{{1,2,3},{2,5,3},{1,0,8}}", m.toString()); m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance()); Assert.assertEquals("Array2DRowFieldMatrix{}", m.toString()); } @Test public void testSetSubMatrix() { Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData); m.setSubMatrix(detData2,1,1); FieldMatrix<Fraction> expected = new Array2DRowFieldMatrix<Fraction> (new Fraction[][] { {new Fraction(1),new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(1),new Fraction(3)}, {new Fraction(1),new Fraction(2),new Fraction(4)} }); Assert.assertEquals(expected, m); m.setSubMatrix(detData2,0,0); expected = new Array2DRowFieldMatrix<Fraction> (new Fraction[][] { {new Fraction(1),new Fraction(3),new Fraction(3)}, {new Fraction(2),new Fraction(4),new Fraction(3)}, {new Fraction(1),new Fraction(2),new Fraction(4)} }); Assert.assertEquals(expected, m); m.setSubMatrix(testDataPlus2,0,0); expected = new Array2DRowFieldMatrix<Fraction> (new Fraction[][] { {new Fraction(3),new Fraction(4),new Fraction(5)}, {new Fraction(4),new Fraction(7),new Fraction(5)}, {new Fraction(3),new Fraction(2),new Fraction(10)} }); Assert.assertEquals(expected, m); // dimension overflow try { m.setSubMatrix(testData,1,1); Assert.fail("expecting OutOfRangeException"); } catch (OutOfRangeException e) { // expected } // dimension underflow try { m.setSubMatrix(testData,-1,1); Assert.fail("expecting OutOfRangeException"); } catch (OutOfRangeException e) { // expected } try { m.setSubMatrix(testData,1,-1); Assert.fail("expecting OutOfRangeException"); } catch (OutOfRangeException e) { // expected } // null try { m.setSubMatrix(null, 1, 1); Assert.fail("expecting NullArgumentException"); } catch (NullArgumentException e) { // expected } Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance()); try { m2.setSubMatrix(testData,0,1); Assert.fail("expecting MathIllegalStateException"); } catch (MathIllegalStateException e) { // expected } try { m2.setSubMatrix(testData,1,0); Assert.fail("expecting MathIllegalStateException"); } catch (MathIllegalStateException e) { // expected } // ragged try { m.setSubMatrix(new Fraction[][] {{new Fraction(1)}, {new Fraction(2), new Fraction(3)}}, 0, 0); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException e) { // expected } // empty try { m.setSubMatrix(new Fraction[][] {{}}, 0, 0); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException e) { // expected } } @Test public void testWalk() { int rows = 150; int columns = 75; FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns); m.walkInRowOrder(new SetVisitor()); GetVisitor getVisitor = new GetVisitor(); m.walkInOptimizedOrder(getVisitor); Assert.assertEquals(rows * columns, getVisitor.getCount()); m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns); m.walkInRowOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2); getVisitor = new GetVisitor(); m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2); Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount()); for (int i = 0; i < rows; ++i) { Assert.assertEquals(new Fraction(0), m.getEntry(i, 0)); Assert.assertEquals(new Fraction(0), m.getEntry(i, columns - 1)); } for (int j = 0; j < columns; ++j) { Assert.assertEquals(new Fraction(0), m.getEntry(0, j)); Assert.assertEquals(new Fraction(0), m.getEntry(rows - 1, j)); } m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns); m.walkInColumnOrder(new SetVisitor()); getVisitor = new GetVisitor(); m.walkInOptimizedOrder(getVisitor); Assert.assertEquals(rows * columns, getVisitor.getCount()); m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns); m.walkInColumnOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2); getVisitor = new GetVisitor(); m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2); Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount()); for (int i = 0; i < rows; ++i) { Assert.assertEquals(new Fraction(0), m.getEntry(i, 0)); Assert.assertEquals(new Fraction(0), m.getEntry(i, columns - 1)); } for (int j = 0; j < columns; ++j) { Assert.assertEquals(new Fraction(0), m.getEntry(0, j)); Assert.assertEquals(new Fraction(0), m.getEntry(rows - 1, j)); } m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns); m.walkInOptimizedOrder(new SetVisitor()); getVisitor = new GetVisitor(); m.walkInRowOrder(getVisitor); Assert.assertEquals(rows * columns, getVisitor.getCount()); m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns); m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2); getVisitor = new GetVisitor(); m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2); Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount()); for (int i = 0; i < rows; ++i) { Assert.assertEquals(new Fraction(0), m.getEntry(i, 0)); Assert.assertEquals(new Fraction(0), m.getEntry(i, columns - 1)); } for (int j = 0; j < columns; ++j) { Assert.assertEquals(new Fraction(0), m.getEntry(0, j)); Assert.assertEquals(new Fraction(0), m.getEntry(rows - 1, j)); } m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns); m.walkInOptimizedOrder(new SetVisitor()); getVisitor = new GetVisitor(); m.walkInColumnOrder(getVisitor); Assert.assertEquals(rows * columns, getVisitor.getCount()); m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), rows, columns); m.walkInOptimizedOrder(new SetVisitor(), 1, rows - 2, 1, columns - 2); getVisitor = new GetVisitor(); m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2); Assert.assertEquals((rows - 2) * (columns - 2), getVisitor.getCount()); for (int i = 0; i < rows; ++i) { Assert.assertEquals(new Fraction(0), m.getEntry(i, 0)); Assert.assertEquals(new Fraction(0), m.getEntry(i, columns - 1)); } for (int j = 0; j < columns; ++j) { Assert.assertEquals(new Fraction(0), m.getEntry(0, j)); Assert.assertEquals(new Fraction(0), m.getEntry(rows - 1, j)); } } @Test public void testSerial() { Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData); Assert.assertEquals(m,TestUtils.serializeAndRecover(m)); } private static class SetVisitor extends DefaultFieldMatrixChangingVisitor<Fraction> { public SetVisitor() { super(Fraction.ZERO); } @Override public Fraction visit(int i, int j, Fraction value) { return new Fraction(i * 1024 + j, 1024); } } private static class GetVisitor extends DefaultFieldMatrixPreservingVisitor<Fraction> { private int count; public GetVisitor() { super(Fraction.ZERO); count = 0; } @Override public void visit(int i, int j, Fraction value) { ++count; Assert.assertEquals(new Fraction(i * 1024 + j, 1024), value); } public int getCount() { return count; } } //--------------- -----------------Protected methods /** extracts the l and u matrices from compact lu representation */ protected void splitLU(FieldMatrix<Fraction> lu, Fraction[][] lowerData, Fraction[][] upperData) { if (!lu.isSquare()) { throw new NonSquareMatrixException(lu.getRowDimension(), lu.getColumnDimension()); } if (lowerData.length != lowerData[0].length) { throw new DimensionMismatchException(lowerData.length, lowerData[0].length); } if (upperData.length != upperData[0].length) { throw new DimensionMismatchException(upperData.length, upperData[0].length); } if (lowerData.length != upperData.length) { throw new DimensionMismatchException(lowerData.length, upperData.length); } if (lowerData.length != lu.getRowDimension()) { throw new DimensionMismatchException(lowerData.length, lu.getRowDimension()); } int n = lu.getRowDimension(); for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { if (j < i) { lowerData[i][j] = lu.getEntry(i, j); upperData[i][j] = Fraction.ZERO; } else if (i == j) { lowerData[i][j] = Fraction.ONE; upperData[i][j] = lu.getEntry(i, j); } else { lowerData[i][j] = Fraction.ZERO; upperData[i][j] = lu.getEntry(i, j); } } } } /** Returns the result of applying the given row permutation to the matrix */ protected FieldMatrix<Fraction> permuteRows(FieldMatrix<Fraction> matrix, int[] permutation) { if (!matrix.isSquare()) { throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension()); } if (matrix.getRowDimension() != permutation.length) { throw new DimensionMismatchException(matrix.getRowDimension(), permutation.length); } int n = matrix.getRowDimension(); int m = matrix.getColumnDimension(); Fraction out[][] = new Fraction[m][n]; for (int i = 0; i < n; i++) { for (int j = 0; j < m; j++) { out[i][j] = matrix.getEntry(permutation[i], j); } } return new Array2DRowFieldMatrix<Fraction>(out); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import java.util.Locale; public class FrenchRealVectorFormatTest extends RealVectorFormatAbstractTest { @Override protected char getDecimalCharacter() { return ','; } @Override protected Locale getLocale() { return Locale.FRENCH; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import java.util.Random; import org.apache.commons.math3.distribution.NormalDistribution; import org.junit.Test; import org.junit.Assert; public class HessenbergTransformerTest { private double[][] testSquare5 = { { 5, 4, 3, 2, 1 }, { 1, 4, 0, 3, 3 }, { 2, 0, 3, 0, 0 }, { 3, 2, 1, 2, 5 }, { 4, 2, 1, 4, 1 } }; private double[][] testSquare3 = { { 2, -1, 1 }, { -1, 2, 1 }, { 1, -1, 2 } }; // from http://eigen.tuxfamily.org/dox/classEigen_1_1HessenbergDecomposition.html private double[][] testRandom = { { 0.680, 0.823, -0.4440, -0.2700 }, { -0.211, -0.605, 0.1080, 0.0268 }, { 0.566, -0.330, -0.0452, 0.9040 }, { 0.597, 0.536, 0.2580, 0.8320 } }; @Test public void testNonSquare() { try { new HessenbergTransformer(MatrixUtils.createRealMatrix(new double[3][2])); Assert.fail("an exception should have been thrown"); } catch (NonSquareMatrixException ime) { // expected behavior } } @Test public void testAEqualPHPt() { checkAEqualPHPt(MatrixUtils.createRealMatrix(testSquare5)); checkAEqualPHPt(MatrixUtils.createRealMatrix(testSquare3)); checkAEqualPHPt(MatrixUtils.createRealMatrix(testRandom)); } @Test public void testPOrthogonal() { checkOrthogonal(new HessenbergTransformer(MatrixUtils.createRealMatrix(testSquare5)).getP()); checkOrthogonal(new HessenbergTransformer(MatrixUtils.createRealMatrix(testSquare3)).getP()); } @Test public void testPTOrthogonal() { checkOrthogonal(new HessenbergTransformer(MatrixUtils.createRealMatrix(testSquare5)).getPT()); checkOrthogonal(new HessenbergTransformer(MatrixUtils.createRealMatrix(testSquare3)).getPT()); } @Test public void testHessenbergForm() { checkHessenbergForm(new HessenbergTransformer(MatrixUtils.createRealMatrix(testSquare5)).getH()); checkHessenbergForm(new HessenbergTransformer(MatrixUtils.createRealMatrix(testSquare3)).getH()); } @Test public void testRandomData() { for (int run = 0; run < 100; run++) { Random r = new Random(System.currentTimeMillis()); // matrix size int size = r.nextInt(20) + 4; double[][] data = new double[size][size]; for (int i = 0; i < size; i++) { for (int j = 0; j < size; j++) { data[i][j] = r.nextInt(100); } } RealMatrix m = MatrixUtils.createRealMatrix(data); RealMatrix h = checkAEqualPHPt(m); checkHessenbergForm(h); } } @Test public void testRandomDataNormalDistribution() { for (int run = 0; run < 100; run++) { Random r = new Random(System.currentTimeMillis()); NormalDistribution dist = new NormalDistribution(0.0, r.nextDouble() * 5); // matrix size int size = r.nextInt(20) + 4; double[][] data = new double[size][size]; for (int i = 0; i < size; i++) { for (int j = 0; j < size; j++) { data[i][j] = dist.sample(); } } RealMatrix m = MatrixUtils.createRealMatrix(data); RealMatrix h = checkAEqualPHPt(m); checkHessenbergForm(h); } } @Test public void testMatricesValues5() { checkMatricesValues(testSquare5, new double[][] { { 1.0, 0.0, 0.0, 0.0, 0.0 }, { 0.0, -0.182574185835055, 0.784218758628863, 0.395029040913988, -0.442289115981669 }, { 0.0, -0.365148371670111, -0.337950625265477, -0.374110794088820, -0.782621974707823 }, { 0.0, -0.547722557505166, 0.402941130124223, -0.626468266309003, 0.381019628053472 }, { 0.0, -0.730296743340221, -0.329285224617644, 0.558149336547665, 0.216118545309225 } }, new double[][] { { 5.0, -3.65148371670111, 2.59962019434982, -0.237003414680848, -3.13886458663398 }, { -5.47722557505166, 6.9, -2.29164066120599, 0.207283564429169, 0.703858369151728 }, { 0.0, -4.21386600008432, 2.30555659846067, 2.74935928725112, 0.857569835914113 }, { 0.0, 0.0, 2.86406180891882, -1.11582249161595, 0.817995267184158 }, { 0.0, 0.0, 0.0, 0.683518597386085, 1.91026589315528 } }); } @Test public void testMatricesValues3() { checkMatricesValues(testSquare3, new double[][] { { 1.0, 0.0, 0.0 }, { 0.0, -0.707106781186547, 0.707106781186547 }, { 0.0, 0.707106781186547, 0.707106781186548 }, }, new double[][] { { 2.0, 1.41421356237309, 0.0 }, { 1.41421356237310, 2.0, -1.0 }, { 0.0, 1.0, 2.0 }, }); } /////////////////////////////////////////////////////////////////////////// // Test helpers /////////////////////////////////////////////////////////////////////////// private RealMatrix checkAEqualPHPt(RealMatrix matrix) { HessenbergTransformer transformer = new HessenbergTransformer(matrix); RealMatrix p = transformer.getP(); RealMatrix pT = transformer.getPT(); RealMatrix h = transformer.getH(); RealMatrix result = p.multiply(h).multiply(pT); double norm = result.subtract(matrix).getNorm(); Assert.assertEquals(0, norm, 1.0e-10); for (int i = 0; i < matrix.getRowDimension(); ++i) { for (int j = 0; j < matrix.getColumnDimension(); ++j) { if (i > j + 1) { Assert.assertEquals(matrix.getEntry(i, j), result.getEntry(i, j), 1.0e-12); } } } return transformer.getH(); } private void checkOrthogonal(RealMatrix m) { RealMatrix mTm = m.transpose().multiply(m); RealMatrix id = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension()); Assert.assertEquals(0, mTm.subtract(id).getNorm(), 1.0e-14); } private void checkHessenbergForm(RealMatrix m) { final int rows = m.getRowDimension(); final int cols = m.getColumnDimension(); for (int i = 0; i < rows; ++i) { for (int j = 0; j < cols; ++j) { if (i > j + 1) { Assert.assertEquals(0, m.getEntry(i, j), 1.0e-16); } } } } private void checkMatricesValues(double[][] matrix, double[][] pRef, double[][] hRef) { HessenbergTransformer transformer = new HessenbergTransformer(MatrixUtils.createRealMatrix(matrix)); // check values against known references RealMatrix p = transformer.getP(); Assert.assertEquals(0, p.subtract(MatrixUtils.createRealMatrix(pRef)).getNorm(), 1.0e-14); RealMatrix h = transformer.getH(); Assert.assertEquals(0, h.subtract(MatrixUtils.createRealMatrix(hRef)).getNorm(), 1.0e-14); // check the same cached instance is returned the second time Assert.assertTrue(p == transformer.getP()); Assert.assertTrue(h == transformer.getH()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import org.junit.Test; import org.junit.Assert; public class LUDecompositionTest { private double[][] testData = { { 1.0, 2.0, 3.0}, { 2.0, 5.0, 3.0}, { 1.0, 0.0, 8.0} }; private double[][] testDataMinus = { { -1.0, -2.0, -3.0}, { -2.0, -5.0, -3.0}, { -1.0, 0.0, -8.0} }; private double[][] luData = { { 2.0, 3.0, 3.0 }, { 0.0, 5.0, 7.0 }, { 6.0, 9.0, 8.0 } }; // singular matrices private double[][] singular = { { 2.0, 3.0 }, { 2.0, 3.0 } }; private double[][] bigSingular = { { 1.0, 2.0, 3.0, 4.0 }, { 2.0, 5.0, 3.0, 4.0 }, { 7.0, 3.0, 256.0, 1930.0 }, { 3.0, 7.0, 6.0, 8.0 } }; // 4th row = 1st + 2nd private static final double entryTolerance = 10e-16; private static final double normTolerance = 10e-14; /** test dimensions */ @Test public void testDimensions() { RealMatrix matrix = MatrixUtils.createRealMatrix(testData); LUDecomposition LU = new LUDecomposition(matrix); Assert.assertEquals(testData.length, LU.getL().getRowDimension()); Assert.assertEquals(testData.length, LU.getL().getColumnDimension()); Assert.assertEquals(testData.length, LU.getU().getRowDimension()); Assert.assertEquals(testData.length, LU.getU().getColumnDimension()); Assert.assertEquals(testData.length, LU.getP().getRowDimension()); Assert.assertEquals(testData.length, LU.getP().getColumnDimension()); } /** test non-square matrix */ @Test public void testNonSquare() { try { new LUDecomposition(MatrixUtils.createRealMatrix(new double[3][2])); Assert.fail("Expecting NonSquareMatrixException"); } catch (NonSquareMatrixException ime) { // expected behavior } } /** test PA = LU */ @Test public void testPAEqualLU() { RealMatrix matrix = MatrixUtils.createRealMatrix(testData); LUDecomposition lu = new LUDecomposition(matrix); RealMatrix l = lu.getL(); RealMatrix u = lu.getU(); RealMatrix p = lu.getP(); double norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm(); Assert.assertEquals(0, norm, normTolerance); matrix = MatrixUtils.createRealMatrix(testDataMinus); lu = new LUDecomposition(matrix); l = lu.getL(); u = lu.getU(); p = lu.getP(); norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm(); Assert.assertEquals(0, norm, normTolerance); matrix = MatrixUtils.createRealIdentityMatrix(17); lu = new LUDecomposition(matrix); l = lu.getL(); u = lu.getU(); p = lu.getP(); norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm(); Assert.assertEquals(0, norm, normTolerance); matrix = MatrixUtils.createRealMatrix(singular); lu = new LUDecomposition(matrix); Assert.assertFalse(lu.getSolver().isNonSingular()); Assert.assertNull(lu.getL()); Assert.assertNull(lu.getU()); Assert.assertNull(lu.getP()); matrix = MatrixUtils.createRealMatrix(bigSingular); lu = new LUDecomposition(matrix); Assert.assertFalse(lu.getSolver().isNonSingular()); Assert.assertNull(lu.getL()); Assert.assertNull(lu.getU()); Assert.assertNull(lu.getP()); } /** test that L is lower triangular with unit diagonal */ @Test public void testLLowerTriangular() { RealMatrix matrix = MatrixUtils.createRealMatrix(testData); RealMatrix l = new LUDecomposition(matrix).getL(); for (int i = 0; i < l.getRowDimension(); i++) { Assert.assertEquals(l.getEntry(i, i), 1, entryTolerance); for (int j = i + 1; j < l.getColumnDimension(); j++) { Assert.assertEquals(l.getEntry(i, j), 0, entryTolerance); } } } /** test that U is upper triangular */ @Test public void testUUpperTriangular() { RealMatrix matrix = MatrixUtils.createRealMatrix(testData); RealMatrix u = new LUDecomposition(matrix).getU(); for (int i = 0; i < u.getRowDimension(); i++) { for (int j = 0; j < i; j++) { Assert.assertEquals(u.getEntry(i, j), 0, entryTolerance); } } } /** test that P is a permutation matrix */ @Test public void testPPermutation() { RealMatrix matrix = MatrixUtils.createRealMatrix(testData); RealMatrix p = new LUDecomposition(matrix).getP(); RealMatrix ppT = p.multiply(p.transpose()); RealMatrix id = MatrixUtils.createRealIdentityMatrix(p.getRowDimension()); Assert.assertEquals(0, ppT.subtract(id).getNorm(), normTolerance); for (int i = 0; i < p.getRowDimension(); i++) { int zeroCount = 0; int oneCount = 0; int otherCount = 0; for (int j = 0; j < p.getColumnDimension(); j++) { final double e = p.getEntry(i, j); if (e == 0) { ++zeroCount; } else if (e == 1) { ++oneCount; } else { ++otherCount; } } Assert.assertEquals(p.getColumnDimension() - 1, zeroCount); Assert.assertEquals(1, oneCount); Assert.assertEquals(0, otherCount); } for (int j = 0; j < p.getColumnDimension(); j++) { int zeroCount = 0; int oneCount = 0; int otherCount = 0; for (int i = 0; i < p.getRowDimension(); i++) { final double e = p.getEntry(i, j); if (e == 0) { ++zeroCount; } else if (e == 1) { ++oneCount; } else { ++otherCount; } } Assert.assertEquals(p.getRowDimension() - 1, zeroCount); Assert.assertEquals(1, oneCount); Assert.assertEquals(0, otherCount); } } /** test singular */ @Test public void testSingular() { LUDecomposition lu = new LUDecomposition(MatrixUtils.createRealMatrix(testData)); Assert.assertTrue(lu.getSolver().isNonSingular()); lu = new LUDecomposition(MatrixUtils.createRealMatrix(singular)); Assert.assertFalse(lu.getSolver().isNonSingular()); lu = new LUDecomposition(MatrixUtils.createRealMatrix(bigSingular)); Assert.assertFalse(lu.getSolver().isNonSingular()); } /** test matrices values */ @Test public void testMatricesValues1() { LUDecomposition lu = new LUDecomposition(MatrixUtils.createRealMatrix(testData)); RealMatrix lRef = MatrixUtils.createRealMatrix(new double[][] { { 1.0, 0.0, 0.0 }, { 0.5, 1.0, 0.0 }, { 0.5, 0.2, 1.0 } }); RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] { { 2.0, 5.0, 3.0 }, { 0.0, -2.5, 6.5 }, { 0.0, 0.0, 0.2 } }); RealMatrix pRef = MatrixUtils.createRealMatrix(new double[][] { { 0.0, 1.0, 0.0 }, { 0.0, 0.0, 1.0 }, { 1.0, 0.0, 0.0 } }); int[] pivotRef = { 1, 2, 0 }; // check values against known references RealMatrix l = lu.getL(); Assert.assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13); RealMatrix u = lu.getU(); Assert.assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-13); RealMatrix p = lu.getP(); Assert.assertEquals(0, p.subtract(pRef).getNorm(), 1.0e-13); int[] pivot = lu.getPivot(); for (int i = 0; i < pivotRef.length; ++i) { Assert.assertEquals(pivotRef[i], pivot[i]); } // check the same cached instance is returned the second time Assert.assertTrue(l == lu.getL()); Assert.assertTrue(u == lu.getU()); Assert.assertTrue(p == lu.getP()); } /** test matrices values */ @Test public void testMatricesValues2() { LUDecomposition lu = new LUDecomposition(MatrixUtils.createRealMatrix(luData)); RealMatrix lRef = MatrixUtils.createRealMatrix(new double[][] { { 1.0, 0.0, 0.0 }, { 0.0, 1.0, 0.0 }, { 1.0 / 3.0, 0.0, 1.0 } }); RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] { { 6.0, 9.0, 8.0 }, { 0.0, 5.0, 7.0 }, { 0.0, 0.0, 1.0 / 3.0 } }); RealMatrix pRef = MatrixUtils.createRealMatrix(new double[][] { { 0.0, 0.0, 1.0 }, { 0.0, 1.0, 0.0 }, { 1.0, 0.0, 0.0 } }); int[] pivotRef = { 2, 1, 0 }; // check values against known references RealMatrix l = lu.getL(); Assert.assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13); RealMatrix u = lu.getU(); Assert.assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-13); RealMatrix p = lu.getP(); Assert.assertEquals(0, p.subtract(pRef).getNorm(), 1.0e-13); int[] pivot = lu.getPivot(); for (int i = 0; i < pivotRef.length; ++i) { Assert.assertEquals(pivotRef[i], pivot[i]); } // check the same cached instance is returned the second time Assert.assertTrue(l == lu.getL()); Assert.assertTrue(u == lu.getU()); Assert.assertTrue(p == lu.getP()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.junit.Test; import org.junit.Assert; public class LUSolverTest { private double[][] testData = { { 1.0, 2.0, 3.0}, { 2.0, 5.0, 3.0}, { 1.0, 0.0, 8.0} }; private double[][] luData = { { 2.0, 3.0, 3.0 }, { 0.0, 5.0, 7.0 }, { 6.0, 9.0, 8.0 } }; // singular matrices private double[][] singular = { { 2.0, 3.0 }, { 2.0, 3.0 } }; private double[][] bigSingular = { { 1.0, 2.0, 3.0, 4.0 }, { 2.0, 5.0, 3.0, 4.0 }, { 7.0, 3.0, 256.0, 1930.0 }, { 3.0, 7.0, 6.0, 8.0 } }; // 4th row = 1st + 2nd /** test threshold impact */ @Test public void testThreshold() { final RealMatrix matrix = MatrixUtils.createRealMatrix(new double[][] { { 1.0, 2.0, 3.0}, { 2.0, 5.0, 3.0}, { 4.000001, 9.0, 9.0} }); Assert.assertFalse(new LUDecomposition(matrix, 1.0e-5).getSolver().isNonSingular()); Assert.assertTrue(new LUDecomposition(matrix, 1.0e-10).getSolver().isNonSingular()); } /** test singular */ @Test public void testSingular() { DecompositionSolver solver = new LUDecomposition(MatrixUtils.createRealMatrix(testData)).getSolver(); Assert.assertTrue(solver.isNonSingular()); solver = new LUDecomposition(MatrixUtils.createRealMatrix(singular)).getSolver(); Assert.assertFalse(solver.isNonSingular()); solver = new LUDecomposition(MatrixUtils.createRealMatrix(bigSingular)).getSolver(); Assert.assertFalse(solver.isNonSingular()); } /** test solve dimension errors */ @Test public void testSolveDimensionErrors() { DecompositionSolver solver = new LUDecomposition(MatrixUtils.createRealMatrix(testData)).getSolver(); RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]); try { solver.solve(b); Assert.fail("an exception should have been thrown"); } catch (MathIllegalArgumentException iae) { // expected behavior } try { solver.solve(b.getColumnVector(0)); Assert.fail("an exception should have been thrown"); } catch (MathIllegalArgumentException iae) { // expected behavior } try { solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0))); Assert.fail("an exception should have been thrown"); } catch (MathIllegalArgumentException iae) { // expected behavior } } /** test solve singularity errors */ @Test public void testSolveSingularityErrors() { DecompositionSolver solver = new LUDecomposition(MatrixUtils.createRealMatrix(singular)).getSolver(); RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]); try { solver.solve(b); Assert.fail("an exception should have been thrown"); } catch (SingularMatrixException ime) { // expected behavior } try { solver.solve(b.getColumnVector(0)); Assert.fail("an exception should have been thrown"); } catch (SingularMatrixException ime) { // expected behavior } try { solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0))); Assert.fail("an exception should have been thrown"); } catch (SingularMatrixException ime) { // expected behavior } } /** test solve */ @Test public void testSolve() { DecompositionSolver solver = new LUDecomposition(MatrixUtils.createRealMatrix(testData)).getSolver(); RealMatrix b = MatrixUtils.createRealMatrix(new double[][] { { 1, 0 }, { 2, -5 }, { 3, 1 } }); RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] { { 19, -71 }, { -6, 22 }, { -2, 9 } }); // using RealMatrix Assert.assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 1.0e-13); // using ArrayRealVector for (int i = 0; i < b.getColumnDimension(); ++i) { Assert.assertEquals(0, solver.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(), 1.0e-13); } // using RealVector with an alternate implementation for (int i = 0; i < b.getColumnDimension(); ++i) { ArrayRealVectorTest.RealVectorTestImpl v = new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i)); Assert.assertEquals(0, solver.solve(v).subtract(xRef.getColumnVector(i)).getNorm(), 1.0e-13); } } /** test determinant */ @Test public void testDeterminant() { Assert.assertEquals( -1, getDeterminant(MatrixUtils.createRealMatrix(testData)), 1.0e-15); Assert.assertEquals(-10, getDeterminant(MatrixUtils.createRealMatrix(luData)), 1.0e-14); Assert.assertEquals( 0, getDeterminant(MatrixUtils.createRealMatrix(singular)), 1.0e-17); Assert.assertEquals( 0, getDeterminant(MatrixUtils.createRealMatrix(bigSingular)), 1.0e-10); } private double getDeterminant(RealMatrix m) { return new LUDecomposition(m).getDeterminant(); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import org.junit.Assert; import org.junit.Test; /** * Test for {@link MatrixDimensionMismatchException}. * * @version $Id$ */ public class MatrixDimensionMismatchExceptionTest { @Test public void testAccessors() { final MatrixDimensionMismatchException e = new MatrixDimensionMismatchException(1, 2, 3, 4); Assert.assertEquals(1, e.getWrongRowDimension()); Assert.assertEquals(2, e.getWrongColumnDimension()); Assert.assertEquals(3, e.getExpectedRowDimension()); Assert.assertEquals(4, e.getExpectedColumnDimension()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import java.math.BigDecimal; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.fraction.BigFraction; import org.apache.commons.math3.fraction.Fraction; import org.apache.commons.math3.fraction.FractionConversionException; import org.apache.commons.math3.fraction.FractionField; import org.apache.commons.math3.exception.NullArgumentException; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.junit.Assert; import org.junit.Test; /** * Test cases for the {@link MatrixUtils} class. * * @version $Id$ */ public final class MatrixUtilsTest { protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} }; protected double[][] nullMatrix = null; protected double[] row = {1,2,3}; protected BigDecimal[] bigRow = {new BigDecimal(1),new BigDecimal(2),new BigDecimal(3)}; protected String[] stringRow = {"1", "2", "3"}; protected Fraction[] fractionRow = {new Fraction(1),new Fraction(2),new Fraction(3)}; protected double[][] rowMatrix = {{1,2,3}}; protected BigDecimal[][] bigRowMatrix = {{new BigDecimal(1), new BigDecimal(2), new BigDecimal(3)}}; protected String[][] stringRowMatrix = {{"1", "2", "3"}}; protected Fraction[][] fractionRowMatrix = {{new Fraction(1), new Fraction(2), new Fraction(3)}}; protected double[] col = {0,4,6}; protected BigDecimal[] bigCol = {new BigDecimal(0),new BigDecimal(4),new BigDecimal(6)}; protected String[] stringCol = {"0","4","6"}; protected Fraction[] fractionCol = {new Fraction(0),new Fraction(4),new Fraction(6)}; protected double[] nullDoubleArray = null; protected double[][] colMatrix = {{0},{4},{6}}; protected BigDecimal[][] bigColMatrix = {{new BigDecimal(0)},{new BigDecimal(4)},{new BigDecimal(6)}}; protected String[][] stringColMatrix = {{"0"}, {"4"}, {"6"}}; protected Fraction[][] fractionColMatrix = {{new Fraction(0)},{new Fraction(4)},{new Fraction(6)}}; @Test public void testCreateRealMatrix() { Assert.assertEquals(new BlockRealMatrix(testData), MatrixUtils.createRealMatrix(testData)); try { MatrixUtils.createRealMatrix(new double[][] {{1}, {1,2}}); // ragged Assert.fail("Expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // expected } try { MatrixUtils.createRealMatrix(new double[][] {{}, {}}); // no columns Assert.fail("Expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // expected } try { MatrixUtils.createRealMatrix(null); // null Assert.fail("Expecting NullArgumentException"); } catch (NullArgumentException ex) { // expected } } @Test public void testcreateFieldMatrix() { Assert.assertEquals(new Array2DRowFieldMatrix<Fraction>(asFraction(testData)), MatrixUtils.createFieldMatrix(asFraction(testData))); Assert.assertEquals(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), fractionColMatrix), MatrixUtils.createFieldMatrix(fractionColMatrix)); try { MatrixUtils.createFieldMatrix(asFraction(new double[][] {{1}, {1,2}})); // ragged Assert.fail("Expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // expected } try { MatrixUtils.createFieldMatrix(asFraction(new double[][] {{}, {}})); // no columns Assert.fail("Expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // expected } try { MatrixUtils.createFieldMatrix((Fraction[][])null); // null Assert.fail("Expecting NullArgumentException"); } catch (NullArgumentException ex) { // expected } } @Test public void testCreateRowRealMatrix() { Assert.assertEquals(MatrixUtils.createRowRealMatrix(row), new BlockRealMatrix(rowMatrix)); try { MatrixUtils.createRowRealMatrix(new double[] {}); // empty Assert.fail("Expecting NotStrictlyPositiveException"); } catch (NotStrictlyPositiveException ex) { // expected } try { MatrixUtils.createRowRealMatrix(null); // null Assert.fail("Expecting NullArgumentException"); } catch (NullArgumentException ex) { // expected } } @Test public void testCreateRowFieldMatrix() { Assert.assertEquals(MatrixUtils.createRowFieldMatrix(asFraction(row)), new Array2DRowFieldMatrix<Fraction>(asFraction(rowMatrix))); Assert.assertEquals(MatrixUtils.createRowFieldMatrix(fractionRow), new Array2DRowFieldMatrix<Fraction>(fractionRowMatrix)); try { MatrixUtils.createRowFieldMatrix(new Fraction[] {}); // empty Assert.fail("Expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // expected } try { MatrixUtils.createRowFieldMatrix((Fraction[]) null); // null Assert.fail("Expecting NullArgumentException"); } catch (NullArgumentException ex) { // expected } } @Test public void testCreateColumnRealMatrix() { Assert.assertEquals(MatrixUtils.createColumnRealMatrix(col), new BlockRealMatrix(colMatrix)); try { MatrixUtils.createColumnRealMatrix(new double[] {}); // empty Assert.fail("Expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // expected } try { MatrixUtils.createColumnRealMatrix(null); // null Assert.fail("Expecting NullArgumentException"); } catch (NullArgumentException ex) { // expected } } @Test public void testCreateColumnFieldMatrix() { Assert.assertEquals(MatrixUtils.createColumnFieldMatrix(asFraction(col)), new Array2DRowFieldMatrix<Fraction>(asFraction(colMatrix))); Assert.assertEquals(MatrixUtils.createColumnFieldMatrix(fractionCol), new Array2DRowFieldMatrix<Fraction>(fractionColMatrix)); try { MatrixUtils.createColumnFieldMatrix(new Fraction[] {}); // empty Assert.fail("Expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // expected } try { MatrixUtils.createColumnFieldMatrix((Fraction[]) null); // null Assert.fail("Expecting NullArgumentException"); } catch (NullArgumentException ex) { // expected } } /** * Verifies that the matrix is an identity matrix */ protected void checkIdentityMatrix(RealMatrix m) { for (int i = 0; i < m.getRowDimension(); i++) { for (int j =0; j < m.getColumnDimension(); j++) { if (i == j) { Assert.assertEquals(m.getEntry(i, j), 1d, 0); } else { Assert.assertEquals(m.getEntry(i, j), 0d, 0); } } } } @Test public void testCreateIdentityMatrix() { checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(3)); checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(2)); checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(1)); try { MatrixUtils.createRealIdentityMatrix(0); Assert.fail("Expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // expected } } /** * Verifies that the matrix is an identity matrix */ protected void checkIdentityFieldMatrix(FieldMatrix<Fraction> m) { for (int i = 0; i < m.getRowDimension(); i++) { for (int j =0; j < m.getColumnDimension(); j++) { if (i == j) { Assert.assertEquals(m.getEntry(i, j), Fraction.ONE); } else { Assert.assertEquals(m.getEntry(i, j), Fraction.ZERO); } } } } @Test public void testcreateFieldIdentityMatrix() { checkIdentityFieldMatrix(MatrixUtils.createFieldIdentityMatrix(FractionField.getInstance(), 3)); checkIdentityFieldMatrix(MatrixUtils.createFieldIdentityMatrix(FractionField.getInstance(), 2)); checkIdentityFieldMatrix(MatrixUtils.createFieldIdentityMatrix(FractionField.getInstance(), 1)); try { MatrixUtils.createRealIdentityMatrix(0); Assert.fail("Expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // expected } } @Test public void testBigFractionConverter() { BigFraction[][] bfData = { { new BigFraction(1), new BigFraction(2), new BigFraction(3) }, { new BigFraction(2), new BigFraction(5), new BigFraction(3) }, { new BigFraction(1), new BigFraction(0), new BigFraction(8) } }; FieldMatrix<BigFraction> m = new Array2DRowFieldMatrix<BigFraction>(bfData, false); RealMatrix converted = MatrixUtils.bigFractionMatrixToRealMatrix(m); RealMatrix reference = new Array2DRowRealMatrix(testData, false); Assert.assertEquals(0.0, converted.subtract(reference).getNorm(), 0.0); } @Test public void testFractionConverter() { Fraction[][] fData = { { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(5), new Fraction(3) }, { new Fraction(1), new Fraction(0), new Fraction(8) } }; FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(fData, false); RealMatrix converted = MatrixUtils.fractionMatrixToRealMatrix(m); RealMatrix reference = new Array2DRowRealMatrix(testData, false); Assert.assertEquals(0.0, converted.subtract(reference).getNorm(), 0.0); } public static final Fraction[][] asFraction(double[][] data) { Fraction d[][] = new Fraction[data.length][]; try { for (int i = 0; i < data.length; ++i) { double[] dataI = data[i]; Fraction[] dI = new Fraction[dataI.length]; for (int j = 0; j < dataI.length; ++j) { dI[j] = new Fraction(dataI[j]); } d[i] = dI; } } catch (FractionConversionException fce) { Assert.fail(fce.getMessage()); } return d; } public static final Fraction[] asFraction(double[] data) { Fraction d[] = new Fraction[data.length]; try { for (int i = 0; i < data.length; ++i) { d[i] = new Fraction(data[i]); } } catch (FractionConversionException fce) { Assert.fail(fce.getMessage()); } return d; } @Test public void testSolveLowerTriangularSystem(){ RealMatrix rm = new Array2DRowRealMatrix( new double[][] { {2,0,0,0 }, { 1,1,0,0 }, { 3,3,3,0 }, { 3,3,3,4 } }, false); RealVector b = new ArrayRealVector(new double[] { 2,3,4,8 }, false); MatrixUtils.solveLowerTriangularSystem(rm, b); TestUtils.assertEquals( new double[]{1,2,-1.66666666666667, 1.0} , b.toArray() , 1.0e-12); } /* * Taken from R manual http://stat.ethz.ch/R-manual/R-patched/library/base/html/backsolve.html */ @Test public void testSolveUpperTriangularSystem(){ RealMatrix rm = new Array2DRowRealMatrix( new double[][] { {1,2,3 }, { 0,1,1 }, { 0,0,2 } }, false); RealVector b = new ArrayRealVector(new double[] { 8,4,2 }, false); MatrixUtils.solveUpperTriangularSystem(rm, b); TestUtils.assertEquals( new double[]{-1,3,1} , b.toArray() , 1.0e-12); } /** * This test should probably be replaced by one that could show * whether this algorithm can sometimes perform better (precision- or * performance-wise) than the direct inversion of the whole matrix. */ @Test public void testBlockInverse() { final double[][] data = { { -1, 0, 123, 4 }, { -56, 78.9, -0.1, -23.4 }, { 5.67, 8, -9, 1011 }, { 12, 345, -67.8, 9 }, }; final RealMatrix m = new Array2DRowRealMatrix(data); final int len = data.length; final double tol = 1e-14; for (int splitIndex = 0; splitIndex < 3; splitIndex++) { final RealMatrix mInv = MatrixUtils.blockInverse(m, splitIndex); final RealMatrix id = m.multiply(mInv); // Check that we recovered the identity matrix. for (int i = 0; i < len; i++) { for (int j = 0; j < len; j++) { final double entry = id.getEntry(i, j); if (i == j) { Assert.assertEquals("[" + i + "][" + j + "]", 1, entry, tol); } else { Assert.assertEquals("[" + i + "][" + j + "]", 0, entry, tol); } } } } } @Test(expected=SingularMatrixException.class) public void testBlockInverseNonInvertible() { final double[][] data = { { -1, 0, 123, 4 }, { -56, 78.9, -0.1, -23.4 }, { 5.67, 8, -9, 1011 }, { 5.67, 8, -9, 1011 }, }; MatrixUtils.blockInverse(new Array2DRowRealMatrix(data), 2); } @Test public void testIsSymmetric() { final double eps = Math.ulp(1d); final double[][] dataSym = { { 1, 2, 3 }, { 2, 2, 5 }, { 3, 5, 6 }, }; Assert.assertTrue(MatrixUtils.isSymmetric(MatrixUtils.createRealMatrix(dataSym), eps)); final double[][] dataNonSym = { { 1, 2, -3 }, { 2, 2, 5 }, { 3, 5, 6 }, }; Assert.assertFalse(MatrixUtils.isSymmetric(MatrixUtils.createRealMatrix(dataNonSym), eps)); } @Test public void testIsSymmetricTolerance() { final double eps = 1e-4; final double[][] dataSym1 = { { 1, 1, 1.00009 }, { 1, 1, 1 }, { 1.0, 1, 1 }, }; Assert.assertTrue(MatrixUtils.isSymmetric(MatrixUtils.createRealMatrix(dataSym1), eps)); final double[][] dataSym2 = { { 1, 1, 0.99990 }, { 1, 1, 1 }, { 1.0, 1, 1 }, }; Assert.assertTrue(MatrixUtils.isSymmetric(MatrixUtils.createRealMatrix(dataSym2), eps)); final double[][] dataNonSym1 = { { 1, 1, 1.00011 }, { 1, 1, 1 }, { 1.0, 1, 1 }, }; Assert.assertFalse(MatrixUtils.isSymmetric(MatrixUtils.createRealMatrix(dataNonSym1), eps)); final double[][] dataNonSym2 = { { 1, 1, 0.99989 }, { 1, 1, 1 }, { 1.0, 1, 1 }, }; Assert.assertFalse(MatrixUtils.isSymmetric(MatrixUtils.createRealMatrix(dataNonSym2), eps)); } @Test public void testCheckSymmetric1() { final double[][] dataSym = { { 1, 2, 3 }, { 2, 2, 5 }, { 3, 5, 6 }, }; MatrixUtils.checkSymmetric(MatrixUtils.createRealMatrix(dataSym), Math.ulp(1d)); } @Test(expected=NonSymmetricMatrixException.class) public void testCheckSymmetric2() { final double[][] dataNonSym = { { 1, 2, -3 }, { 2, 2, 5 }, { 3, 5, 6 }, }; MatrixUtils.checkSymmetric(MatrixUtils.createRealMatrix(dataNonSym), Math.ulp(1d)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import org.apache.commons.math3.exception.NumberIsTooLargeException; import org.junit.Test; public final class OpenMapRealMatrixTest { @Test(expected=NumberIsTooLargeException.class) public void testMath679() { new OpenMapRealMatrix(3, Integer.MAX_VALUE); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import java.util.Random; import org.apache.commons.math3.linear.SingularMatrixException; import org.junit.Assert; import org.junit.Test; public class QRDecompositionTest { private double[][] testData3x3NonSingular = { { 12, -51, 4 }, { 6, 167, -68 }, { -4, 24, -41 }, }; private double[][] testData3x3Singular = { { 1, 4, 7, }, { 2, 5, 8, }, { 3, 6, 9, }, }; private double[][] testData3x4 = { { 12, -51, 4, 1 }, { 6, 167, -68, 2 }, { -4, 24, -41, 3 }, }; private double[][] testData4x3 = { { 12, -51, 4, }, { 6, 167, -68, }, { -4, 24, -41, }, { -5, 34, 7, }, }; private static final double entryTolerance = 10e-16; private static final double normTolerance = 10e-14; /** test dimensions */ @Test public void testDimensions() { checkDimension(MatrixUtils.createRealMatrix(testData3x3NonSingular)); checkDimension(MatrixUtils.createRealMatrix(testData4x3)); checkDimension(MatrixUtils.createRealMatrix(testData3x4)); Random r = new Random(643895747384642l); int p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4; int q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4; checkDimension(createTestMatrix(r, p, q)); checkDimension(createTestMatrix(r, q, p)); } private void checkDimension(RealMatrix m) { int rows = m.getRowDimension(); int columns = m.getColumnDimension(); QRDecomposition qr = new QRDecomposition(m); Assert.assertEquals(rows, qr.getQ().getRowDimension()); Assert.assertEquals(rows, qr.getQ().getColumnDimension()); Assert.assertEquals(rows, qr.getR().getRowDimension()); Assert.assertEquals(columns, qr.getR().getColumnDimension()); } /** test A = QR */ @Test public void testAEqualQR() { checkAEqualQR(MatrixUtils.createRealMatrix(testData3x3NonSingular)); checkAEqualQR(MatrixUtils.createRealMatrix(testData3x3Singular)); checkAEqualQR(MatrixUtils.createRealMatrix(testData3x4)); checkAEqualQR(MatrixUtils.createRealMatrix(testData4x3)); Random r = new Random(643895747384642l); int p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4; int q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4; checkAEqualQR(createTestMatrix(r, p, q)); checkAEqualQR(createTestMatrix(r, q, p)); } private void checkAEqualQR(RealMatrix m) { QRDecomposition qr = new QRDecomposition(m); double norm = qr.getQ().multiply(qr.getR()).subtract(m).getNorm(); Assert.assertEquals(0, norm, normTolerance); } /** test the orthogonality of Q */ @Test public void testQOrthogonal() { checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x3NonSingular)); checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x3Singular)); checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x4)); checkQOrthogonal(MatrixUtils.createRealMatrix(testData4x3)); Random r = new Random(643895747384642l); int p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4; int q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4; checkQOrthogonal(createTestMatrix(r, p, q)); checkQOrthogonal(createTestMatrix(r, q, p)); } private void checkQOrthogonal(RealMatrix m) { QRDecomposition qr = new QRDecomposition(m); RealMatrix eye = MatrixUtils.createRealIdentityMatrix(m.getRowDimension()); double norm = qr.getQT().multiply(qr.getQ()).subtract(eye).getNorm(); Assert.assertEquals(0, norm, normTolerance); } /** test that R is upper triangular */ @Test public void testRUpperTriangular() { RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular); checkUpperTriangular(new QRDecomposition(matrix).getR()); matrix = MatrixUtils.createRealMatrix(testData3x3Singular); checkUpperTriangular(new QRDecomposition(matrix).getR()); matrix = MatrixUtils.createRealMatrix(testData3x4); checkUpperTriangular(new QRDecomposition(matrix).getR()); matrix = MatrixUtils.createRealMatrix(testData4x3); checkUpperTriangular(new QRDecomposition(matrix).getR()); Random r = new Random(643895747384642l); int p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4; int q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4; matrix = createTestMatrix(r, p, q); checkUpperTriangular(new QRDecomposition(matrix).getR()); matrix = createTestMatrix(r, p, q); checkUpperTriangular(new QRDecomposition(matrix).getR()); } private void checkUpperTriangular(RealMatrix m) { m.walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() { @Override public void visit(int row, int column, double value) { if (column < row) { Assert.assertEquals(0.0, value, entryTolerance); } } }); } /** test that H is trapezoidal */ @Test public void testHTrapezoidal() { RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular); checkTrapezoidal(new QRDecomposition(matrix).getH()); matrix = MatrixUtils.createRealMatrix(testData3x3Singular); checkTrapezoidal(new QRDecomposition(matrix).getH()); matrix = MatrixUtils.createRealMatrix(testData3x4); checkTrapezoidal(new QRDecomposition(matrix).getH()); matrix = MatrixUtils.createRealMatrix(testData4x3); checkTrapezoidal(new QRDecomposition(matrix).getH()); Random r = new Random(643895747384642l); int p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4; int q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4; matrix = createTestMatrix(r, p, q); checkTrapezoidal(new QRDecomposition(matrix).getH()); matrix = createTestMatrix(r, p, q); checkTrapezoidal(new QRDecomposition(matrix).getH()); } private void checkTrapezoidal(RealMatrix m) { m.walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() { @Override public void visit(int row, int column, double value) { if (column > row) { Assert.assertEquals(0.0, value, entryTolerance); } } }); } /** test matrices values */ @Test public void testMatricesValues() { QRDecomposition qr = new QRDecomposition(MatrixUtils.createRealMatrix(testData3x3NonSingular)); RealMatrix qRef = MatrixUtils.createRealMatrix(new double[][] { { -12.0 / 14.0, 69.0 / 175.0, -58.0 / 175.0 }, { -6.0 / 14.0, -158.0 / 175.0, 6.0 / 175.0 }, { 4.0 / 14.0, -30.0 / 175.0, -165.0 / 175.0 } }); RealMatrix rRef = MatrixUtils.createRealMatrix(new double[][] { { -14.0, -21.0, 14.0 }, { 0.0, -175.0, 70.0 }, { 0.0, 0.0, 35.0 } }); RealMatrix hRef = MatrixUtils.createRealMatrix(new double[][] { { 26.0 / 14.0, 0.0, 0.0 }, { 6.0 / 14.0, 648.0 / 325.0, 0.0 }, { -4.0 / 14.0, 36.0 / 325.0, 2.0 } }); // check values against known references RealMatrix q = qr.getQ(); Assert.assertEquals(0, q.subtract(qRef).getNorm(), 1.0e-13); RealMatrix qT = qr.getQT(); Assert.assertEquals(0, qT.subtract(qRef.transpose()).getNorm(), 1.0e-13); RealMatrix r = qr.getR(); Assert.assertEquals(0, r.subtract(rRef).getNorm(), 1.0e-13); RealMatrix h = qr.getH(); Assert.assertEquals(0, h.subtract(hRef).getNorm(), 1.0e-13); // check the same cached instance is returned the second time Assert.assertTrue(q == qr.getQ()); Assert.assertTrue(r == qr.getR()); Assert.assertTrue(h == qr.getH()); } @Test(expected=SingularMatrixException.class) public void testNonInvertible() { QRDecomposition qr = new QRDecomposition(MatrixUtils.createRealMatrix(testData3x3Singular)); qr.getSolver().getInverse(); } private RealMatrix createTestMatrix(final Random r, final int rows, final int columns) { RealMatrix m = MatrixUtils.createRealMatrix(rows, columns); m.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor(){ @Override public double visit(int row, int column, double value) { return 2.0 * r.nextDouble() - 1.0; } }); return m; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import java.util.Random; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.junit.Test; import org.junit.Assert; public class QRSolverTest { double[][] testData3x3NonSingular = { { 12, -51, 4 }, { 6, 167, -68 }, { -4, 24, -41 } }; double[][] testData3x3Singular = { { 1, 2, 2 }, { 2, 4, 6 }, { 4, 8, 12 } }; double[][] testData3x4 = { { 12, -51, 4, 1 }, { 6, 167, -68, 2 }, { -4, 24, -41, 3 } }; double[][] testData4x3 = { { 12, -51, 4 }, { 6, 167, -68 }, { -4, 24, -41 }, { -5, 34, 7 } }; /** test rank */ @Test public void testRank() { DecompositionSolver solver = new QRDecomposition(MatrixUtils.createRealMatrix(testData3x3NonSingular)).getSolver(); Assert.assertTrue(solver.isNonSingular()); solver = new QRDecomposition(MatrixUtils.createRealMatrix(testData3x3Singular)).getSolver(); Assert.assertFalse(solver.isNonSingular()); solver = new QRDecomposition(MatrixUtils.createRealMatrix(testData3x4)).getSolver(); Assert.assertTrue(solver.isNonSingular()); solver = new QRDecomposition(MatrixUtils.createRealMatrix(testData4x3)).getSolver(); Assert.assertTrue(solver.isNonSingular()); } /** test solve dimension errors */ @Test public void testSolveDimensionErrors() { DecompositionSolver solver = new QRDecomposition(MatrixUtils.createRealMatrix(testData3x3NonSingular)).getSolver(); RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]); try { solver.solve(b); Assert.fail("an exception should have been thrown"); } catch (MathIllegalArgumentException iae) { // expected behavior } try { solver.solve(b.getColumnVector(0)); Assert.fail("an exception should have been thrown"); } catch (MathIllegalArgumentException iae) { // expected behavior } } /** test solve rank errors */ @Test public void testSolveRankErrors() { DecompositionSolver solver = new QRDecomposition(MatrixUtils.createRealMatrix(testData3x3Singular)).getSolver(); RealMatrix b = MatrixUtils.createRealMatrix(new double[3][2]); try { solver.solve(b); Assert.fail("an exception should have been thrown"); } catch (SingularMatrixException iae) { // expected behavior } try { solver.solve(b.getColumnVector(0)); Assert.fail("an exception should have been thrown"); } catch (SingularMatrixException iae) { // expected behavior } } /** test solve */ @Test public void testSolve() { QRDecomposition decomposition = new QRDecomposition(MatrixUtils.createRealMatrix(testData3x3NonSingular)); DecompositionSolver solver = decomposition.getSolver(); RealMatrix b = MatrixUtils.createRealMatrix(new double[][] { { -102, 12250 }, { 544, 24500 }, { 167, -36750 } }); RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] { { 1, 2515 }, { 2, 422 }, { -3, 898 } }); // using RealMatrix Assert.assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 2.0e-16 * xRef.getNorm()); // using ArrayRealVector for (int i = 0; i < b.getColumnDimension(); ++i) { final RealVector x = solver.solve(b.getColumnVector(i)); final double error = x.subtract(xRef.getColumnVector(i)).getNorm(); Assert.assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm()); } // using RealVector with an alternate implementation for (int i = 0; i < b.getColumnDimension(); ++i) { ArrayRealVectorTest.RealVectorTestImpl v = new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i)); final RealVector x = solver.solve(v); final double error = x.subtract(xRef.getColumnVector(i)).getNorm(); Assert.assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm()); } } @Test public void testOverdetermined() { final Random r = new Random(5559252868205245l); int p = (7 * BlockRealMatrix.BLOCK_SIZE) / 4; int q = (5 * BlockRealMatrix.BLOCK_SIZE) / 4; RealMatrix a = createTestMatrix(r, p, q); RealMatrix xRef = createTestMatrix(r, q, BlockRealMatrix.BLOCK_SIZE + 3); // build a perturbed system: A.X + noise = B RealMatrix b = a.multiply(xRef); final double noise = 0.001; b.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() { @Override public double visit(int row, int column, double value) { return value * (1.0 + noise * (2 * r.nextDouble() - 1)); } }); // despite perturbation, the least square solution should be pretty good RealMatrix x = new QRDecomposition(a).getSolver().solve(b); Assert.assertEquals(0, x.subtract(xRef).getNorm(), 0.01 * noise * p * q); } @Test public void testUnderdetermined() { final Random r = new Random(42185006424567123l); int p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4; int q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4; RealMatrix a = createTestMatrix(r, p, q); RealMatrix xRef = createTestMatrix(r, q, BlockRealMatrix.BLOCK_SIZE + 3); RealMatrix b = a.multiply(xRef); RealMatrix x = new QRDecomposition(a).getSolver().solve(b); // too many equations, the system cannot be solved at all Assert.assertTrue(x.subtract(xRef).getNorm() / (p * q) > 0.01); // the last unknown should have been set to 0 Assert.assertEquals(0.0, x.getSubMatrix(p, q - 1, 0, x.getColumnDimension() - 1).getNorm(), 0); } private RealMatrix createTestMatrix(final Random r, final int rows, final int columns) { RealMatrix m = MatrixUtils.createRealMatrix(rows, columns); m.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() { @Override public double visit(int row, int column, double value) { return 2.0 * r.nextDouble() - 1.0; } }); return m; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import java.util.Random; import org.junit.Assert; import org.junit.Test; public class RRQRDecompositionTest { private double[][] testData3x3NonSingular = { { 12, -51, 4 }, { 6, 167, -68 }, { -4, 24, -41 }, }; private double[][] testData3x3Singular = { { 1, 4, 7, }, { 2, 5, 8, }, { 3, 6, 9, }, }; private double[][] testData3x4 = { { 12, -51, 4, 1 }, { 6, 167, -68, 2 }, { -4, 24, -41, 3 }, }; private double[][] testData4x3 = { { 12, -51, 4, }, { 6, 167, -68, }, { -4, 24, -41, }, { -5, 34, 7, }, }; private static final double entryTolerance = 10e-16; private static final double normTolerance = 10e-14; /** test dimensions */ @Test public void testDimensions() { checkDimension(MatrixUtils.createRealMatrix(testData3x3NonSingular)); checkDimension(MatrixUtils.createRealMatrix(testData4x3)); checkDimension(MatrixUtils.createRealMatrix(testData3x4)); Random r = new Random(643895747384642l); int p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4; int q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4; checkDimension(createTestMatrix(r, p, q)); checkDimension(createTestMatrix(r, q, p)); } private void checkDimension(RealMatrix m) { int rows = m.getRowDimension(); int columns = m.getColumnDimension(); RRQRDecomposition qr = new RRQRDecomposition(m); Assert.assertEquals(rows, qr.getQ().getRowDimension()); Assert.assertEquals(rows, qr.getQ().getColumnDimension()); Assert.assertEquals(rows, qr.getR().getRowDimension()); Assert.assertEquals(columns, qr.getR().getColumnDimension()); } /** test AP = QR */ @Test public void testAPEqualQR() { checkAPEqualQR(MatrixUtils.createRealMatrix(testData3x3NonSingular)); checkAPEqualQR(MatrixUtils.createRealMatrix(testData3x3Singular)); checkAPEqualQR(MatrixUtils.createRealMatrix(testData3x4)); checkAPEqualQR(MatrixUtils.createRealMatrix(testData4x3)); Random r = new Random(643895747384642l); int p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4; int q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4; checkAPEqualQR(createTestMatrix(r, p, q)); checkAPEqualQR(createTestMatrix(r, q, p)); } private void checkAPEqualQR(RealMatrix m) { RRQRDecomposition rrqr = new RRQRDecomposition(m); double norm = rrqr.getQ().multiply(rrqr.getR()).subtract(m.multiply(rrqr.getP())).getNorm(); Assert.assertEquals(0, norm, normTolerance); } /** test the orthogonality of Q */ @Test public void testQOrthogonal() { checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x3NonSingular)); checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x3Singular)); checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x4)); checkQOrthogonal(MatrixUtils.createRealMatrix(testData4x3)); Random r = new Random(643895747384642l); int p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4; int q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4; checkQOrthogonal(createTestMatrix(r, p, q)); checkQOrthogonal(createTestMatrix(r, q, p)); } private void checkQOrthogonal(RealMatrix m) { RRQRDecomposition qr = new RRQRDecomposition(m); RealMatrix eye = MatrixUtils.createRealIdentityMatrix(m.getRowDimension()); double norm = qr.getQT().multiply(qr.getQ()).subtract(eye).getNorm(); Assert.assertEquals(0, norm, normTolerance); } /** test that R is upper triangular */ @Test public void testRUpperTriangular() { RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular); checkUpperTriangular(new RRQRDecomposition(matrix).getR()); matrix = MatrixUtils.createRealMatrix(testData3x3Singular); checkUpperTriangular(new RRQRDecomposition(matrix).getR()); matrix = MatrixUtils.createRealMatrix(testData3x4); checkUpperTriangular(new RRQRDecomposition(matrix).getR()); matrix = MatrixUtils.createRealMatrix(testData4x3); checkUpperTriangular(new RRQRDecomposition(matrix).getR()); Random r = new Random(643895747384642l); int p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4; int q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4; matrix = createTestMatrix(r, p, q); checkUpperTriangular(new RRQRDecomposition(matrix).getR()); matrix = createTestMatrix(r, p, q); checkUpperTriangular(new RRQRDecomposition(matrix).getR()); } private void checkUpperTriangular(RealMatrix m) { m.walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() { @Override public void visit(int row, int column, double value) { if (column < row) { Assert.assertEquals(0.0, value, entryTolerance); } } }); } /** test that H is trapezoidal */ @Test public void testHTrapezoidal() { RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular); checkTrapezoidal(new RRQRDecomposition(matrix).getH()); matrix = MatrixUtils.createRealMatrix(testData3x3Singular); checkTrapezoidal(new RRQRDecomposition(matrix).getH()); matrix = MatrixUtils.createRealMatrix(testData3x4); checkTrapezoidal(new RRQRDecomposition(matrix).getH()); matrix = MatrixUtils.createRealMatrix(testData4x3); checkTrapezoidal(new RRQRDecomposition(matrix).getH()); Random r = new Random(643895747384642l); int p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4; int q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4; matrix = createTestMatrix(r, p, q); checkTrapezoidal(new RRQRDecomposition(matrix).getH()); matrix = createTestMatrix(r, p, q); checkTrapezoidal(new RRQRDecomposition(matrix).getH()); } private void checkTrapezoidal(RealMatrix m) { m.walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() { @Override public void visit(int row, int column, double value) { if (column > row) { Assert.assertEquals(0.0, value, entryTolerance); } } }); } @Test(expected=SingularMatrixException.class) public void testNonInvertible() { RRQRDecomposition qr = new RRQRDecomposition(MatrixUtils.createRealMatrix(testData3x3Singular), 3.0e-16); qr.getSolver().getInverse(); } private RealMatrix createTestMatrix(final Random r, final int rows, final int columns) { RealMatrix m = MatrixUtils.createRealMatrix(rows, columns); m.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor(){ @Override public double visit(int row, int column, double value) { return 2.0 * r.nextDouble() - 1.0; } }); return m; } /** test the rank is returned correctly */ @Test public void testRank() { double[][] d = { { 1, 1, 1 }, { 0, 0, 0 }, { 1, 2, 3 } }; RealMatrix m = new Array2DRowRealMatrix(d); RRQRDecomposition qr = new RRQRDecomposition(m); Assert.assertEquals(2, qr.getRank(1.0e-16)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import java.util.Random; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.junit.Test; import org.junit.Assert; public class RRQRSolverTest { double[][] testData3x3NonSingular = { { 12, -51, 4 }, { 6, 167, -68 }, { -4, 24, -41 } }; double[][] testData3x3Singular = { { 1, 2, 2 }, { 2, 4, 6 }, { 4, 8, 12 } }; double[][] testData3x4 = { { 12, -51, 4, 1 }, { 6, 167, -68, 2 }, { -4, 24, -41, 3 } }; double[][] testData4x3 = { { 12, -51, 4 }, { 6, 167, -68 }, { -4, 24, -41 }, { -5, 34, 7 } }; /** test rank */ @Test public void testRank() { DecompositionSolver solver = new RRQRDecomposition(MatrixUtils.createRealMatrix(testData3x3NonSingular), 1.0e-16).getSolver(); Assert.assertTrue(solver.isNonSingular()); solver = new RRQRDecomposition(MatrixUtils.createRealMatrix(testData3x3Singular), 1.0e-16).getSolver(); Assert.assertFalse(solver.isNonSingular()); solver = new RRQRDecomposition(MatrixUtils.createRealMatrix(testData3x4), 1.0e-16).getSolver(); Assert.assertTrue(solver.isNonSingular()); solver = new RRQRDecomposition(MatrixUtils.createRealMatrix(testData4x3), 1.0e-16).getSolver(); Assert.assertTrue(solver.isNonSingular()); } /** test solve dimension errors */ @Test public void testSolveDimensionErrors() { DecompositionSolver solver = new RRQRDecomposition(MatrixUtils.createRealMatrix(testData3x3NonSingular)).getSolver(); RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]); try { solver.solve(b); Assert.fail("an exception should have been thrown"); } catch (MathIllegalArgumentException iae) { // expected behavior } try { solver.solve(b.getColumnVector(0)); Assert.fail("an exception should have been thrown"); } catch (MathIllegalArgumentException iae) { // expected behavior } } /** test solve rank errors */ @Test public void testSolveRankErrors() { DecompositionSolver solver = new RRQRDecomposition(MatrixUtils.createRealMatrix(testData3x3Singular), 1.0e-16).getSolver(); RealMatrix b = MatrixUtils.createRealMatrix(new double[3][2]); try { solver.solve(b); Assert.fail("an exception should have been thrown"); } catch (SingularMatrixException iae) { // expected behavior } try { solver.solve(b.getColumnVector(0)); Assert.fail("an exception should have been thrown"); } catch (SingularMatrixException iae) { // expected behavior } } /** test solve */ @Test public void testSolve() { RealMatrix b = MatrixUtils.createRealMatrix(new double[][] { { -102, 12250 }, { 544, 24500 }, { 167, -36750 } }); RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] { { 1, 2515 }, { 2, 422 }, { -3, 898 } }); RRQRDecomposition decomposition = new RRQRDecomposition(MatrixUtils.createRealMatrix(testData3x3NonSingular)); DecompositionSolver solver = decomposition.getSolver(); // using RealMatrix Assert.assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 3.0e-16 * xRef.getNorm()); // using ArrayRealVector for (int i = 0; i < b.getColumnDimension(); ++i) { final RealVector x = solver.solve(b.getColumnVector(i)); final double error = x.subtract(xRef.getColumnVector(i)).getNorm(); Assert.assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm()); } // using RealVector with an alternate implementation for (int i = 0; i < b.getColumnDimension(); ++i) { ArrayRealVectorTest.RealVectorTestImpl v = new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i)); final RealVector x = solver.solve(v); final double error = x.subtract(xRef.getColumnVector(i)).getNorm(); Assert.assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm()); } } @Test public void testOverdetermined() { final Random r = new Random(5559252868205245l); int p = (7 * BlockRealMatrix.BLOCK_SIZE) / 4; int q = (5 * BlockRealMatrix.BLOCK_SIZE) / 4; RealMatrix a = createTestMatrix(r, p, q); RealMatrix xRef = createTestMatrix(r, q, BlockRealMatrix.BLOCK_SIZE + 3); // build a perturbed system: A.X + noise = B RealMatrix b = a.multiply(xRef); final double noise = 0.001; b.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() { @Override public double visit(int row, int column, double value) { return value * (1.0 + noise * (2 * r.nextDouble() - 1)); } }); // despite perturbation, the least square solution should be pretty good RealMatrix x = new RRQRDecomposition(a).getSolver().solve(b); Assert.assertEquals(0, x.subtract(xRef).getNorm(), 0.01 * noise * p * q); } @Test public void testUnderdetermined() { final Random r = new Random(42185006424567123l); int p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4; int q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4; RealMatrix a = createTestMatrix(r, p, q); RealMatrix xRef = createTestMatrix(r, q, BlockRealMatrix.BLOCK_SIZE + 3); RealMatrix b = a.multiply(xRef); RRQRDecomposition rrqrd = new RRQRDecomposition(a); RealMatrix x = rrqrd.getSolver().solve(b); // too many equations, the system cannot be solved at all Assert.assertTrue(x.subtract(xRef).getNorm() / (p * q) > 0.01); // the last permuted unknown should have been set to 0 RealMatrix permuted = rrqrd.getP().transpose().multiply(x); Assert.assertEquals(0.0, permuted.getSubMatrix(p, q - 1, 0, permuted.getColumnDimension() - 1).getNorm(), 0); } private RealMatrix createTestMatrix(final Random r, final int rows, final int columns) { RealMatrix m = MatrixUtils.createRealMatrix(rows, columns); m.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() { @Override public double visit(int row, int column, double value) { return 2.0 * r.nextDouble() - 1.0; } }); return m; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import java.util.Locale; public class RealMatrixFormatTest extends RealMatrixFormatAbstractTest { @Override protected char getDecimalCharacter() { return '.'; } @Override protected Locale getLocale() { return Locale.US; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import java.util.Locale; public class RealVectorFormatTest extends RealVectorFormatAbstractTest { @Override protected char getDecimalCharacter() { return '.'; } @Override protected Locale getLocale() { return Locale.US; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import java.util.Iterator; import org.apache.commons.math3.linear.RealVector.Entry; import org.junit.Assert; import org.junit.Ignore; import org.junit.Test; /** * Tests for {@link RealVector}. */ public class RealVectorTest extends RealVectorAbstractTest{ @Override public RealVector create(final double[] data) { return new RealVectorTestImpl(data); } @Test @Ignore("Abstract class RealVector does not implement append(RealVector).") @Override public void testAppendVector() { // Do nothing } @Test @Ignore("Abstract class RealVector does not implement append(double)") @Override public void testAppendScalar() { // Do nothing } @Test @Ignore("Abstract class RealVector does not implement getSubvector(int, int)") @Override public void testGetSubVector() { // Do nothing } @Test @Ignore("Abstract class RealVector does not implement getSubvector(int, int)") @Override public void testGetSubVectorInvalidIndex1() { // Do nothing } @Test @Ignore("Abstract class RealVector does not implement getSubvector(int, int)") @Override public void testGetSubVectorInvalidIndex2() { // Do nothing } @Test @Ignore("Abstract class RealVector does not implement getSubvector(int, int)") @Override public void testGetSubVectorInvalidIndex3() { // Do nothing } @Test @Ignore("Abstract class RealVector does not implement getSubvector(int, int)") @Override public void testGetSubVectorInvalidIndex4() { // Do nothing } @Test @Ignore("Abstract class RealVector does not implement setSubvector(int, RealVector)") @Override public void testSetSubVectorSameType() { // Do nothing } @Test @Ignore("Abstract class RealVector does not implement setSubvector(int, RealVector)") @Override public void testSetSubVectorMixedType() { // Do nothing } @Test @Ignore("Abstract class RealVector does not implement setSubvector(int, RealVector)") @Override public void testSetSubVectorInvalidIndex1() { // Do nothing } @Test @Ignore("Abstract class RealVector does not implement setSubvector(int, RealVector)") @Override public void testSetSubVectorInvalidIndex2() { // Do nothing } @Test @Ignore("Abstract class RealVector does not implement setSubvector(int, RealVector)") @Override public void testSetSubVectorInvalidIndex3() { // Do nothing } @Test @Ignore("Abstract class RealVector does not implement isNaN()") @Override public void testIsNaN() { // Do nothing } @Test @Ignore("Abstract class RealVector does not implement isNaN()") @Override public void testIsInfinite() { // Do nothing } @Test @Ignore("Abstract class RealVector does not implement ebeMultiply(RealVector)") @Override public void testEbeMultiplySameType() { // Do nothing } @Test @Ignore("Abstract class RealVector does not implement ebeMultiply(RealVector)") @Override public void testEbeMultiplyMixedTypes() { // Do nothing } @Test @Ignore("Abstract class RealVector does not implement ebeMultiply(RealVector)") @Override public void testEbeMultiplyDimensionMismatch() { // Do nothing } @Test @Ignore("Abstract class RealVector does not implement ebeDivide(RealVector)") @Override public void testEbeDivideSameType() { // Do nothing } @Test @Ignore("Abstract class RealVector does not implement ebeDivide(RealVector)") @Override public void testEbeDivideMixedTypes() { // Do nothing } @Test @Ignore("Abstract class RealVector does not implement ebeDivide(RealVector)") @Override public void testEbeDivideDimensionMismatch() { // Do nothing } @Test @Ignore("Abstract class RealVector does not implement getL1Norm()") @Override public void testGetL1Norm() { // Do nothing } @Test @Ignore("Abstract class RealVector does not implement getLInfNorm()") @Override public void testGetLInfNorm() { // Do nothing } @Test public void testSparseIterator() { /* * For non-default values, use x + 1, x + 2, etc... to make sure that * these values are really different from x. */ final double x = getPreferredEntryValue(); final double[] data = { x, x + 1d, x, x, x + 2d, x + 3d, x + 4d, x, x, x, x + 5d, x + 6d, x }; RealVector v = create(data); Entry e; int i = 0; final double[] nonDefault = { x + 1d, x + 2d, x + 3d, x + 4d, x + 5d, x + 6d }; for (Iterator<Entry> it = v.sparseIterator(); it.hasNext(); i++) { e = it.next(); Assert.assertEquals(nonDefault[i], e.getValue(), 0); } double [] onlyOne = {x, x + 1d, x}; v = create(onlyOne); for(Iterator<Entry> it = v.sparseIterator(); it.hasNext(); ) { e = it.next(); Assert.assertEquals(onlyOne[1], e.getValue(), 0); } } @Test @Ignore("Abstract class RealVector is not serializable.") @Override public void testSerial() { // Do nothing } @Test @Ignore("Abstract class RealVector does not override equals(Object).") @Override public void testEquals() { // Do nothing } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import org.junit.Test; import org.junit.Assert; public class RectangularCholeskyDecompositionTest { @Test public void testDecomposition3x3() { RealMatrix m = MatrixUtils.createRealMatrix(new double[][] { { 1, 9, 9 }, { 9, 225, 225 }, { 9, 225, 625 } }); RectangularCholeskyDecomposition d = new RectangularCholeskyDecomposition(m, 1.0e-6); // as this decomposition permutes lines and columns, the root is NOT triangular // (in fact here it is the lower right part of the matrix which is zero and // the upper left non-zero) Assert.assertEquals(0.8, d.getRootMatrix().getEntry(0, 2), 1.0e-15); Assert.assertEquals(25.0, d.getRootMatrix().getEntry(2, 0), 1.0e-15); Assert.assertEquals(0.0, d.getRootMatrix().getEntry(2, 2), 1.0e-15); RealMatrix root = d.getRootMatrix(); RealMatrix rebuiltM = root.multiply(root.transpose()); Assert.assertEquals(0.0, m.subtract(rebuiltM).getNorm(), 1.0e-15); } @Test public void testFullRank() { RealMatrix base = MatrixUtils.createRealMatrix(new double[][] { { 0.1159548705, 0., 0., 0. }, { 0.0896442724, 0.1223540781, 0., 0. }, { 0.0852155322, 4.558668e-3, 0.1083577299, 0. }, { 0.0905486674, 0.0213768077, 0.0128878333, 0.1014155693 } }); RealMatrix m = base.multiply(base.transpose()); RectangularCholeskyDecomposition d = new RectangularCholeskyDecomposition(m, 1.0e-10); RealMatrix root = d.getRootMatrix(); RealMatrix rebuiltM = root.multiply(root.transpose()); Assert.assertEquals(0.0, m.subtract(rebuiltM).getNorm(), 1.0e-15); // the pivoted Cholesky decomposition is *not* unique. Here, the root is // not equal to the original trianbular base matrix Assert.assertTrue(root.subtract(base).getNorm() > 0.3); } @Test public void testMath789() { final RealMatrix m1 = MatrixUtils.createRealMatrix(new double[][]{ {0.013445532, 0.010394690, 0.009881156, 0.010499559}, {0.010394690, 0.023006616, 0.008196856, 0.010732709}, {0.009881156, 0.008196856, 0.019023866, 0.009210099}, {0.010499559, 0.010732709, 0.009210099, 0.019107243} }); composeAndTest(m1, 4); final RealMatrix m2 = MatrixUtils.createRealMatrix(new double[][]{ {0.0, 0.0, 0.0, 0.0, 0.0}, {0.0, 0.013445532, 0.010394690, 0.009881156, 0.010499559}, {0.0, 0.010394690, 0.023006616, 0.008196856, 0.010732709}, {0.0, 0.009881156, 0.008196856, 0.019023866, 0.009210099}, {0.0, 0.010499559, 0.010732709, 0.009210099, 0.019107243} }); composeAndTest(m2, 4); final RealMatrix m3 = MatrixUtils.createRealMatrix(new double[][]{ {0.013445532, 0.010394690, 0.0, 0.009881156, 0.010499559}, {0.010394690, 0.023006616, 0.0, 0.008196856, 0.010732709}, {0.0, 0.0, 0.0, 0.0, 0.0}, {0.009881156, 0.008196856, 0.0, 0.019023866, 0.009210099}, {0.010499559, 0.010732709, 0.0, 0.009210099, 0.019107243} }); composeAndTest(m3, 4); } private void composeAndTest(RealMatrix m, int expectedRank) { RectangularCholeskyDecomposition r = new RectangularCholeskyDecomposition(m); Assert.assertEquals(expectedRank, r.getRank()); RealMatrix root = r.getRootMatrix(); RealMatrix rebuiltMatrix = root.multiply(root.transpose()); Assert.assertEquals(0.0, m.subtract(rebuiltMatrix).getNorm(), 1.0e-16); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import java.util.Random; import org.apache.commons.math3.distribution.NormalDistribution; import org.junit.Test; import org.junit.Assert; public class SchurTransformerTest { private double[][] testSquare5 = { { 5, 4, 3, 2, 1 }, { 1, 4, 0, 3, 3 }, { 2, 0, 3, 0, 0 }, { 3, 2, 1, 2, 5 }, { 4, 2, 1, 4, 1 } }; private double[][] testSquare3 = { { 2, -1, 1 }, { -1, 2, 1 }, { 1, -1, 2 } }; // from http://eigen.tuxfamily.org/dox/classEigen_1_1RealSchur.html private double[][] testRandom = { { 0.680, -0.3300, -0.2700, -0.717, -0.687, 0.0259 }, { -0.211, 0.5360, 0.0268, 0.214, -0.198, 0.6780 }, { 0.566, -0.4440, 0.9040, -0.967, -0.740, 0.2250 }, { 0.597, 0.1080, 0.8320, -0.514, -0.782, -0.4080 }, { 0.823, -0.0452, 0.2710, -0.726, 0.998, 0.2750 }, { -0.605, 0.2580, 0.4350, 0.608, -0.563, 0.0486 } }; @Test public void testNonSquare() { try { new SchurTransformer(MatrixUtils.createRealMatrix(new double[3][2])); Assert.fail("an exception should have been thrown"); } catch (NonSquareMatrixException ime) { // expected behavior } } @Test public void testAEqualPTPt() { checkAEqualPTPt(MatrixUtils.createRealMatrix(testSquare5)); checkAEqualPTPt(MatrixUtils.createRealMatrix(testSquare3)); checkAEqualPTPt(MatrixUtils.createRealMatrix(testRandom)); } @Test public void testPOrthogonal() { checkOrthogonal(new SchurTransformer(MatrixUtils.createRealMatrix(testSquare5)).getP()); checkOrthogonal(new SchurTransformer(MatrixUtils.createRealMatrix(testSquare3)).getP()); checkOrthogonal(new SchurTransformer(MatrixUtils.createRealMatrix(testRandom)).getP()); } @Test public void testPTOrthogonal() { checkOrthogonal(new SchurTransformer(MatrixUtils.createRealMatrix(testSquare5)).getPT()); checkOrthogonal(new SchurTransformer(MatrixUtils.createRealMatrix(testSquare3)).getPT()); checkOrthogonal(new SchurTransformer(MatrixUtils.createRealMatrix(testRandom)).getPT()); } @Test public void testSchurForm() { checkSchurForm(new SchurTransformer(MatrixUtils.createRealMatrix(testSquare5)).getT()); checkSchurForm(new SchurTransformer(MatrixUtils.createRealMatrix(testSquare3)).getT()); checkSchurForm(new SchurTransformer(MatrixUtils.createRealMatrix(testRandom)).getT()); } @Test public void testRandomData() { for (int run = 0; run < 100; run++) { Random r = new Random(System.currentTimeMillis()); // matrix size int size = r.nextInt(20) + 4; double[][] data = new double[size][size]; for (int i = 0; i < size; i++) { for (int j = 0; j < size; j++) { data[i][j] = r.nextInt(100); } } RealMatrix m = MatrixUtils.createRealMatrix(data); RealMatrix s = checkAEqualPTPt(m); checkSchurForm(s); } } @Test public void testRandomDataNormalDistribution() { for (int run = 0; run < 100; run++) { Random r = new Random(System.currentTimeMillis()); NormalDistribution dist = new NormalDistribution(0.0, r.nextDouble() * 5); // matrix size int size = r.nextInt(20) + 4; double[][] data = new double[size][size]; for (int i = 0; i < size; i++) { for (int j = 0; j < size; j++) { data[i][j] = dist.sample(); } } RealMatrix m = MatrixUtils.createRealMatrix(data); RealMatrix s = checkAEqualPTPt(m); checkSchurForm(s); } } @Test public void testMath848() { double[][] data = { { 0.1849449280, -0.0646971046, 0.0774755812, -0.0969651755, -0.0692648806, 0.3282344352, -0.0177423074, 0.2063136340}, {-0.0742700134, -0.0289063030, -0.0017269460, -0.0375550146, -0.0487737922, -0.2616837868, -0.0821201295, -0.2530000167}, { 0.2549910127, 0.0995733692, -0.0009718388, 0.0149282808, 0.1791878897, -0.0823182816, 0.0582629256, 0.3219545182}, {-0.0694747557, -0.1880649148, -0.2740630911, 0.0720096468, -0.1800836914, -0.3518996425, 0.2486747833, 0.6257938167}, { 0.0536360918, -0.1339297778, 0.2241579764, -0.0195327484, -0.0054103808, 0.0347564518, 0.5120802482, -0.0329902864}, {-0.5933332356, -0.2488721082, 0.2357173629, 0.0177285473, 0.0856630593, -0.3567126300, -0.1600668126, -0.1010899621}, {-0.0514349819, -0.0854319435, 0.1125050061, 0.0063453560, -0.2250000688, -0.2209343090, 0.1964623477, -0.1512329924}, { 0.0197395947, -0.1997170581, -0.1425959019, -0.2749477910, -0.0969467073, 0.0603688520, -0.2826905192, 0.1794315473}}; RealMatrix m = MatrixUtils.createRealMatrix(data); RealMatrix s = checkAEqualPTPt(m); checkSchurForm(s); } /////////////////////////////////////////////////////////////////////////// // Test helpers /////////////////////////////////////////////////////////////////////////// private RealMatrix checkAEqualPTPt(RealMatrix matrix) { SchurTransformer transformer = new SchurTransformer(matrix); RealMatrix p = transformer.getP(); RealMatrix t = transformer.getT(); RealMatrix pT = transformer.getPT(); RealMatrix result = p.multiply(t).multiply(pT); double norm = result.subtract(matrix).getNorm(); Assert.assertEquals(0, norm, 1.0e-9); return t; } private void checkOrthogonal(RealMatrix m) { RealMatrix mTm = m.transpose().multiply(m); RealMatrix id = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension()); Assert.assertEquals(0, mTm.subtract(id).getNorm(), 1.0e-14); } private void checkSchurForm(final RealMatrix m) { final int rows = m.getRowDimension(); final int cols = m.getColumnDimension(); for (int i = 0; i < rows; ++i) { for (int j = 0; j < cols; ++j) { if (i > j + 1) { Assert.assertEquals(0, m.getEntry(i, j), 1.0e-16); } } } } @SuppressWarnings("unused") private void checkMatricesValues(double[][] matrix, double[][] pRef, double[][] hRef) { SchurTransformer transformer = new SchurTransformer(MatrixUtils.createRealMatrix(matrix)); // check values against known references RealMatrix p = transformer.getP(); Assert.assertEquals(0, p.subtract(MatrixUtils.createRealMatrix(pRef)).getNorm(), 1.0e-14); RealMatrix t = transformer.getT(); Assert.assertEquals(0, t.subtract(MatrixUtils.createRealMatrix(hRef)).getNorm(), 1.0e-14); // check the same cached instance is returned the second time Assert.assertTrue(p == transformer.getP()); Assert.assertTrue(t == transformer.getT()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import java.io.BufferedReader; import java.io.DataInputStream; import java.io.IOException; import java.io.InputStreamReader; import java.util.Random; import org.junit.Assert; import org.junit.Test; public class SingularValueDecompositionTest { private double[][] testSquare = { { 24.0 / 25.0, 43.0 / 25.0 }, { 57.0 / 25.0, 24.0 / 25.0 } }; private double[][] testNonSquare = { { -540.0 / 625.0, 963.0 / 625.0, -216.0 / 625.0 }, { -1730.0 / 625.0, -744.0 / 625.0, 1008.0 / 625.0 }, { -720.0 / 625.0, 1284.0 / 625.0, -288.0 / 625.0 }, { -360.0 / 625.0, 192.0 / 625.0, 1756.0 / 625.0 }, }; private static final double normTolerance = 10e-14; @Test public void testMoreRows() { final double[] singularValues = { 123.456, 2.3, 1.001, 0.999 }; final int rows = singularValues.length + 2; final int columns = singularValues.length; Random r = new Random(15338437322523l); SingularValueDecomposition svd = new SingularValueDecomposition(createTestMatrix(r, rows, columns, singularValues)); double[] computedSV = svd.getSingularValues(); Assert.assertEquals(singularValues.length, computedSV.length); for (int i = 0; i < singularValues.length; ++i) { Assert.assertEquals(singularValues[i], computedSV[i], 1.0e-10); } } @Test public void testMoreColumns() { final double[] singularValues = { 123.456, 2.3, 1.001, 0.999 }; final int rows = singularValues.length; final int columns = singularValues.length + 2; Random r = new Random(732763225836210l); SingularValueDecomposition svd = new SingularValueDecomposition(createTestMatrix(r, rows, columns, singularValues)); double[] computedSV = svd.getSingularValues(); Assert.assertEquals(singularValues.length, computedSV.length); for (int i = 0; i < singularValues.length; ++i) { Assert.assertEquals(singularValues[i], computedSV[i], 1.0e-10); } } /** test dimensions */ @Test public void testDimensions() { RealMatrix matrix = MatrixUtils.createRealMatrix(testSquare); final int m = matrix.getRowDimension(); final int n = matrix.getColumnDimension(); SingularValueDecomposition svd = new SingularValueDecomposition(matrix); Assert.assertEquals(m, svd.getU().getRowDimension()); Assert.assertEquals(m, svd.getU().getColumnDimension()); Assert.assertEquals(m, svd.getS().getColumnDimension()); Assert.assertEquals(n, svd.getS().getColumnDimension()); Assert.assertEquals(n, svd.getV().getRowDimension()); Assert.assertEquals(n, svd.getV().getColumnDimension()); } /** Test based on a dimension 4 Hadamard matrix. */ @Test public void testHadamard() { RealMatrix matrix = new Array2DRowRealMatrix(new double[][] { {15.0 / 2.0, 5.0 / 2.0, 9.0 / 2.0, 3.0 / 2.0 }, { 5.0 / 2.0, 15.0 / 2.0, 3.0 / 2.0, 9.0 / 2.0 }, { 9.0 / 2.0, 3.0 / 2.0, 15.0 / 2.0, 5.0 / 2.0 }, { 3.0 / 2.0, 9.0 / 2.0, 5.0 / 2.0, 15.0 / 2.0 } }, false); SingularValueDecomposition svd = new SingularValueDecomposition(matrix); Assert.assertEquals(16.0, svd.getSingularValues()[0], 1.0e-14); Assert.assertEquals( 8.0, svd.getSingularValues()[1], 1.0e-14); Assert.assertEquals( 4.0, svd.getSingularValues()[2], 1.0e-14); Assert.assertEquals( 2.0, svd.getSingularValues()[3], 1.0e-14); RealMatrix fullCovariance = new Array2DRowRealMatrix(new double[][] { { 85.0 / 1024, -51.0 / 1024, -75.0 / 1024, 45.0 / 1024 }, { -51.0 / 1024, 85.0 / 1024, 45.0 / 1024, -75.0 / 1024 }, { -75.0 / 1024, 45.0 / 1024, 85.0 / 1024, -51.0 / 1024 }, { 45.0 / 1024, -75.0 / 1024, -51.0 / 1024, 85.0 / 1024 } }, false); Assert.assertEquals(0.0, fullCovariance.subtract(svd.getCovariance(0.0)).getNorm(), 1.0e-14); RealMatrix halfCovariance = new Array2DRowRealMatrix(new double[][] { { 5.0 / 1024, -3.0 / 1024, 5.0 / 1024, -3.0 / 1024 }, { -3.0 / 1024, 5.0 / 1024, -3.0 / 1024, 5.0 / 1024 }, { 5.0 / 1024, -3.0 / 1024, 5.0 / 1024, -3.0 / 1024 }, { -3.0 / 1024, 5.0 / 1024, -3.0 / 1024, 5.0 / 1024 } }, false); Assert.assertEquals(0.0, halfCovariance.subtract(svd.getCovariance(6.0)).getNorm(), 1.0e-14); } /** test A = USVt */ @Test public void testAEqualUSVt() { checkAEqualUSVt(MatrixUtils.createRealMatrix(testSquare)); checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare)); checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare).transpose()); } public void checkAEqualUSVt(final RealMatrix matrix) { SingularValueDecomposition svd = new SingularValueDecomposition(matrix); RealMatrix u = svd.getU(); RealMatrix s = svd.getS(); RealMatrix v = svd.getV(); double norm = u.multiply(s).multiply(v.transpose()).subtract(matrix).getNorm(); Assert.assertEquals(0, norm, normTolerance); } /** test that U is orthogonal */ @Test public void testUOrthogonal() { checkOrthogonal(new SingularValueDecomposition(MatrixUtils.createRealMatrix(testSquare)).getU()); checkOrthogonal(new SingularValueDecomposition(MatrixUtils.createRealMatrix(testNonSquare)).getU()); checkOrthogonal(new SingularValueDecomposition(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getU()); } /** test that V is orthogonal */ @Test public void testVOrthogonal() { checkOrthogonal(new SingularValueDecomposition(MatrixUtils.createRealMatrix(testSquare)).getV()); checkOrthogonal(new SingularValueDecomposition(MatrixUtils.createRealMatrix(testNonSquare)).getV()); checkOrthogonal(new SingularValueDecomposition(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getV()); } public void checkOrthogonal(final RealMatrix m) { RealMatrix mTm = m.transpose().multiply(m); RealMatrix id = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension()); Assert.assertEquals(0, mTm.subtract(id).getNorm(), normTolerance); } /** test matrices values */ // This test is useless since whereas the columns of U and V are linked // together, the actual triplet (U,S,V) is not uniquely defined. public void testMatricesValues1() { SingularValueDecomposition svd = new SingularValueDecomposition(MatrixUtils.createRealMatrix(testSquare)); RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] { { 3.0 / 5.0, -4.0 / 5.0 }, { 4.0 / 5.0, 3.0 / 5.0 } }); RealMatrix sRef = MatrixUtils.createRealMatrix(new double[][] { { 3.0, 0.0 }, { 0.0, 1.0 } }); RealMatrix vRef = MatrixUtils.createRealMatrix(new double[][] { { 4.0 / 5.0, 3.0 / 5.0 }, { 3.0 / 5.0, -4.0 / 5.0 } }); // check values against known references RealMatrix u = svd.getU(); Assert.assertEquals(0, u.subtract(uRef).getNorm(), normTolerance); RealMatrix s = svd.getS(); Assert.assertEquals(0, s.subtract(sRef).getNorm(), normTolerance); RealMatrix v = svd.getV(); Assert.assertEquals(0, v.subtract(vRef).getNorm(), normTolerance); // check the same cached instance is returned the second time Assert.assertTrue(u == svd.getU()); Assert.assertTrue(s == svd.getS()); Assert.assertTrue(v == svd.getV()); } /** test matrices values */ // This test is useless since whereas the columns of U and V are linked // together, the actual triplet (U,S,V) is not uniquely defined. public void useless_testMatricesValues2() { RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] { { 0.0 / 5.0, 3.0 / 5.0, 0.0 / 5.0 }, { -4.0 / 5.0, 0.0 / 5.0, -3.0 / 5.0 }, { 0.0 / 5.0, 4.0 / 5.0, 0.0 / 5.0 }, { -3.0 / 5.0, 0.0 / 5.0, 4.0 / 5.0 } }); RealMatrix sRef = MatrixUtils.createRealMatrix(new double[][] { { 4.0, 0.0, 0.0 }, { 0.0, 3.0, 0.0 }, { 0.0, 0.0, 2.0 } }); RealMatrix vRef = MatrixUtils.createRealMatrix(new double[][] { { 80.0 / 125.0, -60.0 / 125.0, 75.0 / 125.0 }, { 24.0 / 125.0, 107.0 / 125.0, 60.0 / 125.0 }, { -93.0 / 125.0, -24.0 / 125.0, 80.0 / 125.0 } }); // check values against known references SingularValueDecomposition svd = new SingularValueDecomposition(MatrixUtils.createRealMatrix(testNonSquare)); RealMatrix u = svd.getU(); Assert.assertEquals(0, u.subtract(uRef).getNorm(), normTolerance); RealMatrix s = svd.getS(); Assert.assertEquals(0, s.subtract(sRef).getNorm(), normTolerance); RealMatrix v = svd.getV(); Assert.assertEquals(0, v.subtract(vRef).getNorm(), normTolerance); // check the same cached instance is returned the second time Assert.assertTrue(u == svd.getU()); Assert.assertTrue(s == svd.getS()); Assert.assertTrue(v == svd.getV()); } /** test MATH-465 */ @Test public void testRank() { double[][] d = { { 1, 1, 1 }, { 0, 0, 0 }, { 1, 2, 3 } }; RealMatrix m = new Array2DRowRealMatrix(d); SingularValueDecomposition svd = new SingularValueDecomposition(m); Assert.assertEquals(2, svd.getRank()); } /** test MATH-583 */ @Test public void testStability1() { RealMatrix m = new Array2DRowRealMatrix(201, 201); loadRealMatrix(m,"matrix1.csv"); try { new SingularValueDecomposition(m); } catch (Exception e) { Assert.fail("Exception whilst constructing SVD"); } } /** test MATH-327 */ @Test public void testStability2() { RealMatrix m = new Array2DRowRealMatrix(7, 168); loadRealMatrix(m,"matrix2.csv"); try { new SingularValueDecomposition(m); } catch (Throwable e) { Assert.fail("Exception whilst constructing SVD"); } } private void loadRealMatrix(RealMatrix m, String resourceName) { try { DataInputStream in = new DataInputStream(getClass().getResourceAsStream(resourceName)); BufferedReader br = new BufferedReader(new InputStreamReader(in)); String strLine; int row = 0; while ((strLine = br.readLine()) != null) { if (!strLine.startsWith("#")) { int col = 0; for (String entry : strLine.split(",")) { m.setEntry(row, col++, Double.parseDouble(entry)); } row++; } } in.close(); } catch (IOException e) {} } /** test condition number */ @Test public void testConditionNumber() { SingularValueDecomposition svd = new SingularValueDecomposition(MatrixUtils.createRealMatrix(testSquare)); // replace 1.0e-15 with 1.5e-15 Assert.assertEquals(3.0, svd.getConditionNumber(), 1.5e-15); } @Test public void testInverseConditionNumber() { SingularValueDecomposition svd = new SingularValueDecomposition(MatrixUtils.createRealMatrix(testSquare)); Assert.assertEquals(1.0/3.0, svd.getInverseConditionNumber(), 1.5e-15); } private RealMatrix createTestMatrix(final Random r, final int rows, final int columns, final double[] singularValues) { final RealMatrix u = EigenDecompositionTest.createOrthogonalMatrix(r, rows); final RealMatrix d = new Array2DRowRealMatrix(rows, columns); d.setSubMatrix(MatrixUtils.createRealDiagonalMatrix(singularValues).getData(), 0, 0); final RealMatrix v = EigenDecompositionTest.createOrthogonalMatrix(r, columns); return u.multiply(d).multiply(v); } @Test public void testIssue947() { double[][] nans = new double[][] { { Double.NaN, Double.NaN }, { Double.NaN, Double.NaN } }; RealMatrix m = new Array2DRowRealMatrix(nans, false); SingularValueDecomposition svd = new SingularValueDecomposition(m); Assert.assertTrue(Double.isNaN(svd.getSingularValues()[0])); Assert.assertTrue(Double.isNaN(svd.getSingularValues()[1])); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.junit.Assert; import org.junit.Test; public class SingularValueSolverTest { private double[][] testSquare = { { 24.0 / 25.0, 43.0 / 25.0 }, { 57.0 / 25.0, 24.0 / 25.0 } }; private static final double normTolerance = 10e-14; /** test solve dimension errors */ @Test public void testSolveDimensionErrors() { DecompositionSolver solver = new SingularValueDecomposition(MatrixUtils.createRealMatrix(testSquare)).getSolver(); RealMatrix b = MatrixUtils.createRealMatrix(new double[3][2]); try { solver.solve(b); Assert.fail("an exception should have been thrown"); } catch (MathIllegalArgumentException iae) { // expected behavior } try { solver.solve(b.getColumnVector(0)); Assert.fail("an exception should have been thrown"); } catch (MathIllegalArgumentException iae) { // expected behavior } try { solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0))); Assert.fail("an exception should have been thrown"); } catch (MathIllegalArgumentException iae) { // expected behavior } } /** test least square solve */ @Test public void testLeastSquareSolve() { RealMatrix m = MatrixUtils.createRealMatrix(new double[][] { { 1.0, 0.0 }, { 0.0, 0.0 } }); DecompositionSolver solver = new SingularValueDecomposition(m).getSolver(); RealMatrix b = MatrixUtils.createRealMatrix(new double[][] { { 11, 12 }, { 21, 22 } }); RealMatrix xMatrix = solver.solve(b); Assert.assertEquals(11, xMatrix.getEntry(0, 0), 1.0e-15); Assert.assertEquals(12, xMatrix.getEntry(0, 1), 1.0e-15); Assert.assertEquals(0, xMatrix.getEntry(1, 0), 1.0e-15); Assert.assertEquals(0, xMatrix.getEntry(1, 1), 1.0e-15); RealVector xColVec = solver.solve(b.getColumnVector(0)); Assert.assertEquals(11, xColVec.getEntry(0), 1.0e-15); Assert.assertEquals(0, xColVec.getEntry(1), 1.0e-15); RealVector xColOtherVec = solver.solve(new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(0))); Assert.assertEquals(11, xColOtherVec.getEntry(0), 1.0e-15); Assert.assertEquals(0, xColOtherVec.getEntry(1), 1.0e-15); } /** test solve */ @Test public void testSolve() { DecompositionSolver solver = new SingularValueDecomposition(MatrixUtils.createRealMatrix(testSquare)).getSolver(); RealMatrix b = MatrixUtils.createRealMatrix(new double[][] { { 1, 2, 3 }, { 0, -5, 1 } }); RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] { { -8.0 / 25.0, -263.0 / 75.0, -29.0 / 75.0 }, { 19.0 / 25.0, 78.0 / 25.0, 49.0 / 25.0 } }); // using RealMatrix Assert.assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), normTolerance); // using ArrayRealVector for (int i = 0; i < b.getColumnDimension(); ++i) { Assert.assertEquals(0, solver.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(), 1.0e-13); } // using RealVector with an alternate implementation for (int i = 0; i < b.getColumnDimension(); ++i) { ArrayRealVectorTest.RealVectorTestImpl v = new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i)); Assert.assertEquals(0, solver.solve(v).subtract(xRef.getColumnVector(i)).getNorm(), 1.0e-13); } } /** test condition number */ @Test public void testConditionNumber() { SingularValueDecomposition svd = new SingularValueDecomposition(MatrixUtils.createRealMatrix(testSquare)); // replace 1.0e-15 with 1.5e-15 Assert.assertEquals(3.0, svd.getConditionNumber(), 1.5e-15); } @Test public void testMath320B() { RealMatrix rm = new Array2DRowRealMatrix(new double[][] { { 1.0, 2.0 }, { 1.0, 2.0 } }); SingularValueDecomposition svd = new SingularValueDecomposition(rm); RealMatrix recomposed = svd.getU().multiply(svd.getS()).multiply(svd.getVT()); Assert.assertEquals(0.0, recomposed.subtract(rm).getNorm(), 2.0e-15); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import org.junit.Test; import org.junit.Assert; import org.apache.commons.math3.Field; import org.apache.commons.math3.fraction.Fraction; import org.apache.commons.math3.fraction.FractionConversionException; import org.apache.commons.math3.fraction.FractionField; import org.apache.commons.math3.exception.NoDataException; import org.apache.commons.math3.exception.OutOfRangeException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.exception.NullArgumentException; import org.apache.commons.math3.exception.MathIllegalArgumentException; /** * Test cases for the {@link SparseFieldMatrix} class. * * @version $Id$ */ public class SparseFieldMatrixTest { // 3 x 3 identity matrix protected Fraction[][] id = { {new Fraction(1), new Fraction(0), new Fraction(0) }, { new Fraction(0), new Fraction(1), new Fraction(0) }, { new Fraction(0), new Fraction(0), new Fraction(1) } }; // Test data for group operations protected Fraction[][] testData = { { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(5), new Fraction(3) }, { new Fraction(1), new Fraction(0), new Fraction(8) } }; protected Fraction[][] testDataLU = null; protected Fraction[][] testDataPlus2 = { { new Fraction(3), new Fraction(4), new Fraction(5) }, { new Fraction(4), new Fraction(7), new Fraction(5) }, { new Fraction(3), new Fraction(2), new Fraction(10) } }; protected Fraction[][] testDataMinus = { { new Fraction(-1), new Fraction(-2), new Fraction(-3) }, { new Fraction(-2), new Fraction(-5), new Fraction(-3) }, { new Fraction(-1), new Fraction(0), new Fraction(-8) } }; protected Fraction[] testDataRow1 = { new Fraction(1), new Fraction(2), new Fraction(3) }; protected Fraction[] testDataCol3 = { new Fraction(3), new Fraction(3), new Fraction(8) }; protected Fraction[][] testDataInv = { { new Fraction(-40), new Fraction(16), new Fraction(9) }, { new Fraction(13), new Fraction(-5), new Fraction(-3) }, { new Fraction(5), new Fraction(-2), new Fraction(-1) } }; protected Fraction[] preMultTest = { new Fraction(8), new Fraction(12), new Fraction(33) }; protected Fraction[][] testData2 = { { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(5), new Fraction(3) } }; protected Fraction[][] testData2T = { { new Fraction(1), new Fraction(2) }, { new Fraction(2), new Fraction(5) }, { new Fraction(3), new Fraction(3) } }; protected Fraction[][] testDataPlusInv = { { new Fraction(-39), new Fraction(18), new Fraction(12) }, { new Fraction(15), new Fraction(0), new Fraction(0) }, { new Fraction(6), new Fraction(-2), new Fraction(7) } }; // lu decomposition tests protected Fraction[][] luData = { { new Fraction(2), new Fraction(3), new Fraction(3) }, { new Fraction(0), new Fraction(5), new Fraction(7) }, { new Fraction(6), new Fraction(9), new Fraction(8) } }; protected Fraction[][] luDataLUDecomposition = null; // singular matrices protected Fraction[][] singular = { { new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(3) } }; protected Fraction[][] bigSingular = { { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(2), new Fraction(5), new Fraction(3), new Fraction(4) }, { new Fraction(7), new Fraction(3), new Fraction(256), new Fraction(1930) }, { new Fraction(3), new Fraction(7), new Fraction(6), new Fraction(8) } }; // 4th // row // = // 1st // + // 2nd protected Fraction[][] detData = { { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(4), new Fraction(5), new Fraction(6) }, { new Fraction(7), new Fraction(8), new Fraction(10) } }; protected Fraction[][] detData2 = { { new Fraction(1), new Fraction(3) }, { new Fraction(2), new Fraction(4) } }; // vectors protected Fraction[] testVector = { new Fraction(1), new Fraction(2), new Fraction(3) }; protected Fraction[] testVector2 = { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) }; // submatrix accessor tests protected Fraction[][] subTestData = null; // array selections protected Fraction[][] subRows02Cols13 = { {new Fraction(2), new Fraction(4) }, { new Fraction(4), new Fraction(8) } }; protected Fraction[][] subRows03Cols12 = { { new Fraction(2), new Fraction(3) }, { new Fraction(5), new Fraction(6) } }; protected Fraction[][] subRows03Cols123 = { { new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6), new Fraction(7) } }; // effective permutations protected Fraction[][] subRows20Cols123 = { { new Fraction(4), new Fraction(6), new Fraction(8) }, { new Fraction(2), new Fraction(3), new Fraction(4) } }; protected Fraction[][] subRows31Cols31 = null; // contiguous ranges protected Fraction[][] subRows01Cols23 = null; protected Fraction[][] subRows23Cols00 = { { new Fraction(2) }, { new Fraction(4) } }; protected Fraction[][] subRows00Cols33 = { { new Fraction(4) } }; // row matrices protected Fraction[][] subRow0 = { { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) } }; protected Fraction[][] subRow3 = { { new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7) } }; // column matrices protected Fraction[][] subColumn1 = null; protected Fraction[][] subColumn3 = null; // tolerances protected double entryTolerance = 10E-16; protected double normTolerance = 10E-14; protected Field<Fraction> field = FractionField.getInstance(); public SparseFieldMatrixTest() { try { testDataLU = new Fraction[][]{ { new Fraction(2), new Fraction(5), new Fraction(3) }, { new Fraction(.5d), new Fraction(-2.5d), new Fraction(6.5d) }, { new Fraction(0.5d), new Fraction(0.2d), new Fraction(.2d) } }; luDataLUDecomposition = new Fraction[][]{ { new Fraction(6), new Fraction(9), new Fraction(8) }, { new Fraction(0), new Fraction(5), new Fraction(7) }, { new Fraction(0.33333333333333), new Fraction(0), new Fraction(0.33333333333333) } }; subTestData = new Fraction [][]{ { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(1.5), new Fraction(2.5), new Fraction(3.5), new Fraction(4.5) }, { new Fraction(2), new Fraction(4), new Fraction(6), new Fraction(8) }, { new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7) } }; subRows31Cols31 = new Fraction[][]{ { new Fraction(7), new Fraction(5) }, { new Fraction(4.5), new Fraction(2.5) } }; subRows01Cols23 = new Fraction[][]{ { new Fraction(3), new Fraction(4) }, { new Fraction(3.5), new Fraction(4.5) } }; subColumn1 = new Fraction [][]{ { new Fraction(2) }, { new Fraction(2.5) }, { new Fraction(4) }, { new Fraction(5) } }; subColumn3 = new Fraction[][]{ { new Fraction(4) }, { new Fraction(4.5) }, { new Fraction(8) }, { new Fraction(7) } }; } catch (FractionConversionException e) { // ignore, can't happen } } /** test dimensions */ @Test public void testDimensions() { SparseFieldMatrix<Fraction> m = createSparseMatrix(testData); SparseFieldMatrix<Fraction> m2 = createSparseMatrix(testData2); Assert.assertEquals("testData row dimension", 3, m.getRowDimension()); Assert.assertEquals("testData column dimension", 3, m.getColumnDimension()); Assert.assertTrue("testData is square", m.isSquare()); Assert.assertEquals("testData2 row dimension", m2.getRowDimension(), 2); Assert.assertEquals("testData2 column dimension", m2.getColumnDimension(), 3); Assert.assertTrue("testData2 is not square", !m2.isSquare()); } /** test copy functions */ @Test public void testCopyFunctions() { SparseFieldMatrix<Fraction> m1 = createSparseMatrix(testData); FieldMatrix<Fraction> m2 = m1.copy(); Assert.assertEquals(m1.getClass(), m2.getClass()); Assert.assertEquals((m2), m1); SparseFieldMatrix<Fraction> m3 = createSparseMatrix(testData); FieldMatrix<Fraction> m4 = m3.copy(); Assert.assertEquals(m3.getClass(), m4.getClass()); Assert.assertEquals((m4), m3); } /** test add */ @Test public void testAdd() { SparseFieldMatrix<Fraction> m = createSparseMatrix(testData); SparseFieldMatrix<Fraction> mInv = createSparseMatrix(testDataInv); SparseFieldMatrix<Fraction> mDataPlusInv = createSparseMatrix(testDataPlusInv); FieldMatrix<Fraction> mPlusMInv = m.add(mInv); for (int row = 0; row < m.getRowDimension(); row++) { for (int col = 0; col < m.getColumnDimension(); col++) { Assert.assertEquals("sum entry entry", mDataPlusInv.getEntry(row, col).doubleValue(), mPlusMInv.getEntry(row, col).doubleValue(), entryTolerance); } } } /** test add failure */ @Test public void testAddFail() { SparseFieldMatrix<Fraction> m = createSparseMatrix(testData); SparseFieldMatrix<Fraction> m2 = createSparseMatrix(testData2); try { m.add(m2); Assert.fail("MathIllegalArgumentException expected"); } catch (MathIllegalArgumentException ex) { // ignored } } /** test m-n = m + -n */ @Test public void testPlusMinus() { SparseFieldMatrix<Fraction> m = createSparseMatrix(testData); SparseFieldMatrix<Fraction> n = createSparseMatrix(testDataInv); assertClose("m-n = m + -n", m.subtract(n), n.scalarMultiply(new Fraction(-1)).add(m), entryTolerance); try { m.subtract(createSparseMatrix(testData2)); Assert.fail("Expecting illegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } } /** test multiply */ @Test public void testMultiply() { SparseFieldMatrix<Fraction> m = createSparseMatrix(testData); SparseFieldMatrix<Fraction> mInv = createSparseMatrix(testDataInv); SparseFieldMatrix<Fraction> identity = createSparseMatrix(id); SparseFieldMatrix<Fraction> m2 = createSparseMatrix(testData2); assertClose("inverse multiply", m.multiply(mInv), identity, entryTolerance); assertClose("inverse multiply", m.multiply(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testDataInv)), identity, entryTolerance); assertClose("inverse multiply", mInv.multiply(m), identity, entryTolerance); assertClose("identity multiply", m.multiply(identity), m, entryTolerance); assertClose("identity multiply", identity.multiply(mInv), mInv, entryTolerance); assertClose("identity multiply", m2.multiply(identity), m2, entryTolerance); try { m.multiply(createSparseMatrix(bigSingular)); Assert.fail("Expecting illegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } } // Additional Test for Array2DRowRealMatrixTest.testMultiply private Fraction[][] d3 = new Fraction[][] { { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8) } }; private Fraction[][] d4 = new Fraction[][] { { new Fraction(1) }, { new Fraction(2) }, { new Fraction(3) }, { new Fraction(4) } }; private Fraction[][] d5 = new Fraction[][] { { new Fraction(30) }, { new Fraction(70) } }; @Test public void testMultiply2() { FieldMatrix<Fraction> m3 = createSparseMatrix(d3); FieldMatrix<Fraction> m4 = createSparseMatrix(d4); FieldMatrix<Fraction> m5 = createSparseMatrix(d5); assertClose("m3*m4=m5", m3.multiply(m4), m5, entryTolerance); } /** test trace */ @Test public void testTrace() { FieldMatrix<Fraction> m = createSparseMatrix(id); Assert.assertEquals("identity trace", 3d, m.getTrace().doubleValue(), entryTolerance); m = createSparseMatrix(testData2); try { m.getTrace(); Assert.fail("Expecting NonSquareMatrixException"); } catch (NonSquareMatrixException ex) { // ignored } } /** test sclarAdd */ @Test public void testScalarAdd() { FieldMatrix<Fraction> m = createSparseMatrix(testData); assertClose("scalar add", createSparseMatrix(testDataPlus2), m.scalarAdd(new Fraction(2)), entryTolerance); } /** test operate */ @Test public void testOperate() { FieldMatrix<Fraction> m = createSparseMatrix(id); assertClose("identity operate", testVector, m.operate(testVector), entryTolerance); assertClose("identity operate", testVector, m.operate( new ArrayFieldVector<Fraction>(testVector)).getData(), entryTolerance); m = createSparseMatrix(bigSingular); try { m.operate(testVector); Assert.fail("Expecting illegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } } /** test issue MATH-209 */ @Test public void testMath209() { FieldMatrix<Fraction> a = createSparseMatrix(new Fraction[][] { { new Fraction(1), new Fraction(2) }, { new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6) } }); Fraction[] b = a.operate(new Fraction[] { new Fraction(1), new Fraction(1) }); Assert.assertEquals(a.getRowDimension(), b.length); Assert.assertEquals(3.0, b[0].doubleValue(), 1.0e-12); Assert.assertEquals(7.0, b[1].doubleValue(), 1.0e-12); Assert.assertEquals(11.0, b[2].doubleValue(), 1.0e-12); } /** test transpose */ @Test public void testTranspose() { FieldMatrix<Fraction> m = createSparseMatrix(testData); FieldMatrix<Fraction> mIT = new FieldLUDecomposition<Fraction>(m).getSolver().getInverse().transpose(); FieldMatrix<Fraction> mTI = new FieldLUDecomposition<Fraction>(m.transpose()).getSolver().getInverse(); assertClose("inverse-transpose", mIT, mTI, normTolerance); m = createSparseMatrix(testData2); FieldMatrix<Fraction> mt = createSparseMatrix(testData2T); assertClose("transpose",mt,m.transpose(),normTolerance); } /** test preMultiply by vector */ @Test public void testPremultiplyVector() { FieldMatrix<Fraction> m = createSparseMatrix(testData); assertClose("premultiply", m.preMultiply(testVector), preMultTest, normTolerance); assertClose("premultiply", m.preMultiply( new ArrayFieldVector<Fraction>(testVector).getData()), preMultTest, normTolerance); m = createSparseMatrix(bigSingular); try { m.preMultiply(testVector); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } } @Test public void testPremultiply() { FieldMatrix<Fraction> m3 = createSparseMatrix(d3); FieldMatrix<Fraction> m4 = createSparseMatrix(d4); FieldMatrix<Fraction> m5 = createSparseMatrix(d5); assertClose("m3*m4=m5", m4.preMultiply(m3), m5, entryTolerance); SparseFieldMatrix<Fraction> m = createSparseMatrix(testData); SparseFieldMatrix<Fraction> mInv = createSparseMatrix(testDataInv); SparseFieldMatrix<Fraction> identity = createSparseMatrix(id); assertClose("inverse multiply", m.preMultiply(mInv), identity, entryTolerance); assertClose("inverse multiply", mInv.preMultiply(m), identity, entryTolerance); assertClose("identity multiply", m.preMultiply(identity), m, entryTolerance); assertClose("identity multiply", identity.preMultiply(mInv), mInv, entryTolerance); try { m.preMultiply(createSparseMatrix(bigSingular)); Assert.fail("Expecting illegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } } @Test public void testGetVectors() { FieldMatrix<Fraction> m = createSparseMatrix(testData); assertClose("get row", m.getRow(0), testDataRow1, entryTolerance); assertClose("get col", m.getColumn(2), testDataCol3, entryTolerance); try { m.getRow(10); Assert.fail("expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // ignored } try { m.getColumn(-1); Assert.fail("expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // ignored } } @Test public void testGetEntry() { FieldMatrix<Fraction> m = createSparseMatrix(testData); Assert.assertEquals("get entry", m.getEntry(0, 1).doubleValue(), 2d, entryTolerance); try { m.getEntry(10, 4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } /** test examples in user guide */ @Test public void testExamples() { // Create a real matrix with two rows and three columns Fraction[][] matrixData = { { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(5), new Fraction(3) } }; FieldMatrix<Fraction> m = createSparseMatrix(matrixData); // One more with three rows, two columns Fraction[][] matrixData2 = { { new Fraction(1), new Fraction(2) }, { new Fraction(2), new Fraction(5) }, { new Fraction(1), new Fraction(7) } }; FieldMatrix<Fraction> n = createSparseMatrix(matrixData2); // Now multiply m by n FieldMatrix<Fraction> p = m.multiply(n); Assert.assertEquals(2, p.getRowDimension()); Assert.assertEquals(2, p.getColumnDimension()); // Invert p FieldMatrix<Fraction> pInverse = new FieldLUDecomposition<Fraction>(p).getSolver().getInverse(); Assert.assertEquals(2, pInverse.getRowDimension()); Assert.assertEquals(2, pInverse.getColumnDimension()); // Solve example Fraction[][] coefficientsData = { { new Fraction(2), new Fraction(3), new Fraction(-2) }, { new Fraction(-1), new Fraction(7), new Fraction(6) }, { new Fraction(4), new Fraction(-3), new Fraction(-5) } }; FieldMatrix<Fraction> coefficients = createSparseMatrix(coefficientsData); Fraction[] constants = { new Fraction(1), new Fraction(-2), new Fraction(1) }; Fraction[] solution; solution = new FieldLUDecomposition<Fraction>(coefficients) .getSolver() .solve(new ArrayFieldVector<Fraction>(constants, false)).toArray(); Assert.assertEquals((new Fraction(2).multiply((solution[0])).add(new Fraction(3).multiply(solution[1])).subtract(new Fraction(2).multiply(solution[2]))).doubleValue(), constants[0].doubleValue(), 1E-12); Assert.assertEquals(((new Fraction(-1).multiply(solution[0])).add(new Fraction(7).multiply(solution[1])).add(new Fraction(6).multiply(solution[2]))).doubleValue(), constants[1].doubleValue(), 1E-12); Assert.assertEquals(((new Fraction(4).multiply(solution[0])).subtract(new Fraction(3).multiply( solution[1])).subtract(new Fraction(5).multiply(solution[2]))).doubleValue(), constants[2].doubleValue(), 1E-12); } // test submatrix accessors @Test public void testSubMatrix() { FieldMatrix<Fraction> m = createSparseMatrix(subTestData); FieldMatrix<Fraction> mRows23Cols00 = createSparseMatrix(subRows23Cols00); FieldMatrix<Fraction> mRows00Cols33 = createSparseMatrix(subRows00Cols33); FieldMatrix<Fraction> mRows01Cols23 = createSparseMatrix(subRows01Cols23); FieldMatrix<Fraction> mRows02Cols13 = createSparseMatrix(subRows02Cols13); FieldMatrix<Fraction> mRows03Cols12 = createSparseMatrix(subRows03Cols12); FieldMatrix<Fraction> mRows03Cols123 = createSparseMatrix(subRows03Cols123); FieldMatrix<Fraction> mRows20Cols123 = createSparseMatrix(subRows20Cols123); FieldMatrix<Fraction> mRows31Cols31 = createSparseMatrix(subRows31Cols31); Assert.assertEquals("Rows23Cols00", mRows23Cols00, m.getSubMatrix(2, 3, 0, 0)); Assert.assertEquals("Rows00Cols33", mRows00Cols33, m.getSubMatrix(0, 0, 3, 3)); Assert.assertEquals("Rows01Cols23", mRows01Cols23, m.getSubMatrix(0, 1, 2, 3)); Assert.assertEquals("Rows02Cols13", mRows02Cols13, m.getSubMatrix(new int[] { 0, 2 }, new int[] { 1, 3 })); Assert.assertEquals("Rows03Cols12", mRows03Cols12, m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2 })); Assert.assertEquals("Rows03Cols123", mRows03Cols123, m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2, 3 })); Assert.assertEquals("Rows20Cols123", mRows20Cols123, m.getSubMatrix(new int[] { 2, 0 }, new int[] { 1, 2, 3 })); Assert.assertEquals("Rows31Cols31", mRows31Cols31, m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 })); Assert.assertEquals("Rows31Cols31", mRows31Cols31, m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 })); try { m.getSubMatrix(1, 0, 2, 4); Assert.fail("Expecting NumberIsTooSmallException"); } catch (NumberIsTooSmallException ex) { // expected } try { m.getSubMatrix(-1, 1, 2, 2); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getSubMatrix(1, 0, 2, 2); Assert.fail("Expecting NumberIsTooSmallException"); } catch (NumberIsTooSmallException ex) { // expected } try { m.getSubMatrix(1, 0, 2, 4); Assert.fail("Expecting NumberIsTooSmallException"); } catch (NumberIsTooSmallException ex) { // expected } try { m.getSubMatrix(new int[] {}, new int[] { 0 }); Assert.fail("Expecting NoDataException"); } catch (NoDataException ex) { // expected } try { m.getSubMatrix(new int[] { 0 }, new int[] { 4 }); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testGetRowMatrix() { FieldMatrix<Fraction> m = createSparseMatrix(subTestData); FieldMatrix<Fraction> mRow0 = createSparseMatrix(subRow0); FieldMatrix<Fraction> mRow3 = createSparseMatrix(subRow3); Assert.assertEquals("Row0", mRow0, m.getRowMatrix(0)); Assert.assertEquals("Row3", mRow3, m.getRowMatrix(3)); try { m.getRowMatrix(-1); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getRowMatrix(4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testGetColumnMatrix() { FieldMatrix<Fraction> m = createSparseMatrix(subTestData); FieldMatrix<Fraction> mColumn1 = createSparseMatrix(subColumn1); FieldMatrix<Fraction> mColumn3 = createSparseMatrix(subColumn3); Assert.assertEquals("Column1", mColumn1, m.getColumnMatrix(1)); Assert.assertEquals("Column3", mColumn3, m.getColumnMatrix(3)); try { m.getColumnMatrix(-1); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getColumnMatrix(4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testGetRowVector() { FieldMatrix<Fraction> m = createSparseMatrix(subTestData); FieldVector<Fraction> mRow0 = new ArrayFieldVector<Fraction>(subRow0[0]); FieldVector<Fraction> mRow3 = new ArrayFieldVector<Fraction>(subRow3[0]); Assert.assertEquals("Row0", mRow0, m.getRowVector(0)); Assert.assertEquals("Row3", mRow3, m.getRowVector(3)); try { m.getRowVector(-1); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getRowVector(4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testGetColumnVector() { FieldMatrix<Fraction> m = createSparseMatrix(subTestData); FieldVector<Fraction> mColumn1 = columnToVector(subColumn1); FieldVector<Fraction> mColumn3 = columnToVector(subColumn3); Assert.assertEquals("Column1", mColumn1, m.getColumnVector(1)); Assert.assertEquals("Column3", mColumn3, m.getColumnVector(3)); try { m.getColumnVector(-1); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getColumnVector(4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } private FieldVector<Fraction> columnToVector(Fraction[][] column) { Fraction[] data = new Fraction[column.length]; for (int i = 0; i < data.length; ++i) { data[i] = column[i][0]; } return new ArrayFieldVector<Fraction>(data, false); } @Test public void testEqualsAndHashCode() { SparseFieldMatrix<Fraction> m = createSparseMatrix(testData); SparseFieldMatrix<Fraction> m1 = (SparseFieldMatrix<Fraction>) m.copy(); SparseFieldMatrix<Fraction> mt = (SparseFieldMatrix<Fraction>) m.transpose(); Assert.assertTrue(m.hashCode() != mt.hashCode()); Assert.assertEquals(m.hashCode(), m1.hashCode()); Assert.assertEquals(m, m); Assert.assertEquals(m, m1); Assert.assertFalse(m.equals(null)); Assert.assertFalse(m.equals(mt)); Assert.assertFalse(m.equals(createSparseMatrix(bigSingular))); } /* Disable for now @Test public void testToString() { SparseFieldMatrix<Fraction> m = createSparseMatrix(testData); Assert.assertEquals("SparseFieldMatrix<Fraction>{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}", m.toString()); m = new SparseFieldMatrix<Fraction>(field, 1, 1); Assert.assertEquals("SparseFieldMatrix<Fraction>{{0.0}}", m.toString()); } */ @Test public void testSetSubMatrix() { SparseFieldMatrix<Fraction> m = createSparseMatrix(testData); m.setSubMatrix(detData2, 1, 1); FieldMatrix<Fraction> expected = createSparseMatrix(new Fraction[][] { { new Fraction(1), new Fraction(2), new Fraction(3) }, { new Fraction(2), new Fraction(1), new Fraction(3) }, { new Fraction(1), new Fraction(2), new Fraction(4) } }); Assert.assertEquals(expected, m); m.setSubMatrix(detData2, 0, 0); expected = createSparseMatrix(new Fraction[][] { { new Fraction(1), new Fraction(3), new Fraction(3) }, { new Fraction(2), new Fraction(4), new Fraction(3) }, { new Fraction(1), new Fraction(2), new Fraction(4) } }); Assert.assertEquals(expected, m); m.setSubMatrix(testDataPlus2, 0, 0); expected = createSparseMatrix(new Fraction[][] { { new Fraction(3), new Fraction(4), new Fraction(5) }, { new Fraction(4), new Fraction(7), new Fraction(5) }, { new Fraction(3), new Fraction(2), new Fraction(10) } }); Assert.assertEquals(expected, m); // javadoc example SparseFieldMatrix<Fraction> matrix = createSparseMatrix(new Fraction[][] { { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8) }, { new Fraction(9), new Fraction(0), new Fraction(1), new Fraction(2) } }); matrix.setSubMatrix(new Fraction[][] { { new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6) } }, 1, 1); expected = createSparseMatrix(new Fraction[][] { { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(3), new Fraction(4), new Fraction(8) }, { new Fraction(9), new Fraction(5), new Fraction(6), new Fraction(2) } }); Assert.assertEquals(expected, matrix); // dimension overflow try { m.setSubMatrix(testData, 1, 1); Assert.fail("expecting OutOfRangeException"); } catch (OutOfRangeException e) { // expected } // dimension underflow try { m.setSubMatrix(testData, -1, 1); Assert.fail("expecting OutOfRangeException"); } catch (OutOfRangeException e) { // expected } try { m.setSubMatrix(testData, 1, -1); Assert.fail("expecting OutOfRangeException"); } catch (OutOfRangeException e) { // expected } // null try { m.setSubMatrix(null, 1, 1); Assert.fail("expecting NullArgumentException"); } catch (NullArgumentException e) { // expected } try { new SparseFieldMatrix<Fraction>(field, 0, 0); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException e) { // expected } // ragged try { m.setSubMatrix(new Fraction[][] { { new Fraction(1) }, { new Fraction(2), new Fraction(3) } }, 0, 0); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException e) { // expected } // empty try { m.setSubMatrix(new Fraction[][] { {} }, 0, 0); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException e) { // expected } } // --------------- -----------------Protected methods /** verifies that two matrices are close (1-norm) */ protected void assertClose(String msg, FieldMatrix<Fraction> m, FieldMatrix<Fraction> n, double tolerance) { for(int i=0; i < m.getRowDimension(); i++){ for(int j=0; j < m.getColumnDimension(); j++){ Assert.assertEquals(msg, m.getEntry(i,j).doubleValue(), n.getEntry(i,j).doubleValue(), tolerance); } } } /** verifies that two vectors are close (sup norm) */ protected void assertClose(String msg, Fraction[] m, Fraction[] n, double tolerance) { if (m.length != n.length) { Assert.fail("vectors not same length"); } for (int i = 0; i < m.length; i++) { Assert.assertEquals(msg + " " + i + " elements differ", m[i].doubleValue(), n[i].doubleValue(), tolerance); } } private SparseFieldMatrix<Fraction> createSparseMatrix(Fraction[][] data) { SparseFieldMatrix<Fraction> matrix = new SparseFieldMatrix<Fraction>(field, data.length, data[0].length); for (int row = 0; row < data.length; row++) { for (int col = 0; col < data[row].length; col++) { matrix.setEntry(row, col, data[row][col]); } } return matrix; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import org.apache.commons.math3.fraction.Fraction; import org.apache.commons.math3.fraction.FractionConversionException; import org.apache.commons.math3.fraction.FractionField; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.junit.Assert; import org.junit.Test; /** * Test cases for the {@link SparseFieldVector} class. * * @version $Id$ */ public class SparseFieldVectorTest { // protected Fraction[][] ma1 = {{new Fraction(1), new Fraction(2), new Fraction(3)}, {new Fraction(4), new Fraction(5), new Fraction(6)}, {new Fraction(7), new Fraction(8), new Fraction(9)}}; protected Fraction[] vec1 = {new Fraction(1), new Fraction(2), new Fraction(3)}; protected Fraction[] vec2 = {new Fraction(4), new Fraction(5), new Fraction(6)}; protected Fraction[] vec3 = {new Fraction(7), new Fraction(8), new Fraction(9)}; protected Fraction[] vec4 = {new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8), new Fraction(9)}; protected Fraction[] vec_null = {new Fraction(0), new Fraction(0), new Fraction(0)}; protected Fraction[] dvec1 = {new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8),new Fraction(9)}; protected Fraction[][] mat1 = {{new Fraction(1), new Fraction(2), new Fraction(3)}, {new Fraction(4), new Fraction(5), new Fraction(6)},{ new Fraction(7), new Fraction(8), new Fraction(9)}}; // tolerances protected double entryTolerance = 10E-16; protected double normTolerance = 10E-14; protected FractionField field = FractionField.getInstance(); @Test public void testMapFunctions() throws FractionConversionException { SparseFieldVector<Fraction> v1 = new SparseFieldVector<Fraction>(field,vec1); //octave = v1 .+ 2.0 FieldVector<Fraction> v_mapAdd = v1.mapAdd(new Fraction(2)); Fraction[] result_mapAdd = {new Fraction(3), new Fraction(4), new Fraction(5)}; Assert.assertArrayEquals("compare vectors" ,result_mapAdd,v_mapAdd.getData()); //octave = v1 .+ 2.0 FieldVector<Fraction> v_mapAddToSelf = v1.copy(); v_mapAddToSelf.mapAddToSelf(new Fraction(2)); Fraction[] result_mapAddToSelf = {new Fraction(3), new Fraction(4), new Fraction(5)}; Assert.assertArrayEquals("compare vectors" ,result_mapAddToSelf,v_mapAddToSelf.getData()); //octave = v1 .- 2.0 FieldVector<Fraction> v_mapSubtract = v1.mapSubtract(new Fraction(2)); Fraction[] result_mapSubtract = {new Fraction(-1), new Fraction(0), new Fraction(1)}; Assert.assertArrayEquals("compare vectors" ,result_mapSubtract,v_mapSubtract.getData()); //octave = v1 .- 2.0 FieldVector<Fraction> v_mapSubtractToSelf = v1.copy(); v_mapSubtractToSelf.mapSubtractToSelf(new Fraction(2)); Fraction[] result_mapSubtractToSelf = {new Fraction(-1), new Fraction(0), new Fraction(1)}; Assert.assertArrayEquals("compare vectors" ,result_mapSubtractToSelf,v_mapSubtractToSelf.getData()); //octave = v1 .* 2.0 FieldVector<Fraction> v_mapMultiply = v1.mapMultiply(new Fraction(2)); Fraction[] result_mapMultiply = {new Fraction(2), new Fraction(4), new Fraction(6)}; Assert.assertArrayEquals("compare vectors" ,result_mapMultiply,v_mapMultiply.getData()); //octave = v1 .* 2.0 FieldVector<Fraction> v_mapMultiplyToSelf = v1.copy(); v_mapMultiplyToSelf.mapMultiplyToSelf(new Fraction(2)); Fraction[] result_mapMultiplyToSelf = {new Fraction(2), new Fraction(4), new Fraction(6)}; Assert.assertArrayEquals("compare vectors" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData()); //octave = v1 ./ 2.0 FieldVector<Fraction> v_mapDivide = v1.mapDivide(new Fraction(2)); Fraction[] result_mapDivide = {new Fraction(.5d), new Fraction(1), new Fraction(1.5d)}; Assert.assertArrayEquals("compare vectors" ,result_mapDivide,v_mapDivide.getData()); //octave = v1 ./ 2.0 FieldVector<Fraction> v_mapDivideToSelf = v1.copy(); v_mapDivideToSelf.mapDivideToSelf(new Fraction(2)); Fraction[] result_mapDivideToSelf = {new Fraction(.5d), new Fraction(1), new Fraction(1.5d)}; Assert.assertArrayEquals("compare vectors" ,result_mapDivideToSelf,v_mapDivideToSelf.getData()); //octave = v1 .^-1 FieldVector<Fraction> v_mapInv = v1.mapInv(); Fraction[] result_mapInv = {new Fraction(1),new Fraction(0.5d),new Fraction(3.333333333333333e-01d)}; Assert.assertArrayEquals("compare vectors" ,result_mapInv,v_mapInv.getData()); //octave = v1 .^-1 FieldVector<Fraction> v_mapInvToSelf = v1.copy(); v_mapInvToSelf.mapInvToSelf(); Fraction[] result_mapInvToSelf = {new Fraction(1),new Fraction(0.5d),new Fraction(3.333333333333333e-01d)}; Assert.assertArrayEquals("compare vectors" ,result_mapInvToSelf,v_mapInvToSelf.getData()); } @Test public void testBasicFunctions() throws FractionConversionException { SparseFieldVector<Fraction> v1 = new SparseFieldVector<Fraction>(field,vec1); SparseFieldVector<Fraction> v2 = new SparseFieldVector<Fraction>(field,vec2); FieldVector<Fraction> v2_t = new ArrayFieldVectorTest.FieldVectorTestImpl<Fraction>(vec2); //octave = v1 + v2 FieldVector<Fraction> v_add = v1.add(v2); Fraction[] result_add = {new Fraction(5), new Fraction(7), new Fraction(9)}; Assert.assertArrayEquals("compare vect" ,v_add.getData(),result_add); FieldVector<Fraction> vt2 = new ArrayFieldVectorTest.FieldVectorTestImpl<Fraction>(vec2); FieldVector<Fraction> v_add_i = v1.add(vt2); Fraction[] result_add_i = {new Fraction(5), new Fraction(7), new Fraction(9)}; Assert.assertArrayEquals("compare vect" ,v_add_i.getData(),result_add_i); //octave = v1 - v2 SparseFieldVector<Fraction> v_subtract = v1.subtract(v2); Fraction[] result_subtract = {new Fraction(-3), new Fraction(-3), new Fraction(-3)}; assertClose("compare vect" ,v_subtract.getData(),result_subtract,normTolerance); FieldVector<Fraction> v_subtract_i = v1.subtract(vt2); Fraction[] result_subtract_i = {new Fraction(-3), new Fraction(-3), new Fraction(-3)}; assertClose("compare vect" ,v_subtract_i.getData(),result_subtract_i,normTolerance); // octave v1 .* v2 FieldVector<Fraction> v_ebeMultiply = v1.ebeMultiply(v2); Fraction[] result_ebeMultiply = {new Fraction(4), new Fraction(10), new Fraction(18)}; assertClose("compare vect" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance); FieldVector<Fraction> v_ebeMultiply_2 = v1.ebeMultiply(v2_t); Fraction[] result_ebeMultiply_2 = {new Fraction(4), new Fraction(10), new Fraction(18)}; assertClose("compare vect" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance); // octave v1 ./ v2 FieldVector<Fraction> v_ebeDivide = v1.ebeDivide(v2); Fraction[] result_ebeDivide = {new Fraction(0.25d), new Fraction(0.4d), new Fraction(0.5d)}; assertClose("compare vect" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance); FieldVector<Fraction> v_ebeDivide_2 = v1.ebeDivide(v2_t); Fraction[] result_ebeDivide_2 = {new Fraction(0.25d), new Fraction(0.4d), new Fraction(0.5d)}; assertClose("compare vect" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance); // octave dot(v1,v2) Fraction dot = v1.dotProduct(v2); Assert.assertEquals("compare val ",new Fraction(32), dot); // octave dot(v1,v2_t) Fraction dot_2 = v1.dotProduct(v2_t); Assert.assertEquals("compare val ",new Fraction(32), dot_2); FieldMatrix<Fraction> m_outerProduct = v1.outerProduct(v2); Assert.assertEquals("compare val ",new Fraction(4), m_outerProduct.getEntry(0,0)); FieldMatrix<Fraction> m_outerProduct_2 = v1.outerProduct(v2_t); Assert.assertEquals("compare val ",new Fraction(4), m_outerProduct_2.getEntry(0,0)); } @Test public void testOuterProduct() { final SparseFieldVector<Fraction> u = new SparseFieldVector<Fraction>(FractionField.getInstance(), new Fraction[] {new Fraction(1), new Fraction(2), new Fraction(-3)}); final SparseFieldVector<Fraction> v = new SparseFieldVector<Fraction>(FractionField.getInstance(), new Fraction[] {new Fraction(4), new Fraction(-2)}); final FieldMatrix<Fraction> uv = u.outerProduct(v); final double tol = Math.ulp(1d); Assert.assertEquals(new Fraction(4).doubleValue(), uv.getEntry(0, 0).doubleValue(), tol); Assert.assertEquals(new Fraction(-2).doubleValue(), uv.getEntry(0, 1).doubleValue(), tol); Assert.assertEquals(new Fraction(8).doubleValue(), uv.getEntry(1, 0).doubleValue(), tol); Assert.assertEquals(new Fraction(-4).doubleValue(), uv.getEntry(1, 1).doubleValue(), tol); Assert.assertEquals(new Fraction(-12).doubleValue(), uv.getEntry(2, 0).doubleValue(), tol); Assert.assertEquals(new Fraction(6).doubleValue(), uv.getEntry(2, 1).doubleValue(), tol); } @Test public void testMisc() { SparseFieldVector<Fraction> v1 = new SparseFieldVector<Fraction>(field,vec1); String out1 = v1.toString(); Assert.assertTrue("some output ", out1.length()!=0); try { v1.checkVectorDimensions(2); Assert.fail("MathIllegalArgumentException expected"); } catch (MathIllegalArgumentException ex) { // expected behavior } } @Test public void testPredicates() { SparseFieldVector<Fraction> v = new SparseFieldVector<Fraction>(field, new Fraction[] { new Fraction(0), new Fraction(1), new Fraction(2) }); v.setEntry(0, field.getZero()); Assert.assertEquals(v, new SparseFieldVector<Fraction>(field, new Fraction[] { new Fraction(0), new Fraction(1), new Fraction(2) })); Assert.assertNotSame(v, new SparseFieldVector<Fraction>(field, new Fraction[] { new Fraction(0), new Fraction(1), new Fraction(2), new Fraction(3) })); } /** verifies that two vectors are close (sup norm) */ protected void assertEquals(String msg, Fraction[] m, Fraction[] n) { if (m.length != n.length) { Assert.fail("vectors have different lengths"); } for (int i = 0; i < m.length; i++) { Assert.assertEquals(msg + " " + i + " elements differ", m[i],n[i]); } } /** verifies that two vectors are close (sup norm) */ protected void assertClose(String msg, Fraction[] m, Fraction[] n, double tolerance) { if (m.length != n.length) { Assert.fail("vectors have different lengths"); } for (int i = 0; i < m.length; i++) { Assert.assertEquals(msg + " " + i + " elements differ", m[i].doubleValue(),n[i].doubleValue(), tolerance); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import org.junit.Test; import org.junit.Assert; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.exception.NullArgumentException; import org.apache.commons.math3.exception.OutOfRangeException; import org.apache.commons.math3.exception.NoDataException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.exception.MathIllegalArgumentException; /** * Test cases for the {@link OpenMapRealMatrix} class. * * @version $Id$ */ public final class SparseRealMatrixTest { // 3 x 3 identity matrix protected double[][] id = { { 1d, 0d, 0d }, { 0d, 1d, 0d }, { 0d, 0d, 1d } }; // Test data for group operations protected double[][] testData = { { 1d, 2d, 3d }, { 2d, 5d, 3d }, { 1d, 0d, 8d } }; protected double[][] testDataLU = { { 2d, 5d, 3d }, { .5d, -2.5d, 6.5d }, { 0.5d, 0.2d, .2d } }; protected double[][] testDataPlus2 = { { 3d, 4d, 5d }, { 4d, 7d, 5d }, { 3d, 2d, 10d } }; protected double[][] testDataMinus = { { -1d, -2d, -3d }, { -2d, -5d, -3d }, { -1d, 0d, -8d } }; protected double[] testDataRow1 = { 1d, 2d, 3d }; protected double[] testDataCol3 = { 3d, 3d, 8d }; protected double[][] testDataInv = { { -40d, 16d, 9d }, { 13d, -5d, -3d }, { 5d, -2d, -1d } }; protected double[] preMultTest = { 8, 12, 33 }; protected double[][] testData2 = { { 1d, 2d, 3d }, { 2d, 5d, 3d } }; protected double[][] testData2T = { { 1d, 2d }, { 2d, 5d }, { 3d, 3d } }; protected double[][] testDataPlusInv = { { -39d, 18d, 12d }, { 15d, 0d, 0d }, { 6d, -2d, 7d } }; // lu decomposition tests protected double[][] luData = { { 2d, 3d, 3d }, { 0d, 5d, 7d }, { 6d, 9d, 8d } }; protected double[][] luDataLUDecomposition = { { 6d, 9d, 8d }, { 0d, 5d, 7d }, { 0.33333333333333, 0d, 0.33333333333333 } }; // singular matrices protected double[][] singular = { { 2d, 3d }, { 2d, 3d } }; protected double[][] bigSingular = { { 1d, 2d, 3d, 4d }, { 2d, 5d, 3d, 4d }, { 7d, 3d, 256d, 1930d }, { 3d, 7d, 6d, 8d } }; // 4th // row // = // 1st // + // 2nd protected double[][] detData = { { 1d, 2d, 3d }, { 4d, 5d, 6d }, { 7d, 8d, 10d } }; protected double[][] detData2 = { { 1d, 3d }, { 2d, 4d } }; // vectors protected double[] testVector = { 1, 2, 3 }; protected double[] testVector2 = { 1, 2, 3, 4 }; // submatrix accessor tests protected double[][] subTestData = { { 1, 2, 3, 4 }, { 1.5, 2.5, 3.5, 4.5 }, { 2, 4, 6, 8 }, { 4, 5, 6, 7 } }; // array selections protected double[][] subRows02Cols13 = { { 2, 4 }, { 4, 8 } }; protected double[][] subRows03Cols12 = { { 2, 3 }, { 5, 6 } }; protected double[][] subRows03Cols123 = { { 2, 3, 4 }, { 5, 6, 7 } }; // effective permutations protected double[][] subRows20Cols123 = { { 4, 6, 8 }, { 2, 3, 4 } }; protected double[][] subRows31Cols31 = { { 7, 5 }, { 4.5, 2.5 } }; // contiguous ranges protected double[][] subRows01Cols23 = { { 3, 4 }, { 3.5, 4.5 } }; protected double[][] subRows23Cols00 = { { 2 }, { 4 } }; protected double[][] subRows00Cols33 = { { 4 } }; // row matrices protected double[][] subRow0 = { { 1, 2, 3, 4 } }; protected double[][] subRow3 = { { 4, 5, 6, 7 } }; // column matrices protected double[][] subColumn1 = { { 2 }, { 2.5 }, { 4 }, { 5 } }; protected double[][] subColumn3 = { { 4 }, { 4.5 }, { 8 }, { 7 } }; // tolerances protected double entryTolerance = 10E-16; protected double normTolerance = 10E-14; /** test dimensions */ @Test public void testDimensions() { OpenMapRealMatrix m = createSparseMatrix(testData); OpenMapRealMatrix m2 = createSparseMatrix(testData2); Assert.assertEquals("testData row dimension", 3, m.getRowDimension()); Assert.assertEquals("testData column dimension", 3, m.getColumnDimension()); Assert.assertTrue("testData is square", m.isSquare()); Assert.assertEquals("testData2 row dimension", m2.getRowDimension(), 2); Assert.assertEquals("testData2 column dimension", m2.getColumnDimension(), 3); Assert.assertTrue("testData2 is not square", !m2.isSquare()); } /** test copy functions */ @Test public void testCopyFunctions() { OpenMapRealMatrix m1 = createSparseMatrix(testData); RealMatrix m2 = m1.copy(); Assert.assertEquals(m1.getClass(), m2.getClass()); Assert.assertEquals((m2), m1); OpenMapRealMatrix m3 = createSparseMatrix(testData); RealMatrix m4 = m3.copy(); Assert.assertEquals(m3.getClass(), m4.getClass()); Assert.assertEquals((m4), m3); } /** test add */ @Test public void testAdd() { OpenMapRealMatrix m = createSparseMatrix(testData); OpenMapRealMatrix mInv = createSparseMatrix(testDataInv); OpenMapRealMatrix mDataPlusInv = createSparseMatrix(testDataPlusInv); RealMatrix mPlusMInv = m.add(mInv); for (int row = 0; row < m.getRowDimension(); row++) { for (int col = 0; col < m.getColumnDimension(); col++) { Assert.assertEquals("sum entry entry", mDataPlusInv.getEntry(row, col), mPlusMInv.getEntry(row, col), entryTolerance); } } } /** test add failure */ @Test public void testAddFail() { OpenMapRealMatrix m = createSparseMatrix(testData); OpenMapRealMatrix m2 = createSparseMatrix(testData2); try { m.add(m2); Assert.fail("MathIllegalArgumentException expected"); } catch (MathIllegalArgumentException ex) { // ignored } } /** test norm */ @Test public void testNorm() { OpenMapRealMatrix m = createSparseMatrix(testData); OpenMapRealMatrix m2 = createSparseMatrix(testData2); Assert.assertEquals("testData norm", 14d, m.getNorm(), entryTolerance); Assert.assertEquals("testData2 norm", 7d, m2.getNorm(), entryTolerance); } /** test m-n = m + -n */ @Test public void testPlusMinus() { OpenMapRealMatrix m = createSparseMatrix(testData); OpenMapRealMatrix n = createSparseMatrix(testDataInv); assertClose("m-n = m + -n", m.subtract(n), n.scalarMultiply(-1d).add(m), entryTolerance); try { m.subtract(createSparseMatrix(testData2)); Assert.fail("Expecting illegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } } /** test multiply */ @Test public void testMultiply() { OpenMapRealMatrix m = createSparseMatrix(testData); OpenMapRealMatrix mInv = createSparseMatrix(testDataInv); OpenMapRealMatrix identity = createSparseMatrix(id); OpenMapRealMatrix m2 = createSparseMatrix(testData2); assertClose("inverse multiply", m.multiply(mInv), identity, entryTolerance); assertClose("inverse multiply", m.multiply(new BlockRealMatrix(testDataInv)), identity, entryTolerance); assertClose("inverse multiply", mInv.multiply(m), identity, entryTolerance); assertClose("identity multiply", m.multiply(identity), m, entryTolerance); assertClose("identity multiply", identity.multiply(mInv), mInv, entryTolerance); assertClose("identity multiply", m2.multiply(identity), m2, entryTolerance); try { m.multiply(createSparseMatrix(bigSingular)); Assert.fail("Expecting illegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } } // Additional Test for Array2DRowRealMatrixTest.testMultiply private double[][] d3 = new double[][] { { 1, 2, 3, 4 }, { 5, 6, 7, 8 } }; private double[][] d4 = new double[][] { { 1 }, { 2 }, { 3 }, { 4 } }; private double[][] d5 = new double[][] { { 30 }, { 70 } }; @Test public void testMultiply2() { RealMatrix m3 = createSparseMatrix(d3); RealMatrix m4 = createSparseMatrix(d4); RealMatrix m5 = createSparseMatrix(d5); assertClose("m3*m4=m5", m3.multiply(m4), m5, entryTolerance); } /** test trace */ @Test public void testTrace() { RealMatrix m = createSparseMatrix(id); Assert.assertEquals("identity trace", 3d, m.getTrace(), entryTolerance); m = createSparseMatrix(testData2); try { m.getTrace(); Assert.fail("Expecting NonSquareMatrixException"); } catch (NonSquareMatrixException ex) { // ignored } } /** test sclarAdd */ @Test public void testScalarAdd() { RealMatrix m = createSparseMatrix(testData); assertClose("scalar add", createSparseMatrix(testDataPlus2), m.scalarAdd(2d), entryTolerance); } /** test operate */ @Test public void testOperate() { RealMatrix m = createSparseMatrix(id); assertClose("identity operate", testVector, m.operate(testVector), entryTolerance); assertClose("identity operate", testVector, m.operate( new ArrayRealVector(testVector)).toArray(), entryTolerance); m = createSparseMatrix(bigSingular); try { m.operate(testVector); Assert.fail("Expecting illegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } } /** test issue MATH-209 */ @Test public void testMath209() { RealMatrix a = createSparseMatrix(new double[][] { { 1, 2 }, { 3, 4 }, { 5, 6 } }); double[] b = a.operate(new double[] { 1, 1 }); Assert.assertEquals(a.getRowDimension(), b.length); Assert.assertEquals(3.0, b[0], 1.0e-12); Assert.assertEquals(7.0, b[1], 1.0e-12); Assert.assertEquals(11.0, b[2], 1.0e-12); } /** test transpose */ @Test public void testTranspose() { RealMatrix m = createSparseMatrix(testData); RealMatrix mIT = new LUDecomposition(m).getSolver().getInverse().transpose(); RealMatrix mTI = new LUDecomposition(m.transpose()).getSolver().getInverse(); assertClose("inverse-transpose", mIT, mTI, normTolerance); m = createSparseMatrix(testData2); RealMatrix mt = createSparseMatrix(testData2T); assertClose("transpose",mt,m.transpose(),normTolerance); } /** test preMultiply by vector */ @Test public void testPremultiplyVector() { RealMatrix m = createSparseMatrix(testData); assertClose("premultiply", m.preMultiply(testVector), preMultTest, normTolerance); assertClose("premultiply", m.preMultiply( new ArrayRealVector(testVector).toArray()), preMultTest, normTolerance); m = createSparseMatrix(bigSingular); try { m.preMultiply(testVector); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } } @Test public void testPremultiply() { RealMatrix m3 = createSparseMatrix(d3); RealMatrix m4 = createSparseMatrix(d4); RealMatrix m5 = createSparseMatrix(d5); assertClose("m3*m4=m5", m4.preMultiply(m3), m5, entryTolerance); OpenMapRealMatrix m = createSparseMatrix(testData); OpenMapRealMatrix mInv = createSparseMatrix(testDataInv); OpenMapRealMatrix identity = createSparseMatrix(id); assertClose("inverse multiply", m.preMultiply(mInv), identity, entryTolerance); assertClose("inverse multiply", mInv.preMultiply(m), identity, entryTolerance); assertClose("identity multiply", m.preMultiply(identity), m, entryTolerance); assertClose("identity multiply", identity.preMultiply(mInv), mInv, entryTolerance); try { m.preMultiply(createSparseMatrix(bigSingular)); Assert.fail("Expecting illegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } } @Test public void testGetVectors() { RealMatrix m = createSparseMatrix(testData); assertClose("get row", m.getRow(0), testDataRow1, entryTolerance); assertClose("get col", m.getColumn(2), testDataCol3, entryTolerance); try { m.getRow(10); Assert.fail("expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // ignored } try { m.getColumn(-1); Assert.fail("expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // ignored } } @Test public void testGetEntry() { RealMatrix m = createSparseMatrix(testData); Assert.assertEquals("get entry", m.getEntry(0, 1), 2d, entryTolerance); try { m.getEntry(10, 4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } /** test examples in user guide */ @Test public void testExamples() { // Create a real matrix with two rows and three columns double[][] matrixData = { { 1d, 2d, 3d }, { 2d, 5d, 3d } }; RealMatrix m = createSparseMatrix(matrixData); // One more with three rows, two columns double[][] matrixData2 = { { 1d, 2d }, { 2d, 5d }, { 1d, 7d } }; RealMatrix n = createSparseMatrix(matrixData2); // Now multiply m by n RealMatrix p = m.multiply(n); Assert.assertEquals(2, p.getRowDimension()); Assert.assertEquals(2, p.getColumnDimension()); // Invert p RealMatrix pInverse = new LUDecomposition(p).getSolver().getInverse(); Assert.assertEquals(2, pInverse.getRowDimension()); Assert.assertEquals(2, pInverse.getColumnDimension()); // Solve example double[][] coefficientsData = { { 2, 3, -2 }, { -1, 7, 6 }, { 4, -3, -5 } }; RealMatrix coefficients = createSparseMatrix(coefficientsData); RealVector constants = new ArrayRealVector(new double[]{ 1, -2, 1 }, false); RealVector solution = new LUDecomposition(coefficients).getSolver().solve(constants); final double cst0 = constants.getEntry(0); final double cst1 = constants.getEntry(1); final double cst2 = constants.getEntry(2); final double sol0 = solution.getEntry(0); final double sol1 = solution.getEntry(1); final double sol2 = solution.getEntry(2); Assert.assertEquals(2 * sol0 + 3 * sol1 - 2 * sol2, cst0, 1E-12); Assert.assertEquals(-1 * sol0 + 7 * sol1 + 6 * sol2, cst1, 1E-12); Assert.assertEquals(4 * sol0 - 3 * sol1 - 5 * sol2, cst2, 1E-12); } // test submatrix accessors @Test public void testSubMatrix() { RealMatrix m = createSparseMatrix(subTestData); RealMatrix mRows23Cols00 = createSparseMatrix(subRows23Cols00); RealMatrix mRows00Cols33 = createSparseMatrix(subRows00Cols33); RealMatrix mRows01Cols23 = createSparseMatrix(subRows01Cols23); RealMatrix mRows02Cols13 = createSparseMatrix(subRows02Cols13); RealMatrix mRows03Cols12 = createSparseMatrix(subRows03Cols12); RealMatrix mRows03Cols123 = createSparseMatrix(subRows03Cols123); RealMatrix mRows20Cols123 = createSparseMatrix(subRows20Cols123); RealMatrix mRows31Cols31 = createSparseMatrix(subRows31Cols31); Assert.assertEquals("Rows23Cols00", mRows23Cols00, m.getSubMatrix(2, 3, 0, 0)); Assert.assertEquals("Rows00Cols33", mRows00Cols33, m.getSubMatrix(0, 0, 3, 3)); Assert.assertEquals("Rows01Cols23", mRows01Cols23, m.getSubMatrix(0, 1, 2, 3)); Assert.assertEquals("Rows02Cols13", mRows02Cols13, m.getSubMatrix(new int[] { 0, 2 }, new int[] { 1, 3 })); Assert.assertEquals("Rows03Cols12", mRows03Cols12, m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2 })); Assert.assertEquals("Rows03Cols123", mRows03Cols123, m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2, 3 })); Assert.assertEquals("Rows20Cols123", mRows20Cols123, m.getSubMatrix(new int[] { 2, 0 }, new int[] { 1, 2, 3 })); Assert.assertEquals("Rows31Cols31", mRows31Cols31, m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 })); Assert.assertEquals("Rows31Cols31", mRows31Cols31, m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 })); try { m.getSubMatrix(1, 0, 2, 4); Assert.fail("Expecting NumberIsTooSmallException"); } catch (NumberIsTooSmallException ex) { // expected } try { m.getSubMatrix(-1, 1, 2, 2); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getSubMatrix(1, 0, 2, 2); Assert.fail("Expecting NumberIsTooSmallException"); } catch (NumberIsTooSmallException ex) { // expected } try { m.getSubMatrix(1, 0, 2, 4); Assert.fail("Expecting NumberIsTooSmallException"); } catch (NumberIsTooSmallException ex) { // expected } try { m.getSubMatrix(new int[] {}, new int[] { 0 }); Assert.fail("Expecting NoDataException"); } catch (NoDataException ex) { // expected } try { m.getSubMatrix(new int[] { 0 }, new int[] { 4 }); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testGetRowMatrix() { RealMatrix m = createSparseMatrix(subTestData); RealMatrix mRow0 = createSparseMatrix(subRow0); RealMatrix mRow3 = createSparseMatrix(subRow3); Assert.assertEquals("Row0", mRow0, m.getRowMatrix(0)); Assert.assertEquals("Row3", mRow3, m.getRowMatrix(3)); try { m.getRowMatrix(-1); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getRowMatrix(4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testGetColumnMatrix() { RealMatrix m = createSparseMatrix(subTestData); RealMatrix mColumn1 = createSparseMatrix(subColumn1); RealMatrix mColumn3 = createSparseMatrix(subColumn3); Assert.assertEquals("Column1", mColumn1, m.getColumnMatrix(1)); Assert.assertEquals("Column3", mColumn3, m.getColumnMatrix(3)); try { m.getColumnMatrix(-1); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getColumnMatrix(4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testGetRowVector() { RealMatrix m = createSparseMatrix(subTestData); RealVector mRow0 = new ArrayRealVector(subRow0[0]); RealVector mRow3 = new ArrayRealVector(subRow3[0]); Assert.assertEquals("Row0", mRow0, m.getRowVector(0)); Assert.assertEquals("Row3", mRow3, m.getRowVector(3)); try { m.getRowVector(-1); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getRowVector(4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testGetColumnVector() { RealMatrix m = createSparseMatrix(subTestData); RealVector mColumn1 = columnToVector(subColumn1); RealVector mColumn3 = columnToVector(subColumn3); Assert.assertEquals("Column1", mColumn1, m.getColumnVector(1)); Assert.assertEquals("Column3", mColumn3, m.getColumnVector(3)); try { m.getColumnVector(-1); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } try { m.getColumnVector(4); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } private RealVector columnToVector(double[][] column) { double[] data = new double[column.length]; for (int i = 0; i < data.length; ++i) { data[i] = column[i][0]; } return new ArrayRealVector(data, false); } @Test public void testEqualsAndHashCode() { OpenMapRealMatrix m = createSparseMatrix(testData); OpenMapRealMatrix m1 = m.copy(); OpenMapRealMatrix mt = (OpenMapRealMatrix) m.transpose(); Assert.assertTrue(m.hashCode() != mt.hashCode()); Assert.assertEquals(m.hashCode(), m1.hashCode()); Assert.assertEquals(m, m); Assert.assertEquals(m, m1); Assert.assertFalse(m.equals(null)); Assert.assertFalse(m.equals(mt)); Assert.assertFalse(m.equals(createSparseMatrix(bigSingular))); } @Test public void testToString() { OpenMapRealMatrix m = createSparseMatrix(testData); Assert.assertEquals("OpenMapRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}", m.toString()); m = new OpenMapRealMatrix(1, 1); Assert.assertEquals("OpenMapRealMatrix{{0.0}}", m.toString()); } @Test public void testSetSubMatrix() { OpenMapRealMatrix m = createSparseMatrix(testData); m.setSubMatrix(detData2, 1, 1); RealMatrix expected = createSparseMatrix(new double[][] { { 1.0, 2.0, 3.0 }, { 2.0, 1.0, 3.0 }, { 1.0, 2.0, 4.0 } }); Assert.assertEquals(expected, m); m.setSubMatrix(detData2, 0, 0); expected = createSparseMatrix(new double[][] { { 1.0, 3.0, 3.0 }, { 2.0, 4.0, 3.0 }, { 1.0, 2.0, 4.0 } }); Assert.assertEquals(expected, m); m.setSubMatrix(testDataPlus2, 0, 0); expected = createSparseMatrix(new double[][] { { 3.0, 4.0, 5.0 }, { 4.0, 7.0, 5.0 }, { 3.0, 2.0, 10.0 } }); Assert.assertEquals(expected, m); // javadoc example OpenMapRealMatrix matrix = createSparseMatrix(new double[][] { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 0, 1, 2 } }); matrix.setSubMatrix(new double[][] { { 3, 4 }, { 5, 6 } }, 1, 1); expected = createSparseMatrix(new double[][] { { 1, 2, 3, 4 }, { 5, 3, 4, 8 }, { 9, 5, 6, 2 } }); Assert.assertEquals(expected, matrix); // dimension overflow try { m.setSubMatrix(testData, 1, 1); Assert.fail("expecting OutOfRangeException"); } catch (OutOfRangeException e) { // expected } // dimension underflow try { m.setSubMatrix(testData, -1, 1); Assert.fail("expecting OutOfRangeException"); } catch (OutOfRangeException e) { // expected } try { m.setSubMatrix(testData, 1, -1); Assert.fail("expecting OutOfRangeException"); } catch (OutOfRangeException e) { // expected } // null try { m.setSubMatrix(null, 1, 1); Assert.fail("expecting NullArgumentException"); } catch (NullArgumentException e) { // expected } try { new OpenMapRealMatrix(0, 0); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException e) { // expected } // ragged try { m.setSubMatrix(new double[][] { { 1 }, { 2, 3 } }, 0, 0); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException e) { // expected } // empty try { m.setSubMatrix(new double[][] { {} }, 0, 0); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException e) { // expected } } @Test public void testSerial() { OpenMapRealMatrix m = createSparseMatrix(testData); Assert.assertEquals(m,TestUtils.serializeAndRecover(m)); } // --------------- -----------------Protected methods /** verifies that two matrices are close (1-norm) */ protected void assertClose(String msg, RealMatrix m, RealMatrix n, double tolerance) { Assert.assertTrue(msg, m.subtract(n).getNorm() < tolerance); } /** verifies that two vectors are close (sup norm) */ protected void assertClose(String msg, double[] m, double[] n, double tolerance) { if (m.length != n.length) { Assert.fail("vectors not same length"); } for (int i = 0; i < m.length; i++) { Assert.assertEquals(msg + " " + i + " elements differ", m[i], n[i], tolerance); } } private OpenMapRealMatrix createSparseMatrix(double[][] data) { OpenMapRealMatrix matrix = new OpenMapRealMatrix(data.length, data[0].length); for (int row = 0; row < data.length; row++) { for (int col = 0; col < data[row].length; col++) { matrix.setEntry(row, col, data[row][col]); } } return matrix; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import org.junit.Assert; import org.junit.Ignore; import org.junit.Test; /** * Test cases for the {@link OpenMapRealVector} class. * * @version $Id$ */ public class SparseRealVectorTest extends RealVectorAbstractTest { @Override public RealVector create(double[] data) { return new OpenMapRealVector(data); } @Test public void testConstructors() { final double[] vec1 = {1d, 2d, 3d}; final Double[] dvec1 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d}; OpenMapRealVector v0 = new OpenMapRealVector(); Assert.assertEquals("testData len", 0, v0.getDimension()); OpenMapRealVector v1 = new OpenMapRealVector(7); Assert.assertEquals("testData len", 7, v1.getDimension()); Assert.assertEquals("testData is 0.0 ", 0.0, v1.getEntry(6), 0); OpenMapRealVector v3 = new OpenMapRealVector(vec1); Assert.assertEquals("testData len", 3, v3.getDimension()); Assert.assertEquals("testData is 2.0 ", 2.0, v3.getEntry(1), 0); //SparseRealVector v4 = new SparseRealVector(vec4, 3, 2); //Assert.assertEquals("testData len", 2, v4.getDimension()); //Assert.assertEquals("testData is 4.0 ", 4.0, v4.getEntry(0)); //try { // new SparseRealVector(vec4, 8, 3); // Assert.fail("MathIllegalArgumentException expected"); //} catch (MathIllegalArgumentException ex) { // expected behavior //} RealVector v5_i = new OpenMapRealVector(dvec1); Assert.assertEquals("testData len", 9, v5_i.getDimension()); Assert.assertEquals("testData is 9.0 ", 9.0, v5_i.getEntry(8), 0); OpenMapRealVector v5 = new OpenMapRealVector(dvec1); Assert.assertEquals("testData len", 9, v5.getDimension()); Assert.assertEquals("testData is 9.0 ", 9.0, v5.getEntry(8), 0); OpenMapRealVector v7 = new OpenMapRealVector(v1); Assert.assertEquals("testData len", 7, v7.getDimension()); Assert.assertEquals("testData is 0.0 ", 0.0, v7.getEntry(6), 0); RealVectorTestImpl v7_i = new RealVectorTestImpl(vec1); OpenMapRealVector v7_2 = new OpenMapRealVector(v7_i); Assert.assertEquals("testData len", 3, v7_2.getDimension()); Assert.assertEquals("testData is 0.0 ", 2.0d, v7_2.getEntry(1), 0); OpenMapRealVector v8 = new OpenMapRealVector(v1); Assert.assertEquals("testData len", 7, v8.getDimension()); Assert.assertEquals("testData is 0.0 ", 0.0, v8.getEntry(6), 0); } /* Check that the operations do not throw an exception (cf. MATH-645). */ @Test public void testConcurrentModification() { final RealVector u = new OpenMapRealVector(3, 1e-6); u.setEntry(0, 1); u.setEntry(1, 0); u.setEntry(2, 2); final RealVector v1 = new OpenMapRealVector(3, 1e-6); v1.setEntry(0, 0); v1.setEntry(1, 3); v1.setEntry(2, 0); u.ebeMultiply(v1); u.ebeDivide(v1); } /** * XXX This test is disabled because it currently fails. * The bug must still be fixed in the sparse vector implementation. * When this is done, this override should be deleted. */ @Test @Override @Ignore("This test is skipped until MATH-821 is fixed") public void testMap() {} /** * XXX This test is disabled because it currently fails. * The bug must still be fixed in the sparse vector implementation. * When this is done, this override should be deleted. */ @Test @Override @Ignore("This test is skipped until MATH-821 is fixed") public void testMapToSelf() {} }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import java.util.Arrays; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.util.IterationEvent; import org.apache.commons.math3.util.IterationListener; import org.junit.Assert; import org.junit.Test; public class SymmLQTest { public void saundersTest(final int n, final boolean goodb, final boolean precon, final double shift, final double pertbn) { final RealLinearOperator a = new RealLinearOperator() { @Override public RealVector operate(final RealVector x) { if (x.getDimension() != n) { throw new DimensionMismatchException(x.getDimension(), n); } final double[] y = new double[n]; for (int i = 0; i < n; i++) { y[i] = (i + 1) * 1.1 / n * x.getEntry(i); } return new ArrayRealVector(y, false); } @Override public int getRowDimension() { return n; } @Override public int getColumnDimension() { return n; } }; final double shiftm = shift; final double pertm = FastMath.abs(pertbn); final RealLinearOperator minv; if (precon) { minv = new RealLinearOperator() { @Override public int getRowDimension() { return n; } @Override public int getColumnDimension() { return n; } @Override public RealVector operate(final RealVector x) { if (x.getDimension() != n) { throw new DimensionMismatchException(x.getDimension(), n); } final double[] y = new double[n]; for (int i = 0; i < n; i++) { double d = (i + 1) * 1.1 / n; d = FastMath.abs(d - shiftm); if (i % 10 == 0) { d += pertm; } y[i] = x.getEntry(i) / d; } return new ArrayRealVector(y, false); } }; } else { minv = null; } final RealVector xtrue = new ArrayRealVector(n); for (int i = 0; i < n; i++) { xtrue.setEntry(i, n - i); } final RealVector b = a.operate(xtrue); b.combineToSelf(1.0, -shift, xtrue); final SymmLQ solver = new SymmLQ(2 * n, 1E-12, true); final RealVector x = solver.solve(a, minv, b, goodb, shift); final RealVector y = a.operate(x); final RealVector r1 = new ArrayRealVector(n); for (int i = 0; i < n; i++) { final double bi = b.getEntry(i); final double yi = y.getEntry(i); final double xi = x.getEntry(i); r1.setEntry(i, bi - yi + shift * xi); } final double enorm = x.subtract(xtrue).getNorm() / xtrue.getNorm(); final double etol = 1E-5; Assert.assertTrue("enorm=" + enorm + ", " + solver.getIterationManager().getIterations(), enorm <= etol); } @Test public void testSolveSaunders1() { saundersTest(1, false, false, 0., 0.); } @Test public void testSolveSaunders2() { saundersTest(2, false, false, 0., 0.); } @Test public void testSolveSaunders3() { saundersTest(1, false, true, 0., 0.); } @Test public void testSolveSaunders4() { saundersTest(2, false, true, 0., 0.); } @Test public void testSolveSaunders5() { saundersTest(5, false, true, 0., 0.); } @Test public void testSolveSaunders6() { saundersTest(5, false, true, 0.25, 0.); } @Test public void testSolveSaunders7() { saundersTest(50, false, false, 0., 0.); } @Test public void testSolveSaunders8() { saundersTest(50, false, false, 0.25, 0.); } @Test public void testSolveSaunders9() { saundersTest(50, false, true, 0., 0.10); } @Test public void testSolveSaunders10() { saundersTest(50, false, true, 0.25, 0.10); } @Test public void testSolveSaunders11() { saundersTest(1, true, false, 0., 0.); } @Test public void testSolveSaunders12() { saundersTest(2, true, false, 0., 0.); } @Test public void testSolveSaunders13() { saundersTest(1, true, true, 0., 0.); } @Test public void testSolveSaunders14() { saundersTest(2, true, true, 0., 0.); } @Test public void testSolveSaunders15() { saundersTest(5, true, true, 0., 0.); } @Test public void testSolveSaunders16() { saundersTest(5, true, true, 0.25, 0.); } @Test public void testSolveSaunders17() { saundersTest(50, true, false, 0., 0.); } @Test public void testSolveSaunders18() { saundersTest(50, true, false, 0.25, 0.); } @Test public void testSolveSaunders19() { saundersTest(50, true, true, 0., 0.10); } @Test public void testSolveSaunders20() { saundersTest(50, true, true, 0.25, 0.10); } @Test(expected = NonSquareOperatorException.class) public void testNonSquareOperator() { final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 3); final IterativeLinearSolver solver; solver = new SymmLQ(10, 0., false); final ArrayRealVector b = new ArrayRealVector(a.getRowDimension()); final ArrayRealVector x = new ArrayRealVector(a.getColumnDimension()); solver.solve(a, b, x); } @Test(expected = DimensionMismatchException.class) public void testDimensionMismatchRightHandSide() { final Array2DRowRealMatrix a = new Array2DRowRealMatrix(3, 3); final IterativeLinearSolver solver; solver = new SymmLQ(10, 0., false); final ArrayRealVector b = new ArrayRealVector(2); solver.solve(a, b); } @Test(expected = DimensionMismatchException.class) public void testDimensionMismatchSolution() { final Array2DRowRealMatrix a = new Array2DRowRealMatrix(3, 3); final IterativeLinearSolver solver; solver = new SymmLQ(10, 0., false); final ArrayRealVector b = new ArrayRealVector(3); final ArrayRealVector x = new ArrayRealVector(2); solver.solve(a, b, x); } @Test public void testUnpreconditionedSolution() { final int n = 5; final int maxIterations = 100; final RealLinearOperator a = new HilbertMatrix(n); final InverseHilbertMatrix ainv = new InverseHilbertMatrix(n); final IterativeLinearSolver solver; solver = new SymmLQ(maxIterations, 1E-10, true); final RealVector b = new ArrayRealVector(n); for (int j = 0; j < n; j++) { b.set(0.); b.setEntry(j, 1.); final RealVector x = solver.solve(a, b); for (int i = 0; i < n; i++) { final double actual = x.getEntry(i); final double expected = ainv.getEntry(i, j); final double delta = 1E-6 * Math.abs(expected); final String msg = String.format("entry[%d][%d]", i, j); Assert.assertEquals(msg, expected, actual, delta); } } } @Test public void testUnpreconditionedInPlaceSolutionWithInitialGuess() { final int n = 5; final int maxIterations = 100; final RealLinearOperator a = new HilbertMatrix(n); final InverseHilbertMatrix ainv = new InverseHilbertMatrix(n); final IterativeLinearSolver solver; solver = new SymmLQ(maxIterations, 1E-10, true); final RealVector b = new ArrayRealVector(n); for (int j = 0; j < n; j++) { b.set(0.); b.setEntry(j, 1.); final RealVector x0 = new ArrayRealVector(n); x0.set(1.); final RealVector x = solver.solveInPlace(a, b, x0); Assert.assertSame("x should be a reference to x0", x0, x); for (int i = 0; i < n; i++) { final double actual = x.getEntry(i); final double expected = ainv.getEntry(i, j); final double delta = 1E-6 * Math.abs(expected); final String msg = String.format("entry[%d][%d)", i, j); Assert.assertEquals(msg, expected, actual, delta); } } } @Test public void testUnpreconditionedSolutionWithInitialGuess() { final int n = 5; final int maxIterations = 100; final RealLinearOperator a = new HilbertMatrix(n); final InverseHilbertMatrix ainv = new InverseHilbertMatrix(n); final IterativeLinearSolver solver; solver = new SymmLQ(maxIterations, 1E-10, true); final RealVector b = new ArrayRealVector(n); for (int j = 0; j < n; j++) { b.set(0.); b.setEntry(j, 1.); final RealVector x0 = new ArrayRealVector(n); x0.set(1.); final RealVector x = solver.solve(a, b, x0); Assert.assertNotSame("x should not be a reference to x0", x0, x); for (int i = 0; i < n; i++) { final double actual = x.getEntry(i); final double expected = ainv.getEntry(i, j); final double delta = 1E-6 * Math.abs(expected); final String msg = String.format("entry[%d][%d]", i, j); Assert.assertEquals(msg, expected, actual, delta); Assert.assertEquals(msg, x0.getEntry(i), 1., Math.ulp(1.)); } } } @Test(expected = NonSquareOperatorException.class) public void testNonSquarePreconditioner() { final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 2); final RealLinearOperator m = new RealLinearOperator() { @Override public RealVector operate(final RealVector x) { throw new UnsupportedOperationException(); } @Override public int getRowDimension() { return 2; } @Override public int getColumnDimension() { return 3; } }; final PreconditionedIterativeLinearSolver solver; solver = new SymmLQ(10, 0., false); final ArrayRealVector b = new ArrayRealVector(a.getRowDimension()); solver.solve(a, m, b); } @Test(expected = DimensionMismatchException.class) public void testMismatchedOperatorDimensions() { final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 2); final RealLinearOperator m = new RealLinearOperator() { @Override public RealVector operate(final RealVector x) { throw new UnsupportedOperationException(); } @Override public int getRowDimension() { return 3; } @Override public int getColumnDimension() { return 3; } }; final PreconditionedIterativeLinearSolver solver; solver = new SymmLQ(10, 0d, false); final ArrayRealVector b = new ArrayRealVector(a.getRowDimension()); solver.solve(a, m, b); } @Test(expected = NonPositiveDefiniteOperatorException.class) public void testNonPositiveDefinitePreconditioner() { final Array2DRowRealMatrix a = new Array2DRowRealMatrix(2, 2); a.setEntry(0, 0, 1d); a.setEntry(0, 1, 2d); a.setEntry(1, 0, 3d); a.setEntry(1, 1, 4d); final RealLinearOperator m = new RealLinearOperator() { @Override public RealVector operate(final RealVector x) { final ArrayRealVector y = new ArrayRealVector(2); y.setEntry(0, -x.getEntry(0)); y.setEntry(1, -x.getEntry(1)); return y; } @Override public int getRowDimension() { return 2; } @Override public int getColumnDimension() { return 2; } }; final PreconditionedIterativeLinearSolver solver; solver = new SymmLQ(10, 0d, true); final ArrayRealVector b = new ArrayRealVector(2); b.setEntry(0, -1d); b.setEntry(1, -1d); solver.solve(a, m, b); } @Test public void testPreconditionedSolution() { final int n = 8; final int maxIterations = 100; final RealLinearOperator a = new HilbertMatrix(n); final InverseHilbertMatrix ainv = new InverseHilbertMatrix(n); final RealLinearOperator m = JacobiPreconditioner.create(a); final PreconditionedIterativeLinearSolver solver; solver = new SymmLQ(maxIterations, 1E-15, true); final RealVector b = new ArrayRealVector(n); for (int j = 0; j < n; j++) { b.set(0.); b.setEntry(j, 1.); final RealVector x = solver.solve(a, m, b); for (int i = 0; i < n; i++) { final double actual = x.getEntry(i); final double expected = ainv.getEntry(i, j); final double delta = 1E-6 * Math.abs(expected); final String msg = String.format("coefficient (%d, %d)", i, j); Assert.assertEquals(msg, expected, actual, delta); } } } @Test public void testPreconditionedSolution2() { final int n = 100; final int maxIterations = 100000; final Array2DRowRealMatrix a = new Array2DRowRealMatrix(n, n); double daux = 1.; for (int i = 0; i < n; i++) { a.setEntry(i, i, daux); daux *= 1.2; for (int j = i + 1; j < n; j++) { if (i == j) { } else { final double value = 1.0; a.setEntry(i, j, value); a.setEntry(j, i, value); } } } final RealLinearOperator m = JacobiPreconditioner.create(a); final PreconditionedIterativeLinearSolver prec; final IterativeLinearSolver unprec; prec = new SymmLQ(maxIterations, 1E-15, true); unprec = new SymmLQ(maxIterations, 1E-15, true); final RealVector b = new ArrayRealVector(n); final String pattern = "preconditioned SymmLQ (%d iterations) should" + " have been faster than unpreconditioned (%d iterations)"; String msg; for (int j = 0; j < 1; j++) { b.set(0.); b.setEntry(j, 1.); final RealVector px = prec.solve(a, m, b); final RealVector x = unprec.solve(a, b); final int np = prec.getIterationManager().getIterations(); final int nup = unprec.getIterationManager().getIterations(); msg = String.format(pattern, np, nup); for (int i = 0; i < n; i++) { msg = String.format("row %d, column %d", i, j); final double expected = x.getEntry(i); final double actual = px.getEntry(i); final double delta = 5E-5 * Math.abs(expected); Assert.assertEquals(msg, expected, actual, delta); } } } @Test public void testEventManagement() { final int n = 5; final int maxIterations = 100; final RealLinearOperator a = new HilbertMatrix(n); final IterativeLinearSolver solver; /* * count[0] = number of calls to initializationPerformed * count[1] = number of calls to iterationStarted * count[2] = number of calls to iterationPerformed * count[3] = number of calls to terminationPerformed */ final int[] count = new int[] {0, 0, 0, 0}; final RealVector xFromListener = new ArrayRealVector(n); final IterationListener listener = new IterationListener() { public void initializationPerformed(final IterationEvent e) { ++count[0]; } public void iterationPerformed(final IterationEvent e) { ++count[2]; Assert.assertEquals("iteration performed", count[2], e.getIterations() - 1); } public void iterationStarted(final IterationEvent e) { ++count[1]; Assert.assertEquals("iteration started", count[1], e.getIterations() - 1); } public void terminationPerformed(final IterationEvent e) { ++count[3]; final IterativeLinearSolverEvent ilse; ilse = (IterativeLinearSolverEvent) e; xFromListener.setSubVector(0, ilse.getSolution()); } }; solver = new SymmLQ(maxIterations, 1E-10, true); solver.getIterationManager().addIterationListener(listener); final RealVector b = new ArrayRealVector(n); for (int j = 0; j < n; j++) { Arrays.fill(count, 0); b.set(0.); b.setEntry(j, 1.); final RealVector xFromSolver = solver.solve(a, b); String msg = String.format("column %d (initialization)", j); Assert.assertEquals(msg, 1, count[0]); msg = String.format("column %d (finalization)", j); Assert.assertEquals(msg, 1, count[3]); /* * Check that solution is not "over-refined". When the last * iteration has occurred, no further refinement should be * performed. */ for (int i = 0; i < n; i++){ msg = String.format("row %d, column %d", i, j); final double expected = xFromSolver.getEntry(i); final double actual = xFromListener.getEntry(i); Assert.assertEquals(msg, expected, actual, 0.0); } } } @Test(expected = NonSelfAdjointOperatorException.class) public void testNonSelfAdjointOperator() { final RealLinearOperator a; a = new Array2DRowRealMatrix(new double[][] { {1., 2., 3.}, {2., 4., 5.}, {2.999, 5., 6.} }); final RealVector b; b = new ArrayRealVector(new double[] {1., 1., 1.}); new SymmLQ(100, 1., true).solve(a, b); } @Test(expected = NonSelfAdjointOperatorException.class) public void testNonSelfAdjointPreconditioner() { final RealLinearOperator a = new Array2DRowRealMatrix(new double[][] { {1., 2., 3.}, {2., 4., 5.}, {3., 5., 6.} }); final Array2DRowRealMatrix mMat; mMat = new Array2DRowRealMatrix(new double[][] { {1., 0., 1.}, {0., 1., 0.}, {0., 0., 1.} }); final DecompositionSolver mSolver; mSolver = new LUDecomposition(mMat).getSolver(); final RealLinearOperator minv = new RealLinearOperator() { @Override public RealVector operate(final RealVector x) { return mSolver.solve(x); } @Override public int getRowDimension() { return mMat.getRowDimension(); } @Override public int getColumnDimension() { return mMat.getColumnDimension(); } }; final RealVector b = new ArrayRealVector(new double[] { 1., 1., 1. }); new SymmLQ(100, 1., true).solve(a, minv, b); } @Test public void testUnpreconditionedNormOfResidual() { final int n = 5; final int maxIterations = 100; final RealLinearOperator a = new HilbertMatrix(n); final IterativeLinearSolver solver; final IterationListener listener = new IterationListener() { private void doTestNormOfResidual(final IterationEvent e) { final IterativeLinearSolverEvent evt; evt = (IterativeLinearSolverEvent) e; final RealVector x = evt.getSolution(); final RealVector b = evt.getRightHandSideVector(); final RealVector r = b.subtract(a.operate(x)); final double rnorm = r.getNorm(); Assert.assertEquals("iteration performed (residual)", rnorm, evt.getNormOfResidual(), FastMath.max(1E-5 * rnorm, 1E-10)); } public void initializationPerformed(final IterationEvent e) { doTestNormOfResidual(e); } public void iterationPerformed(final IterationEvent e) { doTestNormOfResidual(e); } public void iterationStarted(final IterationEvent e) { doTestNormOfResidual(e); } public void terminationPerformed(final IterationEvent e) { doTestNormOfResidual(e); } }; solver = new SymmLQ(maxIterations, 1E-10, true); solver.getIterationManager().addIterationListener(listener); final RealVector b = new ArrayRealVector(n); for (int j = 0; j < n; j++) { b.set(0.); b.setEntry(j, 1.); solver.solve(a, b); } } @Test public void testPreconditionedNormOfResidual() { final int n = 5; final int maxIterations = 100; final RealLinearOperator a = new HilbertMatrix(n); final JacobiPreconditioner m = JacobiPreconditioner.create(a); final RealLinearOperator p = m.sqrt(); final PreconditionedIterativeLinearSolver solver; final IterationListener listener = new IterationListener() { private void doTestNormOfResidual(final IterationEvent e) { final IterativeLinearSolverEvent evt; evt = (IterativeLinearSolverEvent) e; final RealVector x = evt.getSolution(); final RealVector b = evt.getRightHandSideVector(); final RealVector r = b.subtract(a.operate(x)); final double rnorm = p.operate(r).getNorm(); Assert.assertEquals("iteration performed (residual)", rnorm, evt.getNormOfResidual(), FastMath.max(1E-5 * rnorm, 1E-10)); } public void initializationPerformed(final IterationEvent e) { doTestNormOfResidual(e); } public void iterationPerformed(final IterationEvent e) { doTestNormOfResidual(e); } public void iterationStarted(final IterationEvent e) { doTestNormOfResidual(e); } public void terminationPerformed(final IterationEvent e) { doTestNormOfResidual(e); } }; solver = new SymmLQ(maxIterations, 1E-10, true); solver.getIterationManager().addIterationListener(listener); final RealVector b = new ArrayRealVector(n); for (int j = 0; j < n; j++) { b.set(0.); b.setEntry(j, 1.); solver.solve(a, m, b); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; import java.util.Arrays; import org.apache.commons.math3.util.FastMath; import org.junit.Test; import org.junit.Assert; public class TriDiagonalTransformerTest { private double[][] testSquare5 = { { 1, 2, 3, 1, 1 }, { 2, 1, 1, 3, 1 }, { 3, 1, 1, 1, 2 }, { 1, 3, 1, 2, 1 }, { 1, 1, 2, 1, 3 } }; private double[][] testSquare3 = { { 1, 3, 4 }, { 3, 2, 2 }, { 4, 2, 0 } }; @Test public void testNonSquare() { try { new TriDiagonalTransformer(MatrixUtils.createRealMatrix(new double[3][2])); Assert.fail("an exception should have been thrown"); } catch (NonSquareMatrixException ime) { // expected behavior } } @Test public void testAEqualQTQt() { checkAEqualQTQt(MatrixUtils.createRealMatrix(testSquare5)); checkAEqualQTQt(MatrixUtils.createRealMatrix(testSquare3)); } private void checkAEqualQTQt(RealMatrix matrix) { TriDiagonalTransformer transformer = new TriDiagonalTransformer(matrix); RealMatrix q = transformer.getQ(); RealMatrix qT = transformer.getQT(); RealMatrix t = transformer.getT(); double norm = q.multiply(t).multiply(qT).subtract(matrix).getNorm(); Assert.assertEquals(0, norm, 4.0e-15); } @Test public void testNoAccessBelowDiagonal() { checkNoAccessBelowDiagonal(testSquare5); checkNoAccessBelowDiagonal(testSquare3); } private void checkNoAccessBelowDiagonal(double[][] data) { double[][] modifiedData = new double[data.length][]; for (int i = 0; i < data.length; ++i) { modifiedData[i] = data[i].clone(); Arrays.fill(modifiedData[i], 0, i, Double.NaN); } RealMatrix matrix = MatrixUtils.createRealMatrix(modifiedData); TriDiagonalTransformer transformer = new TriDiagonalTransformer(matrix); RealMatrix q = transformer.getQ(); RealMatrix qT = transformer.getQT(); RealMatrix t = transformer.getT(); double norm = q.multiply(t).multiply(qT).subtract(MatrixUtils.createRealMatrix(data)).getNorm(); Assert.assertEquals(0, norm, 4.0e-15); } @Test public void testQOrthogonal() { checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare5)).getQ()); checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare3)).getQ()); } @Test public void testQTOrthogonal() { checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare5)).getQT()); checkOrthogonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare3)).getQT()); } private void checkOrthogonal(RealMatrix m) { RealMatrix mTm = m.transpose().multiply(m); RealMatrix id = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension()); Assert.assertEquals(0, mTm.subtract(id).getNorm(), 1.0e-15); } @Test public void testTTriDiagonal() { checkTriDiagonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare5)).getT()); checkTriDiagonal(new TriDiagonalTransformer(MatrixUtils.createRealMatrix(testSquare3)).getT()); } private void checkTriDiagonal(RealMatrix m) { final int rows = m.getRowDimension(); final int cols = m.getColumnDimension(); for (int i = 0; i < rows; ++i) { for (int j = 0; j < cols; ++j) { if ((i < j - 1) || (i > j + 1)) { Assert.assertEquals(0, m.getEntry(i, j), 1.0e-16); } } } } @Test public void testMatricesValues5() { checkMatricesValues(testSquare5, new double[][] { { 1.0, 0.0, 0.0, 0.0, 0.0 }, { 0.0, -0.5163977794943222, 0.016748280772542083, 0.839800693771262, 0.16669620021405473 }, { 0.0, -0.7745966692414833, -0.4354553000860955, -0.44989322880603355, -0.08930153582895772 }, { 0.0, -0.2581988897471611, 0.6364346693566014, -0.30263204032131164, 0.6608313651342882 }, { 0.0, -0.2581988897471611, 0.6364346693566009, -0.027289660803112598, -0.7263191580755246 } }, new double[] { 1, 4.4, 1.433099579242636, -0.89537362758743, 2.062274048344794 }, new double[] { -FastMath.sqrt(15), -3.0832882879592476, 0.6082710842351517, 1.1786086405912128 }); } @Test public void testMatricesValues3() { checkMatricesValues(testSquare3, new double[][] { { 1.0, 0.0, 0.0 }, { 0.0, -0.6, 0.8 }, { 0.0, -0.8, -0.6 }, }, new double[] { 1, 2.64, -0.64 }, new double[] { -5, -1.52 }); } private void checkMatricesValues(double[][] matrix, double[][] qRef, double[] mainDiagnonal, double[] secondaryDiagonal) { TriDiagonalTransformer transformer = new TriDiagonalTransformer(MatrixUtils.createRealMatrix(matrix)); // check values against known references RealMatrix q = transformer.getQ(); Assert.assertEquals(0, q.subtract(MatrixUtils.createRealMatrix(qRef)).getNorm(), 1.0e-14); RealMatrix t = transformer.getT(); double[][] tData = new double[mainDiagnonal.length][mainDiagnonal.length]; for (int i = 0; i < mainDiagnonal.length; ++i) { tData[i][i] = mainDiagnonal[i]; if (i > 0) { tData[i][i - 1] = secondaryDiagonal[i - 1]; } if (i < secondaryDiagonal.length) { tData[i][i + 1] = secondaryDiagonal[i]; } } Assert.assertEquals(0, t.subtract(MatrixUtils.createRealMatrix(tData)).getNorm(), 1.0e-14); // check the same cached instance is returned the second time Assert.assertTrue(q == transformer.getQ()); Assert.assertTrue(t == transformer.getT()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; /** * This is an implementation of {@link UnmodifiableRealVectorAbstractTest} for * unmodifiable views of {@link ArrayRealVectorTest}. * * @version $Id$ */ public class UnmodifiableArrayRealVectorTest extends UnmodifiableRealVectorAbstractTest { /** * Returns a random vector of type {@link ArrayRealVector}. * * @return a new random {@link ArrayRealVector}. */ @Override public RealVector createVector() { ArrayRealVector v = new ArrayRealVector(DIM); for (int i = 0; i < DIM; i++) { v.setEntry(i, RANDOM.nextDouble()); } return v; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.linear; /** * This is an implementation of {@link UnmodifiableRealVectorAbstractTest} for * unmodifiable views of {@link OpenMapRealVector}. * * @version $Id$ */ public class UnmodifiableOpenMapRealVectorTest extends UnmodifiableRealVectorAbstractTest { /** To ensure sufficient sparsity. */ public static final double PROBABILITY_OF_ZERO = 0.5; /** * Returns a random vector of type {@link ArrayRealVector}. * * @return a new random {@link ArrayRealVector}. */ @Override public RealVector createVector() { OpenMapRealVector v = new OpenMapRealVector(DIM, EPS); for (int i = 0; i < DIM; i++) { if (RANDOM.nextDouble() > PROBABILITY_OF_ZERO) { v.setEntry(i, RANDOM.nextDouble()); } } return v; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ml.clustering; import java.util.Arrays; import java.util.List; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.exception.NullArgumentException; import org.junit.Assert; import org.junit.Test; public class DBSCANClustererTest { @Test public void testCluster() { // Test data generated using: http://people.cs.nctu.edu.tw/~rsliang/dbscan/testdatagen.html final DoublePoint[] points = new DoublePoint[] { new DoublePoint(new double[] { 83.08303244924173, 58.83387754182331 }), new DoublePoint(new double[] { 45.05445510940626, 23.469642649637535 }), new DoublePoint(new double[] { 14.96417921432294, 69.0264096390456 }), new DoublePoint(new double[] { 73.53189604333602, 34.896145021310076 }), new DoublePoint(new double[] { 73.28498173551634, 33.96860806993209 }), new DoublePoint(new double[] { 73.45828098873608, 33.92584423092194 }), new DoublePoint(new double[] { 73.9657889183145, 35.73191006924026 }), new DoublePoint(new double[] { 74.0074097183533, 36.81735596177168 }), new DoublePoint(new double[] { 73.41247541410848, 34.27314856695011 }), new DoublePoint(new double[] { 73.9156256353017, 36.83206791547127 }), new DoublePoint(new double[] { 74.81499205809087, 37.15682749846019 }), new DoublePoint(new double[] { 74.03144880081527, 37.57399178552441 }), new DoublePoint(new double[] { 74.51870941207744, 38.674258946906775 }), new DoublePoint(new double[] { 74.50754595105536, 35.58903978415765 }), new DoublePoint(new double[] { 74.51322752749547, 36.030572259100154 }), new DoublePoint(new double[] { 59.27900996617973, 46.41091720294207 }), new DoublePoint(new double[] { 59.73744793841615, 46.20015558367595 }), new DoublePoint(new double[] { 58.81134076672606, 45.71150126331486 }), new DoublePoint(new double[] { 58.52225539437495, 47.416083617601544 }), new DoublePoint(new double[] { 58.218626647023484, 47.36228902172297 }), new DoublePoint(new double[] { 60.27139669447206, 46.606106348801404 }), new DoublePoint(new double[] { 60.894962462363765, 46.976924697402865 }), new DoublePoint(new double[] { 62.29048673878424, 47.66970563563518 }), new DoublePoint(new double[] { 61.03857608977705, 46.212924720020965 }), new DoublePoint(new double[] { 60.16916214139201, 45.18193661351688 }), new DoublePoint(new double[] { 59.90036905976012, 47.555364347063005 }), new DoublePoint(new double[] { 62.33003634144552, 47.83941489877179 }), new DoublePoint(new double[] { 57.86035536718555, 47.31117930193432 }), new DoublePoint(new double[] { 58.13715479685925, 48.985960494028404 }), new DoublePoint(new double[] { 56.131923963548616, 46.8508904252667 }), new DoublePoint(new double[] { 55.976329887053, 47.46384037658572 }), new DoublePoint(new double[] { 56.23245975235477, 47.940035191131756 }), new DoublePoint(new double[] { 58.51687048212625, 46.622885352699086 }), new DoublePoint(new double[] { 57.85411081905477, 45.95394361577928 }), new DoublePoint(new double[] { 56.445776311447844, 45.162093662656844 }), new DoublePoint(new double[] { 57.36691949656233, 47.50097194337286 }), new DoublePoint(new double[] { 58.243626387557015, 46.114052729681134 }), new DoublePoint(new double[] { 56.27224595635198, 44.799080066150054 }), new DoublePoint(new double[] { 57.606924816500396, 46.94291057763621 }), new DoublePoint(new double[] { 30.18714230041951, 13.877149710431695 }), new DoublePoint(new double[] { 30.449448810657486, 13.490778346545994 }), new DoublePoint(new double[] { 30.295018390286714, 13.264889000216499 }), new DoublePoint(new double[] { 30.160201832884923, 11.89278262341395 }), new DoublePoint(new double[] { 31.341509791789576, 15.282655921997502 }), new DoublePoint(new double[] { 31.68601630325429, 14.756873246748 }), new DoublePoint(new double[] { 29.325963742565364, 12.097849250072613 }), new DoublePoint(new double[] { 29.54820742388256, 13.613295356975868 }), new DoublePoint(new double[] { 28.79359608888626, 10.36352064087987 }), new DoublePoint(new double[] { 31.01284597092308, 12.788479208014905 }), new DoublePoint(new double[] { 27.58509216737002, 11.47570110601373 }), new DoublePoint(new double[] { 28.593799561727792, 10.780998203903437 }), new DoublePoint(new double[] { 31.356105766724795, 15.080316198524088 }), new DoublePoint(new double[] { 31.25948503636755, 13.674329151166603 }), new DoublePoint(new double[] { 32.31590076372959, 14.95261758659035 }), new DoublePoint(new double[] { 30.460413702763617, 15.88402809202671 }), new DoublePoint(new double[] { 32.56178203062154, 14.586076852632686 }), new DoublePoint(new double[] { 32.76138648530468, 16.239837325178087 }), new DoublePoint(new double[] { 30.1829453331884, 14.709592407103628 }), new DoublePoint(new double[] { 29.55088173528202, 15.0651247180067 }), new DoublePoint(new double[] { 29.004155302187428, 14.089665298582986 }), new DoublePoint(new double[] { 29.339624439831823, 13.29096065578051 }), new DoublePoint(new double[] { 30.997460327576846, 14.551914158277214 }), new DoublePoint(new double[] { 30.66784126125276, 16.269703107886016 }) }; final DBSCANClusterer<DoublePoint> transformer = new DBSCANClusterer<DoublePoint>(2.0, 5); final List<Cluster<DoublePoint>> clusters = transformer.cluster(Arrays.asList(points)); final List<DoublePoint> clusterOne = Arrays.asList(points[3], points[4], points[5], points[6], points[7], points[8], points[9], points[10], points[11], points[12], points[13], points[14]); final List<DoublePoint> clusterTwo = Arrays.asList(points[15], points[16], points[17], points[18], points[19], points[20], points[21], points[22], points[23], points[24], points[25], points[26], points[27], points[28], points[29], points[30], points[31], points[32], points[33], points[34], points[35], points[36], points[37], points[38]); final List<DoublePoint> clusterThree = Arrays.asList(points[39], points[40], points[41], points[42], points[43], points[44], points[45], points[46], points[47], points[48], points[49], points[50], points[51], points[52], points[53], points[54], points[55], points[56], points[57], points[58], points[59], points[60], points[61], points[62]); boolean cluster1Found = false; boolean cluster2Found = false; boolean cluster3Found = false; Assert.assertEquals(3, clusters.size()); for (final Cluster<DoublePoint> cluster : clusters) { if (cluster.getPoints().containsAll(clusterOne)) { cluster1Found = true; } if (cluster.getPoints().containsAll(clusterTwo)) { cluster2Found = true; } if (cluster.getPoints().containsAll(clusterThree)) { cluster3Found = true; } } Assert.assertTrue(cluster1Found); Assert.assertTrue(cluster2Found); Assert.assertTrue(cluster3Found); } @Test public void testSingleLink() { final DoublePoint[] points = { new DoublePoint(new int[] {10, 10}), // A new DoublePoint(new int[] {12, 9}), new DoublePoint(new int[] {10, 8}), new DoublePoint(new int[] {8, 8}), new DoublePoint(new int[] {8, 6}), new DoublePoint(new int[] {7, 7}), new DoublePoint(new int[] {5, 6}), // B new DoublePoint(new int[] {14, 8}), // C new DoublePoint(new int[] {7, 15}), // N - Noise, should not be present new DoublePoint(new int[] {17, 8}), // D - single-link connected to C should not be present }; final DBSCANClusterer<DoublePoint> clusterer = new DBSCANClusterer<DoublePoint>(3, 3); List<Cluster<DoublePoint>> clusters = clusterer.cluster(Arrays.asList(points)); Assert.assertEquals(1, clusters.size()); final List<DoublePoint> clusterOne = Arrays.asList(points[0], points[1], points[2], points[3], points[4], points[5], points[6], points[7]); Assert.assertTrue(clusters.get(0).getPoints().containsAll(clusterOne)); } @Test public void testGetEps() { final DBSCANClusterer<DoublePoint> transformer = new DBSCANClusterer<DoublePoint>(2.0, 5); Assert.assertEquals(2.0, transformer.getEps(), 0.0); } @Test public void testGetMinPts() { final DBSCANClusterer<DoublePoint> transformer = new DBSCANClusterer<DoublePoint>(2.0, 5); Assert.assertEquals(5, transformer.getMinPts()); } @Test(expected = MathIllegalArgumentException.class) public void testNegativeEps() { new DBSCANClusterer<DoublePoint>(-2.0, 5); } @Test(expected = MathIllegalArgumentException.class) public void testNegativeMinPts() { new DBSCANClusterer<DoublePoint>(2.0, -5); } @Test(expected = NullArgumentException.class) public void testNullDataset() { DBSCANClusterer<DoublePoint> clusterer = new DBSCANClusterer<DoublePoint>(2.0, 5); clusterer.cluster(null); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ml.clustering; import org.hamcrest.CoreMatchers; import org.junit.Assert; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.exception.NullArgumentException; import org.apache.commons.math3.ml.distance.CanberraDistance; import org.apache.commons.math3.ml.distance.DistanceMeasure; import org.apache.commons.math3.random.JDKRandomGenerator; import org.apache.commons.math3.random.RandomGenerator; import org.junit.Test; /** * Test cases for FuzzyKMeansClusterer. * * @version $Id$ * @since 3.3 */ public class FuzzyKMeansClustererTest { @Test public void testCluster() { final List<DoublePoint> points = new ArrayList<DoublePoint>(); // create 10 data points: [1], ... [10] for (int i = 1; i <= 10; i++) { final DoublePoint p = new DoublePoint(new double[] { i } ); points.add(p); } final FuzzyKMeansClusterer<DoublePoint> transformer = new FuzzyKMeansClusterer<DoublePoint>(3, 2.0); final List<CentroidCluster<DoublePoint>> clusters = transformer.cluster(points); // we expect 3 clusters: // [1], [2], [3] // [4], [5], [6], [7] // [8], [9], [10] final List<DoublePoint> clusterOne = Arrays.asList(points.get(0), points.get(1), points.get(2)); final List<DoublePoint> clusterTwo = Arrays.asList(points.get(3), points.get(4), points.get(5), points.get(6)); final List<DoublePoint> clusterThree = Arrays.asList(points.get(7), points.get(8), points.get(9)); boolean cluster1Found = false; boolean cluster2Found = false; boolean cluster3Found = false; Assert.assertEquals(3, clusters.size()); for (final Cluster<DoublePoint> cluster : clusters) { if (cluster.getPoints().containsAll(clusterOne)) { cluster1Found = true; } if (cluster.getPoints().containsAll(clusterTwo)) { cluster2Found = true; } if (cluster.getPoints().containsAll(clusterThree)) { cluster3Found = true; } } Assert.assertTrue(cluster1Found); Assert.assertTrue(cluster2Found); Assert.assertTrue(cluster3Found); } @Test(expected = MathIllegalArgumentException.class) public void testTooSmallFuzzynessFactor() { new FuzzyKMeansClusterer<DoublePoint>(3, 1.0); } @Test(expected = NullArgumentException.class) public void testNullDataset() { final FuzzyKMeansClusterer<DoublePoint> clusterer = new FuzzyKMeansClusterer<DoublePoint>(3, 2.0); clusterer.cluster(null); } @Test public void testGetters() { final DistanceMeasure measure = new CanberraDistance(); final RandomGenerator random = new JDKRandomGenerator(); final FuzzyKMeansClusterer<DoublePoint> clusterer = new FuzzyKMeansClusterer<DoublePoint>(3, 2.0, 100, measure, 1e-6, random); Assert.assertEquals(3, clusterer.getK()); Assert.assertEquals(2.0, clusterer.getFuzziness(), 1e-6); Assert.assertEquals(100, clusterer.getMaxIterations()); Assert.assertEquals(1e-6, clusterer.getEpsilon(), 1e-12); Assert.assertThat(clusterer.getDistanceMeasure(), CoreMatchers.is(measure)); Assert.assertThat(clusterer.getRandomGenerator(), CoreMatchers.is(random)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ml.clustering; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.List; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.ml.distance.EuclideanDistance; import org.apache.commons.math3.random.JDKRandomGenerator; import org.apache.commons.math3.random.RandomGenerator; import org.junit.Assert; import org.junit.Before; import org.junit.Test; public class KMeansPlusPlusClustererTest { private RandomGenerator random; @Before public void setUp() { random = new JDKRandomGenerator(); random.setSeed(1746432956321l); } /** * JIRA: MATH-305 * * Two points, one cluster, one iteration */ @Test public void testPerformClusterAnalysisDegenerate() { KMeansPlusPlusClusterer<DoublePoint> transformer = new KMeansPlusPlusClusterer<DoublePoint>(1, 1); DoublePoint[] points = new DoublePoint[] { new DoublePoint(new int[] { 1959, 325100 }), new DoublePoint(new int[] { 1960, 373200 }), }; List<? extends Cluster<DoublePoint>> clusters = transformer.cluster(Arrays.asList(points)); Assert.assertEquals(1, clusters.size()); Assert.assertEquals(2, (clusters.get(0).getPoints().size())); DoublePoint pt1 = new DoublePoint(new int[] { 1959, 325100 }); DoublePoint pt2 = new DoublePoint(new int[] { 1960, 373200 }); Assert.assertTrue(clusters.get(0).getPoints().contains(pt1)); Assert.assertTrue(clusters.get(0).getPoints().contains(pt2)); } @Test public void testCertainSpace() { KMeansPlusPlusClusterer.EmptyClusterStrategy[] strategies = { KMeansPlusPlusClusterer.EmptyClusterStrategy.LARGEST_VARIANCE, KMeansPlusPlusClusterer.EmptyClusterStrategy.LARGEST_POINTS_NUMBER, KMeansPlusPlusClusterer.EmptyClusterStrategy.FARTHEST_POINT }; for (KMeansPlusPlusClusterer.EmptyClusterStrategy strategy : strategies) { int numberOfVariables = 27; // initialise testvalues int position1 = 1; int position2 = position1 + numberOfVariables; int position3 = position2 + numberOfVariables; int position4 = position3 + numberOfVariables; // testvalues will be multiplied int multiplier = 1000000; DoublePoint[] breakingPoints = new DoublePoint[numberOfVariables]; // define the space which will break the cluster algorithm for (int i = 0; i < numberOfVariables; i++) { int points[] = { position1, position2, position3, position4 }; // multiply the values for (int j = 0; j < points.length; j++) { points[j] = points[j] * multiplier; } DoublePoint DoublePoint = new DoublePoint(points); breakingPoints[i] = DoublePoint; position1 = position1 + numberOfVariables; position2 = position2 + numberOfVariables; position3 = position3 + numberOfVariables; position4 = position4 + numberOfVariables; } for (int n = 2; n < 27; ++n) { KMeansPlusPlusClusterer<DoublePoint> transformer = new KMeansPlusPlusClusterer<DoublePoint>(n, 100, new EuclideanDistance(), random, strategy); List<? extends Cluster<DoublePoint>> clusters = transformer.cluster(Arrays.asList(breakingPoints)); Assert.assertEquals(n, clusters.size()); int sum = 0; for (Cluster<DoublePoint> cluster : clusters) { sum += cluster.getPoints().size(); } Assert.assertEquals(numberOfVariables, sum); } } } /** * A helper class for testSmallDistances(). This class is similar to DoublePoint, but * it defines a different distanceFrom() method that tends to return distances less than 1. */ private class CloseDistance extends EuclideanDistance { private static final long serialVersionUID = 1L; @Override public double compute(double[] a, double[] b) { return super.compute(a, b) * 0.001; } } /** * Test points that are very close together. See issue MATH-546. */ @Test public void testSmallDistances() { // Create a bunch of CloseDoublePoints. Most are identical, but one is different by a // small distance. int[] repeatedArray = { 0 }; int[] uniqueArray = { 1 }; DoublePoint repeatedPoint = new DoublePoint(repeatedArray); DoublePoint uniquePoint = new DoublePoint(uniqueArray); Collection<DoublePoint> points = new ArrayList<DoublePoint>(); final int NUM_REPEATED_POINTS = 10 * 1000; for (int i = 0; i < NUM_REPEATED_POINTS; ++i) { points.add(repeatedPoint); } points.add(uniquePoint); // Ask a KMeansPlusPlusClusterer to run zero iterations (i.e., to simply choose initial // cluster centers). final long RANDOM_SEED = 0; final int NUM_CLUSTERS = 2; final int NUM_ITERATIONS = 0; random.setSeed(RANDOM_SEED); KMeansPlusPlusClusterer<DoublePoint> clusterer = new KMeansPlusPlusClusterer<DoublePoint>(NUM_CLUSTERS, NUM_ITERATIONS, new CloseDistance(), random); List<CentroidCluster<DoublePoint>> clusters = clusterer.cluster(points); // Check that one of the chosen centers is the unique point. boolean uniquePointIsCenter = false; for (CentroidCluster<DoublePoint> cluster : clusters) { if (cluster.getCenter().equals(uniquePoint)) { uniquePointIsCenter = true; } } Assert.assertTrue(uniquePointIsCenter); } /** * 2 variables cannot be clustered into 3 clusters. See issue MATH-436. */ @Test(expected=NumberIsTooSmallException.class) public void testPerformClusterAnalysisToManyClusters() { KMeansPlusPlusClusterer<DoublePoint> transformer = new KMeansPlusPlusClusterer<DoublePoint>(3, 1, new EuclideanDistance(), random); DoublePoint[] points = new DoublePoint[] { new DoublePoint(new int[] { 1959, 325100 }), new DoublePoint(new int[] { 1960, 373200 }) }; transformer.cluster(Arrays.asList(points)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ml.clustering; import java.util.Arrays; import java.util.List; import org.junit.Assert; import org.junit.Test; public class MultiKMeansPlusPlusClustererTest { @Test public void dimension2() { MultiKMeansPlusPlusClusterer<DoublePoint> transformer = new MultiKMeansPlusPlusClusterer<DoublePoint>( new KMeansPlusPlusClusterer<DoublePoint>(3, 10), 5); DoublePoint[] points = new DoublePoint[] { // first expected cluster new DoublePoint(new int[] { -15, 3 }), new DoublePoint(new int[] { -15, 4 }), new DoublePoint(new int[] { -15, 5 }), new DoublePoint(new int[] { -14, 3 }), new DoublePoint(new int[] { -14, 5 }), new DoublePoint(new int[] { -13, 3 }), new DoublePoint(new int[] { -13, 4 }), new DoublePoint(new int[] { -13, 5 }), // second expected cluster new DoublePoint(new int[] { -1, 0 }), new DoublePoint(new int[] { -1, -1 }), new DoublePoint(new int[] { 0, -1 }), new DoublePoint(new int[] { 1, -1 }), new DoublePoint(new int[] { 1, -2 }), // third expected cluster new DoublePoint(new int[] { 13, 3 }), new DoublePoint(new int[] { 13, 4 }), new DoublePoint(new int[] { 14, 4 }), new DoublePoint(new int[] { 14, 7 }), new DoublePoint(new int[] { 16, 5 }), new DoublePoint(new int[] { 16, 6 }), new DoublePoint(new int[] { 17, 4 }), new DoublePoint(new int[] { 17, 7 }) }; List<CentroidCluster<DoublePoint>> clusters = transformer.cluster(Arrays.asList(points)); Assert.assertEquals(3, clusters.size()); boolean cluster1Found = false; boolean cluster2Found = false; boolean cluster3Found = false; double epsilon = 1e-6; for (CentroidCluster<DoublePoint> cluster : clusters) { Clusterable center = cluster.getCenter(); double[] point = center.getPoint(); if (point[0] < 0) { cluster1Found = true; Assert.assertEquals(8, cluster.getPoints().size()); Assert.assertEquals(-14, point[0], epsilon); Assert.assertEquals( 4, point[1], epsilon); } else if (point[1] < 0) { cluster2Found = true; Assert.assertEquals(5, cluster.getPoints().size()); Assert.assertEquals( 0, point[0], epsilon); Assert.assertEquals(-1, point[1], epsilon); } else { cluster3Found = true; Assert.assertEquals(8, cluster.getPoints().size()); Assert.assertEquals(15, point[0], epsilon); Assert.assertEquals(5, point[1], epsilon); } } Assert.assertTrue(cluster1Found); Assert.assertTrue(cluster2Found); Assert.assertTrue(cluster3Found); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ml.distance; import org.junit.Assert; import org.junit.Test; /** * Tests for {@link CanberraDistance} class. */ public class CanberraDistanceTest { final DistanceMeasure distance = new CanberraDistance(); @Test public void testZero() { final double[] a = { 0, 1, -2, 3.4, 5, -6.7, 89 }; Assert.assertEquals(0, distance.compute(a, a), 0d); } @Test public void testZero2() { final double[] a = { 0, 0 }; Assert.assertEquals(0, distance.compute(a, a), 0d); } @Test public void test() { final double[] a = { 1, 2, 3, 4, 9 }; final double[] b = { -5, -6, 7, 4, 3 }; final double expected = 2.9; Assert.assertEquals(expected, distance.compute(a, b), 0d); Assert.assertEquals(expected, distance.compute(b, a), 0d); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ml.distance; import org.junit.Assert; import org.junit.Test; /** * Tests for {@link ChebyshevDistance} class. */ public class ChebyshevDistanceTest { final DistanceMeasure distance = new ChebyshevDistance(); @Test public void testZero() { final double[] a = { 0, 1, -2, 3.4, 5, -6.7, 89 }; Assert.assertEquals(0, distance.compute(a, a), 0d); } @Test public void test() { final double[] a = { 1, 2, 3, 4 }; final double[] b = { -5, -6, 7, 8 }; final double expected = 8; Assert.assertEquals(expected, distance.compute(a, b), 0d); Assert.assertEquals(expected, distance.compute(b, a), 0d); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ml.distance; import org.junit.Assert; import org.apache.commons.math3.ml.distance.DistanceMeasure; import org.junit.Test; /** * Tests for {@link EarthMoversDistance} class. */ public class EarthMoversDistanceTest { final DistanceMeasure distance = new EarthMoversDistance(); final double[] a = { 0.1, 0.3, 0.2, 0.0, 0.25, 0.15 }; final double[] b = { 0.3, 0.0, 0.4, 0.1, 0.0, 0.2 }; @Test public void testZero() { Assert.assertEquals(0, distance.compute(a, a), 0d); } @Test public void testZero2() { final double[] zero = new double[] { 0, 0 }; Assert.assertEquals(0, distance.compute(zero, zero), 0d); } @Test public void test() { double expected = 0.65; //0.2 + 0.1 + 0.1 + 0.2 + 0.05 + 0.0; Assert.assertEquals(expected, distance.compute(a, b), 1e-10); Assert.assertEquals(expected, distance.compute(b, a), 1e-10); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ml.distance; import org.junit.Assert; import org.junit.Test; import org.apache.commons.math3.util.FastMath; /** * Tests for {@link EuclideanDistance} class. */ public class EuclideanDistanceTest { final DistanceMeasure distance = new EuclideanDistance(); @Test public void testZero() { final double[] a = { 0, 1, -2, 3.4, 5, -6.7, 89 }; Assert.assertEquals(0, distance.compute(a, a), 0d); } @Test public void test() { final double[] a = { 1, -2, 3, 4 }; final double[] b = { -5, -6, 7, 8 }; final double expected = FastMath.sqrt(84); Assert.assertEquals(expected, distance.compute(a, b), 0d); Assert.assertEquals(expected, distance.compute(b, a), 0d); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ml.distance; import org.junit.Assert; import org.junit.Test; /** * Tests for {@link ManhattanDistance} class. */ public class ManhattanDistanceTest { final DistanceMeasure distance = new ManhattanDistance(); @Test public void testZero() { final double[] a = { 0, 1, -2, 3.4, 5, -6.7, 89 }; Assert.assertEquals(0, distance.compute(a, a), 0d); } @Test public void test() { final double[] a = { 1, -2, 3, 4 }; final double[] b = { -5, -6, 7, 8 }; final double expected = 18; Assert.assertEquals(expected, distance.compute(a, b), 0d); Assert.assertEquals(expected, distance.compute(b, a), 0d); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ode; import java.util.Random; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.exception.MaxCountExceededException; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.ode.nonstiff.DormandPrince54Integrator; import org.apache.commons.math3.ode.nonstiff.DormandPrince853Integrator; import org.apache.commons.math3.ode.sampling.DummyStepInterpolator; import org.apache.commons.math3.ode.sampling.StepInterpolator; import org.apache.commons.math3.util.FastMath; import org.junit.After; import org.junit.Assert; import org.junit.Before; import org.junit.Test; public class ContinuousOutputModelTest { public ContinuousOutputModelTest() { pb = null; integ = null; } @Test public void testBoundaries() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { integ.addStepHandler(new ContinuousOutputModel()); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); ContinuousOutputModel cm = (ContinuousOutputModel) integ.getStepHandlers().iterator().next(); cm.setInterpolatedTime(2.0 * pb.getInitialTime() - pb.getFinalTime()); cm.setInterpolatedTime(2.0 * pb.getFinalTime() - pb.getInitialTime()); cm.setInterpolatedTime(0.5 * (pb.getFinalTime() + pb.getInitialTime())); } @Test public void testRandomAccess() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { ContinuousOutputModel cm = new ContinuousOutputModel(); integ.addStepHandler(cm); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Random random = new Random(347588535632l); double maxError = 0.0; for (int i = 0; i < 1000; ++i) { double r = random.nextDouble(); double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime(); cm.setInterpolatedTime(time); double[] interpolatedY = cm.getInterpolatedState (); double[] theoreticalY = pb.computeTheoreticalState(time); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } } Assert.assertTrue(maxError < 1.0e-9); } @Test public void testModelsMerging() throws MaxCountExceededException, MathIllegalArgumentException { // theoretical solution: y[0] = cos(t), y[1] = sin(t) FirstOrderDifferentialEquations problem = new FirstOrderDifferentialEquations() { public void computeDerivatives(double t, double[] y, double[] dot) { dot[0] = -y[1]; dot[1] = y[0]; } public int getDimension() { return 2; } }; // integrate backward from &pi; to 0; ContinuousOutputModel cm1 = new ContinuousOutputModel(); FirstOrderIntegrator integ1 = new DormandPrince853Integrator(0, 1.0, 1.0e-8, 1.0e-8); integ1.addStepHandler(cm1); integ1.integrate(problem, FastMath.PI, new double[] { -1.0, 0.0 }, 0, new double[2]); // integrate backward from 2&pi; to &pi; ContinuousOutputModel cm2 = new ContinuousOutputModel(); FirstOrderIntegrator integ2 = new DormandPrince853Integrator(0, 0.1, 1.0e-12, 1.0e-12); integ2.addStepHandler(cm2); integ2.integrate(problem, 2.0 * FastMath.PI, new double[] { 1.0, 0.0 }, FastMath.PI, new double[2]); // merge the two half circles ContinuousOutputModel cm = new ContinuousOutputModel(); cm.append(cm2); cm.append(new ContinuousOutputModel()); cm.append(cm1); // check circle Assert.assertEquals(2.0 * FastMath.PI, cm.getInitialTime(), 1.0e-12); Assert.assertEquals(0, cm.getFinalTime(), 1.0e-12); Assert.assertEquals(cm.getFinalTime(), cm.getInterpolatedTime(), 1.0e-12); for (double t = 0; t < 2.0 * FastMath.PI; t += 0.1) { cm.setInterpolatedTime(t); double[] y = cm.getInterpolatedState(); Assert.assertEquals(FastMath.cos(t), y[0], 1.0e-7); Assert.assertEquals(FastMath.sin(t), y[1], 1.0e-7); } } @Test public void testErrorConditions() throws MaxCountExceededException, MathIllegalArgumentException { ContinuousOutputModel cm = new ContinuousOutputModel(); cm.handleStep(buildInterpolator(0, new double[] { 0.0, 1.0, -2.0 }, 1), true); // dimension mismatch Assert.assertTrue(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0 }, 2.0)); // hole between time ranges Assert.assertTrue(checkAppendError(cm, 10.0, new double[] { 0.0, 1.0, -2.0 }, 20.0)); // propagation direction mismatch Assert.assertTrue(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0, -2.0 }, 0.0)); // no errors Assert.assertFalse(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0, -2.0 }, 2.0)); } private boolean checkAppendError(ContinuousOutputModel cm, double t0, double[] y0, double t1) throws MaxCountExceededException, MathIllegalArgumentException { try { ContinuousOutputModel otherCm = new ContinuousOutputModel(); otherCm.handleStep(buildInterpolator(t0, y0, t1), true); cm.append(otherCm); } catch(IllegalArgumentException iae) { return true; // there was an allowable error } return false; // no allowable error } private StepInterpolator buildInterpolator(double t0, double[] y0, double t1) { DummyStepInterpolator interpolator = new DummyStepInterpolator(y0, new double[y0.length], t1 >= t0); interpolator.storeTime(t0); interpolator.shift(); interpolator.storeTime(t1); return interpolator; } public void checkValue(double value, double reference) { Assert.assertTrue(FastMath.abs(value - reference) < 1.0e-10); } @Before public void setUp() { pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); integ = new DormandPrince54Integrator(minStep, maxStep, 1.0e-8, 1.0e-8); } @After public void tearDown() { pb = null; integ = null; } TestProblem3 pb; FirstOrderIntegrator integ; }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ode; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MaxCountExceededException; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.ode.nonstiff.ClassicalRungeKuttaIntegrator; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class FirstOrderConverterTest { @Test public void testDoubleDimension() { for (int i = 1; i < 10; ++i) { SecondOrderDifferentialEquations eqn2 = new Equations(i, 0.2); FirstOrderConverter eqn1 = new FirstOrderConverter(eqn2); Assert.assertTrue(eqn1.getDimension() == (2 * eqn2.getDimension())); } } @Test public void testDecreasingSteps() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { double previousError = Double.NaN; for (int i = 0; i < 10; ++i) { double step = FastMath.pow(2.0, -(i + 1)); double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, step) - FastMath.sin(4.0); if (i > 0) { Assert.assertTrue(FastMath.abs(error) < FastMath.abs(previousError)); } previousError = error; } } @Test public void testSmallStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, 1.0e-4) - FastMath.sin(4.0); Assert.assertTrue(FastMath.abs(error) < 1.0e-10); } @Test public void testBigStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, 0.5) - FastMath.sin(4.0); Assert.assertTrue(FastMath.abs(error) > 0.1); } private static class Equations implements SecondOrderDifferentialEquations { private int n; private double omega2; public Equations(int n, double omega) { this.n = n; omega2 = omega * omega; } public int getDimension() { return n; } public void computeSecondDerivatives(double t, double[] y, double[] yDot, double[] yDDot) { for (int i = 0; i < n; ++i) { yDDot[i] = -omega2 * y[i]; } } } private double integrateWithSpecifiedStep(double omega, double t0, double t, double step) throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { double[] y0 = new double[2]; y0[0] = FastMath.sin(omega * t0); y0[1] = omega * FastMath.cos(omega * t0); ClassicalRungeKuttaIntegrator i = new ClassicalRungeKuttaIntegrator(step); double[] y = new double[2]; i.integrate(new FirstOrderConverter(new Equations(1, omega)), t0, y0, t, y); return y[0]; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ode; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MaxCountExceededException; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.ode.JacobianMatrices.MismatchedEquations; import org.apache.commons.math3.ode.nonstiff.DormandPrince54Integrator; import org.apache.commons.math3.stat.descriptive.SummaryStatistics; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class JacobianMatricesTest { @Test public void testLowAccuracyExternalDifferentiation() throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException { // this test does not really test JacobianMatrices, // it only shows that WITHOUT this class, attempting to recover // the jacobians from external differentiation on simple integration // results with low accuracy gives very poor results. In fact, // the curves dy/dp = g(b) when b varies from 2.88 to 3.08 are // essentially noise. // This test is taken from Hairer, Norsett and Wanner book // Solving Ordinary Differential Equations I (Nonstiff problems), // the curves dy/dp = g(b) are in figure 6.5 FirstOrderIntegrator integ = new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-4, 1.0e-4 }, new double[] { 1.0e-4, 1.0e-4 }); double hP = 1.0e-12; SummaryStatistics residualsP0 = new SummaryStatistics(); SummaryStatistics residualsP1 = new SummaryStatistics(); for (double b = 2.88; b < 3.08; b += 0.001) { Brusselator brusselator = new Brusselator(b); double[] y = { 1.3, b }; integ.integrate(brusselator, 0, y, 20.0, y); double[] yP = { 1.3, b + hP }; integ.integrate(brusselator, 0, yP, 20.0, yP); residualsP0.addValue((yP[0] - y[0]) / hP - brusselator.dYdP0()); residualsP1.addValue((yP[1] - y[1]) / hP - brusselator.dYdP1()); } Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) > 500); Assert.assertTrue(residualsP0.getStandardDeviation() > 30); Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) > 700); Assert.assertTrue(residualsP1.getStandardDeviation() > 40); } @Test public void testHighAccuracyExternalDifferentiation() throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException, UnknownParameterException { FirstOrderIntegrator integ = new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-10, 1.0e-10 }, new double[] { 1.0e-10, 1.0e-10 }); double hP = 1.0e-12; SummaryStatistics residualsP0 = new SummaryStatistics(); SummaryStatistics residualsP1 = new SummaryStatistics(); for (double b = 2.88; b < 3.08; b += 0.001) { ParamBrusselator brusselator = new ParamBrusselator(b); double[] y = { 1.3, b }; integ.integrate(brusselator, 0, y, 20.0, y); double[] yP = { 1.3, b + hP }; brusselator.setParameter("b", b + hP); integ.integrate(brusselator, 0, yP, 20.0, yP); residualsP0.addValue((yP[0] - y[0]) / hP - brusselator.dYdP0()); residualsP1.addValue((yP[1] - y[1]) / hP - brusselator.dYdP1()); } Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) > 0.02); Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) < 0.03); Assert.assertTrue(residualsP0.getStandardDeviation() > 0.003); Assert.assertTrue(residualsP0.getStandardDeviation() < 0.004); Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) > 0.04); Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) < 0.05); Assert.assertTrue(residualsP1.getStandardDeviation() > 0.007); Assert.assertTrue(residualsP1.getStandardDeviation() < 0.008); } @Test public void testInternalDifferentiation() throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException, UnknownParameterException, MismatchedEquations { AbstractIntegrator integ = new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-4, 1.0e-4 }, new double[] { 1.0e-4, 1.0e-4 }); double hP = 1.0e-12; double hY = 1.0e-12; SummaryStatistics residualsP0 = new SummaryStatistics(); SummaryStatistics residualsP1 = new SummaryStatistics(); for (double b = 2.88; b < 3.08; b += 0.001) { ParamBrusselator brusselator = new ParamBrusselator(b); brusselator.setParameter(ParamBrusselator.B, b); double[] z = { 1.3, b }; double[][] dZdZ0 = new double[2][2]; double[] dZdP = new double[2]; JacobianMatrices jacob = new JacobianMatrices(brusselator, new double[] { hY, hY }, ParamBrusselator.B); jacob.setParameterizedODE(brusselator); jacob.setParameterStep(ParamBrusselator.B, hP); jacob.setInitialParameterJacobian(ParamBrusselator.B, new double[] { 0.0, 1.0 }); ExpandableStatefulODE efode = new ExpandableStatefulODE(brusselator); efode.setTime(0); efode.setPrimaryState(z); jacob.registerVariationalEquations(efode); integ.setMaxEvaluations(5000); integ.integrate(efode, 20.0); jacob.getCurrentMainSetJacobian(dZdZ0); jacob.getCurrentParameterJacobian(ParamBrusselator.B, dZdP); // Assert.assertEquals(5000, integ.getMaxEvaluations()); // Assert.assertTrue(integ.getEvaluations() > 1500); // Assert.assertTrue(integ.getEvaluations() < 2100); // Assert.assertEquals(4 * integ.getEvaluations(), integ.getEvaluations()); residualsP0.addValue(dZdP[0] - brusselator.dYdP0()); residualsP1.addValue(dZdP[1] - brusselator.dYdP1()); } Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) < 0.02); Assert.assertTrue(residualsP0.getStandardDeviation() < 0.003); Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) < 0.05); Assert.assertTrue(residualsP1.getStandardDeviation() < 0.01); } @Test public void testAnalyticalDifferentiation() throws MaxCountExceededException, DimensionMismatchException, NumberIsTooSmallException, NoBracketingException, UnknownParameterException, MismatchedEquations { AbstractIntegrator integ = new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-4, 1.0e-4 }, new double[] { 1.0e-4, 1.0e-4 }); SummaryStatistics residualsP0 = new SummaryStatistics(); SummaryStatistics residualsP1 = new SummaryStatistics(); for (double b = 2.88; b < 3.08; b += 0.001) { Brusselator brusselator = new Brusselator(b); double[] z = { 1.3, b }; double[][] dZdZ0 = new double[2][2]; double[] dZdP = new double[2]; JacobianMatrices jacob = new JacobianMatrices(brusselator, Brusselator.B); jacob.addParameterJacobianProvider(brusselator); jacob.setInitialParameterJacobian(Brusselator.B, new double[] { 0.0, 1.0 }); ExpandableStatefulODE efode = new ExpandableStatefulODE(brusselator); efode.setTime(0); efode.setPrimaryState(z); jacob.registerVariationalEquations(efode); integ.setMaxEvaluations(5000); integ.integrate(efode, 20.0); jacob.getCurrentMainSetJacobian(dZdZ0); jacob.getCurrentParameterJacobian(Brusselator.B, dZdP); // Assert.assertEquals(5000, integ.getMaxEvaluations()); // Assert.assertTrue(integ.getEvaluations() > 350); // Assert.assertTrue(integ.getEvaluations() < 510); residualsP0.addValue(dZdP[0] - brusselator.dYdP0()); residualsP1.addValue(dZdP[1] - brusselator.dYdP1()); } Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) < 0.014); Assert.assertTrue(residualsP0.getStandardDeviation() < 0.003); Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) < 0.05); Assert.assertTrue(residualsP1.getStandardDeviation() < 0.01); } @Test public void testFinalResult() throws MaxCountExceededException, DimensionMismatchException, NumberIsTooSmallException, NoBracketingException, UnknownParameterException, MismatchedEquations { AbstractIntegrator integ = new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-10, 1.0e-10 }, new double[] { 1.0e-10, 1.0e-10 }); double[] y = new double[] { 0.0, 1.0 }; Circle circle = new Circle(y, 1.0, 1.0, 0.1); JacobianMatrices jacob = new JacobianMatrices(circle, Circle.CX, Circle.CY, Circle.OMEGA); jacob.addParameterJacobianProvider(circle); jacob.setInitialMainStateJacobian(circle.exactDyDy0(0)); jacob.setInitialParameterJacobian(Circle.CX, circle.exactDyDcx(0)); jacob.setInitialParameterJacobian(Circle.CY, circle.exactDyDcy(0)); jacob.setInitialParameterJacobian(Circle.OMEGA, circle.exactDyDom(0)); ExpandableStatefulODE efode = new ExpandableStatefulODE(circle); efode.setTime(0); efode.setPrimaryState(y); jacob.registerVariationalEquations(efode); integ.setMaxEvaluations(5000); double t = 18 * FastMath.PI; integ.integrate(efode, t); y = efode.getPrimaryState(); for (int i = 0; i < y.length; ++i) { Assert.assertEquals(circle.exactY(t)[i], y[i], 1.0e-9); } double[][] dydy0 = new double[2][2]; jacob.getCurrentMainSetJacobian(dydy0); for (int i = 0; i < dydy0.length; ++i) { for (int j = 0; j < dydy0[i].length; ++j) { Assert.assertEquals(circle.exactDyDy0(t)[i][j], dydy0[i][j], 1.0e-9); } } double[] dydcx = new double[2]; jacob.getCurrentParameterJacobian(Circle.CX, dydcx); for (int i = 0; i < dydcx.length; ++i) { Assert.assertEquals(circle.exactDyDcx(t)[i], dydcx[i], 1.0e-7); } double[] dydcy = new double[2]; jacob.getCurrentParameterJacobian(Circle.CY, dydcy); for (int i = 0; i < dydcy.length; ++i) { Assert.assertEquals(circle.exactDyDcy(t)[i], dydcy[i], 1.0e-7); } double[] dydom = new double[2]; jacob.getCurrentParameterJacobian(Circle.OMEGA, dydom); for (int i = 0; i < dydom.length; ++i) { Assert.assertEquals(circle.exactDyDom(t)[i], dydom[i], 1.0e-7); } } @Test public void testParameterizable() throws MaxCountExceededException, DimensionMismatchException, NumberIsTooSmallException, NoBracketingException, UnknownParameterException, MismatchedEquations { AbstractIntegrator integ = new DormandPrince54Integrator(1.0e-8, 100.0, new double[] { 1.0e-10, 1.0e-10 }, new double[] { 1.0e-10, 1.0e-10 }); double[] y = new double[] { 0.0, 1.0 }; ParameterizedCircle pcircle = new ParameterizedCircle(y, 1.0, 1.0, 0.1); double hP = 1.0e-12; double hY = 1.0e-12; JacobianMatrices jacob = new JacobianMatrices(pcircle, new double[] { hY, hY }, ParameterizedCircle.CX, ParameterizedCircle.CY, ParameterizedCircle.OMEGA); jacob.setParameterizedODE(pcircle); jacob.setParameterStep(ParameterizedCircle.CX, hP); jacob.setParameterStep(ParameterizedCircle.CY, hP); jacob.setParameterStep(ParameterizedCircle.OMEGA, hP); jacob.setInitialMainStateJacobian(pcircle.exactDyDy0(0)); jacob.setInitialParameterJacobian(ParameterizedCircle.CX, pcircle.exactDyDcx(0)); jacob.setInitialParameterJacobian(ParameterizedCircle.CY, pcircle.exactDyDcy(0)); jacob.setInitialParameterJacobian(ParameterizedCircle.OMEGA, pcircle.exactDyDom(0)); ExpandableStatefulODE efode = new ExpandableStatefulODE(pcircle); efode.setTime(0); efode.setPrimaryState(y); jacob.registerVariationalEquations(efode); integ.setMaxEvaluations(50000); double t = 18 * FastMath.PI; integ.integrate(efode, t); y = efode.getPrimaryState(); for (int i = 0; i < y.length; ++i) { Assert.assertEquals(pcircle.exactY(t)[i], y[i], 1.0e-9); } double[][] dydy0 = new double[2][2]; jacob.getCurrentMainSetJacobian(dydy0); for (int i = 0; i < dydy0.length; ++i) { for (int j = 0; j < dydy0[i].length; ++j) { Assert.assertEquals(pcircle.exactDyDy0(t)[i][j], dydy0[i][j], 5.0e-4); } } double[] dydp0 = new double[2]; jacob.getCurrentParameterJacobian(ParameterizedCircle.CX, dydp0); for (int i = 0; i < dydp0.length; ++i) { Assert.assertEquals(pcircle.exactDyDcx(t)[i], dydp0[i], 5.0e-4); } double[] dydp1 = new double[2]; jacob.getCurrentParameterJacobian(ParameterizedCircle.OMEGA, dydp1); for (int i = 0; i < dydp1.length; ++i) { Assert.assertEquals(pcircle.exactDyDom(t)[i], dydp1[i], 1.0e-2); } } private static class Brusselator extends AbstractParameterizable implements MainStateJacobianProvider, ParameterJacobianProvider { public static final String B = "b"; private double b; public Brusselator(double b) { super(B); this.b = b; } public int getDimension() { return 2; } public void computeDerivatives(double t, double[] y, double[] yDot) { double prod = y[0] * y[0] * y[1]; yDot[0] = 1 + prod - (b + 1) * y[0]; yDot[1] = b * y[0] - prod; } public void computeMainStateJacobian(double t, double[] y, double[] yDot, double[][] dFdY) { double p = 2 * y[0] * y[1]; double y02 = y[0] * y[0]; dFdY[0][0] = p - (1 + b); dFdY[0][1] = y02; dFdY[1][0] = b - p; dFdY[1][1] = -y02; } public void computeParameterJacobian(double t, double[] y, double[] yDot, String paramName, double[] dFdP) { if (isSupported(paramName)) { dFdP[0] = -y[0]; dFdP[1] = y[0]; } else { dFdP[0] = 0; dFdP[1] = 0; } } public double dYdP0() { return -1088.232716447743 + (1050.775747149553 + (-339.012934631828 + 36.52917025056327 * b) * b) * b; } public double dYdP1() { return 1502.824469929139 + (-1438.6974831849952 + (460.959476642384 - 49.43847385647082 * b) * b) * b; } } private static class ParamBrusselator extends AbstractParameterizable implements FirstOrderDifferentialEquations, ParameterizedODE { public static final String B = "b"; private double b; public ParamBrusselator(double b) { super(B); this.b = b; } public int getDimension() { return 2; } /** {@inheritDoc} */ public double getParameter(final String name) throws UnknownParameterException { complainIfNotSupported(name); return b; } /** {@inheritDoc} */ public void setParameter(final String name, final double value) throws UnknownParameterException { complainIfNotSupported(name); b = value; } public void computeDerivatives(double t, double[] y, double[] yDot) { double prod = y[0] * y[0] * y[1]; yDot[0] = 1 + prod - (b + 1) * y[0]; yDot[1] = b * y[0] - prod; } public double dYdP0() { return -1088.232716447743 + (1050.775747149553 + (-339.012934631828 + 36.52917025056327 * b) * b) * b; } public double dYdP1() { return 1502.824469929139 + (-1438.6974831849952 + (460.959476642384 - 49.43847385647082 * b) * b) * b; } } /** ODE representing a point moving on a circle with provided center and angular rate. */ private static class Circle extends AbstractParameterizable implements MainStateJacobianProvider, ParameterJacobianProvider { public static final String CX = "cx"; public static final String CY = "cy"; public static final String OMEGA = "omega"; private final double[] y0; private double cx; private double cy; private double omega; public Circle(double[] y0, double cx, double cy, double omega) { super(CX,CY,OMEGA); this.y0 = y0.clone(); this.cx = cx; this.cy = cy; this.omega = omega; } public int getDimension() { return 2; } public void computeDerivatives(double t, double[] y, double[] yDot) { yDot[0] = omega * (cy - y[1]); yDot[1] = omega * (y[0] - cx); } public void computeMainStateJacobian(double t, double[] y, double[] yDot, double[][] dFdY) { dFdY[0][0] = 0; dFdY[0][1] = -omega; dFdY[1][0] = omega; dFdY[1][1] = 0; } public void computeParameterJacobian(double t, double[] y, double[] yDot, String paramName, double[] dFdP) throws UnknownParameterException { complainIfNotSupported(paramName); if (paramName.equals(CX)) { dFdP[0] = 0; dFdP[1] = -omega; } else if (paramName.equals(CY)) { dFdP[0] = omega; dFdP[1] = 0; } else { dFdP[0] = cy - y[1]; dFdP[1] = y[0] - cx; } } public double[] exactY(double t) { double cos = FastMath.cos(omega * t); double sin = FastMath.sin(omega * t); double dx0 = y0[0] - cx; double dy0 = y0[1] - cy; return new double[] { cx + cos * dx0 - sin * dy0, cy + sin * dx0 + cos * dy0 }; } public double[][] exactDyDy0(double t) { double cos = FastMath.cos(omega * t); double sin = FastMath.sin(omega * t); return new double[][] { { cos, -sin }, { sin, cos } }; } public double[] exactDyDcx(double t) { double cos = FastMath.cos(omega * t); double sin = FastMath.sin(omega * t); return new double[] {1 - cos, -sin}; } public double[] exactDyDcy(double t) { double cos = FastMath.cos(omega * t); double sin = FastMath.sin(omega * t); return new double[] {sin, 1 - cos}; } public double[] exactDyDom(double t) { double cos = FastMath.cos(omega * t); double sin = FastMath.sin(omega * t); double dx0 = y0[0] - cx; double dy0 = y0[1] - cy; return new double[] { -t * (sin * dx0 + cos * dy0) , t * (cos * dx0 - sin * dy0) }; } } /** ODE representing a point moving on a circle with provided center and angular rate. */ private static class ParameterizedCircle extends AbstractParameterizable implements FirstOrderDifferentialEquations, ParameterizedODE { public static final String CX = "cx"; public static final String CY = "cy"; public static final String OMEGA = "omega"; private final double[] y0; private double cx; private double cy; private double omega; public ParameterizedCircle(double[] y0, double cx, double cy, double omega) { super(CX,CY,OMEGA); this.y0 = y0.clone(); this.cx = cx; this.cy = cy; this.omega = omega; } public int getDimension() { return 2; } public void computeDerivatives(double t, double[] y, double[] yDot) { yDot[0] = omega * (cy - y[1]); yDot[1] = omega * (y[0] - cx); } public double getParameter(final String name) throws UnknownParameterException { if (name.equals(CX)) { return cx; } else if (name.equals(CY)) { return cy; } else if (name.equals(OMEGA)) { return omega; } else { throw new UnknownParameterException(name); } } public void setParameter(final String name, final double value) throws UnknownParameterException { if (name.equals(CX)) { cx = value; } else if (name.equals(CY)) { cy = value; } else if (name.equals(OMEGA)) { omega = value; } else { throw new UnknownParameterException(name); } } public double[] exactY(double t) { double cos = FastMath.cos(omega * t); double sin = FastMath.sin(omega * t); double dx0 = y0[0] - cx; double dy0 = y0[1] - cy; return new double[] { cx + cos * dx0 - sin * dy0, cy + sin * dx0 + cos * dy0 }; } public double[][] exactDyDy0(double t) { double cos = FastMath.cos(omega * t); double sin = FastMath.sin(omega * t); return new double[][] { { cos, -sin }, { sin, cos } }; } public double[] exactDyDcx(double t) { double cos = FastMath.cos(omega * t); double sin = FastMath.sin(omega * t); return new double[] {1 - cos, -sin}; } public double[] exactDyDcy(double t) { double cos = FastMath.cos(omega * t); double sin = FastMath.sin(omega * t); return new double[] {sin, 1 - cos}; } public double[] exactDyDom(double t) { double cos = FastMath.cos(omega * t); double sin = FastMath.sin(omega * t); double dx0 = y0[0] - cx; double dy0 = y0[1] - cy; return new double[] { -t * (sin * dx0 + cos * dy0) , t * (cos * dx0 - sin * dy0) }; } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ode.events; import org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MaxCountExceededException; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.ode.FirstOrderDifferentialEquations; import org.apache.commons.math3.ode.FirstOrderIntegrator; import org.apache.commons.math3.ode.nonstiff.DormandPrince853Integrator; import org.apache.commons.math3.random.RandomGenerator; import org.apache.commons.math3.random.Well19937a; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class EventFilterTest { @Test public void testHistoryIncreasingForward() { // start point: g > 0 testHistory(FilterType.TRIGGER_ONLY_INCREASING_EVENTS, 0.5 * FastMath.PI, 30.5 * FastMath.PI, FastMath.PI, -1); // start point: g = 0 testHistory(FilterType.TRIGGER_ONLY_INCREASING_EVENTS, 0, 30.5 * FastMath.PI, FastMath.PI, -1); // start point: g < 0 testHistory(FilterType.TRIGGER_ONLY_INCREASING_EVENTS, 1.5 * FastMath.PI, 30.5 * FastMath.PI, FastMath.PI, +1); } @Test public void testHistoryIncreasingBackward() { // start point: g > 0 testHistory(FilterType.TRIGGER_ONLY_INCREASING_EVENTS, 0.5 * FastMath.PI, -30.5 * FastMath.PI, FastMath.PI, -1); // start point: g = 0 testHistory(FilterType.TRIGGER_ONLY_INCREASING_EVENTS, 0, -30.5 * FastMath.PI, FastMath.PI, +1); // start point: g < 0 testHistory(FilterType.TRIGGER_ONLY_INCREASING_EVENTS, 1.5 * FastMath.PI, -30.5 * FastMath.PI, FastMath.PI, -1); } @Test public void testHistoryDecreasingForward() { // start point: g > 0 testHistory(FilterType.TRIGGER_ONLY_DECREASING_EVENTS, 0.5 * FastMath.PI, 30.5 * FastMath.PI, 0, +1); // start point: g = 0 testHistory(FilterType.TRIGGER_ONLY_DECREASING_EVENTS, 0, 30.5 * FastMath.PI, 0, +1); // start point: g < 0 testHistory(FilterType.TRIGGER_ONLY_DECREASING_EVENTS, 1.5 * FastMath.PI, 30.5 * FastMath.PI, 0, +1); } @Test public void testHistoryDecreasingBackward() { // start point: g > 0 testHistory(FilterType.TRIGGER_ONLY_DECREASING_EVENTS, 0.5 * FastMath.PI, -30.5 * FastMath.PI, 0, -1); // start point: g = 0 testHistory(FilterType.TRIGGER_ONLY_DECREASING_EVENTS, 0, -30.5 * FastMath.PI, 0, -1); // start point: g < 0 testHistory(FilterType.TRIGGER_ONLY_DECREASING_EVENTS, 1.5 * FastMath.PI, -30.5 * FastMath.PI, 0, +1); } public void testHistory(FilterType type, double t0, double t1, double refSwitch, double signEven) { Event onlyIncreasing = new Event(false, true); EventFilter eventFilter = new EventFilter(onlyIncreasing, type); eventFilter.init(t0, new double[] {1.0, 0.0}, t1); // first pass to set up switches history for a long period double h = FastMath.copySign(0.05, t1 - t0); double n = (int) FastMath.floor((t1 - t0) / h); for (int i = 0; i < n; ++i) { double t = t0 + i * h; eventFilter.g(t, new double[] { FastMath.sin(t), FastMath.cos(t) }); } // verify old events are preserved, even if randomly accessed RandomGenerator rng = new Well19937a(0xb0e7401265af8cd3l); for (int i = 0; i < 5000; i++) { double t = t0 + (t1 - t0) * rng.nextDouble(); double g = eventFilter.g(t, new double[] { FastMath.sin(t), FastMath.cos(t) }); int turn = (int) FastMath.floor((t - refSwitch) / (2 * FastMath.PI)); if (turn % 2 == 0) { Assert.assertEquals( signEven * FastMath.sin(t), g, 1.0e-10); } else { Assert.assertEquals(-signEven * FastMath.sin(t), g, 1.0e-10); } } } @Test public void testIncreasingOnly() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { double e = 1e-15; FirstOrderIntegrator integrator; integrator = new DormandPrince853Integrator(1.0e-3, 100.0, 1e-7, 1e-7); Event allEvents = new Event(true, true); integrator.addEventHandler(allEvents, 0.1, e, 1000, new BracketingNthOrderBrentSolver(1.0e-7, 5)); Event onlyIncreasing = new Event(false, true); integrator.addEventHandler(new EventFilter(onlyIncreasing, FilterType.TRIGGER_ONLY_INCREASING_EVENTS), 0.1, e, 100, new BracketingNthOrderBrentSolver(1.0e-7, 5)); double t0 = 0.5 * FastMath.PI; double tEnd = 5.5 * FastMath.PI; double[] y = { 0.0, 1.0 }; Assert.assertEquals(tEnd, integrator.integrate(new SineCosine(), t0, y, tEnd, y), 1.0e-7); Assert.assertEquals(5, allEvents.getEventCount()); Assert.assertEquals(2, onlyIncreasing.getEventCount()); } @Test public void testDecreasingOnly() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { double e = 1e-15; FirstOrderIntegrator integrator; integrator = new DormandPrince853Integrator(1.0e-3, 100.0, 1e-7, 1e-7); Event allEvents = new Event(true, true); integrator.addEventHandler(allEvents, 0.1, e, 1000, new BracketingNthOrderBrentSolver(1.0e-7, 5)); Event onlyDecreasing = new Event(true, false); integrator.addEventHandler(new EventFilter(onlyDecreasing, FilterType.TRIGGER_ONLY_DECREASING_EVENTS), 0.1, e, 1000, new BracketingNthOrderBrentSolver(1.0e-7, 5)); double t0 = 0.5 * FastMath.PI; double tEnd = 5.5 * FastMath.PI; double[] y = { 0.0, 1.0 }; Assert.assertEquals(tEnd, integrator.integrate(new SineCosine(), t0, y, tEnd, y), 1.0e-7); Assert.assertEquals(5, allEvents.getEventCount()); Assert.assertEquals(3, onlyDecreasing.getEventCount()); } @Test public void testTwoOppositeFilters() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { double e = 1e-15; FirstOrderIntegrator integrator; integrator = new DormandPrince853Integrator(1.0e-3, 100.0, 1e-7, 1e-7); Event allEvents = new Event(true, true); integrator.addEventHandler(allEvents, 0.1, e, 1000, new BracketingNthOrderBrentSolver(1.0e-7, 5)); Event onlyIncreasing = new Event(false, true); integrator.addEventHandler(new EventFilter(onlyIncreasing, FilterType.TRIGGER_ONLY_INCREASING_EVENTS), 0.1, e, 1000, new BracketingNthOrderBrentSolver(1.0e-7, 5)); Event onlyDecreasing = new Event(true, false); integrator.addEventHandler(new EventFilter(onlyDecreasing, FilterType.TRIGGER_ONLY_DECREASING_EVENTS), 0.1, e, 1000, new BracketingNthOrderBrentSolver(1.0e-7, 5)); double t0 = 0.5 * FastMath.PI; double tEnd = 5.5 * FastMath.PI; double[] y = { 0.0, 1.0 }; Assert.assertEquals(tEnd, integrator.integrate(new SineCosine(), t0, y, tEnd, y), 1.0e-7); Assert.assertEquals(5, allEvents.getEventCount()); Assert.assertEquals(2, onlyIncreasing.getEventCount()); Assert.assertEquals(3, onlyDecreasing.getEventCount()); } private static class SineCosine implements FirstOrderDifferentialEquations { public int getDimension() { return 2; } public void computeDerivatives(double t, double[] y, double[] yDot) { yDot[0] = y[1]; yDot[1] = -y[0]; } } /** State events for this unit test. */ protected static class Event implements EventHandler { private final boolean expectDecreasing; private final boolean expectIncreasing; private int eventCount; public Event(boolean expectDecreasing, boolean expectIncreasing) { this.expectDecreasing = expectDecreasing; this.expectIncreasing = expectIncreasing; } public int getEventCount() { return eventCount; } public void init(double t0, double[] y0, double t) { eventCount = 0; } public double g(double t, double[] y) { return y[0]; } public Action eventOccurred(double t, double[] y, boolean increasing) { if (increasing) { Assert.assertTrue(expectIncreasing); } else { Assert.assertTrue(expectDecreasing); } eventCount++; return Action.RESET_STATE; } public void resetState(double t, double[] y) { // in fact, we don't really reset anything for this test } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ode.events; import org.apache.commons.math3.analysis.solvers.BrentSolver; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MaxCountExceededException; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.ode.ExpandableStatefulODE; import org.apache.commons.math3.ode.FirstOrderDifferentialEquations; import org.apache.commons.math3.ode.SecondaryEquations; import org.apache.commons.math3.ode.nonstiff.DormandPrince853Integrator; import org.apache.commons.math3.ode.sampling.AbstractStepInterpolator; import org.apache.commons.math3.ode.sampling.DummyStepInterpolator; import org.junit.Assert; import org.junit.Test; public class EventStateTest { // JIRA: MATH-322 @Test public void closeEvents() throws MaxCountExceededException, NoBracketingException { final double r1 = 90.0; final double r2 = 135.0; final double gap = r2 - r1; EventHandler closeEventsGenerator = new EventHandler() { public void init(double t0, double[] y0, double t) { } public void resetState(double t, double[] y) { } public double g(double t, double[] y) { return (t - r1) * (r2 - t); } public Action eventOccurred(double t, double[] y, boolean increasing) { return Action.CONTINUE; } }; final double tolerance = 0.1; EventState es = new EventState(closeEventsGenerator, 1.5 * gap, tolerance, 100, new BrentSolver(tolerance)); es.setExpandable(new ExpandableStatefulODE(new FirstOrderDifferentialEquations() { public int getDimension() { return 0; } public void computeDerivatives(double t, double[] y, double[] yDot) { } })); AbstractStepInterpolator interpolator = new DummyStepInterpolator(new double[0], new double[0], true); interpolator.storeTime(r1 - 2.5 * gap); interpolator.shift(); interpolator.storeTime(r1 - 1.5 * gap); es.reinitializeBegin(interpolator); interpolator.shift(); interpolator.storeTime(r1 - 0.5 * gap); Assert.assertFalse(es.evaluateStep(interpolator)); interpolator.shift(); interpolator.storeTime(0.5 * (r1 + r2)); Assert.assertTrue(es.evaluateStep(interpolator)); Assert.assertEquals(r1, es.getEventTime(), tolerance); es.stepAccepted(es.getEventTime(), new double[0]); interpolator.shift(); interpolator.storeTime(r2 + 0.4 * gap); Assert.assertTrue(es.evaluateStep(interpolator)); Assert.assertEquals(r2, es.getEventTime(), tolerance); } // Jira: MATH-695 @Test public void testIssue695() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { FirstOrderDifferentialEquations equation = new FirstOrderDifferentialEquations() { public int getDimension() { return 1; } public void computeDerivatives(double t, double[] y, double[] yDot) { yDot[0] = 1.0; } }; DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.001, 1000, 1.0e-14, 1.0e-14); integrator.addEventHandler(new ResettingEvent(10.99), 0.1, 1.0e-9, 1000); integrator.addEventHandler(new ResettingEvent(11.01), 0.1, 1.0e-9, 1000); integrator.setInitialStepSize(3.0); double target = 30.0; double[] y = new double[1]; double tEnd = integrator.integrate(equation, 0.0, y, target, y); Assert.assertEquals(target, tEnd, 1.0e-10); Assert.assertEquals(32.0, y[0], 1.0e-10); } private static class ResettingEvent implements EventHandler { private static double lastTriggerTime = Double.NEGATIVE_INFINITY; private final double tEvent; public ResettingEvent(final double tEvent) { this.tEvent = tEvent; } public void init(double t0, double[] y0, double t) { } public double g(double t, double[] y) { // the bug corresponding to issue 695 causes the g function // to be called at obsolete times t despite an event // occurring later has already been triggered. // When this occurs, the following assertion is violated Assert.assertTrue("going backard in time! (" + t + " < " + lastTriggerTime + ")", t >= lastTriggerTime); return t - tEvent; } public Action eventOccurred(double t, double[] y, boolean increasing) { // remember in a class variable when the event was triggered lastTriggerTime = t; return Action.RESET_STATE; } public void resetState(double t, double[] y) { y[0] += 1.0; } } // Jira: MATH-965 @Test public void testIssue965() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { ExpandableStatefulODE equation = new ExpandableStatefulODE(new FirstOrderDifferentialEquations() { public int getDimension() { return 1; } public void computeDerivatives(double t, double[] y, double[] yDot) { yDot[0] = 2.0; } }); equation.setTime(0.0); equation.setPrimaryState(new double[1]); equation.addSecondaryEquations(new SecondaryEquations() { public int getDimension() { return 1; } public void computeDerivatives(double t, double[] primary, double[] primaryDot, double[] secondary, double[] secondaryDot) { secondaryDot[0] = -3.0; } }); int index = equation.getSecondaryMappers()[0].getFirstIndex(); DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.001, 1000, 1.0e-14, 1.0e-14); integrator.addEventHandler(new SecondaryStateEvent(index, -3.0), 0.1, 1.0e-9, 1000); integrator.setInitialStepSize(3.0); integrator.integrate(equation, 30.0); Assert.assertEquals( 1.0, equation.getTime(), 1.0e-10); Assert.assertEquals( 2.0, equation.getPrimaryState()[0], 1.0e-10); Assert.assertEquals(-3.0, equation.getSecondaryState(0)[0], 1.0e-10); } private static class SecondaryStateEvent implements EventHandler { private int index; private final double target; public SecondaryStateEvent(final int index, final double target) { this.index = index; this.target = target; } public void init(double t0, double[] y0, double t) { } public double g(double t, double[] y) { return y[index] - target; } public Action eventOccurred(double t, double[] y, boolean increasing) { return Action.STOP; } public void resetState(double t, double[] y) { } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ode.events; import java.util.ArrayList; import java.util.List; import org.apache.commons.math3.analysis.solvers.BaseSecantSolver; import org.apache.commons.math3.analysis.solvers.PegasusSolver; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MaxCountExceededException; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.ode.FirstOrderDifferentialEquations; import org.apache.commons.math3.ode.FirstOrderIntegrator; import org.apache.commons.math3.ode.nonstiff.DormandPrince853Integrator; import org.junit.Assert; import org.junit.Test; /** Tests for overlapping state events. Also tests an event function that does * not converge to zero, but does have values of opposite sign around its root. */ public class OverlappingEventsTest implements FirstOrderDifferentialEquations { /** Expected event times for first event. */ private static final double[] EVENT_TIMES1 = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0}; /** Expected event times for second event. */ private static final double[] EVENT_TIMES2 = {0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5, 9.0, 9.5}; /** Test for events that occur at the exact same time, but due to numerical * calculations occur very close together instead. Uses event type 0. See * {@link org.apache.commons.math3.ode.events.EventHandler#g(double, double[]) * EventHandler.g(double, double[])}. */ @Test public void testOverlappingEvents0() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { test(0); } /** Test for events that occur at the exact same time, but due to numerical * calculations occur very close together instead. Uses event type 1. See * {@link org.apache.commons.math3.ode.events.EventHandler#g(double, double[]) * EventHandler.g(double, double[])}. */ @Test public void testOverlappingEvents1() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { test(1); } /** Test for events that occur at the exact same time, but due to numerical * calculations occur very close together instead. * @param eventType the type of events to use. See * {@link org.apache.commons.math3.ode.events.EventHandler#g(double, double[]) * EventHandler.g(double, double[])}. */ public void test(int eventType) throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { double e = 1e-15; FirstOrderIntegrator integrator = new DormandPrince853Integrator(e, 100.0, 1e-7, 1e-7); BaseSecantSolver rootSolver = new PegasusSolver(e, e); EventHandler evt1 = new Event(0, eventType); EventHandler evt2 = new Event(1, eventType); integrator.addEventHandler(evt1, 0.1, e, 999, rootSolver); integrator.addEventHandler(evt2, 0.1, e, 999, rootSolver); double t = 0.0; double tEnd = 10.0; double[] y = {0.0, 0.0}; List<Double> events1 = new ArrayList<Double>(); List<Double> events2 = new ArrayList<Double>(); while (t < tEnd) { t = integrator.integrate(this, t, y, tEnd, y); //System.out.println("t=" + t + ",\t\ty=[" + y[0] + "," + y[1] + "]"); if (y[0] >= 1.0) { y[0] = 0.0; events1.add(t); //System.out.println("Event 1 @ t=" + t); } if (y[1] >= 1.0) { y[1] = 0.0; events2.add(t); //System.out.println("Event 2 @ t=" + t); } } Assert.assertEquals(EVENT_TIMES1.length, events1.size()); Assert.assertEquals(EVENT_TIMES2.length, events2.size()); for(int i = 0; i < EVENT_TIMES1.length; i++) { Assert.assertEquals(EVENT_TIMES1[i], events1.get(i), 1e-7); } for(int i = 0; i < EVENT_TIMES2.length; i++) { Assert.assertEquals(EVENT_TIMES2[i], events2.get(i), 1e-7); } //System.out.println(); } /** {@inheritDoc} */ public int getDimension() { return 2; } /** {@inheritDoc} */ public void computeDerivatives(double t, double[] y, double[] yDot) { yDot[0] = 1.0; yDot[1] = 2.0; } /** State events for this unit test. */ private class Event implements EventHandler { /** The index of the continuous variable to use. */ private final int idx; /** The event type to use. See {@link #g}. */ private final int eventType; /** Constructor for the {@link Event} class. * @param idx the index of the continuous variable to use * @param eventType the type of event to use. See {@link #g} */ public Event(int idx, int eventType) { this.idx = idx; this.eventType = eventType; } /** {@inheritDoc} */ public void init(double t0, double[] y0, double t) { } /** {@inheritDoc} */ public double g(double t, double[] y) { return (eventType == 0) ? y[idx] >= 1.0 ? 1.0 : -1.0 : y[idx] - 1.0; } /** {@inheritDoc} */ public Action eventOccurred(double t, double[] y, boolean increasing) { return Action.STOP; } /** {@inheritDoc} */ public void resetState(double t, double[] y) { // Never called. } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ode.events; import org.junit.Assert; import java.util.Arrays; import org.apache.commons.math3.analysis.solvers.PegasusSolver; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MaxCountExceededException; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.ode.FirstOrderDifferentialEquations; import org.apache.commons.math3.ode.FirstOrderIntegrator; import org.apache.commons.math3.ode.events.EventHandler; import org.apache.commons.math3.ode.nonstiff.DormandPrince853Integrator; import org.apache.commons.math3.ode.nonstiff.GraggBulirschStoerIntegrator; import org.junit.Test; public class ReappearingEventTest { @Test public void testDormandPrince() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { double tEnd = test(1); Assert.assertEquals(10.0, tEnd, 1e-7); } @Test public void testGragg() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { double tEnd = test(2); Assert.assertEquals(10.0, tEnd, 1e-7); } public double test(int integratorType) throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { double e = 1e-15; FirstOrderIntegrator integrator; integrator = (integratorType == 1) ? new DormandPrince853Integrator(e, 100.0, 1e-7, 1e-7) : new GraggBulirschStoerIntegrator(e, 100.0, 1e-7, 1e-7); PegasusSolver rootSolver = new PegasusSolver(e, e); integrator.addEventHandler(new Event(), 0.1, e, 1000, rootSolver); double t0 = 6.0; double tEnd = 10.0; double[] y = {2.0, 2.0, 2.0, 4.0, 2.0, 7.0, 15.0}; return integrator.integrate(new Ode(), t0, y, tEnd, y); } private static class Ode implements FirstOrderDifferentialEquations { public int getDimension() { return 7; } public void computeDerivatives(double t, double[] y, double[] yDot) { Arrays.fill(yDot, 1.0); } } /** State events for this unit test. */ protected static class Event implements EventHandler { public void init(double t0, double[] y0, double t) { } public double g(double t, double[] y) { return y[6] - 15.0; } public Action eventOccurred(double t, double[] y, boolean increasing) { return Action.STOP; } public void resetState(double t, double[] y) { // Never called. } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ode.nonstiff; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MaxCountExceededException; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.ode.FirstOrderIntegrator; import org.apache.commons.math3.ode.TestProblem1; import org.apache.commons.math3.ode.TestProblem5; import org.apache.commons.math3.ode.TestProblem6; import org.apache.commons.math3.ode.TestProblemHandler; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class AdamsBashforthIntegratorTest { @Test(expected=DimensionMismatchException.class) public void dimensionCheck() throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException { TestProblem1 pb = new TestProblem1(); FirstOrderIntegrator integ = new AdamsBashforthIntegrator(2, 0.0, 1.0, 1.0e-10, 1.0e-10); integ.integrate(pb, 0.0, new double[pb.getDimension()+10], 1.0, new double[pb.getDimension()+10]); } @Test(expected=NumberIsTooSmallException.class) public void testMinStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem1 pb = new TestProblem1(); double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime()); double maxStep = pb.getFinalTime() - pb.getInitialTime(); double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 }; double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 }; FirstOrderIntegrator integ = new AdamsBashforthIntegrator(4, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); } @Test public void testIncreasingTolerance() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { int previousCalls = Integer.MAX_VALUE; for (int i = -12; i < -5; ++i) { TestProblem1 pb = new TestProblem1(); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = FastMath.pow(10.0, i); double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; FirstOrderIntegrator integ = new AdamsBashforthIntegrator(4, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); // the 50 and 300 factors are only valid for this test // and has been obtained from trial and error // there is no general relation between local and global errors Assert.assertTrue(handler.getMaximalValueError() > (50.0 * scalAbsoluteTolerance)); Assert.assertTrue(handler.getMaximalValueError() < (300.0 * scalAbsoluteTolerance)); Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-16); int calls = pb.getCalls(); Assert.assertEquals(integ.getEvaluations(), calls); Assert.assertTrue(calls <= previousCalls); previousCalls = calls; } } @Test(expected = MaxCountExceededException.class) public void exceedMaxEvaluations() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem1 pb = new TestProblem1(); double range = pb.getFinalTime() - pb.getInitialTime(); AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(2, 0, range, 1.0e-12, 1.0e-12); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.setMaxEvaluations(650); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); } @Test public void backward() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem5 pb = new TestProblem5(); double range = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()); FirstOrderIntegrator integ = new AdamsBashforthIntegrator(4, 0, range, 1.0e-12, 1.0e-12); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertTrue(handler.getLastError() < 1.5e-8); Assert.assertTrue(handler.getMaximalValueError() < 1.5e-8); Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-16); Assert.assertEquals("Adams-Bashforth", integ.getName()); } @Test public void polynomial() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem6 pb = new TestProblem6(); double range = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()); for (int nSteps = 2; nSteps < 8; ++nSteps) { AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(nSteps, 1.0e-6 * range, 0.1 * range, 1.0e-5, 1.0e-5); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); if (nSteps < 4) { Assert.assertTrue(handler.getMaximalValueError() > 1.0e-03); } else { Assert.assertTrue(handler.getMaximalValueError() < 4.0e-12); } } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ode.nonstiff; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MaxCountExceededException; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.ode.FirstOrderIntegrator; import org.apache.commons.math3.ode.TestProblem1; import org.apache.commons.math3.ode.TestProblem5; import org.apache.commons.math3.ode.TestProblem6; import org.apache.commons.math3.ode.TestProblemHandler; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class AdamsMoultonIntegratorTest { @Test(expected=DimensionMismatchException.class) public void dimensionCheck() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem1 pb = new TestProblem1(); FirstOrderIntegrator integ = new AdamsMoultonIntegrator(2, 0.0, 1.0, 1.0e-10, 1.0e-10); integ.integrate(pb, 0.0, new double[pb.getDimension()+10], 1.0, new double[pb.getDimension()+10]); } @Test(expected=NumberIsTooSmallException.class) public void testMinStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem1 pb = new TestProblem1(); double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime()); double maxStep = pb.getFinalTime() - pb.getInitialTime(); double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 }; double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 }; FirstOrderIntegrator integ = new AdamsMoultonIntegrator(4, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); } @Test public void testIncreasingTolerance() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { int previousCalls = Integer.MAX_VALUE; for (int i = -12; i < -2; ++i) { TestProblem1 pb = new TestProblem1(); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = FastMath.pow(10.0, i); double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; FirstOrderIntegrator integ = new AdamsMoultonIntegrator(4, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); // the 0.5 and 11.0 factors are only valid for this test // and has been obtained from trial and error // there is no general relation between local and global errors Assert.assertTrue(handler.getMaximalValueError() > ( 0.5 * scalAbsoluteTolerance)); Assert.assertTrue(handler.getMaximalValueError() < (11.0 * scalAbsoluteTolerance)); Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-16); int calls = pb.getCalls(); Assert.assertEquals(integ.getEvaluations(), calls); Assert.assertTrue(calls <= previousCalls); previousCalls = calls; } } @Test(expected = MaxCountExceededException.class) public void exceedMaxEvaluations() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem1 pb = new TestProblem1(); double range = pb.getFinalTime() - pb.getInitialTime(); AdamsMoultonIntegrator integ = new AdamsMoultonIntegrator(2, 0, range, 1.0e-12, 1.0e-12); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.setMaxEvaluations(650); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); } @Test public void backward() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem5 pb = new TestProblem5(); double range = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()); FirstOrderIntegrator integ = new AdamsMoultonIntegrator(4, 0, range, 1.0e-12, 1.0e-12); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertTrue(handler.getLastError() < 1.0e-9); Assert.assertTrue(handler.getMaximalValueError() < 1.0e-9); Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-16); Assert.assertEquals("Adams-Moulton", integ.getName()); } @Test public void polynomial() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem6 pb = new TestProblem6(); double range = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()); for (int nSteps = 2; nSteps < 8; ++nSteps) { AdamsMoultonIntegrator integ = new AdamsMoultonIntegrator(nSteps, 1.0e-6 * range, 0.1 * range, 1.0e-5, 1.0e-5); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); if (nSteps < 4) { Assert.assertTrue(handler.getMaximalValueError() > 7.0e-04); } else { Assert.assertTrue(handler.getMaximalValueError() < 3.0e-13); } } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ode.nonstiff; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MaxCountExceededException; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.ode.FirstOrderDifferentialEquations; import org.apache.commons.math3.ode.FirstOrderIntegrator; import org.apache.commons.math3.ode.TestProblem1; import org.apache.commons.math3.ode.TestProblem3; import org.apache.commons.math3.ode.TestProblem5; import org.apache.commons.math3.ode.TestProblemAbstract; import org.apache.commons.math3.ode.TestProblemFactory; import org.apache.commons.math3.ode.TestProblemHandler; import org.apache.commons.math3.ode.events.EventHandler; import org.apache.commons.math3.ode.sampling.StepHandler; import org.apache.commons.math3.ode.sampling.StepInterpolator; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class ClassicalRungeKuttaIntegratorTest { @Test public void testMissedEndEvent() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { final double t0 = 1878250320.0000029; final double tEvent = 1878250379.9999986; final double[] k = { 1.0e-4, 1.0e-5, 1.0e-6 }; FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations() { public int getDimension() { return k.length; } public void computeDerivatives(double t, double[] y, double[] yDot) { for (int i = 0; i < y.length; ++i) { yDot[i] = k[i] * y[i]; } } }; ClassicalRungeKuttaIntegrator integrator = new ClassicalRungeKuttaIntegrator(60.0); double[] y0 = new double[k.length]; for (int i = 0; i < y0.length; ++i) { y0[i] = i + 1; } double[] y = new double[k.length]; double finalT = integrator.integrate(ode, t0, y0, tEvent, y); Assert.assertEquals(tEvent, finalT, 5.0e-6); for (int i = 0; i < y.length; ++i) { Assert.assertEquals(y0[i] * FastMath.exp(k[i] * (finalT - t0)), y[i], 1.0e-9); } integrator.addEventHandler(new EventHandler() { public void init(double t0, double[] y0, double t) { } public void resetState(double t, double[] y) { } public double g(double t, double[] y) { return t - tEvent; } public Action eventOccurred(double t, double[] y, boolean increasing) { Assert.assertEquals(tEvent, t, 5.0e-6); return Action.CONTINUE; } }, Double.POSITIVE_INFINITY, 1.0e-20, 100); finalT = integrator.integrate(ode, t0, y0, tEvent + 120, y); Assert.assertEquals(tEvent + 120, finalT, 5.0e-6); for (int i = 0; i < y.length; ++i) { Assert.assertEquals(y0[i] * FastMath.exp(k[i] * (finalT - t0)), y[i], 1.0e-9); } } @Test public void testSanityChecks() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { try { TestProblem1 pb = new TestProblem1(); new ClassicalRungeKuttaIntegrator(0.01).integrate(pb, 0.0, new double[pb.getDimension()+10], 1.0, new double[pb.getDimension()]); Assert.fail("an exception should have been thrown"); } catch(DimensionMismatchException ie) { } try { TestProblem1 pb = new TestProblem1(); new ClassicalRungeKuttaIntegrator(0.01).integrate(pb, 0.0, new double[pb.getDimension()], 1.0, new double[pb.getDimension()+10]); Assert.fail("an exception should have been thrown"); } catch(DimensionMismatchException ie) { } try { TestProblem1 pb = new TestProblem1(); new ClassicalRungeKuttaIntegrator(0.01).integrate(pb, 0.0, new double[pb.getDimension()], 0.0, new double[pb.getDimension()]); Assert.fail("an exception should have been thrown"); } catch(NumberIsTooSmallException ie) { } } @Test public void testDecreasingSteps() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblemAbstract[] problems = TestProblemFactory.getProblems(); for (int k = 0; k < problems.length; ++k) { double previousValueError = Double.NaN; double previousTimeError = Double.NaN; for (int i = 4; i < 10; ++i) { TestProblemAbstract pb = problems[k].copy(); double step = (pb.getFinalTime() - pb.getInitialTime()) * FastMath.pow(2.0, -i); FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); EventHandler[] functions = pb.getEventsHandlers(); for (int l = 0; l < functions.length; ++l) { integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000); } Assert.assertEquals(functions.length, integ.getEventHandlers().size()); double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); if (functions.length == 0) { Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10); } double error = handler.getMaximalValueError(); if (i > 4) { Assert.assertTrue(error < 1.01 * FastMath.abs(previousValueError)); } previousValueError = error; double timeError = handler.getMaximalTimeError(); if (i > 4) { Assert.assertTrue(timeError <= FastMath.abs(previousTimeError)); } previousTimeError = timeError; integ.clearEventHandlers(); Assert.assertEquals(0, integ.getEventHandlers().size()); } } } @Test public void testSmallStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem1 pb = new TestProblem1(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001; FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertTrue(handler.getLastError() < 2.0e-13); Assert.assertTrue(handler.getMaximalValueError() < 4.0e-12); Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); Assert.assertEquals("classical Runge-Kutta", integ.getName()); } @Test public void testBigStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem1 pb = new TestProblem1(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2; FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertTrue(handler.getLastError() > 0.0004); Assert.assertTrue(handler.getMaximalValueError() > 0.005); Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); } @Test public void testBackward() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem5 pb = new TestProblem5(); double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001; FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertTrue(handler.getLastError() < 5.0e-10); Assert.assertTrue(handler.getMaximalValueError() < 7.0e-10); Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); Assert.assertEquals("classical Runge-Kutta", integ.getName()); } @Test public void testKepler() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { final TestProblem3 pb = new TestProblem3(0.9); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003; FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step); integ.addStepHandler(new KeplerHandler(pb)); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); } private static class KeplerHandler implements StepHandler { public KeplerHandler(TestProblem3 pb) { this.pb = pb; maxError = 0; } public void init(double t0, double[] y0, double t) { maxError = 0; } public void handleStep(StepInterpolator interpolator, boolean isLast) throws MaxCountExceededException { double[] interpolatedY = interpolator.getInterpolatedState (); double[] theoreticalY = pb.computeTheoreticalState(interpolator.getCurrentTime()); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } if (isLast) { // even with more than 1000 evaluations per period, // RK4 is not able to integrate such an eccentric // orbit with a good accuracy Assert.assertTrue(maxError > 0.005); } } private double maxError = 0; private TestProblem3 pb; } @Test public void testStepSize() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { final double step = 1.23456; FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step); integ.addStepHandler(new StepHandler() { public void handleStep(StepInterpolator interpolator, boolean isLast) { if (! isLast) { Assert.assertEquals(step, interpolator.getCurrentTime() - interpolator.getPreviousTime(), 1.0e-12); } } public void init(double t0, double[] y0, double t) { } }); integ.integrate(new FirstOrderDifferentialEquations() { public void computeDerivatives(double t, double[] y, double[] dot) { dot[0] = 1.0; } public int getDimension() { return 1; } }, 0.0, new double[] { 0.0 }, 5.0, new double[1]); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ode.nonstiff; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Random; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MaxCountExceededException; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.ode.ContinuousOutputModel; import org.apache.commons.math3.ode.TestProblem3; import org.apache.commons.math3.ode.sampling.StepHandler; import org.apache.commons.math3.ode.sampling.StepInterpolatorTestUtils; import org.junit.Assert; import org.junit.Test; public class ClassicalRungeKuttaStepInterpolatorTest { @Test public void derivativesConsistency() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem3 pb = new TestProblem3(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001; ClassicalRungeKuttaIntegrator integ = new ClassicalRungeKuttaIntegrator(step); StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10); } @Test public void serialization() throws IOException, ClassNotFoundException, DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem3 pb = new TestProblem3(0.9); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003; ClassicalRungeKuttaIntegrator integ = new ClassicalRungeKuttaIntegrator(step); integ.addStepHandler(new ContinuousOutputModel()); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); for (StepHandler handler : integ.getStepHandlers()) { oos.writeObject(handler); } Assert.assertTrue(bos.size () > 880000); Assert.assertTrue(bos.size () < 900000); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); ContinuousOutputModel cm = (ContinuousOutputModel) ois.readObject(); Random random = new Random(347588535632l); double maxError = 0.0; for (int i = 0; i < 1000; ++i) { double r = random.nextDouble(); double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime(); cm.setInterpolatedTime(time); double[] interpolatedY = cm.getInterpolatedState (); double[] theoreticalY = pb.computeTheoreticalState(time); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } } Assert.assertTrue(maxError > 0.005); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ode.nonstiff; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MaxCountExceededException; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.ode.FirstOrderIntegrator; import org.apache.commons.math3.ode.TestProblem1; import org.apache.commons.math3.ode.TestProblem3; import org.apache.commons.math3.ode.TestProblem4; import org.apache.commons.math3.ode.TestProblem5; import org.apache.commons.math3.ode.TestProblemAbstract; import org.apache.commons.math3.ode.TestProblemHandler; import org.apache.commons.math3.ode.events.EventHandler; import org.apache.commons.math3.ode.sampling.StepHandler; import org.apache.commons.math3.ode.sampling.StepInterpolator; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class DormandPrince54IntegratorTest { @Test(expected=DimensionMismatchException.class) public void testDimensionCheck() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem1 pb = new TestProblem1(); DormandPrince54Integrator integrator = new DormandPrince54Integrator(0.0, 1.0, 1.0e-10, 1.0e-10); integrator.integrate(pb, 0.0, new double[pb.getDimension()+10], 1.0, new double[pb.getDimension()+10]); } @Test(expected=NumberIsTooSmallException.class) public void testMinStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem1 pb = new TestProblem1(); double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime()); double maxStep = pb.getFinalTime() - pb.getInitialTime(); double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 }; double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 }; FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.fail("an exception should have been thrown"); } @Test public void testSmallLastStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblemAbstract pb = new TestProblem5(); double minStep = 1.25; double maxStep = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()); double scalAbsoluteTolerance = 6.0e-4; double scalRelativeTolerance = 6.0e-4; AdaptiveStepsizeIntegrator integ = new DormandPrince54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); DP54SmallLastHandler handler = new DP54SmallLastHandler(minStep); integ.addStepHandler(handler); integ.setInitialStepSize(1.7); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertTrue(handler.wasLastSeen()); Assert.assertEquals("Dormand-Prince 5(4)", integ.getName()); } @Test public void testBackward() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem5 pb = new TestProblem5(); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertTrue(handler.getLastError() < 2.0e-7); Assert.assertTrue(handler.getMaximalValueError() < 2.0e-7); Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); Assert.assertEquals("Dormand-Prince 5(4)", integ.getName()); } private static class DP54SmallLastHandler implements StepHandler { public DP54SmallLastHandler(double minStep) { lastSeen = false; this.minStep = minStep; } public void init(double t0, double[] y0, double t) { } public void handleStep(StepInterpolator interpolator, boolean isLast) { if (isLast) { lastSeen = true; double h = interpolator.getCurrentTime() - interpolator.getPreviousTime(); Assert.assertTrue(FastMath.abs(h) < minStep); } } public boolean wasLastSeen() { return lastSeen; } private boolean lastSeen; private double minStep; } @Test public void testIncreasingTolerance() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { int previousCalls = Integer.MAX_VALUE; for (int i = -12; i < -2; ++i) { TestProblem1 pb = new TestProblem1(); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = FastMath.pow(10.0, i); double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; EmbeddedRungeKuttaIntegrator integ = new DormandPrince54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.setSafety(0.8); integ.setMaxGrowth(5.0); integ.setMinReduction(0.3); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertEquals(0.8, integ.getSafety(), 1.0e-12); Assert.assertEquals(5.0, integ.getMaxGrowth(), 1.0e-12); Assert.assertEquals(0.3, integ.getMinReduction(), 1.0e-12); // the 0.7 factor is only valid for this test // and has been obtained from trial and error // there is no general relation between local and global errors Assert.assertTrue(handler.getMaximalValueError() < (0.7 * scalAbsoluteTolerance)); Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); int calls = pb.getCalls(); Assert.assertEquals(integ.getEvaluations(), calls); Assert.assertTrue(calls <= previousCalls); previousCalls = calls; } } @Test public void testEvents() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem4 pb = new TestProblem4(); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); EventHandler[] functions = pb.getEventsHandlers(); double convergence = 1.0e-8 * maxStep; for (int l = 0; l < functions.length; ++l) { integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, convergence, 1000); } Assert.assertEquals(functions.length, integ.getEventHandlers().size()); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertTrue(handler.getMaximalValueError() < 5.0e-6); Assert.assertEquals(0, handler.getMaximalTimeError(), convergence); Assert.assertEquals(12.0, handler.getLastTime(), convergence); integ.clearEventHandlers(); Assert.assertEquals(0, integ.getEventHandlers().size()); } @Test public void testKepler() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { final TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = scalAbsoluteTolerance; FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); integ.addStepHandler(new KeplerHandler(pb)); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertEquals(integ.getEvaluations(), pb.getCalls()); Assert.assertTrue(pb.getCalls() < 2800); } @Test public void testVariableSteps() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { final TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = scalAbsoluteTolerance; FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); integ.addStepHandler(new VariableHandler()); double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10); } private static class KeplerHandler implements StepHandler { public KeplerHandler(TestProblem3 pb) { this.pb = pb; } public void init(double t0, double[] y0, double t) { nbSteps = 0; maxError = 0; } public void handleStep(StepInterpolator interpolator, boolean isLast) throws MaxCountExceededException { ++nbSteps; for (int a = 1; a < 10; ++a) { double prev = interpolator.getPreviousTime(); double curr = interpolator.getCurrentTime(); double interp = ((10 - a) * prev + a * curr) / 10; interpolator.setInterpolatedTime(interp); double[] interpolatedY = interpolator.getInterpolatedState (); double[] theoreticalY = pb.computeTheoreticalState(interpolator.getInterpolatedTime()); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } } if (isLast) { Assert.assertTrue(maxError < 7.0e-10); Assert.assertTrue(nbSteps < 400); } } private int nbSteps; private double maxError; private TestProblem3 pb; } private static class VariableHandler implements StepHandler { public VariableHandler() { firstTime = true; minStep = 0; maxStep = 0; } public void init(double t0, double[] y0, double t) { firstTime = true; minStep = 0; maxStep = 0; } public void handleStep(StepInterpolator interpolator, boolean isLast) { double step = FastMath.abs(interpolator.getCurrentTime() - interpolator.getPreviousTime()); if (firstTime) { minStep = FastMath.abs(step); maxStep = minStep; firstTime = false; } else { if (step < minStep) { minStep = step; } if (step > maxStep) { maxStep = step; } } if (isLast) { Assert.assertTrue(minStep < (1.0 / 450.0)); Assert.assertTrue(maxStep > (1.0 / 4.2)); } } private boolean firstTime; private double minStep; private double maxStep; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ode.nonstiff; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Random; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MaxCountExceededException; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.ode.ContinuousOutputModel; import org.apache.commons.math3.ode.TestProblem3; import org.apache.commons.math3.ode.sampling.StepHandler; import org.apache.commons.math3.ode.sampling.StepInterpolator; import org.apache.commons.math3.ode.sampling.StepInterpolatorTestUtils; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class DormandPrince54StepInterpolatorTest { @Test public void derivativesConsistency() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem3 pb = new TestProblem3(0.1); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = scalAbsoluteTolerance; DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10); } @Test public void serialization() throws IOException, ClassNotFoundException, DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = scalAbsoluteTolerance; DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); integ.addStepHandler(new ContinuousOutputModel()); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); for (StepHandler handler : integ.getStepHandlers()) { oos.writeObject(handler); } Assert.assertTrue(bos.size () > 135000); Assert.assertTrue(bos.size () < 145000); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); ContinuousOutputModel cm = (ContinuousOutputModel) ois.readObject(); Random random = new Random(347588535632l); double maxError = 0.0; for (int i = 0; i < 1000; ++i) { double r = random.nextDouble(); double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime(); cm.setInterpolatedTime(time); double[] interpolatedY = cm.getInterpolatedState (); double[] theoreticalY = pb.computeTheoreticalState(time); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } } Assert.assertTrue(maxError < 7.0e-10); } @Test public void checkClone() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = scalAbsoluteTolerance; DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); integ.addStepHandler(new StepHandler() { public void handleStep(StepInterpolator interpolator, boolean isLast) throws MaxCountExceededException { StepInterpolator cloned = interpolator.copy(); double tA = cloned.getPreviousTime(); double tB = cloned.getCurrentTime(); double halfStep = FastMath.abs(tB - tA) / 2; Assert.assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12); Assert.assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12); for (int i = 0; i < 10; ++i) { double t = (i * tB + (9 - i) * tA) / 9; interpolator.setInterpolatedTime(t); Assert.assertTrue(FastMath.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10)); cloned.setInterpolatedTime(t); Assert.assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12); double[] referenceState = interpolator.getInterpolatedState(); double[] cloneState = cloned.getInterpolatedState(); for (int j = 0; j < referenceState.length; ++j) { Assert.assertEquals(referenceState[j], cloneState[j], 1.0e-12); } } } public void init(double t0, double[] y0, double t) { } }); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ode.nonstiff; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MaxCountExceededException; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.ode.FirstOrderDifferentialEquations; import org.apache.commons.math3.ode.FirstOrderIntegrator; import org.apache.commons.math3.ode.TestProblem1; import org.apache.commons.math3.ode.TestProblem3; import org.apache.commons.math3.ode.TestProblem4; import org.apache.commons.math3.ode.TestProblem5; import org.apache.commons.math3.ode.TestProblemHandler; import org.apache.commons.math3.ode.events.EventHandler; import org.apache.commons.math3.ode.sampling.StepHandler; import org.apache.commons.math3.ode.sampling.StepInterpolator; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class DormandPrince853IntegratorTest { @Test public void testMissedEndEvent() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { final double t0 = 1878250320.0000029; final double tEvent = 1878250379.9999986; final double[] k = { 1.0e-4, 1.0e-5, 1.0e-6 }; FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations() { public int getDimension() { return k.length; } public void computeDerivatives(double t, double[] y, double[] yDot) { for (int i = 0; i < y.length; ++i) { yDot[i] = k[i] * y[i]; } } }; DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 100.0, 1.0e-10, 1.0e-10); double[] y0 = new double[k.length]; for (int i = 0; i < y0.length; ++i) { y0[i] = i + 1; } double[] y = new double[k.length]; integrator.setInitialStepSize(60.0); double finalT = integrator.integrate(ode, t0, y0, tEvent, y); Assert.assertEquals(tEvent, finalT, 5.0e-6); for (int i = 0; i < y.length; ++i) { Assert.assertEquals(y0[i] * FastMath.exp(k[i] * (finalT - t0)), y[i], 1.0e-9); } integrator.setInitialStepSize(60.0); integrator.addEventHandler(new EventHandler() { public void init(double t0, double[] y0, double t) { } public void resetState(double t, double[] y) { } public double g(double t, double[] y) { return t - tEvent; } public Action eventOccurred(double t, double[] y, boolean increasing) { Assert.assertEquals(tEvent, t, 5.0e-6); return Action.CONTINUE; } }, Double.POSITIVE_INFINITY, 1.0e-20, 100); finalT = integrator.integrate(ode, t0, y0, tEvent + 120, y); Assert.assertEquals(tEvent + 120, finalT, 5.0e-6); for (int i = 0; i < y.length; ++i) { Assert.assertEquals(y0[i] * FastMath.exp(k[i] * (finalT - t0)), y[i], 1.0e-9); } } @Test(expected=DimensionMismatchException.class) public void testDimensionCheck() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem1 pb = new TestProblem1(); DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 1.0, 1.0e-10, 1.0e-10); integrator.integrate(pb, 0.0, new double[pb.getDimension()+10], 1.0, new double[pb.getDimension()+10]); Assert.fail("an exception should have been thrown"); } @Test(expected=NumberIsTooSmallException.class) public void testNullIntervalCheck() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem1 pb = new TestProblem1(); DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 1.0, 1.0e-10, 1.0e-10); integrator.integrate(pb, 0.0, new double[pb.getDimension()], 0.0, new double[pb.getDimension()]); Assert.fail("an exception should have been thrown"); } @Test(expected=NumberIsTooSmallException.class) public void testMinStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem1 pb = new TestProblem1(); double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime()); double maxStep = pb.getFinalTime() - pb.getInitialTime(); double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 }; double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 }; FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.fail("an exception should have been thrown"); } @Test public void testIncreasingTolerance() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { int previousCalls = Integer.MAX_VALUE; AdaptiveStepsizeIntegrator integ = new DormandPrince853Integrator(0, Double.POSITIVE_INFINITY, Double.NaN, Double.NaN); for (int i = -12; i < -2; ++i) { TestProblem1 pb = new TestProblem1(); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = FastMath.pow(10.0, i); double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; integ.setStepSizeControl(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); // the 1.3 factor is only valid for this test // and has been obtained from trial and error // there is no general relation between local and global errors Assert.assertTrue(handler.getMaximalValueError() < (1.3 * scalAbsoluteTolerance)); Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); int calls = pb.getCalls(); Assert.assertEquals(integ.getEvaluations(), calls); Assert.assertTrue(calls <= previousCalls); previousCalls = calls; } } @Test public void testTooLargeFirstStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { AdaptiveStepsizeIntegrator integ = new DormandPrince853Integrator(0, Double.POSITIVE_INFINITY, Double.NaN, Double.NaN); final double start = 0.0; final double end = 0.001; FirstOrderDifferentialEquations equations = new FirstOrderDifferentialEquations() { public int getDimension() { return 1; } public void computeDerivatives(double t, double[] y, double[] yDot) { Assert.assertTrue(t >= FastMath.nextAfter(start, Double.NEGATIVE_INFINITY)); Assert.assertTrue(t <= FastMath.nextAfter(end, Double.POSITIVE_INFINITY)); yDot[0] = -100.0 * y[0]; } }; integ.setStepSizeControl(0, 1.0, 1.0e-6, 1.0e-8); integ.integrate(equations, start, new double[] { 1.0 }, end, new double[1]); } @Test public void testBackward() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem5 pb = new TestProblem5(); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertTrue(handler.getLastError() < 1.1e-7); Assert.assertTrue(handler.getMaximalValueError() < 1.1e-7); Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); Assert.assertEquals("Dormand-Prince 8 (5, 3)", integ.getName()); } @Test public void testEvents() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem4 pb = new TestProblem4(); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-9; double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); EventHandler[] functions = pb.getEventsHandlers(); double convergence = 1.0e-8 * maxStep; for (int l = 0; l < functions.length; ++l) { integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, convergence, 1000); } Assert.assertEquals(functions.length, integ.getEventHandlers().size()); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertEquals(0, handler.getMaximalValueError(), 2.1e-7); Assert.assertEquals(0, handler.getMaximalTimeError(), convergence); Assert.assertEquals(12.0, handler.getLastTime(), convergence); integ.clearEventHandlers(); Assert.assertEquals(0, integ.getEventHandlers().size()); } @Test public void testKepler() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { final TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = scalAbsoluteTolerance; FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); integ.addStepHandler(new KeplerHandler(pb)); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertEquals(integ.getEvaluations(), pb.getCalls()); Assert.assertTrue(pb.getCalls() < 3300); } @Test public void testVariableSteps() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { final TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = scalAbsoluteTolerance; FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); integ.addStepHandler(new VariableHandler()); double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10); Assert.assertEquals("Dormand-Prince 8 (5, 3)", integ.getName()); } @Test public void testUnstableDerivative() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0); FirstOrderIntegrator integ = new DormandPrince853Integrator(0.1, 10, 1.0e-12, 0.0); integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000); double[] y = { Double.NaN }; integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y); Assert.assertEquals(8.0, y[0], 1.0e-12); } @Test public void testEventsScheduling() { FirstOrderDifferentialEquations sincos = new FirstOrderDifferentialEquations() { public int getDimension() { return 2; } public void computeDerivatives(double t, double[] y, double[] yDot) { yDot[0] = y[1]; yDot[1] = -y[0]; } }; SchedulingChecker sinChecker = new SchedulingChecker(0); // events at 0, PI, 2PI ... SchedulingChecker cosChecker = new SchedulingChecker(1); // events at PI/2, 3PI/2, 5PI/2 ... FirstOrderIntegrator integ = new DormandPrince853Integrator(0.001, 1.0, 1.0e-12, 0.0); integ.addEventHandler(sinChecker, 0.01, 1.0e-7, 100); integ.addStepHandler(sinChecker); integ.addEventHandler(cosChecker, 0.01, 1.0e-7, 100); integ.addStepHandler(cosChecker); double t0 = 0.5; double[] y0 = new double[] { FastMath.sin(t0), FastMath.cos(t0) }; double t = 10.0; double[] y = new double[2]; integ.integrate(sincos, t0, y0, t, y); } private static class SchedulingChecker implements StepHandler, EventHandler { int index; double tMin; public SchedulingChecker(int index) { this.index = index; } public void init(double t0, double[] y0, double t) { tMin = t0; } public void handleStep(StepInterpolator interpolator, boolean isLast) { tMin = interpolator.getCurrentTime(); } public double g(double t, double[] y) { // once a step has been handled by handleStep, // events checking should only refer to dates after the step Assert.assertTrue(t >= tMin); return y[index]; } public Action eventOccurred(double t, double[] y, boolean increasing) { return Action.RESET_STATE; } public void resetState(double t, double[] y) { // in fact, we don't need to reset anything for the test } } private static class KeplerHandler implements StepHandler { public KeplerHandler(TestProblem3 pb) { this.pb = pb; } public void init(double t0, double[] y0, double t) { nbSteps = 0; maxError = 0; } public void handleStep(StepInterpolator interpolator, boolean isLast) throws MaxCountExceededException { ++nbSteps; for (int a = 1; a < 10; ++a) { double prev = interpolator.getPreviousTime(); double curr = interpolator.getCurrentTime(); double interp = ((10 - a) * prev + a * curr) / 10; interpolator.setInterpolatedTime(interp); double[] interpolatedY = interpolator.getInterpolatedState (); double[] theoreticalY = pb.computeTheoreticalState(interpolator.getInterpolatedTime()); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } } if (isLast) { Assert.assertTrue(maxError < 2.4e-10); Assert.assertTrue(nbSteps < 150); } } private int nbSteps; private double maxError; private TestProblem3 pb; } private static class VariableHandler implements StepHandler { public VariableHandler() { firstTime = true; minStep = 0; maxStep = 0; } public void init(double t0, double[] y0, double t) { firstTime = true; minStep = 0; maxStep = 0; } public void handleStep(StepInterpolator interpolator, boolean isLast) { double step = FastMath.abs(interpolator.getCurrentTime() - interpolator.getPreviousTime()); if (firstTime) { minStep = FastMath.abs(step); maxStep = minStep; firstTime = false; } else { if (step < minStep) { minStep = step; } if (step > maxStep) { maxStep = step; } } if (isLast) { Assert.assertTrue(minStep < (1.0 / 100.0)); Assert.assertTrue(maxStep > (1.0 / 2.0)); } } private boolean firstTime = true; private double minStep = 0; private double maxStep = 0; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ode.nonstiff; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Random; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MaxCountExceededException; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.ode.ContinuousOutputModel; import org.apache.commons.math3.ode.TestProblem3; import org.apache.commons.math3.ode.sampling.StepHandler; import org.apache.commons.math3.ode.sampling.StepInterpolator; import org.apache.commons.math3.ode.sampling.StepInterpolatorTestUtils; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class DormandPrince853StepInterpolatorTest { @Test public void derivativesConsistency() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem3 pb = new TestProblem3(0.1); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = scalAbsoluteTolerance; DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10); } @Test public void serialization() throws IOException, ClassNotFoundException, DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = scalAbsoluteTolerance; DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); integ.addStepHandler(new ContinuousOutputModel()); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); for (StepHandler handler : integ.getStepHandlers()) { oos.writeObject(handler); } Assert.assertTrue(bos.size () > 90000); Assert.assertTrue(bos.size () < 100000); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); ContinuousOutputModel cm = (ContinuousOutputModel) ois.readObject(); Random random = new Random(347588535632l); double maxError = 0.0; for (int i = 0; i < 1000; ++i) { double r = random.nextDouble(); double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime(); cm.setInterpolatedTime(time); double[] interpolatedY = cm.getInterpolatedState (); double[] theoreticalY = pb.computeTheoreticalState(time); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } } Assert.assertTrue(maxError < 2.4e-10); } @Test public void checklone() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = scalAbsoluteTolerance; DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); integ.addStepHandler(new StepHandler() { public void handleStep(StepInterpolator interpolator, boolean isLast) throws MaxCountExceededException { StepInterpolator cloned = interpolator.copy(); double tA = cloned.getPreviousTime(); double tB = cloned.getCurrentTime(); double halfStep = FastMath.abs(tB - tA) / 2; Assert.assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12); Assert.assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12); for (int i = 0; i < 10; ++i) { double t = (i * tB + (9 - i) * tA) / 9; interpolator.setInterpolatedTime(t); Assert.assertTrue(FastMath.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10)); cloned.setInterpolatedTime(t); Assert.assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12); double[] referenceState = interpolator.getInterpolatedState(); double[] cloneState = cloned.getInterpolatedState(); for (int j = 0; j < referenceState.length; ++j) { Assert.assertEquals(referenceState[j], cloneState[j], 1.0e-12); } } } public void init(double t0, double[] y0, double t) { } }); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ode.nonstiff; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MaxCountExceededException; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.ode.FirstOrderDifferentialEquations; import org.apache.commons.math3.ode.FirstOrderIntegrator; import org.apache.commons.math3.ode.TestProblem1; import org.apache.commons.math3.ode.TestProblem5; import org.apache.commons.math3.ode.TestProblemAbstract; import org.apache.commons.math3.ode.TestProblemFactory; import org.apache.commons.math3.ode.TestProblemHandler; import org.apache.commons.math3.ode.events.EventHandler; import org.apache.commons.math3.ode.sampling.StepHandler; import org.apache.commons.math3.ode.sampling.StepInterpolator; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class EulerIntegratorTest { @Test(expected=DimensionMismatchException.class) public void testDimensionCheck() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem1 pb = new TestProblem1(); new EulerIntegrator(0.01).integrate(pb, 0.0, new double[pb.getDimension()+10], 1.0, new double[pb.getDimension()+10]); Assert.fail("an exception should have been thrown"); } @Test public void testDecreasingSteps() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblemAbstract[] problems = TestProblemFactory.getProblems(); for (int k = 0; k < problems.length; ++k) { double previousValueError = Double.NaN; double previousTimeError = Double.NaN; for (int i = 4; i < 8; ++i) { TestProblemAbstract pb = problems[k].copy(); double step = (pb.getFinalTime() - pb.getInitialTime()) * FastMath.pow(2.0, -i); FirstOrderIntegrator integ = new EulerIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); EventHandler[] functions = pb.getEventsHandlers(); for (int l = 0; l < functions.length; ++l) { integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000); } double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); if (functions.length == 0) { Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10); } double valueError = handler.getMaximalValueError(); if (i > 4) { Assert.assertTrue(valueError < FastMath.abs(previousValueError)); } previousValueError = valueError; double timeError = handler.getMaximalTimeError(); if (i > 4) { Assert.assertTrue(timeError <= FastMath.abs(previousTimeError)); } previousTimeError = timeError; } } } @Test public void testSmallStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem1 pb = new TestProblem1(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001; FirstOrderIntegrator integ = new EulerIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertTrue(handler.getLastError() < 2.0e-4); Assert.assertTrue(handler.getMaximalValueError() < 1.0e-3); Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); Assert.assertEquals("Euler", integ.getName()); } @Test public void testBigStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem1 pb = new TestProblem1(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2; FirstOrderIntegrator integ = new EulerIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertTrue(handler.getLastError() > 0.01); Assert.assertTrue(handler.getMaximalValueError() > 0.2); Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); } @Test public void testBackward() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem5 pb = new TestProblem5(); double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001; FirstOrderIntegrator integ = new EulerIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertTrue(handler.getLastError() < 0.45); Assert.assertTrue(handler.getMaximalValueError() < 0.45); Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); Assert.assertEquals("Euler", integ.getName()); } @Test public void testStepSize() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { final double step = 1.23456; FirstOrderIntegrator integ = new EulerIntegrator(step); integ.addStepHandler(new StepHandler() { public void handleStep(StepInterpolator interpolator, boolean isLast) { if (! isLast) { Assert.assertEquals(step, interpolator.getCurrentTime() - interpolator.getPreviousTime(), 1.0e-12); } } public void init(double t0, double[] y0, double t) { } }); integ.integrate(new FirstOrderDifferentialEquations() { public void computeDerivatives(double t, double[] y, double[] dot) { dot[0] = 1.0; } public int getDimension() { return 1; } }, 0.0, new double[] { 0.0 }, 5.0, new double[1]); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ode.nonstiff; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Random; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MaxCountExceededException; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.ode.ContinuousOutputModel; import org.apache.commons.math3.ode.EquationsMapper; import org.apache.commons.math3.ode.TestProblem1; import org.apache.commons.math3.ode.TestProblem3; import org.apache.commons.math3.ode.sampling.StepHandler; import org.apache.commons.math3.ode.sampling.StepInterpolatorTestUtils; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class EulerStepInterpolatorTest { @Test public void noReset() throws MaxCountExceededException { double[] y = { 0.0, 1.0, -2.0 }; double[][] yDot = { { 1.0, 2.0, -2.0 } }; EulerStepInterpolator interpolator = new EulerStepInterpolator(); interpolator.reinitialize(new DummyIntegrator(interpolator), y, yDot, true, new EquationsMapper(0, y.length), new EquationsMapper[0]); interpolator.storeTime(0); interpolator.shift(); interpolator.storeTime(1); double[] result = interpolator.getInterpolatedState(); for (int i = 0; i < result.length; ++i) { Assert.assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10); } } @Test public void interpolationAtBounds() throws MaxCountExceededException { double t0 = 0; double[] y0 = {0.0, 1.0, -2.0}; double[] y = y0.clone(); double[][] yDot = { new double[y0.length] }; EulerStepInterpolator interpolator = new EulerStepInterpolator(); interpolator.reinitialize(new DummyIntegrator(interpolator), y, yDot, true, new EquationsMapper(0, y.length), new EquationsMapper[0]); interpolator.storeTime(t0); double dt = 1.0; interpolator.shift(); y[0] = 1.0; y[1] = 3.0; y[2] = -4.0; yDot[0][0] = (y[0] - y0[0]) / dt; yDot[0][1] = (y[1] - y0[1]) / dt; yDot[0][2] = (y[2] - y0[2]) / dt; interpolator.storeTime(t0 + dt); interpolator.setInterpolatedTime(interpolator.getPreviousTime()); double[] result = interpolator.getInterpolatedState(); for (int i = 0; i < result.length; ++i) { Assert.assertTrue(FastMath.abs(result[i] - y0[i]) < 1.0e-10); } interpolator.setInterpolatedTime(interpolator.getCurrentTime()); result = interpolator.getInterpolatedState(); for (int i = 0; i < result.length; ++i) { Assert.assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10); } } @Test public void interpolationInside() throws MaxCountExceededException { double[] y = { 0.0, 1.0, -2.0 }; double[][] yDot = { { 1.0, 2.0, -2.0 } }; EulerStepInterpolator interpolator = new EulerStepInterpolator(); interpolator.reinitialize(new DummyIntegrator(interpolator), y, yDot, true, new EquationsMapper(0, y.length), new EquationsMapper[0]); interpolator.storeTime(0); interpolator.shift(); y[0] = 1.0; y[1] = 3.0; y[2] = -4.0; interpolator.storeTime(1); interpolator.setInterpolatedTime(0.1); double[] result = interpolator.getInterpolatedState(); Assert.assertTrue(FastMath.abs(result[0] - 0.1) < 1.0e-10); Assert.assertTrue(FastMath.abs(result[1] - 1.2) < 1.0e-10); Assert.assertTrue(FastMath.abs(result[2] + 2.2) < 1.0e-10); interpolator.setInterpolatedTime(0.5); result = interpolator.getInterpolatedState(); Assert.assertTrue(FastMath.abs(result[0] - 0.5) < 1.0e-10); Assert.assertTrue(FastMath.abs(result[1] - 2.0) < 1.0e-10); Assert.assertTrue(FastMath.abs(result[2] + 3.0) < 1.0e-10); } @Test public void derivativesConsistency() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem3 pb = new TestProblem3(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001; EulerIntegrator integ = new EulerIntegrator(step); StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10); } @Test public void serialization() throws IOException, ClassNotFoundException, DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem1 pb = new TestProblem1(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001; EulerIntegrator integ = new EulerIntegrator(step); integ.addStepHandler(new ContinuousOutputModel()); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); for (StepHandler handler : integ.getStepHandlers()) { oos.writeObject(handler); } ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); ContinuousOutputModel cm = (ContinuousOutputModel) ois.readObject(); Random random = new Random(347588535632l); double maxError = 0.0; for (int i = 0; i < 1000; ++i) { double r = random.nextDouble(); double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime(); cm.setInterpolatedTime(time); double[] interpolatedY = cm.getInterpolatedState (); double[] theoreticalY = pb.computeTheoreticalState(time); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } } Assert.assertTrue(maxError < 0.001); } private static class DummyIntegrator extends RungeKuttaIntegrator { protected DummyIntegrator(RungeKuttaStepInterpolator prototype) { super("dummy", new double[0], new double[0][0], new double[0], prototype, Double.NaN); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ode.nonstiff; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MaxCountExceededException; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.ode.FirstOrderDifferentialEquations; import org.apache.commons.math3.ode.FirstOrderIntegrator; import org.apache.commons.math3.ode.TestProblem1; import org.apache.commons.math3.ode.TestProblem3; import org.apache.commons.math3.ode.TestProblem5; import org.apache.commons.math3.ode.TestProblemAbstract; import org.apache.commons.math3.ode.TestProblemFactory; import org.apache.commons.math3.ode.TestProblemHandler; import org.apache.commons.math3.ode.events.EventHandler; import org.apache.commons.math3.ode.sampling.StepHandler; import org.apache.commons.math3.ode.sampling.StepInterpolator; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class GillIntegratorTest { @Test(expected=DimensionMismatchException.class) public void testDimensionCheck() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem1 pb = new TestProblem1(); new GillIntegrator(0.01).integrate(pb, 0.0, new double[pb.getDimension()+10], 1.0, new double[pb.getDimension()+10]); Assert.fail("an exception should have been thrown"); } @Test public void testDecreasingSteps() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblemAbstract[] problems = TestProblemFactory.getProblems(); for (int k = 0; k < problems.length; ++k) { double previousValueError = Double.NaN; double previousTimeError = Double.NaN; for (int i = 5; i < 10; ++i) { TestProblemAbstract pb = problems[k].copy(); double step = (pb.getFinalTime() - pb.getInitialTime()) * FastMath.pow(2.0, -i); FirstOrderIntegrator integ = new GillIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); EventHandler[] functions = pb.getEventsHandlers(); for (int l = 0; l < functions.length; ++l) { integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000); } double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); if (functions.length == 0) { Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10); } double valueError = handler.getMaximalValueError(); if (i > 5) { Assert.assertTrue(valueError < 1.01 * FastMath.abs(previousValueError)); } previousValueError = valueError; double timeError = handler.getMaximalTimeError(); if (i > 5) { Assert.assertTrue(timeError <= FastMath.abs(previousTimeError)); } previousTimeError = timeError; } } } @Test public void testSmallStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem1 pb = new TestProblem1(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001; FirstOrderIntegrator integ = new GillIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertTrue(handler.getLastError() < 2.0e-13); Assert.assertTrue(handler.getMaximalValueError() < 4.0e-12); Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); Assert.assertEquals("Gill", integ.getName()); } @Test public void testBigStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem1 pb = new TestProblem1(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2; FirstOrderIntegrator integ = new GillIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertTrue(handler.getLastError() > 0.0004); Assert.assertTrue(handler.getMaximalValueError() > 0.005); Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); } @Test public void testBackward() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem5 pb = new TestProblem5(); double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001; FirstOrderIntegrator integ = new GillIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertTrue(handler.getLastError() < 5.0e-10); Assert.assertTrue(handler.getMaximalValueError() < 7.0e-10); Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); Assert.assertEquals("Gill", integ.getName()); } @Test public void testKepler() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { final TestProblem3 pb = new TestProblem3(0.9); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003; FirstOrderIntegrator integ = new GillIntegrator(step); integ.addStepHandler(new KeplerStepHandler(pb)); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); } @Test public void testUnstableDerivative() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0); FirstOrderIntegrator integ = new GillIntegrator(0.3); integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000); double[] y = { Double.NaN }; integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y); Assert.assertEquals(8.0, y[0], 1.0e-12); } private static class KeplerStepHandler implements StepHandler { public KeplerStepHandler(TestProblem3 pb) { this.pb = pb; } public void init(double t0, double[] y0, double t) { maxError = 0; } public void handleStep(StepInterpolator interpolator, boolean isLast) throws MaxCountExceededException { double[] interpolatedY = interpolator.getInterpolatedState(); double[] theoreticalY = pb.computeTheoreticalState(interpolator.getCurrentTime()); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } if (isLast) { // even with more than 1000 evaluations per period, // RK4 is not able to integrate such an eccentric // orbit with a good accuracy Assert.assertTrue(maxError > 0.001); } } private double maxError; private TestProblem3 pb; } @Test public void testStepSize() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { final double step = 1.23456; FirstOrderIntegrator integ = new GillIntegrator(step); integ.addStepHandler(new StepHandler() { public void handleStep(StepInterpolator interpolator, boolean isLast) { if (! isLast) { Assert.assertEquals(step, interpolator.getCurrentTime() - interpolator.getPreviousTime(), 1.0e-12); } } public void init(double t0, double[] y0, double t) { } }); integ.integrate(new FirstOrderDifferentialEquations() { public void computeDerivatives(double t, double[] y, double[] dot) { dot[0] = 1.0; } public int getDimension() { return 1; } }, 0.0, new double[] { 0.0 }, 5.0, new double[1]); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ode.nonstiff; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Random; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MaxCountExceededException; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.ode.ContinuousOutputModel; import org.apache.commons.math3.ode.TestProblem3; import org.apache.commons.math3.ode.sampling.StepHandler; import org.apache.commons.math3.ode.sampling.StepInterpolatorTestUtils; import org.junit.Assert; import org.junit.Test; public class GillStepInterpolatorTest { @Test public void testDerivativesConsistency() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem3 pb = new TestProblem3(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001; GillIntegrator integ = new GillIntegrator(step); StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10); } @Test public void serialization() throws IOException, ClassNotFoundException, DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem3 pb = new TestProblem3(0.9); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003; GillIntegrator integ = new GillIntegrator(step); integ.addStepHandler(new ContinuousOutputModel()); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); for (StepHandler handler : integ.getStepHandlers()) { oos.writeObject(handler); } Assert.assertTrue(bos.size () > 880000); Assert.assertTrue(bos.size () < 900000); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); ContinuousOutputModel cm = (ContinuousOutputModel) ois.readObject(); Random random = new Random(347588535632l); double maxError = 0.0; for (int i = 0; i < 1000; ++i) { double r = random.nextDouble(); double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime(); cm.setInterpolatedTime(time); double[] interpolatedY = cm.getInterpolatedState (); double[] theoreticalY = pb.computeTheoreticalState(time); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } } Assert.assertTrue(maxError < 0.003); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ode.nonstiff; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MaxCountExceededException; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.ode.FirstOrderDifferentialEquations; import org.apache.commons.math3.ode.FirstOrderIntegrator; import org.apache.commons.math3.ode.TestProblem1; import org.apache.commons.math3.ode.TestProblem3; import org.apache.commons.math3.ode.TestProblem4; import org.apache.commons.math3.ode.TestProblem5; import org.apache.commons.math3.ode.TestProblemAbstract; import org.apache.commons.math3.ode.TestProblemHandler; import org.apache.commons.math3.ode.events.EventHandler; import org.apache.commons.math3.ode.sampling.StepHandler; import org.apache.commons.math3.ode.sampling.StepInterpolator; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class GraggBulirschStoerIntegratorTest { @Test(expected=DimensionMismatchException.class) public void testDimensionCheck() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem1 pb = new TestProblem1(); AdaptiveStepsizeIntegrator integrator = new GraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10); integrator.integrate(pb, 0.0, new double[pb.getDimension()+10], 1.0, new double[pb.getDimension()+10]); } @Test(expected=NumberIsTooSmallException.class) public void testNullIntervalCheck() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem1 pb = new TestProblem1(); GraggBulirschStoerIntegrator integrator = new GraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10); integrator.integrate(pb, 0.0, new double[pb.getDimension()], 0.0, new double[pb.getDimension()]); } @Test(expected=NumberIsTooSmallException.class) public void testMinStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem5 pb = new TestProblem5(); double minStep = 0.1 * FastMath.abs(pb.getFinalTime() - pb.getInitialTime()); double maxStep = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()); double[] vecAbsoluteTolerance = { 1.0e-20, 1.0e-21 }; double[] vecRelativeTolerance = { 1.0e-20, 1.0e-21 }; FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); } @Test public void testBackward() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem5 pb = new TestProblem5(); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertTrue(handler.getLastError() < 7.5e-9); Assert.assertTrue(handler.getMaximalValueError() < 8.1e-9); Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); Assert.assertEquals("Gragg-Bulirsch-Stoer", integ.getName()); } @Test public void testIncreasingTolerance() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { int previousCalls = Integer.MAX_VALUE; for (int i = -12; i < -4; ++i) { TestProblem1 pb = new TestProblem1(); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double absTolerance = FastMath.pow(10.0, i); double relTolerance = absTolerance; FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep, absTolerance, relTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); // the coefficients are only valid for this test // and have been obtained from trial and error // there is no general relation between local and global errors double ratio = handler.getMaximalValueError() / absTolerance; Assert.assertTrue(ratio < 2.4); Assert.assertTrue(ratio > 0.02); Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); int calls = pb.getCalls(); Assert.assertEquals(integ.getEvaluations(), calls); Assert.assertTrue(calls <= previousCalls); previousCalls = calls; } } @Test public void testIntegratorControls() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem3 pb = new TestProblem3(0.999); GraggBulirschStoerIntegrator integ = new GraggBulirschStoerIntegrator(0, pb.getFinalTime() - pb.getInitialTime(), 1.0e-8, 1.0e-10); double errorWithDefaultSettings = getMaxError(integ, pb); // stability control integ.setStabilityCheck(true, 2, 1, 0.99); Assert.assertTrue(errorWithDefaultSettings < getMaxError(integ, pb)); integ.setStabilityCheck(true, -1, -1, -1); integ.setControlFactors(0.5, 0.99, 0.1, 2.5); Assert.assertTrue(errorWithDefaultSettings < getMaxError(integ, pb)); integ.setControlFactors(-1, -1, -1, -1); integ.setOrderControl(10, 0.7, 0.95); Assert.assertTrue(errorWithDefaultSettings < getMaxError(integ, pb)); integ.setOrderControl(-1, -1, -1); integ.setInterpolationControl(true, 3); Assert.assertTrue(errorWithDefaultSettings < getMaxError(integ, pb)); integ.setInterpolationControl(true, -1); } private double getMaxError(FirstOrderIntegrator integrator, TestProblemAbstract pb) throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblemHandler handler = new TestProblemHandler(pb, integrator); integrator.addStepHandler(handler); integrator.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); return handler.getMaximalValueError(); } @Test public void testEvents() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem4 pb = new TestProblem4(); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-10; double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); EventHandler[] functions = pb.getEventsHandlers(); double convergence = 1.0e-8 * maxStep; for (int l = 0; l < functions.length; ++l) { integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, convergence, 1000); } Assert.assertEquals(functions.length, integ.getEventHandlers().size()); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertTrue(handler.getMaximalValueError() < 4.0e-7); Assert.assertEquals(0, handler.getMaximalTimeError(), convergence); Assert.assertEquals(12.0, handler.getLastTime(), convergence); integ.clearEventHandlers(); Assert.assertEquals(0, integ.getEventHandlers().size()); } @Test public void testKepler() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { final TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double absTolerance = 1.0e-6; double relTolerance = 1.0e-6; FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep, absTolerance, relTolerance); integ.addStepHandler(new KeplerStepHandler(pb)); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertEquals(integ.getEvaluations(), pb.getCalls()); Assert.assertTrue(pb.getCalls() < 2150); } @Test public void testVariableSteps() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { final TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double absTolerance = 1.0e-8; double relTolerance = 1.0e-8; FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep, absTolerance, relTolerance); integ.addStepHandler(new VariableStepHandler()); double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10); Assert.assertEquals("Gragg-Bulirsch-Stoer", integ.getName()); } @Test public void testTooLargeFirstStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { AdaptiveStepsizeIntegrator integ = new GraggBulirschStoerIntegrator(0, Double.POSITIVE_INFINITY, Double.NaN, Double.NaN); final double start = 0.0; final double end = 0.001; FirstOrderDifferentialEquations equations = new FirstOrderDifferentialEquations() { public int getDimension() { return 1; } public void computeDerivatives(double t, double[] y, double[] yDot) { Assert.assertTrue(t >= FastMath.nextAfter(start, Double.NEGATIVE_INFINITY)); Assert.assertTrue(t <= FastMath.nextAfter(end, Double.POSITIVE_INFINITY)); yDot[0] = -100.0 * y[0]; } }; integ.setStepSizeControl(0, 1.0, 1.0e-6, 1.0e-8); integ.integrate(equations, start, new double[] { 1.0 }, end, new double[1]); } @Test public void testUnstableDerivative() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0); FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(0.1, 10, 1.0e-12, 0.0); integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000); double[] y = { Double.NaN }; integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y); Assert.assertEquals(8.0, y[0], 1.0e-12); } @Test public void testIssue596() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(1e-10, 100.0, 1e-7, 1e-7); integ.addStepHandler(new StepHandler() { public void init(double t0, double[] y0, double t) { } public void handleStep(StepInterpolator interpolator, boolean isLast) throws MaxCountExceededException { double t = interpolator.getCurrentTime(); interpolator.setInterpolatedTime(t); double[] y = interpolator.getInterpolatedState(); double[] yDot = interpolator.getInterpolatedDerivatives(); Assert.assertEquals(3.0 * t - 5.0, y[0], 1.0e-14); Assert.assertEquals(3.0, yDot[0], 1.0e-14); } }); double[] y = {4.0}; double t0 = 3.0; double tend = 10.0; integ.integrate(new FirstOrderDifferentialEquations() { public int getDimension() { return 1; } public void computeDerivatives(double t, double[] y, double[] yDot) { yDot[0] = 3.0; } }, t0, y, tend, y); } private static class KeplerStepHandler implements StepHandler { public KeplerStepHandler(TestProblem3 pb) { this.pb = pb; } public void init(double t0, double[] y0, double t) { nbSteps = 0; maxError = 0; } public void handleStep(StepInterpolator interpolator, boolean isLast) throws MaxCountExceededException { ++nbSteps; for (int a = 1; a < 100; ++a) { double prev = interpolator.getPreviousTime(); double curr = interpolator.getCurrentTime(); double interp = ((100 - a) * prev + a * curr) / 100; interpolator.setInterpolatedTime(interp); double[] interpolatedY = interpolator.getInterpolatedState (); double[] theoreticalY = pb.computeTheoreticalState(interpolator.getInterpolatedTime()); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } } if (isLast) { Assert.assertTrue(maxError < 2.7e-6); Assert.assertTrue(nbSteps < 80); } } private int nbSteps; private double maxError; private TestProblem3 pb; } public static class VariableStepHandler implements StepHandler { public VariableStepHandler() { firstTime = true; minStep = 0; maxStep = 0; } public void init(double t0, double[] y0, double t) { firstTime = true; minStep = 0; maxStep = 0; } public void handleStep(StepInterpolator interpolator, boolean isLast) { double step = FastMath.abs(interpolator.getCurrentTime() - interpolator.getPreviousTime()); if (firstTime) { minStep = FastMath.abs(step); maxStep = minStep; firstTime = false; } else { if (step < minStep) { minStep = step; } if (step > maxStep) { maxStep = step; } } if (isLast) { Assert.assertTrue(minStep < 8.2e-3); Assert.assertTrue(maxStep > 1.5); } } private boolean firstTime; private double minStep; private double maxStep; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ode.nonstiff; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Random; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MaxCountExceededException; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.ode.ContinuousOutputModel; import org.apache.commons.math3.ode.TestProblem3; import org.apache.commons.math3.ode.sampling.StepHandler; import org.apache.commons.math3.ode.sampling.StepInterpolator; import org.apache.commons.math3.ode.sampling.StepInterpolatorTestUtils; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class GraggBulirschStoerStepInterpolatorTest { @Test public void derivativesConsistency() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double absTolerance = 1.0e-8; double relTolerance = 1.0e-8; GraggBulirschStoerIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep, absTolerance, relTolerance); StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-8); } @Test public void serialization() throws IOException, ClassNotFoundException, DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double absTolerance = 1.0e-8; double relTolerance = 1.0e-8; GraggBulirschStoerIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep, absTolerance, relTolerance); integ.addStepHandler(new ContinuousOutputModel()); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); for (StepHandler handler : integ.getStepHandlers()) { oos.writeObject(handler); } Assert.assertTrue(bos.size () > 35000); Assert.assertTrue(bos.size () < 36000); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); ContinuousOutputModel cm = (ContinuousOutputModel) ois.readObject(); Random random = new Random(347588535632l); double maxError = 0.0; for (int i = 0; i < 1000; ++i) { double r = random.nextDouble(); double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime(); cm.setInterpolatedTime(time); double[] interpolatedY = cm.getInterpolatedState (); double[] theoreticalY = pb.computeTheoreticalState(time); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } } Assert.assertTrue(maxError < 5.0e-10); } @Test public void checklone() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = scalAbsoluteTolerance; GraggBulirschStoerIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); integ.addStepHandler(new StepHandler() { public void handleStep(StepInterpolator interpolator, boolean isLast) throws MaxCountExceededException { StepInterpolator cloned = interpolator.copy(); double tA = cloned.getPreviousTime(); double tB = cloned.getCurrentTime(); double halfStep = FastMath.abs(tB - tA) / 2; Assert.assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12); Assert.assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12); for (int i = 0; i < 10; ++i) { double t = (i * tB + (9 - i) * tA) / 9; interpolator.setInterpolatedTime(t); Assert.assertTrue(FastMath.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10)); cloned.setInterpolatedTime(t); Assert.assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12); double[] referenceState = interpolator.getInterpolatedState(); double[] cloneState = cloned.getInterpolatedState(); for (int j = 0; j < referenceState.length; ++j) { Assert.assertEquals(referenceState[j], cloneState[j], 1.0e-12); } } } public void init(double t0, double[] y0, double t) { } }); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ode.nonstiff; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MaxCountExceededException; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.exception.TooManyEvaluationsException; import org.apache.commons.math3.ode.FirstOrderDifferentialEquations; import org.apache.commons.math3.ode.FirstOrderIntegrator; import org.apache.commons.math3.ode.TestProblem1; import org.apache.commons.math3.ode.TestProblem3; import org.apache.commons.math3.ode.TestProblem4; import org.apache.commons.math3.ode.TestProblem5; import org.apache.commons.math3.ode.TestProblemHandler; import org.apache.commons.math3.ode.events.EventHandler; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class HighamHall54IntegratorTest { @Test public void testWrongDerivative() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { HighamHall54Integrator integrator = new HighamHall54Integrator(0.0, 1.0, 1.0e-10, 1.0e-10); FirstOrderDifferentialEquations equations = new FirstOrderDifferentialEquations() { public void computeDerivatives(double t, double[] y, double[] dot) { if (t < -0.5) { throw new LocalException(); } else { throw new RuntimeException("oops"); } } public int getDimension() { return 1; } }; try { integrator.integrate(equations, -1.0, new double[1], 0.0, new double[1]); Assert.fail("an exception should have been thrown"); } catch(LocalException de) { // expected behavior } try { integrator.integrate(equations, 0.0, new double[1], 1.0, new double[1]); Assert.fail("an exception should have been thrown"); } catch(RuntimeException de) { // expected behavior } } @Test(expected=NumberIsTooSmallException.class) public void testMinStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem1 pb = new TestProblem1(); double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime()); double maxStep = pb.getFinalTime() - pb.getInitialTime(); double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 }; double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 }; FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.fail("an exception should have been thrown"); } @Test public void testIncreasingTolerance() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { int previousCalls = Integer.MAX_VALUE; for (int i = -12; i < -2; ++i) { TestProblem1 pb = new TestProblem1(); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = FastMath.pow(10.0, i); double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); // the 1.3 factor is only valid for this test // and has been obtained from trial and error // there is no general relation between local and global errors Assert.assertTrue(handler.getMaximalValueError() < (1.3 * scalAbsoluteTolerance)); Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); int calls = pb.getCalls(); Assert.assertEquals(integ.getEvaluations(), calls); Assert.assertTrue(calls <= previousCalls); previousCalls = calls; } } @Test public void testBackward() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem5 pb = new TestProblem5(); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertTrue(handler.getLastError() < 5.0e-7); Assert.assertTrue(handler.getMaximalValueError() < 5.0e-7); Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); Assert.assertEquals("Higham-Hall 5(4)", integ.getName()); } @Test public void testEvents() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem4 pb = new TestProblem4(); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); EventHandler[] functions = pb.getEventsHandlers(); double convergence = 1.0e-8 * maxStep; for (int l = 0; l < functions.length; ++l) { integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, convergence, 1000); } Assert.assertEquals(functions.length, integ.getEventHandlers().size()); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertTrue(handler.getMaximalValueError() < 1.0e-7); Assert.assertEquals(0, handler.getMaximalTimeError(), convergence); Assert.assertEquals(12.0, handler.getLastTime(), convergence); integ.clearEventHandlers(); Assert.assertEquals(0, integ.getEventHandlers().size()); } @Test(expected=LocalException.class) public void testEventsErrors() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { final TestProblem1 pb = new TestProblem1(); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.addEventHandler(new EventHandler() { public void init(double t0, double[] y0, double t) { } public Action eventOccurred(double t, double[] y, boolean increasing) { return Action.CONTINUE; } public double g(double t, double[] y) { double middle = (pb.getInitialTime() + pb.getFinalTime()) / 2; double offset = t - middle; if (offset > 0) { throw new LocalException(); } return offset; } public void resetState(double t, double[] y) { } }, Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); } private static class LocalException extends RuntimeException { private static final long serialVersionUID = 3041292643919807960L; } @Test public void testEventsNoConvergence() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { final TestProblem1 pb = new TestProblem1(); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.addEventHandler(new EventHandler() { public void init(double t0, double[] y0, double t) { } public Action eventOccurred(double t, double[] y, boolean increasing) { return Action.CONTINUE; } public double g(double t, double[] y) { double middle = (pb.getInitialTime() + pb.getFinalTime()) / 2; double offset = t - middle; return (offset > 0) ? (offset + 0.5) : (offset - 0.5); } public void resetState(double t, double[] y) { } }, Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 3); try { integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.fail("an exception should have been thrown"); } catch (TooManyEvaluationsException tmee) { // Expected. } } @Test public void testSanityChecks() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { final TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); try { FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, new double[4], new double[4]); integ.integrate(pb, pb.getInitialTime(), new double[6], pb.getFinalTime(), new double[pb.getDimension()]); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException ie) { // expected behavior } try { FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, new double[4], new double[4]); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[6]); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException ie) { // expected behavior } try { FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, new double[2], new double[4]); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException ie) { // expected behavior } try { FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, new double[4], new double[2]); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException ie) { // expected behavior } try { FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, new double[4], new double[4]); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getInitialTime(), new double[pb.getDimension()]); Assert.fail("an exception should have been thrown"); } catch (NumberIsTooSmallException ie) { // expected behavior } } @Test public void testKepler() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { final TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double[] vecAbsoluteTolerance = { 1.0e-8, 1.0e-8, 1.0e-10, 1.0e-10 }; double[] vecRelativeTolerance = { 1.0e-10, 1.0e-10, 1.0e-8, 1.0e-8 }; FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertEquals(0.0, handler.getMaximalValueError(), 1.5e-4); Assert.assertEquals("Higham-Hall 5(4)", integ.getName()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ode.nonstiff; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Random; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MaxCountExceededException; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.ode.ContinuousOutputModel; import org.apache.commons.math3.ode.TestProblem3; import org.apache.commons.math3.ode.sampling.StepHandler; import org.apache.commons.math3.ode.sampling.StepInterpolator; import org.apache.commons.math3.ode.sampling.StepInterpolatorTestUtils; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class HighamHall54StepInterpolatorTest { @Test public void derivativesConsistency() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem3 pb = new TestProblem3(0.1); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = scalAbsoluteTolerance; HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.1e-10); } @Test public void serialization() throws IOException, ClassNotFoundException, DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = scalAbsoluteTolerance; HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); integ.addStepHandler(new ContinuousOutputModel()); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); for (StepHandler handler : integ.getStepHandlers()) { oos.writeObject(handler); } Assert.assertTrue(bos.size () > 185000); Assert.assertTrue(bos.size () < 195000); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); ContinuousOutputModel cm = (ContinuousOutputModel) ois.readObject(); Random random = new Random(347588535632l); double maxError = 0.0; for (int i = 0; i < 1000; ++i) { double r = random.nextDouble(); double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime(); cm.setInterpolatedTime(time); double[] interpolatedY = cm.getInterpolatedState (); double[] theoreticalY = pb.computeTheoreticalState(time); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } } Assert.assertTrue(maxError < 1.6e-10); } @Test public void checkClone() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = scalAbsoluteTolerance; HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); integ.addStepHandler(new StepHandler() { public void handleStep(StepInterpolator interpolator, boolean isLast) throws MaxCountExceededException { StepInterpolator cloned = interpolator.copy(); double tA = cloned.getPreviousTime(); double tB = cloned.getCurrentTime(); double halfStep = FastMath.abs(tB - tA) / 2; Assert.assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12); Assert.assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12); for (int i = 0; i < 10; ++i) { double t = (i * tB + (9 - i) * tA) / 9; interpolator.setInterpolatedTime(t); Assert.assertTrue(FastMath.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10)); cloned.setInterpolatedTime(t); Assert.assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12); double[] referenceState = interpolator.getInterpolatedState(); double[] cloneState = cloned.getInterpolatedState(); for (int j = 0; j < referenceState.length; ++j) { Assert.assertEquals(referenceState[j], cloneState[j], 1.0e-12); } } } public void init(double t0, double[] y0, double t) { } }); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ode.nonstiff; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MaxCountExceededException; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.ode.FirstOrderDifferentialEquations; import org.apache.commons.math3.ode.FirstOrderIntegrator; import org.apache.commons.math3.ode.TestProblem1; import org.apache.commons.math3.ode.TestProblem5; import org.apache.commons.math3.ode.TestProblemAbstract; import org.apache.commons.math3.ode.TestProblemFactory; import org.apache.commons.math3.ode.TestProblemHandler; import org.apache.commons.math3.ode.events.EventHandler; import org.apache.commons.math3.ode.sampling.StepHandler; import org.apache.commons.math3.ode.sampling.StepInterpolator; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class MidpointIntegratorTest { @Test(expected=DimensionMismatchException.class) public void testDimensionCheck() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem1 pb = new TestProblem1(); new MidpointIntegrator(0.01).integrate(pb, 0.0, new double[pb.getDimension()+10], 1.0, new double[pb.getDimension()+10]); Assert.fail("an exception should have been thrown"); } @Test public void testDecreasingSteps() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblemAbstract[] problems = TestProblemFactory.getProblems(); for (int k = 0; k < problems.length; ++k) { double previousValueError = Double.NaN; double previousTimeError = Double.NaN; for (int i = 4; i < 10; ++i) { TestProblemAbstract pb = problems[k].copy(); double step = (pb.getFinalTime() - pb.getInitialTime()) * FastMath.pow(2.0, -i); FirstOrderIntegrator integ = new MidpointIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); EventHandler[] functions = pb.getEventsHandlers(); for (int l = 0; l < functions.length; ++l) { integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000); } double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); if (functions.length == 0) { Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10); } double valueError = handler.getMaximalValueError(); if (i > 4) { Assert.assertTrue(valueError < FastMath.abs(previousValueError)); } previousValueError = valueError; double timeError = handler.getMaximalTimeError(); if (i > 4) { Assert.assertTrue(timeError <= FastMath.abs(previousTimeError)); } previousTimeError = timeError; } } } @Test public void testSmallStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem1 pb = new TestProblem1(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001; FirstOrderIntegrator integ = new MidpointIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertTrue(handler.getLastError() < 2.0e-7); Assert.assertTrue(handler.getMaximalValueError() < 1.0e-6); Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); Assert.assertEquals("midpoint", integ.getName()); } @Test public void testBigStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem1 pb = new TestProblem1(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2; FirstOrderIntegrator integ = new MidpointIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertTrue(handler.getLastError() > 0.01); Assert.assertTrue(handler.getMaximalValueError() > 0.05); Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); } @Test public void testBackward() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem5 pb = new TestProblem5(); double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001; FirstOrderIntegrator integ = new MidpointIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertTrue(handler.getLastError() < 6.0e-4); Assert.assertTrue(handler.getMaximalValueError() < 6.0e-4); Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); Assert.assertEquals("midpoint", integ.getName()); } @Test public void testStepSize() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { final double step = 1.23456; FirstOrderIntegrator integ = new MidpointIntegrator(step); integ.addStepHandler(new StepHandler() { public void handleStep(StepInterpolator interpolator, boolean isLast) { if (! isLast) { Assert.assertEquals(step, interpolator.getCurrentTime() - interpolator.getPreviousTime(), 1.0e-12); } } public void init(double t0, double[] y0, double t) { } }); integ.integrate(new FirstOrderDifferentialEquations() { public void computeDerivatives(double t, double[] y, double[] dot) { dot[0] = 1.0; } public int getDimension() { return 1; } }, 0.0, new double[] { 0.0 }, 5.0, new double[1]); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ode.nonstiff; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Random; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MaxCountExceededException; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.ode.ContinuousOutputModel; import org.apache.commons.math3.ode.TestProblem1; import org.apache.commons.math3.ode.TestProblem3; import org.apache.commons.math3.ode.sampling.StepHandler; import org.apache.commons.math3.ode.sampling.StepInterpolatorTestUtils; import org.junit.Assert; import org.junit.Test; public class MidpointStepInterpolatorTest { @Test public void testDerivativesConsistency() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem3 pb = new TestProblem3(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001; MidpointIntegrator integ = new MidpointIntegrator(step); StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10); } @Test public void serialization() throws IOException, ClassNotFoundException, DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem1 pb = new TestProblem1(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001; MidpointIntegrator integ = new MidpointIntegrator(step); integ.addStepHandler(new ContinuousOutputModel()); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); for (StepHandler handler : integ.getStepHandlers()) { oos.writeObject(handler); } Assert.assertTrue(bos.size () > 135000); Assert.assertTrue(bos.size () < 145000); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); ContinuousOutputModel cm = (ContinuousOutputModel) ois.readObject(); Random random = new Random(347588535632l); double maxError = 0.0; for (int i = 0; i < 1000; ++i) { double r = random.nextDouble(); double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime(); cm.setInterpolatedTime(time); double[] interpolatedY = cm.getInterpolatedState (); double[] theoreticalY = pb.computeTheoreticalState(time); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } } Assert.assertTrue(maxError < 1.0e-6); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ode.nonstiff; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MaxCountExceededException; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.ode.FirstOrderDifferentialEquations; import org.apache.commons.math3.ode.FirstOrderIntegrator; import org.apache.commons.math3.ode.TestProblem1; import org.apache.commons.math3.ode.TestProblem3; import org.apache.commons.math3.ode.TestProblem5; import org.apache.commons.math3.ode.TestProblemAbstract; import org.apache.commons.math3.ode.TestProblemFactory; import org.apache.commons.math3.ode.TestProblemHandler; import org.apache.commons.math3.ode.events.EventHandler; import org.apache.commons.math3.ode.sampling.StepHandler; import org.apache.commons.math3.ode.sampling.StepInterpolator; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class ThreeEighthesIntegratorTest { @Test(expected=DimensionMismatchException.class) public void testDimensionCheck() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem1 pb = new TestProblem1(); new ThreeEighthesIntegrator(0.01).integrate(pb, 0.0, new double[pb.getDimension()+10], 1.0, new double[pb.getDimension()+10]); Assert.fail("an exception should have been thrown"); } @Test public void testDecreasingSteps() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblemAbstract[] problems = TestProblemFactory.getProblems(); for (int k = 0; k < problems.length; ++k) { double previousValueError = Double.NaN; double previousTimeError = Double.NaN; for (int i = 4; i < 10; ++i) { TestProblemAbstract pb = problems[k].copy(); double step = (pb.getFinalTime() - pb.getInitialTime()) * FastMath.pow(2.0, -i); FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); EventHandler[] functions = pb.getEventsHandlers(); for (int l = 0; l < functions.length; ++l) { integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000); } double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); if (functions.length == 0) { Assert.assertEquals(pb.getFinalTime(), stopTime, 1.0e-10); } double error = handler.getMaximalValueError(); if (i > 4) { Assert.assertTrue(error < 1.01 * FastMath.abs(previousValueError)); } previousValueError = error; double timeError = handler.getMaximalTimeError(); if (i > 4) { Assert.assertTrue(timeError <= FastMath.abs(previousTimeError)); } previousTimeError = timeError; } } } @Test public void testSmallStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem1 pb = new TestProblem1(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001; FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertTrue(handler.getLastError() < 2.0e-13); Assert.assertTrue(handler.getMaximalValueError() < 4.0e-12); Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); Assert.assertEquals("3/8", integ.getName()); } @Test public void testBigStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem1 pb = new TestProblem1(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2; FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertTrue(handler.getLastError() > 0.0004); Assert.assertTrue(handler.getMaximalValueError() > 0.005); Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); } @Test public void testBackward() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem5 pb = new TestProblem5(); double step = FastMath.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001; FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertTrue(handler.getLastError() < 5.0e-10); Assert.assertTrue(handler.getMaximalValueError() < 7.0e-10); Assert.assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); Assert.assertEquals("3/8", integ.getName()); } @Test public void testKepler() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { final TestProblem3 pb = new TestProblem3(0.9); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003; FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step); integ.addStepHandler(new KeplerHandler(pb)); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); } private static class KeplerHandler implements StepHandler { public KeplerHandler(TestProblem3 pb) { this.pb = pb; maxError = 0; } public void init(double t0, double[] y0, double t) { maxError = 0; } public void handleStep(StepInterpolator interpolator, boolean isLast) throws MaxCountExceededException { double[] interpolatedY = interpolator.getInterpolatedState(); double[] theoreticalY = pb.computeTheoreticalState(interpolator.getCurrentTime()); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } if (isLast) { // even with more than 1000 evaluations per period, // RK4 is not able to integrate such an eccentric // orbit with a good accuracy Assert.assertTrue(maxError > 0.005); } } private TestProblem3 pb; private double maxError = 0; } @Test public void testStepSize() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { final double step = 1.23456; FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step); integ.addStepHandler(new StepHandler() { public void handleStep(StepInterpolator interpolator, boolean isLast) { if (! isLast) { Assert.assertEquals(step, interpolator.getCurrentTime() - interpolator.getPreviousTime(), 1.0e-12); } } public void init(double t0, double[] y0, double t) { } }); integ.integrate(new FirstOrderDifferentialEquations() { public void computeDerivatives(double t, double[] y, double[] dot) { dot[0] = 1.0; } public int getDimension() { return 1; } }, 0.0, new double[] { 0.0 }, 5.0, new double[1]); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ode.nonstiff; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Random; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MaxCountExceededException; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.ode.ContinuousOutputModel; import org.apache.commons.math3.ode.TestProblem3; import org.apache.commons.math3.ode.sampling.StepHandler; import org.apache.commons.math3.ode.sampling.StepInterpolatorTestUtils; import org.junit.Assert; import org.junit.Test; public class ThreeEighthesStepInterpolatorTest { @Test public void derivativesConsistency() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem3 pb = new TestProblem3(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001; ThreeEighthesIntegrator integ = new ThreeEighthesIntegrator(step); StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 1.0e-10); } @Test public void serialization() throws IOException, ClassNotFoundException, DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { TestProblem3 pb = new TestProblem3(0.9); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003; ThreeEighthesIntegrator integ = new ThreeEighthesIntegrator(step); integ.addStepHandler(new ContinuousOutputModel()); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); for (StepHandler handler : integ.getStepHandlers()) { oos.writeObject(handler); } Assert.assertTrue(bos.size () > 880000); Assert.assertTrue(bos.size () < 900000); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); ContinuousOutputModel cm = (ContinuousOutputModel) ois.readObject(); Random random = new Random(347588535632l); double maxError = 0.0; for (int i = 0; i < 1000; ++i) { double r = random.nextDouble(); double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime(); cm.setInterpolatedTime(time); double[] interpolatedY = cm.getInterpolatedState (); double[] theoreticalY = pb.computeTheoreticalState(time); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } } Assert.assertTrue(maxError > 0.005); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ode.sampling; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import org.apache.commons.math3.exception.MaxCountExceededException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class DummyStepInterpolatorTest { @Test public void testNoReset() throws MaxCountExceededException { double[] y = { 0.0, 1.0, -2.0 }; DummyStepInterpolator interpolator = new DummyStepInterpolator(y, new double[y.length], true); interpolator.storeTime(0); interpolator.shift(); interpolator.storeTime(1); double[] result = interpolator.getInterpolatedState(); for (int i = 0; i < result.length; ++i) { Assert.assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10); } } @Test public void testFixedState() throws MaxCountExceededException { double[] y = { 1.0, 3.0, -4.0 }; DummyStepInterpolator interpolator = new DummyStepInterpolator(y, new double[y.length], true); interpolator.storeTime(0); interpolator.shift(); interpolator.storeTime(1); interpolator.setInterpolatedTime(0.1); double[] result = interpolator.getInterpolatedState(); for (int i = 0; i < result.length; ++i) { Assert.assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10); } interpolator.setInterpolatedTime(0.5); result = interpolator.getInterpolatedState(); for (int i = 0; i < result.length; ++i) { Assert.assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10); } } @Test public void testSerialization() throws IOException, ClassNotFoundException, MaxCountExceededException { double[] y = { 0.0, 1.0, -2.0 }; DummyStepInterpolator interpolator = new DummyStepInterpolator(y, new double[y.length], true); interpolator.storeTime(0); interpolator.shift(); interpolator.storeTime(1); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(interpolator); Assert.assertTrue(bos.size () > 300); Assert.assertTrue(bos.size () < 500); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); DummyStepInterpolator dsi = (DummyStepInterpolator) ois.readObject(); dsi.setInterpolatedTime(0.5); double[] result = dsi.getInterpolatedState(); for (int i = 0; i < result.length; ++i) { Assert.assertTrue(FastMath.abs(result[i] - y[i]) < 1.0e-10); } } @Test public void testImpossibleSerialization() throws IOException { double[] y = { 0.0, 1.0, -2.0 }; AbstractStepInterpolator interpolator = new BadStepInterpolator(y, true); interpolator.storeTime(0); interpolator.shift(); interpolator.storeTime(1); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); try { oos.writeObject(interpolator); Assert.fail("an exception should have been thrown"); } catch (LocalException le) { // expected behavior } } private static class BadStepInterpolator extends DummyStepInterpolator { @SuppressWarnings("unused") public BadStepInterpolator() { } public BadStepInterpolator(double[] y, boolean forward) { super(y, new double[y.length], forward); } @Override protected void doFinalize() { throw new LocalException(); } } private static class LocalException extends RuntimeException { private static final long serialVersionUID = 1L; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ode.sampling; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Random; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MaxCountExceededException; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.ode.ContinuousOutputModel; import org.apache.commons.math3.ode.TestProblem1; import org.apache.commons.math3.ode.TestProblem3; import org.apache.commons.math3.ode.nonstiff.AdamsBashforthIntegrator; import org.junit.Assert; import org.junit.Test; public class NordsieckStepInterpolatorTest { @Test public void derivativesConsistency() throws NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException { TestProblem3 pb = new TestProblem3(); AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(4, 0.0, 1.0, 1.0e-10, 1.0e-10); StepInterpolatorTestUtils.checkDerivativesConsistency(integ, pb, 5e-9); } @Test public void serialization() throws IOException, ClassNotFoundException, NumberIsTooSmallException, DimensionMismatchException, MaxCountExceededException, NoBracketingException { TestProblem1 pb = new TestProblem1(); AdamsBashforthIntegrator integ = new AdamsBashforthIntegrator(4, 0.0, 1.0, 1.0e-10, 1.0e-10); integ.addStepHandler(new ContinuousOutputModel()); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); for (StepHandler handler : integ.getStepHandlers()) { oos.writeObject(handler); } Assert.assertTrue(bos.size () > 25500); Assert.assertTrue(bos.size () < 26500); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); ContinuousOutputModel cm = (ContinuousOutputModel) ois.readObject(); Random random = new Random(347588535632l); double maxError = 0.0; for (int i = 0; i < 1000; ++i) { double r = random.nextDouble(); double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime(); cm.setInterpolatedTime(time); double[] interpolatedY = cm.getInterpolatedState (); double[] theoreticalY = pb.computeTheoreticalState(time); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } } Assert.assertTrue(maxError < 1.0e-6); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ode.sampling; /** Step normalizer output tests, for problems where the first and last points * are overlap fixed points. */ public class StepNormalizerOutputOverlapTest extends StepNormalizerOutputTestBase { @Override protected double getStart() { return 0.0; } @Override protected double getEnd() { return 10.0; } @Override protected double[] getExpInc() { return new double[] { 0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5, 9.0, 9.5, 10.0 }; } @Override protected double[] getExpIncRev() { return new double[] { 10.0, 9.5, 9.0, 8.5, 8.0, 7.5, 7.0, 6.5, 6.0, 5.5, 5.0, 4.5, 4.0, 3.5, 3.0, 2.5, 2.0, 1.5, 1.0, 0.5, 0.0 }; } @Override protected double[] getExpMul() { return new double[] { 0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5, 9.0, 9.5, 10.0 }; } @Override protected double[] getExpMulRev() { return new double[] { 10.0, 9.5, 9.0, 8.5, 8.0, 7.5, 7.0, 6.5, 6.0, 5.5, 5.0, 4.5, 4.0, 3.5, 3.0, 2.5, 2.0, 1.5, 1.0, 0.5, 0.0 }; } @Override protected int[][] getO() { return new int[][] {{1, 0}, {1, 0}, {0, 0}, {0, 0}, {1, 0}, {1, 0}, {0, 0}, {0, 0}, {1, 0}, {1, 0}, {0, 0}, {0, 0}, {1, 0}, {1, 0}, {0, 0}, {0, 0}}; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ode.sampling; /** Step normalizer output tests, for problems where the first and last points * are not fixed points. */ public class StepNormalizerOutputTest extends StepNormalizerOutputTestBase { @Override protected double getStart() { return 0.3; } @Override protected double getEnd() { return 10.1; } @Override protected double[] getExpInc() { return new double[] { 0.3, 0.8, 1.3, 1.8, 2.3, 2.8, 3.3, 3.8, 4.3, 4.8, 5.3, 5.8, 6.3, 6.8, 7.3, 7.8, 8.3, 8.8, 9.3, 9.8, 10.1 }; } @Override protected double[] getExpIncRev() { return new double[] { 10.1, 9.6, 9.1, 8.6, 8.1, 7.6, 7.1, 6.6, 6.1, 5.6, 5.1, 4.6, 4.1, 3.6, 3.1, 2.6, 2.1, 1.6, 1.1, 0.6, 0.3 }; } @Override protected double[] getExpMul() { return new double[] { 0.3, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5, 9.0, 9.5, 10.0, 10.1 }; } @Override protected double[] getExpMulRev() { return new double[] { 10.1, 10.0, 9.5, 9.0, 8.5, 8.0, 7.5, 7.0, 6.5, 6.0, 5.5, 5.0, 4.5, 4.0, 3.5, 3.0, 2.5, 2.0, 1.5, 1.0, 0.5, 0.3 }; } @Override protected int[][] getO() { return new int[][] {{1, 1}, {1, 1}, {0, 1}, {0, 1}, {1, 0}, {1, 0}, {0, 0}, {0, 0}, {1, 1}, {1, 1}, {0, 1}, {0, 1}, {1, 0}, {1, 0}, {0, 0}, {0, 0}}; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.ode.sampling; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MaxCountExceededException; import org.apache.commons.math3.exception.NoBracketingException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.ode.FirstOrderIntegrator; import org.apache.commons.math3.ode.TestProblem3; import org.apache.commons.math3.ode.nonstiff.DormandPrince54Integrator; import org.apache.commons.math3.util.FastMath; import org.junit.After; import org.junit.Assert; import org.junit.Before; import org.junit.Test; public class StepNormalizerTest { public StepNormalizerTest() { pb = null; integ = null; } @Test public void testBoundaries() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { double range = pb.getFinalTime() - pb.getInitialTime(); setLastSeen(false); integ.addStepHandler(new StepNormalizer(range / 10.0, new FixedStepHandler() { private boolean firstCall = true; public void init(double t0, double[] y0, double t) { } public void handleStep(double t, double[] y, double[] yDot, boolean isLast) { if (firstCall) { checkValue(t, pb.getInitialTime()); firstCall = false; } if (isLast) { setLastSeen(true); checkValue(t, pb.getFinalTime()); } } })); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertTrue(lastSeen); } @Test public void testBeforeEnd() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException { final double range = pb.getFinalTime() - pb.getInitialTime(); setLastSeen(false); integ.addStepHandler(new StepNormalizer(range / 10.5, new FixedStepHandler() { public void init(double t0, double[] y0, double t) { } public void handleStep(double t, double[] y, double[] yDot, boolean isLast) { if (isLast) { setLastSeen(true); checkValue(t, pb.getFinalTime() - range / 21.0); } } })); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Assert.assertTrue(lastSeen); } public void checkValue(double value, double reference) { Assert.assertTrue(FastMath.abs(value - reference) < 1.0e-10); } public void setLastSeen(boolean lastSeen) { this.lastSeen = lastSeen; } @Before public void setUp() { pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); integ = new DormandPrince54Integrator(minStep, maxStep, 10.e-8, 1.0e-8); lastSeen = false; } @After public void tearDown() { pb = null; integ = null; } TestProblem3 pb; FirstOrderIntegrator integ; boolean lastSeen; }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optim; import org.apache.commons.math3.TestUtils; import org.junit.Assert; import org.junit.Test; public class PointValuePairTest { @Test public void testSerial() { PointValuePair pv1 = new PointValuePair(new double[] { 1.0, 2.0, 3.0 }, 4.0); PointValuePair pv2 = (PointValuePair) TestUtils.serializeAndRecover(pv1); Assert.assertEquals(pv1.getKey().length, pv2.getKey().length); for (int i = 0; i < pv1.getKey().length; ++i) { Assert.assertEquals(pv1.getKey()[i], pv2.getKey()[i], 1.0e-15); } Assert.assertEquals(pv1.getValue(), pv2.getValue(), 1.0e-15); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optim; import org.apache.commons.math3.TestUtils; import org.junit.Assert; import org.junit.Test; public class PointVectorValuePairTest { @Test public void testSerial() { PointVectorValuePair pv1 = new PointVectorValuePair(new double[] { 1.0, 2.0, 3.0 }, new double[] { 4.0, 5.0 }); PointVectorValuePair pv2 = (PointVectorValuePair) TestUtils.serializeAndRecover(pv1); Assert.assertEquals(pv1.getKey().length, pv2.getKey().length); for (int i = 0; i < pv1.getKey().length; ++i) { Assert.assertEquals(pv1.getKey()[i], pv2.getKey()[i], 1.0e-15); } Assert.assertEquals(pv1.getValue().length, pv2.getValue().length); for (int i = 0; i < pv1.getValue().length; ++i) { Assert.assertEquals(pv1.getValue()[i], pv2.getValue()[i], 1.0e-15); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optim; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.junit.Test; import org.junit.Assert; public class SimplePointCheckerTest { @Test(expected=NotStrictlyPositiveException.class) public void testIterationCheckPrecondition() { new SimplePointChecker<PointValuePair>(1e-1, 1e-2, 0); } @Test public void testIterationCheck() { final int max = 10; final SimplePointChecker<PointValuePair> checker = new SimplePointChecker<PointValuePair>(1e-1, 1e-2, max); Assert.assertTrue(checker.converged(max, null, null)); Assert.assertTrue(checker.converged(max + 1, null, null)); } @Test public void testIterationCheckDisabled() { final SimplePointChecker<PointValuePair> checker = new SimplePointChecker<PointValuePair>(1e-8, 1e-8); final PointValuePair a = new PointValuePair(new double[] { 1d }, 1d); final PointValuePair b = new PointValuePair(new double[] { 10d }, 10d); Assert.assertFalse(checker.converged(-1, a, b)); Assert.assertFalse(checker.converged(0, a, b)); Assert.assertFalse(checker.converged(1000000, a, b)); Assert.assertTrue(checker.converged(-1, a, a)); Assert.assertTrue(checker.converged(-1, b, b)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optim; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.junit.Test; import org.junit.Assert; public class SimpleValueCheckerTest { @Test(expected=NotStrictlyPositiveException.class) public void testIterationCheckPrecondition() { new SimpleValueChecker(1e-1, 1e-2, 0); } @Test public void testIterationCheck() { final int max = 10; final SimpleValueChecker checker = new SimpleValueChecker(1e-1, 1e-2, max); Assert.assertTrue(checker.converged(max, null, null)); Assert.assertTrue(checker.converged(max + 1, null, null)); } @Test public void testIterationCheckDisabled() { final SimpleValueChecker checker = new SimpleValueChecker(1e-8, 1e-8); final PointValuePair a = new PointValuePair(new double[] { 1d }, 1d); final PointValuePair b = new PointValuePair(new double[] { 10d }, 10d); Assert.assertFalse(checker.converged(-1, a, b)); Assert.assertFalse(checker.converged(0, a, b)); Assert.assertFalse(checker.converged(1000000, a, b)); Assert.assertTrue(checker.converged(-1, a, a)); Assert.assertTrue(checker.converged(-1, b, b)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optim; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.junit.Test; import org.junit.Assert; public class SimpleVectorValueCheckerTest { @Test(expected=NotStrictlyPositiveException.class) public void testIterationCheckPrecondition() { new SimpleVectorValueChecker(1e-1, 1e-2, 0); } @Test public void testIterationCheck() { final int max = 10; final SimpleVectorValueChecker checker = new SimpleVectorValueChecker(1e-1, 1e-2, max); Assert.assertTrue(checker.converged(max, null, null)); Assert.assertTrue(checker.converged(max + 1, null, null)); } @Test public void testIterationCheckDisabled() { final SimpleVectorValueChecker checker = new SimpleVectorValueChecker(1e-8, 1e-8); final PointVectorValuePair a = new PointVectorValuePair(new double[] { 1d }, new double[] { 1d }); final PointVectorValuePair b = new PointVectorValuePair(new double[] { 10d }, new double[] { 10d }); Assert.assertFalse(checker.converged(-1, a, b)); Assert.assertFalse(checker.converged(0, a, b)); Assert.assertFalse(checker.converged(1000000, a, b)); Assert.assertTrue(checker.converged(-1, a, a)); Assert.assertTrue(checker.converged(-1, b, b)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optim.linear; import java.util.ArrayList; import java.util.Collection; import java.util.List; import org.apache.commons.math3.optim.MaxIter; import org.apache.commons.math3.optim.nonlinear.scalar.GoalType; import org.apache.commons.math3.optim.PointValuePair; import org.apache.commons.math3.util.Precision; import org.junit.Test; import org.junit.Assert; public class SimplexSolverTest { private static final MaxIter DEFAULT_MAX_ITER = new MaxIter(100); @Test public void testMath828() { LinearObjectiveFunction f = new LinearObjectiveFunction( new double[] { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}, 0.0); ArrayList <LinearConstraint>constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] {0.0, 39.0, 23.0, 96.0, 15.0, 48.0, 9.0, 21.0, 48.0, 36.0, 76.0, 19.0, 88.0, 17.0, 16.0, 36.0,}, Relationship.GEQ, 15.0)); constraints.add(new LinearConstraint(new double[] {0.0, 59.0, 93.0, 12.0, 29.0, 78.0, 73.0, 87.0, 32.0, 70.0, 68.0, 24.0, 11.0, 26.0, 65.0, 25.0,}, Relationship.GEQ, 29.0)); constraints.add(new LinearConstraint(new double[] {0.0, 74.0, 5.0, 82.0, 6.0, 97.0, 55.0, 44.0, 52.0, 54.0, 5.0, 93.0, 91.0, 8.0, 20.0, 97.0,}, Relationship.GEQ, 6.0)); constraints.add(new LinearConstraint(new double[] {8.0, -3.0, -28.0, -72.0, -8.0, -31.0, -31.0, -74.0, -47.0, -59.0, -24.0, -57.0, -56.0, -16.0, -92.0, -59.0,}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {25.0, -7.0, -99.0, -78.0, -25.0, -14.0, -16.0, -89.0, -39.0, -56.0, -53.0, -9.0, -18.0, -26.0, -11.0, -61.0,}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {33.0, -95.0, -15.0, -4.0, -33.0, -3.0, -20.0, -96.0, -27.0, -13.0, -80.0, -24.0, -3.0, -13.0, -57.0, -76.0,}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {7.0, -95.0, -39.0, -93.0, -7.0, -94.0, -94.0, -62.0, -76.0, -26.0, -53.0, -57.0, -31.0, -76.0, -53.0, -52.0,}, Relationship.GEQ, 0.0)); double epsilon = 1e-6; PointValuePair solution = new SimplexSolver().optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints), GoalType.MINIMIZE, new NonNegativeConstraint(true)); Assert.assertEquals(1.0d, solution.getValue(), epsilon); Assert.assertTrue(validSolution(solution, constraints, epsilon)); } @Test public void testMath828Cycle() { LinearObjectiveFunction f = new LinearObjectiveFunction( new double[] { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}, 0.0); ArrayList <LinearConstraint>constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] {0.0, 16.0, 14.0, 69.0, 1.0, 85.0, 52.0, 43.0, 64.0, 97.0, 14.0, 74.0, 89.0, 28.0, 94.0, 58.0, 13.0, 22.0, 21.0, 17.0, 30.0, 25.0, 1.0, 59.0, 91.0, 78.0, 12.0, 74.0, 56.0, 3.0, 88.0,}, Relationship.GEQ, 91.0)); constraints.add(new LinearConstraint(new double[] {0.0, 60.0, 40.0, 81.0, 71.0, 72.0, 46.0, 45.0, 38.0, 48.0, 40.0, 17.0, 33.0, 85.0, 64.0, 32.0, 84.0, 3.0, 54.0, 44.0, 71.0, 67.0, 90.0, 95.0, 54.0, 99.0, 99.0, 29.0, 52.0, 98.0, 9.0,}, Relationship.GEQ, 54.0)); constraints.add(new LinearConstraint(new double[] {0.0, 41.0, 12.0, 86.0, 90.0, 61.0, 31.0, 41.0, 23.0, 89.0, 17.0, 74.0, 44.0, 27.0, 16.0, 47.0, 80.0, 32.0, 11.0, 56.0, 68.0, 82.0, 11.0, 62.0, 62.0, 53.0, 39.0, 16.0, 48.0, 1.0, 63.0,}, Relationship.GEQ, 62.0)); constraints.add(new LinearConstraint(new double[] {83.0, -76.0, -94.0, -19.0, -15.0, -70.0, -72.0, -57.0, -63.0, -65.0, -22.0, -94.0, -22.0, -88.0, -86.0, -89.0, -72.0, -16.0, -80.0, -49.0, -70.0, -93.0, -95.0, -17.0, -83.0, -97.0, -31.0, -47.0, -31.0, -13.0, -23.0,}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {41.0, -96.0, -41.0, -48.0, -70.0, -43.0, -43.0, -43.0, -97.0, -37.0, -85.0, -70.0, -45.0, -67.0, -87.0, -69.0, -94.0, -54.0, -54.0, -92.0, -79.0, -10.0, -35.0, -20.0, -41.0, -41.0, -65.0, -25.0, -12.0, -8.0, -46.0,}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {27.0, -42.0, -65.0, -49.0, -53.0, -42.0, -17.0, -2.0, -61.0, -31.0, -76.0, -47.0, -8.0, -93.0, -86.0, -62.0, -65.0, -63.0, -22.0, -43.0, -27.0, -23.0, -32.0, -74.0, -27.0, -63.0, -47.0, -78.0, -29.0, -95.0, -73.0,}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {15.0, -46.0, -41.0, -83.0, -98.0, -99.0, -21.0, -35.0, -7.0, -14.0, -80.0, -63.0, -18.0, -42.0, -5.0, -34.0, -56.0, -70.0, -16.0, -18.0, -74.0, -61.0, -47.0, -41.0, -15.0, -79.0, -18.0, -47.0, -88.0, -68.0, -55.0,}, Relationship.GEQ, 0.0)); double epsilon = 1e-6; PointValuePair solution = new SimplexSolver().optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints), GoalType.MINIMIZE, new NonNegativeConstraint(true)); Assert.assertEquals(1.0d, solution.getValue(), epsilon); Assert.assertTrue(validSolution(solution, constraints, epsilon)); } @Test public void testMath781() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 2, 6, 7 }, 0); ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1, 2, 1 }, Relationship.LEQ, 2)); constraints.add(new LinearConstraint(new double[] { -1, 1, 1 }, Relationship.LEQ, -1)); constraints.add(new LinearConstraint(new double[] { 2, -3, 1 }, Relationship.LEQ, -1)); double epsilon = 1e-6; SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints), GoalType.MAXIMIZE, new NonNegativeConstraint(false)); Assert.assertTrue(Precision.compareTo(solution.getPoint()[0], 0.0d, epsilon) > 0); Assert.assertTrue(Precision.compareTo(solution.getPoint()[1], 0.0d, epsilon) > 0); Assert.assertTrue(Precision.compareTo(solution.getPoint()[2], 0.0d, epsilon) < 0); Assert.assertEquals(2.0d, solution.getValue(), epsilon); } @Test public void testMath713NegativeVariable() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {1.0, 1.0}, 0.0d); ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] {1, 0}, Relationship.EQ, 1)); double epsilon = 1e-6; SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints), GoalType.MINIMIZE, new NonNegativeConstraint(true)); Assert.assertTrue(Precision.compareTo(solution.getPoint()[0], 0.0d, epsilon) >= 0); Assert.assertTrue(Precision.compareTo(solution.getPoint()[1], 0.0d, epsilon) >= 0); } @Test public void testMath434NegativeVariable() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {0.0, 0.0, 1.0}, 0.0d); ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] {1, 1, 0}, Relationship.EQ, 5)); constraints.add(new LinearConstraint(new double[] {0, 0, 1}, Relationship.GEQ, -10)); double epsilon = 1e-6; SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints), GoalType.MINIMIZE, new NonNegativeConstraint(false)); Assert.assertEquals(5.0, solution.getPoint()[0] + solution.getPoint()[1], epsilon); Assert.assertEquals(-10.0, solution.getPoint()[2], epsilon); Assert.assertEquals(-10.0, solution.getValue(), epsilon); } @Test(expected = NoFeasibleSolutionException.class) public void testMath434UnfeasibleSolution() { double epsilon = 1e-6; LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {1.0, 0.0}, 0.0); ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] {epsilon/2, 0.5}, Relationship.EQ, 0)); constraints.add(new LinearConstraint(new double[] {1e-3, 0.1}, Relationship.EQ, 10)); SimplexSolver solver = new SimplexSolver(); // allowing only non-negative values, no feasible solution shall be found solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints), GoalType.MINIMIZE, new NonNegativeConstraint(true)); } @Test public void testMath434PivotRowSelection() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {1.0}, 0.0); double epsilon = 1e-6; ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] {200}, Relationship.GEQ, 1)); constraints.add(new LinearConstraint(new double[] {100}, Relationship.GEQ, 0.499900001)); SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints), GoalType.MINIMIZE, new NonNegativeConstraint(false)); Assert.assertTrue(Precision.compareTo(solution.getPoint()[0] * 200.d, 1.d, epsilon) >= 0); Assert.assertEquals(0.0050, solution.getValue(), epsilon); } @Test public void testMath434PivotRowSelection2() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {0.0d, 1.0d, 1.0d, 0.0d, 0.0d, 0.0d, 0.0d}, 0.0d); ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] {1.0d, -0.1d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d}, Relationship.EQ, -0.1d)); constraints.add(new LinearConstraint(new double[] {1.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d}, Relationship.GEQ, -1e-18d)); constraints.add(new LinearConstraint(new double[] {0.0d, 1.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d)); constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 0.0d, 1.0d, 0.0d, -0.0128588d, 1e-5d}, Relationship.EQ, 0.0d)); constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 0.0d, 0.0d, 1.0d, 1e-5d, -0.0128586d}, Relationship.EQ, 1e-10d)); constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 1.0d, -1.0d, 0.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d)); constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 1.0d, 1.0d, 0.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d)); constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 1.0d, 0.0d, -1.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d)); constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 1.0d, 0.0d, 1.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d)); double epsilon = 1e-7; SimplexSolver simplex = new SimplexSolver(); PointValuePair solution = simplex.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints), GoalType.MINIMIZE, new NonNegativeConstraint(false)); Assert.assertTrue(Precision.compareTo(solution.getPoint()[0], -1e-18d, epsilon) >= 0); Assert.assertEquals(1.0d, solution.getPoint()[1], epsilon); Assert.assertEquals(0.0d, solution.getPoint()[2], epsilon); Assert.assertEquals(1.0d, solution.getValue(), epsilon); } @Test public void testMath272() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 2, 2, 1 }, 0); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1, 1, 0 }, Relationship.GEQ, 1)); constraints.add(new LinearConstraint(new double[] { 1, 0, 1 }, Relationship.GEQ, 1)); constraints.add(new LinearConstraint(new double[] { 0, 1, 0 }, Relationship.GEQ, 1)); SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints), GoalType.MINIMIZE, new NonNegativeConstraint(true)); Assert.assertEquals(0.0, solution.getPoint()[0], .0000001); Assert.assertEquals(1.0, solution.getPoint()[1], .0000001); Assert.assertEquals(1.0, solution.getPoint()[2], .0000001); Assert.assertEquals(3.0, solution.getValue(), .0000001); } @Test public void testMath286() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 0.8, 0.2, 0.7, 0.3, 0.6, 0.4 }, 0 ); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1, 0, 1, 0, 1, 0 }, Relationship.EQ, 23.0)); constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 1, 0, 1 }, Relationship.EQ, 23.0)); constraints.add(new LinearConstraint(new double[] { 1, 0, 0, 0, 0, 0 }, Relationship.GEQ, 10.0)); constraints.add(new LinearConstraint(new double[] { 0, 0, 1, 0, 0, 0 }, Relationship.GEQ, 8.0)); constraints.add(new LinearConstraint(new double[] { 0, 0, 0, 0, 1, 0 }, Relationship.GEQ, 5.0)); SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints), GoalType.MAXIMIZE, new NonNegativeConstraint(true)); Assert.assertEquals(25.8, solution.getValue(), .0000001); Assert.assertEquals(23.0, solution.getPoint()[0] + solution.getPoint()[2] + solution.getPoint()[4], 0.0000001); Assert.assertEquals(23.0, solution.getPoint()[1] + solution.getPoint()[3] + solution.getPoint()[5], 0.0000001); Assert.assertTrue(solution.getPoint()[0] >= 10.0 - 0.0000001); Assert.assertTrue(solution.getPoint()[2] >= 8.0 - 0.0000001); Assert.assertTrue(solution.getPoint()[4] >= 5.0 - 0.0000001); } @Test public void testDegeneracy() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 0.8, 0.7 }, 0 ); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.LEQ, 18.0)); constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.GEQ, 10.0)); constraints.add(new LinearConstraint(new double[] { 0, 1 }, Relationship.GEQ, 8.0)); SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints), GoalType.MINIMIZE, new NonNegativeConstraint(true)); Assert.assertEquals(13.6, solution.getValue(), .0000001); } @Test public void testMath288() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 7, 3, 0, 0 }, 0 ); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 3, 0, -5, 0 }, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] { 2, 0, 0, -5 }, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] { 0, 3, 0, -5 }, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] { 1, 0, 0, 0 }, Relationship.LEQ, 1.0)); constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 0 }, Relationship.LEQ, 1.0)); SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints), GoalType.MAXIMIZE, new NonNegativeConstraint(true)); Assert.assertEquals(10.0, solution.getValue(), .0000001); } @Test public void testMath290GEQ() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 1, 5 }, 0 ); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 2, 0 }, Relationship.GEQ, -1.0)); SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints), GoalType.MINIMIZE, new NonNegativeConstraint(true)); Assert.assertEquals(0, solution.getValue(), .0000001); Assert.assertEquals(0, solution.getPoint()[0], .0000001); Assert.assertEquals(0, solution.getPoint()[1], .0000001); } @Test(expected=NoFeasibleSolutionException.class) public void testMath290LEQ() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 1, 5 }, 0 ); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 2, 0 }, Relationship.LEQ, -1.0)); SimplexSolver solver = new SimplexSolver(); solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints), GoalType.MINIMIZE, new NonNegativeConstraint(true)); } @Test public void testMath293() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 0.8, 0.2, 0.7, 0.3, 0.4, 0.6}, 0 ); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1, 0, 1, 0, 1, 0 }, Relationship.EQ, 30.0)); constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 1, 0, 1 }, Relationship.EQ, 30.0)); constraints.add(new LinearConstraint(new double[] { 0.8, 0.2, 0.0, 0.0, 0.0, 0.0 }, Relationship.GEQ, 10.0)); constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.7, 0.3, 0.0, 0.0 }, Relationship.GEQ, 10.0)); constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.0, 0.0, 0.4, 0.6 }, Relationship.GEQ, 10.0)); SimplexSolver solver = new SimplexSolver(); PointValuePair solution1 = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints), GoalType.MAXIMIZE, new NonNegativeConstraint(true)); Assert.assertEquals(15.7143, solution1.getPoint()[0], .0001); Assert.assertEquals(0.0, solution1.getPoint()[1], .0001); Assert.assertEquals(14.2857, solution1.getPoint()[2], .0001); Assert.assertEquals(0.0, solution1.getPoint()[3], .0001); Assert.assertEquals(0.0, solution1.getPoint()[4], .0001); Assert.assertEquals(30.0, solution1.getPoint()[5], .0001); Assert.assertEquals(40.57143, solution1.getValue(), .0001); double valA = 0.8 * solution1.getPoint()[0] + 0.2 * solution1.getPoint()[1]; double valB = 0.7 * solution1.getPoint()[2] + 0.3 * solution1.getPoint()[3]; double valC = 0.4 * solution1.getPoint()[4] + 0.6 * solution1.getPoint()[5]; f = new LinearObjectiveFunction(new double[] { 0.8, 0.2, 0.7, 0.3, 0.4, 0.6}, 0 ); constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1, 0, 1, 0, 1, 0 }, Relationship.EQ, 30.0)); constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 1, 0, 1 }, Relationship.EQ, 30.0)); constraints.add(new LinearConstraint(new double[] { 0.8, 0.2, 0.0, 0.0, 0.0, 0.0 }, Relationship.GEQ, valA)); constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.7, 0.3, 0.0, 0.0 }, Relationship.GEQ, valB)); constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.0, 0.0, 0.4, 0.6 }, Relationship.GEQ, valC)); PointValuePair solution2 = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints), GoalType.MAXIMIZE, new NonNegativeConstraint(true)); Assert.assertEquals(40.57143, solution2.getValue(), .0001); } @Test public void testMath930() { Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] {1, -1, -1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, 1, 1, -1, 0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1}, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 1, 0, -1, 0, -1, 0, 1, 0, -1, 0, 1, 0, 1, 0, -1, 0, -1, 0, 1, 0, 1, 0, -1, 0, 1, 0, -1, 0, -1, 0, 1, 0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.628803}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.676993}, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 1, -1, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, 1, -1, 0, 0, -1, 1, 0, 0, 1, -1, 0, 0, 1, -1, 0, 0, -1, 1, 0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.136677}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.444434}, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, -1, 0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.254028}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.302218}, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 1, -1, -1, 1, 0, 0, 0, 0, -1, 1, 1, -1, 0, 0, 0, 0, -1, 1, 1, -1, 0, 0, 0, 0, 1, -1, -1, 1, 0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.653981}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.690437}, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 0, 1, 0, -1, 0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.423786}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.486717}, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 1, -1, 0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.049232}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.304747}, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 1, 0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.129826}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.205625}, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 1, -1, -1, 1, -1, 1, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1, 1, -1, 1, -1, -1, 1, 0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.621944}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.764385}, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, -1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 0, 1, 0, -1, 0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.432572}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.480762}, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, 1, -1, 0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.055983}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.11378}, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 1, 0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.009607}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.057797}, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1, 1, -1, 0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.407308}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.452749}, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.269677}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.321806}, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1, 0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.049232}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.06902}, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.028754}, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, -1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, 0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.484254}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.524607}, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, -1, 0, 1, 0, -1, 0, 1, 0, 1, 0, -1, 0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.385492}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.430134}, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, -1, 1, 0, 0, -1, 1, 0, 0, 1, -1, 0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.34983}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.375781}, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, 1, 0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.254028}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.281308}, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, -1, 1, 0, 0, 0, 0, -1, 1, 1, -1, 0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.304995}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.345347}, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 0, 0, 0, -1, 0, 1, 0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.288899}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.332212}, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, -1, 1, 0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.14351}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.17057}, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1, 0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, -0.129826}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, -0.157435}, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, -1, 1, -1, 1, 1, -1, 0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1}, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, -1, 0, 1, 0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, -0.141071}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, -0.232574}, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, -1, 1, 0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, -0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, -1}, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, -1, 0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, -0.009607}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, -0.057797}, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, -1, 1, 0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, -0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, -1}, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1, 0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, -0.091644}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, -0.203531}, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -1}, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -0.028754}, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, Relationship.EQ, 1.0)); double[] objFunctionCoeff = new double[33]; objFunctionCoeff[3] = 1; LinearObjectiveFunction f = new LinearObjectiveFunction(objFunctionCoeff, 0); SimplexSolver solver = new SimplexSolver(1e-4, 10, 1e-6); PointValuePair solution = solver.optimize(new MaxIter(1000), f, new LinearConstraintSet(constraints), GoalType.MINIMIZE, new NonNegativeConstraint(true)); Assert.assertEquals(0.3752298, solution.getValue(), 1e-4); } @Test public void testSimplexSolver() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 15, 10 }, 7); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.LEQ, 2)); constraints.add(new LinearConstraint(new double[] { 0, 1 }, Relationship.LEQ, 3)); constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.EQ, 4)); SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints), GoalType.MAXIMIZE, new NonNegativeConstraint(true)); Assert.assertEquals(2.0, solution.getPoint()[0], 0.0); Assert.assertEquals(2.0, solution.getPoint()[1], 0.0); Assert.assertEquals(57.0, solution.getValue(), 0.0); } @Test public void testSingleVariableAndConstraint() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 3 }, 0); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.LEQ, 10)); SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints), GoalType.MAXIMIZE, new NonNegativeConstraint(false)); Assert.assertEquals(10.0, solution.getPoint()[0], 0.0); Assert.assertEquals(30.0, solution.getValue(), 0.0); } /** * With no artificial variables needed (no equals and no greater than * constraints) we can go straight to Phase 2. */ @Test public void testModelWithNoArtificialVars() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 15, 10 }, 0); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.LEQ, 2)); constraints.add(new LinearConstraint(new double[] { 0, 1 }, Relationship.LEQ, 3)); constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.LEQ, 4)); SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints), GoalType.MAXIMIZE, new NonNegativeConstraint(false)); Assert.assertEquals(2.0, solution.getPoint()[0], 0.0); Assert.assertEquals(2.0, solution.getPoint()[1], 0.0); Assert.assertEquals(50.0, solution.getValue(), 0.0); } @Test public void testMinimization() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { -2, 1 }, -5); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1, 2 }, Relationship.LEQ, 6)); constraints.add(new LinearConstraint(new double[] { 3, 2 }, Relationship.LEQ, 12)); constraints.add(new LinearConstraint(new double[] { 0, 1 }, Relationship.GEQ, 0)); SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints), GoalType.MINIMIZE, new NonNegativeConstraint(false)); Assert.assertEquals(4.0, solution.getPoint()[0], 0.0); Assert.assertEquals(0.0, solution.getPoint()[1], 0.0); Assert.assertEquals(-13.0, solution.getValue(), 0.0); } @Test public void testSolutionWithNegativeDecisionVariable() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { -2, 1 }, 0); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.GEQ, 6)); constraints.add(new LinearConstraint(new double[] { 1, 2 }, Relationship.LEQ, 14)); SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints), GoalType.MAXIMIZE, new NonNegativeConstraint(false)); Assert.assertEquals(-2.0, solution.getPoint()[0], 0.0); Assert.assertEquals(8.0, solution.getPoint()[1], 0.0); Assert.assertEquals(12.0, solution.getValue(), 0.0); } @Test(expected = NoFeasibleSolutionException.class) public void testInfeasibleSolution() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 15 }, 0); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.LEQ, 1)); constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.GEQ, 3)); SimplexSolver solver = new SimplexSolver(); solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints), GoalType.MAXIMIZE, new NonNegativeConstraint(false)); } @Test(expected = UnboundedSolutionException.class) public void testUnboundedSolution() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 15, 10 }, 0); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.EQ, 2)); SimplexSolver solver = new SimplexSolver(); solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints), GoalType.MAXIMIZE, new NonNegativeConstraint(false)); } @Test public void testRestrictVariablesToNonNegative() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 409, 523, 70, 204, 339 }, 0); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 43, 56, 345, 56, 5 }, Relationship.LEQ, 4567456)); constraints.add(new LinearConstraint(new double[] { 12, 45, 7, 56, 23 }, Relationship.LEQ, 56454)); constraints.add(new LinearConstraint(new double[] { 8, 768, 0, 34, 7456 }, Relationship.LEQ, 1923421)); constraints.add(new LinearConstraint(new double[] { 12342, 2342, 34, 678, 2342 }, Relationship.GEQ, 4356)); constraints.add(new LinearConstraint(new double[] { 45, 678, 76, 52, 23 }, Relationship.EQ, 456356)); SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints), GoalType.MAXIMIZE, new NonNegativeConstraint(true)); Assert.assertEquals(2902.92783505155, solution.getPoint()[0], .0000001); Assert.assertEquals(480.419243986254, solution.getPoint()[1], .0000001); Assert.assertEquals(0.0, solution.getPoint()[2], .0000001); Assert.assertEquals(0.0, solution.getPoint()[3], .0000001); Assert.assertEquals(0.0, solution.getPoint()[4], .0000001); Assert.assertEquals(1438556.7491409, solution.getValue(), .0000001); } @Test public void testEpsilon() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 10, 5, 1 }, 0); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 9, 8, 0 }, Relationship.EQ, 17)); constraints.add(new LinearConstraint(new double[] { 0, 7, 8 }, Relationship.LEQ, 7)); constraints.add(new LinearConstraint(new double[] { 10, 0, 2 }, Relationship.LEQ, 10)); SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints), GoalType.MAXIMIZE, new NonNegativeConstraint(false)); Assert.assertEquals(1.0, solution.getPoint()[0], 0.0); Assert.assertEquals(1.0, solution.getPoint()[1], 0.0); Assert.assertEquals(0.0, solution.getPoint()[2], 0.0); Assert.assertEquals(15.0, solution.getValue(), 0.0); } @Test public void testTrivialModel() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 1, 1 }, 0); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.EQ, 0)); SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints), GoalType.MAXIMIZE, new NonNegativeConstraint(true)); Assert.assertEquals(0, solution.getValue(), .0000001); } @Test public void testLargeModel() { double[] objective = new double[] { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}; LinearObjectiveFunction f = new LinearObjectiveFunction(objective, 0); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(equationFromString(objective.length, "x0 + x1 + x2 + x3 - x12 = 0")); constraints.add(equationFromString(objective.length, "x4 + x5 + x6 + x7 + x8 + x9 + x10 + x11 - x13 = 0")); constraints.add(equationFromString(objective.length, "x4 + x5 + x6 + x7 + x8 + x9 + x10 + x11 >= 49")); constraints.add(equationFromString(objective.length, "x0 + x1 + x2 + x3 >= 42")); constraints.add(equationFromString(objective.length, "x14 + x15 + x16 + x17 - x26 = 0")); constraints.add(equationFromString(objective.length, "x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 - x27 = 0")); constraints.add(equationFromString(objective.length, "x14 + x15 + x16 + x17 - x12 = 0")); constraints.add(equationFromString(objective.length, "x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 - x13 = 0")); constraints.add(equationFromString(objective.length, "x28 + x29 + x30 + x31 - x40 = 0")); constraints.add(equationFromString(objective.length, "x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 - x41 = 0")); constraints.add(equationFromString(objective.length, "x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 >= 49")); constraints.add(equationFromString(objective.length, "x28 + x29 + x30 + x31 >= 42")); constraints.add(equationFromString(objective.length, "x42 + x43 + x44 + x45 - x54 = 0")); constraints.add(equationFromString(objective.length, "x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 - x55 = 0")); constraints.add(equationFromString(objective.length, "x42 + x43 + x44 + x45 - x40 = 0")); constraints.add(equationFromString(objective.length, "x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 - x41 = 0")); constraints.add(equationFromString(objective.length, "x56 + x57 + x58 + x59 - x68 = 0")); constraints.add(equationFromString(objective.length, "x60 + x61 + x62 + x63 + x64 + x65 + x66 + x67 - x69 = 0")); constraints.add(equationFromString(objective.length, "x60 + x61 + x62 + x63 + x64 + x65 + x66 + x67 >= 51")); constraints.add(equationFromString(objective.length, "x56 + x57 + x58 + x59 >= 44")); constraints.add(equationFromString(objective.length, "x70 + x71 + x72 + x73 - x82 = 0")); constraints.add(equationFromString(objective.length, "x74 + x75 + x76 + x77 + x78 + x79 + x80 + x81 - x83 = 0")); constraints.add(equationFromString(objective.length, "x70 + x71 + x72 + x73 - x68 = 0")); constraints.add(equationFromString(objective.length, "x74 + x75 + x76 + x77 + x78 + x79 + x80 + x81 - x69 = 0")); constraints.add(equationFromString(objective.length, "x84 + x85 + x86 + x87 - x96 = 0")); constraints.add(equationFromString(objective.length, "x88 + x89 + x90 + x91 + x92 + x93 + x94 + x95 - x97 = 0")); constraints.add(equationFromString(objective.length, "x88 + x89 + x90 + x91 + x92 + x93 + x94 + x95 >= 51")); constraints.add(equationFromString(objective.length, "x84 + x85 + x86 + x87 >= 44")); constraints.add(equationFromString(objective.length, "x98 + x99 + x100 + x101 - x110 = 0")); constraints.add(equationFromString(objective.length, "x102 + x103 + x104 + x105 + x106 + x107 + x108 + x109 - x111 = 0")); constraints.add(equationFromString(objective.length, "x98 + x99 + x100 + x101 - x96 = 0")); constraints.add(equationFromString(objective.length, "x102 + x103 + x104 + x105 + x106 + x107 + x108 + x109 - x97 = 0")); constraints.add(equationFromString(objective.length, "x112 + x113 + x114 + x115 - x124 = 0")); constraints.add(equationFromString(objective.length, "x116 + x117 + x118 + x119 + x120 + x121 + x122 + x123 - x125 = 0")); constraints.add(equationFromString(objective.length, "x116 + x117 + x118 + x119 + x120 + x121 + x122 + x123 >= 49")); constraints.add(equationFromString(objective.length, "x112 + x113 + x114 + x115 >= 42")); constraints.add(equationFromString(objective.length, "x126 + x127 + x128 + x129 - x138 = 0")); constraints.add(equationFromString(objective.length, "x130 + x131 + x132 + x133 + x134 + x135 + x136 + x137 - x139 = 0")); constraints.add(equationFromString(objective.length, "x126 + x127 + x128 + x129 - x124 = 0")); constraints.add(equationFromString(objective.length, "x130 + x131 + x132 + x133 + x134 + x135 + x136 + x137 - x125 = 0")); constraints.add(equationFromString(objective.length, "x140 + x141 + x142 + x143 - x152 = 0")); constraints.add(equationFromString(objective.length, "x144 + x145 + x146 + x147 + x148 + x149 + x150 + x151 - x153 = 0")); constraints.add(equationFromString(objective.length, "x144 + x145 + x146 + x147 + x148 + x149 + x150 + x151 >= 59")); constraints.add(equationFromString(objective.length, "x140 + x141 + x142 + x143 >= 42")); constraints.add(equationFromString(objective.length, "x154 + x155 + x156 + x157 - x166 = 0")); constraints.add(equationFromString(objective.length, "x158 + x159 + x160 + x161 + x162 + x163 + x164 + x165 - x167 = 0")); constraints.add(equationFromString(objective.length, "x154 + x155 + x156 + x157 - x152 = 0")); constraints.add(equationFromString(objective.length, "x158 + x159 + x160 + x161 + x162 + x163 + x164 + x165 - x153 = 0")); constraints.add(equationFromString(objective.length, "x83 + x82 - x168 = 0")); constraints.add(equationFromString(objective.length, "x111 + x110 - x169 = 0")); constraints.add(equationFromString(objective.length, "x170 - x182 = 0")); constraints.add(equationFromString(objective.length, "x171 - x183 = 0")); constraints.add(equationFromString(objective.length, "x172 - x184 = 0")); constraints.add(equationFromString(objective.length, "x173 - x185 = 0")); constraints.add(equationFromString(objective.length, "x174 - x186 = 0")); constraints.add(equationFromString(objective.length, "x175 + x176 - x187 = 0")); constraints.add(equationFromString(objective.length, "x177 - x188 = 0")); constraints.add(equationFromString(objective.length, "x178 - x189 = 0")); constraints.add(equationFromString(objective.length, "x179 - x190 = 0")); constraints.add(equationFromString(objective.length, "x180 - x191 = 0")); constraints.add(equationFromString(objective.length, "x181 - x192 = 0")); constraints.add(equationFromString(objective.length, "x170 - x26 = 0")); constraints.add(equationFromString(objective.length, "x171 - x27 = 0")); constraints.add(equationFromString(objective.length, "x172 - x54 = 0")); constraints.add(equationFromString(objective.length, "x173 - x55 = 0")); constraints.add(equationFromString(objective.length, "x174 - x168 = 0")); constraints.add(equationFromString(objective.length, "x177 - x169 = 0")); constraints.add(equationFromString(objective.length, "x178 - x138 = 0")); constraints.add(equationFromString(objective.length, "x179 - x139 = 0")); constraints.add(equationFromString(objective.length, "x180 - x166 = 0")); constraints.add(equationFromString(objective.length, "x181 - x167 = 0")); constraints.add(equationFromString(objective.length, "x193 - x205 = 0")); constraints.add(equationFromString(objective.length, "x194 - x206 = 0")); constraints.add(equationFromString(objective.length, "x195 - x207 = 0")); constraints.add(equationFromString(objective.length, "x196 - x208 = 0")); constraints.add(equationFromString(objective.length, "x197 - x209 = 0")); constraints.add(equationFromString(objective.length, "x198 + x199 - x210 = 0")); constraints.add(equationFromString(objective.length, "x200 - x211 = 0")); constraints.add(equationFromString(objective.length, "x201 - x212 = 0")); constraints.add(equationFromString(objective.length, "x202 - x213 = 0")); constraints.add(equationFromString(objective.length, "x203 - x214 = 0")); constraints.add(equationFromString(objective.length, "x204 - x215 = 0")); constraints.add(equationFromString(objective.length, "x193 - x182 = 0")); constraints.add(equationFromString(objective.length, "x194 - x183 = 0")); constraints.add(equationFromString(objective.length, "x195 - x184 = 0")); constraints.add(equationFromString(objective.length, "x196 - x185 = 0")); constraints.add(equationFromString(objective.length, "x197 - x186 = 0")); constraints.add(equationFromString(objective.length, "x198 + x199 - x187 = 0")); constraints.add(equationFromString(objective.length, "x200 - x188 = 0")); constraints.add(equationFromString(objective.length, "x201 - x189 = 0")); constraints.add(equationFromString(objective.length, "x202 - x190 = 0")); constraints.add(equationFromString(objective.length, "x203 - x191 = 0")); constraints.add(equationFromString(objective.length, "x204 - x192 = 0")); SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(DEFAULT_MAX_ITER, f, new LinearConstraintSet(constraints), GoalType.MINIMIZE, new NonNegativeConstraint(true)); Assert.assertEquals(7518.0, solution.getValue(), .0000001); } /** * Converts a test string to a {@link LinearConstraint}. * Ex: x0 + x1 + x2 + x3 - x12 = 0 */ private LinearConstraint equationFromString(int numCoefficients, String s) { Relationship relationship; if (s.contains(">=")) { relationship = Relationship.GEQ; } else if (s.contains("<=")) { relationship = Relationship.LEQ; } else if (s.contains("=")) { relationship = Relationship.EQ; } else { throw new IllegalArgumentException(); } String[] equationParts = s.split("[>|<]?="); double rhs = Double.parseDouble(equationParts[1].trim()); double[] lhs = new double[numCoefficients]; String left = equationParts[0].replaceAll(" ?x", ""); String[] coefficients = left.split(" "); for (String coefficient : coefficients) { double value = coefficient.charAt(0) == '-' ? -1 : 1; int index = Integer.parseInt(coefficient.replaceFirst("[+|-]", "").trim()); lhs[index] = value; } return new LinearConstraint(lhs, relationship, rhs); } private static boolean validSolution(PointValuePair solution, List<LinearConstraint> constraints, double epsilon) { double[] vals = solution.getPoint(); for (LinearConstraint c : constraints) { double[] coeffs = c.getCoefficients().toArray(); double result = 0.0d; for (int i = 0; i < vals.length; i++) { result += vals[i] * coeffs[i]; } switch (c.getRelationship()) { case EQ: if (!Precision.equals(result, c.getValue(), epsilon)) { return false; } break; case GEQ: if (Precision.compareTo(result, c.getValue(), epsilon) < 0) { return false; } break; case LEQ: if (Precision.compareTo(result, c.getValue(), epsilon) > 0) { return false; } break; } } return true; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optim.linear; import java.util.ArrayList; import java.util.Collection; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.optim.nonlinear.scalar.GoalType; import org.junit.Assert; import org.junit.Test; public class SimplexTableauTest { @Test public void testInitialization() { LinearObjectiveFunction f = createFunction(); Collection<LinearConstraint> constraints = createConstraints(); SimplexTableau tableau = new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false, 1.0e-6); double[][] expectedInitialTableau = { {-1, 0, -1, -1, 2, 0, 0, 0, -4}, { 0, 1, -15, -10, 25, 0, 0, 0, 0}, { 0, 0, 1, 0, -1, 1, 0, 0, 2}, { 0, 0, 0, 1, -1, 0, 1, 0, 3}, { 0, 0, 1, 1, -2, 0, 0, 1, 4} }; assertMatrixEquals(expectedInitialTableau, tableau.getData()); } @Test public void testDropPhase1Objective() { LinearObjectiveFunction f = createFunction(); Collection<LinearConstraint> constraints = createConstraints(); SimplexTableau tableau = new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false, 1.0e-6); double[][] expectedTableau = { { 1, -15, -10, 0, 0, 0, 0}, { 0, 1, 0, 1, 0, 0, 2}, { 0, 0, 1, 0, 1, 0, 3}, { 0, 1, 1, 0, 0, 1, 4} }; tableau.dropPhase1Objective(); assertMatrixEquals(expectedTableau, tableau.getData()); } @Test public void testTableauWithNoArtificialVars() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {15, 10}, 0); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] {1, 0}, Relationship.LEQ, 2)); constraints.add(new LinearConstraint(new double[] {0, 1}, Relationship.LEQ, 3)); constraints.add(new LinearConstraint(new double[] {1, 1}, Relationship.LEQ, 4)); SimplexTableau tableau = new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false, 1.0e-6); double[][] initialTableau = { {1, -15, -10, 25, 0, 0, 0, 0}, {0, 1, 0, -1, 1, 0, 0, 2}, {0, 0, 1, -1, 0, 1, 0, 3}, {0, 1, 1, -2, 0, 0, 1, 4} }; assertMatrixEquals(initialTableau, tableau.getData()); } @Test public void testSerial() { LinearObjectiveFunction f = createFunction(); Collection<LinearConstraint> constraints = createConstraints(); SimplexTableau tableau = new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false, 1.0e-6); Assert.assertEquals(tableau, TestUtils.serializeAndRecover(tableau)); } private LinearObjectiveFunction createFunction() { return new LinearObjectiveFunction(new double[] {15, 10}, 0); } private Collection<LinearConstraint> createConstraints() { Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] {1, 0}, Relationship.LEQ, 2)); constraints.add(new LinearConstraint(new double[] {0, 1}, Relationship.LEQ, 3)); constraints.add(new LinearConstraint(new double[] {1, 1}, Relationship.EQ, 4)); return constraints; } private void assertMatrixEquals(double[][] expected, double[][] result) { Assert.assertEquals("Wrong number of rows.", expected.length, result.length); for (int i = 0; i < expected.length; i++) { Assert.assertEquals("Wrong number of columns.", expected[i].length, result[i].length); for (int j = 0; j < expected[i].length; j++) { Assert.assertEquals("Wrong value at position [" + i + "," + j + "]", expected[i][j], result[i][j], 1.0e-15); } } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optim.nonlinear.scalar; import org.apache.commons.math3.analysis.MultivariateFunction; import org.apache.commons.math3.geometry.euclidean.twod.Vector2D; import org.apache.commons.math3.optim.MaxEval; import org.apache.commons.math3.optim.InitialGuess; import org.apache.commons.math3.optim.PointValuePair; import org.apache.commons.math3.optim.SimpleValueChecker; import org.apache.commons.math3.optim.nonlinear.scalar.gradient.CircleScalar; import org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer; import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.NelderMeadSimplex; import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer; import org.apache.commons.math3.random.GaussianRandomGenerator; import org.apache.commons.math3.random.JDKRandomGenerator; import org.apache.commons.math3.random.RandomVectorGenerator; import org.apache.commons.math3.random.UncorrelatedRandomVectorGenerator; import org.junit.Assert; import org.junit.Test; public class MultiStartMultivariateOptimizerTest { @Test public void testCircleFitting() { CircleScalar circle = new CircleScalar(); circle.addPoint( 30.0, 68.0); circle.addPoint( 50.0, -6.0); circle.addPoint(110.0, -20.0); circle.addPoint( 35.0, 15.0); circle.addPoint( 45.0, 97.0); // TODO: the wrapper around NonLinearConjugateGradientOptimizer is a temporary hack for // version 3.1 of the library. It should be removed when NonLinearConjugateGradientOptimizer // will officially be declared as implementing MultivariateDifferentiableOptimizer GradientMultivariateOptimizer underlying = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE, new SimpleValueChecker(1e-10, 1e-10)); JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(753289573253l); RandomVectorGenerator generator = new UncorrelatedRandomVectorGenerator(new double[] { 50, 50 }, new double[] { 10, 10 }, new GaussianRandomGenerator(g)); MultiStartMultivariateOptimizer optimizer = new MultiStartMultivariateOptimizer(underlying, 10, generator); PointValuePair optimum = optimizer.optimize(new MaxEval(200), circle.getObjectiveFunction(), circle.getObjectiveFunctionGradient(), GoalType.MINIMIZE, new InitialGuess(new double[] { 98.680, 47.345 })); Assert.assertEquals(200, optimizer.getMaxEvaluations()); PointValuePair[] optima = optimizer.getOptima(); for (PointValuePair o : optima) { Vector2D center = new Vector2D(o.getPointRef()[0], o.getPointRef()[1]); Assert.assertEquals(69.960161753, circle.getRadius(center), 1e-8); Assert.assertEquals(96.075902096, center.getX(), 1e-8); Assert.assertEquals(48.135167894, center.getY(), 1e-8); } Assert.assertTrue(optimizer.getEvaluations() > 70); Assert.assertTrue(optimizer.getEvaluations() < 90); Assert.assertEquals(3.1267527, optimum.getValue(), 1e-8); } @Test public void testRosenbrock() { Rosenbrock rosenbrock = new Rosenbrock(); SimplexOptimizer underlying = new SimplexOptimizer(new SimpleValueChecker(-1, 1e-3)); NelderMeadSimplex simplex = new NelderMeadSimplex(new double[][] { { -1.2, 1.0 }, { 0.9, 1.2 } , { 3.5, -2.3 } }); JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(16069223052l); RandomVectorGenerator generator = new UncorrelatedRandomVectorGenerator(2, new GaussianRandomGenerator(g)); MultiStartMultivariateOptimizer optimizer = new MultiStartMultivariateOptimizer(underlying, 10, generator); PointValuePair optimum = optimizer.optimize(new MaxEval(1100), new ObjectiveFunction(rosenbrock), GoalType.MINIMIZE, simplex, new InitialGuess(new double[] { -1.2, 1.0 })); Assert.assertEquals(rosenbrock.getCount(), optimizer.getEvaluations()); Assert.assertTrue(optimizer.getEvaluations() > 900); Assert.assertTrue(optimizer.getEvaluations() < 1200); Assert.assertTrue(optimum.getValue() < 8e-4); } private static class Rosenbrock implements MultivariateFunction { private int count; public Rosenbrock() { count = 0; } public double value(double[] x) { ++count; double a = x[1] - x[0] * x[0]; double b = 1 - x[0]; return 100 * a * a + b * b; } public int getCount() { return count; } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optim.nonlinear.scalar; import org.apache.commons.math3.analysis.MultivariateFunction; import org.apache.commons.math3.optim.InitialGuess; import org.apache.commons.math3.optim.MaxEval; import org.apache.commons.math3.optim.PointValuePair; import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex; import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.NelderMeadSimplex; import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer; import org.junit.Assert; import org.junit.Test; public class MultivariateFunctionMappingAdapterTest { @Test public void testStartSimplexInsideRange() { final BiQuadratic biQuadratic = new BiQuadratic(2.0, 2.5, 1.0, 3.0, 2.0, 3.0); final MultivariateFunctionMappingAdapter wrapped = new MultivariateFunctionMappingAdapter(biQuadratic, biQuadratic.getLower(), biQuadratic.getUpper()); SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); final AbstractSimplex simplex = new NelderMeadSimplex(new double[][] { wrapped.boundedToUnbounded(new double[] { 1.5, 2.75 }), wrapped.boundedToUnbounded(new double[] { 1.5, 2.95 }), wrapped.boundedToUnbounded(new double[] { 1.7, 2.90 }) }); final PointValuePair optimum = optimizer.optimize(new MaxEval(300), new ObjectiveFunction(wrapped), simplex, GoalType.MINIMIZE, new InitialGuess(wrapped.boundedToUnbounded(new double[] { 1.5, 2.25 }))); final double[] bounded = wrapped.unboundedToBounded(optimum.getPoint()); Assert.assertEquals(biQuadratic.getBoundedXOptimum(), bounded[0], 2e-7); Assert.assertEquals(biQuadratic.getBoundedYOptimum(), bounded[1], 2e-7); } @Test public void testOptimumOutsideRange() { final BiQuadratic biQuadratic = new BiQuadratic(4.0, 0.0, 1.0, 3.0, 2.0, 3.0); final MultivariateFunctionMappingAdapter wrapped = new MultivariateFunctionMappingAdapter(biQuadratic, biQuadratic.getLower(), biQuadratic.getUpper()); SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); final AbstractSimplex simplex = new NelderMeadSimplex(new double[][] { wrapped.boundedToUnbounded(new double[] { 1.5, 2.75 }), wrapped.boundedToUnbounded(new double[] { 1.5, 2.95 }), wrapped.boundedToUnbounded(new double[] { 1.7, 2.90 }) }); final PointValuePair optimum = optimizer.optimize(new MaxEval(100), new ObjectiveFunction(wrapped), simplex, GoalType.MINIMIZE, new InitialGuess(wrapped.boundedToUnbounded(new double[] { 1.5, 2.25 }))); final double[] bounded = wrapped.unboundedToBounded(optimum.getPoint()); Assert.assertEquals(biQuadratic.getBoundedXOptimum(), bounded[0], 2e-7); Assert.assertEquals(biQuadratic.getBoundedYOptimum(), bounded[1], 2e-7); } @Test public void testUnbounded() { final BiQuadratic biQuadratic = new BiQuadratic(4.0, 0.0, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY); final MultivariateFunctionMappingAdapter wrapped = new MultivariateFunctionMappingAdapter(biQuadratic, biQuadratic.getLower(), biQuadratic.getUpper()); SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); final AbstractSimplex simplex = new NelderMeadSimplex(new double[][] { wrapped.boundedToUnbounded(new double[] { 1.5, 2.75 }), wrapped.boundedToUnbounded(new double[] { 1.5, 2.95 }), wrapped.boundedToUnbounded(new double[] { 1.7, 2.90 }) }); final PointValuePair optimum = optimizer.optimize(new MaxEval(300), new ObjectiveFunction(wrapped), simplex, GoalType.MINIMIZE, new InitialGuess(wrapped.boundedToUnbounded(new double[] { 1.5, 2.25 }))); final double[] bounded = wrapped.unboundedToBounded(optimum.getPoint()); Assert.assertEquals(biQuadratic.getBoundedXOptimum(), bounded[0], 2e-7); Assert.assertEquals(biQuadratic.getBoundedYOptimum(), bounded[1], 2e-7); } @Test public void testHalfBounded() { final BiQuadratic biQuadratic = new BiQuadratic(4.0, 4.0, 1.0, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 3.0); final MultivariateFunctionMappingAdapter wrapped = new MultivariateFunctionMappingAdapter(biQuadratic, biQuadratic.getLower(), biQuadratic.getUpper()); SimplexOptimizer optimizer = new SimplexOptimizer(1e-13, 1e-30); final AbstractSimplex simplex = new NelderMeadSimplex(new double[][] { wrapped.boundedToUnbounded(new double[] { 1.5, 2.75 }), wrapped.boundedToUnbounded(new double[] { 1.5, 2.95 }), wrapped.boundedToUnbounded(new double[] { 1.7, 2.90 }) }); final PointValuePair optimum = optimizer.optimize(new MaxEval(200), new ObjectiveFunction(wrapped), simplex, GoalType.MINIMIZE, new InitialGuess(wrapped.boundedToUnbounded(new double[] { 1.5, 2.25 }))); final double[] bounded = wrapped.unboundedToBounded(optimum.getPoint()); Assert.assertEquals(biQuadratic.getBoundedXOptimum(), bounded[0], 1e-7); Assert.assertEquals(biQuadratic.getBoundedYOptimum(), bounded[1], 1e-7); } private static class BiQuadratic implements MultivariateFunction { private final double xOptimum; private final double yOptimum; private final double xMin; private final double xMax; private final double yMin; private final double yMax; public BiQuadratic(final double xOptimum, final double yOptimum, final double xMin, final double xMax, final double yMin, final double yMax) { this.xOptimum = xOptimum; this.yOptimum = yOptimum; this.xMin = xMin; this.xMax = xMax; this.yMin = yMin; this.yMax = yMax; } public double value(double[] point) { // the function should never be called with out of range points Assert.assertTrue(point[0] >= xMin); Assert.assertTrue(point[0] <= xMax); Assert.assertTrue(point[1] >= yMin); Assert.assertTrue(point[1] <= yMax); final double dx = point[0] - xOptimum; final double dy = point[1] - yOptimum; return dx * dx + dy * dy; } public double[] getLower() { return new double[] { xMin, yMin }; } public double[] getUpper() { return new double[] { xMax, yMax }; } public double getBoundedXOptimum() { return (xOptimum < xMin) ? xMin : ((xOptimum > xMax) ? xMax : xOptimum); } public double getBoundedYOptimum() { return (yOptimum < yMin) ? yMin : ((yOptimum > yMax) ? yMax : yOptimum); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optim.nonlinear.scalar; import org.apache.commons.math3.analysis.MultivariateFunction; import org.apache.commons.math3.optim.MaxEval; import org.apache.commons.math3.optim.InitialGuess; import org.apache.commons.math3.optim.PointValuePair; import org.apache.commons.math3.optim.SimplePointChecker; import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer; import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex; import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.NelderMeadSimplex; import org.junit.Assert; import org.junit.Test; public class MultivariateFunctionPenaltyAdapterTest { @Test public void testStartSimplexInsideRange() { final BiQuadratic biQuadratic = new BiQuadratic(2.0, 2.5, 1.0, 3.0, 2.0, 3.0); final MultivariateFunctionPenaltyAdapter wrapped = new MultivariateFunctionPenaltyAdapter(biQuadratic, biQuadratic.getLower(), biQuadratic.getUpper(), 1000.0, new double[] { 100.0, 100.0 }); SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); final AbstractSimplex simplex = new NelderMeadSimplex(new double[] { 1.0, 0.5 }); final PointValuePair optimum = optimizer.optimize(new MaxEval(300), new ObjectiveFunction(wrapped), simplex, GoalType.MINIMIZE, new InitialGuess(new double[] { 1.5, 2.25 })); Assert.assertEquals(biQuadratic.getBoundedXOptimum(), optimum.getPoint()[0], 2e-7); Assert.assertEquals(biQuadratic.getBoundedYOptimum(), optimum.getPoint()[1], 2e-7); } @Test public void testStartSimplexOutsideRange() { final BiQuadratic biQuadratic = new BiQuadratic(2.0, 2.5, 1.0, 3.0, 2.0, 3.0); final MultivariateFunctionPenaltyAdapter wrapped = new MultivariateFunctionPenaltyAdapter(biQuadratic, biQuadratic.getLower(), biQuadratic.getUpper(), 1000.0, new double[] { 100.0, 100.0 }); SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); final AbstractSimplex simplex = new NelderMeadSimplex(new double[] { 1.0, 0.5 }); final PointValuePair optimum = optimizer.optimize(new MaxEval(300), new ObjectiveFunction(wrapped), simplex, GoalType.MINIMIZE, new InitialGuess(new double[] { -1.5, 4.0 })); Assert.assertEquals(biQuadratic.getBoundedXOptimum(), optimum.getPoint()[0], 2e-7); Assert.assertEquals(biQuadratic.getBoundedYOptimum(), optimum.getPoint()[1], 2e-7); } @Test public void testOptimumOutsideRange() { final BiQuadratic biQuadratic = new BiQuadratic(4.0, 0.0, 1.0, 3.0, 2.0, 3.0); final MultivariateFunctionPenaltyAdapter wrapped = new MultivariateFunctionPenaltyAdapter(biQuadratic, biQuadratic.getLower(), biQuadratic.getUpper(), 1000.0, new double[] { 100.0, 100.0 }); SimplexOptimizer optimizer = new SimplexOptimizer(new SimplePointChecker<PointValuePair>(1.0e-11, 1.0e-20)); final AbstractSimplex simplex = new NelderMeadSimplex(new double[] { 1.0, 0.5 }); final PointValuePair optimum = optimizer.optimize(new MaxEval(600), new ObjectiveFunction(wrapped), simplex, GoalType.MINIMIZE, new InitialGuess(new double[] { -1.5, 4.0 })); Assert.assertEquals(biQuadratic.getBoundedXOptimum(), optimum.getPoint()[0], 2e-7); Assert.assertEquals(biQuadratic.getBoundedYOptimum(), optimum.getPoint()[1], 2e-7); } @Test public void testUnbounded() { final BiQuadratic biQuadratic = new BiQuadratic(4.0, 0.0, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY); final MultivariateFunctionPenaltyAdapter wrapped = new MultivariateFunctionPenaltyAdapter(biQuadratic, biQuadratic.getLower(), biQuadratic.getUpper(), 1000.0, new double[] { 100.0, 100.0 }); SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); final AbstractSimplex simplex = new NelderMeadSimplex(new double[] { 1.0, 0.5 }); final PointValuePair optimum = optimizer.optimize(new MaxEval(300), new ObjectiveFunction(wrapped), simplex, GoalType.MINIMIZE, new InitialGuess(new double[] { -1.5, 4.0 })); Assert.assertEquals(biQuadratic.getBoundedXOptimum(), optimum.getPoint()[0], 2e-7); Assert.assertEquals(biQuadratic.getBoundedYOptimum(), optimum.getPoint()[1], 2e-7); } @Test public void testHalfBounded() { final BiQuadratic biQuadratic = new BiQuadratic(4.0, 4.0, 1.0, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 3.0); final MultivariateFunctionPenaltyAdapter wrapped = new MultivariateFunctionPenaltyAdapter(biQuadratic, biQuadratic.getLower(), biQuadratic.getUpper(), 1000.0, new double[] { 100.0, 100.0 }); SimplexOptimizer optimizer = new SimplexOptimizer(new SimplePointChecker<PointValuePair>(1.0e-10, 1.0e-20)); final AbstractSimplex simplex = new NelderMeadSimplex(new double[] { 1.0, 0.5 }); final PointValuePair optimum = optimizer.optimize(new MaxEval(400), new ObjectiveFunction(wrapped), simplex, GoalType.MINIMIZE, new InitialGuess(new double[] { -1.5, 4.0 })); Assert.assertEquals(biQuadratic.getBoundedXOptimum(), optimum.getPoint()[0], 2e-7); Assert.assertEquals(biQuadratic.getBoundedYOptimum(), optimum.getPoint()[1], 2e-7); } private static class BiQuadratic implements MultivariateFunction { private final double xOptimum; private final double yOptimum; private final double xMin; private final double xMax; private final double yMin; private final double yMax; public BiQuadratic(final double xOptimum, final double yOptimum, final double xMin, final double xMax, final double yMin, final double yMax) { this.xOptimum = xOptimum; this.yOptimum = yOptimum; this.xMin = xMin; this.xMax = xMax; this.yMin = yMin; this.yMax = yMax; } public double value(double[] point) { // the function should never be called with out of range points Assert.assertTrue(point[0] >= xMin); Assert.assertTrue(point[0] <= xMax); Assert.assertTrue(point[1] >= yMin); Assert.assertTrue(point[1] <= yMax); final double dx = point[0] - xOptimum; final double dy = point[1] - yOptimum; return dx * dx + dy * dy; } public double[] getLower() { return new double[] { xMin, yMin }; } public double[] getUpper() { return new double[] { xMax, yMax }; } public double getBoundedXOptimum() { return (xOptimum < xMin) ? xMin : ((xOptimum > xMax) ? xMax : xOptimum); } public double getBoundedYOptimum() { return (yOptimum < yMin) ? yMin : ((yOptimum > yMax) ? yMax : yOptimum); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optim.nonlinear.scalar.gradient; import org.apache.commons.math3.analysis.MultivariateFunction; import org.apache.commons.math3.analysis.MultivariateVectorFunction; import org.apache.commons.math3.analysis.solvers.BrentSolver; import org.apache.commons.math3.exception.MathUnsupportedOperationException; import org.apache.commons.math3.geometry.euclidean.twod.Vector2D; import org.apache.commons.math3.linear.BlockRealMatrix; import org.apache.commons.math3.linear.RealMatrix; import org.apache.commons.math3.optim.PointValuePair; import org.apache.commons.math3.optim.SimpleValueChecker; import org.apache.commons.math3.optim.InitialGuess; import org.apache.commons.math3.optim.MaxEval; import org.apache.commons.math3.optim.SimpleBounds; import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction; import org.apache.commons.math3.optim.nonlinear.scalar.GoalType; import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunctionGradient; import org.junit.Assert; import org.junit.Test; /** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files. * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> * Minpack Copyright Notice (1999) University of Chicago. * All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> * <li>Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above * copyright notice, this list of conditions and the following * disclaimer in the documentation and/or other materials provided * with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, * must include the following acknowledgment: * <code>This product includes software developed by the University of * Chicago, as Operator of Argonne National Laboratory.</code> * Alternately, this acknowledgment may appear in the software itself, * if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" * WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE * UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND * THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE * OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY * OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR * USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF * THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) * DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION * UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL * BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT * HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF * ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, * INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF * ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF * PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER * SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT * (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, * EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE * POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */ public class NonLinearConjugateGradientOptimizerTest { @Test(expected=MathUnsupportedOperationException.class) public void testBoundsUnsupported() { LinearProblem problem = new LinearProblem(new double[][] { { 2 } }, new double[] { 3 }); NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); optimizer.optimize(new MaxEval(100), problem.getObjectiveFunction(), problem.getObjectiveFunctionGradient(), GoalType.MINIMIZE, new InitialGuess(new double[] { 0 }), new SimpleBounds(new double[] { -1 }, new double[] { 1 })); } @Test public void testTrivial() { LinearProblem problem = new LinearProblem(new double[][] { { 2 } }, new double[] { 3 }); NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); PointValuePair optimum = optimizer.optimize(new MaxEval(100), problem.getObjectiveFunction(), problem.getObjectiveFunctionGradient(), GoalType.MINIMIZE, new InitialGuess(new double[] { 0 })); Assert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10); Assert.assertEquals(0.0, optimum.getValue(), 1.0e-10); // Check that the number of iterations is updated (MATH-949). Assert.assertTrue(optimizer.getIterations() > 0); } @Test public void testColumnsPermutation() { LinearProblem problem = new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } }, new double[] { 4.0, 6.0, 1.0 }); NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); PointValuePair optimum = optimizer.optimize(new MaxEval(100), problem.getObjectiveFunction(), problem.getObjectiveFunctionGradient(), GoalType.MINIMIZE, new InitialGuess(new double[] { 0, 0 })); Assert.assertEquals(7.0, optimum.getPoint()[0], 1.0e-10); Assert.assertEquals(3.0, optimum.getPoint()[1], 1.0e-10); Assert.assertEquals(0.0, optimum.getValue(), 1.0e-10); } @Test public void testNoDependency() { LinearProblem problem = new LinearProblem(new double[][] { { 2, 0, 0, 0, 0, 0 }, { 0, 2, 0, 0, 0, 0 }, { 0, 0, 2, 0, 0, 0 }, { 0, 0, 0, 2, 0, 0 }, { 0, 0, 0, 0, 2, 0 }, { 0, 0, 0, 0, 0, 2 } }, new double[] { 0.0, 1.1, 2.2, 3.3, 4.4, 5.5 }); NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); PointValuePair optimum = optimizer.optimize(new MaxEval(100), problem.getObjectiveFunction(), problem.getObjectiveFunctionGradient(), GoalType.MINIMIZE, new InitialGuess(new double[] { 0, 0, 0, 0, 0, 0 })); for (int i = 0; i < problem.target.length; ++i) { Assert.assertEquals(0.55 * i, optimum.getPoint()[i], 1.0e-10); } } @Test public void testOneSet() { LinearProblem problem = new LinearProblem(new double[][] { { 1, 0, 0 }, { -1, 1, 0 }, { 0, -1, 1 } }, new double[] { 1, 1, 1}); NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); PointValuePair optimum = optimizer.optimize(new MaxEval(100), problem.getObjectiveFunction(), problem.getObjectiveFunctionGradient(), GoalType.MINIMIZE, new InitialGuess(new double[] { 0, 0, 0 })); Assert.assertEquals(1.0, optimum.getPoint()[0], 1.0e-10); Assert.assertEquals(2.0, optimum.getPoint()[1], 1.0e-10); Assert.assertEquals(3.0, optimum.getPoint()[2], 1.0e-10); } @Test public void testTwoSets() { final double epsilon = 1.0e-7; LinearProblem problem = new LinearProblem(new double[][] { { 2, 1, 0, 4, 0, 0 }, { -4, -2, 3, -7, 0, 0 }, { 4, 1, -2, 8, 0, 0 }, { 0, -3, -12, -1, 0, 0 }, { 0, 0, 0, 0, epsilon, 1 }, { 0, 0, 0, 0, 1, 1 } }, new double[] { 2, -9, 2, 2, 1 + epsilon * epsilon, 2}); final Preconditioner preconditioner = new Preconditioner() { public double[] precondition(double[] point, double[] r) { double[] d = r.clone(); d[0] /= 72.0; d[1] /= 30.0; d[2] /= 314.0; d[3] /= 260.0; d[4] /= 2 * (1 + epsilon * epsilon); d[5] /= 4.0; return d; } }; NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE, new SimpleValueChecker(1e-13, 1e-13), new BrentSolver(), preconditioner); PointValuePair optimum = optimizer.optimize(new MaxEval(100), problem.getObjectiveFunction(), problem.getObjectiveFunctionGradient(), GoalType.MINIMIZE, new InitialGuess(new double[] { 0, 0, 0, 0, 0, 0 })); Assert.assertEquals( 3.0, optimum.getPoint()[0], 1.0e-10); Assert.assertEquals( 4.0, optimum.getPoint()[1], 1.0e-10); Assert.assertEquals(-1.0, optimum.getPoint()[2], 1.0e-10); Assert.assertEquals(-2.0, optimum.getPoint()[3], 1.0e-10); Assert.assertEquals( 1.0 + epsilon, optimum.getPoint()[4], 1.0e-10); Assert.assertEquals( 1.0 - epsilon, optimum.getPoint()[5], 1.0e-10); } @Test public void testNonInversible() { LinearProblem problem = new LinearProblem(new double[][] { { 1, 2, -3 }, { 2, 1, 3 }, { -3, 0, -9 } }, new double[] { 1, 1, 1 }); NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); PointValuePair optimum = optimizer.optimize(new MaxEval(100), problem.getObjectiveFunction(), problem.getObjectiveFunctionGradient(), GoalType.MINIMIZE, new InitialGuess(new double[] { 0, 0, 0 })); Assert.assertTrue(optimum.getValue() > 0.5); } @Test public void testIllConditioned() { LinearProblem problem1 = new LinearProblem(new double[][] { { 10.0, 7.0, 8.0, 7.0 }, { 7.0, 5.0, 6.0, 5.0 }, { 8.0, 6.0, 10.0, 9.0 }, { 7.0, 5.0, 9.0, 10.0 } }, new double[] { 32, 23, 33, 31 }); NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE, new SimpleValueChecker(1e-13, 1e-13), new BrentSolver(1e-15, 1e-15)); PointValuePair optimum1 = optimizer.optimize(new MaxEval(200), problem1.getObjectiveFunction(), problem1.getObjectiveFunctionGradient(), GoalType.MINIMIZE, new InitialGuess(new double[] { 0, 1, 2, 3 })); Assert.assertEquals(1.0, optimum1.getPoint()[0], 1.0e-4); Assert.assertEquals(1.0, optimum1.getPoint()[1], 1.0e-4); Assert.assertEquals(1.0, optimum1.getPoint()[2], 1.0e-4); Assert.assertEquals(1.0, optimum1.getPoint()[3], 1.0e-4); LinearProblem problem2 = new LinearProblem(new double[][] { { 10.00, 7.00, 8.10, 7.20 }, { 7.08, 5.04, 6.00, 5.00 }, { 8.00, 5.98, 9.89, 9.00 }, { 6.99, 4.99, 9.00, 9.98 } }, new double[] { 32, 23, 33, 31 }); PointValuePair optimum2 = optimizer.optimize(new MaxEval(200), problem2.getObjectiveFunction(), problem2.getObjectiveFunctionGradient(), GoalType.MINIMIZE, new InitialGuess(new double[] { 0, 1, 2, 3 })); Assert.assertEquals(-81.0, optimum2.getPoint()[0], 1.0e-1); Assert.assertEquals(137.0, optimum2.getPoint()[1], 1.0e-1); Assert.assertEquals(-34.0, optimum2.getPoint()[2], 1.0e-1); Assert.assertEquals( 22.0, optimum2.getPoint()[3], 1.0e-1); } @Test public void testMoreEstimatedParametersSimple() { LinearProblem problem = new LinearProblem(new double[][] { { 3.0, 2.0, 0.0, 0.0 }, { 0.0, 1.0, -1.0, 1.0 }, { 2.0, 0.0, 1.0, 0.0 } }, new double[] { 7.0, 3.0, 5.0 }); NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); PointValuePair optimum = optimizer.optimize(new MaxEval(100), problem.getObjectiveFunction(), problem.getObjectiveFunctionGradient(), GoalType.MINIMIZE, new InitialGuess(new double[] { 7, 6, 5, 4 })); Assert.assertEquals(0, optimum.getValue(), 1.0e-10); } @Test public void testMoreEstimatedParametersUnsorted() { LinearProblem problem = new LinearProblem(new double[][] { { 1.0, 1.0, 0.0, 0.0, 0.0, 0.0 }, { 0.0, 0.0, 1.0, 1.0, 1.0, 0.0 }, { 0.0, 0.0, 0.0, 0.0, 1.0, -1.0 }, { 0.0, 0.0, -1.0, 1.0, 0.0, 1.0 }, { 0.0, 0.0, 0.0, -1.0, 1.0, 0.0 } }, new double[] { 3.0, 12.0, -1.0, 7.0, 1.0 }); NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); PointValuePair optimum = optimizer.optimize(new MaxEval(100), problem.getObjectiveFunction(), problem.getObjectiveFunctionGradient(), GoalType.MINIMIZE, new InitialGuess(new double[] { 2, 2, 2, 2, 2, 2 })); Assert.assertEquals(0, optimum.getValue(), 1.0e-10); } @Test public void testRedundantEquations() { LinearProblem problem = new LinearProblem(new double[][] { { 1.0, 1.0 }, { 1.0, -1.0 }, { 1.0, 3.0 } }, new double[] { 3.0, 1.0, 5.0 }); NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); PointValuePair optimum = optimizer.optimize(new MaxEval(100), problem.getObjectiveFunction(), problem.getObjectiveFunctionGradient(), GoalType.MINIMIZE, new InitialGuess(new double[] { 1, 1 })); Assert.assertEquals(2.0, optimum.getPoint()[0], 1.0e-8); Assert.assertEquals(1.0, optimum.getPoint()[1], 1.0e-8); } @Test public void testInconsistentEquations() { LinearProblem problem = new LinearProblem(new double[][] { { 1.0, 1.0 }, { 1.0, -1.0 }, { 1.0, 3.0 } }, new double[] { 3.0, 1.0, 4.0 }); NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); PointValuePair optimum = optimizer.optimize(new MaxEval(100), problem.getObjectiveFunction(), problem.getObjectiveFunctionGradient(), GoalType.MINIMIZE, new InitialGuess(new double[] { 1, 1 })); Assert.assertTrue(optimum.getValue() > 0.1); } @Test public void testCircleFitting() { CircleScalar problem = new CircleScalar(); problem.addPoint( 30.0, 68.0); problem.addPoint( 50.0, -6.0); problem.addPoint(110.0, -20.0); problem.addPoint( 35.0, 15.0); problem.addPoint( 45.0, 97.0); NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE, new SimpleValueChecker(1e-30, 1e-30), new BrentSolver(1e-15, 1e-13)); PointValuePair optimum = optimizer.optimize(new MaxEval(100), problem.getObjectiveFunction(), problem.getObjectiveFunctionGradient(), GoalType.MINIMIZE, new InitialGuess(new double[] { 98.680, 47.345 })); Vector2D center = new Vector2D(optimum.getPointRef()[0], optimum.getPointRef()[1]); Assert.assertEquals(69.960161753, problem.getRadius(center), 1.0e-8); Assert.assertEquals(96.075902096, center.getX(), 1.0e-8); Assert.assertEquals(48.135167894, center.getY(), 1.0e-8); } private static class LinearProblem { final RealMatrix factors; final double[] target; public LinearProblem(double[][] factors, double[] target) { this.factors = new BlockRealMatrix(factors); this.target = target; } public ObjectiveFunction getObjectiveFunction() { return new ObjectiveFunction(new MultivariateFunction() { public double value(double[] point) { double[] y = factors.operate(point); double sum = 0; for (int i = 0; i < y.length; ++i) { double ri = y[i] - target[i]; sum += ri * ri; } return sum; } }); } public ObjectiveFunctionGradient getObjectiveFunctionGradient() { return new ObjectiveFunctionGradient(new MultivariateVectorFunction() { public double[] value(double[] point) { double[] r = factors.operate(point); for (int i = 0; i < r.length; ++i) { r[i] -= target[i]; } double[] p = factors.transpose().operate(r); for (int i = 0; i < p.length; ++i) { p[i] *= 2; } return p; } }); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optim.nonlinear.scalar.noderiv; import java.util.Arrays; import java.util.Random; import org.apache.commons.math3.analysis.MultivariateFunction; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.TooManyEvaluationsException; import org.apache.commons.math3.exception.NumberIsTooLargeException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.optim.MaxEval; import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction; import org.apache.commons.math3.optim.nonlinear.scalar.GoalType; import org.apache.commons.math3.optim.PointValuePair; import org.apache.commons.math3.optim.InitialGuess; import org.apache.commons.math3.optim.SimpleBounds; import org.junit.Assert; import org.junit.Ignore; import org.junit.Test; /** * Test for {@link BOBYQAOptimizer}. */ public class BOBYQAOptimizerTest { static final int DIM = 13; @Test(expected=NumberIsTooLargeException.class) public void testInitOutOfBounds() { double[] startPoint = point(DIM, 3); double[][] boundaries = boundaries(DIM, -1, 2); doTest(new Rosen(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 2000, null); } @Test(expected=DimensionMismatchException.class) public void testBoundariesDimensionMismatch() { double[] startPoint = point(DIM, 0.5); double[][] boundaries = boundaries(DIM + 1, -1, 2); doTest(new Rosen(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 2000, null); } @Test(expected=NumberIsTooSmallException.class) public void testProblemDimensionTooSmall() { double[] startPoint = point(1, 0.5); doTest(new Rosen(), startPoint, null, GoalType.MINIMIZE, 1e-13, 1e-6, 2000, null); } @Test(expected=TooManyEvaluationsException.class) public void testMaxEvaluations() { final int lowMaxEval = 2; double[] startPoint = point(DIM, 0.1); double[][] boundaries = null; doTest(new Rosen(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, lowMaxEval, null); } @Test public void testRosen() { double[] startPoint = point(DIM,0.1); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,1.0),0.0); doTest(new Rosen(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 2000, expected); } @Test public void testMaximize() { double[] startPoint = point(DIM,1.0); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),1.0); doTest(new MinusElli(), startPoint, boundaries, GoalType.MAXIMIZE, 2e-10, 5e-6, 1000, expected); boundaries = boundaries(DIM,-0.3,0.3); startPoint = point(DIM,0.1); doTest(new MinusElli(), startPoint, boundaries, GoalType.MAXIMIZE, 2e-10, 5e-6, 1000, expected); } @Test public void testEllipse() { double[] startPoint = point(DIM,1.0); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new Elli(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 1000, expected); } @Test public void testElliRotated() { double[] startPoint = point(DIM,1.0); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new ElliRotated(), startPoint, boundaries, GoalType.MINIMIZE, 1e-12, 1e-6, 10000, expected); } @Test public void testCigar() { double[] startPoint = point(DIM,1.0); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new Cigar(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 100, expected); } @Test public void testTwoAxes() { double[] startPoint = point(DIM,1.0); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new TwoAxes(), startPoint, boundaries, GoalType.MINIMIZE, 2* 1e-13, 1e-6, 100, expected); } @Test public void testCigTab() { double[] startPoint = point(DIM,1.0); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new CigTab(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 5e-5, 100, expected); } @Test public void testSphere() { double[] startPoint = point(DIM,1.0); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new Sphere(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 100, expected); } @Test public void testTablet() { double[] startPoint = point(DIM,1.0); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new Tablet(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 100, expected); } @Test public void testDiffPow() {} // Defects4J: flaky method // @Test // public void testDiffPow() { // double[] startPoint = point(DIM/2,1.0); // double[][] boundaries = null; // PointValuePair expected = // new PointValuePair(point(DIM/2,0.0),0.0); // doTest(new DiffPow(), startPoint, boundaries, // GoalType.MINIMIZE, // 1e-8, 1e-1, 12000, expected); // } @Test public void testSsDiffPow() { double[] startPoint = point(DIM/2,1.0); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM/2,0.0),0.0); doTest(new SsDiffPow(), startPoint, boundaries, GoalType.MINIMIZE, 1e-2, 1.3e-1, 50000, expected); } @Test public void testAckley() {} // Defects4J: flaky method // @Test // public void testAckley() { // double[] startPoint = point(DIM,0.1); // double[][] boundaries = null; // PointValuePair expected = // new PointValuePair(point(DIM,0.0),0.0); // doTest(new Ackley(), startPoint, boundaries, // GoalType.MINIMIZE, // 1e-8, 1e-5, 1000, expected); // } @Test public void testRastrigin() { double[] startPoint = point(DIM,1.0); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new Rastrigin(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 1000, expected); } @Test public void testConstrainedRosen() { double[] startPoint = point(DIM,0.1); double[][] boundaries = boundaries(DIM,-1,2); PointValuePair expected = new PointValuePair(point(DIM,1.0),0.0); doTest(new Rosen(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 2000, expected); } // See MATH-728 // TODO: this test is temporarily disabled for 3.2 release as a bug in Cobertura // makes it run for several hours before completing @Ignore @Test public void testConstrainedRosenWithMoreInterpolationPoints() { final double[] startPoint = point(DIM, 0.1); final double[][] boundaries = boundaries(DIM, -1, 2); final PointValuePair expected = new PointValuePair(point(DIM, 1.0), 0.0); // This should have been 78 because in the code the hard limit is // said to be // ((DIM + 1) * (DIM + 2)) / 2 - (2 * DIM + 1) // i.e. 78 in this case, but the test fails for 48, 59, 62, 63, 64, // 65, 66, ... final int maxAdditionalPoints = 47; for (int num = 1; num <= maxAdditionalPoints; num++) { doTest(new Rosen(), startPoint, boundaries, GoalType.MINIMIZE, 1e-12, 1e-6, 2000, num, expected, "num=" + num); } } /** * @param func Function to optimize. * @param startPoint Starting point. * @param boundaries Upper / lower point limit. * @param goal Minimization or maximization. * @param fTol Tolerance relative error on the objective function. * @param pointTol Tolerance for checking that the optimum is correct. * @param maxEvaluations Maximum number of evaluations. * @param expected Expected point / value. */ private void doTest(MultivariateFunction func, double[] startPoint, double[][] boundaries, GoalType goal, double fTol, double pointTol, int maxEvaluations, PointValuePair expected) { doTest(func, startPoint, boundaries, goal, fTol, pointTol, maxEvaluations, 0, expected, ""); } /** * @param func Function to optimize. * @param startPoint Starting point. * @param boundaries Upper / lower point limit. * @param goal Minimization or maximization. * @param fTol Tolerance relative error on the objective function. * @param pointTol Tolerance for checking that the optimum is correct. * @param maxEvaluations Maximum number of evaluations. * @param additionalInterpolationPoints Number of interpolation to used * in addition to the default (2 * dim + 1). * @param expected Expected point / value. */ private void doTest(MultivariateFunction func, double[] startPoint, double[][] boundaries, GoalType goal, double fTol, double pointTol, int maxEvaluations, int additionalInterpolationPoints, PointValuePair expected, String assertMsg) { // System.out.println(func.getClass().getName() + " BEGIN"); // XXX int dim = startPoint.length; final int numIterpolationPoints = 2 * dim + 1 + additionalInterpolationPoints; BOBYQAOptimizer optim = new BOBYQAOptimizer(numIterpolationPoints); PointValuePair result = boundaries == null ? optim.optimize(new MaxEval(maxEvaluations), new ObjectiveFunction(func), goal, SimpleBounds.unbounded(dim), new InitialGuess(startPoint)) : optim.optimize(new MaxEval(maxEvaluations), new ObjectiveFunction(func), goal, new InitialGuess(startPoint), new SimpleBounds(boundaries[0], boundaries[1])); // System.out.println(func.getClass().getName() + " = " // + optim.getEvaluations() + " f("); // for (double x: result.getPoint()) System.out.print(x + " "); // System.out.println(") = " + result.getValue()); Assert.assertEquals(assertMsg, expected.getValue(), result.getValue(), fTol); for (int i = 0; i < dim; i++) { Assert.assertEquals(expected.getPoint()[i], result.getPoint()[i], pointTol); } // System.out.println(func.getClass().getName() + " END"); // XXX } private static double[] point(int n, double value) { double[] ds = new double[n]; Arrays.fill(ds, value); return ds; } private static double[][] boundaries(int dim, double lower, double upper) { double[][] boundaries = new double[2][dim]; for (int i = 0; i < dim; i++) boundaries[0][i] = lower; for (int i = 0; i < dim; i++) boundaries[1][i] = upper; return boundaries; } private static class Sphere implements MultivariateFunction { public double value(double[] x) { double f = 0; for (int i = 0; i < x.length; ++i) f += x[i] * x[i]; return f; } } private static class Cigar implements MultivariateFunction { private double factor; Cigar() { this(1e3); } Cigar(double axisratio) { factor = axisratio * axisratio; } public double value(double[] x) { double f = x[0] * x[0]; for (int i = 1; i < x.length; ++i) f += factor * x[i] * x[i]; return f; } } private static class Tablet implements MultivariateFunction { private double factor; Tablet() { this(1e3); } Tablet(double axisratio) { factor = axisratio * axisratio; } public double value(double[] x) { double f = factor * x[0] * x[0]; for (int i = 1; i < x.length; ++i) f += x[i] * x[i]; return f; } } private static class CigTab implements MultivariateFunction { private double factor; CigTab() { this(1e4); } CigTab(double axisratio) { factor = axisratio; } public double value(double[] x) { int end = x.length - 1; double f = x[0] * x[0] / factor + factor * x[end] * x[end]; for (int i = 1; i < end; ++i) f += x[i] * x[i]; return f; } } private static class TwoAxes implements MultivariateFunction { private double factor; TwoAxes() { this(1e6); } TwoAxes(double axisratio) { factor = axisratio * axisratio; } public double value(double[] x) { double f = 0; for (int i = 0; i < x.length; ++i) f += (i < x.length / 2 ? factor : 1) * x[i] * x[i]; return f; } } private static class ElliRotated implements MultivariateFunction { private Basis B = new Basis(); private double factor; ElliRotated() { this(1e3); } ElliRotated(double axisratio) { factor = axisratio * axisratio; } public double value(double[] x) { double f = 0; x = B.Rotate(x); for (int i = 0; i < x.length; ++i) f += Math.pow(factor, i / (x.length - 1.)) * x[i] * x[i]; return f; } } private static class Elli implements MultivariateFunction { private double factor; Elli() { this(1e3); } Elli(double axisratio) { factor = axisratio * axisratio; } public double value(double[] x) { double f = 0; for (int i = 0; i < x.length; ++i) f += Math.pow(factor, i / (x.length - 1.)) * x[i] * x[i]; return f; } } private static class MinusElli implements MultivariateFunction { private final Elli elli = new Elli(); public double value(double[] x) { return 1.0 - elli.value(x); } } private static class DiffPow implements MultivariateFunction { // private int fcount = 0; public double value(double[] x) { double f = 0; for (int i = 0; i < x.length; ++i) f += Math.pow(Math.abs(x[i]), 2. + 10 * (double) i / (x.length - 1.)); // System.out.print("" + (fcount++) + ") "); // for (int i = 0; i < x.length; i++) // System.out.print(x[i] + " "); // System.out.println(" = " + f); return f; } } private static class SsDiffPow implements MultivariateFunction { public double value(double[] x) { double f = Math.pow(new DiffPow().value(x), 0.25); return f; } } private static class Rosen implements MultivariateFunction { public double value(double[] x) { double f = 0; for (int i = 0; i < x.length - 1; ++i) f += 1e2 * (x[i] * x[i] - x[i + 1]) * (x[i] * x[i] - x[i + 1]) + (x[i] - 1.) * (x[i] - 1.); return f; } } private static class Ackley implements MultivariateFunction { private double axisratio; Ackley(double axra) { axisratio = axra; } public Ackley() { this(1); } public double value(double[] x) { double f = 0; double res2 = 0; double fac = 0; for (int i = 0; i < x.length; ++i) { fac = Math.pow(axisratio, (i - 1.) / (x.length - 1.)); f += fac * fac * x[i] * x[i]; res2 += Math.cos(2. * Math.PI * fac * x[i]); } f = (20. - 20. * Math.exp(-0.2 * Math.sqrt(f / x.length)) + Math.exp(1.) - Math.exp(res2 / x.length)); return f; } } private static class Rastrigin implements MultivariateFunction { private double axisratio; private double amplitude; Rastrigin() { this(1, 10); } Rastrigin(double axisratio, double amplitude) { this.axisratio = axisratio; this.amplitude = amplitude; } public double value(double[] x) { double f = 0; double fac; for (int i = 0; i < x.length; ++i) { fac = Math.pow(axisratio, (i - 1.) / (x.length - 1.)); if (i == 0 && x[i] < 0) fac *= 1.; f += fac * fac * x[i] * x[i] + amplitude * (1. - Math.cos(2. * Math.PI * fac * x[i])); } return f; } } private static class Basis { double[][] basis; Random rand = new Random(2); // use not always the same basis double[] Rotate(double[] x) { GenBasis(x.length); double[] y = new double[x.length]; for (int i = 0; i < x.length; ++i) { y[i] = 0; for (int j = 0; j < x.length; ++j) y[i] += basis[i][j] * x[j]; } return y; } void GenBasis(int DIM) { if (basis != null ? basis.length == DIM : false) return; double sp; int i, j, k; /* generate orthogonal basis */ basis = new double[DIM][DIM]; for (i = 0; i < DIM; ++i) { /* sample components gaussian */ for (j = 0; j < DIM; ++j) basis[i][j] = rand.nextGaussian(); /* substract projection of previous vectors */ for (j = i - 1; j >= 0; --j) { for (sp = 0., k = 0; k < DIM; ++k) sp += basis[i][k] * basis[j][k]; /* scalar product */ for (k = 0; k < DIM; ++k) basis[i][k] -= sp * basis[j][k]; /* substract */ } /* normalize */ for (sp = 0., k = 0; k < DIM; ++k) sp += basis[i][k] * basis[i][k]; /* squared norm */ for (k = 0; k < DIM; ++k) basis[i][k] /= Math.sqrt(sp); } } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optim.nonlinear.scalar.noderiv; import java.util.Arrays; import java.util.Random; import org.apache.commons.math3.Retry; import org.apache.commons.math3.RetryRunner; import org.apache.commons.math3.analysis.MultivariateFunction; import org.apache.commons.math3.exception.NumberIsTooLargeException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.NotPositiveException; import org.apache.commons.math3.exception.OutOfRangeException; import org.apache.commons.math3.optim.nonlinear.scalar.GoalType; import org.apache.commons.math3.optim.PointValuePair; import org.apache.commons.math3.optim.InitialGuess; import org.apache.commons.math3.optim.SimpleBounds; import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction; import org.apache.commons.math3.optim.MaxEval; import org.apache.commons.math3.random.MersenneTwister; import org.junit.Assert; import org.junit.Test; import org.junit.runner.RunWith; /** * Test for {@link CMAESOptimizer}. */ @RunWith(RetryRunner.class) public class CMAESOptimizerTest { static final int DIM = 13; static final int LAMBDA = 4 + (int)(3.*Math.log(DIM)); @Test(expected = NumberIsTooLargeException.class) public void testInitOutofbounds1() { double[] startPoint = point(DIM,3); double[] insigma = point(DIM, 0.3); double[][] boundaries = boundaries(DIM,-1,2); PointValuePair expected = new PointValuePair(point(DIM,1.0),0.0); doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); } @Test(expected = NumberIsTooSmallException.class) public void testInitOutofbounds2() { double[] startPoint = point(DIM, -2); double[] insigma = point(DIM, 0.3); double[][] boundaries = boundaries(DIM,-1,2); PointValuePair expected = new PointValuePair(point(DIM,1.0),0.0); doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); } @Test(expected = DimensionMismatchException.class) public void testBoundariesDimensionMismatch() { double[] startPoint = point(DIM,0.5); double[] insigma = point(DIM, 0.3); double[][] boundaries = boundaries(DIM+1,-1,2); PointValuePair expected = new PointValuePair(point(DIM,1.0),0.0); doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); } @Test(expected = NotPositiveException.class) public void testInputSigmaNegative() { double[] startPoint = point(DIM,0.5); double[] insigma = point(DIM,-0.5); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,1.0),0.0); doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); } @Test(expected = OutOfRangeException.class) public void testInputSigmaOutOfRange() { double[] startPoint = point(DIM,0.5); double[] insigma = point(DIM, 1.1); double[][] boundaries = boundaries(DIM,-0.5,0.5); PointValuePair expected = new PointValuePair(point(DIM,1.0),0.0); doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); } @Test(expected = DimensionMismatchException.class) public void testInputSigmaDimensionMismatch() { double[] startPoint = point(DIM,0.5); double[] insigma = point(DIM + 1, 0.5); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,1.0),0.0); doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); } @Test @Retry(3) public void testRosen() { double[] startPoint = point(DIM,0.1); double[] insigma = point(DIM,0.1); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,1.0),0.0); doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13, 1e-13, 1e-6, 100000, expected); } @Test @Retry(3) public void testMaximize() { double[] startPoint = point(DIM,1.0); double[] insigma = point(DIM,0.1); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),1.0); doTest(new MinusElli(), startPoint, insigma, boundaries, GoalType.MAXIMIZE, LAMBDA, true, 0, 1.0-1e-13, 2e-10, 5e-6, 100000, expected); doTest(new MinusElli(), startPoint, insigma, boundaries, GoalType.MAXIMIZE, LAMBDA, false, 0, 1.0-1e-13, 2e-10, 5e-6, 100000, expected); boundaries = boundaries(DIM,-0.3,0.3); startPoint = point(DIM,0.1); doTest(new MinusElli(), startPoint, insigma, boundaries, GoalType.MAXIMIZE, LAMBDA, true, 0, 1.0-1e-13, 2e-10, 5e-6, 100000, expected); } @Test public void testEllipse() { double[] startPoint = point(DIM,1.0); double[] insigma = point(DIM,0.1); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new Elli(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); doTest(new Elli(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13, 1e-13, 1e-6, 100000, expected); } @Test public void testElliRotated() { double[] startPoint = point(DIM,1.0); double[] insigma = point(DIM,0.1); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new ElliRotated(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); doTest(new ElliRotated(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13, 1e-13, 1e-6, 100000, expected); } @Test public void testCigar() { double[] startPoint = point(DIM,1.0); double[] insigma = point(DIM,0.1); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new Cigar(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 200000, expected); doTest(new Cigar(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13, 1e-13, 1e-6, 100000, expected); } @Test public void testCigarWithBoundaries() { double[] startPoint = point(DIM,1.0); double[] insigma = point(DIM,0.1); double[][] boundaries = boundaries(DIM, -1e100, Double.POSITIVE_INFINITY); PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new Cigar(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 200000, expected); doTest(new Cigar(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13, 1e-13, 1e-6, 100000, expected); } @Test public void testTwoAxes() { double[] startPoint = point(DIM,1.0); double[] insigma = point(DIM,0.1); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new TwoAxes(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 2*LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 200000, expected); doTest(new TwoAxes(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 2*LAMBDA, false, 0, 1e-13, 1e-8, 1e-3, 200000, expected); } @Test public void testCigTab() { double[] startPoint = point(DIM,1.0); double[] insigma = point(DIM,0.3); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new CigTab(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 5e-5, 100000, expected); doTest(new CigTab(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13, 1e-13, 5e-5, 100000, expected); } @Test public void testSphere() { double[] startPoint = point(DIM,1.0); double[] insigma = point(DIM,0.1); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new Sphere(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); doTest(new Sphere(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13, 1e-13, 1e-6, 100000, expected); } @Test public void testTablet() { double[] startPoint = point(DIM,1.0); double[] insigma = point(DIM,0.1); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new Tablet(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); doTest(new Tablet(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13, 1e-13, 1e-6, 100000, expected); } @Test public void testDiffPow() { double[] startPoint = point(DIM,1.0); double[] insigma = point(DIM,0.1); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new DiffPow(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 10, true, 0, 1e-13, 1e-8, 1e-1, 100000, expected); doTest(new DiffPow(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 10, false, 0, 1e-13, 1e-8, 2e-1, 100000, expected); } @Test public void testSsDiffPow() { double[] startPoint = point(DIM,1.0); double[] insigma = point(DIM,0.1); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new SsDiffPow(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 10, true, 0, 1e-13, 1e-4, 1e-1, 200000, expected); doTest(new SsDiffPow(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 10, false, 0, 1e-13, 1e-4, 1e-1, 200000, expected); } @Test public void testAckley() { double[] startPoint = point(DIM,1.0); double[] insigma = point(DIM,1.0); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new Ackley(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 2*LAMBDA, true, 0, 1e-13, 1e-9, 1e-5, 100000, expected); doTest(new Ackley(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 2*LAMBDA, false, 0, 1e-13, 1e-9, 1e-5, 100000, expected); } @Test public void testRastrigin() { double[] startPoint = point(DIM,0.1); double[] insigma = point(DIM,0.1); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new Rastrigin(), startPoint, insigma, boundaries, GoalType.MINIMIZE, (int)(200*Math.sqrt(DIM)), true, 0, 1e-13, 1e-13, 1e-6, 200000, expected); doTest(new Rastrigin(), startPoint, insigma, boundaries, GoalType.MINIMIZE, (int)(200*Math.sqrt(DIM)), false, 0, 1e-13, 1e-13, 1e-6, 200000, expected); } @Test public void testConstrainedRosen() { double[] startPoint = point(DIM, 0.1); double[] insigma = point(DIM, 0.1); double[][] boundaries = boundaries(DIM, -1, 2); PointValuePair expected = new PointValuePair(point(DIM,1.0),0.0); doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 2*LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 2*LAMBDA, false, 0, 1e-13, 1e-13, 1e-6, 100000, expected); } @Test public void testDiagonalRosen() { double[] startPoint = point(DIM,0.1); double[] insigma = point(DIM,0.1); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,1.0),0.0); doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 1, 1e-13, 1e-10, 1e-4, 1000000, expected); } @Test public void testMath864() { final CMAESOptimizer optimizer = new CMAESOptimizer(30000, 0, true, 10, 0, new MersenneTwister(), false, null); final MultivariateFunction fitnessFunction = new MultivariateFunction() { public double value(double[] parameters) { final double target = 1; final double error = target - parameters[0]; return error * error; } }; final double[] start = { 0 }; final double[] lower = { -1e6 }; final double[] upper = { 1.5 }; final double[] sigma = { 1e-1 }; final double[] result = optimizer.optimize(new MaxEval(10000), new ObjectiveFunction(fitnessFunction), GoalType.MINIMIZE, new CMAESOptimizer.PopulationSize(5), new CMAESOptimizer.Sigma(sigma), new InitialGuess(start), new SimpleBounds(lower, upper)).getPoint(); Assert.assertTrue("Out of bounds (" + result[0] + " > " + upper[0] + ")", result[0] <= upper[0]); } /** * Cf. MATH-867 */ @Test public void testFitAccuracyDependsOnBoundary() { final CMAESOptimizer optimizer = new CMAESOptimizer(30000, 0, true, 10, 0, new MersenneTwister(), false, null); final MultivariateFunction fitnessFunction = new MultivariateFunction() { public double value(double[] parameters) { final double target = 11.1; final double error = target - parameters[0]; return error * error; } }; final double[] start = { 1 }; // No bounds. PointValuePair result = optimizer.optimize(new MaxEval(100000), new ObjectiveFunction(fitnessFunction), GoalType.MINIMIZE, SimpleBounds.unbounded(1), new CMAESOptimizer.PopulationSize(5), new CMAESOptimizer.Sigma(new double[] { 1e-1 }), new InitialGuess(start)); final double resNoBound = result.getPoint()[0]; // Optimum is near the lower bound. final double[] lower = { -20 }; final double[] upper = { 5e16 }; final double[] sigma = { 10 }; result = optimizer.optimize(new MaxEval(100000), new ObjectiveFunction(fitnessFunction), GoalType.MINIMIZE, new CMAESOptimizer.PopulationSize(5), new CMAESOptimizer.Sigma(sigma), new InitialGuess(start), new SimpleBounds(lower, upper)); final double resNearLo = result.getPoint()[0]; // Optimum is near the upper bound. lower[0] = -5e16; upper[0] = 20; result = optimizer.optimize(new MaxEval(100000), new ObjectiveFunction(fitnessFunction), GoalType.MINIMIZE, new CMAESOptimizer.PopulationSize(5), new CMAESOptimizer.Sigma(sigma), new InitialGuess(start), new SimpleBounds(lower, upper)); final double resNearHi = result.getPoint()[0]; // System.out.println("resNoBound=" + resNoBound + // " resNearLo=" + resNearLo + // " resNearHi=" + resNearHi); // The two values currently differ by a substantial amount, indicating that // the bounds definition can prevent reaching the optimum. Assert.assertEquals(resNoBound, resNearLo, 1e-3); Assert.assertEquals(resNoBound, resNearHi, 1e-3); } /** * @param func Function to optimize. * @param startPoint Starting point. * @param inSigma Individual input sigma. * @param boundaries Upper / lower point limit. * @param goal Minimization or maximization. * @param lambda Population size used for offspring. * @param isActive Covariance update mechanism. * @param diagonalOnly Simplified covariance update. * @param stopValue Termination criteria for optimization. * @param fTol Tolerance relative error on the objective function. * @param pointTol Tolerance for checking that the optimum is correct. * @param maxEvaluations Maximum number of evaluations. * @param expected Expected point / value. */ private void doTest(MultivariateFunction func, double[] startPoint, double[] inSigma, double[][] boundaries, GoalType goal, int lambda, boolean isActive, int diagonalOnly, double stopValue, double fTol, double pointTol, int maxEvaluations, PointValuePair expected) { int dim = startPoint.length; // test diagonalOnly = 0 - slow but normally fewer feval# CMAESOptimizer optim = new CMAESOptimizer(30000, stopValue, isActive, diagonalOnly, 0, new MersenneTwister(), false, null); PointValuePair result = boundaries == null ? optim.optimize(new MaxEval(maxEvaluations), new ObjectiveFunction(func), goal, new InitialGuess(startPoint), SimpleBounds.unbounded(dim), new CMAESOptimizer.Sigma(inSigma), new CMAESOptimizer.PopulationSize(lambda)) : optim.optimize(new MaxEval(maxEvaluations), new ObjectiveFunction(func), goal, new SimpleBounds(boundaries[0], boundaries[1]), new InitialGuess(startPoint), new CMAESOptimizer.Sigma(inSigma), new CMAESOptimizer.PopulationSize(lambda)); // System.out.println("sol=" + Arrays.toString(result.getPoint())); Assert.assertEquals(expected.getValue(), result.getValue(), fTol); for (int i = 0; i < dim; i++) { Assert.assertEquals(expected.getPoint()[i], result.getPoint()[i], pointTol); } Assert.assertTrue(optim.getIterations() > 0); } private static double[] point(int n, double value) { double[] ds = new double[n]; Arrays.fill(ds, value); return ds; } private static double[][] boundaries(int dim, double lower, double upper) { double[][] boundaries = new double[2][dim]; for (int i = 0; i < dim; i++) boundaries[0][i] = lower; for (int i = 0; i < dim; i++) boundaries[1][i] = upper; return boundaries; } private static class Sphere implements MultivariateFunction { public double value(double[] x) { double f = 0; for (int i = 0; i < x.length; ++i) f += x[i] * x[i]; return f; } } private static class Cigar implements MultivariateFunction { private double factor; Cigar() { this(1e3); } Cigar(double axisratio) { factor = axisratio * axisratio; } public double value(double[] x) { double f = x[0] * x[0]; for (int i = 1; i < x.length; ++i) f += factor * x[i] * x[i]; return f; } } private static class Tablet implements MultivariateFunction { private double factor; Tablet() { this(1e3); } Tablet(double axisratio) { factor = axisratio * axisratio; } public double value(double[] x) { double f = factor * x[0] * x[0]; for (int i = 1; i < x.length; ++i) f += x[i] * x[i]; return f; } } private static class CigTab implements MultivariateFunction { private double factor; CigTab() { this(1e4); } CigTab(double axisratio) { factor = axisratio; } public double value(double[] x) { int end = x.length - 1; double f = x[0] * x[0] / factor + factor * x[end] * x[end]; for (int i = 1; i < end; ++i) f += x[i] * x[i]; return f; } } private static class TwoAxes implements MultivariateFunction { private double factor; TwoAxes() { this(1e6); } TwoAxes(double axisratio) { factor = axisratio * axisratio; } public double value(double[] x) { double f = 0; for (int i = 0; i < x.length; ++i) f += (i < x.length / 2 ? factor : 1) * x[i] * x[i]; return f; } } private static class ElliRotated implements MultivariateFunction { private Basis B = new Basis(); private double factor; ElliRotated() { this(1e3); } ElliRotated(double axisratio) { factor = axisratio * axisratio; } public double value(double[] x) { double f = 0; x = B.Rotate(x); for (int i = 0; i < x.length; ++i) f += Math.pow(factor, i / (x.length - 1.)) * x[i] * x[i]; return f; } } private static class Elli implements MultivariateFunction { private double factor; Elli() { this(1e3); } Elli(double axisratio) { factor = axisratio * axisratio; } public double value(double[] x) { double f = 0; for (int i = 0; i < x.length; ++i) f += Math.pow(factor, i / (x.length - 1.)) * x[i] * x[i]; return f; } } private static class MinusElli implements MultivariateFunction { public double value(double[] x) { return 1.0-(new Elli().value(x)); } } private static class DiffPow implements MultivariateFunction { public double value(double[] x) { double f = 0; for (int i = 0; i < x.length; ++i) f += Math.pow(Math.abs(x[i]), 2. + 10 * (double) i / (x.length - 1.)); return f; } } private static class SsDiffPow implements MultivariateFunction { public double value(double[] x) { double f = Math.pow(new DiffPow().value(x), 0.25); return f; } } private static class Rosen implements MultivariateFunction { public double value(double[] x) { double f = 0; for (int i = 0; i < x.length - 1; ++i) f += 1e2 * (x[i] * x[i] - x[i + 1]) * (x[i] * x[i] - x[i + 1]) + (x[i] - 1.) * (x[i] - 1.); return f; } } private static class Ackley implements MultivariateFunction { private double axisratio; Ackley(double axra) { axisratio = axra; } public Ackley() { this(1); } public double value(double[] x) { double f = 0; double res2 = 0; double fac = 0; for (int i = 0; i < x.length; ++i) { fac = Math.pow(axisratio, (i - 1.) / (x.length - 1.)); f += fac * fac * x[i] * x[i]; res2 += Math.cos(2. * Math.PI * fac * x[i]); } f = (20. - 20. * Math.exp(-0.2 * Math.sqrt(f / x.length)) + Math.exp(1.) - Math.exp(res2 / x.length)); return f; } } private static class Rastrigin implements MultivariateFunction { private double axisratio; private double amplitude; Rastrigin() { this(1, 10); } Rastrigin(double axisratio, double amplitude) { this.axisratio = axisratio; this.amplitude = amplitude; } public double value(double[] x) { double f = 0; double fac; for (int i = 0; i < x.length; ++i) { fac = Math.pow(axisratio, (i - 1.) / (x.length - 1.)); if (i == 0 && x[i] < 0) fac *= 1.; f += fac * fac * x[i] * x[i] + amplitude * (1. - Math.cos(2. * Math.PI * fac * x[i])); } return f; } } private static class Basis { double[][] basis; Random rand = new Random(2); // use not always the same basis double[] Rotate(double[] x) { GenBasis(x.length); double[] y = new double[x.length]; for (int i = 0; i < x.length; ++i) { y[i] = 0; for (int j = 0; j < x.length; ++j) y[i] += basis[i][j] * x[j]; } return y; } void GenBasis(int DIM) { if (basis != null ? basis.length == DIM : false) return; double sp; int i, j, k; /* generate orthogonal basis */ basis = new double[DIM][DIM]; for (i = 0; i < DIM; ++i) { /* sample components gaussian */ for (j = 0; j < DIM; ++j) basis[i][j] = rand.nextGaussian(); /* substract projection of previous vectors */ for (j = i - 1; j >= 0; --j) { for (sp = 0., k = 0; k < DIM; ++k) sp += basis[i][k] * basis[j][k]; /* scalar product */ for (k = 0; k < DIM; ++k) basis[i][k] -= sp * basis[j][k]; /* substract */ } /* normalize */ for (sp = 0., k = 0; k < DIM; ++k) sp += basis[i][k] * basis[i][k]; /* squared norm */ for (k = 0; k < DIM; ++k) basis[i][k] /= Math.sqrt(sp); } } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optim.nonlinear.scalar.noderiv; import org.apache.commons.math3.analysis.MultivariateFunction; import org.apache.commons.math3.analysis.SumSincFunction; import org.apache.commons.math3.optim.PointValuePair; import org.apache.commons.math3.optim.InitialGuess; import org.apache.commons.math3.optim.MaxEval; import org.apache.commons.math3.optim.SimpleBounds; import org.apache.commons.math3.optim.nonlinear.scalar.GoalType; import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction; import org.apache.commons.math3.exception.MathUnsupportedOperationException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * Test for {@link PowellOptimizer}. */ public class PowellOptimizerTest { @Test(expected=MathUnsupportedOperationException.class) public void testBoundsUnsupported() { final MultivariateFunction func = new SumSincFunction(-1); final PowellOptimizer optim = new PowellOptimizer(1e-8, 1e-5, 1e-4, 1e-4); optim.optimize(new MaxEval(100), new ObjectiveFunction(func), GoalType.MINIMIZE, new InitialGuess(new double[] { -3, 0 }), new SimpleBounds(new double[] { -5, -1 }, new double[] { 5, 1 })); } @Test public void testSumSinc() { final MultivariateFunction func = new SumSincFunction(-1); int dim = 2; final double[] minPoint = new double[dim]; for (int i = 0; i < dim; i++) { minPoint[i] = 0; } double[] init = new double[dim]; // Initial is minimum. for (int i = 0; i < dim; i++) { init[i] = minPoint[i]; } doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-9); // Initial is far from minimum. for (int i = 0; i < dim; i++) { init[i] = minPoint[i] + 3; } doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-5); // More stringent line search tolerance enhances the precision // of the result. doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-9, 1e-7); } @Test public void testQuadratic() { final MultivariateFunction func = new MultivariateFunction() { public double value(double[] x) { final double a = x[0] - 1; final double b = x[1] - 1; return a * a + b * b + 1; } }; int dim = 2; final double[] minPoint = new double[dim]; for (int i = 0; i < dim; i++) { minPoint[i] = 1; } double[] init = new double[dim]; // Initial is minimum. for (int i = 0; i < dim; i++) { init[i] = minPoint[i]; } doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-8); // Initial is far from minimum. for (int i = 0; i < dim; i++) { init[i] = minPoint[i] - 20; } doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-8); } @Test public void testMaximizeQuadratic() { final MultivariateFunction func = new MultivariateFunction() { public double value(double[] x) { final double a = x[0] - 1; final double b = x[1] - 1; return -a * a - b * b + 1; } }; int dim = 2; final double[] maxPoint = new double[dim]; for (int i = 0; i < dim; i++) { maxPoint[i] = 1; } double[] init = new double[dim]; // Initial is minimum. for (int i = 0; i < dim; i++) { init[i] = maxPoint[i]; } doTest(func, maxPoint, init, GoalType.MAXIMIZE, 1e-9, 1e-8); // Initial is far from minimum. for (int i = 0; i < dim; i++) { init[i] = maxPoint[i] - 20; } doTest(func, maxPoint, init, GoalType.MAXIMIZE, 1e-9, 1e-8); } /** * Ensure that we do not increase the number of function evaluations when * the function values are scaled up. * Note that the tolerances parameters passed to the constructor must * still hold sensible values because they are used to set the line search * tolerances. */ @Test public void testRelativeToleranceOnScaledValues() { final MultivariateFunction func = new MultivariateFunction() { public double value(double[] x) { final double a = x[0] - 1; final double b = x[1] - 1; return a * a * FastMath.sqrt(FastMath.abs(a)) + b * b + 1; } }; int dim = 2; final double[] minPoint = new double[dim]; for (int i = 0; i < dim; i++) { minPoint[i] = 1; } double[] init = new double[dim]; // Initial is far from minimum. for (int i = 0; i < dim; i++) { init[i] = minPoint[i] - 20; } final double relTol = 1e-10; final int maxEval = 1000; // Very small absolute tolerance to rely solely on the relative // tolerance as a stopping criterion final PowellOptimizer optim = new PowellOptimizer(relTol, 1e-100); final PointValuePair funcResult = optim.optimize(new MaxEval(maxEval), new ObjectiveFunction(func), GoalType.MINIMIZE, new InitialGuess(init)); final double funcValue = func.value(funcResult.getPoint()); final int funcEvaluations = optim.getEvaluations(); final double scale = 1e10; final MultivariateFunction funcScaled = new MultivariateFunction() { public double value(double[] x) { return scale * func.value(x); } }; final PointValuePair funcScaledResult = optim.optimize(new MaxEval(maxEval), new ObjectiveFunction(funcScaled), GoalType.MINIMIZE, new InitialGuess(init)); final double funcScaledValue = funcScaled.value(funcScaledResult.getPoint()); final int funcScaledEvaluations = optim.getEvaluations(); // Check that both minima provide the same objective funciton values, // within the relative function tolerance. Assert.assertEquals(1, funcScaledValue / (scale * funcValue), relTol); // Check that the numbers of evaluations are the same. Assert.assertEquals(funcEvaluations, funcScaledEvaluations); } /** * @param func Function to optimize. * @param optimum Expected optimum. * @param init Starting point. * @param goal Minimization or maximization. * @param fTol Tolerance (relative error on the objective function) for * "Powell" algorithm. * @param pointTol Tolerance for checking that the optimum is correct. */ private void doTest(MultivariateFunction func, double[] optimum, double[] init, GoalType goal, double fTol, double pointTol) { final PowellOptimizer optim = new PowellOptimizer(fTol, Math.ulp(1d)); final PointValuePair result = optim.optimize(new MaxEval(1000), new ObjectiveFunction(func), goal, new InitialGuess(init)); final double[] point = result.getPoint(); for (int i = 0, dim = optimum.length; i < dim; i++) { Assert.assertEquals("found[" + i + "]=" + point[i] + " value=" + result.getValue(), optimum[i], point[i], pointTol); } } /** * @param func Function to optimize. * @param optimum Expected optimum. * @param init Starting point. * @param goal Minimization or maximization. * @param fTol Tolerance (relative error on the objective function) for * "Powell" algorithm. * @param fLineTol Tolerance (relative error on the objective function) * for the internal line search algorithm. * @param pointTol Tolerance for checking that the optimum is correct. */ private void doTest(MultivariateFunction func, double[] optimum, double[] init, GoalType goal, double fTol, double fLineTol, double pointTol) { final PowellOptimizer optim = new PowellOptimizer(fTol, Math.ulp(1d), fLineTol, Math.ulp(1d)); final PointValuePair result = optim.optimize(new MaxEval(1000), new ObjectiveFunction(func), goal, new InitialGuess(init)); final double[] point = result.getPoint(); for (int i = 0, dim = optimum.length; i < dim; i++) { Assert.assertEquals("found[" + i + "]=" + point[i] + " value=" + result.getValue(), optimum[i], point[i], pointTol); } Assert.assertTrue(optim.getIterations() > 0); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optim.nonlinear.scalar.noderiv; import org.apache.commons.math3.analysis.MultivariateFunction; import org.apache.commons.math3.optim.MaxEval; import org.apache.commons.math3.optim.InitialGuess; import org.apache.commons.math3.optim.PointValuePair; import org.apache.commons.math3.optim.SimpleValueChecker; import org.apache.commons.math3.optim.SimpleBounds; import org.apache.commons.math3.optim.nonlinear.scalar.GoalType; import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction; import org.apache.commons.math3.exception.MathUnsupportedOperationException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class SimplexOptimizerMultiDirectionalTest { @Test(expected=MathUnsupportedOperationException.class) public void testBoundsUnsupported() { SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); optimizer.optimize(new MaxEval(100), new ObjectiveFunction(fourExtrema), GoalType.MINIMIZE, new InitialGuess(new double[] { -3, 0 }), new NelderMeadSimplex(new double[] { 0.2, 0.2 }), new SimpleBounds(new double[] { -5, -1 }, new double[] { 5, 1 })); } @Test public void testMinimize1() { SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(200), new ObjectiveFunction(fourExtrema), GoalType.MINIMIZE, new InitialGuess(new double[] { -3, 0 }), new MultiDirectionalSimplex(new double[] { 0.2, 0.2 })); Assert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 4e-6); Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 3e-6); Assert.assertEquals(fourExtrema.valueXmYp, optimum.getValue(), 8e-13); Assert.assertTrue(optimizer.getEvaluations() > 120); Assert.assertTrue(optimizer.getEvaluations() < 150); // Check that the number of iterations is updated (MATH-949). Assert.assertTrue(optimizer.getIterations() > 0); } @Test public void testMinimize2() { SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(200), new ObjectiveFunction(fourExtrema), GoalType.MINIMIZE, new InitialGuess(new double[] { 1, 0 }), new MultiDirectionalSimplex(new double[] { 0.2, 0.2 })); Assert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 2e-8); Assert.assertEquals(fourExtrema.yM, optimum.getPoint()[1], 3e-6); Assert.assertEquals(fourExtrema.valueXpYm, optimum.getValue(), 2e-12); Assert.assertTrue(optimizer.getEvaluations() > 120); Assert.assertTrue(optimizer.getEvaluations() < 150); // Check that the number of iterations is updated (MATH-949). Assert.assertTrue(optimizer.getIterations() > 0); } @Test public void testMaximize1() { SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(200), new ObjectiveFunction(fourExtrema), GoalType.MAXIMIZE, new InitialGuess(new double[] { -3.0, 0.0 }), new MultiDirectionalSimplex(new double[] { 0.2, 0.2 })); Assert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 7e-7); Assert.assertEquals(fourExtrema.yM, optimum.getPoint()[1], 3e-7); Assert.assertEquals(fourExtrema.valueXmYm, optimum.getValue(), 2e-14); Assert.assertTrue(optimizer.getEvaluations() > 120); Assert.assertTrue(optimizer.getEvaluations() < 150); // Check that the number of iterations is updated (MATH-949). Assert.assertTrue(optimizer.getIterations() > 0); } @Test public void testMaximize2() { SimplexOptimizer optimizer = new SimplexOptimizer(new SimpleValueChecker(1e-15, 1e-30)); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(200), new ObjectiveFunction(fourExtrema), GoalType.MAXIMIZE, new InitialGuess(new double[] { 1, 0 }), new MultiDirectionalSimplex(new double[] { 0.2, 0.2 })); Assert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 2e-8); Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 3e-6); Assert.assertEquals(fourExtrema.valueXpYp, optimum.getValue(), 2e-12); Assert.assertTrue(optimizer.getEvaluations() > 180); Assert.assertTrue(optimizer.getEvaluations() < 220); // Check that the number of iterations is updated (MATH-949). Assert.assertTrue(optimizer.getIterations() > 0); } @Test public void testRosenbrock() { MultivariateFunction rosenbrock = new MultivariateFunction() { public double value(double[] x) { ++count; double a = x[1] - x[0] * x[0]; double b = 1.0 - x[0]; return 100 * a * a + b * b; } }; count = 0; SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3); PointValuePair optimum = optimizer.optimize(new MaxEval(100), new ObjectiveFunction(rosenbrock), GoalType.MINIMIZE, new InitialGuess(new double[] { -1.2, 1 }), new MultiDirectionalSimplex(new double[][] { { -1.2, 1.0 }, { 0.9, 1.2 }, { 3.5, -2.3 } })); Assert.assertEquals(count, optimizer.getEvaluations()); Assert.assertTrue(optimizer.getEvaluations() > 50); Assert.assertTrue(optimizer.getEvaluations() < 100); Assert.assertTrue(optimum.getValue() > 1e-2); } @Test public void testPowell() { MultivariateFunction powell = new MultivariateFunction() { public double value(double[] x) { ++count; double a = x[0] + 10 * x[1]; double b = x[2] - x[3]; double c = x[1] - 2 * x[2]; double d = x[0] - x[3]; return a * a + 5 * b * b + c * c * c * c + 10 * d * d * d * d; } }; count = 0; SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3); PointValuePair optimum = optimizer.optimize(new MaxEval(1000), new ObjectiveFunction(powell), GoalType.MINIMIZE, new InitialGuess(new double[] { 3, -1, 0, 1 }), new MultiDirectionalSimplex(4)); Assert.assertEquals(count, optimizer.getEvaluations()); Assert.assertTrue(optimizer.getEvaluations() > 800); Assert.assertTrue(optimizer.getEvaluations() < 900); Assert.assertTrue(optimum.getValue() > 1e-2); } @Test public void testMath283() { // fails because MultiDirectional.iterateSimplex is looping forever // the while(true) should be replaced with a convergence check SimplexOptimizer optimizer = new SimplexOptimizer(1e-14, 1e-14); final Gaussian2D function = new Gaussian2D(0, 0, 1); PointValuePair estimate = optimizer.optimize(new MaxEval(1000), new ObjectiveFunction(function), GoalType.MAXIMIZE, new InitialGuess(function.getMaximumPosition()), new MultiDirectionalSimplex(2)); final double EPSILON = 1e-5; final double expectedMaximum = function.getMaximum(); final double actualMaximum = estimate.getValue(); Assert.assertEquals(expectedMaximum, actualMaximum, EPSILON); final double[] expectedPosition = function.getMaximumPosition(); final double[] actualPosition = estimate.getPoint(); Assert.assertEquals(expectedPosition[0], actualPosition[0], EPSILON ); Assert.assertEquals(expectedPosition[1], actualPosition[1], EPSILON ); } private static class FourExtrema implements MultivariateFunction { // The following function has 4 local extrema. final double xM = -3.841947088256863675365; final double yM = -1.391745200270734924416; final double xP = 0.2286682237349059125691; final double yP = -yM; final double valueXmYm = 0.2373295333134216789769; // Local maximum. final double valueXmYp = -valueXmYm; // Local minimum. final double valueXpYm = -0.7290400707055187115322; // Global minimum. final double valueXpYp = -valueXpYm; // Global maximum. public double value(double[] variables) { final double x = variables[0]; final double y = variables[1]; return (x == 0 || y == 0) ? 0 : FastMath.atan(x) * FastMath.atan(x + 2) * FastMath.atan(y) * FastMath.atan(y) / (x * y); } } private static class Gaussian2D implements MultivariateFunction { private final double[] maximumPosition; private final double std; public Gaussian2D(double xOpt, double yOpt, double std) { maximumPosition = new double[] { xOpt, yOpt }; this.std = std; } public double getMaximum() { return value(maximumPosition); } public double[] getMaximumPosition() { return maximumPosition.clone(); } public double value(double[] point) { final double x = point[0], y = point[1]; final double twoS2 = 2.0 * std * std; return 1.0 / (twoS2 * FastMath.PI) * FastMath.exp(-(x * x + y * y) / twoS2); } } private int count; }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optim.nonlinear.scalar.noderiv; import org.apache.commons.math3.exception.TooManyEvaluationsException; import org.apache.commons.math3.exception.MathUnsupportedOperationException; import org.apache.commons.math3.analysis.MultivariateFunction; import org.apache.commons.math3.analysis.MultivariateVectorFunction; import org.apache.commons.math3.linear.Array2DRowRealMatrix; import org.apache.commons.math3.linear.RealMatrix; import org.apache.commons.math3.optim.InitialGuess; import org.apache.commons.math3.optim.MaxEval; import org.apache.commons.math3.optim.SimpleBounds; import org.apache.commons.math3.optim.PointValuePair; import org.apache.commons.math3.optim.nonlinear.scalar.GoalType; import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction; import org.apache.commons.math3.optim.nonlinear.scalar.LeastSquaresConverter; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class SimplexOptimizerNelderMeadTest { @Test(expected=MathUnsupportedOperationException.class) public void testBoundsUnsupported() { SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); optimizer.optimize(new MaxEval(100), new ObjectiveFunction(fourExtrema), GoalType.MINIMIZE, new InitialGuess(new double[] { -3, 0 }), new NelderMeadSimplex(new double[] { 0.2, 0.2 }), new SimpleBounds(new double[] { -5, -1 }, new double[] { 5, 1 })); } @Test public void testMinimize1() { SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(100), new ObjectiveFunction(fourExtrema), GoalType.MINIMIZE, new InitialGuess(new double[] { -3, 0 }), new NelderMeadSimplex(new double[] { 0.2, 0.2 })); Assert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 2e-7); Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 2e-5); Assert.assertEquals(fourExtrema.valueXmYp, optimum.getValue(), 6e-12); Assert.assertTrue(optimizer.getEvaluations() > 60); Assert.assertTrue(optimizer.getEvaluations() < 90); // Check that the number of iterations is updated (MATH-949). Assert.assertTrue(optimizer.getIterations() > 0); } @Test public void testMinimize2() { SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(100), new ObjectiveFunction(fourExtrema), GoalType.MINIMIZE, new InitialGuess(new double[] { 1, 0 }), new NelderMeadSimplex(new double[] { 0.2, 0.2 })); Assert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 5e-6); Assert.assertEquals(fourExtrema.yM, optimum.getPoint()[1], 6e-6); Assert.assertEquals(fourExtrema.valueXpYm, optimum.getValue(), 1e-11); Assert.assertTrue(optimizer.getEvaluations() > 60); Assert.assertTrue(optimizer.getEvaluations() < 90); // Check that the number of iterations is updated (MATH-949). Assert.assertTrue(optimizer.getIterations() > 0); } @Test public void testMaximize1() { SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(100), new ObjectiveFunction(fourExtrema), GoalType.MAXIMIZE, new InitialGuess(new double[] { -3, 0 }), new NelderMeadSimplex(new double[] { 0.2, 0.2 })); Assert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 1e-5); Assert.assertEquals(fourExtrema.yM, optimum.getPoint()[1], 3e-6); Assert.assertEquals(fourExtrema.valueXmYm, optimum.getValue(), 3e-12); Assert.assertTrue(optimizer.getEvaluations() > 60); Assert.assertTrue(optimizer.getEvaluations() < 90); // Check that the number of iterations is updated (MATH-949). Assert.assertTrue(optimizer.getIterations() > 0); } @Test public void testMaximize2() { SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(100), new ObjectiveFunction(fourExtrema), GoalType.MAXIMIZE, new InitialGuess(new double[] { 1, 0 }), new NelderMeadSimplex(new double[] { 0.2, 0.2 })); Assert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 4e-6); Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 5e-6); Assert.assertEquals(fourExtrema.valueXpYp, optimum.getValue(), 7e-12); Assert.assertTrue(optimizer.getEvaluations() > 60); Assert.assertTrue(optimizer.getEvaluations() < 90); // Check that the number of iterations is updated (MATH-949). Assert.assertTrue(optimizer.getIterations() > 0); } @Test public void testRosenbrock() { Rosenbrock rosenbrock = new Rosenbrock(); SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3); PointValuePair optimum = optimizer.optimize(new MaxEval(100), new ObjectiveFunction(rosenbrock), GoalType.MINIMIZE, new InitialGuess(new double[] { -1.2, 1 }), new NelderMeadSimplex(new double[][] { { -1.2, 1 }, { 0.9, 1.2 }, { 3.5, -2.3 } })); Assert.assertEquals(rosenbrock.getCount(), optimizer.getEvaluations()); Assert.assertTrue(optimizer.getEvaluations() > 40); Assert.assertTrue(optimizer.getEvaluations() < 50); Assert.assertTrue(optimum.getValue() < 8e-4); } @Test public void testPowell() { Powell powell = new Powell(); SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3); PointValuePair optimum = optimizer.optimize(new MaxEval(200), new ObjectiveFunction(powell), GoalType.MINIMIZE, new InitialGuess(new double[] { 3, -1, 0, 1 }), new NelderMeadSimplex(4)); Assert.assertEquals(powell.getCount(), optimizer.getEvaluations()); Assert.assertTrue(optimizer.getEvaluations() > 110); Assert.assertTrue(optimizer.getEvaluations() < 130); Assert.assertTrue(optimum.getValue() < 2e-3); } @Test public void testLeastSquares1() { final RealMatrix factors = new Array2DRowRealMatrix(new double[][] { { 1, 0 }, { 0, 1 } }, false); LeastSquaresConverter ls = new LeastSquaresConverter(new MultivariateVectorFunction() { public double[] value(double[] variables) { return factors.operate(variables); } }, new double[] { 2.0, -3.0 }); SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-6); PointValuePair optimum = optimizer.optimize(new MaxEval(200), new ObjectiveFunction(ls), GoalType.MINIMIZE, new InitialGuess(new double[] { 10, 10 }), new NelderMeadSimplex(2)); Assert.assertEquals( 2, optimum.getPointRef()[0], 3e-5); Assert.assertEquals(-3, optimum.getPointRef()[1], 4e-4); Assert.assertTrue(optimizer.getEvaluations() > 60); Assert.assertTrue(optimizer.getEvaluations() < 80); Assert.assertTrue(optimum.getValue() < 1.0e-6); } @Test public void testLeastSquares2() { final RealMatrix factors = new Array2DRowRealMatrix(new double[][] { { 1, 0 }, { 0, 1 } }, false); LeastSquaresConverter ls = new LeastSquaresConverter(new MultivariateVectorFunction() { public double[] value(double[] variables) { return factors.operate(variables); } }, new double[] { 2, -3 }, new double[] { 10, 0.1 }); SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-6); PointValuePair optimum = optimizer.optimize(new MaxEval(200), new ObjectiveFunction(ls), GoalType.MINIMIZE, new InitialGuess(new double[] { 10, 10 }), new NelderMeadSimplex(2)); Assert.assertEquals( 2, optimum.getPointRef()[0], 5e-5); Assert.assertEquals(-3, optimum.getPointRef()[1], 8e-4); Assert.assertTrue(optimizer.getEvaluations() > 60); Assert.assertTrue(optimizer.getEvaluations() < 80); Assert.assertTrue(optimum.getValue() < 1e-6); } @Test public void testLeastSquares3() { final RealMatrix factors = new Array2DRowRealMatrix(new double[][] { { 1, 0 }, { 0, 1 } }, false); LeastSquaresConverter ls = new LeastSquaresConverter(new MultivariateVectorFunction() { public double[] value(double[] variables) { return factors.operate(variables); } }, new double[] { 2, -3 }, new Array2DRowRealMatrix(new double [][] { { 1, 1.2 }, { 1.2, 2 } })); SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-6); PointValuePair optimum = optimizer.optimize(new MaxEval(200), new ObjectiveFunction(ls), GoalType.MINIMIZE, new InitialGuess(new double[] { 10, 10 }), new NelderMeadSimplex(2)); Assert.assertEquals( 2, optimum.getPointRef()[0], 2e-3); Assert.assertEquals(-3, optimum.getPointRef()[1], 8e-4); Assert.assertTrue(optimizer.getEvaluations() > 60); Assert.assertTrue(optimizer.getEvaluations() < 80); Assert.assertTrue(optimum.getValue() < 1e-6); } @Test(expected=TooManyEvaluationsException.class) public void testMaxIterations() { Powell powell = new Powell(); SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3); optimizer.optimize(new MaxEval(20), new ObjectiveFunction(powell), GoalType.MINIMIZE, new InitialGuess(new double[] { 3, -1, 0, 1 }), new NelderMeadSimplex(4)); } private static class FourExtrema implements MultivariateFunction { // The following function has 4 local extrema. final double xM = -3.841947088256863675365; final double yM = -1.391745200270734924416; final double xP = 0.2286682237349059125691; final double yP = -yM; final double valueXmYm = 0.2373295333134216789769; // Local maximum. final double valueXmYp = -valueXmYm; // Local minimum. final double valueXpYm = -0.7290400707055187115322; // Global minimum. final double valueXpYp = -valueXpYm; // Global maximum. public double value(double[] variables) { final double x = variables[0]; final double y = variables[1]; return (x == 0 || y == 0) ? 0 : FastMath.atan(x) * FastMath.atan(x + 2) * FastMath.atan(y) * FastMath.atan(y) / (x * y); } } private static class Rosenbrock implements MultivariateFunction { private int count; public Rosenbrock() { count = 0; } public double value(double[] x) { ++count; double a = x[1] - x[0] * x[0]; double b = 1.0 - x[0]; return 100 * a * a + b * b; } public int getCount() { return count; } } private static class Powell implements MultivariateFunction { private int count; public Powell() { count = 0; } public double value(double[] x) { ++count; double a = x[0] + 10 * x[1]; double b = x[2] - x[3]; double c = x[1] - 2 * x[2]; double d = x[0] - x[3]; return a * a + 5 * b * b + c * c * c * c + 10 * d * d * d * d; } public int getCount() { return count; } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optim.nonlinear.vector; import org.apache.commons.math3.analysis.MultivariateMatrixFunction; import org.apache.commons.math3.analysis.MultivariateVectorFunction; import org.apache.commons.math3.linear.BlockRealMatrix; import org.apache.commons.math3.linear.RealMatrix; import org.apache.commons.math3.optim.InitialGuess; import org.apache.commons.math3.optim.MaxEval; import org.apache.commons.math3.optim.OptimizationData; import org.apache.commons.math3.optim.PointVectorValuePair; import org.apache.commons.math3.optim.SimpleBounds; import org.apache.commons.math3.optim.SimpleVectorValueChecker; import org.apache.commons.math3.optim.nonlinear.vector.jacobian.GaussNewtonOptimizer; import org.apache.commons.math3.random.GaussianRandomGenerator; import org.apache.commons.math3.random.JDKRandomGenerator; import org.apache.commons.math3.random.RandomVectorGenerator; import org.apache.commons.math3.random.UncorrelatedRandomVectorGenerator; import org.junit.Assert; import org.junit.Test; /** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files. * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> * Minpack Copyright Notice (1999) University of Chicago. * All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> * <li>Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above * copyright notice, this list of conditions and the following * disclaimer in the documentation and/or other materials provided * with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, * must include the following acknowledgment: * <code>This product includes software developed by the University of * Chicago, as Operator of Argonne National Laboratory.</code> * Alternately, this acknowledgment may appear in the software itself, * if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" * WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE * UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND * THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE * OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY * OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR * USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF * THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) * DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION * UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL * BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT * HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF * ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, * INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF * ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF * PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER * SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT * (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, * EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE * POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */ public class MultiStartMultivariateVectorOptimizerTest { @Test(expected=NullPointerException.class) public void testGetOptimaBeforeOptimize() { JacobianMultivariateVectorOptimizer underlyingOptimizer = new GaussNewtonOptimizer(true, new SimpleVectorValueChecker(1e-6, 1e-6)); JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(16069223052l); RandomVectorGenerator generator = new UncorrelatedRandomVectorGenerator(1, new GaussianRandomGenerator(g)); MultiStartMultivariateVectorOptimizer optimizer = new MultiStartMultivariateVectorOptimizer(underlyingOptimizer, 10, generator); optimizer.getOptima(); } @Test public void testTrivial() { LinearProblem problem = new LinearProblem(new double[][] { { 2 } }, new double[] { 3 }); JacobianMultivariateVectorOptimizer underlyingOptimizer = new GaussNewtonOptimizer(true, new SimpleVectorValueChecker(1e-6, 1e-6)); JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(16069223052l); RandomVectorGenerator generator = new UncorrelatedRandomVectorGenerator(1, new GaussianRandomGenerator(g)); MultiStartMultivariateVectorOptimizer optimizer = new MultiStartMultivariateVectorOptimizer(underlyingOptimizer, 10, generator); PointVectorValuePair optimum = optimizer.optimize(new MaxEval(100), problem.getModelFunction(), problem.getModelFunctionJacobian(), problem.getTarget(), new Weight(new double[] { 1 }), new InitialGuess(new double[] { 0 })); Assert.assertEquals(1.5, optimum.getPoint()[0], 1e-10); Assert.assertEquals(3.0, optimum.getValue()[0], 1e-10); PointVectorValuePair[] optima = optimizer.getOptima(); Assert.assertEquals(10, optima.length); for (int i = 0; i < optima.length; i++) { Assert.assertEquals(1.5, optima[i].getPoint()[0], 1e-10); Assert.assertEquals(3.0, optima[i].getValue()[0], 1e-10); } Assert.assertTrue(optimizer.getEvaluations() > 20); Assert.assertTrue(optimizer.getEvaluations() < 50); Assert.assertEquals(100, optimizer.getMaxEvaluations()); } @Test public void testIssue914() { LinearProblem problem = new LinearProblem(new double[][] { { 2 } }, new double[] { 3 }); JacobianMultivariateVectorOptimizer underlyingOptimizer = new GaussNewtonOptimizer(true, new SimpleVectorValueChecker(1e-6, 1e-6)) { @Override public PointVectorValuePair optimize(OptimizationData... optData) { // filter out simple bounds, as they are not supported // by the underlying optimizer, and we don't really care for this test OptimizationData[] filtered = optData.clone(); for (int i = 0; i < filtered.length; ++i) { if (filtered[i] instanceof SimpleBounds) { filtered[i] = null; } } return super.optimize(filtered); } }; JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(16069223052l); RandomVectorGenerator generator = new UncorrelatedRandomVectorGenerator(1, new GaussianRandomGenerator(g)); MultiStartMultivariateVectorOptimizer optimizer = new MultiStartMultivariateVectorOptimizer(underlyingOptimizer, 10, generator); optimizer.optimize(new MaxEval(100), problem.getModelFunction(), problem.getModelFunctionJacobian(), problem.getTarget(), new Weight(new double[] { 1 }), new InitialGuess(new double[] { 0 }), new SimpleBounds(new double[] { -1.0e-10 }, new double[] { 1.0e-10 })); PointVectorValuePair[] optima = optimizer.getOptima(); // only the first start should have succeeded Assert.assertEquals(1, optima.length); } /** * Test demonstrating that the user exception is finally thrown if none * of the runs succeed. */ @Test(expected=TestException.class) public void testNoOptimum() { JacobianMultivariateVectorOptimizer underlyingOptimizer = new GaussNewtonOptimizer(true, new SimpleVectorValueChecker(1e-6, 1e-6)); JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(12373523445l); RandomVectorGenerator generator = new UncorrelatedRandomVectorGenerator(1, new GaussianRandomGenerator(g)); MultiStartMultivariateVectorOptimizer optimizer = new MultiStartMultivariateVectorOptimizer(underlyingOptimizer, 10, generator); optimizer.optimize(new MaxEval(100), new Target(new double[] { 0 }), new Weight(new double[] { 1 }), new InitialGuess(new double[] { 0 }), new ModelFunction(new MultivariateVectorFunction() { public double[] value(double[] point) { throw new TestException(); } })); } private static class TestException extends RuntimeException { private static final long serialVersionUID = 1L;} private static class LinearProblem { private final RealMatrix factors; private final double[] target; public LinearProblem(double[][] factors, double[] target) { this.factors = new BlockRealMatrix(factors); this.target = target; } public Target getTarget() { return new Target(target); } public ModelFunction getModelFunction() { return new ModelFunction(new MultivariateVectorFunction() { public double[] value(double[] variables) { return factors.operate(variables); } }); } public ModelFunctionJacobian getModelFunctionJacobian() { return new ModelFunctionJacobian(new MultivariateMatrixFunction() { public double[][] value(double[] point) { return factors.getData(); } }); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optim.nonlinear.vector.jacobian; import java.io.IOException; import org.apache.commons.math3.exception.ConvergenceException; import org.apache.commons.math3.exception.TooManyEvaluationsException; import org.apache.commons.math3.exception.MathUnsupportedOperationException; import org.apache.commons.math3.optim.SimpleVectorValueChecker; import org.apache.commons.math3.optim.InitialGuess; import org.apache.commons.math3.optim.MaxEval; import org.apache.commons.math3.optim.SimpleBounds; import org.apache.commons.math3.optim.nonlinear.vector.Target; import org.apache.commons.math3.optim.nonlinear.vector.Weight; import org.junit.Test; /** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files. * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> * Minpack Copyright Notice (1999) University of Chicago. * All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> * <li>Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above * copyright notice, this list of conditions and the following * disclaimer in the documentation and/or other materials provided * with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, * must include the following acknowledgment: * <code>This product includes software developed by the University of * Chicago, as Operator of Argonne National Laboratory.</code> * Alternately, this acknowledgment may appear in the software itself, * if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" * WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE * UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND * THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE * OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY * OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR * USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF * THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) * DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION * UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL * BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT * HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF * ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, * INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF * ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF * PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER * SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT * (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, * EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE * POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */ public class GaussNewtonOptimizerTest extends AbstractLeastSquaresOptimizerAbstractTest { @Override public AbstractLeastSquaresOptimizer createOptimizer() { return new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-6, 1.0e-6)); } @Test(expected=MathUnsupportedOperationException.class) public void testConstraintsUnsupported() { createOptimizer().optimize(new MaxEval(100), new Target(new double[] { 2 }), new Weight(new double[] { 1 }), new InitialGuess(new double[] { 1, 2 }), new SimpleBounds(new double[] { -10, 0 }, new double[] { 20, 30 })); } @Override @Test(expected = ConvergenceException.class) public void testMoreEstimatedParametersSimple() { /* * Exception is expected with this optimizer */ super.testMoreEstimatedParametersSimple(); } @Override @Test(expected=ConvergenceException.class) public void testMoreEstimatedParametersUnsorted() { /* * Exception is expected with this optimizer */ super.testMoreEstimatedParametersUnsorted(); } @Test(expected=TooManyEvaluationsException.class) public void testMaxEvaluations() throws Exception { CircleVectorial circle = new CircleVectorial(); circle.addPoint( 30.0, 68.0); circle.addPoint( 50.0, -6.0); circle.addPoint(110.0, -20.0); circle.addPoint( 35.0, 15.0); circle.addPoint( 45.0, 97.0); GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1e-30, 1e-30)); optimizer.optimize(new MaxEval(100), circle.getModelFunction(), circle.getModelFunctionJacobian(), new Target(new double[] { 0, 0, 0, 0, 0 }), new Weight(new double[] { 1, 1, 1, 1, 1 }), new InitialGuess(new double[] { 98.680, 47.345 })); } @Override @Test(expected=ConvergenceException.class) public void testCircleFittingBadInit() { /* * This test does not converge with this optimizer. */ super.testCircleFittingBadInit(); } @Override @Test(expected = ConvergenceException.class) public void testHahn1() throws IOException { /* * TODO This test leads to a singular problem with the Gauss-Newton * optimizer. This should be inquired. */ super.testHahn1(); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optim.nonlinear.vector.jacobian; import java.util.ArrayList; import java.util.List; import org.apache.commons.math3.optim.PointVectorValuePair; import org.apache.commons.math3.optim.InitialGuess; import org.apache.commons.math3.optim.MaxEval; import org.apache.commons.math3.optim.SimpleBounds; import org.apache.commons.math3.optim.nonlinear.vector.Target; import org.apache.commons.math3.optim.nonlinear.vector.Weight; import org.apache.commons.math3.optim.nonlinear.vector.ModelFunction; import org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian; import org.apache.commons.math3.analysis.MultivariateVectorFunction; import org.apache.commons.math3.analysis.MultivariateMatrixFunction; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.TooManyEvaluationsException; import org.apache.commons.math3.exception.MathUnsupportedOperationException; import org.apache.commons.math3.geometry.euclidean.twod.Vector2D; import org.apache.commons.math3.linear.SingularMatrixException; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.util.Precision; import org.junit.Assert; import org.junit.Test; /** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files. * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> * Minpack Copyright Notice (1999) University of Chicago. * All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> * <li>Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above * copyright notice, this list of conditions and the following * disclaimer in the documentation and/or other materials provided * with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, * must include the following acknowledgment: * <code>This product includes software developed by the University of * Chicago, as Operator of Argonne National Laboratory.</code> * Alternately, this acknowledgment may appear in the software itself, * if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" * WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE * UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND * THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE * OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY * OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR * USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF * THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) * DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION * UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL * BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT * HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF * ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, * INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF * ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF * PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER * SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT * (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, * EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE * POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */ public class LevenbergMarquardtOptimizerTest extends AbstractLeastSquaresOptimizerAbstractTest { @Override public AbstractLeastSquaresOptimizer createOptimizer() { return new LevenbergMarquardtOptimizer(); } @Test(expected=MathUnsupportedOperationException.class) public void testConstraintsUnsupported() { createOptimizer().optimize(new MaxEval(100), new Target(new double[] { 2 }), new Weight(new double[] { 1 }), new InitialGuess(new double[] { 1, 2 }), new SimpleBounds(new double[] { -10, 0 }, new double[] { 20, 30 })); } @Override @Test(expected=SingularMatrixException.class) public void testNonInvertible() { /* * Overrides the method from parent class, since the default singularity * threshold (1e-14) does not trigger the expected exception. */ LinearProblem problem = new LinearProblem(new double[][] { { 1, 2, -3 }, { 2, 1, 3 }, { -3, 0, -9 } }, new double[] { 1, 1, 1 }); AbstractLeastSquaresOptimizer optimizer = createOptimizer(); PointVectorValuePair optimum = optimizer.optimize(new MaxEval(100), problem.getModelFunction(), problem.getModelFunctionJacobian(), problem.getTarget(), new Weight(new double[] { 1, 1, 1 }), new InitialGuess(new double[] { 0, 0, 0 })); Assert.assertTrue(FastMath.sqrt(optimizer.getTargetSize()) * optimizer.getRMS() > 0.6); optimizer.computeCovariances(optimum.getPoint(), 1.5e-14); } @Test public void testControlParameters() { CircleVectorial circle = new CircleVectorial(); circle.addPoint( 30.0, 68.0); circle.addPoint( 50.0, -6.0); circle.addPoint(110.0, -20.0); circle.addPoint( 35.0, 15.0); circle.addPoint( 45.0, 97.0); checkEstimate(circle.getModelFunction(), circle.getModelFunctionJacobian(), 0.1, 10, 1.0e-14, 1.0e-16, 1.0e-10, false); checkEstimate(circle.getModelFunction(), circle.getModelFunctionJacobian(), 0.1, 10, 1.0e-15, 1.0e-17, 1.0e-10, true); checkEstimate(circle.getModelFunction(), circle.getModelFunctionJacobian(), 0.1, 5, 1.0e-15, 1.0e-16, 1.0e-10, true); circle.addPoint(300, -300); checkEstimate(circle.getModelFunction(), circle.getModelFunctionJacobian(), 0.1, 20, 1.0e-18, 1.0e-16, 1.0e-10, true); } private void checkEstimate(ModelFunction problem, ModelFunctionJacobian problemJacobian, double initialStepBoundFactor, int maxCostEval, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, boolean shouldFail) { try { LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer(initialStepBoundFactor, costRelativeTolerance, parRelativeTolerance, orthoTolerance, Precision.SAFE_MIN); optimizer.optimize(new MaxEval(maxCostEval), problem, problemJacobian, new Target(new double[] { 0, 0, 0, 0, 0 }), new Weight(new double[] { 1, 1, 1, 1, 1 }), new InitialGuess(new double[] { 98.680, 47.345 })); Assert.assertTrue(!shouldFail); } catch (DimensionMismatchException ee) { Assert.assertTrue(shouldFail); } catch (TooManyEvaluationsException ee) { Assert.assertTrue(shouldFail); } } /** * Non-linear test case: fitting of decay curve (from Chapter 8 of * Bevington's textbook, "Data reduction and analysis for the physical sciences"). * XXX The expected ("reference") values may not be accurate and the tolerance too * relaxed for this test to be currently really useful (the issue is under * investigation). */ @Test public void testBevington() { final double[][] dataPoints = { // column 1 = times { 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180, 195, 210, 225, 240, 255, 270, 285, 300, 315, 330, 345, 360, 375, 390, 405, 420, 435, 450, 465, 480, 495, 510, 525, 540, 555, 570, 585, 600, 615, 630, 645, 660, 675, 690, 705, 720, 735, 750, 765, 780, 795, 810, 825, 840, 855, 870, 885, }, // column 2 = measured counts { 775, 479, 380, 302, 185, 157, 137, 119, 110, 89, 74, 61, 66, 68, 48, 54, 51, 46, 55, 29, 28, 37, 49, 26, 35, 29, 31, 24, 25, 35, 24, 30, 26, 28, 21, 18, 20, 27, 17, 17, 14, 17, 24, 11, 22, 17, 12, 10, 13, 16, 9, 9, 14, 21, 17, 13, 12, 18, 10, }, }; final BevingtonProblem problem = new BevingtonProblem(); final int len = dataPoints[0].length; final double[] weights = new double[len]; for (int i = 0; i < len; i++) { problem.addPoint(dataPoints[0][i], dataPoints[1][i]); weights[i] = 1 / dataPoints[1][i]; } final LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer(); final PointVectorValuePair optimum = optimizer.optimize(new MaxEval(100), problem.getModelFunction(), problem.getModelFunctionJacobian(), new Target(dataPoints[1]), new Weight(weights), new InitialGuess(new double[] { 10, 900, 80, 27, 225 })); final double[] solution = optimum.getPoint(); final double[] expectedSolution = { 10.4, 958.3, 131.4, 33.9, 205.0 }; final double[][] covarMatrix = optimizer.computeCovariances(solution, 1e-14); final double[][] expectedCovarMatrix = { { 3.38, -3.69, 27.98, -2.34, -49.24 }, { -3.69, 2492.26, 81.89, -69.21, -8.9 }, { 27.98, 81.89, 468.99, -44.22, -615.44 }, { -2.34, -69.21, -44.22, 6.39, 53.80 }, { -49.24, -8.9, -615.44, 53.8, 929.45 } }; final int numParams = expectedSolution.length; // Check that the computed solution is within the reference error range. for (int i = 0; i < numParams; i++) { final double error = FastMath.sqrt(expectedCovarMatrix[i][i]); Assert.assertEquals("Parameter " + i, expectedSolution[i], solution[i], error); } // Check that each entry of the computed covariance matrix is within 10% // of the reference matrix entry. for (int i = 0; i < numParams; i++) { for (int j = 0; j < numParams; j++) { Assert.assertEquals("Covariance matrix [" + i + "][" + j + "]", expectedCovarMatrix[i][j], covarMatrix[i][j], FastMath.abs(0.1 * expectedCovarMatrix[i][j])); } } } @Test public void testCircleFitting2() { final double xCenter = 123.456; final double yCenter = 654.321; final double xSigma = 10; final double ySigma = 15; final double radius = 111.111; // The test is extremely sensitive to the seed. final long seed = 59421061L; final RandomCirclePointGenerator factory = new RandomCirclePointGenerator(xCenter, yCenter, radius, xSigma, ySigma, seed); final CircleProblem circle = new CircleProblem(xSigma, ySigma); final int numPoints = 10; for (Vector2D p : factory.generate(numPoints)) { circle.addPoint(p.getX(), p.getY()); } // First guess for the center's coordinates and radius. final double[] init = { 90, 659, 115 }; final LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer(); final PointVectorValuePair optimum = optimizer.optimize(new MaxEval(100), circle.getModelFunction(), circle.getModelFunctionJacobian(), new Target(circle.target()), new Weight(circle.weight()), new InitialGuess(init)); final double[] paramFound = optimum.getPoint(); // Retrieve errors estimation. final double[] asymptoticStandardErrorFound = optimizer.computeSigma(paramFound, 1e-14); // Check that the parameters are found within the assumed error bars. Assert.assertEquals(xCenter, paramFound[0], asymptoticStandardErrorFound[0]); Assert.assertEquals(yCenter, paramFound[1], asymptoticStandardErrorFound[1]); Assert.assertEquals(radius, paramFound[2], asymptoticStandardErrorFound[2]); } private static class QuadraticProblem { private List<Double> x; private List<Double> y; public QuadraticProblem() { x = new ArrayList<Double>(); y = new ArrayList<Double>(); } public void addPoint(double x, double y) { this.x.add(x); this.y.add(y); } public ModelFunction getModelFunction() { return new ModelFunction(new MultivariateVectorFunction() { public double[] value(double[] variables) { double[] values = new double[x.size()]; for (int i = 0; i < values.length; ++i) { values[i] = (variables[0] * x.get(i) + variables[1]) * x.get(i) + variables[2]; } return values; } }); } public ModelFunctionJacobian getModelFunctionJacobian() { return new ModelFunctionJacobian(new MultivariateMatrixFunction() { public double[][] value(double[] params) { double[][] jacobian = new double[x.size()][3]; for (int i = 0; i < jacobian.length; ++i) { jacobian[i][0] = x.get(i) * x.get(i); jacobian[i][1] = x.get(i); jacobian[i][2] = 1.0; } return jacobian; } }); } } private static class BevingtonProblem { private List<Double> time; private List<Double> count; public BevingtonProblem() { time = new ArrayList<Double>(); count = new ArrayList<Double>(); } public void addPoint(double t, double c) { time.add(t); count.add(c); } public ModelFunction getModelFunction() { return new ModelFunction(new MultivariateVectorFunction() { public double[] value(double[] params) { double[] values = new double[time.size()]; for (int i = 0; i < values.length; ++i) { final double t = time.get(i); values[i] = params[0] + params[1] * Math.exp(-t / params[3]) + params[2] * Math.exp(-t / params[4]); } return values; } }); } public ModelFunctionJacobian getModelFunctionJacobian() { return new ModelFunctionJacobian(new MultivariateMatrixFunction() { public double[][] value(double[] params) { double[][] jacobian = new double[time.size()][5]; for (int i = 0; i < jacobian.length; ++i) { final double t = time.get(i); jacobian[i][0] = 1; final double p3 = params[3]; final double p4 = params[4]; final double tOp3 = t / p3; final double tOp4 = t / p4; jacobian[i][1] = Math.exp(-tOp3); jacobian[i][2] = Math.exp(-tOp4); jacobian[i][3] = params[1] * Math.exp(-tOp3) * tOp3 / p3; jacobian[i][4] = params[2] * Math.exp(-tOp4) * tOp4 / p4; } return jacobian; } }); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optim.nonlinear.vector.jacobian; import java.util.Arrays; import org.apache.commons.math3.exception.TooManyEvaluationsException; import org.apache.commons.math3.analysis.MultivariateVectorFunction; import org.apache.commons.math3.analysis.MultivariateMatrixFunction; import org.apache.commons.math3.optim.PointVectorValuePair; import org.apache.commons.math3.optim.InitialGuess; import org.apache.commons.math3.optim.MaxEval; import org.apache.commons.math3.optim.nonlinear.vector.Target; import org.apache.commons.math3.optim.nonlinear.vector.Weight; import org.apache.commons.math3.optim.nonlinear.vector.ModelFunction; import org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files. * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> * Minpack Copyright Notice (1999) University of Chicago. * All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> * <li>Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above * copyright notice, this list of conditions and the following * disclaimer in the documentation and/or other materials provided * with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, * must include the following acknowledgment: * <code>This product includes software developed by the University of * Chicago, as Operator of Argonne National Laboratory.</code> * Alternately, this acknowledgment may appear in the software itself, * if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" * WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE * UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND * THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE * OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY * OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR * USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF * THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) * DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION * UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL * BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT * HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF * ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, * INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF * ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF * PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER * SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT * (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, * EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE * POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */ public class MinpackTest { @Test public void testMinpackLinearFullRank() { minpackTest(new LinearFullRankFunction(10, 5, 1.0, 5.0, 2.23606797749979), false); minpackTest(new LinearFullRankFunction(50, 5, 1.0, 8.06225774829855, 6.70820393249937), false); } @Test public void testMinpackLinearRank1() { minpackTest(new LinearRank1Function(10, 5, 1.0, 291.521868819476, 1.4638501094228), false); minpackTest(new LinearRank1Function(50, 5, 1.0, 3101.60039334535, 3.48263016573496), false); } @Test public void testMinpackLinearRank1ZeroColsAndRows() { minpackTest(new LinearRank1ZeroColsAndRowsFunction(10, 5, 1.0), false); minpackTest(new LinearRank1ZeroColsAndRowsFunction(50, 5, 1.0), false); } @Test public void testMinpackRosenbrok() { minpackTest(new RosenbrockFunction(new double[] { -1.2, 1.0 }, FastMath.sqrt(24.2)), false); minpackTest(new RosenbrockFunction(new double[] { -12.0, 10.0 }, FastMath.sqrt(1795769.0)), false); minpackTest(new RosenbrockFunction(new double[] { -120.0, 100.0 }, 11.0 * FastMath.sqrt(169000121.0)), false); } @Test public void testMinpackHelicalValley() { minpackTest(new HelicalValleyFunction(new double[] { -1.0, 0.0, 0.0 }, 50.0), false); minpackTest(new HelicalValleyFunction(new double[] { -10.0, 0.0, 0.0 }, 102.95630140987), false); minpackTest(new HelicalValleyFunction(new double[] { -100.0, 0.0, 0.0}, 991.261822123701), false); } @Test public void testMinpackPowellSingular() { minpackTest(new PowellSingularFunction(new double[] { 3.0, -1.0, 0.0, 1.0 }, 14.6628782986152), false); minpackTest(new PowellSingularFunction(new double[] { 30.0, -10.0, 0.0, 10.0 }, 1270.9838708654), false); minpackTest(new PowellSingularFunction(new double[] { 300.0, -100.0, 0.0, 100.0 }, 126887.903284750), false); } @Test public void testMinpackFreudensteinRoth() { minpackTest(new FreudensteinRothFunction(new double[] { 0.5, -2.0 }, 20.0124960961895, 6.99887517584575, new double[] { 11.4124844654993, -0.896827913731509 }), false); minpackTest(new FreudensteinRothFunction(new double[] { 5.0, -20.0 }, 12432.833948863, 6.9988751744895, new double[] { 11.41300466147456, -0.896796038685959 }), false); minpackTest(new FreudensteinRothFunction(new double[] { 50.0, -200.0 }, 11426454.595762, 6.99887517242903, new double[] { 11.412781785788564, -0.8968051074920405 }), false); } @Test public void testMinpackBard() { minpackTest(new BardFunction(1.0, 6.45613629515967, 0.0906359603390466, new double[] { 0.0824105765758334, 1.1330366534715, 2.34369463894115 }), false); minpackTest(new BardFunction(10.0, 36.1418531596785, 4.17476870138539, new double[] { 0.840666673818329, -158848033.259565, -164378671.653535 }), false); minpackTest(new BardFunction(100.0, 384.114678637399, 4.17476870135969, new double[] { 0.840666673867645, -158946167.205518, -164464906.857771 }), false); } @Test public void testMinpackKowalikOsborne() { minpackTest(new KowalikOsborneFunction(new double[] { 0.25, 0.39, 0.415, 0.39 }, 0.0728915102882945, 0.017535837721129, new double[] { 0.192807810476249, 0.191262653354071, 0.123052801046931, 0.136053221150517 }), false); minpackTest(new KowalikOsborneFunction(new double[] { 2.5, 3.9, 4.15, 3.9 }, 2.97937007555202, 0.032052192917937, new double[] { 728675.473768287, -14.0758803129393, -32977797.7841797, -20571594.1977912 }), false); minpackTest(new KowalikOsborneFunction(new double[] { 25.0, 39.0, 41.5, 39.0 }, 29.9590617016037, 0.0175364017658228, new double[] { 0.192948328597594, 0.188053165007911, 0.122430604321144, 0.134575665392506 }), false); } @Test public void testMinpackMeyer() { minpackTest(new MeyerFunction(new double[] { 0.02, 4000.0, 250.0 }, 41153.4665543031, 9.37794514651874, new double[] { 0.00560963647102661, 6181.34634628659, 345.223634624144 }), false); minpackTest(new MeyerFunction(new double[] { 0.2, 40000.0, 2500.0 }, 4168216.89130846, 792.917871779501, new double[] { 1.42367074157994e-11, 33695.7133432541, 901.268527953801 }), true); } @Test public void testMinpackWatson() { minpackTest(new WatsonFunction(6, 0.0, 5.47722557505166, 0.0478295939097601, new double[] { -0.0157249615083782, 1.01243488232965, -0.232991722387673, 1.26043101102818, -1.51373031394421, 0.99299727291842 }), false); minpackTest(new WatsonFunction(6, 10.0, 6433.12578950026, 0.0478295939096951, new double[] { -0.0157251901386677, 1.01243485860105, -0.232991545843829, 1.26042932089163, -1.51372776706575, 0.99299573426328 }), false); minpackTest(new WatsonFunction(6, 100.0, 674256.040605213, 0.047829593911544, new double[] { -0.0157247019712586, 1.01243490925658, -0.232991922761641, 1.26043292929555, -1.51373320452707, 0.99299901922322 }), false); minpackTest(new WatsonFunction(9, 0.0, 5.47722557505166, 0.00118311459212420, new double[] { -0.153070644166722e-4, 0.999789703934597, 0.0147639634910978, 0.146342330145992, 1.00082109454817, -2.61773112070507, 4.10440313943354, -3.14361226236241, 1.05262640378759 }), false); minpackTest(new WatsonFunction(9, 10.0, 12088.127069307, 0.00118311459212513, new double[] { -0.153071334849279e-4, 0.999789703941234, 0.0147639629786217, 0.146342334818836, 1.00082107321386, -2.61773107084722, 4.10440307655564, -3.14361222178686, 1.05262639322589 }), false); minpackTest(new WatsonFunction(9, 100.0, 1269109.29043834, 0.00118311459212384, new double[] { -0.153069523352176e-4, 0.999789703958371, 0.0147639625185392, 0.146342341096326, 1.00082104729164, -2.61773101573645, 4.10440301427286, -3.14361218602503, 1.05262638516774 }), false); minpackTest(new WatsonFunction(12, 0.0, 5.47722557505166, 0.217310402535861e-4, new double[] { -0.660266001396382e-8, 1.00000164411833, -0.000563932146980154, 0.347820540050756, -0.156731500244233, 1.05281515825593, -3.24727109519451, 7.2884347837505, -10.271848098614, 9.07411353715783, -4.54137541918194, 1.01201187975044 }), false); minpackTest(new WatsonFunction(12, 10.0, 19220.7589790951, 0.217310402518509e-4, new double[] { -0.663710223017410e-8, 1.00000164411787, -0.000563932208347327, 0.347820540486998, -0.156731503955652, 1.05281517654573, -3.2472711515214, 7.28843489430665, -10.2718482369638, 9.07411364383733, -4.54137546533666, 1.01201188830857 }), false); minpackTest(new WatsonFunction(12, 100.0, 2018918.04462367, 0.217310402539845e-4, new double[] { -0.663806046485249e-8, 1.00000164411786, -0.000563932210324959, 0.347820540503588, -0.156731504091375, 1.05281517718031, -3.24727115337025, 7.28843489775302, -10.2718482410813, 9.07411364688464, -4.54137546660822, 1.0120118885369 }), false); } @Test public void testMinpackBox3Dimensional() { minpackTest(new Box3DimensionalFunction(10, new double[] { 0.0, 10.0, 20.0 }, 32.1115837449572), false); } @Test public void testMinpackJennrichSampson() { minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 }, 64.5856498144943, 11.1517793413499, new double[] { // 0.2578330049, 0.257829976764542 0.2578199266368004, 0.25782997676455244 }), false); } @Test public void testMinpackBrownDennis() { minpackTest(new BrownDennisFunction(20, new double[] { 25.0, 5.0, -5.0, -1.0 }, 2815.43839161816, 292.954288244866, new double[] { -11.59125141003, 13.2024883984741, -0.403574643314272, 0.236736269844604 }), false); minpackTest(new BrownDennisFunction(20, new double[] { 250.0, 50.0, -50.0, -10.0 }, 555073.354173069, 292.954270581415, new double[] { -11.5959274272203, 13.2041866926242, -0.403417362841545, 0.236771143410386 }), false); minpackTest(new BrownDennisFunction(20, new double[] { 2500.0, 500.0, -500.0, -100.0 }, 61211252.2338581, 292.954306151134, new double[] { -11.5902596937374, 13.2020628854665, -0.403688070279258, 0.236665033746463 }), false); } @Test public void testMinpackChebyquad() { minpackTest(new ChebyquadFunction(1, 8, 1.0, 1.88623796907732, 1.88623796907732, new double[] { 0.5 }), false); minpackTest(new ChebyquadFunction(1, 8, 10.0, 5383344372.34005, 1.88424820499951, new double[] { 0.9817314924684 }), false); minpackTest(new ChebyquadFunction(1, 8, 100.0, 0.118088726698392e19, 1.88424820499347, new double[] { 0.9817314852934 }), false); minpackTest(new ChebyquadFunction(8, 8, 1.0, 0.196513862833975, 0.0593032355046727, new double[] { 0.0431536648587336, 0.193091637843267, 0.266328593812698, 0.499999334628884, 0.500000665371116, 0.733671406187302, 0.806908362156733, 0.956846335141266 }), false); minpackTest(new ChebyquadFunction(9, 9, 1.0, 0.16994993465202, 0.0, new double[] { 0.0442053461357828, 0.199490672309881, 0.23561910847106, 0.416046907892598, 0.5, 0.583953092107402, 0.764380891528940, 0.800509327690119, 0.955794653864217 }), false); minpackTest(new ChebyquadFunction(10, 10, 1.0, 0.183747831178711, 0.0806471004038253, new double[] { 0.0596202671753563, 0.166708783805937, 0.239171018813509, 0.398885290346268, 0.398883667870681, 0.601116332129320, 0.60111470965373, 0.760828981186491, 0.833291216194063, 0.940379732824644 }), false); } @Test public void testMinpackBrownAlmostLinear() { minpackTest(new BrownAlmostLinearFunction(10, 0.5, 16.5302162063499, 0.0, new double[] { 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 1.20569696650138 }), false); minpackTest(new BrownAlmostLinearFunction(10, 5.0, 9765624.00089211, 0.0, new double[] { 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 1.20569696650135 }), false); minpackTest(new BrownAlmostLinearFunction(10, 50.0, 0.9765625e17, 0.0, new double[] { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 }), false); minpackTest(new BrownAlmostLinearFunction(30, 0.5, 83.476044467848, 0.0, new double[] { 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 1.06737350671578 }), false); minpackTest(new BrownAlmostLinearFunction(40, 0.5, 128.026364472323, 0.0, new double[] { 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 0.999999999999121 }), false); } @Test public void testMinpackOsborne1() { minpackTest(new Osborne1Function(new double[] { 0.5, 1.5, -1.0, 0.01, 0.02, }, 0.937564021037838, 0.00739249260904843, new double[] { 0.375410049244025, 1.93584654543108, -1.46468676748716, 0.0128675339110439, 0.0221227011813076 }), false); } @Test public void testMinpackOsborne2() { minpackTest(new Osborne2Function(new double[] { 1.3, 0.65, 0.65, 0.7, 0.6, 3.0, 5.0, 7.0, 2.0, 4.5, 5.5 }, 1.44686540984712, 0.20034404483314, new double[] { 1.30997663810096, 0.43155248076, 0.633661261602859, 0.599428560991695, 0.754179768272449, 0.904300082378518, 1.36579949521007, 4.82373199748107, 2.39868475104871, 4.56887554791452, 5.67534206273052 }), false); } private void minpackTest(MinpackFunction function, boolean exceptionExpected) { LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer(FastMath.sqrt(2.22044604926e-16), FastMath.sqrt(2.22044604926e-16), 2.22044604926e-16); try { PointVectorValuePair optimum = optimizer.optimize(new MaxEval(400 * (function.getN() + 1)), function.getModelFunction(), function.getModelFunctionJacobian(), new Target(function.getTarget()), new Weight(function.getWeight()), new InitialGuess(function.getStartPoint())); Assert.assertFalse(exceptionExpected); function.checkTheoreticalMinCost(optimizer.getRMS()); function.checkTheoreticalMinParams(optimum); } catch (TooManyEvaluationsException e) { Assert.assertTrue(exceptionExpected); } } private static abstract class MinpackFunction { protected int n; protected int m; protected double[] startParams; protected double theoreticalMinCost; protected double[] theoreticalMinParams; protected double costAccuracy; protected double paramsAccuracy; protected MinpackFunction(int m, double[] startParams, double theoreticalMinCost, double[] theoreticalMinParams) { this.m = m; this.n = startParams.length; this.startParams = startParams.clone(); this.theoreticalMinCost = theoreticalMinCost; this.theoreticalMinParams = theoreticalMinParams; this.costAccuracy = 1.0e-8; this.paramsAccuracy = 1.0e-5; } protected static double[] buildArray(int n, double x) { double[] array = new double[n]; Arrays.fill(array, x); return array; } public double[] getTarget() { return buildArray(m, 0.0); } public double[] getWeight() { return buildArray(m, 1.0); } public double[] getStartPoint() { return startParams.clone(); } protected void setCostAccuracy(double costAccuracy) { this.costAccuracy = costAccuracy; } protected void setParamsAccuracy(double paramsAccuracy) { this.paramsAccuracy = paramsAccuracy; } public int getN() { return startParams.length; } public void checkTheoreticalMinCost(double rms) { double threshold = costAccuracy * (1.0 + theoreticalMinCost); Assert.assertEquals(theoreticalMinCost, FastMath.sqrt(m) * rms, threshold); } public void checkTheoreticalMinParams(PointVectorValuePair optimum) { double[] params = optimum.getPointRef(); if (theoreticalMinParams != null) { for (int i = 0; i < theoreticalMinParams.length; ++i) { double mi = theoreticalMinParams[i]; double vi = params[i]; Assert.assertEquals(mi, vi, paramsAccuracy * (1.0 + FastMath.abs(mi))); } } } public ModelFunction getModelFunction() { return new ModelFunction(new MultivariateVectorFunction() { public double[] value(double[] point) { return computeValue(point); } }); } public ModelFunctionJacobian getModelFunctionJacobian() { return new ModelFunctionJacobian(new MultivariateMatrixFunction() { public double[][] value(double[] point) { return computeJacobian(point); } }); } public abstract double[][] computeJacobian(double[] variables); public abstract double[] computeValue(double[] variables); } private static class LinearFullRankFunction extends MinpackFunction { public LinearFullRankFunction(int m, int n, double x0, double theoreticalStartCost, double theoreticalMinCost) { super(m, buildArray(n, x0), theoreticalMinCost, buildArray(n, -1.0)); } @Override public double[][] computeJacobian(double[] variables) { double t = 2.0 / m; double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { jacobian[i] = new double[n]; for (int j = 0; j < n; ++j) { jacobian[i][j] = (i == j) ? (1 - t) : -t; } } return jacobian; } @Override public double[] computeValue(double[] variables) { double sum = 0; for (int i = 0; i < n; ++i) { sum += variables[i]; } double t = 1 + 2 * sum / m; double[] f = new double[m]; for (int i = 0; i < n; ++i) { f[i] = variables[i] - t; } Arrays.fill(f, n, m, -t); return f; } } private static class LinearRank1Function extends MinpackFunction { public LinearRank1Function(int m, int n, double x0, double theoreticalStartCost, double theoreticalMinCost) { super(m, buildArray(n, x0), theoreticalMinCost, null); } @Override public double[][] computeJacobian(double[] variables) { double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { jacobian[i] = new double[n]; for (int j = 0; j < n; ++j) { jacobian[i][j] = (i + 1) * (j + 1); } } return jacobian; } @Override public double[] computeValue(double[] variables) { double[] f = new double[m]; double sum = 0; for (int i = 0; i < n; ++i) { sum += (i + 1) * variables[i]; } for (int i = 0; i < m; ++i) { f[i] = (i + 1) * sum - 1; } return f; } } private static class LinearRank1ZeroColsAndRowsFunction extends MinpackFunction { public LinearRank1ZeroColsAndRowsFunction(int m, int n, double x0) { super(m, buildArray(n, x0), FastMath.sqrt((m * (m + 3) - 6) / (2.0 * (2 * m - 3))), null); } @Override public double[][] computeJacobian(double[] variables) { double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { jacobian[i] = new double[n]; jacobian[i][0] = 0; for (int j = 1; j < (n - 1); ++j) { if (i == 0) { jacobian[i][j] = 0; } else if (i != (m - 1)) { jacobian[i][j] = i * (j + 1); } else { jacobian[i][j] = 0; } } jacobian[i][n - 1] = 0; } return jacobian; } @Override public double[] computeValue(double[] variables) { double[] f = new double[m]; double sum = 0; for (int i = 1; i < (n - 1); ++i) { sum += (i + 1) * variables[i]; } for (int i = 0; i < (m - 1); ++i) { f[i] = i * sum - 1; } f[m - 1] = -1; return f; } } private static class RosenbrockFunction extends MinpackFunction { public RosenbrockFunction(double[] startParams, double theoreticalStartCost) { super(2, startParams, 0.0, buildArray(2, 1.0)); } @Override public double[][] computeJacobian(double[] variables) { double x1 = variables[0]; return new double[][] { { -20 * x1, 10 }, { -1, 0 } }; } @Override public double[] computeValue(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; return new double[] { 10 * (x2 - x1 * x1), 1 - x1 }; } } private static class HelicalValleyFunction extends MinpackFunction { public HelicalValleyFunction(double[] startParams, double theoreticalStartCost) { super(3, startParams, 0.0, new double[] { 1.0, 0.0, 0.0 }); } @Override public double[][] computeJacobian(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; double tmpSquare = x1 * x1 + x2 * x2; double tmp1 = twoPi * tmpSquare; double tmp2 = FastMath.sqrt(tmpSquare); return new double[][] { { 100 * x2 / tmp1, -100 * x1 / tmp1, 10 }, { 10 * x1 / tmp2, 10 * x2 / tmp2, 0 }, { 0, 0, 1 } }; } @Override public double[] computeValue(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; double x3 = variables[2]; double tmp1; if (x1 == 0) { tmp1 = (x2 >= 0) ? 0.25 : -0.25; } else { tmp1 = FastMath.atan(x2 / x1) / twoPi; if (x1 < 0) { tmp1 += 0.5; } } double tmp2 = FastMath.sqrt(x1 * x1 + x2 * x2); return new double[] { 10.0 * (x3 - 10 * tmp1), 10.0 * (tmp2 - 1), x3 }; } private static final double twoPi = 2.0 * FastMath.PI; } private static class PowellSingularFunction extends MinpackFunction { public PowellSingularFunction(double[] startParams, double theoreticalStartCost) { super(4, startParams, 0.0, buildArray(4, 0.0)); } @Override public double[][] computeJacobian(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; double x3 = variables[2]; double x4 = variables[3]; return new double[][] { { 1, 10, 0, 0 }, { 0, 0, sqrt5, -sqrt5 }, { 0, 2 * (x2 - 2 * x3), -4 * (x2 - 2 * x3), 0 }, { 2 * sqrt10 * (x1 - x4), 0, 0, -2 * sqrt10 * (x1 - x4) } }; } @Override public double[] computeValue(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; double x3 = variables[2]; double x4 = variables[3]; return new double[] { x1 + 10 * x2, sqrt5 * (x3 - x4), (x2 - 2 * x3) * (x2 - 2 * x3), sqrt10 * (x1 - x4) * (x1 - x4) }; } private static final double sqrt5 = FastMath.sqrt( 5.0); private static final double sqrt10 = FastMath.sqrt(10.0); } private static class FreudensteinRothFunction extends MinpackFunction { public FreudensteinRothFunction(double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(2, startParams, theoreticalMinCost, theoreticalMinParams); } @Override public double[][] computeJacobian(double[] variables) { double x2 = variables[1]; return new double[][] { { 1, x2 * (10 - 3 * x2) - 2 }, { 1, x2 * ( 2 + 3 * x2) - 14, } }; } @Override public double[] computeValue(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; return new double[] { -13.0 + x1 + ((5.0 - x2) * x2 - 2.0) * x2, -29.0 + x1 + ((1.0 + x2) * x2 - 14.0) * x2 }; } } private static class BardFunction extends MinpackFunction { public BardFunction(double x0, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(15, buildArray(3, x0), theoreticalMinCost, theoreticalMinParams); } @Override public double[][] computeJacobian(double[] variables) { double x2 = variables[1]; double x3 = variables[2]; double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { double tmp1 = i + 1; double tmp2 = 15 - i; double tmp3 = (i <= 7) ? tmp1 : tmp2; double tmp4 = x2 * tmp2 + x3 * tmp3; tmp4 *= tmp4; jacobian[i] = new double[] { -1, tmp1 * tmp2 / tmp4, tmp1 * tmp3 / tmp4 }; } return jacobian; } @Override public double[] computeValue(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; double x3 = variables[2]; double[] f = new double[m]; for (int i = 0; i < m; ++i) { double tmp1 = i + 1; double tmp2 = 15 - i; double tmp3 = (i <= 7) ? tmp1 : tmp2; f[i] = y[i] - (x1 + tmp1 / (x2 * tmp2 + x3 * tmp3)); } return f; } private static final double[] y = { 0.14, 0.18, 0.22, 0.25, 0.29, 0.32, 0.35, 0.39, 0.37, 0.58, 0.73, 0.96, 1.34, 2.10, 4.39 }; } private static class KowalikOsborneFunction extends MinpackFunction { public KowalikOsborneFunction(double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(11, startParams, theoreticalMinCost, theoreticalMinParams); if (theoreticalStartCost > 20.0) { setCostAccuracy(2.0e-4); setParamsAccuracy(5.0e-3); } } @Override public double[][] computeJacobian(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; double x3 = variables[2]; double x4 = variables[3]; double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { double tmp = v[i] * (v[i] + x3) + x4; double j1 = -v[i] * (v[i] + x2) / tmp; double j2 = -v[i] * x1 / tmp; double j3 = j1 * j2; double j4 = j3 / v[i]; jacobian[i] = new double[] { j1, j2, j3, j4 }; } return jacobian; } @Override public double[] computeValue(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; double x3 = variables[2]; double x4 = variables[3]; double[] f = new double[m]; for (int i = 0; i < m; ++i) { f[i] = y[i] - x1 * (v[i] * (v[i] + x2)) / (v[i] * (v[i] + x3) + x4); } return f; } private static final double[] v = { 4.0, 2.0, 1.0, 0.5, 0.25, 0.167, 0.125, 0.1, 0.0833, 0.0714, 0.0625 }; private static final double[] y = { 0.1957, 0.1947, 0.1735, 0.1600, 0.0844, 0.0627, 0.0456, 0.0342, 0.0323, 0.0235, 0.0246 }; } private static class MeyerFunction extends MinpackFunction { public MeyerFunction(double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(16, startParams, theoreticalMinCost, theoreticalMinParams); if (theoreticalStartCost > 1.0e6) { setCostAccuracy(7.0e-3); setParamsAccuracy(2.0e-2); } } @Override public double[][] computeJacobian(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; double x3 = variables[2]; double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { double temp = 5.0 * (i + 1) + 45.0 + x3; double tmp1 = x2 / temp; double tmp2 = FastMath.exp(tmp1); double tmp3 = x1 * tmp2 / temp; jacobian[i] = new double[] { tmp2, tmp3, -tmp1 * tmp3 }; } return jacobian; } @Override public double[] computeValue(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; double x3 = variables[2]; double[] f = new double[m]; for (int i = 0; i < m; ++i) { f[i] = x1 * FastMath.exp(x2 / (5.0 * (i + 1) + 45.0 + x3)) - y[i]; } return f; } private static final double[] y = { 34780.0, 28610.0, 23650.0, 19630.0, 16370.0, 13720.0, 11540.0, 9744.0, 8261.0, 7030.0, 6005.0, 5147.0, 4427.0, 3820.0, 3307.0, 2872.0 }; } private static class WatsonFunction extends MinpackFunction { public WatsonFunction(int n, double x0, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(31, buildArray(n, x0), theoreticalMinCost, theoreticalMinParams); } @Override public double[][] computeJacobian(double[] variables) { double[][] jacobian = new double[m][]; for (int i = 0; i < (m - 2); ++i) { double div = (i + 1) / 29.0; double s2 = 0.0; double dx = 1.0; for (int j = 0; j < n; ++j) { s2 += dx * variables[j]; dx *= div; } double temp= 2 * div * s2; dx = 1.0 / div; jacobian[i] = new double[n]; for (int j = 0; j < n; ++j) { jacobian[i][j] = dx * (j - temp); dx *= div; } } jacobian[m - 2] = new double[n]; jacobian[m - 2][0] = 1; jacobian[m - 1] = new double[n]; jacobian[m - 1][0]= -2 * variables[0]; jacobian[m - 1][1]= 1; return jacobian; } @Override public double[] computeValue(double[] variables) { double[] f = new double[m]; for (int i = 0; i < (m - 2); ++i) { double div = (i + 1) / 29.0; double s1 = 0; double dx = 1; for (int j = 1; j < n; ++j) { s1 += j * dx * variables[j]; dx *= div; } double s2 = 0; dx = 1; for (int j = 0; j < n; ++j) { s2 += dx * variables[j]; dx *= div; } f[i] = s1 - s2 * s2 - 1; } double x1 = variables[0]; double x2 = variables[1]; f[m - 2] = x1; f[m - 1] = x2 - x1 * x1 - 1; return f; } } private static class Box3DimensionalFunction extends MinpackFunction { public Box3DimensionalFunction(int m, double[] startParams, double theoreticalStartCost) { super(m, startParams, 0.0, new double[] { 1.0, 10.0, 1.0 }); } @Override public double[][] computeJacobian(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { double tmp = (i + 1) / 10.0; jacobian[i] = new double[] { -tmp * FastMath.exp(-tmp * x1), tmp * FastMath.exp(-tmp * x2), FastMath.exp(-i - 1) - FastMath.exp(-tmp) }; } return jacobian; } @Override public double[] computeValue(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; double x3 = variables[2]; double[] f = new double[m]; for (int i = 0; i < m; ++i) { double tmp = (i + 1) / 10.0; f[i] = FastMath.exp(-tmp * x1) - FastMath.exp(-tmp * x2) + (FastMath.exp(-i - 1) - FastMath.exp(-tmp)) * x3; } return f; } } private static class JennrichSampsonFunction extends MinpackFunction { public JennrichSampsonFunction(int m, double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(m, startParams, theoreticalMinCost, theoreticalMinParams); } @Override public double[][] computeJacobian(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { double t = i + 1; jacobian[i] = new double[] { -t * FastMath.exp(t * x1), -t * FastMath.exp(t * x2) }; } return jacobian; } @Override public double[] computeValue(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; double[] f = new double[m]; for (int i = 0; i < m; ++i) { double temp = i + 1; f[i] = 2 + 2 * temp - FastMath.exp(temp * x1) - FastMath.exp(temp * x2); } return f; } } private static class BrownDennisFunction extends MinpackFunction { public BrownDennisFunction(int m, double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(m, startParams, theoreticalMinCost, theoreticalMinParams); setCostAccuracy(2.5e-8); } @Override public double[][] computeJacobian(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; double x3 = variables[2]; double x4 = variables[3]; double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { double temp = (i + 1) / 5.0; double ti = FastMath.sin(temp); double tmp1 = x1 + temp * x2 - FastMath.exp(temp); double tmp2 = x3 + ti * x4 - FastMath.cos(temp); jacobian[i] = new double[] { 2 * tmp1, 2 * temp * tmp1, 2 * tmp2, 2 * ti * tmp2 }; } return jacobian; } @Override public double[] computeValue(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; double x3 = variables[2]; double x4 = variables[3]; double[] f = new double[m]; for (int i = 0; i < m; ++i) { double temp = (i + 1) / 5.0; double tmp1 = x1 + temp * x2 - FastMath.exp(temp); double tmp2 = x3 + FastMath.sin(temp) * x4 - FastMath.cos(temp); f[i] = tmp1 * tmp1 + tmp2 * tmp2; } return f; } } private static class ChebyquadFunction extends MinpackFunction { private static double[] buildChebyquadArray(int n, double factor) { double[] array = new double[n]; double inv = factor / (n + 1); for (int i = 0; i < n; ++i) { array[i] = (i + 1) * inv; } return array; } public ChebyquadFunction(int n, int m, double factor, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(m, buildChebyquadArray(n, factor), theoreticalMinCost, theoreticalMinParams); } @Override public double[][] computeJacobian(double[] variables) { double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { jacobian[i] = new double[n]; } double dx = 1.0 / n; for (int j = 0; j < n; ++j) { double tmp1 = 1; double tmp2 = 2 * variables[j] - 1; double temp = 2 * tmp2; double tmp3 = 0; double tmp4 = 2; for (int i = 0; i < m; ++i) { jacobian[i][j] = dx * tmp4; double ti = 4 * tmp2 + temp * tmp4 - tmp3; tmp3 = tmp4; tmp4 = ti; ti = temp * tmp2 - tmp1; tmp1 = tmp2; tmp2 = ti; } } return jacobian; } @Override public double[] computeValue(double[] variables) { double[] f = new double[m]; for (int j = 0; j < n; ++j) { double tmp1 = 1; double tmp2 = 2 * variables[j] - 1; double temp = 2 * tmp2; for (int i = 0; i < m; ++i) { f[i] += tmp2; double ti = temp * tmp2 - tmp1; tmp1 = tmp2; tmp2 = ti; } } double dx = 1.0 / n; boolean iev = false; for (int i = 0; i < m; ++i) { f[i] *= dx; if (iev) { f[i] += 1.0 / (i * (i + 2)); } iev = ! iev; } return f; } } private static class BrownAlmostLinearFunction extends MinpackFunction { public BrownAlmostLinearFunction(int m, double factor, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(m, buildArray(m, factor), theoreticalMinCost, theoreticalMinParams); } @Override public double[][] computeJacobian(double[] variables) { double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { jacobian[i] = new double[n]; } double prod = 1; for (int j = 0; j < n; ++j) { prod *= variables[j]; for (int i = 0; i < n; ++i) { jacobian[i][j] = 1; } jacobian[j][j] = 2; } for (int j = 0; j < n; ++j) { double temp = variables[j]; if (temp == 0) { temp = 1; prod = 1; for (int k = 0; k < n; ++k) { if (k != j) { prod *= variables[k]; } } } jacobian[n - 1][j] = prod / temp; } return jacobian; } @Override public double[] computeValue(double[] variables) { double[] f = new double[m]; double sum = -(n + 1); double prod = 1; for (int j = 0; j < n; ++j) { sum += variables[j]; prod *= variables[j]; } for (int i = 0; i < n; ++i) { f[i] = variables[i] + sum; } f[n - 1] = prod - 1; return f; } } private static class Osborne1Function extends MinpackFunction { public Osborne1Function(double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(33, startParams, theoreticalMinCost, theoreticalMinParams); } @Override public double[][] computeJacobian(double[] variables) { double x2 = variables[1]; double x3 = variables[2]; double x4 = variables[3]; double x5 = variables[4]; double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { double temp = 10.0 * i; double tmp1 = FastMath.exp(-temp * x4); double tmp2 = FastMath.exp(-temp * x5); jacobian[i] = new double[] { -1, -tmp1, -tmp2, temp * x2 * tmp1, temp * x3 * tmp2 }; } return jacobian; } @Override public double[] computeValue(double[] variables) { double x1 = variables[0]; double x2 = variables[1]; double x3 = variables[2]; double x4 = variables[3]; double x5 = variables[4]; double[] f = new double[m]; for (int i = 0; i < m; ++i) { double temp = 10.0 * i; double tmp1 = FastMath.exp(-temp * x4); double tmp2 = FastMath.exp(-temp * x5); f[i] = y[i] - (x1 + x2 * tmp1 + x3 * tmp2); } return f; } private static final double[] y = { 0.844, 0.908, 0.932, 0.936, 0.925, 0.908, 0.881, 0.850, 0.818, 0.784, 0.751, 0.718, 0.685, 0.658, 0.628, 0.603, 0.580, 0.558, 0.538, 0.522, 0.506, 0.490, 0.478, 0.467, 0.457, 0.448, 0.438, 0.431, 0.424, 0.420, 0.414, 0.411, 0.406 }; } private static class Osborne2Function extends MinpackFunction { public Osborne2Function(double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(65, startParams, theoreticalMinCost, theoreticalMinParams); } @Override public double[][] computeJacobian(double[] variables) { double x01 = variables[0]; double x02 = variables[1]; double x03 = variables[2]; double x04 = variables[3]; double x05 = variables[4]; double x06 = variables[5]; double x07 = variables[6]; double x08 = variables[7]; double x09 = variables[8]; double x10 = variables[9]; double x11 = variables[10]; double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { double temp = i / 10.0; double tmp1 = FastMath.exp(-x05 * temp); double tmp2 = FastMath.exp(-x06 * (temp - x09) * (temp - x09)); double tmp3 = FastMath.exp(-x07 * (temp - x10) * (temp - x10)); double tmp4 = FastMath.exp(-x08 * (temp - x11) * (temp - x11)); jacobian[i] = new double[] { -tmp1, -tmp2, -tmp3, -tmp4, temp * x01 * tmp1, x02 * (temp - x09) * (temp - x09) * tmp2, x03 * (temp - x10) * (temp - x10) * tmp3, x04 * (temp - x11) * (temp - x11) * tmp4, -2 * x02 * x06 * (temp - x09) * tmp2, -2 * x03 * x07 * (temp - x10) * tmp3, -2 * x04 * x08 * (temp - x11) * tmp4 }; } return jacobian; } @Override public double[] computeValue(double[] variables) { double x01 = variables[0]; double x02 = variables[1]; double x03 = variables[2]; double x04 = variables[3]; double x05 = variables[4]; double x06 = variables[5]; double x07 = variables[6]; double x08 = variables[7]; double x09 = variables[8]; double x10 = variables[9]; double x11 = variables[10]; double[] f = new double[m]; for (int i = 0; i < m; ++i) { double temp = i / 10.0; double tmp1 = FastMath.exp(-x05 * temp); double tmp2 = FastMath.exp(-x06 * (temp - x09) * (temp - x09)); double tmp3 = FastMath.exp(-x07 * (temp - x10) * (temp - x10)); double tmp4 = FastMath.exp(-x08 * (temp - x11) * (temp - x11)); f[i] = y[i] - (x01 * tmp1 + x02 * tmp2 + x03 * tmp3 + x04 * tmp4); } return f; } private static final double[] y = { 1.366, 1.191, 1.112, 1.013, 0.991, 0.885, 0.831, 0.847, 0.786, 0.725, 0.746, 0.679, 0.608, 0.655, 0.616, 0.606, 0.602, 0.626, 0.651, 0.724, 0.649, 0.649, 0.694, 0.644, 0.624, 0.661, 0.612, 0.558, 0.533, 0.495, 0.500, 0.423, 0.395, 0.375, 0.372, 0.391, 0.396, 0.405, 0.428, 0.429, 0.523, 0.562, 0.607, 0.653, 0.672, 0.708, 0.633, 0.668, 0.645, 0.632, 0.591, 0.559, 0.597, 0.625, 0.739, 0.710, 0.729, 0.720, 0.636, 0.581, 0.428, 0.292, 0.162, 0.098, 0.054 }; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optim.univariate; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.optim.nonlinear.scalar.GoalType; import org.junit.Assert; import org.junit.Test; /** * Test for {@link BracketFinder}. */ public class BracketFinderTest { @Test public void testCubicMin() { final BracketFinder bFind = new BracketFinder(); final UnivariateFunction func = new UnivariateFunction() { public double value(double x) { if (x < -2) { return value(-2); } else { return (x - 1) * (x + 2) * (x + 3); } } }; bFind.search(func, GoalType.MINIMIZE, -2 , -1); final double tol = 1e-15; // Comparing with results computed in Python. Assert.assertEquals(-2, bFind.getLo(), tol); Assert.assertEquals(-1, bFind.getMid(), tol); Assert.assertEquals(0.61803399999999997, bFind.getHi(), tol); } @Test public void testCubicMax() { final BracketFinder bFind = new BracketFinder(); final UnivariateFunction func = new UnivariateFunction() { public double value(double x) { if (x < -2) { return value(-2); } else { return -(x - 1) * (x + 2) * (x + 3); } } }; bFind.search(func, GoalType.MAXIMIZE, -2 , -1); final double tol = 1e-15; Assert.assertEquals(-2, bFind.getLo(), tol); Assert.assertEquals(-1, bFind.getMid(), tol); Assert.assertEquals(0.61803399999999997, bFind.getHi(), tol); } @Test public void testMinimumIsOnIntervalBoundary() { final UnivariateFunction func = new UnivariateFunction() { public double value(double x) { return x * x; } }; final BracketFinder bFind = new BracketFinder(); bFind.search(func, GoalType.MINIMIZE, 0, 1); Assert.assertTrue(bFind.getLo() <= 0); Assert.assertTrue(0 <= bFind.getHi()); bFind.search(func, GoalType.MINIMIZE, -1, 0); Assert.assertTrue(bFind.getLo() <= 0); Assert.assertTrue(0 <= bFind.getHi()); } @Test public void testIntervalBoundsOrdering() { final UnivariateFunction func = new UnivariateFunction() { public double value(double x) { return x * x; } }; final BracketFinder bFind = new BracketFinder(); bFind.search(func, GoalType.MINIMIZE, -1, 1); Assert.assertTrue(bFind.getLo() <= 0); Assert.assertTrue(0 <= bFind.getHi()); bFind.search(func, GoalType.MINIMIZE, 1, -1); Assert.assertTrue(bFind.getLo() <= 0); Assert.assertTrue(0 <= bFind.getHi()); bFind.search(func, GoalType.MINIMIZE, 1, 2); Assert.assertTrue(bFind.getLo() <= 0); Assert.assertTrue(0 <= bFind.getHi()); bFind.search(func, GoalType.MINIMIZE, 2, 1); Assert.assertTrue(bFind.getLo() <= 0); Assert.assertTrue(0 <= bFind.getHi()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optim.univariate; import org.apache.commons.math3.analysis.QuinticFunction; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.function.Sin; import org.apache.commons.math3.analysis.function.StepFunction; import org.apache.commons.math3.analysis.FunctionUtils; import org.apache.commons.math3.exception.NumberIsTooLargeException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.exception.TooManyEvaluationsException; import org.apache.commons.math3.optim.ConvergenceChecker; import org.apache.commons.math3.optim.nonlinear.scalar.GoalType; import org.apache.commons.math3.optim.MaxEval; import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * @version $Id$ */ public final class BrentOptimizerTest { @Test public void testSinMin() { UnivariateFunction f = new Sin(); UnivariateOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14); Assert.assertEquals(3 * Math.PI / 2, optimizer.optimize(new MaxEval(200), new UnivariateObjectiveFunction(f), GoalType.MINIMIZE, new SearchInterval(4, 5)).getPoint(), 1e-8); Assert.assertTrue(optimizer.getEvaluations() <= 50); Assert.assertEquals(200, optimizer.getMaxEvaluations()); Assert.assertEquals(3 * Math.PI / 2, optimizer.optimize(new MaxEval(200), new UnivariateObjectiveFunction(f), GoalType.MINIMIZE, new SearchInterval(1, 5)).getPoint(), 1e-8); Assert.assertTrue(optimizer.getEvaluations() <= 100); Assert.assertTrue(optimizer.getEvaluations() >= 15); try { optimizer.optimize(new MaxEval(10), new UnivariateObjectiveFunction(f), GoalType.MINIMIZE, new SearchInterval(4, 5)); Assert.fail("an exception should have been thrown"); } catch (TooManyEvaluationsException fee) { // expected } } @Test public void testSinMinWithValueChecker() { final UnivariateFunction f = new Sin(); final ConvergenceChecker<UnivariatePointValuePair> checker = new SimpleUnivariateValueChecker(1e-5, 1e-14); // The default stopping criterion of Brent's algorithm should not // pass, but the search will stop at the given relative tolerance // for the function value. final UnivariateOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14, checker); final UnivariatePointValuePair result = optimizer.optimize(new MaxEval(200), new UnivariateObjectiveFunction(f), GoalType.MINIMIZE, new SearchInterval(4, 5)); Assert.assertEquals(3 * Math.PI / 2, result.getPoint(), 1e-3); } @Test public void testBoundaries() { final double lower = -1.0; final double upper = +1.0; UnivariateFunction f = new UnivariateFunction() { public double value(double x) { if (x < lower) { throw new NumberIsTooSmallException(x, lower, true); } else if (x > upper) { throw new NumberIsTooLargeException(x, upper, true); } else { return x; } } }; UnivariateOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14); Assert.assertEquals(lower, optimizer.optimize(new MaxEval(100), new UnivariateObjectiveFunction(f), GoalType.MINIMIZE, new SearchInterval(lower, upper)).getPoint(), 1.0e-8); Assert.assertEquals(upper, optimizer.optimize(new MaxEval(100), new UnivariateObjectiveFunction(f), GoalType.MAXIMIZE, new SearchInterval(lower, upper)).getPoint(), 1.0e-8); } @Test public void testQuinticMin() { // The function has local minima at -0.27195613 and 0.82221643. UnivariateFunction f = new QuinticFunction(); UnivariateOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14); Assert.assertEquals(-0.27195613, optimizer.optimize(new MaxEval(200), new UnivariateObjectiveFunction(f), GoalType.MINIMIZE, new SearchInterval(-0.3, -0.2)).getPoint(), 1.0e-8); Assert.assertEquals( 0.82221643, optimizer.optimize(new MaxEval(200), new UnivariateObjectiveFunction(f), GoalType.MINIMIZE, new SearchInterval(0.3, 0.9)).getPoint(), 1.0e-8); Assert.assertTrue(optimizer.getEvaluations() <= 50); // search in a large interval Assert.assertEquals(-0.27195613, optimizer.optimize(new MaxEval(200), new UnivariateObjectiveFunction(f), GoalType.MINIMIZE, new SearchInterval(-1.0, 0.2)).getPoint(), 1.0e-8); Assert.assertTrue(optimizer.getEvaluations() <= 50); } @Test public void testQuinticMinStatistics() { // The function has local minima at -0.27195613 and 0.82221643. UnivariateFunction f = new QuinticFunction(); UnivariateOptimizer optimizer = new BrentOptimizer(1e-11, 1e-14); final DescriptiveStatistics[] stat = new DescriptiveStatistics[2]; for (int i = 0; i < stat.length; i++) { stat[i] = new DescriptiveStatistics(); } final double min = -0.75; final double max = 0.25; final int nSamples = 200; final double delta = (max - min) / nSamples; for (int i = 0; i < nSamples; i++) { final double start = min + i * delta; stat[0].addValue(optimizer.optimize(new MaxEval(40), new UnivariateObjectiveFunction(f), GoalType.MINIMIZE, new SearchInterval(min, max, start)).getPoint()); stat[1].addValue(optimizer.getEvaluations()); } final double meanOptValue = stat[0].getMean(); final double medianEval = stat[1].getPercentile(50); Assert.assertTrue(meanOptValue > -0.2719561281); Assert.assertTrue(meanOptValue < -0.2719561280); Assert.assertEquals(23, (int) medianEval); } @Test public void testQuinticMax() { // The quintic function has zeros at 0, +-0.5 and +-1. // The function has a local maximum at 0.27195613. UnivariateFunction f = new QuinticFunction(); UnivariateOptimizer optimizer = new BrentOptimizer(1e-12, 1e-14); Assert.assertEquals(0.27195613, optimizer.optimize(new MaxEval(100), new UnivariateObjectiveFunction(f), GoalType.MAXIMIZE, new SearchInterval(0.2, 0.3)).getPoint(), 1e-8); try { optimizer.optimize(new MaxEval(5), new UnivariateObjectiveFunction(f), GoalType.MAXIMIZE, new SearchInterval(0.2, 0.3)); Assert.fail("an exception should have been thrown"); } catch (TooManyEvaluationsException miee) { // expected } } @Test public void testMinEndpoints() { UnivariateFunction f = new Sin(); UnivariateOptimizer optimizer = new BrentOptimizer(1e-8, 1e-14); // endpoint is minimum double result = optimizer.optimize(new MaxEval(50), new UnivariateObjectiveFunction(f), GoalType.MINIMIZE, new SearchInterval(3 * Math.PI / 2, 5)).getPoint(); Assert.assertEquals(3 * Math.PI / 2, result, 1e-6); result = optimizer.optimize(new MaxEval(50), new UnivariateObjectiveFunction(f), GoalType.MINIMIZE, new SearchInterval(4, 3 * Math.PI / 2)).getPoint(); Assert.assertEquals(3 * Math.PI / 2, result, 1e-6); } @Test public void testMath832() { final UnivariateFunction f = new UnivariateFunction() { public double value(double x) { final double sqrtX = FastMath.sqrt(x); final double a = 1e2 * sqrtX; final double b = 1e6 / x; final double c = 1e4 / sqrtX; return a + b + c; } }; UnivariateOptimizer optimizer = new BrentOptimizer(1e-10, 1e-8); final double result = optimizer.optimize(new MaxEval(1483), new UnivariateObjectiveFunction(f), GoalType.MINIMIZE, new SearchInterval(Double.MIN_VALUE, Double.MAX_VALUE)).getPoint(); Assert.assertEquals(804.9355825, result, 1e-6); } /** * Contrived example showing that prior to the resolution of MATH-855 * (second revision), the algorithm would not return the best point if * it happened to be the initial guess. */ @Test public void testKeepInitIfBest() { final double minSin = 3 * Math.PI / 2; final double offset = 1e-8; final double delta = 1e-7; final UnivariateFunction f1 = new Sin(); final UnivariateFunction f2 = new StepFunction(new double[] { minSin, minSin + offset, minSin + 2 * offset}, new double[] { 0, -1, 0 }); final UnivariateFunction f = FunctionUtils.add(f1, f2); // A slightly less stringent tolerance would make the test pass // even with the previous implementation. final double relTol = 1e-8; final UnivariateOptimizer optimizer = new BrentOptimizer(relTol, 1e-100); final double init = minSin + 1.5 * offset; final UnivariatePointValuePair result = optimizer.optimize(new MaxEval(200), new UnivariateObjectiveFunction(f), GoalType.MINIMIZE, new SearchInterval(minSin - 6.789 * delta, minSin + 9.876 * delta, init)); final int numEval = optimizer.getEvaluations(); final double sol = result.getPoint(); final double expected = init; // System.out.println("numEval=" + numEval); // System.out.println("min=" + init + " f=" + f.value(init)); // System.out.println("sol=" + sol + " f=" + f.value(sol)); // System.out.println("exp=" + expected + " f=" + f.value(expected)); Assert.assertTrue("Best point not reported", f.value(sol) <= f.value(expected)); } /** * Contrived example showing that prior to the resolution of MATH-855, * the algorithm, by always returning the last evaluated point, would * sometimes not report the best point it had found. */ @Test public void testMath855() { final double minSin = 3 * Math.PI / 2; final double offset = 1e-8; final double delta = 1e-7; final UnivariateFunction f1 = new Sin(); final UnivariateFunction f2 = new StepFunction(new double[] { minSin, minSin + offset, minSin + 5 * offset }, new double[] { 0, -1, 0 }); final UnivariateFunction f = FunctionUtils.add(f1, f2); final UnivariateOptimizer optimizer = new BrentOptimizer(1e-8, 1e-100); final UnivariatePointValuePair result = optimizer.optimize(new MaxEval(200), new UnivariateObjectiveFunction(f), GoalType.MINIMIZE, new SearchInterval(minSin - 6.789 * delta, minSin + 9.876 * delta)); final int numEval = optimizer.getEvaluations(); final double sol = result.getPoint(); final double expected = 4.712389027602411; // System.out.println("min=" + (minSin + offset) + " f=" + f.value(minSin + offset)); // System.out.println("sol=" + sol + " f=" + f.value(sol)); // System.out.println("exp=" + expected + " f=" + f.value(expected)); Assert.assertTrue("Best point not reported", f.value(sol) <= f.value(expected)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optim.univariate; import org.apache.commons.math3.analysis.QuinticFunction; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.function.Sin; import org.apache.commons.math3.optim.nonlinear.scalar.GoalType; import org.apache.commons.math3.optim.MaxEval; import org.apache.commons.math3.random.JDKRandomGenerator; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.exception.MathIllegalStateException; import org.junit.Assert; import org.junit.Test; public class MultiStartUnivariateOptimizerTest { @Test(expected=MathIllegalStateException.class) public void testMissingMaxEval() { UnivariateOptimizer underlying = new BrentOptimizer(1e-10, 1e-14); JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(44428400075l); MultiStartUnivariateOptimizer optimizer = new MultiStartUnivariateOptimizer(underlying, 10, g); optimizer.optimize(new UnivariateObjectiveFunction(new Sin()), GoalType.MINIMIZE, new SearchInterval(-1, 1)); } @Test(expected=MathIllegalStateException.class) public void testMissingSearchInterval() { UnivariateOptimizer underlying = new BrentOptimizer(1e-10, 1e-14); JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(44428400075l); MultiStartUnivariateOptimizer optimizer = new MultiStartUnivariateOptimizer(underlying, 10, g); optimizer.optimize(new MaxEval(300), new UnivariateObjectiveFunction(new Sin()), GoalType.MINIMIZE); } @Test public void testSinMin() { UnivariateFunction f = new Sin(); UnivariateOptimizer underlying = new BrentOptimizer(1e-10, 1e-14); JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(44428400075l); MultiStartUnivariateOptimizer optimizer = new MultiStartUnivariateOptimizer(underlying, 10, g); optimizer.optimize(new MaxEval(300), new UnivariateObjectiveFunction(f), GoalType.MINIMIZE, new SearchInterval(-100.0, 100.0)); UnivariatePointValuePair[] optima = optimizer.getOptima(); for (int i = 1; i < optima.length; ++i) { double d = (optima[i].getPoint() - optima[i-1].getPoint()) / (2 * FastMath.PI); Assert.assertTrue(FastMath.abs(d - FastMath.rint(d)) < 1.0e-8); Assert.assertEquals(-1.0, f.value(optima[i].getPoint()), 1.0e-10); Assert.assertEquals(f.value(optima[i].getPoint()), optima[i].getValue(), 1.0e-10); } Assert.assertTrue(optimizer.getEvaluations() > 200); Assert.assertTrue(optimizer.getEvaluations() < 300); } @Test public void testQuinticMin() { // The quintic function has zeros at 0, +-0.5 and +-1. // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643, UnivariateFunction f = new QuinticFunction(); UnivariateOptimizer underlying = new BrentOptimizer(1e-9, 1e-14); JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(4312000053L); MultiStartUnivariateOptimizer optimizer = new MultiStartUnivariateOptimizer(underlying, 5, g); UnivariatePointValuePair optimum = optimizer.optimize(new MaxEval(300), new UnivariateObjectiveFunction(f), GoalType.MINIMIZE, new SearchInterval(-0.3, -0.2)); Assert.assertEquals(-0.27195613, optimum.getPoint(), 1e-9); Assert.assertEquals(-0.0443342695, optimum.getValue(), 1e-9); UnivariatePointValuePair[] optima = optimizer.getOptima(); for (int i = 0; i < optima.length; ++i) { Assert.assertEquals(f.value(optima[i].getPoint()), optima[i].getValue(), 1e-9); } Assert.assertTrue(optimizer.getEvaluations() >= 50); Assert.assertTrue(optimizer.getEvaluations() <= 100); } @Test public void testBadFunction() { UnivariateFunction f = new UnivariateFunction() { public double value(double x) { if (x < 0) { throw new LocalException(); } return 0; } }; UnivariateOptimizer underlying = new BrentOptimizer(1e-9, 1e-14); JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(4312000053L); MultiStartUnivariateOptimizer optimizer = new MultiStartUnivariateOptimizer(underlying, 5, g); try { optimizer.optimize(new MaxEval(300), new UnivariateObjectiveFunction(f), GoalType.MINIMIZE, new SearchInterval(-0.3, -0.2)); Assert.fail(); } catch (LocalException e) { // Expected. } // Ensure that the exception was thrown because no optimum was found. Assert.assertTrue(optimizer.getOptima()[0] == null); } private static class LocalException extends RuntimeException { private static final long serialVersionUID = 1194682757034350629L; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optim.univariate; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.junit.Test; import org.junit.Assert; public class SimpleUnivariateValueCheckerTest { @Test(expected=NotStrictlyPositiveException.class) public void testIterationCheckPrecondition() { new SimpleUnivariateValueChecker(1e-1, 1e-2, 0); } @Test public void testIterationCheck() { final int max = 10; final SimpleUnivariateValueChecker checker = new SimpleUnivariateValueChecker(1e-1, 1e-2, max); Assert.assertTrue(checker.converged(max, null, null)); Assert.assertTrue(checker.converged(max + 1, null, null)); } @Test public void testIterationCheckDisabled() { final SimpleUnivariateValueChecker checker = new SimpleUnivariateValueChecker(1e-8, 1e-8); final UnivariatePointValuePair a = new UnivariatePointValuePair(1d, 1d); final UnivariatePointValuePair b = new UnivariatePointValuePair(10d, 10d); Assert.assertFalse(checker.converged(-1, a, b)); Assert.assertFalse(checker.converged(0, a, b)); Assert.assertFalse(checker.converged(1000000, a, b)); Assert.assertTrue(checker.converged(-1, a, a)); Assert.assertTrue(checker.converged(-1, b, b)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optimization; import org.apache.commons.math3.analysis.differentiation.MultivariateDifferentiableFunction; import org.apache.commons.math3.geometry.euclidean.twod.Vector2D; import org.apache.commons.math3.optimization.general.CircleScalar; import org.apache.commons.math3.optimization.general.ConjugateGradientFormula; import org.apache.commons.math3.optimization.general.NonLinearConjugateGradientOptimizer; import org.apache.commons.math3.random.GaussianRandomGenerator; import org.apache.commons.math3.random.JDKRandomGenerator; import org.apache.commons.math3.random.RandomVectorGenerator; import org.apache.commons.math3.random.UncorrelatedRandomVectorGenerator; import org.junit.Assert; import org.junit.Test; public class MultivariateDifferentiableMultiStartOptimizerTest { @Test public void testCircleFitting() { CircleScalar circle = new CircleScalar(); circle.addPoint( 30.0, 68.0); circle.addPoint( 50.0, -6.0); circle.addPoint(110.0, -20.0); circle.addPoint( 35.0, 15.0); circle.addPoint( 45.0, 97.0); // TODO: the wrapper around NonLinearConjugateGradientOptimizer is a temporary hack for // version 3.1 of the library. It should be removed when NonLinearConjugateGradientOptimizer // will officially be declared as implementing MultivariateDifferentiableOptimizer MultivariateDifferentiableOptimizer underlying = new MultivariateDifferentiableOptimizer() { private final NonLinearConjugateGradientOptimizer cg = new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE, new SimpleValueChecker(1.0e-10, 1.0e-10)); public PointValuePair optimize(int maxEval, MultivariateDifferentiableFunction f, GoalType goalType, double[] startPoint) { return cg.optimize(maxEval, f, goalType, startPoint); } public int getMaxEvaluations() { return cg.getMaxEvaluations(); } public int getEvaluations() { return cg.getEvaluations(); } public ConvergenceChecker<PointValuePair> getConvergenceChecker() { return cg.getConvergenceChecker(); } }; JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(753289573253l); RandomVectorGenerator generator = new UncorrelatedRandomVectorGenerator(new double[] { 50.0, 50.0 }, new double[] { 10.0, 10.0 }, new GaussianRandomGenerator(g)); MultivariateDifferentiableMultiStartOptimizer optimizer = new MultivariateDifferentiableMultiStartOptimizer(underlying, 10, generator); PointValuePair optimum = optimizer.optimize(200, circle, GoalType.MINIMIZE, new double[] { 98.680, 47.345 }); Assert.assertEquals(200, optimizer.getMaxEvaluations()); PointValuePair[] optima = optimizer.getOptima(); for (PointValuePair o : optima) { Vector2D center = new Vector2D(o.getPointRef()[0], o.getPointRef()[1]); Assert.assertEquals(69.960161753, circle.getRadius(center), 1.0e-8); Assert.assertEquals(96.075902096, center.getX(), 1.0e-8); Assert.assertEquals(48.135167894, center.getY(), 1.0e-8); } Assert.assertTrue(optimizer.getEvaluations() > 70); Assert.assertTrue(optimizer.getEvaluations() < 90); Assert.assertEquals(3.1267527, optimum.getValue(), 1.0e-8); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optimization; import org.apache.commons.math3.analysis.differentiation.DerivativeStructure; import org.apache.commons.math3.analysis.differentiation.MultivariateDifferentiableVectorFunction; import org.apache.commons.math3.exception.MathIllegalStateException; import org.apache.commons.math3.linear.BlockRealMatrix; import org.apache.commons.math3.linear.RealMatrix; import org.apache.commons.math3.optimization.general.GaussNewtonOptimizer; import org.apache.commons.math3.random.GaussianRandomGenerator; import org.apache.commons.math3.random.JDKRandomGenerator; import org.apache.commons.math3.random.RandomVectorGenerator; import org.apache.commons.math3.random.UncorrelatedRandomVectorGenerator; import org.junit.Assert; import org.junit.Test; /** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files. * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> * Minpack Copyright Notice (1999) University of Chicago. * All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> * <li>Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above * copyright notice, this list of conditions and the following * disclaimer in the documentation and/or other materials provided * with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, * must include the following acknowledgment: * <code>This product includes software developed by the University of * Chicago, as Operator of Argonne National Laboratory.</code> * Alternately, this acknowledgment may appear in the software itself, * if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" * WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE * UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND * THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE * OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY * OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR * USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF * THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) * DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION * UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL * BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT * HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF * ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, * INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF * ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF * PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER * SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT * (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, * EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE * POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */ public class MultivariateDifferentiableVectorMultiStartOptimizerTest { @Test public void testTrivial() { LinearProblem problem = new LinearProblem(new double[][] { { 2 } }, new double[] { 3 }); // TODO: the wrapper around GaussNewtonOptimizer is a temporary hack for // version 3.1 of the library. It should be removed when GaussNewtonOptimizer // will officialy be declared as implementing MultivariateDifferentiableVectorOptimizer MultivariateDifferentiableVectorOptimizer underlyingOptimizer = new MultivariateDifferentiableVectorOptimizer() { private GaussNewtonOptimizer gn = new GaussNewtonOptimizer(true, new SimpleVectorValueChecker(1.0e-6, 1.0e-6)); public PointVectorValuePair optimize(int maxEval, MultivariateDifferentiableVectorFunction f, double[] target, double[] weight, double[] startPoint) { return gn.optimize(maxEval, f, target, weight, startPoint); } public int getMaxEvaluations() { return gn.getMaxEvaluations(); } public int getEvaluations() { return gn.getEvaluations(); } public ConvergenceChecker<PointVectorValuePair> getConvergenceChecker() { return gn.getConvergenceChecker(); } }; JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(16069223052l); RandomVectorGenerator generator = new UncorrelatedRandomVectorGenerator(1, new GaussianRandomGenerator(g)); MultivariateDifferentiableVectorMultiStartOptimizer optimizer = new MultivariateDifferentiableVectorMultiStartOptimizer(underlyingOptimizer, 10, generator); // no optima before first optimization attempt try { optimizer.getOptima(); Assert.fail("an exception should have been thrown"); } catch (MathIllegalStateException ise) { // expected } PointVectorValuePair optimum = optimizer.optimize(100, problem, problem.target, new double[] { 1 }, new double[] { 0 }); Assert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10); Assert.assertEquals(3.0, optimum.getValue()[0], 1.0e-10); PointVectorValuePair[] optima = optimizer.getOptima(); Assert.assertEquals(10, optima.length); for (int i = 0; i < optima.length; ++i) { Assert.assertEquals(1.5, optima[i].getPoint()[0], 1.0e-10); Assert.assertEquals(3.0, optima[i].getValue()[0], 1.0e-10); } Assert.assertTrue(optimizer.getEvaluations() > 20); Assert.assertTrue(optimizer.getEvaluations() < 50); Assert.assertEquals(100, optimizer.getMaxEvaluations()); } @Test(expected=TestException.class) public void testNoOptimum() { // TODO: the wrapper around GaussNewtonOptimizer is a temporary hack for // version 3.1 of the library. It should be removed when GaussNewtonOptimizer // will officialy be declared as implementing MultivariateDifferentiableVectorOptimizer MultivariateDifferentiableVectorOptimizer underlyingOptimizer = new MultivariateDifferentiableVectorOptimizer() { private GaussNewtonOptimizer gn = new GaussNewtonOptimizer(true, new SimpleVectorValueChecker(1.0e-6, 1.0e-6)); public PointVectorValuePair optimize(int maxEval, MultivariateDifferentiableVectorFunction f, double[] target, double[] weight, double[] startPoint) { return gn.optimize(maxEval, f, target, weight, startPoint); } public int getMaxEvaluations() { return gn.getMaxEvaluations(); } public int getEvaluations() { return gn.getEvaluations(); } public ConvergenceChecker<PointVectorValuePair> getConvergenceChecker() { return gn.getConvergenceChecker(); } }; JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(12373523445l); RandomVectorGenerator generator = new UncorrelatedRandomVectorGenerator(1, new GaussianRandomGenerator(g)); MultivariateDifferentiableVectorMultiStartOptimizer optimizer = new MultivariateDifferentiableVectorMultiStartOptimizer(underlyingOptimizer, 10, generator); optimizer.optimize(100, new MultivariateDifferentiableVectorFunction() { public double[] value(double[] point) { throw new TestException(); } public DerivativeStructure[] value(DerivativeStructure[] point) { return point; } }, new double[] { 2 }, new double[] { 1 }, new double[] { 0 }); } private static class TestException extends RuntimeException { private static final long serialVersionUID = -7809988995389067683L; } private static class LinearProblem implements MultivariateDifferentiableVectorFunction { final RealMatrix factors; final double[] target; public LinearProblem(double[][] factors, double[] target) { this.factors = new BlockRealMatrix(factors); this.target = target; } public double[] value(double[] variables) { return factors.operate(variables); } public DerivativeStructure[] value(DerivativeStructure[] variables) { DerivativeStructure[] y = new DerivativeStructure[factors.getRowDimension()]; for (int i = 0; i < y.length; ++i) { y[i] = variables[0].getField().getZero(); for (int j = 0; j < factors.getColumnDimension(); ++j) { y[i] = y[i].add(variables[j].multiply(factors.getEntry(i, j))); } } return y; } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optimization; import org.apache.commons.math3.analysis.MultivariateFunction; import org.apache.commons.math3.optimization.direct.NelderMeadSimplex; import org.apache.commons.math3.optimization.direct.SimplexOptimizer; import org.apache.commons.math3.random.GaussianRandomGenerator; import org.apache.commons.math3.random.JDKRandomGenerator; import org.apache.commons.math3.random.RandomVectorGenerator; import org.apache.commons.math3.random.UncorrelatedRandomVectorGenerator; import org.junit.Assert; import org.junit.Test; public class MultivariateMultiStartOptimizerTest { @Test public void testRosenbrock() { Rosenbrock rosenbrock = new Rosenbrock(); SimplexOptimizer underlying = new SimplexOptimizer(new SimpleValueChecker(-1, 1.0e-3)); NelderMeadSimplex simplex = new NelderMeadSimplex(new double[][] { { -1.2, 1.0 }, { 0.9, 1.2 } , { 3.5, -2.3 } }); underlying.setSimplex(simplex); JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(16069223052l); RandomVectorGenerator generator = new UncorrelatedRandomVectorGenerator(2, new GaussianRandomGenerator(g)); MultivariateMultiStartOptimizer optimizer = new MultivariateMultiStartOptimizer(underlying, 10, generator); PointValuePair optimum = optimizer.optimize(1100, rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1.0 }); Assert.assertEquals(rosenbrock.getCount(), optimizer.getEvaluations()); Assert.assertTrue(optimizer.getEvaluations() > 900); Assert.assertTrue(optimizer.getEvaluations() < 1200); Assert.assertTrue(optimum.getValue() < 8.0e-4); } private static class Rosenbrock implements MultivariateFunction { private int count; public Rosenbrock() { count = 0; } public double value(double[] x) { ++count; double a = x[1] - x[0] * x[0]; double b = 1.0 - x[0]; return 100 * a * a + b * b; } public int getCount() { return count; } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optimization; import org.apache.commons.math3.TestUtils; import org.junit.Assert; import org.junit.Test; public class PointValuePairTest { @Test public void testSerial() { PointValuePair pv1 = new PointValuePair(new double[] { 1.0, 2.0, 3.0 }, 4.0); PointValuePair pv2 = (PointValuePair) TestUtils.serializeAndRecover(pv1); Assert.assertEquals(pv1.getKey().length, pv2.getKey().length); for (int i = 0; i < pv1.getKey().length; ++i) { Assert.assertEquals(pv1.getKey()[i], pv2.getKey()[i], 1.0e-15); } Assert.assertEquals(pv1.getValue(), pv2.getValue(), 1.0e-15); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optimization; import org.apache.commons.math3.TestUtils; import org.junit.Assert; import org.junit.Test; public class PointVectorValuePairTest { @Test public void testSerial() { PointVectorValuePair pv1 = new PointVectorValuePair(new double[] { 1.0, 2.0, 3.0 }, new double[] { 4.0, 5.0 }); PointVectorValuePair pv2 = (PointVectorValuePair) TestUtils.serializeAndRecover(pv1); Assert.assertEquals(pv1.getKey().length, pv2.getKey().length); for (int i = 0; i < pv1.getKey().length; ++i) { Assert.assertEquals(pv1.getKey()[i], pv2.getKey()[i], 1.0e-15); } Assert.assertEquals(pv1.getValue().length, pv2.getValue().length); for (int i = 0; i < pv1.getValue().length; ++i) { Assert.assertEquals(pv1.getValue()[i], pv2.getValue()[i], 1.0e-15); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optimization; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.junit.Test; import org.junit.Assert; public class SimplePointCheckerTest { @Test(expected=NotStrictlyPositiveException.class) public void testIterationCheckPrecondition() { new SimplePointChecker<PointValuePair>(1e-1, 1e-2, 0); } @Test public void testIterationCheck() { final int max = 10; final SimplePointChecker<PointValuePair> checker = new SimplePointChecker<PointValuePair>(1e-1, 1e-2, max); Assert.assertTrue(checker.converged(max, null, null)); Assert.assertTrue(checker.converged(max + 1, null, null)); } @Test public void testIterationCheckDisabled() { final SimplePointChecker<PointValuePair> checker = new SimplePointChecker<PointValuePair>(1e-8, 1e-8); final PointValuePair a = new PointValuePair(new double[] { 1d }, 1d); final PointValuePair b = new PointValuePair(new double[] { 10d }, 10d); Assert.assertFalse(checker.converged(-1, a, b)); Assert.assertFalse(checker.converged(0, a, b)); Assert.assertFalse(checker.converged(1000000, a, b)); Assert.assertTrue(checker.converged(-1, a, a)); Assert.assertTrue(checker.converged(-1, b, b)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optimization; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.junit.Test; import org.junit.Assert; public class SimpleValueCheckerTest { @Test(expected=NotStrictlyPositiveException.class) public void testIterationCheckPrecondition() { new SimpleValueChecker(1e-1, 1e-2, 0); } @Test public void testIterationCheck() { final int max = 10; final SimpleValueChecker checker = new SimpleValueChecker(1e-1, 1e-2, max); Assert.assertTrue(checker.converged(max, null, null)); Assert.assertTrue(checker.converged(max + 1, null, null)); } @Test public void testIterationCheckDisabled() { final SimpleValueChecker checker = new SimpleValueChecker(1e-8, 1e-8); final PointValuePair a = new PointValuePair(new double[] { 1d }, 1d); final PointValuePair b = new PointValuePair(new double[] { 10d }, 10d); Assert.assertFalse(checker.converged(-1, a, b)); Assert.assertFalse(checker.converged(0, a, b)); Assert.assertFalse(checker.converged(1000000, a, b)); Assert.assertTrue(checker.converged(-1, a, a)); Assert.assertTrue(checker.converged(-1, b, b)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optimization; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.junit.Test; import org.junit.Assert; public class SimpleVectorValueCheckerTest { @Test(expected=NotStrictlyPositiveException.class) public void testIterationCheckPrecondition() { new SimpleVectorValueChecker(1e-1, 1e-2, 0); } @Test public void testIterationCheck() { final int max = 10; final SimpleVectorValueChecker checker = new SimpleVectorValueChecker(1e-1, 1e-2, max); Assert.assertTrue(checker.converged(max, null, null)); Assert.assertTrue(checker.converged(max + 1, null, null)); } @Test public void testIterationCheckDisabled() { final SimpleVectorValueChecker checker = new SimpleVectorValueChecker(1e-8, 1e-8); final PointVectorValuePair a = new PointVectorValuePair(new double[] { 1d }, new double[] { 1d }); final PointVectorValuePair b = new PointVectorValuePair(new double[] { 10d }, new double[] { 10d }); Assert.assertFalse(checker.converged(-1, a, b)); Assert.assertFalse(checker.converged(0, a, b)); Assert.assertFalse(checker.converged(1000000, a, b)); Assert.assertTrue(checker.converged(-1, a, a)); Assert.assertTrue(checker.converged(-1, b, b)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optimization.direct; import java.util.Arrays; import java.util.Random; import org.apache.commons.math3.analysis.MultivariateFunction; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.TooManyEvaluationsException; import org.apache.commons.math3.exception.NumberIsTooLargeException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.optimization.GoalType; import org.apache.commons.math3.optimization.PointValuePair; import org.apache.commons.math3.optimization.InitialGuess; import org.apache.commons.math3.optimization.SimpleBounds; import org.junit.Assert; import org.junit.Ignore; import org.junit.Test; /** * Test for {@link BOBYQAOptimizer}. */ public class BOBYQAOptimizerTest { static final int DIM = 13; @Test(expected=NumberIsTooLargeException.class) public void testInitOutOfBounds() { double[] startPoint = point(DIM, 3); double[][] boundaries = boundaries(DIM, -1, 2); doTest(new Rosen(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 2000, null); } @Test(expected=DimensionMismatchException.class) public void testBoundariesDimensionMismatch() { double[] startPoint = point(DIM, 0.5); double[][] boundaries = boundaries(DIM + 1, -1, 2); doTest(new Rosen(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 2000, null); } @Test(expected=NumberIsTooSmallException.class) public void testProblemDimensionTooSmall() { double[] startPoint = point(1, 0.5); doTest(new Rosen(), startPoint, null, GoalType.MINIMIZE, 1e-13, 1e-6, 2000, null); } @Test(expected=TooManyEvaluationsException.class) public void testMaxEvaluations() { final int lowMaxEval = 2; double[] startPoint = point(DIM, 0.1); double[][] boundaries = null; doTest(new Rosen(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, lowMaxEval, null); } @Test public void testRosen() { double[] startPoint = point(DIM,0.1); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,1.0),0.0); doTest(new Rosen(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 2000, expected); } @Test public void testMaximize() { double[] startPoint = point(DIM,1.0); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),1.0); doTest(new MinusElli(), startPoint, boundaries, GoalType.MAXIMIZE, 2e-10, 5e-6, 1000, expected); boundaries = boundaries(DIM,-0.3,0.3); startPoint = point(DIM,0.1); doTest(new MinusElli(), startPoint, boundaries, GoalType.MAXIMIZE, 2e-10, 5e-6, 1000, expected); } @Test public void testEllipse() { double[] startPoint = point(DIM,1.0); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new Elli(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 1000, expected); } @Test public void testElliRotated() { double[] startPoint = point(DIM,1.0); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new ElliRotated(), startPoint, boundaries, GoalType.MINIMIZE, 1e-12, 1e-6, 10000, expected); } @Test public void testCigar() { double[] startPoint = point(DIM,1.0); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new Cigar(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 100, expected); } @Test public void testTwoAxes() { double[] startPoint = point(DIM,1.0); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new TwoAxes(), startPoint, boundaries, GoalType.MINIMIZE, 2* 1e-13, 1e-6, 100, expected); } @Test public void testCigTab() { double[] startPoint = point(DIM,1.0); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new CigTab(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 5e-5, 100, expected); } @Test public void testSphere() { double[] startPoint = point(DIM,1.0); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new Sphere(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 100, expected); } @Test public void testTablet() { double[] startPoint = point(DIM,1.0); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new Tablet(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 100, expected); } @Test public void testDiffPow() {} // Defects4J: flaky method // @Test // public void testDiffPow() { // double[] startPoint = point(DIM/2,1.0); // double[][] boundaries = null; // PointValuePair expected = // new PointValuePair(point(DIM/2,0.0),0.0); // doTest(new DiffPow(), startPoint, boundaries, // GoalType.MINIMIZE, // 1e-8, 1e-1, 12000, expected); // } @Test public void testSsDiffPow() { double[] startPoint = point(DIM/2,1.0); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM/2,0.0),0.0); doTest(new SsDiffPow(), startPoint, boundaries, GoalType.MINIMIZE, 1e-2, 1.3e-1, 50000, expected); } @Test public void testAckley() {} // Defects4J: flaky method // @Test // public void testAckley() { // double[] startPoint = point(DIM,0.1); // double[][] boundaries = null; // PointValuePair expected = // new PointValuePair(point(DIM,0.0),0.0); // doTest(new Ackley(), startPoint, boundaries, // GoalType.MINIMIZE, // 1e-8, 1e-5, 1000, expected); // } @Test public void testRastrigin() { double[] startPoint = point(DIM,1.0); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new Rastrigin(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 1000, expected); } @Test public void testConstrainedRosen() { double[] startPoint = point(DIM,0.1); double[][] boundaries = boundaries(DIM,-1,2); PointValuePair expected = new PointValuePair(point(DIM,1.0),0.0); doTest(new Rosen(), startPoint, boundaries, GoalType.MINIMIZE, 1e-13, 1e-6, 2000, expected); } // See MATH-728 // TODO: this test is temporarily disabled for 3.2 release as a bug in Cobertura // makes it run for several hours before completing @Ignore @Test public void testConstrainedRosenWithMoreInterpolationPoints() { final double[] startPoint = point(DIM, 0.1); final double[][] boundaries = boundaries(DIM, -1, 2); final PointValuePair expected = new PointValuePair(point(DIM, 1.0), 0.0); // This should have been 78 because in the code the hard limit is // said to be // ((DIM + 1) * (DIM + 2)) / 2 - (2 * DIM + 1) // i.e. 78 in this case, but the test fails for 48, 59, 62, 63, 64, // 65, 66, ... final int maxAdditionalPoints = 47; for (int num = 1; num <= maxAdditionalPoints; num++) { doTest(new Rosen(), startPoint, boundaries, GoalType.MINIMIZE, 1e-12, 1e-6, 2000, num, expected, "num=" + num); } } /** * @param func Function to optimize. * @param startPoint Starting point. * @param boundaries Upper / lower point limit. * @param goal Minimization or maximization. * @param fTol Tolerance relative error on the objective function. * @param pointTol Tolerance for checking that the optimum is correct. * @param maxEvaluations Maximum number of evaluations. * @param expected Expected point / value. */ private void doTest(MultivariateFunction func, double[] startPoint, double[][] boundaries, GoalType goal, double fTol, double pointTol, int maxEvaluations, PointValuePair expected) { doTest(func, startPoint, boundaries, goal, fTol, pointTol, maxEvaluations, 0, expected, ""); } /** * @param func Function to optimize. * @param startPoint Starting point. * @param boundaries Upper / lower point limit. * @param goal Minimization or maximization. * @param fTol Tolerance relative error on the objective function. * @param pointTol Tolerance for checking that the optimum is correct. * @param maxEvaluations Maximum number of evaluations. * @param additionalInterpolationPoints Number of interpolation to used * in addition to the default (2 * dim + 1). * @param expected Expected point / value. */ private void doTest(MultivariateFunction func, double[] startPoint, double[][] boundaries, GoalType goal, double fTol, double pointTol, int maxEvaluations, int additionalInterpolationPoints, PointValuePair expected, String assertMsg) { // System.out.println(func.getClass().getName() + " BEGIN"); // XXX int dim = startPoint.length; // MultivariateOptimizer optim = // new PowellOptimizer(1e-13, Math.ulp(1d)); // PointValuePair result = optim.optimize(100000, func, goal, startPoint); final double[] lB = boundaries == null ? null : boundaries[0]; final double[] uB = boundaries == null ? null : boundaries[1]; final int numIterpolationPoints = 2 * dim + 1 + additionalInterpolationPoints; BOBYQAOptimizer optim = new BOBYQAOptimizer(numIterpolationPoints); PointValuePair result = boundaries == null ? optim.optimize(maxEvaluations, func, goal, new InitialGuess(startPoint)) : optim.optimize(maxEvaluations, func, goal, new InitialGuess(startPoint), new SimpleBounds(lB, uB)); // System.out.println(func.getClass().getName() + " = " // + optim.getEvaluations() + " f("); // for (double x: result.getPoint()) System.out.print(x + " "); // System.out.println(") = " + result.getValue()); Assert.assertEquals(assertMsg, expected.getValue(), result.getValue(), fTol); for (int i = 0; i < dim; i++) { Assert.assertEquals(expected.getPoint()[i], result.getPoint()[i], pointTol); } // System.out.println(func.getClass().getName() + " END"); // XXX } private static double[] point(int n, double value) { double[] ds = new double[n]; Arrays.fill(ds, value); return ds; } private static double[][] boundaries(int dim, double lower, double upper) { double[][] boundaries = new double[2][dim]; for (int i = 0; i < dim; i++) boundaries[0][i] = lower; for (int i = 0; i < dim; i++) boundaries[1][i] = upper; return boundaries; } private static class Sphere implements MultivariateFunction { public double value(double[] x) { double f = 0; for (int i = 0; i < x.length; ++i) f += x[i] * x[i]; return f; } } private static class Cigar implements MultivariateFunction { private double factor; Cigar() { this(1e3); } Cigar(double axisratio) { factor = axisratio * axisratio; } public double value(double[] x) { double f = x[0] * x[0]; for (int i = 1; i < x.length; ++i) f += factor * x[i] * x[i]; return f; } } private static class Tablet implements MultivariateFunction { private double factor; Tablet() { this(1e3); } Tablet(double axisratio) { factor = axisratio * axisratio; } public double value(double[] x) { double f = factor * x[0] * x[0]; for (int i = 1; i < x.length; ++i) f += x[i] * x[i]; return f; } } private static class CigTab implements MultivariateFunction { private double factor; CigTab() { this(1e4); } CigTab(double axisratio) { factor = axisratio; } public double value(double[] x) { int end = x.length - 1; double f = x[0] * x[0] / factor + factor * x[end] * x[end]; for (int i = 1; i < end; ++i) f += x[i] * x[i]; return f; } } private static class TwoAxes implements MultivariateFunction { private double factor; TwoAxes() { this(1e6); } TwoAxes(double axisratio) { factor = axisratio * axisratio; } public double value(double[] x) { double f = 0; for (int i = 0; i < x.length; ++i) f += (i < x.length / 2 ? factor : 1) * x[i] * x[i]; return f; } } private static class ElliRotated implements MultivariateFunction { private Basis B = new Basis(); private double factor; ElliRotated() { this(1e3); } ElliRotated(double axisratio) { factor = axisratio * axisratio; } public double value(double[] x) { double f = 0; x = B.Rotate(x); for (int i = 0; i < x.length; ++i) f += Math.pow(factor, i / (x.length - 1.)) * x[i] * x[i]; return f; } } private static class Elli implements MultivariateFunction { private double factor; Elli() { this(1e3); } Elli(double axisratio) { factor = axisratio * axisratio; } public double value(double[] x) { double f = 0; for (int i = 0; i < x.length; ++i) f += Math.pow(factor, i / (x.length - 1.)) * x[i] * x[i]; return f; } } private static class MinusElli implements MultivariateFunction { private final Elli elli = new Elli(); public double value(double[] x) { return 1.0 - elli.value(x); } } private static class DiffPow implements MultivariateFunction { // private int fcount = 0; public double value(double[] x) { double f = 0; for (int i = 0; i < x.length; ++i) f += Math.pow(Math.abs(x[i]), 2. + 10 * (double) i / (x.length - 1.)); // System.out.print("" + (fcount++) + ") "); // for (int i = 0; i < x.length; i++) // System.out.print(x[i] + " "); // System.out.println(" = " + f); return f; } } private static class SsDiffPow implements MultivariateFunction { public double value(double[] x) { double f = Math.pow(new DiffPow().value(x), 0.25); return f; } } private static class Rosen implements MultivariateFunction { public double value(double[] x) { double f = 0; for (int i = 0; i < x.length - 1; ++i) f += 1e2 * (x[i] * x[i] - x[i + 1]) * (x[i] * x[i] - x[i + 1]) + (x[i] - 1.) * (x[i] - 1.); return f; } } private static class Ackley implements MultivariateFunction { private double axisratio; Ackley(double axra) { axisratio = axra; } public Ackley() { this(1); } public double value(double[] x) { double f = 0; double res2 = 0; double fac = 0; for (int i = 0; i < x.length; ++i) { fac = Math.pow(axisratio, (i - 1.) / (x.length - 1.)); f += fac * fac * x[i] * x[i]; res2 += Math.cos(2. * Math.PI * fac * x[i]); } f = (20. - 20. * Math.exp(-0.2 * Math.sqrt(f / x.length)) + Math.exp(1.) - Math.exp(res2 / x.length)); return f; } } private static class Rastrigin implements MultivariateFunction { private double axisratio; private double amplitude; Rastrigin() { this(1, 10); } Rastrigin(double axisratio, double amplitude) { this.axisratio = axisratio; this.amplitude = amplitude; } public double value(double[] x) { double f = 0; double fac; for (int i = 0; i < x.length; ++i) { fac = Math.pow(axisratio, (i - 1.) / (x.length - 1.)); if (i == 0 && x[i] < 0) fac *= 1.; f += fac * fac * x[i] * x[i] + amplitude * (1. - Math.cos(2. * Math.PI * fac * x[i])); } return f; } } private static class Basis { double[][] basis; Random rand = new Random(2); // use not always the same basis double[] Rotate(double[] x) { GenBasis(x.length); double[] y = new double[x.length]; for (int i = 0; i < x.length; ++i) { y[i] = 0; for (int j = 0; j < x.length; ++j) y[i] += basis[i][j] * x[j]; } return y; } void GenBasis(int DIM) { if (basis != null ? basis.length == DIM : false) return; double sp; int i, j, k; /* generate orthogonal basis */ basis = new double[DIM][DIM]; for (i = 0; i < DIM; ++i) { /* sample components gaussian */ for (j = 0; j < DIM; ++j) basis[i][j] = rand.nextGaussian(); /* substract projection of previous vectors */ for (j = i - 1; j >= 0; --j) { for (sp = 0., k = 0; k < DIM; ++k) sp += basis[i][k] * basis[j][k]; /* scalar product */ for (k = 0; k < DIM; ++k) basis[i][k] -= sp * basis[j][k]; /* substract */ } /* normalize */ for (sp = 0., k = 0; k < DIM; ++k) sp += basis[i][k] * basis[i][k]; /* squared norm */ for (k = 0; k < DIM; ++k) basis[i][k] /= Math.sqrt(sp); } } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optimization.direct; import java.util.Arrays; import java.util.Random; import org.apache.commons.math3.Retry; import org.apache.commons.math3.RetryRunner; import org.apache.commons.math3.analysis.MultivariateFunction; import org.apache.commons.math3.exception.NumberIsTooLargeException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.NotPositiveException; import org.apache.commons.math3.exception.OutOfRangeException; import org.apache.commons.math3.optimization.GoalType; import org.apache.commons.math3.optimization.PointValuePair; import org.apache.commons.math3.optimization.InitialGuess; import org.apache.commons.math3.optimization.SimpleBounds; import org.apache.commons.math3.random.MersenneTwister; import org.junit.Assert; import org.junit.Test; import org.junit.runner.RunWith; /** * Test for {@link CMAESOptimizer}. */ @RunWith(RetryRunner.class) public class CMAESOptimizerTest { static final int DIM = 13; static final int LAMBDA = 4 + (int)(3.*Math.log(DIM)); @Test(expected = NumberIsTooLargeException.class) public void testInitOutofbounds1() { double[] startPoint = point(DIM,3); double[] insigma = point(DIM, 0.3); double[][] boundaries = boundaries(DIM,-1,2); PointValuePair expected = new PointValuePair(point(DIM,1.0),0.0); doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); } @Test(expected = NumberIsTooSmallException.class) public void testInitOutofbounds2() { double[] startPoint = point(DIM, -2); double[] insigma = point(DIM, 0.3); double[][] boundaries = boundaries(DIM,-1,2); PointValuePair expected = new PointValuePair(point(DIM,1.0),0.0); doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); } @Test(expected = DimensionMismatchException.class) public void testBoundariesDimensionMismatch() { double[] startPoint = point(DIM,0.5); double[] insigma = point(DIM, 0.3); double[][] boundaries = boundaries(DIM+1,-1,2); PointValuePair expected = new PointValuePair(point(DIM,1.0),0.0); doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); } @Test(expected = NotPositiveException.class) public void testInputSigmaNegative() { double[] startPoint = point(DIM,0.5); double[] insigma = point(DIM,-0.5); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,1.0),0.0); doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); } @Test(expected = OutOfRangeException.class) public void testInputSigmaOutOfRange() { double[] startPoint = point(DIM,0.5); double[] insigma = point(DIM, 1.1); double[][] boundaries = boundaries(DIM,-0.5,0.5); PointValuePair expected = new PointValuePair(point(DIM,1.0),0.0); doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); } @Test(expected = DimensionMismatchException.class) public void testInputSigmaDimensionMismatch() { double[] startPoint = point(DIM,0.5); double[] insigma = point(DIM + 1, 0.5); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,1.0),0.0); doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); } @Test @Retry(3) public void testRosen() { double[] startPoint = point(DIM,0.1); double[] insigma = point(DIM,0.1); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,1.0),0.0); doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13, 1e-13, 1e-6, 100000, expected); } @Test @Retry(3) public void testMaximize() { double[] startPoint = point(DIM,1.0); double[] insigma = point(DIM,0.1); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),1.0); doTest(new MinusElli(), startPoint, insigma, boundaries, GoalType.MAXIMIZE, LAMBDA, true, 0, 1.0-1e-13, 2e-10, 5e-6, 100000, expected); doTest(new MinusElli(), startPoint, insigma, boundaries, GoalType.MAXIMIZE, LAMBDA, false, 0, 1.0-1e-13, 2e-10, 5e-6, 100000, expected); boundaries = boundaries(DIM,-0.3,0.3); startPoint = point(DIM,0.1); doTest(new MinusElli(), startPoint, insigma, boundaries, GoalType.MAXIMIZE, LAMBDA, true, 0, 1.0-1e-13, 2e-10, 5e-6, 100000, expected); } @Test public void testEllipse() { double[] startPoint = point(DIM,1.0); double[] insigma = point(DIM,0.1); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new Elli(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); doTest(new Elli(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13, 1e-13, 1e-6, 100000, expected); } @Test public void testElliRotated() { double[] startPoint = point(DIM,1.0); double[] insigma = point(DIM,0.1); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new ElliRotated(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); doTest(new ElliRotated(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13, 1e-13, 1e-6, 100000, expected); } @Test public void testCigar() { double[] startPoint = point(DIM,1.0); double[] insigma = point(DIM,0.1); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new Cigar(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 200000, expected); doTest(new Cigar(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13, 1e-13, 1e-6, 100000, expected); } @Test public void testCigarWithBoundaries() { double[] startPoint = point(DIM,1.0); double[] insigma = point(DIM,0.1); double[][] boundaries = boundaries(DIM, -1e100, Double.POSITIVE_INFINITY); PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new Cigar(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 200000, expected); doTest(new Cigar(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13, 1e-13, 1e-6, 100000, expected); } @Test public void testTwoAxes() { double[] startPoint = point(DIM,1.0); double[] insigma = point(DIM,0.1); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new TwoAxes(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 2*LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 200000, expected); doTest(new TwoAxes(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 2*LAMBDA, false, 0, 1e-13, 1e-8, 1e-3, 200000, expected); } @Test public void testCigTab() { double[] startPoint = point(DIM,1.0); double[] insigma = point(DIM,0.3); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new CigTab(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 5e-5, 100000, expected); doTest(new CigTab(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13, 1e-13, 5e-5, 100000, expected); } @Test public void testSphere() { double[] startPoint = point(DIM,1.0); double[] insigma = point(DIM,0.1); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new Sphere(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); doTest(new Sphere(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13, 1e-13, 1e-6, 100000, expected); } @Test public void testTablet() { double[] startPoint = point(DIM,1.0); double[] insigma = point(DIM,0.1); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new Tablet(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); doTest(new Tablet(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 0, 1e-13, 1e-13, 1e-6, 100000, expected); } @Test public void testDiffPow() { double[] startPoint = point(DIM,1.0); double[] insigma = point(DIM,0.1); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new DiffPow(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 10, true, 0, 1e-13, 1e-8, 1e-1, 100000, expected); doTest(new DiffPow(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 10, false, 0, 1e-13, 1e-8, 2e-1, 100000, expected); } @Test public void testSsDiffPow() { double[] startPoint = point(DIM,1.0); double[] insigma = point(DIM,0.1); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new SsDiffPow(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 10, true, 0, 1e-13, 1e-4, 1e-1, 200000, expected); doTest(new SsDiffPow(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 10, false, 0, 1e-13, 1e-4, 1e-1, 200000, expected); } @Test public void testAckley() { double[] startPoint = point(DIM,1.0); double[] insigma = point(DIM,1.0); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new Ackley(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 2*LAMBDA, true, 0, 1e-13, 1e-9, 1e-5, 100000, expected); doTest(new Ackley(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 2*LAMBDA, false, 0, 1e-13, 1e-9, 1e-5, 100000, expected); } @Test public void testRastrigin() { double[] startPoint = point(DIM,0.1); double[] insigma = point(DIM,0.1); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,0.0),0.0); doTest(new Rastrigin(), startPoint, insigma, boundaries, GoalType.MINIMIZE, (int)(200*Math.sqrt(DIM)), true, 0, 1e-13, 1e-13, 1e-6, 200000, expected); doTest(new Rastrigin(), startPoint, insigma, boundaries, GoalType.MINIMIZE, (int)(200*Math.sqrt(DIM)), false, 0, 1e-13, 1e-13, 1e-6, 200000, expected); } @Test public void testConstrainedRosen() { double[] startPoint = point(DIM, 0.1); double[] insigma = point(DIM, 0.1); double[][] boundaries = boundaries(DIM, -1, 2); PointValuePair expected = new PointValuePair(point(DIM,1.0),0.0); doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 2*LAMBDA, true, 0, 1e-13, 1e-13, 1e-6, 100000, expected); doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, 2*LAMBDA, false, 0, 1e-13, 1e-13, 1e-6, 100000, expected); } @Test public void testDiagonalRosen() { double[] startPoint = point(DIM,0.1); double[] insigma = point(DIM,0.1); double[][] boundaries = null; PointValuePair expected = new PointValuePair(point(DIM,1.0),0.0); doTest(new Rosen(), startPoint, insigma, boundaries, GoalType.MINIMIZE, LAMBDA, false, 1, 1e-13, 1e-10, 1e-4, 1000000, expected); } @Test public void testMath864() { final CMAESOptimizer optimizer = new CMAESOptimizer(); final MultivariateFunction fitnessFunction = new MultivariateFunction() { public double value(double[] parameters) { final double target = 1; final double error = target - parameters[0]; return error * error; } }; final double[] start = { 0 }; final double[] lower = { -1e6 }; final double[] upper = { 1.5 }; final double[] result = optimizer.optimize(10000, fitnessFunction, GoalType.MINIMIZE, start, lower, upper).getPoint(); Assert.assertTrue("Out of bounds (" + result[0] + " > " + upper[0] + ")", result[0] <= upper[0]); } /** * Cf. MATH-867 */ @Test public void testFitAccuracyDependsOnBoundary() { final CMAESOptimizer optimizer = new CMAESOptimizer(); final MultivariateFunction fitnessFunction = new MultivariateFunction() { public double value(double[] parameters) { final double target = 11.1; final double error = target - parameters[0]; return error * error; } }; final double[] start = { 1 }; // No bounds. PointValuePair result = optimizer.optimize(100000, fitnessFunction, GoalType.MINIMIZE, start); final double resNoBound = result.getPoint()[0]; // Optimum is near the lower bound. final double[] lower = { -20 }; final double[] upper = { 5e16 }; result = optimizer.optimize(100000, fitnessFunction, GoalType.MINIMIZE, start, lower, upper); final double resNearLo = result.getPoint()[0]; // Optimum is near the upper bound. lower[0] = -5e16; upper[0] = 20; result = optimizer.optimize(100000, fitnessFunction, GoalType.MINIMIZE, start, lower, upper); final double resNearHi = result.getPoint()[0]; // System.out.println("resNoBound=" + resNoBound + // " resNearLo=" + resNearLo + // " resNearHi=" + resNearHi); // The two values currently differ by a substantial amount, indicating that // the bounds definition can prevent reaching the optimum. Assert.assertEquals(resNoBound, resNearLo, 1e-3); Assert.assertEquals(resNoBound, resNearHi, 1e-3); } /** * @param func Function to optimize. * @param startPoint Starting point. * @param inSigma Individual input sigma. * @param boundaries Upper / lower point limit. * @param goal Minimization or maximization. * @param lambda Population size used for offspring. * @param isActive Covariance update mechanism. * @param diagonalOnly Simplified covariance update. * @param stopValue Termination criteria for optimization. * @param fTol Tolerance relative error on the objective function. * @param pointTol Tolerance for checking that the optimum is correct. * @param maxEvaluations Maximum number of evaluations. * @param expected Expected point / value. */ private void doTest(MultivariateFunction func, double[] startPoint, double[] inSigma, double[][] boundaries, GoalType goal, int lambda, boolean isActive, int diagonalOnly, double stopValue, double fTol, double pointTol, int maxEvaluations, PointValuePair expected) { int dim = startPoint.length; // test diagonalOnly = 0 - slow but normally fewer feval# CMAESOptimizer optim = new CMAESOptimizer(30000, stopValue, isActive, diagonalOnly, 0, new MersenneTwister(), false, null); final double[] lB = boundaries == null ? null : boundaries[0]; final double[] uB = boundaries == null ? null : boundaries[1]; PointValuePair result = boundaries == null ? optim.optimize(maxEvaluations, func, goal, new InitialGuess(startPoint), new CMAESOptimizer.Sigma(inSigma), new CMAESOptimizer.PopulationSize(lambda)) : optim.optimize(maxEvaluations, func, goal, new InitialGuess(startPoint), new SimpleBounds(lB, uB), new CMAESOptimizer.Sigma(inSigma), new CMAESOptimizer.PopulationSize(lambda)); // System.out.println("sol=" + Arrays.toString(result.getPoint())); Assert.assertEquals(expected.getValue(), result.getValue(), fTol); for (int i = 0; i < dim; i++) { Assert.assertEquals(expected.getPoint()[i], result.getPoint()[i], pointTol); } } private static double[] point(int n, double value) { double[] ds = new double[n]; Arrays.fill(ds, value); return ds; } private static double[][] boundaries(int dim, double lower, double upper) { double[][] boundaries = new double[2][dim]; for (int i = 0; i < dim; i++) boundaries[0][i] = lower; for (int i = 0; i < dim; i++) boundaries[1][i] = upper; return boundaries; } private static class Sphere implements MultivariateFunction { public double value(double[] x) { double f = 0; for (int i = 0; i < x.length; ++i) f += x[i] * x[i]; return f; } } private static class Cigar implements MultivariateFunction { private double factor; Cigar() { this(1e3); } Cigar(double axisratio) { factor = axisratio * axisratio; } public double value(double[] x) { double f = x[0] * x[0]; for (int i = 1; i < x.length; ++i) f += factor * x[i] * x[i]; return f; } } private static class Tablet implements MultivariateFunction { private double factor; Tablet() { this(1e3); } Tablet(double axisratio) { factor = axisratio * axisratio; } public double value(double[] x) { double f = factor * x[0] * x[0]; for (int i = 1; i < x.length; ++i) f += x[i] * x[i]; return f; } } private static class CigTab implements MultivariateFunction { private double factor; CigTab() { this(1e4); } CigTab(double axisratio) { factor = axisratio; } public double value(double[] x) { int end = x.length - 1; double f = x[0] * x[0] / factor + factor * x[end] * x[end]; for (int i = 1; i < end; ++i) f += x[i] * x[i]; return f; } } private static class TwoAxes implements MultivariateFunction { private double factor; TwoAxes() { this(1e6); } TwoAxes(double axisratio) { factor = axisratio * axisratio; } public double value(double[] x) { double f = 0; for (int i = 0; i < x.length; ++i) f += (i < x.length / 2 ? factor : 1) * x[i] * x[i]; return f; } } private static class ElliRotated implements MultivariateFunction { private Basis B = new Basis(); private double factor; ElliRotated() { this(1e3); } ElliRotated(double axisratio) { factor = axisratio * axisratio; } public double value(double[] x) { double f = 0; x = B.Rotate(x); for (int i = 0; i < x.length; ++i) f += Math.pow(factor, i / (x.length - 1.)) * x[i] * x[i]; return f; } } private static class Elli implements MultivariateFunction { private double factor; Elli() { this(1e3); } Elli(double axisratio) { factor = axisratio * axisratio; } public double value(double[] x) { double f = 0; for (int i = 0; i < x.length; ++i) f += Math.pow(factor, i / (x.length - 1.)) * x[i] * x[i]; return f; } } private static class MinusElli implements MultivariateFunction { public double value(double[] x) { return 1.0-(new Elli().value(x)); } } private static class DiffPow implements MultivariateFunction { public double value(double[] x) { double f = 0; for (int i = 0; i < x.length; ++i) f += Math.pow(Math.abs(x[i]), 2. + 10 * (double) i / (x.length - 1.)); return f; } } private static class SsDiffPow implements MultivariateFunction { public double value(double[] x) { double f = Math.pow(new DiffPow().value(x), 0.25); return f; } } private static class Rosen implements MultivariateFunction { public double value(double[] x) { double f = 0; for (int i = 0; i < x.length - 1; ++i) f += 1e2 * (x[i] * x[i] - x[i + 1]) * (x[i] * x[i] - x[i + 1]) + (x[i] - 1.) * (x[i] - 1.); return f; } } private static class Ackley implements MultivariateFunction { private double axisratio; Ackley(double axra) { axisratio = axra; } public Ackley() { this(1); } public double value(double[] x) { double f = 0; double res2 = 0; double fac = 0; for (int i = 0; i < x.length; ++i) { fac = Math.pow(axisratio, (i - 1.) / (x.length - 1.)); f += fac * fac * x[i] * x[i]; res2 += Math.cos(2. * Math.PI * fac * x[i]); } f = (20. - 20. * Math.exp(-0.2 * Math.sqrt(f / x.length)) + Math.exp(1.) - Math.exp(res2 / x.length)); return f; } } private static class Rastrigin implements MultivariateFunction { private double axisratio; private double amplitude; Rastrigin() { this(1, 10); } Rastrigin(double axisratio, double amplitude) { this.axisratio = axisratio; this.amplitude = amplitude; } public double value(double[] x) { double f = 0; double fac; for (int i = 0; i < x.length; ++i) { fac = Math.pow(axisratio, (i - 1.) / (x.length - 1.)); if (i == 0 && x[i] < 0) fac *= 1.; f += fac * fac * x[i] * x[i] + amplitude * (1. - Math.cos(2. * Math.PI * fac * x[i])); } return f; } } private static class Basis { double[][] basis; Random rand = new Random(2); // use not always the same basis double[] Rotate(double[] x) { GenBasis(x.length); double[] y = new double[x.length]; for (int i = 0; i < x.length; ++i) { y[i] = 0; for (int j = 0; j < x.length; ++j) y[i] += basis[i][j] * x[j]; } return y; } void GenBasis(int DIM) { if (basis != null ? basis.length == DIM : false) return; double sp; int i, j, k; /* generate orthogonal basis */ basis = new double[DIM][DIM]; for (i = 0; i < DIM; ++i) { /* sample components gaussian */ for (j = 0; j < DIM; ++j) basis[i][j] = rand.nextGaussian(); /* substract projection of previous vectors */ for (j = i - 1; j >= 0; --j) { for (sp = 0., k = 0; k < DIM; ++k) sp += basis[i][k] * basis[j][k]; /* scalar product */ for (k = 0; k < DIM; ++k) basis[i][k] -= sp * basis[j][k]; /* substract */ } /* normalize */ for (sp = 0., k = 0; k < DIM; ++k) sp += basis[i][k] * basis[i][k]; /* squared norm */ for (k = 0; k < DIM; ++k) basis[i][k] /= Math.sqrt(sp); } } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optimization.direct; import org.apache.commons.math3.analysis.MultivariateFunction; import org.apache.commons.math3.optimization.GoalType; import org.apache.commons.math3.optimization.PointValuePair; import org.junit.Assert; import org.junit.Test; public class MultivariateFunctionMappingAdapterTest { @Test public void testStartSimplexInsideRange() { final BiQuadratic biQuadratic = new BiQuadratic(2.0, 2.5, 1.0, 3.0, 2.0, 3.0); final MultivariateFunctionMappingAdapter wrapped = new MultivariateFunctionMappingAdapter(biQuadratic, biQuadratic.getLower(), biQuadratic.getUpper()); SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); optimizer.setSimplex(new NelderMeadSimplex(new double[][] { wrapped.boundedToUnbounded(new double[] { 1.5, 2.75 }), wrapped.boundedToUnbounded(new double[] { 1.5, 2.95 }), wrapped.boundedToUnbounded(new double[] { 1.7, 2.90 }) })); final PointValuePair optimum = optimizer.optimize(300, wrapped, GoalType.MINIMIZE, wrapped.boundedToUnbounded(new double[] { 1.5, 2.25 })); final double[] bounded = wrapped.unboundedToBounded(optimum.getPoint()); Assert.assertEquals(biQuadratic.getBoundedXOptimum(), bounded[0], 2e-7); Assert.assertEquals(biQuadratic.getBoundedYOptimum(), bounded[1], 2e-7); } @Test public void testOptimumOutsideRange() { final BiQuadratic biQuadratic = new BiQuadratic(4.0, 0.0, 1.0, 3.0, 2.0, 3.0); final MultivariateFunctionMappingAdapter wrapped = new MultivariateFunctionMappingAdapter(biQuadratic, biQuadratic.getLower(), biQuadratic.getUpper()); SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); optimizer.setSimplex(new NelderMeadSimplex(new double[][] { wrapped.boundedToUnbounded(new double[] { 1.5, 2.75 }), wrapped.boundedToUnbounded(new double[] { 1.5, 2.95 }), wrapped.boundedToUnbounded(new double[] { 1.7, 2.90 }) })); final PointValuePair optimum = optimizer.optimize(100, wrapped, GoalType.MINIMIZE, wrapped.boundedToUnbounded(new double[] { 1.5, 2.25 })); final double[] bounded = wrapped.unboundedToBounded(optimum.getPoint()); Assert.assertEquals(biQuadratic.getBoundedXOptimum(), bounded[0], 2e-7); Assert.assertEquals(biQuadratic.getBoundedYOptimum(), bounded[1], 2e-7); } @Test public void testUnbounded() { final BiQuadratic biQuadratic = new BiQuadratic(4.0, 0.0, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY); final MultivariateFunctionMappingAdapter wrapped = new MultivariateFunctionMappingAdapter(biQuadratic, biQuadratic.getLower(), biQuadratic.getUpper()); SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); optimizer.setSimplex(new NelderMeadSimplex(new double[][] { wrapped.boundedToUnbounded(new double[] { 1.5, 2.75 }), wrapped.boundedToUnbounded(new double[] { 1.5, 2.95 }), wrapped.boundedToUnbounded(new double[] { 1.7, 2.90 }) })); final PointValuePair optimum = optimizer.optimize(300, wrapped, GoalType.MINIMIZE, wrapped.boundedToUnbounded(new double[] { 1.5, 2.25 })); final double[] bounded = wrapped.unboundedToBounded(optimum.getPoint()); Assert.assertEquals(biQuadratic.getBoundedXOptimum(), bounded[0], 2e-7); Assert.assertEquals(biQuadratic.getBoundedYOptimum(), bounded[1], 2e-7); } @Test public void testHalfBounded() { final BiQuadratic biQuadratic = new BiQuadratic(4.0, 4.0, 1.0, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 3.0); final MultivariateFunctionMappingAdapter wrapped = new MultivariateFunctionMappingAdapter(biQuadratic, biQuadratic.getLower(), biQuadratic.getUpper()); SimplexOptimizer optimizer = new SimplexOptimizer(1e-13, 1e-30); optimizer.setSimplex(new NelderMeadSimplex(new double[][] { wrapped.boundedToUnbounded(new double[] { 1.5, 2.75 }), wrapped.boundedToUnbounded(new double[] { 1.5, 2.95 }), wrapped.boundedToUnbounded(new double[] { 1.7, 2.90 }) })); final PointValuePair optimum = optimizer.optimize(200, wrapped, GoalType.MINIMIZE, wrapped.boundedToUnbounded(new double[] { 1.5, 2.25 })); final double[] bounded = wrapped.unboundedToBounded(optimum.getPoint()); Assert.assertEquals(biQuadratic.getBoundedXOptimum(), bounded[0], 1e-7); Assert.assertEquals(biQuadratic.getBoundedYOptimum(), bounded[1], 1e-7); } private static class BiQuadratic implements MultivariateFunction { private final double xOptimum; private final double yOptimum; private final double xMin; private final double xMax; private final double yMin; private final double yMax; public BiQuadratic(final double xOptimum, final double yOptimum, final double xMin, final double xMax, final double yMin, final double yMax) { this.xOptimum = xOptimum; this.yOptimum = yOptimum; this.xMin = xMin; this.xMax = xMax; this.yMin = yMin; this.yMax = yMax; } public double value(double[] point) { // the function should never be called with out of range points Assert.assertTrue(point[0] >= xMin); Assert.assertTrue(point[0] <= xMax); Assert.assertTrue(point[1] >= yMin); Assert.assertTrue(point[1] <= yMax); final double dx = point[0] - xOptimum; final double dy = point[1] - yOptimum; return dx * dx + dy * dy; } public double[] getLower() { return new double[] { xMin, yMin }; } public double[] getUpper() { return new double[] { xMax, yMax }; } public double getBoundedXOptimum() { return (xOptimum < xMin) ? xMin : ((xOptimum > xMax) ? xMax : xOptimum); } public double getBoundedYOptimum() { return (yOptimum < yMin) ? yMin : ((yOptimum > yMax) ? yMax : yOptimum); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optimization.direct; import org.apache.commons.math3.analysis.MultivariateFunction; import org.apache.commons.math3.optimization.GoalType; import org.apache.commons.math3.optimization.PointValuePair; import org.apache.commons.math3.optimization.SimplePointChecker; import org.junit.Assert; import org.junit.Test; public class MultivariateFunctionPenaltyAdapterTest { @Test public void testStartSimplexInsideRange() { final BiQuadratic biQuadratic = new BiQuadratic(2.0, 2.5, 1.0, 3.0, 2.0, 3.0); final MultivariateFunctionPenaltyAdapter wrapped = new MultivariateFunctionPenaltyAdapter(biQuadratic, biQuadratic.getLower(), biQuadratic.getUpper(), 1000.0, new double[] { 100.0, 100.0 }); SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); optimizer.setSimplex(new NelderMeadSimplex(new double[] { 1.0, 0.5 })); final PointValuePair optimum = optimizer.optimize(300, wrapped, GoalType.MINIMIZE, new double[] { 1.5, 2.25 }); Assert.assertEquals(biQuadratic.getBoundedXOptimum(), optimum.getPoint()[0], 2e-7); Assert.assertEquals(biQuadratic.getBoundedYOptimum(), optimum.getPoint()[1], 2e-7); } @Test public void testStartSimplexOutsideRange() { final BiQuadratic biQuadratic = new BiQuadratic(2.0, 2.5, 1.0, 3.0, 2.0, 3.0); final MultivariateFunctionPenaltyAdapter wrapped = new MultivariateFunctionPenaltyAdapter(biQuadratic, biQuadratic.getLower(), biQuadratic.getUpper(), 1000.0, new double[] { 100.0, 100.0 }); SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); optimizer.setSimplex(new NelderMeadSimplex(new double[] { 1.0, 0.5 })); final PointValuePair optimum = optimizer.optimize(300, wrapped, GoalType.MINIMIZE, new double[] { -1.5, 4.0 }); Assert.assertEquals(biQuadratic.getBoundedXOptimum(), optimum.getPoint()[0], 2e-7); Assert.assertEquals(biQuadratic.getBoundedYOptimum(), optimum.getPoint()[1], 2e-7); } @Test public void testOptimumOutsideRange() { final BiQuadratic biQuadratic = new BiQuadratic(4.0, 0.0, 1.0, 3.0, 2.0, 3.0); final MultivariateFunctionPenaltyAdapter wrapped = new MultivariateFunctionPenaltyAdapter(biQuadratic, biQuadratic.getLower(), biQuadratic.getUpper(), 1000.0, new double[] { 100.0, 100.0 }); SimplexOptimizer optimizer = new SimplexOptimizer(new SimplePointChecker<PointValuePair>(1.0e-11, 1.0e-20)); optimizer.setSimplex(new NelderMeadSimplex(new double[] { 1.0, 0.5 })); final PointValuePair optimum = optimizer.optimize(600, wrapped, GoalType.MINIMIZE, new double[] { -1.5, 4.0 }); Assert.assertEquals(biQuadratic.getBoundedXOptimum(), optimum.getPoint()[0], 2e-7); Assert.assertEquals(biQuadratic.getBoundedYOptimum(), optimum.getPoint()[1], 2e-7); } @Test public void testUnbounded() { final BiQuadratic biQuadratic = new BiQuadratic(4.0, 0.0, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY); final MultivariateFunctionPenaltyAdapter wrapped = new MultivariateFunctionPenaltyAdapter(biQuadratic, biQuadratic.getLower(), biQuadratic.getUpper(), 1000.0, new double[] { 100.0, 100.0 }); SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); optimizer.setSimplex(new NelderMeadSimplex(new double[] { 1.0, 0.5 })); final PointValuePair optimum = optimizer.optimize(300, wrapped, GoalType.MINIMIZE, new double[] { -1.5, 4.0 }); Assert.assertEquals(biQuadratic.getBoundedXOptimum(), optimum.getPoint()[0], 2e-7); Assert.assertEquals(biQuadratic.getBoundedYOptimum(), optimum.getPoint()[1], 2e-7); } @Test public void testHalfBounded() { final BiQuadratic biQuadratic = new BiQuadratic(4.0, 4.0, 1.0, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 3.0); final MultivariateFunctionPenaltyAdapter wrapped = new MultivariateFunctionPenaltyAdapter(biQuadratic, biQuadratic.getLower(), biQuadratic.getUpper(), 1000.0, new double[] { 100.0, 100.0 }); SimplexOptimizer optimizer = new SimplexOptimizer(new SimplePointChecker<PointValuePair>(1.0e-10, 1.0e-20)); optimizer.setSimplex(new NelderMeadSimplex(new double[] { 1.0, 0.5 })); final PointValuePair optimum = optimizer.optimize(400, wrapped, GoalType.MINIMIZE, new double[] { -1.5, 4.0 }); Assert.assertEquals(biQuadratic.getBoundedXOptimum(), optimum.getPoint()[0], 2e-7); Assert.assertEquals(biQuadratic.getBoundedYOptimum(), optimum.getPoint()[1], 2e-7); } private static class BiQuadratic implements MultivariateFunction { private final double xOptimum; private final double yOptimum; private final double xMin; private final double xMax; private final double yMin; private final double yMax; public BiQuadratic(final double xOptimum, final double yOptimum, final double xMin, final double xMax, final double yMin, final double yMax) { this.xOptimum = xOptimum; this.yOptimum = yOptimum; this.xMin = xMin; this.xMax = xMax; this.yMin = yMin; this.yMax = yMax; } public double value(double[] point) { // the function should never be called with out of range points Assert.assertTrue(point[0] >= xMin); Assert.assertTrue(point[0] <= xMax); Assert.assertTrue(point[1] >= yMin); Assert.assertTrue(point[1] <= yMax); final double dx = point[0] - xOptimum; final double dy = point[1] - yOptimum; return dx * dx + dy * dy; } public double[] getLower() { return new double[] { xMin, yMin }; } public double[] getUpper() { return new double[] { xMax, yMax }; } public double getBoundedXOptimum() { return (xOptimum < xMin) ? xMin : ((xOptimum > xMax) ? xMax : xOptimum); } public double getBoundedYOptimum() { return (yOptimum < yMin) ? yMin : ((yOptimum > yMax) ? yMax : yOptimum); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optimization.direct; import org.apache.commons.math3.analysis.MultivariateFunction; import org.apache.commons.math3.analysis.SumSincFunction; import org.apache.commons.math3.optimization.GoalType; import org.apache.commons.math3.optimization.MultivariateOptimizer; import org.apache.commons.math3.optimization.PointValuePair; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * Test for {@link PowellOptimizer}. */ public class PowellOptimizerTest { @Test public void testSumSinc() { final MultivariateFunction func = new SumSincFunction(-1); int dim = 2; final double[] minPoint = new double[dim]; for (int i = 0; i < dim; i++) { minPoint[i] = 0; } double[] init = new double[dim]; // Initial is minimum. for (int i = 0; i < dim; i++) { init[i] = minPoint[i]; } doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-9); // Initial is far from minimum. for (int i = 0; i < dim; i++) { init[i] = minPoint[i] + 3; } doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-5); // More stringent line search tolerance enhances the precision // of the result. doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-9, 1e-7); } @Test public void testQuadratic() { final MultivariateFunction func = new MultivariateFunction() { public double value(double[] x) { final double a = x[0] - 1; final double b = x[1] - 1; return a * a + b * b + 1; } }; int dim = 2; final double[] minPoint = new double[dim]; for (int i = 0; i < dim; i++) { minPoint[i] = 1; } double[] init = new double[dim]; // Initial is minimum. for (int i = 0; i < dim; i++) { init[i] = minPoint[i]; } doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-8); // Initial is far from minimum. for (int i = 0; i < dim; i++) { init[i] = minPoint[i] - 20; } doTest(func, minPoint, init, GoalType.MINIMIZE, 1e-9, 1e-8); } @Test public void testMaximizeQuadratic() { final MultivariateFunction func = new MultivariateFunction() { public double value(double[] x) { final double a = x[0] - 1; final double b = x[1] - 1; return -a * a - b * b + 1; } }; int dim = 2; final double[] maxPoint = new double[dim]; for (int i = 0; i < dim; i++) { maxPoint[i] = 1; } double[] init = new double[dim]; // Initial is minimum. for (int i = 0; i < dim; i++) { init[i] = maxPoint[i]; } doTest(func, maxPoint, init, GoalType.MAXIMIZE, 1e-9, 1e-8); // Initial is far from minimum. for (int i = 0; i < dim; i++) { init[i] = maxPoint[i] - 20; } doTest(func, maxPoint, init, GoalType.MAXIMIZE, 1e-9, 1e-8); } /** * Ensure that we do not increase the number of function evaluations when * the function values are scaled up. * Note that the tolerances parameters passed to the constructor must * still hold sensible values because they are used to set the line search * tolerances. */ @Test public void testRelativeToleranceOnScaledValues() { final MultivariateFunction func = new MultivariateFunction() { public double value(double[] x) { final double a = x[0] - 1; final double b = x[1] - 1; return a * a * FastMath.sqrt(FastMath.abs(a)) + b * b + 1; } }; int dim = 2; final double[] minPoint = new double[dim]; for (int i = 0; i < dim; i++) { minPoint[i] = 1; } double[] init = new double[dim]; // Initial is far from minimum. for (int i = 0; i < dim; i++) { init[i] = minPoint[i] - 20; } final double relTol = 1e-10; final int maxEval = 1000; // Very small absolute tolerance to rely solely on the relative // tolerance as a stopping criterion final MultivariateOptimizer optim = new PowellOptimizer(relTol, 1e-100); final PointValuePair funcResult = optim.optimize(maxEval, func, GoalType.MINIMIZE, init); final double funcValue = func.value(funcResult.getPoint()); final int funcEvaluations = optim.getEvaluations(); final double scale = 1e10; final MultivariateFunction funcScaled = new MultivariateFunction() { public double value(double[] x) { return scale * func.value(x); } }; final PointValuePair funcScaledResult = optim.optimize(maxEval, funcScaled, GoalType.MINIMIZE, init); final double funcScaledValue = funcScaled.value(funcScaledResult.getPoint()); final int funcScaledEvaluations = optim.getEvaluations(); // Check that both minima provide the same objective funciton values, // within the relative function tolerance. Assert.assertEquals(1, funcScaledValue / (scale * funcValue), relTol); // Check that the numbers of evaluations are the same. Assert.assertEquals(funcEvaluations, funcScaledEvaluations); } /** * @param func Function to optimize. * @param optimum Expected optimum. * @param init Starting point. * @param goal Minimization or maximization. * @param fTol Tolerance (relative error on the objective function) for * "Powell" algorithm. * @param pointTol Tolerance for checking that the optimum is correct. */ private void doTest(MultivariateFunction func, double[] optimum, double[] init, GoalType goal, double fTol, double pointTol) { final MultivariateOptimizer optim = new PowellOptimizer(fTol, Math.ulp(1d)); final PointValuePair result = optim.optimize(1000, func, goal, init); final double[] point = result.getPoint(); for (int i = 0, dim = optimum.length; i < dim; i++) { Assert.assertEquals("found[" + i + "]=" + point[i] + " value=" + result.getValue(), optimum[i], point[i], pointTol); } } /** * @param func Function to optimize. * @param optimum Expected optimum. * @param init Starting point. * @param goal Minimization or maximization. * @param fTol Tolerance (relative error on the objective function) for * "Powell" algorithm. * @param fLineTol Tolerance (relative error on the objective function) * for the internal line search algorithm. * @param pointTol Tolerance for checking that the optimum is correct. */ private void doTest(MultivariateFunction func, double[] optimum, double[] init, GoalType goal, double fTol, double fLineTol, double pointTol) { final MultivariateOptimizer optim = new PowellOptimizer(fTol, Math.ulp(1d), fLineTol, Math.ulp(1d)); final PointValuePair result = optim.optimize(1000, func, goal, init); final double[] point = result.getPoint(); for (int i = 0, dim = optimum.length; i < dim; i++) { Assert.assertEquals("found[" + i + "]=" + point[i] + " value=" + result.getValue(), optimum[i], point[i], pointTol); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optimization.direct; import org.apache.commons.math3.analysis.MultivariateFunction; import org.apache.commons.math3.optimization.GoalType; import org.apache.commons.math3.optimization.PointValuePair; import org.apache.commons.math3.optimization.SimpleValueChecker; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class SimplexOptimizerMultiDirectionalTest { @Test public void testMinimize1() { SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30); optimizer.setSimplex(new MultiDirectionalSimplex(new double[] { 0.2, 0.2 })); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(200, fourExtrema, GoalType.MINIMIZE, new double[] { -3, 0 }); Assert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 4e-6); Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 3e-6); Assert.assertEquals(fourExtrema.valueXmYp, optimum.getValue(), 8e-13); Assert.assertTrue(optimizer.getEvaluations() > 120); Assert.assertTrue(optimizer.getEvaluations() < 150); } @Test public void testMinimize2() { SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30); optimizer.setSimplex(new MultiDirectionalSimplex(new double[] { 0.2, 0.2 })); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(200, fourExtrema, GoalType.MINIMIZE, new double[] { 1, 0 }); Assert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 2e-8); Assert.assertEquals(fourExtrema.yM, optimum.getPoint()[1], 3e-6); Assert.assertEquals(fourExtrema.valueXpYm, optimum.getValue(), 2e-12); Assert.assertTrue(optimizer.getEvaluations() > 120); Assert.assertTrue(optimizer.getEvaluations() < 150); } @Test public void testMaximize1() { SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30); optimizer.setSimplex(new MultiDirectionalSimplex(new double[] { 0.2, 0.2 })); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(200, fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 }); Assert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 7e-7); Assert.assertEquals(fourExtrema.yM, optimum.getPoint()[1], 3e-7); Assert.assertEquals(fourExtrema.valueXmYm, optimum.getValue(), 2e-14); Assert.assertTrue(optimizer.getEvaluations() > 120); Assert.assertTrue(optimizer.getEvaluations() < 150); } @Test public void testMaximize2() { SimplexOptimizer optimizer = new SimplexOptimizer(new SimpleValueChecker(1e-15, 1e-30)); optimizer.setSimplex(new MultiDirectionalSimplex(new double[] { 0.2, 0.2 })); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(200, fourExtrema, GoalType.MAXIMIZE, new double[] { 1, 0 }); Assert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 2e-8); Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 3e-6); Assert.assertEquals(fourExtrema.valueXpYp, optimum.getValue(), 2e-12); Assert.assertTrue(optimizer.getEvaluations() > 180); Assert.assertTrue(optimizer.getEvaluations() < 220); } @Test public void testRosenbrock() { MultivariateFunction rosenbrock = new MultivariateFunction() { public double value(double[] x) { ++count; double a = x[1] - x[0] * x[0]; double b = 1.0 - x[0]; return 100 * a * a + b * b; } }; count = 0; SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3); optimizer.setSimplex(new MultiDirectionalSimplex(new double[][] { { -1.2, 1.0 }, { 0.9, 1.2 } , { 3.5, -2.3 } })); PointValuePair optimum = optimizer.optimize(100, rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1 }); Assert.assertEquals(count, optimizer.getEvaluations()); Assert.assertTrue(optimizer.getEvaluations() > 50); Assert.assertTrue(optimizer.getEvaluations() < 100); Assert.assertTrue(optimum.getValue() > 1e-2); } @Test public void testPowell() { MultivariateFunction powell = new MultivariateFunction() { public double value(double[] x) { ++count; double a = x[0] + 10 * x[1]; double b = x[2] - x[3]; double c = x[1] - 2 * x[2]; double d = x[0] - x[3]; return a * a + 5 * b * b + c * c * c * c + 10 * d * d * d * d; } }; count = 0; SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3); optimizer.setSimplex(new MultiDirectionalSimplex(4)); PointValuePair optimum = optimizer.optimize(1000, powell, GoalType.MINIMIZE, new double[] { 3, -1, 0, 1 }); Assert.assertEquals(count, optimizer.getEvaluations()); Assert.assertTrue(optimizer.getEvaluations() > 800); Assert.assertTrue(optimizer.getEvaluations() < 900); Assert.assertTrue(optimum.getValue() > 1e-2); } @Test public void testMath283() { // fails because MultiDirectional.iterateSimplex is looping forever // the while(true) should be replaced with a convergence check SimplexOptimizer optimizer = new SimplexOptimizer(1e-14, 1e-14); optimizer.setSimplex(new MultiDirectionalSimplex(2)); final Gaussian2D function = new Gaussian2D(0, 0, 1); PointValuePair estimate = optimizer.optimize(1000, function, GoalType.MAXIMIZE, function.getMaximumPosition()); final double EPSILON = 1e-5; final double expectedMaximum = function.getMaximum(); final double actualMaximum = estimate.getValue(); Assert.assertEquals(expectedMaximum, actualMaximum, EPSILON); final double[] expectedPosition = function.getMaximumPosition(); final double[] actualPosition = estimate.getPoint(); Assert.assertEquals(expectedPosition[0], actualPosition[0], EPSILON ); Assert.assertEquals(expectedPosition[1], actualPosition[1], EPSILON ); } private static class FourExtrema implements MultivariateFunction { // The following function has 4 local extrema. final double xM = -3.841947088256863675365; final double yM = -1.391745200270734924416; final double xP = 0.2286682237349059125691; final double yP = -yM; final double valueXmYm = 0.2373295333134216789769; // Local maximum. final double valueXmYp = -valueXmYm; // Local minimum. final double valueXpYm = -0.7290400707055187115322; // Global minimum. final double valueXpYp = -valueXpYm; // Global maximum. public double value(double[] variables) { final double x = variables[0]; final double y = variables[1]; return (x == 0 || y == 0) ? 0 : FastMath.atan(x) * FastMath.atan(x + 2) * FastMath.atan(y) * FastMath.atan(y) / (x * y); } } private static class Gaussian2D implements MultivariateFunction { private final double[] maximumPosition; private final double std; public Gaussian2D(double xOpt, double yOpt, double std) { maximumPosition = new double[] { xOpt, yOpt }; this.std = std; } public double getMaximum() { return value(maximumPosition); } public double[] getMaximumPosition() { return maximumPosition.clone(); } public double value(double[] point) { final double x = point[0], y = point[1]; final double twoS2 = 2.0 * std * std; return 1.0 / (twoS2 * FastMath.PI) * FastMath.exp(-(x * x + y * y) / twoS2); } } private int count; }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optimization.direct; import org.apache.commons.math3.exception.TooManyEvaluationsException; import org.apache.commons.math3.analysis.MultivariateFunction; import org.apache.commons.math3.analysis.MultivariateVectorFunction; import org.apache.commons.math3.linear.Array2DRowRealMatrix; import org.apache.commons.math3.linear.RealMatrix; import org.apache.commons.math3.optimization.GoalType; import org.apache.commons.math3.optimization.LeastSquaresConverter; import org.apache.commons.math3.optimization.PointValuePair; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class SimplexOptimizerNelderMeadTest { @Test public void testMinimize1() { SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); optimizer.setSimplex(new NelderMeadSimplex(new double[] { 0.2, 0.2 })); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(100, fourExtrema, GoalType.MINIMIZE, new double[] { -3, 0 }); Assert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 2e-7); Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 2e-5); Assert.assertEquals(fourExtrema.valueXmYp, optimum.getValue(), 6e-12); Assert.assertTrue(optimizer.getEvaluations() > 60); Assert.assertTrue(optimizer.getEvaluations() < 90); } @Test public void testMinimize2() { SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); optimizer.setSimplex(new NelderMeadSimplex(new double[] { 0.2, 0.2 })); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(100, fourExtrema, GoalType.MINIMIZE, new double[] { 1, 0 }); Assert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 5e-6); Assert.assertEquals(fourExtrema.yM, optimum.getPoint()[1], 6e-6); Assert.assertEquals(fourExtrema.valueXpYm, optimum.getValue(), 1e-11); Assert.assertTrue(optimizer.getEvaluations() > 60); Assert.assertTrue(optimizer.getEvaluations() < 90); } @Test public void testMaximize1() { SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); optimizer.setSimplex(new NelderMeadSimplex(new double[] { 0.2, 0.2 })); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(100, fourExtrema, GoalType.MAXIMIZE, new double[] { -3, 0 }); Assert.assertEquals(fourExtrema.xM, optimum.getPoint()[0], 1e-5); Assert.assertEquals(fourExtrema.yM, optimum.getPoint()[1], 3e-6); Assert.assertEquals(fourExtrema.valueXmYm, optimum.getValue(), 3e-12); Assert.assertTrue(optimizer.getEvaluations() > 60); Assert.assertTrue(optimizer.getEvaluations() < 90); } @Test public void testMaximize2() { SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); optimizer.setSimplex(new NelderMeadSimplex(new double[] { 0.2, 0.2 })); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(100, fourExtrema, GoalType.MAXIMIZE, new double[] { 1, 0 }); Assert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 4e-6); Assert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 5e-6); Assert.assertEquals(fourExtrema.valueXpYp, optimum.getValue(), 7e-12); Assert.assertTrue(optimizer.getEvaluations() > 60); Assert.assertTrue(optimizer.getEvaluations() < 90); } @Test public void testRosenbrock() { Rosenbrock rosenbrock = new Rosenbrock(); SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3); optimizer.setSimplex(new NelderMeadSimplex(new double[][] { { -1.2, 1 }, { 0.9, 1.2 } , { 3.5, -2.3 } })); PointValuePair optimum = optimizer.optimize(100, rosenbrock, GoalType.MINIMIZE, new double[] { -1.2, 1 }); Assert.assertEquals(rosenbrock.getCount(), optimizer.getEvaluations()); Assert.assertTrue(optimizer.getEvaluations() > 40); Assert.assertTrue(optimizer.getEvaluations() < 50); Assert.assertTrue(optimum.getValue() < 8e-4); } @Test public void testPowell() { Powell powell = new Powell(); SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3); optimizer.setSimplex(new NelderMeadSimplex(4)); PointValuePair optimum = optimizer.optimize(200, powell, GoalType.MINIMIZE, new double[] { 3, -1, 0, 1 }); Assert.assertEquals(powell.getCount(), optimizer.getEvaluations()); Assert.assertTrue(optimizer.getEvaluations() > 110); Assert.assertTrue(optimizer.getEvaluations() < 130); Assert.assertTrue(optimum.getValue() < 2e-3); } @Test public void testLeastSquares1() { final RealMatrix factors = new Array2DRowRealMatrix(new double[][] { { 1, 0 }, { 0, 1 } }, false); LeastSquaresConverter ls = new LeastSquaresConverter(new MultivariateVectorFunction() { public double[] value(double[] variables) { return factors.operate(variables); } }, new double[] { 2.0, -3.0 }); SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-6); optimizer.setSimplex(new NelderMeadSimplex(2)); PointValuePair optimum = optimizer.optimize(200, ls, GoalType.MINIMIZE, new double[] { 10, 10 }); Assert.assertEquals( 2, optimum.getPointRef()[0], 3e-5); Assert.assertEquals(-3, optimum.getPointRef()[1], 4e-4); Assert.assertTrue(optimizer.getEvaluations() > 60); Assert.assertTrue(optimizer.getEvaluations() < 80); Assert.assertTrue(optimum.getValue() < 1.0e-6); } @Test public void testLeastSquares2() { final RealMatrix factors = new Array2DRowRealMatrix(new double[][] { { 1, 0 }, { 0, 1 } }, false); LeastSquaresConverter ls = new LeastSquaresConverter(new MultivariateVectorFunction() { public double[] value(double[] variables) { return factors.operate(variables); } }, new double[] { 2, -3 }, new double[] { 10, 0.1 }); SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-6); optimizer.setSimplex(new NelderMeadSimplex(2)); PointValuePair optimum = optimizer.optimize(200, ls, GoalType.MINIMIZE, new double[] { 10, 10 }); Assert.assertEquals( 2, optimum.getPointRef()[0], 5e-5); Assert.assertEquals(-3, optimum.getPointRef()[1], 8e-4); Assert.assertTrue(optimizer.getEvaluations() > 60); Assert.assertTrue(optimizer.getEvaluations() < 80); Assert.assertTrue(optimum.getValue() < 1e-6); } @Test public void testLeastSquares3() { final RealMatrix factors = new Array2DRowRealMatrix(new double[][] { { 1, 0 }, { 0, 1 } }, false); LeastSquaresConverter ls = new LeastSquaresConverter(new MultivariateVectorFunction() { public double[] value(double[] variables) { return factors.operate(variables); } }, new double[] { 2, -3 }, new Array2DRowRealMatrix(new double [][] { { 1, 1.2 }, { 1.2, 2 } })); SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-6); optimizer.setSimplex(new NelderMeadSimplex(2)); PointValuePair optimum = optimizer.optimize(200, ls, GoalType.MINIMIZE, new double[] { 10, 10 }); Assert.assertEquals( 2, optimum.getPointRef()[0], 2e-3); Assert.assertEquals(-3, optimum.getPointRef()[1], 8e-4); Assert.assertTrue(optimizer.getEvaluations() > 60); Assert.assertTrue(optimizer.getEvaluations() < 80); Assert.assertTrue(optimum.getValue() < 1e-6); } @Test(expected = TooManyEvaluationsException.class) public void testMaxIterations() { Powell powell = new Powell(); SimplexOptimizer optimizer = new SimplexOptimizer(-1, 1e-3); optimizer.setSimplex(new NelderMeadSimplex(4)); optimizer.optimize(20, powell, GoalType.MINIMIZE, new double[] { 3, -1, 0, 1 }); } private static class FourExtrema implements MultivariateFunction { // The following function has 4 local extrema. final double xM = -3.841947088256863675365; final double yM = -1.391745200270734924416; final double xP = 0.2286682237349059125691; final double yP = -yM; final double valueXmYm = 0.2373295333134216789769; // Local maximum. final double valueXmYp = -valueXmYm; // Local minimum. final double valueXpYm = -0.7290400707055187115322; // Global minimum. final double valueXpYp = -valueXpYm; // Global maximum. public double value(double[] variables) { final double x = variables[0]; final double y = variables[1]; return (x == 0 || y == 0) ? 0 : FastMath.atan(x) * FastMath.atan(x + 2) * FastMath.atan(y) * FastMath.atan(y) / (x * y); } } private static class Rosenbrock implements MultivariateFunction { private int count; public Rosenbrock() { count = 0; } public double value(double[] x) { ++count; double a = x[1] - x[0] * x[0]; double b = 1.0 - x[0]; return 100 * a * a + b * b; } public int getCount() { return count; } } private static class Powell implements MultivariateFunction { private int count; public Powell() { count = 0; } public double value(double[] x) { ++count; double a = x[0] + 10 * x[1]; double b = x[2] - x[3]; double c = x[1] - 2 * x[2]; double d = x[0] - x[3]; return a * a + 5 * b * b + c * c * c * c + 10 * d * d * d * d; } public int getCount() { return count; } } }
// Licensed to the Apache Software Foundation (ASF) under one // or more contributor license agreements. See the NOTICE file // distributed with this work for additional information // regarding copyright ownership. The ASF licenses this file // to you under the Apache License, Version 2.0 (the // "License"); you may not use this file except in compliance // with the License. You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, // software distributed under the License is distributed on an // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY // KIND, either express or implied. See the License for the // specific language governing permissions and limitations // under the License. package org.apache.commons.math3.optimization.fitting; import org.apache.commons.math3.optimization.general.LevenbergMarquardtOptimizer; import org.apache.commons.math3.analysis.ParametricUnivariateFunction; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class CurveFitterTest { @Test public void testMath303() { LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer(); CurveFitter<ParametricUnivariateFunction> fitter = new CurveFitter<ParametricUnivariateFunction>(optimizer); fitter.addObservedPoint(2.805d, 0.6934785852953367d); fitter.addObservedPoint(2.74333333333333d, 0.6306772025518496d); fitter.addObservedPoint(1.655d, 0.9474675497289684); fitter.addObservedPoint(1.725d, 0.9013594835804194d); ParametricUnivariateFunction sif = new SimpleInverseFunction(); double[] initialguess1 = new double[1]; initialguess1[0] = 1.0d; Assert.assertEquals(1, fitter.fit(sif, initialguess1).length); double[] initialguess2 = new double[2]; initialguess2[0] = 1.0d; initialguess2[1] = .5d; Assert.assertEquals(2, fitter.fit(sif, initialguess2).length); } @Test public void testMath304() { LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer(); CurveFitter<ParametricUnivariateFunction> fitter = new CurveFitter<ParametricUnivariateFunction>(optimizer); fitter.addObservedPoint(2.805d, 0.6934785852953367d); fitter.addObservedPoint(2.74333333333333d, 0.6306772025518496d); fitter.addObservedPoint(1.655d, 0.9474675497289684); fitter.addObservedPoint(1.725d, 0.9013594835804194d); ParametricUnivariateFunction sif = new SimpleInverseFunction(); double[] initialguess1 = new double[1]; initialguess1[0] = 1.0d; Assert.assertEquals(1.6357215104109237, fitter.fit(sif, initialguess1)[0], 1.0e-14); double[] initialguess2 = new double[1]; initialguess2[0] = 10.0d; Assert.assertEquals(1.6357215104109237, fitter.fit(sif, initialguess1)[0], 1.0e-14); } @Test public void testMath372() { LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer(); CurveFitter<ParametricUnivariateFunction> curveFitter = new CurveFitter<ParametricUnivariateFunction>(optimizer); curveFitter.addObservedPoint( 15, 4443); curveFitter.addObservedPoint( 31, 8493); curveFitter.addObservedPoint( 62, 17586); curveFitter.addObservedPoint(125, 30582); curveFitter.addObservedPoint(250, 45087); curveFitter.addObservedPoint(500, 50683); ParametricUnivariateFunction f = new ParametricUnivariateFunction() { public double value(double x, double ... parameters) { double a = parameters[0]; double b = parameters[1]; double c = parameters[2]; double d = parameters[3]; return d + ((a - d) / (1 + FastMath.pow(x / c, b))); } public double[] gradient(double x, double ... parameters) { double a = parameters[0]; double b = parameters[1]; double c = parameters[2]; double d = parameters[3]; double[] gradients = new double[4]; double den = 1 + FastMath.pow(x / c, b); // derivative with respect to a gradients[0] = 1 / den; // derivative with respect to b // in the reported (invalid) issue, there was a sign error here gradients[1] = -((a - d) * FastMath.pow(x / c, b) * FastMath.log(x / c)) / (den * den); // derivative with respect to c gradients[2] = (b * FastMath.pow(x / c, b - 1) * (x / (c * c)) * (a - d)) / (den * den); // derivative with respect to d gradients[3] = 1 - (1 / den); return gradients; } }; double[] initialGuess = new double[] { 1500, 0.95, 65, 35000 }; double[] estimatedParameters = curveFitter.fit(f, initialGuess); Assert.assertEquals( 2411.00, estimatedParameters[0], 500.00); Assert.assertEquals( 1.62, estimatedParameters[1], 0.04); Assert.assertEquals( 111.22, estimatedParameters[2], 0.30); Assert.assertEquals(55347.47, estimatedParameters[3], 300.00); Assert.assertTrue(optimizer.getRMS() < 600.0); } private static class SimpleInverseFunction implements ParametricUnivariateFunction { public double value(double x, double ... parameters) { return parameters[0] / x + (parameters.length < 2 ? 0 : parameters[1]); } public double[] gradient(double x, double ... doubles) { double[] gradientVector = new double[doubles.length]; gradientVector[0] = 1 / x; if (doubles.length >= 2) { gradientVector[1] = 1; } return gradientVector; } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optimization.fitting; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.optimization.general.LevenbergMarquardtOptimizer; import org.junit.Assert; import org.junit.Test; /** * Tests {@link GaussianFitter}. * * @since 2.2 * @version $Id$ */ public class GaussianFitterTest { /** Good data. */ protected static final double[][] DATASET1 = new double[][] { {4.0254623, 531026.0}, {4.02804905, 664002.0}, {4.02934242, 787079.0}, {4.03128248, 984167.0}, {4.03386923, 1294546.0}, {4.03580929, 1560230.0}, {4.03839603, 1887233.0}, {4.0396894, 2113240.0}, {4.04162946, 2375211.0}, {4.04421621, 2687152.0}, {4.04550958, 2862644.0}, {4.04744964, 3078898.0}, {4.05003639, 3327238.0}, {4.05132976, 3461228.0}, {4.05326982, 3580526.0}, {4.05585657, 3576946.0}, {4.05779662, 3439750.0}, {4.06038337, 3220296.0}, {4.06167674, 3070073.0}, {4.0636168, 2877648.0}, {4.06620355, 2595848.0}, {4.06749692, 2390157.0}, {4.06943698, 2175960.0}, {4.07202373, 1895104.0}, {4.0733171, 1687576.0}, {4.07525716, 1447024.0}, {4.0778439, 1130879.0}, {4.07978396, 904900.0}, {4.08237071, 717104.0}, {4.08366408, 620014.0} }; /** Poor data: right of peak not symmetric with left of peak. */ protected static final double[][] DATASET2 = new double[][] { {-20.15, 1523.0}, {-19.65, 1566.0}, {-19.15, 1592.0}, {-18.65, 1927.0}, {-18.15, 3089.0}, {-17.65, 6068.0}, {-17.15, 14239.0}, {-16.65, 34124.0}, {-16.15, 64097.0}, {-15.65, 110352.0}, {-15.15, 164742.0}, {-14.65, 209499.0}, {-14.15, 267274.0}, {-13.65, 283290.0}, {-13.15, 275363.0}, {-12.65, 258014.0}, {-12.15, 225000.0}, {-11.65, 200000.0}, {-11.15, 190000.0}, {-10.65, 185000.0}, {-10.15, 180000.0}, { -9.65, 179000.0}, { -9.15, 178000.0}, { -8.65, 177000.0}, { -8.15, 176000.0}, { -7.65, 175000.0}, { -7.15, 174000.0}, { -6.65, 173000.0}, { -6.15, 172000.0}, { -5.65, 171000.0}, { -5.15, 170000.0} }; /** Poor data: long tails. */ protected static final double[][] DATASET3 = new double[][] { {-90.15, 1513.0}, {-80.15, 1514.0}, {-70.15, 1513.0}, {-60.15, 1514.0}, {-50.15, 1513.0}, {-40.15, 1514.0}, {-30.15, 1513.0}, {-20.15, 1523.0}, {-19.65, 1566.0}, {-19.15, 1592.0}, {-18.65, 1927.0}, {-18.15, 3089.0}, {-17.65, 6068.0}, {-17.15, 14239.0}, {-16.65, 34124.0}, {-16.15, 64097.0}, {-15.65, 110352.0}, {-15.15, 164742.0}, {-14.65, 209499.0}, {-14.15, 267274.0}, {-13.65, 283290.0}, {-13.15, 275363.0}, {-12.65, 258014.0}, {-12.15, 214073.0}, {-11.65, 182244.0}, {-11.15, 136419.0}, {-10.65, 97823.0}, {-10.15, 58930.0}, { -9.65, 35404.0}, { -9.15, 16120.0}, { -8.65, 9823.0}, { -8.15, 5064.0}, { -7.65, 2575.0}, { -7.15, 1642.0}, { -6.65, 1101.0}, { -6.15, 812.0}, { -5.65, 690.0}, { -5.15, 565.0}, { 5.15, 564.0}, { 15.15, 565.0}, { 25.15, 564.0}, { 35.15, 565.0}, { 45.15, 564.0}, { 55.15, 565.0}, { 65.15, 564.0}, { 75.15, 565.0} }; /** Poor data: right of peak is missing. */ protected static final double[][] DATASET4 = new double[][] { {-20.15, 1523.0}, {-19.65, 1566.0}, {-19.15, 1592.0}, {-18.65, 1927.0}, {-18.15, 3089.0}, {-17.65, 6068.0}, {-17.15, 14239.0}, {-16.65, 34124.0}, {-16.15, 64097.0}, {-15.65, 110352.0}, {-15.15, 164742.0}, {-14.65, 209499.0}, {-14.15, 267274.0}, {-13.65, 283290.0} }; /** Good data, but few points. */ protected static final double[][] DATASET5 = new double[][] { {4.0254623, 531026.0}, {4.03128248, 984167.0}, {4.03839603, 1887233.0}, {4.04421621, 2687152.0}, {4.05132976, 3461228.0}, {4.05326982, 3580526.0}, {4.05779662, 3439750.0}, {4.0636168, 2877648.0}, {4.06943698, 2175960.0}, {4.07525716, 1447024.0}, {4.08237071, 717104.0}, {4.08366408, 620014.0} }; /** * Basic. */ @Test public void testFit01() { GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer()); addDatasetToGaussianFitter(DATASET1, fitter); double[] parameters = fitter.fit(); Assert.assertEquals(3496978.1837704973, parameters[0], 1e-4); Assert.assertEquals(4.054933085999146, parameters[1], 1e-4); Assert.assertEquals(0.015039355620304326, parameters[2], 1e-4); } /** * Zero points is not enough observed points. */ @Test(expected=MathIllegalArgumentException.class) public void testFit02() { GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer()); fitter.fit(); } /** * Two points is not enough observed points. */ @Test(expected=MathIllegalArgumentException.class) public void testFit03() { GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer()); addDatasetToGaussianFitter(new double[][] { {4.0254623, 531026.0}, {4.02804905, 664002.0}}, fitter); fitter.fit(); } /** * Poor data: right of peak not symmetric with left of peak. */ @Test public void testFit04() { GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer()); addDatasetToGaussianFitter(DATASET2, fitter); double[] parameters = fitter.fit(); Assert.assertEquals(233003.2967252038, parameters[0], 1e-4); Assert.assertEquals(-10.654887521095983, parameters[1], 1e-4); Assert.assertEquals(4.335937353196641, parameters[2], 1e-4); } /** * Poor data: long tails. */ @Test public void testFit05() { GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer()); addDatasetToGaussianFitter(DATASET3, fitter); double[] parameters = fitter.fit(); Assert.assertEquals(283863.81929180305, parameters[0], 1e-4); Assert.assertEquals(-13.29641995105174, parameters[1], 1e-4); Assert.assertEquals(1.7297330293549908, parameters[2], 1e-4); } /** * Poor data: right of peak is missing. */ @Test public void testFit06() { GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer()); addDatasetToGaussianFitter(DATASET4, fitter); double[] parameters = fitter.fit(); Assert.assertEquals(285250.66754309234, parameters[0], 1e-4); Assert.assertEquals(-13.528375695228455, parameters[1], 1e-4); Assert.assertEquals(1.5204344894331614, parameters[2], 1e-4); } /** * Basic with smaller dataset. */ @Test public void testFit07() { GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer()); addDatasetToGaussianFitter(DATASET5, fitter); double[] parameters = fitter.fit(); Assert.assertEquals(3514384.729342235, parameters[0], 1e-4); Assert.assertEquals(4.054970307455625, parameters[1], 1e-4); Assert.assertEquals(0.015029412832160017, parameters[2], 1e-4); } @Test public void testMath519() { // The optimizer will try negative sigma values but "GaussianFitter" // will catch the raised exceptions and return NaN values instead. final double[] data = { 1.1143831578403364E-29, 4.95281403484594E-28, 1.1171347211930288E-26, 1.7044813962636277E-25, 1.9784716574832164E-24, 1.8630236407866774E-23, 1.4820532905097742E-22, 1.0241963854632831E-21, 6.275077366673128E-21, 3.461808994532493E-20, 1.7407124684715706E-19, 8.056687953553974E-19, 3.460193945992071E-18, 1.3883326374011525E-17, 5.233894983671116E-17, 1.8630791465263745E-16, 6.288759227922111E-16, 2.0204433920597856E-15, 6.198768938576155E-15, 1.821419346860626E-14, 5.139176445538471E-14, 1.3956427429045787E-13, 3.655705706448139E-13, 9.253753324779779E-13, 2.267636001476696E-12, 5.3880460095836855E-12, 1.2431632654852931E-11 }; GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer()); for (int i = 0; i < data.length; i++) { fitter.addObservedPoint(i, data[i]); } final double[] p = fitter.fit(); Assert.assertEquals(53.1572792, p[1], 1e-7); Assert.assertEquals(5.75214622, p[2], 1e-8); } @Test public void testMath798() { final GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer()); // When the data points are not commented out below, the fit stalls. // This is expected however, since the whole dataset hardly looks like // a Gaussian. // When commented out, the fit proceeds fine. fitter.addObservedPoint(0.23, 395.0); //fitter.addObservedPoint(0.68, 0.0); fitter.addObservedPoint(1.14, 376.0); //fitter.addObservedPoint(1.59, 0.0); fitter.addObservedPoint(2.05, 163.0); //fitter.addObservedPoint(2.50, 0.0); fitter.addObservedPoint(2.95, 49.0); //fitter.addObservedPoint(3.41, 0.0); fitter.addObservedPoint(3.86, 16.0); //fitter.addObservedPoint(4.32, 0.0); fitter.addObservedPoint(4.77, 1.0); final double[] p = fitter.fit(); // Values are copied from a previous run of this test. Assert.assertEquals(420.8397296167364, p[0], 1e-12); Assert.assertEquals(0.603770729862231, p[1], 1e-15); Assert.assertEquals(1.0786447936766612, p[2], 1e-14); } /** * Adds the specified points to specified <code>GaussianFitter</code> * instance. * * @param points data points where first dimension is a point index and * second dimension is an array of length two representing the point * with the first value corresponding to X and the second value * corresponding to Y * @param fitter fitter to which the points in <code>points</code> should be * added as observed points */ protected static void addDatasetToGaussianFitter(double[][] points, GaussianFitter fitter) { for (int i = 0; i < points.length; i++) { fitter.addObservedPoint(points[i][0], points[i][1]); } } }
// Licensed to the Apache Software Foundation (ASF) under one // or more contributor license agreements. See the NOTICE file // distributed with this work for additional information // regarding copyright ownership. The ASF licenses this file // to you under the Apache License, Version 2.0 (the // "License"); you may not use this file except in compliance // with the License. You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, // software distributed under the License is distributed on an // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY // KIND, either express or implied. See the License for the // specific language governing permissions and limitations // under the License. package org.apache.commons.math3.optimization.fitting; import java.util.Random; import org.apache.commons.math3.analysis.function.HarmonicOscillator; import org.apache.commons.math3.optimization.general.LevenbergMarquardtOptimizer; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.exception.MathIllegalStateException; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.util.MathUtils; import org.junit.Test; import org.junit.Assert; public class HarmonicFitterTest { @Test(expected=NumberIsTooSmallException.class) public void testPreconditions1() { HarmonicFitter fitter = new HarmonicFitter(new LevenbergMarquardtOptimizer()); fitter.fit(); } // This test fails (throwing "ConvergenceException" instead). // @Test(expected=ZeroException.class) // public void testPreconditions2() { // HarmonicFitter fitter = // new HarmonicFitter(new LevenbergMarquardtOptimizer()); // final double x = 1.2; // fitter.addObservedPoint(1, x, 1); // fitter.addObservedPoint(1, x, -1); // fitter.addObservedPoint(1, x, 0.5); // fitter.addObservedPoint(1, x, 0); // final double[] fitted = fitter.fit(); // } @Test public void testNoError() { final double a = 0.2; final double w = 3.4; final double p = 4.1; HarmonicOscillator f = new HarmonicOscillator(a, w, p); HarmonicFitter fitter = new HarmonicFitter(new LevenbergMarquardtOptimizer()); for (double x = 0.0; x < 1.3; x += 0.01) { fitter.addObservedPoint(1, x, f.value(x)); } final double[] fitted = fitter.fit(); Assert.assertEquals(a, fitted[0], 1.0e-13); Assert.assertEquals(w, fitted[1], 1.0e-13); Assert.assertEquals(p, MathUtils.normalizeAngle(fitted[2], p), 1e-13); HarmonicOscillator ff = new HarmonicOscillator(fitted[0], fitted[1], fitted[2]); for (double x = -1.0; x < 1.0; x += 0.01) { Assert.assertTrue(FastMath.abs(f.value(x) - ff.value(x)) < 1e-13); } } @Test public void test1PercentError() { Random randomizer = new Random(64925784252l); final double a = 0.2; final double w = 3.4; final double p = 4.1; HarmonicOscillator f = new HarmonicOscillator(a, w, p); HarmonicFitter fitter = new HarmonicFitter(new LevenbergMarquardtOptimizer()); for (double x = 0.0; x < 10.0; x += 0.1) { fitter.addObservedPoint(1, x, f.value(x) + 0.01 * randomizer.nextGaussian()); } final double[] fitted = fitter.fit(); Assert.assertEquals(a, fitted[0], 7.6e-4); Assert.assertEquals(w, fitted[1], 2.7e-3); Assert.assertEquals(p, MathUtils.normalizeAngle(fitted[2], p), 1.3e-2); } @Test public void testTinyVariationsData() { Random randomizer = new Random(64925784252l); HarmonicFitter fitter = new HarmonicFitter(new LevenbergMarquardtOptimizer()); for (double x = 0.0; x < 10.0; x += 0.1) { fitter.addObservedPoint(1, x, 1e-7 * randomizer.nextGaussian()); } fitter.fit(); // This test serves to cover the part of the code of "guessAOmega" // when the algorithm using integrals fails. } @Test public void testInitialGuess() { Random randomizer = new Random(45314242l); final double a = 0.2; final double w = 3.4; final double p = 4.1; HarmonicOscillator f = new HarmonicOscillator(a, w, p); HarmonicFitter fitter = new HarmonicFitter(new LevenbergMarquardtOptimizer()); for (double x = 0.0; x < 10.0; x += 0.1) { fitter.addObservedPoint(1, x, f.value(x) + 0.01 * randomizer.nextGaussian()); } final double[] fitted = fitter.fit(new double[] { 0.15, 3.6, 4.5 }); Assert.assertEquals(a, fitted[0], 1.2e-3); Assert.assertEquals(w, fitted[1], 3.3e-3); Assert.assertEquals(p, MathUtils.normalizeAngle(fitted[2], p), 1.7e-2); } @Test public void testUnsorted() { Random randomizer = new Random(64925784252l); final double a = 0.2; final double w = 3.4; final double p = 4.1; HarmonicOscillator f = new HarmonicOscillator(a, w, p); HarmonicFitter fitter = new HarmonicFitter(new LevenbergMarquardtOptimizer()); // build a regularly spaced array of measurements int size = 100; double[] xTab = new double[size]; double[] yTab = new double[size]; for (int i = 0; i < size; ++i) { xTab[i] = 0.1 * i; yTab[i] = f.value(xTab[i]) + 0.01 * randomizer.nextGaussian(); } // shake it for (int i = 0; i < size; ++i) { int i1 = randomizer.nextInt(size); int i2 = randomizer.nextInt(size); double xTmp = xTab[i1]; double yTmp = yTab[i1]; xTab[i1] = xTab[i2]; yTab[i1] = yTab[i2]; xTab[i2] = xTmp; yTab[i2] = yTmp; } // pass it to the fitter for (int i = 0; i < size; ++i) { fitter.addObservedPoint(1, xTab[i], yTab[i]); } final double[] fitted = fitter.fit(); Assert.assertEquals(a, fitted[0], 7.6e-4); Assert.assertEquals(w, fitted[1], 3.5e-3); Assert.assertEquals(p, MathUtils.normalizeAngle(fitted[2], p), 1.5e-2); } @Test(expected=MathIllegalStateException.class) public void testMath844() { final double[] y = { 0, 1, 2, 3, 2, 1, 0, -1, -2, -3, -2, -1, 0, 1, 2, 3, 2, 1, 0, -1, -2, -3, -2, -1, 0, 1, 2, 3, 2, 1, 0 }; final int len = y.length; final WeightedObservedPoint[] points = new WeightedObservedPoint[len]; for (int i = 0; i < len; i++) { points[i] = new WeightedObservedPoint(1, i, y[i]); } // The guesser fails because the function is far from an harmonic // function: It is a triangular periodic function with amplitude 3 // and period 12, and all sample points are taken at integer abscissae // so function values all belong to the integer subset {-3, -2, -1, 0, // 1, 2, 3}. new HarmonicFitter.ParameterGuesser(points); } }
// Licensed to the Apache Software Foundation (ASF) under one // or more contributor license agreements. See the NOTICE file // distributed with this work for additional information // regarding copyright ownership. The ASF licenses this file // to you under the Apache License, Version 2.0 (the // "License"); you may not use this file except in compliance // with the License. You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, // software distributed under the License is distributed on an // "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY // KIND, either express or implied. See the License for the // specific language governing permissions and limitations // under the License. package org.apache.commons.math3.optimization.fitting; import java.util.Random; import org.apache.commons.math3.analysis.polynomials.PolynomialFunction; import org.apache.commons.math3.analysis.polynomials.PolynomialFunction.Parametric; import org.apache.commons.math3.exception.ConvergenceException; import org.apache.commons.math3.exception.TooManyEvaluationsException; import org.apache.commons.math3.optimization.DifferentiableMultivariateVectorOptimizer; import org.apache.commons.math3.optimization.general.GaussNewtonOptimizer; import org.apache.commons.math3.optimization.general.LevenbergMarquardtOptimizer; import org.apache.commons.math3.optimization.SimpleVectorValueChecker; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.distribution.RealDistribution; import org.apache.commons.math3.distribution.UniformRealDistribution; import org.apache.commons.math3.TestUtils; import org.junit.Test; import org.junit.Assert; /** * Test for class {@link CurveFitter} where the function to fit is a * polynomial. */ public class PolynomialFitterTest { @Test public void testFit() { final RealDistribution rng = new UniformRealDistribution(-100, 100); rng.reseedRandomGenerator(64925784252L); final LevenbergMarquardtOptimizer optim = new LevenbergMarquardtOptimizer(); final PolynomialFitter fitter = new PolynomialFitter(optim); final double[] coeff = { 12.9, -3.4, 2.1 }; // 12.9 - 3.4 x + 2.1 x^2 final PolynomialFunction f = new PolynomialFunction(coeff); // Collect data from a known polynomial. for (int i = 0; i < 100; i++) { final double x = rng.sample(); fitter.addObservedPoint(x, f.value(x)); } // Start fit from initial guesses that are far from the optimal values. final double[] best = fitter.fit(new double[] { -1e-20, 3e15, -5e25 }); TestUtils.assertEquals("best != coeff", coeff, best, 1e-12); } @Test public void testNoError() { Random randomizer = new Random(64925784252l); for (int degree = 1; degree < 10; ++degree) { PolynomialFunction p = buildRandomPolynomial(degree, randomizer); PolynomialFitter fitter = new PolynomialFitter(new LevenbergMarquardtOptimizer()); for (int i = 0; i <= degree; ++i) { fitter.addObservedPoint(1.0, i, p.value(i)); } final double[] init = new double[degree + 1]; PolynomialFunction fitted = new PolynomialFunction(fitter.fit(init)); for (double x = -1.0; x < 1.0; x += 0.01) { double error = FastMath.abs(p.value(x) - fitted.value(x)) / (1.0 + FastMath.abs(p.value(x))); Assert.assertEquals(0.0, error, 1.0e-6); } } } @Test public void testSmallError() { Random randomizer = new Random(53882150042l); double maxError = 0; for (int degree = 0; degree < 10; ++degree) { PolynomialFunction p = buildRandomPolynomial(degree, randomizer); PolynomialFitter fitter = new PolynomialFitter(new LevenbergMarquardtOptimizer()); for (double x = -1.0; x < 1.0; x += 0.01) { fitter.addObservedPoint(1.0, x, p.value(x) + 0.1 * randomizer.nextGaussian()); } final double[] init = new double[degree + 1]; PolynomialFunction fitted = new PolynomialFunction(fitter.fit(init)); for (double x = -1.0; x < 1.0; x += 0.01) { double error = FastMath.abs(p.value(x) - fitted.value(x)) / (1.0 + FastMath.abs(p.value(x))); maxError = FastMath.max(maxError, error); Assert.assertTrue(FastMath.abs(error) < 0.1); } } Assert.assertTrue(maxError > 0.01); } @Test public void testMath798() { final double tol = 1e-14; final SimpleVectorValueChecker checker = new SimpleVectorValueChecker(tol, tol); final double[] init = new double[] { 0, 0 }; final int maxEval = 3; final double[] lm = doMath798(new LevenbergMarquardtOptimizer(checker), maxEval, init); final double[] gn = doMath798(new GaussNewtonOptimizer(checker), maxEval, init); for (int i = 0; i <= 1; i++) { Assert.assertEquals(lm[i], gn[i], tol); } } /** * This test shows that the user can set the maximum number of iterations * to avoid running for too long. * But in the test case, the real problem is that the tolerance is way too * stringent. */ @Test(expected=TooManyEvaluationsException.class) public void testMath798WithToleranceTooLow() { final double tol = 1e-100; final SimpleVectorValueChecker checker = new SimpleVectorValueChecker(tol, tol); final double[] init = new double[] { 0, 0 }; final int maxEval = 10000; // Trying hard to fit. final double[] gn = doMath798(new GaussNewtonOptimizer(checker), maxEval, init); } /** * This test shows that the user can set the maximum number of iterations * to avoid running for too long. * Even if the real problem is that the tolerance is way too stringent, it * is possible to get the best solution so far, i.e. a checker will return * the point when the maximum iteration count has been reached. */ @Test public void testMath798WithToleranceTooLowButNoException() { final double tol = 1e-100; final double[] init = new double[] { 0, 0 }; final int maxEval = 10000; // Trying hard to fit. final SimpleVectorValueChecker checker = new SimpleVectorValueChecker(tol, tol, maxEval); final double[] lm = doMath798(new LevenbergMarquardtOptimizer(checker), maxEval, init); final double[] gn = doMath798(new GaussNewtonOptimizer(checker), maxEval, init); for (int i = 0; i <= 1; i++) { Assert.assertEquals(lm[i], gn[i], 1e-15); } } /** * @param optimizer Optimizer. * @param maxEval Maximum number of function evaluations. * @param init First guess. * @return the solution found by the given optimizer. */ private double[] doMath798(DifferentiableMultivariateVectorOptimizer optimizer, int maxEval, double[] init) { final CurveFitter<Parametric> fitter = new CurveFitter<Parametric>(optimizer); fitter.addObservedPoint(-0.2, -7.12442E-13); fitter.addObservedPoint(-0.199, -4.33397E-13); fitter.addObservedPoint(-0.198, -2.823E-13); fitter.addObservedPoint(-0.197, -1.40405E-13); fitter.addObservedPoint(-0.196, -7.80821E-15); fitter.addObservedPoint(-0.195, 6.20484E-14); fitter.addObservedPoint(-0.194, 7.24673E-14); fitter.addObservedPoint(-0.193, 1.47152E-13); fitter.addObservedPoint(-0.192, 1.9629E-13); fitter.addObservedPoint(-0.191, 2.12038E-13); fitter.addObservedPoint(-0.19, 2.46906E-13); fitter.addObservedPoint(-0.189, 2.77495E-13); fitter.addObservedPoint(-0.188, 2.51281E-13); fitter.addObservedPoint(-0.187, 2.64001E-13); fitter.addObservedPoint(-0.186, 2.8882E-13); fitter.addObservedPoint(-0.185, 3.13604E-13); fitter.addObservedPoint(-0.184, 3.14248E-13); fitter.addObservedPoint(-0.183, 3.1172E-13); fitter.addObservedPoint(-0.182, 3.12912E-13); fitter.addObservedPoint(-0.181, 3.06761E-13); fitter.addObservedPoint(-0.18, 2.8559E-13); fitter.addObservedPoint(-0.179, 2.86806E-13); fitter.addObservedPoint(-0.178, 2.985E-13); fitter.addObservedPoint(-0.177, 2.67148E-13); fitter.addObservedPoint(-0.176, 2.94173E-13); fitter.addObservedPoint(-0.175, 3.27528E-13); fitter.addObservedPoint(-0.174, 3.33858E-13); fitter.addObservedPoint(-0.173, 2.97511E-13); fitter.addObservedPoint(-0.172, 2.8615E-13); fitter.addObservedPoint(-0.171, 2.84624E-13); final double[] coeff = fitter.fit(maxEval, new PolynomialFunction.Parametric(), init); return coeff; } @Test public void testRedundantSolvable() { // Levenberg-Marquardt should handle redundant information gracefully checkUnsolvableProblem(new LevenbergMarquardtOptimizer(), true); } @Test public void testRedundantUnsolvable() { // Gauss-Newton should not be able to solve redundant information checkUnsolvableProblem(new GaussNewtonOptimizer(true, new SimpleVectorValueChecker(1e-15, 1e-15)), false); } @Test public void testLargeSample() { Random randomizer = new Random(0x5551480dca5b369bl); double maxError = 0; for (int degree = 0; degree < 10; ++degree) { PolynomialFunction p = buildRandomPolynomial(degree, randomizer); PolynomialFitter fitter = new PolynomialFitter(new LevenbergMarquardtOptimizer()); for (int i = 0; i < 40000; ++i) { double x = -1.0 + i / 20000.0; fitter.addObservedPoint(1.0, x, p.value(x) + 0.1 * randomizer.nextGaussian()); } final double[] init = new double[degree + 1]; PolynomialFunction fitted = new PolynomialFunction(fitter.fit(init)); for (double x = -1.0; x < 1.0; x += 0.01) { double error = FastMath.abs(p.value(x) - fitted.value(x)) / (1.0 + FastMath.abs(p.value(x))); maxError = FastMath.max(maxError, error); Assert.assertTrue(FastMath.abs(error) < 0.01); } } Assert.assertTrue(maxError > 0.001); } private void checkUnsolvableProblem(DifferentiableMultivariateVectorOptimizer optimizer, boolean solvable) { Random randomizer = new Random(1248788532l); for (int degree = 0; degree < 10; ++degree) { PolynomialFunction p = buildRandomPolynomial(degree, randomizer); PolynomialFitter fitter = new PolynomialFitter(optimizer); // reusing the same point over and over again does not bring // information, the problem cannot be solved in this case for // degrees greater than 1 (but one point is sufficient for // degree 0) for (double x = -1.0; x < 1.0; x += 0.01) { fitter.addObservedPoint(1.0, 0.0, p.value(0.0)); } try { final double[] init = new double[degree + 1]; fitter.fit(init); Assert.assertTrue(solvable || (degree == 0)); } catch(ConvergenceException e) { Assert.assertTrue((! solvable) && (degree > 0)); } } } private PolynomialFunction buildRandomPolynomial(int degree, Random randomizer) { final double[] coefficients = new double[degree + 1]; for (int i = 0; i <= degree; ++i) { coefficients[i] = randomizer.nextGaussian(); } return new PolynomialFunction(coefficients); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optimization.general; import java.io.IOException; import org.apache.commons.math3.exception.ConvergenceException; import org.apache.commons.math3.exception.TooManyEvaluationsException; import org.apache.commons.math3.optimization.SimpleVectorValueChecker; import org.junit.Test; /** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files. * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> * Minpack Copyright Notice (1999) University of Chicago. * All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> * <li>Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above * copyright notice, this list of conditions and the following * disclaimer in the documentation and/or other materials provided * with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, * must include the following acknowledgment: * <code>This product includes software developed by the University of * Chicago, as Operator of Argonne National Laboratory.</code> * Alternately, this acknowledgment may appear in the software itself, * if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" * WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE * UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND * THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE * OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY * OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR * USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF * THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) * DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION * UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL * BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT * HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF * ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, * INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF * ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF * PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER * SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT * (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, * EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE * POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */ public class GaussNewtonOptimizerTest extends AbstractLeastSquaresOptimizerAbstractTest { @Override public AbstractLeastSquaresOptimizer createOptimizer() { return new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-6, 1.0e-6)); } @Override @Test(expected = ConvergenceException.class) public void testMoreEstimatedParametersSimple() { /* * Exception is expected with this optimizer */ super.testMoreEstimatedParametersSimple(); } @Override @Test(expected=ConvergenceException.class) public void testMoreEstimatedParametersUnsorted() { /* * Exception is expected with this optimizer */ super.testMoreEstimatedParametersUnsorted(); } @Test(expected=TooManyEvaluationsException.class) public void testMaxEvaluations() throws Exception { CircleVectorial circle = new CircleVectorial(); circle.addPoint( 30.0, 68.0); circle.addPoint( 50.0, -6.0); circle.addPoint(110.0, -20.0); circle.addPoint( 35.0, 15.0); circle.addPoint( 45.0, 97.0); GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(new SimpleVectorValueChecker(1.0e-30, 1.0e-30)); optimizer.optimize(100, circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 }, new double[] { 98.680, 47.345 }); } @Override @Test(expected=ConvergenceException.class) public void testCircleFittingBadInit() { /* * This test does not converge with this optimizer. */ super.testCircleFittingBadInit(); } @Override @Test(expected = ConvergenceException.class) public void testHahn1() throws IOException { /* * TODO This test leads to a singular problem with the Gauss-Newton * optimizer. This should be inquired. */ super.testHahn1(); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optimization.general; import java.io.Serializable; import java.util.ArrayList; import java.util.List; import org.apache.commons.math3.analysis.differentiation.DerivativeStructure; import org.apache.commons.math3.analysis.differentiation.MultivariateDifferentiableVectorFunction; import org.apache.commons.math3.exception.ConvergenceException; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.TooManyEvaluationsException; import org.apache.commons.math3.geometry.euclidean.twod.Vector2D; import org.apache.commons.math3.linear.SingularMatrixException; import org.apache.commons.math3.optimization.PointVectorValuePair; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.util.Precision; import org.junit.Assert; import org.junit.Test; import org.junit.Ignore; /** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files. * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> * Minpack Copyright Notice (1999) University of Chicago. * All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> * <li>Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above * copyright notice, this list of conditions and the following * disclaimer in the documentation and/or other materials provided * with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, * must include the following acknowledgment: * <code>This product includes software developed by the University of * Chicago, as Operator of Argonne National Laboratory.</code> * Alternately, this acknowledgment may appear in the software itself, * if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" * WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE * UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND * THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE * OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY * OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR * USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF * THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) * DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION * UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL * BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT * HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF * ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, * INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF * ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF * PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER * SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT * (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, * EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE * POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */ public class LevenbergMarquardtOptimizerTest extends AbstractLeastSquaresOptimizerAbstractTest { @Override public AbstractLeastSquaresOptimizer createOptimizer() { return new LevenbergMarquardtOptimizer(); } @Override @Test(expected=SingularMatrixException.class) public void testNonInvertible() { /* * Overrides the method from parent class, since the default singularity * threshold (1e-14) does not trigger the expected exception. */ LinearProblem problem = new LinearProblem(new double[][] { { 1, 2, -3 }, { 2, 1, 3 }, { -3, 0, -9 } }, new double[] { 1, 1, 1 }); AbstractLeastSquaresOptimizer optimizer = createOptimizer(); PointVectorValuePair optimum = optimizer.optimize(100, problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 }); Assert.assertTrue(FastMath.sqrt(problem.target.length) * optimizer.getRMS() > 0.6); optimizer.computeCovariances(optimum.getPoint(), 1.5e-14); } @Test public void testControlParameters() { CircleVectorial circle = new CircleVectorial(); circle.addPoint( 30.0, 68.0); circle.addPoint( 50.0, -6.0); circle.addPoint(110.0, -20.0); circle.addPoint( 35.0, 15.0); circle.addPoint( 45.0, 97.0); checkEstimate(circle, 0.1, 10, 1.0e-14, 1.0e-16, 1.0e-10, false); checkEstimate(circle, 0.1, 10, 1.0e-15, 1.0e-17, 1.0e-10, true); checkEstimate(circle, 0.1, 5, 1.0e-15, 1.0e-16, 1.0e-10, true); circle.addPoint(300, -300); checkEstimate(circle, 0.1, 20, 1.0e-18, 1.0e-16, 1.0e-10, true); } private void checkEstimate(MultivariateDifferentiableVectorFunction problem, double initialStepBoundFactor, int maxCostEval, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, boolean shouldFail) { try { LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer(initialStepBoundFactor, costRelativeTolerance, parRelativeTolerance, orthoTolerance, Precision.SAFE_MIN); optimizer.optimize(maxCostEval, problem, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 }, new double[] { 98.680, 47.345 }); Assert.assertTrue(!shouldFail); } catch (DimensionMismatchException ee) { Assert.assertTrue(shouldFail); } catch (TooManyEvaluationsException ee) { Assert.assertTrue(shouldFail); } } // Test is skipped because it fails with the latest code update. @Ignore@Test public void testMath199() { try { QuadraticProblem problem = new QuadraticProblem(); problem.addPoint (0, -3.182591015485607); problem.addPoint (1, -2.5581184967730577); problem.addPoint (2, -2.1488478161387325); problem.addPoint (3, -1.9122489313410047); problem.addPoint (4, 1.7785661310051026); LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer(100, 1e-10, 1e-10, 1e-10, 0); optimizer.optimize(100, problem, new double[] { 0, 0, 0, 0, 0 }, new double[] { 0.0, 4.4e-323, 1.0, 4.4e-323, 0.0 }, new double[] { 0, 0, 0 }); Assert.fail("an exception should have been thrown"); } catch (ConvergenceException ee) { // expected behavior } } /** * Non-linear test case: fitting of decay curve (from Chapter 8 of * Bevington's textbook, "Data reduction and analysis for the physical sciences"). * XXX The expected ("reference") values may not be accurate and the tolerance too * relaxed for this test to be currently really useful (the issue is under * investigation). */ @Test public void testBevington() { final double[][] dataPoints = { // column 1 = times { 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180, 195, 210, 225, 240, 255, 270, 285, 300, 315, 330, 345, 360, 375, 390, 405, 420, 435, 450, 465, 480, 495, 510, 525, 540, 555, 570, 585, 600, 615, 630, 645, 660, 675, 690, 705, 720, 735, 750, 765, 780, 795, 810, 825, 840, 855, 870, 885, }, // column 2 = measured counts { 775, 479, 380, 302, 185, 157, 137, 119, 110, 89, 74, 61, 66, 68, 48, 54, 51, 46, 55, 29, 28, 37, 49, 26, 35, 29, 31, 24, 25, 35, 24, 30, 26, 28, 21, 18, 20, 27, 17, 17, 14, 17, 24, 11, 22, 17, 12, 10, 13, 16, 9, 9, 14, 21, 17, 13, 12, 18, 10, }, }; final BevingtonProblem problem = new BevingtonProblem(); final int len = dataPoints[0].length; final double[] weights = new double[len]; for (int i = 0; i < len; i++) { problem.addPoint(dataPoints[0][i], dataPoints[1][i]); weights[i] = 1 / dataPoints[1][i]; } final LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer(); final PointVectorValuePair optimum = optimizer.optimize(100, problem, dataPoints[1], weights, new double[] { 10, 900, 80, 27, 225 }); final double[] solution = optimum.getPoint(); final double[] expectedSolution = { 10.4, 958.3, 131.4, 33.9, 205.0 }; final double[][] covarMatrix = optimizer.computeCovariances(solution, 1e-14); final double[][] expectedCovarMatrix = { { 3.38, -3.69, 27.98, -2.34, -49.24 }, { -3.69, 2492.26, 81.89, -69.21, -8.9 }, { 27.98, 81.89, 468.99, -44.22, -615.44 }, { -2.34, -69.21, -44.22, 6.39, 53.80 }, { -49.24, -8.9, -615.44, 53.8, 929.45 } }; final int numParams = expectedSolution.length; // Check that the computed solution is within the reference error range. for (int i = 0; i < numParams; i++) { final double error = FastMath.sqrt(expectedCovarMatrix[i][i]); Assert.assertEquals("Parameter " + i, expectedSolution[i], solution[i], error); } // Check that each entry of the computed covariance matrix is within 10% // of the reference matrix entry. for (int i = 0; i < numParams; i++) { for (int j = 0; j < numParams; j++) { Assert.assertEquals("Covariance matrix [" + i + "][" + j + "]", expectedCovarMatrix[i][j], covarMatrix[i][j], FastMath.abs(0.1 * expectedCovarMatrix[i][j])); } } } @Test public void testCircleFitting2() { final double xCenter = 123.456; final double yCenter = 654.321; final double xSigma = 10; final double ySigma = 15; final double radius = 111.111; // The test is extremely sensitive to the seed. final long seed = 59421061L; final RandomCirclePointGenerator factory = new RandomCirclePointGenerator(xCenter, yCenter, radius, xSigma, ySigma, seed); final CircleProblem circle = new CircleProblem(xSigma, ySigma); final int numPoints = 10; for (Vector2D p : factory.generate(numPoints)) { circle.addPoint(p); // System.out.println(p.x + " " + p.y); } // First guess for the center's coordinates and radius. final double[] init = { 90, 659, 115 }; final LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer(); final PointVectorValuePair optimum = optimizer.optimize(100, circle, circle.target(), circle.weight(), init); final double[] paramFound = optimum.getPoint(); // Retrieve errors estimation. final double[][] covMatrix = optimizer.computeCovariances(paramFound, 1e-14); final double[] asymptoticStandardErrorFound = optimizer.guessParametersErrors(); final double[] sigmaFound = new double[covMatrix.length]; for (int i = 0; i < covMatrix.length; i++) { sigmaFound[i] = FastMath.sqrt(covMatrix[i][i]); // System.out.println("i=" + i + " value=" + paramFound[i] // + " sigma=" + sigmaFound[i] // + " ase=" + asymptoticStandardErrorFound[i]); } // System.out.println("chi2=" + optimizer.getChiSquare()); // Check that the parameters are found within the assumed error bars. Assert.assertEquals(xCenter, paramFound[0], asymptoticStandardErrorFound[0]); Assert.assertEquals(yCenter, paramFound[1], asymptoticStandardErrorFound[1]); Assert.assertEquals(radius, paramFound[2], asymptoticStandardErrorFound[2]); } private static class QuadraticProblem implements MultivariateDifferentiableVectorFunction, Serializable { private static final long serialVersionUID = 7072187082052755854L; private List<Double> x; private List<Double> y; public QuadraticProblem() { x = new ArrayList<Double>(); y = new ArrayList<Double>(); } public void addPoint(double x, double y) { this.x.add(x); this.y.add(y); } public double[] value(double[] variables) { double[] values = new double[x.size()]; for (int i = 0; i < values.length; ++i) { values[i] = (variables[0] * x.get(i) + variables[1]) * x.get(i) + variables[2]; } return values; } public DerivativeStructure[] value(DerivativeStructure[] variables) { DerivativeStructure[] values = new DerivativeStructure[x.size()]; for (int i = 0; i < values.length; ++i) { values[i] = (variables[0].multiply(x.get(i)).add(variables[1])).multiply(x.get(i)).add(variables[2]); } return values; } } private static class BevingtonProblem implements MultivariateDifferentiableVectorFunction { private List<Double> time; private List<Double> count; public BevingtonProblem() { time = new ArrayList<Double>(); count = new ArrayList<Double>(); } public void addPoint(double t, double c) { time.add(t); count.add(c); } public double[] value(double[] params) { double[] values = new double[time.size()]; for (int i = 0; i < values.length; ++i) { final double t = time.get(i); values[i] = params[0] + params[1] * Math.exp(-t / params[3]) + params[2] * Math.exp(-t / params[4]); } return values; } public DerivativeStructure[] value(DerivativeStructure[] params) { DerivativeStructure[] values = new DerivativeStructure[time.size()]; for (int i = 0; i < values.length; ++i) { final double t = time.get(i); values[i] = params[0].add( params[1].multiply(params[3].reciprocal().multiply(-t).exp())).add( params[2].multiply(params[4].reciprocal().multiply(-t).exp())); } return values; } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optimization.general; import java.io.Serializable; import java.util.Arrays; import org.apache.commons.math3.exception.TooManyEvaluationsException; import org.apache.commons.math3.analysis.differentiation.DerivativeStructure; import org.apache.commons.math3.analysis.differentiation.MultivariateDifferentiableVectorFunction; import org.apache.commons.math3.optimization.PointVectorValuePair; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files. * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> * Minpack Copyright Notice (1999) University of Chicago. * All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> * <li>Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above * copyright notice, this list of conditions and the following * disclaimer in the documentation and/or other materials provided * with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, * must include the following acknowledgment: * <code>This product includes software developed by the University of * Chicago, as Operator of Argonne National Laboratory.</code> * Alternately, this acknowledgment may appear in the software itself, * if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" * WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE * UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND * THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE * OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY * OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR * USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF * THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) * DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION * UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL * BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT * HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF * ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, * INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF * ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF * PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER * SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT * (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, * EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE * POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */ public class MinpackTest { @Test public void testMinpackLinearFullRank() { minpackTest(new LinearFullRankFunction(10, 5, 1.0, 5.0, 2.23606797749979), false); minpackTest(new LinearFullRankFunction(50, 5, 1.0, 8.06225774829855, 6.70820393249937), false); } @Test public void testMinpackLinearRank1() { minpackTest(new LinearRank1Function(10, 5, 1.0, 291.521868819476, 1.4638501094228), false); minpackTest(new LinearRank1Function(50, 5, 1.0, 3101.60039334535, 3.48263016573496), false); } @Test public void testMinpackLinearRank1ZeroColsAndRows() { minpackTest(new LinearRank1ZeroColsAndRowsFunction(10, 5, 1.0), false); minpackTest(new LinearRank1ZeroColsAndRowsFunction(50, 5, 1.0), false); } @Test public void testMinpackRosenbrok() { minpackTest(new RosenbrockFunction(new double[] { -1.2, 1.0 }, FastMath.sqrt(24.2)), false); minpackTest(new RosenbrockFunction(new double[] { -12.0, 10.0 }, FastMath.sqrt(1795769.0)), false); minpackTest(new RosenbrockFunction(new double[] { -120.0, 100.0 }, 11.0 * FastMath.sqrt(169000121.0)), false); } @Test public void testMinpackHelicalValley() { minpackTest(new HelicalValleyFunction(new double[] { -1.0, 0.0, 0.0 }, 50.0), false); minpackTest(new HelicalValleyFunction(new double[] { -10.0, 0.0, 0.0 }, 102.95630140987), false); minpackTest(new HelicalValleyFunction(new double[] { -100.0, 0.0, 0.0}, 991.261822123701), false); } @Test public void testMinpackPowellSingular() { minpackTest(new PowellSingularFunction(new double[] { 3.0, -1.0, 0.0, 1.0 }, 14.6628782986152), false); minpackTest(new PowellSingularFunction(new double[] { 30.0, -10.0, 0.0, 10.0 }, 1270.9838708654), false); minpackTest(new PowellSingularFunction(new double[] { 300.0, -100.0, 0.0, 100.0 }, 126887.903284750), false); } @Test public void testMinpackFreudensteinRoth() { minpackTest(new FreudensteinRothFunction(new double[] { 0.5, -2.0 }, 20.0124960961895, 6.99887517584575, new double[] { 11.4124844654993, -0.896827913731509 }), false); minpackTest(new FreudensteinRothFunction(new double[] { 5.0, -20.0 }, 12432.833948863, 6.9988751744895, new double[] { 11.41300466147456, -0.896796038685959 }), false); minpackTest(new FreudensteinRothFunction(new double[] { 50.0, -200.0 }, 11426454.595762, 6.99887517242903, new double[] { 11.412781785788564, -0.8968051074920405 }), false); } @Test public void testMinpackBard() { minpackTest(new BardFunction(1.0, 6.45613629515967, 0.0906359603390466, new double[] { 0.0824105765758334, 1.1330366534715, 2.34369463894115 }), false); minpackTest(new BardFunction(10.0, 36.1418531596785, 4.17476870138539, new double[] { 0.840666673818329, -158848033.259565, -164378671.653535 }), false); minpackTest(new BardFunction(100.0, 384.114678637399, 4.17476870135969, new double[] { 0.840666673867645, -158946167.205518, -164464906.857771 }), false); } @Test public void testMinpackKowalikOsborne() { minpackTest(new KowalikOsborneFunction(new double[] { 0.25, 0.39, 0.415, 0.39 }, 0.0728915102882945, 0.017535837721129, new double[] { 0.192807810476249, 0.191262653354071, 0.123052801046931, 0.136053221150517 }), false); minpackTest(new KowalikOsborneFunction(new double[] { 2.5, 3.9, 4.15, 3.9 }, 2.97937007555202, 0.032052192917937, new double[] { 728675.473768287, -14.0758803129393, -32977797.7841797, -20571594.1977912 }), false); minpackTest(new KowalikOsborneFunction(new double[] { 25.0, 39.0, 41.5, 39.0 }, 29.9590617016037, 0.0175364017658228, new double[] { 0.192948328597594, 0.188053165007911, 0.122430604321144, 0.134575665392506 }), false); } @Test public void testMinpackMeyer() { minpackTest(new MeyerFunction(new double[] { 0.02, 4000.0, 250.0 }, 41153.4665543031, 9.37794514651874, new double[] { 0.00560963647102661, 6181.34634628659, 345.223634624144 }), false); minpackTest(new MeyerFunction(new double[] { 0.2, 40000.0, 2500.0 }, 4168216.89130846, 792.917871779501, new double[] { 1.42367074157994e-11, 33695.7133432541, 901.268527953801 }), true); } @Test public void testMinpackWatson() { minpackTest(new WatsonFunction(6, 0.0, 5.47722557505166, 0.0478295939097601, new double[] { -0.0157249615083782, 1.01243488232965, -0.232991722387673, 1.26043101102818, -1.51373031394421, 0.99299727291842 }), false); minpackTest(new WatsonFunction(6, 10.0, 6433.12578950026, 0.0478295939096951, new double[] { -0.0157251901386677, 1.01243485860105, -0.232991545843829, 1.26042932089163, -1.51372776706575, 0.99299573426328 }), false); minpackTest(new WatsonFunction(6, 100.0, 674256.040605213, 0.047829593911544, new double[] { -0.0157247019712586, 1.01243490925658, -0.232991922761641, 1.26043292929555, -1.51373320452707, 0.99299901922322 }), false); minpackTest(new WatsonFunction(9, 0.0, 5.47722557505166, 0.00118311459212420, new double[] { -0.153070644166722e-4, 0.999789703934597, 0.0147639634910978, 0.146342330145992, 1.00082109454817, -2.61773112070507, 4.10440313943354, -3.14361226236241, 1.05262640378759 }), false); minpackTest(new WatsonFunction(9, 10.0, 12088.127069307, 0.00118311459212513, new double[] { -0.153071334849279e-4, 0.999789703941234, 0.0147639629786217, 0.146342334818836, 1.00082107321386, -2.61773107084722, 4.10440307655564, -3.14361222178686, 1.05262639322589 }), false); minpackTest(new WatsonFunction(9, 100.0, 1269109.29043834, 0.00118311459212384, new double[] { -0.153069523352176e-4, 0.999789703958371, 0.0147639625185392, 0.146342341096326, 1.00082104729164, -2.61773101573645, 4.10440301427286, -3.14361218602503, 1.05262638516774 }), false); minpackTest(new WatsonFunction(12, 0.0, 5.47722557505166, 0.217310402535861e-4, new double[] { -0.660266001396382e-8, 1.00000164411833, -0.000563932146980154, 0.347820540050756, -0.156731500244233, 1.05281515825593, -3.24727109519451, 7.2884347837505, -10.271848098614, 9.07411353715783, -4.54137541918194, 1.01201187975044 }), false); minpackTest(new WatsonFunction(12, 10.0, 19220.7589790951, 0.217310402518509e-4, new double[] { -0.663710223017410e-8, 1.00000164411787, -0.000563932208347327, 0.347820540486998, -0.156731503955652, 1.05281517654573, -3.2472711515214, 7.28843489430665, -10.2718482369638, 9.07411364383733, -4.54137546533666, 1.01201188830857 }), false); minpackTest(new WatsonFunction(12, 100.0, 2018918.04462367, 0.217310402539845e-4, new double[] { -0.663806046485249e-8, 1.00000164411786, -0.000563932210324959, 0.347820540503588, -0.156731504091375, 1.05281517718031, -3.24727115337025, 7.28843489775302, -10.2718482410813, 9.07411364688464, -4.54137546660822, 1.0120118885369 }), false); } @Test public void testMinpackBox3Dimensional() { minpackTest(new Box3DimensionalFunction(10, new double[] { 0.0, 10.0, 20.0 }, 32.1115837449572), false); } @Test public void testMinpackJennrichSampson() { minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 }, 64.5856498144943, 11.1517793413499, new double[] { // 0.2578330049, 0.257829976764542 0.2578199266368004, 0.25782997676455244 }), false); } @Test public void testMinpackBrownDennis() { minpackTest(new BrownDennisFunction(20, new double[] { 25.0, 5.0, -5.0, -1.0 }, 2815.43839161816, 292.954288244866, new double[] { -11.59125141003, 13.2024883984741, -0.403574643314272, 0.236736269844604 }), false); minpackTest(new BrownDennisFunction(20, new double[] { 250.0, 50.0, -50.0, -10.0 }, 555073.354173069, 292.954270581415, new double[] { -11.5959274272203, 13.2041866926242, -0.403417362841545, 0.236771143410386 }), false); minpackTest(new BrownDennisFunction(20, new double[] { 2500.0, 500.0, -500.0, -100.0 }, 61211252.2338581, 292.954306151134, new double[] { -11.5902596937374, 13.2020628854665, -0.403688070279258, 0.236665033746463 }), false); } @Test public void testMinpackChebyquad() { minpackTest(new ChebyquadFunction(1, 8, 1.0, 1.88623796907732, 1.88623796907732, new double[] { 0.5 }), false); minpackTest(new ChebyquadFunction(1, 8, 10.0, 5383344372.34005, 1.88424820499951, new double[] { 0.9817314924684 }), false); minpackTest(new ChebyquadFunction(1, 8, 100.0, 0.118088726698392e19, 1.88424820499347, new double[] { 0.9817314852934 }), false); minpackTest(new ChebyquadFunction(8, 8, 1.0, 0.196513862833975, 0.0593032355046727, new double[] { 0.0431536648587336, 0.193091637843267, 0.266328593812698, 0.499999334628884, 0.500000665371116, 0.733671406187302, 0.806908362156733, 0.956846335141266 }), false); minpackTest(new ChebyquadFunction(9, 9, 1.0, 0.16994993465202, 0.0, new double[] { 0.0442053461357828, 0.199490672309881, 0.23561910847106, 0.416046907892598, 0.5, 0.583953092107402, 0.764380891528940, 0.800509327690119, 0.955794653864217 }), false); minpackTest(new ChebyquadFunction(10, 10, 1.0, 0.183747831178711, 0.0806471004038253, new double[] { 0.0596202671753563, 0.166708783805937, 0.239171018813509, 0.398885290346268, 0.398883667870681, 0.601116332129320, 0.60111470965373, 0.760828981186491, 0.833291216194063, 0.940379732824644 }), false); } @Test public void testMinpackBrownAlmostLinear() { minpackTest(new BrownAlmostLinearFunction(10, 0.5, 16.5302162063499, 0.0, new double[] { 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 1.20569696650138 }), false); minpackTest(new BrownAlmostLinearFunction(10, 5.0, 9765624.00089211, 0.0, new double[] { 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 1.20569696650135 }), false); minpackTest(new BrownAlmostLinearFunction(10, 50.0, 0.9765625e17, 0.0, new double[] { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 }), false); minpackTest(new BrownAlmostLinearFunction(30, 0.5, 83.476044467848, 0.0, new double[] { 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 1.06737350671578 }), false); minpackTest(new BrownAlmostLinearFunction(40, 0.5, 128.026364472323, 0.0, new double[] { 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 0.999999999999121 }), false); } @Test public void testMinpackOsborne1() { minpackTest(new Osborne1Function(new double[] { 0.5, 1.5, -1.0, 0.01, 0.02, }, 0.937564021037838, 0.00739249260904843, new double[] { 0.375410049244025, 1.93584654543108, -1.46468676748716, 0.0128675339110439, 0.0221227011813076 }), false); } @Test public void testMinpackOsborne2() { minpackTest(new Osborne2Function(new double[] { 1.3, 0.65, 0.65, 0.7, 0.6, 3.0, 5.0, 7.0, 2.0, 4.5, 5.5 }, 1.44686540984712, 0.20034404483314, new double[] { 1.30997663810096, 0.43155248076, 0.633661261602859, 0.599428560991695, 0.754179768272449, 0.904300082378518, 1.36579949521007, 4.82373199748107, 2.39868475104871, 4.56887554791452, 5.67534206273052 }), false); } private void minpackTest(MinpackFunction function, boolean exceptionExpected) { LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer(FastMath.sqrt(2.22044604926e-16), FastMath.sqrt(2.22044604926e-16), 2.22044604926e-16); // Assert.assertTrue(function.checkTheoreticalStartCost(optimizer.getRMS())); try { PointVectorValuePair optimum = optimizer.optimize(400 * (function.getN() + 1), function, function.getTarget(), function.getWeight(), function.getStartPoint()); Assert.assertFalse(exceptionExpected); function.checkTheoreticalMinCost(optimizer.getRMS()); function.checkTheoreticalMinParams(optimum); } catch (TooManyEvaluationsException e) { Assert.assertTrue(exceptionExpected); } } private static abstract class MinpackFunction implements MultivariateDifferentiableVectorFunction, Serializable { private static final long serialVersionUID = -6209760235478794233L; protected int n; protected int m; protected double[] startParams; protected double theoreticalMinCost; protected double[] theoreticalMinParams; protected double costAccuracy; protected double paramsAccuracy; protected MinpackFunction(int m, double[] startParams, double theoreticalMinCost, double[] theoreticalMinParams) { this.m = m; this.n = startParams.length; this.startParams = startParams.clone(); this.theoreticalMinCost = theoreticalMinCost; this.theoreticalMinParams = theoreticalMinParams; this.costAccuracy = 1.0e-8; this.paramsAccuracy = 1.0e-5; } protected static double[] buildArray(int n, double x) { double[] array = new double[n]; Arrays.fill(array, x); return array; } public double[] getTarget() { return buildArray(m, 0.0); } public double[] getWeight() { return buildArray(m, 1.0); } public double[] getStartPoint() { return startParams.clone(); } protected void setCostAccuracy(double costAccuracy) { this.costAccuracy = costAccuracy; } protected void setParamsAccuracy(double paramsAccuracy) { this.paramsAccuracy = paramsAccuracy; } public int getN() { return startParams.length; } public void checkTheoreticalMinCost(double rms) { double threshold = costAccuracy * (1.0 + theoreticalMinCost); Assert.assertEquals(theoreticalMinCost, FastMath.sqrt(m) * rms, threshold); } public void checkTheoreticalMinParams(PointVectorValuePair optimum) { double[] params = optimum.getPointRef(); if (theoreticalMinParams != null) { for (int i = 0; i < theoreticalMinParams.length; ++i) { double mi = theoreticalMinParams[i]; double vi = params[i]; Assert.assertEquals(mi, vi, paramsAccuracy * (1.0 + FastMath.abs(mi))); } } } public double[] value(double[] variables) { DerivativeStructure[] dsV = new DerivativeStructure[variables.length]; for (int i = 0; i < variables.length; ++i) { dsV[i] = new DerivativeStructure(0, 0, variables[i]); } DerivativeStructure[] dsY = value(dsV); double[] y = new double[dsY.length]; for (int i = 0; i < dsY.length; ++i) { y[i] = dsY[i].getValue(); } return y; } public abstract DerivativeStructure[] value(DerivativeStructure[] variables); } private static class LinearFullRankFunction extends MinpackFunction { private static final long serialVersionUID = -9030323226268039536L; public LinearFullRankFunction(int m, int n, double x0, double theoreticalStartCost, double theoreticalMinCost) { super(m, buildArray(n, x0), theoreticalMinCost, buildArray(n, -1.0)); } @Override public DerivativeStructure[] value(DerivativeStructure[] variables) { DerivativeStructure sum = variables[0].getField().getZero(); for (int i = 0; i < n; ++i) { sum = sum.add(variables[i]); } DerivativeStructure t = sum.multiply(2.0 / m).add(1); DerivativeStructure[] f = new DerivativeStructure[m]; for (int i = 0; i < n; ++i) { f[i] = variables[i].subtract(t); } Arrays.fill(f, n, m, t.negate()); return f; } } private static class LinearRank1Function extends MinpackFunction { private static final long serialVersionUID = 8494863245104608300L; public LinearRank1Function(int m, int n, double x0, double theoreticalStartCost, double theoreticalMinCost) { super(m, buildArray(n, x0), theoreticalMinCost, null); } @Override public DerivativeStructure[] value(DerivativeStructure[] variables) { DerivativeStructure[] f = new DerivativeStructure[m]; DerivativeStructure sum = variables[0].getField().getZero(); for (int i = 0; i < n; ++i) { sum = sum.add(variables[i].multiply(i + 1)); } for (int i = 0; i < m; ++i) { f[i] = sum.multiply(i + 1).subtract(1); } return f; } } private static class LinearRank1ZeroColsAndRowsFunction extends MinpackFunction { private static final long serialVersionUID = -3316653043091995018L; public LinearRank1ZeroColsAndRowsFunction(int m, int n, double x0) { super(m, buildArray(n, x0), FastMath.sqrt((m * (m + 3) - 6) / (2.0 * (2 * m - 3))), null); } @Override public DerivativeStructure[] value(DerivativeStructure[] variables) { DerivativeStructure[] f = new DerivativeStructure[m]; DerivativeStructure sum = variables[0].getField().getZero(); for (int i = 1; i < (n - 1); ++i) { sum = sum.add(variables[i].multiply(i + 1)); } for (int i = 0; i < (m - 1); ++i) { f[i] = sum.multiply(i).subtract(1); } f[m - 1] = variables[0].getField().getOne().negate(); return f; } } private static class RosenbrockFunction extends MinpackFunction { private static final long serialVersionUID = 2893438180956569134L; public RosenbrockFunction(double[] startParams, double theoreticalStartCost) { super(2, startParams, 0.0, buildArray(2, 1.0)); } @Override public DerivativeStructure[] value(DerivativeStructure[] variables) { DerivativeStructure x1 = variables[0]; DerivativeStructure x2 = variables[1]; return new DerivativeStructure[] { x2.subtract(x1.multiply(x1)).multiply(10), x1.negate().add(1) }; } } private static class HelicalValleyFunction extends MinpackFunction { private static final long serialVersionUID = 220613787843200102L; public HelicalValleyFunction(double[] startParams, double theoreticalStartCost) { super(3, startParams, 0.0, new double[] { 1.0, 0.0, 0.0 }); } @Override public DerivativeStructure[] value(DerivativeStructure[] variables) { DerivativeStructure x1 = variables[0]; DerivativeStructure x2 = variables[1]; DerivativeStructure x3 = variables[2]; DerivativeStructure tmp1 = variables[0].getField().getZero(); if (x1.getValue() == 0) { tmp1 = tmp1.add((x2.getValue() >= 0) ? 0.25 : -0.25); } else { tmp1 = x2.divide(x1).atan().divide(twoPi); if (x1.getValue() < 0) { tmp1 = tmp1.add(0.5); } } DerivativeStructure tmp2 = x1.multiply(x1).add(x2.multiply(x2)).sqrt(); return new DerivativeStructure[] { x3.subtract(tmp1.multiply(10)).multiply(10), tmp2.subtract(1).multiply(10), x3 }; } private static final double twoPi = 2.0 * FastMath.PI; } private static class PowellSingularFunction extends MinpackFunction { private static final long serialVersionUID = 7298364171208142405L; public PowellSingularFunction(double[] startParams, double theoreticalStartCost) { super(4, startParams, 0.0, buildArray(4, 0.0)); } @Override public DerivativeStructure[] value(DerivativeStructure[] variables) { DerivativeStructure x1 = variables[0]; DerivativeStructure x2 = variables[1]; DerivativeStructure x3 = variables[2]; DerivativeStructure x4 = variables[3]; return new DerivativeStructure[] { x1.add(x2.multiply(10)), x3.subtract(x4).multiply(sqrt5), x2.subtract(x3.multiply(2)).multiply(x2.subtract(x3.multiply(2))), x1.subtract(x4).multiply(x1.subtract(x4)).multiply(sqrt10) }; } private static final double sqrt5 = FastMath.sqrt( 5.0); private static final double sqrt10 = FastMath.sqrt(10.0); } private static class FreudensteinRothFunction extends MinpackFunction { private static final long serialVersionUID = 2892404999344244214L; public FreudensteinRothFunction(double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(2, startParams, theoreticalMinCost, theoreticalMinParams); } @Override public DerivativeStructure[] value(DerivativeStructure[] variables) { DerivativeStructure x1 = variables[0]; DerivativeStructure x2 = variables[1]; return new DerivativeStructure[] { x1.subtract(13.0).add(x2.negate().add(5.0).multiply(x2).subtract(2).multiply(x2)), x1.subtract(29.0).add(x2.add(1).multiply(x2).subtract(14).multiply(x2)) }; } } private static class BardFunction extends MinpackFunction { private static final long serialVersionUID = 5990442612572087668L; public BardFunction(double x0, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(15, buildArray(3, x0), theoreticalMinCost, theoreticalMinParams); } @Override public DerivativeStructure[] value(DerivativeStructure[] variables) { DerivativeStructure x1 = variables[0]; DerivativeStructure x2 = variables[1]; DerivativeStructure x3 = variables[2]; DerivativeStructure[] f = new DerivativeStructure[m]; for (int i = 0; i < m; ++i) { double tmp1 = i + 1; double tmp2 = 15 - i; double tmp3 = (i <= 7) ? tmp1 : tmp2; f[i] = x1.add(x2.multiply(tmp2).add(x3.multiply(tmp3)).reciprocal().multiply(tmp1)).negate().add(y[i]); } return f; } private static final double[] y = { 0.14, 0.18, 0.22, 0.25, 0.29, 0.32, 0.35, 0.39, 0.37, 0.58, 0.73, 0.96, 1.34, 2.10, 4.39 }; } private static class KowalikOsborneFunction extends MinpackFunction { private static final long serialVersionUID = -4867445739880495801L; public KowalikOsborneFunction(double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(11, startParams, theoreticalMinCost, theoreticalMinParams); if (theoreticalStartCost > 20.0) { setCostAccuracy(2.0e-4); setParamsAccuracy(5.0e-3); } } @Override public DerivativeStructure[] value(DerivativeStructure[] variables) { DerivativeStructure x1 = variables[0]; DerivativeStructure x2 = variables[1]; DerivativeStructure x3 = variables[2]; DerivativeStructure x4 = variables[3]; DerivativeStructure[] f = new DerivativeStructure[m]; for (int i = 0; i < m; ++i) { f[i] = x1.multiply(x2.add(v[i]).multiply(v[i])).divide(x4.add(x3.add(v[i]).multiply(v[i]))).negate().add(y[i]); } return f; } private static final double[] v = { 4.0, 2.0, 1.0, 0.5, 0.25, 0.167, 0.125, 0.1, 0.0833, 0.0714, 0.0625 }; private static final double[] y = { 0.1957, 0.1947, 0.1735, 0.1600, 0.0844, 0.0627, 0.0456, 0.0342, 0.0323, 0.0235, 0.0246 }; } private static class MeyerFunction extends MinpackFunction { private static final long serialVersionUID = -838060619150131027L; public MeyerFunction(double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(16, startParams, theoreticalMinCost, theoreticalMinParams); if (theoreticalStartCost > 1.0e6) { setCostAccuracy(7.0e-3); setParamsAccuracy(2.0e-2); } } @Override public DerivativeStructure[] value(DerivativeStructure[] variables) { DerivativeStructure x1 = variables[0]; DerivativeStructure x2 = variables[1]; DerivativeStructure x3 = variables[2]; DerivativeStructure[] f = new DerivativeStructure[m]; for (int i = 0; i < m; ++i) { f[i] = x1.multiply(x2.divide(x3.add(5.0 * (i + 1) + 45.0)).exp()).subtract(y[i]); } return f; } private static final double[] y = { 34780.0, 28610.0, 23650.0, 19630.0, 16370.0, 13720.0, 11540.0, 9744.0, 8261.0, 7030.0, 6005.0, 5147.0, 4427.0, 3820.0, 3307.0, 2872.0 }; } private static class WatsonFunction extends MinpackFunction { private static final long serialVersionUID = -9034759294980218927L; public WatsonFunction(int n, double x0, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(31, buildArray(n, x0), theoreticalMinCost, theoreticalMinParams); } @Override public DerivativeStructure[] value(DerivativeStructure[] variables) { DerivativeStructure[] f = new DerivativeStructure[m]; for (int i = 0; i < (m - 2); ++i) { double div = (i + 1) / 29.0; DerivativeStructure s1 = variables[0].getField().getZero(); DerivativeStructure dx = variables[0].getField().getOne(); for (int j = 1; j < n; ++j) { s1 = s1.add(dx.multiply(j).multiply(variables[j])); dx = dx.multiply(div); } DerivativeStructure s2 = variables[0].getField().getZero(); dx = variables[0].getField().getOne(); for (int j = 0; j < n; ++j) { s2 = s2.add(dx.multiply(variables[j])); dx = dx.multiply(div); } f[i] = s1.subtract(s2.multiply(s2)).subtract(1); } DerivativeStructure x1 = variables[0]; DerivativeStructure x2 = variables[1]; f[m - 2] = x1; f[m - 1] = x2.subtract(x1.multiply(x1)).subtract(1); return f; } } private static class Box3DimensionalFunction extends MinpackFunction { private static final long serialVersionUID = 5511403858142574493L; public Box3DimensionalFunction(int m, double[] startParams, double theoreticalStartCost) { super(m, startParams, 0.0, new double[] { 1.0, 10.0, 1.0 }); } @Override public DerivativeStructure[] value(DerivativeStructure[] variables) { DerivativeStructure x1 = variables[0]; DerivativeStructure x2 = variables[1]; DerivativeStructure x3 = variables[2]; DerivativeStructure[] f = new DerivativeStructure[m]; for (int i = 0; i < m; ++i) { double tmp = (i + 1) / 10.0; f[i] = x1.multiply(-tmp).exp().subtract(x2.multiply(-tmp).exp()).add( x3.multiply(FastMath.exp(-i - 1) - FastMath.exp(-tmp))); } return f; } } private static class JennrichSampsonFunction extends MinpackFunction { private static final long serialVersionUID = -2489165190443352947L; public JennrichSampsonFunction(int m, double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(m, startParams, theoreticalMinCost, theoreticalMinParams); } @Override public DerivativeStructure[] value(DerivativeStructure[] variables) { DerivativeStructure x1 = variables[0]; DerivativeStructure x2 = variables[1]; DerivativeStructure[] f = new DerivativeStructure[m]; for (int i = 0; i < m; ++i) { double temp = i + 1; f[i] = x1.multiply(temp).exp().add(x2.multiply(temp).exp()).subtract(2 + 2 * temp).negate(); } return f; } } private static class BrownDennisFunction extends MinpackFunction { private static final long serialVersionUID = 8340018645694243910L; public BrownDennisFunction(int m, double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(m, startParams, theoreticalMinCost, theoreticalMinParams); setCostAccuracy(2.5e-8); } @Override public DerivativeStructure[] value(DerivativeStructure[] variables) { DerivativeStructure x1 = variables[0]; DerivativeStructure x2 = variables[1]; DerivativeStructure x3 = variables[2]; DerivativeStructure x4 = variables[3]; DerivativeStructure[] f = new DerivativeStructure[m]; for (int i = 0; i < m; ++i) { double temp = (i + 1) / 5.0; DerivativeStructure tmp1 = x1.add(x2.multiply(temp)).subtract(FastMath.exp(temp)); DerivativeStructure tmp2 = x3.add(x4.multiply(FastMath.sin(temp))).subtract(FastMath.cos(temp)); f[i] = tmp1.multiply(tmp1).add(tmp2.multiply(tmp2)); } return f; } } private static class ChebyquadFunction extends MinpackFunction { private static final long serialVersionUID = -2394877275028008594L; private static double[] buildChebyquadArray(int n, double factor) { double[] array = new double[n]; double inv = factor / (n + 1); for (int i = 0; i < n; ++i) { array[i] = (i + 1) * inv; } return array; } public ChebyquadFunction(int n, int m, double factor, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(m, buildChebyquadArray(n, factor), theoreticalMinCost, theoreticalMinParams); } @Override public DerivativeStructure[] value(DerivativeStructure[] variables) { DerivativeStructure[] f = new DerivativeStructure[m]; Arrays.fill(f, variables[0].getField().getZero()); for (int j = 0; j < n; ++j) { DerivativeStructure tmp1 = variables[0].getField().getOne(); DerivativeStructure tmp2 = variables[j].multiply(2).subtract(1); DerivativeStructure temp = tmp2.multiply(2); for (int i = 0; i < m; ++i) { f[i] = f[i].add(tmp2); DerivativeStructure ti = temp.multiply(tmp2).subtract(tmp1); tmp1 = tmp2; tmp2 = ti; } } double dx = 1.0 / n; boolean iev = false; for (int i = 0; i < m; ++i) { f[i] = f[i].multiply(dx); if (iev) { f[i] = f[i].add(1.0 / (i * (i + 2))); } iev = ! iev; } return f; } } private static class BrownAlmostLinearFunction extends MinpackFunction { private static final long serialVersionUID = 8239594490466964725L; public BrownAlmostLinearFunction(int m, double factor, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(m, buildArray(m, factor), theoreticalMinCost, theoreticalMinParams); } @Override public DerivativeStructure[] value(DerivativeStructure[] variables) { DerivativeStructure[] f = new DerivativeStructure[m]; DerivativeStructure sum = variables[0].getField().getZero().subtract(n + 1); DerivativeStructure prod = variables[0].getField().getOne(); for (int j = 0; j < n; ++j) { sum = sum.add(variables[j]); prod = prod.multiply(variables[j]); } for (int i = 0; i < n; ++i) { f[i] = variables[i].add(sum); } f[n - 1] = prod.subtract(1); return f; } } private static class Osborne1Function extends MinpackFunction { private static final long serialVersionUID = 4006743521149849494L; public Osborne1Function(double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(33, startParams, theoreticalMinCost, theoreticalMinParams); } @Override public DerivativeStructure[] value(DerivativeStructure[] variables) { DerivativeStructure x1 = variables[0]; DerivativeStructure x2 = variables[1]; DerivativeStructure x3 = variables[2]; DerivativeStructure x4 = variables[3]; DerivativeStructure x5 = variables[4]; DerivativeStructure[] f = new DerivativeStructure[m]; for (int i = 0; i < m; ++i) { double temp = 10.0 * i; DerivativeStructure tmp1 = x4.multiply(-temp).exp(); DerivativeStructure tmp2 = x5.multiply(-temp).exp(); f[i] = x1.add(x2.multiply(tmp1)).add(x3.multiply(tmp2)).negate().add(y[i]); } return f; } private static final double[] y = { 0.844, 0.908, 0.932, 0.936, 0.925, 0.908, 0.881, 0.850, 0.818, 0.784, 0.751, 0.718, 0.685, 0.658, 0.628, 0.603, 0.580, 0.558, 0.538, 0.522, 0.506, 0.490, 0.478, 0.467, 0.457, 0.448, 0.438, 0.431, 0.424, 0.420, 0.414, 0.411, 0.406 }; } private static class Osborne2Function extends MinpackFunction { private static final long serialVersionUID = -8418268780389858746L; public Osborne2Function(double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(65, startParams, theoreticalMinCost, theoreticalMinParams); } @Override public DerivativeStructure[] value(DerivativeStructure[] variables) { DerivativeStructure x01 = variables[0]; DerivativeStructure x02 = variables[1]; DerivativeStructure x03 = variables[2]; DerivativeStructure x04 = variables[3]; DerivativeStructure x05 = variables[4]; DerivativeStructure x06 = variables[5]; DerivativeStructure x07 = variables[6]; DerivativeStructure x08 = variables[7]; DerivativeStructure x09 = variables[8]; DerivativeStructure x10 = variables[9]; DerivativeStructure x11 = variables[10]; DerivativeStructure[] f = new DerivativeStructure[m]; for (int i = 0; i < m; ++i) { double temp = i / 10.0; DerivativeStructure tmp1 = x05.multiply(-temp).exp(); DerivativeStructure tmp2 = x06.negate().multiply(x09.subtract(temp).multiply(x09.subtract(temp))).exp(); DerivativeStructure tmp3 = x07.negate().multiply(x10.subtract(temp).multiply(x10.subtract(temp))).exp(); DerivativeStructure tmp4 = x08.negate().multiply(x11.subtract(temp).multiply(x11.subtract(temp))).exp(); f[i] = x01.multiply(tmp1).add(x02.multiply(tmp2)).add(x03.multiply(tmp3)).add(x04.multiply(tmp4)).negate().add(y[i]); } return f; } private static final double[] y = { 1.366, 1.191, 1.112, 1.013, 0.991, 0.885, 0.831, 0.847, 0.786, 0.725, 0.746, 0.679, 0.608, 0.655, 0.616, 0.606, 0.602, 0.626, 0.651, 0.724, 0.649, 0.649, 0.694, 0.644, 0.624, 0.661, 0.612, 0.558, 0.533, 0.495, 0.500, 0.423, 0.395, 0.375, 0.372, 0.391, 0.396, 0.405, 0.428, 0.429, 0.523, 0.562, 0.607, 0.653, 0.672, 0.708, 0.633, 0.668, 0.645, 0.632, 0.591, 0.559, 0.597, 0.625, 0.739, 0.710, 0.729, 0.720, 0.636, 0.581, 0.428, 0.292, 0.162, 0.098, 0.054 }; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optimization.general; import java.io.Serializable; import org.apache.commons.math3.analysis.differentiation.DerivativeStructure; import org.apache.commons.math3.analysis.differentiation.MultivariateDifferentiableFunction; import org.apache.commons.math3.analysis.solvers.BrentSolver; import org.apache.commons.math3.geometry.euclidean.twod.Vector2D; import org.apache.commons.math3.linear.BlockRealMatrix; import org.apache.commons.math3.linear.RealMatrix; import org.apache.commons.math3.optimization.GoalType; import org.apache.commons.math3.optimization.PointValuePair; import org.apache.commons.math3.optimization.SimpleValueChecker; import org.junit.Assert; import org.junit.Test; /** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files. * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> * Minpack Copyright Notice (1999) University of Chicago. * All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> * <li>Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above * copyright notice, this list of conditions and the following * disclaimer in the documentation and/or other materials provided * with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, * must include the following acknowledgment: * <code>This product includes software developed by the University of * Chicago, as Operator of Argonne National Laboratory.</code> * Alternately, this acknowledgment may appear in the software itself, * if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" * WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE * UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND * THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE * OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY * OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR * USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF * THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) * DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION * UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL * BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT * HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF * ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, * INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF * ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF * PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER * SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT * (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, * EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE * POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */ public class NonLinearConjugateGradientOptimizerTest { @Test public void testTrivial() { LinearProblem problem = new LinearProblem(new double[][] { { 2 } }, new double[] { 3 }); NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); PointValuePair optimum = optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0 }); Assert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10); Assert.assertEquals(0.0, optimum.getValue(), 1.0e-10); } @Test public void testColumnsPermutation() { LinearProblem problem = new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } }, new double[] { 4.0, 6.0, 1.0 }); NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); PointValuePair optimum = optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0 }); Assert.assertEquals(7.0, optimum.getPoint()[0], 1.0e-10); Assert.assertEquals(3.0, optimum.getPoint()[1], 1.0e-10); Assert.assertEquals(0.0, optimum.getValue(), 1.0e-10); } @Test public void testNoDependency() { LinearProblem problem = new LinearProblem(new double[][] { { 2, 0, 0, 0, 0, 0 }, { 0, 2, 0, 0, 0, 0 }, { 0, 0, 2, 0, 0, 0 }, { 0, 0, 0, 2, 0, 0 }, { 0, 0, 0, 0, 2, 0 }, { 0, 0, 0, 0, 0, 2 } }, new double[] { 0.0, 1.1, 2.2, 3.3, 4.4, 5.5 }); NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); PointValuePair optimum = optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0, 0, 0, 0, 0 }); for (int i = 0; i < problem.target.length; ++i) { Assert.assertEquals(0.55 * i, optimum.getPoint()[i], 1.0e-10); } } @Test public void testOneSet() { LinearProblem problem = new LinearProblem(new double[][] { { 1, 0, 0 }, { -1, 1, 0 }, { 0, -1, 1 } }, new double[] { 1, 1, 1}); NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); PointValuePair optimum = optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0, 0 }); Assert.assertEquals(1.0, optimum.getPoint()[0], 1.0e-10); Assert.assertEquals(2.0, optimum.getPoint()[1], 1.0e-10); Assert.assertEquals(3.0, optimum.getPoint()[2], 1.0e-10); } @Test public void testTwoSets() { final double epsilon = 1.0e-7; LinearProblem problem = new LinearProblem(new double[][] { { 2, 1, 0, 4, 0, 0 }, { -4, -2, 3, -7, 0, 0 }, { 4, 1, -2, 8, 0, 0 }, { 0, -3, -12, -1, 0, 0 }, { 0, 0, 0, 0, epsilon, 1 }, { 0, 0, 0, 0, 1, 1 } }, new double[] { 2, -9, 2, 2, 1 + epsilon * epsilon, 2}); final Preconditioner preconditioner = new Preconditioner() { public double[] precondition(double[] point, double[] r) { double[] d = r.clone(); d[0] /= 72.0; d[1] /= 30.0; d[2] /= 314.0; d[3] /= 260.0; d[4] /= 2 * (1 + epsilon * epsilon); d[5] /= 4.0; return d; } }; NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE, new SimpleValueChecker(1e-13, 1e-13), new BrentSolver(), preconditioner); PointValuePair optimum = optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0, 0, 0, 0, 0 }); Assert.assertEquals( 3.0, optimum.getPoint()[0], 1.0e-10); Assert.assertEquals( 4.0, optimum.getPoint()[1], 1.0e-10); Assert.assertEquals(-1.0, optimum.getPoint()[2], 1.0e-10); Assert.assertEquals(-2.0, optimum.getPoint()[3], 1.0e-10); Assert.assertEquals( 1.0 + epsilon, optimum.getPoint()[4], 1.0e-10); Assert.assertEquals( 1.0 - epsilon, optimum.getPoint()[5], 1.0e-10); } @Test public void testNonInversible() { LinearProblem problem = new LinearProblem(new double[][] { { 1, 2, -3 }, { 2, 1, 3 }, { -3, 0, -9 } }, new double[] { 1, 1, 1 }); NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); PointValuePair optimum = optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0, 0 }); Assert.assertTrue(optimum.getValue() > 0.5); } @Test public void testIllConditioned() { LinearProblem problem1 = new LinearProblem(new double[][] { { 10.0, 7.0, 8.0, 7.0 }, { 7.0, 5.0, 6.0, 5.0 }, { 8.0, 6.0, 10.0, 9.0 }, { 7.0, 5.0, 9.0, 10.0 } }, new double[] { 32, 23, 33, 31 }); NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE, new SimpleValueChecker(1e-13, 1e-13), new BrentSolver(1e-15, 1e-15)); PointValuePair optimum1 = optimizer.optimize(200, problem1, GoalType.MINIMIZE, new double[] { 0, 1, 2, 3 }); Assert.assertEquals(1.0, optimum1.getPoint()[0], 1.0e-4); Assert.assertEquals(1.0, optimum1.getPoint()[1], 1.0e-4); Assert.assertEquals(1.0, optimum1.getPoint()[2], 1.0e-4); Assert.assertEquals(1.0, optimum1.getPoint()[3], 1.0e-4); LinearProblem problem2 = new LinearProblem(new double[][] { { 10.00, 7.00, 8.10, 7.20 }, { 7.08, 5.04, 6.00, 5.00 }, { 8.00, 5.98, 9.89, 9.00 }, { 6.99, 4.99, 9.00, 9.98 } }, new double[] { 32, 23, 33, 31 }); PointValuePair optimum2 = optimizer.optimize(200, problem2, GoalType.MINIMIZE, new double[] { 0, 1, 2, 3 }); Assert.assertEquals(-81.0, optimum2.getPoint()[0], 1.0e-1); Assert.assertEquals(137.0, optimum2.getPoint()[1], 1.0e-1); Assert.assertEquals(-34.0, optimum2.getPoint()[2], 1.0e-1); Assert.assertEquals( 22.0, optimum2.getPoint()[3], 1.0e-1); } @Test public void testMoreEstimatedParametersSimple() { LinearProblem problem = new LinearProblem(new double[][] { { 3.0, 2.0, 0.0, 0.0 }, { 0.0, 1.0, -1.0, 1.0 }, { 2.0, 0.0, 1.0, 0.0 } }, new double[] { 7.0, 3.0, 5.0 }); NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); PointValuePair optimum = optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 7, 6, 5, 4 }); Assert.assertEquals(0, optimum.getValue(), 1.0e-10); } @Test public void testMoreEstimatedParametersUnsorted() { LinearProblem problem = new LinearProblem(new double[][] { { 1.0, 1.0, 0.0, 0.0, 0.0, 0.0 }, { 0.0, 0.0, 1.0, 1.0, 1.0, 0.0 }, { 0.0, 0.0, 0.0, 0.0, 1.0, -1.0 }, { 0.0, 0.0, -1.0, 1.0, 0.0, 1.0 }, { 0.0, 0.0, 0.0, -1.0, 1.0, 0.0 } }, new double[] { 3.0, 12.0, -1.0, 7.0, 1.0 }); NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); PointValuePair optimum = optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 2, 2, 2, 2, 2, 2 }); Assert.assertEquals(0, optimum.getValue(), 1.0e-10); } @Test public void testRedundantEquations() { LinearProblem problem = new LinearProblem(new double[][] { { 1.0, 1.0 }, { 1.0, -1.0 }, { 1.0, 3.0 } }, new double[] { 3.0, 1.0, 5.0 }); NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); PointValuePair optimum = optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 1, 1 }); Assert.assertEquals(2.0, optimum.getPoint()[0], 1.0e-8); Assert.assertEquals(1.0, optimum.getPoint()[1], 1.0e-8); } @Test public void testInconsistentEquations() { LinearProblem problem = new LinearProblem(new double[][] { { 1.0, 1.0 }, { 1.0, -1.0 }, { 1.0, 3.0 } }, new double[] { 3.0, 1.0, 4.0 }); NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); PointValuePair optimum = optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 1, 1 }); Assert.assertTrue(optimum.getValue() > 0.1); } @Test public void testCircleFitting() { CircleScalar circle = new CircleScalar(); circle.addPoint( 30.0, 68.0); circle.addPoint( 50.0, -6.0); circle.addPoint(110.0, -20.0); circle.addPoint( 35.0, 15.0); circle.addPoint( 45.0, 97.0); NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE, new SimpleValueChecker(1e-30, 1e-30), new BrentSolver(1e-15, 1e-13)); PointValuePair optimum = optimizer.optimize(100, circle, GoalType.MINIMIZE, new double[] { 98.680, 47.345 }); Vector2D center = new Vector2D(optimum.getPointRef()[0], optimum.getPointRef()[1]); Assert.assertEquals(69.960161753, circle.getRadius(center), 1.0e-8); Assert.assertEquals(96.075902096, center.getX(), 1.0e-8); Assert.assertEquals(48.135167894, center.getY(), 1.0e-8); } private static class LinearProblem implements MultivariateDifferentiableFunction, Serializable { private static final long serialVersionUID = 703247177355019415L; final RealMatrix factors; final double[] target; public LinearProblem(double[][] factors, double[] target) { this.factors = new BlockRealMatrix(factors); this.target = target; } public double value(double[] variables) { double[] y = factors.operate(variables); double sum = 0; for (int i = 0; i < y.length; ++i) { double ri = y[i] - target[i]; sum += ri * ri; } return sum; } public DerivativeStructure value(DerivativeStructure[] variables) { DerivativeStructure[] y = new DerivativeStructure[factors.getRowDimension()]; for (int i = 0; i < y.length; ++i) { y[i] = variables[0].getField().getZero(); for (int j = 0; j < factors.getColumnDimension(); ++j) { y[i] = y[i].add(variables[j].multiply(factors.getEntry(i, j))); } } DerivativeStructure sum = variables[0].getField().getZero(); for (int i = 0; i < y.length; ++i) { DerivativeStructure ri = y[i].subtract(target[i]); sum = sum.add(ri.multiply(ri)); } return sum; } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optimization.linear; import org.junit.Assert; import java.util.ArrayList; import java.util.Collection; import java.util.List; import org.apache.commons.math3.optimization.GoalType; import org.apache.commons.math3.optimization.PointValuePair; import org.apache.commons.math3.util.Precision; import org.junit.Test; public class SimplexSolverTest { @Test public void testMath828() { LinearObjectiveFunction f = new LinearObjectiveFunction( new double[] { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}, 0.0); ArrayList <LinearConstraint>constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] {0.0, 39.0, 23.0, 96.0, 15.0, 48.0, 9.0, 21.0, 48.0, 36.0, 76.0, 19.0, 88.0, 17.0, 16.0, 36.0,}, Relationship.GEQ, 15.0)); constraints.add(new LinearConstraint(new double[] {0.0, 59.0, 93.0, 12.0, 29.0, 78.0, 73.0, 87.0, 32.0, 70.0, 68.0, 24.0, 11.0, 26.0, 65.0, 25.0,}, Relationship.GEQ, 29.0)); constraints.add(new LinearConstraint(new double[] {0.0, 74.0, 5.0, 82.0, 6.0, 97.0, 55.0, 44.0, 52.0, 54.0, 5.0, 93.0, 91.0, 8.0, 20.0, 97.0,}, Relationship.GEQ, 6.0)); constraints.add(new LinearConstraint(new double[] {8.0, -3.0, -28.0, -72.0, -8.0, -31.0, -31.0, -74.0, -47.0, -59.0, -24.0, -57.0, -56.0, -16.0, -92.0, -59.0,}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {25.0, -7.0, -99.0, -78.0, -25.0, -14.0, -16.0, -89.0, -39.0, -56.0, -53.0, -9.0, -18.0, -26.0, -11.0, -61.0,}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {33.0, -95.0, -15.0, -4.0, -33.0, -3.0, -20.0, -96.0, -27.0, -13.0, -80.0, -24.0, -3.0, -13.0, -57.0, -76.0,}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {7.0, -95.0, -39.0, -93.0, -7.0, -94.0, -94.0, -62.0, -76.0, -26.0, -53.0, -57.0, -31.0, -76.0, -53.0, -52.0,}, Relationship.GEQ, 0.0)); double epsilon = 1e-6; PointValuePair solution = new SimplexSolver().optimize(f, constraints, GoalType.MINIMIZE, true); Assert.assertEquals(1.0d, solution.getValue(), epsilon); Assert.assertTrue(validSolution(solution, constraints, epsilon)); } @Test public void testMath828Cycle() { LinearObjectiveFunction f = new LinearObjectiveFunction( new double[] { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}, 0.0); ArrayList <LinearConstraint>constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] {0.0, 16.0, 14.0, 69.0, 1.0, 85.0, 52.0, 43.0, 64.0, 97.0, 14.0, 74.0, 89.0, 28.0, 94.0, 58.0, 13.0, 22.0, 21.0, 17.0, 30.0, 25.0, 1.0, 59.0, 91.0, 78.0, 12.0, 74.0, 56.0, 3.0, 88.0,}, Relationship.GEQ, 91.0)); constraints.add(new LinearConstraint(new double[] {0.0, 60.0, 40.0, 81.0, 71.0, 72.0, 46.0, 45.0, 38.0, 48.0, 40.0, 17.0, 33.0, 85.0, 64.0, 32.0, 84.0, 3.0, 54.0, 44.0, 71.0, 67.0, 90.0, 95.0, 54.0, 99.0, 99.0, 29.0, 52.0, 98.0, 9.0,}, Relationship.GEQ, 54.0)); constraints.add(new LinearConstraint(new double[] {0.0, 41.0, 12.0, 86.0, 90.0, 61.0, 31.0, 41.0, 23.0, 89.0, 17.0, 74.0, 44.0, 27.0, 16.0, 47.0, 80.0, 32.0, 11.0, 56.0, 68.0, 82.0, 11.0, 62.0, 62.0, 53.0, 39.0, 16.0, 48.0, 1.0, 63.0,}, Relationship.GEQ, 62.0)); constraints.add(new LinearConstraint(new double[] {83.0, -76.0, -94.0, -19.0, -15.0, -70.0, -72.0, -57.0, -63.0, -65.0, -22.0, -94.0, -22.0, -88.0, -86.0, -89.0, -72.0, -16.0, -80.0, -49.0, -70.0, -93.0, -95.0, -17.0, -83.0, -97.0, -31.0, -47.0, -31.0, -13.0, -23.0,}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {41.0, -96.0, -41.0, -48.0, -70.0, -43.0, -43.0, -43.0, -97.0, -37.0, -85.0, -70.0, -45.0, -67.0, -87.0, -69.0, -94.0, -54.0, -54.0, -92.0, -79.0, -10.0, -35.0, -20.0, -41.0, -41.0, -65.0, -25.0, -12.0, -8.0, -46.0,}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {27.0, -42.0, -65.0, -49.0, -53.0, -42.0, -17.0, -2.0, -61.0, -31.0, -76.0, -47.0, -8.0, -93.0, -86.0, -62.0, -65.0, -63.0, -22.0, -43.0, -27.0, -23.0, -32.0, -74.0, -27.0, -63.0, -47.0, -78.0, -29.0, -95.0, -73.0,}, Relationship.GEQ, 0.0)); constraints.add(new LinearConstraint(new double[] {15.0, -46.0, -41.0, -83.0, -98.0, -99.0, -21.0, -35.0, -7.0, -14.0, -80.0, -63.0, -18.0, -42.0, -5.0, -34.0, -56.0, -70.0, -16.0, -18.0, -74.0, -61.0, -47.0, -41.0, -15.0, -79.0, -18.0, -47.0, -88.0, -68.0, -55.0,}, Relationship.GEQ, 0.0)); double epsilon = 1e-6; PointValuePair solution = new SimplexSolver().optimize(f, constraints, GoalType.MINIMIZE, true); Assert.assertEquals(1.0d, solution.getValue(), epsilon); Assert.assertTrue(validSolution(solution, constraints, epsilon)); } @Test public void testMath781() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 2, 6, 7 }, 0); ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1, 2, 1 }, Relationship.LEQ, 2)); constraints.add(new LinearConstraint(new double[] { -1, 1, 1 }, Relationship.LEQ, -1)); constraints.add(new LinearConstraint(new double[] { 2, -3, 1 }, Relationship.LEQ, -1)); double epsilon = 1e-6; SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false); Assert.assertTrue(Precision.compareTo(solution.getPoint()[0], 0.0d, epsilon) > 0); Assert.assertTrue(Precision.compareTo(solution.getPoint()[1], 0.0d, epsilon) > 0); Assert.assertTrue(Precision.compareTo(solution.getPoint()[2], 0.0d, epsilon) < 0); Assert.assertEquals(2.0d, solution.getValue(), epsilon); } @Test public void testMath713NegativeVariable() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {1.0, 1.0}, 0.0d); ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] {1, 0}, Relationship.EQ, 1)); double epsilon = 1e-6; SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true); Assert.assertTrue(Precision.compareTo(solution.getPoint()[0], 0.0d, epsilon) >= 0); Assert.assertTrue(Precision.compareTo(solution.getPoint()[1], 0.0d, epsilon) >= 0); } @Test public void testMath434NegativeVariable() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {0.0, 0.0, 1.0}, 0.0d); ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] {1, 1, 0}, Relationship.EQ, 5)); constraints.add(new LinearConstraint(new double[] {0, 0, 1}, Relationship.GEQ, -10)); double epsilon = 1e-6; SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, false); Assert.assertEquals(5.0, solution.getPoint()[0] + solution.getPoint()[1], epsilon); Assert.assertEquals(-10.0, solution.getPoint()[2], epsilon); Assert.assertEquals(-10.0, solution.getValue(), epsilon); } @Test(expected = NoFeasibleSolutionException.class) public void testMath434UnfeasibleSolution() { double epsilon = 1e-6; LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {1.0, 0.0}, 0.0); ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] {epsilon/2, 0.5}, Relationship.EQ, 0)); constraints.add(new LinearConstraint(new double[] {1e-3, 0.1}, Relationship.EQ, 10)); SimplexSolver solver = new SimplexSolver(); // allowing only non-negative values, no feasible solution shall be found solver.optimize(f, constraints, GoalType.MINIMIZE, true); } @Test public void testMath434PivotRowSelection() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {1.0}, 0.0); double epsilon = 1e-6; ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] {200}, Relationship.GEQ, 1)); constraints.add(new LinearConstraint(new double[] {100}, Relationship.GEQ, 0.499900001)); SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, false); Assert.assertTrue(Precision.compareTo(solution.getPoint()[0] * 200.d, 1.d, epsilon) >= 0); Assert.assertEquals(0.0050, solution.getValue(), epsilon); } @Test public void testMath434PivotRowSelection2() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {0.0d, 1.0d, 1.0d, 0.0d, 0.0d, 0.0d, 0.0d}, 0.0d); ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] {1.0d, -0.1d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d}, Relationship.EQ, -0.1d)); constraints.add(new LinearConstraint(new double[] {1.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d}, Relationship.GEQ, -1e-18d)); constraints.add(new LinearConstraint(new double[] {0.0d, 1.0d, 0.0d, 0.0d, 0.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d)); constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 0.0d, 1.0d, 0.0d, -0.0128588d, 1e-5d}, Relationship.EQ, 0.0d)); constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 0.0d, 0.0d, 1.0d, 1e-5d, -0.0128586d}, Relationship.EQ, 1e-10d)); constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 1.0d, -1.0d, 0.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d)); constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 1.0d, 1.0d, 0.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d)); constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 1.0d, 0.0d, -1.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d)); constraints.add(new LinearConstraint(new double[] {0.0d, 0.0d, 1.0d, 0.0d, 1.0d, 0.0d, 0.0d}, Relationship.GEQ, 0.0d)); double epsilon = 1e-7; SimplexSolver simplex = new SimplexSolver(); PointValuePair solution = simplex.optimize(f, constraints, GoalType.MINIMIZE, false); Assert.assertTrue(Precision.compareTo(solution.getPoint()[0], -1e-18d, epsilon) >= 0); Assert.assertEquals(1.0d, solution.getPoint()[1], epsilon); Assert.assertEquals(0.0d, solution.getPoint()[2], epsilon); Assert.assertEquals(1.0d, solution.getValue(), epsilon); } @Test public void testMath272() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 2, 2, 1 }, 0); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1, 1, 0 }, Relationship.GEQ, 1)); constraints.add(new LinearConstraint(new double[] { 1, 0, 1 }, Relationship.GEQ, 1)); constraints.add(new LinearConstraint(new double[] { 0, 1, 0 }, Relationship.GEQ, 1)); SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true); Assert.assertEquals(0.0, solution.getPoint()[0], .0000001); Assert.assertEquals(1.0, solution.getPoint()[1], .0000001); Assert.assertEquals(1.0, solution.getPoint()[2], .0000001); Assert.assertEquals(3.0, solution.getValue(), .0000001); } @Test public void testMath286() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 0.8, 0.2, 0.7, 0.3, 0.6, 0.4 }, 0 ); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1, 0, 1, 0, 1, 0 }, Relationship.EQ, 23.0)); constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 1, 0, 1 }, Relationship.EQ, 23.0)); constraints.add(new LinearConstraint(new double[] { 1, 0, 0, 0, 0, 0 }, Relationship.GEQ, 10.0)); constraints.add(new LinearConstraint(new double[] { 0, 0, 1, 0, 0, 0 }, Relationship.GEQ, 8.0)); constraints.add(new LinearConstraint(new double[] { 0, 0, 0, 0, 1, 0 }, Relationship.GEQ, 5.0)); SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true); Assert.assertEquals(25.8, solution.getValue(), .0000001); Assert.assertEquals(23.0, solution.getPoint()[0] + solution.getPoint()[2] + solution.getPoint()[4], 0.0000001); Assert.assertEquals(23.0, solution.getPoint()[1] + solution.getPoint()[3] + solution.getPoint()[5], 0.0000001); Assert.assertTrue(solution.getPoint()[0] >= 10.0 - 0.0000001); Assert.assertTrue(solution.getPoint()[2] >= 8.0 - 0.0000001); Assert.assertTrue(solution.getPoint()[4] >= 5.0 - 0.0000001); } @Test public void testDegeneracy() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 0.8, 0.7 }, 0 ); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.LEQ, 18.0)); constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.GEQ, 10.0)); constraints.add(new LinearConstraint(new double[] { 0, 1 }, Relationship.GEQ, 8.0)); SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true); Assert.assertEquals(13.6, solution.getValue(), .0000001); } @Test public void testMath288() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 7, 3, 0, 0 }, 0 ); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 3, 0, -5, 0 }, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] { 2, 0, 0, -5 }, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] { 0, 3, 0, -5 }, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] { 1, 0, 0, 0 }, Relationship.LEQ, 1.0)); constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 0 }, Relationship.LEQ, 1.0)); SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true); Assert.assertEquals(10.0, solution.getValue(), .0000001); } @Test public void testMath290GEQ() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 1, 5 }, 0 ); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 2, 0 }, Relationship.GEQ, -1.0)); SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true); Assert.assertEquals(0, solution.getValue(), .0000001); Assert.assertEquals(0, solution.getPoint()[0], .0000001); Assert.assertEquals(0, solution.getPoint()[1], .0000001); } @Test(expected=NoFeasibleSolutionException.class) public void testMath290LEQ() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 1, 5 }, 0 ); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 2, 0 }, Relationship.LEQ, -1.0)); SimplexSolver solver = new SimplexSolver(); solver.optimize(f, constraints, GoalType.MINIMIZE, true); } @Test public void testMath293() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 0.8, 0.2, 0.7, 0.3, 0.4, 0.6}, 0 ); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1, 0, 1, 0, 1, 0 }, Relationship.EQ, 30.0)); constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 1, 0, 1 }, Relationship.EQ, 30.0)); constraints.add(new LinearConstraint(new double[] { 0.8, 0.2, 0.0, 0.0, 0.0, 0.0 }, Relationship.GEQ, 10.0)); constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.7, 0.3, 0.0, 0.0 }, Relationship.GEQ, 10.0)); constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.0, 0.0, 0.4, 0.6 }, Relationship.GEQ, 10.0)); SimplexSolver solver = new SimplexSolver(); PointValuePair solution1 = solver.optimize(f, constraints, GoalType.MAXIMIZE, true); Assert.assertEquals(15.7143, solution1.getPoint()[0], .0001); Assert.assertEquals(0.0, solution1.getPoint()[1], .0001); Assert.assertEquals(14.2857, solution1.getPoint()[2], .0001); Assert.assertEquals(0.0, solution1.getPoint()[3], .0001); Assert.assertEquals(0.0, solution1.getPoint()[4], .0001); Assert.assertEquals(30.0, solution1.getPoint()[5], .0001); Assert.assertEquals(40.57143, solution1.getValue(), .0001); double valA = 0.8 * solution1.getPoint()[0] + 0.2 * solution1.getPoint()[1]; double valB = 0.7 * solution1.getPoint()[2] + 0.3 * solution1.getPoint()[3]; double valC = 0.4 * solution1.getPoint()[4] + 0.6 * solution1.getPoint()[5]; f = new LinearObjectiveFunction(new double[] { 0.8, 0.2, 0.7, 0.3, 0.4, 0.6}, 0 ); constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1, 0, 1, 0, 1, 0 }, Relationship.EQ, 30.0)); constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 1, 0, 1 }, Relationship.EQ, 30.0)); constraints.add(new LinearConstraint(new double[] { 0.8, 0.2, 0.0, 0.0, 0.0, 0.0 }, Relationship.GEQ, valA)); constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.7, 0.3, 0.0, 0.0 }, Relationship.GEQ, valB)); constraints.add(new LinearConstraint(new double[] { 0.0, 0.0, 0.0, 0.0, 0.4, 0.6 }, Relationship.GEQ, valC)); PointValuePair solution2 = solver.optimize(f, constraints, GoalType.MAXIMIZE, true); Assert.assertEquals(40.57143, solution2.getValue(), .0001); } @Test public void testSimplexSolver() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 15, 10 }, 7); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.LEQ, 2)); constraints.add(new LinearConstraint(new double[] { 0, 1 }, Relationship.LEQ, 3)); constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.EQ, 4)); SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false); Assert.assertEquals(2.0, solution.getPoint()[0], 0.0); Assert.assertEquals(2.0, solution.getPoint()[1], 0.0); Assert.assertEquals(57.0, solution.getValue(), 0.0); } @Test public void testSingleVariableAndConstraint() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 3 }, 0); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.LEQ, 10)); SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false); Assert.assertEquals(10.0, solution.getPoint()[0], 0.0); Assert.assertEquals(30.0, solution.getValue(), 0.0); } /** * With no artificial variables needed (no equals and no greater than * constraints) we can go straight to Phase 2. */ @Test public void testModelWithNoArtificialVars() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 15, 10 }, 0); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.LEQ, 2)); constraints.add(new LinearConstraint(new double[] { 0, 1 }, Relationship.LEQ, 3)); constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.LEQ, 4)); SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false); Assert.assertEquals(2.0, solution.getPoint()[0], 0.0); Assert.assertEquals(2.0, solution.getPoint()[1], 0.0); Assert.assertEquals(50.0, solution.getValue(), 0.0); } @Test public void testMinimization() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { -2, 1 }, -5); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1, 2 }, Relationship.LEQ, 6)); constraints.add(new LinearConstraint(new double[] { 3, 2 }, Relationship.LEQ, 12)); constraints.add(new LinearConstraint(new double[] { 0, 1 }, Relationship.GEQ, 0)); SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, false); Assert.assertEquals(4.0, solution.getPoint()[0], 0.0); Assert.assertEquals(0.0, solution.getPoint()[1], 0.0); Assert.assertEquals(-13.0, solution.getValue(), 0.0); } @Test public void testSolutionWithNegativeDecisionVariable() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { -2, 1 }, 0); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.GEQ, 6)); constraints.add(new LinearConstraint(new double[] { 1, 2 }, Relationship.LEQ, 14)); SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false); Assert.assertEquals(-2.0, solution.getPoint()[0], 0.0); Assert.assertEquals(8.0, solution.getPoint()[1], 0.0); Assert.assertEquals(12.0, solution.getValue(), 0.0); } @Test(expected = NoFeasibleSolutionException.class) public void testInfeasibleSolution() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 15 }, 0); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.LEQ, 1)); constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.GEQ, 3)); SimplexSolver solver = new SimplexSolver(); solver.optimize(f, constraints, GoalType.MAXIMIZE, false); } @Test(expected = UnboundedSolutionException.class) public void testUnboundedSolution() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 15, 10 }, 0); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1, 0 }, Relationship.EQ, 2)); SimplexSolver solver = new SimplexSolver(); solver.optimize(f, constraints, GoalType.MAXIMIZE, false); } @Test public void testRestrictVariablesToNonNegative() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 409, 523, 70, 204, 339 }, 0); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 43, 56, 345, 56, 5 }, Relationship.LEQ, 4567456)); constraints.add(new LinearConstraint(new double[] { 12, 45, 7, 56, 23 }, Relationship.LEQ, 56454)); constraints.add(new LinearConstraint(new double[] { 8, 768, 0, 34, 7456 }, Relationship.LEQ, 1923421)); constraints.add(new LinearConstraint(new double[] { 12342, 2342, 34, 678, 2342 }, Relationship.GEQ, 4356)); constraints.add(new LinearConstraint(new double[] { 45, 678, 76, 52, 23 }, Relationship.EQ, 456356)); SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true); Assert.assertEquals(2902.92783505155, solution.getPoint()[0], .0000001); Assert.assertEquals(480.419243986254, solution.getPoint()[1], .0000001); Assert.assertEquals(0.0, solution.getPoint()[2], .0000001); Assert.assertEquals(0.0, solution.getPoint()[3], .0000001); Assert.assertEquals(0.0, solution.getPoint()[4], .0000001); Assert.assertEquals(1438556.7491409, solution.getValue(), .0000001); } @Test public void testEpsilon() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 10, 5, 1 }, 0); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 9, 8, 0 }, Relationship.EQ, 17)); constraints.add(new LinearConstraint(new double[] { 0, 7, 8 }, Relationship.LEQ, 7)); constraints.add(new LinearConstraint(new double[] { 10, 0, 2 }, Relationship.LEQ, 10)); SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false); Assert.assertEquals(1.0, solution.getPoint()[0], 0.0); Assert.assertEquals(1.0, solution.getPoint()[1], 0.0); Assert.assertEquals(0.0, solution.getPoint()[2], 0.0); Assert.assertEquals(15.0, solution.getValue(), 0.0); } @Test public void testTrivialModel() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 1, 1 }, 0); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.EQ, 0)); SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true); Assert.assertEquals(0, solution.getValue(), .0000001); } @Test public void testLargeModel() { double[] objective = new double[] { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 12, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}; LinearObjectiveFunction f = new LinearObjectiveFunction(objective, 0); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(equationFromString(objective.length, "x0 + x1 + x2 + x3 - x12 = 0")); constraints.add(equationFromString(objective.length, "x4 + x5 + x6 + x7 + x8 + x9 + x10 + x11 - x13 = 0")); constraints.add(equationFromString(objective.length, "x4 + x5 + x6 + x7 + x8 + x9 + x10 + x11 >= 49")); constraints.add(equationFromString(objective.length, "x0 + x1 + x2 + x3 >= 42")); constraints.add(equationFromString(objective.length, "x14 + x15 + x16 + x17 - x26 = 0")); constraints.add(equationFromString(objective.length, "x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 - x27 = 0")); constraints.add(equationFromString(objective.length, "x14 + x15 + x16 + x17 - x12 = 0")); constraints.add(equationFromString(objective.length, "x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 - x13 = 0")); constraints.add(equationFromString(objective.length, "x28 + x29 + x30 + x31 - x40 = 0")); constraints.add(equationFromString(objective.length, "x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 - x41 = 0")); constraints.add(equationFromString(objective.length, "x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 >= 49")); constraints.add(equationFromString(objective.length, "x28 + x29 + x30 + x31 >= 42")); constraints.add(equationFromString(objective.length, "x42 + x43 + x44 + x45 - x54 = 0")); constraints.add(equationFromString(objective.length, "x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 - x55 = 0")); constraints.add(equationFromString(objective.length, "x42 + x43 + x44 + x45 - x40 = 0")); constraints.add(equationFromString(objective.length, "x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 - x41 = 0")); constraints.add(equationFromString(objective.length, "x56 + x57 + x58 + x59 - x68 = 0")); constraints.add(equationFromString(objective.length, "x60 + x61 + x62 + x63 + x64 + x65 + x66 + x67 - x69 = 0")); constraints.add(equationFromString(objective.length, "x60 + x61 + x62 + x63 + x64 + x65 + x66 + x67 >= 51")); constraints.add(equationFromString(objective.length, "x56 + x57 + x58 + x59 >= 44")); constraints.add(equationFromString(objective.length, "x70 + x71 + x72 + x73 - x82 = 0")); constraints.add(equationFromString(objective.length, "x74 + x75 + x76 + x77 + x78 + x79 + x80 + x81 - x83 = 0")); constraints.add(equationFromString(objective.length, "x70 + x71 + x72 + x73 - x68 = 0")); constraints.add(equationFromString(objective.length, "x74 + x75 + x76 + x77 + x78 + x79 + x80 + x81 - x69 = 0")); constraints.add(equationFromString(objective.length, "x84 + x85 + x86 + x87 - x96 = 0")); constraints.add(equationFromString(objective.length, "x88 + x89 + x90 + x91 + x92 + x93 + x94 + x95 - x97 = 0")); constraints.add(equationFromString(objective.length, "x88 + x89 + x90 + x91 + x92 + x93 + x94 + x95 >= 51")); constraints.add(equationFromString(objective.length, "x84 + x85 + x86 + x87 >= 44")); constraints.add(equationFromString(objective.length, "x98 + x99 + x100 + x101 - x110 = 0")); constraints.add(equationFromString(objective.length, "x102 + x103 + x104 + x105 + x106 + x107 + x108 + x109 - x111 = 0")); constraints.add(equationFromString(objective.length, "x98 + x99 + x100 + x101 - x96 = 0")); constraints.add(equationFromString(objective.length, "x102 + x103 + x104 + x105 + x106 + x107 + x108 + x109 - x97 = 0")); constraints.add(equationFromString(objective.length, "x112 + x113 + x114 + x115 - x124 = 0")); constraints.add(equationFromString(objective.length, "x116 + x117 + x118 + x119 + x120 + x121 + x122 + x123 - x125 = 0")); constraints.add(equationFromString(objective.length, "x116 + x117 + x118 + x119 + x120 + x121 + x122 + x123 >= 49")); constraints.add(equationFromString(objective.length, "x112 + x113 + x114 + x115 >= 42")); constraints.add(equationFromString(objective.length, "x126 + x127 + x128 + x129 - x138 = 0")); constraints.add(equationFromString(objective.length, "x130 + x131 + x132 + x133 + x134 + x135 + x136 + x137 - x139 = 0")); constraints.add(equationFromString(objective.length, "x126 + x127 + x128 + x129 - x124 = 0")); constraints.add(equationFromString(objective.length, "x130 + x131 + x132 + x133 + x134 + x135 + x136 + x137 - x125 = 0")); constraints.add(equationFromString(objective.length, "x140 + x141 + x142 + x143 - x152 = 0")); constraints.add(equationFromString(objective.length, "x144 + x145 + x146 + x147 + x148 + x149 + x150 + x151 - x153 = 0")); constraints.add(equationFromString(objective.length, "x144 + x145 + x146 + x147 + x148 + x149 + x150 + x151 >= 59")); constraints.add(equationFromString(objective.length, "x140 + x141 + x142 + x143 >= 42")); constraints.add(equationFromString(objective.length, "x154 + x155 + x156 + x157 - x166 = 0")); constraints.add(equationFromString(objective.length, "x158 + x159 + x160 + x161 + x162 + x163 + x164 + x165 - x167 = 0")); constraints.add(equationFromString(objective.length, "x154 + x155 + x156 + x157 - x152 = 0")); constraints.add(equationFromString(objective.length, "x158 + x159 + x160 + x161 + x162 + x163 + x164 + x165 - x153 = 0")); constraints.add(equationFromString(objective.length, "x83 + x82 - x168 = 0")); constraints.add(equationFromString(objective.length, "x111 + x110 - x169 = 0")); constraints.add(equationFromString(objective.length, "x170 - x182 = 0")); constraints.add(equationFromString(objective.length, "x171 - x183 = 0")); constraints.add(equationFromString(objective.length, "x172 - x184 = 0")); constraints.add(equationFromString(objective.length, "x173 - x185 = 0")); constraints.add(equationFromString(objective.length, "x174 - x186 = 0")); constraints.add(equationFromString(objective.length, "x175 + x176 - x187 = 0")); constraints.add(equationFromString(objective.length, "x177 - x188 = 0")); constraints.add(equationFromString(objective.length, "x178 - x189 = 0")); constraints.add(equationFromString(objective.length, "x179 - x190 = 0")); constraints.add(equationFromString(objective.length, "x180 - x191 = 0")); constraints.add(equationFromString(objective.length, "x181 - x192 = 0")); constraints.add(equationFromString(objective.length, "x170 - x26 = 0")); constraints.add(equationFromString(objective.length, "x171 - x27 = 0")); constraints.add(equationFromString(objective.length, "x172 - x54 = 0")); constraints.add(equationFromString(objective.length, "x173 - x55 = 0")); constraints.add(equationFromString(objective.length, "x174 - x168 = 0")); constraints.add(equationFromString(objective.length, "x177 - x169 = 0")); constraints.add(equationFromString(objective.length, "x178 - x138 = 0")); constraints.add(equationFromString(objective.length, "x179 - x139 = 0")); constraints.add(equationFromString(objective.length, "x180 - x166 = 0")); constraints.add(equationFromString(objective.length, "x181 - x167 = 0")); constraints.add(equationFromString(objective.length, "x193 - x205 = 0")); constraints.add(equationFromString(objective.length, "x194 - x206 = 0")); constraints.add(equationFromString(objective.length, "x195 - x207 = 0")); constraints.add(equationFromString(objective.length, "x196 - x208 = 0")); constraints.add(equationFromString(objective.length, "x197 - x209 = 0")); constraints.add(equationFromString(objective.length, "x198 + x199 - x210 = 0")); constraints.add(equationFromString(objective.length, "x200 - x211 = 0")); constraints.add(equationFromString(objective.length, "x201 - x212 = 0")); constraints.add(equationFromString(objective.length, "x202 - x213 = 0")); constraints.add(equationFromString(objective.length, "x203 - x214 = 0")); constraints.add(equationFromString(objective.length, "x204 - x215 = 0")); constraints.add(equationFromString(objective.length, "x193 - x182 = 0")); constraints.add(equationFromString(objective.length, "x194 - x183 = 0")); constraints.add(equationFromString(objective.length, "x195 - x184 = 0")); constraints.add(equationFromString(objective.length, "x196 - x185 = 0")); constraints.add(equationFromString(objective.length, "x197 - x186 = 0")); constraints.add(equationFromString(objective.length, "x198 + x199 - x187 = 0")); constraints.add(equationFromString(objective.length, "x200 - x188 = 0")); constraints.add(equationFromString(objective.length, "x201 - x189 = 0")); constraints.add(equationFromString(objective.length, "x202 - x190 = 0")); constraints.add(equationFromString(objective.length, "x203 - x191 = 0")); constraints.add(equationFromString(objective.length, "x204 - x192 = 0")); SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true); Assert.assertEquals(7518.0, solution.getValue(), .0000001); } /** * Converts a test string to a {@link LinearConstraint}. * Ex: x0 + x1 + x2 + x3 - x12 = 0 */ private LinearConstraint equationFromString(int numCoefficients, String s) { Relationship relationship; if (s.contains(">=")) { relationship = Relationship.GEQ; } else if (s.contains("<=")) { relationship = Relationship.LEQ; } else if (s.contains("=")) { relationship = Relationship.EQ; } else { throw new IllegalArgumentException(); } String[] equationParts = s.split("[>|<]?="); double rhs = Double.parseDouble(equationParts[1].trim()); double[] lhs = new double[numCoefficients]; String left = equationParts[0].replaceAll(" ?x", ""); String[] coefficients = left.split(" "); for (String coefficient : coefficients) { double value = coefficient.charAt(0) == '-' ? -1 : 1; int index = Integer.parseInt(coefficient.replaceFirst("[+|-]", "").trim()); lhs[index] = value; } return new LinearConstraint(lhs, relationship, rhs); } private static boolean validSolution(PointValuePair solution, List<LinearConstraint> constraints, double epsilon) { double[] vals = solution.getPoint(); for (LinearConstraint c : constraints) { double[] coeffs = c.getCoefficients().toArray(); double result = 0.0d; for (int i = 0; i < vals.length; i++) { result += vals[i] * coeffs[i]; } switch (c.getRelationship()) { case EQ: if (!Precision.equals(result, c.getValue(), epsilon)) { return false; } break; case GEQ: if (Precision.compareTo(result, c.getValue(), epsilon) < 0) { return false; } break; case LEQ: if (Precision.compareTo(result, c.getValue(), epsilon) > 0) { return false; } break; } } return true; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optimization.linear; import java.util.ArrayList; import java.util.Collection; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.optimization.GoalType; import org.junit.Assert; import org.junit.Test; public class SimplexTableauTest { @Test public void testInitialization() { LinearObjectiveFunction f = createFunction(); Collection<LinearConstraint> constraints = createConstraints(); SimplexTableau tableau = new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false, 1.0e-6); double[][] expectedInitialTableau = { {-1, 0, -1, -1, 2, 0, 0, 0, -4}, { 0, 1, -15, -10, 25, 0, 0, 0, 0}, { 0, 0, 1, 0, -1, 1, 0, 0, 2}, { 0, 0, 0, 1, -1, 0, 1, 0, 3}, { 0, 0, 1, 1, -2, 0, 0, 1, 4} }; assertMatrixEquals(expectedInitialTableau, tableau.getData()); } @Test public void testDropPhase1Objective() { LinearObjectiveFunction f = createFunction(); Collection<LinearConstraint> constraints = createConstraints(); SimplexTableau tableau = new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false, 1.0e-6); double[][] expectedTableau = { { 1, -15, -10, 0, 0, 0, 0}, { 0, 1, 0, 1, 0, 0, 2}, { 0, 0, 1, 0, 1, 0, 3}, { 0, 1, 1, 0, 0, 1, 4} }; tableau.dropPhase1Objective(); assertMatrixEquals(expectedTableau, tableau.getData()); } @Test public void testTableauWithNoArtificialVars() { LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {15, 10}, 0); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] {1, 0}, Relationship.LEQ, 2)); constraints.add(new LinearConstraint(new double[] {0, 1}, Relationship.LEQ, 3)); constraints.add(new LinearConstraint(new double[] {1, 1}, Relationship.LEQ, 4)); SimplexTableau tableau = new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false, 1.0e-6); double[][] initialTableau = { {1, -15, -10, 25, 0, 0, 0, 0}, {0, 1, 0, -1, 1, 0, 0, 2}, {0, 0, 1, -1, 0, 1, 0, 3}, {0, 1, 1, -2, 0, 0, 1, 4} }; assertMatrixEquals(initialTableau, tableau.getData()); } @Test public void testSerial() { LinearObjectiveFunction f = createFunction(); Collection<LinearConstraint> constraints = createConstraints(); SimplexTableau tableau = new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false, 1.0e-6); Assert.assertEquals(tableau, TestUtils.serializeAndRecover(tableau)); } private LinearObjectiveFunction createFunction() { return new LinearObjectiveFunction(new double[] {15, 10}, 0); } private Collection<LinearConstraint> createConstraints() { Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] {1, 0}, Relationship.LEQ, 2)); constraints.add(new LinearConstraint(new double[] {0, 1}, Relationship.LEQ, 3)); constraints.add(new LinearConstraint(new double[] {1, 1}, Relationship.EQ, 4)); return constraints; } private void assertMatrixEquals(double[][] expected, double[][] result) { Assert.assertEquals("Wrong number of rows.", expected.length, result.length); for (int i = 0; i < expected.length; i++) { Assert.assertEquals("Wrong number of columns.", expected[i].length, result[i].length); for (int j = 0; j < expected[i].length; j++) { Assert.assertEquals("Wrong value at position [" + i + "," + j + "]", expected[i][j], result[i][j], 1.0e-15); } } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optimization.univariate; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.optimization.GoalType; import org.junit.Assert; import org.junit.Test; /** * Test for {@link BracketFinder}. */ public class BracketFinderTest { @Test public void testCubicMin() { final BracketFinder bFind = new BracketFinder(); final UnivariateFunction func = new UnivariateFunction() { public double value(double x) { if (x < -2) { return value(-2); } else { return (x - 1) * (x + 2) * (x + 3); } } }; bFind.search(func, GoalType.MINIMIZE, -2 , -1); final double tol = 1e-15; // Comparing with results computed in Python. Assert.assertEquals(-2, bFind.getLo(), tol); Assert.assertEquals(-1, bFind.getMid(), tol); Assert.assertEquals(0.61803399999999997, bFind.getHi(), tol); } @Test public void testCubicMax() { final BracketFinder bFind = new BracketFinder(); final UnivariateFunction func = new UnivariateFunction() { public double value(double x) { if (x < -2) { return value(-2); } else { return -(x - 1) * (x + 2) * (x + 3); } } }; bFind.search(func, GoalType.MAXIMIZE, -2 , -1); final double tol = 1e-15; Assert.assertEquals(-2, bFind.getLo(), tol); Assert.assertEquals(-1, bFind.getMid(), tol); Assert.assertEquals(0.61803399999999997, bFind.getHi(), tol); } @Test public void testMinimumIsOnIntervalBoundary() { final UnivariateFunction func = new UnivariateFunction() { public double value(double x) { return x * x; } }; final BracketFinder bFind = new BracketFinder(); bFind.search(func, GoalType.MINIMIZE, 0, 1); Assert.assertTrue(bFind.getLo() <= 0); Assert.assertTrue(0 <= bFind.getHi()); bFind.search(func, GoalType.MINIMIZE, -1, 0); Assert.assertTrue(bFind.getLo() <= 0); Assert.assertTrue(0 <= bFind.getHi()); } @Test public void testIntervalBoundsOrdering() { final UnivariateFunction func = new UnivariateFunction() { public double value(double x) { return x * x; } }; final BracketFinder bFind = new BracketFinder(); bFind.search(func, GoalType.MINIMIZE, -1, 1); Assert.assertTrue(bFind.getLo() <= 0); Assert.assertTrue(0 <= bFind.getHi()); bFind.search(func, GoalType.MINIMIZE, 1, -1); Assert.assertTrue(bFind.getLo() <= 0); Assert.assertTrue(0 <= bFind.getHi()); bFind.search(func, GoalType.MINIMIZE, 1, 2); Assert.assertTrue(bFind.getLo() <= 0); Assert.assertTrue(0 <= bFind.getHi()); bFind.search(func, GoalType.MINIMIZE, 2, 1); Assert.assertTrue(bFind.getLo() <= 0); Assert.assertTrue(0 <= bFind.getHi()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optimization.univariate; import org.apache.commons.math3.analysis.QuinticFunction; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.function.Sin; import org.apache.commons.math3.analysis.function.StepFunction; import org.apache.commons.math3.analysis.FunctionUtils; import org.apache.commons.math3.exception.NumberIsTooLargeException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.exception.TooManyEvaluationsException; import org.apache.commons.math3.optimization.ConvergenceChecker; import org.apache.commons.math3.optimization.GoalType; import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * @version $Id$ */ public final class BrentOptimizerTest { @Test public void testSinMin() { UnivariateFunction f = new Sin(); UnivariateOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14); Assert.assertEquals(3 * Math.PI / 2, optimizer.optimize(200, f, GoalType.MINIMIZE, 4, 5).getPoint(), 1e-8); Assert.assertTrue(optimizer.getEvaluations() <= 50); Assert.assertEquals(200, optimizer.getMaxEvaluations()); Assert.assertEquals(3 * Math.PI / 2, optimizer.optimize(200, f, GoalType.MINIMIZE, 1, 5).getPoint(), 1e-8); Assert.assertTrue(optimizer.getEvaluations() <= 100); Assert.assertTrue(optimizer.getEvaluations() >= 15); try { optimizer.optimize(10, f, GoalType.MINIMIZE, 4, 5); Assert.fail("an exception should have been thrown"); } catch (TooManyEvaluationsException fee) { // expected } } @Test public void testSinMinWithValueChecker() { final UnivariateFunction f = new Sin(); final ConvergenceChecker<UnivariatePointValuePair> checker = new SimpleUnivariateValueChecker(1e-5, 1e-14); // The default stopping criterion of Brent's algorithm should not // pass, but the search will stop at the given relative tolerance // for the function value. final UnivariateOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14, checker); final UnivariatePointValuePair result = optimizer.optimize(200, f, GoalType.MINIMIZE, 4, 5); Assert.assertEquals(3 * Math.PI / 2, result.getPoint(), 1e-3); } @Test public void testBoundaries() { final double lower = -1.0; final double upper = +1.0; UnivariateFunction f = new UnivariateFunction() { public double value(double x) { if (x < lower) { throw new NumberIsTooSmallException(x, lower, true); } else if (x > upper) { throw new NumberIsTooLargeException(x, upper, true); } else { return x; } } }; UnivariateOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14); Assert.assertEquals(lower, optimizer.optimize(100, f, GoalType.MINIMIZE, lower, upper).getPoint(), 1.0e-8); Assert.assertEquals(upper, optimizer.optimize(100, f, GoalType.MAXIMIZE, lower, upper).getPoint(), 1.0e-8); } @Test public void testQuinticMin() { // The function has local minima at -0.27195613 and 0.82221643. UnivariateFunction f = new QuinticFunction(); UnivariateOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14); Assert.assertEquals(-0.27195613, optimizer.optimize(200, f, GoalType.MINIMIZE, -0.3, -0.2).getPoint(), 1.0e-8); Assert.assertEquals( 0.82221643, optimizer.optimize(200, f, GoalType.MINIMIZE, 0.3, 0.9).getPoint(), 1.0e-8); Assert.assertTrue(optimizer.getEvaluations() <= 50); // search in a large interval Assert.assertEquals(-0.27195613, optimizer.optimize(200, f, GoalType.MINIMIZE, -1.0, 0.2).getPoint(), 1.0e-8); Assert.assertTrue(optimizer.getEvaluations() <= 50); } @Test public void testQuinticMinStatistics() { // The function has local minima at -0.27195613 and 0.82221643. UnivariateFunction f = new QuinticFunction(); UnivariateOptimizer optimizer = new BrentOptimizer(1e-11, 1e-14); final DescriptiveStatistics[] stat = new DescriptiveStatistics[2]; for (int i = 0; i < stat.length; i++) { stat[i] = new DescriptiveStatistics(); } final double min = -0.75; final double max = 0.25; final int nSamples = 200; final double delta = (max - min) / nSamples; for (int i = 0; i < nSamples; i++) { final double start = min + i * delta; stat[0].addValue(optimizer.optimize(40, f, GoalType.MINIMIZE, min, max, start).getPoint()); stat[1].addValue(optimizer.getEvaluations()); } final double meanOptValue = stat[0].getMean(); final double medianEval = stat[1].getPercentile(50); Assert.assertTrue(meanOptValue > -0.2719561281); Assert.assertTrue(meanOptValue < -0.2719561280); Assert.assertEquals(23, (int) medianEval); } @Test public void testQuinticMax() { // The quintic function has zeros at 0, +-0.5 and +-1. // The function has a local maximum at 0.27195613. UnivariateFunction f = new QuinticFunction(); UnivariateOptimizer optimizer = new BrentOptimizer(1e-12, 1e-14); Assert.assertEquals(0.27195613, optimizer.optimize(100, f, GoalType.MAXIMIZE, 0.2, 0.3).getPoint(), 1e-8); try { optimizer.optimize(5, f, GoalType.MAXIMIZE, 0.2, 0.3); Assert.fail("an exception should have been thrown"); } catch (TooManyEvaluationsException miee) { // expected } } @Test public void testMinEndpoints() { UnivariateFunction f = new Sin(); UnivariateOptimizer optimizer = new BrentOptimizer(1e-8, 1e-14); // endpoint is minimum double result = optimizer.optimize(50, f, GoalType.MINIMIZE, 3 * Math.PI / 2, 5).getPoint(); Assert.assertEquals(3 * Math.PI / 2, result, 1e-6); result = optimizer.optimize(50, f, GoalType.MINIMIZE, 4, 3 * Math.PI / 2).getPoint(); Assert.assertEquals(3 * Math.PI / 2, result, 1e-6); } @Test public void testMath832() { final UnivariateFunction f = new UnivariateFunction() { public double value(double x) { final double sqrtX = FastMath.sqrt(x); final double a = 1e2 * sqrtX; final double b = 1e6 / x; final double c = 1e4 / sqrtX; return a + b + c; } }; UnivariateOptimizer optimizer = new BrentOptimizer(1e-10, 1e-8); final double result = optimizer.optimize(1483, f, GoalType.MINIMIZE, Double.MIN_VALUE, Double.MAX_VALUE).getPoint(); Assert.assertEquals(804.9355825, result, 1e-6); } /** * Contrived example showing that prior to the resolution of MATH-855 * (second revision), the algorithm would not return the best point if * it happened to be the initial guess. */ @Test public void testKeepInitIfBest() { final double minSin = 3 * Math.PI / 2; final double offset = 1e-8; final double delta = 1e-7; final UnivariateFunction f1 = new Sin(); final UnivariateFunction f2 = new StepFunction(new double[] { minSin, minSin + offset, minSin + 2 * offset}, new double[] { 0, -1, 0 }); final UnivariateFunction f = FunctionUtils.add(f1, f2); // A slightly less stringent tolerance would make the test pass // even with the previous implementation. final double relTol = 1e-8; final UnivariateOptimizer optimizer = new BrentOptimizer(relTol, 1e-100); final double init = minSin + 1.5 * offset; final UnivariatePointValuePair result = optimizer.optimize(200, f, GoalType.MINIMIZE, minSin - 6.789 * delta, minSin + 9.876 * delta, init); final int numEval = optimizer.getEvaluations(); final double sol = result.getPoint(); final double expected = init; // System.out.println("numEval=" + numEval); // System.out.println("min=" + init + " f=" + f.value(init)); // System.out.println("sol=" + sol + " f=" + f.value(sol)); // System.out.println("exp=" + expected + " f=" + f.value(expected)); Assert.assertTrue("Best point not reported", f.value(sol) <= f.value(expected)); } /** * Contrived example showing that prior to the resolution of MATH-855, * the algorithm, by always returning the last evaluated point, would * sometimes not report the best point it had found. */ @Test public void testMath855() { final double minSin = 3 * Math.PI / 2; final double offset = 1e-8; final double delta = 1e-7; final UnivariateFunction f1 = new Sin(); final UnivariateFunction f2 = new StepFunction(new double[] { minSin, minSin + offset, minSin + 5 * offset }, new double[] { 0, -1, 0 }); final UnivariateFunction f = FunctionUtils.add(f1, f2); final UnivariateOptimizer optimizer = new BrentOptimizer(1e-8, 1e-100); final UnivariatePointValuePair result = optimizer.optimize(200, f, GoalType.MINIMIZE, minSin - 6.789 * delta, minSin + 9.876 * delta); final int numEval = optimizer.getEvaluations(); final double sol = result.getPoint(); final double expected = 4.712389027602411; // System.out.println("min=" + (minSin + offset) + " f=" + f.value(minSin + offset)); // System.out.println("sol=" + sol + " f=" + f.value(sol)); // System.out.println("exp=" + expected + " f=" + f.value(expected)); Assert.assertTrue("Best point not reported", f.value(sol) <= f.value(expected)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optimization.univariate; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.junit.Test; import org.junit.Assert; public class SimpleUnivariateValueCheckerTest { @Test(expected=NotStrictlyPositiveException.class) public void testIterationCheckPrecondition() { new SimpleUnivariateValueChecker(1e-1, 1e-2, 0); } @Test public void testIterationCheck() { final int max = 10; final SimpleUnivariateValueChecker checker = new SimpleUnivariateValueChecker(1e-1, 1e-2, max); Assert.assertTrue(checker.converged(max, null, null)); Assert.assertTrue(checker.converged(max + 1, null, null)); } @Test public void testIterationCheckDisabled() { final SimpleUnivariateValueChecker checker = new SimpleUnivariateValueChecker(1e-8, 1e-8); final UnivariatePointValuePair a = new UnivariatePointValuePair(1d, 1d); final UnivariatePointValuePair b = new UnivariatePointValuePair(10d, 10d); Assert.assertFalse(checker.converged(-1, a, b)); Assert.assertFalse(checker.converged(0, a, b)); Assert.assertFalse(checker.converged(1000000, a, b)); Assert.assertTrue(checker.converged(-1, a, a)); Assert.assertTrue(checker.converged(-1, b, b)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.optimization.univariate; import org.apache.commons.math3.analysis.QuinticFunction; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.function.Sin; import org.apache.commons.math3.optimization.GoalType; import org.apache.commons.math3.random.JDKRandomGenerator; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class UnivariateMultiStartOptimizerTest { @Test public void testSinMin() { UnivariateFunction f = new Sin(); UnivariateOptimizer underlying = new BrentOptimizer(1e-10, 1e-14); JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(44428400075l); UnivariateMultiStartOptimizer<UnivariateFunction> optimizer = new UnivariateMultiStartOptimizer<UnivariateFunction>(underlying, 10, g); optimizer.optimize(300, f, GoalType.MINIMIZE, -100.0, 100.0); UnivariatePointValuePair[] optima = optimizer.getOptima(); for (int i = 1; i < optima.length; ++i) { double d = (optima[i].getPoint() - optima[i-1].getPoint()) / (2 * FastMath.PI); Assert.assertTrue(FastMath.abs(d - FastMath.rint(d)) < 1.0e-8); Assert.assertEquals(-1.0, f.value(optima[i].getPoint()), 1.0e-10); Assert.assertEquals(f.value(optima[i].getPoint()), optima[i].getValue(), 1.0e-10); } Assert.assertTrue(optimizer.getEvaluations() > 200); Assert.assertTrue(optimizer.getEvaluations() < 300); } @Test public void testQuinticMin() { // The quintic function has zeros at 0, +-0.5 and +-1. // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643, UnivariateFunction f = new QuinticFunction(); UnivariateOptimizer underlying = new BrentOptimizer(1e-9, 1e-14); JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(4312000053L); UnivariateMultiStartOptimizer<UnivariateFunction> optimizer = new UnivariateMultiStartOptimizer<UnivariateFunction>(underlying, 5, g); UnivariatePointValuePair optimum = optimizer.optimize(300, f, GoalType.MINIMIZE, -0.3, -0.2); Assert.assertEquals(-0.2719561293, optimum.getPoint(), 1e-9); Assert.assertEquals(-0.0443342695, optimum.getValue(), 1e-9); UnivariatePointValuePair[] optima = optimizer.getOptima(); for (int i = 0; i < optima.length; ++i) { Assert.assertEquals(f.value(optima[i].getPoint()), optima[i].getValue(), 1e-9); } Assert.assertTrue(optimizer.getEvaluations() >= 50); Assert.assertTrue(optimizer.getEvaluations() <= 100); } @Test public void testBadFunction() { UnivariateFunction f = new UnivariateFunction() { public double value(double x) { if (x < 0) { throw new LocalException(); } return 0; } }; UnivariateOptimizer underlying = new BrentOptimizer(1e-9, 1e-14); JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(4312000053L); UnivariateMultiStartOptimizer<UnivariateFunction> optimizer = new UnivariateMultiStartOptimizer<UnivariateFunction>(underlying, 5, g); try { optimizer.optimize(300, f, GoalType.MINIMIZE, -0.3, -0.2); Assert.fail(); } catch (LocalException e) { // Expected. } // Ensure that the exception was thrown because no optimum was found. Assert.assertTrue(optimizer.getOptima()[0] == null); } private static class LocalException extends RuntimeException { private static final long serialVersionUID = 1194682757034350629L; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.primes; import java.util.HashSet; import java.util.List; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.exception.util.LocalizedFormats; import org.junit.Assert; import org.junit.Test; public class PrimesTest { public static final int[] PRIMES = {//primes here have been verified one by one using Dario Alejandro Alpern's tool, see http://www.alpertron.com.ar/ECM.HTM 2,3,5,7,11,13,17,19,23,29,31,43,47,53,71,73,79,89,97, 107,137,151,157,271,293,331,409,607,617,683,829, 1049,1103,1229,1657, 2039,2053,//around first boundary in miller-rabin 2251,2389,2473,2699,3271,3389,3449,5653,6449,6869,9067,9091, 11251,12433,12959,22961,41047,46337,65413,80803,91577,92693, 118423,656519,795659, 1373639,1373677,//around second boundary in miller-rabin 588977,952381, 1013041,1205999,2814001, 22605091, 25325981,25326023,//around third boundary in miller-rabin 100000007,715827881, 2147483647//Integer.MAX_VALUE }; public static final int[] NOT_PRIMES = {//composite chosen at random + particular values used in algorithms such as boundaries for millerRabin 4,6,8,9,10,12,14,15,16,18,20,21,22,24,25, 275, 2037,2041,2045,2046,2047,2048,2049,2051,2055,//around first boundary in miller-rabin 9095, 463465, 1373637,1373641,1373651,1373652,1373653,1373654,1373655,1373673,1373675,1373679,//around second boundary in miller-rabin 25325979,25325983,25325993,25325997,25325999,25326001,25326003,25326007,25326009,25326011,25326021,25326025,//around third boundary in miller-rabin 100000005, 1073741341,1073741823,2147473649,2147483641,2147483643,2147483645,2147483646}; public static final int[] BELOW_2 = { Integer.MIN_VALUE,-1,0,1}; void assertPrimeFactorsException(int n, Throwable expected) { try { Primes.primeFactors(n); Assert.fail("Exception not thrown"); } catch (Throwable e) { Assert.assertEquals(expected.getClass(), e.getClass()); if (expected.getMessage() != null) { Assert.assertEquals(expected.getMessage(), e.getMessage()); } } } void assertNextPrimeException(int n, Throwable expected){ try { Primes.nextPrime(n); Assert.fail("Exception not thrown"); } catch(Throwable e) { Assert.assertEquals(expected.getClass(), e.getClass()); if (expected.getMessage() != null) { Assert.assertEquals(expected.getMessage(), e.getMessage()); } } } @Test public void testNextPrime() { Assert.assertEquals(2, Primes.nextPrime(0)); Assert.assertEquals(2, Primes.nextPrime(1)); Assert.assertEquals(2, Primes.nextPrime(2)); Assert.assertEquals(3, Primes.nextPrime(3)); Assert.assertEquals(5, Primes.nextPrime(4)); Assert.assertEquals(5, Primes.nextPrime(5)); for (int i = 0; i < SmallPrimes.PRIMES.length - 1; i++) { for (int j = SmallPrimes.PRIMES[i] + 1; j <= SmallPrimes.PRIMES[i + 1]; j++) { Assert.assertEquals(SmallPrimes.PRIMES[i+1], Primes.nextPrime(j)); } } Assert.assertEquals(25325981, Primes.nextPrime(25325981)); for (int i = 25325981 + 1; i <= 25326023; i++) { Assert.assertEquals(25326023, Primes.nextPrime(i)); } Assert.assertEquals(Integer.MAX_VALUE, Primes.nextPrime(Integer.MAX_VALUE - 10)); Assert.assertEquals(Integer.MAX_VALUE, Primes.nextPrime(Integer.MAX_VALUE - 1)); Assert.assertEquals(Integer.MAX_VALUE, Primes.nextPrime(Integer.MAX_VALUE)); assertNextPrimeException(Integer.MIN_VALUE, new MathIllegalArgumentException(LocalizedFormats.NUMBER_TOO_SMALL,Integer.MIN_VALUE,0)); assertNextPrimeException(-1, new MathIllegalArgumentException(LocalizedFormats.NUMBER_TOO_SMALL,-1,0)); assertNextPrimeException(-13, new MathIllegalArgumentException(LocalizedFormats.NUMBER_TOO_SMALL,-13,0)); } @Test public void testIsPrime() throws Exception { for (int i : BELOW_2) { Assert.assertFalse(Primes.isPrime(i)); } for (int i:NOT_PRIMES) { Assert.assertFalse(Primes.isPrime(i)); } for (int i:PRIMES) { Assert.assertTrue(Primes.isPrime(i)); } } static int sum(List<Integer> numbers){ int out = 0; for (int i:numbers) { out += i; } return out; } static int product(List<Integer> numbers) { int out = 1; for (int i : numbers) { out *= i; } return out; } static final HashSet<Integer> PRIMES_SET = new HashSet<Integer>(); static { for (int p : PRIMES) { PRIMES_SET.add(p); } } static void checkPrimeFactors(List<Integer> factors){ for (int p : factors) { if (!PRIMES_SET.contains(p)) { Assert.fail("Not found in primes list: " + p); } } } @Test public void testPrimeFactors() throws Exception { for (int i : BELOW_2) { assertPrimeFactorsException(i, new MathIllegalArgumentException(LocalizedFormats.NUMBER_TOO_SMALL,i,2)); } for (int i : NOT_PRIMES) { List<Integer> factors = Primes.primeFactors(i); checkPrimeFactors(factors); int prod = product(factors); Assert.assertEquals(i, prod); } for (int i : PRIMES) { List<Integer> factors = Primes.primeFactors(i); Assert.assertEquals(i, (int)factors.get(0)); Assert.assertEquals(1, factors.size()); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.special; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.exception.OutOfRangeException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * @version $Id$ */ public class BetaTest { /* * Use reflection to test private methods. */ private static final Method LOG_GAMMA_SUM_METHOD; private static final Method LOG_GAMMA_MINUS_LOG_GAMMA_SUM_METHOD; private static final Method SUM_DELTA_MINUS_DELTA_SUM_METHOD; static { final Class<Beta> b; final Class<Double> d = Double.TYPE; b = Beta.class; Method m = null; try { m = b.getDeclaredMethod("logGammaSum", d, d); } catch (NoSuchMethodException e) { Assert.fail(e.getMessage()); } LOG_GAMMA_SUM_METHOD = m; LOG_GAMMA_SUM_METHOD.setAccessible(true); m = null; try { m = b.getDeclaredMethod("logGammaMinusLogGammaSum",d, d); } catch (NoSuchMethodException e) { Assert.fail(e.getMessage()); } LOG_GAMMA_MINUS_LOG_GAMMA_SUM_METHOD = m; LOG_GAMMA_MINUS_LOG_GAMMA_SUM_METHOD.setAccessible(true); m = null; try { m = b.getDeclaredMethod("sumDeltaMinusDeltaSum",d, d); } catch (NoSuchMethodException e) { Assert.fail(e.getMessage()); } SUM_DELTA_MINUS_DELTA_SUM_METHOD = m; SUM_DELTA_MINUS_DELTA_SUM_METHOD.setAccessible(true); } private void testRegularizedBeta(double expected, double x, double a, double b) { double actual = Beta.regularizedBeta(x, a, b); TestUtils.assertEquals(expected, actual, 10e-15); } private void testLogBeta(double expected, double a, double b) { double actual = Beta.logBeta(a, b); TestUtils.assertEquals(expected, actual, 10e-15); } @Test public void testRegularizedBetaNanPositivePositive() { testRegularizedBeta(Double.NaN, Double.NaN, 1.0, 1.0); } @Test public void testRegularizedBetaPositiveNanPositive() { testRegularizedBeta(Double.NaN, 0.5, Double.NaN, 1.0); } @Test public void testRegularizedBetaPositivePositiveNan() { testRegularizedBeta(Double.NaN, 0.5, 1.0, Double.NaN); } @Test public void testRegularizedBetaNegativePositivePositive() { testRegularizedBeta(Double.NaN, -0.5, 1.0, 2.0); } @Test public void testRegularizedBetaPositiveNegativePositive() { testRegularizedBeta(Double.NaN, 0.5, -1.0, 2.0); } @Test public void testRegularizedBetaPositivePositiveNegative() { testRegularizedBeta(Double.NaN, 0.5, 1.0, -2.0); } @Test public void testRegularizedBetaZeroPositivePositive() { testRegularizedBeta(0.0, 0.0, 1.0, 2.0); } @Test public void testRegularizedBetaPositiveZeroPositive() { testRegularizedBeta(Double.NaN, 0.5, 0.0, 2.0); } @Test public void testRegularizedBetaPositivePositiveZero() { testRegularizedBeta(Double.NaN, 0.5, 1.0, 0.0); } @Test public void testRegularizedBetaPositivePositivePositive() { testRegularizedBeta(0.75, 0.5, 1.0, 2.0); } @Test public void testLogBetaNanPositive() { testLogBeta(Double.NaN, Double.NaN, 2.0); } @Test public void testLogBetaPositiveNan() { testLogBeta(Double.NaN, 1.0, Double.NaN); } @Test public void testLogBetaNegativePositive() { testLogBeta(Double.NaN, -1.0, 2.0); } @Test public void testLogBetaPositiveNegative() { testLogBeta(Double.NaN, 1.0, -2.0); } @Test public void testLogBetaZeroPositive() { testLogBeta(Double.NaN, 0.0, 2.0); } @Test public void testLogBetaPositiveZero() { testLogBeta(Double.NaN, 1.0, 0.0); } @Test public void testLogBetaPositivePositive() { testLogBeta(-0.693147180559945, 1.0, 2.0); } /** * Reference data for the {@link Gamma#logGammaSum(double, double)} * function. This data was generated with the following * <a href="http://maxima.sourceforge.net/">Maxima</a> script. * * <pre> * kill(all); * * fpprec : 64; * gsumln(a, b) := log(gamma(a + b)); * * x : [1.0b0, 1.125b0, 1.25b0, 1.375b0, 1.5b0, 1.625b0, 1.75b0, 1.875b0, 2.0b0]; * * for i : 1 while i <= length(x) do * for j : 1 while j <= length(x) do block( * a : x[i], * b : x[j], * print("{", float(a), ",", float(b), ",", float(gsumln(a, b)), "},") * ); * </pre> */ private static final double[][] LOG_GAMMA_SUM_REF = { { 1.0 , 1.0 , 0.0 }, { 1.0 , 1.125 , .05775985153034387 }, { 1.0 , 1.25 , .1248717148923966 }, { 1.0 , 1.375 , .2006984603774558 }, { 1.0 , 1.5 , .2846828704729192 }, { 1.0 , 1.625 , .3763336820249054 }, { 1.0 , 1.75 , .4752146669149371 }, { 1.0 , 1.875 , .5809359740231859 }, { 1.0 , 2.0 , .6931471805599453 }, { 1.125 , 1.0 , .05775985153034387 }, { 1.125 , 1.125 , .1248717148923966 }, { 1.125 , 1.25 , .2006984603774558 }, { 1.125 , 1.375 , .2846828704729192 }, { 1.125 , 1.5 , .3763336820249054 }, { 1.125 , 1.625 , .4752146669149371 }, { 1.125 , 1.75 , .5809359740231859 }, { 1.125 , 1.875 , .6931471805599453 }, { 1.125 , 2.0 , 0.811531653906724 }, { 1.25 , 1.0 , .1248717148923966 }, { 1.25 , 1.125 , .2006984603774558 }, { 1.25 , 1.25 , .2846828704729192 }, { 1.25 , 1.375 , .3763336820249054 }, { 1.25 , 1.5 , .4752146669149371 }, { 1.25 , 1.625 , .5809359740231859 }, { 1.25 , 1.75 , .6931471805599453 }, { 1.25 , 1.875 , 0.811531653906724 }, { 1.25 , 2.0 , .9358019311087253 }, { 1.375 , 1.0 , .2006984603774558 }, { 1.375 , 1.125 , .2846828704729192 }, { 1.375 , 1.25 , .3763336820249054 }, { 1.375 , 1.375 , .4752146669149371 }, { 1.375 , 1.5 , .5809359740231859 }, { 1.375 , 1.625 , .6931471805599453 }, { 1.375 , 1.75 , 0.811531653906724 }, { 1.375 , 1.875 , .9358019311087253 }, { 1.375 , 2.0 , 1.06569589786406 }, { 1.5 , 1.0 , .2846828704729192 }, { 1.5 , 1.125 , .3763336820249054 }, { 1.5 , 1.25 , .4752146669149371 }, { 1.5 , 1.375 , .5809359740231859 }, { 1.5 , 1.5 , .6931471805599453 }, { 1.5 , 1.625 , 0.811531653906724 }, { 1.5 , 1.75 , .9358019311087253 }, { 1.5 , 1.875 , 1.06569589786406 }, { 1.5 , 2.0 , 1.200973602347074 }, { 1.625 , 1.0 , .3763336820249054 }, { 1.625 , 1.125 , .4752146669149371 }, { 1.625 , 1.25 , .5809359740231859 }, { 1.625 , 1.375 , .6931471805599453 }, { 1.625 , 1.5 , 0.811531653906724 }, { 1.625 , 1.625 , .9358019311087253 }, { 1.625 , 1.75 , 1.06569589786406 }, { 1.625 , 1.875 , 1.200973602347074 }, { 1.625 , 2.0 , 1.341414578068493 }, { 1.75 , 1.0 , .4752146669149371 }, { 1.75 , 1.125 , .5809359740231859 }, { 1.75 , 1.25 , .6931471805599453 }, { 1.75 , 1.375 , 0.811531653906724 }, { 1.75 , 1.5 , .9358019311087253 }, { 1.75 , 1.625 , 1.06569589786406 }, { 1.75 , 1.75 , 1.200973602347074 }, { 1.75 , 1.875 , 1.341414578068493 }, { 1.75 , 2.0 , 1.486815578593417 }, { 1.875 , 1.0 , .5809359740231859 }, { 1.875 , 1.125 , .6931471805599453 }, { 1.875 , 1.25 , 0.811531653906724 }, { 1.875 , 1.375 , .9358019311087253 }, { 1.875 , 1.5 , 1.06569589786406 }, { 1.875 , 1.625 , 1.200973602347074 }, { 1.875 , 1.75 , 1.341414578068493 }, { 1.875 , 1.875 , 1.486815578593417 }, { 1.875 , 2.0 , 1.6369886482725 }, { 2.0 , 1.0 , .6931471805599453 }, { 2.0 , 1.125 , 0.811531653906724 }, { 2.0 , 1.25 , .9358019311087253 }, { 2.0 , 1.375 , 1.06569589786406 }, { 2.0 , 1.5 , 1.200973602347074 }, { 2.0 , 1.625 , 1.341414578068493 }, { 2.0 , 1.75 , 1.486815578593417 }, { 2.0 , 1.875 , 1.6369886482725 }, { 2.0 , 2.0 , 1.791759469228055 }, }; private static double logGammaSum(final double a, final double b) { /* * Use reflection to access private method. */ try { return ((Double) LOG_GAMMA_SUM_METHOD.invoke(null, a, b)).doubleValue(); } catch (final IllegalAccessException e) { Assert.fail(e.getMessage()); } catch (final IllegalArgumentException e) { Assert.fail(e.getMessage()); } catch (final InvocationTargetException e) { final Throwable te = e.getTargetException(); if (te instanceof MathIllegalArgumentException) { throw (MathIllegalArgumentException) te; } Assert.fail(e.getMessage()); } return Double.NaN; } @Test public void testLogGammaSum() { final int ulps = 2; for (int i = 0; i < LOG_GAMMA_SUM_REF.length; i++) { final double[] ref = LOG_GAMMA_SUM_REF[i]; final double a = ref[0]; final double b = ref[1]; final double expected = ref[2]; final double actual = logGammaSum(a, b); final double tol = ulps * FastMath.ulp(expected); final StringBuilder builder = new StringBuilder(); builder.append(a).append(", ").append(b); Assert.assertEquals(builder.toString(), expected, actual, tol); } } @Test(expected = OutOfRangeException.class) public void testLogGammaSumPrecondition1() { logGammaSum(0.0, 1.0); } @Test(expected = OutOfRangeException.class) public void testLogGammaSumPrecondition2() { logGammaSum(3.0, 1.0); } @Test(expected = OutOfRangeException.class) public void testLogGammaSumPrecondition3() { logGammaSum(1.0, 0.0); } @Test(expected = OutOfRangeException.class) public void testLogGammaSumPrecondition4() { logGammaSum(1.0, 3.0); } private static final double[][] LOG_GAMMA_MINUS_LOG_GAMMA_SUM_REF = { // { 0.0 , 8.0 , 0.0 }, // { 0.0 , 9.0 , 0.0 }, { 0.0 , 10.0 , 0.0 }, { 0.0 , 11.0 , 0.0 }, { 0.0 , 12.0 , 0.0 }, { 0.0 , 13.0 , 0.0 }, { 0.0 , 14.0 , 0.0 }, { 0.0 , 15.0 , 0.0 }, { 0.0 , 16.0 , 0.0 }, { 0.0 , 17.0 , 0.0 }, { 0.0 , 18.0 , 0.0 }, // { 1.0 , 8.0 , - 2.079441541679836 }, // { 1.0 , 9.0 , - 2.19722457733622 }, { 1.0 , 10.0 , - 2.302585092994046 }, { 1.0 , 11.0 , - 2.397895272798371 }, { 1.0 , 12.0 , - 2.484906649788 }, { 1.0 , 13.0 , - 2.564949357461537 }, { 1.0 , 14.0 , - 2.639057329615258 }, { 1.0 , 15.0 , - 2.70805020110221 }, { 1.0 , 16.0 , - 2.772588722239781 }, { 1.0 , 17.0 , - 2.833213344056216 }, { 1.0 , 18.0 , - 2.890371757896165 }, // { 2.0 , 8.0 , - 4.276666119016055 }, // { 2.0 , 9.0 , - 4.499809670330265 }, { 2.0 , 10.0 , - 4.700480365792417 }, { 2.0 , 11.0 , - 4.882801922586371 }, { 2.0 , 12.0 , - 5.049856007249537 }, { 2.0 , 13.0 , - 5.204006687076795 }, { 2.0 , 14.0 , - 5.347107530717468 }, { 2.0 , 15.0 , - 5.480638923341991 }, { 2.0 , 16.0 , - 5.605802066295998 }, { 2.0 , 17.0 , - 5.723585101952381 }, { 2.0 , 18.0 , - 5.834810737062605 }, // { 3.0 , 8.0 , - 6.579251212010101 }, // { 3.0 , 9.0 , - 6.897704943128636 }, { 3.0 , 10.0 , - 7.185387015580416 }, { 3.0 , 11.0 , - 7.447751280047908 }, { 3.0 , 12.0 , - 7.688913336864796 }, { 3.0 , 13.0 , - 7.912056888179006 }, { 3.0 , 14.0 , - 8.11969625295725 }, { 3.0 , 15.0 , - 8.313852267398207 }, { 3.0 , 16.0 , - 8.496173824192162 }, { 3.0 , 17.0 , - 8.668024081118821 }, { 3.0 , 18.0 , - 8.830543010616596 }, // { 4.0 , 8.0 , - 8.977146484808472 }, // { 4.0 , 9.0 , - 9.382611592916636 }, { 4.0 , 10.0 , - 9.750336373041954 }, { 4.0 , 11.0 , - 10.08680860966317 }, { 4.0 , 12.0 , - 10.39696353796701 }, { 4.0 , 13.0 , - 10.68464561041879 }, { 4.0 , 14.0 , - 10.95290959701347 }, { 4.0 , 15.0 , - 11.20422402529437 }, { 4.0 , 16.0 , - 11.4406128033586 }, { 4.0 , 17.0 , - 11.66375635467281 }, { 4.0 , 18.0 , - 11.87506544834002 }, // { 5.0 , 8.0 , - 11.46205313459647 }, // { 5.0 , 9.0 , - 11.94756095037817 }, { 5.0 , 10.0 , - 12.38939370265721 }, { 5.0 , 11.0 , - 12.79485881076538 }, { 5.0 , 12.0 , - 13.16955226020679 }, { 5.0 , 13.0 , - 13.517858954475 }, { 5.0 , 14.0 , - 13.84328135490963 }, { 5.0 , 15.0 , - 14.14866300446081 }, { 5.0 , 16.0 , - 14.43634507691259 }, { 5.0 , 17.0 , - 14.70827879239624 }, { 5.0 , 18.0 , - 14.96610790169833 }, // { 6.0 , 8.0 , - 14.02700249205801 }, // { 6.0 , 9.0 , - 14.58661827999343 }, { 6.0 , 10.0 , - 15.09744390375942 }, { 6.0 , 11.0 , - 15.56744753300516 }, { 6.0 , 12.0 , - 16.002765604263 }, { 6.0 , 13.0 , - 16.40823071237117 }, { 6.0 , 14.0 , - 16.78772033407607 }, { 6.0 , 15.0 , - 17.14439527801481 }, { 6.0 , 16.0 , - 17.48086751463602 }, { 6.0 , 17.0 , - 17.79932124575455 }, { 6.0 , 18.0 , - 18.10160211762749 }, // { 7.0 , 8.0 , - 16.66605982167327 }, // { 7.0 , 9.0 , - 17.29466848109564 }, { 7.0 , 10.0 , - 17.8700326259992 }, { 7.0 , 11.0 , - 18.40066087706137 }, { 7.0 , 12.0 , - 18.89313736215917 }, { 7.0 , 13.0 , - 19.35266969153761 }, { 7.0 , 14.0 , - 19.78345260763006 }, { 7.0 , 15.0 , - 20.18891771573823 }, { 7.0 , 16.0 , - 20.57190996799433 }, { 7.0 , 17.0 , - 20.9348154616837 }, { 7.0 , 18.0 , - 21.27965594797543 }, // { 8.0 , 8.0 , - 19.37411002277548 }, // { 8.0 , 9.0 , - 20.06725720333542 }, { 8.0 , 10.0 , - 20.70324597005542 }, { 8.0 , 11.0 , - 21.29103263495754 }, { 8.0 , 12.0 , - 21.83757634132561 }, { 8.0 , 13.0 , - 22.3484019650916 }, { 8.0 , 14.0 , - 22.82797504535349 }, { 8.0 , 15.0 , - 23.27996016909654 }, { 8.0 , 16.0 , - 23.70740418392348 }, { 8.0 , 17.0 , - 24.11286929203165 }, { 8.0 , 18.0 , - 24.49853177284363 }, // { 9.0 , 8.0 , - 22.14669874501526 }, // { 9.0 , 9.0 , - 22.90047054739164 }, { 9.0 , 10.0 , - 23.59361772795159 }, { 9.0 , 11.0 , - 24.23547161412398 }, { 9.0 , 12.0 , - 24.8333086148796 }, { 9.0 , 13.0 , - 25.39292440281502 }, { 9.0 , 14.0 , - 25.9190174987118 }, { 9.0 , 15.0 , - 26.41545438502569 }, { 9.0 , 16.0 , - 26.88545801427143 }, { 9.0 , 17.0 , - 27.33174511689985 }, { 9.0 , 18.0 , - 27.75662831086511 }, // { 10.0 , 8.0 , - 24.97991208907148 }, // { 10.0 , 9.0 , - 25.7908423052878 }, { 10.0 , 10.0 , - 26.53805670711802 }, { 10.0 , 11.0 , - 27.23120388767797 }, { 10.0 , 12.0 , - 27.87783105260302 }, { 10.0 , 13.0 , - 28.48396685617334 }, { 10.0 , 14.0 , - 29.05451171464095 }, { 10.0 , 15.0 , - 29.59350821537364 }, { 10.0 , 16.0 , - 30.10433383913963 }, { 10.0 , 17.0 , - 30.58984165492133 }, { 10.0 , 18.0 , - 31.05246517686944 }, }; private static double logGammaMinusLogGammaSum(final double a, final double b) { /* * Use reflection to access private method. */ try { final Method m = LOG_GAMMA_MINUS_LOG_GAMMA_SUM_METHOD; return ((Double) m.invoke(null, a, b)).doubleValue(); } catch (final IllegalAccessException e) { Assert.fail(e.getMessage()); } catch (final IllegalArgumentException e) { Assert.fail(e.getMessage()); } catch (final InvocationTargetException e) { final Throwable te = e.getTargetException(); if (te instanceof MathIllegalArgumentException) { throw (MathIllegalArgumentException) te; } Assert.fail(e.getMessage()); } return Double.NaN; } @Test public void testLogGammaMinusLogGammaSum() { final int ulps = 4; for (int i = 0; i < LOG_GAMMA_MINUS_LOG_GAMMA_SUM_REF.length; i++) { final double[] ref = LOG_GAMMA_MINUS_LOG_GAMMA_SUM_REF[i]; final double a = ref[0]; final double b = ref[1]; final double expected = ref[2]; final double actual = logGammaMinusLogGammaSum(a, b); final double tol = ulps * FastMath.ulp(expected); final StringBuilder builder = new StringBuilder(); builder.append(a).append(", ").append(b); Assert.assertEquals(builder.toString(), expected, actual, tol); } } @Test(expected = NumberIsTooSmallException.class) public void testLogGammaMinusLogGammaSumPrecondition1() { logGammaMinusLogGammaSum(-1.0, 8.0); } @Test(expected = NumberIsTooSmallException.class) public void testLogGammaMinusLogGammaSumPrecondition2() { logGammaMinusLogGammaSum(1.0, 7.0); } private static final double[][] SUM_DELTA_MINUS_DELTA_SUM_REF = { { 10.0 , 10.0 , .01249480717472882 }, { 10.0 , 11.0 , .01193628470267385 }, { 10.0 , 12.0 , .01148578547212797 }, { 10.0 , 13.0 , .01111659739668398 }, { 10.0 , 14.0 , .01080991216314295 }, { 10.0 , 15.0 , .01055214134859758 }, { 10.0 , 16.0 , .01033324912491747 }, { 10.0 , 17.0 , .01014568069918883 }, { 10.0 , 18.0 , .009983653199146491 }, { 10.0 , 19.0 , .009842674320242729 }, { 10.0 , 20.0 , 0.0097192081956071 }, { 11.0 , 10.0 , .01193628470267385 }, { 11.0 , 11.0 , .01135973290745925 }, { 11.0 , 12.0 , .01089355537047828 }, { 11.0 , 13.0 , .01051064829297728 }, { 11.0 , 14.0 , 0.0101918899639826 }, { 11.0 , 15.0 , .009923438811859604 }, { 11.0 , 16.0 , .009695052724952705 }, { 11.0 , 17.0 , 0.00949900745283617 }, { 11.0 , 18.0 , .009329379874933402 }, { 11.0 , 19.0 , 0.00918156080743147 }, { 11.0 , 20.0 , 0.00905191635141762 }, { 12.0 , 10.0 , .01148578547212797 }, { 12.0 , 11.0 , .01089355537047828 }, { 12.0 , 12.0 , .01041365883144029 }, { 12.0 , 13.0 , .01001867865848564 }, { 12.0 , 14.0 , 0.00968923999191334 }, { 12.0 , 15.0 , .009411294976563555 }, { 12.0 , 16.0 , .009174432043268762 }, { 12.0 , 17.0 , .008970786693291802 }, { 12.0 , 18.0 , .008794318926790865 }, { 12.0 , 19.0 , .008640321527910711 }, { 12.0 , 20.0 , .008505077879954796 }, { 13.0 , 10.0 , .01111659739668398 }, { 13.0 , 11.0 , .01051064829297728 }, { 13.0 , 12.0 , .01001867865848564 }, { 13.0 , 13.0 , .009613018147953376 }, { 13.0 , 14.0 , .009274085618154277 }, { 13.0 , 15.0 , 0.0089876637564166 }, { 13.0 , 16.0 , .008743200745261382 }, { 13.0 , 17.0 , .008532715206686251 }, { 13.0 , 18.0 , .008350069108807093 }, { 13.0 , 19.0 , .008190472517984874 }, { 13.0 , 20.0 , .008050138630244345 }, { 14.0 , 10.0 , .01080991216314295 }, { 14.0 , 11.0 , 0.0101918899639826 }, { 14.0 , 12.0 , 0.00968923999191334 }, { 14.0 , 13.0 , .009274085618154277 }, { 14.0 , 14.0 , .008926676241967286 }, { 14.0 , 15.0 , .008632654302369184 }, { 14.0 , 16.0 , .008381351102615795 }, { 14.0 , 17.0 , .008164687232662443 }, { 14.0 , 18.0 , .007976441942841219 }, { 14.0 , 19.0 , .007811755112234388 }, { 14.0 , 20.0 , .007666780069317652 }, { 15.0 , 10.0 , .01055214134859758 }, { 15.0 , 11.0 , .009923438811859604 }, { 15.0 , 12.0 , .009411294976563555 }, { 15.0 , 13.0 , 0.0089876637564166 }, { 15.0 , 14.0 , .008632654302369184 }, { 15.0 , 15.0 , 0.00833179217417291 }, { 15.0 , 16.0 , .008074310643041299 }, { 15.0 , 17.0 , .007852047581145882 }, { 15.0 , 18.0 , .007658712051540045 }, { 15.0 , 19.0 , .007489384065757007 }, { 15.0 , 20.0 , .007340165635725612 }, { 16.0 , 10.0 , .01033324912491747 }, { 16.0 , 11.0 , .009695052724952705 }, { 16.0 , 12.0 , .009174432043268762 }, { 16.0 , 13.0 , .008743200745261382 }, { 16.0 , 14.0 , .008381351102615795 }, { 16.0 , 15.0 , .008074310643041299 }, { 16.0 , 16.0 , .007811229919967624 }, { 16.0 , 17.0 , .007583876618287594 }, { 16.0 , 18.0 , .007385899933505551 }, { 16.0 , 19.0 , .007212328560607852 }, { 16.0 , 20.0 , .007059220321091879 }, { 17.0 , 10.0 , .01014568069918883 }, { 17.0 , 11.0 , 0.00949900745283617 }, { 17.0 , 12.0 , .008970786693291802 }, { 17.0 , 13.0 , .008532715206686251 }, { 17.0 , 14.0 , .008164687232662443 }, { 17.0 , 15.0 , .007852047581145882 }, { 17.0 , 16.0 , .007583876618287594 }, { 17.0 , 17.0 , .007351882161431358 }, { 17.0 , 18.0 , .007149662089534654 }, { 17.0 , 19.0 , .006972200907152378 }, { 17.0 , 20.0 , .006815518216094137 }, { 18.0 , 10.0 , .009983653199146491 }, { 18.0 , 11.0 , .009329379874933402 }, { 18.0 , 12.0 , .008794318926790865 }, { 18.0 , 13.0 , .008350069108807093 }, { 18.0 , 14.0 , .007976441942841219 }, { 18.0 , 15.0 , .007658712051540045 }, { 18.0 , 16.0 , .007385899933505551 }, { 18.0 , 17.0 , .007149662089534654 }, { 18.0 , 18.0 , .006943552208153373 }, { 18.0 , 19.0 , .006762516574228829 }, { 18.0 , 20.0 , .006602541598043117 }, { 19.0 , 10.0 , .009842674320242729 }, { 19.0 , 11.0 , 0.00918156080743147 }, { 19.0 , 12.0 , .008640321527910711 }, { 19.0 , 13.0 , .008190472517984874 }, { 19.0 , 14.0 , .007811755112234388 }, { 19.0 , 15.0 , .007489384065757007 }, { 19.0 , 16.0 , .007212328560607852 }, { 19.0 , 17.0 , .006972200907152378 }, { 19.0 , 18.0 , .006762516574228829 }, { 19.0 , 19.0 , .006578188655176814 }, { 19.0 , 20.0 , .006415174623476747 }, { 20.0 , 10.0 , 0.0097192081956071 }, { 20.0 , 11.0 , 0.00905191635141762 }, { 20.0 , 12.0 , .008505077879954796 }, { 20.0 , 13.0 , .008050138630244345 }, { 20.0 , 14.0 , .007666780069317652 }, { 20.0 , 15.0 , .007340165635725612 }, { 20.0 , 16.0 , .007059220321091879 }, { 20.0 , 17.0 , .006815518216094137 }, { 20.0 , 18.0 , .006602541598043117 }, { 20.0 , 19.0 , .006415174623476747 }, { 20.0 , 20.0 , .006249349445691423 }, }; private static double sumDeltaMinusDeltaSum(final double a, final double b) { /* * Use reflection to access private method. */ try { final Method m = SUM_DELTA_MINUS_DELTA_SUM_METHOD; return ((Double) m.invoke(null, a, b)).doubleValue(); } catch (final IllegalAccessException e) { Assert.fail(e.getMessage()); } catch (final IllegalArgumentException e) { Assert.fail(e.getMessage()); } catch (final InvocationTargetException e) { final Throwable te = e.getTargetException(); if (te instanceof MathIllegalArgumentException) { throw (MathIllegalArgumentException) te; } Assert.fail(e.getMessage()); } return Double.NaN; } @Test public void testSumDeltaMinusDeltaSum() { final int ulps = 3; for (int i = 0; i < SUM_DELTA_MINUS_DELTA_SUM_REF.length; i++) { final double[] ref = SUM_DELTA_MINUS_DELTA_SUM_REF[i]; final double a = ref[0]; final double b = ref[1]; final double expected = ref[2]; final double actual = sumDeltaMinusDeltaSum(a, b); final double tol = ulps * FastMath.ulp(expected); final StringBuilder builder = new StringBuilder(); builder.append(a).append(", ").append(b); Assert.assertEquals(builder.toString(), expected, actual, tol); } } @Test(expected = NumberIsTooSmallException.class) public void testSumDeltaMinusDeltaSumPrecondition1() { sumDeltaMinusDeltaSum(9.0, 10.0); } @Test(expected = NumberIsTooSmallException.class) public void testSumDeltaMinusDeltaSumPrecondition2() { sumDeltaMinusDeltaSum(10.0, 9.0); } private static final double[][] LOG_BETA_REF = { { 0.125 , 0.125 , 2.750814190409515 }, { 0.125 , 0.25 , 2.444366899981226 }, { 0.125 , 0.5 , 2.230953804989556 }, { 0.125 , 1.0 , 2.079441541679836 }, { 0.125 , 2.0 , 1.961658506023452 }, { 0.125 , 3.0 , 1.901033884207018 }, { 0.125 , 4.0 , 1.860211889686763 }, { 0.125 , 5.0 , 1.829440231020009 }, { 0.125 , 6.0 , 1.804747618429637 }, { 0.125 , 7.0 , 1.784128331226902 }, { 0.125 , 8.0 , 1.766428754127501 }, { 0.125 , 9.0 , 1.750924567591535 }, { 0.125 , 10.0 , 1.7371312454592 }, { 0.125 , 1000.0 , 1.156003642015969 }, { 0.125 , 1001.0 , 1.155878649827818 }, { 0.125 , 10000.0 , .8681312798751318 }, { 0.25 , 0.125 , 2.444366899981226 }, { 0.25 , 0.25 , 2.003680106471455 }, { 0.25 , 0.5 , 1.657106516191482 }, { 0.25 , 1.0 , 1.386294361119891 }, { 0.25 , 2.0 , 1.163150809805681 }, { 0.25 , 3.0 , 1.045367774149297 }, { 0.25 , 4.0 , 0.965325066475761 }, { 0.25 , 5.0 , .9047004446593261 }, { 0.25 , 6.0 , .8559102804898941 }, { 0.25 , 7.0 , 0.815088285969639 }, { 0.25 , 8.0 , .7799969661583689 }, { 0.25 , 9.0 , .7492253074916152 }, { 0.25 , 10.0 , .7218263333035008 }, { 0.25 , 1000.0 , - .4388225372378877 }, { 0.25 , 1001.0 , - .4390725059930951 }, { 0.25 , 10000.0 , - 1.014553193217846 }, { 0.5 , 0.125 , 2.230953804989556 }, { 0.5 , 0.25 , 1.657106516191482 }, { 0.5 , 0.5 , 1.1447298858494 }, { 0.5 , 1.0 , .6931471805599453 }, { 0.5 , 2.0 , .2876820724517809 }, { 0.5 , 3.0 , .06453852113757118 }, // { 0.5 , 4.0 , - .08961215868968714 }, { 0.5 , 5.0 , - .2073951943460706 }, { 0.5 , 6.0 , - .3027053741503954 }, { 0.5 , 7.0 , - .3827480818239319 }, { 0.5 , 8.0 , - .4517409533108833 }, { 0.5 , 9.0 , - .5123655751273182 }, { 0.5 , 10.0 , - .5664327963975939 }, { 0.5 , 1000.0 , - 2.881387696571577 }, { 0.5 , 1001.0 , - 2.881887571613228 }, { 0.5 , 10000.0 , - 4.032792743063396 }, { 1.0 , 0.125 , 2.079441541679836 }, { 1.0 , 0.25 , 1.386294361119891 }, { 1.0 , 0.5 , .6931471805599453 }, { 1.0 , 1.0 , 0.0 }, { 1.0 , 2.0 , - .6931471805599453 }, { 1.0 , 3.0 , - 1.09861228866811 }, { 1.0 , 4.0 , - 1.386294361119891 }, { 1.0 , 5.0 , - 1.6094379124341 }, { 1.0 , 6.0 , - 1.791759469228055 }, { 1.0 , 7.0 , - 1.945910149055313 }, { 1.0 , 8.0 , - 2.079441541679836 }, { 1.0 , 9.0 , - 2.19722457733622 }, { 1.0 , 10.0 , - 2.302585092994046 }, { 1.0 , 1000.0 , - 6.907755278982137 }, { 1.0 , 1001.0 , - 6.90875477931522 }, { 1.0 , 10000.0 , - 9.210340371976184 }, { 2.0 , 0.125 , 1.961658506023452 }, { 2.0 , 0.25 , 1.163150809805681 }, { 2.0 , 0.5 , .2876820724517809 }, { 2.0 , 1.0 , - .6931471805599453 }, { 2.0 , 2.0 , - 1.791759469228055 }, { 2.0 , 3.0 , - 2.484906649788 }, { 2.0 , 4.0 , - 2.995732273553991 }, { 2.0 , 5.0 , - 3.401197381662155 }, { 2.0 , 6.0 , - 3.737669618283368 }, { 2.0 , 7.0 , - 4.02535169073515 }, { 2.0 , 8.0 , - 4.276666119016055 }, { 2.0 , 9.0 , - 4.499809670330265 }, { 2.0 , 10.0 , - 4.700480365792417 }, { 2.0 , 1000.0 , - 13.81651005829736 }, { 2.0 , 1001.0 , - 13.81850806096003 }, { 2.0 , 10000.0 , - 18.4207807389527 }, { 3.0 , 0.125 , 1.901033884207018 }, { 3.0 , 0.25 , 1.045367774149297 }, { 3.0 , 0.5 , .06453852113757118 }, { 3.0 , 1.0 , - 1.09861228866811 }, { 3.0 , 2.0 , - 2.484906649788 }, { 3.0 , 3.0 , - 3.401197381662155 }, { 3.0 , 4.0 , - 4.0943445622221 }, { 3.0 , 5.0 , - 4.653960350157523 }, { 3.0 , 6.0 , - 5.123963979403259 }, { 3.0 , 7.0 , - 5.529429087511423 }, { 3.0 , 8.0 , - 5.886104031450156 }, { 3.0 , 9.0 , - 6.20455776256869 }, { 3.0 , 10.0 , - 6.492239835020471 }, { 3.0 , 1000.0 , - 20.03311615938222 }, { 3.0 , 1001.0 , - 20.03611166836202 }, { 3.0 , 10000.0 , - 26.9381739103716 }, { 4.0 , 0.125 , 1.860211889686763 }, { 4.0 , 0.25 , 0.965325066475761 }, // { 4.0 , 0.5 , - .08961215868968714 }, { 4.0 , 1.0 , - 1.386294361119891 }, { 4.0 , 2.0 , - 2.995732273553991 }, { 4.0 , 3.0 , - 4.0943445622221 }, { 4.0 , 4.0 , - 4.941642422609304 }, { 4.0 , 5.0 , - 5.634789603169249 }, { 4.0 , 6.0 , - 6.222576268071369 }, { 4.0 , 7.0 , - 6.733401891837359 }, { 4.0 , 8.0 , - 7.185387015580416 }, { 4.0 , 9.0 , - 7.590852123688581 }, { 4.0 , 10.0 , - 7.958576903813898 }, { 4.0 , 1000.0 , - 25.84525465867605 }, { 4.0 , 1001.0 , - 25.84924667994559 }, { 4.0 , 10000.0 , - 35.05020194868867 }, { 5.0 , 0.125 , 1.829440231020009 }, { 5.0 , 0.25 , .9047004446593261 }, { 5.0 , 0.5 , - .2073951943460706 }, { 5.0 , 1.0 , - 1.6094379124341 }, { 5.0 , 2.0 , - 3.401197381662155 }, { 5.0 , 3.0 , - 4.653960350157523 }, { 5.0 , 4.0 , - 5.634789603169249 }, { 5.0 , 5.0 , - 6.445719819385578 }, { 5.0 , 6.0 , - 7.138866999945524 }, { 5.0 , 7.0 , - 7.745002803515839 }, { 5.0 , 8.0 , - 8.283999304248526 }, { 5.0 , 9.0 , - 8.769507120030227 }, { 5.0 , 10.0 , - 9.211339872309265 }, { 5.0 , 1000.0 , - 31.37070759780783 }, { 5.0 , 1001.0 , - 31.37569513931887 }, { 5.0 , 10000.0 , - 42.87464787956629 }, { 6.0 , 0.125 , 1.804747618429637 }, { 6.0 , 0.25 , .8559102804898941 }, { 6.0 , 0.5 , - .3027053741503954 }, { 6.0 , 1.0 , - 1.791759469228055 }, { 6.0 , 2.0 , - 3.737669618283368 }, { 6.0 , 3.0 , - 5.123963979403259 }, { 6.0 , 4.0 , - 6.222576268071369 }, { 6.0 , 5.0 , - 7.138866999945524 }, { 6.0 , 6.0 , - 7.927324360309794 }, { 6.0 , 7.0 , - 8.620471540869739 }, { 6.0 , 8.0 , - 9.239510749275963 }, { 6.0 , 9.0 , - 9.799126537211386 }, { 6.0 , 10.0 , - 10.30995216097738 }, { 6.0 , 1000.0 , - 36.67401250586691 }, { 6.0 , 1001.0 , - 36.67999457754446 }, { 6.0 , 10000.0 , - 50.47605021415003 }, { 7.0 , 0.125 , 1.784128331226902 }, { 7.0 , 0.25 , 0.815088285969639 }, { 7.0 , 0.5 , - .3827480818239319 }, { 7.0 , 1.0 , - 1.945910149055313 }, { 7.0 , 2.0 , - 4.02535169073515 }, { 7.0 , 3.0 , - 5.529429087511423 }, { 7.0 , 4.0 , - 6.733401891837359 }, { 7.0 , 5.0 , - 7.745002803515839 }, { 7.0 , 6.0 , - 8.620471540869739 }, { 7.0 , 7.0 , - 9.39366142910322 }, { 7.0 , 8.0 , - 10.08680860966317 }, { 7.0 , 9.0 , - 10.71541726908554 }, { 7.0 , 10.0 , - 11.2907814139891 }, { 7.0 , 1000.0 , - 41.79599038729854 }, { 7.0 , 1001.0 , - 41.80296600103496 }, { 7.0 , 10000.0 , - 57.89523093697012 }, { 8.0 , 0.125 , 1.766428754127501 }, { 8.0 , 0.25 , .7799969661583689 }, { 8.0 , 0.5 , - .4517409533108833 }, { 8.0 , 1.0 , - 2.079441541679836 }, { 8.0 , 2.0 , - 4.276666119016055 }, { 8.0 , 3.0 , - 5.886104031450156 }, { 8.0 , 4.0 , - 7.185387015580416 }, { 8.0 , 5.0 , - 8.283999304248526 }, { 8.0 , 6.0 , - 9.239510749275963 }, { 8.0 , 7.0 , - 10.08680860966317 }, { 8.0 , 8.0 , - 10.84894866171006 }, { 8.0 , 9.0 , - 11.54209584227001 }, { 8.0 , 10.0 , - 12.17808460899001 }, { 8.0 , 1000.0 , - 46.76481113096179 }, { 8.0 , 1001.0 , - 46.77277930061096 }, { 8.0 , 10000.0 , - 65.16036091500527 }, { 9.0 , 0.125 , 1.750924567591535 }, { 9.0 , 0.25 , .7492253074916152 }, { 9.0 , 0.5 , - .5123655751273182 }, { 9.0 , 1.0 , - 2.19722457733622 }, { 9.0 , 2.0 , - 4.499809670330265 }, { 9.0 , 3.0 , - 6.20455776256869 }, { 9.0 , 4.0 , - 7.590852123688581 }, { 9.0 , 5.0 , - 8.769507120030227 }, { 9.0 , 6.0 , - 9.799126537211386 }, { 9.0 , 7.0 , - 10.71541726908554 }, { 9.0 , 8.0 , - 11.54209584227001 }, { 9.0 , 9.0 , - 12.29586764464639 }, { 9.0 , 10.0 , - 12.98901482520633 }, { 9.0 , 1000.0 , - 51.60109303791327 }, { 9.0 , 1001.0 , - 51.61005277928474 }, { 9.0 , 10000.0 , - 72.29205942547217 }, { 10.0 , 0.125 , 1.7371312454592 }, { 10.0 , 0.25 , .7218263333035008 }, { 10.0 , 0.5 , - .5664327963975939 }, { 10.0 , 1.0 , - 2.302585092994046 }, { 10.0 , 2.0 , - 4.700480365792417 }, { 10.0 , 3.0 , - 6.492239835020471 }, { 10.0 , 4.0 , - 7.958576903813898 }, { 10.0 , 5.0 , - 9.211339872309265 }, { 10.0 , 6.0 , - 10.30995216097738 }, { 10.0 , 7.0 , - 11.2907814139891 }, { 10.0 , 8.0 , - 12.17808460899001 }, { 10.0 , 9.0 , - 12.98901482520633 }, { 10.0 , 10.0 , - 13.73622922703655 }, { 10.0 , 1000.0 , - 56.32058348093065 }, { 10.0 , 1001.0 , - 56.33053381178382 }, { 10.0 , 10000.0 , - 79.30607481535498 }, { 1000.0 , 0.125 , 1.156003642015969 }, { 1000.0 , 0.25 , - .4388225372378877 }, { 1000.0 , 0.5 , - 2.881387696571577 }, { 1000.0 , 1.0 , - 6.907755278982137 }, { 1000.0 , 2.0 , - 13.81651005829736 }, { 1000.0 , 3.0 , - 20.03311615938222 }, { 1000.0 , 4.0 , - 25.84525465867605 }, { 1000.0 , 5.0 , - 31.37070759780783 }, { 1000.0 , 6.0 , - 36.67401250586691 }, { 1000.0 , 7.0 , - 41.79599038729854 }, { 1000.0 , 8.0 , - 46.76481113096179 }, { 1000.0 , 9.0 , - 51.60109303791327 }, { 1000.0 , 10.0 , - 56.32058348093065 }, { 1000.0 , 1000.0 , - 1388.482601635902 }, { 1000.0 , 1001.0 , - 1389.175748816462 }, { 1000.0 , 10000.0 , - 3353.484270767097 }, { 1001.0 , 0.125 , 1.155878649827818 }, { 1001.0 , 0.25 , - .4390725059930951 }, { 1001.0 , 0.5 , - 2.881887571613228 }, { 1001.0 , 1.0 , - 6.90875477931522 }, { 1001.0 , 2.0 , - 13.81850806096003 }, { 1001.0 , 3.0 , - 20.03611166836202 }, { 1001.0 , 4.0 , - 25.84924667994559 }, { 1001.0 , 5.0 , - 31.37569513931887 }, { 1001.0 , 6.0 , - 36.67999457754446 }, { 1001.0 , 7.0 , - 41.80296600103496 }, { 1001.0 , 8.0 , - 46.77277930061096 }, { 1001.0 , 9.0 , - 51.61005277928474 }, { 1001.0 , 10.0 , - 56.33053381178382 }, { 1001.0 , 1000.0 , - 1389.175748816462 }, { 1001.0 , 1001.0 , - 1389.869395872064 }, { 1001.0 , 10000.0 , - 3355.882166039895 }, { 10000.0 , 0.125 , .8681312798751318 }, { 10000.0 , 0.25 , - 1.014553193217846 }, { 10000.0 , 0.5 , - 4.032792743063396 }, { 10000.0 , 1.0 , - 9.210340371976184 }, { 10000.0 , 2.0 , - 18.4207807389527 }, { 10000.0 , 3.0 , - 26.9381739103716 }, { 10000.0 , 4.0 , - 35.05020194868867 }, { 10000.0 , 5.0 , - 42.87464787956629 }, { 10000.0 , 6.0 , - 50.47605021415003 }, { 10000.0 , 7.0 , - 57.89523093697012 }, { 10000.0 , 8.0 , - 65.16036091500527 }, { 10000.0 , 9.0 , - 72.29205942547217 }, { 10000.0 , 10.0 , - 79.30607481535498 }, { 10000.0 , 1000.0 , - 3353.484270767097 }, { 10000.0 , 1001.0 , - 3355.882166039895 }, { 10000.0 , 10000.0 , - 13866.28325676141 }, }; @Test public void testLogBeta() { final int ulps = 3; for (int i = 0; i < LOG_BETA_REF.length; i++) { final double[] ref = LOG_BETA_REF[i]; final double a = ref[0]; final double b = ref[1]; final double expected = ref[2]; final double actual = Beta.logBeta(a, b); final double tol = ulps * FastMath.ulp(expected); final StringBuilder builder = new StringBuilder(); builder.append(a).append(", ").append(b); Assert.assertEquals(builder.toString(), expected, actual, tol); } }}
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.special; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.util.FastMath; import org.junit.Test; import org.junit.Assert; /** * @version $Id$ */ public class ErfTest { @Test public void testErf0() { double actual = Erf.erf(0.0); double expected = 0.0; Assert.assertEquals(expected, actual, 1.0e-15); Assert.assertEquals(1 - expected, Erf.erfc(0.0), 1.0e-15); } @Test public void testErf1960() { double x = 1.960 / FastMath.sqrt(2.0); double actual = Erf.erf(x); double expected = 0.95; Assert.assertEquals(expected, actual, 1.0e-5); Assert.assertEquals(1 - actual, Erf.erfc(x), 1.0e-15); actual = Erf.erf(-x); expected = -expected; Assert.assertEquals(expected, actual, 1.0e-5); Assert.assertEquals(1 - actual, Erf.erfc(-x), 1.0e-15); } @Test public void testErf2576() { double x = 2.576 / FastMath.sqrt(2.0); double actual = Erf.erf(x); double expected = 0.99; Assert.assertEquals(expected, actual, 1.0e-5); Assert.assertEquals(1 - actual, Erf.erfc(x), 1e-15); actual = Erf.erf(-x); expected = -expected; Assert.assertEquals(expected, actual, 1.0e-5); Assert.assertEquals(1 - actual, Erf.erfc(-x), 1.0e-15); } @Test public void testErf2807() { double x = 2.807 / FastMath.sqrt(2.0); double actual = Erf.erf(x); double expected = 0.995; Assert.assertEquals(expected, actual, 1.0e-5); Assert.assertEquals(1 - actual, Erf.erfc(x), 1.0e-15); actual = Erf.erf(-x); expected = -expected; Assert.assertEquals(expected, actual, 1.0e-5); Assert.assertEquals(1 - actual, Erf.erfc(-x), 1.0e-15); } @Test public void testErf3291() { double x = 3.291 / FastMath.sqrt(2.0); double actual = Erf.erf(x); double expected = 0.999; Assert.assertEquals(expected, actual, 1.0e-5); Assert.assertEquals(1 - expected, Erf.erfc(x), 1.0e-5); actual = Erf.erf(-x); expected = -expected; Assert.assertEquals(expected, actual, 1.0e-5); Assert.assertEquals(1 - expected, Erf.erfc(-x), 1.0e-5); } /** * MATH-301, MATH-456 */ @Test public void testLargeValues() { for (int i = 1; i < 200; i*=10) { double result = Erf.erf(i); Assert.assertFalse(Double.isNaN(result)); Assert.assertTrue(result > 0 && result <= 1); result = Erf.erf(-i); Assert.assertFalse(Double.isNaN(result)); Assert.assertTrue(result >= -1 && result < 0); result = Erf.erfc(i); Assert.assertFalse(Double.isNaN(result)); Assert.assertTrue(result >= 0 && result < 1); result = Erf.erfc(-i); Assert.assertFalse(Double.isNaN(result)); Assert.assertTrue(result >= 1 && result <= 2); } Assert.assertEquals(-1, Erf.erf(Double.NEGATIVE_INFINITY), 0); Assert.assertEquals(1, Erf.erf(Double.POSITIVE_INFINITY), 0); Assert.assertEquals(2, Erf.erfc(Double.NEGATIVE_INFINITY), 0); Assert.assertEquals(0, Erf.erfc(Double.POSITIVE_INFINITY), 0); } /** * Compare Erf.erf against reference values computed using GCC 4.2.1 (Apple OSX packaged version) * erfl (extended precision erf). */ @Test public void testErfGnu() { final double tol = 1E-15; final double[] gnuValues = new double[] {-1, -1, -1, -1, -1, -1, -1, -1, -0.99999999999999997848, -0.99999999999999264217, -0.99999999999846254017, -0.99999999980338395581, -0.99999998458274209971, -0.9999992569016276586, -0.99997790950300141459, -0.99959304798255504108, -0.99532226501895273415, -0.96610514647531072711, -0.84270079294971486948, -0.52049987781304653809, 0, 0.52049987781304653809, 0.84270079294971486948, 0.96610514647531072711, 0.99532226501895273415, 0.99959304798255504108, 0.99997790950300141459, 0.9999992569016276586, 0.99999998458274209971, 0.99999999980338395581, 0.99999999999846254017, 0.99999999999999264217, 0.99999999999999997848, 1, 1, 1, 1, 1, 1, 1, 1}; double x = -10d; for (int i = 0; i < 41; i++) { Assert.assertEquals(gnuValues[i], Erf.erf(x), tol); x += 0.5d; } } /** * Compare Erf.erfc against reference values computed using GCC 4.2.1 (Apple OSX packaged version) * erfcl (extended precision erfc). */ @Test public void testErfcGnu() { final double tol = 1E-15; final double[] gnuValues = new double[] { 2, 2, 2, 2, 2, 2, 2, 2, 1.9999999999999999785, 1.9999999999999926422, 1.9999999999984625402, 1.9999999998033839558, 1.9999999845827420998, 1.9999992569016276586, 1.9999779095030014146, 1.9995930479825550411, 1.9953222650189527342, 1.9661051464753107271, 1.8427007929497148695, 1.5204998778130465381, 1, 0.47950012218695346194, 0.15729920705028513051, 0.033894853524689272893, 0.0046777349810472658333, 0.00040695201744495893941, 2.2090496998585441366E-05, 7.4309837234141274516E-07, 1.5417257900280018858E-08, 1.966160441542887477E-10, 1.5374597944280348501E-12, 7.3578479179743980661E-15, 2.1519736712498913103E-17, 3.8421483271206474691E-20, 4.1838256077794144006E-23, 2.7766493860305691016E-26, 1.1224297172982927079E-29, 2.7623240713337714448E-33, 4.1370317465138102353E-37, 3.7692144856548799402E-41, 2.0884875837625447567E-45}; double x = -10d; for (int i = 0; i < 41; i++) { Assert.assertEquals(gnuValues[i], Erf.erfc(x), tol); x += 0.5d; } } /** * Tests erfc against reference data computed using Maple reported in Marsaglia, G,, * "Evaluating the Normal Distribution," Journal of Statistical Software, July, 2004. * http//www.jstatsoft.org/v11/a05/paper */ @Test public void testErfcMaple() { double[][] ref = new double[][] {{0.1, 4.60172162722971e-01}, {1.2, 1.15069670221708e-01}, {2.3, 1.07241100216758e-02}, {3.4, 3.36929265676881e-04}, {4.5, 3.39767312473006e-06}, {5.6, 1.07175902583109e-08}, {6.7, 1.04209769879652e-11}, {7.8, 3.09535877195870e-15}, {8.9, 2.79233437493966e-19}, {10.0, 7.61985302416053e-24}, {11.1, 6.27219439321703e-29}, {12.2, 1.55411978638959e-34}, {13.3, 1.15734162836904e-40}, {14.4, 2.58717592540226e-47}, {15.5, 1.73446079179387e-54}, {16.6, 3.48454651995041e-62} }; for (int i = 0; i < 15; i++) { final double result = 0.5*Erf.erfc(ref[i][0]/Math.sqrt(2)); Assert.assertEquals(ref[i][1], result, 1E-15); TestUtils.assertRelativelyEquals(ref[i][1], result, 1E-13); } } /** * Test the implementation of Erf.erf(double, double) for consistency with results * obtained from Erf.erf(double) and Erf.erfc(double). */ @Test public void testTwoArgumentErf() { double[] xi = new double[]{-2.0, -1.0, -0.9, -0.1, 0.0, 0.1, 0.9, 1.0, 2.0}; for(double x1 : xi) { for(double x2 : xi) { double a = Erf.erf(x1, x2); double b = Erf.erf(x2) - Erf.erf(x1); double c = Erf.erfc(x1) - Erf.erfc(x2); Assert.assertEquals(a, b, 1E-15); Assert.assertEquals(a, c, 1E-15); } } } @Test public void testErfInvNaN() { Assert.assertTrue(Double.isNaN(Erf.erfInv(-1.001))); Assert.assertTrue(Double.isNaN(Erf.erfInv(+1.001))); } @Test public void testErfInvInfinite() { Assert.assertTrue(Double.isInfinite(Erf.erfInv(-1))); Assert.assertTrue(Erf.erfInv(-1) < 0); Assert.assertTrue(Double.isInfinite(Erf.erfInv(+1))); Assert.assertTrue(Erf.erfInv(+1) > 0); } @Test public void testErfInv() { for (double x = -5.9; x < 5.9; x += 0.01) { final double y = Erf.erf(x); final double dydx = 2 * FastMath.exp(-x * x) / FastMath.sqrt(FastMath.PI); Assert.assertEquals(x, Erf.erfInv(y), 1.0e-15 / dydx); } } @Test public void testErfcInvNaN() { Assert.assertTrue(Double.isNaN(Erf.erfcInv(-0.001))); Assert.assertTrue(Double.isNaN(Erf.erfcInv(+2.001))); } @Test public void testErfcInvInfinite() { Assert.assertTrue(Double.isInfinite(Erf.erfcInv(-0))); Assert.assertTrue(Erf.erfcInv( 0) > 0); Assert.assertTrue(Double.isInfinite(Erf.erfcInv(+2))); Assert.assertTrue(Erf.erfcInv(+2) < 0); } @Test public void testErfcInv() { for (double x = -5.85; x < 5.9; x += 0.01) { final double y = Erf.erfc(x); final double dydxAbs = 2 * FastMath.exp(-x * x) / FastMath.sqrt(FastMath.PI); Assert.assertEquals(x, Erf.erfcInv(y), 1.0e-15 / dydxAbs); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.special; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.exception.NumberIsTooLargeException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * @version $Id$ */ public class GammaTest { private void testRegularizedGamma(double expected, double a, double x) { double actualP = Gamma.regularizedGammaP(a, x); double actualQ = Gamma.regularizedGammaQ(a, x); TestUtils.assertEquals(expected, actualP, 10e-15); TestUtils.assertEquals(actualP, 1.0 - actualQ, 10e-15); } private void testLogGamma(double expected, double x) { double actual = Gamma.logGamma(x); TestUtils.assertEquals(expected, actual, 10e-15); } @Test public void testRegularizedGammaNanPositive() { testRegularizedGamma(Double.NaN, Double.NaN, 1.0); } @Test public void testRegularizedGammaPositiveNan() { testRegularizedGamma(Double.NaN, 1.0, Double.NaN); } @Test public void testRegularizedGammaNegativePositive() { testRegularizedGamma(Double.NaN, -1.5, 1.0); } @Test public void testRegularizedGammaPositiveNegative() { testRegularizedGamma(Double.NaN, 1.0, -1.0); } @Test public void testRegularizedGammaZeroPositive() { testRegularizedGamma(Double.NaN, 0.0, 1.0); } @Test public void testRegularizedGammaPositiveZero() { testRegularizedGamma(0.0, 1.0, 0.0); } @Test public void testRegularizedGammaPositivePositive() { testRegularizedGamma(0.632120558828558, 1.0, 1.0); } @Test public void testLogGammaNan() { testLogGamma(Double.NaN, Double.NaN); } @Test public void testLogGammaNegative() { testLogGamma(Double.NaN, -1.0); } @Test public void testLogGammaZero() { testLogGamma(Double.NaN, 0.0); } @Test public void testLogGammaPositive() { testLogGamma(0.6931471805599457, 3.0); } @Test public void testDigammaLargeArgs() { double eps = 1e-8; Assert.assertEquals(4.6001618527380874002, Gamma.digamma(100), eps); Assert.assertEquals(3.9019896734278921970, Gamma.digamma(50), eps); Assert.assertEquals(2.9705239922421490509, Gamma.digamma(20), eps); Assert.assertEquals(2.9958363947076465821, Gamma.digamma(20.5), eps); Assert.assertEquals(2.2622143570941481605, Gamma.digamma(10.1), eps); Assert.assertEquals(2.1168588189004379233, Gamma.digamma(8.8), eps); Assert.assertEquals(1.8727843350984671394, Gamma.digamma(7), eps); Assert.assertEquals(0.42278433509846713939, Gamma.digamma(2), eps); Assert.assertEquals(-100.56088545786867450, Gamma.digamma(0.01), eps); Assert.assertEquals(-4.0390398965921882955, Gamma.digamma(-0.8), eps); Assert.assertEquals(4.2003210041401844726, Gamma.digamma(-6.3), eps); } @Test public void testDigammaSmallArgs() { // values for negative powers of 10 from 1 to 30 as computed by webMathematica with 20 digits // see functions.wolfram.com double[] expected = {-10.423754940411076795, -100.56088545786867450, -1000.5755719318103005, -10000.577051183514335, -100000.57719921568107, -1.0000005772140199687e6, -1.0000000577215500408e7, -1.0000000057721564845e8, -1.0000000005772156633e9, -1.0000000000577215665e10, -1.0000000000057721566e11, -1.0000000000005772157e12, -1.0000000000000577216e13, -1.0000000000000057722e14, -1.0000000000000005772e15, -1e+16, -1e+17, -1e+18, -1e+19, -1e+20, -1e+21, -1e+22, -1e+23, -1e+24, -1e+25, -1e+26, -1e+27, -1e+28, -1e+29, -1e+30}; for (double n = 1; n < 30; n++) { checkRelativeError(String.format("Test %.0f: ", n), expected[(int) (n - 1)], Gamma.digamma(FastMath.pow(10.0, -n)), 1e-8); } } @Test public void testTrigamma() { double eps = 1e-8; // computed using webMathematica. For example, to compute trigamma($i) = Polygamma(1, $i), use // // http://functions.wolfram.com/webMathematica/Evaluated.jsp?name=PolyGamma2&plottype=0&vars={%221%22,%22$i%22}&digits=20 double[] data = { 1e-4, 1.0000000164469368793e8, 1e-3, 1.0000016425331958690e6, 1e-2, 10001.621213528313220, 1e-1, 101.43329915079275882, 1, 1.6449340668482264365, 2, 0.64493406684822643647, 3, 0.39493406684822643647, 4, 0.28382295573711532536, 5, 0.22132295573711532536, 10, 0.10516633568168574612, 20, 0.051270822935203119832, 50, 0.020201333226697125806, 100, 0.010050166663333571395 }; for (int i = data.length - 2; i >= 0; i -= 2) { Assert.assertEquals(String.format("trigamma %.0f", data[i]), data[i + 1], Gamma.trigamma(data[i]), eps); } } /** * Reference data for the {@link Gamma#logGamma(double)} function. This data * was generated with the following <a * href="http://maxima.sourceforge.net/">Maxima</a> script. * * <pre> * kill(all); * * fpprec : 64; * gamln(x) := log(gamma(x)); * x : append(makelist(bfloat(i / 8), i, 1, 80), * [0.8b0, 1b2, 1b3, 1b4, 1b5, 1b6, 1b7, 1b8, 1b9, 1b10]); * * for i : 1 while i <= length(x) do * print("{", float(x[i]), ",", float(gamln(x[i])), "},"); * </pre> */ private static final double[][] LOG_GAMMA_REF = { { 0.125 , 2.019418357553796 }, { 0.25 , 1.288022524698077 }, { 0.375 , .8630739822706475 }, { 0.5 , .5723649429247001 }, { 0.625 , .3608294954889402 }, { 0.75 , .2032809514312954 }, { 0.875 , .08585870722533433 }, { 0.890625 , .07353860936979656 }, { 0.90625 , .06169536624059108 }, { 0.921875 , .05031670080005688 }, { 0.9375 , 0.0393909017345823 }, { 0.953125 , .02890678734595923 }, { 0.96875 , .01885367233441289 }, { 0.984375 , .009221337197578781 }, { 1.0 , 0.0 }, { 1.015625 , - 0.00881970970573307 }, { 1.03125 , - .01724677500176807 }, { 1.046875 , - .02528981394675729 }, { 1.0625 , - .03295710029357782 }, { 1.078125 , - .04025658272400143 }, { 1.09375 , - .04719590272716985 }, { 1.109375 , - .05378241123619192 }, { 1.125 , - .06002318412603958 }, { 1.25 , - .09827183642181316 }, { 1.375 , - .1177552707410788 }, { 1.5 , - .1207822376352452 }, { 1.625 , - .1091741337567954 }, { 1.75 , - .08440112102048555 }, { 1.875 , - 0.0476726853991883 }, { 1.890625 , - .04229320615532515 }, { 1.90625 , - .03674470657266143 }, { 1.921875 , - .03102893865389552 }, { 1.9375 , - .02514761940298887 }, { 1.953125 , - .01910243184040138 }, { 1.96875 , - .01289502598016741 }, { 1.984375 , - .006527019770560387 }, { 2.0 , 0.0 }, { 2.015625 , .006684476830232185 }, { 2.03125 , .01352488366498562 }, { 2.046875 , .02051972208453692 }, { 2.0625 , .02766752152285702 }, { 2.078125 , 0.0349668385135861 }, { 2.09375 , .04241625596251728 }, { 2.109375 , .05001438244545164 }, { 2.125 , .05775985153034387 }, { 2.25 , .1248717148923966 }, { 2.375 , .2006984603774558 }, { 2.5 , .2846828704729192 }, { 2.625 , .3763336820249054 }, { 2.75 , .4752146669149371 }, { 2.875 , .5809359740231859 }, { 2.890625 , .5946142560817441 }, { 2.90625 , .6083932548009232 }, { 2.921875 , .6222723333588501 }, { 2.9375 , .6362508628423761 }, { 2.953125 , .6503282221022278 }, { 2.96875 , .6645037976116387 }, { 2.984375 , 0.678776983328359 }, { 3.0 , .6931471805599453 }, { 3.015625 , .7076137978322324 }, { 3.03125 , .7221762507608962 }, { 3.046875 , .7368339619260166 }, { 3.0625 , 0.751586360749556 }, { 3.078125 , .7664328833756681 }, { 3.09375 , .7813729725537568 }, { 3.109375 , .7964060775242092 }, { 3.125 , 0.811531653906724 }, { 3.25 , .9358019311087253 }, { 3.375 , 1.06569589786406 }, { 3.5 , 1.200973602347074 }, { 3.625 , 1.341414578068493 }, { 3.75 , 1.486815578593417 }, { 3.875 , 1.6369886482725 }, { 4.0 , 1.791759469228055 }, { 4.125 , 1.950965937095089 }, { 4.25 , 2.114456927450371 }, { 4.375 , 2.282091222188554 }, { 4.5 , 2.453736570842442 }, { 4.625 , 2.62926886637513 }, { 4.75 , 2.808571418575736 }, { 4.875 , 2.99153431107781 }, { 5.0 , 3.178053830347946 }, { 5.125 , 3.368031956881733 }, { 5.25 , 3.561375910386697 }, { 5.375 , 3.757997741998131 }, { 5.5 , 3.957813967618717 }, { 5.625 , 4.160745237339519 }, { 5.75 , 4.366716036622286 }, { 5.875 , 4.57565441552762 }, { 6.0 , 4.787491742782046 }, { 6.125 , 5.002162481906205 }, { 6.25 , 5.219603986990229 }, { 6.375 , 5.439756316011858 }, { 6.5 , 5.662562059857142 }, { 6.625 , 5.887966185430003 }, { 6.75 , 6.115915891431546 }, { 6.875 , 6.346360475557843 }, { 7.0 , 6.579251212010101 }, { 7.125 , 6.814541238336996 }, { 7.25 , 7.05218545073854 }, { 7.375 , 7.292140407056348 }, { 7.5 , 7.534364236758733 }, { 7.625 , 7.778816557302289 }, { 7.75 , 8.025458396315983 }, { 7.875 , 8.274252119110479 }, { 8.0 , 8.525161361065415 }, { 8.125 , 8.77815096449171 }, { 8.25 , 9.033186919605123 }, { 8.375 , 9.290236309282232 }, { 8.5 , 9.549267257300997 }, { 8.625 , 9.810248879795765 }, { 8.75 , 10.07315123968124 }, { 8.875 , 10.33794530382217 }, { 9.0 , 10.60460290274525 }, { 9.125 , 10.87309669270751 }, { 9.25 , 11.14340011995171 }, { 9.375 , 11.41548738699336 }, { 9.5 , 11.68933342079727 }, { 9.625 , 11.96491384271319 }, { 9.75 , 12.24220494005076 }, { 9.875 , 12.52118363918365 }, { 10.0 , 12.80182748008147 }, { 0.8 , .1520596783998376 }, { 100.0 , 359.1342053695754 }, { 1000.0 , 5905.220423209181 }, { 10000.0 , 82099.71749644238 }, { 100000.0 , 1051287.708973657 }, { 1000000.0 , 1.2815504569147612e+7 }, { 10000000.0 , 1.511809493694739e+8 }, { 1.e+8 , 1.7420680661038346e+9 }, { 1.e+9 , 1.972326582750371e+10 }, { 1.e+10 , 2.202585092888106e+11 }, }; @Test public void testLogGamma() { final int ulps = 3; for (int i = 0; i < LOG_GAMMA_REF.length; i++) { final double[] data = LOG_GAMMA_REF[i]; final double x = data[0]; final double expected = data[1]; final double actual = Gamma.logGamma(x); final double tol; if (expected == 0.0) { tol = 1E-15; } else { tol = ulps * FastMath.ulp(expected); } Assert.assertEquals(Double.toString(x), expected, actual, tol); } } @Test public void testLogGammaPrecondition1() { Assert.assertTrue(Double.isNaN(Gamma.logGamma(0.0))); } @Test public void testLogGammaPrecondition2() { Assert.assertTrue(Double.isNaN(Gamma.logGamma(-1.0))); } /** * <p> * Reference values for the {@link Gamma#invGamma1pm1(double)} method. * These values were generated with the following <a * href="http://maxima.sourceforge.net/">Maxima</a> script * </p> * * <pre> * kill(all); * * fpprec : 64; * gam1(x) := 1 / gamma(1 + x) - 1; * x : makelist(bfloat(i / 8), i, -4, 12); * * for i : 1 while i <= length(x) do print("{", * float(x[i]), * ",", * float(gam1(x[i])), * "},"); * </pre> */ private static final double[][] INV_GAMMA1P_M1_REF = { { -0.5 , -.4358104164522437 }, { -0.375 , -.3029021533379859 }, { -0.25 , -0.183951060901737 }, { -0.125 , -.08227611018520711 }, { 0.0 , 0.0 }, { 0.125 , .06186116458306091 }, { 0.25 , .1032626513208373 }, { 0.375 , .1249687649039041 }, { 0.5 , .1283791670955126 }, { 0.625 , .1153565546592225 }, { 0.75 , 0.0880652521310173 }, { 0.875 , .04882730264547758 }, { 1.0 , 0.0 }, { 1.125 , -.05612340925950141 }, { 1.25 , -.1173898789433302 }, { 1.375 , -.1818408982517061 }, { 1.5 , -0.247747221936325 }, }; @Test public void testInvGamma1pm1() { final int ulps = 3; for (int i = 0; i < INV_GAMMA1P_M1_REF.length; i++) { final double[] ref = INV_GAMMA1P_M1_REF[i]; final double x = ref[0]; final double expected = ref[1]; final double actual = Gamma.invGamma1pm1(x); final double tol = ulps * FastMath.ulp(expected); Assert.assertEquals(Double.toString(x), expected, actual, tol); } } @Test(expected = NumberIsTooSmallException.class) public void testInvGamma1pm1Precondition1() { Gamma.invGamma1pm1(-0.51); } @Test(expected = NumberIsTooLargeException.class) public void testInvGamma1pm1Precondition2() { Gamma.invGamma1pm1(1.51); } private static final double[][] LOG_GAMMA1P_REF = { { - 0.5 , .5723649429247001 }, { - 0.375 , .3608294954889402 }, { - 0.25 , .2032809514312954 }, { - 0.125 , .08585870722533433 }, { 0.0 , 0.0 }, { 0.125 , - .06002318412603958 }, { 0.25 , - .09827183642181316 }, { 0.375 , - .1177552707410788 }, { 0.5 , - .1207822376352452 }, { 0.625 , - .1091741337567954 }, { 0.75 , - .08440112102048555 }, { 0.875 , - 0.0476726853991883 }, { 1.0 , 0.0 }, { 1.125 , .05775985153034387 }, { 1.25 , .1248717148923966 }, { 1.375 , .2006984603774558 }, { 1.5 , .2846828704729192 }, }; @Test public void testLogGamma1p() { final int ulps = 3; for (int i = 0; i < LOG_GAMMA1P_REF.length; i++) { final double[] ref = LOG_GAMMA1P_REF[i]; final double x = ref[0]; final double expected = ref[1]; final double actual = Gamma.logGamma1p(x); final double tol = ulps * FastMath.ulp(expected); Assert.assertEquals(Double.toString(x), expected, actual, tol); } } @Test(expected = NumberIsTooSmallException.class) public void testLogGamma1pPrecondition1() { Gamma.logGamma1p(-0.51); } @Test(expected = NumberIsTooLargeException.class) public void testLogGamma1pPrecondition2() { Gamma.logGamma1p(1.51); } /** * Reference data for the {@link Gamma#gamma(double)} function. This * data was generated with the following <a * href="http://maxima.sourceforge.net/">Maxima</a> script. * * <pre> * kill(all); * * fpprec : 64; * * EPSILON : 10**(-fpprec + 1); * isInteger(x) := abs(x - floor(x)) <= EPSILON * abs(x); * * x : makelist(bfloat(i / 8), i, -160, 160); * x : append(x, makelist(bfloat(i / 2), i, 41, 200)); * * for i : 1 while i <= length(x) do if not(isInteger(x[i])) then * print("{", float(x[i]), ",", float(gamma(x[i])), "},"); * </pre> */ private static final double[][] GAMMA_REF = { { - 19.875 , 4.920331854832504e-18 }, { - 19.75 , 3.879938752480031e-18 }, { - 19.625 , 4.323498423815027e-18 }, { - 19.5 , 5.811045977502237e-18 }, { - 19.375 , 9.14330910942125e-18 }, { - 19.25 , 1.735229114436739e-17 }, { - 19.125 , 4.653521565668223e-17 }, { - 18.875 , - 9.779159561479603e-17 }, { - 18.75 , - 7.662879036148061e-17 }, { - 18.625 , - 8.484865656736991e-17 }, { - 18.5 , - 1.133153965612936e-16 }, { - 18.375 , - 1.771516139950367e-16 }, { - 18.25 , - 3.340316045290721e-16 }, { - 18.125 , - 8.899859994340475e-16 }, { - 17.875 , 1.845816367229275e-15 }, { - 17.75 , 1.436789819277761e-15 }, { - 17.625 , 1.580306228567265e-15 }, { - 17.5 , 2.096334836383932e-15 }, { - 17.375 , 3.255160907158799e-15 }, { - 17.25 , 6.096076782655566e-15 }, { - 17.125 , 1.613099623974211e-14 }, { - 16.875 , - 3.29939675642233e-14 }, { - 16.75 , - 2.550301929218027e-14 }, { - 16.625 , - 2.785289727849803e-14 }, { - 16.5 , - 3.66858596367188e-14 }, { - 16.375 , - 5.655842076188414e-14 }, { - 16.25 , - 1.051573245008085e-13 }, { - 16.125 , - 2.762433106055837e-13 }, { - 15.875 , 5.567732026462681e-13 }, { - 15.75 , 4.271755731440195e-13 }, { - 15.625 , 4.630544172550298e-13 }, { - 15.5 , 6.053166840058604e-13 }, { - 15.375 , 9.261441399758529e-13 }, { - 15.25 , 1.708806523138138e-12 }, { - 15.125 , 4.454423383515037e-12 }, { - 14.875 , - 8.838774592009505e-12 }, { - 14.75 , - 6.728015277018307e-12 }, { - 14.625 , - 7.235225269609841e-12 }, { - 14.5 , - 9.382408602090835e-12 }, { - 14.375 , - 1.423946615212874e-11 }, { - 14.25 , - 2.605929947785661e-11 }, { - 14.125 , - 6.737315367566492e-11 }, { - 13.875 , 1.314767720561414e-10 }, { - 13.75 , 9.923822533602004e-11 }, { - 13.625 , 1.058151695680439e-10 }, { - 13.5 , 1.360449247303171e-10 }, { - 13.375 , 2.046923259368506e-10 }, { - 13.25 , 3.713450175594567e-10 }, { - 13.125 , 9.516457956687671e-10 }, { - 12.875 , - 1.8242402122789617e-9 }, { - 12.75 , - 1.3645255983702756e-9 }, { - 12.625 , - 1.4417316853645984e-9 }, { - 12.5 , - 1.836606483859281e-9 }, { - 12.375 , - 2.7377598594053765e-9 }, { - 12.25 , - 4.9203214826628017e-9 }, { - 12.125 , - 1.2490351068152569e-8 }, { - 11.875 , 2.3487092733091633e-8 }, { - 11.75 , 1.7397701379221012e-8 }, { - 11.625 , 1.8201862527728055e-8 }, { - 11.5 , 2.295758104824101e-8 }, { - 11.375 , 3.3879778260141535e-8 }, { - 11.25 , 6.027393816261931e-8 }, { - 11.125 , 1.5144550670134987e-7 }, { - 10.875 , - 2.7890922620546316e-7 }, { - 10.75 , - 2.044229912058469e-7 }, { - 10.625 , - 2.1159665188483867e-7 }, { - 10.5 , - 2.640121820547716e-7 }, { - 10.375 , - 3.8538247770911e-7 }, { - 10.25 , - 6.780818043294673e-7 }, { - 10.125 , - 1.6848312620525174e-6 }, { - 9.875 , 3.0331378349844124e-6 }, { - 9.75 , 2.1975471554628537e-6 }, { - 9.625 , 2.2482144262764103e-6 }, { - 9.5 , 2.772127911575102e-6 }, { - 9.375 , 3.998343206232017e-6 }, { - 9.25 , 6.95033849437704e-6 }, { - 9.125 , 1.7058916528281737e-5 }, { - 8.875 , - 2.9952236120471065e-5 }, { - 8.75 , - 2.1426084765762826e-5 }, { - 8.625 , - 2.163906385291045e-5 }, { - 8.5 , - 2.633521515996347e-5 }, { - 8.375 , - 3.748446755842515e-5 }, { - 8.25 , - 6.429063107298763e-5 }, { - 8.125 , - 1.5566261332057085e-4 }, { - 7.875 , 2.658260955691807e-4 }, { - 7.75 , 1.874782417004247e-4 }, { - 7.625 , 1.8663692573135265e-4 }, { - 7.5 , 2.238493288596895e-4 }, { - 7.375 , 3.1393241580181064e-4 }, { - 7.25 , 5.303977063521479e-4 }, { - 7.125 , .001264758733229638 }, { - 6.875 , - .002093380502607298 }, { - 6.75 , - .001452956373178292 }, { - 6.625 , - .001423106558701564 }, { - 6.5 , - .001678869966447671 }, { - 6.375 , - .002315251566538353 }, { - 6.25 , - .003845383371053072 }, { - 6.125 , - .009011405974261174 }, { - 5.875 , .01439199095542518 }, { - 5.75 , .009807455518953468 }, { - 5.625 , .009428080951397862 }, { - 5.5 , .01091265478190986 }, { - 5.375 , 0.014759728736682 }, { - 5.25 , 0.0240336460690817 }, { - 5.125 , .05519486159234969 }, { - 4.875 , - 0.0845529468631229 }, { - 4.75 , - .05639286923398244 }, { - 4.625 , - .05303295535161297 }, { - 4.5 , - .06001960130050425 }, { - 4.375 , - .07933354195966577 }, { - 4.25 , - .1261766418626789 }, { - 4.125 , - .2828736656607921 }, { - 3.875 , .4121956159577241 }, { - 3.75 , .2678661288614166 }, { - 3.625 , 0.24527741850121 }, { - 3.5 , .2700882058522691 }, { - 3.375 , .3470842460735378 }, { - 3.25 , .5362507279163854 }, { - 3.125 , 1.166853870850768 }, { - 2.875 , - 1.597258011836181 }, { - 2.75 , - 1.004497983230312 }, { - 2.625 , - .8891306420668862 }, { - 2.5 , - .9453087204829419 }, { - 2.375 , - 1.17140933049819 }, { - 2.25 , - 1.742814865728253 }, { - 2.125 , - 3.646418346408649 }, { - 1.875 , 4.59211678402902 }, { - 1.75 , 2.762369453883359 }, { - 1.625 , 2.333967935425576 }, { - 1.5 , 2.363271801207355 }, { - 1.375 , 2.782097159933201 }, { - 1.25 , 3.921333447888569 }, { - 1.125 , 7.748638986118379 }, { - 0.875 , - 8.610218970054413 }, { - 0.75 , - 4.834146544295877 }, { - 0.625 , - 3.792697895066561 }, { - 0.5 , - 3.544907701811032 }, { - 0.375 , - 3.825383594908152 }, { - 0.25 , - 4.901666809860711 }, { - 0.125 , - 8.717218859383175 }, { 0.125 , 7.533941598797612 }, { 0.25 , 3.625609908221908 }, { 0.375 , 2.370436184416601 }, { 0.5 , 1.772453850905516 }, { 0.625 , 1.434518848090557 }, { 0.75 , 1.225416702465178 }, { 0.875 , 1.089652357422897 }, { 1.0 , 1.0 }, { 1.125 , .9417426998497015 }, { 1.25 , 0.906402477055477 }, { 1.375 , .8889135691562253 }, { 1.5 , 0.886226925452758 }, { 1.625 , 0.896574280056598 }, { 1.75 , .9190625268488832 }, { 1.875 , .9534458127450348 }, { 2.0 , 1.0 }, { 2.125 , 1.059460537330914 }, { 2.25 , 1.133003096319346 }, { 2.375 , 1.22225615758981 }, { 2.5 , 1.329340388179137 }, { 2.625 , 1.456933205091972 }, { 2.75 , 1.608359421985546 }, { 2.875 , 1.78771089889694 }, { 3.0 , 2.0 }, { 3.125 , 2.251353641828193 }, { 3.25 , 2.549256966718529 }, { 3.375 , 2.902858374275799 }, { 3.5 , 3.323350970447843 }, { 3.625 , 3.824449663366426 }, { 3.75 , 4.422988410460251 }, { 3.875 , 5.139668834328703 }, { 4.0 , 6.0 }, { 4.125 , 7.035480130713102 }, { 4.25 , 8.28508514183522 }, { 4.375 , 9.797147013180819 }, { 4.5 , 11.63172839656745 }, { 4.625 , 13.86363002970329 }, { 4.75 , 16.58620653922594 }, { 4.875 , 19.91621673302373 }, { 5.0 , 24.0 }, { 5.125 , 29.02135553919155 }, { 5.25 , 35.21161185279968 }, { 5.375 , 42.86251818266609 }, { 5.5 , 52.34277778455352 }, { 5.625 , 64.11928888737773 }, { 5.75 , 78.78448106132322 }, { 5.875 , 97.09155657349066 }, { 6.0 , 120.0 }, { 6.125 , 148.7344471383567 }, { 6.25 , 184.8609622271983 }, { 6.375 , 230.3860352318302 }, { 6.5 , 287.8852778150443 }, { 6.625 , 360.6709999914997 }, { 6.75 , 453.0107661026085 }, { 6.875 , 570.4128948692577 }, { 7.0 , 720.0 }, { 7.125 , 910.9984887224346 }, { 7.25 , 1155.38101391999 }, { 7.375 , 1468.710974602918 }, { 7.5 , 1871.254305797788 }, { 7.625 , 2389.445374943686 }, { 7.75 , 3057.822671192607 }, { 7.875 , 3921.588652226146 }, { 8.0 , 5040.0 }, { 8.125 , 6490.864232147346 }, { 8.25 , 8376.512350919926 }, { 8.375 , 10831.74343769652 }, { 8.5 , 14034.40729348341 }, { 8.625 , 18219.5209839456 }, { 8.75 , 23698.12570174271 }, { 8.875 , 30882.5106362809 }, { 9.0 , 40320.0 }, { 9.125 , 52738.27188619719 }, { 9.25 , 69106.22689508938 }, { 9.375 , 90715.85129070834 }, { 9.5 , 119292.461994609 }, { 9.625 , 157143.3684865308 }, { 9.75 , 207358.5998902487 }, { 9.875 , 274082.281896993 }, { 10.0 , 362880.0 }, { 10.125 , 481236.7309615494 }, { 10.25 , 639232.5987795768 }, { 10.375 , 850461.1058503906 }, { 10.5 , 1133278.388948786 }, { 10.625 , 1512504.921682859 }, { 10.75 , 2021746.348929925 }, { 10.875 , 2706562.533732806 }, { 11.0 , 3628800.0 }, { 11.125 , 4872521.900985687 }, { 11.25 , 6552134.137490662 }, { 11.375 , 8823533.973197803 }, { 11.5 , 1.1899423083962249e+7 }, { 11.625 , 1.6070364792880382e+7 }, { 11.75 , 2.1733773250996688e+7 }, { 11.875 , 2.943386755434427e+7 }, { 12.0 , 3.99168e+7 }, { 12.125 , 5.420680614846578e+7 }, { 12.25 , 7.371150904676994e+7 }, { 12.375 , 1.0036769894512501e+8 }, { 12.5 , 1.3684336546556586e+8 }, { 12.625 , 1.8681799071723443e+8 }, { 12.75 , 2.5537183569921107e+8 }, { 12.875 , 3.4952717720783816e+8 }, { 13.0 , 4.790016e+8 }, { 13.125 , 6.572575245501475e+8 }, { 13.25 , 9.029659858229319e+8 }, { 13.375 , 1.2420502744459219e+9 }, { 13.5 , 1.7105420683195732e+9 }, { 13.625 , 2.3585771328050845e+9 }, { 13.75 , 3.2559909051649416e+9 }, { 13.875 , 4.500162406550916e+9 }, { 14.0 , 6.2270208e+9 }, { 14.125 , 8.626505009720685e+9 }, { 14.25 , 1.196429931215385e+10 }, { 14.375 , 1.66124224207142e+10 }, { 14.5 , 2.309231792231424e+10 }, { 14.625 , 3.213561343446927e+10 }, { 14.75 , 4.476987494601794e+10 }, { 14.875 , 6.243975339089396e+10 }, { 15.0 , 8.71782912e+10 }, { 15.125 , 1.218493832623047e+11 }, { 15.25 , 1.704912651981923e+11 }, { 15.375 , 2.388035722977667e+11 }, { 15.5 , 3.348386098735565e+11 }, { 15.625 , 4.699833464791132e+11 }, { 15.75 , 6.603556554537646e+11 }, { 15.875 , 9.287913316895475e+11 }, { 16.0 , 1.307674368e+12 }, { 16.125 , 1.842971921842358e+12 }, { 16.25 , 2.599991794272433e+12 }, { 16.375 , 3.671604924078163e+12 }, { 16.5 , 5.189998453040126e+12 }, { 16.625 , 7.343489788736144e+12 }, { 16.75 , 1.040060157339679e+13 }, { 16.875 , 1.474456239057157e+13 }, { 17.0 , 2.0922789888e+13 }, { 17.125 , 2.971792223970803e+13 }, { 17.25 , 4.224986665692704e+13 }, { 17.375 , 6.012253063177992e+13 }, { 17.5 , 8.563497447516206e+13 }, { 17.625 , 1.220855177377384e+14 }, { 17.75 , 1.742100763543963e+14 }, { 17.875 , 2.488144903408952e+14 }, { 18.0 , 3.55687428096e+14 }, { 18.125 , 5.08919418355e+14 }, { 18.25 , 7.288101998319914e+14 }, { 18.375 , 1.044628969727176e+15 }, { 18.5 , 1.498612053315336e+15 }, { 18.625 , 2.151757250127639e+15 }, { 18.75 , 3.092228855290534e+15 }, { 18.875 , 4.447559014843502e+15 }, { 19.0 , 6.402373705728e+15 }, { 19.125 , 9.224164457684374e+15 }, { 19.25 , 1.330078614693384e+16 }, { 19.375 , 1.919505731873686e+16 }, { 19.5 , 2.772432298633372e+16 }, { 19.625 , 4.007647878362728e+16 }, { 19.75 , 5.797929103669752e+16 }, { 19.875 , 8.39476764051711e+16 }, { 20.0 , 1.21645100408832e+17 }, { 20.5 , 5.406242982335075e+17 }, { 21.0 , 2.43290200817664e+18 }, { 21.5 , 1.10827981137869e+19 }, { 22.0 , 5.109094217170944e+19 }, { 22.5 , 2.382801594464184e+20 }, { 23.0 , 1.124000727777608e+21 }, { 23.5 , 5.361303587544415e+21 }, { 24.0 , 2.585201673888498e+22 }, { 24.5 , 1.259906343072938e+23 }, { 25.0 , 6.204484017332395e+23 }, { 25.5 , 3.086770540528697e+24 }, { 26.0 , 1.551121004333099e+25 }, { 26.5 , 7.871264878348176e+25 }, { 27.0 , 4.032914611266056e+26 }, { 27.5 , 2.085885192762267e+27 }, { 28.0 , 1.088886945041835e+28 }, { 28.5 , 5.736184280096234e+28 }, { 29.0 , 3.048883446117139e+29 }, { 29.5 , 1.634812519827427e+30 }, { 30.0 , 8.841761993739702e+30 }, { 30.5 , 4.822696933490909e+31 }, { 31.0 , 2.65252859812191e+32 }, { 31.5 , 1.470922564714727e+33 }, { 32.0 , 8.222838654177922e+33 }, { 32.5 , 4.633406078851391e+34 }, { 33.0 , 2.631308369336935e+35 }, { 33.5 , 1.505856975626702e+36 }, { 34.0 , 8.683317618811885e+36 }, { 34.5 , 5.044620868349451e+37 }, { 35.0 , 2.952327990396041e+38 }, { 35.5 , 1.740394199580561e+39 }, { 36.0 , 1.033314796638614e+40 }, { 36.5 , 6.178399408510991e+40 }, { 37.0 , 3.719933267899013e+41 }, { 37.5 , 2.255115784106512e+42 }, { 38.0 , 1.376375309122634e+43 }, { 38.5 , 8.456684190399419e+43 }, { 39.0 , 5.230226174666011e+44 }, { 39.5 , 3.255823413303776e+45 }, { 40.0 , 2.039788208119745e+46 }, { 40.5 , 1.286050248254992e+47 }, { 41.0 , 8.159152832478976e+47 }, { 41.5 , 5.208503505432716e+48 }, { 42.0 , 3.345252661316381e+49 }, { 42.5 , 2.161528954754577e+50 }, { 43.0 , 1.40500611775288e+51 }, { 43.5 , 9.186498057706953e+51 }, { 44.0 , 6.041526306337383e+52 }, { 44.5 , 3.996126655102524e+53 }, { 45.0 , 2.658271574788449e+54 }, { 45.5 , 1.778276361520623e+55 }, { 46.0 , 1.196222208654802e+56 }, { 46.5 , 8.091157444918836e+56 }, { 47.0 , 5.502622159812088e+57 }, { 47.5 , 3.762388211887259e+58 }, { 48.0 , 2.586232415111682e+59 }, { 48.5 , 1.787134400646448e+60 }, { 49.0 , 1.241391559253607e+61 }, { 49.5 , 8.667601843135273e+61 }, { 50.0 , 6.082818640342675e+62 }, { 50.5 , 4.290462912351959e+63 }, { 51.0 , 3.041409320171338e+64 }, { 51.5 , 2.16668377073774e+65 }, { 52.0 , 1.551118753287382e+66 }, { 52.5 , 1.115842141929936e+67 }, { 53.0 , 8.065817517094388e+67 }, { 53.5 , 5.858171245132164e+68 }, { 54.0 , 4.274883284060025e+69 }, { 54.5 , 3.134121616145708e+70 }, { 55.0 , 2.308436973392413e+71 }, { 55.5 , 1.70809628079941e+72 }, { 56.0 , 1.269640335365828e+73 }, { 56.5 , 9.479934358436728e+73 }, { 57.0 , 7.109985878048635e+74 }, { 57.5 , 5.356162912516752e+75 }, { 58.0 , 4.052691950487721e+76 }, { 58.5 , 3.079793674697132e+77 }, { 59.0 , 2.350561331282878e+78 }, { 59.5 , 1.801679299697822e+79 }, { 60.0 , 1.386831185456898e+80 }, { 60.5 , 1.071999183320204e+81 }, { 61.0 , 8.320987112741391e+81 }, { 61.5 , 6.485595059087236e+82 }, { 62.0 , 5.075802138772249e+83 }, { 62.5 , 3.98864096133865e+84 }, { 63.0 , 3.146997326038794e+85 }, { 63.5 , 2.492900600836656e+86 }, { 64.0 , 1.98260831540444e+87 }, { 64.5 , 1.582991881531277e+88 }, { 65.0 , 1.268869321858841e+89 }, { 65.5 , 1.021029763587673e+90 }, { 66.0 , 8.247650592082472e+90 }, { 66.5 , 6.687744951499262e+91 }, { 67.0 , 5.443449390774431e+92 }, { 67.5 , 4.447350392747009e+93 }, { 68.0 , 3.647111091818868e+94 }, { 68.5 , 3.001961515104231e+95 }, { 69.0 , 2.48003554243683e+96 }, { 69.5 , 2.056343637846398e+97 }, { 70.0 , 1.711224524281413e+98 }, { 70.5 , 1.429158828303247e+99 }, { 71.0 , 1.19785716699699e+100 }, { 71.5 , 1.00755697395379e+101 }, { 72.0 , 8.50478588567862e+101 }, { 72.5 , 7.20403236376959e+102 }, { 73.0 , 6.12344583768861e+103 }, { 73.5 , 5.22292346373295e+104 }, { 74.0 , 4.47011546151268e+105 }, { 74.5 , 3.83884874584372e+106 }, { 75.0 , 3.30788544151939e+107 }, { 75.5 , 2.85994231565357e+108 }, { 76.0 , 2.48091408113954e+109 }, { 76.5 , 2.15925644831845e+110 }, { 77.0 , 1.88549470166605e+111 }, { 77.5 , 1.65183118296361e+112 }, { 78.0 , 1.45183092028286e+113 }, { 78.5 , 1.2801691667968e+114 }, { 79.0 , 1.13242811782063e+115 }, { 79.5 , 1.00493279593549e+116 }, { 80.0 , 8.94618213078298e+116 }, { 80.5 , 7.98921572768712e+117 }, { 81.0 , 7.15694570462638e+118 }, { 81.5 , 6.43131866078814e+119 }, { 82.0 , 5.79712602074737e+120 }, { 82.5 , 5.24152470854233e+121 }, { 83.0 , 4.75364333701284e+122 }, { 83.5 , 4.32425788454742e+123 }, { 84.0 , 3.94552396972066e+124 }, { 84.5 , 3.6107553335971e+125 }, { 85.0 , 3.31424013456535e+126 }, { 85.5 , 3.05108825688955e+127 }, { 86.0 , 2.81710411438055e+128 }, { 86.5 , 2.60868045964056e+129 }, { 87.0 , 2.42270953836727e+130 }, { 87.5 , 2.25650859758909e+131 }, { 88.0 , 2.10775729837953e+132 }, { 88.5 , 1.97444502289045e+133 }, { 89.0 , 1.85482642257398e+134 }, { 89.5 , 1.74738384525805e+135 }, { 90.0 , 1.65079551609085e+136 }, { 90.5 , 1.56390854150595e+137 }, { 91.0 , 1.48571596448176e+138 }, { 91.5 , 1.41533723006289e+139 }, { 92.0 , 1.3520015276784e+140 }, { 92.5 , 1.29503356550754e+141 }, { 93.0 , 1.24384140546413e+142 }, { 93.5 , 1.19790604809448e+143 }, { 94.0 , 1.15677250708164e+144 }, { 94.5 , 1.12004215496834e+145 }, { 95.0 , 1.08736615665674e+146 }, { 95.5 , 1.05843983644508e+147 }, { 96.0 , 1.03299784882391e+148 }, { 96.5 , 1.01081004380505e+149 }, { 97.0 , 9.9167793487095e+149 }, { 97.5 , 9.75431692271873e+150 }, { 98.0 , 9.61927596824821e+151 }, { 98.5 , 9.51045899965076e+152 }, { 99.0 , 9.42689044888325e+153 }, { 99.5 , 9.367802114656e+154 }, { 100.0 , 9.33262154439441e+155 }, }; @Test public void testGamma() { for (int i = 0; i < GAMMA_REF.length; i++) { final double[] ref = GAMMA_REF[i]; final double x = ref[0]; final double expected = ref[1]; final double actual = Gamma.gamma(x); final double absX = FastMath.abs(x); final int ulps; if (absX <= 8.0) { ulps = 3; } else if (absX <= 20.0) { ulps = 5; } else if (absX <= 30.0) { ulps = 50; } else if (absX <= 50.0) { ulps = 180; } else { ulps = 500; } final double tol = ulps * FastMath.ulp(expected); Assert.assertEquals(Double.toString(x), expected, actual, tol); } } @Test public void testGammaNegativeInteger() { for (int i = -100; i <= 0; i++) { Assert.assertTrue(Integer.toString(i), Double.isNaN(Gamma.gamma(i))); } } private void checkRelativeError(String msg, double expected, double actual, double tolerance) { Assert.assertEquals(msg, expected, actual, FastMath.abs(tolerance * actual)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat; import java.io.BufferedReader; import java.io.InputStream; import java.io.InputStreamReader; import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics; import org.apache.commons.math3.stat.descriptive.SummaryStatistics; import org.junit.Assert; import org.junit.Test; /** * Certified data test cases. * @version $Id$ */ public class CertifiedDataTest { protected double mean = Double.NaN; protected double std = Double.NaN; /** * Test SummaryStatistics - implementations that do not store the data * and use single pass algorithms to compute statistics */ @Test public void testSummaryStatistics() throws Exception { SummaryStatistics u = new SummaryStatistics(); loadStats("data/PiDigits.txt", u); Assert.assertEquals("PiDigits: std", std, u.getStandardDeviation(), 1E-13); Assert.assertEquals("PiDigits: mean", mean, u.getMean(), 1E-13); loadStats("data/Mavro.txt", u); Assert.assertEquals("Mavro: std", std, u.getStandardDeviation(), 1E-14); Assert.assertEquals("Mavro: mean", mean, u.getMean(), 1E-14); loadStats("data/Michelso.txt", u); Assert.assertEquals("Michelso: std", std, u.getStandardDeviation(), 1E-13); Assert.assertEquals("Michelso: mean", mean, u.getMean(), 1E-13); loadStats("data/NumAcc1.txt", u); Assert.assertEquals("NumAcc1: std", std, u.getStandardDeviation(), 1E-14); Assert.assertEquals("NumAcc1: mean", mean, u.getMean(), 1E-14); loadStats("data/NumAcc2.txt", u); Assert.assertEquals("NumAcc2: std", std, u.getStandardDeviation(), 1E-14); Assert.assertEquals("NumAcc2: mean", mean, u.getMean(), 1E-14); } /** * Test DescriptiveStatistics - implementations that store full array of * values and execute multi-pass algorithms */ @Test public void testDescriptiveStatistics() throws Exception { DescriptiveStatistics u = new DescriptiveStatistics(); loadStats("data/PiDigits.txt", u); Assert.assertEquals("PiDigits: std", std, u.getStandardDeviation(), 1E-14); Assert.assertEquals("PiDigits: mean", mean, u.getMean(), 1E-14); loadStats("data/Mavro.txt", u); Assert.assertEquals("Mavro: std", std, u.getStandardDeviation(), 1E-14); Assert.assertEquals("Mavro: mean", mean, u.getMean(), 1E-14); loadStats("data/Michelso.txt", u); Assert.assertEquals("Michelso: std", std, u.getStandardDeviation(), 1E-14); Assert.assertEquals("Michelso: mean", mean, u.getMean(), 1E-14); loadStats("data/NumAcc1.txt", u); Assert.assertEquals("NumAcc1: std", std, u.getStandardDeviation(), 1E-14); Assert.assertEquals("NumAcc1: mean", mean, u.getMean(), 1E-14); loadStats("data/NumAcc2.txt", u); Assert.assertEquals("NumAcc2: std", std, u.getStandardDeviation(), 1E-14); Assert.assertEquals("NumAcc2: mean", mean, u.getMean(), 1E-14); } /** * loads a DescriptiveStatistics off of a test file * @param file * @param statistical summary */ private void loadStats(String resource, Object u) throws Exception { DescriptiveStatistics d = null; SummaryStatistics s = null; if (u instanceof DescriptiveStatistics) { d = (DescriptiveStatistics) u; } else { s = (SummaryStatistics) u; } u.getClass().getDeclaredMethod( "clear", new Class[]{}).invoke(u, new Object[]{}); mean = Double.NaN; std = Double.NaN; InputStream resourceAsStream = CertifiedDataTest.class.getResourceAsStream(resource); Assert.assertNotNull("Could not find resource "+resource,resourceAsStream); BufferedReader in = new BufferedReader( new InputStreamReader( resourceAsStream)); String line = null; for (int j = 0; j < 60; j++) { line = in.readLine(); if (j == 40) { mean = Double.parseDouble( line.substring(line.lastIndexOf(":") + 1).trim()); } if (j == 41) { std = Double.parseDouble( line.substring(line.lastIndexOf(":") + 1).trim()); } } line = in.readLine(); while (line != null) { if (d != null) { d.addValue(Double.parseDouble(line.trim())); } else { s.addValue(Double.parseDouble(line.trim())); } line = in.readLine(); } resourceAsStream.close(); in.close(); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat; import java.io.BufferedReader; import java.io.StringReader; import java.util.ArrayList; import java.util.Iterator; import java.util.List; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.junit.Assert; import org.junit.Before; import org.junit.Test; /** * Test cases for the {@link Frequency} class. * * @version $Id$ */ public final class FrequencyTest { private static final long ONE_LONG = 1L; private static final long TWO_LONG = 2L; private static final long THREE_LONG = 3L; private static final int ONE = 1; private static final int TWO = 2; private static final int THREEE = 3 ; private static final double TOLERANCE = 10E-15d; private Frequency f = null; @Before public void setUp() { f = new Frequency(); } /** test freq counts */ @Test public void testCounts() { Assert.assertEquals("total count",0,f.getSumFreq()); f.addValue(ONE_LONG); f.addValue(TWO_LONG); f.addValue(1); f.addValue(ONE); Assert.assertEquals("one frequency count",3,f.getCount(1)); Assert.assertEquals("two frequency count",1,f.getCount(2)); Assert.assertEquals("three frequency count",0,f.getCount(3)); Assert.assertEquals("total count",4,f.getSumFreq()); Assert.assertEquals("zero cumulative frequency", 0, f.getCumFreq(0)); Assert.assertEquals("one cumulative frequency", 3, f.getCumFreq(1)); Assert.assertEquals("two cumulative frequency", 4, f.getCumFreq(2)); Assert.assertEquals("Integer argument cum freq",4, f.getCumFreq(Integer.valueOf(2))); Assert.assertEquals("five cumulative frequency", 4, f.getCumFreq(5)); Assert.assertEquals("foo cumulative frequency", 0, f.getCumFreq("foo")); f.clear(); Assert.assertEquals("total count",0,f.getSumFreq()); // userguide examples ------------------------------------------------------------------- f.addValue("one"); f.addValue("One"); f.addValue("oNe"); f.addValue("Z"); Assert.assertEquals("one cumulative frequency", 1 , f.getCount("one")); Assert.assertEquals("Z cumulative pct", 0.5, f.getCumPct("Z"), TOLERANCE); Assert.assertEquals("z cumulative pct", 1.0, f.getCumPct("z"), TOLERANCE); Assert.assertEquals("Ot cumulative pct", 0.25, f.getCumPct("Ot"), TOLERANCE); f.clear(); f = null; Frequency f = new Frequency(); f.addValue(1); f.addValue(Integer.valueOf(1)); f.addValue(Long.valueOf(1)); f.addValue(2); f.addValue(Integer.valueOf(-1)); Assert.assertEquals("1 count", 3, f.getCount(1)); Assert.assertEquals("1 count", 3, f.getCount(Integer.valueOf(1))); Assert.assertEquals("0 cum pct", 0.2, f.getCumPct(0), TOLERANCE); Assert.assertEquals("1 pct", 0.6, f.getPct(Integer.valueOf(1)), TOLERANCE); Assert.assertEquals("-2 cum pct", 0, f.getCumPct(-2), TOLERANCE); Assert.assertEquals("10 cum pct", 1, f.getCumPct(10), TOLERANCE); f = null; f = new Frequency(String.CASE_INSENSITIVE_ORDER); f.addValue("one"); f.addValue("One"); f.addValue("oNe"); f.addValue("Z"); Assert.assertEquals("one count", 3 , f.getCount("one")); Assert.assertEquals("Z cumulative pct -- case insensitive", 1 , f.getCumPct("Z"), TOLERANCE); Assert.assertEquals("z cumulative pct -- case insensitive", 1 , f.getCumPct("z"), TOLERANCE); f = null; f = new Frequency(); Assert.assertEquals(0L, f.getCount('a')); Assert.assertEquals(0L, f.getCumFreq('b')); TestUtils.assertEquals(Double.NaN, f.getPct('a'), 0.0); TestUtils.assertEquals(Double.NaN, f.getCumPct('b'), 0.0); f.addValue('a'); f.addValue('b'); f.addValue('c'); f.addValue('d'); Assert.assertEquals(1L, f.getCount('a')); Assert.assertEquals(2L, f.getCumFreq('b')); Assert.assertEquals(0.25, f.getPct('a'), 0.0); Assert.assertEquals(0.5, f.getCumPct('b'), 0.0); Assert.assertEquals(1.0, f.getCumPct('e'), 0.0); } /** test pcts */ @Test public void testPcts() { f.addValue(ONE_LONG); f.addValue(TWO_LONG); f.addValue(ONE); f.addValue(TWO); f.addValue(THREE_LONG); f.addValue(THREE_LONG); f.addValue(3); f.addValue(THREEE); Assert.assertEquals("one pct",0.25,f.getPct(1),TOLERANCE); Assert.assertEquals("two pct",0.25,f.getPct(Long.valueOf(2)),TOLERANCE); Assert.assertEquals("three pct",0.5,f.getPct(THREE_LONG),TOLERANCE); Assert.assertEquals("five pct",0,f.getPct(5),TOLERANCE); Assert.assertEquals("foo pct",0,f.getPct("foo"),TOLERANCE); Assert.assertEquals("one cum pct",0.25,f.getCumPct(1),TOLERANCE); Assert.assertEquals("two cum pct",0.50,f.getCumPct(Long.valueOf(2)),TOLERANCE); Assert.assertEquals("Integer argument",0.50,f.getCumPct(Integer.valueOf(2)),TOLERANCE); Assert.assertEquals("three cum pct",1.0,f.getCumPct(THREE_LONG),TOLERANCE); Assert.assertEquals("five cum pct",1.0,f.getCumPct(5),TOLERANCE); Assert.assertEquals("zero cum pct",0.0,f.getCumPct(0),TOLERANCE); Assert.assertEquals("foo cum pct",0,f.getCumPct("foo"),TOLERANCE); } /** test adding incomparable values */ @Test public void testAdd() { char aChar = 'a'; char bChar = 'b'; String aString = "a"; f.addValue(aChar); f.addValue(bChar); try { f.addValue(aString); Assert.fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } try { f.addValue(2); Assert.fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } Assert.assertEquals("a pct",0.5,f.getPct(aChar),TOLERANCE); Assert.assertEquals("b cum pct",1.0,f.getCumPct(bChar),TOLERANCE); Assert.assertEquals("a string pct",0.0,f.getPct(aString),TOLERANCE); Assert.assertEquals("a string cum pct",0.0,f.getCumPct(aString),TOLERANCE); f = new Frequency(); f.addValue("One"); try { f.addValue(new Integer("One")); Assert.fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } } /** test empty table */ @Test public void testEmptyTable() { Assert.assertEquals("freq sum, empty table", 0, f.getSumFreq()); Assert.assertEquals("count, empty table", 0, f.getCount(0)); Assert.assertEquals("count, empty table",0, f.getCount(Integer.valueOf(0))); Assert.assertEquals("cum freq, empty table", 0, f.getCumFreq(0)); Assert.assertEquals("cum freq, empty table", 0, f.getCumFreq("x")); Assert.assertTrue("pct, empty table", Double.isNaN(f.getPct(0))); Assert.assertTrue("pct, empty table", Double.isNaN(f.getPct(Integer.valueOf(0)))); Assert.assertTrue("cum pct, empty table", Double.isNaN(f.getCumPct(0))); Assert.assertTrue("cum pct, empty table", Double.isNaN(f.getCumPct(Integer.valueOf(0)))); } @Test public void testNonComparableCumPct() { f.addValue("a"); Assert.assertEquals("cum freq, single entry", 1.0d, f.getCumPct("a"),TOLERANCE); Assert.assertEquals("cum freq, single entry non comparable", 0.0d, f.getCumPct(100),TOLERANCE); } @Test public void testNonComparablePct() { f.addValue("a"); Assert.assertEquals("cum freq, single entry", 1.0d, f.getPct("a"),TOLERANCE); Assert.assertEquals("cum freq, single entry non comparable", 0.0d, f.getPct(100),TOLERANCE); } /** * Tests toString() */ @Test public void testToString() throws Exception { f.addValue(ONE_LONG); f.addValue(TWO_LONG); f.addValue(ONE); f.addValue(TWO); String s = f.toString(); //System.out.println(s); Assert.assertNotNull(s); BufferedReader reader = new BufferedReader(new StringReader(s)); String line = reader.readLine(); // header line Assert.assertNotNull(line); line = reader.readLine(); // one's or two's line Assert.assertNotNull(line); line = reader.readLine(); // one's or two's line Assert.assertNotNull(line); line = reader.readLine(); // no more elements Assert.assertNull(line); } @Test public void testIntegerValues() { Comparable<?> obj1 = null; obj1 = Integer.valueOf(1); Integer int1 = Integer.valueOf(1); f.addValue(obj1); f.addValue(int1); f.addValue(2); f.addValue(Long.valueOf(2)); Assert.assertEquals("Integer 1 count", 2, f.getCount(1)); Assert.assertEquals("Integer 1 count", 2, f.getCount(Integer.valueOf(1))); Assert.assertEquals("Integer 1 count", 2, f.getCount(Long.valueOf(1))); Assert.assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(1), TOLERANCE); Assert.assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(Long.valueOf(1)), TOLERANCE); Assert.assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(Integer.valueOf(1)), TOLERANCE); Iterator<?> it = f.valuesIterator(); while (it.hasNext()) { Assert.assertTrue(it.next() instanceof Long); } } @Test public void testSerial() { f.addValue(ONE_LONG); f.addValue(TWO_LONG); f.addValue(ONE); f.addValue(TWO); Assert.assertEquals(f, TestUtils.serializeAndRecover(f)); } @Test public void testGetUniqueCount() { Assert.assertEquals(0, f.getUniqueCount()); f.addValue(ONE_LONG); Assert.assertEquals(1, f.getUniqueCount()); f.addValue(ONE_LONG); Assert.assertEquals(1, f.getUniqueCount()); f.addValue(TWO); Assert.assertEquals(2, f.getUniqueCount()); } @Test public void testIncrement() { Assert.assertEquals(0, f.getUniqueCount()); f.incrementValue(ONE_LONG, 1); Assert.assertEquals(1, f.getCount(ONE_LONG)); f.incrementValue(ONE_LONG, 4); Assert.assertEquals(5, f.getCount(ONE_LONG)); f.incrementValue(ONE_LONG, -5); Assert.assertEquals(0, f.getCount(ONE_LONG)); } @Test public void testMerge() { Assert.assertEquals(0, f.getUniqueCount()); f.addValue(ONE_LONG); f.addValue(TWO_LONG); f.addValue(ONE); f.addValue(TWO); Assert.assertEquals(2, f.getUniqueCount()); Assert.assertEquals(2, f.getCount(ONE)); Assert.assertEquals(2, f.getCount(TWO)); Frequency g = new Frequency(); g.addValue(ONE_LONG); g.addValue(THREE_LONG); g.addValue(THREEE); Assert.assertEquals(2, g.getUniqueCount()); Assert.assertEquals(1, g.getCount(ONE)); Assert.assertEquals(2, g.getCount(THREEE)); f.merge(g); Assert.assertEquals(3, f.getUniqueCount()); Assert.assertEquals(3, f.getCount(ONE)); Assert.assertEquals(2, f.getCount(TWO)); Assert.assertEquals(2, f.getCount(THREEE)); } @Test public void testMergeCollection() { Assert.assertEquals(0, f.getUniqueCount()); f.addValue(ONE_LONG); Assert.assertEquals(1, f.getUniqueCount()); Assert.assertEquals(1, f.getCount(ONE)); Assert.assertEquals(0, f.getCount(TWO)); Frequency g = new Frequency(); g.addValue(TWO_LONG); Frequency h = new Frequency(); h.addValue(THREE_LONG); List<Frequency> coll = new ArrayList<Frequency>(); coll.add(g); coll.add(h); f.merge(coll); Assert.assertEquals(3, f.getUniqueCount()); Assert.assertEquals(1, f.getCount(ONE)); Assert.assertEquals(1, f.getCount(TWO)); Assert.assertEquals(1, f.getCount(THREEE)); } @Test public void testMode() { List<Comparable<?>> mode; mode = f.getMode(); Assert.assertEquals(0, mode.size()); f.addValue("3"); mode = f.getMode(); Assert.assertEquals(1, mode.size()); Assert.assertEquals("3", mode.get(0)); f.addValue("2"); mode = f.getMode(); Assert.assertEquals(2, mode.size()); Assert.assertEquals("2", mode.get(0)); Assert.assertEquals("3",mode.get(1)); f.addValue("2"); mode = f.getMode(); Assert.assertEquals(1, mode.size()); Assert.assertEquals("2", mode.get(0)); Assert.assertFalse(mode.contains("1")); Assert.assertTrue(mode.contains("2")); try { f.addValue(Double.valueOf(Double.NaN)); Assert.fail("Expected MathIllegalArgumentException"); } catch (MathIllegalArgumentException e) { // expected } } @Test public void testModeDoubleNan() { List<Comparable<?>> mode; f.addValue(Double.valueOf(Double.NaN)); f.addValue(Double.valueOf(Double.NaN)); f.addValue(Double.valueOf(Double.NaN)); f.addValue(Double.valueOf(Double.NEGATIVE_INFINITY)); f.addValue(Double.valueOf(Double.POSITIVE_INFINITY)); f.addValue(Double.valueOf(Double.NEGATIVE_INFINITY)); f.addValue(Double.valueOf(Double.POSITIVE_INFINITY)); f.addValue(Double.valueOf(Double.NEGATIVE_INFINITY)); f.addValue(Double.valueOf(Double.POSITIVE_INFINITY)); mode = f.getMode(); Assert.assertEquals(3, mode.size()); Assert.assertEquals(Double.valueOf(Double.NEGATIVE_INFINITY), mode.get(0)); Assert.assertEquals(Double.valueOf(Double.POSITIVE_INFINITY), mode.get(1)); Assert.assertEquals(Double.valueOf(Double.NaN), mode.get(2)); try { f.addValue(Float.valueOf(Float.NaN)); Assert.fail("Expected MathIllegalArgumentException"); } catch (MathIllegalArgumentException e) { // expected } } @Test public void testModeFloatNan() { List<Comparable<?>> mode; f.addValue(Float.valueOf(Float.NaN)); f.addValue(Float.valueOf(Float.NaN)); f.addValue(Float.valueOf(Float.NaN)); f.addValue(Float.valueOf(Float.NEGATIVE_INFINITY)); f.addValue(Float.valueOf(Float.POSITIVE_INFINITY)); f.addValue(Float.valueOf(Float.NEGATIVE_INFINITY)); f.addValue(Float.valueOf(Float.POSITIVE_INFINITY)); f.addValue(Float.valueOf(Float.NEGATIVE_INFINITY)); f.addValue(Float.valueOf(Float.POSITIVE_INFINITY)); mode = f.getMode(); Assert.assertEquals(3, mode.size()); Assert.assertEquals(Float.valueOf(Float.NEGATIVE_INFINITY), mode.get(0)); Assert.assertEquals(Float.valueOf(Float.POSITIVE_INFINITY), mode.get(1)); Assert.assertEquals(Float.valueOf(Float.NaN), mode.get(2)); try { f.addValue(Double.valueOf(Double.NaN)); Assert.fail("Expected MathIllegalArgumentException"); } catch (MathIllegalArgumentException e) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.util.Precision; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.junit.Assert; import org.junit.Test; /** * Test cases for the {@link StatUtils} class. * @version $Id$ */ public final class StatUtilsTest { private static final double ONE = 1; private static final float TWO = 2; private static final int THREE = 3; private static final double MEAN = 2; private static final double SUMSQ = 18; private static final double SUM = 8; private static final double VAR = 0.666666666666666666667; private static final double MIN = 1; private static final double MAX = 3; private static final double TOLERANCE = 10E-15; private static final double NAN = Double.NaN; /** test stats */ @Test public void testStats() { double[] values = new double[] { ONE, TWO, TWO, THREE }; Assert.assertEquals("sum", SUM, StatUtils.sum(values), TOLERANCE); Assert.assertEquals("sumsq", SUMSQ, StatUtils.sumSq(values), TOLERANCE); Assert.assertEquals("var", VAR, StatUtils.variance(values), TOLERANCE); Assert.assertEquals("var with mean", VAR, StatUtils.variance(values, MEAN), TOLERANCE); Assert.assertEquals("mean", MEAN, StatUtils.mean(values), TOLERANCE); Assert.assertEquals("min", MIN, StatUtils.min(values), TOLERANCE); Assert.assertEquals("max", MAX, StatUtils.max(values), TOLERANCE); } @Test public void testN0andN1Conditions() { double[] values = new double[0]; Assert.assertTrue( "Mean of n = 0 set should be NaN", Double.isNaN(StatUtils.mean(values))); Assert.assertTrue( "Variance of n = 0 set should be NaN", Double.isNaN(StatUtils.variance(values))); values = new double[] { ONE }; Assert.assertTrue( "Mean of n = 1 set should be value of single item n1", StatUtils.mean(values) == ONE); Assert.assertTrue( "Variance of n = 1 set should be zero", StatUtils.variance(values) == 0); } @Test public void testArrayIndexConditions() { double[] values = { 1.0, 2.0, 3.0, 4.0 }; Assert.assertEquals( "Sum not expected", 5.0, StatUtils.sum(values, 1, 2), Double.MIN_VALUE); Assert.assertEquals( "Sum not expected", 3.0, StatUtils.sum(values, 0, 2), Double.MIN_VALUE); Assert.assertEquals( "Sum not expected", 7.0, StatUtils.sum(values, 2, 2), Double.MIN_VALUE); try { StatUtils.sum(values, 2, 3); Assert.fail("Expected RuntimeException"); } catch (RuntimeException e) { // expected } try { StatUtils.sum(values, -1, 2); Assert.fail("Expected RuntimeException"); } catch (RuntimeException e) { // expected } } @Test public void testSumSq() { double[] x = null; // test null try { StatUtils.sumSq(x); Assert.fail("null is not a valid data array."); } catch (MathIllegalArgumentException ex) { // success } try { StatUtils.sumSq(x, 0, 4); Assert.fail("null is not a valid data array."); } catch (MathIllegalArgumentException ex) { // success } // test empty x = new double[] {}; TestUtils.assertEquals(0, StatUtils.sumSq(x), TOLERANCE); TestUtils.assertEquals(0, StatUtils.sumSq(x, 0, 0), TOLERANCE); // test one x = new double[] {TWO}; TestUtils.assertEquals(4, StatUtils.sumSq(x), TOLERANCE); TestUtils.assertEquals(4, StatUtils.sumSq(x, 0, 1), TOLERANCE); // test many x = new double[] {ONE, TWO, TWO, THREE}; TestUtils.assertEquals(18, StatUtils.sumSq(x), TOLERANCE); TestUtils.assertEquals(8, StatUtils.sumSq(x, 1, 2), TOLERANCE); } @Test public void testProduct() { double[] x = null; // test null try { StatUtils.product(x); Assert.fail("null is not a valid data array."); } catch (MathIllegalArgumentException ex) { // success } try { StatUtils.product(x, 0, 4); Assert.fail("null is not a valid data array."); } catch (MathIllegalArgumentException ex) { // success } // test empty x = new double[] {}; TestUtils.assertEquals(1, StatUtils.product(x), TOLERANCE); TestUtils.assertEquals(1, StatUtils.product(x, 0, 0), TOLERANCE); // test one x = new double[] {TWO}; TestUtils.assertEquals(TWO, StatUtils.product(x), TOLERANCE); TestUtils.assertEquals(TWO, StatUtils.product(x, 0, 1), TOLERANCE); // test many x = new double[] {ONE, TWO, TWO, THREE}; TestUtils.assertEquals(12, StatUtils.product(x), TOLERANCE); TestUtils.assertEquals(4, StatUtils.product(x, 1, 2), TOLERANCE); } @Test public void testSumLog() { double[] x = null; // test null try { StatUtils.sumLog(x); Assert.fail("null is not a valid data array."); } catch (MathIllegalArgumentException ex) { // success } try { StatUtils.sumLog(x, 0, 4); Assert.fail("null is not a valid data array."); } catch (MathIllegalArgumentException ex) { // success } // test empty x = new double[] {}; TestUtils.assertEquals(0, StatUtils.sumLog(x), TOLERANCE); TestUtils.assertEquals(0, StatUtils.sumLog(x, 0, 0), TOLERANCE); // test one x = new double[] {TWO}; TestUtils.assertEquals(FastMath.log(TWO), StatUtils.sumLog(x), TOLERANCE); TestUtils.assertEquals(FastMath.log(TWO), StatUtils.sumLog(x, 0, 1), TOLERANCE); // test many x = new double[] {ONE, TWO, TWO, THREE}; TestUtils.assertEquals(FastMath.log(ONE) + 2.0 * FastMath.log(TWO) + FastMath.log(THREE), StatUtils.sumLog(x), TOLERANCE); TestUtils.assertEquals(2.0 * FastMath.log(TWO), StatUtils.sumLog(x, 1, 2), TOLERANCE); } @Test public void testMean() { double[] x = null; try { StatUtils.mean(x, 0, 4); Assert.fail("null is not a valid data array."); } catch (MathIllegalArgumentException ex) { // success } // test empty x = new double[] {}; TestUtils.assertEquals(Double.NaN, StatUtils.mean(x, 0, 0), TOLERANCE); // test one x = new double[] {TWO}; TestUtils.assertEquals(TWO, StatUtils.mean(x, 0, 1), TOLERANCE); // test many x = new double[] {ONE, TWO, TWO, THREE}; TestUtils.assertEquals(2.5, StatUtils.mean(x, 2, 2), TOLERANCE); } @Test public void testVariance() { double[] x = null; try { StatUtils.variance(x, 0, 4); Assert.fail("null is not a valid data array."); } catch (MathIllegalArgumentException ex) { // success } // test empty x = new double[] {}; TestUtils.assertEquals(Double.NaN, StatUtils.variance(x, 0, 0), TOLERANCE); // test one x = new double[] {TWO}; TestUtils.assertEquals(0.0, StatUtils.variance(x, 0, 1), TOLERANCE); // test many x = new double[] {ONE, TWO, TWO, THREE}; TestUtils.assertEquals(0.5, StatUtils.variance(x, 2, 2), TOLERANCE); // test precomputed mean x = new double[] {ONE, TWO, TWO, THREE}; TestUtils.assertEquals(0.5, StatUtils.variance(x,2.5, 2, 2), TOLERANCE); } @Test public void testPopulationVariance() { double[] x = null; try { StatUtils.variance(x, 0, 4); Assert.fail("null is not a valid data array."); } catch (MathIllegalArgumentException ex) { // success } // test empty x = new double[] {}; TestUtils.assertEquals(Double.NaN, StatUtils.populationVariance(x, 0, 0), TOLERANCE); // test one x = new double[] {TWO}; TestUtils.assertEquals(0.0, StatUtils.populationVariance(x, 0, 1), TOLERANCE); // test many x = new double[] {ONE, TWO, TWO, THREE}; TestUtils.assertEquals(0.25, StatUtils.populationVariance(x, 0, 2), TOLERANCE); // test precomputed mean x = new double[] {ONE, TWO, TWO, THREE}; TestUtils.assertEquals(0.25, StatUtils.populationVariance(x, 2.5, 2, 2), TOLERANCE); } @Test public void testMax() { double[] x = null; try { StatUtils.max(x, 0, 4); Assert.fail("null is not a valid data array."); } catch (MathIllegalArgumentException ex) { // success } // test empty x = new double[] {}; TestUtils.assertEquals(Double.NaN, StatUtils.max(x, 0, 0), TOLERANCE); // test one x = new double[] {TWO}; TestUtils.assertEquals(TWO, StatUtils.max(x, 0, 1), TOLERANCE); // test many x = new double[] {ONE, TWO, TWO, THREE}; TestUtils.assertEquals(THREE, StatUtils.max(x, 1, 3), TOLERANCE); // test first nan is ignored x = new double[] {NAN, TWO, THREE}; TestUtils.assertEquals(THREE, StatUtils.max(x), TOLERANCE); // test middle nan is ignored x = new double[] {ONE, NAN, THREE}; TestUtils.assertEquals(THREE, StatUtils.max(x), TOLERANCE); // test last nan is ignored x = new double[] {ONE, TWO, NAN}; TestUtils.assertEquals(TWO, StatUtils.max(x), TOLERANCE); // test all nan returns nan x = new double[] {NAN, NAN, NAN}; TestUtils.assertEquals(NAN, StatUtils.max(x), TOLERANCE); } @Test public void testMin() { double[] x = null; try { StatUtils.min(x, 0, 4); Assert.fail("null is not a valid data array."); } catch (MathIllegalArgumentException ex) { // success } // test empty x = new double[] {}; TestUtils.assertEquals(Double.NaN, StatUtils.min(x, 0, 0), TOLERANCE); // test one x = new double[] {TWO}; TestUtils.assertEquals(TWO, StatUtils.min(x, 0, 1), TOLERANCE); // test many x = new double[] {ONE, TWO, TWO, THREE}; TestUtils.assertEquals(TWO, StatUtils.min(x, 1, 3), TOLERANCE); // test first nan is ignored x = new double[] {NAN, TWO, THREE}; TestUtils.assertEquals(TWO, StatUtils.min(x), TOLERANCE); // test middle nan is ignored x = new double[] {ONE, NAN, THREE}; TestUtils.assertEquals(ONE, StatUtils.min(x), TOLERANCE); // test last nan is ignored x = new double[] {ONE, TWO, NAN}; TestUtils.assertEquals(ONE, StatUtils.min(x), TOLERANCE); // test all nan returns nan x = new double[] {NAN, NAN, NAN}; TestUtils.assertEquals(NAN, StatUtils.min(x), TOLERANCE); } @Test public void testPercentile() { double[] x = null; // test null try { StatUtils.percentile(x, .25); Assert.fail("null is not a valid data array."); } catch (MathIllegalArgumentException ex) { // success } try { StatUtils.percentile(x, 0, 4, 0.25); Assert.fail("null is not a valid data array."); } catch (MathIllegalArgumentException ex) { // success } // test empty x = new double[] {}; TestUtils.assertEquals(Double.NaN, StatUtils.percentile(x, 25), TOLERANCE); TestUtils.assertEquals(Double.NaN, StatUtils.percentile(x, 0, 0, 25), TOLERANCE); // test one x = new double[] {TWO}; TestUtils.assertEquals(TWO, StatUtils.percentile(x, 25), TOLERANCE); TestUtils.assertEquals(TWO, StatUtils.percentile(x, 0, 1, 25), TOLERANCE); // test many x = new double[] {ONE, TWO, TWO, THREE}; TestUtils.assertEquals(2.5, StatUtils.percentile(x, 70), TOLERANCE); TestUtils.assertEquals(2.5, StatUtils.percentile(x, 1, 3, 62.5), TOLERANCE); } @Test public void testDifferenceStats() { double sample1[] = {1d, 2d, 3d, 4d}; double sample2[] = {1d, 3d, 4d, 2d}; double diff[] = {0d, -1d, -1d, 2d}; double small[] = {1d, 4d}; double meanDifference = StatUtils.meanDifference(sample1, sample2); Assert.assertEquals(StatUtils.sumDifference(sample1, sample2), StatUtils.sum(diff), TOLERANCE); Assert.assertEquals(meanDifference, StatUtils.mean(diff), TOLERANCE); Assert.assertEquals(StatUtils.varianceDifference(sample1, sample2, meanDifference), StatUtils.variance(diff), TOLERANCE); try { StatUtils.meanDifference(sample1, small); Assert.fail("Expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // expected } try { StatUtils.varianceDifference(sample1, small, meanDifference); Assert.fail("Expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // expected } try { double[] single = {1.0}; StatUtils.varianceDifference(single, single, meanDifference); Assert.fail("Expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // expected } } @Test public void testGeometricMean() { double[] test = null; try { StatUtils.geometricMean(test); Assert.fail("Expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // expected } test = new double[] {2, 4, 6, 8}; Assert.assertEquals(FastMath.exp(0.25d * StatUtils.sumLog(test)), StatUtils.geometricMean(test), Double.MIN_VALUE); Assert.assertEquals(FastMath.exp(0.5 * StatUtils.sumLog(test, 0, 2)), StatUtils.geometricMean(test, 0, 2), Double.MIN_VALUE); } /** * Run the test with the values 50 and 100 and assume standardized values */ @Test public void testNormalize1() { double sample[] = { 50, 100 }; double expectedSample[] = { -25 / Math.sqrt(1250), 25 / Math.sqrt(1250) }; double[] out = StatUtils.normalize(sample); for (int i = 0; i < out.length; i++) { Assert.assertTrue(Precision.equals(out[i], expectedSample[i], 1)); } } /** * Run with 77 random values, assuming that the outcome has a mean of 0 and a standard deviation of 1 with a * precision of 1E-10. */ @Test public void testNormalize2() { // create an sample with 77 values int length = 77; double sample[] = new double[length]; for (int i = 0; i < length; i++) { sample[i] = Math.random(); } // normalize this sample double standardizedSample[] = StatUtils.normalize(sample); DescriptiveStatistics stats = new DescriptiveStatistics(); // Add the data from the array for (int i = 0; i < length; i++) { stats.addValue(standardizedSample[i]); } // the calculations do have a limited precision double distance = 1E-10; // check the mean an standard deviation Assert.assertEquals(0.0, stats.getMean(), distance); Assert.assertEquals(1.0, stats.getStandardDeviation(), distance); } @Test public void testMode() { final double[] singleMode = {0, 1, 0, 2, 7, 11, 12}; final double[] modeSingle = StatUtils.mode(singleMode); Assert.assertEquals(0, modeSingle[0], Double.MIN_VALUE); Assert.assertEquals(1, modeSingle.length); final double[] twoMode = {0, 1, 2, 0, 2, 3, 7, 11}; final double[] modeDouble = StatUtils.mode(twoMode); Assert.assertEquals(0, modeDouble[0], Double.MIN_VALUE); Assert.assertEquals(2, modeDouble[1], Double.MIN_VALUE); Assert.assertEquals(2, modeDouble.length); final double[] nanInfested = {0, 0, 0, Double.NaN, Double.NaN, Double.NaN, Double.NaN, 2, 2, 2, 3, 5}; final double[] modeNan = StatUtils.mode(nanInfested); Assert.assertEquals(0, modeNan[0], Double.MIN_VALUE); Assert.assertEquals(2, modeNan[1], Double.MIN_VALUE); Assert.assertEquals(2, modeNan.length); final double[] infInfested = {0, 0, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 2, 2, 3, 5}; final double[] modeInf = StatUtils.mode(infInfested); Assert.assertEquals(Double.NEGATIVE_INFINITY, modeInf[0], Double.MIN_VALUE); Assert.assertEquals(0, modeInf[1], Double.MIN_VALUE); Assert.assertEquals(2, modeInf[2], Double.MIN_VALUE); Assert.assertEquals(Double.POSITIVE_INFINITY, modeInf[3], Double.MIN_VALUE); Assert.assertEquals(4, modeInf.length); final double[] noData = {}; final double[] modeNodata = StatUtils.mode(noData); Assert.assertEquals(0, modeNodata.length); final double[] nansOnly = {Double.NaN, Double.NaN}; final double[] modeNansOnly = StatUtils.mode(nansOnly); Assert.assertEquals(0, modeNansOnly.length); final double[] nullArray = null; try { StatUtils.mode(nullArray); Assert.fail("Expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // Expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.clustering; import java.util.Arrays; import java.util.List; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.exception.NullArgumentException; import org.junit.Assert; import org.junit.Test; public class DBSCANClustererTest { @Test public void testCluster() { // Test data generated using: http://people.cs.nctu.edu.tw/~rsliang/dbscan/testdatagen.html final EuclideanDoublePoint[] points = new EuclideanDoublePoint[] { new EuclideanDoublePoint(new double[] { 83.08303244924173, 58.83387754182331 }), new EuclideanDoublePoint(new double[] { 45.05445510940626, 23.469642649637535 }), new EuclideanDoublePoint(new double[] { 14.96417921432294, 69.0264096390456 }), new EuclideanDoublePoint(new double[] { 73.53189604333602, 34.896145021310076 }), new EuclideanDoublePoint(new double[] { 73.28498173551634, 33.96860806993209 }), new EuclideanDoublePoint(new double[] { 73.45828098873608, 33.92584423092194 }), new EuclideanDoublePoint(new double[] { 73.9657889183145, 35.73191006924026 }), new EuclideanDoublePoint(new double[] { 74.0074097183533, 36.81735596177168 }), new EuclideanDoublePoint(new double[] { 73.41247541410848, 34.27314856695011 }), new EuclideanDoublePoint(new double[] { 73.9156256353017, 36.83206791547127 }), new EuclideanDoublePoint(new double[] { 74.81499205809087, 37.15682749846019 }), new EuclideanDoublePoint(new double[] { 74.03144880081527, 37.57399178552441 }), new EuclideanDoublePoint(new double[] { 74.51870941207744, 38.674258946906775 }), new EuclideanDoublePoint(new double[] { 74.50754595105536, 35.58903978415765 }), new EuclideanDoublePoint(new double[] { 74.51322752749547, 36.030572259100154 }), new EuclideanDoublePoint(new double[] { 59.27900996617973, 46.41091720294207 }), new EuclideanDoublePoint(new double[] { 59.73744793841615, 46.20015558367595 }), new EuclideanDoublePoint(new double[] { 58.81134076672606, 45.71150126331486 }), new EuclideanDoublePoint(new double[] { 58.52225539437495, 47.416083617601544 }), new EuclideanDoublePoint(new double[] { 58.218626647023484, 47.36228902172297 }), new EuclideanDoublePoint(new double[] { 60.27139669447206, 46.606106348801404 }), new EuclideanDoublePoint(new double[] { 60.894962462363765, 46.976924697402865 }), new EuclideanDoublePoint(new double[] { 62.29048673878424, 47.66970563563518 }), new EuclideanDoublePoint(new double[] { 61.03857608977705, 46.212924720020965 }), new EuclideanDoublePoint(new double[] { 60.16916214139201, 45.18193661351688 }), new EuclideanDoublePoint(new double[] { 59.90036905976012, 47.555364347063005 }), new EuclideanDoublePoint(new double[] { 62.33003634144552, 47.83941489877179 }), new EuclideanDoublePoint(new double[] { 57.86035536718555, 47.31117930193432 }), new EuclideanDoublePoint(new double[] { 58.13715479685925, 48.985960494028404 }), new EuclideanDoublePoint(new double[] { 56.131923963548616, 46.8508904252667 }), new EuclideanDoublePoint(new double[] { 55.976329887053, 47.46384037658572 }), new EuclideanDoublePoint(new double[] { 56.23245975235477, 47.940035191131756 }), new EuclideanDoublePoint(new double[] { 58.51687048212625, 46.622885352699086 }), new EuclideanDoublePoint(new double[] { 57.85411081905477, 45.95394361577928 }), new EuclideanDoublePoint(new double[] { 56.445776311447844, 45.162093662656844 }), new EuclideanDoublePoint(new double[] { 57.36691949656233, 47.50097194337286 }), new EuclideanDoublePoint(new double[] { 58.243626387557015, 46.114052729681134 }), new EuclideanDoublePoint(new double[] { 56.27224595635198, 44.799080066150054 }), new EuclideanDoublePoint(new double[] { 57.606924816500396, 46.94291057763621 }), new EuclideanDoublePoint(new double[] { 30.18714230041951, 13.877149710431695 }), new EuclideanDoublePoint(new double[] { 30.449448810657486, 13.490778346545994 }), new EuclideanDoublePoint(new double[] { 30.295018390286714, 13.264889000216499 }), new EuclideanDoublePoint(new double[] { 30.160201832884923, 11.89278262341395 }), new EuclideanDoublePoint(new double[] { 31.341509791789576, 15.282655921997502 }), new EuclideanDoublePoint(new double[] { 31.68601630325429, 14.756873246748 }), new EuclideanDoublePoint(new double[] { 29.325963742565364, 12.097849250072613 }), new EuclideanDoublePoint(new double[] { 29.54820742388256, 13.613295356975868 }), new EuclideanDoublePoint(new double[] { 28.79359608888626, 10.36352064087987 }), new EuclideanDoublePoint(new double[] { 31.01284597092308, 12.788479208014905 }), new EuclideanDoublePoint(new double[] { 27.58509216737002, 11.47570110601373 }), new EuclideanDoublePoint(new double[] { 28.593799561727792, 10.780998203903437 }), new EuclideanDoublePoint(new double[] { 31.356105766724795, 15.080316198524088 }), new EuclideanDoublePoint(new double[] { 31.25948503636755, 13.674329151166603 }), new EuclideanDoublePoint(new double[] { 32.31590076372959, 14.95261758659035 }), new EuclideanDoublePoint(new double[] { 30.460413702763617, 15.88402809202671 }), new EuclideanDoublePoint(new double[] { 32.56178203062154, 14.586076852632686 }), new EuclideanDoublePoint(new double[] { 32.76138648530468, 16.239837325178087 }), new EuclideanDoublePoint(new double[] { 30.1829453331884, 14.709592407103628 }), new EuclideanDoublePoint(new double[] { 29.55088173528202, 15.0651247180067 }), new EuclideanDoublePoint(new double[] { 29.004155302187428, 14.089665298582986 }), new EuclideanDoublePoint(new double[] { 29.339624439831823, 13.29096065578051 }), new EuclideanDoublePoint(new double[] { 30.997460327576846, 14.551914158277214 }), new EuclideanDoublePoint(new double[] { 30.66784126125276, 16.269703107886016 }) }; final DBSCANClusterer<EuclideanDoublePoint> transformer = new DBSCANClusterer<EuclideanDoublePoint>(2.0, 5); final List<Cluster<EuclideanDoublePoint>> clusters = transformer.cluster(Arrays.asList(points)); final List<EuclideanDoublePoint> clusterOne = Arrays.asList(points[3], points[4], points[5], points[6], points[7], points[8], points[9], points[10], points[11], points[12], points[13], points[14]); final List<EuclideanDoublePoint> clusterTwo = Arrays.asList(points[15], points[16], points[17], points[18], points[19], points[20], points[21], points[22], points[23], points[24], points[25], points[26], points[27], points[28], points[29], points[30], points[31], points[32], points[33], points[34], points[35], points[36], points[37], points[38]); final List<EuclideanDoublePoint> clusterThree = Arrays.asList(points[39], points[40], points[41], points[42], points[43], points[44], points[45], points[46], points[47], points[48], points[49], points[50], points[51], points[52], points[53], points[54], points[55], points[56], points[57], points[58], points[59], points[60], points[61], points[62]); boolean cluster1Found = false; boolean cluster2Found = false; boolean cluster3Found = false; Assert.assertEquals(3, clusters.size()); for (final Cluster<EuclideanDoublePoint> cluster : clusters) { if (cluster.getPoints().containsAll(clusterOne)) { cluster1Found = true; } if (cluster.getPoints().containsAll(clusterTwo)) { cluster2Found = true; } if (cluster.getPoints().containsAll(clusterThree)) { cluster3Found = true; } } Assert.assertTrue(cluster1Found); Assert.assertTrue(cluster2Found); Assert.assertTrue(cluster3Found); } @Test public void testSingleLink() { final EuclideanIntegerPoint[] points = { new EuclideanIntegerPoint(new int[] {10, 10}), // A new EuclideanIntegerPoint(new int[] {12, 9}), new EuclideanIntegerPoint(new int[] {10, 8}), new EuclideanIntegerPoint(new int[] {8, 8}), new EuclideanIntegerPoint(new int[] {8, 6}), new EuclideanIntegerPoint(new int[] {7, 7}), new EuclideanIntegerPoint(new int[] {5, 6}), // B new EuclideanIntegerPoint(new int[] {14, 8}), // C new EuclideanIntegerPoint(new int[] {7, 15}), // N - Noise, should not be present new EuclideanIntegerPoint(new int[] {17, 8}), // D - single-link connected to C should not be present }; final DBSCANClusterer<EuclideanIntegerPoint> clusterer = new DBSCANClusterer<EuclideanIntegerPoint>(3, 3); List<Cluster<EuclideanIntegerPoint>> clusters = clusterer.cluster(Arrays.asList(points)); Assert.assertEquals(1, clusters.size()); final List<EuclideanIntegerPoint> clusterOne = Arrays.asList(points[0], points[1], points[2], points[3], points[4], points[5], points[6], points[7]); Assert.assertTrue(clusters.get(0).getPoints().containsAll(clusterOne)); } @Test public void testGetEps() { final DBSCANClusterer<EuclideanDoublePoint> transformer = new DBSCANClusterer<EuclideanDoublePoint>(2.0, 5); Assert.assertEquals(2.0, transformer.getEps(), 0.0); } @Test public void testGetMinPts() { final DBSCANClusterer<EuclideanDoublePoint> transformer = new DBSCANClusterer<EuclideanDoublePoint>(2.0, 5); Assert.assertEquals(5, transformer.getMinPts()); } @Test(expected = MathIllegalArgumentException.class) public void testNegativeEps() { new DBSCANClusterer<EuclideanDoublePoint>(-2.0, 5); } @Test(expected = MathIllegalArgumentException.class) public void testNegativeMinPts() { new DBSCANClusterer<EuclideanDoublePoint>(2.0, -5); } @Test(expected = NullArgumentException.class) public void testNullDataset() { DBSCANClusterer<EuclideanDoublePoint> clusterer = new DBSCANClusterer<EuclideanDoublePoint>(2.0, 5); clusterer.cluster(null); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.clustering; import java.util.ArrayList; import java.util.List; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class EuclideanDoublePointTest { @Test public void testArrayIsReference() { final double[] array = { -3.0, -2.0, -1.0, 0.0, 1.0 }; Assert.assertArrayEquals(array, new EuclideanDoublePoint(array).getPoint(), 1.0e-15); } @Test public void testDistance() { final EuclideanDoublePoint e1 = new EuclideanDoublePoint(new double[] { -3.0, -2.0, -1.0, 0.0, 1.0 }); final EuclideanDoublePoint e2 = new EuclideanDoublePoint(new double[] { 1.0, 0.0, -1.0, 1.0, 1.0 }); Assert.assertEquals(FastMath.sqrt(21.0), e1.distanceFrom(e2), 1.0e-15); Assert.assertEquals(0.0, e1.distanceFrom(e1), 1.0e-15); Assert.assertEquals(0.0, e2.distanceFrom(e2), 1.0e-15); } @Test public void testCentroid() { final List<EuclideanDoublePoint> list = new ArrayList<EuclideanDoublePoint>(); list.add(new EuclideanDoublePoint(new double[] { 1.0, 3.0 })); list.add(new EuclideanDoublePoint(new double[] { 2.0, 2.0 })); list.add(new EuclideanDoublePoint(new double[] { 3.0, 3.0 })); list.add(new EuclideanDoublePoint(new double[] { 2.0, 4.0 })); final EuclideanDoublePoint c = list.get(0).centroidOf(list); Assert.assertEquals(2.0, c.getPoint()[0], 1.0e-15); Assert.assertEquals(3.0, c.getPoint()[1], 1.0e-15); } @Test public void testSerial() { final EuclideanDoublePoint p = new EuclideanDoublePoint(new double[] { -3.0, -2.0, -1.0, 0.0, 1.0 }); Assert.assertEquals(p, TestUtils.serializeAndRecover(p)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.clustering; import java.util.ArrayList; import java.util.List; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class EuclideanIntegerPointTest { @Test public void testArrayIsReference() { int[] array = { -3, -2, -1, 0, 1 }; Assert.assertTrue(array == new EuclideanIntegerPoint(array).getPoint()); } @Test public void testDistance() { EuclideanIntegerPoint e1 = new EuclideanIntegerPoint(new int[] { -3, -2, -1, 0, 1 }); EuclideanIntegerPoint e2 = new EuclideanIntegerPoint(new int[] { 1, 0, -1, 1, 1 }); Assert.assertEquals(FastMath.sqrt(21.0), e1.distanceFrom(e2), 1.0e-15); Assert.assertEquals(0.0, e1.distanceFrom(e1), 1.0e-15); Assert.assertEquals(0.0, e2.distanceFrom(e2), 1.0e-15); } @Test public void testCentroid() { List<EuclideanIntegerPoint> list = new ArrayList<EuclideanIntegerPoint>(); list.add(new EuclideanIntegerPoint(new int[] { 1, 3 })); list.add(new EuclideanIntegerPoint(new int[] { 2, 2 })); list.add(new EuclideanIntegerPoint(new int[] { 3, 3 })); list.add(new EuclideanIntegerPoint(new int[] { 2, 4 })); EuclideanIntegerPoint c = list.get(0).centroidOf(list); Assert.assertEquals(2, c.getPoint()[0]); Assert.assertEquals(3, c.getPoint()[1]); } @Test public void testSerial() { EuclideanIntegerPoint p = new EuclideanIntegerPoint(new int[] { -3, -2, -1, 0, 1 }); Assert.assertEquals(p, TestUtils.serializeAndRecover(p)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.clustering; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.List; import java.util.Random; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.junit.Assert; import org.junit.Test; public class KMeansPlusPlusClustererTest { @Test public void dimension2() { KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(new Random(1746432956321l)); EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] { // first expected cluster new EuclideanIntegerPoint(new int[] { -15, 3 }), new EuclideanIntegerPoint(new int[] { -15, 4 }), new EuclideanIntegerPoint(new int[] { -15, 5 }), new EuclideanIntegerPoint(new int[] { -14, 3 }), new EuclideanIntegerPoint(new int[] { -14, 5 }), new EuclideanIntegerPoint(new int[] { -13, 3 }), new EuclideanIntegerPoint(new int[] { -13, 4 }), new EuclideanIntegerPoint(new int[] { -13, 5 }), // second expected cluster new EuclideanIntegerPoint(new int[] { -1, 0 }), new EuclideanIntegerPoint(new int[] { -1, -1 }), new EuclideanIntegerPoint(new int[] { 0, -1 }), new EuclideanIntegerPoint(new int[] { 1, -1 }), new EuclideanIntegerPoint(new int[] { 1, -2 }), // third expected cluster new EuclideanIntegerPoint(new int[] { 13, 3 }), new EuclideanIntegerPoint(new int[] { 13, 4 }), new EuclideanIntegerPoint(new int[] { 14, 4 }), new EuclideanIntegerPoint(new int[] { 14, 7 }), new EuclideanIntegerPoint(new int[] { 16, 5 }), new EuclideanIntegerPoint(new int[] { 16, 6 }), new EuclideanIntegerPoint(new int[] { 17, 4 }), new EuclideanIntegerPoint(new int[] { 17, 7 }) }; List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points), 3, 5, 10); Assert.assertEquals(3, clusters.size()); boolean cluster1Found = false; boolean cluster2Found = false; boolean cluster3Found = false; for (Cluster<EuclideanIntegerPoint> cluster : clusters) { int[] center = cluster.getCenter().getPoint(); if (center[0] < 0) { cluster1Found = true; Assert.assertEquals(8, cluster.getPoints().size()); Assert.assertEquals(-14, center[0]); Assert.assertEquals( 4, center[1]); } else if (center[1] < 0) { cluster2Found = true; Assert.assertEquals(5, cluster.getPoints().size()); Assert.assertEquals( 0, center[0]); Assert.assertEquals(-1, center[1]); } else { cluster3Found = true; Assert.assertEquals(8, cluster.getPoints().size()); Assert.assertEquals(15, center[0]); Assert.assertEquals(5, center[1]); } } Assert.assertTrue(cluster1Found); Assert.assertTrue(cluster2Found); Assert.assertTrue(cluster3Found); } /** * JIRA: MATH-305 * * Two points, one cluster, one iteration */ @Test public void testPerformClusterAnalysisDegenerate() { KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>( new Random(1746432956321l)); EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] { new EuclideanIntegerPoint(new int[] { 1959, 325100 }), new EuclideanIntegerPoint(new int[] { 1960, 373200 }), }; List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points), 1, 1); Assert.assertEquals(1, clusters.size()); Assert.assertEquals(2, (clusters.get(0).getPoints().size())); EuclideanIntegerPoint pt1 = new EuclideanIntegerPoint(new int[] { 1959, 325100 }); EuclideanIntegerPoint pt2 = new EuclideanIntegerPoint(new int[] { 1960, 373200 }); Assert.assertTrue(clusters.get(0).getPoints().contains(pt1)); Assert.assertTrue(clusters.get(0).getPoints().contains(pt2)); } @Test public void testCertainSpace() { KMeansPlusPlusClusterer.EmptyClusterStrategy[] strategies = { KMeansPlusPlusClusterer.EmptyClusterStrategy.LARGEST_VARIANCE, KMeansPlusPlusClusterer.EmptyClusterStrategy.LARGEST_POINTS_NUMBER, KMeansPlusPlusClusterer.EmptyClusterStrategy.FARTHEST_POINT }; for (KMeansPlusPlusClusterer.EmptyClusterStrategy strategy : strategies) { KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(new Random(1746432956321l), strategy); int numberOfVariables = 27; // initialise testvalues int position1 = 1; int position2 = position1 + numberOfVariables; int position3 = position2 + numberOfVariables; int position4 = position3 + numberOfVariables; // testvalues will be multiplied int multiplier = 1000000; EuclideanIntegerPoint[] breakingPoints = new EuclideanIntegerPoint[numberOfVariables]; // define the space which will break the cluster algorithm for (int i = 0; i < numberOfVariables; i++) { int points[] = { position1, position2, position3, position4 }; // multiply the values for (int j = 0; j < points.length; j++) { points[j] = points[j] * multiplier; } EuclideanIntegerPoint euclideanIntegerPoint = new EuclideanIntegerPoint(points); breakingPoints[i] = euclideanIntegerPoint; position1 = position1 + numberOfVariables; position2 = position2 + numberOfVariables; position3 = position3 + numberOfVariables; position4 = position4 + numberOfVariables; } for (int n = 2; n < 27; ++n) { List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(breakingPoints), n, 100); Assert.assertEquals(n, clusters.size()); int sum = 0; for (Cluster<EuclideanIntegerPoint> cluster : clusters) { sum += cluster.getPoints().size(); } Assert.assertEquals(numberOfVariables, sum); } } } /** * A helper class for testSmallDistances(). This class is similar to EuclideanIntegerPoint, but * it defines a different distanceFrom() method that tends to return distances less than 1. */ private class CloseIntegerPoint implements Clusterable<CloseIntegerPoint> { public CloseIntegerPoint(EuclideanIntegerPoint point) { euclideanPoint = point; } public double distanceFrom(CloseIntegerPoint p) { return euclideanPoint.distanceFrom(p.euclideanPoint) * 0.001; } public CloseIntegerPoint centroidOf(Collection<CloseIntegerPoint> p) { Collection<EuclideanIntegerPoint> euclideanPoints = new ArrayList<EuclideanIntegerPoint>(); for (CloseIntegerPoint point : p) { euclideanPoints.add(point.euclideanPoint); } return new CloseIntegerPoint(euclideanPoint.centroidOf(euclideanPoints)); } @Override public boolean equals(Object o) { if (!(o instanceof CloseIntegerPoint)) { return false; } CloseIntegerPoint p = (CloseIntegerPoint) o; return euclideanPoint.equals(p.euclideanPoint); } @Override public int hashCode() { return euclideanPoint.hashCode(); } private EuclideanIntegerPoint euclideanPoint; } /** * Test points that are very close together. See issue MATH-546. */ @Test public void testSmallDistances() { // Create a bunch of CloseIntegerPoints. Most are identical, but one is different by a // small distance. int[] repeatedArray = { 0 }; int[] uniqueArray = { 1 }; CloseIntegerPoint repeatedPoint = new CloseIntegerPoint(new EuclideanIntegerPoint(repeatedArray)); CloseIntegerPoint uniquePoint = new CloseIntegerPoint(new EuclideanIntegerPoint(uniqueArray)); Collection<CloseIntegerPoint> points = new ArrayList<CloseIntegerPoint>(); final int NUM_REPEATED_POINTS = 10 * 1000; for (int i = 0; i < NUM_REPEATED_POINTS; ++i) { points.add(repeatedPoint); } points.add(uniquePoint); // Ask a KMeansPlusPlusClusterer to run zero iterations (i.e., to simply choose initial // cluster centers). final long RANDOM_SEED = 0; final int NUM_CLUSTERS = 2; final int NUM_ITERATIONS = 0; KMeansPlusPlusClusterer<CloseIntegerPoint> clusterer = new KMeansPlusPlusClusterer<CloseIntegerPoint>(new Random(RANDOM_SEED)); List<Cluster<CloseIntegerPoint>> clusters = clusterer.cluster(points, NUM_CLUSTERS, NUM_ITERATIONS); // Check that one of the chosen centers is the unique point. boolean uniquePointIsCenter = false; for (Cluster<CloseIntegerPoint> cluster : clusters) { if (cluster.getCenter().equals(uniquePoint)) { uniquePointIsCenter = true; } } Assert.assertTrue(uniquePointIsCenter); } /** * 2 variables cannot be clustered into 3 clusters. See issue MATH-436. */ @Test(expected=NumberIsTooSmallException.class) public void testPerformClusterAnalysisToManyClusters() { KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>( new Random(1746432956321l)); EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] { new EuclideanIntegerPoint(new int[] { 1959, 325100 }), new EuclideanIntegerPoint(new int[] { 1960, 373200 }) }; transformer.cluster(Arrays.asList(points), 3, 1); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.correlation; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.apache.commons.math3.linear.RealMatrix; import org.apache.commons.math3.linear.Array2DRowRealMatrix; import org.apache.commons.math3.stat.descriptive.moment.Variance; import org.junit.Assert; import org.junit.Test; public class CovarianceTest { protected final double[] longleyData = new double[] { 60323,83.0,234289,2356,1590,107608,1947, 61122,88.5,259426,2325,1456,108632,1948, 60171,88.2,258054,3682,1616,109773,1949, 61187,89.5,284599,3351,1650,110929,1950, 63221,96.2,328975,2099,3099,112075,1951, 63639,98.1,346999,1932,3594,113270,1952, 64989,99.0,365385,1870,3547,115094,1953, 63761,100.0,363112,3578,3350,116219,1954, 66019,101.2,397469,2904,3048,117388,1955, 67857,104.6,419180,2822,2857,118734,1956, 68169,108.4,442769,2936,2798,120445,1957, 66513,110.8,444546,4681,2637,121950,1958, 68655,112.6,482704,3813,2552,123366,1959, 69564,114.2,502601,3931,2514,125368,1960, 69331,115.7,518173,4806,2572,127852,1961, 70551,116.9,554894,4007,2827,130081,1962 }; protected final double[] swissData = new double[] { 80.2,17.0,15,12,9.96, 83.1,45.1,6,9,84.84, 92.5,39.7,5,5,93.40, 85.8,36.5,12,7,33.77, 76.9,43.5,17,15,5.16, 76.1,35.3,9,7,90.57, 83.8,70.2,16,7,92.85, 92.4,67.8,14,8,97.16, 82.4,53.3,12,7,97.67, 82.9,45.2,16,13,91.38, 87.1,64.5,14,6,98.61, 64.1,62.0,21,12,8.52, 66.9,67.5,14,7,2.27, 68.9,60.7,19,12,4.43, 61.7,69.3,22,5,2.82, 68.3,72.6,18,2,24.20, 71.7,34.0,17,8,3.30, 55.7,19.4,26,28,12.11, 54.3,15.2,31,20,2.15, 65.1,73.0,19,9,2.84, 65.5,59.8,22,10,5.23, 65.0,55.1,14,3,4.52, 56.6,50.9,22,12,15.14, 57.4,54.1,20,6,4.20, 72.5,71.2,12,1,2.40, 74.2,58.1,14,8,5.23, 72.0,63.5,6,3,2.56, 60.5,60.8,16,10,7.72, 58.3,26.8,25,19,18.46, 65.4,49.5,15,8,6.10, 75.5,85.9,3,2,99.71, 69.3,84.9,7,6,99.68, 77.3,89.7,5,2,100.00, 70.5,78.2,12,6,98.96, 79.4,64.9,7,3,98.22, 65.0,75.9,9,9,99.06, 92.2,84.6,3,3,99.46, 79.3,63.1,13,13,96.83, 70.4,38.4,26,12,5.62, 65.7,7.7,29,11,13.79, 72.7,16.7,22,13,11.22, 64.4,17.6,35,32,16.92, 77.6,37.6,15,7,4.97, 67.6,18.7,25,7,8.65, 35.0,1.2,37,53,42.34, 44.7,46.6,16,29,50.43, 42.8,27.7,22,29,58.33 }; /** * Test Longley dataset against R. * Data Source: J. Longley (1967) "An Appraisal of Least Squares * Programs for the Electronic Computer from the Point of View of the User" * Journal of the American Statistical Association, vol. 62. September, * pp. 819-841. * * Data are from NIST: * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat */ @Test public void testLongly() { RealMatrix matrix = createRealMatrix(longleyData, 16, 7); RealMatrix covarianceMatrix = new Covariance(matrix).getCovarianceMatrix(); double[] rData = new double[] { 12333921.73333333246, 3.679666000000000e+04, 343330206.333333313, 1649102.666666666744, 1117681.066666666651, 23461965.733333334, 16240.93333333333248, 36796.66000000000, 1.164576250000000e+02, 1063604.115416667, 6258.666250000000, 3490.253750000000, 73503.000000000, 50.92333333333334, 343330206.33333331347, 1.063604115416667e+06, 9879353659.329166412, 56124369.854166664183, 30880428.345833335072, 685240944.600000024, 470977.90000000002328, 1649102.66666666674, 6.258666250000000e+03, 56124369.854166664, 873223.429166666698, -115378.762499999997, 4462741.533333333, 2973.03333333333330, 1117681.06666666665, 3.490253750000000e+03, 30880428.345833335, -115378.762499999997, 484304.095833333326, 1764098.133333333, 1382.43333333333339, 23461965.73333333433, 7.350300000000000e+04, 685240944.600000024, 4462741.533333333209, 1764098.133333333302, 48387348.933333330, 32917.40000000000146, 16240.93333333333, 5.092333333333334e+01, 470977.900000000, 2973.033333333333, 1382.433333333333, 32917.40000000, 22.66666666666667 }; TestUtils.assertEquals("covariance matrix", createRealMatrix(rData, 7, 7), covarianceMatrix, 10E-9); } /** * Test R Swiss fertility dataset against R. * Data Source: R datasets package */ @Test public void testSwissFertility() { RealMatrix matrix = createRealMatrix(swissData, 47, 5); RealMatrix covarianceMatrix = new Covariance(matrix).getCovarianceMatrix(); double[] rData = new double[] { 156.0424976873265, 100.1691489361702, -64.36692876965772, -79.7295097132285, 241.5632030527289, 100.169148936170251, 515.7994172062905, -124.39283071230344, -139.6574005550416, 379.9043755781684, -64.3669287696577, -124.3928307123034, 63.64662349676226, 53.5758556891767, -190.5606105457909, -79.7295097132285, -139.6574005550416, 53.57585568917669, 92.4560592044403, -61.6988297872340, 241.5632030527289, 379.9043755781684, -190.56061054579092, -61.6988297872340, 1739.2945371877890 }; TestUtils.assertEquals("covariance matrix", createRealMatrix(rData, 5, 5), covarianceMatrix, 10E-13); } /** * Constant column */ @Test public void testConstant() { double[] noVariance = new double[] {1, 1, 1, 1}; double[] values = new double[] {1, 2, 3, 4}; Assert.assertEquals(0d, new Covariance().covariance(noVariance, values, true), Double.MIN_VALUE); Assert.assertEquals(0d, new Covariance().covariance(noVariance, noVariance, true), Double.MIN_VALUE); } /** * One column */ @Test public void testOneColumn() { RealMatrix cov = new Covariance(new double[][] {{1}, {2}}, false).getCovarianceMatrix(); Assert.assertEquals(1, cov.getRowDimension()); Assert.assertEquals(1, cov.getColumnDimension()); Assert.assertEquals(0.25, cov.getEntry(0, 0), 1.0e-15); } /** * Insufficient data */ @Test public void testInsufficientData() { double[] one = new double[] {1}; double[] two = new double[] {2}; try { new Covariance().covariance(one, two, false); Assert.fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // Expected } try { new Covariance(new double[][] {{},{}}); Assert.fail("Expecting NotStrictlyPositiveException"); } catch (NotStrictlyPositiveException ex) { // Expected } } /** * Verify that diagonal entries are consistent with Variance computation and matrix matches * column-by-column covariances */ @Test public void testConsistency() { final RealMatrix matrix = createRealMatrix(swissData, 47, 5); final RealMatrix covarianceMatrix = new Covariance(matrix).getCovarianceMatrix(); // Variances on the diagonal Variance variance = new Variance(); for (int i = 0; i < 5; i++) { Assert.assertEquals(variance.evaluate(matrix.getColumn(i)), covarianceMatrix.getEntry(i,i), 10E-14); } // Symmetry, column-consistency Assert.assertEquals(covarianceMatrix.getEntry(2, 3), new Covariance().covariance(matrix.getColumn(2), matrix.getColumn(3), true), 10E-14); Assert.assertEquals(covarianceMatrix.getEntry(2, 3), covarianceMatrix.getEntry(3, 2), Double.MIN_VALUE); // All columns same -> all entries = column variance RealMatrix repeatedColumns = new Array2DRowRealMatrix(47, 3); for (int i = 0; i < 3; i++) { repeatedColumns.setColumnMatrix(i, matrix.getColumnMatrix(0)); } RealMatrix repeatedCovarianceMatrix = new Covariance(repeatedColumns).getCovarianceMatrix(); double columnVariance = variance.evaluate(matrix.getColumn(0)); for (int i = 0; i < 3; i++) { for (int j = 0; j < 3; j++) { Assert.assertEquals(columnVariance, repeatedCovarianceMatrix.getEntry(i, j), 10E-14); } } // Check bias-correction defaults double[][] data = matrix.getData(); TestUtils.assertEquals("Covariances", covarianceMatrix, new Covariance().computeCovarianceMatrix(data),Double.MIN_VALUE); TestUtils.assertEquals("Covariances", covarianceMatrix, new Covariance().computeCovarianceMatrix(data, true),Double.MIN_VALUE); double[] x = data[0]; double[] y = data[1]; Assert.assertEquals(new Covariance().covariance(x, y), new Covariance().covariance(x, y, true), Double.MIN_VALUE); } protected RealMatrix createRealMatrix(double[] data, int nRows, int nCols) { double[][] matrixData = new double[nRows][nCols]; int ptr = 0; for (int i = 0; i < nRows; i++) { System.arraycopy(data, ptr, matrixData[i], 0, nCols); ptr += nCols; } return new Array2DRowRealMatrix(matrixData); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.correlation; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.distribution.TDistribution; import org.apache.commons.math3.linear.RealMatrix; import org.apache.commons.math3.linear.BlockRealMatrix; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; public class PearsonsCorrelationTest { protected final double[] longleyData = new double[] { 60323,83.0,234289,2356,1590,107608,1947, 61122,88.5,259426,2325,1456,108632,1948, 60171,88.2,258054,3682,1616,109773,1949, 61187,89.5,284599,3351,1650,110929,1950, 63221,96.2,328975,2099,3099,112075,1951, 63639,98.1,346999,1932,3594,113270,1952, 64989,99.0,365385,1870,3547,115094,1953, 63761,100.0,363112,3578,3350,116219,1954, 66019,101.2,397469,2904,3048,117388,1955, 67857,104.6,419180,2822,2857,118734,1956, 68169,108.4,442769,2936,2798,120445,1957, 66513,110.8,444546,4681,2637,121950,1958, 68655,112.6,482704,3813,2552,123366,1959, 69564,114.2,502601,3931,2514,125368,1960, 69331,115.7,518173,4806,2572,127852,1961, 70551,116.9,554894,4007,2827,130081,1962 }; protected final double[] swissData = new double[] { 80.2,17.0,15,12,9.96, 83.1,45.1,6,9,84.84, 92.5,39.7,5,5,93.40, 85.8,36.5,12,7,33.77, 76.9,43.5,17,15,5.16, 76.1,35.3,9,7,90.57, 83.8,70.2,16,7,92.85, 92.4,67.8,14,8,97.16, 82.4,53.3,12,7,97.67, 82.9,45.2,16,13,91.38, 87.1,64.5,14,6,98.61, 64.1,62.0,21,12,8.52, 66.9,67.5,14,7,2.27, 68.9,60.7,19,12,4.43, 61.7,69.3,22,5,2.82, 68.3,72.6,18,2,24.20, 71.7,34.0,17,8,3.30, 55.7,19.4,26,28,12.11, 54.3,15.2,31,20,2.15, 65.1,73.0,19,9,2.84, 65.5,59.8,22,10,5.23, 65.0,55.1,14,3,4.52, 56.6,50.9,22,12,15.14, 57.4,54.1,20,6,4.20, 72.5,71.2,12,1,2.40, 74.2,58.1,14,8,5.23, 72.0,63.5,6,3,2.56, 60.5,60.8,16,10,7.72, 58.3,26.8,25,19,18.46, 65.4,49.5,15,8,6.10, 75.5,85.9,3,2,99.71, 69.3,84.9,7,6,99.68, 77.3,89.7,5,2,100.00, 70.5,78.2,12,6,98.96, 79.4,64.9,7,3,98.22, 65.0,75.9,9,9,99.06, 92.2,84.6,3,3,99.46, 79.3,63.1,13,13,96.83, 70.4,38.4,26,12,5.62, 65.7,7.7,29,11,13.79, 72.7,16.7,22,13,11.22, 64.4,17.6,35,32,16.92, 77.6,37.6,15,7,4.97, 67.6,18.7,25,7,8.65, 35.0,1.2,37,53,42.34, 44.7,46.6,16,29,50.43, 42.8,27.7,22,29,58.33 }; /** * Test Longley dataset against R. */ @Test public void testLongly() { RealMatrix matrix = createRealMatrix(longleyData, 16, 7); PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix); RealMatrix correlationMatrix = corrInstance.getCorrelationMatrix(); double[] rData = new double[] { 1.000000000000000, 0.9708985250610560, 0.9835516111796693, 0.5024980838759942, 0.4573073999764817, 0.960390571594376, 0.9713294591921188, 0.970898525061056, 1.0000000000000000, 0.9915891780247822, 0.6206333925590966, 0.4647441876006747, 0.979163432977498, 0.9911491900672053, 0.983551611179669, 0.9915891780247822, 1.0000000000000000, 0.6042609398895580, 0.4464367918926265, 0.991090069458478, 0.9952734837647849, 0.502498083875994, 0.6206333925590966, 0.6042609398895580, 1.0000000000000000, -0.1774206295018783, 0.686551516365312, 0.6682566045621746, 0.457307399976482, 0.4647441876006747, 0.4464367918926265, -0.1774206295018783, 1.0000000000000000, 0.364416267189032, 0.4172451498349454, 0.960390571594376, 0.9791634329774981, 0.9910900694584777, 0.6865515163653120, 0.3644162671890320, 1.000000000000000, 0.9939528462329257, 0.971329459192119, 0.9911491900672053, 0.9952734837647849, 0.6682566045621746, 0.4172451498349454, 0.993952846232926, 1.0000000000000000 }; TestUtils.assertEquals("correlation matrix", createRealMatrix(rData, 7, 7), correlationMatrix, 10E-15); double[] rPvalues = new double[] { 4.38904690369668e-10, 8.36353208910623e-12, 7.8159700933611e-14, 0.0472894097790304, 0.01030636128354301, 0.01316878049026582, 0.0749178049642416, 0.06971758330341182, 0.0830166169296545, 0.510948586323452, 3.693245043123738e-09, 4.327782576751815e-11, 1.167954621905665e-13, 0.00331028281967516, 0.1652293725106684, 3.95834476307755e-10, 1.114663916723657e-13, 1.332267629550188e-15, 0.00466039138541463, 0.1078477071581498, 7.771561172376096e-15 }; RealMatrix rPMatrix = createLowerTriangularRealMatrix(rPvalues, 7); fillUpper(rPMatrix, 0d); TestUtils.assertEquals("correlation p values", rPMatrix, corrInstance.getCorrelationPValues(), 10E-15); } /** * Test R Swiss fertility dataset against R. */ @Test public void testSwissFertility() { RealMatrix matrix = createRealMatrix(swissData, 47, 5); PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix); RealMatrix correlationMatrix = corrInstance.getCorrelationMatrix(); double[] rData = new double[] { 1.0000000000000000, 0.3530791836199747, -0.6458827064572875, -0.6637888570350691, 0.4636847006517939, 0.3530791836199747, 1.0000000000000000,-0.6865422086171366, -0.6395225189483201, 0.4010950530487398, -0.6458827064572875, -0.6865422086171366, 1.0000000000000000, 0.6984152962884830, -0.5727418060641666, -0.6637888570350691, -0.6395225189483201, 0.6984152962884830, 1.0000000000000000, -0.1538589170909148, 0.4636847006517939, 0.4010950530487398, -0.5727418060641666, -0.1538589170909148, 1.0000000000000000 }; TestUtils.assertEquals("correlation matrix", createRealMatrix(rData, 5, 5), correlationMatrix, 10E-15); double[] rPvalues = new double[] { 0.01491720061472623, 9.45043734069043e-07, 9.95151527133974e-08, 3.658616965962355e-07, 1.304590105694471e-06, 4.811397236181847e-08, 0.001028523190118147, 0.005204433539191644, 2.588307925380906e-05, 0.301807756132683 }; RealMatrix rPMatrix = createLowerTriangularRealMatrix(rPvalues, 5); fillUpper(rPMatrix, 0d); TestUtils.assertEquals("correlation p values", rPMatrix, corrInstance.getCorrelationPValues(), 10E-15); } /** * Test p-value near 0. JIRA: MATH-371 */ @Test public void testPValueNearZero() { /* * Create a dataset that has r -> 1, p -> 0 as dimension increases. * Prior to the fix for MATH-371, p vanished for dimension >= 14. * Post fix, p-values diminish smoothly, vanishing at dimension = 127. * Tested value is ~1E-303. */ int dimension = 120; double[][] data = new double[dimension][2]; for (int i = 0; i < dimension; i++) { data[i][0] = i; data[i][1] = i + 1/((double)i + 1); } PearsonsCorrelation corrInstance = new PearsonsCorrelation(data); Assert.assertTrue(corrInstance.getCorrelationPValues().getEntry(0, 1) > 0); } /** * Constant column */ @Test public void testConstant() { double[] noVariance = new double[] {1, 1, 1, 1}; double[] values = new double[] {1, 2, 3, 4}; Assert.assertTrue(Double.isNaN(new PearsonsCorrelation().correlation(noVariance, values))); } /** * Insufficient data */ @Test public void testInsufficientData() { double[] one = new double[] {1}; double[] two = new double[] {2}; try { new PearsonsCorrelation().correlation(one, two); Assert.fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // Expected } RealMatrix matrix = new BlockRealMatrix(new double[][] {{0},{1}}); try { new PearsonsCorrelation(matrix); Assert.fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // Expected } } /** * Verify that direct t-tests using standard error estimates are consistent * with reported p-values */ @Test public void testStdErrorConsistency() { TDistribution tDistribution = new TDistribution(45); RealMatrix matrix = createRealMatrix(swissData, 47, 5); PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix); RealMatrix rValues = corrInstance.getCorrelationMatrix(); RealMatrix pValues = corrInstance.getCorrelationPValues(); RealMatrix stdErrors = corrInstance.getCorrelationStandardErrors(); for (int i = 0; i < 5; i++) { for (int j = 0; j < i; j++) { double t = FastMath.abs(rValues.getEntry(i, j)) / stdErrors.getEntry(i, j); double p = 2 * (1 - tDistribution.cumulativeProbability(t)); Assert.assertEquals(p, pValues.getEntry(i, j), 10E-15); } } } /** * Verify that creating correlation from covariance gives same results as * direct computation from the original matrix */ @Test public void testCovarianceConsistency() { RealMatrix matrix = createRealMatrix(longleyData, 16, 7); PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix); Covariance covInstance = new Covariance(matrix); PearsonsCorrelation corrFromCovInstance = new PearsonsCorrelation(covInstance); TestUtils.assertEquals("correlation values", corrInstance.getCorrelationMatrix(), corrFromCovInstance.getCorrelationMatrix(), 10E-15); TestUtils.assertEquals("p values", corrInstance.getCorrelationPValues(), corrFromCovInstance.getCorrelationPValues(), 10E-15); TestUtils.assertEquals("standard errors", corrInstance.getCorrelationStandardErrors(), corrFromCovInstance.getCorrelationStandardErrors(), 10E-15); PearsonsCorrelation corrFromCovInstance2 = new PearsonsCorrelation(covInstance.getCovarianceMatrix(), 16); TestUtils.assertEquals("correlation values", corrInstance.getCorrelationMatrix(), corrFromCovInstance2.getCorrelationMatrix(), 10E-15); TestUtils.assertEquals("p values", corrInstance.getCorrelationPValues(), corrFromCovInstance2.getCorrelationPValues(), 10E-15); TestUtils.assertEquals("standard errors", corrInstance.getCorrelationStandardErrors(), corrFromCovInstance2.getCorrelationStandardErrors(), 10E-15); } @Test public void testConsistency() { RealMatrix matrix = createRealMatrix(longleyData, 16, 7); PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix); double[][] data = matrix.getData(); double[] x = matrix.getColumn(0); double[] y = matrix.getColumn(1); Assert.assertEquals(new PearsonsCorrelation().correlation(x, y), corrInstance.getCorrelationMatrix().getEntry(0, 1), Double.MIN_VALUE); TestUtils.assertEquals("Correlation matrix", corrInstance.getCorrelationMatrix(), new PearsonsCorrelation().computeCorrelationMatrix(data), Double.MIN_VALUE); } protected RealMatrix createRealMatrix(double[] data, int nRows, int nCols) { double[][] matrixData = new double[nRows][nCols]; int ptr = 0; for (int i = 0; i < nRows; i++) { System.arraycopy(data, ptr, matrixData[i], 0, nCols); ptr += nCols; } return new BlockRealMatrix(matrixData); } protected RealMatrix createLowerTriangularRealMatrix(double[] data, int dimension) { int ptr = 0; RealMatrix result = new BlockRealMatrix(dimension, dimension); for (int i = 1; i < dimension; i++) { for (int j = 0; j < i; j++) { result.setEntry(i, j, data[ptr]); ptr++; } } return result; } protected void fillUpper(RealMatrix matrix, double diagonalValue) { int dimension = matrix.getColumnDimension(); for (int i = 0; i < dimension; i++) { matrix.setEntry(i, i, diagonalValue); for (int j = i+1; j < dimension; j++) { matrix.setEntry(i, j, matrix.getEntry(j, i)); } } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.correlation; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.linear.BlockRealMatrix; import org.apache.commons.math3.linear.MatrixUtils; import org.apache.commons.math3.linear.RealMatrix; import org.apache.commons.math3.stat.ranking.NaNStrategy; import org.apache.commons.math3.stat.ranking.NaturalRanking; import org.junit.Assert; import org.junit.Test; /** * Test cases for Spearman's rank correlation * * @since 2.0 * @version $Id$ */ public class SpearmansRankCorrelationTest extends PearsonsCorrelationTest { /** * Test Longley dataset against R. */ @Override @Test public void testLongly() { RealMatrix matrix = createRealMatrix(longleyData, 16, 7); SpearmansCorrelation corrInstance = new SpearmansCorrelation(matrix); RealMatrix correlationMatrix = corrInstance.getCorrelationMatrix(); double[] rData = new double[] { 1, 0.982352941176471, 0.985294117647059, 0.564705882352941, 0.2264705882352941, 0.976470588235294, 0.976470588235294, 0.982352941176471, 1, 0.997058823529412, 0.664705882352941, 0.2205882352941176, 0.997058823529412, 0.997058823529412, 0.985294117647059, 0.997058823529412, 1, 0.638235294117647, 0.2235294117647059, 0.9941176470588236, 0.9941176470588236, 0.564705882352941, 0.664705882352941, 0.638235294117647, 1, -0.3411764705882353, 0.685294117647059, 0.685294117647059, 0.2264705882352941, 0.2205882352941176, 0.2235294117647059, -0.3411764705882353, 1, 0.2264705882352941, 0.2264705882352941, 0.976470588235294, 0.997058823529412, 0.9941176470588236, 0.685294117647059, 0.2264705882352941, 1, 1, 0.976470588235294, 0.997058823529412, 0.9941176470588236, 0.685294117647059, 0.2264705882352941, 1, 1 }; TestUtils.assertEquals("Spearman's correlation matrix", createRealMatrix(rData, 7, 7), correlationMatrix, 10E-15); } /** * Test R swiss fertility dataset. */ @Test public void testSwiss() { RealMatrix matrix = createRealMatrix(swissData, 47, 5); SpearmansCorrelation corrInstance = new SpearmansCorrelation(matrix); RealMatrix correlationMatrix = corrInstance.getCorrelationMatrix(); double[] rData = new double[] { 1, 0.2426642769364176, -0.660902996352354, -0.443257690360988, 0.4136455623012432, 0.2426642769364176, 1, -0.598859938748963, -0.650463814145816, 0.2886878090882852, -0.660902996352354, -0.598859938748963, 1, 0.674603831406147, -0.4750575257171745, -0.443257690360988, -0.650463814145816, 0.674603831406147, 1, -0.1444163088302244, 0.4136455623012432, 0.2886878090882852, -0.4750575257171745, -0.1444163088302244, 1 }; TestUtils.assertEquals("Spearman's correlation matrix", createRealMatrix(rData, 5, 5), correlationMatrix, 10E-15); } /** * Constant column */ @Override @Test public void testConstant() { double[] noVariance = new double[] {1, 1, 1, 1}; double[] values = new double[] {1, 2, 3, 4}; Assert.assertTrue(Double.isNaN(new SpearmansCorrelation().correlation(noVariance, values))); } /** * Insufficient data */ @Override @Test public void testInsufficientData() { double[] one = new double[] {1}; double[] two = new double[] {2}; try { new SpearmansCorrelation().correlation(one, two); Assert.fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // Expected } RealMatrix matrix = new BlockRealMatrix(new double[][] {{0},{1}}); try { new SpearmansCorrelation(matrix); Assert.fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // Expected } } @Override @Test public void testConsistency() { RealMatrix matrix = createRealMatrix(longleyData, 16, 7); SpearmansCorrelation corrInstance = new SpearmansCorrelation(matrix); double[][] data = matrix.getData(); double[] x = matrix.getColumn(0); double[] y = matrix.getColumn(1); Assert.assertEquals(new SpearmansCorrelation().correlation(x, y), corrInstance.getCorrelationMatrix().getEntry(0, 1), Double.MIN_VALUE); TestUtils.assertEquals("Correlation matrix", corrInstance.getCorrelationMatrix(), new SpearmansCorrelation().computeCorrelationMatrix(data), Double.MIN_VALUE); } @Test public void testMath891Array() { final double[] xArray = new double[] { Double.NaN, 1.9, 2, 100, 3 }; final double[] yArray = new double[] { 10, 2, 10, Double.NaN, 4 }; NaturalRanking ranking = new NaturalRanking(NaNStrategy.REMOVED); SpearmansCorrelation spearman = new SpearmansCorrelation(ranking); Assert.assertEquals(0.5, spearman.correlation(xArray, yArray), Double.MIN_VALUE); } @Test public void testMath891Matrix() { final double[] xArray = new double[] { Double.NaN, 1.9, 2, 100, 3 }; final double[] yArray = new double[] { 10, 2, 10, Double.NaN, 4 }; RealMatrix matrix = MatrixUtils.createRealMatrix(xArray.length, 2); for (int i = 0; i < xArray.length; i++) { matrix.addToEntry(i, 0, xArray[i]); matrix.addToEntry(i, 1, yArray[i]); } // compute correlation NaturalRanking ranking = new NaturalRanking(NaNStrategy.REMOVED); SpearmansCorrelation spearman = new SpearmansCorrelation(matrix, ranking); Assert.assertEquals(0.5, spearman.getCorrelationMatrix().getEntry(0, 1), Double.MIN_VALUE); } // Not relevant here @Override @Test public void testStdErrorConsistency() {} @Override @Test public void testCovarianceConsistency() {} }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.correlation; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.linear.Array2DRowRealMatrix; import org.apache.commons.math3.linear.RealMatrix; import org.apache.commons.math3.random.ISAACRandom; import org.junit.Assert; import org.junit.Test; public class StorelessCovarianceTest { protected final double[] longleyData = new double[] { 60323,83.0,234289,2356,1590,107608,1947, 61122,88.5,259426,2325,1456,108632,1948, 60171,88.2,258054,3682,1616,109773,1949, 61187,89.5,284599,3351,1650,110929,1950, 63221,96.2,328975,2099,3099,112075,1951, 63639,98.1,346999,1932,3594,113270,1952, 64989,99.0,365385,1870,3547,115094,1953, 63761,100.0,363112,3578,3350,116219,1954, 66019,101.2,397469,2904,3048,117388,1955, 67857,104.6,419180,2822,2857,118734,1956, 68169,108.4,442769,2936,2798,120445,1957, 66513,110.8,444546,4681,2637,121950,1958, 68655,112.6,482704,3813,2552,123366,1959, 69564,114.2,502601,3931,2514,125368,1960, 69331,115.7,518173,4806,2572,127852,1961, 70551,116.9,554894,4007,2827,130081,1962 }; protected final double[] swissData = new double[] { 80.2,17.0,15,12,9.96, 83.1,45.1,6,9,84.84, 92.5,39.7,5,5,93.40, 85.8,36.5,12,7,33.77, 76.9,43.5,17,15,5.16, 76.1,35.3,9,7,90.57, 83.8,70.2,16,7,92.85, 92.4,67.8,14,8,97.16, 82.4,53.3,12,7,97.67, 82.9,45.2,16,13,91.38, 87.1,64.5,14,6,98.61, 64.1,62.0,21,12,8.52, 66.9,67.5,14,7,2.27, 68.9,60.7,19,12,4.43, 61.7,69.3,22,5,2.82, 68.3,72.6,18,2,24.20, 71.7,34.0,17,8,3.30, 55.7,19.4,26,28,12.11, 54.3,15.2,31,20,2.15, 65.1,73.0,19,9,2.84, 65.5,59.8,22,10,5.23, 65.0,55.1,14,3,4.52, 56.6,50.9,22,12,15.14, 57.4,54.1,20,6,4.20, 72.5,71.2,12,1,2.40, 74.2,58.1,14,8,5.23, 72.0,63.5,6,3,2.56, 60.5,60.8,16,10,7.72, 58.3,26.8,25,19,18.46, 65.4,49.5,15,8,6.10, 75.5,85.9,3,2,99.71, 69.3,84.9,7,6,99.68, 77.3,89.7,5,2,100.00, 70.5,78.2,12,6,98.96, 79.4,64.9,7,3,98.22, 65.0,75.9,9,9,99.06, 92.2,84.6,3,3,99.46, 79.3,63.1,13,13,96.83, 70.4,38.4,26,12,5.62, 65.7,7.7,29,11,13.79, 72.7,16.7,22,13,11.22, 64.4,17.6,35,32,16.92, 77.6,37.6,15,7,4.97, 67.6,18.7,25,7,8.65, 35.0,1.2,37,53,42.34, 44.7,46.6,16,29,50.43, 42.8,27.7,22,29,58.33 }; protected final double[][] longleyDataSimple = { {60323, 83.0}, {61122,88.5}, {60171, 88.2}, {61187, 89.5}, {63221, 96.2}, {63639, 98.1}, {64989, 99.0}, {63761, 100.0}, {66019, 101.2}, {67857, 104.6}, {68169, 108.4}, {66513, 110.8}, {68655, 112.6}, {69564, 114.2}, {69331, 115.7}, {70551, 116.9} }; @Test public void testLonglySimpleVar(){ double rCov = 12333921.73333333246; StorelessBivariateCovariance cov = new StorelessBivariateCovariance(); for(int i=0;i<longleyDataSimple.length;i++){ cov.increment(longleyDataSimple[i][0],longleyDataSimple[i][0]); } TestUtils.assertEquals("simple covariance test", rCov, cov.getResult(), 10E-7); } @Test public void testLonglySimpleCov(){ double rCov = 36796.660000; StorelessBivariateCovariance cov = new StorelessBivariateCovariance(); for(int i=0;i<longleyDataSimple.length;i++){ cov.increment(longleyDataSimple[i][0], longleyDataSimple[i][1]); } TestUtils.assertEquals("simple covariance test", rCov, cov.getResult(), 10E-7); } /** * Test Longley dataset against R. * Data Source: J. Longley (1967) "An Appraisal of Least Squares * Programs for the Electronic Computer from the Point of View of the User" * Journal of the American Statistical Association, vol. 62. September, * pp. 819-841. * * Data are from NIST: * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat */ @Test public void testLonglyByRow() { RealMatrix matrix = createRealMatrix(longleyData, 16, 7); double[] rData = new double[] { 12333921.73333333246, 3.679666000000000e+04, 343330206.333333313, 1649102.666666666744, 1117681.066666666651, 23461965.733333334, 16240.93333333333248, 36796.66000000000, 1.164576250000000e+02, 1063604.115416667, 6258.666250000000, 3490.253750000000, 73503.000000000, 50.92333333333334, 343330206.33333331347, 1.063604115416667e+06, 9879353659.329166412, 56124369.854166664183, 30880428.345833335072, 685240944.600000024, 470977.90000000002328, 1649102.66666666674, 6.258666250000000e+03, 56124369.854166664, 873223.429166666698, -115378.762499999997, 4462741.533333333, 2973.03333333333330, 1117681.06666666665, 3.490253750000000e+03, 30880428.345833335, -115378.762499999997, 484304.095833333326, 1764098.133333333, 1382.43333333333339, 23461965.73333333433, 7.350300000000000e+04, 685240944.600000024, 4462741.533333333209, 1764098.133333333302, 48387348.933333330, 32917.40000000000146, 16240.93333333333, 5.092333333333334e+01, 470977.900000000, 2973.033333333333, 1382.433333333333, 32917.40000000, 22.66666666666667 }; StorelessCovariance covMatrix = new StorelessCovariance(7); for(int i=0;i<matrix.getRowDimension();i++){ covMatrix.increment(matrix.getRow(i)); } RealMatrix covarianceMatrix = covMatrix.getCovarianceMatrix(); TestUtils.assertEquals("covariance matrix", createRealMatrix(rData, 7, 7), covarianceMatrix, 10E-7); } /** * Test R Swiss fertility dataset against R. * Data Source: R datasets package */ @Test public void testSwissFertilityByRow() { RealMatrix matrix = createRealMatrix(swissData, 47, 5); double[] rData = new double[] { 156.0424976873265, 100.1691489361702, -64.36692876965772, -79.7295097132285, 241.5632030527289, 100.169148936170251, 515.7994172062905, -124.39283071230344, -139.6574005550416, 379.9043755781684, -64.3669287696577, -124.3928307123034, 63.64662349676226, 53.5758556891767, -190.5606105457909, -79.7295097132285, -139.6574005550416, 53.57585568917669, 92.4560592044403, -61.6988297872340, 241.5632030527289, 379.9043755781684, -190.56061054579092, -61.6988297872340, 1739.2945371877890 }; StorelessCovariance covMatrix = new StorelessCovariance(5); for(int i=0;i<matrix.getRowDimension();i++){ covMatrix.increment(matrix.getRow(i)); } RealMatrix covarianceMatrix = covMatrix.getCovarianceMatrix(); TestUtils.assertEquals("covariance matrix", createRealMatrix(rData, 5, 5), covarianceMatrix, 10E-13); } /** * Test symmetry of the covariance matrix */ @Test public void testSymmetry() { RealMatrix matrix = createRealMatrix(swissData, 47, 5); final int dimension = 5; StorelessCovariance storelessCov = new StorelessCovariance(dimension); for(int i=0;i<matrix.getRowDimension();i++){ storelessCov.increment(matrix.getRow(i)); } double[][] covMatrix = storelessCov.getData(); for (int i = 0; i < dimension; i++) { for (int j = i; j < dimension; j++) { Assert.assertEquals(covMatrix[i][j], covMatrix[j][i], 10e-9); } } } /** * Test equality of covariance. chk: covariance of two * samples separately and adds them together. cov: computes * covariance of the combined sample showing both are equal. */ @Test public void testEquivalence() { int num_sets = 2; StorelessBivariateCovariance cov = new StorelessBivariateCovariance();// covariance of the superset StorelessBivariateCovariance chk = new StorelessBivariateCovariance();// check covariance made by appending covariance of subsets ISAACRandom rand = new ISAACRandom(10L);// Seed can be changed for (int s = 0; s < num_sets; s++) {// loop through sets of samlpes StorelessBivariateCovariance covs = new StorelessBivariateCovariance(); for (int i = 0; i < 5; i++) { // loop through individual samlpes. double x = rand.nextDouble(); double y = rand.nextDouble(); covs.increment(x, y);// add sample to the subset cov.increment(x, y);// add sample to the superset } chk.append(covs); } TestUtils.assertEquals("covariance subset test", chk.getResult(), cov.getResult(), 10E-7); } protected RealMatrix createRealMatrix(double[] data, int nRows, int nCols) { double[][] matrixData = new double[nRows][nCols]; int ptr = 0; for (int i = 0; i < nRows; i++) { System.arraycopy(data, ptr, matrixData[i], 0, nCols); ptr += nCols; } return new Array2DRowRealMatrix(matrixData); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.data; /** * @version $Id$ */ public class LewTest extends CertifiedDataAbstractTest { @Override protected String getResourceName() { return "org/apache/commons/math3/stat/data/Lew.txt"; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.data; /** * @version $Id$ */ public class LotteryTest extends CertifiedDataAbstractTest { @Override protected String getResourceName() { return "org/apache/commons/math3/stat/data/Lottery.txt"; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.descriptive; import java.util.ArrayList; import java.util.Collection; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.distribution.RealDistribution; import org.apache.commons.math3.distribution.UniformRealDistribution; import org.apache.commons.math3.distribution.IntegerDistribution; import org.apache.commons.math3.distribution.UniformIntegerDistribution; import org.apache.commons.math3.util.Precision; import org.junit.Assert; import org.junit.Test; /** * Test cases for {@link AggregateSummaryStatistics} * */ public class AggregateSummaryStatisticsTest { /** * Tests the standard aggregation behavior */ @Test public void testAggregation() { AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics(); SummaryStatistics setOneStats = aggregate.createContributingStatistics(); SummaryStatistics setTwoStats = aggregate.createContributingStatistics(); Assert.assertNotNull("The set one contributing stats are null", setOneStats); Assert.assertNotNull("The set two contributing stats are null", setTwoStats); Assert.assertNotSame("Contributing stats objects are the same", setOneStats, setTwoStats); setOneStats.addValue(2); setOneStats.addValue(3); setOneStats.addValue(5); setOneStats.addValue(7); setOneStats.addValue(11); Assert.assertEquals("Wrong number of set one values", 5, setOneStats.getN()); Assert.assertTrue("Wrong sum of set one values", Precision.equals(28.0, setOneStats.getSum(), 1)); setTwoStats.addValue(2); setTwoStats.addValue(4); setTwoStats.addValue(8); Assert.assertEquals("Wrong number of set two values", 3, setTwoStats.getN()); Assert.assertTrue("Wrong sum of set two values", Precision.equals(14.0, setTwoStats.getSum(), 1)); Assert.assertEquals("Wrong number of aggregate values", 8, aggregate.getN()); Assert.assertTrue("Wrong aggregate sum", Precision.equals(42.0, aggregate.getSum(), 1)); } /** * Verify that aggregating over a partition gives the same results * as direct computation. * * 1) Randomly generate a dataset of 10-100 values * from [-100, 100] * 2) Divide the dataset it into 2-5 partitions * 3) Create an AggregateSummaryStatistic and ContributingStatistics * for each partition * 4) Compare results from the AggregateSummaryStatistic with values * returned by a single SummaryStatistics instance that is provided * the full dataset */ @Test public void testAggregationConsistency() { // Generate a random sample and random partition double[] totalSample = generateSample(); double[][] subSamples = generatePartition(totalSample); int nSamples = subSamples.length; // Create aggregator and total stats for comparison AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics(); SummaryStatistics totalStats = new SummaryStatistics(); // Create array of component stats SummaryStatistics componentStats[] = new SummaryStatistics[nSamples]; for (int i = 0; i < nSamples; i++) { // Make componentStats[i] a contributing statistic to aggregate componentStats[i] = aggregate.createContributingStatistics(); // Add values from subsample for (int j = 0; j < subSamples[i].length; j++) { componentStats[i].addValue(subSamples[i][j]); } } // Compute totalStats directly for (int i = 0; i < totalSample.length; i++) { totalStats.addValue(totalSample[i]); } /* * Compare statistics in totalStats with aggregate. * Note that guaranteed success of this comparison depends on the * fact that <aggregate> gets values in exactly the same order * as <totalStats>. * */ Assert.assertEquals(totalStats.getSummary(), aggregate.getSummary()); } /** * Test aggregate function by randomly generating a dataset of 10-100 values * from [-100, 100], dividing it into 2-5 partitions, computing stats for each * partition and comparing the result of aggregate(...) applied to the collection * of per-partition SummaryStatistics with a single SummaryStatistics computed * over the full sample. * */ @Test public void testAggregate() { // Generate a random sample and random partition double[] totalSample = generateSample(); double[][] subSamples = generatePartition(totalSample); int nSamples = subSamples.length; // Compute combined stats directly SummaryStatistics totalStats = new SummaryStatistics(); for (int i = 0; i < totalSample.length; i++) { totalStats.addValue(totalSample[i]); } // Now compute subsample stats individually and aggregate SummaryStatistics[] subSampleStats = new SummaryStatistics[nSamples]; for (int i = 0; i < nSamples; i++) { subSampleStats[i] = new SummaryStatistics(); } Collection<SummaryStatistics> aggregate = new ArrayList<SummaryStatistics>(); for (int i = 0; i < nSamples; i++) { for (int j = 0; j < subSamples[i].length; j++) { subSampleStats[i].addValue(subSamples[i][j]); } aggregate.add(subSampleStats[i]); } // Compare values StatisticalSummary aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate); assertEquals(totalStats.getSummary(), aggregatedStats, 10E-12); } @Test public void testAggregateDegenerate() { double[] totalSample = {1, 2, 3, 4, 5}; double[][] subSamples = {{1}, {2}, {3}, {4}, {5}}; // Compute combined stats directly SummaryStatistics totalStats = new SummaryStatistics(); for (int i = 0; i < totalSample.length; i++) { totalStats.addValue(totalSample[i]); } // Now compute subsample stats individually and aggregate SummaryStatistics[] subSampleStats = new SummaryStatistics[5]; for (int i = 0; i < 5; i++) { subSampleStats[i] = new SummaryStatistics(); } Collection<SummaryStatistics> aggregate = new ArrayList<SummaryStatistics>(); for (int i = 0; i < 5; i++) { for (int j = 0; j < subSamples[i].length; j++) { subSampleStats[i].addValue(subSamples[i][j]); } aggregate.add(subSampleStats[i]); } // Compare values StatisticalSummaryValues aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate); assertEquals(totalStats.getSummary(), aggregatedStats, 10E-12); } @Test public void testAggregateSpecialValues() { double[] totalSample = {Double.POSITIVE_INFINITY, 2, 3, Double.NaN, 5}; double[][] subSamples = {{Double.POSITIVE_INFINITY, 2}, {3}, {Double.NaN}, {5}}; // Compute combined stats directly SummaryStatistics totalStats = new SummaryStatistics(); for (int i = 0; i < totalSample.length; i++) { totalStats.addValue(totalSample[i]); } // Now compute subsample stats individually and aggregate SummaryStatistics[] subSampleStats = new SummaryStatistics[5]; for (int i = 0; i < 4; i++) { subSampleStats[i] = new SummaryStatistics(); } Collection<SummaryStatistics> aggregate = new ArrayList<SummaryStatistics>(); for (int i = 0; i < 4; i++) { for (int j = 0; j < subSamples[i].length; j++) { subSampleStats[i].addValue(subSamples[i][j]); } aggregate.add(subSampleStats[i]); } // Compare values StatisticalSummaryValues aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate); assertEquals(totalStats.getSummary(), aggregatedStats, 10E-12); } /** * Verifies that a StatisticalSummary and a StatisticalSummaryValues are equal up * to delta, with NaNs, infinities returned in the same spots. For max, min, n, values * have to agree exactly, delta is used only for sum, mean, variance, std dev. */ protected static void assertEquals(StatisticalSummary expected, StatisticalSummary observed, double delta) { TestUtils.assertEquals(expected.getMax(), observed.getMax(), 0); TestUtils.assertEquals(expected.getMin(), observed.getMin(), 0); Assert.assertEquals(expected.getN(), observed.getN()); TestUtils.assertEquals(expected.getSum(), observed.getSum(), delta); TestUtils.assertEquals(expected.getMean(), observed.getMean(), delta); TestUtils.assertEquals(expected.getStandardDeviation(), observed.getStandardDeviation(), delta); TestUtils.assertEquals(expected.getVariance(), observed.getVariance(), delta); } /** * Generates a random sample of double values. * Sample size is random, between 10 and 100 and values are * uniformly distributed over [-100, 100]. * * @return array of random double values */ private double[] generateSample() { final IntegerDistribution size = new UniformIntegerDistribution(10, 100); final RealDistribution randomData = new UniformRealDistribution(-100, 100); final int sampleSize = size.sample(); final double[] out = randomData.sample(sampleSize); return out; } /** * Generates a partition of <sample> into up to 5 sequentially selected * subsamples with randomly selected partition points. * * @param sample array to partition * @return rectangular array with rows = subsamples */ private double[][] generatePartition(double[] sample) { final int length = sample.length; final double[][] out = new double[5][]; int cur = 0; // beginning of current partition segment int offset = 0; // end of current partition segment int sampleCount = 0; // number of segments defined for (int i = 0; i < 5; i++) { if (cur == length || offset == length) { break; } final int next; if (i == 4 || cur == length - 1) { next = length - 1; } else { next = (new UniformIntegerDistribution(cur, length - 1)).sample(); } final int subLength = next - cur + 1; out[i] = new double[subLength]; System.arraycopy(sample, offset, out[i], 0, subLength); cur = next + 1; sampleCount++; offset += subLength; } if (sampleCount < 5) { double[][] out2 = new double[sampleCount][]; for (int j = 0; j < sampleCount; j++) { final int curSize = out[j].length; out2[j] = new double[curSize]; System.arraycopy(out[j], 0, out2[j], 0, curSize); } return out2; } else { return out; } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */ package org.apache.commons.math3.stat.descriptive; import java.util.Locale; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.stat.descriptive.rank.Percentile; import org.apache.commons.math3.stat.descriptive.moment.GeometricMean; import org.apache.commons.math3.stat.descriptive.moment.Mean; import org.apache.commons.math3.stat.descriptive.moment.Variance; import org.apache.commons.math3.stat.descriptive.rank.Max; import org.apache.commons.math3.stat.descriptive.rank.Min; import org.apache.commons.math3.stat.descriptive.summary.Sum; import org.apache.commons.math3.stat.descriptive.summary.SumOfSquares; import org.apache.commons.math3.util.Precision; import org.junit.Assert; import org.junit.Test; /** * Test cases for the DescriptiveStatistics class. * * @version $Id$ * 2007) $ */ public class DescriptiveStatisticsTest { protected DescriptiveStatistics createDescriptiveStatistics() { return new DescriptiveStatistics(); } @Test public void testSetterInjection() { DescriptiveStatistics stats = createDescriptiveStatistics(); stats.addValue(1); stats.addValue(3); Assert.assertEquals(2, stats.getMean(), 1E-10); // Now lets try some new math stats.setMeanImpl(new deepMean()); Assert.assertEquals(42, stats.getMean(), 1E-10); } @Test public void testCopy() { DescriptiveStatistics stats = createDescriptiveStatistics(); stats.addValue(1); stats.addValue(3); DescriptiveStatistics copy = new DescriptiveStatistics(stats); Assert.assertEquals(2, copy.getMean(), 1E-10); // Now lets try some new math stats.setMeanImpl(new deepMean()); copy = stats.copy(); Assert.assertEquals(42, copy.getMean(), 1E-10); } @Test public void testWindowSize() { DescriptiveStatistics stats = createDescriptiveStatistics(); stats.setWindowSize(300); for (int i = 0; i < 100; ++i) { stats.addValue(i + 1); } int refSum = (100 * 101) / 2; Assert.assertEquals(refSum / 100.0, stats.getMean(), 1E-10); Assert.assertEquals(300, stats.getWindowSize()); try { stats.setWindowSize(-3); Assert.fail("an exception should have been thrown"); } catch (IllegalArgumentException iae) { // expected } Assert.assertEquals(300, stats.getWindowSize()); stats.setWindowSize(50); Assert.assertEquals(50, stats.getWindowSize()); int refSum2 = refSum - (50 * 51) / 2; Assert.assertEquals(refSum2 / 50.0, stats.getMean(), 1E-10); } @Test public void testGetValues() { DescriptiveStatistics stats = createDescriptiveStatistics(); for (int i = 100; i > 0; --i) { stats.addValue(i); } int refSum = (100 * 101) / 2; Assert.assertEquals(refSum / 100.0, stats.getMean(), 1E-10); double[] v = stats.getValues(); for (int i = 0; i < v.length; ++i) { Assert.assertEquals(100.0 - i, v[i], 1.0e-10); } double[] s = stats.getSortedValues(); for (int i = 0; i < s.length; ++i) { Assert.assertEquals(i + 1.0, s[i], 1.0e-10); } Assert.assertEquals(12.0, stats.getElement(88), 1.0e-10); } @Test public void testToString() { DescriptiveStatistics stats = createDescriptiveStatistics(); stats.addValue(1); stats.addValue(2); stats.addValue(3); Locale d = Locale.getDefault(); Locale.setDefault(Locale.US); Assert.assertEquals("DescriptiveStatistics:\n" + "n: 3\n" + "min: 1.0\n" + "max: 3.0\n" + "mean: 2.0\n" + "std dev: 1.0\n" + "median: 2.0\n" + "skewness: 0.0\n" + "kurtosis: NaN\n", stats.toString()); Locale.setDefault(d); } @Test public void testShuffledStatistics() { // the purpose of this test is only to check the get/set methods // we are aware shuffling statistics like this is really not // something sensible to do in production ... DescriptiveStatistics reference = createDescriptiveStatistics(); DescriptiveStatistics shuffled = createDescriptiveStatistics(); UnivariateStatistic tmp = shuffled.getGeometricMeanImpl(); shuffled.setGeometricMeanImpl(shuffled.getMeanImpl()); shuffled.setMeanImpl(shuffled.getKurtosisImpl()); shuffled.setKurtosisImpl(shuffled.getSkewnessImpl()); shuffled.setSkewnessImpl(shuffled.getVarianceImpl()); shuffled.setVarianceImpl(shuffled.getMaxImpl()); shuffled.setMaxImpl(shuffled.getMinImpl()); shuffled.setMinImpl(shuffled.getSumImpl()); shuffled.setSumImpl(shuffled.getSumsqImpl()); shuffled.setSumsqImpl(tmp); for (int i = 100; i > 0; --i) { reference.addValue(i); shuffled.addValue(i); } Assert.assertEquals(reference.getMean(), shuffled.getGeometricMean(), 1.0e-10); Assert.assertEquals(reference.getKurtosis(), shuffled.getMean(), 1.0e-10); Assert.assertEquals(reference.getSkewness(), shuffled.getKurtosis(), 1.0e-10); Assert.assertEquals(reference.getVariance(), shuffled.getSkewness(), 1.0e-10); Assert.assertEquals(reference.getMax(), shuffled.getVariance(), 1.0e-10); Assert.assertEquals(reference.getMin(), shuffled.getMax(), 1.0e-10); Assert.assertEquals(reference.getSum(), shuffled.getMin(), 1.0e-10); Assert.assertEquals(reference.getSumsq(), shuffled.getSum(), 1.0e-10); Assert.assertEquals(reference.getGeometricMean(), shuffled.getSumsq(), 1.0e-10); } @Test public void testPercentileSetter() { DescriptiveStatistics stats = createDescriptiveStatistics(); stats.addValue(1); stats.addValue(2); stats.addValue(3); Assert.assertEquals(2, stats.getPercentile(50.0), 1E-10); // Inject wrapped Percentile impl stats.setPercentileImpl(new goodPercentile()); Assert.assertEquals(2, stats.getPercentile(50.0), 1E-10); // Try "new math" impl stats.setPercentileImpl(new subPercentile()); Assert.assertEquals(10.0, stats.getPercentile(10.0), 1E-10); // Try to set bad impl try { stats.setPercentileImpl(new badPercentile()); Assert.fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } } @Test public void test20090720() { DescriptiveStatistics descriptiveStatistics = new DescriptiveStatistics(100); for (int i = 0; i < 161; i++) { descriptiveStatistics.addValue(1.2); } descriptiveStatistics.clear(); descriptiveStatistics.addValue(1.2); Assert.assertEquals(1, descriptiveStatistics.getN()); } @Test public void testRemoval() { final DescriptiveStatistics dstat = createDescriptiveStatistics(); checkremoval(dstat, 1, 6.0, 0.0, Double.NaN); checkremoval(dstat, 3, 5.0, 3.0, 4.5); checkremoval(dstat, 6, 3.5, 2.5, 3.0); checkremoval(dstat, 9, 3.5, 2.5, 3.0); checkremoval(dstat, DescriptiveStatistics.INFINITE_WINDOW, 3.5, 2.5, 3.0); } @Test public void testSummaryConsistency() { final DescriptiveStatistics dstats = new DescriptiveStatistics(); final SummaryStatistics sstats = new SummaryStatistics(); final int windowSize = 5; dstats.setWindowSize(windowSize); final double tol = 1E-12; for (int i = 0; i < 20; i++) { dstats.addValue(i); sstats.clear(); double[] values = dstats.getValues(); for (int j = 0; j < values.length; j++) { sstats.addValue(values[j]); } TestUtils.assertEquals(dstats.getMean(), sstats.getMean(), tol); TestUtils.assertEquals(new Mean().evaluate(values), dstats.getMean(), tol); TestUtils.assertEquals(dstats.getMax(), sstats.getMax(), tol); TestUtils.assertEquals(new Max().evaluate(values), dstats.getMax(), tol); TestUtils.assertEquals(dstats.getGeometricMean(), sstats.getGeometricMean(), tol); TestUtils.assertEquals(new GeometricMean().evaluate(values), dstats.getGeometricMean(), tol); TestUtils.assertEquals(dstats.getMin(), sstats.getMin(), tol); TestUtils.assertEquals(new Min().evaluate(values), dstats.getMin(), tol); TestUtils.assertEquals(dstats.getStandardDeviation(), sstats.getStandardDeviation(), tol); TestUtils.assertEquals(dstats.getVariance(), sstats.getVariance(), tol); TestUtils.assertEquals(new Variance().evaluate(values), dstats.getVariance(), tol); TestUtils.assertEquals(dstats.getSum(), sstats.getSum(), tol); TestUtils.assertEquals(new Sum().evaluate(values), dstats.getSum(), tol); TestUtils.assertEquals(dstats.getSumsq(), sstats.getSumsq(), tol); TestUtils.assertEquals(new SumOfSquares().evaluate(values), dstats.getSumsq(), tol); TestUtils.assertEquals(dstats.getPopulationVariance(), sstats.getPopulationVariance(), tol); TestUtils.assertEquals(new Variance(false).evaluate(values), dstats.getPopulationVariance(), tol); } } public void checkremoval(DescriptiveStatistics dstat, int wsize, double mean1, double mean2, double mean3) { dstat.setWindowSize(wsize); dstat.clear(); for (int i = 1 ; i <= 6 ; ++i) { dstat.addValue(i); } Assert.assertTrue(Precision.equalsIncludingNaN(mean1, dstat.getMean())); dstat.replaceMostRecentValue(0); Assert.assertTrue(Precision.equalsIncludingNaN(mean2, dstat.getMean())); dstat.removeMostRecentValue(); Assert.assertTrue(Precision.equalsIncludingNaN(mean3, dstat.getMean())); } // Test UnivariateStatistics impls for setter injection tests /** * A new way to compute the mean */ static class deepMean implements UnivariateStatistic { public double evaluate(double[] values, int begin, int length) { return 42; } public double evaluate(double[] values) { return 42; } public UnivariateStatistic copy() { return new deepMean(); } } /** * Test percentile implementation - wraps a Percentile */ static class goodPercentile implements UnivariateStatistic { private Percentile percentile = new Percentile(); public void setQuantile(double quantile) { percentile.setQuantile(quantile); } public double evaluate(double[] values, int begin, int length) { return percentile.evaluate(values, begin, length); } public double evaluate(double[] values) { return percentile.evaluate(values); } public UnivariateStatistic copy() { goodPercentile result = new goodPercentile(); result.setQuantile(percentile.getQuantile()); return result; } } /** * Test percentile subclass - another "new math" impl * Always returns currently set quantile */ static class subPercentile extends Percentile { @Override public double evaluate(double[] values, int begin, int length) { return getQuantile(); } @Override public double evaluate(double[] values) { return getQuantile(); } private static final long serialVersionUID = 8040701391045914979L; @Override public Percentile copy() { subPercentile result = new subPercentile(); return result; } } /** * "Bad" test percentile implementation - no setQuantile */ static class badPercentile implements UnivariateStatistic { private Percentile percentile = new Percentile(); public double evaluate(double[] values, int begin, int length) { return percentile.evaluate(values, begin, length); } public double evaluate(double[] values) { return percentile.evaluate(values); } public UnivariateStatistic copy() { return new badPercentile(); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.descriptive; import java.util.ArrayList; import java.util.List; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * Test cases for the {@link ListUnivariateImpl} class. * * @version $Id$ */ public final class ListUnivariateImplTest { private double one = 1; private float two = 2; private int three = 3; private double mean = 2; private double sumSq = 18; private double sum = 8; private double var = 0.666666666666666666667; private double std = FastMath.sqrt(var); private double n = 4; private double min = 1; private double max = 3; private double tolerance = 10E-15; /** test stats */ @Test public void testStats() { List<Object> externalList = new ArrayList<Object>(); DescriptiveStatistics u = new ListUnivariateImpl( externalList ); Assert.assertEquals("total count",0,u.getN(),tolerance); u.addValue(one); u.addValue(two); u.addValue(two); u.addValue(three); Assert.assertEquals("N",n,u.getN(),tolerance); Assert.assertEquals("sum",sum,u.getSum(),tolerance); Assert.assertEquals("sumsq",sumSq,u.getSumsq(),tolerance); Assert.assertEquals("var",var,u.getVariance(),tolerance); Assert.assertEquals("std",std,u.getStandardDeviation(),tolerance); Assert.assertEquals("mean",mean,u.getMean(),tolerance); Assert.assertEquals("min",min,u.getMin(),tolerance); Assert.assertEquals("max",max,u.getMax(),tolerance); u.clear(); Assert.assertEquals("total count",0,u.getN(),tolerance); } @Test public void testN0andN1Conditions() { List<Object> list = new ArrayList<Object>(); DescriptiveStatistics u = new ListUnivariateImpl( list ); Assert.assertTrue("Mean of n = 0 set should be NaN", Double.isNaN( u.getMean() ) ); Assert.assertTrue("Standard Deviation of n = 0 set should be NaN", Double.isNaN( u.getStandardDeviation() ) ); Assert.assertTrue("Variance of n = 0 set should be NaN", Double.isNaN(u.getVariance() ) ); list.add( Double.valueOf(one)); Assert.assertTrue( "Mean of n = 1 set should be value of single item n1", u.getMean() == one); Assert.assertTrue( "StdDev of n = 1 set should be zero, instead it is: " + u.getStandardDeviation(), u.getStandardDeviation() == 0); Assert.assertTrue( "Variance of n = 1 set should be zero", u.getVariance() == 0); } @Test public void testSkewAndKurtosis() { DescriptiveStatistics u = new DescriptiveStatistics(); double[] testArray = { 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1, 9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 }; for( int i = 0; i < testArray.length; i++) { u.addValue( testArray[i]); } Assert.assertEquals("mean", 12.40455, u.getMean(), 0.0001); Assert.assertEquals("variance", 10.00236, u.getVariance(), 0.0001); Assert.assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001); Assert.assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001); } @Test public void testProductAndGeometricMean() { ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList<Object>()); u.setWindowSize(10); u.addValue( 1.0 ); u.addValue( 2.0 ); u.addValue( 3.0 ); u.addValue( 4.0 ); Assert.assertEquals( "Geometric mean not expected", 2.213364, u.getGeometricMean(), 0.00001 ); // Now test rolling - StorelessDescriptiveStatistics should discount the contribution // of a discarded element for( int i = 0; i < 10; i++ ) { u.addValue( i + 2 ); } // Values should be (2,3,4,5,6,7,8,9,10,11) Assert.assertEquals( "Geometric mean not expected", 5.755931, u.getGeometricMean(), 0.00001 ); } /** test stats */ @Test public void testSerialization() { DescriptiveStatistics u = new ListUnivariateImpl(); Assert.assertEquals("total count",0,u.getN(),tolerance); u.addValue(one); u.addValue(two); DescriptiveStatistics u2 = (DescriptiveStatistics)TestUtils.serializeAndRecover(u); u2.addValue(two); u2.addValue(three); Assert.assertEquals("N",n,u2.getN(),tolerance); Assert.assertEquals("sum",sum,u2.getSum(),tolerance); Assert.assertEquals("sumsq",sumSq,u2.getSumsq(),tolerance); Assert.assertEquals("var",var,u2.getVariance(),tolerance); Assert.assertEquals("std",std,u2.getStandardDeviation(),tolerance); Assert.assertEquals("mean",mean,u2.getMean(),tolerance); Assert.assertEquals("min",min,u2.getMin(),tolerance); Assert.assertEquals("max",max,u2.getMax(),tolerance); u2.clear(); Assert.assertEquals("total count",0,u2.getN(),tolerance); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.descriptive; import java.io.Serializable; import java.util.ArrayList; import java.util.List; import org.apache.commons.math3.util.FastMath; import org.apache.commons.math3.util.NumberTransformer; import org.apache.commons.math3.util.TransformerMap; import org.junit.Assert; import org.junit.Test; /** * Test cases for the {@link ListUnivariateImpl} class. * * @version $Id$ */ public final class MixedListUnivariateImplTest { private double one = 1; private float two = 2; private int three = 3; private double mean = 2; private double sumSq = 18; private double sum = 8; private double var = 0.666666666666666666667; private double std = FastMath.sqrt(var); private double n = 4; private double min = 1; private double max = 3; private double tolerance = 10E-15; private TransformerMap transformers = new TransformerMap(); public MixedListUnivariateImplTest() { transformers = new TransformerMap(); transformers.putTransformer(Foo.class, new FooTransformer()); transformers.putTransformer(Bar.class, new BarTransformer()); } /** test stats */ @Test public void testStats() { List<Object> externalList = new ArrayList<Object>(); DescriptiveStatistics u = new ListUnivariateImpl(externalList,transformers); Assert.assertEquals("total count", 0, u.getN(), tolerance); u.addValue(one); u.addValue(two); u.addValue(two); u.addValue(three); Assert.assertEquals("N", n, u.getN(), tolerance); Assert.assertEquals("sum", sum, u.getSum(), tolerance); Assert.assertEquals("sumsq", sumSq, u.getSumsq(), tolerance); Assert.assertEquals("var", var, u.getVariance(), tolerance); Assert.assertEquals("std", std, u.getStandardDeviation(), tolerance); Assert.assertEquals("mean", mean, u.getMean(), tolerance); Assert.assertEquals("min", min, u.getMin(), tolerance); Assert.assertEquals("max", max, u.getMax(), tolerance); u.clear(); Assert.assertEquals("total count", 0, u.getN(), tolerance); } @Test public void testN0andN1Conditions() { DescriptiveStatistics u = new ListUnivariateImpl(new ArrayList<Object>(),transformers); Assert.assertTrue( "Mean of n = 0 set should be NaN", Double.isNaN(u.getMean())); Assert.assertTrue( "Standard Deviation of n = 0 set should be NaN", Double.isNaN(u.getStandardDeviation())); Assert.assertTrue( "Variance of n = 0 set should be NaN", Double.isNaN(u.getVariance())); u.addValue(one); Assert.assertTrue( "Mean of n = 1 set should be value of single item n1, instead it is " + u.getMean() , u.getMean() == one); Assert.assertTrue( "StdDev of n = 1 set should be zero, instead it is: " + u.getStandardDeviation(), u.getStandardDeviation() == 0); Assert.assertTrue( "Variance of n = 1 set should be zero", u.getVariance() == 0); } @Test public void testSkewAndKurtosis() { ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList<Object>(), transformers); u.addObject("12.5"); u.addObject(Integer.valueOf(12)); u.addObject("11.8"); u.addObject("14.2"); u.addObject(new Foo()); u.addObject("14.5"); u.addObject(Long.valueOf(21)); u.addObject("8.2"); u.addObject("10.3"); u.addObject("11.3"); u.addObject(Float.valueOf(14.1f)); u.addObject("9.9"); u.addObject("12.2"); u.addObject(new Bar()); u.addObject("12.1"); u.addObject("11"); u.addObject(Double.valueOf(19.8)); u.addObject("11"); u.addObject("10"); u.addObject("8.8"); u.addObject("9"); u.addObject("12.3"); Assert.assertEquals("mean", 12.40455, u.getMean(), 0.0001); Assert.assertEquals("variance", 10.00236, u.getVariance(), 0.0001); Assert.assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001); Assert.assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001); } @Test public void testProductAndGeometricMean() { ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList<Object>(),transformers); u.setWindowSize(10); u.addValue(1.0); u.addValue(2.0); u.addValue(3.0); u.addValue(4.0); Assert.assertEquals( "Geometric mean not expected", 2.213364, u.getGeometricMean(), 0.00001); // Now test rolling - StorelessDescriptiveStatistics should discount the contribution // of a discarded element for (int i = 0; i < 10; i++) { u.addValue(i + 2); } // Values should be (2,3,4,5,6,7,8,9,10,11) Assert.assertEquals( "Geometric mean not expected", 5.755931, u.getGeometricMean(), 0.00001); } public static final class Foo { public String heresFoo() { return "14.9"; } } public static final class FooTransformer implements NumberTransformer, Serializable { private static final long serialVersionUID = -4252248129291326127L; public double transform(Object o) { return Double.parseDouble(((Foo) o).heresFoo()); } } public static final class Bar { public String heresBar() { return "12.0"; } } public static final class BarTransformer implements NumberTransformer, Serializable { private static final long serialVersionUID = -1768345377764262043L; public double transform(Object o) { return Double.parseDouble(((Bar) o).heresBar()); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.descriptive; import java.util.Locale; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.stat.descriptive.moment.Mean; import org.apache.commons.math3.util.FastMath; import org.junit.Test; import org.junit.Assert; /** * Test cases for the {@link MultivariateSummaryStatistics} class. * * @version $Id$ */ public class MultivariateSummaryStatisticsTest { protected MultivariateSummaryStatistics createMultivariateSummaryStatistics(int k, boolean isCovarianceBiasCorrected) { return new MultivariateSummaryStatistics(k, isCovarianceBiasCorrected); } @Test public void testSetterInjection() { MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(2, true); u.setMeanImpl(new StorelessUnivariateStatistic[] { new sumMean(), new sumMean() }); u.addValue(new double[] { 1, 2 }); u.addValue(new double[] { 3, 4 }); Assert.assertEquals(4, u.getMean()[0], 1E-14); Assert.assertEquals(6, u.getMean()[1], 1E-14); u.clear(); u.addValue(new double[] { 1, 2 }); u.addValue(new double[] { 3, 4 }); Assert.assertEquals(4, u.getMean()[0], 1E-14); Assert.assertEquals(6, u.getMean()[1], 1E-14); u.clear(); u.setMeanImpl(new StorelessUnivariateStatistic[] { new Mean(), new Mean() }); // OK after clear u.addValue(new double[] { 1, 2 }); u.addValue(new double[] { 3, 4 }); Assert.assertEquals(2, u.getMean()[0], 1E-14); Assert.assertEquals(3, u.getMean()[1], 1E-14); Assert.assertEquals(2, u.getDimension()); } @Test public void testSetterIllegalState() { MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(2, true); u.addValue(new double[] { 1, 2 }); u.addValue(new double[] { 3, 4 }); try { u.setMeanImpl(new StorelessUnivariateStatistic[] { new sumMean(), new sumMean() }); Assert.fail("Expecting IllegalStateException"); } catch (IllegalStateException ex) { // expected } } @Test public void testToString() { MultivariateSummaryStatistics stats = createMultivariateSummaryStatistics(2, true); stats.addValue(new double[] {1, 3}); stats.addValue(new double[] {2, 2}); stats.addValue(new double[] {3, 1}); Locale d = Locale.getDefault(); Locale.setDefault(Locale.US); final String suffix = System.getProperty("line.separator"); Assert.assertEquals("MultivariateSummaryStatistics:" + suffix+ "n: 3" +suffix+ "min: 1.0, 1.0" +suffix+ "max: 3.0, 3.0" +suffix+ "mean: 2.0, 2.0" +suffix+ "geometric mean: 1.817..., 1.817..." +suffix+ "sum of squares: 14.0, 14.0" +suffix+ "sum of logarithms: 1.791..., 1.791..." +suffix+ "standard deviation: 1.0, 1.0" +suffix+ "covariance: Array2DRowRealMatrix{{1.0,-1.0},{-1.0,1.0}}" +suffix, stats.toString().replaceAll("([0-9]+\\.[0-9][0-9][0-9])[0-9]+", "$1...")); Locale.setDefault(d); } @Test public void testShuffledStatistics() { // the purpose of this test is only to check the get/set methods // we are aware shuffling statistics like this is really not // something sensible to do in production ... MultivariateSummaryStatistics reference = createMultivariateSummaryStatistics(2, true); MultivariateSummaryStatistics shuffled = createMultivariateSummaryStatistics(2, true); StorelessUnivariateStatistic[] tmp = shuffled.getGeoMeanImpl(); shuffled.setGeoMeanImpl(shuffled.getMeanImpl()); shuffled.setMeanImpl(shuffled.getMaxImpl()); shuffled.setMaxImpl(shuffled.getMinImpl()); shuffled.setMinImpl(shuffled.getSumImpl()); shuffled.setSumImpl(shuffled.getSumsqImpl()); shuffled.setSumsqImpl(shuffled.getSumLogImpl()); shuffled.setSumLogImpl(tmp); for (int i = 100; i > 0; --i) { reference.addValue(new double[] {i, i}); shuffled.addValue(new double[] {i, i}); } TestUtils.assertEquals(reference.getMean(), shuffled.getGeometricMean(), 1.0e-10); TestUtils.assertEquals(reference.getMax(), shuffled.getMean(), 1.0e-10); TestUtils.assertEquals(reference.getMin(), shuffled.getMax(), 1.0e-10); TestUtils.assertEquals(reference.getSum(), shuffled.getMin(), 1.0e-10); TestUtils.assertEquals(reference.getSumSq(), shuffled.getSum(), 1.0e-10); TestUtils.assertEquals(reference.getSumLog(), shuffled.getSumSq(), 1.0e-10); TestUtils.assertEquals(reference.getGeometricMean(), shuffled.getSumLog(), 1.0e-10); } /** * Bogus mean implementation to test setter injection. * Returns the sum instead of the mean. */ static class sumMean implements StorelessUnivariateStatistic { private double sum = 0; private long n = 0; public double evaluate(double[] values, int begin, int length) { return 0; } public double evaluate(double[] values) { return 0; } public void clear() { sum = 0; n = 0; } public long getN() { return n; } public double getResult() { return sum; } public void increment(double d) { sum += d; n++; } public void incrementAll(double[] values, int start, int length) { } public void incrementAll(double[] values) { } public StorelessUnivariateStatistic copy() { return new sumMean(); } } @Test public void testDimension() { try { createMultivariateSummaryStatistics(2, true).addValue(new double[3]); Assert.fail("Expecting DimensionMismatchException"); } catch (DimensionMismatchException dme) { // expected behavior } } /** test stats */ @Test public void testStats() { MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(2, true); Assert.assertEquals(0, u.getN()); u.addValue(new double[] { 1, 2 }); u.addValue(new double[] { 2, 3 }); u.addValue(new double[] { 2, 3 }); u.addValue(new double[] { 3, 4 }); Assert.assertEquals( 4, u.getN()); Assert.assertEquals( 8, u.getSum()[0], 1.0e-10); Assert.assertEquals(12, u.getSum()[1], 1.0e-10); Assert.assertEquals(18, u.getSumSq()[0], 1.0e-10); Assert.assertEquals(38, u.getSumSq()[1], 1.0e-10); Assert.assertEquals( 1, u.getMin()[0], 1.0e-10); Assert.assertEquals( 2, u.getMin()[1], 1.0e-10); Assert.assertEquals( 3, u.getMax()[0], 1.0e-10); Assert.assertEquals( 4, u.getMax()[1], 1.0e-10); Assert.assertEquals(2.4849066497880003102, u.getSumLog()[0], 1.0e-10); Assert.assertEquals( 4.276666119016055311, u.getSumLog()[1], 1.0e-10); Assert.assertEquals( 1.8612097182041991979, u.getGeometricMean()[0], 1.0e-10); Assert.assertEquals( 2.9129506302439405217, u.getGeometricMean()[1], 1.0e-10); Assert.assertEquals( 2, u.getMean()[0], 1.0e-10); Assert.assertEquals( 3, u.getMean()[1], 1.0e-10); Assert.assertEquals(FastMath.sqrt(2.0 / 3.0), u.getStandardDeviation()[0], 1.0e-10); Assert.assertEquals(FastMath.sqrt(2.0 / 3.0), u.getStandardDeviation()[1], 1.0e-10); Assert.assertEquals(2.0 / 3.0, u.getCovariance().getEntry(0, 0), 1.0e-10); Assert.assertEquals(2.0 / 3.0, u.getCovariance().getEntry(0, 1), 1.0e-10); Assert.assertEquals(2.0 / 3.0, u.getCovariance().getEntry(1, 0), 1.0e-10); Assert.assertEquals(2.0 / 3.0, u.getCovariance().getEntry(1, 1), 1.0e-10); u.clear(); Assert.assertEquals(0, u.getN()); } @Test public void testN0andN1Conditions() { MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(1, true); Assert.assertTrue(Double.isNaN(u.getMean()[0])); Assert.assertTrue(Double.isNaN(u.getStandardDeviation()[0])); /* n=1 */ u.addValue(new double[] { 1 }); Assert.assertEquals(1.0, u.getMean()[0], 1.0e-10); Assert.assertEquals(1.0, u.getGeometricMean()[0], 1.0e-10); Assert.assertEquals(0.0, u.getStandardDeviation()[0], 1.0e-10); /* n=2 */ u.addValue(new double[] { 2 }); Assert.assertTrue(u.getStandardDeviation()[0] > 0); } @Test public void testNaNContracts() { MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(1, true); Assert.assertTrue(Double.isNaN(u.getMean()[0])); Assert.assertTrue(Double.isNaN(u.getMin()[0])); Assert.assertTrue(Double.isNaN(u.getStandardDeviation()[0])); Assert.assertTrue(Double.isNaN(u.getGeometricMean()[0])); u.addValue(new double[] { 1.0 }); Assert.assertFalse(Double.isNaN(u.getMean()[0])); Assert.assertFalse(Double.isNaN(u.getMin()[0])); Assert.assertFalse(Double.isNaN(u.getStandardDeviation()[0])); Assert.assertFalse(Double.isNaN(u.getGeometricMean()[0])); } @Test public void testSerialization() { MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(2, true); // Empty test TestUtils.checkSerializedEquality(u); MultivariateSummaryStatistics s = (MultivariateSummaryStatistics) TestUtils.serializeAndRecover(u); Assert.assertEquals(u, s); // Add some data u.addValue(new double[] { 2d, 1d }); u.addValue(new double[] { 1d, 1d }); u.addValue(new double[] { 3d, 1d }); u.addValue(new double[] { 4d, 1d }); u.addValue(new double[] { 5d, 1d }); // Test again TestUtils.checkSerializedEquality(u); s = (MultivariateSummaryStatistics) TestUtils.serializeAndRecover(u); Assert.assertEquals(u, s); } @Test public void testEqualsAndHashCode() { MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(2, true); MultivariateSummaryStatistics t = null; int emptyHash = u.hashCode(); Assert.assertTrue(u.equals(u)); Assert.assertFalse(u.equals(t)); Assert.assertFalse(u.equals(Double.valueOf(0))); t = createMultivariateSummaryStatistics(2, true); Assert.assertTrue(t.equals(u)); Assert.assertTrue(u.equals(t)); Assert.assertEquals(emptyHash, t.hashCode()); // Add some data to u u.addValue(new double[] { 2d, 1d }); u.addValue(new double[] { 1d, 1d }); u.addValue(new double[] { 3d, 1d }); u.addValue(new double[] { 4d, 1d }); u.addValue(new double[] { 5d, 1d }); Assert.assertFalse(t.equals(u)); Assert.assertFalse(u.equals(t)); Assert.assertTrue(u.hashCode() != t.hashCode()); //Add data in same order to t t.addValue(new double[] { 2d, 1d }); t.addValue(new double[] { 1d, 1d }); t.addValue(new double[] { 3d, 1d }); t.addValue(new double[] { 4d, 1d }); t.addValue(new double[] { 5d, 1d }); Assert.assertTrue(t.equals(u)); Assert.assertTrue(u.equals(t)); Assert.assertEquals(u.hashCode(), t.hashCode()); // Clear and make sure summaries are indistinguishable from empty summary u.clear(); t.clear(); Assert.assertTrue(t.equals(u)); Assert.assertTrue(u.equals(t)); Assert.assertEquals(emptyHash, t.hashCode()); Assert.assertEquals(emptyHash, u.hashCode()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.descriptive; import java.util.Locale; import org.apache.commons.math3.TestUtils; import org.junit.Assert; import org.junit.Test; /** * Test cases for the {@link StatisticalSummaryValues} class. * * @version $Id$ */ public final class StatisticalSummaryValuesTest { @Test public void testSerialization() { StatisticalSummaryValues u = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6); TestUtils.checkSerializedEquality(u); StatisticalSummaryValues t = (StatisticalSummaryValues) TestUtils.serializeAndRecover(u); verifyEquality(u, t); } @Test public void testEqualsAndHashCode() { StatisticalSummaryValues u = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6); StatisticalSummaryValues t = null; Assert.assertTrue("reflexive", u.equals(u)); Assert.assertFalse("non-null compared to null", u.equals(t)); Assert.assertFalse("wrong type", u.equals(Double.valueOf(0))); t = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6); Assert.assertTrue("instances with same data should be equal", t.equals(u)); Assert.assertEquals("hash code", u.hashCode(), t.hashCode()); u = new StatisticalSummaryValues(Double.NaN, 2, 3, 4, 5, 6); t = new StatisticalSummaryValues(1, Double.NaN, 3, 4, 5, 6); Assert.assertFalse("instances based on different data should be different", (u.equals(t) ||t.equals(u))); } private void verifyEquality(StatisticalSummaryValues s, StatisticalSummaryValues u) { Assert.assertEquals("N",s.getN(),u.getN()); TestUtils.assertEquals("sum",s.getSum(),u.getSum(), 0); TestUtils.assertEquals("var",s.getVariance(),u.getVariance(), 0); TestUtils.assertEquals("std",s.getStandardDeviation(),u.getStandardDeviation(), 0); TestUtils.assertEquals("mean",s.getMean(),u.getMean(), 0); TestUtils.assertEquals("min",s.getMin(),u.getMin(), 0); TestUtils.assertEquals("max",s.getMax(),u.getMax(), 0); } @Test public void testToString() { StatisticalSummaryValues u = new StatisticalSummaryValues(4.5, 16, 10, 5, 4, 45); Locale d = Locale.getDefault(); Locale.setDefault(Locale.US); Assert.assertEquals("StatisticalSummaryValues:\n" + "n: 10\n" + "min: 4.0\n" + "max: 5.0\n" + "mean: 4.5\n" + "std dev: 4.0\n" + "variance: 16.0\n" + "sum: 45.0\n", u.toString()); Locale.setDefault(d); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.descriptive; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.stat.descriptive.moment.GeometricMean; import org.apache.commons.math3.stat.descriptive.moment.Mean; import org.apache.commons.math3.stat.descriptive.moment.Variance; import org.apache.commons.math3.stat.descriptive.summary.Sum; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * Test cases for the {@link SummaryStatistics} class. * * @version $Id$ */ public class SummaryStatisticsTest { private double one = 1; private float twoF = 2; private long twoL = 2; private int three = 3; private double mean = 2; private double sumSq = 18; private double sum = 8; private double var = 0.666666666666666666667; private double popVar = 0.5; private double std = FastMath.sqrt(var); private double n = 4; private double min = 1; private double max = 3; private double tolerance = 10E-15; protected SummaryStatistics createSummaryStatistics() { return new SummaryStatistics(); } /** test stats */ @Test public void testStats() { SummaryStatistics u = createSummaryStatistics(); Assert.assertEquals("total count",0,u.getN(),tolerance); u.addValue(one); u.addValue(twoF); u.addValue(twoL); u.addValue(three); Assert.assertEquals("N",n,u.getN(),tolerance); Assert.assertEquals("sum",sum,u.getSum(),tolerance); Assert.assertEquals("sumsq",sumSq,u.getSumsq(),tolerance); Assert.assertEquals("var",var,u.getVariance(),tolerance); Assert.assertEquals("population var",popVar,u.getPopulationVariance(),tolerance); Assert.assertEquals("std",std,u.getStandardDeviation(),tolerance); Assert.assertEquals("mean",mean,u.getMean(),tolerance); Assert.assertEquals("min",min,u.getMin(),tolerance); Assert.assertEquals("max",max,u.getMax(),tolerance); u.clear(); Assert.assertEquals("total count",0,u.getN(),tolerance); } @Test public void testN0andN1Conditions() { SummaryStatistics u = createSummaryStatistics(); Assert.assertTrue("Mean of n = 0 set should be NaN", Double.isNaN( u.getMean() ) ); Assert.assertTrue("Standard Deviation of n = 0 set should be NaN", Double.isNaN( u.getStandardDeviation() ) ); Assert.assertTrue("Variance of n = 0 set should be NaN", Double.isNaN(u.getVariance() ) ); /* n=1 */ u.addValue(one); Assert.assertTrue("mean should be one (n = 1)", u.getMean() == one); Assert.assertTrue("geometric should be one (n = 1) instead it is " + u.getGeometricMean(), u.getGeometricMean() == one); Assert.assertTrue("Std should be zero (n = 1)", u.getStandardDeviation() == 0.0); Assert.assertTrue("variance should be zero (n = 1)", u.getVariance() == 0.0); /* n=2 */ u.addValue(twoF); Assert.assertTrue("Std should not be zero (n = 2)", u.getStandardDeviation() != 0.0); Assert.assertTrue("variance should not be zero (n = 2)", u.getVariance() != 0.0); } @Test public void testProductAndGeometricMean() { SummaryStatistics u = createSummaryStatistics(); u.addValue( 1.0 ); u.addValue( 2.0 ); u.addValue( 3.0 ); u.addValue( 4.0 ); Assert.assertEquals( "Geometric mean not expected", 2.213364, u.getGeometricMean(), 0.00001 ); } @Test public void testNaNContracts() { SummaryStatistics u = createSummaryStatistics(); Assert.assertTrue("mean not NaN",Double.isNaN(u.getMean())); Assert.assertTrue("min not NaN",Double.isNaN(u.getMin())); Assert.assertTrue("std dev not NaN",Double.isNaN(u.getStandardDeviation())); Assert.assertTrue("var not NaN",Double.isNaN(u.getVariance())); Assert.assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean())); u.addValue(1.0); Assert.assertEquals( "mean not expected", 1.0, u.getMean(), Double.MIN_VALUE); Assert.assertEquals( "variance not expected", 0.0, u.getVariance(), Double.MIN_VALUE); Assert.assertEquals( "geometric mean not expected", 1.0, u.getGeometricMean(), Double.MIN_VALUE); u.addValue(-1.0); Assert.assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean())); u.addValue(0.0); Assert.assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean())); //FiXME: test all other NaN contract specs } @Test public void testGetSummary() { SummaryStatistics u = createSummaryStatistics(); StatisticalSummary summary = u.getSummary(); verifySummary(u, summary); u.addValue(1d); summary = u.getSummary(); verifySummary(u, summary); u.addValue(2d); summary = u.getSummary(); verifySummary(u, summary); u.addValue(2d); summary = u.getSummary(); verifySummary(u, summary); } @Test public void testSerialization() { SummaryStatistics u = createSummaryStatistics(); // Empty test TestUtils.checkSerializedEquality(u); SummaryStatistics s = (SummaryStatistics) TestUtils.serializeAndRecover(u); StatisticalSummary summary = s.getSummary(); verifySummary(u, summary); // Add some data u.addValue(2d); u.addValue(1d); u.addValue(3d); u.addValue(4d); u.addValue(5d); // Test again TestUtils.checkSerializedEquality(u); s = (SummaryStatistics) TestUtils.serializeAndRecover(u); summary = s.getSummary(); verifySummary(u, summary); } @Test public void testEqualsAndHashCode() { SummaryStatistics u = createSummaryStatistics(); SummaryStatistics t = null; int emptyHash = u.hashCode(); Assert.assertTrue("reflexive", u.equals(u)); Assert.assertFalse("non-null compared to null", u.equals(t)); Assert.assertFalse("wrong type", u.equals(Double.valueOf(0))); t = createSummaryStatistics(); Assert.assertTrue("empty instances should be equal", t.equals(u)); Assert.assertTrue("empty instances should be equal", u.equals(t)); Assert.assertEquals("empty hash code", emptyHash, t.hashCode()); // Add some data to u u.addValue(2d); u.addValue(1d); u.addValue(3d); u.addValue(4d); Assert.assertFalse("different n's should make instances not equal", t.equals(u)); Assert.assertFalse("different n's should make instances not equal", u.equals(t)); Assert.assertTrue("different n's should make hashcodes different", u.hashCode() != t.hashCode()); //Add data in same order to t t.addValue(2d); t.addValue(1d); t.addValue(3d); t.addValue(4d); Assert.assertTrue("summaries based on same data should be equal", t.equals(u)); Assert.assertTrue("summaries based on same data should be equal", u.equals(t)); Assert.assertEquals("summaries based on same data should have same hashcodes", u.hashCode(), t.hashCode()); // Clear and make sure summaries are indistinguishable from empty summary u.clear(); t.clear(); Assert.assertTrue("empty instances should be equal", t.equals(u)); Assert.assertTrue("empty instances should be equal", u.equals(t)); Assert.assertEquals("empty hash code", emptyHash, t.hashCode()); Assert.assertEquals("empty hash code", emptyHash, u.hashCode()); } @Test public void testCopy() { SummaryStatistics u = createSummaryStatistics(); u.addValue(2d); u.addValue(1d); u.addValue(3d); u.addValue(4d); SummaryStatistics v = new SummaryStatistics(u); Assert.assertEquals(u, v); Assert.assertEquals(v, u); // Make sure both behave the same with additional values added u.addValue(7d); u.addValue(9d); u.addValue(11d); u.addValue(23d); v.addValue(7d); v.addValue(9d); v.addValue(11d); v.addValue(23d); Assert.assertEquals(u, v); Assert.assertEquals(v, u); // Check implementation pointers are preserved u.clear(); u.setSumImpl(new Sum()); SummaryStatistics.copy(u,v); Assert.assertEquals(u.getSumImpl(), v.getSumImpl()); } private void verifySummary(SummaryStatistics u, StatisticalSummary s) { Assert.assertEquals("N",s.getN(),u.getN()); TestUtils.assertEquals("sum",s.getSum(),u.getSum(),tolerance); TestUtils.assertEquals("var",s.getVariance(),u.getVariance(),tolerance); TestUtils.assertEquals("std",s.getStandardDeviation(),u.getStandardDeviation(),tolerance); TestUtils.assertEquals("mean",s.getMean(),u.getMean(),tolerance); TestUtils.assertEquals("min",s.getMin(),u.getMin(),tolerance); TestUtils.assertEquals("max",s.getMax(),u.getMax(),tolerance); } @Test public void testSetterInjection() { SummaryStatistics u = createSummaryStatistics(); u.setMeanImpl(new Sum()); u.setSumLogImpl(new Sum()); u.addValue(1); u.addValue(3); Assert.assertEquals(4, u.getMean(), 1E-14); Assert.assertEquals(4, u.getSumOfLogs(), 1E-14); Assert.assertEquals(FastMath.exp(2), u.getGeometricMean(), 1E-14); u.clear(); u.addValue(1); u.addValue(2); Assert.assertEquals(3, u.getMean(), 1E-14); u.clear(); u.setMeanImpl(new Mean()); // OK after clear } @Test public void testSetterIllegalState() { SummaryStatistics u = createSummaryStatistics(); u.addValue(1); u.addValue(3); try { u.setMeanImpl(new Sum()); Assert.fail("Expecting IllegalStateException"); } catch (IllegalStateException ex) { // expected } } /** * JIRA: MATH-691 */ @Test public void testOverrideVarianceWithMathClass() { double[] scores = {1, 2, 3, 4}; SummaryStatistics stats = new SummaryStatistics(); stats.setVarianceImpl(new Variance(false)); //use "population variance" for(double i : scores) { stats.addValue(i); } Assert.assertEquals((new Variance(false)).evaluate(scores),stats.getVariance(), 0); } @Test public void testOverrideMeanWithMathClass() { double[] scores = {1, 2, 3, 4}; SummaryStatistics stats = new SummaryStatistics(); stats.setMeanImpl(new Mean()); for(double i : scores) { stats.addValue(i); } Assert.assertEquals((new Mean()).evaluate(scores),stats.getMean(), 0); } @Test public void testOverrideGeoMeanWithMathClass() { double[] scores = {1, 2, 3, 4}; SummaryStatistics stats = new SummaryStatistics(); stats.setGeoMeanImpl(new GeometricMean()); for(double i : scores) { stats.addValue(i); } Assert.assertEquals((new GeometricMean()).evaluate(scores),stats.getGeometricMean(), 0); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */ package org.apache.commons.math3.stat.descriptive; /** * Test cases for the {@link SynchronizedDescriptiveStatisticsTest} class. * @version $Id$ * 2007) $ */ public final class SynchronizedDescriptiveStatisticsTest extends DescriptiveStatisticsTest { @Override protected DescriptiveStatistics createDescriptiveStatistics() { return new SynchronizedDescriptiveStatistics(); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */ package org.apache.commons.math3.stat.descriptive; /** * Test cases for the {@link SynchronizedMultivariateSummaryStatisticsTest} class. * @version $Id$ * 2007) $ */ public final class SynchronizedMultivariateSummaryStatisticsTest extends MultivariateSummaryStatisticsTest { @Override protected MultivariateSummaryStatistics createMultivariateSummaryStatistics(int k, boolean isCovarianceBiasCorrected) { return new SynchronizedMultivariateSummaryStatistics(k, isCovarianceBiasCorrected); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */ package org.apache.commons.math3.stat.descriptive; /** * Test cases for the {@link SynchronizedSummaryStatisticsTest} class. * @version $Id$ * 2007) $ */ public final class SynchronizedSummaryStatisticsTest extends SummaryStatisticsTest { @Override protected SummaryStatistics createSummaryStatistics() { return new SynchronizedSummaryStatistics(); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.descriptive.moment; import org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math3.stat.descriptive.UnivariateStatistic; /** * Test cases for the {@link FirstMoment} class. * @version $Id$ */ public class FirstMomentTest extends StorelessUnivariateStatisticAbstractTest{ /** descriptive statistic. */ protected FirstMoment stat; /** * @see org.apache.commons.math3.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic() */ @Override public UnivariateStatistic getUnivariateStatistic() { return new FirstMoment(); } /** * @see org.apache.commons.math3.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue() */ @Override public double expectedValue() { return this.mean; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.descriptive.moment; import org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math3.stat.descriptive.UnivariateStatistic; /** * Test cases for the {@link FourthMoment} class. * @version $Id$ */ public class FourthMomentTest extends StorelessUnivariateStatisticAbstractTest{ /** descriptive statistic. */ protected FourthMoment stat; /** * @see org.apache.commons.math3.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic() */ @Override public UnivariateStatistic getUnivariateStatistic() { return new FourthMoment(); } /** * @see org.apache.commons.math3.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue() */ @Override public double expectedValue() { return this.fourthMoment; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.descriptive.moment; import org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math3.stat.descriptive.UnivariateStatistic; import org.junit.Assert; import org.junit.Test; /** * Test cases for the {@link UnivariateStatistic} class. * @version $Id$ */ public class GeometricMeanTest extends StorelessUnivariateStatisticAbstractTest{ protected GeometricMean stat; /** * {@inheritDoc} */ @Override public UnivariateStatistic getUnivariateStatistic() { return new GeometricMean(); } /** * {@inheritDoc} */ @Override public double expectedValue() { return this.geoMean; } @Test public void testSpecialValues() { GeometricMean mean = new GeometricMean(); // empty Assert.assertTrue(Double.isNaN(mean.getResult())); // finite data mean.increment(1d); Assert.assertFalse(Double.isNaN(mean.getResult())); // add 0 -- makes log sum blow to minus infinity, should make 0 mean.increment(0d); Assert.assertEquals(0d, mean.getResult(), 0); // add positive infinity - note the minus infinity above mean.increment(Double.POSITIVE_INFINITY); Assert.assertTrue(Double.isNaN(mean.getResult())); // clear mean.clear(); Assert.assertTrue(Double.isNaN(mean.getResult())); // positive infinity by itself mean.increment(Double.POSITIVE_INFINITY); Assert.assertEquals(Double.POSITIVE_INFINITY, mean.getResult(), 0); // negative value -- should make NaN mean.increment(-2d); Assert.assertTrue(Double.isNaN(mean.getResult())); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.descriptive.moment; import org.junit.Assert; import org.junit.Test; /** * @version $Id$ */ public class InteractionTest { protected double mean = 12.40454545454550; protected double var = 10.00235930735930; protected double skew = 1.437423729196190; protected double kurt = 2.377191264804700; protected double tolerance = 10E-12; protected double[] testArray = { 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1, 9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 }; @Test public void testInteraction() { FourthMoment m4 = new FourthMoment(); Mean m = new Mean(m4); Variance v = new Variance(m4); Skewness s= new Skewness(m4); Kurtosis k = new Kurtosis(m4); for (int i = 0; i < testArray.length; i++){ m4.increment(testArray[i]); } Assert.assertEquals(mean,m.getResult(),tolerance); Assert.assertEquals(var,v.getResult(),tolerance); Assert.assertEquals(skew ,s.getResult(),tolerance); Assert.assertEquals(kurt,k.getResult(),tolerance); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.descriptive.moment; import org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math3.stat.descriptive.UnivariateStatistic; import org.junit.Assert; import org.junit.Test; /** * Test cases for the {@link UnivariateStatistic} class. * @version $Id$ */ public class KurtosisTest extends StorelessUnivariateStatisticAbstractTest{ protected Kurtosis stat; /** * {@inheritDoc} */ @Override public UnivariateStatistic getUnivariateStatistic() { return new Kurtosis(); } /** * {@inheritDoc} */ @Override public double expectedValue() { return this.kurt; } /** * Make sure Double.NaN is returned iff n < 4 * */ @Test public void testNaN() { Kurtosis kurt = new Kurtosis(); Assert.assertTrue(Double.isNaN(kurt.getResult())); kurt.increment(1d); Assert.assertTrue(Double.isNaN(kurt.getResult())); kurt.increment(1d); Assert.assertTrue(Double.isNaN(kurt.getResult())); kurt.increment(1d); Assert.assertTrue(Double.isNaN(kurt.getResult())); kurt.increment(1d); Assert.assertFalse(Double.isNaN(kurt.getResult())); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.descriptive.moment; import org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math3.stat.descriptive.UnivariateStatistic; import org.junit.Assert; import org.junit.Test; /** * Test cases for the {@link UnivariateStatistic} class. * @version $Id$ */ public class MeanTest extends StorelessUnivariateStatisticAbstractTest{ protected Mean stat; /** * {@inheritDoc} */ @Override public UnivariateStatistic getUnivariateStatistic() { return new Mean(); } /** * {@inheritDoc} */ @Override public double expectedValue() { return this.mean; } /**Expected value for the testArray defined in UnivariateStatisticAbstractTest */ public double expectedWeightedValue() { return this.weightedMean; } @Test public void testSmallSamples() { Mean mean = new Mean(); Assert.assertTrue(Double.isNaN(mean.getResult())); mean.increment(1d); Assert.assertEquals(1d, mean.getResult(), 0); } @Test public void testWeightedMean() { Mean mean = new Mean(); Assert.assertEquals(expectedWeightedValue(), mean.evaluate(testArray, testWeightsArray, 0, testArray.length), getTolerance()); Assert.assertEquals(expectedValue(), mean.evaluate(testArray, identicalWeightsArray, 0, testArray.length), getTolerance()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.descriptive.moment; import org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math3.stat.descriptive.UnivariateStatistic; /** * Test cases for the {@link SecondMoment} class. * @version $Id$ */ public class SecondMomentTest extends StorelessUnivariateStatisticAbstractTest { /** descriptive statistic. */ protected SecondMoment stat; /** * @see org.apache.commons.math3.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic() */ @Override public UnivariateStatistic getUnivariateStatistic() { return new SecondMoment(); } /** * @see org.apache.commons.math3.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue() */ @Override public double expectedValue() { return this.secondMoment; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.descriptive.moment; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.stat.StatUtils; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.junit.Assert; import org.junit.Test; public class SemiVarianceTest { @Test public void testInsufficientData() { double[] nothing = null; SemiVariance sv = new SemiVariance(); try { sv.evaluate(nothing); Assert.fail("null is not a valid data array."); } catch (MathIllegalArgumentException iae) { } try { sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE); sv.evaluate(nothing); Assert.fail("null is not a valid data array."); } catch (MathIllegalArgumentException iae) { } nothing = new double[] {}; Assert.assertTrue(Double.isNaN(sv.evaluate(nothing))); } @Test public void testSingleDown() { SemiVariance sv = new SemiVariance(); double[] values = { 50.0d }; double singletest = sv.evaluate(values); Assert.assertEquals(0.0d, singletest, 0); } @Test public void testSingleUp() { SemiVariance sv = new SemiVariance(SemiVariance.UPSIDE_VARIANCE); double[] values = { 50.0d }; double singletest = sv.evaluate(values); Assert.assertEquals(0.0d, singletest, 0); } @Test public void testSample() { final double[] values = { -2.0d, 2.0d, 4.0d, -2.0d, 22.0d, 11.0d, 3.0d, 14.0d, 5.0d }; final int length = values.length; final double mean = StatUtils.mean(values); // 6.333... final SemiVariance sv = new SemiVariance(); // Default bias correction is true final double downsideSemiVariance = sv.evaluate(values); // Downside is the default Assert.assertEquals(TestUtils.sumSquareDev(new double[] {-2d, 2d, 4d, -2d, 3d, 5d}, mean) / (length - 1), downsideSemiVariance, 1E-14); sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE); final double upsideSemiVariance = sv.evaluate(values); Assert.assertEquals(TestUtils.sumSquareDev(new double[] {22d, 11d, 14d}, mean) / (length - 1), upsideSemiVariance, 1E-14); // Verify that upper + lower semivariance against the mean sum to variance Assert.assertEquals(StatUtils.variance(values), downsideSemiVariance + upsideSemiVariance, 10e-12); } @Test public void testPopulation() { double[] values = { -2.0d, 2.0d, 4.0d, -2.0d, 22.0d, 11.0d, 3.0d, 14.0d, 5.0d }; SemiVariance sv = new SemiVariance(false); double singletest = sv.evaluate(values); Assert.assertEquals(19.556d, singletest, 0.01d); sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE); singletest = sv.evaluate(values); Assert.assertEquals(36.222d, singletest, 0.01d); } @Test public void testNonMeanCutoffs() { double[] values = { -2.0d, 2.0d, 4.0d, -2.0d, 22.0d, 11.0d, 3.0d, 14.0d, 5.0d }; SemiVariance sv = new SemiVariance(false); // Turn off bias correction - use df = length double singletest = sv.evaluate(values, 1.0d, SemiVariance.DOWNSIDE_VARIANCE, false, 0, values.length); Assert.assertEquals(TestUtils.sumSquareDev(new double[] { -2d, -2d }, 1.0d) / values.length, singletest, 0.01d); singletest = sv.evaluate(values, 3.0d, SemiVariance.UPSIDE_VARIANCE, false, 0, values.length); Assert.assertEquals(TestUtils.sumSquareDev(new double[] { 4d, 22d, 11d, 14d, 5d }, 3.0d) / values.length, singletest, 0.01d); } /** * Check that the lower + upper semivariance against the mean sum to the * variance. */ @Test public void testVarianceDecompMeanCutoff() { double[] values = { -2.0d, 2.0d, 4.0d, -2.0d, 22.0d, 11.0d, 3.0d, 14.0d, 5.0d }; double variance = StatUtils.variance(values); SemiVariance sv = new SemiVariance(true); // Bias corrected sv.setVarianceDirection(SemiVariance.DOWNSIDE_VARIANCE); final double lower = sv.evaluate(values); sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE); final double upper = sv.evaluate(values); Assert.assertEquals(variance, lower + upper, 10e-12); } /** * Check that upper and lower semivariances against a cutoff sum to the sum * of squared deviations of the full set of values against the cutoff * divided by df = length - 1 (assuming bias-corrected). */ @Test public void testVarianceDecompNonMeanCutoff() { double[] values = { -2.0d, 2.0d, 4.0d, -2.0d, 22.0d, 11.0d, 3.0d, 14.0d, 5.0d }; double target = 0; double totalSumOfSquares = TestUtils.sumSquareDev(values, target); SemiVariance sv = new SemiVariance(true); // Bias corrected sv.setVarianceDirection(SemiVariance.DOWNSIDE_VARIANCE); double lower = sv.evaluate(values, target); sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE); double upper = sv.evaluate(values, target); Assert.assertEquals(totalSumOfSquares / (values.length - 1), lower + upper, 10e-12); } @Test public void testNoVariance() { final double[] values = {100d, 100d, 100d, 100d}; SemiVariance sv = new SemiVariance(); Assert.assertEquals(0, sv.evaluate(values), 10E-12); Assert.assertEquals(0, sv.evaluate(values, 100d), 10E-12); Assert.assertEquals(0, sv.evaluate(values, 100d, SemiVariance.UPSIDE_VARIANCE, false, 0, values.length), 10E-12); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.descriptive.moment; import org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math3.stat.descriptive.UnivariateStatistic; import org.junit.Assert; import org.junit.Test; /** * Test cases for the {@link UnivariateStatistic} class. * * @version $Id$ */ public class SkewnessTest extends StorelessUnivariateStatisticAbstractTest{ protected Skewness stat; /** * {@inheritDoc} */ @Override public UnivariateStatistic getUnivariateStatistic() { return new Skewness(); } /** * {@inheritDoc} */ @Override public double expectedValue() { return this.skew; } /** * Make sure Double.NaN is returned iff n < 3 * */ @Test public void testNaN() { Skewness skew = new Skewness(); Assert.assertTrue(Double.isNaN(skew.getResult())); skew.increment(1d); Assert.assertTrue(Double.isNaN(skew.getResult())); skew.increment(1d); Assert.assertTrue(Double.isNaN(skew.getResult())); skew.increment(1d); Assert.assertFalse(Double.isNaN(skew.getResult())); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.descriptive.moment; import org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math3.stat.descriptive.UnivariateStatistic; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * Test cases for the {@link UnivariateStatistic} class. * * @version $Id$ */ public class StandardDeviationTest extends StorelessUnivariateStatisticAbstractTest{ protected StandardDeviation stat; /** * {@inheritDoc} */ @Override public UnivariateStatistic getUnivariateStatistic() { return new StandardDeviation(); } /** * {@inheritDoc} */ @Override public double expectedValue() { return this.std; } /** * Make sure Double.NaN is returned iff n = 0 * */ @Test public void testNaN() { StandardDeviation std = new StandardDeviation(); Assert.assertTrue(Double.isNaN(std.getResult())); std.increment(1d); Assert.assertEquals(0d, std.getResult(), 0); } /** * Test population version of variance */ @Test public void testPopulation() { double[] values = {-1.0d, 3.1d, 4.0d, -2.1d, 22d, 11.7d, 3d, 14d}; double sigma = populationStandardDeviation(values); SecondMoment m = new SecondMoment(); m.evaluate(values); // side effect is to add values StandardDeviation s1 = new StandardDeviation(); s1.setBiasCorrected(false); Assert.assertEquals(sigma, s1.evaluate(values), 1E-14); s1.incrementAll(values); Assert.assertEquals(sigma, s1.getResult(), 1E-14); s1 = new StandardDeviation(false, m); Assert.assertEquals(sigma, s1.getResult(), 1E-14); s1 = new StandardDeviation(false); Assert.assertEquals(sigma, s1.evaluate(values), 1E-14); s1.incrementAll(values); Assert.assertEquals(sigma, s1.getResult(), 1E-14); } /** * Definitional formula for population standard deviation */ protected double populationStandardDeviation(double[] v) { double mean = new Mean().evaluate(v); double sum = 0; for (int i = 0; i < v.length; i++) { sum += (v[i] - mean) * (v[i] - mean); } return FastMath.sqrt(sum / v.length); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.descriptive.moment; import org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math3.stat.descriptive.UnivariateStatistic; /** * Test cases for the {@link ThirdMoment} class. * @version $Id$ */ public class ThirdMomentTest extends StorelessUnivariateStatisticAbstractTest{ /** descriptive statistic. */ protected ThirdMoment stat; /** * @see org.apache.commons.math3.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic() */ @Override public UnivariateStatistic getUnivariateStatistic() { return new ThirdMoment(); } /** * @see org.apache.commons.math3.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue() */ @Override public double expectedValue() { return this.thirdMoment; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.descriptive.moment; import org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math3.stat.descriptive.UnivariateStatistic; import org.apache.commons.math3.util.MathArrays; import org.junit.Assert; import org.junit.Test; /** * Test cases for the {@link UnivariateStatistic} class. * * @version $Id$ */ public class VarianceTest extends StorelessUnivariateStatisticAbstractTest{ protected Variance stat; /** * {@inheritDoc} */ @Override public UnivariateStatistic getUnivariateStatistic() { return new Variance(); } /** * {@inheritDoc} */ @Override public double expectedValue() { return this.var; } /**Expected value for the testArray defined in UnivariateStatisticAbstractTest */ public double expectedWeightedValue() { return this.weightedVar; } /** * Make sure Double.NaN is returned iff n = 0 * */ @Test public void testNaN() { StandardDeviation std = new StandardDeviation(); Assert.assertTrue(Double.isNaN(std.getResult())); std.increment(1d); Assert.assertEquals(0d, std.getResult(), 0); } /** * Test population version of variance */ @Test public void testPopulation() { double[] values = {-1.0d, 3.1d, 4.0d, -2.1d, 22d, 11.7d, 3d, 14d}; SecondMoment m = new SecondMoment(); m.evaluate(values); // side effect is to add values Variance v1 = new Variance(); v1.setBiasCorrected(false); Assert.assertEquals(populationVariance(values), v1.evaluate(values), 1E-14); v1.incrementAll(values); Assert.assertEquals(populationVariance(values), v1.getResult(), 1E-14); v1 = new Variance(false, m); Assert.assertEquals(populationVariance(values), v1.getResult(), 1E-14); v1 = new Variance(false); Assert.assertEquals(populationVariance(values), v1.evaluate(values), 1E-14); v1.incrementAll(values); Assert.assertEquals(populationVariance(values), v1.getResult(), 1E-14); } /** * Definitional formula for population variance */ protected double populationVariance(double[] v) { double mean = new Mean().evaluate(v); double sum = 0; for (int i = 0; i < v.length; i++) { sum += (v[i] - mean) * (v[i] - mean); } return sum / v.length; } @Test public void testWeightedVariance() { Variance variance = new Variance(); Assert.assertEquals(expectedWeightedValue(), variance.evaluate(testArray, testWeightsArray, 0, testArray.length), getTolerance()); // All weights = 1 -> weighted variance = unweighted variance Assert.assertEquals(expectedValue(), variance.evaluate(testArray, unitWeightsArray, 0, testArray.length), getTolerance()); // All weights the same -> when weights are normalized to sum to the length of the values array, // weighted variance = unweighted value Assert.assertEquals(expectedValue(), variance.evaluate(testArray, MathArrays.normalizeArray(identicalWeightsArray, testArray.length), 0, testArray.length), getTolerance()); } }
//Licensed to the Apache Software Foundation (ASF) under one //or more contributor license agreements. See the NOTICE file //distributed with this work for additional information //regarding copyright ownership. The ASF licenses this file //to you under the Apache License, Version 2.0 (the //"License"); you may not use this file except in compliance //with the License. You may obtain a copy of the License at //http://www.apache.org/licenses/LICENSE-2.0 //Unless required by applicable law or agreed to in writing, //software distributed under the License is distributed on an //"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY //KIND, either express or implied. See the License for the //specific language governing permissions and limitations //under the License. package org.apache.commons.math3.stat.descriptive.moment; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.linear.RealMatrix; import org.junit.Test; import org.junit.Assert; public class VectorialCovarianceTest { private double[][] points; public VectorialCovarianceTest() { points = new double[][] { { 1.2, 2.3, 4.5}, {-0.7, 2.3, 5.0}, { 3.1, 0.0, -3.1}, { 6.0, 1.2, 4.2}, {-0.7, 2.3, 5.0} }; } @Test public void testMismatch() { try { new VectorialCovariance(8, true).increment(new double[5]); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException dme) { Assert.assertEquals(5, dme.getArgument()); Assert.assertEquals(8, dme.getDimension()); } } @Test public void testSimplistic() { VectorialCovariance stat = new VectorialCovariance(2, true); stat.increment(new double[] {-1.0, 1.0}); stat.increment(new double[] { 1.0, -1.0}); RealMatrix c = stat.getResult(); Assert.assertEquals( 2.0, c.getEntry(0, 0), 1.0e-12); Assert.assertEquals(-2.0, c.getEntry(1, 0), 1.0e-12); Assert.assertEquals( 2.0, c.getEntry(1, 1), 1.0e-12); } @Test public void testBasicStats() { VectorialCovariance stat = new VectorialCovariance(points[0].length, true); for (int i = 0; i < points.length; ++i) { stat.increment(points[i]); } Assert.assertEquals(points.length, stat.getN()); RealMatrix c = stat.getResult(); double[][] refC = new double[][] { { 8.0470, -1.9195, -3.4445}, {-1.9195, 1.0470, 3.2795}, {-3.4445, 3.2795, 12.2070} }; for (int i = 0; i < c.getRowDimension(); ++i) { for (int j = 0; j <= i; ++j) { Assert.assertEquals(refC[i][j], c.getEntry(i, j), 1.0e-12); } } } @Test public void testSerial(){ VectorialCovariance stat = new VectorialCovariance(points[0].length, true); Assert.assertEquals(stat, TestUtils.serializeAndRecover(stat)); } }
//Licensed to the Apache Software Foundation (ASF) under one //or more contributor license agreements. See the NOTICE file //distributed with this work for additional information //regarding copyright ownership. The ASF licenses this file //to you under the Apache License, Version 2.0 (the //"License"); you may not use this file except in compliance //with the License. You may obtain a copy of the License at //http://www.apache.org/licenses/LICENSE-2.0 //Unless required by applicable law or agreed to in writing, //software distributed under the License is distributed on an //"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY //KIND, either express or implied. See the License for the //specific language governing permissions and limitations //under the License. package org.apache.commons.math3.stat.descriptive.moment; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.TestUtils; import org.junit.Test; import org.junit.Assert; public class VectorialMeanTest { private double[][] points; public VectorialMeanTest() { points = new double[][] { { 1.2, 2.3, 4.5}, {-0.7, 2.3, 5.0}, { 3.1, 0.0, -3.1}, { 6.0, 1.2, 4.2}, {-0.7, 2.3, 5.0} }; } @Test public void testMismatch() { try { new VectorialMean(8).increment(new double[5]); Assert.fail("an exception should have been thrown"); } catch (DimensionMismatchException dme) { Assert.assertEquals(5, dme.getArgument()); Assert.assertEquals(8, dme.getDimension()); } } @Test public void testSimplistic() { VectorialMean stat = new VectorialMean(2); stat.increment(new double[] {-1.0, 1.0}); stat.increment(new double[] { 1.0, -1.0}); double[] mean = stat.getResult(); Assert.assertEquals(0.0, mean[0], 1.0e-12); Assert.assertEquals(0.0, mean[1], 1.0e-12); } @Test public void testBasicStats() { VectorialMean stat = new VectorialMean(points[0].length); for (int i = 0; i < points.length; ++i) { stat.increment(points[i]); } Assert.assertEquals(points.length, stat.getN()); double[] mean = stat.getResult(); double[] refMean = new double[] { 1.78, 1.62, 3.12}; for (int i = 0; i < mean.length; ++i) { Assert.assertEquals(refMean[i], mean[i], 1.0e-12); } } @Test public void testSerial() { VectorialMean stat = new VectorialMean(points[0].length); for (int i = 0; i < points.length; ++i) { stat.increment(points[i]); } Assert.assertEquals(stat, TestUtils.serializeAndRecover(stat)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.descriptive.rank; import org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math3.stat.descriptive.UnivariateStatistic; import org.junit.Assert; import org.junit.Test; /** * Test cases for the {@link UnivariateStatistic} class. * @version $Id$ */ public class MaxTest extends StorelessUnivariateStatisticAbstractTest { protected Max stat; /** * {@inheritDoc} */ @Override public UnivariateStatistic getUnivariateStatistic() { return new Max(); } /** * {@inheritDoc} */ @Override public double expectedValue() { return this.max; } @Test public void testSpecialValues() { double[] testArray = {0d, Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY}; Max max = new Max(); Assert.assertTrue(Double.isNaN(max.getResult())); max.increment(testArray[0]); Assert.assertEquals(0d, max.getResult(), 0); max.increment(testArray[1]); Assert.assertEquals(0d, max.getResult(), 0); max.increment(testArray[2]); Assert.assertEquals(0d, max.getResult(), 0); max.increment(testArray[3]); Assert.assertEquals(Double.POSITIVE_INFINITY, max.getResult(), 0); Assert.assertEquals(Double.POSITIVE_INFINITY, max.evaluate(testArray), 0); } @Test public void testNaNs() { Max max = new Max(); double nan = Double.NaN; Assert.assertEquals(3d, max.evaluate(new double[]{nan, 2d, 3d}), 0); Assert.assertEquals(3d, max.evaluate(new double[]{1d, nan, 3d}), 0); Assert.assertEquals(2d, max.evaluate(new double[]{1d, 2d, nan}), 0); Assert.assertTrue(Double.isNaN(max.evaluate(new double[]{nan, nan, nan}))); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.descriptive.rank; import org.apache.commons.math3.stat.descriptive.UnivariateStatistic; import org.apache.commons.math3.stat.descriptive.UnivariateStatisticAbstractTest; /** * Test cases for the {@link UnivariateStatistic} class. * @version $Id$ */ public class MedianTest extends UnivariateStatisticAbstractTest{ protected Median stat; /** * {@inheritDoc} */ @Override public UnivariateStatistic getUnivariateStatistic() { return new Median(); } /** * {@inheritDoc} */ @Override public double expectedValue() { return this.median; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.descriptive.rank; import org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math3.stat.descriptive.UnivariateStatistic; import org.junit.Assert; import org.junit.Test; /** * Test cases for the {@link UnivariateStatistic} class. * @version $Id$ */ public class MinTest extends StorelessUnivariateStatisticAbstractTest{ protected Min stat; /** * {@inheritDoc} */ @Override public UnivariateStatistic getUnivariateStatistic() { return new Min(); } /** * {@inheritDoc} */ @Override public double expectedValue() { return this.min; } @Test public void testSpecialValues() { double[] testArray = {0d, Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY}; Min min = new Min(); Assert.assertTrue(Double.isNaN(min.getResult())); min.increment(testArray[0]); Assert.assertEquals(0d, min.getResult(), 0); min.increment(testArray[1]); Assert.assertEquals(0d, min.getResult(), 0); min.increment(testArray[2]); Assert.assertEquals(0d, min.getResult(), 0); min.increment(testArray[3]); Assert.assertEquals(Double.NEGATIVE_INFINITY, min.getResult(), 0); Assert.assertEquals(Double.NEGATIVE_INFINITY, min.evaluate(testArray), 0); } @Test public void testNaNs() { Min min = new Min(); double nan = Double.NaN; Assert.assertEquals(2d, min.evaluate(new double[]{nan, 2d, 3d}), 0); Assert.assertEquals(1d, min.evaluate(new double[]{1d, nan, 3d}), 0); Assert.assertEquals(1d, min.evaluate(new double[]{1d, 2d, nan}), 0); Assert.assertTrue(Double.isNaN(min.evaluate(new double[]{nan, nan, nan}))); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.descriptive.rank; import org.apache.commons.math3.stat.descriptive.UnivariateStatistic; import org.apache.commons.math3.stat.descriptive.UnivariateStatisticAbstractTest; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.junit.Assert; import org.junit.Test; /** * Test cases for the {@link UnivariateStatistic} class. * @version $Id$ */ public class PercentileTest extends UnivariateStatisticAbstractTest{ protected Percentile stat; /** * {@inheritDoc} */ @Override public UnivariateStatistic getUnivariateStatistic() { return new Percentile(95.0); } /** * {@inheritDoc} */ @Override public double expectedValue() { return this.percentile95; } @Test public void testHighPercentile(){ double[] d = new double[]{1, 2, 3}; Percentile p = new Percentile(75); Assert.assertEquals(3.0, p.evaluate(d), 1.0e-5); } @Test public void testLowPercentile() { double[] d = new double[] {0, 1}; Percentile p = new Percentile(25); Assert.assertEquals(0d, p.evaluate(d), Double.MIN_VALUE); } @Test public void testPercentile() { double[] d = new double[] {1, 3, 2, 4}; Percentile p = new Percentile(30); Assert.assertEquals(1.5, p.evaluate(d), 1.0e-5); p.setQuantile(25); Assert.assertEquals(1.25, p.evaluate(d), 1.0e-5); p.setQuantile(75); Assert.assertEquals(3.75, p.evaluate(d), 1.0e-5); p.setQuantile(50); Assert.assertEquals(2.5, p.evaluate(d), 1.0e-5); // invalid percentiles try { p.evaluate(d, 0, d.length, -1.0); Assert.fail(); } catch (MathIllegalArgumentException ex) { // success } try { p.evaluate(d, 0, d.length, 101.0); Assert.fail(); } catch (MathIllegalArgumentException ex) { // success } } @Test public void testNISTExample() { double[] d = new double[] {95.1772, 95.1567, 95.1937, 95.1959, 95.1442, 95.0610, 95.1591, 95.1195, 95.1772, 95.0925, 95.1990, 95.1682 }; Percentile p = new Percentile(90); Assert.assertEquals(95.1981, p.evaluate(d), 1.0e-4); Assert.assertEquals(95.1990, p.evaluate(d,0,d.length, 100d), 0); } @Test public void test5() { Percentile percentile = new Percentile(5); Assert.assertEquals(this.percentile5, percentile.evaluate(testArray), getTolerance()); } @Test public void testNullEmpty() { Percentile percentile = new Percentile(50); double[] nullArray = null; double[] emptyArray = new double[] {}; try { percentile.evaluate(nullArray); Assert.fail("Expecting MathIllegalArgumentException for null array"); } catch (MathIllegalArgumentException ex) { // expected } Assert.assertTrue(Double.isNaN(percentile.evaluate(emptyArray))); } @Test public void testSingleton() { Percentile percentile = new Percentile(50); double[] singletonArray = new double[] {1d}; Assert.assertEquals(1d, percentile.evaluate(singletonArray), 0); Assert.assertEquals(1d, percentile.evaluate(singletonArray, 0, 1), 0); Assert.assertEquals(1d, percentile.evaluate(singletonArray, 0, 1, 5), 0); Assert.assertEquals(1d, percentile.evaluate(singletonArray, 0, 1, 100), 0); Assert.assertTrue(Double.isNaN(percentile.evaluate(singletonArray, 0, 0))); } @Test public void testSpecialValues() { Percentile percentile = new Percentile(50); double[] specialValues = new double[] {0d, 1d, 2d, 3d, 4d, Double.NaN}; Assert.assertEquals(2.5d, percentile.evaluate(specialValues), 0); specialValues = new double[] {Double.NEGATIVE_INFINITY, 1d, 2d, 3d, Double.NaN, Double.POSITIVE_INFINITY}; Assert.assertEquals(2.5d, percentile.evaluate(specialValues), 0); specialValues = new double[] {1d, 1d, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY}; Assert.assertTrue(Double.isInfinite(percentile.evaluate(specialValues))); specialValues = new double[] {1d, 1d, Double.NaN, Double.NaN}; Assert.assertTrue(Double.isNaN(percentile.evaluate(specialValues))); specialValues = new double[] {1d, 1d, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY}; // Interpolation results in NEGATIVE_INFINITY + POSITIVE_INFINITY Assert.assertTrue(Double.isNaN(percentile.evaluate(specialValues))); } @Test public void testSetQuantile() { Percentile percentile = new Percentile(10); percentile.setQuantile(100); // OK Assert.assertEquals(100, percentile.getQuantile(), 0); try { percentile.setQuantile(0); Assert.fail("Expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // expected } try { new Percentile(0); Assert.fail("Expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.descriptive.summary; import org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic; import org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math3.stat.descriptive.UnivariateStatistic; import org.junit.Assert; import org.junit.Test; /** * Test cases for the {@link UnivariateStatistic} class. * @version $Id$ */ public class ProductTest extends StorelessUnivariateStatisticAbstractTest{ protected Product stat; /** * {@inheritDoc} */ @Override public UnivariateStatistic getUnivariateStatistic() { return new Product(); } /** * {@inheritDoc} */ @Override public double getTolerance() { return 10E8; //sic -- big absolute error due to only 15 digits of accuracy in double } /** * {@inheritDoc} */ @Override public double expectedValue() { return this.product; } /**Expected value for the testArray defined in UnivariateStatisticAbstractTest */ public double expectedWeightedValue() { return this.weightedProduct; } @Test public void testSpecialValues() { Product product = new Product(); Assert.assertEquals(1, product.getResult(), 0); product.increment(1); Assert.assertEquals(1, product.getResult(), 0); product.increment(Double.POSITIVE_INFINITY); Assert.assertEquals(Double.POSITIVE_INFINITY, product.getResult(), 0); product.increment(Double.NEGATIVE_INFINITY); Assert.assertEquals(Double.NEGATIVE_INFINITY, product.getResult(), 0); product.increment(Double.NaN); Assert.assertTrue(Double.isNaN(product.getResult())); product.increment(1); Assert.assertTrue(Double.isNaN(product.getResult())); } @Test public void testWeightedProduct() { Product product = new Product(); Assert.assertEquals(expectedWeightedValue(), product.evaluate(testArray, testWeightsArray, 0, testArray.length),getTolerance()); Assert.assertEquals(expectedValue(), product.evaluate(testArray, unitWeightsArray, 0, testArray.length), getTolerance()); } @Override protected void checkClearValue(StorelessUnivariateStatistic statistic){ Assert.assertEquals(1, statistic.getResult(), 0); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.descriptive.summary; import org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic; import org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math3.stat.descriptive.UnivariateStatistic; import org.junit.Assert; import org.junit.Test; /** * Test cases for the {@link UnivariateStatistic} class. * @version $Id$ */ public class SumLogTest extends StorelessUnivariateStatisticAbstractTest{ protected SumOfLogs stat; /** * {@inheritDoc} */ @Override public UnivariateStatistic getUnivariateStatistic() { return new SumOfLogs(); } /** * {@inheritDoc} */ @Override public double expectedValue() { return this.sumLog; } @Test public void testSpecialValues() { SumOfLogs sum = new SumOfLogs(); // empty Assert.assertEquals(0, sum.getResult(), 0); // finite data sum.increment(1d); Assert.assertFalse(Double.isNaN(sum.getResult())); // add negative infinity sum.increment(0d); Assert.assertEquals(Double.NEGATIVE_INFINITY, sum.getResult(), 0); // add positive infinity -- should make NaN sum.increment(Double.POSITIVE_INFINITY); Assert.assertTrue(Double.isNaN(sum.getResult())); // clear sum.clear(); Assert.assertEquals(0, sum.getResult(), 0); // positive infinity by itself sum.increment(Double.POSITIVE_INFINITY); Assert.assertEquals(Double.POSITIVE_INFINITY, sum.getResult(), 0); // negative value -- should make NaN sum.increment(-2d); Assert.assertTrue(Double.isNaN(sum.getResult())); } @Override protected void checkClearValue(StorelessUnivariateStatistic statistic){ Assert.assertEquals(0, statistic.getResult(), 0); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.descriptive.summary; import org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic; import org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math3.stat.descriptive.UnivariateStatistic; import org.junit.Assert; import org.junit.Test; /** * Test cases for the {@link SumOfSquares} class. * * @version $Id$ */ public class SumSqTest extends StorelessUnivariateStatisticAbstractTest{ protected SumOfSquares stat; /** * {@inheritDoc} */ @Override public UnivariateStatistic getUnivariateStatistic() { return new SumOfSquares(); } /** * {@inheritDoc} */ @Override public double expectedValue() { return this.sumSq; } @Test public void testSpecialValues() { SumOfSquares sumSq = new SumOfSquares(); Assert.assertEquals(0, sumSq.getResult(), 0); sumSq.increment(2d); Assert.assertEquals(4d, sumSq.getResult(), 0); sumSq.increment(Double.POSITIVE_INFINITY); Assert.assertEquals(Double.POSITIVE_INFINITY, sumSq.getResult(), 0); sumSq.increment(Double.NEGATIVE_INFINITY); Assert.assertEquals(Double.POSITIVE_INFINITY, sumSq.getResult(), 0); sumSq.increment(Double.NaN); Assert.assertTrue(Double.isNaN(sumSq.getResult())); sumSq.increment(1); Assert.assertTrue(Double.isNaN(sumSq.getResult())); } @Override protected void checkClearValue(StorelessUnivariateStatistic statistic){ Assert.assertEquals(0, statistic.getResult(), 0); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.descriptive.summary; import org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatistic; import org.apache.commons.math3.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math3.stat.descriptive.UnivariateStatistic; import org.junit.Assert; import org.junit.Test; /** * Test cases for the {@link Sum} class. * @version $Id$ */ public class SumTest extends StorelessUnivariateStatisticAbstractTest{ protected Sum stat; /** * {@inheritDoc} */ @Override public UnivariateStatistic getUnivariateStatistic() { return new Sum(); } /** * {@inheritDoc} */ @Override public double expectedValue() { return this.sum; } /**Expected value for the testArray defined in UnivariateStatisticAbstractTest */ public double expectedWeightedValue() { return this.weightedSum; } @Test public void testSpecialValues() { Sum sum = new Sum(); Assert.assertEquals(0, sum.getResult(), 0); sum.increment(1); Assert.assertEquals(1, sum.getResult(), 0); sum.increment(Double.POSITIVE_INFINITY); Assert.assertEquals(Double.POSITIVE_INFINITY, sum.getResult(), 0); sum.increment(Double.NEGATIVE_INFINITY); Assert.assertTrue(Double.isNaN(sum.getResult())); sum.increment(1); Assert.assertTrue(Double.isNaN(sum.getResult())); } @Test public void testWeightedSum() { Sum sum = new Sum(); Assert.assertEquals(expectedWeightedValue(), sum.evaluate(testArray, testWeightsArray, 0, testArray.length), getTolerance()); Assert.assertEquals(expectedValue(), sum.evaluate(testArray, unitWeightsArray, 0, testArray.length), getTolerance()); } @Override protected void checkClearValue(StorelessUnivariateStatistic statistic){ Assert.assertEquals(0, statistic.getResult(), 0); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.inference; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.NotPositiveException; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.apache.commons.math3.exception.OutOfRangeException; import org.apache.commons.math3.exception.ZeroException; import org.junit.Assert; import org.junit.Test; /** * Test cases for the ChiSquareTestImpl class. * * @version $Id$ */ public class ChiSquareTestTest { protected ChiSquareTest testStatistic = new ChiSquareTest(); @Test public void testChiSquare() { // Target values computed using R version 1.8.1 // Some assembly required ;-) // Use sum((obs - exp)^2/exp) for the chi-square statistic and // 1 - pchisq(sum((obs - exp)^2/exp), length(obs) - 1) for the p-value long[] observed = {10, 9, 11}; double[] expected = {10, 10, 10}; Assert.assertEquals("chi-square statistic", 0.2, testStatistic.chiSquare(expected, observed), 10E-12); Assert.assertEquals("chi-square p-value", 0.904837418036, testStatistic.chiSquareTest(expected, observed), 1E-10); long[] observed1 = { 500, 623, 72, 70, 31 }; double[] expected1 = { 485, 541, 82, 61, 37 }; Assert.assertEquals( "chi-square test statistic", 9.023307936427388, testStatistic.chiSquare(expected1, observed1), 1E-10); Assert.assertEquals("chi-square p-value", 0.06051952647453607, testStatistic.chiSquareTest(expected1, observed1), 1E-9); Assert.assertTrue("chi-square test reject", testStatistic.chiSquareTest(expected1, observed1, 0.08)); Assert.assertTrue("chi-square test accept", !testStatistic.chiSquareTest(expected1, observed1, 0.05)); try { testStatistic.chiSquareTest(expected1, observed1, 95); Assert.fail("alpha out of range, OutOfRangeException expected"); } catch (OutOfRangeException ex) { // expected } long[] tooShortObs = { 0 }; double[] tooShortEx = { 1 }; try { testStatistic.chiSquare(tooShortEx, tooShortObs); Assert.fail("arguments too short, DimensionMismatchException expected"); } catch (DimensionMismatchException ex) { // expected } // unmatched arrays long[] unMatchedObs = { 0, 1, 2, 3 }; double[] unMatchedEx = { 1, 1, 2 }; try { testStatistic.chiSquare(unMatchedEx, unMatchedObs); Assert.fail("arrays have different lengths, DimensionMismatchException expected"); } catch (DimensionMismatchException ex) { // expected } // 0 expected count expected[0] = 0; try { testStatistic.chiSquareTest(expected, observed, .01); Assert.fail("bad expected count, NotStrictlyPositiveException expected"); } catch (NotStrictlyPositiveException ex) { // expected } // negative observed count expected[0] = 1; observed[0] = -1; try { testStatistic.chiSquareTest(expected, observed, .01); Assert.fail("bad expected count, NotPositiveException expected"); } catch (NotPositiveException ex) { // expected } } @Test public void testChiSquareIndependence() { // Target values computed using R version 1.8.1 long[][] counts = { {40, 22, 43}, {91, 21, 28}, {60, 10, 22}}; Assert.assertEquals( "chi-square test statistic", 22.709027688, testStatistic.chiSquare(counts), 1E-9); Assert.assertEquals("chi-square p-value", 0.000144751460134, testStatistic.chiSquareTest(counts), 1E-9); Assert.assertTrue("chi-square test reject", testStatistic.chiSquareTest(counts, 0.0002)); Assert.assertTrue("chi-square test accept", !testStatistic.chiSquareTest(counts, 0.0001)); long[][] counts2 = {{10, 15}, {30, 40}, {60, 90} }; Assert.assertEquals( "chi-square test statistic", 0.168965517241, testStatistic.chiSquare(counts2), 1E-9); Assert.assertEquals("chi-square p-value",0.918987499852, testStatistic.chiSquareTest(counts2), 1E-9); Assert.assertTrue("chi-square test accept", !testStatistic.chiSquareTest(counts2, 0.1)); // ragged input array long[][] counts3 = { {40, 22, 43}, {91, 21, 28}, {60, 10}}; try { testStatistic.chiSquare(counts3); Assert.fail("Expecting DimensionMismatchException"); } catch (DimensionMismatchException ex) { // expected } // insufficient data long[][] counts4 = {{40, 22, 43}}; try { testStatistic.chiSquare(counts4); Assert.fail("Expecting DimensionMismatchException"); } catch (DimensionMismatchException ex) { // expected } long[][] counts5 = {{40}, {40}, {30}, {10}}; try { testStatistic.chiSquare(counts5); Assert.fail("Expecting DimensionMismatchException"); } catch (DimensionMismatchException ex) { // expected } // negative counts long[][] counts6 = {{10, -2}, {30, 40}, {60, 90} }; try { testStatistic.chiSquare(counts6); Assert.fail("Expecting NotPositiveException"); } catch (NotPositiveException ex) { // expected } // bad alpha try { testStatistic.chiSquareTest(counts, 0); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testChiSquareLargeTestStatistic() { double[] exp = new double[] { 3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0, 232921.0, 437665.75 }; long[] obs = new long[] { 2372383, 584222, 257170, 17750155, 7903832, 489265, 209628, 393899 }; org.apache.commons.math3.stat.inference.ChiSquareTest csti = new org.apache.commons.math3.stat.inference.ChiSquareTest(); double cst = csti.chiSquareTest(exp, obs); Assert.assertEquals("chi-square p-value", 0.0, cst, 1E-3); Assert.assertEquals( "chi-square test statistic", 114875.90421929007, testStatistic.chiSquare(exp, obs), 1E-9); } /** Contingency table containing zeros - PR # 32531 */ @Test public void testChiSquareZeroCount() { // Target values computed using R version 1.8.1 long[][] counts = { {40, 0, 4}, {91, 1, 2}, {60, 2, 0}}; Assert.assertEquals( "chi-square test statistic", 9.67444662263, testStatistic.chiSquare(counts), 1E-9); Assert.assertEquals("chi-square p-value", 0.0462835770603, testStatistic.chiSquareTest(counts), 1E-9); } /** Target values verified using DATAPLOT version 2006.3 */ @Test public void testChiSquareDataSetsComparisonEqualCounts() { long[] observed1 = {10, 12, 12, 10}; long[] observed2 = {5, 15, 14, 10}; Assert.assertEquals("chi-square p value", 0.541096, testStatistic.chiSquareTestDataSetsComparison( observed1, observed2), 1E-6); Assert.assertEquals("chi-square test statistic", 2.153846, testStatistic.chiSquareDataSetsComparison( observed1, observed2), 1E-6); Assert.assertFalse("chi-square test result", testStatistic.chiSquareTestDataSetsComparison( observed1, observed2, 0.4)); } /** Target values verified using DATAPLOT version 2006.3 */ @Test public void testChiSquareDataSetsComparisonUnEqualCounts() { long[] observed1 = {10, 12, 12, 10, 15}; long[] observed2 = {15, 10, 10, 15, 5}; Assert.assertEquals("chi-square p value", 0.124115, testStatistic.chiSquareTestDataSetsComparison( observed1, observed2), 1E-6); Assert.assertEquals("chi-square test statistic", 7.232189, testStatistic.chiSquareDataSetsComparison( observed1, observed2), 1E-6); Assert.assertTrue("chi-square test result", testStatistic.chiSquareTestDataSetsComparison( observed1, observed2, 0.13)); Assert.assertFalse("chi-square test result", testStatistic.chiSquareTestDataSetsComparison( observed1, observed2, 0.12)); } @Test public void testChiSquareDataSetsComparisonBadCounts() { long[] observed1 = {10, -1, 12, 10, 15}; long[] observed2 = {15, 10, 10, 15, 5}; try { testStatistic.chiSquareTestDataSetsComparison( observed1, observed2); Assert.fail("Expecting NotPositiveException - negative count"); } catch (NotPositiveException ex) { // expected } long[] observed3 = {10, 0, 12, 10, 15}; long[] observed4 = {15, 0, 10, 15, 5}; try { testStatistic.chiSquareTestDataSetsComparison( observed3, observed4); Assert.fail("Expecting ZeroException - double 0's"); } catch (ZeroException ex) { // expected } long[] observed5 = {10, 10, 12, 10, 15}; long[] observed6 = {0, 0, 0, 0, 0}; try { testStatistic.chiSquareTestDataSetsComparison( observed5, observed6); Assert.fail("Expecting ZeroException - vanishing counts"); } catch (ZeroException ex) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.inference; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.NotPositiveException; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.apache.commons.math3.exception.OutOfRangeException; import org.apache.commons.math3.exception.ZeroException; import org.junit.Assert; import org.junit.Test; /** * Test cases for the GTest class. * * Data for the tests are from p64-69 in: McDonald, J.H. 2009. Handbook of * Biological Statistics (2nd ed.). Sparky House Publishing, Baltimore, * Maryland. * */ public class GTestTest { protected GTest testStatistic = new GTest(); @Test public void testGTestGoodnesOfFit1() throws Exception { final double[] exp = new double[]{ 3d, 1d }; final long[] obs = new long[]{ 423, 133 }; Assert.assertEquals("G test statistic", 0.348721, testStatistic.g(exp, obs), 1E-6); final double p_gtgf = testStatistic.gTest(exp, obs); Assert.assertEquals("g-Test p-value", 0.55483, p_gtgf, 1E-5); Assert.assertFalse(testStatistic.gTest(exp, obs, 0.05)); } @Test public void testGTestGoodnesOfFit2() throws Exception { final double[] exp = new double[]{ 0.54d, 0.40d, 0.05d, 0.01d }; final long[] obs = new long[]{ 70, 79, 3, 4 }; Assert.assertEquals("G test statistic", 13.144799, testStatistic.g(exp, obs), 1E-6); final double p_gtgf = testStatistic.gTest(exp, obs); Assert.assertEquals("g-Test p-value", 0.004333, p_gtgf, 1E-5); Assert.assertTrue(testStatistic.gTest(exp, obs, 0.05)); } @Test public void testGTestGoodnesOfFit3() throws Exception { final double[] exp = new double[]{ 0.167d, 0.483d, 0.350d }; final long[] obs = new long[]{ 14, 21, 25 }; Assert.assertEquals("G test statistic", 4.5554, testStatistic.g(exp, obs), 1E-4); // Intrinisic (Hardy-Weinberg proportions) P-Value should be 0.033 final double p_gtgf = testStatistic.gTestIntrinsic(exp, obs); Assert.assertEquals("g-Test p-value", 0.0328, p_gtgf, 1E-4); Assert.assertFalse(testStatistic.gTest(exp, obs, 0.05)); } @Test public void testGTestIndependance1() throws Exception { final long[] obs1 = new long[]{ 268, 199, 42 }; final long[] obs2 = new long[]{ 807, 759, 184 }; final double g = testStatistic.gDataSetsComparison(obs1, obs2); Assert.assertEquals("G test statistic", 7.3008170, g, 1E-6); final double p_gti = testStatistic.gTestDataSetsComparison(obs1, obs2); Assert.assertEquals("g-Test p-value", 0.0259805, p_gti, 1E-6); Assert.assertTrue(testStatistic.gTestDataSetsComparison(obs1, obs2, 0.05)); } @Test public void testGTestIndependance2() throws Exception { final long[] obs1 = new long[]{ 127, 99, 264 }; final long[] obs2 = new long[]{ 116, 67, 161 }; final double g = testStatistic.gDataSetsComparison(obs1, obs2); Assert.assertEquals("G test statistic", 6.227288, g, 1E-6); final double p_gti = testStatistic.gTestDataSetsComparison(obs1, obs2); Assert.assertEquals("g-Test p-value", 0.04443, p_gti, 1E-5); Assert.assertTrue(testStatistic.gTestDataSetsComparison(obs1, obs2, 0.05)); } @Test public void testGTestIndependance3() throws Exception { final long[] obs1 = new long[]{ 190, 149 }; final long[] obs2 = new long[]{ 42, 49 }; final double g = testStatistic.gDataSetsComparison(obs1, obs2); Assert.assertEquals("G test statistic", 2.8187, g, 1E-4); final double p_gti = testStatistic.gTestDataSetsComparison(obs1, obs2); Assert.assertEquals("g-Test p-value", 0.09317325, p_gti, 1E-6); Assert.assertFalse(testStatistic.gTestDataSetsComparison(obs1, obs2, 0.05)); } @Test public void testGTestSetsComparisonBadCounts() { long[] observed1 = {10, -1, 12, 10, 15}; long[] observed2 = {15, 10, 10, 15, 5}; try { testStatistic.gTestDataSetsComparison( observed1, observed2); Assert.fail("Expecting NotPositiveException - negative count"); } catch (NotPositiveException ex) { // expected } long[] observed3 = {10, 0, 12, 10, 15}; long[] observed4 = {15, 0, 10, 15, 5}; try { testStatistic.gTestDataSetsComparison( observed3, observed4); Assert.fail("Expecting ZeroException - double 0's"); } catch (ZeroException ex) { // expected } long[] observed5 = {10, 10, 12, 10, 15}; long[] observed6 = {0, 0, 0, 0, 0}; try { testStatistic.gTestDataSetsComparison( observed5, observed6); Assert.fail("Expecting ZeroException - vanishing counts"); } catch (ZeroException ex) { // expected } } @Test public void testUnmatchedArrays() { final long[] observed = { 0, 1, 2, 3 }; final double[] expected = { 1, 1, 2 }; final long[] observed2 = {3, 4}; try { testStatistic.gTest(expected, observed); Assert.fail("arrays have different lengths, DimensionMismatchException expected"); } catch (DimensionMismatchException ex) { // expected } try { testStatistic.gTestDataSetsComparison(observed, observed2); Assert.fail("arrays have different lengths, DimensionMismatchException expected"); } catch (DimensionMismatchException ex) { // expected } } @Test public void testNegativeObservedCounts() { final long[] observed = { 0, 1, 2, -3 }; final double[] expected = { 1, 1, 2, 3}; final long[] observed2 = {3, 4, 5, 0}; try { testStatistic.gTest(expected, observed); Assert.fail("negative observed count, NotPositiveException expected"); } catch (NotPositiveException ex) { // expected } try { testStatistic.gTestDataSetsComparison(observed, observed2); Assert.fail("negative observed count, NotPositiveException expected"); } catch (NotPositiveException ex) { // expected } } @Test public void testZeroExpectedCounts() { final long[] observed = { 0, 1, 2, -3 }; final double[] expected = { 1, 0, 2, 3}; try { testStatistic.gTest(expected, observed); Assert.fail("zero expected count, NotStrictlyPositiveException expected"); } catch (NotStrictlyPositiveException ex) { // expected } } @Test public void testBadAlpha() { final long[] observed = { 0, 1, 2, 3 }; final double[] expected = { 1, 2, 2, 3}; final long[] observed2 = { 0, 2, 2, 3 }; try { testStatistic.gTest(expected, observed, 0.8); Assert.fail("zero expected count, NotStrictlyPositiveException expected"); } catch (OutOfRangeException ex) { // expected } try { testStatistic.gTestDataSetsComparison(observed, observed2, -0.5); Assert.fail("zero expected count, NotStrictlyPositiveException expected"); } catch (OutOfRangeException ex) { // expected } } @Test public void testScaling() { final long[] observed = {9, 11, 10, 8, 12}; final double[] expected1 = {10, 10, 10, 10, 10}; final double[] expected2 = {1000, 1000, 1000, 1000, 1000}; final double[] expected3 = {1, 1, 1, 1, 1}; final double tol = 1E-15; Assert.assertEquals( testStatistic.gTest(expected1, observed), testStatistic.gTest(expected2, observed), tol); Assert.assertEquals( testStatistic.gTest(expected1, observed), testStatistic.gTest(expected3, observed), tol); } @Test public void testRootLogLikelihood() { // positive where k11 is bigger than expected. Assert.assertTrue(testStatistic.rootLogLikelihoodRatio(904, 21060, 1144, 283012) > 0.0); // negative because k11 is lower than expected Assert.assertTrue(testStatistic.rootLogLikelihoodRatio(36, 21928, 60280, 623876) < 0.0); Assert.assertEquals(Math.sqrt(2.772589), testStatistic.rootLogLikelihoodRatio(1, 0, 0, 1), 0.000001); Assert.assertEquals(-Math.sqrt(2.772589), testStatistic.rootLogLikelihoodRatio(0, 1, 1, 0), 0.000001); Assert.assertEquals(Math.sqrt(27.72589), testStatistic.rootLogLikelihoodRatio(10, 0, 0, 10), 0.00001); Assert.assertEquals(Math.sqrt(39.33052), testStatistic.rootLogLikelihoodRatio(5, 1995, 0, 100000), 0.00001); Assert.assertEquals(-Math.sqrt(39.33052), testStatistic.rootLogLikelihoodRatio(0, 100000, 5, 1995), 0.00001); Assert.assertEquals(Math.sqrt(4730.737), testStatistic.rootLogLikelihoodRatio(1000, 1995, 1000, 100000), 0.001); Assert.assertEquals(-Math.sqrt(4730.737), testStatistic.rootLogLikelihoodRatio(1000, 100000, 1000, 1995), 0.001); Assert.assertEquals(Math.sqrt(5734.343), testStatistic.rootLogLikelihoodRatio(1000, 1000, 1000, 100000), 0.001); Assert.assertEquals(Math.sqrt(5714.932), testStatistic.rootLogLikelihoodRatio(1000, 1000, 1000, 99000), 0.001); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.inference; import org.apache.commons.math3.exception.NoDataException; import org.apache.commons.math3.exception.NullArgumentException; import org.junit.Assert; import org.junit.Test; /** * Test cases for the MannWhitneyUTestImpl class. * * @version $Id$ */ public class MannWhitneyUTestTest { protected MannWhitneyUTest testStatistic = new MannWhitneyUTest(); @Test public void testMannWhitneyUSimple() { /* Target values computed using R version 2.11.1 * x <- c(19, 22, 16, 29, 24) * y <- c(20, 11, 17, 12) * wilcox.test(x, y, alternative = "two.sided", mu = 0, paired = FALSE, exact = FALSE, correct = FALSE) * W = 17, p-value = 0.08641 */ final double x[] = {19, 22, 16, 29, 24}; final double y[] = {20, 11, 17, 12}; Assert.assertEquals(17, testStatistic.mannWhitneyU(x, y), 1e-10); Assert.assertEquals(0.08641, testStatistic.mannWhitneyUTest(x, y), 1e-5); } @Test public void testMannWhitneyUInputValidation() { /* Samples must be present, i.e. length > 0 */ try { testStatistic.mannWhitneyUTest(new double[] { }, new double[] { 1.0 }); Assert.fail("x does not contain samples (exact), NoDataException expected"); } catch (NoDataException ex) { // expected } try { testStatistic.mannWhitneyUTest(new double[] { 1.0 }, new double[] { }); Assert.fail("y does not contain samples (exact), NoDataException expected"); } catch (NoDataException ex) { // expected } /* * x and y is null */ try { testStatistic.mannWhitneyUTest(null, null); Assert.fail("x and y is null (exact), NullArgumentException expected"); } catch (NullArgumentException ex) { // expected } try { testStatistic.mannWhitneyUTest(null, null); Assert.fail("x and y is null (asymptotic), NullArgumentException expected"); } catch (NullArgumentException ex) { // expected } /* * x or y is null */ try { testStatistic.mannWhitneyUTest(null, new double[] { 1.0 }); Assert.fail("x is null (exact), NullArgumentException expected"); } catch (NullArgumentException ex) { // expected } try { testStatistic.mannWhitneyUTest(new double[] { 1.0 }, null); Assert.fail("y is null (exact), NullArgumentException expected"); } catch (NullArgumentException ex) { // expected } } @Test public void testBigDataSet() { double[] d1 = new double[1500]; double[] d2 = new double[1500]; for (int i = 0; i < 1500; i++) { d1[i] = 2 * i; d2[i] = 2 * i + 1; } double result = testStatistic.mannWhitneyUTest(d1, d2); Assert.assertTrue(result > 0.1); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.inference; import java.util.ArrayList; import java.util.List; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.stat.descriptive.SummaryStatistics; import org.junit.Assert; import org.junit.Test; /** * Test cases for the OneWayAnovaImpl class. * * @version $Id$ */ public class OneWayAnovaTest { protected OneWayAnova testStatistic = new OneWayAnova(); private double[] emptyArray = {}; private double[] classA = {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0 }; private double[] classB = {99.0, 92.0, 102.0, 100.0, 102.0, 89.0 }; private double[] classC = {110.0, 115.0, 111.0, 117.0, 128.0, 117.0 }; @Test public void testAnovaFValue() { // Target comparison values computed using R version 2.6.0 (Linux version) List<double[]> threeClasses = new ArrayList<double[]>(); threeClasses.add(classA); threeClasses.add(classB); threeClasses.add(classC); Assert.assertEquals("ANOVA F-value", 24.67361709460624, testStatistic.anovaFValue(threeClasses), 1E-12); List<double[]> twoClasses = new ArrayList<double[]>(); twoClasses.add(classA); twoClasses.add(classB); Assert.assertEquals("ANOVA F-value", 0.0150579150579, testStatistic.anovaFValue(twoClasses), 1E-12); List<double[]> emptyContents = new ArrayList<double[]>(); emptyContents.add(emptyArray); emptyContents.add(classC); try { testStatistic.anovaFValue(emptyContents); Assert.fail("empty array for key classX, MathIllegalArgumentException expected"); } catch (MathIllegalArgumentException ex) { // expected } List<double[]> tooFew = new ArrayList<double[]>(); tooFew.add(classA); try { testStatistic.anovaFValue(tooFew); Assert.fail("less than two classes, MathIllegalArgumentException expected"); } catch (MathIllegalArgumentException ex) { // expected } } @Test public void testAnovaPValue() { // Target comparison values computed using R version 2.6.0 (Linux version) List<double[]> threeClasses = new ArrayList<double[]>(); threeClasses.add(classA); threeClasses.add(classB); threeClasses.add(classC); Assert.assertEquals("ANOVA P-value", 6.959446E-06, testStatistic.anovaPValue(threeClasses), 1E-12); List<double[]> twoClasses = new ArrayList<double[]>(); twoClasses.add(classA); twoClasses.add(classB); Assert.assertEquals("ANOVA P-value", 0.904212960464, testStatistic.anovaPValue(twoClasses), 1E-12); } @Test public void testAnovaPValueSummaryStatistics() { // Target comparison values computed using R version 2.6.0 (Linux version) List<SummaryStatistics> threeClasses = new ArrayList<SummaryStatistics>(); SummaryStatistics statsA = new SummaryStatistics(); for (double a : classA) { statsA.addValue(a); } threeClasses.add(statsA); SummaryStatistics statsB = new SummaryStatistics(); for (double b : classB) { statsB.addValue(b); } threeClasses.add(statsB); SummaryStatistics statsC = new SummaryStatistics(); for (double c : classC) { statsC.addValue(c); } threeClasses.add(statsC); Assert.assertEquals("ANOVA P-value", 6.959446E-06, testStatistic.anovaPValue(threeClasses, true), 1E-12); List<SummaryStatistics> twoClasses = new ArrayList<SummaryStatistics>(); twoClasses.add(statsA); twoClasses.add(statsB); Assert.assertEquals("ANOVA P-value", 0.904212960464, testStatistic.anovaPValue(twoClasses, false), 1E-12); } @Test public void testAnovaTest() { // Target comparison values computed using R version 2.3.1 (Linux version) List<double[]> threeClasses = new ArrayList<double[]>(); threeClasses.add(classA); threeClasses.add(classB); threeClasses.add(classC); Assert.assertTrue("ANOVA Test P<0.01", testStatistic.anovaTest(threeClasses, 0.01)); List<double[]> twoClasses = new ArrayList<double[]>(); twoClasses.add(classA); twoClasses.add(classB); Assert.assertFalse("ANOVA Test P>0.01", testStatistic.anovaTest(twoClasses, 0.01)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.inference; import org.apache.commons.math3.exception.NullArgumentException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.exception.OutOfRangeException; import org.apache.commons.math3.stat.descriptive.SummaryStatistics; import org.junit.Assert; import org.junit.Before; import org.junit.Test; /** * Test cases for the TTestImpl class. * * @version $Id$ */ public class TTestTest { protected TTest testStatistic = new TTest(); private double[] tooShortObs = { 1.0 }; private double[] emptyObs = {}; private SummaryStatistics emptyStats = new SummaryStatistics(); SummaryStatistics tooShortStats = null; @Before public void setUp() { tooShortStats = new SummaryStatistics(); tooShortStats.addValue(0d); } @Test public void testOneSampleT() { double[] observed = {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0, 88.0, 98.0, 94.0, 101.0, 92.0, 95.0 }; double mu = 100.0; SummaryStatistics sampleStats = null; sampleStats = new SummaryStatistics(); for (int i = 0; i < observed.length; i++) { sampleStats.addValue(observed[i]); } // Target comparison values computed using R version 1.8.1 (Linux version) Assert.assertEquals("t statistic", -2.81976445346, testStatistic.t(mu, observed), 10E-10); Assert.assertEquals("t statistic", -2.81976445346, testStatistic.t(mu, sampleStats), 10E-10); Assert.assertEquals("p value", 0.0136390585873, testStatistic.tTest(mu, observed), 10E-10); Assert.assertEquals("p value", 0.0136390585873, testStatistic.tTest(mu, sampleStats), 10E-10); try { testStatistic.t(mu, (double[]) null); Assert.fail("arguments too short, NullArgumentException expected"); } catch (NullArgumentException ex) { // expected } try { testStatistic.t(mu, (SummaryStatistics) null); Assert.fail("arguments too short, NullArgumentException expected"); } catch (NullArgumentException ex) { // expected } try { testStatistic.t(mu, emptyObs); Assert.fail("arguments too short, NumberIsTooSmallException expected"); } catch (NumberIsTooSmallException ex) { // expected } try { testStatistic.t(mu, emptyStats); Assert.fail("arguments too short, NumberIsTooSmallException expected"); } catch (NumberIsTooSmallException ex) { // expected } try { testStatistic.t(mu, tooShortObs); Assert.fail("insufficient data to compute t statistic, NumberIsTooSmallException expected"); } catch (NumberIsTooSmallException ex) { // expected } try { testStatistic.tTest(mu, tooShortObs); Assert.fail("insufficient data to perform t test, NumberIsTooSmallException expected"); } catch (NumberIsTooSmallException ex) { // expected } try { testStatistic.t(mu, tooShortStats); Assert.fail("insufficient data to compute t statistic, NumberIsTooSmallException expected"); } catch (NumberIsTooSmallException ex) { // expected } try { testStatistic.tTest(mu, tooShortStats); Assert.fail("insufficient data to perform t test, NumberIsTooSmallException expected"); } catch (NumberIsTooSmallException ex) { // expected } } @Test public void testOneSampleTTest() { double[] oneSidedP = {2d, 0d, 6d, 6d, 3d, 3d, 2d, 3d, -6d, 6d, 6d, 6d, 3d, 0d, 1d, 1d, 0d, 2d, 3d, 3d }; SummaryStatistics oneSidedPStats = new SummaryStatistics(); for (int i = 0; i < oneSidedP.length; i++) { oneSidedPStats.addValue(oneSidedP[i]); } // Target comparison values computed using R version 1.8.1 (Linux version) Assert.assertEquals("one sample t stat", 3.86485535541, testStatistic.t(0d, oneSidedP), 10E-10); Assert.assertEquals("one sample t stat", 3.86485535541, testStatistic.t(0d, oneSidedPStats),1E-10); Assert.assertEquals("one sample p value", 0.000521637019637, testStatistic.tTest(0d, oneSidedP) / 2d, 10E-10); Assert.assertEquals("one sample p value", 0.000521637019637, testStatistic.tTest(0d, oneSidedPStats) / 2d, 10E-5); Assert.assertTrue("one sample t-test reject", testStatistic.tTest(0d, oneSidedP, 0.01)); Assert.assertTrue("one sample t-test reject", testStatistic.tTest(0d, oneSidedPStats, 0.01)); Assert.assertTrue("one sample t-test accept", !testStatistic.tTest(0d, oneSidedP, 0.0001)); Assert.assertTrue("one sample t-test accept", !testStatistic.tTest(0d, oneSidedPStats, 0.0001)); try { testStatistic.tTest(0d, oneSidedP, 95); Assert.fail("alpha out of range, OutOfRangeException expected"); } catch (OutOfRangeException ex) { // expected } try { testStatistic.tTest(0d, oneSidedPStats, 95); Assert.fail("alpha out of range, OutOfRangeException expected"); } catch (OutOfRangeException ex) { // expected } } @Test public void testTwoSampleTHeterscedastic() { double[] sample1 = { 7d, -4d, 18d, 17d, -3d, -5d, 1d, 10d, 11d, -2d }; double[] sample2 = { -1d, 12d, -1d, -3d, 3d, -5d, 5d, 2d, -11d, -1d, -3d }; SummaryStatistics sampleStats1 = new SummaryStatistics(); for (int i = 0; i < sample1.length; i++) { sampleStats1.addValue(sample1[i]); } SummaryStatistics sampleStats2 = new SummaryStatistics(); for (int i = 0; i < sample2.length; i++) { sampleStats2.addValue(sample2[i]); } // Target comparison values computed using R version 1.8.1 (Linux version) Assert.assertEquals("two sample heteroscedastic t stat", 1.60371728768, testStatistic.t(sample1, sample2), 1E-10); Assert.assertEquals("two sample heteroscedastic t stat", 1.60371728768, testStatistic.t(sampleStats1, sampleStats2), 1E-10); Assert.assertEquals("two sample heteroscedastic p value", 0.128839369622, testStatistic.tTest(sample1, sample2), 1E-10); Assert.assertEquals("two sample heteroscedastic p value", 0.128839369622, testStatistic.tTest(sampleStats1, sampleStats2), 1E-10); Assert.assertTrue("two sample heteroscedastic t-test reject", testStatistic.tTest(sample1, sample2, 0.2)); Assert.assertTrue("two sample heteroscedastic t-test reject", testStatistic.tTest(sampleStats1, sampleStats2, 0.2)); Assert.assertTrue("two sample heteroscedastic t-test accept", !testStatistic.tTest(sample1, sample2, 0.1)); Assert.assertTrue("two sample heteroscedastic t-test accept", !testStatistic.tTest(sampleStats1, sampleStats2, 0.1)); try { testStatistic.tTest(sample1, sample2, .95); Assert.fail("alpha out of range, OutOfRangeException expected"); } catch (OutOfRangeException ex) { // expected } try { testStatistic.tTest(sampleStats1, sampleStats2, .95); Assert.fail("alpha out of range, OutOfRangeException expected"); } catch (OutOfRangeException ex) { // expected } try { testStatistic.tTest(sample1, tooShortObs, .01); Assert.fail("insufficient data, NumberIsTooSmallException expected"); } catch (NumberIsTooSmallException ex) { // expected } try { testStatistic.tTest(sampleStats1, tooShortStats, .01); Assert.fail("insufficient data, NumberIsTooSmallException expected"); } catch (NumberIsTooSmallException ex) { // expected } try { testStatistic.tTest(sample1, tooShortObs); Assert.fail("insufficient data, NumberIsTooSmallException expected"); } catch (NumberIsTooSmallException ex) { // expected } try { testStatistic.tTest(sampleStats1, tooShortStats); Assert.fail("insufficient data, NumberIsTooSmallException expected"); } catch (NumberIsTooSmallException ex) { // expected } try { testStatistic.t(sample1, tooShortObs); Assert.fail("insufficient data, NumberIsTooSmallException expected"); } catch (NumberIsTooSmallException ex) { // expected } try { testStatistic.t(sampleStats1, tooShortStats); Assert.fail("insufficient data, NumberIsTooSmallException expected"); } catch (NumberIsTooSmallException ex) { // expected } } @Test public void testTwoSampleTHomoscedastic() { double[] sample1 ={2, 4, 6, 8, 10, 97}; double[] sample2 = {4, 6, 8, 10, 16}; SummaryStatistics sampleStats1 = new SummaryStatistics(); for (int i = 0; i < sample1.length; i++) { sampleStats1.addValue(sample1[i]); } SummaryStatistics sampleStats2 = new SummaryStatistics(); for (int i = 0; i < sample2.length; i++) { sampleStats2.addValue(sample2[i]); } // Target comparison values computed using R version 1.8.1 (Linux version) Assert.assertEquals("two sample homoscedastic t stat", 0.73096310086, testStatistic.homoscedasticT(sample1, sample2), 10E-11); Assert.assertEquals("two sample homoscedastic p value", 0.4833963785, testStatistic.homoscedasticTTest(sampleStats1, sampleStats2), 1E-10); Assert.assertTrue("two sample homoscedastic t-test reject", testStatistic.homoscedasticTTest(sample1, sample2, 0.49)); Assert.assertTrue("two sample homoscedastic t-test accept", !testStatistic.homoscedasticTTest(sample1, sample2, 0.48)); } @Test public void testSmallSamples() { double[] sample1 = {1d, 3d}; double[] sample2 = {4d, 5d}; // Target values computed using R, version 1.8.1 (linux version) Assert.assertEquals(-2.2360679775, testStatistic.t(sample1, sample2), 1E-10); Assert.assertEquals(0.198727388935, testStatistic.tTest(sample1, sample2), 1E-10); } @Test public void testPaired() { double[] sample1 = {1d, 3d, 5d, 7d}; double[] sample2 = {0d, 6d, 11d, 2d}; double[] sample3 = {5d, 7d, 8d, 10d}; // Target values computed using R, version 1.8.1 (linux version) Assert.assertEquals(-0.3133, testStatistic.pairedT(sample1, sample2), 1E-4); Assert.assertEquals(0.774544295819, testStatistic.pairedTTest(sample1, sample2), 1E-10); Assert.assertEquals(0.001208, testStatistic.pairedTTest(sample1, sample3), 1E-6); Assert.assertFalse(testStatistic.pairedTTest(sample1, sample3, .001)); Assert.assertTrue(testStatistic.pairedTTest(sample1, sample3, .002)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.inference; import java.util.ArrayList; import java.util.List; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.NotPositiveException; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.apache.commons.math3.exception.NullArgumentException; import org.apache.commons.math3.exception.NumberIsTooSmallException; import org.apache.commons.math3.exception.OutOfRangeException; import org.apache.commons.math3.stat.descriptive.SummaryStatistics; import org.junit.Assert; import org.junit.Test; /** * Test cases for the TestUtils class. * * @version $Id$ */ public class TestUtilsTest { @Test public void testChiSquare() { // Target values computed using R version 1.8.1 // Some assembly required ;-) // Use sum((obs - exp)^2/exp) for the chi-square statistic and // 1 - pchisq(sum((obs - exp)^2/exp), length(obs) - 1) for the p-value long[] observed = {10, 9, 11}; double[] expected = {10, 10, 10}; Assert.assertEquals("chi-square statistic", 0.2, TestUtils.chiSquare(expected, observed), 10E-12); Assert.assertEquals("chi-square p-value", 0.904837418036, TestUtils.chiSquareTest(expected, observed), 1E-10); long[] observed1 = { 500, 623, 72, 70, 31 }; double[] expected1 = { 485, 541, 82, 61, 37 }; Assert.assertEquals( "chi-square test statistic", 9.023307936427388, TestUtils.chiSquare(expected1, observed1), 1E-10); Assert.assertEquals("chi-square p-value", 0.06051952647453607, TestUtils.chiSquareTest(expected1, observed1), 1E-9); Assert.assertTrue("chi-square test reject", TestUtils.chiSquareTest(expected1, observed1, 0.07)); Assert.assertTrue("chi-square test accept", !TestUtils.chiSquareTest(expected1, observed1, 0.05)); try { TestUtils.chiSquareTest(expected1, observed1, 95); Assert.fail("alpha out of range, OutOfRangeException expected"); } catch (OutOfRangeException ex) { // expected } long[] tooShortObs = { 0 }; double[] tooShortEx = { 1 }; try { TestUtils.chiSquare(tooShortEx, tooShortObs); Assert.fail("arguments too short, DimensionMismatchException expected"); } catch (DimensionMismatchException ex) { // expected } // unmatched arrays long[] unMatchedObs = { 0, 1, 2, 3 }; double[] unMatchedEx = { 1, 1, 2 }; try { TestUtils.chiSquare(unMatchedEx, unMatchedObs); Assert.fail("arrays have different lengths, DimensionMismatchException expected"); } catch (DimensionMismatchException ex) { // expected } // 0 expected count expected[0] = 0; try { TestUtils.chiSquareTest(expected, observed, .01); Assert.fail("bad expected count, NotStrictlyPositiveException expected"); } catch (NotStrictlyPositiveException ex) { // expected } // negative observed count expected[0] = 1; observed[0] = -1; try { TestUtils.chiSquareTest(expected, observed, .01); Assert.fail("bad expected count, NotPositiveException expected"); } catch (NotPositiveException ex) { // expected } } @Test public void testChiSquareIndependence() { // Target values computed using R version 1.8.1 long[][] counts = { {40, 22, 43}, {91, 21, 28}, {60, 10, 22}}; Assert.assertEquals( "chi-square test statistic", 22.709027688, TestUtils.chiSquare(counts), 1E-9); Assert.assertEquals("chi-square p-value", 0.000144751460134, TestUtils.chiSquareTest(counts), 1E-9); Assert.assertTrue("chi-square test reject", TestUtils.chiSquareTest(counts, 0.0002)); Assert.assertTrue("chi-square test accept", !TestUtils.chiSquareTest(counts, 0.0001)); long[][] counts2 = {{10, 15}, {30, 40}, {60, 90} }; Assert.assertEquals( "chi-square test statistic", 0.168965517241, TestUtils.chiSquare(counts2), 1E-9); Assert.assertEquals("chi-square p-value",0.918987499852, TestUtils.chiSquareTest(counts2), 1E-9); Assert.assertTrue("chi-square test accept", !TestUtils.chiSquareTest(counts2, 0.1)); // ragged input array long[][] counts3 = { {40, 22, 43}, {91, 21, 28}, {60, 10}}; try { TestUtils.chiSquare(counts3); Assert.fail("Expecting DimensionMismatchException"); } catch (DimensionMismatchException ex) { // expected } // insufficient data long[][] counts4 = {{40, 22, 43}}; try { TestUtils.chiSquare(counts4); Assert.fail("Expecting DimensionMismatchException"); } catch (DimensionMismatchException ex) { // expected } long[][] counts5 = {{40}, {40}, {30}, {10}}; try { TestUtils.chiSquare(counts5); Assert.fail("Expecting DimensionMismatchException"); } catch (DimensionMismatchException ex) { // expected } // negative counts long[][] counts6 = {{10, -2}, {30, 40}, {60, 90} }; try { TestUtils.chiSquare(counts6); Assert.fail("Expecting NotPositiveException"); } catch (NotPositiveException ex) { // expected } // bad alpha try { TestUtils.chiSquareTest(counts, 0); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // expected } } @Test public void testChiSquareLargeTestStatistic() { double[] exp = new double[] { 3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0, 232921.0, 437665.75 }; long[] obs = new long[] { 2372383, 584222, 257170, 17750155, 7903832, 489265, 209628, 393899 }; org.apache.commons.math3.stat.inference.ChiSquareTest csti = new org.apache.commons.math3.stat.inference.ChiSquareTest(); double cst = csti.chiSquareTest(exp, obs); Assert.assertEquals("chi-square p-value", 0.0, cst, 1E-3); Assert.assertEquals( "chi-square test statistic", 114875.90421929007, TestUtils.chiSquare(exp, obs), 1E-9); } /** Contingency table containing zeros - PR # 32531 */ @Test public void testChiSquareZeroCount() { // Target values computed using R version 1.8.1 long[][] counts = { {40, 0, 4}, {91, 1, 2}, {60, 2, 0}}; Assert.assertEquals( "chi-square test statistic", 9.67444662263, TestUtils.chiSquare(counts), 1E-9); Assert.assertEquals("chi-square p-value", 0.0462835770603, TestUtils.chiSquareTest(counts), 1E-9); } private double[] tooShortObs = { 1.0 }; private double[] emptyObs = {}; private SummaryStatistics emptyStats = new SummaryStatistics(); @Test public void testOneSampleT() { double[] observed = {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0, 88.0, 98.0, 94.0, 101.0, 92.0, 95.0 }; double mu = 100.0; SummaryStatistics sampleStats = null; sampleStats = new SummaryStatistics(); for (int i = 0; i < observed.length; i++) { sampleStats.addValue(observed[i]); } // Target comparison values computed using R version 1.8.1 (Linux version) Assert.assertEquals("t statistic", -2.81976445346, TestUtils.t(mu, observed), 10E-10); Assert.assertEquals("t statistic", -2.81976445346, TestUtils.t(mu, sampleStats), 10E-10); Assert.assertEquals("p value", 0.0136390585873, TestUtils.tTest(mu, observed), 10E-10); Assert.assertEquals("p value", 0.0136390585873, TestUtils.tTest(mu, sampleStats), 10E-10); try { TestUtils.t(mu, (double[]) null); Assert.fail("arguments too short, NullArgumentException expected"); } catch (NullArgumentException ex) { // expected } try { TestUtils.t(mu, (SummaryStatistics) null); Assert.fail("arguments too short, NullArgumentException expected"); } catch (NullArgumentException ex) { // expected } try { TestUtils.t(mu, emptyObs); Assert.fail("arguments too short, NumberIsTooSmallException expected"); } catch (NumberIsTooSmallException ex) { // expected } try { TestUtils.t(mu, emptyStats); Assert.fail("arguments too short, NumberIsTooSmallException expected"); } catch (NumberIsTooSmallException ex) { // expected } try { TestUtils.t(mu, tooShortObs); Assert.fail("insufficient data to compute t statistic, NumberIsTooSmallException expected"); } catch (NumberIsTooSmallException ex) { // expected } try { TestUtils.tTest(mu, tooShortObs); Assert.fail("insufficient data to perform t test, NumberIsTooSmallException expected"); } catch (NumberIsTooSmallException ex) { // expected } try { TestUtils.t(mu, (SummaryStatistics) null); Assert.fail("insufficient data to compute t statistic, NullArgumentException expected"); } catch (NullArgumentException ex) { // expected } try { TestUtils.tTest(mu, (SummaryStatistics) null); Assert.fail("insufficient data to perform t test, NullArgumentException expected"); } catch (NullArgumentException ex) { // expected } } @Test public void testOneSampleTTest() { double[] oneSidedP = {2d, 0d, 6d, 6d, 3d, 3d, 2d, 3d, -6d, 6d, 6d, 6d, 3d, 0d, 1d, 1d, 0d, 2d, 3d, 3d }; SummaryStatistics oneSidedPStats = new SummaryStatistics(); for (int i = 0; i < oneSidedP.length; i++) { oneSidedPStats.addValue(oneSidedP[i]); } // Target comparison values computed using R version 1.8.1 (Linux version) Assert.assertEquals("one sample t stat", 3.86485535541, TestUtils.t(0d, oneSidedP), 10E-10); Assert.assertEquals("one sample t stat", 3.86485535541, TestUtils.t(0d, oneSidedPStats),1E-10); Assert.assertEquals("one sample p value", 0.000521637019637, TestUtils.tTest(0d, oneSidedP) / 2d, 10E-10); Assert.assertEquals("one sample p value", 0.000521637019637, TestUtils.tTest(0d, oneSidedPStats) / 2d, 10E-5); Assert.assertTrue("one sample t-test reject", TestUtils.tTest(0d, oneSidedP, 0.01)); Assert.assertTrue("one sample t-test reject", TestUtils.tTest(0d, oneSidedPStats, 0.01)); Assert.assertTrue("one sample t-test accept", !TestUtils.tTest(0d, oneSidedP, 0.0001)); Assert.assertTrue("one sample t-test accept", !TestUtils.tTest(0d, oneSidedPStats, 0.0001)); try { TestUtils.tTest(0d, oneSidedP, 95); Assert.fail("alpha out of range, OutOfRangeException expected"); } catch (OutOfRangeException ex) { // expected } try { TestUtils.tTest(0d, oneSidedPStats, 95); Assert.fail("alpha out of range, OutOfRangeException expected"); } catch (OutOfRangeException ex) { // expected } } @Test public void testTwoSampleTHeterscedastic() { double[] sample1 = { 7d, -4d, 18d, 17d, -3d, -5d, 1d, 10d, 11d, -2d }; double[] sample2 = { -1d, 12d, -1d, -3d, 3d, -5d, 5d, 2d, -11d, -1d, -3d }; SummaryStatistics sampleStats1 = new SummaryStatistics(); for (int i = 0; i < sample1.length; i++) { sampleStats1.addValue(sample1[i]); } SummaryStatistics sampleStats2 = new SummaryStatistics(); for (int i = 0; i < sample2.length; i++) { sampleStats2.addValue(sample2[i]); } // Target comparison values computed using R version 1.8.1 (Linux version) Assert.assertEquals("two sample heteroscedastic t stat", 1.60371728768, TestUtils.t(sample1, sample2), 1E-10); Assert.assertEquals("two sample heteroscedastic t stat", 1.60371728768, TestUtils.t(sampleStats1, sampleStats2), 1E-10); Assert.assertEquals("two sample heteroscedastic p value", 0.128839369622, TestUtils.tTest(sample1, sample2), 1E-10); Assert.assertEquals("two sample heteroscedastic p value", 0.128839369622, TestUtils.tTest(sampleStats1, sampleStats2), 1E-10); Assert.assertTrue("two sample heteroscedastic t-test reject", TestUtils.tTest(sample1, sample2, 0.2)); Assert.assertTrue("two sample heteroscedastic t-test reject", TestUtils.tTest(sampleStats1, sampleStats2, 0.2)); Assert.assertTrue("two sample heteroscedastic t-test accept", !TestUtils.tTest(sample1, sample2, 0.1)); Assert.assertTrue("two sample heteroscedastic t-test accept", !TestUtils.tTest(sampleStats1, sampleStats2, 0.1)); try { TestUtils.tTest(sample1, sample2, .95); Assert.fail("alpha out of range, OutOfRangeException expected"); } catch (OutOfRangeException ex) { // expected } try { TestUtils.tTest(sampleStats1, sampleStats2, .95); Assert.fail("alpha out of range, OutOfRangeException expected"); } catch (OutOfRangeException ex) { // expected } try { TestUtils.tTest(sample1, tooShortObs, .01); Assert.fail("insufficient data, NumberIsTooSmallException expected"); } catch (NumberIsTooSmallException ex) { // expected } try { TestUtils.tTest(sampleStats1, (SummaryStatistics) null, .01); Assert.fail("insufficient data, NullArgumentException expected"); } catch (NullArgumentException ex) { // expected } try { TestUtils.tTest(sample1, tooShortObs); Assert.fail("insufficient data, NumberIsTooSmallException expected"); } catch (NumberIsTooSmallException ex) { // expected } try { TestUtils.tTest(sampleStats1, (SummaryStatistics) null); Assert.fail("insufficient data, NullArgumentException expected"); } catch (NullArgumentException ex) { // expected } try { TestUtils.t(sample1, tooShortObs); Assert.fail("insufficient data, NumberIsTooSmallException expected"); } catch (NumberIsTooSmallException ex) { // expected } try { TestUtils.t(sampleStats1, (SummaryStatistics) null); Assert.fail("insufficient data, NullArgumentException expected"); } catch (NullArgumentException ex) { // expected } } @Test public void testTwoSampleTHomoscedastic() { double[] sample1 ={2, 4, 6, 8, 10, 97}; double[] sample2 = {4, 6, 8, 10, 16}; SummaryStatistics sampleStats1 = new SummaryStatistics(); for (int i = 0; i < sample1.length; i++) { sampleStats1.addValue(sample1[i]); } SummaryStatistics sampleStats2 = new SummaryStatistics(); for (int i = 0; i < sample2.length; i++) { sampleStats2.addValue(sample2[i]); } // Target comparison values computed using R version 1.8.1 (Linux version) Assert.assertEquals("two sample homoscedastic t stat", 0.73096310086, TestUtils.homoscedasticT(sample1, sample2), 10E-11); Assert.assertEquals("two sample homoscedastic p value", 0.4833963785, TestUtils.homoscedasticTTest(sampleStats1, sampleStats2), 1E-10); Assert.assertTrue("two sample homoscedastic t-test reject", TestUtils.homoscedasticTTest(sample1, sample2, 0.49)); Assert.assertTrue("two sample homoscedastic t-test accept", !TestUtils.homoscedasticTTest(sample1, sample2, 0.48)); } @Test public void testSmallSamples() { double[] sample1 = {1d, 3d}; double[] sample2 = {4d, 5d}; // Target values computed using R, version 1.8.1 (linux version) Assert.assertEquals(-2.2360679775, TestUtils.t(sample1, sample2), 1E-10); Assert.assertEquals(0.198727388935, TestUtils.tTest(sample1, sample2), 1E-10); } @Test public void testPaired() { double[] sample1 = {1d, 3d, 5d, 7d}; double[] sample2 = {0d, 6d, 11d, 2d}; double[] sample3 = {5d, 7d, 8d, 10d}; // Target values computed using R, version 1.8.1 (linux version) Assert.assertEquals(-0.3133, TestUtils.pairedT(sample1, sample2), 1E-4); Assert.assertEquals(0.774544295819, TestUtils.pairedTTest(sample1, sample2), 1E-10); Assert.assertEquals(0.001208, TestUtils.pairedTTest(sample1, sample3), 1E-6); Assert.assertFalse(TestUtils.pairedTTest(sample1, sample3, .001)); Assert.assertTrue(TestUtils.pairedTTest(sample1, sample3, .002)); } private double[] classA = {93.0, 103.0, 95.0, 101.0}; private double[] classB = {99.0, 92.0, 102.0, 100.0, 102.0}; private double[] classC = {110.0, 115.0, 111.0, 117.0, 128.0}; private List<double[]> classes = new ArrayList<double[]>(); private OneWayAnova oneWayAnova = new OneWayAnova(); @Test public void testOneWayAnovaUtils() { classes.add(classA); classes.add(classB); classes.add(classC); Assert.assertEquals(oneWayAnova.anovaFValue(classes), TestUtils.oneWayAnovaFValue(classes), 10E-12); Assert.assertEquals(oneWayAnova.anovaPValue(classes), TestUtils.oneWayAnovaPValue(classes), 10E-12); Assert.assertEquals(oneWayAnova.anovaTest(classes, 0.01), TestUtils.oneWayAnovaTest(classes, 0.01)); } @Test public void testGTestGoodnesOfFit() throws Exception { double[] exp = new double[]{ 0.54d, 0.40d, 0.05d, 0.01d }; long[] obs = new long[]{ 70, 79, 3, 4 }; Assert.assertEquals("G test statistic", 13.144799, TestUtils.g(exp, obs), 1E-5); double p_gtgf = TestUtils.gTest(exp, obs); Assert.assertEquals("g-Test p-value", 0.004333, p_gtgf, 1E-5); Assert.assertTrue(TestUtils.gTest(exp, obs, 0.05)); } @Test public void testGTestIndependance() throws Exception { long[] obs1 = new long[]{ 268, 199, 42 }; long[] obs2 = new long[]{ 807, 759, 184 }; double g = TestUtils.gDataSetsComparison(obs1, obs2); Assert.assertEquals("G test statistic", 7.3008170, g, 1E-4); double p_gti = TestUtils.gTestDataSetsComparison(obs1, obs2); Assert.assertEquals("g-Test p-value", 0.0259805, p_gti, 1E-4); Assert.assertTrue(TestUtils.gTestDataSetsComparison(obs1, obs2, 0.05)); } @Test public void testRootLogLikelihood() { // positive where k11 is bigger than expected. Assert.assertTrue(TestUtils.rootLogLikelihoodRatio(904, 21060, 1144, 283012) > 0.0); // negative because k11 is lower than expected Assert.assertTrue(TestUtils.rootLogLikelihoodRatio(36, 21928, 60280, 623876) < 0.0); Assert.assertEquals(Math.sqrt(2.772589), TestUtils.rootLogLikelihoodRatio(1, 0, 0, 1), 0.000001); Assert.assertEquals(-Math.sqrt(2.772589), TestUtils.rootLogLikelihoodRatio(0, 1, 1, 0), 0.000001); Assert.assertEquals(Math.sqrt(27.72589), TestUtils.rootLogLikelihoodRatio(10, 0, 0, 10), 0.00001); Assert.assertEquals(Math.sqrt(39.33052), TestUtils.rootLogLikelihoodRatio(5, 1995, 0, 100000), 0.00001); Assert.assertEquals(-Math.sqrt(39.33052), TestUtils.rootLogLikelihoodRatio(0, 100000, 5, 1995), 0.00001); Assert.assertEquals(Math.sqrt(4730.737), TestUtils.rootLogLikelihoodRatio(1000, 1995, 1000, 100000), 0.001); Assert.assertEquals(-Math.sqrt(4730.737), TestUtils.rootLogLikelihoodRatio(1000, 100000, 1000, 1995), 0.001); Assert.assertEquals(Math.sqrt(5734.343), TestUtils.rootLogLikelihoodRatio(1000, 1000, 1000, 100000), 0.001); Assert.assertEquals(Math.sqrt(5714.932), TestUtils.rootLogLikelihoodRatio(1000, 1000, 1000, 99000), 0.001); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.inference; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.NoDataException; import org.apache.commons.math3.exception.NullArgumentException; import org.apache.commons.math3.exception.NumberIsTooLargeException; import org.junit.Assert; import org.junit.Test; /** * Test cases for the WilcoxonSignedRangTest class. * * @version $Id$ */ public class WilcoxonSignedRankTestTest { protected WilcoxonSignedRankTest testStatistic = new WilcoxonSignedRankTest(); @Test public void testWilcoxonSignedRankSimple() { /* Target values computed using R version 2.11.1 * x <- c(1.83, 0.50, 1.62, 2.48, 1.68, 1.88, 1.55, 3.06, 1.30) * y <- c(0.878, 0.647, 0.598, 2.05, 1.06, 1.29, 1.06, 3.14, 1.29) */ final double x[] = {1.83, 0.50, 1.62, 2.48, 1.68, 1.88, 1.55, 3.06, 1.30}; final double y[] = {0.878, 0.647, 0.598, 2.05, 1.06, 1.29, 1.06, 3.14, 1.29}; /* EXACT: * wilcox.test(x, y, alternative = "two.sided", mu = 0, paired = TRUE, exact = TRUE, correct = FALSE) * V = 40, p-value = 0.03906 * * Corresponds to the value obtained in R. */ Assert.assertEquals(40, testStatistic.wilcoxonSignedRank(x, y), 1e-10); Assert.assertEquals(0.03906, testStatistic.wilcoxonSignedRankTest(x, y, true), 1e-5); /* ASYMPTOTIC: * wilcox.test(x, y, alternative = "two.sided", mu = 0, paired = TRUE, exact = FALSE, correct = FALSE) * V = 40, p-value = 0.03815 * * This is not entirely the same due to different corrects, * e.g. http://mlsc.lboro.ac.uk/resources/statistics/wsrt.pdf * and src/library/stats/R/wilcox.test.R in the R source */ Assert.assertEquals(40, testStatistic.wilcoxonSignedRank(x, y), 1e-10); Assert.assertEquals(0.0329693812, testStatistic.wilcoxonSignedRankTest(x, y, false), 1e-10); } @Test public void testWilcoxonSignedRankInputValidation() { /* * Exact only for sample size <= 30 */ final double[] x1 = new double[30]; final double[] x2 = new double[31]; final double[] y1 = new double[30]; final double[] y2 = new double[31]; for (int i = 0; i < 30; ++i) { x1[i] = x2[i] = y1[i] = y2[i] = i; } // Exactly 30 is okay //testStatistic.wilcoxonSignedRankTest(x1, y1, true); try { testStatistic.wilcoxonSignedRankTest(x2, y2, true); Assert.fail("More than 30 samples and exact chosen, NumberIsTooLargeException expected"); } catch (NumberIsTooLargeException ex) { // expected } /* Samples must be present, i.e. length > 0 */ try { testStatistic.wilcoxonSignedRankTest(new double[] { }, new double[] { 1.0 }, true); Assert.fail("x does not contain samples (exact), NoDataException expected"); } catch (NoDataException ex) { // expected } try { testStatistic.wilcoxonSignedRankTest(new double[] { }, new double[] { 1.0 }, false); Assert.fail("x does not contain samples (asymptotic), NoDataException expected"); } catch (NoDataException ex) { // expected } try { testStatistic.wilcoxonSignedRankTest(new double[] { 1.0 }, new double[] { }, true); Assert.fail("y does not contain samples (exact), NoDataException expected"); } catch (NoDataException ex) { // expected } try { testStatistic.wilcoxonSignedRankTest(new double[] { 1.0 }, new double[] { }, false); Assert.fail("y does not contain samples (asymptotic), NoDataException expected"); } catch (NoDataException ex) { // expected } /* Samples not same size, i.e. cannot be pairred */ try { testStatistic.wilcoxonSignedRankTest(new double[] { 1.0, 2.0 }, new double[] { 3.0 }, true); Assert.fail("x and y not same size (exact), DimensionMismatchException expected"); } catch (DimensionMismatchException ex) { // expected } try { testStatistic.wilcoxonSignedRankTest(new double[] { 1.0, 2.0 }, new double[] { 3.0 }, false); Assert.fail("x and y not same size (asymptotic), DimensionMismatchException expected"); } catch (DimensionMismatchException ex) { // expected } /* * x and y is null */ try { testStatistic.wilcoxonSignedRankTest(null, null, true); Assert.fail("x and y is null (exact), NullArgumentException expected"); } catch (NullArgumentException ex) { // expected } try { testStatistic.wilcoxonSignedRankTest(null, null, false); Assert.fail("x and y is null (asymptotic), NullArgumentException expected"); } catch (NullArgumentException ex) { // expected } /* * x or y is null */ try { testStatistic.wilcoxonSignedRankTest(null, new double[] { 1.0 }, true); Assert.fail("x is null (exact), NullArgumentException expected"); } catch (NullArgumentException ex) { // expected } try { testStatistic.wilcoxonSignedRankTest(null, new double[] { 1.0 }, false); Assert.fail("x is null (asymptotic), NullArgumentException expected"); } catch (NullArgumentException ex) { // expected } try { testStatistic.wilcoxonSignedRankTest(new double[] { 1.0 }, null, true); Assert.fail("y is null (exact), NullArgumentException expected"); } catch (NullArgumentException ex) { // expected } try { testStatistic.wilcoxonSignedRankTest(new double[] { 1.0 }, null, false); Assert.fail("y is null (asymptotic), NullArgumentException expected"); } catch (NullArgumentException ex) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.ranking; import org.junit.Assert; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.exception.NotANumberException; import org.apache.commons.math3.random.JDKRandomGenerator; import org.apache.commons.math3.random.RandomGenerator; import org.junit.Test; /** * Test cases for NaturalRanking class * * @since 2.0 * @version $Id$ */ public class NaturalRankingTest { private final double[] exampleData = { 20, 17, 30, 42.3, 17, 50, Double.NaN, Double.NEGATIVE_INFINITY, 17 }; private final double[] tiesFirst = { 0, 0, 2, 1, 4 }; private final double[] tiesLast = { 4, 4, 1, 0 }; private final double[] multipleNaNs = { 0, 1, Double.NaN, Double.NaN }; private final double[] multipleTies = { 3, 2, 5, 5, 6, 6, 1 }; private final double[] allSame = { 0, 0, 0, 0 }; @Test public void testDefault() { // Ties averaged, NaNs failed NaturalRanking ranking = new NaturalRanking(); double[] ranks; try { ranks = ranking.rank(exampleData); Assert.fail("expected NotANumberException due to NaNStrategy.FAILED"); } catch (NotANumberException e) { // expected } ranks = ranking.rank(tiesFirst); double[] correctRanks = new double[] { 1.5, 1.5, 4, 3, 5 }; TestUtils.assertEquals(correctRanks, ranks, 0d); ranks = ranking.rank(tiesLast); correctRanks = new double[] { 3.5, 3.5, 2, 1 }; TestUtils.assertEquals(correctRanks, ranks, 0d); try { ranks = ranking.rank(multipleNaNs); Assert.fail("expected NotANumberException due to NaNStrategy.FAILED"); } catch (NotANumberException e) { // expected } ranks = ranking.rank(multipleTies); correctRanks = new double[] { 3, 2, 4.5, 4.5, 6.5, 6.5, 1 }; TestUtils.assertEquals(correctRanks, ranks, 0d); ranks = ranking.rank(allSame); correctRanks = new double[] { 2.5, 2.5, 2.5, 2.5 }; TestUtils.assertEquals(correctRanks, ranks, 0d); } @Test public void testNaNsMaximalTiesMinimum() { NaturalRanking ranking = new NaturalRanking(NaNStrategy.MAXIMAL, TiesStrategy.MINIMUM); double[] ranks = ranking.rank(exampleData); double[] correctRanks = { 5, 2, 6, 7, 2, 8, 9, 1, 2 }; TestUtils.assertEquals(correctRanks, ranks, 0d); ranks = ranking.rank(tiesFirst); correctRanks = new double[] { 1, 1, 4, 3, 5 }; TestUtils.assertEquals(correctRanks, ranks, 0d); ranks = ranking.rank(tiesLast); correctRanks = new double[] { 3, 3, 2, 1 }; TestUtils.assertEquals(correctRanks, ranks, 0d); ranks = ranking.rank(multipleNaNs); correctRanks = new double[] { 1, 2, 3, 3 }; TestUtils.assertEquals(correctRanks, ranks, 0d); ranks = ranking.rank(multipleTies); correctRanks = new double[] { 3, 2, 4, 4, 6, 6, 1 }; TestUtils.assertEquals(correctRanks, ranks, 0d); ranks = ranking.rank(allSame); correctRanks = new double[] { 1, 1, 1, 1 }; TestUtils.assertEquals(correctRanks, ranks, 0d); } @Test public void testNaNsRemovedTiesSequential() { NaturalRanking ranking = new NaturalRanking(NaNStrategy.REMOVED, TiesStrategy.SEQUENTIAL); double[] ranks = ranking.rank(exampleData); double[] correctRanks = { 5, 2, 6, 7, 3, 8, 1, 4 }; TestUtils.assertEquals(correctRanks, ranks, 0d); ranks = ranking.rank(tiesFirst); correctRanks = new double[] { 1, 2, 4, 3, 5 }; TestUtils.assertEquals(correctRanks, ranks, 0d); ranks = ranking.rank(tiesLast); correctRanks = new double[] { 3, 4, 2, 1 }; TestUtils.assertEquals(correctRanks, ranks, 0d); ranks = ranking.rank(multipleNaNs); correctRanks = new double[] { 1, 2 }; TestUtils.assertEquals(correctRanks, ranks, 0d); ranks = ranking.rank(multipleTies); correctRanks = new double[] { 3, 2, 4, 5, 6, 7, 1 }; TestUtils.assertEquals(correctRanks, ranks, 0d); ranks = ranking.rank(allSame); correctRanks = new double[] { 1, 2, 3, 4 }; TestUtils.assertEquals(correctRanks, ranks, 0d); } @Test public void testNaNsMinimalTiesMaximum() { NaturalRanking ranking = new NaturalRanking(NaNStrategy.MINIMAL, TiesStrategy.MAXIMUM); double[] ranks = ranking.rank(exampleData); double[] correctRanks = { 6, 5, 7, 8, 5, 9, 2, 2, 5 }; TestUtils.assertEquals(correctRanks, ranks, 0d); ranks = ranking.rank(tiesFirst); correctRanks = new double[] { 2, 2, 4, 3, 5 }; TestUtils.assertEquals(correctRanks, ranks, 0d); ranks = ranking.rank(tiesLast); correctRanks = new double[] { 4, 4, 2, 1 }; TestUtils.assertEquals(correctRanks, ranks, 0d); ranks = ranking.rank(multipleNaNs); correctRanks = new double[] { 3, 4, 2, 2 }; TestUtils.assertEquals(correctRanks, ranks, 0d); ranks = ranking.rank(multipleTies); correctRanks = new double[] { 3, 2, 5, 5, 7, 7, 1 }; TestUtils.assertEquals(correctRanks, ranks, 0d); ranks = ranking.rank(allSame); correctRanks = new double[] { 4, 4, 4, 4 }; TestUtils.assertEquals(correctRanks, ranks, 0d); } @Test public void testNaNsMinimalTiesAverage() { NaturalRanking ranking = new NaturalRanking(NaNStrategy.MINIMAL); double[] ranks = ranking.rank(exampleData); double[] correctRanks = { 6, 4, 7, 8, 4, 9, 1.5, 1.5, 4 }; TestUtils.assertEquals(correctRanks, ranks, 0d); ranks = ranking.rank(tiesFirst); correctRanks = new double[] { 1.5, 1.5, 4, 3, 5 }; TestUtils.assertEquals(correctRanks, ranks, 0d); ranks = ranking.rank(tiesLast); correctRanks = new double[] { 3.5, 3.5, 2, 1 }; TestUtils.assertEquals(correctRanks, ranks, 0d); ranks = ranking.rank(multipleNaNs); correctRanks = new double[] { 3, 4, 1.5, 1.5 }; TestUtils.assertEquals(correctRanks, ranks, 0d); ranks = ranking.rank(multipleTies); correctRanks = new double[] { 3, 2, 4.5, 4.5, 6.5, 6.5, 1 }; TestUtils.assertEquals(correctRanks, ranks, 0d); ranks = ranking.rank(allSame); correctRanks = new double[] { 2.5, 2.5, 2.5, 2.5 }; TestUtils.assertEquals(correctRanks, ranks, 0d); } @Test public void testNaNsFixedTiesRandom() { RandomGenerator randomGenerator = new JDKRandomGenerator(); randomGenerator.setSeed(1000); NaturalRanking ranking = new NaturalRanking(NaNStrategy.FIXED, randomGenerator); double[] ranks = ranking.rank(exampleData); double[] correctRanks = { 5, 3, 6, 7, 3, 8, Double.NaN, 1, 2 }; TestUtils.assertEquals(correctRanks, ranks, 0d); ranks = ranking.rank(tiesFirst); correctRanks = new double[] { 1, 2, 4, 3, 5 }; TestUtils.assertEquals(correctRanks, ranks, 0d); ranks = ranking.rank(tiesLast); correctRanks = new double[] { 3, 3, 2, 1 }; TestUtils.assertEquals(correctRanks, ranks, 0d); ranks = ranking.rank(multipleNaNs); correctRanks = new double[] { 1, 2, Double.NaN, Double.NaN }; TestUtils.assertEquals(correctRanks, ranks, 0d); ranks = ranking.rank(multipleTies); correctRanks = new double[] { 3, 2, 4, 4, 6, 7, 1 }; TestUtils.assertEquals(correctRanks, ranks, 0d); ranks = ranking.rank(allSame); correctRanks = new double[] { 2, 3, 3, 3 }; TestUtils.assertEquals(correctRanks, ranks, 0d); } @Test public void testNaNsAndInfs() { double[] data = { 0, Double.POSITIVE_INFINITY, Double.NaN, Double.NEGATIVE_INFINITY }; NaturalRanking ranking = new NaturalRanking(NaNStrategy.MAXIMAL); double[] ranks = ranking.rank(data); double[] correctRanks = new double[] { 2, 3.5, 3.5, 1 }; TestUtils.assertEquals(correctRanks, ranks, 0d); ranking = new NaturalRanking(NaNStrategy.MINIMAL); ranks = ranking.rank(data); correctRanks = new double[] { 3, 4, 1.5, 1.5 }; TestUtils.assertEquals(correctRanks, ranks, 0d); } @Test(expected=NotANumberException.class) public void testNaNsFailed() { double[] data = { 0, Double.POSITIVE_INFINITY, Double.NaN, Double.NEGATIVE_INFINITY }; NaturalRanking ranking = new NaturalRanking(NaNStrategy.FAILED); ranking.rank(data); } @Test public void testNoNaNsFailed() { double[] data = { 1, 2, 3, 4 }; NaturalRanking ranking = new NaturalRanking(NaNStrategy.FAILED); double[] ranks = ranking.rank(data); TestUtils.assertEquals(data, ranks, 0d); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.regression; import org.junit.Assert; import org.junit.Before; import org.junit.Test; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.linear.MatrixUtils; import org.apache.commons.math3.linear.RealMatrix; import org.apache.commons.math3.linear.RealVector; import org.apache.commons.math3.random.CorrelatedRandomVectorGenerator; import org.apache.commons.math3.random.JDKRandomGenerator; import org.apache.commons.math3.random.GaussianRandomGenerator; import org.apache.commons.math3.random.RandomGenerator; import org.apache.commons.math3.stat.correlation.Covariance; import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics; public class GLSMultipleLinearRegressionTest extends MultipleLinearRegressionAbstractTest { private double[] y; private double[][] x; private double[][] omega; private double[] longley = new double[] { 60323,83.0,234289,2356,1590,107608,1947, 61122,88.5,259426,2325,1456,108632,1948, 60171,88.2,258054,3682,1616,109773,1949, 61187,89.5,284599,3351,1650,110929,1950, 63221,96.2,328975,2099,3099,112075,1951, 63639,98.1,346999,1932,3594,113270,1952, 64989,99.0,365385,1870,3547,115094,1953, 63761,100.0,363112,3578,3350,116219,1954, 66019,101.2,397469,2904,3048,117388,1955, 67857,104.6,419180,2822,2857,118734,1956, 68169,108.4,442769,2936,2798,120445,1957, 66513,110.8,444546,4681,2637,121950,1958, 68655,112.6,482704,3813,2552,123366,1959, 69564,114.2,502601,3931,2514,125368,1960, 69331,115.7,518173,4806,2572,127852,1961, 70551,116.9,554894,4007,2827,130081,1962 }; @Before @Override public void setUp(){ y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0}; x = new double[6][]; x[0] = new double[]{0, 0, 0, 0, 0}; x[1] = new double[]{2.0, 0, 0, 0, 0}; x[2] = new double[]{0, 3.0, 0, 0, 0}; x[3] = new double[]{0, 0, 4.0, 0, 0}; x[4] = new double[]{0, 0, 0, 5.0, 0}; x[5] = new double[]{0, 0, 0, 0, 6.0}; omega = new double[6][]; omega[0] = new double[]{1.0, 0, 0, 0, 0, 0}; omega[1] = new double[]{0, 2.0, 0, 0, 0, 0}; omega[2] = new double[]{0, 0, 3.0, 0, 0, 0}; omega[3] = new double[]{0, 0, 0, 4.0, 0, 0}; omega[4] = new double[]{0, 0, 0, 0, 5.0, 0}; omega[5] = new double[]{0, 0, 0, 0, 0, 6.0}; super.setUp(); } @Test(expected=IllegalArgumentException.class) public void cannotAddXSampleData() { createRegression().newSampleData(new double[]{}, null, null); } @Test(expected=IllegalArgumentException.class) public void cannotAddNullYSampleData() { createRegression().newSampleData(null, new double[][]{}, null); } @Test(expected=IllegalArgumentException.class) public void cannotAddSampleDataWithSizeMismatch() { double[] y = new double[]{1.0, 2.0}; double[][] x = new double[1][]; x[0] = new double[]{1.0, 0}; createRegression().newSampleData(y, x, null); } @Test(expected=IllegalArgumentException.class) public void cannotAddNullCovarianceData() { createRegression().newSampleData(new double[]{}, new double[][]{}, null); } @Test(expected=IllegalArgumentException.class) public void notEnoughData() { double[] reducedY = new double[y.length - 1]; double[][] reducedX = new double[x.length - 1][]; double[][] reducedO = new double[omega.length - 1][]; System.arraycopy(y, 0, reducedY, 0, reducedY.length); System.arraycopy(x, 0, reducedX, 0, reducedX.length); System.arraycopy(omega, 0, reducedO, 0, reducedO.length); createRegression().newSampleData(reducedY, reducedX, reducedO); } @Test(expected=IllegalArgumentException.class) public void cannotAddCovarianceDataWithSampleSizeMismatch() { double[] y = new double[]{1.0, 2.0}; double[][] x = new double[2][]; x[0] = new double[]{1.0, 0}; x[1] = new double[]{0, 1.0}; double[][] omega = new double[1][]; omega[0] = new double[]{1.0, 0}; createRegression().newSampleData(y, x, omega); } @Test(expected=IllegalArgumentException.class) public void cannotAddCovarianceDataThatIsNotSquare() { double[] y = new double[]{1.0, 2.0}; double[][] x = new double[2][]; x[0] = new double[]{1.0, 0}; x[1] = new double[]{0, 1.0}; double[][] omega = new double[3][]; omega[0] = new double[]{1.0, 0}; omega[1] = new double[]{0, 1.0}; omega[2] = new double[]{0, 2.0}; createRegression().newSampleData(y, x, omega); } @Override protected GLSMultipleLinearRegression createRegression() { GLSMultipleLinearRegression regression = new GLSMultipleLinearRegression(); regression.newSampleData(y, x, omega); return regression; } @Override protected int getNumberOfRegressors() { return x[0].length + 1; } @Override protected int getSampleSize() { return y.length; } /** * test calculateYVariance */ @Test public void testYVariance() { // assumes: y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0}; GLSMultipleLinearRegression model = new GLSMultipleLinearRegression(); model.newSampleData(y, x, omega); TestUtils.assertEquals(model.calculateYVariance(), 3.5, 0); } /** * Verifies that setting X, Y and covariance separately has the same effect as newSample(X,Y,cov). */ @Test public void testNewSample2() { double[] y = new double[] {1, 2, 3, 4}; double[][] x = new double[][] { {19, 22, 33}, {20, 30, 40}, {25, 35, 45}, {27, 37, 47} }; double[][] covariance = MatrixUtils.createRealIdentityMatrix(4).scalarMultiply(2).getData(); GLSMultipleLinearRegression regression = new GLSMultipleLinearRegression(); regression.newSampleData(y, x, covariance); RealMatrix combinedX = regression.getX().copy(); RealVector combinedY = regression.getY().copy(); RealMatrix combinedCovInv = regression.getOmegaInverse(); regression.newXSampleData(x); regression.newYSampleData(y); Assert.assertEquals(combinedX, regression.getX()); Assert.assertEquals(combinedY, regression.getY()); Assert.assertEquals(combinedCovInv, regression.getOmegaInverse()); } /** * Verifies that GLS with identity covariance matrix gives the same results * as OLS. */ @Test public void testGLSOLSConsistency() { RealMatrix identityCov = MatrixUtils.createRealIdentityMatrix(16); GLSMultipleLinearRegression glsModel = new GLSMultipleLinearRegression(); OLSMultipleLinearRegression olsModel = new OLSMultipleLinearRegression(); glsModel.newSampleData(longley, 16, 6); olsModel.newSampleData(longley, 16, 6); glsModel.newCovarianceData(identityCov.getData()); double[] olsBeta = olsModel.calculateBeta().toArray(); double[] glsBeta = glsModel.calculateBeta().toArray(); // TODO: Should have assertRelativelyEquals(double[], double[], eps) in TestUtils // Should also add RealVector and RealMatrix versions for (int i = 0; i < olsBeta.length; i++) { TestUtils.assertRelativelyEquals(olsBeta[i], glsBeta[i], 10E-7); } } /** * Generate an error covariance matrix and sample data representing models * with this error structure. Then verify that GLS estimated coefficients, * on average, perform better than OLS. */ @Test public void testGLSEfficiency() { RandomGenerator rg = new JDKRandomGenerator(); rg.setSeed(200); // Seed has been selected to generate non-trivial covariance // Assume model has 16 observations (will use Longley data). Start by generating // non-constant variances for the 16 error terms. final int nObs = 16; double[] sigma = new double[nObs]; for (int i = 0; i < nObs; i++) { sigma[i] = 10 * rg.nextDouble(); } // Now generate 1000 error vectors to use to estimate the covariance matrix // Columns are draws on N(0, sigma[col]) final int numSeeds = 1000; RealMatrix errorSeeds = MatrixUtils.createRealMatrix(numSeeds, nObs); for (int i = 0; i < numSeeds; i++) { for (int j = 0; j < nObs; j++) { errorSeeds.setEntry(i, j, rg.nextGaussian() * sigma[j]); } } // Get covariance matrix for columns RealMatrix cov = (new Covariance(errorSeeds)).getCovarianceMatrix(); // Create a CorrelatedRandomVectorGenerator to use to generate correlated errors GaussianRandomGenerator rawGenerator = new GaussianRandomGenerator(rg); double[] errorMeans = new double[nObs]; // Counting on init to 0 here CorrelatedRandomVectorGenerator gen = new CorrelatedRandomVectorGenerator(errorMeans, cov, 1.0e-12 * cov.getNorm(), rawGenerator); // Now start generating models. Use Longley X matrix on LHS // and Longley OLS beta vector as "true" beta. Generate // Y values by XB + u where u is a CorrelatedRandomVector generated // from cov. OLSMultipleLinearRegression ols = new OLSMultipleLinearRegression(); ols.newSampleData(longley, nObs, 6); final RealVector b = ols.calculateBeta().copy(); final RealMatrix x = ols.getX().copy(); // Create a GLS model to reuse GLSMultipleLinearRegression gls = new GLSMultipleLinearRegression(); gls.newSampleData(longley, nObs, 6); gls.newCovarianceData(cov.getData()); // Create aggregators for stats measuring model performance DescriptiveStatistics olsBetaStats = new DescriptiveStatistics(); DescriptiveStatistics glsBetaStats = new DescriptiveStatistics(); // Generate Y vectors for 10000 models, estimate GLS and OLS and // Verify that OLS estimates are better final int nModels = 10000; for (int i = 0; i < nModels; i++) { // Generate y = xb + u with u cov RealVector u = MatrixUtils.createRealVector(gen.nextVector()); double[] y = u.add(x.operate(b)).toArray(); // Estimate OLS parameters ols.newYSampleData(y); RealVector olsBeta = ols.calculateBeta(); // Estimate GLS parameters gls.newYSampleData(y); RealVector glsBeta = gls.calculateBeta(); // Record deviations from "true" beta double dist = olsBeta.getDistance(b); olsBetaStats.addValue(dist * dist); dist = glsBeta.getDistance(b); glsBetaStats.addValue(dist * dist); } // Verify that GLS is on average more efficient, lower variance assert(olsBetaStats.getMean() > 1.5 * glsBetaStats.getMean()); assert(olsBetaStats.getStandardDeviation() > glsBetaStats.getStandardDeviation()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.regression; import org.apache.commons.math3.linear.RealMatrix; import org.apache.commons.math3.stat.correlation.PearsonsCorrelation; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * MillerUpdatingRegression tests. */ public class MillerUpdatingRegressionTest { public MillerUpdatingRegressionTest() { } /* This is the Greene Airline Cost data. * The data can be downloaded from http://www.indiana.edu/~statmath/stat/all/panel/airline.csv */ private final static double[][] airdata = { /*"I",*/new double[]{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6}, /*"T",*/ new double[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}, /*"C",*/ new double[]{1140640, 1215690, 1309570, 1511530, 1676730, 1823740, 2022890, 2314760, 2639160, 3247620, 3787750, 3867750, 3996020, 4282880, 4748320, 569292, 640614, 777655, 999294, 1203970, 1358100, 1501350, 1709270, 2025400, 2548370, 3137740, 3557700, 3717740, 3962370, 4209390, 286298, 309290, 342056, 374595, 450037, 510412, 575347, 669331, 783799, 913883, 1041520, 1125800, 1096070, 1198930, 1170470, 145167, 170192, 247506, 309391, 354338, 373941, 420915, 474017, 532590, 676771, 880438, 1052020, 1193680, 1303390, 1436970, 91361, 95428, 98187, 115967, 138382, 156228, 183169, 210212, 274024, 356915, 432344, 524294, 530924, 581447, 610257, 68978, 74904, 83829, 98148, 118449, 133161, 145062, 170711, 199775, 276797, 381478, 506969, 633388, 804388, 1009500}, /*"Q",*/ new double[]{0.952757, 0.986757, 1.09198, 1.17578, 1.16017, 1.17376, 1.29051, 1.39067, 1.61273, 1.82544, 1.54604, 1.5279, 1.6602, 1.82231, 1.93646, 0.520635, 0.534627, 0.655192, 0.791575, 0.842945, 0.852892, 0.922843, 1, 1.19845, 1.34067, 1.32624, 1.24852, 1.25432, 1.37177, 1.38974, 0.262424, 0.266433, 0.306043, 0.325586, 0.345706, 0.367517, 0.409937, 0.448023, 0.539595, 0.539382, 0.467967, 0.450544, 0.468793, 0.494397, 0.493317, 0.086393, 0.09674, 0.1415, 0.169715, 0.173805, 0.164272, 0.170906, 0.17784, 0.192248, 0.242469, 0.256505, 0.249657, 0.273923, 0.371131, 0.421411, 0.051028, 0.052646, 0.056348, 0.066953, 0.070308, 0.073961, 0.084946, 0.095474, 0.119814, 0.150046, 0.144014, 0.1693, 0.172761, 0.18667, 0.213279, 0.037682, 0.039784, 0.044331, 0.050245, 0.055046, 0.052462, 0.056977, 0.06149, 0.069027, 0.092749, 0.11264, 0.154154, 0.186461, 0.246847, 0.304013}, /*"PF",*/ new double[]{106650, 110307, 110574, 121974, 196606, 265609, 263451, 316411, 384110, 569251, 871636, 997239, 938002, 859572, 823411, 103795, 111477, 118664, 114797, 215322, 281704, 304818, 348609, 374579, 544109, 853356, 1003200, 941977, 856533, 821361, 118788, 123798, 122882, 131274, 222037, 278721, 306564, 356073, 378311, 555267, 850322, 1015610, 954508, 886999, 844079, 114987, 120501, 121908, 127220, 209405, 263148, 316724, 363598, 389436, 547376, 850418, 1011170, 951934, 881323, 831374, 118222, 116223, 115853, 129372, 243266, 277930, 317273, 358794, 397667, 566672, 848393, 1005740, 958231, 872924, 844622, 117112, 119420, 116087, 122997, 194309, 307923, 323595, 363081, 386422, 564867, 874818, 1013170, 930477, 851676, 819476}, /*"LF",*/ new double[]{0.534487, 0.532328, 0.547736, 0.540846, 0.591167, 0.575417, 0.594495, 0.597409, 0.638522, 0.676287, 0.605735, 0.61436, 0.633366, 0.650117, 0.625603, 0.490851, 0.473449, 0.503013, 0.512501, 0.566782, 0.558133, 0.558799, 0.57207, 0.624763, 0.628706, 0.58915, 0.532612, 0.526652, 0.540163, 0.528775, 0.524334, 0.537185, 0.582119, 0.579489, 0.606592, 0.60727, 0.582425, 0.573972, 0.654256, 0.631055, 0.56924, 0.589682, 0.587953, 0.565388, 0.577078, 0.432066, 0.439669, 0.488932, 0.484181, 0.529925, 0.532723, 0.549067, 0.55714, 0.611377, 0.645319, 0.611734, 0.580884, 0.572047, 0.59457, 0.585525, 0.442875, 0.462473, 0.519118, 0.529331, 0.557797, 0.556181, 0.569327, 0.583465, 0.631818, 0.604723, 0.587921, 0.616159, 0.605868, 0.594688, 0.635545, 0.448539, 0.475889, 0.500562, 0.500344, 0.528897, 0.495361, 0.510342, 0.518296, 0.546723, 0.554276, 0.517766, 0.580049, 0.556024, 0.537791, 0.525775} }; /** * Test of hasIntercept method, of class MillerUpdatingRegression. */ @Test public void testHasIntercept() { MillerUpdatingRegression instance = new MillerUpdatingRegression(10, false); if (instance.hasIntercept()) { Assert.fail("Should not have intercept"); } instance = new MillerUpdatingRegression(10, true); if (!instance.hasIntercept()) { Assert.fail("Should have intercept"); } } /** * Test of getN method, of class MillerUpdatingRegression. */ @Test public void testAddObsGetNClear() { MillerUpdatingRegression instance = new MillerUpdatingRegression(3, true); double[][] xAll = new double[airdata[0].length][]; double[] y = new double[airdata[0].length]; for (int i = 0; i < airdata[0].length; i++) { xAll[i] = new double[3]; xAll[i][0] = Math.log(airdata[3][i]); xAll[i][1] = Math.log(airdata[4][i]); xAll[i][2] = airdata[5][i]; y[i] = Math.log(airdata[2][i]); } instance.addObservations(xAll, y); if (instance.getN() != xAll.length) { Assert.fail("Number of observations not correct in bulk addition"); } instance.clear(); for (int i = 0; i < xAll.length; i++) { instance.addObservation(xAll[i], y[i]); } if (instance.getN() != xAll.length) { Assert.fail("Number of observations not correct in drip addition"); } return; } @Test public void testNegativeTestAddObs() { MillerUpdatingRegression instance = new MillerUpdatingRegression(3, true); try { instance.addObservation(new double[]{1.0}, 0.0); Assert.fail("Should throw IllegalArgumentException"); } catch (IllegalArgumentException iae) { } catch (Exception e) { Assert.fail("Should throw IllegalArgumentException"); } try { instance.addObservation(new double[]{1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0}, 0.0); Assert.fail("Should throw IllegalArgumentException"); } catch (IllegalArgumentException iae) { } catch (Exception e) { Assert.fail("Should throw IllegalArgumentException"); } try { instance.addObservation(new double[]{1.0, 1.0, 1.0}, 0.0); } catch (Exception e) { Assert.fail("Should throw IllegalArgumentException"); } //now we try it without an intercept instance = new MillerUpdatingRegression(3, false); try { instance.addObservation(new double[]{1.0}, 0.0); Assert.fail("Should throw IllegalArgumentException [NOINTERCEPT]"); } catch (IllegalArgumentException iae) { } catch (Exception e) { Assert.fail("Should throw IllegalArgumentException [NOINTERCEPT]"); } try { instance.addObservation(new double[]{1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0}, 0.0); Assert.fail("Should throw IllegalArgumentException [NOINTERCEPT]"); } catch (IllegalArgumentException iae) { } catch (Exception e) { Assert.fail("Should throw IllegalArgumentException [NOINTERCEPT]"); } try { instance.addObservation(new double[]{1.0, 1.0, 1.0}, 0.0); } catch (Exception e) { Assert.fail("Should throw IllegalArgumentException [NOINTERCEPT]"); } } @Test public void testNegativeTestAddMultipleObs() { MillerUpdatingRegression instance = new MillerUpdatingRegression(3, true); try { double[][] tst = {{1.0, 1.0, 1.0}, {1.20, 2.0, 2.1}}; double[] y = {1.0}; instance.addObservations(tst, y); Assert.fail("Should throw IllegalArgumentException"); } catch (IllegalArgumentException iae) { } catch (Exception e) { Assert.fail("Should throw IllegalArgumentException"); } try { double[][] tst = {{1.0, 1.0, 1.0}, {1.20, 2.0, 2.1}}; double[] y = {1.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0}; instance.addObservations(tst, y); Assert.fail("Should throw IllegalArgumentException"); } catch (IllegalArgumentException iae) { } catch (Exception e) { Assert.fail("Should throw IllegalArgumentException"); } } /* Results can be found at http://www.indiana.edu/~statmath/stat/all/panel/panel4.html * This test concerns a known data set */ @Test public void testRegressAirlineConstantExternal() { MillerUpdatingRegression instance = new MillerUpdatingRegression(4, false); double[][] x = new double[airdata[0].length][]; double[] y = new double[airdata[0].length]; for (int i = 0; i < airdata[0].length; i++) { x[i] = new double[4]; x[i][0] = 1.0; x[i][1] = Math.log(airdata[3][i]); x[i][2] = Math.log(airdata[4][i]); x[i][3] = airdata[5][i]; y[i] = Math.log(airdata[2][i]); } instance.addObservations(x, y); try { RegressionResults result = instance.regress(); Assert.assertNotNull("The test case is a prototype.", result); TestUtils.assertEquals( new double[]{9.5169, 0.8827, 0.4540, -1.6275}, result.getParameterEstimates(), 1e-4); TestUtils.assertEquals( new double[]{.2292445, .0132545, .0203042, .345302}, result.getStdErrorOfEstimates(), 1.0e-4); TestUtils.assertEquals(0.01552839, result.getMeanSquareError(), 1.0e-8); } catch (Exception e) { Assert.fail("Should not throw exception but does"); } } @Test public void testRegressAirlineConstantInternal() { MillerUpdatingRegression instance = new MillerUpdatingRegression(3, true); double[][] x = new double[airdata[0].length][]; double[] y = new double[airdata[0].length]; for (int i = 0; i < airdata[0].length; i++) { x[i] = new double[3]; x[i][0] = Math.log(airdata[3][i]); x[i][1] = Math.log(airdata[4][i]); x[i][2] = airdata[5][i]; y[i] = Math.log(airdata[2][i]); } instance.addObservations(x, y); try { RegressionResults result = instance.regress(); Assert.assertNotNull("The test case is a prototype.", result); TestUtils.assertEquals( new double[]{9.5169, 0.8827, 0.4540, -1.6275}, result.getParameterEstimates(), 1e-4); TestUtils.assertEquals( new double[]{.2292445, .0132545, .0203042, .345302}, result.getStdErrorOfEstimates(), 1.0e-4); TestUtils.assertEquals(0.9883, result.getRSquared(), 1.0e-4); TestUtils.assertEquals(0.01552839, result.getMeanSquareError(), 1.0e-8); } catch (Exception e) { Assert.fail("Should not throw exception but does"); } } @Test public void testFilippelli() { double[] data = new double[]{ 0.8116, -6.860120914, 0.9072, -4.324130045, 0.9052, -4.358625055, 0.9039, -4.358426747, 0.8053, -6.955852379, 0.8377, -6.661145254, 0.8667, -6.355462942, 0.8809, -6.118102026, 0.7975, -7.115148017, 0.8162, -6.815308569, 0.8515, -6.519993057, 0.8766, -6.204119983, 0.8885, -5.853871964, 0.8859, -6.109523091, 0.8959, -5.79832982, 0.8913, -5.482672118, 0.8959, -5.171791386, 0.8971, -4.851705903, 0.9021, -4.517126416, 0.909, -4.143573228, 0.9139, -3.709075441, 0.9199, -3.499489089, 0.8692, -6.300769497, 0.8872, -5.953504836, 0.89, -5.642065153, 0.891, -5.031376979, 0.8977, -4.680685696, 0.9035, -4.329846955, 0.9078, -3.928486195, 0.7675, -8.56735134, 0.7705, -8.363211311, 0.7713, -8.107682739, 0.7736, -7.823908741, 0.7775, -7.522878745, 0.7841, -7.218819279, 0.7971, -6.920818754, 0.8329, -6.628932138, 0.8641, -6.323946875, 0.8804, -5.991399828, 0.7668, -8.781464495, 0.7633, -8.663140179, 0.7678, -8.473531488, 0.7697, -8.247337057, 0.77, -7.971428747, 0.7749, -7.676129393, 0.7796, -7.352812702, 0.7897, -7.072065318, 0.8131, -6.774174009, 0.8498, -6.478861916, 0.8741, -6.159517513, 0.8061, -6.835647144, 0.846, -6.53165267, 0.8751, -6.224098421, 0.8856, -5.910094889, 0.8919, -5.598599459, 0.8934, -5.290645224, 0.894, -4.974284616, 0.8957, -4.64454848, 0.9047, -4.290560426, 0.9129, -3.885055584, 0.9209, -3.408378962, 0.9219, -3.13200249, 0.7739, -8.726767166, 0.7681, -8.66695597, 0.7665, -8.511026475, 0.7703, -8.165388579, 0.7702, -7.886056648, 0.7761, -7.588043762, 0.7809, -7.283412422, 0.7961, -6.995678626, 0.8253, -6.691862621, 0.8602, -6.392544977, 0.8809, -6.067374056, 0.8301, -6.684029655, 0.8664, -6.378719832, 0.8834, -6.065855188, 0.8898, -5.752272167, 0.8964, -5.132414673, 0.8963, -4.811352704, 0.9074, -4.098269308, 0.9119, -3.66174277, 0.9228, -3.2644011 }; MillerUpdatingRegression model = new MillerUpdatingRegression(10, true); int off = 0; double[] tmp = new double[10]; int nobs = 82; for (int i = 0; i < nobs; i++) { tmp[0] = data[off + 1]; // tmp[1] = tmp[0] * tmp[0]; // tmp[2] = tmp[0] * tmp[1]; //^3 // tmp[3] = tmp[1] * tmp[1]; //^4 // tmp[4] = tmp[2] * tmp[1]; //^5 // tmp[5] = tmp[2] * tmp[2]; //^6 // tmp[6] = tmp[2] * tmp[3]; //^7 // tmp[7] = tmp[3] * tmp[3]; //^8 // tmp[8] = tmp[4] * tmp[3]; //^9 // tmp[9] = tmp[4] * tmp[4]; //^10 tmp[1] = tmp[0] * tmp[0]; tmp[2] = tmp[0] * tmp[1]; tmp[3] = tmp[0] * tmp[2]; tmp[4] = tmp[0] * tmp[3]; tmp[5] = tmp[0] * tmp[4]; tmp[6] = tmp[0] * tmp[5]; tmp[7] = tmp[0] * tmp[6]; tmp[8] = tmp[0] * tmp[7]; tmp[9] = tmp[0] * tmp[8]; model.addObservation(tmp, data[off]); off += 2; } RegressionResults result = model.regress(); double[] betaHat = result.getParameterEstimates(); TestUtils.assertEquals(betaHat, new double[]{ -1467.48961422980, -2772.17959193342, -2316.37108160893, -1127.97394098372, -354.478233703349, -75.1242017393757, -10.8753180355343, -1.06221498588947, -0.670191154593408E-01, -0.246781078275479E-02, -0.402962525080404E-04 }, 1E-5); // // double[] se = result.getStdErrorOfEstimates(); TestUtils.assertEquals(se, new double[]{ 298.084530995537, 559.779865474950, 466.477572127796, 227.204274477751, 71.6478660875927, 15.2897178747400, 2.23691159816033, 0.221624321934227, 0.142363763154724E-01, 0.535617408889821E-03, 0.896632837373868E-05 }, 1E-5); // TestUtils.assertEquals(0.996727416185620, result.getRSquared(), 1.0e-8); TestUtils.assertEquals(0.112091743968020E-04, result.getMeanSquareError(), 1.0e-10); TestUtils.assertEquals(0.795851382172941E-03, result.getErrorSumSquares(), 1.0e-10); } @Test public void testWampler1() { double[] data = new double[]{ 1, 0, 6, 1, 63, 2, 364, 3, 1365, 4, 3906, 5, 9331, 6, 19608, 7, 37449, 8, 66430, 9, 111111, 10, 177156, 11, 271453, 12, 402234, 13, 579195, 14, 813616, 15, 1118481, 16, 1508598, 17, 2000719, 18, 2613660, 19, 3368421, 20}; MillerUpdatingRegression model = new MillerUpdatingRegression(5, true); int off = 0; double[] tmp = new double[5]; int nobs = 21; for (int i = 0; i < nobs; i++) { tmp[0] = data[off + 1]; tmp[1] = tmp[0] * tmp[0]; tmp[2] = tmp[0] * tmp[1]; tmp[3] = tmp[0] * tmp[2]; tmp[4] = tmp[0] * tmp[3]; model.addObservation(tmp, data[off]); off += 2; } RegressionResults result = model.regress(); double[] betaHat = result.getParameterEstimates(); TestUtils.assertEquals(betaHat, new double[]{1.0, 1.0, 1.0, 1.0, 1.0, 1.0}, 1E-8); // // double[] se = result.getStdErrorOfEstimates(); TestUtils.assertEquals(se, new double[]{0.0, 0.0, 0.0, 0.0, 0.0, 0.0}, 1E-8); // TestUtils.assertEquals(1.0, result.getRSquared(), 1.0e-10); TestUtils.assertEquals(0, result.getMeanSquareError(), 1.0e-7); TestUtils.assertEquals(0.00, result.getErrorSumSquares(), 1.0e-6); return; } @Test public void testWampler2() { double[] data = new double[]{ 1.00000, 0, 1.11111, 1, 1.24992, 2, 1.42753, 3, 1.65984, 4, 1.96875, 5, 2.38336, 6, 2.94117, 7, 3.68928, 8, 4.68559, 9, 6.00000, 10, 7.71561, 11, 9.92992, 12, 12.75603, 13, 16.32384, 14, 20.78125, 15, 26.29536, 16, 33.05367, 17, 41.26528, 18, 51.16209, 19, 63.00000, 20}; MillerUpdatingRegression model = new MillerUpdatingRegression(5, true); int off = 0; double[] tmp = new double[5]; int nobs = 21; for (int i = 0; i < nobs; i++) { tmp[0] = data[off + 1]; tmp[1] = tmp[0] * tmp[0]; tmp[2] = tmp[0] * tmp[1]; tmp[3] = tmp[0] * tmp[2]; tmp[4] = tmp[0] * tmp[3]; model.addObservation(tmp, data[off]); off += 2; } RegressionResults result = model.regress(); double[] betaHat = result.getParameterEstimates(); TestUtils.assertEquals(betaHat, new double[]{1.0, 1.0e-1, 1.0e-2, 1.0e-3, 1.0e-4, 1.0e-5}, 1E-8); // // double[] se = result.getStdErrorOfEstimates(); TestUtils.assertEquals(se, new double[]{0.0, 0.0, 0.0, 0.0, 0.0, 0.0}, 1E-8); // TestUtils.assertEquals(1.0, result.getRSquared(), 1.0e-10); TestUtils.assertEquals(0, result.getMeanSquareError(), 1.0e-7); TestUtils.assertEquals(0.00, result.getErrorSumSquares(), 1.0e-6); return; } @Test public void testWampler3() { double[] data = new double[]{ 760, 0, -2042, 1, 2111, 2, -1684, 3, 3888, 4, 1858, 5, 11379, 6, 17560, 7, 39287, 8, 64382, 9, 113159, 10, 175108, 11, 273291, 12, 400186, 13, 581243, 14, 811568, 15, 1121004, 16, 1506550, 17, 2002767, 18, 2611612, 19, 3369180, 20}; MillerUpdatingRegression model = new MillerUpdatingRegression(5, true); int off = 0; double[] tmp = new double[5]; int nobs = 21; for (int i = 0; i < nobs; i++) { tmp[0] = data[off + 1]; tmp[1] = tmp[0] * tmp[0]; tmp[2] = tmp[0] * tmp[1]; tmp[3] = tmp[0] * tmp[2]; tmp[4] = tmp[0] * tmp[3]; model.addObservation(tmp, data[off]); off += 2; } RegressionResults result = model.regress(); double[] betaHat = result.getParameterEstimates(); TestUtils.assertEquals(betaHat, new double[]{1.0, 1.0, 1.0, 1.0, 1.0, 1.0}, 1E-8); // double[] se = result.getStdErrorOfEstimates(); TestUtils.assertEquals(se, new double[]{2152.32624678170, 2363.55173469681, 779.343524331583, 101.475507550350, 5.64566512170752, 0.112324854679312}, 1E-8); // TestUtils.assertEquals(.999995559025820, result.getRSquared(), 1.0e-10); TestUtils.assertEquals(5570284.53333333, result.getMeanSquareError(), 1.0e-7); TestUtils.assertEquals(83554268.0000000, result.getErrorSumSquares(), 1.0e-6); return; } //@Test public void testWampler4() { double[] data = new double[]{ 75901, 0, -204794, 1, 204863, 2, -204436, 3, 253665, 4, -200894, 5, 214131, 6, -185192, 7, 221249, 8, -138370, 9, 315911, 10, -27644, 11, 455253, 12, 197434, 13, 783995, 14, 608816, 15, 1370781, 16, 1303798, 17, 2205519, 18, 2408860, 19, 3444321, 20}; MillerUpdatingRegression model = new MillerUpdatingRegression(5, true); int off = 0; double[] tmp = new double[5]; int nobs = 21; for (int i = 0; i < nobs; i++) { tmp[0] = data[off + 1]; tmp[1] = tmp[0] * tmp[0]; tmp[2] = tmp[0] * tmp[1]; tmp[3] = tmp[0] * tmp[2]; tmp[4] = tmp[0] * tmp[3]; model.addObservation(tmp, data[off]); off += 2; } RegressionResults result = model.regress(); double[] betaHat = result.getParameterEstimates(); TestUtils.assertEquals(betaHat, new double[]{1.0, 1.0, 1.0, 1.0, 1.0, 1.0}, 1E-8); // // double[] se = result.getStdErrorOfEstimates(); TestUtils.assertEquals(se, new double[]{215232.624678170, 236355.173469681, 77934.3524331583, 10147.5507550350, 564.566512170752, 11.2324854679312}, 1E-8); // TestUtils.assertEquals(.957478440825662, result.getRSquared(), 1.0e-10); TestUtils.assertEquals(55702845333.3333, result.getMeanSquareError(), 1.0e-4); TestUtils.assertEquals(835542680000.000, result.getErrorSumSquares(), 1.0e-3); return; } /** * Test Longley dataset against certified values provided by NIST. * Data Source: J. Longley (1967) "An Appraisal of Least Squares * Programs for the Electronic Computer from the Point of View of the User" * Journal of the American Statistical Association, vol. 62. September, * pp. 819-841. * * Certified values (and data) are from NIST: * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat */ @Test public void testLongly() { // Y values are first, then independent vars // Each row is one observation double[] design = new double[]{ 60323, 83.0, 234289, 2356, 1590, 107608, 1947, 61122, 88.5, 259426, 2325, 1456, 108632, 1948, 60171, 88.2, 258054, 3682, 1616, 109773, 1949, 61187, 89.5, 284599, 3351, 1650, 110929, 1950, 63221, 96.2, 328975, 2099, 3099, 112075, 1951, 63639, 98.1, 346999, 1932, 3594, 113270, 1952, 64989, 99.0, 365385, 1870, 3547, 115094, 1953, 63761, 100.0, 363112, 3578, 3350, 116219, 1954, 66019, 101.2, 397469, 2904, 3048, 117388, 1955, 67857, 104.6, 419180, 2822, 2857, 118734, 1956, 68169, 108.4, 442769, 2936, 2798, 120445, 1957, 66513, 110.8, 444546, 4681, 2637, 121950, 1958, 68655, 112.6, 482704, 3813, 2552, 123366, 1959, 69564, 114.2, 502601, 3931, 2514, 125368, 1960, 69331, 115.7, 518173, 4806, 2572, 127852, 1961, 70551, 116.9, 554894, 4007, 2827, 130081, 1962 }; final int nobs = 16; final int nvars = 6; // Estimate the model MillerUpdatingRegression model = new MillerUpdatingRegression(6, true); int off = 0; double[] tmp = new double[6]; for (int i = 0; i < nobs; i++) { System.arraycopy(design, off + 1, tmp, 0, nvars); model.addObservation(tmp, design[off]); off += nvars + 1; } // Check expected beta values from NIST RegressionResults result = model.regress(); double[] betaHat = result.getParameterEstimates(); TestUtils.assertEquals(betaHat, new double[]{-3482258.63459582, 15.0618722713733, -0.358191792925910E-01, -2.02022980381683, -1.03322686717359, -0.511041056535807E-01, 1829.15146461355}, 1E-8); // // Check standard errors from NIST double[] errors = result.getStdErrorOfEstimates(); TestUtils.assertEquals(new double[]{890420.383607373, 84.9149257747669, 0.334910077722432E-01, 0.488399681651699, 0.214274163161675, 0.226073200069370, 455.478499142212}, errors, 1E-6); // // Check R-Square statistics against R TestUtils.assertEquals(0.995479004577296, result.getRSquared(), 1E-12); TestUtils.assertEquals(0.992465007628826, result.getAdjustedRSquared(), 1E-12); // // // // Estimate model without intercept model = new MillerUpdatingRegression(6, false); off = 0; for (int i = 0; i < nobs; i++) { System.arraycopy(design, off + 1, tmp, 0, nvars); model.addObservation(tmp, design[off]); off += nvars + 1; } // Check expected beta values from R result = model.regress(); betaHat = result.getParameterEstimates(); TestUtils.assertEquals(betaHat, new double[]{-52.99357013868291, 0.07107319907358, -0.42346585566399, -0.57256866841929, -0.41420358884978, 48.41786562001326}, 1E-11); // // Check standard errors from R errors = result.getStdErrorOfEstimates(); TestUtils.assertEquals(new double[]{129.54486693117232, 0.03016640003786, 0.41773654056612, 0.27899087467676, 0.32128496193363, 17.68948737819961}, errors, 1E-11); // // // Check R-Square statistics against R TestUtils.assertEquals(0.9999670130706, result.getRSquared(), 1E-12); TestUtils.assertEquals(0.999947220913, result.getAdjustedRSquared(), 1E-12); } // @Test // public void testRegressReorder() { // // System.out.println("testRegressReorder"); // MillerUpdatingRegression instance = new MillerUpdatingRegression(4, false); // double[][] x = new double[airdata[0].length][]; // double[] y = new double[airdata[0].length]; // for (int i = 0; i < airdata[0].length; i++) { // x[i] = new double[4]; // x[i][0] = 1.0; // x[i][1] = Math.log(airdata[3][i]); // x[i][2] = Math.log(airdata[4][i]); // x[i][3] = airdata[5][i]; // y[i] = Math.log(airdata[2][i]); // } // // instance.addObservations(x, y); // RegressionResults result = instance.regress(); // if (result == null) { // Assert.fail("Null result...."); // } // // instance.reorderRegressors(new int[]{3, 2}, 0); // RegressionResults resultInverse = instance.regress(); // // double[] beta = result.getParameterEstimates(); // double[] betar = resultInverse.getParameterEstimates(); // if (Math.abs(beta[0] - betar[0]) > 1.0e-14) { // Assert.fail("Parameters not correct after reorder (0,3)"); // } // if (Math.abs(beta[1] - betar[1]) > 1.0e-14) { // Assert.fail("Parameters not correct after reorder (1,2)"); // } // if (Math.abs(beta[2] - betar[2]) > 1.0e-14) { // Assert.fail("Parameters not correct after reorder (2,1)"); // } // if (Math.abs(beta[3] - betar[3]) > 1.0e-14) { // Assert.fail("Parameters not correct after reorder (3,0)"); // } // } @Test public void testOneRedundantColumn() { MillerUpdatingRegression instance = new MillerUpdatingRegression(4, false); MillerUpdatingRegression instance2 = new MillerUpdatingRegression(5, false); double[][] x = new double[airdata[0].length][]; double[][] x2 = new double[airdata[0].length][]; double[] y = new double[airdata[0].length]; for (int i = 0; i < airdata[0].length; i++) { x[i] = new double[4]; x2[i] = new double[5]; x[i][0] = 1.0; x[i][1] = Math.log(airdata[3][i]); x[i][2] = Math.log(airdata[4][i]); x[i][3] = airdata[5][i]; x2[i][0] = x[i][0]; x2[i][1] = x[i][1]; x2[i][2] = x[i][2]; x2[i][3] = x[i][3]; x2[i][4] = x[i][3]; y[i] = Math.log(airdata[2][i]); } instance.addObservations(x, y); RegressionResults result = instance.regress(); Assert.assertNotNull("Could not estimate initial regression", result); instance2.addObservations(x2, y); RegressionResults resultRedundant = instance2.regress(); Assert.assertNotNull("Could not estimate redundant regression", resultRedundant); double[] beta = result.getParameterEstimates(); double[] betar = resultRedundant.getParameterEstimates(); double[] se = result.getStdErrorOfEstimates(); double[] ser = resultRedundant.getStdErrorOfEstimates(); for (int i = 0; i < beta.length; i++) { if (Math.abs(beta[i] - betar[i]) > 1.0e-8) { Assert.fail("Parameters not correctly estimated"); } if (Math.abs(se[i] - ser[i]) > 1.0e-8) { Assert.fail("Standard errors not correctly estimated"); } for (int j = 0; j < i; j++) { if (Math.abs(result.getCovarianceOfParameters(i, j) - resultRedundant.getCovarianceOfParameters(i, j)) > 1.0e-8) { Assert.fail("Variance Covariance not correct"); } } } TestUtils.assertEquals(result.getAdjustedRSquared(), resultRedundant.getAdjustedRSquared(), 1.0e-8); TestUtils.assertEquals(result.getErrorSumSquares(), resultRedundant.getErrorSumSquares(), 1.0e-8); TestUtils.assertEquals(result.getMeanSquareError(), resultRedundant.getMeanSquareError(), 1.0e-8); TestUtils.assertEquals(result.getRSquared(), resultRedundant.getRSquared(), 1.0e-8); return; } @Test public void testThreeRedundantColumn() { MillerUpdatingRegression instance = new MillerUpdatingRegression(4, false); MillerUpdatingRegression instance2 = new MillerUpdatingRegression(7, false); double[][] x = new double[airdata[0].length][]; double[][] x2 = new double[airdata[0].length][]; double[] y = new double[airdata[0].length]; for (int i = 0; i < airdata[0].length; i++) { x[i] = new double[4]; x2[i] = new double[7]; x[i][0] = 1.0; x[i][1] = Math.log(airdata[3][i]); x[i][2] = Math.log(airdata[4][i]); x[i][3] = airdata[5][i]; x2[i][0] = x[i][0]; x2[i][1] = x[i][0]; x2[i][2] = x[i][1]; x2[i][3] = x[i][2]; x2[i][4] = x[i][1]; x2[i][5] = x[i][3]; x2[i][6] = x[i][2]; y[i] = Math.log(airdata[2][i]); } instance.addObservations(x, y); RegressionResults result = instance.regress(); Assert.assertNotNull("Could not estimate initial regression", result); instance2.addObservations(x2, y); RegressionResults resultRedundant = instance2.regress(); Assert.assertNotNull("Could not estimate redundant regression", resultRedundant); double[] beta = result.getParameterEstimates(); double[] betar = resultRedundant.getParameterEstimates(); double[] se = result.getStdErrorOfEstimates(); double[] ser = resultRedundant.getStdErrorOfEstimates(); if (Math.abs(beta[0] - betar[0]) > 1.0e-8) { Assert.fail("Parameters not correct after reorder (0,3)"); } if (Math.abs(beta[1] - betar[2]) > 1.0e-8) { Assert.fail("Parameters not correct after reorder (1,2)"); } if (Math.abs(beta[2] - betar[3]) > 1.0e-8) { Assert.fail("Parameters not correct after reorder (2,1)"); } if (Math.abs(beta[3] - betar[5]) > 1.0e-8) { Assert.fail("Parameters not correct after reorder (3,0)"); } if (Math.abs(se[0] - ser[0]) > 1.0e-8) { Assert.fail("Se not correct after reorder (0,3)"); } if (Math.abs(se[1] - ser[2]) > 1.0e-8) { Assert.fail("Se not correct after reorder (1,2)"); } if (Math.abs(se[2] - ser[3]) > 1.0e-8) { Assert.fail("Se not correct after reorder (2,1)"); } if (Math.abs(se[3] - ser[5]) > 1.0e-8) { Assert.fail("Se not correct after reorder (3,0)"); } if (Math.abs(result.getCovarianceOfParameters(0, 0) - resultRedundant.getCovarianceOfParameters(0, 0)) > 1.0e-8) { Assert.fail("VCV not correct after reorder (0,0)"); } if (Math.abs(result.getCovarianceOfParameters(0, 1) - resultRedundant.getCovarianceOfParameters(0, 2)) > 1.0e-8) { Assert.fail("VCV not correct after reorder (0,1)<->(0,2)"); } if (Math.abs(result.getCovarianceOfParameters(0, 2) - resultRedundant.getCovarianceOfParameters(0, 3)) > 1.0e-8) { Assert.fail("VCV not correct after reorder (0,2)<->(0,1)"); } if (Math.abs(result.getCovarianceOfParameters(0, 3) - resultRedundant.getCovarianceOfParameters(0, 5)) > 1.0e-8) { Assert.fail("VCV not correct after reorder (0,3)<->(0,3)"); } if (Math.abs(result.getCovarianceOfParameters(1, 0) - resultRedundant.getCovarianceOfParameters(2, 0)) > 1.0e-8) { Assert.fail("VCV not correct after reorder (1,0)<->(2,0)"); } if (Math.abs(result.getCovarianceOfParameters(1, 1) - resultRedundant.getCovarianceOfParameters(2, 2)) > 1.0e-8) { Assert.fail("VCV not correct (1,1)<->(2,1)"); } if (Math.abs(result.getCovarianceOfParameters(1, 2) - resultRedundant.getCovarianceOfParameters(2, 3)) > 1.0e-8) { Assert.fail("VCV not correct (1,2)<->(2,2)"); } if (Math.abs(result.getCovarianceOfParameters(2, 0) - resultRedundant.getCovarianceOfParameters(3, 0)) > 1.0e-8) { Assert.fail("VCV not correct (2,0)<->(1,0)"); } if (Math.abs(result.getCovarianceOfParameters(2, 1) - resultRedundant.getCovarianceOfParameters(3, 2)) > 1.0e-8) { Assert.fail("VCV not correct (2,1)<->(1,2)"); } if (Math.abs(result.getCovarianceOfParameters(3, 3) - resultRedundant.getCovarianceOfParameters(5, 5)) > 1.0e-8) { Assert.fail("VCV not correct (3,3)<->(3,2)"); } TestUtils.assertEquals(result.getAdjustedRSquared(), resultRedundant.getAdjustedRSquared(), 1.0e-8); TestUtils.assertEquals(result.getErrorSumSquares(), resultRedundant.getErrorSumSquares(), 1.0e-8); TestUtils.assertEquals(result.getMeanSquareError(), resultRedundant.getMeanSquareError(), 1.0e-8); TestUtils.assertEquals(result.getRSquared(), resultRedundant.getRSquared(), 1.0e-8); return; } @Test public void testPCorr() { MillerUpdatingRegression instance = new MillerUpdatingRegression(4, false); double[][] x = new double[airdata[0].length][]; double[] y = new double[airdata[0].length]; double[] cp = new double[10]; double[] yxcorr = new double[4]; double[] diag = new double[4]; double sumysq = 0.0; int off = 0; for (int i = 0; i < airdata[0].length; i++) { x[i] = new double[4]; x[i][0] = 1.0; x[i][1] = Math.log(airdata[3][i]); x[i][2] = Math.log(airdata[4][i]); x[i][3] = airdata[5][i]; y[i] = Math.log(airdata[2][i]); off = 0; for (int j = 0; j < 4; j++) { double tmp = x[i][j]; for (int k = 0; k <= j; k++, off++) { cp[off] += tmp * x[i][k]; } yxcorr[j] += tmp * y[i]; } sumysq += y[i] * y[i]; } PearsonsCorrelation pearson = new PearsonsCorrelation(x); RealMatrix corr = pearson.getCorrelationMatrix(); off = 0; for (int i = 0; i < 4; i++, off += (i + 1)) { diag[i] = FastMath.sqrt(cp[off]); } instance.addObservations(x, y); double[] pc = instance.getPartialCorrelations(0); int idx = 0; off = 0; int off2 = 6; for (int i = 0; i < 4; i++) { for (int j = 0; j < i; j++) { if (Math.abs(pc[idx] - cp[off] / (diag[i] * diag[j])) > 1.0e-8) { Assert.fail("Failed cross products... i = " + i + " j = " + j); } ++idx; ++off; } ++off; if (Math.abs(pc[i+off2] - yxcorr[ i] / (FastMath.sqrt(sumysq) * diag[i])) > 1.0e-8) { Assert.fail("Assert.failed cross product i = " + i + " y"); } } double[] pc2 = instance.getPartialCorrelations(1); idx = 0; for (int i = 1; i < 4; i++) { for (int j = 1; j < i; j++) { if (Math.abs(pc2[idx] - corr.getEntry(j, i)) > 1.0e-8) { Assert.fail("Failed cross products... i = " + i + " j = " + j); } ++idx; } } double[] pc3 = instance.getPartialCorrelations(2); if (pc3 == null) { Assert.fail("Should not be null"); } return; } @Test public void testHdiag() { MillerUpdatingRegression instance = new MillerUpdatingRegression(4, false); double[][] x = new double[airdata[0].length][]; double[] y = new double[airdata[0].length]; for (int i = 0; i < airdata[0].length; i++) { x[i] = new double[4]; x[i][0] = 1.0; x[i][1] = Math.log(airdata[3][i]); x[i][2] = Math.log(airdata[4][i]); x[i][3] = airdata[5][i]; y[i] = Math.log(airdata[2][i]); } instance.addObservations(x, y); OLSMultipleLinearRegression ols = new OLSMultipleLinearRegression(); ols.setNoIntercept(true); ols.newSampleData(y, x); RealMatrix rm = ols.calculateHat(); for (int i = 0; i < x.length; i++) { TestUtils.assertEquals(instance.getDiagonalOfHatMatrix(x[i]), rm.getEntry(i, i), 1.0e-8); } return; } @Test public void testHdiagConstant() { MillerUpdatingRegression instance = new MillerUpdatingRegression(3, true); double[][] x = new double[airdata[0].length][]; double[] y = new double[airdata[0].length]; for (int i = 0; i < airdata[0].length; i++) { x[i] = new double[3]; x[i][0] = Math.log(airdata[3][i]); x[i][1] = Math.log(airdata[4][i]); x[i][2] = airdata[5][i]; y[i] = Math.log(airdata[2][i]); } instance.addObservations(x, y); OLSMultipleLinearRegression ols = new OLSMultipleLinearRegression(); ols.setNoIntercept(false); ols.newSampleData(y, x); RealMatrix rm = ols.calculateHat(); for (int i = 0; i < x.length; i++) { TestUtils.assertEquals(instance.getDiagonalOfHatMatrix(x[i]), rm.getEntry(i, i), 1.0e-8); } return; } @Test public void testSubsetRegression() { MillerUpdatingRegression instance = new MillerUpdatingRegression(3, true); MillerUpdatingRegression redRegression = new MillerUpdatingRegression(2, true); double[][] x = new double[airdata[0].length][]; double[][] xReduced = new double[airdata[0].length][]; double[] y = new double[airdata[0].length]; for (int i = 0; i < airdata[0].length; i++) { x[i] = new double[3]; x[i][0] = Math.log(airdata[3][i]); x[i][1] = Math.log(airdata[4][i]); x[i][2] = airdata[5][i]; xReduced[i] = new double[2]; xReduced[i][0] = Math.log(airdata[3][i]); xReduced[i][1] = Math.log(airdata[4][i]); y[i] = Math.log(airdata[2][i]); } instance.addObservations(x, y); redRegression.addObservations(xReduced, y); RegressionResults resultsInstance = instance.regress( new int[]{0,1,2} ); RegressionResults resultsReduced = redRegression.regress(); TestUtils.assertEquals(resultsInstance.getParameterEstimates(), resultsReduced.getParameterEstimates(), 1.0e-12); TestUtils.assertEquals(resultsInstance.getStdErrorOfEstimates(), resultsReduced.getStdErrorOfEstimates(), 1.0e-12); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.regression; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.linear.DefaultRealMatrixChangingVisitor; import org.apache.commons.math3.linear.MatrixUtils; import org.apache.commons.math3.linear.RealMatrix; import org.apache.commons.math3.linear.Array2DRowRealMatrix; import org.apache.commons.math3.linear.RealVector; import org.apache.commons.math3.stat.StatUtils; import org.junit.Assert; import org.junit.Before; import org.junit.Test; public class OLSMultipleLinearRegressionTest extends MultipleLinearRegressionAbstractTest { private double[] y; private double[][] x; @Before @Override public void setUp(){ y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0}; x = new double[6][]; x[0] = new double[]{0, 0, 0, 0, 0}; x[1] = new double[]{2.0, 0, 0, 0, 0}; x[2] = new double[]{0, 3.0, 0, 0, 0}; x[3] = new double[]{0, 0, 4.0, 0, 0}; x[4] = new double[]{0, 0, 0, 5.0, 0}; x[5] = new double[]{0, 0, 0, 0, 6.0}; super.setUp(); } @Override protected OLSMultipleLinearRegression createRegression() { OLSMultipleLinearRegression regression = new OLSMultipleLinearRegression(); regression.newSampleData(y, x); return regression; } @Override protected int getNumberOfRegressors() { return x[0].length + 1; } @Override protected int getSampleSize() { return y.length; } @Test(expected=IllegalArgumentException.class) public void cannotAddSampleDataWithSizeMismatch() { double[] y = new double[]{1.0, 2.0}; double[][] x = new double[1][]; x[0] = new double[]{1.0, 0}; createRegression().newSampleData(y, x); } @Test public void testPerfectFit() { double[] betaHat = regression.estimateRegressionParameters(); TestUtils.assertEquals(betaHat, new double[]{ 11.0, 1.0 / 2.0, 2.0 / 3.0, 3.0 / 4.0, 4.0 / 5.0, 5.0 / 6.0 }, 1e-14); double[] residuals = regression.estimateResiduals(); TestUtils.assertEquals(residuals, new double[]{0d,0d,0d,0d,0d,0d}, 1e-14); RealMatrix errors = new Array2DRowRealMatrix(regression.estimateRegressionParametersVariance(), false); final double[] s = { 1.0, -1.0 / 2.0, -1.0 / 3.0, -1.0 / 4.0, -1.0 / 5.0, -1.0 / 6.0 }; RealMatrix referenceVariance = new Array2DRowRealMatrix(s.length, s.length); referenceVariance.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() { @Override public double visit(int row, int column, double value) { if (row == 0) { return s[column]; } double x = s[row] * s[column]; return (row == column) ? 2 * x : x; } }); Assert.assertEquals(0.0, errors.subtract(referenceVariance).getNorm(), 5.0e-16 * referenceVariance.getNorm()); Assert.assertEquals(1, ((OLSMultipleLinearRegression) regression).calculateRSquared(), 1E-12); } /** * Test Longley dataset against certified values provided by NIST. * Data Source: J. Longley (1967) "An Appraisal of Least Squares * Programs for the Electronic Computer from the Point of View of the User" * Journal of the American Statistical Association, vol. 62. September, * pp. 819-841. * * Certified values (and data) are from NIST: * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat */ @Test public void testLongly() { // Y values are first, then independent vars // Each row is one observation double[] design = new double[] { 60323,83.0,234289,2356,1590,107608,1947, 61122,88.5,259426,2325,1456,108632,1948, 60171,88.2,258054,3682,1616,109773,1949, 61187,89.5,284599,3351,1650,110929,1950, 63221,96.2,328975,2099,3099,112075,1951, 63639,98.1,346999,1932,3594,113270,1952, 64989,99.0,365385,1870,3547,115094,1953, 63761,100.0,363112,3578,3350,116219,1954, 66019,101.2,397469,2904,3048,117388,1955, 67857,104.6,419180,2822,2857,118734,1956, 68169,108.4,442769,2936,2798,120445,1957, 66513,110.8,444546,4681,2637,121950,1958, 68655,112.6,482704,3813,2552,123366,1959, 69564,114.2,502601,3931,2514,125368,1960, 69331,115.7,518173,4806,2572,127852,1961, 70551,116.9,554894,4007,2827,130081,1962 }; final int nobs = 16; final int nvars = 6; // Estimate the model OLSMultipleLinearRegression model = new OLSMultipleLinearRegression(); model.newSampleData(design, nobs, nvars); // Check expected beta values from NIST double[] betaHat = model.estimateRegressionParameters(); TestUtils.assertEquals(betaHat, new double[]{-3482258.63459582, 15.0618722713733, -0.358191792925910E-01,-2.02022980381683, -1.03322686717359,-0.511041056535807E-01, 1829.15146461355}, 2E-8); // // Check expected residuals from R double[] residuals = model.estimateResiduals(); TestUtils.assertEquals(residuals, new double[]{ 267.340029759711,-94.0139423988359,46.28716775752924, -410.114621930906,309.7145907602313,-249.3112153297231, -164.0489563956039,-13.18035686637081,14.30477260005235, 455.394094551857,-17.26892711483297,-39.0550425226967, -155.5499735953195,-85.6713080421283,341.9315139607727, -206.7578251937366}, 1E-8); // Check standard errors from NIST double[] errors = model.estimateRegressionParametersStandardErrors(); TestUtils.assertEquals(new double[] {890420.383607373, 84.9149257747669, 0.334910077722432E-01, 0.488399681651699, 0.214274163161675, 0.226073200069370, 455.478499142212}, errors, 1E-6); // Check regression standard error against R Assert.assertEquals(304.8540735619638, model.estimateRegressionStandardError(), 1E-10); // Check R-Square statistics against R Assert.assertEquals(0.995479004577296, model.calculateRSquared(), 1E-12); Assert.assertEquals(0.992465007628826, model.calculateAdjustedRSquared(), 1E-12); checkVarianceConsistency(model); // Estimate model without intercept model.setNoIntercept(true); model.newSampleData(design, nobs, nvars); // Check expected beta values from R betaHat = model.estimateRegressionParameters(); TestUtils.assertEquals(betaHat, new double[]{-52.99357013868291, 0.07107319907358, -0.42346585566399,-0.57256866841929, -0.41420358884978, 48.41786562001326}, 1E-11); // Check standard errors from R errors = model.estimateRegressionParametersStandardErrors(); TestUtils.assertEquals(new double[] {129.54486693117232, 0.03016640003786, 0.41773654056612, 0.27899087467676, 0.32128496193363, 17.68948737819961}, errors, 1E-11); // Check expected residuals from R residuals = model.estimateResiduals(); TestUtils.assertEquals(residuals, new double[]{ 279.90274927293092, -130.32465380836874, 90.73228661967445, -401.31252201634948, -440.46768772620027, -543.54512853774793, 201.32111639536299, 215.90889365977932, 73.09368242049943, 913.21694494481869, 424.82484953610174, -8.56475876776709, -361.32974610842876, 27.34560497213464, 151.28955976355002, -492.49937355336846}, 1E-10); // Check regression standard error against R Assert.assertEquals(475.1655079819517, model.estimateRegressionStandardError(), 1E-10); // Check R-Square statistics against R Assert.assertEquals(0.9999670130706, model.calculateRSquared(), 1E-12); Assert.assertEquals(0.999947220913, model.calculateAdjustedRSquared(), 1E-12); } /** * Test R Swiss fertility dataset against R. * Data Source: R datasets package */ @Test public void testSwissFertility() { double[] design = new double[] { 80.2,17.0,15,12,9.96, 83.1,45.1,6,9,84.84, 92.5,39.7,5,5,93.40, 85.8,36.5,12,7,33.77, 76.9,43.5,17,15,5.16, 76.1,35.3,9,7,90.57, 83.8,70.2,16,7,92.85, 92.4,67.8,14,8,97.16, 82.4,53.3,12,7,97.67, 82.9,45.2,16,13,91.38, 87.1,64.5,14,6,98.61, 64.1,62.0,21,12,8.52, 66.9,67.5,14,7,2.27, 68.9,60.7,19,12,4.43, 61.7,69.3,22,5,2.82, 68.3,72.6,18,2,24.20, 71.7,34.0,17,8,3.30, 55.7,19.4,26,28,12.11, 54.3,15.2,31,20,2.15, 65.1,73.0,19,9,2.84, 65.5,59.8,22,10,5.23, 65.0,55.1,14,3,4.52, 56.6,50.9,22,12,15.14, 57.4,54.1,20,6,4.20, 72.5,71.2,12,1,2.40, 74.2,58.1,14,8,5.23, 72.0,63.5,6,3,2.56, 60.5,60.8,16,10,7.72, 58.3,26.8,25,19,18.46, 65.4,49.5,15,8,6.10, 75.5,85.9,3,2,99.71, 69.3,84.9,7,6,99.68, 77.3,89.7,5,2,100.00, 70.5,78.2,12,6,98.96, 79.4,64.9,7,3,98.22, 65.0,75.9,9,9,99.06, 92.2,84.6,3,3,99.46, 79.3,63.1,13,13,96.83, 70.4,38.4,26,12,5.62, 65.7,7.7,29,11,13.79, 72.7,16.7,22,13,11.22, 64.4,17.6,35,32,16.92, 77.6,37.6,15,7,4.97, 67.6,18.7,25,7,8.65, 35.0,1.2,37,53,42.34, 44.7,46.6,16,29,50.43, 42.8,27.7,22,29,58.33 }; final int nobs = 47; final int nvars = 4; // Estimate the model OLSMultipleLinearRegression model = new OLSMultipleLinearRegression(); model.newSampleData(design, nobs, nvars); // Check expected beta values from R double[] betaHat = model.estimateRegressionParameters(); TestUtils.assertEquals(betaHat, new double[]{91.05542390271397, -0.22064551045715, -0.26058239824328, -0.96161238456030, 0.12441843147162}, 1E-12); // Check expected residuals from R double[] residuals = model.estimateResiduals(); TestUtils.assertEquals(residuals, new double[]{ 7.1044267859730512,1.6580347433531366, 4.6944952770029644,8.4548022690166160,13.6547432343186212, -9.3586864458500774,7.5822446330520386,15.5568995563859289, 0.8113090736598980,7.1186762732484308,7.4251378771228724, 2.6761316873234109,0.8351584810309354,7.1769991119615177, -3.8746753206299553,-3.1337779476387251,-0.1412575244091504, 1.1186809170469780,-6.3588097346816594,3.4039270429434074, 2.3374058329820175,-7.9272368576900503,-7.8361010968497959, -11.2597369269357070,0.9445333697827101,6.6544245101380328, -0.9146136301118665,-4.3152449403848570,-4.3536932047009183, -3.8907885169304661,-6.3027643926302188,-7.8308982189289091, -3.1792280015332750,-6.7167298771158226,-4.8469946718041754, -10.6335664353633685,11.1031134362036958,6.0084032641811733, 5.4326230830188482,-7.2375578629692230,2.1671550814448222, 15.0147574652763112,4.8625103516321015,-7.1597256413907706, -0.4515205619767598,-10.2916870903837587,-15.7812984571900063}, 1E-12); // Check standard errors from R double[] errors = model.estimateRegressionParametersStandardErrors(); TestUtils.assertEquals(new double[] {6.94881329475087, 0.07360008972340, 0.27410957467466, 0.19454551679325, 0.03726654773803}, errors, 1E-10); // Check regression standard error against R Assert.assertEquals(7.73642194433223, model.estimateRegressionStandardError(), 1E-12); // Check R-Square statistics against R Assert.assertEquals(0.649789742860228, model.calculateRSquared(), 1E-12); Assert.assertEquals(0.6164363850373927, model.calculateAdjustedRSquared(), 1E-12); checkVarianceConsistency(model); // Estimate the model with no intercept model = new OLSMultipleLinearRegression(); model.setNoIntercept(true); model.newSampleData(design, nobs, nvars); // Check expected beta values from R betaHat = model.estimateRegressionParameters(); TestUtils.assertEquals(betaHat, new double[]{0.52191832900513, 2.36588087917963, -0.94770353802795, 0.30851985863609}, 1E-12); // Check expected residuals from R residuals = model.estimateResiduals(); TestUtils.assertEquals(residuals, new double[]{ 44.138759883538249, 27.720705122356215, 35.873200836126799, 34.574619581211977, 26.600168342080213, 15.074636243026923, -12.704904871199814, 1.497443824078134, 2.691972687079431, 5.582798774291231, -4.422986561283165, -9.198581600334345, 4.481765170730647, 2.273520207553216, -22.649827853221336, -17.747900013943308, 20.298314638496436, 6.861405135329779, -8.684712790954924, -10.298639278062371, -9.896618896845819, 4.568568616351242, -15.313570491727944, -13.762961360873966, 7.156100301980509, 16.722282219843990, 26.716200609071898, -1.991466398777079, -2.523342564719335, 9.776486693095093, -5.297535127628603, -16.639070567471094, -10.302057295211819, -23.549487860816846, 1.506624392156384, -17.939174438345930, 13.105792202765040, -1.943329906928462, -1.516005841666695, -0.759066561832886, 20.793137744128977, -2.485236153005426, 27.588238710486976, 2.658333257106881, -15.998337823623046, -5.550742066720694, -14.219077806826615}, 1E-12); // Check standard errors from R errors = model.estimateRegressionParametersStandardErrors(); TestUtils.assertEquals(new double[] {0.10470063765677, 0.41684100584290, 0.43370143099691, 0.07694953606522}, errors, 1E-10); // Check regression standard error against R Assert.assertEquals(17.24710630547, model.estimateRegressionStandardError(), 1E-10); // Check R-Square statistics against R Assert.assertEquals(0.946350722085, model.calculateRSquared(), 1E-12); Assert.assertEquals(0.9413600915813, model.calculateAdjustedRSquared(), 1E-12); } /** * Test hat matrix computation * */ @Test public void testHat() { /* * This example is from "The Hat Matrix in Regression and ANOVA", * David C. Hoaglin and Roy E. Welsch, * The American Statistician, Vol. 32, No. 1 (Feb., 1978), pp. 17-22. * */ double[] design = new double[] { 11.14, .499, 11.1, 12.74, .558, 8.9, 13.13, .604, 8.8, 11.51, .441, 8.9, 12.38, .550, 8.8, 12.60, .528, 9.9, 11.13, .418, 10.7, 11.7, .480, 10.5, 11.02, .406, 10.5, 11.41, .467, 10.7 }; int nobs = 10; int nvars = 2; // Estimate the model OLSMultipleLinearRegression model = new OLSMultipleLinearRegression(); model.newSampleData(design, nobs, nvars); RealMatrix hat = model.calculateHat(); // Reference data is upper half of symmetric hat matrix double[] referenceData = new double[] { .418, -.002, .079, -.274, -.046, .181, .128, .222, .050, .242, .242, .292, .136, .243, .128, -.041, .033, -.035, .004, .417, -.019, .273, .187, -.126, .044, -.153, .004, .604, .197, -.038, .168, -.022, .275, -.028, .252, .111, -.030, .019, -.010, -.010, .148, .042, .117, .012, .111, .262, .145, .277, .174, .154, .120, .168, .315, .148, .187 }; // Check against reference data and verify symmetry int k = 0; for (int i = 0; i < 10; i++) { for (int j = i; j < 10; j++) { Assert.assertEquals(referenceData[k], hat.getEntry(i, j), 10e-3); Assert.assertEquals(hat.getEntry(i, j), hat.getEntry(j, i), 10e-12); k++; } } /* * Verify that residuals computed using the hat matrix are close to * what we get from direct computation, i.e. r = (I - H) y */ double[] residuals = model.estimateResiduals(); RealMatrix I = MatrixUtils.createRealIdentityMatrix(10); double[] hatResiduals = I.subtract(hat).operate(model.getY()).toArray(); TestUtils.assertEquals(residuals, hatResiduals, 10e-12); } /** * test calculateYVariance */ @Test public void testYVariance() { // assumes: y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0}; OLSMultipleLinearRegression model = new OLSMultipleLinearRegression(); model.newSampleData(y, x); TestUtils.assertEquals(model.calculateYVariance(), 3.5, 0); } /** * Verifies that calculateYVariance and calculateResidualVariance return consistent * values with direct variance computation from Y, residuals, respectively. */ protected void checkVarianceConsistency(OLSMultipleLinearRegression model) { // Check Y variance consistency TestUtils.assertEquals(StatUtils.variance(model.getY().toArray()), model.calculateYVariance(), 0); // Check residual variance consistency double[] residuals = model.calculateResiduals().toArray(); RealMatrix X = model.getX(); TestUtils.assertEquals( StatUtils.variance(model.calculateResiduals().toArray()) * (residuals.length - 1), model.calculateErrorVariance() * (X.getRowDimension() - X.getColumnDimension()), 1E-20); } /** * Verifies that setting X and Y separately has the same effect as newSample(X,Y). */ @Test public void testNewSample2() { double[] y = new double[] {1, 2, 3, 4}; double[][] x = new double[][] { {19, 22, 33}, {20, 30, 40}, {25, 35, 45}, {27, 37, 47} }; OLSMultipleLinearRegression regression = new OLSMultipleLinearRegression(); regression.newSampleData(y, x); RealMatrix combinedX = regression.getX().copy(); RealVector combinedY = regression.getY().copy(); regression.newXSampleData(x); regression.newYSampleData(y); Assert.assertEquals(combinedX, regression.getX()); Assert.assertEquals(combinedY, regression.getY()); // No intercept regression.setNoIntercept(true); regression.newSampleData(y, x); combinedX = regression.getX().copy(); combinedY = regression.getY().copy(); regression.newXSampleData(x); regression.newYSampleData(y); Assert.assertEquals(combinedX, regression.getX()); Assert.assertEquals(combinedY, regression.getY()); } @Test(expected=IllegalArgumentException.class) public void testNewSampleDataYNull() { createRegression().newSampleData(null, new double[][] {}); } @Test(expected=IllegalArgumentException.class) public void testNewSampleDataXNull() { createRegression().newSampleData(new double[] {}, null); } /* * This is a test based on the Wampler1 data set * http://www.itl.nist.gov/div898/strd/lls/data/Wampler1.shtml */ @Test public void testWampler1() { double[] data = new double[]{ 1, 0, 6, 1, 63, 2, 364, 3, 1365, 4, 3906, 5, 9331, 6, 19608, 7, 37449, 8, 66430, 9, 111111, 10, 177156, 11, 271453, 12, 402234, 13, 579195, 14, 813616, 15, 1118481, 16, 1508598, 17, 2000719, 18, 2613660, 19, 3368421, 20}; OLSMultipleLinearRegression model = new OLSMultipleLinearRegression(); final int nvars = 5; final int nobs = 21; double[] tmp = new double[(nvars + 1) * nobs]; int off = 0; int off2 = 0; for (int i = 0; i < nobs; i++) { tmp[off2] = data[off]; tmp[off2 + 1] = data[off + 1]; tmp[off2 + 2] = tmp[off2 + 1] * tmp[off2 + 1]; tmp[off2 + 3] = tmp[off2 + 1] * tmp[off2 + 2]; tmp[off2 + 4] = tmp[off2 + 1] * tmp[off2 + 3]; tmp[off2 + 5] = tmp[off2 + 1] * tmp[off2 + 4]; off2 += (nvars + 1); off += 2; } model.newSampleData(tmp, nobs, nvars); double[] betaHat = model.estimateRegressionParameters(); TestUtils.assertEquals(betaHat, new double[]{1.0, 1.0, 1.0, 1.0, 1.0, 1.0}, 1E-8); double[] se = model.estimateRegressionParametersStandardErrors(); TestUtils.assertEquals(se, new double[]{0.0, 0.0, 0.0, 0.0, 0.0, 0.0}, 1E-8); TestUtils.assertEquals(1.0, model.calculateRSquared(), 1.0e-10); TestUtils.assertEquals(0, model.estimateErrorVariance(), 1.0e-7); TestUtils.assertEquals(0.00, model.calculateResidualSumOfSquares(), 1.0e-6); return; } /* * This is a test based on the Wampler2 data set * http://www.itl.nist.gov/div898/strd/lls/data/Wampler2.shtml */ @Test public void testWampler2() { double[] data = new double[]{ 1.00000, 0, 1.11111, 1, 1.24992, 2, 1.42753, 3, 1.65984, 4, 1.96875, 5, 2.38336, 6, 2.94117, 7, 3.68928, 8, 4.68559, 9, 6.00000, 10, 7.71561, 11, 9.92992, 12, 12.75603, 13, 16.32384, 14, 20.78125, 15, 26.29536, 16, 33.05367, 17, 41.26528, 18, 51.16209, 19, 63.00000, 20}; OLSMultipleLinearRegression model = new OLSMultipleLinearRegression(); final int nvars = 5; final int nobs = 21; double[] tmp = new double[(nvars + 1) * nobs]; int off = 0; int off2 = 0; for (int i = 0; i < nobs; i++) { tmp[off2] = data[off]; tmp[off2 + 1] = data[off + 1]; tmp[off2 + 2] = tmp[off2 + 1] * tmp[off2 + 1]; tmp[off2 + 3] = tmp[off2 + 1] * tmp[off2 + 2]; tmp[off2 + 4] = tmp[off2 + 1] * tmp[off2 + 3]; tmp[off2 + 5] = tmp[off2 + 1] * tmp[off2 + 4]; off2 += (nvars + 1); off += 2; } model.newSampleData(tmp, nobs, nvars); double[] betaHat = model.estimateRegressionParameters(); TestUtils.assertEquals(betaHat, new double[]{ 1.0, 1.0e-1, 1.0e-2, 1.0e-3, 1.0e-4, 1.0e-5}, 1E-8); double[] se = model.estimateRegressionParametersStandardErrors(); TestUtils.assertEquals(se, new double[]{0.0, 0.0, 0.0, 0.0, 0.0, 0.0}, 1E-8); TestUtils.assertEquals(1.0, model.calculateRSquared(), 1.0e-10); TestUtils.assertEquals(0, model.estimateErrorVariance(), 1.0e-7); TestUtils.assertEquals(0.00, model.calculateResidualSumOfSquares(), 1.0e-6); return; } /* * This is a test based on the Wampler3 data set * http://www.itl.nist.gov/div898/strd/lls/data/Wampler3.shtml */ @Test public void testWampler3() { double[] data = new double[]{ 760, 0, -2042, 1, 2111, 2, -1684, 3, 3888, 4, 1858, 5, 11379, 6, 17560, 7, 39287, 8, 64382, 9, 113159, 10, 175108, 11, 273291, 12, 400186, 13, 581243, 14, 811568, 15, 1121004, 16, 1506550, 17, 2002767, 18, 2611612, 19, 3369180, 20}; OLSMultipleLinearRegression model = new OLSMultipleLinearRegression(); final int nvars = 5; final int nobs = 21; double[] tmp = new double[(nvars + 1) * nobs]; int off = 0; int off2 = 0; for (int i = 0; i < nobs; i++) { tmp[off2] = data[off]; tmp[off2 + 1] = data[off + 1]; tmp[off2 + 2] = tmp[off2 + 1] * tmp[off2 + 1]; tmp[off2 + 3] = tmp[off2 + 1] * tmp[off2 + 2]; tmp[off2 + 4] = tmp[off2 + 1] * tmp[off2 + 3]; tmp[off2 + 5] = tmp[off2 + 1] * tmp[off2 + 4]; off2 += (nvars + 1); off += 2; } model.newSampleData(tmp, nobs, nvars); double[] betaHat = model.estimateRegressionParameters(); TestUtils.assertEquals(betaHat, new double[]{ 1.0, 1.0, 1.0, 1.0, 1.0, 1.0}, 1E-8); double[] se = model.estimateRegressionParametersStandardErrors(); TestUtils.assertEquals(se, new double[]{2152.32624678170, 2363.55173469681, 779.343524331583, 101.475507550350, 5.64566512170752, 0.112324854679312}, 1E-8); // TestUtils.assertEquals(.999995559025820, model.calculateRSquared(), 1.0e-10); TestUtils.assertEquals(5570284.53333333, model.estimateErrorVariance(), 1.0e-6); TestUtils.assertEquals(83554268.0000000, model.calculateResidualSumOfSquares(), 1.0e-5); return; } /* * This is a test based on the Wampler4 data set * http://www.itl.nist.gov/div898/strd/lls/data/Wampler4.shtml */ @Test public void testWampler4() { double[] data = new double[]{ 75901, 0, -204794, 1, 204863, 2, -204436, 3, 253665, 4, -200894, 5, 214131, 6, -185192, 7, 221249, 8, -138370, 9, 315911, 10, -27644, 11, 455253, 12, 197434, 13, 783995, 14, 608816, 15, 1370781, 16, 1303798, 17, 2205519, 18, 2408860, 19, 3444321, 20}; OLSMultipleLinearRegression model = new OLSMultipleLinearRegression(); final int nvars = 5; final int nobs = 21; double[] tmp = new double[(nvars + 1) * nobs]; int off = 0; int off2 = 0; for (int i = 0; i < nobs; i++) { tmp[off2] = data[off]; tmp[off2 + 1] = data[off + 1]; tmp[off2 + 2] = tmp[off2 + 1] * tmp[off2 + 1]; tmp[off2 + 3] = tmp[off2 + 1] * tmp[off2 + 2]; tmp[off2 + 4] = tmp[off2 + 1] * tmp[off2 + 3]; tmp[off2 + 5] = tmp[off2 + 1] * tmp[off2 + 4]; off2 += (nvars + 1); off += 2; } model.newSampleData(tmp, nobs, nvars); double[] betaHat = model.estimateRegressionParameters(); TestUtils.assertEquals(betaHat, new double[]{ 1.0, 1.0, 1.0, 1.0, 1.0, 1.0}, 1E-6); double[] se = model.estimateRegressionParametersStandardErrors(); TestUtils.assertEquals(se, new double[]{215232.624678170, 236355.173469681, 77934.3524331583, 10147.5507550350, 564.566512170752, 11.2324854679312}, 1E-8); TestUtils.assertEquals(.957478440825662, model.calculateRSquared(), 1.0e-10); TestUtils.assertEquals(55702845333.3333, model.estimateErrorVariance(), 1.0e-4); TestUtils.assertEquals(835542680000.000, model.calculateResidualSumOfSquares(), 1.0e-3); return; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.stat.regression; import java.util.Random; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.exception.OutOfRangeException; import org.apache.commons.math3.random.ISAACRandom; import org.junit.Assert; import org.junit.Test; /** * Test cases for the TestStatistic class. * * @version $Id$ */ public final class SimpleRegressionTest { /* * NIST "Norris" refernce data set from * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Norris.dat * Strangely, order is {y,x} */ private double[][] data = { { 0.1, 0.2 }, {338.8, 337.4 }, {118.1, 118.2 }, {888.0, 884.6 }, {9.2, 10.1 }, {228.1, 226.5 }, {668.5, 666.3 }, {998.5, 996.3 }, {449.1, 448.6 }, {778.9, 777.0 }, {559.2, 558.2 }, {0.3, 0.4 }, {0.1, 0.6 }, {778.1, 775.5 }, {668.8, 666.9 }, {339.3, 338.0 }, {448.9, 447.5 }, {10.8, 11.6 }, {557.7, 556.0 }, {228.3, 228.1 }, {998.0, 995.8 }, {888.8, 887.6 }, {119.6, 120.2 }, {0.3, 0.3 }, {0.6, 0.3 }, {557.6, 556.8 }, {339.3, 339.1 }, {888.0, 887.2 }, {998.5, 999.0 }, {778.9, 779.0 }, {10.2, 11.1 }, {117.6, 118.3 }, {228.9, 229.2 }, {668.4, 669.1 }, {449.2, 448.9 }, {0.2, 0.5 } }; /* * Correlation example from * http://www.xycoon.com/correlation.htm */ private double[][] corrData = { { 101.0, 99.2 }, {100.1, 99.0 }, {100.0, 100.0 }, {90.6, 111.6 }, {86.5, 122.2 }, {89.7, 117.6 }, {90.6, 121.1 }, {82.8, 136.0 }, {70.1, 154.2 }, {65.4, 153.6 }, {61.3, 158.5 }, {62.5, 140.6 }, {63.6, 136.2 }, {52.6, 168.0 }, {59.7, 154.3 }, {59.5, 149.0 }, {61.3, 165.5 } }; /* * From Moore and Mcabe, "Introduction to the Practice of Statistics" * Example 10.3 */ private double[][] infData = { { 15.6, 5.2 }, {26.8, 6.1 }, {37.8, 8.7 }, {36.4, 8.5 }, {35.5, 8.8 }, {18.6, 4.9 }, {15.3, 4.5 }, {7.9, 2.5 }, {0.0, 1.1 } }; /* * Points to remove in the remove tests */ private double[][] removeSingle = {infData[1]}; private double[][] removeMultiple = { infData[1], infData[2] }; private double removeX = infData[0][0]; private double removeY = infData[0][1]; /* * Data with bad linear fit */ private double[][] infData2 = { { 1, 1 }, {2, 0 }, {3, 5 }, {4, 2 }, {5, -1 }, {6, 12 } }; /* * Data from NIST NOINT1 */ private double[][] noint1 = { {130.0,60.0}, {131.0,61.0}, {132.0,62.0}, {133.0,63.0}, {134.0,64.0}, {135.0,65.0}, {136.0,66.0}, {137.0,67.0}, {138.0,68.0}, {139.0,69.0}, {140.0,70.0} }; /* * Data from NIST NOINT2 * */ private double[][] noint2 = { {3.0,4}, {4,5}, {4,6} }; /** * Test that the SimpleRegression objects generated from combining two * SimpleRegression objects created from subsets of data are identical to * SimpleRegression objects created from the combined data. */ @Test public void testAppend() { check(false); check(true); } /** * Checks that adding data to a single model gives the same result * as adding "parts" of the dataset to smaller models and using append * to aggregate the smaller models. * * @param includeIntercept */ private void check(boolean includeIntercept) { final int sets = 2; final ISAACRandom rand = new ISAACRandom(10L);// Seed can be changed final SimpleRegression whole = new SimpleRegression(includeIntercept);// regression of the whole set final SimpleRegression parts = new SimpleRegression(includeIntercept);// regression with parts. for (int s = 0; s < sets; s++) {// loop through each subset of data. final double coef = rand.nextDouble(); final SimpleRegression sub = new SimpleRegression(includeIntercept);// sub regression for (int i = 0; i < 5; i++) { // loop through individual samlpes. final double x = rand.nextDouble(); final double y = x * coef + rand.nextDouble();// some noise sub.addData(x, y); whole.addData(x, y); } parts.append(sub); Assert.assertTrue(equals(parts, whole, 1E-6)); } } /** * Returns true iff the statistics reported by model1 are all within tol of * those reported by model2. * * @param model1 first model * @param model2 second model * @param tol tolerance * @return true if the two models report the same regression stats */ private boolean equals(SimpleRegression model1, SimpleRegression model2, double tol) { if (model1.getN() != model2.getN()) { return false; } if (Math.abs(model1.getIntercept() - model2.getIntercept()) > tol) { return false; } if (Math.abs(model1.getInterceptStdErr() - model2.getInterceptStdErr()) > tol) { return false; } if (Math.abs(model1.getMeanSquareError() - model2.getMeanSquareError()) > tol) { return false; } if (Math.abs(model1.getR() - model2.getR()) > tol) { return false; } if (Math.abs(model1.getRegressionSumSquares() - model2.getRegressionSumSquares()) > tol) { return false; } if (Math.abs(model1.getRSquare() - model2.getRSquare()) > tol) { return false; } if (Math.abs(model1.getSignificance() - model2.getSignificance()) > tol) { return false; } if (Math.abs(model1.getSlope() - model2.getSlope()) > tol) { return false; } if (Math.abs(model1.getSlopeConfidenceInterval() - model2.getSlopeConfidenceInterval()) > tol) { return false; } if (Math.abs(model1.getSlopeStdErr() - model2.getSlopeStdErr()) > tol) { return false; } if (Math.abs(model1.getSumOfCrossProducts() - model2.getSumOfCrossProducts()) > tol) { return false; } if (Math.abs(model1.getSumSquaredErrors() - model2.getSumSquaredErrors()) > tol) { return false; } if (Math.abs(model1.getTotalSumSquares() - model2.getTotalSumSquares()) > tol) { return false; } if (Math.abs(model1.getXSumSquares() - model2.getXSumSquares()) > tol) { return false; } return true; } @Test public void testRegressIfaceMethod(){ final SimpleRegression regression = new SimpleRegression(true); final UpdatingMultipleLinearRegression iface = regression; final SimpleRegression regressionNoint = new SimpleRegression( false ); final SimpleRegression regressionIntOnly= new SimpleRegression( false ); for (int i = 0; i < data.length; i++) { iface.addObservation( new double[]{data[i][1]}, data[i][0]); regressionNoint.addData(data[i][1], data[i][0]); regressionIntOnly.addData(1.0, data[i][0]); } //should not be null final RegressionResults fullReg = iface.regress( ); Assert.assertNotNull(fullReg); Assert.assertEquals("intercept", regression.getIntercept(), fullReg.getParameterEstimate(0), 1.0e-16); Assert.assertEquals("intercept std err",regression.getInterceptStdErr(), fullReg.getStdErrorOfEstimate(0),1.0E-16); Assert.assertEquals("slope", regression.getSlope(), fullReg.getParameterEstimate(1), 1.0e-16); Assert.assertEquals("slope std err",regression.getSlopeStdErr(), fullReg.getStdErrorOfEstimate(1),1.0E-16); Assert.assertEquals("number of observations",regression.getN(), fullReg.getN()); Assert.assertEquals("r-square",regression.getRSquare(), fullReg.getRSquared(), 1.0E-16); Assert.assertEquals("SSR", regression.getRegressionSumSquares(), fullReg.getRegressionSumSquares() ,1.0E-16); Assert.assertEquals("MSE", regression.getMeanSquareError(), fullReg.getMeanSquareError() ,1.0E-16); Assert.assertEquals("SSE", regression.getSumSquaredErrors(), fullReg.getErrorSumSquares() ,1.0E-16); final RegressionResults noInt = iface.regress( new int[]{1} ); Assert.assertNotNull(noInt); Assert.assertEquals("slope", regressionNoint.getSlope(), noInt.getParameterEstimate(0), 1.0e-12); Assert.assertEquals("slope std err",regressionNoint.getSlopeStdErr(), noInt.getStdErrorOfEstimate(0),1.0E-16); Assert.assertEquals("number of observations",regressionNoint.getN(), noInt.getN()); Assert.assertEquals("r-square",regressionNoint.getRSquare(), noInt.getRSquared(), 1.0E-16); Assert.assertEquals("SSR", regressionNoint.getRegressionSumSquares(), noInt.getRegressionSumSquares() ,1.0E-8); Assert.assertEquals("MSE", regressionNoint.getMeanSquareError(), noInt.getMeanSquareError() ,1.0E-16); Assert.assertEquals("SSE", regressionNoint.getSumSquaredErrors(), noInt.getErrorSumSquares() ,1.0E-16); final RegressionResults onlyInt = iface.regress( new int[]{0} ); Assert.assertNotNull(onlyInt); Assert.assertEquals("slope", regressionIntOnly.getSlope(), onlyInt.getParameterEstimate(0), 1.0e-12); Assert.assertEquals("slope std err",regressionIntOnly.getSlopeStdErr(), onlyInt.getStdErrorOfEstimate(0),1.0E-12); Assert.assertEquals("number of observations",regressionIntOnly.getN(), onlyInt.getN()); Assert.assertEquals("r-square",regressionIntOnly.getRSquare(), onlyInt.getRSquared(), 1.0E-14); Assert.assertEquals("SSE", regressionIntOnly.getSumSquaredErrors(), onlyInt.getErrorSumSquares() ,1.0E-8); Assert.assertEquals("SSR", regressionIntOnly.getRegressionSumSquares(), onlyInt.getRegressionSumSquares() ,1.0E-8); Assert.assertEquals("MSE", regressionIntOnly.getMeanSquareError(), onlyInt.getMeanSquareError() ,1.0E-8); } /** * Verify that regress generates exceptions as advertised for bad model specifications. */ @Test public void testRegressExceptions() { // No intercept final SimpleRegression noIntRegression = new SimpleRegression(false); noIntRegression.addData(noint2[0][1], noint2[0][0]); noIntRegression.addData(noint2[1][1], noint2[1][0]); noIntRegression.addData(noint2[2][1], noint2[2][0]); try { // null array noIntRegression.regress(null); Assert.fail("Expecting MathIllegalArgumentException for null array"); } catch (MathIllegalArgumentException ex) { // Expected } try { // empty array noIntRegression.regress(new int[] {}); Assert.fail("Expecting MathIllegalArgumentException for empty array"); } catch (MathIllegalArgumentException ex) { // Expected } try { // more than 1 regressor noIntRegression.regress(new int[] {0, 1}); Assert.fail("Expecting ModelSpecificationException - too many regressors"); } catch (ModelSpecificationException ex) { // Expected } try { // invalid regressor noIntRegression.regress(new int[] {1}); Assert.fail("Expecting OutOfRangeException - invalid regression"); } catch (OutOfRangeException ex) { // Expected } // With intercept final SimpleRegression regression = new SimpleRegression(true); regression.addData(noint2[0][1], noint2[0][0]); regression.addData(noint2[1][1], noint2[1][0]); regression.addData(noint2[2][1], noint2[2][0]); try { // null array regression.regress(null); Assert.fail("Expecting MathIllegalArgumentException for null array"); } catch (MathIllegalArgumentException ex) { // Expected } try { // empty array regression.regress(new int[] {}); Assert.fail("Expecting MathIllegalArgumentException for empty array"); } catch (MathIllegalArgumentException ex) { // Expected } try { // more than 2 regressors regression.regress(new int[] {0, 1, 2}); Assert.fail("Expecting ModelSpecificationException - too many regressors"); } catch (ModelSpecificationException ex) { // Expected } try { // wrong order regression.regress(new int[] {1,0}); Assert.fail("Expecting ModelSpecificationException - invalid regression"); } catch (ModelSpecificationException ex) { // Expected } try { // out of range regression.regress(new int[] {3,4}); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // Expected } try { // out of range regression.regress(new int[] {0,2}); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // Expected } try { // out of range regression.regress(new int[] {2}); Assert.fail("Expecting OutOfRangeException"); } catch (OutOfRangeException ex) { // Expected } } @Test public void testNoInterceot_noint2(){ SimpleRegression regression = new SimpleRegression(false); regression.addData(noint2[0][1], noint2[0][0]); regression.addData(noint2[1][1], noint2[1][0]); regression.addData(noint2[2][1], noint2[2][0]); Assert.assertEquals("intercept", 0, regression.getIntercept(), 0); Assert.assertEquals("slope", 0.727272727272727, regression.getSlope(), 10E-12); Assert.assertEquals("slope std err", 0.420827318078432E-01, regression.getSlopeStdErr(),10E-12); Assert.assertEquals("number of observations", 3, regression.getN()); Assert.assertEquals("r-square", 0.993348115299335, regression.getRSquare(), 10E-12); Assert.assertEquals("SSR", 40.7272727272727, regression.getRegressionSumSquares(), 10E-9); Assert.assertEquals("MSE", 0.136363636363636, regression.getMeanSquareError(), 10E-10); Assert.assertEquals("SSE", 0.272727272727273, regression.getSumSquaredErrors(),10E-9); } @Test public void testNoIntercept_noint1(){ SimpleRegression regression = new SimpleRegression(false); for (int i = 0; i < noint1.length; i++) { regression.addData(noint1[i][1], noint1[i][0]); } Assert.assertEquals("intercept", 0, regression.getIntercept(), 0); Assert.assertEquals("slope", 2.07438016528926, regression.getSlope(), 10E-12); Assert.assertEquals("slope std err", 0.165289256198347E-01, regression.getSlopeStdErr(),10E-12); Assert.assertEquals("number of observations", 11, regression.getN()); Assert.assertEquals("r-square", 0.999365492298663, regression.getRSquare(), 10E-12); Assert.assertEquals("SSR", 200457.727272727, regression.getRegressionSumSquares(), 10E-9); Assert.assertEquals("MSE", 12.7272727272727, regression.getMeanSquareError(), 10E-10); Assert.assertEquals("SSE", 127.272727272727, regression.getSumSquaredErrors(),10E-9); } @Test public void testNorris() { SimpleRegression regression = new SimpleRegression(); for (int i = 0; i < data.length; i++) { regression.addData(data[i][1], data[i][0]); } // Tests against certified values from // http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Norris.dat Assert.assertEquals("slope", 1.00211681802045, regression.getSlope(), 10E-12); Assert.assertEquals("slope std err", 0.429796848199937E-03, regression.getSlopeStdErr(),10E-12); Assert.assertEquals("number of observations", 36, regression.getN()); Assert.assertEquals( "intercept", -0.262323073774029, regression.getIntercept(),10E-12); Assert.assertEquals("std err intercept", 0.232818234301152, regression.getInterceptStdErr(),10E-12); Assert.assertEquals("r-square", 0.999993745883712, regression.getRSquare(), 10E-12); Assert.assertEquals("SSR", 4255954.13232369, regression.getRegressionSumSquares(), 10E-9); Assert.assertEquals("MSE", 0.782864662630069, regression.getMeanSquareError(), 10E-10); Assert.assertEquals("SSE", 26.6173985294224, regression.getSumSquaredErrors(),10E-9); // ------------ End certified data tests Assert.assertEquals( "predict(0)", -0.262323073774029, regression.predict(0), 10E-12); Assert.assertEquals("predict(1)", 1.00211681802045 - 0.262323073774029, regression.predict(1), 10E-12); } @Test public void testCorr() { SimpleRegression regression = new SimpleRegression(); regression.addData(corrData); Assert.assertEquals("number of observations", 17, regression.getN()); Assert.assertEquals("r-square", .896123, regression.getRSquare(), 10E-6); Assert.assertEquals("r", -0.94663767742, regression.getR(), 1E-10); } @Test public void testNaNs() { SimpleRegression regression = new SimpleRegression(); Assert.assertTrue("intercept not NaN", Double.isNaN(regression.getIntercept())); Assert.assertTrue("slope not NaN", Double.isNaN(regression.getSlope())); Assert.assertTrue("slope std err not NaN", Double.isNaN(regression.getSlopeStdErr())); Assert.assertTrue("intercept std err not NaN", Double.isNaN(regression.getInterceptStdErr())); Assert.assertTrue("MSE not NaN", Double.isNaN(regression.getMeanSquareError())); Assert.assertTrue("e not NaN", Double.isNaN(regression.getR())); Assert.assertTrue("r-square not NaN", Double.isNaN(regression.getRSquare())); Assert.assertTrue( "RSS not NaN", Double.isNaN(regression.getRegressionSumSquares())); Assert.assertTrue("SSE not NaN",Double.isNaN(regression.getSumSquaredErrors())); Assert.assertTrue("SSTO not NaN", Double.isNaN(regression.getTotalSumSquares())); Assert.assertTrue("predict not NaN", Double.isNaN(regression.predict(0))); regression.addData(1, 2); regression.addData(1, 3); // No x variation, so these should still blow... Assert.assertTrue("intercept not NaN", Double.isNaN(regression.getIntercept())); Assert.assertTrue("slope not NaN", Double.isNaN(regression.getSlope())); Assert.assertTrue("slope std err not NaN", Double.isNaN(regression.getSlopeStdErr())); Assert.assertTrue("intercept std err not NaN", Double.isNaN(regression.getInterceptStdErr())); Assert.assertTrue("MSE not NaN", Double.isNaN(regression.getMeanSquareError())); Assert.assertTrue("e not NaN", Double.isNaN(regression.getR())); Assert.assertTrue("r-square not NaN", Double.isNaN(regression.getRSquare())); Assert.assertTrue("RSS not NaN", Double.isNaN(regression.getRegressionSumSquares())); Assert.assertTrue("SSE not NaN", Double.isNaN(regression.getSumSquaredErrors())); Assert.assertTrue("predict not NaN", Double.isNaN(regression.predict(0))); // but SSTO should be OK Assert.assertTrue("SSTO NaN", !Double.isNaN(regression.getTotalSumSquares())); regression = new SimpleRegression(); regression.addData(1, 2); regression.addData(3, 3); // All should be OK except MSE, s(b0), s(b1) which need one more df Assert.assertTrue("interceptNaN", !Double.isNaN(regression.getIntercept())); Assert.assertTrue("slope NaN", !Double.isNaN(regression.getSlope())); Assert.assertTrue("slope std err not NaN", Double.isNaN(regression.getSlopeStdErr())); Assert.assertTrue("intercept std err not NaN", Double.isNaN(regression.getInterceptStdErr())); Assert.assertTrue("MSE not NaN", Double.isNaN(regression.getMeanSquareError())); Assert.assertTrue("r NaN", !Double.isNaN(regression.getR())); Assert.assertTrue("r-square NaN", !Double.isNaN(regression.getRSquare())); Assert.assertTrue("RSS NaN", !Double.isNaN(regression.getRegressionSumSquares())); Assert.assertTrue("SSE NaN", !Double.isNaN(regression.getSumSquaredErrors())); Assert.assertTrue("SSTO NaN", !Double.isNaN(regression.getTotalSumSquares())); Assert.assertTrue("predict NaN", !Double.isNaN(regression.predict(0))); regression.addData(1, 4); // MSE, MSE, s(b0), s(b1) should all be OK now Assert.assertTrue("MSE NaN", !Double.isNaN(regression.getMeanSquareError())); Assert.assertTrue("slope std err NaN", !Double.isNaN(regression.getSlopeStdErr())); Assert.assertTrue("intercept std err NaN", !Double.isNaN(regression.getInterceptStdErr())); } @Test public void testClear() { SimpleRegression regression = new SimpleRegression(); regression.addData(corrData); Assert.assertEquals("number of observations", 17, regression.getN()); regression.clear(); Assert.assertEquals("number of observations", 0, regression.getN()); regression.addData(corrData); Assert.assertEquals("r-square", .896123, regression.getRSquare(), 10E-6); regression.addData(data); Assert.assertEquals("number of observations", 53, regression.getN()); } @Test public void testInference() { //---------- verified against R, version 1.8.1 ----- // infData SimpleRegression regression = new SimpleRegression(); regression.addData(infData); Assert.assertEquals("slope std err", 0.011448491, regression.getSlopeStdErr(), 1E-10); Assert.assertEquals("std err intercept", 0.286036932, regression.getInterceptStdErr(),1E-8); Assert.assertEquals("significance", 4.596e-07, regression.getSignificance(),1E-8); Assert.assertEquals("slope conf interval half-width", 0.0270713794287, regression.getSlopeConfidenceInterval(),1E-8); // infData2 regression = new SimpleRegression(); regression.addData(infData2); Assert.assertEquals("slope std err", 1.07260253, regression.getSlopeStdErr(), 1E-8); Assert.assertEquals("std err intercept",4.17718672, regression.getInterceptStdErr(),1E-8); Assert.assertEquals("significance", 0.261829133982, regression.getSignificance(),1E-11); Assert.assertEquals("slope conf interval half-width", 2.97802204827, regression.getSlopeConfidenceInterval(),1E-8); //------------- End R-verified tests ------------------------------- //FIXME: get a real example to test against with alpha = .01 Assert.assertTrue("tighter means wider", regression.getSlopeConfidenceInterval() < regression.getSlopeConfidenceInterval(0.01)); try { regression.getSlopeConfidenceInterval(1); Assert.fail("expecting MathIllegalArgumentException for alpha = 1"); } catch (MathIllegalArgumentException ex) { // ignored } } @Test public void testPerfect() { SimpleRegression regression = new SimpleRegression(); int n = 100; for (int i = 0; i < n; i++) { regression.addData(((double) i) / (n - 1), i); } Assert.assertEquals(0.0, regression.getSignificance(), 1.0e-5); Assert.assertTrue(regression.getSlope() > 0.0); Assert.assertTrue(regression.getSumSquaredErrors() >= 0.0); } @Test public void testPerfectNegative() { SimpleRegression regression = new SimpleRegression(); int n = 100; for (int i = 0; i < n; i++) { regression.addData(- ((double) i) / (n - 1), i); } Assert.assertEquals(0.0, regression.getSignificance(), 1.0e-5); Assert.assertTrue(regression.getSlope() < 0.0); } @Test public void testRandom() { SimpleRegression regression = new SimpleRegression(); Random random = new Random(1); int n = 100; for (int i = 0; i < n; i++) { regression.addData(((double) i) / (n - 1), random.nextDouble()); } Assert.assertTrue( 0.0 < regression.getSignificance() && regression.getSignificance() < 1.0); } // Jira MATH-85 = Bugzilla 39432 @Test public void testSSENonNegative() { double[] y = { 8915.102, 8919.302, 8923.502 }; double[] x = { 1.107178495E2, 1.107264895E2, 1.107351295E2 }; SimpleRegression reg = new SimpleRegression(); for (int i = 0; i < x.length; i++) { reg.addData(x[i], y[i]); } Assert.assertTrue(reg.getSumSquaredErrors() >= 0.0); } // Test remove X,Y (single observation) @Test public void testRemoveXY() { // Create regression with inference data then remove to test SimpleRegression regression = new SimpleRegression(); regression.addData(infData); regression.removeData(removeX, removeY); regression.addData(removeX, removeY); // Use the inference assertions to make sure that everything worked Assert.assertEquals("slope std err", 0.011448491, regression.getSlopeStdErr(), 1E-10); Assert.assertEquals("std err intercept", 0.286036932, regression.getInterceptStdErr(),1E-8); Assert.assertEquals("significance", 4.596e-07, regression.getSignificance(),1E-8); Assert.assertEquals("slope conf interval half-width", 0.0270713794287, regression.getSlopeConfidenceInterval(),1E-8); } // Test remove single observation in array @Test public void testRemoveSingle() { // Create regression with inference data then remove to test SimpleRegression regression = new SimpleRegression(); regression.addData(infData); regression.removeData(removeSingle); regression.addData(removeSingle); // Use the inference assertions to make sure that everything worked Assert.assertEquals("slope std err", 0.011448491, regression.getSlopeStdErr(), 1E-10); Assert.assertEquals("std err intercept", 0.286036932, regression.getInterceptStdErr(),1E-8); Assert.assertEquals("significance", 4.596e-07, regression.getSignificance(),1E-8); Assert.assertEquals("slope conf interval half-width", 0.0270713794287, regression.getSlopeConfidenceInterval(),1E-8); } // Test remove multiple observations @Test public void testRemoveMultiple() { // Create regression with inference data then remove to test SimpleRegression regression = new SimpleRegression(); regression.addData(infData); regression.removeData(removeMultiple); regression.addData(removeMultiple); // Use the inference assertions to make sure that everything worked Assert.assertEquals("slope std err", 0.011448491, regression.getSlopeStdErr(), 1E-10); Assert.assertEquals("std err intercept", 0.286036932, regression.getInterceptStdErr(),1E-8); Assert.assertEquals("significance", 4.596e-07, regression.getSignificance(),1E-8); Assert.assertEquals("slope conf interval half-width", 0.0270713794287, regression.getSlopeConfidenceInterval(),1E-8); } // Remove observation when empty @Test public void testRemoveObsFromEmpty() { SimpleRegression regression = new SimpleRegression(); regression.removeData(removeX, removeY); Assert.assertEquals(regression.getN(), 0); } // Remove single observation to empty @Test public void testRemoveObsFromSingle() { SimpleRegression regression = new SimpleRegression(); regression.addData(removeX, removeY); regression.removeData(removeX, removeY); Assert.assertEquals(regression.getN(), 0); } // Remove multiple observations to empty @Test public void testRemoveMultipleToEmpty() { SimpleRegression regression = new SimpleRegression(); regression.addData(removeMultiple); regression.removeData(removeMultiple); Assert.assertEquals(regression.getN(), 0); } // Remove multiple observations past empty (i.e. size of array > n) @Test public void testRemoveMultiplePastEmpty() { SimpleRegression regression = new SimpleRegression(); regression.addData(removeX, removeY); regression.removeData(removeMultiple); Assert.assertEquals(regression.getN(), 0); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.transform; import java.util.Arrays; import java.util.Collection; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.function.Sin; import org.apache.commons.math3.analysis.function.Sinc; import org.apache.commons.math3.exception.MathIllegalStateException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameters; /** * Test case for fast cosine transformer. * <p> * FCT algorithm is exact, the small tolerance number is used only to account * for round-off errors. * * @version $Id$ */ @RunWith(value = Parameterized.class) public final class FastCosineTransformerTest extends RealTransformerAbstractTest { private DctNormalization normalization; private final int[] invalidDataSize; private final double[] relativeTolerance; private final int[] validDataSize; public FastCosineTransformerTest(final DctNormalization normalization) { this.normalization = normalization; this.validDataSize = new int[] { 2, 3, 5, 9, 17, 33, 65, 129 }; this.invalidDataSize = new int[] { 128 }; this.relativeTolerance = new double[] { 1E-15, 1E-15, 1E-14, 1E-13, 1E-13, 1E-12, 1E-11, 1E-10 }; } /** * Returns an array containing {@code true, false} in order to check both * standard and orthogonal DCTs. * * @return an array of parameters for this parameterized test */ @Parameters public static Collection<Object[]> data() { final DctNormalization[] normalization = DctNormalization.values(); final Object[][] data = new DctNormalization[normalization.length][1]; for (int i = 0; i < normalization.length; i++){ data[i][0] = normalization[i]; } return Arrays.asList(data); } @Override RealTransformer createRealTransformer() { return new FastCosineTransformer(normalization); } @Override int getInvalidDataSize(final int i) { return invalidDataSize[i]; } @Override int getNumberOfInvalidDataSizes() { return invalidDataSize.length; } @Override int getNumberOfValidDataSizes() { return validDataSize.length; } @Override double getRelativeTolerance(final int i) { return relativeTolerance[i]; } @Override int getValidDataSize(final int i) { return validDataSize[i]; } @Override UnivariateFunction getValidFunction() { return new Sinc(); } @Override double getValidLowerBound() { return 0.0; } @Override double getValidUpperBound() { return FastMath.PI; } @Override double[] transform(final double[] x, final TransformType type) { final int n = x.length; final double[] y = new double[n]; final double[] cos = new double[2 * (n - 1)]; for (int i = 0; i < cos.length; i++) { cos[i] = FastMath.cos(FastMath.PI * i / (n - 1.0)); } int sgn = 1; for (int j = 0; j < n; j++) { double yj = 0.5 * (x[0] + sgn * x[n - 1]); for (int i = 1; i < n - 1; i++) { yj += x[i] * cos[(i * j) % cos.length]; } y[j] = yj; sgn *= -1; } final double s; if (type == TransformType.FORWARD) { if (normalization == DctNormalization.STANDARD_DCT_I) { s = 1.0; } else if (normalization == DctNormalization.ORTHOGONAL_DCT_I) { s = FastMath.sqrt(2.0 / (n - 1.0)); } else { throw new MathIllegalStateException(); } } else if (type == TransformType.INVERSE) { if (normalization == DctNormalization.STANDARD_DCT_I) { s = 2.0 / (n - 1.0); } else if (normalization == DctNormalization.ORTHOGONAL_DCT_I) { s = FastMath.sqrt(2.0 / (n - 1.0)); } else { throw new MathIllegalStateException(); } } else { /* * Should never occur. This clause is a safeguard in case other * types are used to TransformType (which should not be done). */ throw new MathIllegalStateException(); } TransformUtils.scaleArray(y, s); return y; } /* * Additional tests. */ /** Test of transformer for the ad hoc data. */ @Test public void testAdHocData() { FastCosineTransformer transformer; transformer = new FastCosineTransformer(DctNormalization.STANDARD_DCT_I); double result[], tolerance = 1E-12; double x[] = { 0.0, 1.0, 4.0, 9.0, 16.0, 25.0, 36.0, 49.0, 64.0 }; double y[] = { 172.0, -105.096569476353, 27.3137084989848, -12.9593152353742, 8.0, -5.78585076868676, 4.68629150101524, -4.15826451958632, 4.0 }; result = transformer.transform(x, TransformType.FORWARD); for (int i = 0; i < result.length; i++) { Assert.assertEquals(y[i], result[i], tolerance); } result = transformer.transform(y, TransformType.INVERSE); for (int i = 0; i < result.length; i++) { Assert.assertEquals(x[i], result[i], tolerance); } TransformUtils.scaleArray(x, FastMath.sqrt(0.5 * (x.length - 1))); transformer = new FastCosineTransformer(DctNormalization.ORTHOGONAL_DCT_I); result = transformer.transform(y, TransformType.FORWARD); for (int i = 0; i < result.length; i++) { Assert.assertEquals(x[i], result[i], tolerance); } result = transformer.transform(x, TransformType.INVERSE); for (int i = 0; i < result.length; i++) { Assert.assertEquals(y[i], result[i], tolerance); } } /** Test of parameters for the transformer. */ @Test public void testParameters() throws Exception { UnivariateFunction f = new Sin(); FastCosineTransformer transformer; transformer = new FastCosineTransformer(DctNormalization.STANDARD_DCT_I); try { // bad interval transformer.transform(f, 1, -1, 65, TransformType.FORWARD); Assert.fail("Expecting IllegalArgumentException - bad interval"); } catch (IllegalArgumentException ex) { // expected } try { // bad samples number transformer.transform(f, -1, 1, 1, TransformType.FORWARD); Assert .fail("Expecting IllegalArgumentException - bad samples number"); } catch (IllegalArgumentException ex) { // expected } try { // bad samples number transformer.transform(f, -1, 1, 64, TransformType.FORWARD); Assert .fail("Expecting IllegalArgumentException - bad samples number"); } catch (IllegalArgumentException ex) { // expected } } /** Test of transformer for the sine function. */ @Test public void testSinFunction() { UnivariateFunction f = new Sin(); FastCosineTransformer transformer; transformer = new FastCosineTransformer(DctNormalization.STANDARD_DCT_I); double min, max, result[], tolerance = 1E-12; int N = 9; double expected[] = { 0.0, 3.26197262739567, 0.0, -2.17958042710327, 0.0, -0.648846697642915, 0.0, -0.433545502649478, 0.0 }; min = 0.0; max = 2.0 * FastMath.PI * N / (N - 1); result = transformer.transform(f, min, max, N, TransformType.FORWARD); for (int i = 0; i < N; i++) { Assert.assertEquals(expected[i], result[i], tolerance); } min = -FastMath.PI; max = FastMath.PI * (N + 1) / (N - 1); result = transformer.transform(f, min, max, N, TransformType.FORWARD); for (int i = 0; i < N; i++) { Assert.assertEquals(-expected[i], result[i], tolerance); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.transform; import java.util.Random; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.function.Sin; import org.apache.commons.math3.analysis.function.Sinc; import org.apache.commons.math3.complex.Complex; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.apache.commons.math3.exception.NumberIsTooLargeException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; /** * Test case for fast Fourier transformer. * <p> * FFT algorithm is exact, the small tolerance number is used only * to account for round-off errors. * * @version $Id$ */ public final class FastFourierTransformerTest { /** The common seed of all random number generators used in this test. */ private final static long SEED = 20110111L; /* * Precondition checks. */ @Test public void testTransformComplexSizeNotAPowerOfTwo() { final int n = 127; final Complex[] x = createComplexData(n); final DftNormalization[] norm; norm = DftNormalization.values(); final TransformType[] type; type = TransformType.values(); for (int i = 0; i < norm.length; i++) { for (int j = 0; j < type.length; j++) { final FastFourierTransformer fft; fft = new FastFourierTransformer(norm[i]); try { fft.transform(x, type[j]); Assert.fail(norm[i] + ", " + type[j] + ": MathIllegalArgumentException was expected"); } catch (MathIllegalArgumentException e) { // Expected behaviour } } } } @Test public void testTransformRealSizeNotAPowerOfTwo() { final int n = 127; final double[] x = createRealData(n); final DftNormalization[] norm; norm = DftNormalization.values(); final TransformType[] type; type = TransformType.values(); for (int i = 0; i < norm.length; i++) { for (int j = 0; j < type.length; j++) { final FastFourierTransformer fft; fft = new FastFourierTransformer(norm[i]); try { fft.transform(x, type[j]); Assert.fail(norm[i] + ", " + type[j] + ": MathIllegalArgumentException was expected"); } catch (MathIllegalArgumentException e) { // Expected behaviour } } } } @Test public void testTransformFunctionSizeNotAPowerOfTwo() { final int n = 127; final UnivariateFunction f = new Sin(); final DftNormalization[] norm; norm = DftNormalization.values(); final TransformType[] type; type = TransformType.values(); for (int i = 0; i < norm.length; i++) { for (int j = 0; j < type.length; j++) { final FastFourierTransformer fft; fft = new FastFourierTransformer(norm[i]); try { fft.transform(f, 0.0, Math.PI, n, type[j]); Assert.fail(norm[i] + ", " + type[j] + ": MathIllegalArgumentException was expected"); } catch (MathIllegalArgumentException e) { // Expected behaviour } } } } @Test public void testTransformFunctionNotStrictlyPositiveNumberOfSamples() { final int n = -128; final UnivariateFunction f = new Sin(); final DftNormalization[] norm; norm = DftNormalization.values(); final TransformType[] type; type = TransformType.values(); for (int i = 0; i < norm.length; i++) { for (int j = 0; j < type.length; j++) { final FastFourierTransformer fft; fft = new FastFourierTransformer(norm[i]); try { fft.transform(f, 0.0, Math.PI, n, type[j]); fft.transform(f, 0.0, Math.PI, n, type[j]); Assert.fail(norm[i] + ", " + type[j] + ": NotStrictlyPositiveException was expected"); } catch (NotStrictlyPositiveException e) { // Expected behaviour } } } } @Test public void testTransformFunctionInvalidBounds() { final int n = 128; final UnivariateFunction f = new Sin(); final DftNormalization[] norm; norm = DftNormalization.values(); final TransformType[] type; type = TransformType.values(); for (int i = 0; i < norm.length; i++) { for (int j = 0; j < type.length; j++) { final FastFourierTransformer fft; fft = new FastFourierTransformer(norm[i]); try { fft.transform(f, Math.PI, 0.0, n, type[j]); Assert.fail(norm[i] + ", " + type[j] + ": NumberIsTooLargeException was expected"); } catch (NumberIsTooLargeException e) { // Expected behaviour } } } } /* * Utility methods for checking (successful) transforms. */ private static Complex[] createComplexData(final int n) { final Random random = new Random(SEED); final Complex[] data = new Complex[n]; for (int i = 0; i < n; i++) { final double re = 2.0 * random.nextDouble() - 1.0; final double im = 2.0 * random.nextDouble() - 1.0; data[i] = new Complex(re, im); } return data; } private static double[] createRealData(final int n) { final Random random = new Random(SEED); final double[] data = new double[n]; for (int i = 0; i < n; i++) { data[i] = 2.0 * random.nextDouble() - 1.0; } return data; } /** Naive implementation of DFT, for reference. */ private static Complex[] dft(final Complex[] x, final int sgn) { final int n = x.length; final double[] cos = new double[n]; final double[] sin = new double[n]; final Complex[] y = new Complex[n]; for (int i = 0; i < n; i++) { final double arg = 2.0 * FastMath.PI * i / n; cos[i] = FastMath.cos(arg); sin[i] = FastMath.sin(arg); } for (int i = 0; i < n; i++) { double yr = 0.0; double yi = 0.0; for (int j = 0; j < n; j++) { final int index = (i * j) % n; final double c = cos[index]; final double s = sin[index]; final double xr = x[j].getReal(); final double xi = x[j].getImaginary(); yr += c * xr - sgn * s * xi; yi += sgn * s * xr + c * xi; } y[i] = new Complex(yr, yi); } return y; } private static void doTestTransformComplex(final int n, final double tol, final DftNormalization normalization, final TransformType type) { final FastFourierTransformer fft; fft = new FastFourierTransformer(normalization); final Complex[] x = createComplexData(n); final Complex[] expected; final double s; if (type==TransformType.FORWARD) { expected = dft(x, -1); if (normalization == DftNormalization.STANDARD){ s = 1.0; } else { s = 1.0 / FastMath.sqrt(n); } } else { expected = dft(x, 1); if (normalization == DftNormalization.STANDARD) { s = 1.0 / n; } else { s = 1.0 / FastMath.sqrt(n); } } final Complex[] actual = fft.transform(x, type); for (int i = 0; i < n; i++) { final String msg; msg = String.format("%s, %s, %d, %d", normalization, type, n, i); final double re = s * expected[i].getReal(); Assert.assertEquals(msg, re, actual[i].getReal(), tol * FastMath.abs(re)); final double im = s * expected[i].getImaginary(); Assert.assertEquals(msg, im, actual[i].getImaginary(), tol * FastMath.abs(re)); } } private static void doTestTransformReal(final int n, final double tol, final DftNormalization normalization, final TransformType type) { final FastFourierTransformer fft; fft = new FastFourierTransformer(normalization); final double[] x = createRealData(n); final Complex[] xc = new Complex[n]; for (int i = 0; i < n; i++) { xc[i] = new Complex(x[i], 0.0); } final Complex[] expected; final double s; if (type == TransformType.FORWARD) { expected = dft(xc, -1); if (normalization == DftNormalization.STANDARD) { s = 1.0; } else { s = 1.0 / FastMath.sqrt(n); } } else { expected = dft(xc, 1); if (normalization == DftNormalization.STANDARD) { s = 1.0 / n; } else { s = 1.0 / FastMath.sqrt(n); } } final Complex[] actual = fft.transform(x, type); for (int i = 0; i < n; i++) { final String msg; msg = String.format("%s, %s, %d, %d", normalization, type, n, i); final double re = s * expected[i].getReal(); Assert.assertEquals(msg, re, actual[i].getReal(), tol * FastMath.abs(re)); final double im = s * expected[i].getImaginary(); Assert.assertEquals(msg, im, actual[i].getImaginary(), tol * FastMath.abs(re)); } } private static void doTestTransformFunction(final UnivariateFunction f, final double min, final double max, int n, final double tol, final DftNormalization normalization, final TransformType type) { final FastFourierTransformer fft; fft = new FastFourierTransformer(normalization); final Complex[] x = new Complex[n]; for (int i = 0; i < n; i++) { final double t = min + i * (max - min) / n; x[i] = new Complex(f.value(t)); } final Complex[] expected; final double s; if (type == TransformType.FORWARD) { expected = dft(x, -1); if (normalization == DftNormalization.STANDARD) { s = 1.0; } else { s = 1.0 / FastMath.sqrt(n); } } else { expected = dft(x, 1); if (normalization == DftNormalization.STANDARD) { s = 1.0 / n; } else { s = 1.0 / FastMath.sqrt(n); } } final Complex[] actual = fft.transform(f, min, max, n, type); for (int i = 0; i < n; i++) { final String msg = String.format("%d, %d", n, i); final double re = s * expected[i].getReal(); Assert.assertEquals(msg, re, actual[i].getReal(), tol * FastMath.abs(re)); final double im = s * expected[i].getImaginary(); Assert.assertEquals(msg, im, actual[i].getImaginary(), tol * FastMath.abs(re)); } } /* * Tests of standard transform (when data is valid). */ @Test public void testTransformComplex() { final DftNormalization[] norm; norm = DftNormalization.values(); final TransformType[] type; type = TransformType.values(); for (int i = 0; i < norm.length; i++) { for (int j = 0; j < type.length; j++) { doTestTransformComplex(2, 1.0E-15, norm[i], type[j]); doTestTransformComplex(4, 1.0E-14, norm[i], type[j]); doTestTransformComplex(8, 1.0E-14, norm[i], type[j]); doTestTransformComplex(16, 1.0E-13, norm[i], type[j]); doTestTransformComplex(32, 1.0E-13, norm[i], type[j]); doTestTransformComplex(64, 1.0E-12, norm[i], type[j]); doTestTransformComplex(128, 1.0E-12, norm[i], type[j]); } } } @Test public void testStandardTransformReal() { final DftNormalization[] norm; norm = DftNormalization.values(); final TransformType[] type; type = TransformType.values(); for (int i = 0; i < norm.length; i++) { for (int j = 0; j < type.length; j++) { doTestTransformReal(2, 1.0E-15, norm[i], type[j]); doTestTransformReal(4, 1.0E-14, norm[i], type[j]); doTestTransformReal(8, 1.0E-14, norm[i], type[j]); doTestTransformReal(16, 1.0E-13, norm[i], type[j]); doTestTransformReal(32, 1.0E-13, norm[i], type[j]); doTestTransformReal(64, 1.0E-13, norm[i], type[j]); doTestTransformReal(128, 1.0E-11, norm[i], type[j]); } } } @Test public void testStandardTransformFunction() { final UnivariateFunction f = new Sinc(); final double min = -FastMath.PI; final double max = FastMath.PI; final DftNormalization[] norm; norm = DftNormalization.values(); final TransformType[] type; type = TransformType.values(); for (int i = 0; i < norm.length; i++) { for (int j = 0; j < type.length; j++) { doTestTransformFunction(f, min, max, 2, 1.0E-15, norm[i], type[j]); doTestTransformFunction(f, min, max, 4, 1.0E-14, norm[i], type[j]); doTestTransformFunction(f, min, max, 8, 1.0E-14, norm[i], type[j]); doTestTransformFunction(f, min, max, 16, 1.0E-13, norm[i], type[j]); doTestTransformFunction(f, min, max, 32, 1.0E-13, norm[i], type[j]); doTestTransformFunction(f, min, max, 64, 1.0E-12, norm[i], type[j]); doTestTransformFunction(f, min, max, 128, 1.0E-11, norm[i], type[j]); } } } /* * Additional tests for 1D data. */ /** * Test of transformer for the ad hoc data taken from Mathematica. */ @Test public void testAdHocData() { FastFourierTransformer transformer; transformer = new FastFourierTransformer(DftNormalization.STANDARD); Complex result[]; double tolerance = 1E-12; double x[] = {1.3, 2.4, 1.7, 4.1, 2.9, 1.7, 5.1, 2.7}; Complex y[] = { new Complex(21.9, 0.0), new Complex(-2.09497474683058, 1.91507575950825), new Complex(-2.6, 2.7), new Complex(-1.10502525316942, -4.88492424049175), new Complex(0.1, 0.0), new Complex(-1.10502525316942, 4.88492424049175), new Complex(-2.6, -2.7), new Complex(-2.09497474683058, -1.91507575950825)}; result = transformer.transform(x, TransformType.FORWARD); for (int i = 0; i < result.length; i++) { Assert.assertEquals(y[i].getReal(), result[i].getReal(), tolerance); Assert.assertEquals(y[i].getImaginary(), result[i].getImaginary(), tolerance); } result = transformer.transform(y, TransformType.INVERSE); for (int i = 0; i < result.length; i++) { Assert.assertEquals(x[i], result[i].getReal(), tolerance); Assert.assertEquals(0.0, result[i].getImaginary(), tolerance); } double x2[] = {10.4, 21.6, 40.8, 13.6, 23.2, 32.8, 13.6, 19.2}; TransformUtils.scaleArray(x2, 1.0 / FastMath.sqrt(x2.length)); Complex y2[] = y; transformer = new FastFourierTransformer(DftNormalization.UNITARY); result = transformer.transform(y2, TransformType.FORWARD); for (int i = 0; i < result.length; i++) { Assert.assertEquals(x2[i], result[i].getReal(), tolerance); Assert.assertEquals(0.0, result[i].getImaginary(), tolerance); } result = transformer.transform(x2, TransformType.INVERSE); for (int i = 0; i < result.length; i++) { Assert.assertEquals(y2[i].getReal(), result[i].getReal(), tolerance); Assert.assertEquals(y2[i].getImaginary(), result[i].getImaginary(), tolerance); } } /** * Test of transformer for the sine function. */ @Test public void testSinFunction() { UnivariateFunction f = new Sin(); FastFourierTransformer transformer; transformer = new FastFourierTransformer(DftNormalization.STANDARD); Complex result[]; int N = 1 << 8; double min, max, tolerance = 1E-12; min = 0.0; max = 2.0 * FastMath.PI; result = transformer.transform(f, min, max, N, TransformType.FORWARD); Assert.assertEquals(0.0, result[1].getReal(), tolerance); Assert.assertEquals(-(N >> 1), result[1].getImaginary(), tolerance); Assert.assertEquals(0.0, result[N-1].getReal(), tolerance); Assert.assertEquals(N >> 1, result[N-1].getImaginary(), tolerance); for (int i = 0; i < N-1; i += (i == 0 ? 2 : 1)) { Assert.assertEquals(0.0, result[i].getReal(), tolerance); Assert.assertEquals(0.0, result[i].getImaginary(), tolerance); } min = -FastMath.PI; max = FastMath.PI; result = transformer.transform(f, min, max, N, TransformType.INVERSE); Assert.assertEquals(0.0, result[1].getReal(), tolerance); Assert.assertEquals(-0.5, result[1].getImaginary(), tolerance); Assert.assertEquals(0.0, result[N-1].getReal(), tolerance); Assert.assertEquals(0.5, result[N-1].getImaginary(), tolerance); for (int i = 0; i < N-1; i += (i == 0 ? 2 : 1)) { Assert.assertEquals(0.0, result[i].getReal(), tolerance); Assert.assertEquals(0.0, result[i].getImaginary(), tolerance); } } /* * Additional tests for 2D data. */ @Test public void test2DData() { FastFourierTransformer transformer; transformer = new FastFourierTransformer(DftNormalization.STANDARD); double tolerance = 1E-12; Complex[][] input = new Complex[][] {new Complex[] {new Complex(1, 0), new Complex(2, 0)}, new Complex[] {new Complex(3, 1), new Complex(4, 2)}}; Complex[][] goodOutput = new Complex[][] {new Complex[] {new Complex(5, 1.5), new Complex(-1, -.5)}, new Complex[] {new Complex(-2, -1.5), new Complex(0, .5)}}; for (int i = 0; i < goodOutput.length; i++) { TransformUtils.scaleArray( goodOutput[i], FastMath.sqrt(goodOutput[i].length) * FastMath.sqrt(goodOutput.length)); } Complex[][] output = (Complex[][])transformer.mdfft(input, TransformType.FORWARD); Complex[][] output2 = (Complex[][])transformer.mdfft(output, TransformType.INVERSE); Assert.assertEquals(input.length, output.length); Assert.assertEquals(input.length, output2.length); Assert.assertEquals(input[0].length, output[0].length); Assert.assertEquals(input[0].length, output2[0].length); Assert.assertEquals(input[1].length, output[1].length); Assert.assertEquals(input[1].length, output2[1].length); for (int i = 0; i < input.length; i++) { for (int j = 0; j < input[0].length; j++) { Assert.assertEquals(input[i][j].getImaginary(), output2[i][j].getImaginary(), tolerance); Assert.assertEquals(input[i][j].getReal(), output2[i][j].getReal(), tolerance); Assert.assertEquals(goodOutput[i][j].getImaginary(), output[i][j].getImaginary(), tolerance); Assert.assertEquals(goodOutput[i][j].getReal(), output[i][j].getReal(), tolerance); } } } @Test public void test2DDataUnitary() { FastFourierTransformer transformer; transformer = new FastFourierTransformer(DftNormalization.UNITARY); double tolerance = 1E-12; Complex[][] input = new Complex[][] {new Complex[] {new Complex(1, 0), new Complex(2, 0)}, new Complex[] {new Complex(3, 1), new Complex(4, 2)}}; Complex[][] goodOutput = new Complex[][] {new Complex[] {new Complex(5, 1.5), new Complex(-1, -.5)}, new Complex[] {new Complex(-2, -1.5), new Complex(0, .5)}}; Complex[][] output = (Complex[][])transformer.mdfft(input, TransformType.FORWARD); Complex[][] output2 = (Complex[][])transformer.mdfft(output, TransformType.INVERSE); Assert.assertEquals(input.length, output.length); Assert.assertEquals(input.length, output2.length); Assert.assertEquals(input[0].length, output[0].length); Assert.assertEquals(input[0].length, output2[0].length); Assert.assertEquals(input[1].length, output[1].length); Assert.assertEquals(input[1].length, output2[1].length); for (int i = 0; i < input.length; i++) { for (int j = 0; j < input[0].length; j++) { Assert.assertEquals(input[i][j].getImaginary(), output2[i][j].getImaginary(), tolerance); Assert.assertEquals(input[i][j].getReal(), output2[i][j].getReal(), tolerance); Assert.assertEquals(goodOutput[i][j].getImaginary(), output[i][j].getImaginary(), tolerance); Assert.assertEquals(goodOutput[i][j].getReal(), output[i][j].getReal(), tolerance); } } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.transform; import org.apache.commons.math3.util.Precision; import org.junit.Assert; import org.junit.Test; /** * JUnit Test for HadamardTransformerTest * @see org.apache.commons.math3.transform.FastHadamardTransformer */ public final class FastHadamardTransformerTest { /** * Test of transformer for the a 8-point FHT (means n=8) */ @Test public void test8Points() { checkAllTransforms(new int[] { 1, 4, -2, 3, 0, 1, 4, -1 }, new int[] { 10, -4, 2, -4, 2, -12, 6, 8 }); } /** * Test of transformer for the a 4-points FHT (means n=4) */ @Test public void test4Points() { checkAllTransforms(new int[] { 1, 2, 3, 4 }, new int[] { 10, -2, -4, 0 }); } /** * Test the inverse transform of an integer vector is not always an integer vector */ @Test public void testNoIntInverse() { FastHadamardTransformer transformer = new FastHadamardTransformer(); double[] x = transformer.transform(new double[] { 0, 1, 0, 1}, TransformType.INVERSE); Assert.assertEquals( 0.5, x[0], 0); Assert.assertEquals(-0.5, x[1], 0); Assert.assertEquals( 0.0, x[2], 0); Assert.assertEquals( 0.0, x[3], 0); } /** * Test of transformer for wrong number of points */ @Test public void test3Points() { try { new FastHadamardTransformer().transform(new double[3], TransformType.FORWARD); Assert.fail("an exception should have been thrown"); } catch (IllegalArgumentException iae) { // expected } } private void checkAllTransforms(int[]x, int[] y) { checkDoubleTransform(x, y); checkInverseDoubleTransform(x, y); checkIntTransform(x, y); } private void checkDoubleTransform(int[]x, int[] y) { // Initiate the transformer FastHadamardTransformer transformer = new FastHadamardTransformer(); // check double transform double[] dX = new double[x.length]; for (int i = 0; i < dX.length; ++i) { dX[i] = x[i]; } double dResult[] = transformer.transform(dX, TransformType.FORWARD); for (int i = 0; i < dResult.length; i++) { // compare computed results to precomputed results Assert.assertTrue(Precision.equals(y[i], dResult[i], 1)); } } private void checkIntTransform(int[]x, int[] y) { // Initiate the transformer FastHadamardTransformer transformer = new FastHadamardTransformer(); // check integer transform int iResult[] = transformer.transform(x); for (int i = 0; i < iResult.length; i++) { // compare computed results to precomputed results Assert.assertEquals(y[i], iResult[i]); } } private void checkInverseDoubleTransform(int[]x, int[] y) { // Initiate the transformer FastHadamardTransformer transformer = new FastHadamardTransformer(); // check double transform double[] dY = new double[y.length]; for (int i = 0; i < dY.length; ++i) { dY[i] = y[i]; } double dResult[] = transformer.transform(dY, TransformType.INVERSE); for (int i = 0; i < dResult.length; i++) { // compare computed results to precomputed results Assert.assertTrue(Precision.equals(x[i], dResult[i], 1)); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.transform; import java.util.Arrays; import java.util.Collection; import org.apache.commons.math3.analysis.UnivariateFunction; import org.apache.commons.math3.analysis.function.Sin; import org.apache.commons.math3.analysis.function.Sinc; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.exception.MathIllegalStateException; import org.apache.commons.math3.util.FastMath; import org.junit.Assert; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameters; /** * Test case for fast sine transformer. * <p> * FST algorithm is exact, the small tolerance number is used only * to account for round-off errors. * * @version $Id$ */ @RunWith(value = Parameterized.class) public final class FastSineTransformerTest extends RealTransformerAbstractTest { private final DstNormalization normalization; private final int[] invalidDataSize; private final double[] relativeTolerance; private final int[] validDataSize; public FastSineTransformerTest(final DstNormalization normalization) { this.normalization = normalization; this.validDataSize = new int[] { 1, 2, 4, 8, 16, 32, 64, 128 }; this.invalidDataSize = new int[] { 129 }; this.relativeTolerance = new double[] { 1E-15, 1E-15, 1E-14, 1E-14, 1E-13, 1E-12, 1E-11, 1E-11 }; } /** * Returns an array containing {@code true, false} in order to check both * standard and orthogonal DSTs. * * @return an array of parameters for this parameterized test */ @Parameters public static Collection<Object[]> data() { final DstNormalization[] normalization = DstNormalization.values(); final Object[][] data = new DstNormalization[normalization.length][1]; for (int i = 0; i < normalization.length; i++) { data[i][0] = normalization[i]; } return Arrays.asList(data); } /** * {@inheritDoc} * * Overriding the default implementation allows to ensure that the first * element of the data set is zero. */ @Override double[] createRealData(final int n) { final double[] data = super.createRealData(n); data[0] = 0.0; return data; } @Override RealTransformer createRealTransformer() { return new FastSineTransformer(normalization); } @Override int getInvalidDataSize(final int i) { return invalidDataSize[i]; } @Override int getNumberOfInvalidDataSizes() { return invalidDataSize.length; } @Override int getNumberOfValidDataSizes() { return validDataSize.length; } @Override double getRelativeTolerance(final int i) { return relativeTolerance[i]; } @Override int getValidDataSize(final int i) { return validDataSize[i]; } @Override UnivariateFunction getValidFunction() { return new Sinc(); } @Override double getValidLowerBound() { return 0.0; } @Override double getValidUpperBound() { return FastMath.PI; } @Override double[] transform(final double[] x, final TransformType type) { final int n = x.length; final double[] y = new double[n]; final double[] sin = new double[2 * n]; for (int i = 0; i < sin.length; i++) { sin[i] = FastMath.sin(FastMath.PI * i / n); } for (int j = 0; j < n; j++) { double yj = 0.0; for (int i = 0; i < n; i++) { yj += x[i] * sin[(i * j) % sin.length]; } y[j] = yj; } final double s; if (type == TransformType.FORWARD) { if (normalization == DstNormalization.STANDARD_DST_I) { s = 1.0; } else if (normalization == DstNormalization.ORTHOGONAL_DST_I) { s = FastMath.sqrt(2.0 / n); } else { throw new MathIllegalStateException(); } } else if (type == TransformType.INVERSE) { if (normalization == DstNormalization.STANDARD_DST_I) { s = 2.0 / n; } else if (normalization == DstNormalization.ORTHOGONAL_DST_I) { s = FastMath.sqrt(2.0 / n); } else { throw new MathIllegalStateException(); } } else { /* * Should never occur. This clause is a safeguard in case other * types are used to TransformType (which should not be done). */ throw new MathIllegalStateException(); } TransformUtils.scaleArray(y, s); return y; } /* * Additional tests. */ @Test public void testTransformRealFirstElementNotZero() { final TransformType[] type = TransformType.values(); final double[] data = new double[] { 1.0, 1.0, 1.0, 1.0 }; final RealTransformer transformer = createRealTransformer(); for (int j = 0; j < type.length; j++) { try { transformer.transform(data, type[j]); Assert.fail(type[j].toString()); } catch (MathIllegalArgumentException e) { // Expected: do nothing } } } /* * Additional (legacy) tests. */ /** * Test of transformer for the ad hoc data. */ @Test public void testAdHocData() { FastSineTransformer transformer; transformer = new FastSineTransformer(DstNormalization.STANDARD_DST_I); double result[], tolerance = 1E-12; double x[] = { 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0 }; double y[] = { 0.0, 20.1093579685034, -9.65685424949238, 5.98642305066196, -4.0, 2.67271455167720, -1.65685424949238, 0.795649469518633 }; result = transformer.transform(x, TransformType.FORWARD); for (int i = 0; i < result.length; i++) { Assert.assertEquals(y[i], result[i], tolerance); } result = transformer.transform(y, TransformType.INVERSE); for (int i = 0; i < result.length; i++) { Assert.assertEquals(x[i], result[i], tolerance); } TransformUtils.scaleArray(x, FastMath.sqrt(x.length / 2.0)); transformer = new FastSineTransformer(DstNormalization.ORTHOGONAL_DST_I); result = transformer.transform(y, TransformType.FORWARD); for (int i = 0; i < result.length; i++) { Assert.assertEquals(x[i], result[i], tolerance); } result = transformer.transform(x, TransformType.INVERSE); for (int i = 0; i < result.length; i++) { Assert.assertEquals(y[i], result[i], tolerance); } } /** * Test of transformer for the sine function. */ @Test public void testSinFunction() { UnivariateFunction f = new Sin(); FastSineTransformer transformer; transformer = new FastSineTransformer(DstNormalization.STANDARD_DST_I); double min, max, result[], tolerance = 1E-12; int N = 1 << 8; min = 0.0; max = 2.0 * FastMath.PI; result = transformer.transform(f, min, max, N, TransformType.FORWARD); Assert.assertEquals(N >> 1, result[2], tolerance); for (int i = 0; i < N; i += (i == 1 ? 2 : 1)) { Assert.assertEquals(0.0, result[i], tolerance); } min = -FastMath.PI; max = FastMath.PI; result = transformer.transform(f, min, max, N, TransformType.FORWARD); Assert.assertEquals(-(N >> 1), result[2], tolerance); for (int i = 0; i < N; i += (i == 1 ? 2 : 1)) { Assert.assertEquals(0.0, result[i], tolerance); } } /** * Test of parameters for the transformer. */ @Test public void testParameters() throws Exception { UnivariateFunction f = new Sin(); FastSineTransformer transformer; transformer = new FastSineTransformer(DstNormalization.STANDARD_DST_I); try { // bad interval transformer.transform(f, 1, -1, 64, TransformType.FORWARD); Assert.fail("Expecting IllegalArgumentException - bad interval"); } catch (IllegalArgumentException ex) { // expected } try { // bad samples number transformer.transform(f, -1, 1, 0, TransformType.FORWARD); Assert.fail("Expecting IllegalArgumentException - bad samples number"); } catch (IllegalArgumentException ex) { // expected } try { // bad samples number transformer.transform(f, -1, 1, 100, TransformType.FORWARD); Assert.fail("Expecting IllegalArgumentException - bad samples number"); } catch (IllegalArgumentException ex) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.util; import java.util.ArrayList; import java.util.Arrays; import java.math.BigInteger; import org.apache.commons.math3.exception.MathArithmeticException; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.random.RandomDataGenerator; import org.junit.Assert; import org.junit.Test; /** * Test cases for the {@link ArithmeticUtils} class. * * @version $Id$ */ public class ArithmeticUtilsTest { @Test public void testAddAndCheck() { int big = Integer.MAX_VALUE; int bigNeg = Integer.MIN_VALUE; Assert.assertEquals(big, ArithmeticUtils.addAndCheck(big, 0)); try { ArithmeticUtils.addAndCheck(big, 1); Assert.fail("Expecting MathArithmeticException"); } catch (MathArithmeticException ex) { } try { ArithmeticUtils.addAndCheck(bigNeg, -1); Assert.fail("Expecting MathArithmeticException"); } catch (MathArithmeticException ex) { } } @Test public void testAddAndCheckLong() { long max = Long.MAX_VALUE; long min = Long.MIN_VALUE; Assert.assertEquals(max, ArithmeticUtils.addAndCheck(max, 0L)); Assert.assertEquals(min, ArithmeticUtils.addAndCheck(min, 0L)); Assert.assertEquals(max, ArithmeticUtils.addAndCheck(0L, max)); Assert.assertEquals(min, ArithmeticUtils.addAndCheck(0L, min)); Assert.assertEquals(1, ArithmeticUtils.addAndCheck(-1L, 2L)); Assert.assertEquals(1, ArithmeticUtils.addAndCheck(2L, -1L)); Assert.assertEquals(-3, ArithmeticUtils.addAndCheck(-2L, -1L)); Assert.assertEquals(min, ArithmeticUtils.addAndCheck(min + 1, -1L)); testAddAndCheckLongFailure(max, 1L); testAddAndCheckLongFailure(min, -1L); testAddAndCheckLongFailure(1L, max); testAddAndCheckLongFailure(-1L, min); } @Test public void testGcd() { int a = 30; int b = 50; int c = 77; Assert.assertEquals(0, ArithmeticUtils.gcd(0, 0)); Assert.assertEquals(b, ArithmeticUtils.gcd(0, b)); Assert.assertEquals(a, ArithmeticUtils.gcd(a, 0)); Assert.assertEquals(b, ArithmeticUtils.gcd(0, -b)); Assert.assertEquals(a, ArithmeticUtils.gcd(-a, 0)); Assert.assertEquals(10, ArithmeticUtils.gcd(a, b)); Assert.assertEquals(10, ArithmeticUtils.gcd(-a, b)); Assert.assertEquals(10, ArithmeticUtils.gcd(a, -b)); Assert.assertEquals(10, ArithmeticUtils.gcd(-a, -b)); Assert.assertEquals(1, ArithmeticUtils.gcd(a, c)); Assert.assertEquals(1, ArithmeticUtils.gcd(-a, c)); Assert.assertEquals(1, ArithmeticUtils.gcd(a, -c)); Assert.assertEquals(1, ArithmeticUtils.gcd(-a, -c)); Assert.assertEquals(3 * (1<<15), ArithmeticUtils.gcd(3 * (1<<20), 9 * (1<<15))); Assert.assertEquals(Integer.MAX_VALUE, ArithmeticUtils.gcd(Integer.MAX_VALUE, 0)); Assert.assertEquals(Integer.MAX_VALUE, ArithmeticUtils.gcd(-Integer.MAX_VALUE, 0)); Assert.assertEquals(1<<30, ArithmeticUtils.gcd(1<<30, -Integer.MIN_VALUE)); try { // gcd(Integer.MIN_VALUE, 0) > Integer.MAX_VALUE ArithmeticUtils.gcd(Integer.MIN_VALUE, 0); Assert.fail("expecting MathArithmeticException"); } catch (MathArithmeticException expected) { // expected } try { // gcd(0, Integer.MIN_VALUE) > Integer.MAX_VALUE ArithmeticUtils.gcd(0, Integer.MIN_VALUE); Assert.fail("expecting MathArithmeticException"); } catch (MathArithmeticException expected) { // expected } try { // gcd(Integer.MIN_VALUE, Integer.MIN_VALUE) > Integer.MAX_VALUE ArithmeticUtils.gcd(Integer.MIN_VALUE, Integer.MIN_VALUE); Assert.fail("expecting MathArithmeticException"); } catch (MathArithmeticException expected) { // expected } } @Test public void testGcdConsistency() { int[] primeList = {19, 23, 53, 67, 73, 79, 101, 103, 111, 131}; ArrayList<Integer> primes = new ArrayList<Integer>(); for (int i = 0; i < primeList.length; i++) { primes.add(Integer.valueOf(primeList[i])); } RandomDataGenerator randomData = new RandomDataGenerator(); for (int i = 0; i < 20; i++) { Object[] sample = randomData.nextSample(primes, 4); int p1 = ((Integer) sample[0]).intValue(); int p2 = ((Integer) sample[1]).intValue(); int p3 = ((Integer) sample[2]).intValue(); int p4 = ((Integer) sample[3]).intValue(); int i1 = p1 * p2 * p3; int i2 = p1 * p2 * p4; int gcd = p1 * p2; Assert.assertEquals(gcd, ArithmeticUtils.gcd(i1, i2)); long l1 = i1; long l2 = i2; Assert.assertEquals(gcd, ArithmeticUtils.gcd(l1, l2)); } } @Test public void testGcdLong(){ long a = 30; long b = 50; long c = 77; Assert.assertEquals(0, ArithmeticUtils.gcd(0L, 0)); Assert.assertEquals(b, ArithmeticUtils.gcd(0, b)); Assert.assertEquals(a, ArithmeticUtils.gcd(a, 0)); Assert.assertEquals(b, ArithmeticUtils.gcd(0, -b)); Assert.assertEquals(a, ArithmeticUtils.gcd(-a, 0)); Assert.assertEquals(10, ArithmeticUtils.gcd(a, b)); Assert.assertEquals(10, ArithmeticUtils.gcd(-a, b)); Assert.assertEquals(10, ArithmeticUtils.gcd(a, -b)); Assert.assertEquals(10, ArithmeticUtils.gcd(-a, -b)); Assert.assertEquals(1, ArithmeticUtils.gcd(a, c)); Assert.assertEquals(1, ArithmeticUtils.gcd(-a, c)); Assert.assertEquals(1, ArithmeticUtils.gcd(a, -c)); Assert.assertEquals(1, ArithmeticUtils.gcd(-a, -c)); Assert.assertEquals(3L * (1L<<45), ArithmeticUtils.gcd(3L * (1L<<50), 9L * (1L<<45))); Assert.assertEquals(1L<<45, ArithmeticUtils.gcd(1L<<45, Long.MIN_VALUE)); Assert.assertEquals(Long.MAX_VALUE, ArithmeticUtils.gcd(Long.MAX_VALUE, 0L)); Assert.assertEquals(Long.MAX_VALUE, ArithmeticUtils.gcd(-Long.MAX_VALUE, 0L)); Assert.assertEquals(1, ArithmeticUtils.gcd(60247241209L, 153092023L)); try { // gcd(Long.MIN_VALUE, 0) > Long.MAX_VALUE ArithmeticUtils.gcd(Long.MIN_VALUE, 0); Assert.fail("expecting MathArithmeticException"); } catch (MathArithmeticException expected) { // expected } try { // gcd(0, Long.MIN_VALUE) > Long.MAX_VALUE ArithmeticUtils.gcd(0, Long.MIN_VALUE); Assert.fail("expecting MathArithmeticException"); } catch (MathArithmeticException expected) { // expected } try { // gcd(Long.MIN_VALUE, Long.MIN_VALUE) > Long.MAX_VALUE ArithmeticUtils.gcd(Long.MIN_VALUE, Long.MIN_VALUE); Assert.fail("expecting MathArithmeticException"); } catch (MathArithmeticException expected) { // expected } } @Test public void testLcm() { int a = 30; int b = 50; int c = 77; Assert.assertEquals(0, ArithmeticUtils.lcm(0, b)); Assert.assertEquals(0, ArithmeticUtils.lcm(a, 0)); Assert.assertEquals(b, ArithmeticUtils.lcm(1, b)); Assert.assertEquals(a, ArithmeticUtils.lcm(a, 1)); Assert.assertEquals(150, ArithmeticUtils.lcm(a, b)); Assert.assertEquals(150, ArithmeticUtils.lcm(-a, b)); Assert.assertEquals(150, ArithmeticUtils.lcm(a, -b)); Assert.assertEquals(150, ArithmeticUtils.lcm(-a, -b)); Assert.assertEquals(2310, ArithmeticUtils.lcm(a, c)); // Assert that no intermediate value overflows: // The naive implementation of lcm(a,b) would be (a*b)/gcd(a,b) Assert.assertEquals((1<<20)*15, ArithmeticUtils.lcm((1<<20)*3, (1<<20)*5)); // Special case Assert.assertEquals(0, ArithmeticUtils.lcm(0, 0)); try { // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int ArithmeticUtils.lcm(Integer.MIN_VALUE, 1); Assert.fail("Expecting MathArithmeticException"); } catch (MathArithmeticException expected) { // expected } try { // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int ArithmeticUtils.lcm(Integer.MIN_VALUE, 1<<20); Assert.fail("Expecting MathArithmeticException"); } catch (MathArithmeticException expected) { // expected } try { ArithmeticUtils.lcm(Integer.MAX_VALUE, Integer.MAX_VALUE - 1); Assert.fail("Expecting MathArithmeticException"); } catch (MathArithmeticException expected) { // expected } } @Test public void testLcmLong() { long a = 30; long b = 50; long c = 77; Assert.assertEquals(0, ArithmeticUtils.lcm(0, b)); Assert.assertEquals(0, ArithmeticUtils.lcm(a, 0)); Assert.assertEquals(b, ArithmeticUtils.lcm(1, b)); Assert.assertEquals(a, ArithmeticUtils.lcm(a, 1)); Assert.assertEquals(150, ArithmeticUtils.lcm(a, b)); Assert.assertEquals(150, ArithmeticUtils.lcm(-a, b)); Assert.assertEquals(150, ArithmeticUtils.lcm(a, -b)); Assert.assertEquals(150, ArithmeticUtils.lcm(-a, -b)); Assert.assertEquals(2310, ArithmeticUtils.lcm(a, c)); Assert.assertEquals(Long.MAX_VALUE, ArithmeticUtils.lcm(60247241209L, 153092023L)); // Assert that no intermediate value overflows: // The naive implementation of lcm(a,b) would be (a*b)/gcd(a,b) Assert.assertEquals((1L<<50)*15, ArithmeticUtils.lcm((1L<<45)*3, (1L<<50)*5)); // Special case Assert.assertEquals(0L, ArithmeticUtils.lcm(0L, 0L)); try { // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int ArithmeticUtils.lcm(Long.MIN_VALUE, 1); Assert.fail("Expecting MathArithmeticException"); } catch (MathArithmeticException expected) { // expected } try { // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int ArithmeticUtils.lcm(Long.MIN_VALUE, 1<<20); Assert.fail("Expecting MathArithmeticException"); } catch (MathArithmeticException expected) { // expected } Assert.assertEquals((long) Integer.MAX_VALUE * (Integer.MAX_VALUE - 1), ArithmeticUtils.lcm((long)Integer.MAX_VALUE, Integer.MAX_VALUE - 1)); try { ArithmeticUtils.lcm(Long.MAX_VALUE, Long.MAX_VALUE - 1); Assert.fail("Expecting MathArithmeticException"); } catch (MathArithmeticException expected) { // expected } } @Test public void testMulAndCheck() { int big = Integer.MAX_VALUE; int bigNeg = Integer.MIN_VALUE; Assert.assertEquals(big, ArithmeticUtils.mulAndCheck(big, 1)); try { ArithmeticUtils.mulAndCheck(big, 2); Assert.fail("Expecting MathArithmeticException"); } catch (MathArithmeticException ex) { } try { ArithmeticUtils.mulAndCheck(bigNeg, 2); Assert.fail("Expecting MathArithmeticException"); } catch (MathArithmeticException ex) { } } @Test public void testMulAndCheckLong() { long max = Long.MAX_VALUE; long min = Long.MIN_VALUE; Assert.assertEquals(max, ArithmeticUtils.mulAndCheck(max, 1L)); Assert.assertEquals(min, ArithmeticUtils.mulAndCheck(min, 1L)); Assert.assertEquals(0L, ArithmeticUtils.mulAndCheck(max, 0L)); Assert.assertEquals(0L, ArithmeticUtils.mulAndCheck(min, 0L)); Assert.assertEquals(max, ArithmeticUtils.mulAndCheck(1L, max)); Assert.assertEquals(min, ArithmeticUtils.mulAndCheck(1L, min)); Assert.assertEquals(0L, ArithmeticUtils.mulAndCheck(0L, max)); Assert.assertEquals(0L, ArithmeticUtils.mulAndCheck(0L, min)); Assert.assertEquals(1L, ArithmeticUtils.mulAndCheck(-1L, -1L)); Assert.assertEquals(min, ArithmeticUtils.mulAndCheck(min / 2, 2)); testMulAndCheckLongFailure(max, 2L); testMulAndCheckLongFailure(2L, max); testMulAndCheckLongFailure(min, 2L); testMulAndCheckLongFailure(2L, min); testMulAndCheckLongFailure(min, -1L); testMulAndCheckLongFailure(-1L, min); } @Test public void testSubAndCheck() { int big = Integer.MAX_VALUE; int bigNeg = Integer.MIN_VALUE; Assert.assertEquals(big, ArithmeticUtils.subAndCheck(big, 0)); Assert.assertEquals(bigNeg + 1, ArithmeticUtils.subAndCheck(bigNeg, -1)); Assert.assertEquals(-1, ArithmeticUtils.subAndCheck(bigNeg, -big)); try { ArithmeticUtils.subAndCheck(big, -1); Assert.fail("Expecting MathArithmeticException"); } catch (MathArithmeticException ex) { } try { ArithmeticUtils.subAndCheck(bigNeg, 1); Assert.fail("Expecting MathArithmeticException"); } catch (MathArithmeticException ex) { } } @Test public void testSubAndCheckErrorMessage() { int big = Integer.MAX_VALUE; try { ArithmeticUtils.subAndCheck(big, -1); Assert.fail("Expecting MathArithmeticException"); } catch (MathArithmeticException ex) { Assert.assertTrue(ex.getMessage().length() > 1); } } @Test public void testSubAndCheckLong() { long max = Long.MAX_VALUE; long min = Long.MIN_VALUE; Assert.assertEquals(max, ArithmeticUtils.subAndCheck(max, 0)); Assert.assertEquals(min, ArithmeticUtils.subAndCheck(min, 0)); Assert.assertEquals(-max, ArithmeticUtils.subAndCheck(0, max)); Assert.assertEquals(min + 1, ArithmeticUtils.subAndCheck(min, -1)); // min == -1-max Assert.assertEquals(-1, ArithmeticUtils.subAndCheck(-max - 1, -max)); Assert.assertEquals(max, ArithmeticUtils.subAndCheck(-1, -1 - max)); testSubAndCheckLongFailure(0L, min); testSubAndCheckLongFailure(max, -1L); testSubAndCheckLongFailure(min, 1L); } @Test public void testPow() { Assert.assertEquals(1801088541, ArithmeticUtils.pow(21, 7)); Assert.assertEquals(1, ArithmeticUtils.pow(21, 0)); try { ArithmeticUtils.pow(21, -7); Assert.fail("Expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException e) { // expected behavior } Assert.assertEquals(1801088541, ArithmeticUtils.pow(21, 7l)); Assert.assertEquals(1, ArithmeticUtils.pow(21, 0l)); try { ArithmeticUtils.pow(21, -7l); Assert.fail("Expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException e) { // expected behavior } Assert.assertEquals(1801088541l, ArithmeticUtils.pow(21l, 7)); Assert.assertEquals(1l, ArithmeticUtils.pow(21l, 0)); try { ArithmeticUtils.pow(21l, -7); Assert.fail("Expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException e) { // expected behavior } Assert.assertEquals(1801088541l, ArithmeticUtils.pow(21l, 7l)); Assert.assertEquals(1l, ArithmeticUtils.pow(21l, 0l)); try { ArithmeticUtils.pow(21l, -7l); Assert.fail("Expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException e) { // expected behavior } BigInteger twentyOne = BigInteger.valueOf(21l); Assert.assertEquals(BigInteger.valueOf(1801088541l), ArithmeticUtils.pow(twentyOne, 7)); Assert.assertEquals(BigInteger.ONE, ArithmeticUtils.pow(twentyOne, 0)); try { ArithmeticUtils.pow(twentyOne, -7); Assert.fail("Expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException e) { // expected behavior } Assert.assertEquals(BigInteger.valueOf(1801088541l), ArithmeticUtils.pow(twentyOne, 7l)); Assert.assertEquals(BigInteger.ONE, ArithmeticUtils.pow(twentyOne, 0l)); try { ArithmeticUtils.pow(twentyOne, -7l); Assert.fail("Expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException e) { // expected behavior } Assert.assertEquals(BigInteger.valueOf(1801088541l), ArithmeticUtils.pow(twentyOne, BigInteger.valueOf(7l))); Assert.assertEquals(BigInteger.ONE, ArithmeticUtils.pow(twentyOne, BigInteger.ZERO)); try { ArithmeticUtils.pow(twentyOne, BigInteger.valueOf(-7l)); Assert.fail("Expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException e) { // expected behavior } BigInteger bigOne = new BigInteger("1543786922199448028351389769265814882661837148" + "4763915343722775611762713982220306372888519211" + "560905579993523402015636025177602059044911261"); Assert.assertEquals(bigOne, ArithmeticUtils.pow(twentyOne, 103)); Assert.assertEquals(bigOne, ArithmeticUtils.pow(twentyOne, 103l)); Assert.assertEquals(bigOne, ArithmeticUtils.pow(twentyOne, BigInteger.valueOf(103l))); } @Test public void testIsPowerOfTwo() { final int n = 1025; final boolean[] expected = new boolean[n]; Arrays.fill(expected, false); for (int i = 1; i < expected.length; i *= 2) { expected[i] = true; } for (int i = 0; i < expected.length; i++) { final boolean actual = ArithmeticUtils.isPowerOfTwo(i); Assert.assertTrue(Integer.toString(i), actual == expected[i]); } } private void testAddAndCheckLongFailure(long a, long b) { try { ArithmeticUtils.addAndCheck(a, b); Assert.fail("Expecting MathArithmeticException"); } catch (MathArithmeticException ex) { // success } } private void testMulAndCheckLongFailure(long a, long b) { try { ArithmeticUtils.mulAndCheck(a, b); Assert.fail("Expecting MathArithmeticException"); } catch (MathArithmeticException ex) { // success } } private void testSubAndCheckLongFailure(long a, long b) { try { ArithmeticUtils.subAndCheck(a, b); Assert.fail("Expecting MathArithmeticException"); } catch (MathArithmeticException ex) { // success } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.util; import org.apache.commons.math3.TestUtils; import org.junit.Assert; import org.junit.Test; public class BigRealFieldTest { @Test public void testZero() { Assert.assertEquals(BigReal.ZERO, BigRealField.getInstance().getZero()); } @Test public void testOne() { Assert.assertEquals(BigReal.ONE, BigRealField.getInstance().getOne()); } @Test public void testSerial() { // deserializing the singleton should give the singleton itself back BigRealField field = BigRealField.getInstance(); Assert.assertTrue(field == TestUtils.serializeAndRecover(field)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.util; import java.math.BigDecimal; import java.math.BigInteger; import java.math.MathContext; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.exception.MathArithmeticException; import org.junit.Assert; import org.junit.Test; public class BigRealTest { @Test public void testConstructor() { Assert.assertEquals(1.625, new BigReal(new BigDecimal("1.625")).doubleValue(), 1.0e-15); Assert.assertEquals(-5.0, new BigReal(new BigInteger("-5")).doubleValue(), 1.0e-15); Assert.assertEquals(-5.0, new BigReal(new BigInteger("-5"), MathContext.DECIMAL64) .doubleValue(), 1.0e-15); Assert .assertEquals(0.125, new BigReal(new BigInteger("125"), 3).doubleValue(), 1.0e-15); Assert.assertEquals(0.125, new BigReal(new BigInteger("125"), 3, MathContext.DECIMAL64) .doubleValue(), 1.0e-15); Assert.assertEquals(1.625, new BigReal(new char[] { '1', '.', '6', '2', '5' }).doubleValue(), 1.0e-15); Assert.assertEquals(1.625, new BigReal(new char[] { 'A', 'A', '1', '.', '6', '2', '5', '9' }, 2, 5).doubleValue(), 1.0e-15); Assert.assertEquals(1.625, new BigReal(new char[] { 'A', 'A', '1', '.', '6', '2', '5', '9' }, 2, 5, MathContext.DECIMAL64).doubleValue(), 1.0e-15); Assert.assertEquals(1.625, new BigReal(new char[] { '1', '.', '6', '2', '5' }, MathContext.DECIMAL64).doubleValue(), 1.0e-15); Assert.assertEquals(1.625, new BigReal(1.625).doubleValue(), 1.0e-15); Assert.assertEquals(1.625, new BigReal(1.625, MathContext.DECIMAL64) .doubleValue(), 1.0e-15); Assert.assertEquals(-5.0, new BigReal(-5).doubleValue(), 1.0e-15); Assert.assertEquals(-5.0, new BigReal(-5, MathContext.DECIMAL64) .doubleValue(), 1.0e-15); Assert.assertEquals(-5.0, new BigReal(-5l).doubleValue(), 1.0e-15); Assert.assertEquals(-5.0, new BigReal(-5l, MathContext.DECIMAL64) .doubleValue(), 1.0e-15); Assert.assertEquals(1.625, new BigReal("1.625").doubleValue(), 1.0e-15); Assert.assertEquals(1.625, new BigReal("1.625", MathContext.DECIMAL64) .doubleValue(), 1.0e-15); } @Test public void testCompareTo() { BigReal first = new BigReal(1.0 / 2.0); BigReal second = new BigReal(1.0 / 3.0); BigReal third = new BigReal(1.0 / 2.0); Assert.assertEquals(0, first.compareTo(first)); Assert.assertEquals(0, first.compareTo(third)); Assert.assertEquals(1, first.compareTo(second)); Assert.assertEquals(-1, second.compareTo(first)); } @Test public void testAdd() { BigReal a = new BigReal("1.2345678"); BigReal b = new BigReal("8.7654321"); Assert.assertEquals(9.9999999, a.add(b).doubleValue(), 1.0e-15); } @Test public void testSubtract() { BigReal a = new BigReal("1.2345678"); BigReal b = new BigReal("8.7654321"); Assert.assertEquals(-7.5308643, a.subtract(b).doubleValue(), 1.0e-15); } @Test public void testNegate() { BigReal a = new BigReal("1.2345678"); BigReal zero = new BigReal("0.0000000"); Assert.assertEquals(a.negate().add(a), zero); Assert.assertEquals(a.add(a.negate()), zero); Assert.assertEquals(zero, zero.negate()); } @Test public void testDivide() { BigReal a = new BigReal("1.0000000000"); BigReal b = new BigReal("0.0009765625"); Assert.assertEquals(1024.0, a.divide(b).doubleValue(), 1.0e-15); } @Test(expected = MathArithmeticException.class) public void testDivisionByZero() { final BigReal a = BigReal.ONE; final BigReal b = BigReal.ZERO; a.divide(b); } @Test public void testReciprocal() { BigReal a = new BigReal("1.2345678"); double eps = FastMath.pow(10., -a.getScale()); BigReal one = new BigReal("1.0000000"); BigReal b = a.reciprocal(); BigReal r = one.subtract(a.multiply(b)); Assert.assertTrue(FastMath.abs(r.doubleValue()) <= eps); r = one.subtract(b.multiply(a)); Assert.assertTrue(FastMath.abs(r.doubleValue()) <= eps); } @Test(expected = MathArithmeticException.class) public void testReciprocalOfZero() { BigReal.ZERO.reciprocal(); } @Test public void testMultiply() { BigReal a = new BigReal("1024.0"); BigReal b = new BigReal("0.0009765625"); Assert.assertEquals(1.0, a.multiply(b).doubleValue(), 1.0e-15); int n = 1024; Assert.assertEquals(1.0, b.multiply(n).doubleValue(), 1.0e-15); } @Test public void testDoubleValue() { Assert.assertEquals(0.5, new BigReal(0.5).doubleValue(), 1.0e-15); } @Test public void testBigDecimalValue() { BigDecimal pi = new BigDecimal( "3.1415926535897932384626433832795028841971693993751"); Assert.assertEquals(pi, new BigReal(pi).bigDecimalValue()); Assert.assertEquals(new BigDecimal(0.5), new BigReal(1.0 / 2.0).bigDecimalValue()); } @Test public void testEqualsAndHashCode() { BigReal zero = new BigReal(0.0); BigReal nullReal = null; Assert.assertTrue(zero.equals(zero)); Assert.assertFalse(zero.equals(nullReal)); Assert.assertFalse(zero.equals(Double.valueOf(0))); BigReal zero2 = new BigReal(0.0); Assert.assertTrue(zero.equals(zero2)); Assert.assertEquals(zero.hashCode(), zero2.hashCode()); BigReal one = new BigReal(1.0); Assert.assertFalse((one.equals(zero) || zero.equals(one))); Assert.assertTrue(one.equals(BigReal.ONE)); } @Test public void testSerial() { BigReal[] Reals = { new BigReal(3.0), BigReal.ONE, BigReal.ZERO, new BigReal(17), new BigReal(FastMath.PI), new BigReal(-2.5) }; for (BigReal Real : Reals) { Assert.assertEquals(Real, TestUtils.serializeAndRecover(Real)); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.util; import java.util.ArrayList; import java.util.HashMap; import java.util.Iterator; import java.util.List; import java.util.Map; import org.apache.commons.math3.exception.MathArithmeticException; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.exception.NotPositiveException; import org.apache.commons.math3.exception.NumberIsTooLargeException; import org.junit.Assert; import org.junit.Test; /** * Test cases for the {@link CombinatoricsUtils} class. * * @version $Id: $ */ public class CombinatoricsUtilsTest { /** cached binomial coefficients */ private static final List<Map<Integer, Long>> binomialCache = new ArrayList<Map<Integer, Long>>(); /** Verify that b(0,0) = 1 */ @Test public void test0Choose0() { Assert.assertEquals(CombinatoricsUtils.binomialCoefficientDouble(0, 0), 1d, 0); Assert.assertEquals(CombinatoricsUtils.binomialCoefficientLog(0, 0), 0d, 0); Assert.assertEquals(CombinatoricsUtils.binomialCoefficient(0, 0), 1); } @Test public void testBinomialCoefficient() { long[] bcoef5 = { 1, 5, 10, 10, 5, 1 }; long[] bcoef6 = { 1, 6, 15, 20, 15, 6, 1 }; for (int i = 0; i < 6; i++) { Assert.assertEquals("5 choose " + i, bcoef5[i], CombinatoricsUtils.binomialCoefficient(5, i)); } for (int i = 0; i < 7; i++) { Assert.assertEquals("6 choose " + i, bcoef6[i], CombinatoricsUtils.binomialCoefficient(6, i)); } for (int n = 1; n < 10; n++) { for (int k = 0; k <= n; k++) { Assert.assertEquals(n + " choose " + k, binomialCoefficient(n, k), CombinatoricsUtils.binomialCoefficient(n, k)); Assert.assertEquals(n + " choose " + k, binomialCoefficient(n, k), CombinatoricsUtils.binomialCoefficientDouble(n, k), Double.MIN_VALUE); Assert.assertEquals(n + " choose " + k, FastMath.log(binomialCoefficient(n, k)), CombinatoricsUtils.binomialCoefficientLog(n, k), 10E-12); } } int[] n = { 34, 66, 100, 1500, 1500 }; int[] k = { 17, 33, 10, 1500 - 4, 4 }; for (int i = 0; i < n.length; i++) { long expected = binomialCoefficient(n[i], k[i]); Assert.assertEquals(n[i] + " choose " + k[i], expected, CombinatoricsUtils.binomialCoefficient(n[i], k[i])); Assert.assertEquals(n[i] + " choose " + k[i], expected, CombinatoricsUtils.binomialCoefficientDouble(n[i], k[i]), 0.0); Assert.assertEquals("log(" + n[i] + " choose " + k[i] + ")", FastMath.log(expected), CombinatoricsUtils.binomialCoefficientLog(n[i], k[i]), 0.0); } } @Test public void testBinomialCoefficientFail() { try { CombinatoricsUtils.binomialCoefficient(4, 5); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } try { CombinatoricsUtils.binomialCoefficientDouble(4, 5); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } try { CombinatoricsUtils.binomialCoefficientLog(4, 5); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } try { CombinatoricsUtils.binomialCoefficient(-1, -2); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } try { CombinatoricsUtils.binomialCoefficientDouble(-1, -2); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } try { CombinatoricsUtils.binomialCoefficientLog(-1, -2); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } try { CombinatoricsUtils.binomialCoefficient(67, 30); Assert.fail("expecting MathArithmeticException"); } catch (MathArithmeticException ex) { // ignored } try { CombinatoricsUtils.binomialCoefficient(67, 34); Assert.fail("expecting MathArithmeticException"); } catch (MathArithmeticException ex) { // ignored } double x = CombinatoricsUtils.binomialCoefficientDouble(1030, 515); Assert.assertTrue("expecting infinite binomial coefficient", Double .isInfinite(x)); } /** * Tests correctness for large n and sharpness of upper bound in API doc * JIRA: MATH-241 */ @Test public void testBinomialCoefficientLarge() throws Exception { // This tests all legal and illegal values for n <= 200. for (int n = 0; n <= 200; n++) { for (int k = 0; k <= n; k++) { long ourResult = -1; long exactResult = -1; boolean shouldThrow = false; boolean didThrow = false; try { ourResult = CombinatoricsUtils.binomialCoefficient(n, k); } catch (MathArithmeticException ex) { didThrow = true; } try { exactResult = binomialCoefficient(n, k); } catch (MathArithmeticException ex) { shouldThrow = true; } Assert.assertEquals(n + " choose " + k, exactResult, ourResult); Assert.assertEquals(n + " choose " + k, shouldThrow, didThrow); Assert.assertTrue(n + " choose " + k, (n > 66 || !didThrow)); if (!shouldThrow && exactResult > 1) { Assert.assertEquals(n + " choose " + k, 1., CombinatoricsUtils.binomialCoefficientDouble(n, k) / exactResult, 1e-10); Assert.assertEquals(n + " choose " + k, 1, CombinatoricsUtils.binomialCoefficientLog(n, k) / FastMath.log(exactResult), 1e-10); } } } long ourResult = CombinatoricsUtils.binomialCoefficient(300, 3); long exactResult = binomialCoefficient(300, 3); Assert.assertEquals(exactResult, ourResult); ourResult = CombinatoricsUtils.binomialCoefficient(700, 697); exactResult = binomialCoefficient(700, 697); Assert.assertEquals(exactResult, ourResult); // This one should throw try { CombinatoricsUtils.binomialCoefficient(700, 300); Assert.fail("Expecting MathArithmeticException"); } catch (MathArithmeticException ex) { // Expected } int n = 10000; ourResult = CombinatoricsUtils.binomialCoefficient(n, 3); exactResult = binomialCoefficient(n, 3); Assert.assertEquals(exactResult, ourResult); Assert.assertEquals(1, CombinatoricsUtils.binomialCoefficientDouble(n, 3) / exactResult, 1e-10); Assert.assertEquals(1, CombinatoricsUtils.binomialCoefficientLog(n, 3) / FastMath.log(exactResult), 1e-10); } @Test public void testFactorial() { for (int i = 1; i < 21; i++) { Assert.assertEquals(i + "! ", factorial(i), CombinatoricsUtils.factorial(i)); Assert.assertEquals(i + "! ", factorial(i), CombinatoricsUtils.factorialDouble(i), Double.MIN_VALUE); Assert.assertEquals(i + "! ", FastMath.log(factorial(i)), CombinatoricsUtils.factorialLog(i), 10E-12); } Assert.assertEquals("0", 1, CombinatoricsUtils.factorial(0)); Assert.assertEquals("0", 1.0d, CombinatoricsUtils.factorialDouble(0), 1E-14); Assert.assertEquals("0", 0.0d, CombinatoricsUtils.factorialLog(0), 1E-14); } @Test public void testFactorialFail() { try { CombinatoricsUtils.factorial(-1); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } try { CombinatoricsUtils.factorialDouble(-1); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } try { CombinatoricsUtils.factorialLog(-1); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } try { CombinatoricsUtils.factorial(21); Assert.fail("expecting MathArithmeticException"); } catch (MathArithmeticException ex) { // ignored } Assert.assertTrue("expecting infinite factorial value", Double.isInfinite(CombinatoricsUtils.factorialDouble(171))); } @Test public void testStirlingS2() { Assert.assertEquals(1, CombinatoricsUtils.stirlingS2(0, 0)); for (int n = 1; n < 30; ++n) { Assert.assertEquals(0, CombinatoricsUtils.stirlingS2(n, 0)); Assert.assertEquals(1, CombinatoricsUtils.stirlingS2(n, 1)); if (n > 2) { Assert.assertEquals((1l << (n - 1)) - 1l, CombinatoricsUtils.stirlingS2(n, 2)); Assert.assertEquals(CombinatoricsUtils.binomialCoefficient(n, 2), CombinatoricsUtils.stirlingS2(n, n - 1)); } Assert.assertEquals(1, CombinatoricsUtils.stirlingS2(n, n)); } Assert.assertEquals(536870911l, CombinatoricsUtils.stirlingS2(30, 2)); Assert.assertEquals(576460752303423487l, CombinatoricsUtils.stirlingS2(60, 2)); Assert.assertEquals( 25, CombinatoricsUtils.stirlingS2( 5, 3)); Assert.assertEquals( 90, CombinatoricsUtils.stirlingS2( 6, 3)); Assert.assertEquals( 65, CombinatoricsUtils.stirlingS2( 6, 4)); Assert.assertEquals( 301, CombinatoricsUtils.stirlingS2( 7, 3)); Assert.assertEquals( 350, CombinatoricsUtils.stirlingS2( 7, 4)); Assert.assertEquals( 140, CombinatoricsUtils.stirlingS2( 7, 5)); Assert.assertEquals( 966, CombinatoricsUtils.stirlingS2( 8, 3)); Assert.assertEquals( 1701, CombinatoricsUtils.stirlingS2( 8, 4)); Assert.assertEquals( 1050, CombinatoricsUtils.stirlingS2( 8, 5)); Assert.assertEquals( 266, CombinatoricsUtils.stirlingS2( 8, 6)); Assert.assertEquals( 3025, CombinatoricsUtils.stirlingS2( 9, 3)); Assert.assertEquals( 7770, CombinatoricsUtils.stirlingS2( 9, 4)); Assert.assertEquals( 6951, CombinatoricsUtils.stirlingS2( 9, 5)); Assert.assertEquals( 2646, CombinatoricsUtils.stirlingS2( 9, 6)); Assert.assertEquals( 462, CombinatoricsUtils.stirlingS2( 9, 7)); Assert.assertEquals( 9330, CombinatoricsUtils.stirlingS2(10, 3)); Assert.assertEquals(34105, CombinatoricsUtils.stirlingS2(10, 4)); Assert.assertEquals(42525, CombinatoricsUtils.stirlingS2(10, 5)); Assert.assertEquals(22827, CombinatoricsUtils.stirlingS2(10, 6)); Assert.assertEquals( 5880, CombinatoricsUtils.stirlingS2(10, 7)); Assert.assertEquals( 750, CombinatoricsUtils.stirlingS2(10, 8)); } @Test(expected=NotPositiveException.class) public void testStirlingS2NegativeN() { CombinatoricsUtils.stirlingS2(3, -1); } @Test(expected=NumberIsTooLargeException.class) public void testStirlingS2LargeK() { CombinatoricsUtils.stirlingS2(3, 4); } @Test(expected=MathArithmeticException.class) public void testStirlingS2Overflow() { CombinatoricsUtils.stirlingS2(26, 9); } /** * Exact (caching) recursive implementation to test against */ private long binomialCoefficient(int n, int k) throws MathArithmeticException { if (binomialCache.size() > n) { Long cachedResult = binomialCache.get(n).get(Integer.valueOf(k)); if (cachedResult != null) { return cachedResult.longValue(); } } long result = -1; if ((n == k) || (k == 0)) { result = 1; } else if ((k == 1) || (k == n - 1)) { result = n; } else { // Reduce stack depth for larger values of n if (k < n - 100) { binomialCoefficient(n - 100, k); } if (k > 100) { binomialCoefficient(n - 100, k - 100); } result = ArithmeticUtils.addAndCheck(binomialCoefficient(n - 1, k - 1), binomialCoefficient(n - 1, k)); } if (result == -1) { throw new MathArithmeticException(); } for (int i = binomialCache.size(); i < n + 1; i++) { binomialCache.add(new HashMap<Integer, Long>()); } binomialCache.get(n).put(Integer.valueOf(k), Long.valueOf(result)); return result; } /** * Exact direct multiplication implementation to test against */ private long factorial(int n) { long result = 1; for (int i = 2; i <= n; i++) { result *= i; } return result; } @Test public void testCombinationsIterator() { Iterator<int[]> combinationsIterator = CombinatoricsUtils.combinationsIterator(5, 3); checkIterator(combinationsIterator, 5, 3); combinationsIterator = CombinatoricsUtils.combinationsIterator(6, 4); checkIterator(combinationsIterator, 6, 4); combinationsIterator = CombinatoricsUtils.combinationsIterator(8, 2); checkIterator(combinationsIterator, 8, 2); combinationsIterator = CombinatoricsUtils.combinationsIterator(6, 1); checkIterator(combinationsIterator, 6, 1); combinationsIterator = CombinatoricsUtils.combinationsIterator(3, 3); checkIterator(combinationsIterator, 3, 3); combinationsIterator = CombinatoricsUtils.combinationsIterator(1, 1); checkIterator(combinationsIterator, 1, 1); combinationsIterator = CombinatoricsUtils.combinationsIterator(1, 1); checkIterator(combinationsIterator, 1, 1); combinationsIterator = CombinatoricsUtils.combinationsIterator(1, 0); checkIterator(combinationsIterator, 1, 0); combinationsIterator = CombinatoricsUtils.combinationsIterator(0, 0); checkIterator(combinationsIterator, 0, 0); combinationsIterator = CombinatoricsUtils.combinationsIterator(4, 2); checkIterator(combinationsIterator, 4, 2); combinationsIterator = CombinatoricsUtils.combinationsIterator(123, 2); checkIterator(combinationsIterator, 123, 2); } /** * Verifies that the iterator generates a lexicographically * increasing sequence of b(n,k) arrays, each having length k * and each array itself increasing. * * @param iterator * @param n size of universe * @param k size of subsets */ private void checkIterator(Iterator<int[]> iterator, int n, int k) { long lastLex = -1; long length = 0; while (iterator.hasNext()) { final int[] iterate = iterator.next(); Assert.assertEquals(k, iterate.length); final long curLex = lexNorm(iterate, n); Assert.assertTrue(curLex > lastLex); lastLex = curLex; length++; for (int i = 1; i < iterate.length; i++) { Assert.assertTrue(iterate[i] > iterate[i - 1]); } } Assert.assertEquals(CombinatoricsUtils.binomialCoefficient(n, k), length); } @Test public void testCombinationsIteratorFail() { try { CombinatoricsUtils.combinationsIterator(4, 5); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } try { CombinatoricsUtils.combinationsIterator(-1, -2); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) { // ignored } } /** * Returns the value represented by the digits in the input array in reverse order. * For example [3,2,1] returns 123. * * @param iterate input array * @param n size of universe * @return lexicographic norm */ private long lexNorm(int[] iterate, int n) { long ret = 0; for (int i = iterate.length - 1; i >= 0; i--) { ret += iterate[i] * ArithmeticUtils.pow(n, (long) i); } return ret; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.util; import org.junit.Assert; import org.junit.Test; /** * @version $Id$ */ public class ContinuedFractionTest { @Test public void testGoldenRatio() throws Exception { ContinuedFraction cf = new ContinuedFraction() { @Override public double getA(int n, double x) { return 1.0; } @Override public double getB(int n, double x) { return 1.0; } }; double gr = cf.evaluate(0.0, 10e-9); Assert.assertEquals(1.61803399, gr, 10e-9); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.util; import org.apache.commons.math3.ExtendedFieldElementAbstractTest; import org.junit.Assert; import org.junit.Test; public class Decimal64Test extends ExtendedFieldElementAbstractTest<Decimal64> { public static final double X = 1.2345; public static final Decimal64 PLUS_X = new Decimal64(X); public static final Decimal64 MINUS_X = new Decimal64(-X); public static final double Y = 6.789; public static final Decimal64 PLUS_Y = new Decimal64(Y); public static final Decimal64 MINUS_Y = new Decimal64(-Y); public static final Decimal64 PLUS_ZERO = new Decimal64(0.0); public static final Decimal64 MINUS_ZERO = new Decimal64(-0.0); @Override protected Decimal64 build(final double x) { return new Decimal64(x); } @Test public void testAdd() { Decimal64 expected, actual; expected = new Decimal64(X + Y); actual = PLUS_X.add(PLUS_Y); Assert.assertEquals(expected, actual); actual = PLUS_Y.add(PLUS_X); Assert.assertEquals(expected, actual); expected = new Decimal64(X + (-Y)); actual = PLUS_X.add(MINUS_Y); Assert.assertEquals(expected, actual); actual = MINUS_Y.add(PLUS_X); Assert.assertEquals(expected, actual); expected = new Decimal64((-X) + (-Y)); actual = MINUS_X.add(MINUS_Y); Assert.assertEquals(expected, actual); actual = MINUS_Y.add(MINUS_X); Assert.assertEquals(expected, actual); expected = Decimal64.POSITIVE_INFINITY; actual = PLUS_X.add(Decimal64.POSITIVE_INFINITY); Assert.assertEquals(expected, actual); actual = Decimal64.POSITIVE_INFINITY.add(PLUS_X); Assert.assertEquals(expected, actual); actual = MINUS_X.add(Decimal64.POSITIVE_INFINITY); Assert.assertEquals(expected, actual); actual = Decimal64.POSITIVE_INFINITY.add(MINUS_X); Assert.assertEquals(expected, actual); actual = Decimal64.POSITIVE_INFINITY.add(Decimal64.POSITIVE_INFINITY); Assert.assertEquals(expected, actual); expected = Decimal64.NEGATIVE_INFINITY; actual = PLUS_X.add(Decimal64.NEGATIVE_INFINITY); Assert.assertEquals(expected, actual); actual = Decimal64.NEGATIVE_INFINITY.add(PLUS_X); Assert.assertEquals(expected, actual); actual = Decimal64.NEGATIVE_INFINITY.add(Decimal64.NEGATIVE_INFINITY); Assert.assertEquals(expected, actual); actual = MINUS_X.add(Decimal64.NEGATIVE_INFINITY); Assert.assertEquals(expected, actual); actual = Decimal64.NEGATIVE_INFINITY.add(MINUS_X); Assert.assertEquals(expected, actual); expected = Decimal64.NAN; actual = Decimal64.POSITIVE_INFINITY.add(Decimal64.NEGATIVE_INFINITY); Assert.assertEquals(expected, actual); actual = Decimal64.NEGATIVE_INFINITY.add(Decimal64.POSITIVE_INFINITY); Assert.assertEquals(expected, actual); actual = PLUS_X.add(Decimal64.NAN); Assert.assertEquals(expected, actual); actual = Decimal64.NAN.add(PLUS_X); Assert.assertEquals(expected, actual); actual = MINUS_X.add(Decimal64.NAN); Assert.assertEquals(expected, actual); actual = Decimal64.NAN.add(MINUS_X); Assert.assertEquals(expected, actual); actual = Decimal64.POSITIVE_INFINITY.add(Decimal64.NAN); Assert.assertEquals(expected, actual); actual = Decimal64.NAN.add(Decimal64.POSITIVE_INFINITY); Assert.assertEquals(expected, actual); actual = Decimal64.NEGATIVE_INFINITY.add(Decimal64.NAN); Assert.assertEquals(expected, actual); actual = Decimal64.NAN.add(Decimal64.NEGATIVE_INFINITY); Assert.assertEquals(expected, actual); actual = Decimal64.NAN.add(Decimal64.NAN); Assert.assertEquals(expected, actual); } @Test public void testSubtract() { Decimal64 expected, actual; expected = new Decimal64(X - Y); actual = PLUS_X.subtract(PLUS_Y); Assert.assertEquals(expected, actual); expected = new Decimal64(X - (-Y)); actual = PLUS_X.subtract(MINUS_Y); Assert.assertEquals(expected, actual); expected = new Decimal64((-X) - Y); actual = MINUS_X.subtract(PLUS_Y); Assert.assertEquals(expected, actual); expected = new Decimal64((-X) - (-Y)); actual = MINUS_X.subtract(MINUS_Y); Assert.assertEquals(expected, actual); expected = Decimal64.NEGATIVE_INFINITY; actual = PLUS_X.subtract(Decimal64.POSITIVE_INFINITY); Assert.assertEquals(expected, actual); actual = MINUS_X.subtract(Decimal64.POSITIVE_INFINITY); Assert.assertEquals(expected, actual); actual = Decimal64.NEGATIVE_INFINITY .subtract(Decimal64.POSITIVE_INFINITY); Assert.assertEquals(expected, actual); expected = Decimal64.POSITIVE_INFINITY; actual = PLUS_X.subtract(Decimal64.NEGATIVE_INFINITY); Assert.assertEquals(expected, actual); actual = MINUS_X.subtract(Decimal64.NEGATIVE_INFINITY); Assert.assertEquals(expected, actual); actual = Decimal64.POSITIVE_INFINITY .subtract(Decimal64.NEGATIVE_INFINITY); Assert.assertEquals(expected, actual); expected = Decimal64.NAN; actual = Decimal64.POSITIVE_INFINITY .subtract(Decimal64.POSITIVE_INFINITY); Assert.assertEquals(expected, actual); actual = Decimal64.NEGATIVE_INFINITY .subtract(Decimal64.NEGATIVE_INFINITY); Assert.assertEquals(expected, actual); actual = PLUS_X.subtract(Decimal64.NAN); Assert.assertEquals(expected, actual); actual = Decimal64.NAN.subtract(PLUS_X); Assert.assertEquals(expected, actual); actual = MINUS_X.subtract(Decimal64.NAN); Assert.assertEquals(expected, actual); actual = Decimal64.NAN.subtract(MINUS_X); Assert.assertEquals(expected, actual); actual = Decimal64.POSITIVE_INFINITY.subtract(Decimal64.NAN); Assert.assertEquals(expected, actual); actual = Decimal64.NAN.subtract(Decimal64.POSITIVE_INFINITY); Assert.assertEquals(expected, actual); actual = Decimal64.NEGATIVE_INFINITY.subtract(Decimal64.NAN); Assert.assertEquals(expected, actual); actual = Decimal64.NAN.subtract(Decimal64.NEGATIVE_INFINITY); Assert.assertEquals(expected, actual); actual = Decimal64.NAN.subtract(Decimal64.NAN); Assert.assertEquals(expected, actual); } @Test public void testNegate() { Decimal64 expected, actual; expected = MINUS_X; actual = PLUS_X.negate(); Assert.assertEquals(expected, actual); expected = PLUS_X; actual = MINUS_X.negate(); Assert.assertEquals(expected, actual); expected = MINUS_ZERO; actual = PLUS_ZERO.negate(); Assert.assertEquals(expected, actual); expected = PLUS_ZERO; actual = MINUS_ZERO.negate(); Assert.assertEquals(expected, actual); expected = Decimal64.POSITIVE_INFINITY; actual = Decimal64.NEGATIVE_INFINITY.negate(); Assert.assertEquals(expected, actual); expected = Decimal64.NEGATIVE_INFINITY; actual = Decimal64.POSITIVE_INFINITY.negate(); Assert.assertEquals(expected, actual); expected = Decimal64.NAN; actual = Decimal64.NAN.negate(); Assert.assertEquals(expected, actual); } @Test public void testMultiply() { Decimal64 expected, actual; expected = new Decimal64(X * Y); actual = PLUS_X.multiply(PLUS_Y); Assert.assertEquals(expected, actual); actual = PLUS_Y.multiply(PLUS_X); Assert.assertEquals(expected, actual); expected = new Decimal64(X * (-Y)); actual = PLUS_X.multiply(MINUS_Y); Assert.assertEquals(expected, actual); actual = MINUS_Y.multiply(PLUS_X); Assert.assertEquals(expected, actual); expected = new Decimal64((-X) * (-Y)); actual = MINUS_X.multiply(MINUS_Y); Assert.assertEquals(expected, actual); actual = MINUS_Y.multiply(MINUS_X); Assert.assertEquals(expected, actual); expected = Decimal64.POSITIVE_INFINITY; actual = PLUS_X.multiply(Decimal64.POSITIVE_INFINITY); Assert.assertEquals(expected, actual); actual = Decimal64.POSITIVE_INFINITY.multiply(PLUS_X); Assert.assertEquals(expected, actual); actual = MINUS_X.multiply(Decimal64.NEGATIVE_INFINITY); Assert.assertEquals(expected, actual); actual = Decimal64.NEGATIVE_INFINITY.multiply(MINUS_X); Assert.assertEquals(expected, actual); actual = Decimal64.POSITIVE_INFINITY .multiply(Decimal64.POSITIVE_INFINITY); Assert.assertEquals(expected, actual); actual = Decimal64.NEGATIVE_INFINITY .multiply(Decimal64.NEGATIVE_INFINITY); Assert.assertEquals(expected, actual); expected = Decimal64.NEGATIVE_INFINITY; actual = PLUS_X.multiply(Decimal64.NEGATIVE_INFINITY); Assert.assertEquals(expected, actual); actual = Decimal64.NEGATIVE_INFINITY.multiply(PLUS_X); Assert.assertEquals(expected, actual); actual = MINUS_X.multiply(Decimal64.POSITIVE_INFINITY); Assert.assertEquals(expected, actual); actual = Decimal64.POSITIVE_INFINITY.multiply(MINUS_X); Assert.assertEquals(expected, actual); actual = Decimal64.POSITIVE_INFINITY .multiply(Decimal64.NEGATIVE_INFINITY); Assert.assertEquals(expected, actual); actual = Decimal64.NEGATIVE_INFINITY .multiply(Decimal64.POSITIVE_INFINITY); Assert.assertEquals(expected, actual); expected = Decimal64.NAN; actual = PLUS_X.multiply(Decimal64.NAN); Assert.assertEquals(expected, actual); actual = Decimal64.NAN.multiply(PLUS_X); Assert.assertEquals(expected, actual); actual = MINUS_X.multiply(Decimal64.NAN); Assert.assertEquals(expected, actual); actual = Decimal64.NAN.multiply(MINUS_X); Assert.assertEquals(expected, actual); actual = Decimal64.POSITIVE_INFINITY.multiply(Decimal64.NAN); Assert.assertEquals(expected, actual); actual = Decimal64.NAN.multiply(Decimal64.POSITIVE_INFINITY); Assert.assertEquals(expected, actual); actual = Decimal64.NEGATIVE_INFINITY.multiply(Decimal64.NAN); Assert.assertEquals(expected, actual); actual = Decimal64.NAN.multiply(Decimal64.NEGATIVE_INFINITY); Assert.assertEquals(expected, actual); actual = Decimal64.NAN.multiply(Decimal64.NAN); Assert.assertEquals(expected, actual); } @Test public void testDivide() { Decimal64 expected, actual; expected = new Decimal64(X / Y); actual = PLUS_X.divide(PLUS_Y); Assert.assertEquals(expected, actual); expected = new Decimal64(X / (-Y)); actual = PLUS_X.divide(MINUS_Y); Assert.assertEquals(expected, actual); expected = new Decimal64((-X) / Y); actual = MINUS_X.divide(PLUS_Y); Assert.assertEquals(expected, actual); expected = new Decimal64((-X) / (-Y)); actual = MINUS_X.divide(MINUS_Y); Assert.assertEquals(expected, actual); expected = PLUS_ZERO; actual = PLUS_X.divide(Decimal64.POSITIVE_INFINITY); Assert.assertEquals(expected, actual); actual = MINUS_X.divide(Decimal64.NEGATIVE_INFINITY); Assert.assertEquals(expected, actual); expected = MINUS_ZERO; actual = MINUS_X.divide(Decimal64.POSITIVE_INFINITY); Assert.assertEquals(expected, actual); actual = PLUS_X.divide(Decimal64.NEGATIVE_INFINITY); Assert.assertEquals(expected, actual); expected = Decimal64.POSITIVE_INFINITY; actual = Decimal64.POSITIVE_INFINITY.divide(PLUS_X); Assert.assertEquals(expected, actual); actual = Decimal64.NEGATIVE_INFINITY.divide(MINUS_X); Assert.assertEquals(expected, actual); actual = PLUS_X.divide(PLUS_ZERO); Assert.assertEquals(expected, actual); actual = MINUS_X.divide(MINUS_ZERO); Assert.assertEquals(expected, actual); expected = Decimal64.NEGATIVE_INFINITY; actual = Decimal64.POSITIVE_INFINITY.divide(MINUS_X); Assert.assertEquals(expected, actual); actual = Decimal64.NEGATIVE_INFINITY.divide(PLUS_X); Assert.assertEquals(expected, actual); actual = PLUS_X.divide(MINUS_ZERO); Assert.assertEquals(expected, actual); actual = MINUS_X.divide(PLUS_ZERO); Assert.assertEquals(expected, actual); expected = Decimal64.NAN; actual = Decimal64.POSITIVE_INFINITY .divide(Decimal64.POSITIVE_INFINITY); Assert.assertEquals(expected, actual); actual = Decimal64.POSITIVE_INFINITY .divide(Decimal64.NEGATIVE_INFINITY); Assert.assertEquals(expected, actual); actual = Decimal64.NEGATIVE_INFINITY .divide(Decimal64.POSITIVE_INFINITY); Assert.assertEquals(expected, actual); actual = Decimal64.NEGATIVE_INFINITY .divide(Decimal64.NEGATIVE_INFINITY); Assert.assertEquals(expected, actual); actual = PLUS_X.divide(Decimal64.NAN); Assert.assertEquals(expected, actual); actual = Decimal64.NAN.divide(PLUS_X); Assert.assertEquals(expected, actual); actual = MINUS_X.divide(Decimal64.NAN); Assert.assertEquals(expected, actual); actual = Decimal64.NAN.divide(MINUS_X); Assert.assertEquals(expected, actual); actual = Decimal64.POSITIVE_INFINITY.divide(Decimal64.NAN); Assert.assertEquals(expected, actual); actual = Decimal64.NAN.divide(Decimal64.POSITIVE_INFINITY); Assert.assertEquals(expected, actual); actual = Decimal64.NEGATIVE_INFINITY.divide(Decimal64.NAN); Assert.assertEquals(expected, actual); actual = Decimal64.NAN.divide(Decimal64.NEGATIVE_INFINITY); Assert.assertEquals(expected, actual); actual = Decimal64.NAN.divide(Decimal64.NAN); Assert.assertEquals(expected, actual); actual = PLUS_ZERO.divide(PLUS_ZERO); Assert.assertEquals(expected, actual); actual = PLUS_ZERO.divide(MINUS_ZERO); Assert.assertEquals(expected, actual); actual = MINUS_ZERO.divide(PLUS_ZERO); Assert.assertEquals(expected, actual); actual = MINUS_ZERO.divide(MINUS_ZERO); Assert.assertEquals(expected, actual); } @Test public void testReciprocal() { Decimal64 expected, actual; expected = new Decimal64(1.0 / X); actual = PLUS_X.reciprocal(); Assert.assertEquals(expected, actual); expected = new Decimal64(1.0 / (-X)); actual = MINUS_X.reciprocal(); Assert.assertEquals(expected, actual); expected = PLUS_ZERO; actual = Decimal64.POSITIVE_INFINITY.reciprocal(); Assert.assertEquals(expected, actual); expected = MINUS_ZERO; actual = Decimal64.NEGATIVE_INFINITY.reciprocal(); Assert.assertEquals(expected, actual); } @Test public void testIsInfinite() { Assert.assertFalse(MINUS_X.isInfinite()); Assert.assertFalse(PLUS_X.isInfinite()); Assert.assertFalse(MINUS_Y.isInfinite()); Assert.assertFalse(PLUS_Y.isInfinite()); Assert.assertFalse(Decimal64.NAN.isInfinite()); Assert.assertTrue(Decimal64.NEGATIVE_INFINITY.isInfinite()); Assert.assertTrue(Decimal64.POSITIVE_INFINITY.isInfinite()); } @Test public void testIsNaN() { Assert.assertFalse(MINUS_X.isNaN()); Assert.assertFalse(PLUS_X.isNaN()); Assert.assertFalse(MINUS_Y.isNaN()); Assert.assertFalse(PLUS_Y.isNaN()); Assert.assertFalse(Decimal64.NEGATIVE_INFINITY.isNaN()); Assert.assertFalse(Decimal64.POSITIVE_INFINITY.isNaN()); Assert.assertTrue(Decimal64.NAN.isNaN()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.util; import java.math.BigDecimal; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.exception.NullArgumentException; import org.junit.Assert; import org.junit.Test; /** * @version $Id$ */ public class DefaultTransformerTest { /** * */ @Test public void testTransformDouble() throws Exception { double expected = 1.0; Double input = Double.valueOf(expected); DefaultTransformer t = new DefaultTransformer(); Assert.assertEquals(expected, t.transform(input), 1.0e-4); } /** * */ @Test public void testTransformNull() throws Exception { DefaultTransformer t = new DefaultTransformer(); try { t.transform(null); Assert.fail("Expecting NullArgumentException"); } catch (NullArgumentException e) { // expected } } /** * */ @Test public void testTransformInteger() throws Exception { double expected = 1.0; Integer input = Integer.valueOf(1); DefaultTransformer t = new DefaultTransformer(); Assert.assertEquals(expected, t.transform(input), 1.0e-4); } /** * */ @Test public void testTransformBigDecimal() throws Exception { double expected = 1.0; BigDecimal input = new BigDecimal("1.0"); DefaultTransformer t = new DefaultTransformer(); Assert.assertEquals(expected, t.transform(input), 1.0e-4); } /** * */ @Test public void testTransformString() throws Exception { double expected = 1.0; String input = "1.0"; DefaultTransformer t = new DefaultTransformer(); Assert.assertEquals(expected, t.transform(input), 1.0e-4); } /** * */ @Test(expected=MathIllegalArgumentException.class) public void testTransformObject(){ Boolean input = Boolean.TRUE; DefaultTransformer t = new DefaultTransformer(); t.transform(input); } @Test public void testSerial() { Assert.assertEquals(new DefaultTransformer(), TestUtils.serializeAndRecover(new DefaultTransformer())); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.util; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.lang.reflect.Modifier; import java.lang.reflect.Type; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import org.junit.Assert; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import org.junit.runners.Parameterized.Parameters; /** * Test to compare FastMath results against StrictMath results for boundary values. * <p> * Running all tests independently: <br/> * {@code mvn test -Dtest=FastMathStrictComparisonTest}<br/> * or just run tests against a single method (e.g. scalb):<br/> * {@code mvn test -Dtest=FastMathStrictComparisonTest -DargLine="-DtestMethod=scalb"} */ @SuppressWarnings("boxing") @RunWith(Parameterized.class) public class FastMathStrictComparisonTest { // Values which often need special handling private static final Double[] DOUBLE_SPECIAL_VALUES = { -0.0, +0.0, // 1,2 Double.NaN, // 3 Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, // 4,5 -Double.MAX_VALUE, Double.MAX_VALUE, // 6,7 // decreasing order of absolute value to help catch first failure -Precision.EPSILON, Precision.EPSILON, // 8,9 -Precision.SAFE_MIN, Precision.SAFE_MIN, // 10,11 -Double.MIN_VALUE, Double.MIN_VALUE, // 12,13 }; private static final Float [] FLOAT_SPECIAL_VALUES = { -0.0f, +0.0f, // 1,2 Float.NaN, // 3 Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY, // 4,5 Float.MIN_VALUE, Float.MAX_VALUE, // 6,7 -Float.MIN_VALUE, -Float.MAX_VALUE, // 8,9 }; private static final Object [] LONG_SPECIAL_VALUES = { -1,0,1, // 1,2,3 Long.MIN_VALUE, Long.MAX_VALUE, // 4,5 }; private static final Object[] INT_SPECIAL_VALUES = { -1,0,1, // 1,2,3 Integer.MIN_VALUE, Integer.MAX_VALUE, // 4,5 }; private final Method mathMethod; private final Method fastMethod; private final Type[] types; private final Object[][] valueArrays; public FastMathStrictComparisonTest(Method m, Method f, Type[] types, Object[][] data) throws Exception{ this.mathMethod=m; this.fastMethod=f; this.types=types; this.valueArrays=data; } @Test public void test1() throws Exception{ setupMethodCall(mathMethod, fastMethod, types, valueArrays); } private static boolean isNumber(Double d) { return !(d.isInfinite() || d.isNaN()); } private static boolean isNumber(Float f) { return !(f.isInfinite() || f.isNaN()); } private static void reportFailedResults(Method mathMethod, Object[] params, Object expected, Object actual, int[] entries){ final String methodName = mathMethod.getName(); String format = null; long actL=0; long expL=0; if (expected instanceof Double) { Double exp = (Double) expected; Double act = (Double) actual; if (isNumber(exp) && isNumber(act) && exp != 0) { // show difference as hex actL = Double.doubleToLongBits(act); expL = Double.doubleToLongBits(exp); if (Math.abs(actL-expL)==1) { // Not 100% sure off-by-one errors are allowed everywhere, so only allow for these methods if (methodName.equals("toRadians") || methodName.equals("atan2")) { return; } } format = "%016x"; } } else if (expected instanceof Float ){ Float exp = (Float) expected; Float act = (Float) actual; if (isNumber(exp) && isNumber(act) && exp != 0) { // show difference as hex actL = Float.floatToIntBits(act); expL = Float.floatToIntBits(exp); format = "%08x"; } } StringBuilder sb = new StringBuilder(); sb.append(mathMethod.getReturnType().getSimpleName()); sb.append(" "); sb.append(methodName); sb.append("("); String sep = ""; for(Object o : params){ sb.append(sep); sb.append(o); sep=", "; } sb.append(") expected "); if (format != null){ sb.append(String.format(format, expL)); } else { sb.append(expected); } sb.append(" actual "); if (format != null){ sb.append(String.format(format, actL)); } else { sb.append(actual); } sb.append(" entries "); sb.append(Arrays.toString(entries)); String message = sb.toString(); final boolean fatal = true; if (fatal) { Assert.fail(message); } else { System.out.println(message); } } private static void callMethods(Method mathMethod, Method fastMethod, Object[] params, int[] entries) throws IllegalAccessException, InvocationTargetException { try { Object expected = mathMethod.invoke(mathMethod, params); Object actual = fastMethod.invoke(mathMethod, params); if (!expected.equals(actual)) { reportFailedResults(mathMethod, params, expected, actual, entries); } } catch (IllegalArgumentException e) { Assert.fail(mathMethod+" "+e); } } private static void setupMethodCall(Method mathMethod, Method fastMethod, Type[] types, Object[][] valueArrays) throws Exception { Object[] params = new Object[types.length]; int entry1 = 0; int[] entries = new int[types.length]; for(Object d : valueArrays[0]) { entry1++; params[0] = d; entries[0] = entry1; if (params.length > 1){ int entry2 = 0; for(Object d1 : valueArrays[1]) { entry2++; params[1] = d1; entries[1] = entry2; callMethods(mathMethod, fastMethod, params, entries); } } else { callMethods(mathMethod, fastMethod, params, entries); } } } @Parameters public static List<Object[]> data() throws Exception { String singleMethod = System.getProperty("testMethod"); List<Object[]> list = new ArrayList<Object[]>(); for(Method mathMethod : StrictMath.class.getDeclaredMethods()) { method: if (Modifier.isPublic(mathMethod.getModifiers())){// Only test public methods Type []types = mathMethod.getGenericParameterTypes(); if (types.length >=1) { // Only check methods with at least one parameter try { // Get the corresponding FastMath method Method fastMethod = FastMath.class.getDeclaredMethod(mathMethod.getName(), (Class[]) types); if (Modifier.isPublic(fastMethod.getModifiers())) { // It must be public too if (singleMethod != null && !fastMethod.getName().equals(singleMethod)) { break method; } Object [][] values = new Object[types.length][]; int index = 0; for(Type t : types) { if (t.equals(double.class)){ values[index]=DOUBLE_SPECIAL_VALUES; } else if (t.equals(float.class)) { values[index]=FLOAT_SPECIAL_VALUES; } else if (t.equals(long.class)) { values[index]=LONG_SPECIAL_VALUES; } else if (t.equals(int.class)) { values[index]=INT_SPECIAL_VALUES; } else { System.out.println("Cannot handle class "+t+" for "+mathMethod); break method; } index++; } // System.out.println(fastMethod); /* * The current implementation runs each method as a separate test. * Could be amended to run each value as a separate test */ list.add(new Object[]{mathMethod, fastMethod, types, values}); // setupMethodCall(mathMethod, fastMethod, params, data); } else { System.out.println("Cannot find public FastMath method corresponding to: "+mathMethod); } } catch (NoSuchMethodException e) { System.out.println("Cannot find FastMath method corresponding to: "+mathMethod); } } } } return list; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.util; import java.lang.reflect.Method; import java.lang.reflect.Modifier; import java.lang.reflect.Type; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.dfp.Dfp; import org.apache.commons.math3.dfp.DfpField; import org.apache.commons.math3.dfp.DfpMath; import org.apache.commons.math3.random.MersenneTwister; import org.apache.commons.math3.random.RandomGenerator; import org.junit.Assert; import org.junit.Before; import org.junit.Ignore; import org.junit.Test; public class FastMathTest { private static final double MAX_ERROR_ULP = 0.51; private static final int NUMBER_OF_TRIALS = 1000; private DfpField field; private RandomGenerator generator; @Before public void setUp() { field = new DfpField(40); generator = new MersenneTwister(6176597458463500194l); } @Test public void testMinMaxDouble() { double[][] pairs = { { -50.0, 50.0 }, { Double.POSITIVE_INFINITY, 1.0 }, { Double.NEGATIVE_INFINITY, 1.0 }, { Double.NaN, 1.0 }, { Double.POSITIVE_INFINITY, 0.0 }, { Double.NEGATIVE_INFINITY, 0.0 }, { Double.NaN, 0.0 }, { Double.NaN, Double.NEGATIVE_INFINITY }, { Double.NaN, Double.POSITIVE_INFINITY }, { Precision.SAFE_MIN, Precision.EPSILON } }; for (double[] pair : pairs) { Assert.assertEquals("min(" + pair[0] + ", " + pair[1] + ")", Math.min(pair[0], pair[1]), FastMath.min(pair[0], pair[1]), Precision.EPSILON); Assert.assertEquals("min(" + pair[1] + ", " + pair[0] + ")", Math.min(pair[1], pair[0]), FastMath.min(pair[1], pair[0]), Precision.EPSILON); Assert.assertEquals("max(" + pair[0] + ", " + pair[1] + ")", Math.max(pair[0], pair[1]), FastMath.max(pair[0], pair[1]), Precision.EPSILON); Assert.assertEquals("max(" + pair[1] + ", " + pair[0] + ")", Math.max(pair[1], pair[0]), FastMath.max(pair[1], pair[0]), Precision.EPSILON); } } @Test public void testMinMaxFloat() { float[][] pairs = { { -50.0f, 50.0f }, { Float.POSITIVE_INFINITY, 1.0f }, { Float.NEGATIVE_INFINITY, 1.0f }, { Float.NaN, 1.0f }, { Float.POSITIVE_INFINITY, 0.0f }, { Float.NEGATIVE_INFINITY, 0.0f }, { Float.NaN, 0.0f }, { Float.NaN, Float.NEGATIVE_INFINITY }, { Float.NaN, Float.POSITIVE_INFINITY } }; for (float[] pair : pairs) { Assert.assertEquals("min(" + pair[0] + ", " + pair[1] + ")", Math.min(pair[0], pair[1]), FastMath.min(pair[0], pair[1]), Precision.EPSILON); Assert.assertEquals("min(" + pair[1] + ", " + pair[0] + ")", Math.min(pair[1], pair[0]), FastMath.min(pair[1], pair[0]), Precision.EPSILON); Assert.assertEquals("max(" + pair[0] + ", " + pair[1] + ")", Math.max(pair[0], pair[1]), FastMath.max(pair[0], pair[1]), Precision.EPSILON); Assert.assertEquals("max(" + pair[1] + ", " + pair[0] + ")", Math.max(pair[1], pair[0]), FastMath.max(pair[1], pair[0]), Precision.EPSILON); } } @Test public void testConstants() { Assert.assertEquals(Math.PI, FastMath.PI, 1.0e-20); Assert.assertEquals(Math.E, FastMath.E, 1.0e-20); } @Test public void testAtan2() { double y1 = 1.2713504628280707e10; double x1 = -5.674940885228782e-10; Assert.assertEquals(Math.atan2(y1, x1), FastMath.atan2(y1, x1), 2 * Precision.EPSILON); double y2 = 0.0; double x2 = Double.POSITIVE_INFINITY; Assert.assertEquals(Math.atan2(y2, x2), FastMath.atan2(y2, x2), Precision.SAFE_MIN); } @Test public void testHyperbolic() { double maxErr = 0; for (double x = -30; x < 30; x += 0.001) { double tst = FastMath.sinh(x); double ref = Math.sinh(x); maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref)); } Assert.assertEquals(0, maxErr, 2); maxErr = 0; for (double x = -30; x < 30; x += 0.001) { double tst = FastMath.cosh(x); double ref = Math.cosh(x); maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref)); } Assert.assertEquals(0, maxErr, 2); maxErr = 0; for (double x = -0.5; x < 0.5; x += 0.001) { double tst = FastMath.tanh(x); double ref = Math.tanh(x); maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref)); } Assert.assertEquals(0, maxErr, 4); } @Test public void testMath904() { final double x = -1; final double y = (5 + 1e-15) * 1e15; Assert.assertEquals(Math.pow(x, y), FastMath.pow(x, y), 0); Assert.assertEquals(Math.pow(x, -y), FastMath.pow(x, -y), 0); } @Test public void testMath905LargePositive() { final double start = StrictMath.log(Double.MAX_VALUE); final double endT = StrictMath.sqrt(2) * StrictMath.sqrt(Double.MAX_VALUE); final double end = 2 * StrictMath.log(endT); double maxErr = 0; for (double x = start; x < end; x += 1e-3) { final double tst = FastMath.cosh(x); final double ref = Math.cosh(x); maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref)); } Assert.assertEquals(0, maxErr, 3); for (double x = start; x < end; x += 1e-3) { final double tst = FastMath.sinh(x); final double ref = Math.sinh(x); maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref)); } Assert.assertEquals(0, maxErr, 3); } @Test public void testMath905LargeNegative() { final double start = -StrictMath.log(Double.MAX_VALUE); final double endT = StrictMath.sqrt(2) * StrictMath.sqrt(Double.MAX_VALUE); final double end = -2 * StrictMath.log(endT); double maxErr = 0; for (double x = start; x > end; x -= 1e-3) { final double tst = FastMath.cosh(x); final double ref = Math.cosh(x); maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref)); } Assert.assertEquals(0, maxErr, 3); for (double x = start; x > end; x -= 1e-3) { final double tst = FastMath.sinh(x); final double ref = Math.sinh(x); maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref)); } Assert.assertEquals(0, maxErr, 3); } @Test public void testHyperbolicInverses() { double maxErr = 0; for (double x = -30; x < 30; x += 0.01) { maxErr = FastMath.max(maxErr, FastMath.abs(x - FastMath.sinh(FastMath.asinh(x))) / (2 * FastMath.ulp(x))); } Assert.assertEquals(0, maxErr, 3); maxErr = 0; for (double x = 1; x < 30; x += 0.01) { maxErr = FastMath.max(maxErr, FastMath.abs(x - FastMath.cosh(FastMath.acosh(x))) / (2 * FastMath.ulp(x))); } Assert.assertEquals(0, maxErr, 2); maxErr = 0; for (double x = -1 + Precision.EPSILON; x < 1 - Precision.EPSILON; x += 0.0001) { maxErr = FastMath.max(maxErr, FastMath.abs(x - FastMath.tanh(FastMath.atanh(x))) / (2 * FastMath.ulp(x))); } Assert.assertEquals(0, maxErr, 2); } @Test public void testLogAccuracy() { double maxerrulp = 0.0; for (int i = 0; i < NUMBER_OF_TRIALS; i++) { double x = Math.exp(generator.nextDouble() * 1416.0 - 708.0) * generator.nextDouble(); // double x = generator.nextDouble()*2.0; double tst = FastMath.log(x); double ref = DfpMath.log(field.newDfp(x)).toDouble(); double err = (tst - ref) / ref; if (err != 0.0) { double ulp = Math.abs(ref - Double.longBitsToDouble((Double .doubleToLongBits(ref) ^ 1))); double errulp = field.newDfp(tst).subtract(DfpMath.log(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble(); // System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp); maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); } } Assert.assertTrue("log() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); } @Test public void testLog10Accuracy() { double maxerrulp = 0.0; for (int i = 0; i < NUMBER_OF_TRIALS; i++) { double x = Math.exp(generator.nextDouble() * 1416.0 - 708.0) * generator.nextDouble(); // double x = generator.nextDouble()*2.0; double tst = FastMath.log10(x); double ref = DfpMath.log(field.newDfp(x)).divide(DfpMath.log(field.newDfp("10"))).toDouble(); double err = (tst - ref) / ref; if (err != 0.0) { double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1))); double errulp = field.newDfp(tst).subtract(DfpMath.log(field.newDfp(x)).divide(DfpMath.log(field.newDfp("10")))).divide(field.newDfp(ulp)).toDouble(); // System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp); maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); } } Assert.assertTrue("log10() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); } @Test public void testLog1pAccuracy() { double maxerrulp = 0.0; for (int i = 0; i < NUMBER_OF_TRIALS; i++) { double x = Math.exp(generator.nextDouble() * 10.0 - 5.0) * generator.nextDouble(); // double x = generator.nextDouble()*2.0; double tst = FastMath.log1p(x); double ref = DfpMath.log(field.newDfp(x).add(field.getOne())).toDouble(); double err = (tst - ref) / ref; if (err != 0.0) { double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1))); double errulp = field.newDfp(tst).subtract(DfpMath.log(field.newDfp(x).add(field.getOne()))).divide(field.newDfp(ulp)).toDouble(); // System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp); maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); } } Assert.assertTrue("log1p() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); } @Test public void testLog1pSpecialCases() { Assert.assertTrue("Logp of -1.0 should be -Inf", Double.isInfinite(FastMath.log1p(-1.0))); } @Test public void testLogSpecialCases() { Assert.assertTrue("Log of zero should be -Inf", Double.isInfinite(FastMath.log(0.0))); Assert.assertTrue("Log of -zero should be -Inf", Double.isInfinite(FastMath.log(-0.0))); Assert.assertTrue("Log of NaN should be NaN", Double.isNaN(FastMath.log(Double.NaN))); Assert.assertTrue("Log of negative number should be NaN", Double.isNaN(FastMath.log(-1.0))); Assert.assertEquals("Log of Double.MIN_VALUE should be -744.4400719213812", -744.4400719213812, FastMath.log(Double.MIN_VALUE), Precision.EPSILON); Assert.assertTrue("Log of infinity should be infinity", Double.isInfinite(FastMath.log(Double.POSITIVE_INFINITY))); } @Test public void testExpSpecialCases() { // Smallest value that will round up to Double.MIN_VALUE Assert.assertEquals(Double.MIN_VALUE, FastMath.exp(-745.1332191019411), Precision.EPSILON); Assert.assertEquals("exp(-745.1332191019412) should be 0.0", 0.0, FastMath.exp(-745.1332191019412), Precision.EPSILON); Assert.assertTrue("exp of NaN should be NaN", Double.isNaN(FastMath.exp(Double.NaN))); Assert.assertTrue("exp of infinity should be infinity", Double.isInfinite(FastMath.exp(Double.POSITIVE_INFINITY))); Assert.assertEquals("exp of -infinity should be 0.0", 0.0, FastMath.exp(Double.NEGATIVE_INFINITY), Precision.EPSILON); Assert.assertEquals("exp(1) should be Math.E", Math.E, FastMath.exp(1.0), Precision.EPSILON); } @Test public void testPowSpecialCases() { Assert.assertEquals("pow(-1, 0) should be 1.0", 1.0, FastMath.pow(-1.0, 0.0), Precision.EPSILON); Assert.assertEquals("pow(-1, -0) should be 1.0", 1.0, FastMath.pow(-1.0, -0.0), Precision.EPSILON); Assert.assertEquals("pow(PI, 1.0) should be PI", FastMath.PI, FastMath.pow(FastMath.PI, 1.0), Precision.EPSILON); Assert.assertEquals("pow(-PI, 1.0) should be -PI", -FastMath.PI, FastMath.pow(-FastMath.PI, 1.0), Precision.EPSILON); Assert.assertTrue("pow(PI, NaN) should be NaN", Double.isNaN(FastMath.pow(Math.PI, Double.NaN))); Assert.assertTrue("pow(NaN, PI) should be NaN", Double.isNaN(FastMath.pow(Double.NaN, Math.PI))); Assert.assertTrue("pow(2.0, Infinity) should be Infinity", Double.isInfinite(FastMath.pow(2.0, Double.POSITIVE_INFINITY))); Assert.assertTrue("pow(0.5, -Infinity) should be Infinity", Double.isInfinite(FastMath.pow(0.5, Double.NEGATIVE_INFINITY))); Assert.assertEquals("pow(0.5, Infinity) should be 0.0", 0.0, FastMath.pow(0.5, Double.POSITIVE_INFINITY), Precision.EPSILON); Assert.assertEquals("pow(2.0, -Infinity) should be 0.0", 0.0, FastMath.pow(2.0, Double.NEGATIVE_INFINITY), Precision.EPSILON); Assert.assertEquals("pow(0.0, 0.5) should be 0.0", 0.0, FastMath.pow(0.0, 0.5), Precision.EPSILON); Assert.assertEquals("pow(Infinity, -0.5) should be 0.0", 0.0, FastMath.pow(Double.POSITIVE_INFINITY, -0.5), Precision.EPSILON); Assert.assertTrue("pow(0.0, -0.5) should be Inf", Double.isInfinite(FastMath.pow(0.0, -0.5))); Assert.assertTrue("pow(Inf, 0.5) should be Inf", Double.isInfinite(FastMath.pow(Double.POSITIVE_INFINITY, 0.5))); Assert.assertTrue("pow(-0.0, -3.0) should be -Inf", Double.isInfinite(FastMath.pow(-0.0, -3.0))); Assert.assertTrue("pow(-Inf, -3.0) should be -Inf", Double.isInfinite(FastMath.pow(Double.NEGATIVE_INFINITY, 3.0))); Assert.assertTrue("pow(-0.0, -3.5) should be Inf", Double.isInfinite(FastMath.pow(-0.0, -3.5))); Assert.assertTrue("pow(Inf, 3.5) should be Inf", Double.isInfinite(FastMath.pow(Double.POSITIVE_INFINITY, 3.5))); Assert.assertEquals("pow(-2.0, 3.0) should be -8.0", -8.0, FastMath.pow(-2.0, 3.0), Precision.EPSILON); Assert.assertTrue("pow(-2.0, 3.5) should be NaN", Double.isNaN(FastMath.pow(-2.0, 3.5))); // Added tests for a 100% coverage Assert.assertTrue("pow(+Inf, NaN) should be NaN", Double.isNaN(FastMath.pow(Double.POSITIVE_INFINITY, Double.NaN))); Assert.assertTrue("pow(1.0, +Inf) should be NaN", Double.isNaN(FastMath.pow(1.0, Double.POSITIVE_INFINITY))); Assert.assertTrue("pow(-Inf, NaN) should be NaN", Double.isNaN(FastMath.pow(Double.NEGATIVE_INFINITY, Double.NaN))); Assert.assertEquals("pow(-Inf, -1.0) should be 0.0", 0.0, FastMath.pow(Double.NEGATIVE_INFINITY, -1.0), Precision.EPSILON); Assert.assertEquals("pow(-Inf, -2.0) should be 0.0", 0.0, FastMath.pow(Double.NEGATIVE_INFINITY, -2.0), Precision.EPSILON); Assert.assertTrue("pow(-Inf, 1.0) should be -Inf", Double.isInfinite(FastMath.pow(Double.NEGATIVE_INFINITY, 1.0))); Assert.assertTrue("pow(-Inf, 2.0) should be +Inf", Double.isInfinite(FastMath.pow(Double.NEGATIVE_INFINITY, 2.0))); Assert.assertTrue("pow(1.0, -Inf) should be NaN", Double.isNaN(FastMath.pow(1.0, Double.NEGATIVE_INFINITY))); } @Test public void testAtan2SpecialCases() { Assert.assertTrue("atan2(NaN, 0.0) should be NaN", Double.isNaN(FastMath.atan2(Double.NaN, 0.0))); Assert.assertTrue("atan2(0.0, NaN) should be NaN", Double.isNaN(FastMath.atan2(0.0, Double.NaN))); Assert.assertEquals("atan2(0.0, 0.0) should be 0.0", 0.0, FastMath.atan2(0.0, 0.0), Precision.EPSILON); Assert.assertEquals("atan2(0.0, 0.001) should be 0.0", 0.0, FastMath.atan2(0.0, 0.001), Precision.EPSILON); Assert.assertEquals("atan2(0.1, +Inf) should be 0.0", 0.0, FastMath.atan2(0.1, Double.POSITIVE_INFINITY), Precision.EPSILON); Assert.assertEquals("atan2(-0.0, 0.0) should be -0.0", -0.0, FastMath.atan2(-0.0, 0.0), Precision.EPSILON); Assert.assertEquals("atan2(-0.0, 0.001) should be -0.0", -0.0, FastMath.atan2(-0.0, 0.001), Precision.EPSILON); Assert.assertEquals("atan2(-0.0, +Inf) should be -0.0", -0.0, FastMath.atan2(-0.1, Double.POSITIVE_INFINITY), Precision.EPSILON); Assert.assertEquals("atan2(0.0, -0.0) should be PI", FastMath.PI, FastMath.atan2(0.0, -0.0), Precision.EPSILON); Assert.assertEquals("atan2(0.1, -Inf) should be PI", FastMath.PI, FastMath.atan2(0.1, Double.NEGATIVE_INFINITY), Precision.EPSILON); Assert.assertEquals("atan2(-0.0, -0.0) should be -PI", -FastMath.PI, FastMath.atan2(-0.0, -0.0), Precision.EPSILON); Assert.assertEquals("atan2(0.1, -Inf) should be -PI", -FastMath.PI, FastMath.atan2(-0.1, Double.NEGATIVE_INFINITY), Precision.EPSILON); Assert.assertEquals("atan2(0.1, 0.0) should be PI/2", FastMath.PI / 2.0, FastMath.atan2(0.1, 0.0), Precision.EPSILON); Assert.assertEquals("atan2(0.1, -0.0) should be PI/2", FastMath.PI / 2.0, FastMath.atan2(0.1, -0.0), Precision.EPSILON); Assert.assertEquals("atan2(Inf, 0.1) should be PI/2", FastMath.PI / 2.0, FastMath.atan2(Double.POSITIVE_INFINITY, 0.1), Precision.EPSILON); Assert.assertEquals("atan2(Inf, -0.1) should be PI/2", FastMath.PI / 2.0, FastMath.atan2(Double.POSITIVE_INFINITY, -0.1), Precision.EPSILON); Assert.assertEquals("atan2(-0.1, 0.0) should be -PI/2", -FastMath.PI / 2.0, FastMath.atan2(-0.1, 0.0), Precision.EPSILON); Assert.assertEquals("atan2(-0.1, -0.0) should be -PI/2", -FastMath.PI / 2.0, FastMath.atan2(-0.1, -0.0), Precision.EPSILON); Assert.assertEquals("atan2(-Inf, 0.1) should be -PI/2", -FastMath.PI / 2.0, FastMath.atan2(Double.NEGATIVE_INFINITY, 0.1), Precision.EPSILON); Assert.assertEquals("atan2(-Inf, -0.1) should be -PI/2", -FastMath.PI / 2.0, FastMath.atan2(Double.NEGATIVE_INFINITY, -0.1), Precision.EPSILON); Assert.assertEquals("atan2(Inf, Inf) should be PI/4", FastMath.PI / 4.0, FastMath.atan2(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY), Precision.EPSILON); Assert.assertEquals("atan2(Inf, -Inf) should be PI * 3/4", FastMath.PI * 3.0 / 4.0, FastMath.atan2(Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY), Precision.EPSILON); Assert.assertEquals("atan2(-Inf, Inf) should be -PI/4", -FastMath.PI / 4.0, FastMath.atan2(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY), Precision.EPSILON); Assert.assertEquals("atan2(-Inf, -Inf) should be -PI * 3/4", - FastMath.PI * 3.0 / 4.0, FastMath.atan2(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY), Precision.EPSILON); } @Test public void testPowAccuracy() { double maxerrulp = 0.0; for (int i = 0; i < NUMBER_OF_TRIALS; i++) { double x = (generator.nextDouble() * 2.0 + 0.25); double y = (generator.nextDouble() * 1200.0 - 600.0) * generator.nextDouble(); /* * double x = FastMath.floor(generator.nextDouble()*1024.0 - 512.0); double * y; if (x != 0) y = FastMath.floor(512.0 / FastMath.abs(x)); else * y = generator.nextDouble()*1200.0; y = y - y/2; x = FastMath.pow(2.0, x) * * generator.nextDouble(); y = y * generator.nextDouble(); */ // double x = generator.nextDouble()*2.0; double tst = FastMath.pow(x, y); double ref = DfpMath.pow(field.newDfp(x), field.newDfp(y)).toDouble(); double err = (tst - ref) / ref; if (err != 0) { double ulp = Math.abs(ref - Double.longBitsToDouble((Double .doubleToLongBits(ref) ^ 1))); double errulp = field.newDfp(tst).subtract(DfpMath.pow(field.newDfp(x), field.newDfp(y))).divide(field.newDfp(ulp)).toDouble(); // System.out.println(x + "\t" + y + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp); maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); } } Assert.assertTrue("pow() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); } @Test public void testExpAccuracy() { double maxerrulp = 0.0; for (int i = 0; i < NUMBER_OF_TRIALS; i++) { /* double x = 1.0 + i/1024.0/2.0; */ double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble(); // double x = (generator.nextDouble() * 20.0) - 10.0; // double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble(); /* double x = 3.0 / 512.0 * i - 3.0; */ double tst = FastMath.exp(x); double ref = DfpMath.exp(field.newDfp(x)).toDouble(); double err = (tst - ref) / ref; if (err != 0) { double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1))); double errulp = field.newDfp(tst).subtract(DfpMath.exp(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble(); // System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp); maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); } } Assert.assertTrue("exp() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); } @Test public void testSinAccuracy() { double maxerrulp = 0.0; for (int i = 0; i < NUMBER_OF_TRIALS; i++) { /* double x = 1.0 + i/1024.0/2.0; */ // double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble(); double x = ((generator.nextDouble() * Math.PI) - Math.PI / 2.0) * Math.pow(2, 21) * generator.nextDouble(); // double x = (generator.nextDouble() * 20.0) - 10.0; // double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble(); /* double x = 3.0 / 512.0 * i - 3.0; */ double tst = FastMath.sin(x); double ref = DfpMath.sin(field.newDfp(x)).toDouble(); double err = (tst - ref) / ref; if (err != 0) { double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1))); double errulp = field.newDfp(tst).subtract(DfpMath.sin(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble(); // System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp); maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); } } Assert.assertTrue("sin() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); } @Test public void testCosAccuracy() { double maxerrulp = 0.0; for (int i = 0; i < NUMBER_OF_TRIALS; i++) { /* double x = 1.0 + i/1024.0/2.0; */ // double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble(); double x = ((generator.nextDouble() * Math.PI) - Math.PI / 2.0) * Math.pow(2, 21) * generator.nextDouble(); // double x = (generator.nextDouble() * 20.0) - 10.0; // double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble(); /* double x = 3.0 / 512.0 * i - 3.0; */ double tst = FastMath.cos(x); double ref = DfpMath.cos(field.newDfp(x)).toDouble(); double err = (tst - ref) / ref; if (err != 0) { double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1))); double errulp = field.newDfp(tst).subtract(DfpMath.cos(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble(); // System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp); maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); } } Assert.assertTrue("cos() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); } @Test public void testTanAccuracy() { double maxerrulp = 0.0; for (int i = 0; i < NUMBER_OF_TRIALS; i++) { /* double x = 1.0 + i/1024.0/2.0; */ // double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble(); double x = ((generator.nextDouble() * Math.PI) - Math.PI / 2.0) * Math.pow(2, 12) * generator.nextDouble(); // double x = (generator.nextDouble() * 20.0) - 10.0; // double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble(); /* double x = 3.0 / 512.0 * i - 3.0; */ double tst = FastMath.tan(x); double ref = DfpMath.tan(field.newDfp(x)).toDouble(); double err = (tst - ref) / ref; if (err != 0) { double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1))); double errulp = field.newDfp(tst).subtract(DfpMath.tan(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble(); // System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp); maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); } } Assert.assertTrue("tan() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); } @Test public void testAtanAccuracy() { double maxerrulp = 0.0; for (int i = 0; i < NUMBER_OF_TRIALS; i++) { /* double x = 1.0 + i/1024.0/2.0; */ // double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble(); // double x = ((generator.nextDouble() * Math.PI) - Math.PI/2.0) * // generator.nextDouble(); double x = ((generator.nextDouble() * 16.0) - 8.0) * generator.nextDouble(); // double x = (generator.nextDouble() * 20.0) - 10.0; // double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble(); /* double x = 3.0 / 512.0 * i - 3.0; */ double tst = FastMath.atan(x); double ref = DfpMath.atan(field.newDfp(x)).toDouble(); double err = (tst - ref) / ref; if (err != 0) { double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1))); double errulp = field.newDfp(tst).subtract(DfpMath.atan(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble(); // System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp); maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); } } Assert.assertTrue("atan() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); } @Test public void testAtan2Accuracy() { double maxerrulp = 0.0; for (int i = 0; i < NUMBER_OF_TRIALS; i++) { /* double x = 1.0 + i/1024.0/2.0; */ // double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble(); double x = generator.nextDouble() - 0.5; double y = generator.nextDouble() - 0.5; // double x = (generator.nextDouble() * 20.0) - 10.0; // double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble(); /* double x = 3.0 / 512.0 * i - 3.0; */ double tst = FastMath.atan2(y, x); Dfp refdfp = DfpMath.atan(field.newDfp(y) .divide(field.newDfp(x))); /* Make adjustments for sign */ if (x < 0.0) { if (y > 0.0) refdfp = field.getPi().add(refdfp); else refdfp = refdfp.subtract(field.getPi()); } double ref = refdfp.toDouble(); double err = (tst - ref) / ref; if (err != 0) { double ulp = Math.abs(ref - Double.longBitsToDouble((Double .doubleToLongBits(ref) ^ 1))); double errulp = field.newDfp(tst).subtract(refdfp).divide(field.newDfp(ulp)).toDouble(); // System.out.println(x + "\t" + y + "\t" + tst + "\t" + ref + "\t" + errulp); maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); } } Assert.assertTrue("atan2() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); } @Test public void testExpm1Accuracy() { double maxerrulp = 0.0; for (int i = 0; i < NUMBER_OF_TRIALS; i++) { /* double x = 1.0 + i/1024.0/2.0; */ // double x = (generator.nextDouble() * 20.0) - 10.0; double x = ((generator.nextDouble() * 16.0) - 8.0) * generator.nextDouble(); /* double x = 3.0 / 512.0 * i - 3.0; */ double tst = FastMath.expm1(x); double ref = DfpMath.exp(field.newDfp(x)).subtract(field.getOne()).toDouble(); double err = (tst - ref) / ref; if (err != 0) { double ulp = Math.abs(ref - Double.longBitsToDouble((Double .doubleToLongBits(ref) ^ 1))); double errulp = field.newDfp(tst).subtract(DfpMath.exp(field.newDfp(x)).subtract(field.getOne())).divide(field.newDfp(ulp)).toDouble(); // System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp); maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); } } Assert.assertTrue("expm1() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); } @Test public void testAsinAccuracy() { double maxerrulp = 0.0; for (int i=0; i<10000; i++) { double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble(); double tst = FastMath.asin(x); double ref = DfpMath.asin(field.newDfp(x)).toDouble(); double err = (tst - ref) / ref; if (err != 0) { double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1))); double errulp = field.newDfp(tst).subtract(DfpMath.asin(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble(); //System.out.println(x+"\t"+tst+"\t"+ref+"\t"+err+"\t"+errulp); maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); } } Assert.assertTrue("asin() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); } @Test public void testAcosAccuracy() { double maxerrulp = 0.0; for (int i=0; i<10000; i++) { double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble(); double tst = FastMath.acos(x); double ref = DfpMath.acos(field.newDfp(x)).toDouble(); double err = (tst - ref) / ref; if (err != 0) { double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1))); double errulp = field.newDfp(tst).subtract(DfpMath.acos(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble(); //System.out.println(x+"\t"+tst+"\t"+ref+"\t"+err+"\t"+errulp); maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); } } Assert.assertTrue("acos() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); } /** * Added tests for a 100% coverage of acos(). */ @Test public void testAcosSpecialCases() { Assert.assertTrue("acos(NaN) should be NaN", Double.isNaN(FastMath.acos(Double.NaN))); Assert.assertTrue("acos(-1.1) should be NaN", Double.isNaN(FastMath.acos(-1.1))); Assert.assertTrue("acos(-1.1) should be NaN", Double.isNaN(FastMath.acos(1.1))); Assert.assertEquals("acos(-1.0) should be PI", FastMath.acos(-1.0), FastMath.PI, Precision.EPSILON); Assert.assertEquals("acos(1.0) should be 0.0", FastMath.acos(1.0), 0.0, Precision.EPSILON); Assert.assertEquals("acos(0.0) should be PI/2", FastMath.acos(0.0), FastMath.PI / 2.0, Precision.EPSILON); } /** * Added tests for a 100% coverage of asin(). */ @Test public void testAsinSpecialCases() { Assert.assertTrue("asin(NaN) should be NaN", Double.isNaN(FastMath.asin(Double.NaN))); Assert.assertTrue("asin(1.1) should be NaN", Double.isNaN(FastMath.asin(1.1))); Assert.assertTrue("asin(-1.1) should be NaN", Double.isNaN(FastMath.asin(-1.1))); Assert.assertEquals("asin(1.0) should be PI/2", FastMath.asin(1.0), FastMath.PI / 2.0, Precision.EPSILON); Assert.assertEquals("asin(-1.0) should be -PI/2", FastMath.asin(-1.0), -FastMath.PI / 2.0, Precision.EPSILON); Assert.assertEquals("asin(0.0) should be 0.0", FastMath.asin(0.0), 0.0, Precision.EPSILON); } private Dfp cosh(Dfp x) { return DfpMath.exp(x).add(DfpMath.exp(x.negate())).divide(2); } private Dfp sinh(Dfp x) { return DfpMath.exp(x).subtract(DfpMath.exp(x.negate())).divide(2); } private Dfp tanh(Dfp x) { return sinh(x).divide(cosh(x)); } @Test public void testSinhAccuracy() { double maxerrulp = 0.0; for (int i=0; i<10000; i++) { double x = ((generator.nextDouble() * 16.0) - 8.0) * generator.nextDouble(); double tst = FastMath.sinh(x); double ref = sinh(field.newDfp(x)).toDouble(); double err = (tst - ref) / ref; if (err != 0) { double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1))); double errulp = field.newDfp(tst).subtract(sinh(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble(); //System.out.println(x+"\t"+tst+"\t"+ref+"\t"+err+"\t"+errulp); maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); } } Assert.assertTrue("sinh() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); } @Test public void testCoshAccuracy() { double maxerrulp = 0.0; for (int i=0; i<10000; i++) { double x = ((generator.nextDouble() * 16.0) - 8.0) * generator.nextDouble(); double tst = FastMath.cosh(x); double ref = cosh(field.newDfp(x)).toDouble(); double err = (tst - ref) / ref; if (err != 0) { double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1))); double errulp = field.newDfp(tst).subtract(cosh(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble(); //System.out.println(x+"\t"+tst+"\t"+ref+"\t"+err+"\t"+errulp); maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); } } Assert.assertTrue("cosh() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); } @Test public void testTanhAccuracy() { double maxerrulp = 0.0; for (int i=0; i<10000; i++) { double x = ((generator.nextDouble() * 16.0) - 8.0) * generator.nextDouble(); double tst = FastMath.tanh(x); double ref = tanh(field.newDfp(x)).toDouble(); double err = (tst - ref) / ref; if (err != 0) { double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1))); double errulp = field.newDfp(tst).subtract(tanh(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble(); //System.out.println(x+"\t"+tst+"\t"+ref+"\t"+err+"\t"+errulp); maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); } } Assert.assertTrue("tanh() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); } @Test public void testCbrtAccuracy() { double maxerrulp = 0.0; for (int i=0; i<10000; i++) { double x = ((generator.nextDouble() * 200.0) - 100.0) * generator.nextDouble(); double tst = FastMath.cbrt(x); double ref = cbrt(field.newDfp(x)).toDouble(); double err = (tst - ref) / ref; if (err != 0) { double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1))); double errulp = field.newDfp(tst).subtract(cbrt(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble(); //System.out.println(x+"\t"+tst+"\t"+ref+"\t"+err+"\t"+errulp); maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); } } Assert.assertTrue("cbrt() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); } private Dfp cbrt(Dfp x) { boolean negative=false; if (x.lessThan(field.getZero())) { negative = true; x = x.negate(); } Dfp y = DfpMath.pow(x, field.getOne().divide(3)); if (negative) { y = y.negate(); } return y; } @Test public void testToDegrees() { double maxerrulp = 0.0; for (int i = 0; i < NUMBER_OF_TRIALS; i++) { double x = generator.nextDouble(); double tst = field.newDfp(x).multiply(180).divide(field.getPi()).toDouble(); double ref = FastMath.toDegrees(x); double err = (tst - ref) / ref; if (err != 0) { double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1))); double errulp = field.newDfp(tst).subtract(DfpMath.exp(field.newDfp(x)).subtract(field.getOne())).divide(field.newDfp(ulp)).toDouble(); // System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp); maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); } } Assert.assertTrue("toDegrees() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); } @Test public void testToRadians() { double maxerrulp = 0.0; for (int i = 0; i < NUMBER_OF_TRIALS; i++) { double x = generator.nextDouble(); double tst = field.newDfp(x).multiply(field.getPi()).divide(180).toDouble(); double ref = FastMath.toRadians(x); double err = (tst - ref) / ref; if (err != 0) { double ulp = Math.abs(ref - Double.longBitsToDouble((Double .doubleToLongBits(ref) ^ 1))); double errulp = field.newDfp(tst).subtract(DfpMath.exp(field.newDfp(x)).subtract(field.getOne())).divide(field.newDfp(ulp)).toDouble(); // System.out.println(x + "\t" + tst + "\t" + ref + "\t" + err + "\t" + errulp); maxerrulp = Math.max(maxerrulp, Math.abs(errulp)); } } Assert.assertTrue("toRadians() had errors in excess of " + MAX_ERROR_ULP + " ULP", maxerrulp < MAX_ERROR_ULP); } @Test public void testNextAfter() { // 0x402fffffffffffff 0x404123456789abcd -> 4030000000000000 Assert.assertEquals(16.0, FastMath.nextAfter(15.999999999999998, 34.27555555555555), 0.0); // 0xc02fffffffffffff 0x404123456789abcd -> c02ffffffffffffe Assert.assertEquals(-15.999999999999996, FastMath.nextAfter(-15.999999999999998, 34.27555555555555), 0.0); // 0x402fffffffffffff 0x400123456789abcd -> 402ffffffffffffe Assert.assertEquals(15.999999999999996, FastMath.nextAfter(15.999999999999998, 2.142222222222222), 0.0); // 0xc02fffffffffffff 0x400123456789abcd -> c02ffffffffffffe Assert.assertEquals(-15.999999999999996, FastMath.nextAfter(-15.999999999999998, 2.142222222222222), 0.0); // 0x4020000000000000 0x404123456789abcd -> 4020000000000001 Assert.assertEquals(8.000000000000002, FastMath.nextAfter(8.0, 34.27555555555555), 0.0); // 0xc020000000000000 0x404123456789abcd -> c01fffffffffffff Assert.assertEquals(-7.999999999999999, FastMath.nextAfter(-8.0, 34.27555555555555), 0.0); // 0x4020000000000000 0x400123456789abcd -> 401fffffffffffff Assert.assertEquals(7.999999999999999, FastMath.nextAfter(8.0, 2.142222222222222), 0.0); // 0xc020000000000000 0x400123456789abcd -> c01fffffffffffff Assert.assertEquals(-7.999999999999999, FastMath.nextAfter(-8.0, 2.142222222222222), 0.0); // 0x3f2e43753d36a223 0x3f2e43753d36a224 -> 3f2e43753d36a224 Assert.assertEquals(2.308922399667661E-4, FastMath.nextAfter(2.3089223996676606E-4, 2.308922399667661E-4), 0.0); // 0x3f2e43753d36a223 0x3f2e43753d36a223 -> 3f2e43753d36a223 Assert.assertEquals(2.3089223996676606E-4, FastMath.nextAfter(2.3089223996676606E-4, 2.3089223996676606E-4), 0.0); // 0x3f2e43753d36a223 0x3f2e43753d36a222 -> 3f2e43753d36a222 Assert.assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, 2.3089223996676603E-4), 0.0); // 0x3f2e43753d36a223 0xbf2e43753d36a224 -> 3f2e43753d36a222 Assert.assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, -2.308922399667661E-4), 0.0); // 0x3f2e43753d36a223 0xbf2e43753d36a223 -> 3f2e43753d36a222 Assert.assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, -2.3089223996676606E-4), 0.0); // 0x3f2e43753d36a223 0xbf2e43753d36a222 -> 3f2e43753d36a222 Assert.assertEquals(2.3089223996676603E-4, FastMath.nextAfter(2.3089223996676606E-4, -2.3089223996676603E-4), 0.0); // 0xbf2e43753d36a223 0x3f2e43753d36a224 -> bf2e43753d36a222 Assert.assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, 2.308922399667661E-4), 0.0); // 0xbf2e43753d36a223 0x3f2e43753d36a223 -> bf2e43753d36a222 Assert.assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, 2.3089223996676606E-4), 0.0); // 0xbf2e43753d36a223 0x3f2e43753d36a222 -> bf2e43753d36a222 Assert.assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, 2.3089223996676603E-4), 0.0); // 0xbf2e43753d36a223 0xbf2e43753d36a224 -> bf2e43753d36a224 Assert.assertEquals(-2.308922399667661E-4, FastMath.nextAfter(-2.3089223996676606E-4, -2.308922399667661E-4), 0.0); // 0xbf2e43753d36a223 0xbf2e43753d36a223 -> bf2e43753d36a223 Assert.assertEquals(-2.3089223996676606E-4, FastMath.nextAfter(-2.3089223996676606E-4, -2.3089223996676606E-4), 0.0); // 0xbf2e43753d36a223 0xbf2e43753d36a222 -> bf2e43753d36a222 Assert.assertEquals(-2.3089223996676603E-4, FastMath.nextAfter(-2.3089223996676606E-4, -2.3089223996676603E-4), 0.0); } @Test public void testDoubleNextAfterSpecialCases() { Assert.assertEquals(-Double.MAX_VALUE,FastMath.nextAfter(Double.NEGATIVE_INFINITY, 0D), 0D); Assert.assertEquals(Double.MAX_VALUE,FastMath.nextAfter(Double.POSITIVE_INFINITY, 0D), 0D); Assert.assertEquals(Double.NaN,FastMath.nextAfter(Double.NaN, 0D), 0D); Assert.assertEquals(Double.POSITIVE_INFINITY,FastMath.nextAfter(Double.MAX_VALUE, Double.POSITIVE_INFINITY), 0D); Assert.assertEquals(Double.NEGATIVE_INFINITY,FastMath.nextAfter(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY), 0D); Assert.assertEquals(Double.MIN_VALUE, FastMath.nextAfter(0D, 1D), 0D); Assert.assertEquals(-Double.MIN_VALUE, FastMath.nextAfter(0D, -1D), 0D); Assert.assertEquals(0D, FastMath.nextAfter(Double.MIN_VALUE, -1), 0D); Assert.assertEquals(0D, FastMath.nextAfter(-Double.MIN_VALUE, 1), 0D); } @Test public void testFloatNextAfterSpecialCases() { Assert.assertEquals(-Float.MAX_VALUE,FastMath.nextAfter(Float.NEGATIVE_INFINITY, 0F), 0F); Assert.assertEquals(Float.MAX_VALUE,FastMath.nextAfter(Float.POSITIVE_INFINITY, 0F), 0F); Assert.assertEquals(Float.NaN,FastMath.nextAfter(Float.NaN, 0F), 0F); Assert.assertEquals(Float.POSITIVE_INFINITY,FastMath.nextAfter(Float.MAX_VALUE, Float.POSITIVE_INFINITY), 0F); Assert.assertEquals(Float.NEGATIVE_INFINITY,FastMath.nextAfter(-Float.MAX_VALUE, Float.NEGATIVE_INFINITY), 0F); Assert.assertEquals(Float.MIN_VALUE, FastMath.nextAfter(0F, 1F), 0F); Assert.assertEquals(-Float.MIN_VALUE, FastMath.nextAfter(0F, -1F), 0F); Assert.assertEquals(0F, FastMath.nextAfter(Float.MIN_VALUE, -1F), 0F); Assert.assertEquals(0F, FastMath.nextAfter(-Float.MIN_VALUE, 1F), 0F); } @Test public void testDoubleScalbSpecialCases() { Assert.assertEquals(2.5269841324701218E-175, FastMath.scalb(2.2250738585072014E-308, 442), 0D); Assert.assertEquals(1.307993905256674E297, FastMath.scalb(1.1102230246251565E-16, 1040), 0D); Assert.assertEquals(7.2520887996488946E-217, FastMath.scalb(Double.MIN_VALUE, 356), 0D); Assert.assertEquals(8.98846567431158E307, FastMath.scalb(Double.MIN_VALUE, 2097), 0D); Assert.assertEquals(Double.POSITIVE_INFINITY, FastMath.scalb(Double.MIN_VALUE, 2098), 0D); Assert.assertEquals(1.1125369292536007E-308, FastMath.scalb(2.225073858507201E-308, -1), 0D); Assert.assertEquals(1.0E-323, FastMath.scalb(Double.MAX_VALUE, -2097), 0D); Assert.assertEquals(Double.MIN_VALUE, FastMath.scalb(Double.MAX_VALUE, -2098), 0D); Assert.assertEquals(0, FastMath.scalb(Double.MAX_VALUE, -2099), 0D); Assert.assertEquals(Double.POSITIVE_INFINITY, FastMath.scalb(Double.POSITIVE_INFINITY, -1000000), 0D); Assert.assertEquals(Double.NEGATIVE_INFINITY, FastMath.scalb(-1.1102230246251565E-16, 1078), 0D); Assert.assertEquals(Double.NEGATIVE_INFINITY, FastMath.scalb(-1.1102230246251565E-16, 1079), 0D); Assert.assertEquals(Double.NEGATIVE_INFINITY, FastMath.scalb(-2.2250738585072014E-308, 2047), 0D); Assert.assertEquals(Double.NEGATIVE_INFINITY, FastMath.scalb(-2.2250738585072014E-308, 2048), 0D); Assert.assertEquals(Double.NEGATIVE_INFINITY, FastMath.scalb(-1.7976931348623157E308, 2147483647), 0D); Assert.assertEquals(Double.POSITIVE_INFINITY, FastMath.scalb( 1.7976931348623157E308, 2147483647), 0D); Assert.assertEquals(Double.NEGATIVE_INFINITY, FastMath.scalb(-1.1102230246251565E-16, 2147483647), 0D); Assert.assertEquals(Double.POSITIVE_INFINITY, FastMath.scalb( 1.1102230246251565E-16, 2147483647), 0D); Assert.assertEquals(Double.NEGATIVE_INFINITY, FastMath.scalb(-2.2250738585072014E-308, 2147483647), 0D); Assert.assertEquals(Double.POSITIVE_INFINITY, FastMath.scalb( 2.2250738585072014E-308, 2147483647), 0D); } @Test public void testFloatScalbSpecialCases() { Assert.assertEquals(0f, FastMath.scalb(Float.MIN_VALUE, -30), 0F); Assert.assertEquals(2 * Float.MIN_VALUE, FastMath.scalb(Float.MIN_VALUE, 1), 0F); Assert.assertEquals(7.555786e22f, FastMath.scalb(Float.MAX_VALUE, -52), 0F); Assert.assertEquals(1.7014118e38f, FastMath.scalb(Float.MIN_VALUE, 276), 0F); Assert.assertEquals(Float.POSITIVE_INFINITY, FastMath.scalb(Float.MIN_VALUE, 277), 0F); Assert.assertEquals(5.8774718e-39f, FastMath.scalb(1.1754944e-38f, -1), 0F); Assert.assertEquals(2 * Float.MIN_VALUE, FastMath.scalb(Float.MAX_VALUE, -276), 0F); Assert.assertEquals(Float.MIN_VALUE, FastMath.scalb(Float.MAX_VALUE, -277), 0F); Assert.assertEquals(0, FastMath.scalb(Float.MAX_VALUE, -278), 0F); Assert.assertEquals(Float.POSITIVE_INFINITY, FastMath.scalb(Float.POSITIVE_INFINITY, -1000000), 0F); Assert.assertEquals(-3.13994498e38f, FastMath.scalb(-1.1e-7f, 151), 0F); Assert.assertEquals(Float.NEGATIVE_INFINITY, FastMath.scalb(-1.1e-7f, 152), 0F); Assert.assertEquals(Float.POSITIVE_INFINITY, FastMath.scalb(3.4028235E38f, 2147483647), 0F); Assert.assertEquals(Float.NEGATIVE_INFINITY, FastMath.scalb(-3.4028235E38f, 2147483647), 0F); } private boolean compareClassMethods(Class<?> class1, Class<?> class2){ boolean allfound = true; for(Method method1 : class1.getDeclaredMethods()){ if (Modifier.isPublic(method1.getModifiers())){ Type []params = method1.getGenericParameterTypes(); try { class2.getDeclaredMethod(method1.getName(), (Class[]) params); } catch (NoSuchMethodException e) { allfound = false; System.out.println(class2.getSimpleName()+" does not implement: "+method1); } } } return allfound; } @Test public void checkMissingFastMathClasses() { boolean ok = compareClassMethods(StrictMath.class, FastMath.class); Assert.assertTrue("FastMath should implement all StrictMath methods", ok); } @Ignore @Test public void checkExtraFastMathClasses() { compareClassMethods( FastMath.class, StrictMath.class); } @Test public void testSignumDouble() { final double delta = 0.0; Assert.assertEquals(1.0, FastMath.signum(2.0), delta); Assert.assertEquals(0.0, FastMath.signum(0.0), delta); Assert.assertEquals(-1.0, FastMath.signum(-2.0), delta); TestUtils.assertSame(-0. / 0., FastMath.signum(Double.NaN)); } @Test public void testSignumFloat() { final float delta = 0.0F; Assert.assertEquals(1.0F, FastMath.signum(2.0F), delta); Assert.assertEquals(0.0F, FastMath.signum(0.0F), delta); Assert.assertEquals(-1.0F, FastMath.signum(-2.0F), delta); TestUtils.assertSame(Float.NaN, FastMath.signum(Float.NaN)); } @Test public void testLogWithBase() { Assert.assertEquals(2.0, FastMath.log(2, 4), 0); Assert.assertEquals(3.0, FastMath.log(2, 8), 0); Assert.assertTrue(Double.isNaN(FastMath.log(-1, 1))); Assert.assertTrue(Double.isNaN(FastMath.log(1, -1))); Assert.assertTrue(Double.isNaN(FastMath.log(0, 0))); Assert.assertEquals(0, FastMath.log(0, 10), 0); Assert.assertEquals(Double.NEGATIVE_INFINITY, FastMath.log(10, 0), 0); } @Test public void testIndicatorDouble() { double delta = 0.0; Assert.assertEquals(1.0, FastMath.copySign(1d, 2.0), delta); Assert.assertEquals(1.0, FastMath.copySign(1d, 0.0), delta); Assert.assertEquals(-1.0, FastMath.copySign(1d, -0.0), delta); Assert.assertEquals(1.0, FastMath.copySign(1d, Double.POSITIVE_INFINITY), delta); Assert.assertEquals(-1.0, FastMath.copySign(1d, Double.NEGATIVE_INFINITY), delta); Assert.assertEquals(1.0, FastMath.copySign(1d, Double.NaN), delta); Assert.assertEquals(-1.0, FastMath.copySign(1d, -2.0), delta); } @Test public void testIndicatorFloat() { float delta = 0.0F; Assert.assertEquals(1.0F, FastMath.copySign(1d, 2.0F), delta); Assert.assertEquals(1.0F, FastMath.copySign(1d, 0.0F), delta); Assert.assertEquals(-1.0F, FastMath.copySign(1d, -0.0F), delta); Assert.assertEquals(1.0F, FastMath.copySign(1d, Float.POSITIVE_INFINITY), delta); Assert.assertEquals(-1.0F, FastMath.copySign(1d, Float.NEGATIVE_INFINITY), delta); Assert.assertEquals(1.0F, FastMath.copySign(1d, Float.NaN), delta); Assert.assertEquals(-1.0F, FastMath.copySign(1d, -2.0F), delta); } @Test public void testIntPow() { final int maxExp = 300; DfpField field = new DfpField(40); final double base = 1.23456789; Dfp baseDfp = field.newDfp(base); Dfp dfpPower = field.getOne(); for (int i = 0; i < maxExp; i++) { Assert.assertEquals("exp=" + i, dfpPower.toDouble(), FastMath.pow(base, i), 0.6 * FastMath.ulp(dfpPower.toDouble())); dfpPower = dfpPower.multiply(baseDfp); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */ package org.apache.commons.math3.util; import org.apache.commons.math3.exception.MaxCountExceededException; import org.apache.commons.math3.exception.TooManyEvaluationsException; import org.junit.Assert; import org.junit.Test; /** * Test for {@link Incrementor}. */ public class IncrementorTest { @Test public void testConstructor1() { final Incrementor i = new Incrementor(); Assert.assertEquals(0, i.getMaximalCount()); Assert.assertEquals(0, i.getCount()); } @Test public void testConstructor2() { final Incrementor i = new Incrementor(10); Assert.assertEquals(10, i.getMaximalCount()); Assert.assertEquals(0, i.getCount()); } @Test public void testCanIncrement1() { final Incrementor i = new Incrementor(3); Assert.assertTrue(i.canIncrement()); i.incrementCount(); Assert.assertTrue(i.canIncrement()); i.incrementCount(); Assert.assertTrue(i.canIncrement()); i.incrementCount(); Assert.assertFalse(i.canIncrement()); } @Test public void testCanIncrement2() { final Incrementor i = new Incrementor(3); while (i.canIncrement()) { i.incrementCount(); } // Must keep try/catch because the exception must be generated here, // and not in the previous loop. try { i.incrementCount(); Assert.fail("MaxCountExceededException expected"); } catch (MaxCountExceededException e) { // Expected. } } @Test public void testAccessor() { final Incrementor i = new Incrementor(); i.setMaximalCount(10); Assert.assertEquals(10, i.getMaximalCount()); Assert.assertEquals(0, i.getCount()); } @Test public void testBelowMaxCount() { final Incrementor i = new Incrementor(); i.setMaximalCount(3); i.incrementCount(); i.incrementCount(); i.incrementCount(); Assert.assertEquals(3, i.getCount()); } @Test(expected=MaxCountExceededException.class) public void testAboveMaxCount() { final Incrementor i = new Incrementor(); i.setMaximalCount(3); i.incrementCount(); i.incrementCount(); i.incrementCount(); i.incrementCount(); } @Test(expected=TooManyEvaluationsException.class) public void testAlternateException() { final Incrementor.MaxCountExceededCallback cb = new Incrementor.MaxCountExceededCallback() { /** {@inheritDoc} */ public void trigger(int max) { throw new TooManyEvaluationsException(max); } }; final Incrementor i = new Incrementor(0, cb); i.incrementCount(); } @Test public void testReset() { final Incrementor i = new Incrementor(); i.setMaximalCount(3); i.incrementCount(); i.incrementCount(); i.incrementCount(); Assert.assertEquals(3, i.getCount()); i.resetCount(); Assert.assertEquals(0, i.getCount()); } @Test public void testBulkIncrement() { final Incrementor i = new Incrementor(); i.setMaximalCount(3); i.incrementCount(2); Assert.assertEquals(2, i.getCount()); i.incrementCount(1); Assert.assertEquals(3, i.getCount()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */ package org.apache.commons.math3.util; import java.util.Arrays; import java.util.Iterator; import org.apache.commons.math3.TestUtils; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.MathArithmeticException; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.exception.NoDataException; import org.apache.commons.math3.exception.NonMonotonicSequenceException; import org.apache.commons.math3.exception.NotPositiveException; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.apache.commons.math3.exception.NullArgumentException; import org.apache.commons.math3.random.Well1024a; import org.junit.Assert; import org.junit.Test; /** * Test cases for the {@link MathArrays} class. * * @version $Id$ */ public class MathArraysTest { @Test public void testScale() { final double[] test = new double[] { -2.5, -1, 0, 1, 2.5 }; final double[] correctTest = MathArrays.copyOf(test); final double[] correctScaled = new double[]{5.25, 2.1, 0, -2.1, -5.25}; final double[] scaled = MathArrays.scale(-2.1, test); // Make sure test has not changed for (int i = 0; i < test.length; i++) { Assert.assertEquals(correctTest[i], test[i], 0); } // Test scaled values for (int i = 0; i < scaled.length; i++) { Assert.assertEquals(correctScaled[i], scaled[i], 0); } } @Test public void testScaleInPlace() { final double[] test = new double[] { -2.5, -1, 0, 1, 2.5 }; final double[] correctScaled = new double[]{5.25, 2.1, 0, -2.1, -5.25}; MathArrays.scaleInPlace(-2.1, test); // Make sure test has changed for (int i = 0; i < test.length; i++) { Assert.assertEquals(correctScaled[i], test[i], 0); } } @Test(expected=DimensionMismatchException.class) public void testEbeAddPrecondition() { MathArrays.ebeAdd(new double[3], new double[4]); } @Test(expected=DimensionMismatchException.class) public void testEbeSubtractPrecondition() { MathArrays.ebeSubtract(new double[3], new double[4]); } @Test(expected=DimensionMismatchException.class) public void testEbeMultiplyPrecondition() { MathArrays.ebeMultiply(new double[3], new double[4]); } @Test(expected=DimensionMismatchException.class) public void testEbeDividePrecondition() { MathArrays.ebeDivide(new double[3], new double[4]); } @Test public void testEbeAdd() { final double[] a = { 0, 1, 2 }; final double[] b = { 3, 5, 7 }; final double[] r = MathArrays.ebeAdd(a, b); for (int i = 0; i < a.length; i++) { Assert.assertEquals(a[i] + b[i], r[i], 0); } } @Test public void testEbeSubtract() { final double[] a = { 0, 1, 2 }; final double[] b = { 3, 5, 7 }; final double[] r = MathArrays.ebeSubtract(a, b); for (int i = 0; i < a.length; i++) { Assert.assertEquals(a[i] - b[i], r[i], 0); } } @Test public void testEbeMultiply() { final double[] a = { 0, 1, 2 }; final double[] b = { 3, 5, 7 }; final double[] r = MathArrays.ebeMultiply(a, b); for (int i = 0; i < a.length; i++) { Assert.assertEquals(a[i] * b[i], r[i], 0); } } @Test public void testEbeDivide() { final double[] a = { 0, 1, 2 }; final double[] b = { 3, 5, 7 }; final double[] r = MathArrays.ebeDivide(a, b); for (int i = 0; i < a.length; i++) { Assert.assertEquals(a[i] / b[i], r[i], 0); } } @Test public void testL1DistanceDouble() { double[] p1 = { 2.5, 0.0 }; double[] p2 = { -0.5, 4.0 }; Assert.assertTrue(Precision.equals(7.0, MathArrays.distance1(p1, p2), 1)); } @Test public void testL1DistanceInt() { int[] p1 = { 3, 0 }; int[] p2 = { 0, 4 }; Assert.assertEquals(7, MathArrays.distance1(p1, p2)); } @Test public void testL2DistanceDouble() { double[] p1 = { 2.5, 0.0 }; double[] p2 = { -0.5, 4.0 }; Assert.assertTrue(Precision.equals(5.0, MathArrays.distance(p1, p2), 1)); } @Test public void testL2DistanceInt() { int[] p1 = { 3, 0 }; int[] p2 = { 0, 4 }; Assert.assertTrue(Precision.equals(5, MathArrays.distance(p1, p2), 1)); } @Test public void testLInfDistanceDouble() { double[] p1 = { 2.5, 0.0 }; double[] p2 = { -0.5, 4.0 }; Assert.assertTrue(Precision.equals(4.0, MathArrays.distanceInf(p1, p2), 1)); } @Test public void testLInfDistanceInt() { int[] p1 = { 3, 0 }; int[] p2 = { 0, 4 }; Assert.assertEquals(4, MathArrays.distanceInf(p1, p2)); } @Test public void testCheckOrder() { MathArrays.checkOrder(new double[] {-15, -5.5, -1, 2, 15}, MathArrays.OrderDirection.INCREASING, true); MathArrays.checkOrder(new double[] {-15, -5.5, -1, 2, 2}, MathArrays.OrderDirection.INCREASING, false); MathArrays.checkOrder(new double[] {3, -5.5, -11, -27.5}, MathArrays.OrderDirection.DECREASING, true); MathArrays.checkOrder(new double[] {3, 0, 0, -5.5, -11, -27.5}, MathArrays.OrderDirection.DECREASING, false); try { MathArrays.checkOrder(new double[] {-15, -5.5, -1, -1, 2, 15}, MathArrays.OrderDirection.INCREASING, true); Assert.fail("an exception should have been thrown"); } catch (NonMonotonicSequenceException e) { // Expected } try { MathArrays.checkOrder(new double[] {-15, -5.5, -1, -2, 2}, MathArrays.OrderDirection.INCREASING, false); Assert.fail("an exception should have been thrown"); } catch (NonMonotonicSequenceException e) { // Expected } try { MathArrays.checkOrder(new double[] {3, 3, -5.5, -11, -27.5}, MathArrays.OrderDirection.DECREASING, true); Assert.fail("an exception should have been thrown"); } catch (NonMonotonicSequenceException e) { // Expected } try { MathArrays.checkOrder(new double[] {3, -1, 0, -5.5, -11, -27.5}, MathArrays.OrderDirection.DECREASING, false); Assert.fail("an exception should have been thrown"); } catch (NonMonotonicSequenceException e) { // Expected } try { MathArrays.checkOrder(new double[] {3, 0, -5.5, -11, -10}, MathArrays.OrderDirection.DECREASING, false); Assert.fail("an exception should have been thrown"); } catch (NonMonotonicSequenceException e) { // Expected } } @Test public void testIsMonotonic() { Assert.assertFalse(MathArrays.isMonotonic(new double[] { -15, -5.5, -1, -1, 2, 15 }, MathArrays.OrderDirection.INCREASING, true)); Assert.assertTrue(MathArrays.isMonotonic(new double[] { -15, -5.5, -1, 0, 2, 15 }, MathArrays.OrderDirection.INCREASING, true)); Assert.assertFalse(MathArrays.isMonotonic(new double[] { -15, -5.5, -1, -2, 2 }, MathArrays.OrderDirection.INCREASING, false)); Assert.assertTrue(MathArrays.isMonotonic(new double[] { -15, -5.5, -1, -1, 2 }, MathArrays.OrderDirection.INCREASING, false)); Assert.assertFalse(MathArrays.isMonotonic(new double[] { 3, 3, -5.5, -11, -27.5 }, MathArrays.OrderDirection.DECREASING, true)); Assert.assertTrue(MathArrays.isMonotonic(new double[] { 3, 2, -5.5, -11, -27.5 }, MathArrays.OrderDirection.DECREASING, true)); Assert.assertFalse(MathArrays.isMonotonic(new double[] { 3, -1, 0, -5.5, -11, -27.5 }, MathArrays.OrderDirection.DECREASING, false)); Assert.assertTrue(MathArrays.isMonotonic(new double[] { 3, 0, 0, -5.5, -11, -27.5 }, MathArrays.OrderDirection.DECREASING, false)); } @Test public void testIsMonotonicComparable() { Assert.assertFalse(MathArrays.isMonotonic(new Double[] { new Double(-15), new Double(-5.5), new Double(-1), new Double(-1), new Double(2), new Double(15) }, MathArrays.OrderDirection.INCREASING, true)); Assert.assertTrue(MathArrays.isMonotonic(new Double[] { new Double(-15), new Double(-5.5), new Double(-1), new Double(0), new Double(2), new Double(15) }, MathArrays.OrderDirection.INCREASING, true)); Assert.assertFalse(MathArrays.isMonotonic(new Double[] { new Double(-15), new Double(-5.5), new Double(-1), new Double(-2), new Double(2) }, MathArrays.OrderDirection.INCREASING, false)); Assert.assertTrue(MathArrays.isMonotonic(new Double[] { new Double(-15), new Double(-5.5), new Double(-1), new Double(-1), new Double(2) }, MathArrays.OrderDirection.INCREASING, false)); Assert.assertFalse(MathArrays.isMonotonic(new Double[] { new Double(3), new Double(3), new Double(-5.5), new Double(-11), new Double(-27.5) }, MathArrays.OrderDirection.DECREASING, true)); Assert.assertTrue(MathArrays.isMonotonic(new Double[] { new Double(3), new Double(2), new Double(-5.5), new Double(-11), new Double(-27.5) }, MathArrays.OrderDirection.DECREASING, true)); Assert.assertFalse(MathArrays.isMonotonic(new Double[] { new Double(3), new Double(-1), new Double(0), new Double(-5.5), new Double(-11), new Double(-27.5) }, MathArrays.OrderDirection.DECREASING, false)); Assert.assertTrue(MathArrays.isMonotonic(new Double[] { new Double(3), new Double(0), new Double(0), new Double(-5.5), new Double(-11), new Double(-27.5) }, MathArrays.OrderDirection.DECREASING, false)); } @Test public void testCheckRectangular() { final long[][] rect = new long[][] {{0, 1}, {2, 3}}; final long[][] ragged = new long[][] {{0, 1}, {2}}; final long[][] nullArray = null; final long[][] empty = new long[][] {}; MathArrays.checkRectangular(rect); MathArrays.checkRectangular(empty); try { MathArrays.checkRectangular(ragged); Assert.fail("Expecting DimensionMismatchException"); } catch (DimensionMismatchException ex) { // Expected } try { MathArrays.checkRectangular(nullArray); Assert.fail("Expecting NullArgumentException"); } catch (NullArgumentException ex) { // Expected } } @Test public void testCheckPositive() { final double[] positive = new double[] {1, 2, 3}; final double[] nonNegative = new double[] {0, 1, 2}; final double[] nullArray = null; final double[] empty = new double[] {}; MathArrays.checkPositive(positive); MathArrays.checkPositive(empty); try { MathArrays.checkPositive(nullArray); Assert.fail("Expecting NullPointerException"); } catch (NullPointerException ex) { // Expected } try { MathArrays.checkPositive(nonNegative); Assert.fail("Expecting NotStrictlyPositiveException"); } catch (NotStrictlyPositiveException ex) { // Expected } } @Test public void testCheckNonNegative() { final long[] nonNegative = new long[] {0, 1}; final long[] hasNegative = new long[] {-1}; final long[] nullArray = null; final long[] empty = new long[] {}; MathArrays.checkNonNegative(nonNegative); MathArrays.checkNonNegative(empty); try { MathArrays.checkNonNegative(nullArray); Assert.fail("Expecting NullPointerException"); } catch (NullPointerException ex) { // Expected } try { MathArrays.checkNonNegative(hasNegative); Assert.fail("Expecting NotPositiveException"); } catch (NotPositiveException ex) { // Expected } } @Test public void testCheckNonNegative2D() { final long[][] nonNegative = new long[][] {{0, 1}, {1, 0}}; final long[][] hasNegative = new long[][] {{-1}, {0}}; final long[][] nullArray = null; final long[][] empty = new long[][] {}; MathArrays.checkNonNegative(nonNegative); MathArrays.checkNonNegative(empty); try { MathArrays.checkNonNegative(nullArray); Assert.fail("Expecting NullPointerException"); } catch (NullPointerException ex) { // Expected } try { MathArrays.checkNonNegative(hasNegative); Assert.fail("Expecting NotPositiveException"); } catch (NotPositiveException ex) { // Expected } } @Test public void testSortInPlace() { final double[] x1 = {2, 5, -3, 1, 4}; final double[] x2 = {4, 25, 9, 1, 16}; final double[] x3 = {8, 125, -27, 1, 64}; MathArrays.sortInPlace(x1, x2, x3); Assert.assertEquals(-3, x1[0], Math.ulp(1d)); Assert.assertEquals(9, x2[0], Math.ulp(1d)); Assert.assertEquals(-27, x3[0], Math.ulp(1d)); Assert.assertEquals(1, x1[1], Math.ulp(1d)); Assert.assertEquals(1, x2[1], Math.ulp(1d)); Assert.assertEquals(1, x3[1], Math.ulp(1d)); Assert.assertEquals(2, x1[2], Math.ulp(1d)); Assert.assertEquals(4, x2[2], Math.ulp(1d)); Assert.assertEquals(8, x3[2], Math.ulp(1d)); Assert.assertEquals(4, x1[3], Math.ulp(1d)); Assert.assertEquals(16, x2[3], Math.ulp(1d)); Assert.assertEquals(64, x3[3], Math.ulp(1d)); Assert.assertEquals(5, x1[4], Math.ulp(1d)); Assert.assertEquals(25, x2[4], Math.ulp(1d)); Assert.assertEquals(125, x3[4], Math.ulp(1d)); } @Test public void testSortInPlaceDecresasingOrder() { final double[] x1 = {2, 5, -3, 1, 4}; final double[] x2 = {4, 25, 9, 1, 16}; final double[] x3 = {8, 125, -27, 1, 64}; MathArrays.sortInPlace(x1, MathArrays.OrderDirection.DECREASING, x2, x3); Assert.assertEquals(-3, x1[4], Math.ulp(1d)); Assert.assertEquals(9, x2[4], Math.ulp(1d)); Assert.assertEquals(-27, x3[4], Math.ulp(1d)); Assert.assertEquals(1, x1[3], Math.ulp(1d)); Assert.assertEquals(1, x2[3], Math.ulp(1d)); Assert.assertEquals(1, x3[3], Math.ulp(1d)); Assert.assertEquals(2, x1[2], Math.ulp(1d)); Assert.assertEquals(4, x2[2], Math.ulp(1d)); Assert.assertEquals(8, x3[2], Math.ulp(1d)); Assert.assertEquals(4, x1[1], Math.ulp(1d)); Assert.assertEquals(16, x2[1], Math.ulp(1d)); Assert.assertEquals(64, x3[1], Math.ulp(1d)); Assert.assertEquals(5, x1[0], Math.ulp(1d)); Assert.assertEquals(25, x2[0], Math.ulp(1d)); Assert.assertEquals(125, x3[0], Math.ulp(1d)); } @Test /** Example in javadoc */ public void testSortInPlaceExample() { final double[] x = {3, 1, 2}; final double[] y = {1, 2, 3}; final double[] z = {0, 5, 7}; MathArrays.sortInPlace(x, y, z); final double[] sx = {1, 2, 3}; final double[] sy = {2, 3, 1}; final double[] sz = {5, 7, 0}; Assert.assertTrue(Arrays.equals(sx, x)); Assert.assertTrue(Arrays.equals(sy, y)); Assert.assertTrue(Arrays.equals(sz, z)); } @Test public void testSortInPlaceFailures() { final double[] nullArray = null; final double[] one = {1}; final double[] two = {1, 2}; final double[] onep = {2}; try { MathArrays.sortInPlace(one, two); Assert.fail("Expecting DimensionMismatchException"); } catch (DimensionMismatchException ex) { // expected } try { MathArrays.sortInPlace(one, nullArray); Assert.fail("Expecting NullArgumentException"); } catch (NullArgumentException ex) { // expected } try { MathArrays.sortInPlace(one, onep, nullArray); Assert.fail("Expecting NullArgumentException"); } catch (NullArgumentException ex) { // expected } } @Test public void testCopyOfInt() { final int[] source = { Integer.MIN_VALUE, -1, 0, 1, 3, 113, 4769, Integer.MAX_VALUE }; final int[] dest = MathArrays.copyOf(source); Assert.assertEquals(dest.length, source.length); for (int i = 0; i < source.length; i++) { Assert.assertEquals(source[i], dest[i]); } } @Test public void testCopyOfInt2() { final int[] source = { Integer.MIN_VALUE, -1, 0, 1, 3, 113, 4769, Integer.MAX_VALUE }; final int offset = 3; final int[] dest = MathArrays.copyOf(source, source.length - offset); Assert.assertEquals(dest.length, source.length - offset); for (int i = 0; i < source.length - offset; i++) { Assert.assertEquals(source[i], dest[i]); } } @Test public void testCopyOfInt3() { final int[] source = { Integer.MIN_VALUE, -1, 0, 1, 3, 113, 4769, Integer.MAX_VALUE }; final int offset = 3; final int[] dest = MathArrays.copyOf(source, source.length + offset); Assert.assertEquals(dest.length, source.length + offset); for (int i = 0; i < source.length; i++) { Assert.assertEquals(source[i], dest[i]); } for (int i = source.length; i < source.length + offset; i++) { Assert.assertEquals(0, dest[i], 0); } } @Test public void testCopyOfDouble() { final double[] source = { Double.NEGATIVE_INFINITY, -Double.MAX_VALUE, -1, 0, Double.MIN_VALUE, Math.ulp(1d), 1, 3, 113, 4769, Double.MAX_VALUE, Double.POSITIVE_INFINITY }; final double[] dest = MathArrays.copyOf(source); Assert.assertEquals(dest.length, source.length); for (int i = 0; i < source.length; i++) { Assert.assertEquals(source[i], dest[i], 0); } } @Test public void testCopyOfDouble2() { final double[] source = { Double.NEGATIVE_INFINITY, -Double.MAX_VALUE, -1, 0, Double.MIN_VALUE, Math.ulp(1d), 1, 3, 113, 4769, Double.MAX_VALUE, Double.POSITIVE_INFINITY }; final int offset = 3; final double[] dest = MathArrays.copyOf(source, source.length - offset); Assert.assertEquals(dest.length, source.length - offset); for (int i = 0; i < source.length - offset; i++) { Assert.assertEquals(source[i], dest[i], 0); } } @Test public void testCopyOfDouble3() { final double[] source = { Double.NEGATIVE_INFINITY, -Double.MAX_VALUE, -1, 0, Double.MIN_VALUE, Math.ulp(1d), 1, 3, 113, 4769, Double.MAX_VALUE, Double.POSITIVE_INFINITY }; final int offset = 3; final double[] dest = MathArrays.copyOf(source, source.length + offset); Assert.assertEquals(dest.length, source.length + offset); for (int i = 0; i < source.length; i++) { Assert.assertEquals(source[i], dest[i], 0); } for (int i = source.length; i < source.length + offset; i++) { Assert.assertEquals(0, dest[i], 0); } } // MATH-1005 @Test public void testLinearCombinationWithSingleElementArray() { final double[] a = { 1.23456789 }; final double[] b = { 98765432.1 }; Assert.assertEquals(a[0] * b[0], MathArrays.linearCombination(a, b), 0d); } @Test public void testLinearCombination1() { final double[] a = new double[] { -1321008684645961.0 / 268435456.0, -5774608829631843.0 / 268435456.0, -7645843051051357.0 / 8589934592.0 }; final double[] b = new double[] { -5712344449280879.0 / 2097152.0, -4550117129121957.0 / 2097152.0, 8846951984510141.0 / 131072.0 }; final double abSumInline = MathArrays.linearCombination(a[0], b[0], a[1], b[1], a[2], b[2]); final double abSumArray = MathArrays.linearCombination(a, b); Assert.assertEquals(abSumInline, abSumArray, 0); Assert.assertEquals(-1.8551294182586248737720779899, abSumInline, 1.0e-15); final double naive = a[0] * b[0] + a[1] * b[1] + a[2] * b[2]; Assert.assertTrue(FastMath.abs(naive - abSumInline) > 1.5); } @Test public void testLinearCombination2() { // we compare accurate versus naive dot product implementations // on regular vectors (i.e. not extreme cases like in the previous test) Well1024a random = new Well1024a(553267312521321234l); for (int i = 0; i < 10000; ++i) { final double ux = 1e17 * random.nextDouble(); final double uy = 1e17 * random.nextDouble(); final double uz = 1e17 * random.nextDouble(); final double vx = 1e17 * random.nextDouble(); final double vy = 1e17 * random.nextDouble(); final double vz = 1e17 * random.nextDouble(); final double sInline = MathArrays.linearCombination(ux, vx, uy, vy, uz, vz); final double sArray = MathArrays.linearCombination(new double[] {ux, uy, uz}, new double[] {vx, vy, vz}); Assert.assertEquals(sInline, sArray, 0); } } @Test public void testLinearCombinationInfinite() { final double[][] a = new double[][] { { 1, 2, 3, 4}, { 1, Double.POSITIVE_INFINITY, 3, 4}, { 1, 2, Double.POSITIVE_INFINITY, 4}, { 1, Double.POSITIVE_INFINITY, 3, Double.NEGATIVE_INFINITY}, { 1, 2, 3, 4}, { 1, 2, 3, 4}, { 1, 2, 3, 4}, { 1, 2, 3, 4} }; final double[][] b = new double[][] { { 1, -2, 3, 4}, { 1, -2, 3, 4}, { 1, -2, 3, 4}, { 1, -2, 3, 4}, { 1, Double.POSITIVE_INFINITY, 3, 4}, { 1, -2, Double.POSITIVE_INFINITY, 4}, { 1, Double.POSITIVE_INFINITY, 3, Double.NEGATIVE_INFINITY}, { Double.NaN, -2, 3, 4} }; Assert.assertEquals(-3, MathArrays.linearCombination(a[0][0], b[0][0], a[0][1], b[0][1]), 1.0e-10); Assert.assertEquals(6, MathArrays.linearCombination(a[0][0], b[0][0], a[0][1], b[0][1], a[0][2], b[0][2]), 1.0e-10); Assert.assertEquals(22, MathArrays.linearCombination(a[0][0], b[0][0], a[0][1], b[0][1], a[0][2], b[0][2], a[0][3], b[0][3]), 1.0e-10); Assert.assertEquals(22, MathArrays.linearCombination(a[0], b[0]), 1.0e-10); Assert.assertEquals(Double.NEGATIVE_INFINITY, MathArrays.linearCombination(a[1][0], b[1][0], a[1][1], b[1][1]), 1.0e-10); Assert.assertEquals(Double.NEGATIVE_INFINITY, MathArrays.linearCombination(a[1][0], b[1][0], a[1][1], b[1][1], a[1][2], b[1][2]), 1.0e-10); Assert.assertEquals(Double.NEGATIVE_INFINITY, MathArrays.linearCombination(a[1][0], b[1][0], a[1][1], b[1][1], a[1][2], b[1][2], a[1][3], b[1][3]), 1.0e-10); Assert.assertEquals(Double.NEGATIVE_INFINITY, MathArrays.linearCombination(a[1], b[1]), 1.0e-10); Assert.assertEquals(-3, MathArrays.linearCombination(a[2][0], b[2][0], a[2][1], b[2][1]), 1.0e-10); Assert.assertEquals(Double.POSITIVE_INFINITY, MathArrays.linearCombination(a[2][0], b[2][0], a[2][1], b[2][1], a[2][2], b[2][2]), 1.0e-10); Assert.assertEquals(Double.POSITIVE_INFINITY, MathArrays.linearCombination(a[2][0], b[2][0], a[2][1], b[2][1], a[2][2], b[2][2], a[2][3], b[2][3]), 1.0e-10); Assert.assertEquals(Double.POSITIVE_INFINITY, MathArrays.linearCombination(a[2], b[2]), 1.0e-10); Assert.assertEquals(Double.NEGATIVE_INFINITY, MathArrays.linearCombination(a[3][0], b[3][0], a[3][1], b[3][1]), 1.0e-10); Assert.assertEquals(Double.NEGATIVE_INFINITY, MathArrays.linearCombination(a[3][0], b[3][0], a[3][1], b[3][1], a[3][2], b[3][2]), 1.0e-10); Assert.assertEquals(Double.NEGATIVE_INFINITY, MathArrays.linearCombination(a[3][0], b[3][0], a[3][1], b[3][1], a[3][2], b[3][2], a[3][3], b[3][3]), 1.0e-10); Assert.assertEquals(Double.NEGATIVE_INFINITY, MathArrays.linearCombination(a[3], b[3]), 1.0e-10); Assert.assertEquals(Double.POSITIVE_INFINITY, MathArrays.linearCombination(a[4][0], b[4][0], a[4][1], b[4][1]), 1.0e-10); Assert.assertEquals(Double.POSITIVE_INFINITY, MathArrays.linearCombination(a[4][0], b[4][0], a[4][1], b[4][1], a[4][2], b[4][2]), 1.0e-10); Assert.assertEquals(Double.POSITIVE_INFINITY, MathArrays.linearCombination(a[4][0], b[4][0], a[4][1], b[4][1], a[4][2], b[4][2], a[4][3], b[4][3]), 1.0e-10); Assert.assertEquals(Double.POSITIVE_INFINITY, MathArrays.linearCombination(a[4], b[4]), 1.0e-10); Assert.assertEquals(-3, MathArrays.linearCombination(a[5][0], b[5][0], a[5][1], b[5][1]), 1.0e-10); Assert.assertEquals(Double.POSITIVE_INFINITY, MathArrays.linearCombination(a[5][0], b[5][0], a[5][1], b[5][1], a[5][2], b[5][2]), 1.0e-10); Assert.assertEquals(Double.POSITIVE_INFINITY, MathArrays.linearCombination(a[5][0], b[5][0], a[5][1], b[5][1], a[5][2], b[5][2], a[5][3], b[5][3]), 1.0e-10); Assert.assertEquals(Double.POSITIVE_INFINITY, MathArrays.linearCombination(a[5], b[5]), 1.0e-10); Assert.assertEquals(Double.POSITIVE_INFINITY, MathArrays.linearCombination(a[6][0], b[6][0], a[6][1], b[6][1]), 1.0e-10); Assert.assertEquals(Double.POSITIVE_INFINITY, MathArrays.linearCombination(a[6][0], b[6][0], a[6][1], b[6][1], a[6][2], b[6][2]), 1.0e-10); Assert.assertTrue(Double.isNaN(MathArrays.linearCombination(a[6][0], b[6][0], a[6][1], b[6][1], a[6][2], b[6][2], a[6][3], b[6][3]))); Assert.assertTrue(Double.isNaN(MathArrays.linearCombination(a[6], b[6]))); Assert.assertTrue(Double.isNaN(MathArrays.linearCombination(a[7][0], b[7][0], a[7][1], b[7][1]))); Assert.assertTrue(Double.isNaN(MathArrays.linearCombination(a[7][0], b[7][0], a[7][1], b[7][1], a[7][2], b[7][2]))); Assert.assertTrue(Double.isNaN(MathArrays.linearCombination(a[7][0], b[7][0], a[7][1], b[7][1], a[7][2], b[7][2], a[7][3], b[7][3]))); Assert.assertTrue(Double.isNaN(MathArrays.linearCombination(a[7], b[7]))); } @Test public void testArrayEquals() { Assert.assertFalse(MathArrays.equals(new double[] { 1d }, null)); Assert.assertFalse(MathArrays.equals(null, new double[] { 1d })); Assert.assertTrue(MathArrays.equals((double[]) null, (double[]) null)); Assert.assertFalse(MathArrays.equals(new double[] { 1d }, new double[0])); Assert.assertTrue(MathArrays.equals(new double[] { 1d }, new double[] { 1d })); Assert.assertTrue(MathArrays.equals(new double[] { Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 1d, 0d }, new double[] { Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 1d, 0d })); Assert.assertFalse(MathArrays.equals(new double[] { Double.NaN }, new double[] { Double.NaN })); Assert.assertFalse(MathArrays.equals(new double[] { Double.POSITIVE_INFINITY }, new double[] { Double.NEGATIVE_INFINITY })); Assert.assertFalse(MathArrays.equals(new double[] { 1d }, new double[] { FastMath.nextAfter(FastMath.nextAfter(1d, 2d), 2d) })); } @Test public void testArrayEqualsIncludingNaN() { Assert.assertFalse(MathArrays.equalsIncludingNaN(new double[] { 1d }, null)); Assert.assertFalse(MathArrays.equalsIncludingNaN(null, new double[] { 1d })); Assert.assertTrue(MathArrays.equalsIncludingNaN((double[]) null, (double[]) null)); Assert.assertFalse(MathArrays.equalsIncludingNaN(new double[] { 1d }, new double[0])); Assert.assertTrue(MathArrays.equalsIncludingNaN(new double[] { 1d }, new double[] { 1d })); Assert.assertTrue(MathArrays.equalsIncludingNaN(new double[] { Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 1d, 0d }, new double[] { Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 1d, 0d })); Assert.assertFalse(MathArrays.equalsIncludingNaN(new double[] { Double.POSITIVE_INFINITY }, new double[] { Double.NEGATIVE_INFINITY })); Assert.assertFalse(MathArrays.equalsIncludingNaN(new double[] { 1d }, new double[] { FastMath.nextAfter(FastMath.nextAfter(1d, 2d), 2d) })); } @Test public void testNormalizeArray() { double[] testValues1 = new double[] {1, 1, 2}; TestUtils.assertEquals( new double[] {.25, .25, .5}, MathArrays.normalizeArray(testValues1, 1), Double.MIN_VALUE); double[] testValues2 = new double[] {-1, -1, 1}; TestUtils.assertEquals( new double[] {1, 1, -1}, MathArrays.normalizeArray(testValues2, 1), Double.MIN_VALUE); // Ignore NaNs double[] testValues3 = new double[] {-1, -1, Double.NaN, 1, Double.NaN}; TestUtils.assertEquals( new double[] {1, 1,Double.NaN, -1, Double.NaN}, MathArrays.normalizeArray(testValues3, 1), Double.MIN_VALUE); // Zero sum -> MathArithmeticException double[] zeroSum = new double[] {-1, 1}; try { MathArrays.normalizeArray(zeroSum, 1); Assert.fail("expecting MathArithmeticException"); } catch (MathArithmeticException ex) {} // Infinite elements -> MathArithmeticException double[] hasInf = new double[] {1, 2, 1, Double.NEGATIVE_INFINITY}; try { MathArrays.normalizeArray(hasInf, 1); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) {} // Infinite target -> MathIllegalArgumentException try { MathArrays.normalizeArray(testValues1, Double.POSITIVE_INFINITY); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) {} // NaN target -> MathIllegalArgumentException try { MathArrays.normalizeArray(testValues1, Double.NaN); Assert.fail("expecting MathIllegalArgumentException"); } catch (MathIllegalArgumentException ex) {} } @Test public void testConvolve() { /* Test Case (obtained via SciPy) * x=[1.2,-1.8,1.4] * h=[1,0.8,0.5,0.3] * convolve(x,h) -> array([ 1.2 , -0.84, 0.56, 0.58, 0.16, 0.42]) */ double[] x1 = { 1.2, -1.8, 1.4 }; double[] h1 = { 1, 0.8, 0.5, 0.3 }; double[] y1 = { 1.2, -0.84, 0.56, 0.58, 0.16, 0.42 }; double tolerance = 1e-13; double[] yActual = MathArrays.convolve(x1, h1); Assert.assertArrayEquals(y1, yActual, tolerance); double[] x2 = { 1, 2, 3 }; double[] h2 = { 0, 1, 0.5 }; double[] y2 = { 0, 1, 2.5, 4, 1.5 }; yActual = MathArrays.convolve(x2, h2); Assert.assertArrayEquals(y2, yActual, tolerance); try { MathArrays.convolve(new double[]{1, 2}, null); Assert.fail("an exception should have been thrown"); } catch (NullArgumentException e) { // expected behavior } try { MathArrays.convolve(null, new double[]{1, 2}); Assert.fail("an exception should have been thrown"); } catch (NullArgumentException e) { // expected behavior } try { MathArrays.convolve(new double[]{1, 2}, new double[]{}); Assert.fail("an exception should have been thrown"); } catch (NoDataException e) { // expected behavior } try { MathArrays.convolve(new double[]{}, new double[]{1, 2}); Assert.fail("an exception should have been thrown"); } catch (NoDataException e) { // expected behavior } try { MathArrays.convolve(new double[]{}, new double[]{}); Assert.fail("an exception should have been thrown"); } catch (NoDataException e) { // expected behavior } } @Test public void testShuffleTail() { final int[] orig = new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; final int[] list = orig.clone(); final int start = 4; MathArrays.shuffle(list, start, MathArrays.Position.TAIL, new Well1024a(7654321L)); // Ensure that all entries below index "start" did not move. for (int i = 0; i < start; i++) { Assert.assertEquals(orig[i], list[i]); } // Ensure that at least one entry has moved. boolean ok = false; for (int i = start; i < orig.length - 1; i++) { if (orig[i] != list[i]) { ok = true; break; } } Assert.assertTrue(ok); } @Test public void testShuffleHead() { final int[] orig = new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; final int[] list = orig.clone(); final int start = 4; MathArrays.shuffle(list, start, MathArrays.Position.HEAD, new Well1024a(1234567L)); // Ensure that all entries above index "start" did not move. for (int i = start + 1; i < orig.length; i++) { Assert.assertEquals(orig[i], list[i]); } // Ensure that at least one entry has moved. boolean ok = false; for (int i = 0; i <= start; i++) { if (orig[i] != list[i]) { ok = true; break; } } Assert.assertTrue(ok); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */ package org.apache.commons.math3.util; import org.apache.commons.math3.distribution.RealDistribution; import org.apache.commons.math3.distribution.UniformRealDistribution; import org.apache.commons.math3.exception.MathArithmeticException; import org.apache.commons.math3.exception.NotFiniteNumberException; import org.apache.commons.math3.exception.NullArgumentException; import org.apache.commons.math3.exception.util.LocalizedFormats; import org.apache.commons.math3.random.RandomDataImpl; import org.junit.Assert; import org.junit.Test; /** * Test cases for the MathUtils class. * @version $Id$ * 2007) $ */ public final class MathUtilsTest { @Test public void testHash() { double[] testArray = { Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 1d, 0d, 1E-14, (1 + 1E-14), Double.MIN_VALUE, Double.MAX_VALUE }; for (int i = 0; i < testArray.length; i++) { for (int j = 0; j < testArray.length; j++) { if (i == j) { Assert.assertEquals(MathUtils.hash(testArray[i]), MathUtils.hash(testArray[j])); Assert.assertEquals(MathUtils.hash(testArray[j]), MathUtils.hash(testArray[i])); } else { Assert.assertTrue(MathUtils.hash(testArray[i]) != MathUtils.hash(testArray[j])); Assert.assertTrue(MathUtils.hash(testArray[j]) != MathUtils.hash(testArray[i])); } } } } @Test public void testArrayHash() { Assert.assertEquals(0, MathUtils.hash((double[]) null)); Assert.assertEquals(MathUtils.hash(new double[] { Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 1d, 0d }), MathUtils.hash(new double[] { Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 1d, 0d })); Assert.assertFalse(MathUtils.hash(new double[] { 1d }) == MathUtils.hash(new double[] { FastMath.nextAfter(1d, 2d) })); Assert.assertFalse(MathUtils.hash(new double[] { 1d }) == MathUtils.hash(new double[] { 1d, 1d })); } /** * Make sure that permuted arrays do not hash to the same value. */ @Test public void testPermutedArrayHash() { double[] original = new double[10]; double[] permuted = new double[10]; RandomDataImpl random = new RandomDataImpl(); // Generate 10 distinct random values for (int i = 0; i < 10; i++) { final RealDistribution u = new UniformRealDistribution(i + 0.5, i + 0.75); original[i] = u.sample(); } // Generate a random permutation, making sure it is not the identity boolean isIdentity = true; do { int[] permutation = random.nextPermutation(10, 10); for (int i = 0; i < 10; i++) { if (i != permutation[i]) { isIdentity = false; } permuted[i] = original[permutation[i]]; } } while (isIdentity); // Verify that permuted array has different hash Assert.assertFalse(MathUtils.hash(original) == MathUtils.hash(permuted)); } @Test public void testIndicatorByte() { Assert.assertEquals((byte)1, MathUtils.copySign((byte)1, (byte)2)); Assert.assertEquals((byte)1, MathUtils.copySign((byte)1, (byte)0)); Assert.assertEquals((byte)(-1), MathUtils.copySign((byte)1, (byte)(-2))); } @Test public void testIndicatorInt() { Assert.assertEquals(1, MathUtils.copySign(1, 2)); Assert.assertEquals(1, MathUtils.copySign(1, 0)); Assert.assertEquals((-1), MathUtils.copySign(1, -2)); } @Test public void testIndicatorLong() { Assert.assertEquals(1L, MathUtils.copySign(1L, 2L)); Assert.assertEquals(1L, MathUtils.copySign(1L, 0L)); Assert.assertEquals(-1L, MathUtils.copySign(1L, -2L)); } @Test public void testIndicatorShort() { Assert.assertEquals((short)1, MathUtils.copySign((short)1, (short)2)); Assert.assertEquals((short)1, MathUtils.copySign((short)1, (short)0)); Assert.assertEquals((short)(-1), MathUtils.copySign((short)1, (short)(-2))); } @Test public void testNormalizeAngle() { for (double a = -15.0; a <= 15.0; a += 0.1) { for (double b = -15.0; b <= 15.0; b += 0.2) { double c = MathUtils.normalizeAngle(a, b); Assert.assertTrue((b - FastMath.PI) <= c); Assert.assertTrue(c <= (b + FastMath.PI)); double twoK = FastMath.rint((a - c) / FastMath.PI); Assert.assertEquals(c, a - twoK * FastMath.PI, 1.0e-14); } } } @Test public void testReduce() { final double period = -12.222; final double offset = 13; final double delta = 1.5; double orig = offset + 122456789 * period + delta; double expected = delta; Assert.assertEquals(expected, MathUtils.reduce(orig, period, offset), 1e-7); Assert.assertEquals(expected, MathUtils.reduce(orig, -period, offset), 1e-7); orig = offset - 123356789 * period - delta; expected = Math.abs(period) - delta; Assert.assertEquals(expected, MathUtils.reduce(orig, period, offset), 1e-6); Assert.assertEquals(expected, MathUtils.reduce(orig, -period, offset), 1e-6); orig = offset - 123446789 * period + delta; expected = delta; Assert.assertEquals(expected, MathUtils.reduce(orig, period, offset), 1e-6); Assert.assertEquals(expected, MathUtils.reduce(orig, -period, offset), 1e-6); Assert.assertTrue(Double.isNaN(MathUtils.reduce(orig, Double.NaN, offset))); Assert.assertTrue(Double.isNaN(MathUtils.reduce(Double.NaN, period, offset))); Assert.assertTrue(Double.isNaN(MathUtils.reduce(orig, period, Double.NaN))); Assert.assertTrue(Double.isNaN(MathUtils.reduce(orig, period, Double.POSITIVE_INFINITY))); Assert.assertTrue(Double.isNaN(MathUtils.reduce(Double.POSITIVE_INFINITY, period, offset))); Assert.assertTrue(Double.isNaN(MathUtils.reduce(orig, Double.POSITIVE_INFINITY, offset))); Assert.assertTrue(Double.isNaN(MathUtils.reduce(orig, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY))); Assert.assertTrue(Double.isNaN(MathUtils.reduce(Double.POSITIVE_INFINITY, period, Double.POSITIVE_INFINITY))); Assert.assertTrue(Double.isNaN(MathUtils.reduce(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, offset))); Assert.assertTrue(Double.isNaN(MathUtils.reduce(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY))); } @Test public void testReduceComparedWithNormalizeAngle() { final double tol = Math.ulp(1d); final double period = 2 * Math.PI; for (double a = -15; a <= 15; a += 0.5) { for (double center = -15; center <= 15; center += 1) { final double nA = MathUtils.normalizeAngle(a, center); final double offset = center - Math.PI; final double r = MathUtils.reduce(a, period, offset); Assert.assertEquals(nA, r + offset, tol); } } } @Test public void testSignByte() { final byte one = (byte) 1; Assert.assertEquals((byte) 1, MathUtils.copySign(one, (byte) 2)); Assert.assertEquals((byte) (-1), MathUtils.copySign(one, (byte) (-2))); } @Test public void testSignInt() { final int one = 1; Assert.assertEquals(1, MathUtils.copySign(one, 2)); Assert.assertEquals((-1), MathUtils.copySign(one, -2)); } @Test public void testSignLong() { final long one = 1L; Assert.assertEquals(1L, MathUtils.copySign(one, 2L)); Assert.assertEquals(-1L, MathUtils.copySign(one, -2L)); } @Test public void testSignShort() { final short one = (short) 1; Assert.assertEquals((short) 1, MathUtils.copySign(one, (short) 2)); Assert.assertEquals((short) (-1), MathUtils.copySign(one, (short) (-2))); } @Test public void testCheckFinite() { try { MathUtils.checkFinite(Double.POSITIVE_INFINITY); Assert.fail("an exception should have been thrown"); } catch (NotFiniteNumberException e) { // Expected } try { MathUtils.checkFinite(Double.NEGATIVE_INFINITY); Assert.fail("an exception should have been thrown"); } catch (NotFiniteNumberException e) { // Expected } try { MathUtils.checkFinite(Double.NaN); Assert.fail("an exception should have been thrown"); } catch (NotFiniteNumberException e) { // Expected } try { MathUtils.checkFinite(new double[] {0, -1, Double.POSITIVE_INFINITY, -2, 3}); Assert.fail("an exception should have been thrown"); } catch (NotFiniteNumberException e) { // Expected } try { MathUtils.checkFinite(new double[] {1, Double.NEGATIVE_INFINITY, -2, 3}); Assert.fail("an exception should have been thrown"); } catch (NotFiniteNumberException e) { // Expected } try { MathUtils.checkFinite(new double[] {4, 3, -1, Double.NaN, -2, 1}); Assert.fail("an exception should have been thrown"); } catch (NotFiniteNumberException e) { // Expected } } @Test public void testCheckNotNull1() { try { Object obj = null; MathUtils.checkNotNull(obj); } catch (NullArgumentException e) { // Expected. } } @Test public void testCheckNotNull2() { try { double[] array = null; MathUtils.checkNotNull(array, LocalizedFormats.INPUT_ARRAY); } catch (NullArgumentException e) { // Expected. } } @Test public void testCopySignByte() { byte a = MathUtils.copySign(Byte.MIN_VALUE, (byte) -1); Assert.assertEquals(Byte.MIN_VALUE, a); final byte minValuePlusOne = Byte.MIN_VALUE + (byte) 1; a = MathUtils.copySign(minValuePlusOne, (byte) 1); Assert.assertEquals(Byte.MAX_VALUE, a); a = MathUtils.copySign(Byte.MAX_VALUE, (byte) -1); Assert.assertEquals(minValuePlusOne, a); final byte one = 1; byte val = -2; a = MathUtils.copySign(val, one); Assert.assertEquals(-val, a); final byte minusOne = -one; val = 2; a = MathUtils.copySign(val, minusOne); Assert.assertEquals(-val, a); val = 0; a = MathUtils.copySign(val, minusOne); Assert.assertEquals(val, a); val = 0; a = MathUtils.copySign(val, one); Assert.assertEquals(val, a); } @Test(expected=MathArithmeticException.class) public void testCopySignByte2() { MathUtils.copySign(Byte.MIN_VALUE, (byte) 1); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.util; import org.apache.commons.math3.exception.DimensionMismatchException; import org.apache.commons.math3.exception.OutOfRangeException; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.junit.Assert; import org.junit.Test; /** * */ public class MultidimensionalCounterTest { @Test public void testPreconditions() { MultidimensionalCounter c; try { c = new MultidimensionalCounter(0, 1); Assert.fail("NotStrictlyPositiveException expected"); } catch (NotStrictlyPositiveException e) { // Expected. } try { c = new MultidimensionalCounter(2, 0); Assert.fail("NotStrictlyPositiveException expected"); } catch (NotStrictlyPositiveException e) { // Expected. } try { c = new MultidimensionalCounter(-1, 1); Assert.fail("NotStrictlyPositiveException expected"); } catch (NotStrictlyPositiveException e) { // Expected. } c = new MultidimensionalCounter(2, 3); try { c.getCount(1, 1, 1); Assert.fail("DimensionMismatchException expected"); } catch (DimensionMismatchException e) { // Expected. } try { c.getCount(3, 1); Assert.fail("OutOfRangeException expected"); } catch (OutOfRangeException e) { // Expected. } try { c.getCount(0, -1); Assert.fail("OutOfRangeException expected"); } catch (OutOfRangeException e) { // Expected. } try { c.getCounts(-1); Assert.fail("OutOfRangeException expected"); } catch (OutOfRangeException e) { // Expected. } try { c.getCounts(6); Assert.fail("OutOfRangeException expected"); } catch (OutOfRangeException e) { // Expected. } } @Test public void testIteratorPreconditions() { MultidimensionalCounter.Iterator iter = (new MultidimensionalCounter(2, 3)).iterator(); try { iter.getCount(-1); Assert.fail("IndexOutOfBoundsException expected"); } catch (IndexOutOfBoundsException e) { // Expected. } try { iter.getCount(2); Assert.fail("IndexOutOfBoundsException expected"); } catch (IndexOutOfBoundsException e) { // Expected. } } @Test public void testMulti2UniConversion() { final MultidimensionalCounter c = new MultidimensionalCounter(2, 4, 5); Assert.assertEquals(c.getCount(1, 2, 3), 33); } @Test public void testAccessors() { final int[] originalSize = new int[] {2, 6, 5}; final MultidimensionalCounter c = new MultidimensionalCounter(originalSize); final int nDim = c.getDimension(); Assert.assertEquals(nDim, originalSize.length); final int[] size = c.getSizes(); for (int i = 0; i < nDim; i++) { Assert.assertEquals(originalSize[i], size[i]); } } @Test public void testIterationConsistency() { final MultidimensionalCounter c = new MultidimensionalCounter(2, 3, 4); final int[][] expected = new int[][] { { 0, 0, 0 }, { 0, 0, 1 }, { 0, 0, 2 }, { 0, 0, 3 }, { 0, 1, 0 }, { 0, 1, 1 }, { 0, 1, 2 }, { 0, 1, 3 }, { 0, 2, 0 }, { 0, 2, 1 }, { 0, 2, 2 }, { 0, 2, 3 }, { 1, 0, 0 }, { 1, 0, 1 }, { 1, 0, 2 }, { 1, 0, 3 }, { 1, 1, 0 }, { 1, 1, 1 }, { 1, 1, 2 }, { 1, 1, 3 }, { 1, 2, 0 }, { 1, 2, 1 }, { 1, 2, 2 }, { 1, 2, 3 } }; final int totalSize = c.getSize(); final int nDim = c.getDimension(); final MultidimensionalCounter.Iterator iter = c.iterator(); for (int i = 0; i < totalSize; i++) { if (!iter.hasNext()) { Assert.fail("Too short"); } final int uniDimIndex = iter.next().intValue(); Assert.assertEquals("Wrong iteration at " + i, i, uniDimIndex); for (int dimIndex = 0; dimIndex < nDim; dimIndex++) { Assert.assertEquals("Wrong multidimensional index for [" + i + "][" + dimIndex + "]", expected[i][dimIndex], iter.getCount(dimIndex)); } Assert.assertEquals("Wrong unidimensional index for [" + i + "]", c.getCount(expected[i]), uniDimIndex); final int[] indices = c.getCounts(uniDimIndex); for (int dimIndex = 0; dimIndex < nDim; dimIndex++) { Assert.assertEquals("Wrong multidimensional index for [" + i + "][" + dimIndex + "]", expected[i][dimIndex], indices[dimIndex]); } } if (iter.hasNext()) { Assert.fail("Too long"); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.util; import java.util.ConcurrentModificationException; import java.util.HashMap; import java.util.HashSet; import java.util.Map; import java.util.NoSuchElementException; import java.util.Random; import java.util.Set; import org.junit.Assert; import org.junit.Before; import org.junit.Test; /** * Test cases for the {@link OpenIntToDoubleHashMap}. */ @SuppressWarnings("boxing") public class OpenIntToDoubleHashMapTest { private Map<Integer, Double> javaMap = new HashMap<Integer, Double>(); @Before public void setUp() throws Exception { javaMap.put(50, 100.0); javaMap.put(75, 75.0); javaMap.put(25, 500.0); javaMap.put(Integer.MAX_VALUE, Double.MAX_VALUE); javaMap.put(0, -1.0); javaMap.put(1, 0.0); javaMap.put(33, -0.1); javaMap.put(23234234, -242343.0); javaMap.put(23321, Double.MIN_VALUE); javaMap.put(-4444, 332.0); javaMap.put(-1, -2323.0); javaMap.put(Integer.MIN_VALUE, 44.0); /* Add a few more to cause the table to rehash */ javaMap.putAll(generate()); } private Map<Integer, Double> generate() { Map<Integer, Double> map = new HashMap<Integer, Double>(); Random r = new Random(); for (int i = 0; i < 2000; ++i) map.put(r.nextInt(), r.nextDouble()); return map; } private OpenIntToDoubleHashMap createFromJavaMap() { OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap(); for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) { map.put(mapEntry.getKey(), mapEntry.getValue()); } return map; } @Test public void testPutAndGetWith0ExpectedSize() { OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap(0); assertPutAndGet(map); } @Test public void testPutAndGetWithExpectedSize() { OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap(500); assertPutAndGet(map); } @Test public void testPutAndGet() { OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap(); assertPutAndGet(map); } private void assertPutAndGet(OpenIntToDoubleHashMap map) { assertPutAndGet(map, 0, new HashSet<Integer>()); } private void assertPutAndGet(OpenIntToDoubleHashMap map, int mapSize, Set<Integer> keysInMap) { Assert.assertEquals(mapSize, map.size()); for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) { map.put(mapEntry.getKey(), mapEntry.getValue()); if (!keysInMap.contains(mapEntry.getKey())) ++mapSize; Assert.assertEquals(mapSize, map.size()); Assert.assertTrue(Precision.equals(mapEntry.getValue(), map.get(mapEntry.getKey()), 1)); } } @Test public void testPutAbsentOnExisting() { OpenIntToDoubleHashMap map = createFromJavaMap(); int size = javaMap.size(); for (Map.Entry<Integer, Double> mapEntry : generateAbsent().entrySet()) { map.put(mapEntry.getKey(), mapEntry.getValue()); Assert.assertEquals(++size, map.size()); Assert.assertTrue(Precision.equals(mapEntry.getValue(), map.get(mapEntry.getKey()), 1)); } } @Test public void testPutOnExisting() { OpenIntToDoubleHashMap map = createFromJavaMap(); for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) { map.put(mapEntry.getKey(), mapEntry.getValue()); Assert.assertEquals(javaMap.size(), map.size()); Assert.assertTrue(Precision.equals(mapEntry.getValue(), map.get(mapEntry.getKey()), 1)); } } @Test public void testGetAbsent() { Map<Integer, Double> generated = generateAbsent(); OpenIntToDoubleHashMap map = createFromJavaMap(); for (Map.Entry<Integer, Double> mapEntry : generated.entrySet()) Assert.assertTrue(Double.isNaN(map.get(mapEntry.getKey()))); } @Test public void testGetFromEmpty() { OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap(); Assert.assertTrue(Double.isNaN(map.get(5))); Assert.assertTrue(Double.isNaN(map.get(0))); Assert.assertTrue(Double.isNaN(map.get(50))); } @Test public void testRemove() { OpenIntToDoubleHashMap map = createFromJavaMap(); int mapSize = javaMap.size(); Assert.assertEquals(mapSize, map.size()); for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) { map.remove(mapEntry.getKey()); Assert.assertEquals(--mapSize, map.size()); Assert.assertTrue(Double.isNaN(map.get(mapEntry.getKey()))); } /* Ensure that put and get still work correctly after removals */ assertPutAndGet(map); } /* This time only remove some entries */ @Test public void testRemove2() { OpenIntToDoubleHashMap map = createFromJavaMap(); int mapSize = javaMap.size(); int count = 0; Set<Integer> keysInMap = new HashSet<Integer>(javaMap.keySet()); for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) { keysInMap.remove(mapEntry.getKey()); map.remove(mapEntry.getKey()); Assert.assertEquals(--mapSize, map.size()); Assert.assertTrue(Double.isNaN(map.get(mapEntry.getKey()))); if (count++ > 5) break; } /* Ensure that put and get still work correctly after removals */ assertPutAndGet(map, mapSize, keysInMap); } @Test public void testRemoveFromEmpty() { OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap(); Assert.assertTrue(Double.isNaN(map.remove(50))); } @Test public void testRemoveAbsent() { Map<Integer, Double> generated = generateAbsent(); OpenIntToDoubleHashMap map = createFromJavaMap(); int mapSize = map.size(); for (Map.Entry<Integer, Double> mapEntry : generated.entrySet()) { map.remove(mapEntry.getKey()); Assert.assertEquals(mapSize, map.size()); Assert.assertTrue(Double.isNaN(map.get(mapEntry.getKey()))); } } /** * Returns a map with at least 100 elements where each element is absent from javaMap. */ private Map<Integer, Double> generateAbsent() { Map<Integer, Double> generated = new HashMap<Integer, Double>(); do { generated.putAll(generate()); for (Integer key : javaMap.keySet()) generated.remove(key); } while (generated.size() < 100); return generated; } @Test public void testCopy() { OpenIntToDoubleHashMap copy = new OpenIntToDoubleHashMap(createFromJavaMap()); Assert.assertEquals(javaMap.size(), copy.size()); for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) Assert.assertTrue(Precision.equals(mapEntry.getValue(), copy.get(mapEntry.getKey()), 1)); } @Test public void testContainsKey() { OpenIntToDoubleHashMap map = createFromJavaMap(); for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) { Assert.assertTrue(map.containsKey(mapEntry.getKey())); } for (Map.Entry<Integer, Double> mapEntry : generateAbsent().entrySet()) { Assert.assertFalse(map.containsKey(mapEntry.getKey())); } for (Map.Entry<Integer, Double> mapEntry : javaMap.entrySet()) { int key = mapEntry.getKey(); Assert.assertTrue(map.containsKey(key)); map.remove(key); Assert.assertFalse(map.containsKey(key)); } } @Test public void testIterator() { OpenIntToDoubleHashMap map = createFromJavaMap(); OpenIntToDoubleHashMap.Iterator iterator = map.iterator(); for (int i = 0; i < map.size(); ++i) { Assert.assertTrue(iterator.hasNext()); iterator.advance(); int key = iterator.key(); Assert.assertTrue(map.containsKey(key)); Assert.assertEquals(javaMap.get(key), map.get(key), 0); Assert.assertEquals(javaMap.get(key), iterator.value(), 0); Assert.assertTrue(javaMap.containsKey(key)); } Assert.assertFalse(iterator.hasNext()); try { iterator.advance(); Assert.fail("an exception should have been thrown"); } catch (NoSuchElementException nsee) { // expected } } @Test public void testConcurrentModification() { OpenIntToDoubleHashMap map = createFromJavaMap(); OpenIntToDoubleHashMap.Iterator iterator = map.iterator(); map.put(3, 3); try { iterator.advance(); Assert.fail("an exception should have been thrown"); } catch (ConcurrentModificationException cme) { // expected } } /** * Regression test for a bug in findInsertionIndex where the hashing in the second probing * loop was inconsistent with the first causing duplicate keys after the right sequence * of puts and removes. */ @Test public void testPutKeysWithCollisions() { OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap(); int key1 = -1996012590; double value1 = 1.0; map.put(key1, value1); int key2 = 835099822; map.put(key2, value1); int key3 = 1008859686; map.put(key3, value1); Assert.assertTrue(Precision.equals(value1, map.get(key3), 1)); Assert.assertEquals(3, map.size()); map.remove(key2); double value2 = 2.0; map.put(key3, value2); Assert.assertTrue(Precision.equals(value2, map.get(key3), 1)); Assert.assertEquals(2, map.size()); } /** * Similar to testPutKeysWithCollisions() but exercises the codepaths in a slightly * different manner. */ @Test public void testPutKeysWithCollision2() { OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap(); int key1 = 837989881; double value1 = 1.0; map.put(key1, value1); int key2 = 476463321; map.put(key2, value1); Assert.assertEquals(2, map.size()); Assert.assertTrue(Precision.equals(value1, map.get(key2), 1)); map.remove(key1); double value2 = 2.0; map.put(key2, value2); Assert.assertEquals(1, map.size()); Assert.assertTrue(Precision.equals(value2, map.get(key2), 1)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.util; import java.util.ConcurrentModificationException; import java.util.HashMap; import java.util.HashSet; import java.util.Map; import java.util.NoSuchElementException; import java.util.Random; import java.util.Set; import java.util.Map.Entry; import org.apache.commons.math3.Field; import org.apache.commons.math3.fraction.Fraction; import org.apache.commons.math3.fraction.FractionConversionException; import org.apache.commons.math3.fraction.FractionField; import org.junit.Assert; import org.junit.Before; import org.junit.Test; @SuppressWarnings("boxing") public class OpenIntToFieldTest { private Map<Integer, Fraction> javaMap = new HashMap<Integer, Fraction>(); private FractionField field = FractionField.getInstance(); @Before public void setUp() throws FractionConversionException { javaMap.put(50, new Fraction(100.0)); javaMap.put(75, new Fraction(75.0)); javaMap.put(25, new Fraction(500.0)); javaMap.put(Integer.MAX_VALUE, new Fraction(Integer.MAX_VALUE)); javaMap.put(0, new Fraction(-1.0)); javaMap.put(1, new Fraction(0.0)); javaMap.put(33, new Fraction(-0.1)); javaMap.put(23234234, new Fraction(-242343.0)); javaMap.put(23321, new Fraction (Integer.MIN_VALUE)); javaMap.put(-4444, new Fraction(332.0)); javaMap.put(-1, new Fraction(-2323.0)); javaMap.put(Integer.MIN_VALUE, new Fraction(44.0)); /* Add a few more to cause the table to rehash */ javaMap.putAll(generate()); } private Map<Integer, Fraction> generate() { Map<Integer, Fraction> map = new HashMap<Integer, Fraction>(); Random r = new Random(); double dd=0; for (int i = 0; i < 2000; ++i) dd = r.nextDouble(); try { map.put(r.nextInt(), new Fraction(dd)); } catch (FractionConversionException e) { throw new IllegalStateException("Invalid :"+dd, e); } return map; } private OpenIntToFieldHashMap<Fraction> createFromJavaMap(Field<Fraction> field) { OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field); for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) { map.put(mapEntry.getKey(), mapEntry.getValue()); } return map; } @Test public void testPutAndGetWith0ExpectedSize() { OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field,0); assertPutAndGet(map); } @Test public void testPutAndGetWithExpectedSize() { OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field,500); assertPutAndGet(map); } @Test public void testPutAndGet() { OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field); assertPutAndGet(map); } private void assertPutAndGet(OpenIntToFieldHashMap<Fraction> map) { assertPutAndGet(map, 0, new HashSet<Integer>()); } private void assertPutAndGet(OpenIntToFieldHashMap<Fraction> map, int mapSize, Set<Integer> keysInMap) { Assert.assertEquals(mapSize, map.size()); for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) { map.put(mapEntry.getKey(), mapEntry.getValue()); if (!keysInMap.contains(mapEntry.getKey())) ++mapSize; Assert.assertEquals(mapSize, map.size()); Assert.assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey())); } } @Test public void testPutAbsentOnExisting() { OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field); int size = javaMap.size(); for (Map.Entry<Integer, Fraction> mapEntry : generateAbsent().entrySet()) { map.put(mapEntry.getKey(), mapEntry.getValue()); Assert.assertEquals(++size, map.size()); Assert.assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey())); } } @Test public void testPutOnExisting() { OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field); for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) { map.put(mapEntry.getKey(), mapEntry.getValue()); Assert.assertEquals(javaMap.size(), map.size()); Assert.assertEquals(mapEntry.getValue(), map.get(mapEntry.getKey())); } } @Test public void testGetAbsent() { Map<Integer, Fraction> generated = generateAbsent(); OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field); for (Map.Entry<Integer, Fraction> mapEntry : generated.entrySet()) Assert.assertTrue(field.getZero().equals(map.get(mapEntry.getKey()))); } @Test public void testGetFromEmpty() { OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field); Assert.assertTrue(field.getZero().equals(map.get(5))); Assert.assertTrue(field.getZero().equals(map.get(0))); Assert.assertTrue(field.getZero().equals(map.get(50))); } @Test public void testRemove() { OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field); int mapSize = javaMap.size(); Assert.assertEquals(mapSize, map.size()); for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) { map.remove(mapEntry.getKey()); Assert.assertEquals(--mapSize, map.size()); Assert.assertTrue(field.getZero().equals(map.get(mapEntry.getKey()))); } /* Ensure that put and get still work correctly after removals */ assertPutAndGet(map); } /* This time only remove some entries */ @Test public void testRemove2() { OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field); int mapSize = javaMap.size(); int count = 0; Set<Integer> keysInMap = new HashSet<Integer>(javaMap.keySet()); for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) { keysInMap.remove(mapEntry.getKey()); map.remove(mapEntry.getKey()); Assert.assertEquals(--mapSize, map.size()); Assert.assertTrue(field.getZero().equals(map.get(mapEntry.getKey()))); if (count++ > 5) break; } /* Ensure that put and get still work correctly after removals */ assertPutAndGet(map, mapSize, keysInMap); } @Test public void testRemoveFromEmpty() { OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field); Assert.assertTrue(field.getZero().equals(map.remove(50))); } @Test public void testRemoveAbsent() { Map<Integer, Fraction> generated = generateAbsent(); OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field); int mapSize = map.size(); for (Map.Entry<Integer, Fraction> mapEntry : generated.entrySet()) { map.remove(mapEntry.getKey()); Assert.assertEquals(mapSize, map.size()); Assert.assertTrue(field.getZero().equals(map.get(mapEntry.getKey()))); } } /** * Returns a map with at least 100 elements where each element is absent from javaMap. */ private Map<Integer, Fraction> generateAbsent() { Map<Integer, Fraction> generated = new HashMap<Integer, Fraction>(); do { generated.putAll(generate()); for (Integer key : javaMap.keySet()) generated.remove(key); } while (generated.size() < 100); return generated; } @Test public void testCopy() { OpenIntToFieldHashMap<Fraction> copy = new OpenIntToFieldHashMap<Fraction>(createFromJavaMap(field)); Assert.assertEquals(javaMap.size(), copy.size()); for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) Assert.assertEquals(mapEntry.getValue(), copy.get(mapEntry.getKey())); } @Test public void testContainsKey() { OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field); for (Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) { Assert.assertTrue(map.containsKey(mapEntry.getKey())); } for (Map.Entry<Integer, Fraction> mapEntry : generateAbsent().entrySet()) { Assert.assertFalse(map.containsKey(mapEntry.getKey())); } for (Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) { int key = mapEntry.getKey(); Assert.assertTrue(map.containsKey(key)); map.remove(key); Assert.assertFalse(map.containsKey(key)); } } @Test public void testIterator() { OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field); OpenIntToFieldHashMap<Fraction>.Iterator iterator = map.iterator(); for (int i = 0; i < map.size(); ++i) { Assert.assertTrue(iterator.hasNext()); iterator.advance(); int key = iterator.key(); Assert.assertTrue(map.containsKey(key)); Assert.assertEquals(javaMap.get(key), map.get(key)); Assert.assertEquals(javaMap.get(key), iterator.value()); Assert.assertTrue(javaMap.containsKey(key)); } Assert.assertFalse(iterator.hasNext()); try { iterator.advance(); Assert.fail("an exception should have been thrown"); } catch (NoSuchElementException nsee) { // expected } } @Test public void testConcurrentModification() { OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field); OpenIntToFieldHashMap<Fraction>.Iterator iterator = map.iterator(); map.put(3, new Fraction(3)); try { iterator.advance(); Assert.fail("an exception should have been thrown"); } catch (ConcurrentModificationException cme) { // expected } } /** * Regression test for a bug in findInsertionIndex where the hashing in the second probing * loop was inconsistent with the first causing duplicate keys after the right sequence * of puts and removes. */ @Test public void testPutKeysWithCollisions() { OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field); int key1 = -1996012590; Fraction value1 = new Fraction(1); map.put(key1, value1); int key2 = 835099822; map.put(key2, value1); int key3 = 1008859686; map.put(key3, value1); Assert.assertEquals(value1, map.get(key3)); Assert.assertEquals(3, map.size()); map.remove(key2); Fraction value2 = new Fraction(2); map.put(key3, value2); Assert.assertEquals(value2, map.get(key3)); Assert.assertEquals(2, map.size()); } /** * Similar to testPutKeysWithCollisions() but exercises the codepaths in a slightly * different manner. */ @Test public void testPutKeysWithCollision2() { OpenIntToFieldHashMap<Fraction>map = new OpenIntToFieldHashMap<Fraction>(field); int key1 = 837989881; Fraction value1 = new Fraction(1); map.put(key1, value1); int key2 = 476463321; map.put(key2, value1); Assert.assertEquals(2, map.size()); Assert.assertEquals(value1, map.get(key2)); map.remove(key1); Fraction value2 = new Fraction(2); map.put(key2, value2); Assert.assertEquals(1, map.size()); Assert.assertEquals(value2, map.get(key2)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */ package org.apache.commons.math3.util; import org.junit.Assert; import org.junit.Test; /** * Test for {@link Pair}. */ public class PairTest { @Test public void testAccessor() { final Pair<Integer, Double> p = new Pair<Integer, Double>(new Integer(1), new Double(2)); Assert.assertEquals(new Integer(1), p.getKey()); Assert.assertEquals(2, p.getValue().doubleValue(), Math.ulp(1d)); } @Test public void testAccessor2() { final Pair<Integer, Double> p = new Pair<Integer, Double>(new Integer(1), new Double(2)); // Check that both APIs refer to the same data. Assert.assertTrue(p.getFirst() == p.getKey()); Assert.assertTrue(p.getSecond() == p.getValue()); } @Test public void testEquals() { Pair<Integer, Double> p1 = new Pair<Integer, Double>(null, null); Assert.assertFalse(p1.equals(null)); Pair<Integer, Double> p2 = new Pair<Integer, Double>(null, null); Assert.assertTrue(p1.equals(p2)); p1 = new Pair<Integer, Double>(new Integer(1), new Double(2)); Assert.assertFalse(p1.equals(p2)); p2 = new Pair<Integer, Double>(new Integer(1), new Double(2)); Assert.assertTrue(p1.equals(p2)); Pair<Integer, Float> p3 = new Pair<Integer, Float>(new Integer(1), new Float(2)); Assert.assertFalse(p1.equals(p3)); } @Test public void testHashCode() { final MyInteger m1 = new MyInteger(1); final MyInteger m2 = new MyInteger(1); final Pair<MyInteger, MyInteger> p1 = new Pair<MyInteger, MyInteger>(m1, m1); final Pair<MyInteger, MyInteger> p2 = new Pair<MyInteger, MyInteger>(m2, m2); // Same contents, same hash code. Assert.assertTrue(p1.hashCode() == p2.hashCode()); // Different contents, different hash codes. m2.set(2); Assert.assertFalse(p1.hashCode() == p2.hashCode()); } /** * A mutable integer. */ private static class MyInteger { private int i; public MyInteger(int i) { this.i = i; } public void set(int i) { this.i = i; } @Override public boolean equals(Object o) { if (!(o instanceof MyInteger)) { return false; } else { return i == ((MyInteger) o).i; } } @Override public int hashCode() { return i; } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */ package org.apache.commons.math3.util; import java.math.BigDecimal; import org.apache.commons.math3.exception.MathArithmeticException; import org.apache.commons.math3.exception.MathIllegalArgumentException; import org.apache.commons.math3.TestUtils; import org.junit.Assert; import org.junit.Test; /** * Test cases for the {@link Precision} class. * * @version $Id$ */ public class PrecisionTest { @Test public void testEqualsWithRelativeTolerance() { Assert.assertTrue(Precision.equalsWithRelativeTolerance(0d, 0d, 0d)); Assert.assertTrue(Precision.equalsWithRelativeTolerance(0d, 1 / Double.NEGATIVE_INFINITY, 0d)); final double eps = 1e-14; Assert.assertFalse(Precision.equalsWithRelativeTolerance(1.987654687654968, 1.987654687654988, eps)); Assert.assertTrue(Precision.equalsWithRelativeTolerance(1.987654687654968, 1.987654687654987, eps)); Assert.assertFalse(Precision.equalsWithRelativeTolerance(1.987654687654968, 1.987654687654948, eps)); Assert.assertTrue(Precision.equalsWithRelativeTolerance(1.987654687654968, 1.987654687654949, eps)); Assert.assertFalse(Precision.equalsWithRelativeTolerance(Precision.SAFE_MIN, 0.0, eps)); Assert.assertFalse(Precision.equalsWithRelativeTolerance(1.0000000000001e-300, 1e-300, eps)); Assert.assertTrue(Precision.equalsWithRelativeTolerance(1.00000000000001e-300, 1e-300, eps)); Assert.assertFalse(Precision.equalsWithRelativeTolerance(Double.NEGATIVE_INFINITY, 1.23, eps)); Assert.assertFalse(Precision.equalsWithRelativeTolerance(Double.POSITIVE_INFINITY, 1.23, eps)); Assert.assertTrue(Precision.equalsWithRelativeTolerance(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, eps)); Assert.assertTrue(Precision.equalsWithRelativeTolerance(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, eps)); Assert.assertFalse(Precision.equalsWithRelativeTolerance(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, eps)); Assert.assertFalse(Precision.equalsWithRelativeTolerance(Double.NaN, 1.23, eps)); Assert.assertFalse(Precision.equalsWithRelativeTolerance(Double.NaN, Double.NaN, eps)); } @Test public void testEqualsIncludingNaN() { double[] testArray = { Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 1d, 0d }; for (int i = 0; i < testArray.length; i++) { for (int j = 0; j < testArray.length; j++) { if (i == j) { Assert.assertTrue(Precision.equalsIncludingNaN(testArray[i], testArray[j])); Assert.assertTrue(Precision.equalsIncludingNaN(testArray[j], testArray[i])); } else { Assert.assertTrue(!Precision.equalsIncludingNaN(testArray[i], testArray[j])); Assert.assertTrue(!Precision.equalsIncludingNaN(testArray[j], testArray[i])); } } } } @Test public void testEqualsWithAllowedDelta() { Assert.assertTrue(Precision.equals(153.0000, 153.0000, .0625)); Assert.assertTrue(Precision.equals(153.0000, 153.0625, .0625)); Assert.assertTrue(Precision.equals(152.9375, 153.0000, .0625)); Assert.assertFalse(Precision.equals(153.0000, 153.0625, .0624)); Assert.assertFalse(Precision.equals(152.9374, 153.0000, .0625)); Assert.assertFalse(Precision.equals(Double.NaN, Double.NaN, 1.0)); Assert.assertTrue(Precision.equals(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0)); Assert.assertTrue(Precision.equals(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1.0)); Assert.assertFalse(Precision.equals(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0)); } @Test public void testMath475() { final double a = 1.7976931348623182E16; final double b = FastMath.nextUp(a); double diff = FastMath.abs(a - b); // Because they are adjacent floating point numbers, "a" and "b" are // considered equal even though the allowed error is smaller than // their difference. Assert.assertTrue(Precision.equals(a, b, 0.5 * diff)); final double c = FastMath.nextUp(b); diff = FastMath.abs(a - c); // Because "a" and "c" are not adjacent, the tolerance is taken into // account for assessing equality. Assert.assertTrue(Precision.equals(a, c, diff)); Assert.assertFalse(Precision.equals(a, c, (1 - 1e-16) * diff)); } @Test public void testEqualsIncludingNaNWithAllowedDelta() { Assert.assertTrue(Precision.equalsIncludingNaN(153.0000, 153.0000, .0625)); Assert.assertTrue(Precision.equalsIncludingNaN(153.0000, 153.0625, .0625)); Assert.assertTrue(Precision.equalsIncludingNaN(152.9375, 153.0000, .0625)); Assert.assertTrue(Precision.equalsIncludingNaN(Double.NaN, Double.NaN, 1.0)); Assert.assertTrue(Precision.equalsIncludingNaN(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0)); Assert.assertTrue(Precision.equalsIncludingNaN(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1.0)); Assert.assertFalse(Precision.equalsIncludingNaN(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 1.0)); Assert.assertFalse(Precision.equalsIncludingNaN(153.0000, 153.0625, .0624)); Assert.assertFalse(Precision.equalsIncludingNaN(152.9374, 153.0000, .0625)); } // Tests for floating point equality @Test public void testFloatEqualsWithAllowedUlps() { Assert.assertTrue("+0.0f == -0.0f",Precision.equals(0.0f, -0.0f)); Assert.assertTrue("+0.0f == -0.0f (1 ulp)",Precision.equals(0.0f, -0.0f, 1)); float oneFloat = 1.0f; Assert.assertTrue("1.0f == 1.0f + 1 ulp",Precision.equals(oneFloat, Float.intBitsToFloat(1 + Float.floatToIntBits(oneFloat)))); Assert.assertTrue("1.0f == 1.0f + 1 ulp (1 ulp)",Precision.equals(oneFloat, Float.intBitsToFloat(1 + Float.floatToIntBits(oneFloat)), 1)); Assert.assertFalse("1.0f != 1.0f + 2 ulp (1 ulp)",Precision.equals(oneFloat, Float.intBitsToFloat(2 + Float.floatToIntBits(oneFloat)), 1)); Assert.assertTrue(Precision.equals(153.0f, 153.0f, 1)); // These tests need adjusting for floating point precision // Assert.assertTrue(Precision.equals(153.0f, 153.00000000000003f, 1)); // Assert.assertFalse(Precision.equals(153.0f, 153.00000000000006f, 1)); // Assert.assertTrue(Precision.equals(153.0f, 152.99999999999997f, 1)); // Assert.assertFalse(Precision.equals(153f, 152.99999999999994f, 1)); // // Assert.assertTrue(Precision.equals(-128.0f, -127.99999999999999f, 1)); // Assert.assertFalse(Precision.equals(-128.0f, -127.99999999999997f, 1)); // Assert.assertTrue(Precision.equals(-128.0f, -128.00000000000003f, 1)); // Assert.assertFalse(Precision.equals(-128.0f, -128.00000000000006f, 1)); Assert.assertTrue(Precision.equals(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY, 1)); Assert.assertTrue(Precision.equals(Double.MAX_VALUE, Float.POSITIVE_INFINITY, 1)); Assert.assertTrue(Precision.equals(Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY, 1)); Assert.assertTrue(Precision.equals(-Float.MAX_VALUE, Float.NEGATIVE_INFINITY, 1)); Assert.assertFalse(Precision.equals(Float.NaN, Float.NaN, 1)); Assert.assertFalse(Precision.equals(Float.NaN, Float.NaN, 0)); Assert.assertFalse(Precision.equals(Float.NaN, 0, 0)); Assert.assertFalse(Precision.equals(Float.NaN, Float.POSITIVE_INFINITY, 0)); Assert.assertFalse(Precision.equals(Float.NaN, Float.NEGATIVE_INFINITY, 0)); Assert.assertFalse(Precision.equals(Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY, 100000)); } @Test public void testEqualsWithAllowedUlps() { Assert.assertTrue(Precision.equals(0.0, -0.0, 1)); Assert.assertTrue(Precision.equals(1.0, 1 + FastMath.ulp(1d), 1)); Assert.assertFalse(Precision.equals(1.0, 1 + 2 * FastMath.ulp(1d), 1)); final double nUp1 = FastMath.nextAfter(1d, Double.POSITIVE_INFINITY); final double nnUp1 = FastMath.nextAfter(nUp1, Double.POSITIVE_INFINITY); Assert.assertTrue(Precision.equals(1.0, nUp1, 1)); Assert.assertTrue(Precision.equals(nUp1, nnUp1, 1)); Assert.assertFalse(Precision.equals(1.0, nnUp1, 1)); Assert.assertTrue(Precision.equals(0.0, FastMath.ulp(0d), 1)); Assert.assertTrue(Precision.equals(0.0, -FastMath.ulp(0d), 1)); Assert.assertTrue(Precision.equals(153.0, 153.0, 1)); Assert.assertTrue(Precision.equals(153.0, 153.00000000000003, 1)); Assert.assertFalse(Precision.equals(153.0, 153.00000000000006, 1)); Assert.assertTrue(Precision.equals(153.0, 152.99999999999997, 1)); Assert.assertFalse(Precision.equals(153, 152.99999999999994, 1)); Assert.assertTrue(Precision.equals(-128.0, -127.99999999999999, 1)); Assert.assertFalse(Precision.equals(-128.0, -127.99999999999997, 1)); Assert.assertTrue(Precision.equals(-128.0, -128.00000000000003, 1)); Assert.assertFalse(Precision.equals(-128.0, -128.00000000000006, 1)); Assert.assertTrue(Precision.equals(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1)); Assert.assertTrue(Precision.equals(Double.MAX_VALUE, Double.POSITIVE_INFINITY, 1)); Assert.assertTrue(Precision.equals(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1)); Assert.assertTrue(Precision.equals(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY, 1)); Assert.assertFalse(Precision.equals(Double.NaN, Double.NaN, 1)); Assert.assertFalse(Precision.equals(Double.NaN, Double.NaN, 0)); Assert.assertFalse(Precision.equals(Double.NaN, 0, 0)); Assert.assertFalse(Precision.equals(Double.NaN, Double.POSITIVE_INFINITY, 0)); Assert.assertFalse(Precision.equals(Double.NaN, Double.NEGATIVE_INFINITY, 0)); Assert.assertFalse(Precision.equals(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 100000)); } @Test public void testEqualsIncludingNaNWithAllowedUlps() { Assert.assertTrue(Precision.equalsIncludingNaN(0.0, -0.0, 1)); Assert.assertTrue(Precision.equalsIncludingNaN(1.0, 1 + FastMath.ulp(1d), 1)); Assert.assertFalse(Precision.equalsIncludingNaN(1.0, 1 + 2 * FastMath.ulp(1d), 1)); final double nUp1 = FastMath.nextAfter(1d, Double.POSITIVE_INFINITY); final double nnUp1 = FastMath.nextAfter(nUp1, Double.POSITIVE_INFINITY); Assert.assertTrue(Precision.equalsIncludingNaN(1.0, nUp1, 1)); Assert.assertTrue(Precision.equalsIncludingNaN(nUp1, nnUp1, 1)); Assert.assertFalse(Precision.equalsIncludingNaN(1.0, nnUp1, 1)); Assert.assertTrue(Precision.equalsIncludingNaN(0.0, FastMath.ulp(0d), 1)); Assert.assertTrue(Precision.equalsIncludingNaN(0.0, -FastMath.ulp(0d), 1)); Assert.assertTrue(Precision.equalsIncludingNaN(153.0, 153.0, 1)); Assert.assertTrue(Precision.equalsIncludingNaN(153.0, 153.00000000000003, 1)); Assert.assertFalse(Precision.equalsIncludingNaN(153.0, 153.00000000000006, 1)); Assert.assertTrue(Precision.equalsIncludingNaN(153.0, 152.99999999999997, 1)); Assert.assertFalse(Precision.equalsIncludingNaN(153, 152.99999999999994, 1)); Assert.assertTrue(Precision.equalsIncludingNaN(-128.0, -127.99999999999999, 1)); Assert.assertFalse(Precision.equalsIncludingNaN(-128.0, -127.99999999999997, 1)); Assert.assertTrue(Precision.equalsIncludingNaN(-128.0, -128.00000000000003, 1)); Assert.assertFalse(Precision.equalsIncludingNaN(-128.0, -128.00000000000006, 1)); Assert.assertTrue(Precision.equalsIncludingNaN(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 1)); Assert.assertTrue(Precision.equalsIncludingNaN(Double.MAX_VALUE, Double.POSITIVE_INFINITY, 1)); Assert.assertTrue(Precision.equalsIncludingNaN(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 1)); Assert.assertTrue(Precision.equalsIncludingNaN(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY, 1)); Assert.assertTrue(Precision.equalsIncludingNaN(Double.NaN, Double.NaN, 1)); Assert.assertFalse(Precision.equalsIncludingNaN(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 100000)); } @Test public void testCompareToEpsilon() { Assert.assertEquals(0, Precision.compareTo(152.33, 152.32, .011)); Assert.assertTrue(Precision.compareTo(152.308, 152.32, .011) < 0); Assert.assertTrue(Precision.compareTo(152.33, 152.318, .011) > 0); Assert.assertEquals(0, Precision.compareTo(Double.MIN_VALUE, +0.0, Double.MIN_VALUE)); Assert.assertEquals(0, Precision.compareTo(Double.MIN_VALUE, -0.0, Double.MIN_VALUE)); } @Test public void testCompareToMaxUlps() { double a = 152.32; double delta = FastMath.ulp(a); for (int i = 0; i <= 10; ++i) { if (i <= 5) { Assert.assertEquals( 0, Precision.compareTo(a, a + i * delta, 5)); Assert.assertEquals( 0, Precision.compareTo(a, a - i * delta, 5)); } else { Assert.assertEquals(-1, Precision.compareTo(a, a + i * delta, 5)); Assert.assertEquals(+1, Precision.compareTo(a, a - i * delta, 5)); } } Assert.assertEquals( 0, Precision.compareTo(-0.0, 0.0, 0)); Assert.assertEquals(-1, Precision.compareTo(-Double.MIN_VALUE, -0.0, 0)); Assert.assertEquals( 0, Precision.compareTo(-Double.MIN_VALUE, -0.0, 1)); Assert.assertEquals(-1, Precision.compareTo(-Double.MIN_VALUE, +0.0, 0)); Assert.assertEquals( 0, Precision.compareTo(-Double.MIN_VALUE, +0.0, 1)); Assert.assertEquals(+1, Precision.compareTo( Double.MIN_VALUE, -0.0, 0)); Assert.assertEquals( 0, Precision.compareTo( Double.MIN_VALUE, -0.0, 1)); Assert.assertEquals(+1, Precision.compareTo( Double.MIN_VALUE, +0.0, 0)); Assert.assertEquals( 0, Precision.compareTo( Double.MIN_VALUE, +0.0, 1)); Assert.assertEquals(-1, Precision.compareTo(-Double.MIN_VALUE, Double.MIN_VALUE, 0)); Assert.assertEquals(-1, Precision.compareTo(-Double.MIN_VALUE, Double.MIN_VALUE, 1)); Assert.assertEquals( 0, Precision.compareTo(-Double.MIN_VALUE, Double.MIN_VALUE, 2)); Assert.assertEquals( 0, Precision.compareTo(Double.MAX_VALUE, Double.POSITIVE_INFINITY, 1)); Assert.assertEquals(-1, Precision.compareTo(Double.MAX_VALUE, Double.POSITIVE_INFINITY, 0)); Assert.assertEquals(+1, Precision.compareTo(Double.MAX_VALUE, Double.NaN, Integer.MAX_VALUE)); Assert.assertEquals(+1, Precision.compareTo(Double.NaN, Double.MAX_VALUE, Integer.MAX_VALUE)); } @Test public void testRoundDouble() { double x = 1.234567890; Assert.assertEquals(1.23, Precision.round(x, 2), 0.0); Assert.assertEquals(1.235, Precision.round(x, 3), 0.0); Assert.assertEquals(1.2346, Precision.round(x, 4), 0.0); // JIRA MATH-151 Assert.assertEquals(39.25, Precision.round(39.245, 2), 0.0); Assert.assertEquals(39.24, Precision.round(39.245, 2, BigDecimal.ROUND_DOWN), 0.0); double xx = 39.0; xx = xx + 245d / 1000d; Assert.assertEquals(39.25, Precision.round(xx, 2), 0.0); // BZ 35904 Assert.assertEquals(30.1d, Precision.round(30.095d, 2), 0.0d); Assert.assertEquals(30.1d, Precision.round(30.095d, 1), 0.0d); Assert.assertEquals(33.1d, Precision.round(33.095d, 1), 0.0d); Assert.assertEquals(33.1d, Precision.round(33.095d, 2), 0.0d); Assert.assertEquals(50.09d, Precision.round(50.085d, 2), 0.0d); Assert.assertEquals(50.19d, Precision.round(50.185d, 2), 0.0d); Assert.assertEquals(50.01d, Precision.round(50.005d, 2), 0.0d); Assert.assertEquals(30.01d, Precision.round(30.005d, 2), 0.0d); Assert.assertEquals(30.65d, Precision.round(30.645d, 2), 0.0d); Assert.assertEquals(1.24, Precision.round(x, 2, BigDecimal.ROUND_CEILING), 0.0); Assert.assertEquals(1.235, Precision.round(x, 3, BigDecimal.ROUND_CEILING), 0.0); Assert.assertEquals(1.2346, Precision.round(x, 4, BigDecimal.ROUND_CEILING), 0.0); Assert.assertEquals(-1.23, Precision.round(-x, 2, BigDecimal.ROUND_CEILING), 0.0); Assert.assertEquals(-1.234, Precision.round(-x, 3, BigDecimal.ROUND_CEILING), 0.0); Assert.assertEquals(-1.2345, Precision.round(-x, 4, BigDecimal.ROUND_CEILING), 0.0); Assert.assertEquals(1.23, Precision.round(x, 2, BigDecimal.ROUND_DOWN), 0.0); Assert.assertEquals(1.234, Precision.round(x, 3, BigDecimal.ROUND_DOWN), 0.0); Assert.assertEquals(1.2345, Precision.round(x, 4, BigDecimal.ROUND_DOWN), 0.0); Assert.assertEquals(-1.23, Precision.round(-x, 2, BigDecimal.ROUND_DOWN), 0.0); Assert.assertEquals(-1.234, Precision.round(-x, 3, BigDecimal.ROUND_DOWN), 0.0); Assert.assertEquals(-1.2345, Precision.round(-x, 4, BigDecimal.ROUND_DOWN), 0.0); Assert.assertEquals(1.23, Precision.round(x, 2, BigDecimal.ROUND_FLOOR), 0.0); Assert.assertEquals(1.234, Precision.round(x, 3, BigDecimal.ROUND_FLOOR), 0.0); Assert.assertEquals(1.2345, Precision.round(x, 4, BigDecimal.ROUND_FLOOR), 0.0); Assert.assertEquals(-1.24, Precision.round(-x, 2, BigDecimal.ROUND_FLOOR), 0.0); Assert.assertEquals(-1.235, Precision.round(-x, 3, BigDecimal.ROUND_FLOOR), 0.0); Assert.assertEquals(-1.2346, Precision.round(-x, 4, BigDecimal.ROUND_FLOOR), 0.0); Assert.assertEquals(1.23, Precision.round(x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0); Assert.assertEquals(1.235, Precision.round(x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0); Assert.assertEquals(1.2346, Precision.round(x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0); Assert.assertEquals(-1.23, Precision.round(-x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0); Assert.assertEquals(-1.235, Precision.round(-x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0); Assert.assertEquals(-1.2346, Precision.round(-x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0); Assert.assertEquals(1.234, Precision.round(1.2345, 3, BigDecimal.ROUND_HALF_DOWN), 0.0); Assert.assertEquals(-1.234, Precision.round(-1.2345, 3, BigDecimal.ROUND_HALF_DOWN), 0.0); Assert.assertEquals(1.23, Precision.round(x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0); Assert.assertEquals(1.235, Precision.round(x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0); Assert.assertEquals(1.2346, Precision.round(x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0); Assert.assertEquals(-1.23, Precision.round(-x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0); Assert.assertEquals(-1.235, Precision.round(-x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0); Assert.assertEquals(-1.2346, Precision.round(-x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0); Assert.assertEquals(1.234, Precision.round(1.2345, 3, BigDecimal.ROUND_HALF_EVEN), 0.0); Assert.assertEquals(-1.234, Precision.round(-1.2345, 3, BigDecimal.ROUND_HALF_EVEN), 0.0); Assert.assertEquals(1.236, Precision.round(1.2355, 3, BigDecimal.ROUND_HALF_EVEN), 0.0); Assert.assertEquals(-1.236, Precision.round(-1.2355, 3, BigDecimal.ROUND_HALF_EVEN), 0.0); Assert.assertEquals(1.23, Precision.round(x, 2, BigDecimal.ROUND_HALF_UP), 0.0); Assert.assertEquals(1.235, Precision.round(x, 3, BigDecimal.ROUND_HALF_UP), 0.0); Assert.assertEquals(1.2346, Precision.round(x, 4, BigDecimal.ROUND_HALF_UP), 0.0); Assert.assertEquals(-1.23, Precision.round(-x, 2, BigDecimal.ROUND_HALF_UP), 0.0); Assert.assertEquals(-1.235, Precision.round(-x, 3, BigDecimal.ROUND_HALF_UP), 0.0); Assert.assertEquals(-1.2346, Precision.round(-x, 4, BigDecimal.ROUND_HALF_UP), 0.0); Assert.assertEquals(1.235, Precision.round(1.2345, 3, BigDecimal.ROUND_HALF_UP), 0.0); Assert.assertEquals(-1.235, Precision.round(-1.2345, 3, BigDecimal.ROUND_HALF_UP), 0.0); Assert.assertEquals(-1.23, Precision.round(-1.23, 2, BigDecimal.ROUND_UNNECESSARY), 0.0); Assert.assertEquals(1.23, Precision.round(1.23, 2, BigDecimal.ROUND_UNNECESSARY), 0.0); try { Precision.round(1.234, 2, BigDecimal.ROUND_UNNECESSARY); Assert.fail(); } catch (ArithmeticException ex) { // expected } Assert.assertEquals(1.24, Precision.round(x, 2, BigDecimal.ROUND_UP), 0.0); Assert.assertEquals(1.235, Precision.round(x, 3, BigDecimal.ROUND_UP), 0.0); Assert.assertEquals(1.2346, Precision.round(x, 4, BigDecimal.ROUND_UP), 0.0); Assert.assertEquals(-1.24, Precision.round(-x, 2, BigDecimal.ROUND_UP), 0.0); Assert.assertEquals(-1.235, Precision.round(-x, 3, BigDecimal.ROUND_UP), 0.0); Assert.assertEquals(-1.2346, Precision.round(-x, 4, BigDecimal.ROUND_UP), 0.0); try { Precision.round(1.234, 2, 1923); Assert.fail(); } catch (IllegalArgumentException ex) { // expected } // MATH-151 Assert.assertEquals(39.25, Precision.round(39.245, 2, BigDecimal.ROUND_HALF_UP), 0.0); // special values TestUtils.assertEquals(Double.NaN, Precision.round(Double.NaN, 2), 0.0); Assert.assertEquals(0.0, Precision.round(0.0, 2), 0.0); Assert.assertEquals(Double.POSITIVE_INFINITY, Precision.round(Double.POSITIVE_INFINITY, 2), 0.0); Assert.assertEquals(Double.NEGATIVE_INFINITY, Precision.round(Double.NEGATIVE_INFINITY, 2), 0.0); } @Test public void testRoundFloat() { float x = 1.234567890f; Assert.assertEquals(1.23f, Precision.round(x, 2), 0.0); Assert.assertEquals(1.235f, Precision.round(x, 3), 0.0); Assert.assertEquals(1.2346f, Precision.round(x, 4), 0.0); // BZ 35904 Assert.assertEquals(30.1f, Precision.round(30.095f, 2), 0.0f); Assert.assertEquals(30.1f, Precision.round(30.095f, 1), 0.0f); Assert.assertEquals(50.09f, Precision.round(50.085f, 2), 0.0f); Assert.assertEquals(50.19f, Precision.round(50.185f, 2), 0.0f); Assert.assertEquals(50.01f, Precision.round(50.005f, 2), 0.0f); Assert.assertEquals(30.01f, Precision.round(30.005f, 2), 0.0f); Assert.assertEquals(30.65f, Precision.round(30.645f, 2), 0.0f); Assert.assertEquals(1.24f, Precision.round(x, 2, BigDecimal.ROUND_CEILING), 0.0); Assert.assertEquals(1.235f, Precision.round(x, 3, BigDecimal.ROUND_CEILING), 0.0); Assert.assertEquals(1.2346f, Precision.round(x, 4, BigDecimal.ROUND_CEILING), 0.0); Assert.assertEquals(-1.23f, Precision.round(-x, 2, BigDecimal.ROUND_CEILING), 0.0); Assert.assertEquals(-1.234f, Precision.round(-x, 3, BigDecimal.ROUND_CEILING), 0.0); Assert.assertEquals(-1.2345f, Precision.round(-x, 4, BigDecimal.ROUND_CEILING), 0.0); Assert.assertEquals(1.23f, Precision.round(x, 2, BigDecimal.ROUND_DOWN), 0.0); Assert.assertEquals(1.234f, Precision.round(x, 3, BigDecimal.ROUND_DOWN), 0.0); Assert.assertEquals(1.2345f, Precision.round(x, 4, BigDecimal.ROUND_DOWN), 0.0); Assert.assertEquals(-1.23f, Precision.round(-x, 2, BigDecimal.ROUND_DOWN), 0.0); Assert.assertEquals(-1.234f, Precision.round(-x, 3, BigDecimal.ROUND_DOWN), 0.0); Assert.assertEquals(-1.2345f, Precision.round(-x, 4, BigDecimal.ROUND_DOWN), 0.0); Assert.assertEquals(1.23f, Precision.round(x, 2, BigDecimal.ROUND_FLOOR), 0.0); Assert.assertEquals(1.234f, Precision.round(x, 3, BigDecimal.ROUND_FLOOR), 0.0); Assert.assertEquals(1.2345f, Precision.round(x, 4, BigDecimal.ROUND_FLOOR), 0.0); Assert.assertEquals(-1.24f, Precision.round(-x, 2, BigDecimal.ROUND_FLOOR), 0.0); Assert.assertEquals(-1.235f, Precision.round(-x, 3, BigDecimal.ROUND_FLOOR), 0.0); Assert.assertEquals(-1.2346f, Precision.round(-x, 4, BigDecimal.ROUND_FLOOR), 0.0); Assert.assertEquals(1.23f, Precision.round(x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0); Assert.assertEquals(1.235f, Precision.round(x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0); Assert.assertEquals(1.2346f, Precision.round(x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0); Assert.assertEquals(-1.23f, Precision.round(-x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0); Assert.assertEquals(-1.235f, Precision.round(-x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0); Assert.assertEquals(-1.2346f, Precision.round(-x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0); Assert.assertEquals(1.234f, Precision.round(1.2345f, 3, BigDecimal.ROUND_HALF_DOWN), 0.0); Assert.assertEquals(-1.234f, Precision.round(-1.2345f, 3, BigDecimal.ROUND_HALF_DOWN), 0.0); Assert.assertEquals(1.23f, Precision.round(x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0); Assert.assertEquals(1.235f, Precision.round(x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0); Assert.assertEquals(1.2346f, Precision.round(x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0); Assert.assertEquals(-1.23f, Precision.round(-x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0); Assert.assertEquals(-1.235f, Precision.round(-x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0); Assert.assertEquals(-1.2346f, Precision.round(-x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0); Assert.assertEquals(1.234f, Precision.round(1.2345f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0); Assert.assertEquals(-1.234f, Precision.round(-1.2345f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0); Assert.assertEquals(1.236f, Precision.round(1.2355f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0); Assert.assertEquals(-1.236f, Precision.round(-1.2355f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0); Assert.assertEquals(1.23f, Precision.round(x, 2, BigDecimal.ROUND_HALF_UP), 0.0); Assert.assertEquals(1.235f, Precision.round(x, 3, BigDecimal.ROUND_HALF_UP), 0.0); Assert.assertEquals(1.2346f, Precision.round(x, 4, BigDecimal.ROUND_HALF_UP), 0.0); Assert.assertEquals(-1.23f, Precision.round(-x, 2, BigDecimal.ROUND_HALF_UP), 0.0); Assert.assertEquals(-1.235f, Precision.round(-x, 3, BigDecimal.ROUND_HALF_UP), 0.0); Assert.assertEquals(-1.2346f, Precision.round(-x, 4, BigDecimal.ROUND_HALF_UP), 0.0); Assert.assertEquals(1.235f, Precision.round(1.2345f, 3, BigDecimal.ROUND_HALF_UP), 0.0); Assert.assertEquals(-1.235f, Precision.round(-1.2345f, 3, BigDecimal.ROUND_HALF_UP), 0.0); Assert.assertEquals(-1.23f, Precision.round(-1.23f, 2, BigDecimal.ROUND_UNNECESSARY), 0.0); Assert.assertEquals(1.23f, Precision.round(1.23f, 2, BigDecimal.ROUND_UNNECESSARY), 0.0); try { Precision.round(1.234f, 2, BigDecimal.ROUND_UNNECESSARY); Assert.fail(); } catch (MathArithmeticException ex) { // success } Assert.assertEquals(1.24f, Precision.round(x, 2, BigDecimal.ROUND_UP), 0.0); Assert.assertEquals(1.235f, Precision.round(x, 3, BigDecimal.ROUND_UP), 0.0); Assert.assertEquals(1.2346f, Precision.round(x, 4, BigDecimal.ROUND_UP), 0.0); Assert.assertEquals(-1.24f, Precision.round(-x, 2, BigDecimal.ROUND_UP), 0.0); Assert.assertEquals(-1.235f, Precision.round(-x, 3, BigDecimal.ROUND_UP), 0.0); Assert.assertEquals(-1.2346f, Precision.round(-x, 4, BigDecimal.ROUND_UP), 0.0); try { Precision.round(1.234f, 2, 1923); Assert.fail(); } catch (MathIllegalArgumentException ex) { // success } // special values TestUtils.assertEquals(Float.NaN, Precision.round(Float.NaN, 2), 0.0f); Assert.assertEquals(0.0f, Precision.round(0.0f, 2), 0.0f); Assert.assertEquals(Float.POSITIVE_INFINITY, Precision.round(Float.POSITIVE_INFINITY, 2), 0.0f); Assert.assertEquals(Float.NEGATIVE_INFINITY, Precision.round(Float.NEGATIVE_INFINITY, 2), 0.0f); } @Test public void testIssue721() { Assert.assertEquals(-53, FastMath.getExponent(Precision.EPSILON)); Assert.assertEquals(-1022, FastMath.getExponent(Precision.SAFE_MIN)); } @Test public void testRepresentableDelta() { int nonRepresentableCount = 0; final double x = 100; final int numTrials = 10000; for (int i = 0; i < numTrials; i++) { final double originalDelta = Math.random(); final double delta = Precision.representableDelta(x, originalDelta); if (delta != originalDelta) { ++nonRepresentableCount; } } Assert.assertTrue(nonRepresentableCount / (double) numTrials > 0.9); } @Test public void testMath843() { final double afterEpsilon = FastMath.nextAfter(Precision.EPSILON, Double.POSITIVE_INFINITY); // a) 1 + EPSILON is equal to 1. Assert.assertTrue(1 + Precision.EPSILON == 1); // b) 1 + "the number after EPSILON" is not equal to 1. Assert.assertFalse(1 + afterEpsilon == 1); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.util; import org.apache.commons.math3.distribution.IntegerDistribution; import org.apache.commons.math3.distribution.UniformIntegerDistribution; import org.junit.After; import org.junit.Assert; import org.junit.Before; import org.junit.Test; /** * This class contains test cases for the ResizableDoubleArray. * * @version $Id$ */ public class ResizableDoubleArrayTest extends DoubleArrayAbstractTest { @After public void tearDown() throws Exception { da = null; ra = null; } @Before public void setUp() throws Exception { da = new ResizableDoubleArray(); ra = new ResizableDoubleArray(); } @Test public void testConstructors() { float defaultExpansionFactor = 2.0f; float defaultContractionCriteria = 2.5f; int defaultMode = ResizableDoubleArray.MULTIPLICATIVE_MODE; ResizableDoubleArray testDa = new ResizableDoubleArray(2); Assert.assertEquals(0, testDa.getNumElements()); Assert.assertEquals(2, testDa.getCapacity()); Assert.assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0); Assert.assertEquals(defaultContractionCriteria, testDa.getContractionCriteria(), 0); Assert.assertEquals(defaultMode, testDa.getExpansionMode()); try { da = new ResizableDoubleArray(-1); Assert.fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } testDa = new ResizableDoubleArray((double[]) null); Assert.assertEquals(0, testDa.getNumElements()); double[] initialArray = new double[] { 0, 1, 2 }; testDa = new ResizableDoubleArray(initialArray); Assert.assertEquals(3, testDa.getNumElements()); testDa = new ResizableDoubleArray(2, 2.0f); Assert.assertEquals(0, testDa.getNumElements()); Assert.assertEquals(2, testDa.getCapacity()); Assert.assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0); Assert.assertEquals(defaultContractionCriteria, testDa.getContractionCriteria(), 0); Assert.assertEquals(defaultMode, testDa.getExpansionMode()); try { da = new ResizableDoubleArray(2, 0.5f); Assert.fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } testDa = new ResizableDoubleArray(2, 3.0f); Assert.assertEquals(3.0f, testDa.getExpansionFactor(), 0); Assert.assertEquals(3.5f, testDa.getContractionCriteria(), 0); testDa = new ResizableDoubleArray(2, 2.0f, 3.0f); Assert.assertEquals(0, testDa.getNumElements()); Assert.assertEquals(2, testDa.getCapacity()); Assert.assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0); Assert.assertEquals(3.0f, testDa.getContractionCriteria(), 0); Assert.assertEquals(defaultMode, testDa.getExpansionMode()); try { da = new ResizableDoubleArray(2, 2.0f, 1.5f); Assert.fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } testDa = new ResizableDoubleArray(2, 2.0f, 3.0f, ResizableDoubleArray.ADDITIVE_MODE); Assert.assertEquals(0, testDa.getNumElements()); Assert.assertEquals(2, testDa.getCapacity()); Assert.assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0); Assert.assertEquals(3.0f, testDa.getContractionCriteria(), 0); Assert.assertEquals(ResizableDoubleArray.ADDITIVE_MODE, testDa.getExpansionMode()); try { da = new ResizableDoubleArray(2, 2.0f, 2.5f, -1); Assert.fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } // Copy constructor testDa = new ResizableDoubleArray(2, 2.0f, 3.0f, ResizableDoubleArray.ADDITIVE_MODE); testDa.addElement(2.0); testDa.addElement(3.2); ResizableDoubleArray copyDa = new ResizableDoubleArray(testDa); Assert.assertEquals(copyDa, testDa); Assert.assertEquals(testDa, copyDa); } @Test public void testSetElementArbitraryExpansion1() { // MULTIPLICATIVE_MODE da.addElement(2.0); da.addElement(4.0); da.addElement(6.0); da.setElement(1, 3.0); // Expand the array arbitrarily to 1000 items da.setElement(1000, 3.4); Assert.assertEquals( "The number of elements should now be 1001, it isn't", da.getNumElements(), 1001); Assert.assertEquals( "Uninitialized Elements are default value of 0.0, index 766 wasn't", 0.0, da.getElement( 760 ), Double.MIN_VALUE ); Assert.assertEquals( "The 1000th index should be 3.4, it isn't", 3.4, da.getElement(1000), Double.MIN_VALUE ); Assert.assertEquals( "The 0th index should be 2.0, it isn't", 2.0, da.getElement(0), Double.MIN_VALUE); } @Test public void testSetElementArbitraryExpansion2() { // Make sure numElements and expansion work correctly for expansion boundary cases da.addElement(2.0); da.addElement(4.0); da.addElement(6.0); Assert.assertEquals(16, ((ResizableDoubleArray) da).getCapacity()); Assert.assertEquals(3, da.getNumElements()); da.setElement(3, 7.0); Assert.assertEquals(16, ((ResizableDoubleArray) da).getCapacity()); Assert.assertEquals(4, da.getNumElements()); da.setElement(10, 10.0); Assert.assertEquals(16, ((ResizableDoubleArray) da).getCapacity()); Assert.assertEquals(11, da.getNumElements()); da.setElement(9, 10.0); Assert.assertEquals(16, ((ResizableDoubleArray) da).getCapacity()); Assert.assertEquals(11, da.getNumElements()); try { da.setElement(-2, 3); Assert.fail("Expecting ArrayIndexOutOfBoundsException for negative index"); } catch (ArrayIndexOutOfBoundsException ex) { // expected } // ADDITIVE_MODE ResizableDoubleArray testDa = new ResizableDoubleArray(2, 2.0f, 3.0f, ResizableDoubleArray.ADDITIVE_MODE); Assert.assertEquals(2, testDa.getCapacity()); testDa.addElement(1d); testDa.addElement(1d); Assert.assertEquals(2, testDa.getCapacity()); testDa.addElement(1d); Assert.assertEquals(4, testDa.getCapacity()); } @Override @Test public void testAdd1000() { super.testAdd1000(); Assert.assertEquals("Internal Storage length should be 1024 if we started out with initial capacity of " + "16 and an expansion factor of 2.0", 1024, ((ResizableDoubleArray) da).getCapacity()); } @Test public void testAddElements() { ResizableDoubleArray testDa = new ResizableDoubleArray(); // MULTIPLICATIVE_MODE testDa.addElements(new double[] {4, 5, 6}); Assert.assertEquals(3, testDa.getNumElements(), 0); Assert.assertEquals(4, testDa.getElement(0), 0); Assert.assertEquals(5, testDa.getElement(1), 0); Assert.assertEquals(6, testDa.getElement(2), 0); testDa.addElements(new double[] {4, 5, 6}); Assert.assertEquals(6, testDa.getNumElements()); // ADDITIVE_MODE (x's are occupied storage locations, 0's are open) testDa = new ResizableDoubleArray(2, 2.0f, 2.5f, ResizableDoubleArray.ADDITIVE_MODE); Assert.assertEquals(2, testDa.getCapacity()); testDa.addElements(new double[] { 1d }); // x,0 testDa.addElements(new double[] { 2d }); // x,x testDa.addElements(new double[] { 3d }); // x,x,x,0 -- expanded Assert.assertEquals(1d, testDa.getElement(0), 0); Assert.assertEquals(2d, testDa.getElement(1), 0); Assert.assertEquals(3d, testDa.getElement(2), 0); Assert.assertEquals(4, testDa.getCapacity()); // x,x,x,0 Assert.assertEquals(3, testDa.getNumElements()); } @Override @Test public void testAddElementRolling() { super.testAddElementRolling(); // MULTIPLICATIVE_MODE da.clear(); da.addElement(1); da.addElement(2); da.addElementRolling(3); Assert.assertEquals(3, da.getElement(1), 0); da.addElementRolling(4); Assert.assertEquals(3, da.getElement(0), 0); Assert.assertEquals(4, da.getElement(1), 0); da.addElement(5); Assert.assertEquals(5, da.getElement(2), 0); da.addElementRolling(6); Assert.assertEquals(4, da.getElement(0), 0); Assert.assertEquals(5, da.getElement(1), 0); Assert.assertEquals(6, da.getElement(2), 0); // ADDITIVE_MODE (x's are occupied storage locations, 0's are open) ResizableDoubleArray testDa = new ResizableDoubleArray(2, 2.0f, 2.5f, ResizableDoubleArray.ADDITIVE_MODE); Assert.assertEquals(2, testDa.getCapacity()); testDa.addElement(1d); // x,0 testDa.addElement(2d); // x,x testDa.addElement(3d); // x,x,x,0 -- expanded Assert.assertEquals(1d, testDa.getElement(0), 0); Assert.assertEquals(2d, testDa.getElement(1), 0); Assert.assertEquals(3d, testDa.getElement(2), 0); Assert.assertEquals(4, testDa.getCapacity()); // x,x,x,0 Assert.assertEquals(3, testDa.getNumElements()); testDa.addElementRolling(4d); Assert.assertEquals(2d, testDa.getElement(0), 0); Assert.assertEquals(3d, testDa.getElement(1), 0); Assert.assertEquals(4d, testDa.getElement(2), 0); Assert.assertEquals(4, testDa.getCapacity()); // 0,x,x,x Assert.assertEquals(3, testDa.getNumElements()); testDa.addElementRolling(5d); // 0,0,x,x,x,0 -- time to contract Assert.assertEquals(3d, testDa.getElement(0), 0); Assert.assertEquals(4d, testDa.getElement(1), 0); Assert.assertEquals(5d, testDa.getElement(2), 0); Assert.assertEquals(4, testDa.getCapacity()); // contracted -- x,x,x,0 Assert.assertEquals(3, testDa.getNumElements()); try { testDa.getElement(4); Assert.fail("Expecting ArrayIndexOutOfBoundsException"); } catch (ArrayIndexOutOfBoundsException ex) { // expected } try { testDa.getElement(-1); Assert.fail("Expecting ArrayIndexOutOfBoundsException"); } catch (ArrayIndexOutOfBoundsException ex) { // expected } } @Test public void testSetNumberOfElements() { da.addElement( 1.0 ); da.addElement( 1.0 ); da.addElement( 1.0 ); da.addElement( 1.0 ); da.addElement( 1.0 ); da.addElement( 1.0 ); Assert.assertEquals( "Number of elements should equal 6", da.getNumElements(), 6); ((ResizableDoubleArray) da).setNumElements( 3 ); Assert.assertEquals( "Number of elements should equal 3", da.getNumElements(), 3); try { ((ResizableDoubleArray) da).setNumElements( -3 ); Assert.fail( "Setting number of elements to negative should've thrown an exception"); } catch( IllegalArgumentException iae ) { } ((ResizableDoubleArray) da).setNumElements(1024); Assert.assertEquals( "Number of elements should now be 1024", da.getNumElements(), 1024); Assert.assertEquals( "Element 453 should be a default double", da.getElement( 453 ), 0.0, Double.MIN_VALUE); } @Test public void testWithInitialCapacity() { ResizableDoubleArray eDA2 = new ResizableDoubleArray(2); Assert.assertEquals("Initial number of elements should be 0", 0, eDA2.getNumElements()); final IntegerDistribution randomData = new UniformIntegerDistribution(100, 1000); final int iterations = randomData.sample(); for( int i = 0; i < iterations; i++) { eDA2.addElement( i ); } Assert.assertEquals("Number of elements should be equal to " + iterations, iterations, eDA2.getNumElements()); eDA2.addElement( 2.0 ); Assert.assertEquals("Number of elements should be equals to " + (iterations +1), iterations + 1 , eDA2.getNumElements() ); } @Test public void testWithInitialCapacityAndExpansionFactor() { ResizableDoubleArray eDA3 = new ResizableDoubleArray(3, 3.0f, 3.5f); Assert.assertEquals("Initial number of elements should be 0", 0, eDA3.getNumElements() ); final IntegerDistribution randomData = new UniformIntegerDistribution(100, 3000); final int iterations = randomData.sample(); for( int i = 0; i < iterations; i++) { eDA3.addElement( i ); } Assert.assertEquals("Number of elements should be equal to " + iterations, iterations,eDA3.getNumElements()); eDA3.addElement( 2.0 ); Assert.assertEquals("Number of elements should be equals to " + (iterations +1), iterations +1, eDA3.getNumElements() ); Assert.assertEquals("Expansion factor should equal 3.0", 3.0f, eDA3.getExpansionFactor(), Double.MIN_VALUE); } @Test public void testDiscard() { da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); Assert.assertEquals( "Number of elements should be 11", 11, da.getNumElements()); ((ResizableDoubleArray)da).discardFrontElements(5); Assert.assertEquals( "Number of elements should be 6", 6, da.getNumElements()); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); Assert.assertEquals( "Number of elements should be 10", 10, da.getNumElements()); ((ResizableDoubleArray)da).discardMostRecentElements(2); Assert.assertEquals( "Number of elements should be 8", 8, da.getNumElements()); try { ((ResizableDoubleArray)da).discardFrontElements(-1); Assert.fail( "Trying to discard a negative number of element is not allowed"); } catch( Exception e ){ } try { ((ResizableDoubleArray)da).discardMostRecentElements(-1); Assert.fail( "Trying to discard a negative number of element is not allowed"); } catch( Exception e ){ } try { ((ResizableDoubleArray)da).discardFrontElements( 10000 ); Assert.fail( "You can't discard more elements than the array contains"); } catch( Exception e ){ } try { ((ResizableDoubleArray)da).discardMostRecentElements( 10000 ); Assert.fail( "You can't discard more elements than the array contains"); } catch( Exception e ){ } } @Test public void testSubstitute() { da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); Assert.assertEquals( "Number of elements should be 11", 11, da.getNumElements()); ((ResizableDoubleArray)da).substituteMostRecentElement(24); Assert.assertEquals( "Number of elements should be 11", 11, da.getNumElements()); try { ((ResizableDoubleArray)da).discardMostRecentElements(10); } catch( Exception e ){ Assert.fail( "Trying to discard a negative number of element is not allowed"); } ((ResizableDoubleArray)da).substituteMostRecentElement(24); Assert.assertEquals( "Number of elements should be 1", 1, da.getNumElements()); } @Test public void testMutators() { ((ResizableDoubleArray)da).setContractionCriteria(10f); Assert.assertEquals(10f, ((ResizableDoubleArray)da).getContractionCriteria(), 0); ((ResizableDoubleArray)da).setExpansionFactor(8f); Assert.assertEquals(8f, ((ResizableDoubleArray)da).getExpansionFactor(), 0); try { ((ResizableDoubleArray)da).setExpansionFactor(11f); // greater than contractionCriteria Assert.fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } ((ResizableDoubleArray)da).setExpansionMode( ResizableDoubleArray.ADDITIVE_MODE); Assert.assertEquals(ResizableDoubleArray.ADDITIVE_MODE, ((ResizableDoubleArray)da).getExpansionMode()); try { ((ResizableDoubleArray)da).setExpansionMode(-1); Assert.fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } } @Test public void testEqualsAndHashCode() throws Exception { // Wrong type ResizableDoubleArray first = new ResizableDoubleArray(); Double other = new Double(2); Assert.assertFalse(first.equals(other)); // Null other = null; Assert.assertFalse(first.equals(other)); // Reflexive Assert.assertTrue(first.equals(first)); // Argumentless constructor ResizableDoubleArray second = new ResizableDoubleArray(); verifyEquality(first, second); // Equals iff same data, same properties ResizableDoubleArray third = new ResizableDoubleArray(3, 2.0f, 2.0f); verifyInequality(third, first); ResizableDoubleArray fourth = new ResizableDoubleArray(3, 2.0f, 2.0f); ResizableDoubleArray fifth = new ResizableDoubleArray(2, 2.0f, 2.0f); verifyEquality(third, fourth); verifyInequality(third, fifth); third.addElement(4.1); third.addElement(4.2); third.addElement(4.3); fourth.addElement(4.1); fourth.addElement(4.2); fourth.addElement(4.3); verifyEquality(third, fourth); // expand fourth.addElement(4.4); verifyInequality(third, fourth); third.addElement(4.4); verifyEquality(third, fourth); fourth.addElement(4.4); verifyInequality(third, fourth); third.addElement(4.4); verifyEquality(third, fourth); fourth.addElementRolling(4.5); third.addElementRolling(4.5); verifyEquality(third, fourth); // discard third.discardFrontElements(1); verifyInequality(third, fourth); fourth.discardFrontElements(1); verifyEquality(third, fourth); // discard recent third.discardMostRecentElements(2); fourth.discardMostRecentElements(2); verifyEquality(third, fourth); // wrong order third.addElement(18); fourth.addElement(17); third.addElement(17); fourth.addElement(18); verifyInequality(third, fourth); // copy ResizableDoubleArray.copy(fourth, fifth); verifyEquality(fourth, fifth); // Copy constructor verifyEquality(fourth, new ResizableDoubleArray(fourth)); // Instance copy verifyEquality(fourth, fourth.copy()); } @Test public void testGetArrayRef() { final ResizableDoubleArray a = new ResizableDoubleArray(); // Modify "a" through the public API. final int index = 20; final double v1 = 1.2; a.setElement(index, v1); // Modify the internal storage through the protected API. final double v2 = v1 + 3.4; final double[] aInternalArray = a.getArrayRef(); aInternalArray[a.getStartIndex() + index] = v2; Assert.assertEquals(v2, a.getElement(index), 0d); } @Test public void testCompute() { final ResizableDoubleArray a = new ResizableDoubleArray(); final int max = 20; for (int i = 1; i <= max; i++) { a.setElement(i, i); } final MathArrays.Function add = new MathArrays.Function() { public double evaluate(double[] a, int index, int num) { double sum = 0; final int max = index + num; for (int i = index; i < max; i++) { sum += a[i]; } return sum; } public double evaluate(double[] a) { return evaluate(a, 0, a.length); } }; final double sum = a.compute(add); Assert.assertEquals(0.5 * max * (max + 1), sum, 0); } private void verifyEquality(ResizableDoubleArray a, ResizableDoubleArray b) { Assert.assertTrue(b.equals(a)); Assert.assertTrue(a.equals(b)); Assert.assertEquals(a.hashCode(), b.hashCode()); } private void verifyInequality(ResizableDoubleArray a, ResizableDoubleArray b) { Assert.assertFalse(b.equals(a)); Assert.assertFalse(a.equals(b)); Assert.assertFalse(a.hashCode() == b.hashCode()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math3.util; import org.apache.commons.math3.TestUtils; import org.junit.Assert; import org.junit.Test; /** * @version $Id$ */ public class TransformerMapTest { /** * */ @Test public void testPutTransformer(){ NumberTransformer expected = new DefaultTransformer(); TransformerMap map = new TransformerMap(); map.putTransformer(TransformerMapTest.class, expected); Assert.assertEquals(expected, map.getTransformer(TransformerMapTest.class)); } /** * */ @Test public void testContainsClass(){ NumberTransformer expected = new DefaultTransformer(); TransformerMap map = new TransformerMap(); map.putTransformer(TransformerMapTest.class, expected); Assert.assertTrue(map.containsClass(TransformerMapTest.class)); } /** * */ @Test public void testContainsTransformer(){ NumberTransformer expected = new DefaultTransformer(); TransformerMap map = new TransformerMap(); map.putTransformer(TransformerMapTest.class, expected); Assert.assertTrue(map.containsTransformer(expected)); } /** * */ @Test public void testRemoveTransformer(){ NumberTransformer expected = new DefaultTransformer(); TransformerMap map = new TransformerMap(); map.putTransformer(TransformerMapTest.class, expected); Assert.assertTrue(map.containsClass(TransformerMapTest.class)); Assert.assertTrue(map.containsTransformer(expected)); map.removeTransformer(TransformerMapTest.class); Assert.assertFalse(map.containsClass(TransformerMapTest.class)); Assert.assertFalse(map.containsTransformer(expected)); } /** * */ @Test public void testClear(){ NumberTransformer expected = new DefaultTransformer(); TransformerMap map = new TransformerMap(); map.putTransformer(TransformerMapTest.class, expected); Assert.assertTrue(map.containsClass(TransformerMapTest.class)); map.clear(); Assert.assertFalse(map.containsClass(TransformerMapTest.class)); } /** * */ @Test public void testClasses(){ NumberTransformer expected = new DefaultTransformer(); TransformerMap map = new TransformerMap(); map.putTransformer(TransformerMapTest.class, expected); Assert.assertTrue(map.classes().contains(TransformerMapTest.class)); } /** * */ @Test public void testTransformers(){ NumberTransformer expected = new DefaultTransformer(); TransformerMap map = new TransformerMap(); map.putTransformer(TransformerMapTest.class, expected); Assert.assertTrue(map.transformers().contains(expected)); } @Test public void testSerial(){ NumberTransformer expected = new DefaultTransformer(); TransformerMap map = new TransformerMap(); map.putTransformer(TransformerMapTest.class, expected); Assert.assertEquals(map, TestUtils.serializeAndRecover(map)); } }
