/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.base.AbstractPartial; import org.joda.time.chrono.BuddhistChronology; import org.joda.time.chrono.ISOChronology; import org.joda.time.field.AbstractPartialFieldProperty; /** * This class is a Junit unit test for YearMonthDay. * * @author Stephen Colebourne */ public class TestAbstractPartial extends TestCase { private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private long TEST_TIME_NOW = (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; private long TEST_TIME1 = (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; private long TEST_TIME2 = (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone zone = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestAbstractPartial.class); } public TestAbstractPartial(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); zone = DateTimeZone.getDefault(); DateTimeZone.setDefault(DateTimeZone.UTC); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(zone); zone = null; } //----------------------------------------------------------------------- public void testGetValue() throws Throwable { MockPartial mock = new MockPartial(); assertEquals(1970, mock.getValue(0)); assertEquals(1, mock.getValue(1)); try { mock.getValue(-1); fail(); } catch (IndexOutOfBoundsException ex) {} try { mock.getValue(2); fail(); } catch (IndexOutOfBoundsException ex) {} } public void testGetValues() throws Throwable { MockPartial mock = new MockPartial(); int[] vals = mock.getValues(); assertEquals(2, vals.length); assertEquals(1970, vals[0]); assertEquals(1, vals[1]); } public void testGetField() throws Throwable { MockPartial mock = new MockPartial(); assertEquals(BuddhistChronology.getInstanceUTC().year(), mock.getField(0)); assertEquals(BuddhistChronology.getInstanceUTC().monthOfYear(), mock.getField(1)); try { mock.getField(-1); fail(); } catch (IndexOutOfBoundsException ex) {} try { mock.getField(2); fail(); } catch (IndexOutOfBoundsException ex) {} } public void testGetFieldType() throws Throwable { MockPartial mock = new MockPartial(); assertEquals(DateTimeFieldType.year(), mock.getFieldType(0)); assertEquals(DateTimeFieldType.monthOfYear(), mock.getFieldType(1)); try { mock.getFieldType(-1); fail(); } catch (IndexOutOfBoundsException ex) {} try { mock.getFieldType(2); fail(); } catch (IndexOutOfBoundsException ex) {} } public void testGetFieldTypes() throws Throwable { MockPartial mock = new MockPartial(); DateTimeFieldType[] vals = mock.getFieldTypes(); assertEquals(2, vals.length); assertEquals(DateTimeFieldType.year(), vals[0]); assertEquals(DateTimeFieldType.monthOfYear(), vals[1]); } public void testGetPropertyEquals() throws Throwable { MockProperty0 prop0 = new MockProperty0(); assertEquals(true, prop0.equals(prop0)); assertEquals(true, prop0.equals(new MockProperty0())); assertEquals(false, prop0.equals(new MockProperty1())); assertEquals(false, prop0.equals(new MockProperty0Val())); assertEquals(false, prop0.equals(new MockProperty0Field())); assertEquals(false, prop0.equals(new MockProperty0Chrono())); assertEquals(false, prop0.equals("")); assertEquals(false, prop0.equals(null)); } //----------------------------------------------------------------------- static class MockPartial extends AbstractPartial { int[] val = new int[] {1970, 1}; MockPartial() { super(); } protected DateTimeField getField(int index, Chronology chrono) { switch (index) { case 0: return chrono.year(); case 1: return chrono.monthOfYear(); default: throw new IndexOutOfBoundsException(); } } public int size() { return 2; } public int getValue(int index) { return val[index]; } public void setValue(int index, int value) { val[index] = value; } public Chronology getChronology() { return BuddhistChronology.getInstanceUTC(); } } static class MockProperty0 extends AbstractPartialFieldProperty { MockPartial partial = new MockPartial(); public DateTimeField getField() { return partial.getField(0); } public ReadablePartial getReadablePartial() { return partial; } public int get() { return partial.getValue(0); } } static class MockProperty1 extends AbstractPartialFieldProperty { MockPartial partial = new MockPartial(); public DateTimeField getField() { return partial.getField(1); } public ReadablePartial getReadablePartial() { return partial; } public int get() { return partial.getValue(1); } } static class MockProperty0Field extends MockProperty0 { public DateTimeField getField() { return BuddhistChronology.getInstanceUTC().hourOfDay(); } } static class MockProperty0Val extends MockProperty0 { public int get() { return 99; } } static class MockProperty0Chrono extends MockProperty0 { public ReadablePartial getReadablePartial() { return new MockPartial() { public Chronology getChronology() { return ISOChronology.getInstanceUTC(); } }; } } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.base.BasePartial; /** * This class is a Junit unit test for YearMonthDay. * * @author Stephen Colebourne */ public class TestBasePartial extends TestCase { private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private long TEST_TIME_NOW = (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; private long TEST_TIME1 = (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; private long TEST_TIME2 = (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone zone = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestBasePartial.class); } public TestBasePartial(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); zone = DateTimeZone.getDefault(); DateTimeZone.setDefault(DateTimeZone.UTC); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(zone); zone = null; } //----------------------------------------------------------------------- public void testSetMethods() throws Throwable { MockPartial mock = new MockPartial(); assertEquals(1970, mock.getYear()); assertEquals(1, mock.getMonthOfYear()); mock.setYear(2004); assertEquals(2004, mock.getYear()); assertEquals(1, mock.getMonthOfYear()); mock.setMonthOfYear(6); assertEquals(2004, mock.getYear()); assertEquals(6, mock.getMonthOfYear()); mock.set(2005, 5); assertEquals(2005, mock.getYear()); assertEquals(5, mock.getMonthOfYear()); try { mock.setMonthOfYear(0); fail(); } catch (IllegalArgumentException ex) {} assertEquals(2005, mock.getYear()); assertEquals(5, mock.getMonthOfYear()); try { mock.setMonthOfYear(13); fail(); } catch (IllegalArgumentException ex) {} assertEquals(2005, mock.getYear()); assertEquals(5, mock.getMonthOfYear()); } static class MockPartial extends BasePartial { MockPartial() { super(new int[] {1970, 1}, null); } protected DateTimeField getField(int index, Chronology chrono) { switch (index) { case 0: return chrono.year(); case 1: return chrono.monthOfYear(); default: throw new IndexOutOfBoundsException(); } } public int size() { return 2; } public int getYear() { return getValue(0); } public void setYear(int year) { setValue(0, year); } public int getMonthOfYear() { return getValue(1); } public void setMonthOfYear(int month) { setValue(1, month); } public void set(int year, int month) { setValues(new int[] {year, month}); } } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.base.BaseSingleFieldPeriod; /** * This class is a Junit unit test for BaseSingleFieldPeriod. * * @author Stephen Colebourne */ public class TestBaseSingleFieldPeriod extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestBaseSingleFieldPeriod.class); } public TestBaseSingleFieldPeriod(String name) { super(name); } protected void setUp() throws Exception { } protected void tearDown() throws Exception { } //----------------------------------------------------------------------- public void testFactory_between_RInstant() { // test using Days DateTime start = new DateTime(2006, 6, 9, 12, 0, 0, 0, PARIS); DateTime end1 = new DateTime(2006, 6, 12, 12, 0, 0, 0, PARIS); DateTime end2 = new DateTime(2006, 6, 15, 18, 0, 0, 0, PARIS); assertEquals(3, Single.between(start, end1, DurationFieldType.days())); assertEquals(0, Single.between(start, start, DurationFieldType.days())); assertEquals(0, Single.between(end1, end1, DurationFieldType.days())); assertEquals(-3, Single.between(end1, start, DurationFieldType.days())); assertEquals(6, Single.between(start, end2, DurationFieldType.days())); try { Single.between(start, (ReadableInstant) null, DurationFieldType.days()); fail(); } catch (IllegalArgumentException ex) { // expected } try { Single.between((ReadableInstant) null, end1, DurationFieldType.days()); fail(); } catch (IllegalArgumentException ex) { // expected } try { Single.between((ReadableInstant) null, (ReadableInstant) null, DurationFieldType.days()); fail(); } catch (IllegalArgumentException ex) { // expected } } @SuppressWarnings("deprecation") public void testFactory_between_RPartial() { LocalDate start = new LocalDate(2006, 6, 9); LocalDate end1 = new LocalDate(2006, 6, 12); YearMonthDay end2 = new YearMonthDay(2006, 6, 15); Single zero = new Single(0); assertEquals(3, Single.between(start, end1, zero)); assertEquals(0, Single.between(start, start, zero)); assertEquals(0, Single.between(end1, end1, zero)); assertEquals(-3, Single.between(end1, start, zero)); assertEquals(6, Single.between(start, end2, zero)); try { Single.between(start, (ReadablePartial) null, zero); fail(); } catch (IllegalArgumentException ex) { // expected } try { Single.between((ReadablePartial) null, end1, zero); fail(); } catch (IllegalArgumentException ex) { // expected } try { Single.between((ReadablePartial) null, (ReadablePartial) null, zero); fail(); } catch (IllegalArgumentException ex) { // expected } try { Single.between(start, new LocalTime(), zero); fail(); } catch (IllegalArgumentException ex) { // expected } try { Single.between(new Partial(DateTimeFieldType.dayOfWeek(), 2), new Partial(DateTimeFieldType.dayOfMonth(), 3), zero); fail(); } catch (IllegalArgumentException ex) { // expected } Partial p = new Partial( new DateTimeFieldType[] {DateTimeFieldType.year(), DateTimeFieldType.hourOfDay()}, new int[] {1, 2}); try { Single.between(p, p, zero); fail(); } catch (IllegalArgumentException ex) { // expected } } public void testFactory_standardPeriodIn_RPeriod() { assertEquals(0, Single.standardPeriodIn((ReadablePeriod) null, DateTimeConstants.MILLIS_PER_DAY)); assertEquals(0, Single.standardPeriodIn(Period.ZERO, DateTimeConstants.MILLIS_PER_DAY)); assertEquals(1, Single.standardPeriodIn(new Period(0, 0, 0, 1, 0, 0, 0, 0), DateTimeConstants.MILLIS_PER_DAY)); assertEquals(123, Single.standardPeriodIn(Period.days(123), DateTimeConstants.MILLIS_PER_DAY)); assertEquals(-987, Single.standardPeriodIn(Period.days(-987), DateTimeConstants.MILLIS_PER_DAY)); assertEquals(1, Single.standardPeriodIn(Period.hours(47), DateTimeConstants.MILLIS_PER_DAY)); assertEquals(2, Single.standardPeriodIn(Period.hours(48), DateTimeConstants.MILLIS_PER_DAY)); assertEquals(2, Single.standardPeriodIn(Period.hours(49), DateTimeConstants.MILLIS_PER_DAY)); assertEquals(14, Single.standardPeriodIn(Period.weeks(2), DateTimeConstants.MILLIS_PER_DAY)); try { Single.standardPeriodIn(Period.months(1), DateTimeConstants.MILLIS_PER_DAY); fail(); } catch (IllegalArgumentException ex) { // expeceted } } //----------------------------------------------------------------------- public void testValueIndexMethods() { Single test = new Single(20); assertEquals(1, test.size()); assertEquals(20, test.getValue(0)); try { test.getValue(1); fail(); } catch (IndexOutOfBoundsException ex) { // expected } } public void testFieldTypeIndexMethods() { Single test = new Single(20); assertEquals(1, test.size()); assertEquals(DurationFieldType.days(), test.getFieldType(0)); try { test.getFieldType(1); fail(); } catch (IndexOutOfBoundsException ex) { // expected } } public void testIsSupported() { Single test = new Single(20); assertEquals(false, test.isSupported(DurationFieldType.years())); assertEquals(false, test.isSupported(DurationFieldType.months())); assertEquals(false, test.isSupported(DurationFieldType.weeks())); assertEquals(true, test.isSupported(DurationFieldType.days())); assertEquals(false, test.isSupported(DurationFieldType.hours())); assertEquals(false, test.isSupported(DurationFieldType.minutes())); assertEquals(false, test.isSupported(DurationFieldType.seconds())); assertEquals(false, test.isSupported(DurationFieldType.millis())); } public void testGet() { Single test = new Single(20); assertEquals(0, test.get(DurationFieldType.years())); assertEquals(0, test.get(DurationFieldType.months())); assertEquals(0, test.get(DurationFieldType.weeks())); assertEquals(20, test.get(DurationFieldType.days())); assertEquals(0, test.get(DurationFieldType.hours())); assertEquals(0, test.get(DurationFieldType.minutes())); assertEquals(0, test.get(DurationFieldType.seconds())); assertEquals(0, test.get(DurationFieldType.millis())); } //----------------------------------------------------------------------- public void testEqualsHashCode() { Single testA = new Single(20); Single testB = new Single(20); assertEquals(true, testA.equals(testB)); assertEquals(true, testB.equals(testA)); assertEquals(true, testA.equals(testA)); assertEquals(true, testB.equals(testB)); assertEquals(true, testA.hashCode() == testB.hashCode()); assertEquals(true, testA.hashCode() == testA.hashCode()); assertEquals(true, testB.hashCode() == testB.hashCode()); Single testC = new Single(30); assertEquals(false, testA.equals(testC)); assertEquals(false, testB.equals(testC)); assertEquals(false, testC.equals(testA)); assertEquals(false, testC.equals(testB)); assertEquals(false, testA.hashCode() == testC.hashCode()); assertEquals(false, testB.hashCode() == testC.hashCode()); assertEquals(true, testA.equals(Days.days(20))); assertEquals(true, testA.equals(new Period(0, 0, 0, 20, 0, 0, 0, 0, PeriodType.days()))); assertEquals(false, testA.equals(Period.days(2))); assertEquals(false, testA.equals("Hello")); assertEquals(false, testA.equals(Hours.hours(2))); assertEquals(false, testA.equals(null)); } public void testCompareTo() { Single test1 = new Single(21); Single test2 = new Single(22); Single test3 = new Single(23); assertEquals(true, test1.compareTo(test1) == 0); assertEquals(true, test1.compareTo(test2) < 0); assertEquals(true, test1.compareTo(test3) < 0); assertEquals(true, test2.compareTo(test1) > 0); assertEquals(true, test2.compareTo(test2) == 0); assertEquals(true, test2.compareTo(test3) < 0); assertEquals(true, test3.compareTo(test1) > 0); assertEquals(true, test3.compareTo(test2) > 0); assertEquals(true, test3.compareTo(test3) == 0); // try { // test1.compareTo("Hello"); // fail(); // } catch (ClassCastException ex) { // // expected // } // try { // test1.compareTo(new Period(0, 0, 0, 21, 0, 0, 0, 0, PeriodType.days())); // fail(); // } catch (ClassCastException ex) { // // expected // } try { test1.compareTo(null); fail(); } catch (NullPointerException ex) { // expected } } //----------------------------------------------------------------------- public void testToPeriod() { Single test = new Single(20); Period expected = Period.days(20); assertEquals(expected, test.toPeriod()); } public void testToMutablePeriod() { Single test = new Single(20); MutablePeriod expected = new MutablePeriod(0, 0, 0, 20, 0, 0, 0, 0); assertEquals(expected, test.toMutablePeriod()); } // public void testToDurationFrom() { // Period test = new Period(123L); // assertEquals(new Duration(123L), test.toDurationFrom(new Instant(0L))); // } // // public void testToDurationTo() { // Period test = new Period(123L); // assertEquals(new Duration(123L), test.toDurationTo(new Instant(123L))); // } // //----------------------------------------------------------------------- public void testGetSetValue() { Single test = new Single(20); assertEquals(20, test.getValue()); test.setValue(10); assertEquals(10, test.getValue()); } //----------------------------------------------------------------------- /** Test class. */ static class Single extends BaseSingleFieldPeriod { public Single(int period) { super(period); } public static int between(ReadableInstant start, ReadableInstant end, DurationFieldType field) { return BaseSingleFieldPeriod.between(start, end, field); } public static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance) { return BaseSingleFieldPeriod.between(start, end, zeroInstance); } public static int standardPeriodIn(ReadablePeriod period, long millisPerUnit) { return BaseSingleFieldPeriod.standardPeriodIn(period, millisPerUnit); } public DurationFieldType getFieldType() { return DurationFieldType.days(); } public PeriodType getPeriodType() { return PeriodType.days(); } public int getValue() { return super.getValue(); } public void setValue(int value) { super.setValue(value); } } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.BuddhistChronology; import org.joda.time.chrono.CopticChronology; import org.joda.time.chrono.EthiopicChronology; import org.joda.time.chrono.GJChronology; import org.joda.time.chrono.GregorianChronology; import org.joda.time.chrono.ISOChronology; import org.joda.time.chrono.IslamicChronology; import org.joda.time.chrono.JulianChronology; import org.joda.time.chrono.LenientChronology; import org.joda.time.chrono.LimitChronology; import org.joda.time.chrono.StrictChronology; import org.joda.time.chrono.ZonedChronology; /** * This class is a Junit unit test for Chronology. * * @author Stephen Colebourne */ public class TestChronology extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) // private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; // 2002-04-05 private long TEST_TIME1 = (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; // 2003-05-06 private long TEST_TIME2 = (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestChronology.class); } public TestChronology(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testTest() { assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString()); assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString()); assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString()); } //----------------------------------------------------------------------- public void testEqualsHashCode_ISO() { Chronology chrono1 = ISOChronology.getInstanceUTC(); Chronology chrono2 = ISOChronology.getInstanceUTC(); Chronology chrono3 = ISOChronology.getInstance(); assertEquals(true, chrono1.equals(chrono2)); assertEquals(false, chrono1.equals(chrono3)); DateTime dt1 = new DateTime(0L, chrono1); DateTime dt2 = new DateTime(0L, chrono2); DateTime dt3 = new DateTime(0L, chrono3); assertEquals(true, dt1.equals(dt2)); assertEquals(false, dt1.equals(dt3)); assertEquals(true, chrono1.hashCode() == chrono2.hashCode()); assertEquals(false, chrono1.hashCode() == chrono3.hashCode()); } //----------------------------------------------------------------------- public void testEqualsHashCode_Lenient() { Chronology chrono1 = LenientChronology.getInstance(ISOChronology.getInstanceUTC()); Chronology chrono2 = LenientChronology.getInstance(ISOChronology.getInstanceUTC()); Chronology chrono3 = LenientChronology.getInstance(ISOChronology.getInstance()); assertEquals(true, chrono1.equals(chrono2)); assertEquals(false, chrono1.equals(chrono3)); DateTime dt1 = new DateTime(0L, chrono1); DateTime dt2 = new DateTime(0L, chrono2); DateTime dt3 = new DateTime(0L, chrono3); assertEquals(true, dt1.equals(dt2)); assertEquals(false, dt1.equals(dt3)); assertEquals(true, chrono1.hashCode() == chrono2.hashCode()); assertEquals(false, chrono1.hashCode() == chrono3.hashCode()); } //----------------------------------------------------------------------- public void testEqualsHashCode_Strict() { Chronology chrono1 = StrictChronology.getInstance(ISOChronology.getInstanceUTC()); Chronology chrono2 = StrictChronology.getInstance(ISOChronology.getInstanceUTC()); Chronology chrono3 = StrictChronology.getInstance(ISOChronology.getInstance()); assertEquals(true, chrono1.equals(chrono2)); assertEquals(false, chrono1.equals(chrono3)); DateTime dt1 = new DateTime(0L, chrono1); DateTime dt2 = new DateTime(0L, chrono2); DateTime dt3 = new DateTime(0L, chrono3); assertEquals(true, dt1.equals(dt2)); assertEquals(false, dt1.equals(dt3)); assertEquals(true, chrono1.hashCode() == chrono2.hashCode()); assertEquals(false, chrono1.hashCode() == chrono3.hashCode()); } //----------------------------------------------------------------------- public void testEqualsHashCode_Limit() { DateTime lower = new DateTime(0L); DateTime higherA = new DateTime(1000000L); DateTime higherB = new DateTime(2000000L); Chronology chrono1 = LimitChronology.getInstance(ISOChronology.getInstanceUTC(), lower, higherA); Chronology chrono2A = LimitChronology.getInstance(ISOChronology.getInstanceUTC(), lower, higherA); Chronology chrono2B = LimitChronology.getInstance(ISOChronology.getInstanceUTC(), lower, higherB); Chronology chrono3 = LimitChronology.getInstance(ISOChronology.getInstance(), lower, higherA); assertEquals(true, chrono1.equals(chrono2A)); assertEquals(false, chrono1.equals(chrono2B)); assertEquals(false, chrono1.equals(chrono3)); DateTime dt1 = new DateTime(0L, chrono1); DateTime dt2A = new DateTime(0L, chrono2A); DateTime dt2B = new DateTime(0L, chrono2B); DateTime dt3 = new DateTime(0L, chrono3); assertEquals(true, dt1.equals(dt2A)); assertEquals(false, dt1.equals(dt2B)); assertEquals(false, dt1.equals(dt3)); assertEquals(true, chrono1.hashCode() == chrono2A.hashCode()); assertEquals(false, chrono1.hashCode() == chrono2B.hashCode()); assertEquals(false, chrono1.hashCode() == chrono3.hashCode()); } //----------------------------------------------------------------------- public void testEqualsHashCode_Zoned() { DateTimeZone zoneA = DateTimeZone.forID("Europe/Paris"); DateTimeZone zoneB = DateTimeZone.forID("Asia/Tokyo"); Chronology chrono1 = ZonedChronology.getInstance(ISOChronology.getInstanceUTC(), zoneA); Chronology chrono2 = ZonedChronology.getInstance(ISOChronology.getInstanceUTC(), zoneA); Chronology chrono3 = ZonedChronology.getInstance(ISOChronology.getInstanceUTC(), zoneB); assertEquals(true, chrono1.equals(chrono2)); assertEquals(false, chrono1.equals(chrono3)); DateTime dt1 = new DateTime(0L, chrono1); DateTime dt2 = new DateTime(0L, chrono2); DateTime dt3 = new DateTime(0L, chrono3); assertEquals(true, dt1.equals(dt2)); assertEquals(false, dt1.equals(dt3)); assertEquals(true, chrono1.hashCode() == chrono2.hashCode()); assertEquals(false, chrono1.hashCode() == chrono3.hashCode()); } //----------------------------------------------------------------------- public void testToString() { DateTimeZone paris = DateTimeZone.forID("Europe/Paris"); ISOChronology isoParis = ISOChronology.getInstance(paris); assertEquals("ISOChronology[Europe/Paris]", isoParis.toString()); assertEquals("GJChronology[Europe/Paris]", GJChronology.getInstance(paris).toString()); assertEquals("GregorianChronology[Europe/Paris]", GregorianChronology.getInstance(paris).toString()); assertEquals("JulianChronology[Europe/Paris]", JulianChronology.getInstance(paris).toString()); assertEquals("BuddhistChronology[Europe/Paris]", BuddhistChronology.getInstance(paris).toString()); assertEquals("CopticChronology[Europe/Paris]", CopticChronology.getInstance(paris).toString()); assertEquals("EthiopicChronology[Europe/Paris]", EthiopicChronology.getInstance(paris).toString()); assertEquals("IslamicChronology[Europe/Paris]", IslamicChronology.getInstance(paris).toString()); assertEquals("LenientChronology[ISOChronology[Europe/Paris]]", LenientChronology.getInstance(isoParis).toString()); assertEquals("StrictChronology[ISOChronology[Europe/Paris]]", StrictChronology.getInstance(isoParis).toString()); assertEquals("LimitChronology[ISOChronology[Europe/Paris], NoLimit, NoLimit]", LimitChronology.getInstance(isoParis, null, null).toString()); assertEquals("ZonedChronology[ISOChronology[UTC], Europe/Paris]", ZonedChronology.getInstance(isoParis, paris).toString()); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.base.AbstractInstant; import org.joda.time.chrono.BuddhistChronology; import org.joda.time.chrono.CopticChronology; import org.joda.time.chrono.GJChronology; import org.joda.time.chrono.GregorianChronology; import org.joda.time.chrono.ISOChronology; import org.joda.time.field.UnsupportedDateTimeField; import org.joda.time.field.UnsupportedDurationField; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; /** * This class is a Junit unit test for DateMidnight. * * @author Stephen Colebourne */ @SuppressWarnings("deprecation") public class TestDateMidnight_Basics extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final DateTimeZone NEWYORK = DateTimeZone.forID("America/New_York"); // the default time zone is set to LONDON in setUp() // we have to hard code LONDON here (instead of ISOChronology.getInstance() etc.) // as TestAll sets up a different time zone for better all-round testing private static final ISOChronology ISO_DEFAULT = ISOChronology.getInstance(LONDON); private static final ISOChronology ISO_PARIS = ISOChronology.getInstance(PARIS); private static final GJChronology GJ_DEFAULT = GJChronology.getInstance(LONDON); private static final GregorianChronology GREGORIAN_DEFAULT = GregorianChronology.getInstance(LONDON); private static final GregorianChronology GREGORIAN_PARIS = GregorianChronology.getInstance(PARIS); private static final BuddhistChronology BUDDHIST_DEFAULT = BuddhistChronology.getInstance(LONDON); private static final CopticChronology COPTIC_DEFAULT = CopticChronology.getInstance(LONDON); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365; // 2002-06-09 private long TEST_TIME_NOW_UTC = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; private long TEST_TIME_NOW_LONDON = TEST_TIME_NOW_UTC - DateTimeConstants.MILLIS_PER_HOUR; // private long TEST_TIME_NOW_PARIS = // TEST_TIME_NOW_UTC - 2*DateTimeConstants.MILLIS_PER_HOUR; // 2002-04-05 private long TEST_TIME1_UTC = (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; private long TEST_TIME1_LONDON = (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY - DateTimeConstants.MILLIS_PER_HOUR; private long TEST_TIME1_PARIS = (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY - 2*DateTimeConstants.MILLIS_PER_HOUR; // 2003-05-06 private long TEST_TIME2_UTC = (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private long TEST_TIME2_LONDON = (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY - DateTimeConstants.MILLIS_PER_HOUR; private long TEST_TIME2_PARIS = (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY - 2*DateTimeConstants.MILLIS_PER_HOUR; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestDateMidnight_Basics.class); } public TestDateMidnight_Basics(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW_UTC); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testTest() { assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW_UTC).toString()); assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1_UTC).toString()); assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2_UTC).toString()); } //----------------------------------------------------------------------- public void testGet_DateTimeField() { DateMidnight test = new DateMidnight(); assertEquals(1, test.get(ISO_DEFAULT.era())); assertEquals(20, test.get(ISO_DEFAULT.centuryOfEra())); assertEquals(2, test.get(ISO_DEFAULT.yearOfCentury())); assertEquals(2002, test.get(ISO_DEFAULT.yearOfEra())); assertEquals(2002, test.get(ISO_DEFAULT.year())); assertEquals(6, test.get(ISO_DEFAULT.monthOfYear())); assertEquals(9, test.get(ISO_DEFAULT.dayOfMonth())); assertEquals(2002, test.get(ISO_DEFAULT.weekyear())); assertEquals(23, test.get(ISO_DEFAULT.weekOfWeekyear())); assertEquals(7, test.get(ISO_DEFAULT.dayOfWeek())); assertEquals(160, test.get(ISO_DEFAULT.dayOfYear())); assertEquals(0, test.get(ISO_DEFAULT.halfdayOfDay())); assertEquals(0, test.get(ISO_DEFAULT.hourOfHalfday())); assertEquals(24, test.get(ISO_DEFAULT.clockhourOfDay())); assertEquals(12, test.get(ISO_DEFAULT.clockhourOfHalfday())); assertEquals(0, test.get(ISO_DEFAULT.hourOfDay())); assertEquals(0, test.get(ISO_DEFAULT.minuteOfHour())); assertEquals(0, test.get(ISO_DEFAULT.minuteOfDay())); assertEquals(0, test.get(ISO_DEFAULT.secondOfMinute())); assertEquals(0, test.get(ISO_DEFAULT.secondOfDay())); assertEquals(0, test.get(ISO_DEFAULT.millisOfSecond())); assertEquals(0, test.get(ISO_DEFAULT.millisOfDay())); try { test.get((DateTimeField) null); fail(); } catch (IllegalArgumentException ex) {} } public void testGet_DateTimeFieldType() { DateMidnight test = new DateMidnight(); assertEquals(1, test.get(DateTimeFieldType.era())); assertEquals(20, test.get(DateTimeFieldType.centuryOfEra())); assertEquals(2, test.get(DateTimeFieldType.yearOfCentury())); assertEquals(2002, test.get(DateTimeFieldType.yearOfEra())); assertEquals(2002, test.get(DateTimeFieldType.year())); assertEquals(6, test.get(DateTimeFieldType.monthOfYear())); assertEquals(9, test.get(DateTimeFieldType.dayOfMonth())); assertEquals(2002, test.get(DateTimeFieldType.weekyear())); assertEquals(23, test.get(DateTimeFieldType.weekOfWeekyear())); assertEquals(7, test.get(DateTimeFieldType.dayOfWeek())); assertEquals(160, test.get(DateTimeFieldType.dayOfYear())); assertEquals(0, test.get(DateTimeFieldType.halfdayOfDay())); assertEquals(0, test.get(DateTimeFieldType.hourOfHalfday())); assertEquals(24, test.get(DateTimeFieldType.clockhourOfDay())); assertEquals(12, test.get(DateTimeFieldType.clockhourOfHalfday())); assertEquals(0, test.get(DateTimeFieldType.hourOfDay())); assertEquals(0, test.get(DateTimeFieldType.minuteOfHour())); assertEquals(0, test.get(DateTimeFieldType.minuteOfDay())); assertEquals(0, test.get(DateTimeFieldType.secondOfMinute())); assertEquals(0, test.get(DateTimeFieldType.secondOfDay())); assertEquals(0, test.get(DateTimeFieldType.millisOfSecond())); assertEquals(0, test.get(DateTimeFieldType.millisOfDay())); try { test.get((DateTimeFieldType) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testGetters() { DateMidnight test = new DateMidnight(); assertEquals(ISO_DEFAULT, test.getChronology()); assertEquals(LONDON, test.getZone()); assertEquals(TEST_TIME_NOW_LONDON, test.getMillis()); assertEquals(1, test.getEra()); assertEquals(20, test.getCenturyOfEra()); assertEquals(2, test.getYearOfCentury()); assertEquals(2002, test.getYearOfEra()); assertEquals(2002, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(2002, test.getWeekyear()); assertEquals(23, test.getWeekOfWeekyear()); assertEquals(7, test.getDayOfWeek()); assertEquals(160, test.getDayOfYear()); assertEquals(0, test.getHourOfDay()); assertEquals(0, test.getMinuteOfHour()); assertEquals(0, test.getMinuteOfDay()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getSecondOfDay()); assertEquals(0, test.getMillisOfSecond()); assertEquals(0, test.getMillisOfDay()); } public void testWithers() { DateMidnight test = new DateMidnight(1970, 6, 9, GJ_DEFAULT); check(test.withYear(2000), 2000, 6, 9); check(test.withMonthOfYear(2), 1970, 2, 9); check(test.withDayOfMonth(2), 1970, 6, 2); check(test.withDayOfYear(6), 1970, 1, 6); check(test.withDayOfWeek(6), 1970, 6, 13); check(test.withWeekOfWeekyear(6), 1970, 2, 3); check(test.withWeekyear(1971), 1971, 6, 15); check(test.withYearOfCentury(60), 1960, 6, 9); check(test.withCenturyOfEra(21), 2070, 6, 9); check(test.withYearOfEra(1066), 1066, 6, 9); check(test.withEra(DateTimeConstants.BC), -1970, 6, 9); try { test.withMonthOfYear(0); fail(); } catch (IllegalArgumentException ex) {} try { test.withMonthOfYear(13); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testEqualsHashCode() { DateMidnight test1 = new DateMidnight(TEST_TIME1_UTC); DateMidnight test2 = new DateMidnight(TEST_TIME1_UTC); assertEquals(true, test1.equals(test2)); assertEquals(true, test2.equals(test1)); assertEquals(true, test1.equals(test1)); assertEquals(true, test2.equals(test2)); assertEquals(true, test1.hashCode() == test2.hashCode()); assertEquals(true, test1.hashCode() == test1.hashCode()); assertEquals(true, test2.hashCode() == test2.hashCode()); DateMidnight test3 = new DateMidnight(TEST_TIME2_UTC); assertEquals(false, test1.equals(test3)); assertEquals(false, test2.equals(test3)); assertEquals(false, test3.equals(test1)); assertEquals(false, test3.equals(test2)); assertEquals(false, test1.hashCode() == test3.hashCode()); assertEquals(false, test2.hashCode() == test3.hashCode()); assertEquals(false, test1.equals("Hello")); assertEquals(true, test1.equals(new MockInstant())); assertEquals(false, test1.equals(new DateMidnight(TEST_TIME1_UTC, GREGORIAN_DEFAULT))); } class MockInstant extends AbstractInstant { public String toString() { return null; } public long getMillis() { return TEST_TIME1_LONDON; } public Chronology getChronology() { return ISO_DEFAULT; } } public void testCompareTo() { DateMidnight test1 = new DateMidnight(TEST_TIME1_UTC); DateMidnight test1a = new DateMidnight(TEST_TIME1_UTC); assertEquals(0, test1.compareTo(test1a)); assertEquals(0, test1a.compareTo(test1)); assertEquals(0, test1.compareTo(test1)); assertEquals(0, test1a.compareTo(test1a)); DateMidnight test2 = new DateMidnight(TEST_TIME2_UTC); assertEquals(-1, test1.compareTo(test2)); assertEquals(+1, test2.compareTo(test1)); DateMidnight test3 = new DateMidnight(TEST_TIME2_UTC, GREGORIAN_PARIS); assertEquals(-1, test1.compareTo(test3)); assertEquals(+1, test3.compareTo(test1)); assertEquals(-1, test3.compareTo(test2)); // midnight paris before london assertEquals(+1, test2.compareTo(new MockInstant())); assertEquals(0, test1.compareTo(new MockInstant())); try { test1.compareTo(null); fail(); } catch (NullPointerException ex) {} // try { // test1.compareTo(new Date()); // fail(); // } catch (ClassCastException ex) {} } public void testIsEqual() { DateMidnight test1 = new DateMidnight(TEST_TIME1_UTC); DateMidnight test1a = new DateMidnight(TEST_TIME1_UTC); assertEquals(true, test1.isEqual(test1a)); assertEquals(true, test1a.isEqual(test1)); assertEquals(true, test1.isEqual(test1)); assertEquals(true, test1a.isEqual(test1a)); DateMidnight test2 = new DateMidnight(TEST_TIME2_UTC); assertEquals(false, test1.isEqual(test2)); assertEquals(false, test2.isEqual(test1)); DateMidnight test3 = new DateMidnight(TEST_TIME2_UTC, GREGORIAN_PARIS); assertEquals(false, test1.isEqual(test3)); assertEquals(false, test3.isEqual(test1)); assertEquals(false, test3.isEqual(test2)); // midnight paris before london assertEquals(false, test2.isEqual(new MockInstant())); assertEquals(true, test1.isEqual(new MockInstant())); assertEquals(false, new DateMidnight(TEST_TIME_NOW_UTC + DateTimeConstants.MILLIS_PER_DAY, DateTimeZone.UTC).isEqual(null)); assertEquals(true, new DateMidnight(TEST_TIME_NOW_UTC, DateTimeZone.UTC).isEqual(null)); assertEquals(false, new DateMidnight(TEST_TIME_NOW_UTC - DateTimeConstants.MILLIS_PER_DAY, DateTimeZone.UTC).isEqual(null)); assertEquals(false, new DateMidnight(2004, 6, 9).isEqual(new DateTime(2004, 6, 8, 23, 59, 59, 999))); assertEquals(true, new DateMidnight(2004, 6, 9).isEqual(new DateTime(2004, 6, 9, 0, 0, 0, 0))); assertEquals(false, new DateMidnight(2004, 6, 9).isEqual(new DateTime(2004, 6, 9, 0, 0, 0, 1))); } public void testIsBefore() { DateMidnight test1 = new DateMidnight(TEST_TIME1_UTC); DateMidnight test1a = new DateMidnight(TEST_TIME1_UTC); assertEquals(false, test1.isBefore(test1a)); assertEquals(false, test1a.isBefore(test1)); assertEquals(false, test1.isBefore(test1)); assertEquals(false, test1a.isBefore(test1a)); DateMidnight test2 = new DateMidnight(TEST_TIME2_UTC); assertEquals(true, test1.isBefore(test2)); assertEquals(false, test2.isBefore(test1)); DateMidnight test3 = new DateMidnight(TEST_TIME2_UTC, GREGORIAN_PARIS); assertEquals(true, test1.isBefore(test3)); assertEquals(false, test3.isBefore(test1)); assertEquals(true, test3.isBefore(test2)); // midnight paris before london assertEquals(false, test2.isBefore(new MockInstant())); assertEquals(false, test1.isBefore(new MockInstant())); assertEquals(false, new DateMidnight(TEST_TIME_NOW_UTC + DateTimeConstants.MILLIS_PER_DAY, DateTimeZone.UTC).isBefore(null)); assertEquals(false, new DateMidnight(TEST_TIME_NOW_UTC, DateTimeZone.UTC).isBefore(null)); assertEquals(true, new DateMidnight(TEST_TIME_NOW_UTC - DateTimeConstants.MILLIS_PER_DAY, DateTimeZone.UTC).isBefore(null)); assertEquals(false, new DateMidnight(2004, 6, 9).isBefore(new DateTime(2004, 6, 8, 23, 59, 59, 999))); assertEquals(false, new DateMidnight(2004, 6, 9).isBefore(new DateTime(2004, 6, 9, 0, 0, 0, 0))); assertEquals(true, new DateMidnight(2004, 6, 9).isBefore(new DateTime(2004, 6, 9, 0, 0, 0, 1))); } public void testIsAfter() { DateMidnight test1 = new DateMidnight(TEST_TIME1_UTC); DateMidnight test1a = new DateMidnight(TEST_TIME1_UTC); assertEquals(false, test1.isAfter(test1a)); assertEquals(false, test1a.isAfter(test1)); assertEquals(false, test1.isAfter(test1)); assertEquals(false, test1a.isAfter(test1a)); DateMidnight test2 = new DateMidnight(TEST_TIME2_UTC); assertEquals(false, test1.isAfter(test2)); assertEquals(true, test2.isAfter(test1)); DateMidnight test3 = new DateMidnight(TEST_TIME2_UTC, GREGORIAN_PARIS); assertEquals(false, test1.isAfter(test3)); assertEquals(true, test3.isAfter(test1)); assertEquals(false, test3.isAfter(test2)); // midnight paris before london assertEquals(true, test2.isAfter(new MockInstant())); assertEquals(false, test1.isAfter(new MockInstant())); assertEquals(true, new DateMidnight(TEST_TIME_NOW_UTC + DateTimeConstants.MILLIS_PER_DAY, DateTimeZone.UTC).isAfter(null)); assertEquals(false, new DateMidnight(TEST_TIME_NOW_UTC, DateTimeZone.UTC).isAfter(null)); assertEquals(false, new DateMidnight(TEST_TIME_NOW_UTC - DateTimeConstants.MILLIS_PER_DAY, DateTimeZone.UTC).isAfter(null)); assertEquals(true, new DateMidnight(2004, 6, 9).isAfter(new DateTime(2004, 6, 8, 23, 59, 59, 999))); assertEquals(false, new DateMidnight(2004, 6, 9).isAfter(new DateTime(2004, 6, 9, 0, 0, 0, 0))); assertEquals(false, new DateMidnight(2004, 6, 9).isAfter(new DateTime(2004, 6, 9, 0, 0, 0, 1))); } //----------------------------------------------------------------------- public void testSerialization() throws Exception { DateMidnight test = new DateMidnight(TEST_TIME_NOW_UTC); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(test); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); DateMidnight result = (DateMidnight) ois.readObject(); ois.close(); assertEquals(test, result); } //----------------------------------------------------------------------- public void testToString() { DateMidnight test = new DateMidnight(TEST_TIME_NOW_UTC); assertEquals("2002-06-09T00:00:00.000+01:00", test.toString()); test = new DateMidnight(TEST_TIME_NOW_UTC, PARIS); assertEquals("2002-06-09T00:00:00.000+02:00", test.toString()); test = new DateMidnight(TEST_TIME_NOW_UTC, NEWYORK); assertEquals("2002-06-08T00:00:00.000-04:00", test.toString()); // the 8th } public void testToString_String() { DateMidnight test = new DateMidnight(TEST_TIME_NOW_UTC); assertEquals("2002 00", test.toString("yyyy HH")); assertEquals("2002-06-09T00:00:00.000+01:00", test.toString((String) null)); } public void testToString_String_String() { DateMidnight test = new DateMidnight(TEST_TIME_NOW_UTC); assertEquals("Sun 9/6", test.toString("EEE d/M", Locale.ENGLISH)); assertEquals("dim. 9/6", test.toString("EEE d/M", Locale.FRENCH)); assertEquals("2002-06-09T00:00:00.000+01:00", test.toString(null, Locale.ENGLISH)); assertEquals("Sun 9/6", test.toString("EEE d/M", null)); assertEquals("2002-06-09T00:00:00.000+01:00", test.toString(null, null)); } public void testToString_DTFormatter() { DateMidnight test = new DateMidnight(TEST_TIME_NOW_UTC); assertEquals("2002 00", test.toString(DateTimeFormat.forPattern("yyyy HH"))); assertEquals("2002-06-09T00:00:00.000+01:00", test.toString((DateTimeFormatter) null)); } //----------------------------------------------------------------------- public void testToInstant() { DateMidnight test = new DateMidnight(TEST_TIME1_UTC); Instant result = test.toInstant(); assertEquals(TEST_TIME1_LONDON, result.getMillis()); } public void testToDateTime() { DateMidnight test = new DateMidnight(TEST_TIME1_UTC, PARIS); DateTime result = test.toDateTime(); assertEquals(test.getMillis(), result.getMillis()); assertEquals(TEST_TIME1_PARIS, result.getMillis()); assertEquals(PARIS, result.getZone()); } public void testToDateTimeISO() { DateMidnight test = new DateMidnight(TEST_TIME1_UTC, PARIS); DateTime result = test.toDateTimeISO(); assertSame(DateTime.class, result.getClass()); assertSame(ISOChronology.class, result.getChronology().getClass()); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISO_PARIS, result.getChronology()); } public void testToDateTime_DateTimeZone() { DateMidnight test = new DateMidnight(TEST_TIME1_UTC); DateTime result = test.toDateTime(LONDON); assertEquals(test.getMillis(), result.getMillis()); assertEquals(TEST_TIME1_LONDON, result.getMillis()); assertEquals(LONDON, result.getZone()); test = new DateMidnight(TEST_TIME1_UTC); result = test.toDateTime(PARIS); assertEquals(test.getMillis(), result.getMillis()); assertEquals(TEST_TIME1_LONDON, result.getMillis()); assertEquals(PARIS, result.getZone()); test = new DateMidnight(TEST_TIME1_UTC, PARIS); result = test.toDateTime((DateTimeZone) null); assertEquals(test.getMillis(), result.getMillis()); assertEquals(TEST_TIME1_PARIS, result.getMillis()); assertEquals(LONDON, result.getZone()); test = new DateMidnight(TEST_TIME1_UTC); result = test.toDateTime((DateTimeZone) null); assertEquals(test.getMillis(), result.getMillis()); assertEquals(TEST_TIME1_LONDON, result.getMillis()); assertEquals(LONDON, result.getZone()); } public void testToDateTime_Chronology() { DateMidnight test = new DateMidnight(TEST_TIME1_UTC); DateTime result = test.toDateTime(ISO_DEFAULT); assertEquals(test.getMillis(), result.getMillis()); assertEquals(TEST_TIME1_LONDON, result.getMillis()); assertEquals(LONDON, result.getZone()); test = new DateMidnight(TEST_TIME1_UTC); result = test.toDateTime(GREGORIAN_PARIS); assertEquals(test.getMillis(), result.getMillis()); assertEquals(TEST_TIME1_LONDON, result.getMillis()); assertEquals(GREGORIAN_PARIS, result.getChronology()); test = new DateMidnight(TEST_TIME1_UTC, GREGORIAN_PARIS); result = test.toDateTime((Chronology) null); assertEquals(test.getMillis(), result.getMillis()); assertEquals(TEST_TIME1_PARIS, result.getMillis()); assertEquals(ISO_DEFAULT, result.getChronology()); test = new DateMidnight(TEST_TIME1_UTC); result = test.toDateTime((Chronology) null); assertEquals(test.getMillis(), result.getMillis()); assertEquals(TEST_TIME1_LONDON, result.getMillis()); assertEquals(ISO_DEFAULT, result.getChronology()); } public void testToMutableDateTime() { DateMidnight test = new DateMidnight(TEST_TIME1_UTC, PARIS); MutableDateTime result = test.toMutableDateTime(); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISO_PARIS, result.getChronology()); } public void testToMutableDateTimeISO() { DateMidnight test = new DateMidnight(TEST_TIME1_UTC, PARIS); MutableDateTime result = test.toMutableDateTimeISO(); assertSame(MutableDateTime.class, result.getClass()); assertSame(ISOChronology.class, result.getChronology().getClass()); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISO_PARIS, result.getChronology()); } public void testToMutableDateTime_DateTimeZone() { DateMidnight test = new DateMidnight(TEST_TIME1_UTC); MutableDateTime result = test.toMutableDateTime(LONDON); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISO_DEFAULT, result.getChronology()); test = new DateMidnight(TEST_TIME1_UTC); result = test.toMutableDateTime(PARIS); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISO_PARIS, result.getChronology()); test = new DateMidnight(TEST_TIME1_UTC, PARIS); result = test.toMutableDateTime((DateTimeZone) null); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISO_DEFAULT, result.getChronology()); test = new DateMidnight(TEST_TIME1_UTC); result = test.toMutableDateTime((DateTimeZone) null); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISO_DEFAULT, result.getChronology()); } public void testToMutableDateTime_Chronology() { DateMidnight test = new DateMidnight(TEST_TIME1_UTC); MutableDateTime result = test.toMutableDateTime(ISO_DEFAULT); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISO_DEFAULT, result.getChronology()); test = new DateMidnight(TEST_TIME1_UTC); result = test.toMutableDateTime(GREGORIAN_PARIS); assertEquals(test.getMillis(), result.getMillis()); assertEquals(GREGORIAN_PARIS, result.getChronology()); test = new DateMidnight(TEST_TIME1_UTC, GREGORIAN_PARIS); result = test.toMutableDateTime((Chronology) null); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISO_DEFAULT, result.getChronology()); test = new DateMidnight(TEST_TIME1_UTC); result = test.toMutableDateTime((Chronology) null); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISO_DEFAULT, result.getChronology()); } public void testToDate() { DateMidnight test = new DateMidnight(TEST_TIME1_UTC); Date result = test.toDate(); assertEquals(test.getMillis(), result.getTime()); } public void testToCalendar_Locale() { DateMidnight test = new DateMidnight(TEST_TIME1_UTC); Calendar result = test.toCalendar(null); assertEquals(test.getMillis(), result.getTime().getTime()); assertEquals(TimeZone.getTimeZone("Europe/London"), result.getTimeZone()); test = new DateMidnight(TEST_TIME1_UTC, PARIS); result = test.toCalendar(null); assertEquals(test.getMillis(), result.getTime().getTime()); assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone()); test = new DateMidnight(TEST_TIME1_UTC, PARIS); result = test.toCalendar(Locale.UK); assertEquals(test.getMillis(), result.getTime().getTime()); assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone()); } public void testToGregorianCalendar() { DateMidnight test = new DateMidnight(TEST_TIME1_UTC); GregorianCalendar result = test.toGregorianCalendar(); assertEquals(test.getMillis(), result.getTime().getTime()); assertEquals(TimeZone.getTimeZone("Europe/London"), result.getTimeZone()); test = new DateMidnight(TEST_TIME1_UTC, PARIS); result = test.toGregorianCalendar(); assertEquals(test.getMillis(), result.getTime().getTime()); assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone()); } //----------------------------------------------------------------------- public void testToYearMonthDay() { DateMidnight base = new DateMidnight(TEST_TIME1_UTC, COPTIC_DEFAULT); YearMonthDay test = base.toYearMonthDay(); assertEquals(new YearMonthDay(TEST_TIME1_UTC, COPTIC_DEFAULT), test); } public void testToLocalDate() { DateMidnight base = new DateMidnight(TEST_TIME1_UTC, COPTIC_DEFAULT); LocalDate test = base.toLocalDate(); assertEquals(new LocalDate(TEST_TIME1_UTC, COPTIC_DEFAULT), test); } public void testToInterval() { DateMidnight base = new DateMidnight(TEST_TIME1_UTC, COPTIC_DEFAULT); Interval test = base.toInterval(); DateMidnight end = base.plus(Period.days(1)); assertEquals(new Interval(base, end), test); } //----------------------------------------------------------------------- public void testWithMillis_long() { DateMidnight test = new DateMidnight(TEST_TIME1_UTC); DateMidnight result = test.withMillis(TEST_TIME2_UTC); assertEquals(TEST_TIME2_LONDON, result.getMillis()); assertEquals(test.getChronology(), result.getChronology()); test = new DateMidnight(TEST_TIME1_UTC, GREGORIAN_PARIS); result = test.withMillis(TEST_TIME2_UTC); assertEquals(TEST_TIME2_PARIS, result.getMillis()); assertEquals(test.getChronology(), result.getChronology()); test = new DateMidnight(TEST_TIME1_UTC); result = test.withMillis(TEST_TIME1_UTC); assertSame(test, result); } public void testWithChronology_Chronology() { DateMidnight test = new DateMidnight(TEST_TIME1_UTC); DateMidnight result = test.withChronology(GREGORIAN_PARIS); assertEquals(TEST_TIME1_LONDON, test.getMillis()); assertEquals(TEST_TIME1_PARIS, result.getMillis()); assertEquals(GREGORIAN_PARIS, result.getChronology()); test = new DateMidnight(TEST_TIME1_UTC, GREGORIAN_PARIS); result = test.withChronology(null); assertEquals(TEST_TIME1_PARIS, test.getMillis()); // midnight Paris is previous day in London assertEquals(TEST_TIME1_LONDON - DateTimeConstants.MILLIS_PER_DAY, result.getMillis()); assertEquals(ISO_DEFAULT, result.getChronology()); test = new DateMidnight(TEST_TIME1_UTC); result = test.withChronology(null); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISO_DEFAULT, result.getChronology()); test = new DateMidnight(TEST_TIME1_UTC); result = test.withChronology(ISO_DEFAULT); assertSame(test, result); } public void testWithZoneRetainFields_DateTimeZone() { DateMidnight test = new DateMidnight(TEST_TIME1_UTC); DateMidnight result = test.withZoneRetainFields(PARIS); assertEquals(TEST_TIME1_LONDON, test.getMillis()); assertEquals(TEST_TIME1_PARIS, result.getMillis()); assertEquals(ISO_PARIS, result.getChronology()); test = new DateMidnight(TEST_TIME1_UTC, GREGORIAN_PARIS); result = test.withZoneRetainFields(null); assertEquals(TEST_TIME1_PARIS, test.getMillis()); assertEquals(TEST_TIME1_LONDON, result.getMillis()); assertEquals(GREGORIAN_DEFAULT, result.getChronology()); test = new DateMidnight(TEST_TIME1_UTC); result = test.withZoneRetainFields(LONDON); assertSame(test, result); test = new DateMidnight(TEST_TIME1_UTC); result = test.withZoneRetainFields(null); assertSame(test, result); test = new DateMidnight(TEST_TIME1_UTC, new MockNullZoneChronology()); result = test.withZoneRetainFields(LONDON); assertSame(test, result); } //----------------------------------------------------------------------- public void testWithFields_RPartial() { DateMidnight test = new DateMidnight(2004, 5, 6); DateMidnight result = test.withFields(new YearMonthDay(2003, 4, 5)); DateMidnight expected = new DateMidnight(2003, 4, 5); assertEquals(expected, result); test = new DateMidnight(TEST_TIME1_UTC); result = test.withFields(null); assertSame(test, result); } //----------------------------------------------------------------------- public void testWithField1() { DateMidnight test = new DateMidnight(2004, 6, 9); DateMidnight result = test.withField(DateTimeFieldType.year(), 2006); assertEquals(new DateMidnight(2004, 6, 9), test); assertEquals(new DateMidnight(2006, 6, 9), result); } public void testWithField2() { DateMidnight test = new DateMidnight(2004, 6, 9); try { test.withField(null, 6); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testWithFieldAdded1() { DateMidnight test = new DateMidnight(2004, 6, 9); DateMidnight result = test.withFieldAdded(DurationFieldType.years(), 6); assertEquals(new DateMidnight(2004, 6, 9), test); assertEquals(new DateMidnight(2010, 6, 9), result); } public void testWithFieldAdded2() { DateMidnight test = new DateMidnight(2004, 6, 9); try { test.withFieldAdded(null, 0); fail(); } catch (IllegalArgumentException ex) {} } public void testWithFieldAdded3() { DateMidnight test = new DateMidnight(2004, 6, 9); try { test.withFieldAdded(null, 6); fail(); } catch (IllegalArgumentException ex) {} } public void testWithFieldAdded4() { DateMidnight test = new DateMidnight(2004, 6, 9); DateMidnight result = test.withFieldAdded(DurationFieldType.years(), 0); assertSame(test, result); } //----------------------------------------------------------------------- public void testWithDurationAdded_long_int() { DateMidnight test = new DateMidnight(TEST_TIME1_UTC, BUDDHIST_DEFAULT); DateMidnight result = test.withDurationAdded(123456789L, 1); DateMidnight expected = new DateMidnight(test.getMillis() + 123456789L, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.withDurationAdded(123456789L, 0); assertSame(test, result); result = test.withDurationAdded(123456789L, 2); expected = new DateMidnight(test.getMillis() + (2L * 123456789L), BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.withDurationAdded(123456789L, -3); expected = new DateMidnight(test.getMillis() - (3L * 123456789L), BUDDHIST_DEFAULT); assertEquals(expected, result); } //----------------------------------------------------------------------- public void testWithDurationAdded_RD_int() { DateMidnight test = new DateMidnight(TEST_TIME1_UTC, BUDDHIST_DEFAULT); DateMidnight result = test.withDurationAdded(new Duration(123456789L), 1); DateMidnight expected = new DateMidnight(test.getMillis() + 123456789L, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.withDurationAdded(null, 1); assertSame(test, result); result = test.withDurationAdded(new Duration(123456789L), 0); assertSame(test, result); result = test.withDurationAdded(new Duration(123456789L), 2); expected = new DateMidnight(test.getMillis() + (2L * 123456789L), BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.withDurationAdded(new Duration(123456789L), -3); expected = new DateMidnight(test.getMillis() - (3L * 123456789L), BUDDHIST_DEFAULT); assertEquals(expected, result); } //----------------------------------------------------------------------- public void testWithDurationAdded_RP_int() { DateMidnight test = new DateMidnight(2002, 5, 3, BUDDHIST_DEFAULT); DateMidnight result = test.withPeriodAdded(new Period(1, 2, 3, 4, 5, 6, 7, 8), 1); DateMidnight expected = new DateMidnight(2003, 7, 28, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.withPeriodAdded(null, 1); assertSame(test, result); result = test.withPeriodAdded(new Period(1, 2, 3, 4, 5, 6, 7, 8), 0); assertSame(test, result); result = test.withPeriodAdded(new Period(1, 2, 0, 4, 5, 6, 7, 8), 3); expected = new DateMidnight(2005, 11, 15, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.withPeriodAdded(new Period(1, 2, 0, 1, 1, 2, 3, 4), -1); expected = new DateMidnight(2001, 3, 1, BUDDHIST_DEFAULT); assertEquals(expected, result); } //----------------------------------------------------------------------- public void testPlus_long() { DateMidnight test = new DateMidnight(TEST_TIME1_UTC, BUDDHIST_DEFAULT); DateMidnight result = test.plus(123456789L); DateMidnight expected = new DateMidnight(test.getMillis() + 123456789L, BUDDHIST_DEFAULT); assertEquals(expected, result); } public void testPlus_RD() { DateMidnight test = new DateMidnight(TEST_TIME1_UTC, BUDDHIST_DEFAULT); DateMidnight result = test.plus(new Duration(123456789L)); DateMidnight expected = new DateMidnight(test.getMillis() + 123456789L, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.plus((ReadableDuration) null); assertSame(test, result); } public void testPlus_RP() { DateMidnight test = new DateMidnight(2002, 5, 3, BUDDHIST_DEFAULT); DateMidnight result = test.plus(new Period(1, 2, 3, 4, 5, 6, 7, 8)); DateMidnight expected = new DateMidnight(2003, 7, 28, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.plus((ReadablePeriod) null); assertSame(test, result); } public void testPlusYears_int() { DateMidnight test = new DateMidnight(2002, 5, 3, BUDDHIST_DEFAULT); DateMidnight result = test.plusYears(1); DateMidnight expected = new DateMidnight(2003, 5, 3, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.plusYears(0); assertSame(test, result); } public void testPlusMonths_int() { DateMidnight test = new DateMidnight(2002, 5, 3, BUDDHIST_DEFAULT); DateMidnight result = test.plusMonths(1); DateMidnight expected = new DateMidnight(2002, 6, 3, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.plusMonths(0); assertSame(test, result); } public void testPlusWeeks_int() { DateMidnight test = new DateMidnight(2002, 5, 3, BUDDHIST_DEFAULT); DateMidnight result = test.plusWeeks(1); DateMidnight expected = new DateMidnight(2002, 5, 10, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.plusWeeks(0); assertSame(test, result); } public void testPlusDays_int() { DateMidnight test = new DateMidnight(2002, 5, 3, BUDDHIST_DEFAULT); DateMidnight result = test.plusDays(1); DateMidnight expected = new DateMidnight(2002, 5, 4, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.plusDays(0); assertSame(test, result); } //----------------------------------------------------------------------- public void testMinus_long() { DateMidnight test = new DateMidnight(TEST_TIME1_UTC, BUDDHIST_DEFAULT); DateMidnight result = test.minus(123456789L); DateMidnight expected = new DateMidnight(test.getMillis() - 123456789L, BUDDHIST_DEFAULT); assertEquals(expected, result); } public void testMinus_RD() { DateMidnight test = new DateMidnight(TEST_TIME1_UTC, BUDDHIST_DEFAULT); DateMidnight result = test.minus(new Duration(123456789L)); DateMidnight expected = new DateMidnight(test.getMillis() - 123456789L, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.minus((ReadableDuration) null); assertSame(test, result); } public void testMinus_RP() { DateMidnight test = new DateMidnight(2002, 5, 3, BUDDHIST_DEFAULT); DateMidnight result = test.minus(new Period(1, 1, 1, 1, 1, 1, 1, 1)); DateMidnight expected = new DateMidnight(2001, 3, 25, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.minus((ReadablePeriod) null); assertSame(test, result); } public void testMinusYears_int() { DateMidnight test = new DateMidnight(2002, 5, 3, BUDDHIST_DEFAULT); DateMidnight result = test.minusYears(1); DateMidnight expected = new DateMidnight(2001, 5, 3, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.minusYears(0); assertSame(test, result); } public void testMinusMonths_int() { DateMidnight test = new DateMidnight(2002, 5, 3, BUDDHIST_DEFAULT); DateMidnight result = test.minusMonths(1); DateMidnight expected = new DateMidnight(2002, 4, 3, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.minusMonths(0); assertSame(test, result); } public void testMinusWeeks_int() { DateMidnight test = new DateMidnight(2002, 5, 3, BUDDHIST_DEFAULT); DateMidnight result = test.minusWeeks(1); DateMidnight expected = new DateMidnight(2002, 4, 26, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.minusWeeks(0); assertSame(test, result); } public void testMinusDays_int() { DateMidnight test = new DateMidnight(2002, 5, 3, BUDDHIST_DEFAULT); DateMidnight result = test.minusDays(1); DateMidnight expected = new DateMidnight(2002, 5, 2, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.minusDays(0); assertSame(test, result); } //----------------------------------------------------------------------- public void testProperty() { DateMidnight test = new DateMidnight(); assertEquals(test.year(), test.property(DateTimeFieldType.year())); assertEquals(test.dayOfWeek(), test.property(DateTimeFieldType.dayOfWeek())); assertEquals(test.weekOfWeekyear(), test.property(DateTimeFieldType.weekOfWeekyear())); assertEquals(test.property(DateTimeFieldType.millisOfSecond()), test.property(DateTimeFieldType.millisOfSecond())); DateTimeFieldType bad = new DateTimeFieldType("bad") { private static final long serialVersionUID = 1L; public DurationFieldType getDurationType() { return DurationFieldType.weeks(); } public DurationFieldType getRangeDurationType() { return null; } public DateTimeField getField(Chronology chronology) { return UnsupportedDateTimeField.getInstance(this, UnsupportedDurationField.getInstance(getDurationType())); } }; try { test.property(bad); fail(); } catch (IllegalArgumentException ex) {} try { test.property(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- private void check(DateMidnight test, int year, int month, int day) { assertEquals(year, test.getYear()); assertEquals(month, test.getMonthOfYear()); assertEquals(day, test.getDayOfMonth()); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.util.Date; import java.util.Locale; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.GregorianChronology; import org.joda.time.chrono.ISOChronology; import org.joda.time.convert.ConverterManager; import org.joda.time.convert.MockZeroNullIntegerConverter; import org.joda.time.format.DateTimeFormat; /** * This class is a Junit unit test for DateMidnight. * * @author Stephen Colebourne */ @SuppressWarnings("deprecation") public class TestDateMidnight_Constructors extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365; // 2002-06-09 private long TEST_TIME_NOW_UTC = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; private long TEST_TIME_NOW_LONDON = TEST_TIME_NOW_UTC - DateTimeConstants.MILLIS_PER_HOUR; private long TEST_TIME_NOW_PARIS = TEST_TIME_NOW_UTC - 2*DateTimeConstants.MILLIS_PER_HOUR; // 2002-04-05 private long TEST_TIME1_UTC = (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; private long TEST_TIME1_LONDON = (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY - DateTimeConstants.MILLIS_PER_HOUR; private long TEST_TIME1_PARIS = (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY - 2*DateTimeConstants.MILLIS_PER_HOUR; // 2003-05-06 private long TEST_TIME2_UTC = (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private long TEST_TIME2_LONDON = (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY - DateTimeConstants.MILLIS_PER_HOUR; private long TEST_TIME2_PARIS = (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY - 2*DateTimeConstants.MILLIS_PER_HOUR; private DateTimeZone zone = null; private Locale locale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestDateMidnight_Constructors.class); } public TestDateMidnight_Constructors(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW_UTC); zone = DateTimeZone.getDefault(); locale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(zone); Locale.setDefault(locale); zone = null; } //----------------------------------------------------------------------- public void testTest() { assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW_UTC).toString()); assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1_UTC).toString()); assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2_UTC).toString()); } //----------------------------------------------------------------------- /** * Test now () */ public void test_now() throws Throwable { DateMidnight test = DateMidnight.now(); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW_LONDON, test.getMillis()); assertEquals(2002, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); } /** * Test now (DateTimeZone) */ public void test_now_DateTimeZone() throws Throwable { DateMidnight test = DateMidnight.now(PARIS); assertEquals(ISOChronology.getInstance(PARIS), test.getChronology()); assertEquals(TEST_TIME_NOW_PARIS, test.getMillis()); } /** * Test now (DateTimeZone=null) */ public void test_now_nullDateTimeZone() throws Throwable { try { DateMidnight.now((DateTimeZone) null); fail(); } catch (NullPointerException ex) {} } /** * Test now (Chronology) */ public void test_now_Chronology() throws Throwable { DateMidnight test = DateMidnight.now(GregorianChronology.getInstance()); assertEquals(GregorianChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW_LONDON, test.getMillis()); } /** * Test now (Chronology=null) */ public void test_now_nullChronology() throws Throwable { try { DateMidnight.now((Chronology) null); fail(); } catch (NullPointerException ex) {} } //----------------------------------------------------------------------- public void testParse_noFormatter() throws Throwable { assertEquals(new DateMidnight(2010, 6, 30, ISOChronology.getInstance(LONDON)), DateMidnight.parse("2010-06-30")); assertEquals(new DateMidnight(2010, 1, 2, ISOChronology.getInstance(LONDON)), DateMidnight.parse("2010-002")); } public void testParse_formatter() throws Throwable { assertEquals(new DateMidnight(2010, 6, 30, ISOChronology.getInstance(LONDON)), DateMidnight.parse("2010--30 06", DateTimeFormat.forPattern("yyyy--dd MM"))); } //----------------------------------------------------------------------- /** * Test constructor () */ public void testConstructor() throws Throwable { DateMidnight test = new DateMidnight(); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW_LONDON, test.getMillis()); assertEquals(2002, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); } /** * Test constructor (DateTimeZone) */ public void testConstructor_DateTimeZone() throws Throwable { DateMidnight test = new DateMidnight(PARIS); assertEquals(ISOChronology.getInstance(PARIS), test.getChronology()); assertEquals(TEST_TIME_NOW_PARIS, test.getMillis()); } /** * Test constructor (DateTimeZone=null) */ public void testConstructor_nullDateTimeZone() throws Throwable { DateMidnight test = new DateMidnight((DateTimeZone) null); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW_LONDON, test.getMillis()); } /** * Test constructor (Chronology) */ public void testConstructor_Chronology() throws Throwable { DateMidnight test = new DateMidnight(GregorianChronology.getInstance()); assertEquals(GregorianChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW_LONDON, test.getMillis()); } /** * Test constructor (Chronology=null) */ public void testConstructor_nullChronology() throws Throwable { DateMidnight test = new DateMidnight((Chronology) null); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW_LONDON, test.getMillis()); } //----------------------------------------------------------------------- /** * Test constructor (long) */ public void testConstructor_long1() throws Throwable { DateMidnight test = new DateMidnight(TEST_TIME1_UTC); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME1_LONDON, test.getMillis()); } /** * Test constructor (long) */ public void testConstructor_long2() throws Throwable { DateMidnight test = new DateMidnight(TEST_TIME2_UTC); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME2_LONDON, test.getMillis()); } /** * Test constructor (long, DateTimeZone) */ public void testConstructor_long1_DateTimeZone() throws Throwable { DateMidnight test = new DateMidnight(TEST_TIME1_UTC, PARIS); assertEquals(ISOChronology.getInstance(PARIS), test.getChronology()); assertEquals(TEST_TIME1_PARIS, test.getMillis()); } /** * Test constructor (long, DateTimeZone) */ public void testConstructor_long2_DateTimeZone() throws Throwable { DateMidnight test = new DateMidnight(TEST_TIME2_UTC, PARIS); assertEquals(ISOChronology.getInstance(PARIS), test.getChronology()); assertEquals(TEST_TIME2_PARIS, test.getMillis()); } /** * Test constructor (long, DateTimeZone=null) */ public void testConstructor_long_nullDateTimeZone() throws Throwable { DateMidnight test = new DateMidnight(TEST_TIME1_UTC, (DateTimeZone) null); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME1_LONDON, test.getMillis()); } /** * Test constructor (long, Chronology) */ public void testConstructor_long1_Chronology() throws Throwable { DateMidnight test = new DateMidnight(TEST_TIME1_UTC, GregorianChronology.getInstance()); assertEquals(GregorianChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME1_LONDON, test.getMillis()); } /** * Test constructor (long, Chronology) */ public void testConstructor_long2_Chronology() throws Throwable { DateMidnight test = new DateMidnight(TEST_TIME2_UTC, GregorianChronology.getInstance()); assertEquals(GregorianChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME2_LONDON, test.getMillis()); } /** * Test constructor (long, Chronology=null) */ public void testConstructor_long_nullChronology() throws Throwable { DateMidnight test = new DateMidnight(TEST_TIME1_UTC, (Chronology) null); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME1_LONDON, test.getMillis()); } //----------------------------------------------------------------------- /** * Test constructor (Object) */ public void testConstructor_Object() throws Throwable { Date date = new Date(TEST_TIME1_UTC); DateMidnight test = new DateMidnight(date); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME1_LONDON, test.getMillis()); } /** * Test constructor (Object) */ public void testConstructor_invalidObject() throws Throwable { try { new DateMidnight(new Object()); fail(); } catch (IllegalArgumentException ex) {} } /** * Test constructor (Object=null) */ public void testConstructor_nullObject() throws Throwable { DateMidnight test = new DateMidnight((Object) null); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW_LONDON, test.getMillis()); } /** * Test constructor (Object=null) */ public void testConstructor_badconverterObject() throws Throwable { try { ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE); DateMidnight test = new DateMidnight(new Integer(0)); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(0L - DateTimeConstants.MILLIS_PER_HOUR, test.getMillis()); } finally { ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE); } } /** * Test constructor (Object, DateTimeZone) */ public void testConstructor_Object_DateTimeZone() throws Throwable { Date date = new Date(TEST_TIME1_UTC); DateMidnight test = new DateMidnight(date, PARIS); assertEquals(ISOChronology.getInstance(PARIS), test.getChronology()); assertEquals(TEST_TIME1_PARIS, test.getMillis()); } /** * Test constructor (Object, DateTimeZone) */ public void testConstructor_invalidObject_DateTimeZone() throws Throwable { try { new DateMidnight(new Object(), PARIS); fail(); } catch (IllegalArgumentException ex) {} } /** * Test constructor (Object=null, DateTimeZone) */ public void testConstructor_nullObject_DateTimeZone() throws Throwable { DateMidnight test = new DateMidnight((Object) null, PARIS); assertEquals(ISOChronology.getInstance(PARIS), test.getChronology()); assertEquals(TEST_TIME_NOW_PARIS, test.getMillis()); } /** * Test constructor (Object, DateTimeZone=null) */ public void testConstructor_Object_nullDateTimeZone() throws Throwable { Date date = new Date(TEST_TIME1_UTC); DateMidnight test = new DateMidnight(date, (DateTimeZone) null); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME1_LONDON, test.getMillis()); } /** * Test constructor (Object=null, DateTimeZone=null) */ public void testConstructor_nullObject_nullDateTimeZone() throws Throwable { DateMidnight test = new DateMidnight((Object) null, (DateTimeZone) null); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW_LONDON, test.getMillis()); } /** * Test constructor (Object, DateTimeZone) */ public void testConstructor_badconverterObject_DateTimeZone() throws Throwable { try { ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE); DateMidnight test = new DateMidnight(new Integer(0), GregorianChronology.getInstance()); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(0L - DateTimeConstants.MILLIS_PER_HOUR, test.getMillis()); } finally { ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE); } } /** * Test constructor (Object, Chronology) */ public void testConstructor_Object_Chronology() throws Throwable { Date date = new Date(TEST_TIME1_UTC); DateMidnight test = new DateMidnight(date, GregorianChronology.getInstance()); assertEquals(GregorianChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME1_LONDON, test.getMillis()); } /** * Test constructor (Object, Chronology) */ public void testConstructor_invalidObject_Chronology() throws Throwable { try { new DateMidnight(new Object(), GregorianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} } /** * Test constructor (Object=null, Chronology) */ public void testConstructor_nullObject_Chronology() throws Throwable { DateMidnight test = new DateMidnight((Object) null, GregorianChronology.getInstance()); assertEquals(GregorianChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW_LONDON, test.getMillis()); } /** * Test constructor (Object, Chronology=null) */ public void testConstructor_Object_nullChronology() throws Throwable { Date date = new Date(TEST_TIME1_UTC); DateMidnight test = new DateMidnight(date, (Chronology) null); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME1_LONDON, test.getMillis()); } /** * Test constructor (Object=null, Chronology=null) */ public void testConstructor_nullObject_nullChronology() throws Throwable { DateMidnight test = new DateMidnight((Object) null, (Chronology) null); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW_LONDON, test.getMillis()); } /** * Test constructor (Object, Chronology) */ public void testConstructor_badconverterObject_Chronology() throws Throwable { try { ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE); DateMidnight test = new DateMidnight(new Integer(0), GregorianChronology.getInstance()); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(0L - DateTimeConstants.MILLIS_PER_HOUR, test.getMillis()); } finally { ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE); } } //----------------------------------------------------------------------- /** * Test constructor (int, int, int) */ public void testConstructor_int_int_int() throws Throwable { DateMidnight test = new DateMidnight(2002, 6, 9); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(LONDON, test.getZone()); assertEquals(TEST_TIME_NOW_LONDON, test.getMillis()); assertEquals(2002, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); try { new DateMidnight(Integer.MIN_VALUE, 6, 9); fail(); } catch (IllegalArgumentException ex) {} try { new DateMidnight(Integer.MAX_VALUE, 6, 9); fail(); } catch (IllegalArgumentException ex) {} try { new DateMidnight(2002, 0, 9); fail(); } catch (IllegalArgumentException ex) {} try { new DateMidnight(2002, 13, 9); fail(); } catch (IllegalArgumentException ex) {} try { new DateMidnight(2002, 6, 0); fail(); } catch (IllegalArgumentException ex) {} try { new DateMidnight(2002, 6, 31); fail(); } catch (IllegalArgumentException ex) {} new DateMidnight(2002, 7, 31); try { new DateMidnight(2002, 7, 32); fail(); } catch (IllegalArgumentException ex) {} } /** * Test constructor (int, int, int, DateTimeZone) */ public void testConstructor_int_int_int_DateTimeZone() throws Throwable { DateMidnight test = new DateMidnight(2002, 6, 9, PARIS); assertEquals(ISOChronology.getInstance(PARIS), test.getChronology()); assertEquals(TEST_TIME_NOW_PARIS, test.getMillis()); assertEquals(2002, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); try { new DateMidnight(Integer.MIN_VALUE, 6, 9, PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new DateMidnight(Integer.MAX_VALUE, 6, 9, PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new DateMidnight(2002, 0, 9, PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new DateMidnight(2002, 13, 9, PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new DateMidnight(2002, 6, 0, PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new DateMidnight(2002, 6, 31, PARIS); fail(); } catch (IllegalArgumentException ex) {} new DateMidnight(2002, 7, 31, PARIS); try { new DateMidnight(2002, 7, 32, PARIS); fail(); } catch (IllegalArgumentException ex) {} } /** * Test constructor (int, int, int, DateTimeZone=null) */ public void testConstructor_int_int_int_nullDateTimeZone() throws Throwable { DateMidnight test = new DateMidnight(2002, 6, 9, (DateTimeZone) null); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW_LONDON, test.getMillis()); assertEquals(2002, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); } /** * Test constructor (int, int, int, Chronology) */ public void testConstructor_int_int_int_Chronology() throws Throwable { DateMidnight test = new DateMidnight(2002, 6, 9, GregorianChronology.getInstance()); assertEquals(GregorianChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW_LONDON, test.getMillis()); assertEquals(2002, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); try { new DateMidnight(Integer.MIN_VALUE, 6, 9, GregorianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} try { new DateMidnight(Integer.MAX_VALUE, 6, 9, GregorianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} try { new DateMidnight(2002, 0, 9, GregorianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} try { new DateMidnight(2002, 13, 9, GregorianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} try { new DateMidnight(2002, 6, 0, GregorianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} try { new DateMidnight(2002, 6, 31, GregorianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} new DateMidnight(2002, 7, 31, GregorianChronology.getInstance()); try { new DateMidnight(2002, 7, 32, GregorianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} } /** * Test constructor (int, int, int, Chronology=null) */ public void testConstructor_int_int_int_nullChronology() throws Throwable { DateMidnight test = new DateMidnight(2002, 6, 9, (Chronology) null); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW_LONDON, test.getMillis()); assertEquals(2002, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.util.Locale; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.CopticChronology; import org.joda.time.chrono.LenientChronology; import org.joda.time.chrono.StrictChronology; /** * This class is a Junit unit test for DateTime. * * @author Stephen Colebourne * @author Mike Schrag */ @SuppressWarnings("deprecation") public class TestDateMidnight_Properties extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS); //private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; // 2002-04-05 Fri private long TEST_TIME1 = (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; // 2003-05-06 Tue private long TEST_TIME2 = (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone zone = null; private Locale locale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestDateMidnight_Properties.class); } public TestDateMidnight_Properties(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); zone = DateTimeZone.getDefault(); locale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(zone); Locale.setDefault(locale); zone = null; } //----------------------------------------------------------------------- public void testTest() { assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString()); assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString()); assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString()); } //----------------------------------------------------------------------- public void testPropertyGetEra() { DateMidnight test = new DateMidnight(2004, 6, 9); assertSame(test.getChronology().era(), test.era().getField()); assertEquals("era", test.era().getName()); assertEquals("Property[era]", test.era().toString()); assertSame(test, test.era().getDateMidnight()); assertEquals(1, test.era().get()); assertEquals("AD", test.era().getAsText()); assertEquals("ap. J.-C.", test.era().getAsText(Locale.FRENCH)); assertEquals("AD", test.era().getAsShortText()); assertEquals("ap. J.-C.", test.era().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().eras(), test.era().getDurationField()); assertEquals(null, test.era().getRangeDurationField()); assertEquals(2, test.era().getMaximumTextLength(null)); assertEquals(9, test.era().getMaximumTextLength(Locale.FRENCH)); assertEquals(2, test.era().getMaximumShortTextLength(null)); assertEquals(9, test.era().getMaximumShortTextLength(Locale.FRENCH)); } //----------------------------------------------------------------------- public void testPropertyGetYearOfEra() { DateMidnight test = new DateMidnight(2004, 6, 9); assertSame(test.getChronology().yearOfEra(), test.yearOfEra().getField()); assertEquals("yearOfEra", test.yearOfEra().getName()); assertEquals("Property[yearOfEra]", test.yearOfEra().toString()); assertSame(test, test.yearOfEra().getDateMidnight()); assertEquals(2004, test.yearOfEra().get()); assertEquals("2004", test.yearOfEra().getAsText()); assertEquals("2004", test.yearOfEra().getAsText(Locale.FRENCH)); assertEquals("2004", test.yearOfEra().getAsShortText()); assertEquals("2004", test.yearOfEra().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().years(), test.yearOfEra().getDurationField()); assertEquals(test.getChronology().eras(), test.yearOfEra().getRangeDurationField()); assertEquals(9, test.yearOfEra().getMaximumTextLength(null)); assertEquals(9, test.yearOfEra().getMaximumShortTextLength(null)); } //----------------------------------------------------------------------- public void testPropertyGetCenturyOfEra() { DateMidnight test = new DateMidnight(2004, 6, 9); assertSame(test.getChronology().centuryOfEra(), test.centuryOfEra().getField()); assertEquals("centuryOfEra", test.centuryOfEra().getName()); assertEquals("Property[centuryOfEra]", test.centuryOfEra().toString()); assertSame(test, test.centuryOfEra().getDateMidnight()); assertEquals(20, test.centuryOfEra().get()); assertEquals("20", test.centuryOfEra().getAsText()); assertEquals("20", test.centuryOfEra().getAsText(Locale.FRENCH)); assertEquals("20", test.centuryOfEra().getAsShortText()); assertEquals("20", test.centuryOfEra().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().centuries(), test.centuryOfEra().getDurationField()); assertEquals(test.getChronology().eras(), test.centuryOfEra().getRangeDurationField()); assertEquals(7, test.centuryOfEra().getMaximumTextLength(null)); assertEquals(7, test.centuryOfEra().getMaximumShortTextLength(null)); } //----------------------------------------------------------------------- public void testPropertyGetYearOfCentury() { DateMidnight test = new DateMidnight(2004, 6, 9); assertSame(test.getChronology().yearOfCentury(), test.yearOfCentury().getField()); assertEquals("yearOfCentury", test.yearOfCentury().getName()); assertEquals("Property[yearOfCentury]", test.yearOfCentury().toString()); assertSame(test, test.yearOfCentury().getDateMidnight()); assertEquals(4, test.yearOfCentury().get()); assertEquals("4", test.yearOfCentury().getAsText()); assertEquals("4", test.yearOfCentury().getAsText(Locale.FRENCH)); assertEquals("4", test.yearOfCentury().getAsShortText()); assertEquals("4", test.yearOfCentury().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().years(), test.yearOfCentury().getDurationField()); assertEquals(test.getChronology().centuries(), test.yearOfCentury().getRangeDurationField()); assertEquals(2, test.yearOfCentury().getMaximumTextLength(null)); assertEquals(2, test.yearOfCentury().getMaximumShortTextLength(null)); } //----------------------------------------------------------------------- public void testPropertyGetWeekyear() { DateMidnight test = new DateMidnight(2004, 6, 9); assertSame(test.getChronology().weekyear(), test.weekyear().getField()); assertEquals("weekyear", test.weekyear().getName()); assertEquals("Property[weekyear]", test.weekyear().toString()); assertSame(test, test.weekyear().getDateMidnight()); assertEquals(2004, test.weekyear().get()); assertEquals("2004", test.weekyear().getAsText()); assertEquals("2004", test.weekyear().getAsText(Locale.FRENCH)); assertEquals("2004", test.weekyear().getAsShortText()); assertEquals("2004", test.weekyear().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().weekyears(), test.weekyear().getDurationField()); assertEquals(null, test.weekyear().getRangeDurationField()); assertEquals(9, test.weekyear().getMaximumTextLength(null)); assertEquals(9, test.weekyear().getMaximumShortTextLength(null)); } //----------------------------------------------------------------------- public void testPropertyGetYear() { DateMidnight test = new DateMidnight(2004, 6, 9); assertSame(test.getChronology().year(), test.year().getField()); assertEquals("year", test.year().getName()); assertEquals("Property[year]", test.year().toString()); assertSame(test, test.year().getDateMidnight()); assertEquals(2004, test.year().get()); assertEquals("2004", test.year().getAsText()); assertEquals("2004", test.year().getAsText(Locale.FRENCH)); assertEquals("2004", test.year().getAsShortText()); assertEquals("2004", test.year().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().years(), test.year().getDurationField()); assertEquals(null, test.year().getRangeDurationField()); assertEquals(9, test.year().getMaximumTextLength(null)); assertEquals(9, test.year().getMaximumShortTextLength(null)); assertEquals(-292275054, test.year().getMinimumValue()); assertEquals(-292275054, test.year().getMinimumValueOverall()); assertEquals(292278993, test.year().getMaximumValue()); assertEquals(292278993, test.year().getMaximumValueOverall()); } //----------------------------------------------------------------------- public void testPropertyGetMonthOfYear() { DateMidnight test = new DateMidnight(2004, 6, 9); assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField()); assertEquals("monthOfYear", test.monthOfYear().getName()); assertEquals("Property[monthOfYear]", test.monthOfYear().toString()); assertSame(test, test.monthOfYear().getDateMidnight()); assertEquals(6, test.monthOfYear().get()); assertEquals("6", test.monthOfYear().getAsString()); assertEquals("June", test.monthOfYear().getAsText()); assertEquals("juin", test.monthOfYear().getAsText(Locale.FRENCH)); assertEquals("Jun", test.monthOfYear().getAsShortText()); assertEquals("juin", test.monthOfYear().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField()); assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField()); assertEquals(9, test.monthOfYear().getMaximumTextLength(null)); assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null)); test = new DateMidnight(2004, 7, 9); assertEquals("juillet", test.monthOfYear().getAsText(Locale.FRENCH)); assertEquals("juil.", test.monthOfYear().getAsShortText(Locale.FRENCH)); assertEquals(1, test.monthOfYear().getMinimumValue()); assertEquals(1, test.monthOfYear().getMinimumValueOverall()); assertEquals(12, test.monthOfYear().getMaximumValue()); assertEquals(12, test.monthOfYear().getMaximumValueOverall()); assertEquals(1, test.monthOfYear().getMinimumValue()); assertEquals(1, test.monthOfYear().getMinimumValueOverall()); assertEquals(12, test.monthOfYear().getMaximumValue()); assertEquals(12, test.monthOfYear().getMaximumValueOverall()); } public void testPropertySetMonthOfYear() { DateMidnight test = new DateMidnight(2004, 6, 9); DateMidnight copy = test.monthOfYear().setCopy(8); assertEquals(2004, copy.getYear()); assertEquals(8, copy.getMonthOfYear()); assertEquals(9, copy.getDayOfMonth()); } public void testPropertySetTextMonthOfYear() { DateMidnight test = new DateMidnight(2004, 6, 9); DateMidnight copy = test.monthOfYear().setCopy("8"); assertEquals(2004, copy.getYear()); assertEquals(8, copy.getMonthOfYear()); assertEquals(9, copy.getDayOfMonth()); } public void testPropertySetTextLocaleMonthOfYear() { DateMidnight test = new DateMidnight(2004, 6, 9); DateMidnight copy = test.monthOfYear().setCopy("mars", Locale.FRENCH); assertEquals(2004, copy.getYear()); assertEquals(3, copy.getMonthOfYear()); assertEquals(9, copy.getDayOfMonth()); } public void testPropertyAddMonthOfYear() { DateMidnight test = new DateMidnight(2004, 6, 9); DateMidnight copy = test.monthOfYear().addToCopy(8); assertEquals(2005, copy.getYear()); assertEquals(2, copy.getMonthOfYear()); assertEquals(9, copy.getDayOfMonth()); } public void testPropertyAddLongMonthOfYear() { DateMidnight test = new DateMidnight(2004, 6, 9); DateMidnight copy = test.monthOfYear().addToCopy(8L); assertEquals(2005, copy.getYear()); assertEquals(2, copy.getMonthOfYear()); assertEquals(9, copy.getDayOfMonth()); } public void testPropertyAddWrapFieldMonthOfYear() { DateMidnight test = new DateMidnight(2004, 6, 9); DateMidnight copy = test.monthOfYear().addWrapFieldToCopy(8); assertEquals(2004, copy.getYear()); assertEquals(2, copy.getMonthOfYear()); assertEquals(9, copy.getDayOfMonth()); } public void testPropertyGetDifferenceMonthOfYear() { DateMidnight test1 = new DateMidnight(2004, 6, 9); DateMidnight test2 = new DateMidnight(2004, 8, 9); assertEquals(-2, test1.monthOfYear().getDifference(test2)); assertEquals(2, test2.monthOfYear().getDifference(test1)); assertEquals(-2L, test1.monthOfYear().getDifferenceAsLong(test2)); assertEquals(2L, test2.monthOfYear().getDifferenceAsLong(test1)); } public void testPropertyRoundFloorMonthOfYear() { DateMidnight test = new DateMidnight(2004, 6, 16); DateMidnight copy = test.monthOfYear().roundFloorCopy(); assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString()); } public void testPropertyRoundCeilingMonthOfYear() { DateMidnight test = new DateMidnight(2004, 6, 16); DateMidnight copy = test.monthOfYear().roundCeilingCopy(); assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString()); } public void testPropertyRoundHalfFloorMonthOfYear() { DateMidnight test = new DateMidnight(2004, 6, 16); DateMidnight copy = test.monthOfYear().roundHalfFloorCopy(); assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString()); test = new DateMidnight(2004, 6, 17); copy = test.monthOfYear().roundHalfFloorCopy(); assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString()); test = new DateMidnight(2004, 6, 15); copy = test.monthOfYear().roundHalfFloorCopy(); assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString()); } public void testPropertyRoundHalfCeilingMonthOfYear() { DateMidnight test = new DateMidnight(2004, 6, 16); DateMidnight copy = test.monthOfYear().roundHalfCeilingCopy(); assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString()); test = new DateMidnight(2004, 6, 17); copy = test.monthOfYear().roundHalfCeilingCopy(); assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString()); test = new DateMidnight(2004, 6, 15); copy = test.monthOfYear().roundHalfCeilingCopy(); assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString()); } public void testPropertyRoundHalfEvenMonthOfYear() { DateMidnight test = new DateMidnight(2004, 6, 16); DateMidnight copy = test.monthOfYear().roundHalfEvenCopy(); assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString()); test = new DateMidnight(2004, 9, 16); copy = test.monthOfYear().roundHalfEvenCopy(); assertEquals("2004-10-01T00:00:00.000+01:00", copy.toString()); test = new DateMidnight(2004, 6, 17); copy = test.monthOfYear().roundHalfEvenCopy(); assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString()); test = new DateMidnight(2004, 6, 15); copy = test.monthOfYear().roundHalfEvenCopy(); assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString()); } public void testPropertyRemainderMonthOfYear() { DateMidnight test = new DateMidnight(2004, 6, 9); assertEquals((9L - 1L) * DateTimeConstants.MILLIS_PER_DAY, test.monthOfYear().remainder()); } //----------------------------------------------------------------------- public void testPropertyGetDayOfMonth() { DateMidnight test = new DateMidnight(2004, 6, 9); assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField()); assertEquals("dayOfMonth", test.dayOfMonth().getName()); assertEquals("Property[dayOfMonth]", test.dayOfMonth().toString()); assertSame(test, test.dayOfMonth().getDateMidnight()); assertEquals(9, test.dayOfMonth().get()); assertEquals("9", test.dayOfMonth().getAsText()); assertEquals("9", test.dayOfMonth().getAsText(Locale.FRENCH)); assertEquals("9", test.dayOfMonth().getAsShortText()); assertEquals("9", test.dayOfMonth().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField()); assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField()); assertEquals(2, test.dayOfMonth().getMaximumTextLength(null)); assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null)); assertEquals(1, test.dayOfMonth().getMinimumValue()); assertEquals(1, test.dayOfMonth().getMinimumValueOverall()); assertEquals(30, test.dayOfMonth().getMaximumValue()); assertEquals(31, test.dayOfMonth().getMaximumValueOverall()); assertEquals(false, test.dayOfMonth().isLeap()); assertEquals(0, test.dayOfMonth().getLeapAmount()); assertEquals(null, test.dayOfMonth().getLeapDurationField()); } public void testPropertyWithMaximumValueDayOfMonth() { DateMidnight test = new DateMidnight(2004, 6, 9); DateMidnight copy = test.dayOfMonth().withMaximumValue(); assertEquals("2004-06-09T00:00:00.000+01:00", test.toString()); assertEquals("2004-06-30T00:00:00.000+01:00", copy.toString()); } public void testPropertyWithMinimumValueDayOfMonth() { DateMidnight test = new DateMidnight(2004, 6, 9); DateMidnight copy = test.dayOfMonth().withMinimumValue(); assertEquals("2004-06-09T00:00:00.000+01:00", test.toString()); assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString()); } //----------------------------------------------------------------------- public void testPropertyGetDayOfYear() { // 31+29+31+30+31+9 = 161 DateMidnight test = new DateMidnight(2004, 6, 9); assertSame(test.getChronology().dayOfYear(), test.dayOfYear().getField()); assertEquals("dayOfYear", test.dayOfYear().getName()); assertEquals("Property[dayOfYear]", test.dayOfYear().toString()); assertSame(test, test.dayOfYear().getDateMidnight()); assertEquals(161, test.dayOfYear().get()); assertEquals("161", test.dayOfYear().getAsText()); assertEquals("161", test.dayOfYear().getAsText(Locale.FRENCH)); assertEquals("161", test.dayOfYear().getAsShortText()); assertEquals("161", test.dayOfYear().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().days(), test.dayOfYear().getDurationField()); assertEquals(test.getChronology().years(), test.dayOfYear().getRangeDurationField()); assertEquals(3, test.dayOfYear().getMaximumTextLength(null)); assertEquals(3, test.dayOfYear().getMaximumShortTextLength(null)); assertEquals(false, test.dayOfYear().isLeap()); assertEquals(0, test.dayOfYear().getLeapAmount()); assertEquals(null, test.dayOfYear().getLeapDurationField()); } //----------------------------------------------------------------------- public void testPropertyGetWeekOfWeekyear() { DateMidnight test = new DateMidnight(2004, 6, 9); assertSame(test.getChronology().weekOfWeekyear(), test.weekOfWeekyear().getField()); assertEquals("weekOfWeekyear", test.weekOfWeekyear().getName()); assertEquals("Property[weekOfWeekyear]", test.weekOfWeekyear().toString()); assertSame(test, test.weekOfWeekyear().getDateMidnight()); assertEquals(24, test.weekOfWeekyear().get()); assertEquals("24", test.weekOfWeekyear().getAsText()); assertEquals("24", test.weekOfWeekyear().getAsText(Locale.FRENCH)); assertEquals("24", test.weekOfWeekyear().getAsShortText()); assertEquals("24", test.weekOfWeekyear().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().weeks(), test.weekOfWeekyear().getDurationField()); assertEquals(test.getChronology().weekyears(), test.weekOfWeekyear().getRangeDurationField()); assertEquals(2, test.weekOfWeekyear().getMaximumTextLength(null)); assertEquals(2, test.weekOfWeekyear().getMaximumShortTextLength(null)); assertEquals(false, test.weekOfWeekyear().isLeap()); assertEquals(0, test.weekOfWeekyear().getLeapAmount()); assertEquals(null, test.weekOfWeekyear().getLeapDurationField()); } //----------------------------------------------------------------------- public void testPropertyGetDayOfWeek() { DateMidnight test = new DateMidnight(2004, 6, 9); assertSame(test.getChronology().dayOfWeek(), test.dayOfWeek().getField()); assertEquals("dayOfWeek", test.dayOfWeek().getName()); assertEquals("Property[dayOfWeek]", test.dayOfWeek().toString()); assertSame(test, test.dayOfWeek().getDateMidnight()); assertEquals(3, test.dayOfWeek().get()); assertEquals("3", test.dayOfWeek().getAsString()); assertEquals("Wednesday", test.dayOfWeek().getAsText()); assertEquals("mercredi", test.dayOfWeek().getAsText(Locale.FRENCH)); assertEquals("Wed", test.dayOfWeek().getAsShortText()); assertEquals("mer.", test.dayOfWeek().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().days(), test.dayOfWeek().getDurationField()); assertEquals(test.getChronology().weeks(), test.dayOfWeek().getRangeDurationField()); assertEquals(9, test.dayOfWeek().getMaximumTextLength(null)); assertEquals(8, test.dayOfWeek().getMaximumTextLength(Locale.FRENCH)); assertEquals(3, test.dayOfWeek().getMaximumShortTextLength(null)); assertEquals(4, test.dayOfWeek().getMaximumShortTextLength(Locale.FRENCH)); assertEquals(1, test.dayOfWeek().getMinimumValue()); assertEquals(1, test.dayOfWeek().getMinimumValueOverall()); assertEquals(7, test.dayOfWeek().getMaximumValue()); assertEquals(7, test.dayOfWeek().getMaximumValueOverall()); assertEquals(false, test.dayOfWeek().isLeap()); assertEquals(0, test.dayOfWeek().getLeapAmount()); assertEquals(null, test.dayOfWeek().getLeapDurationField()); } //----------------------------------------------------------------------- public void testPropertyToIntervalYearOfEra() { DateMidnight test = new DateMidnight(2004, 6, 9); Interval testInterval = test.yearOfEra().toInterval(); assertEquals(new DateMidnight(2004, 1, 1), testInterval.getStart()); assertEquals(new DateMidnight(2005, 1, 1), testInterval.getEnd()); } public void testPropertyToIntervalYearOfCentury() { DateMidnight test = new DateMidnight(2004, 6, 9); Interval testInterval = test.yearOfCentury().toInterval(); assertEquals(new DateMidnight(2004, 1, 1), testInterval.getStart()); assertEquals(new DateMidnight(2005, 1, 1), testInterval.getEnd()); } public void testPropertyToIntervalYear() { DateMidnight test = new DateMidnight(2004, 6, 9); Interval testInterval = test.year().toInterval(); assertEquals(new DateMidnight(2004, 1, 1), testInterval.getStart()); assertEquals(new DateMidnight(2005, 1, 1), testInterval.getEnd()); } public void testPropertyToIntervalMonthOfYear() { DateMidnight test = new DateMidnight(2004, 6, 9); Interval testInterval = test.monthOfYear().toInterval(); assertEquals(new DateMidnight(2004, 6, 1), testInterval.getStart()); assertEquals(new DateMidnight(2004, 7, 1), testInterval.getEnd()); } public void testPropertyToIntervalDayOfMonth() { DateMidnight test = new DateMidnight(2004, 6, 9); Interval testInterval = test.dayOfMonth().toInterval(); assertEquals(new DateMidnight(2004, 6, 9), testInterval.getStart()); assertEquals(new DateMidnight(2004, 6, 10), testInterval.getEnd()); DateMidnight febTest = new DateMidnight(2004, 2, 29); Interval febTestInterval = febTest.dayOfMonth().toInterval(); assertEquals(new DateMidnight(2004, 2, 29), febTestInterval.getStart()); assertEquals(new DateMidnight(2004, 3, 1), febTestInterval.getEnd()); } public void testPropertyEqualsHashCodeLenient() { DateMidnight test1 = new DateMidnight(1970, 6, 9, LenientChronology.getInstance(COPTIC_PARIS)); DateMidnight test2 = new DateMidnight(1970, 6, 9, LenientChronology.getInstance(COPTIC_PARIS)); assertEquals(true, test1.dayOfMonth().equals(test2.dayOfMonth())); assertEquals(true, test2.dayOfMonth().equals(test1.dayOfMonth())); assertEquals(true, test1.dayOfMonth().equals(test1.dayOfMonth())); assertEquals(true, test2.dayOfMonth().equals(test2.dayOfMonth())); assertEquals(true, test1.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode()); assertEquals(true, test1.dayOfMonth().hashCode() == test1.dayOfMonth().hashCode()); assertEquals(true, test2.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode()); } public void testPropertyEqualsHashCodeStrict() { DateMidnight test1 = new DateMidnight(1970, 6, 9, StrictChronology.getInstance(COPTIC_PARIS)); DateMidnight test2 = new DateMidnight(1970, 6, 9, StrictChronology.getInstance(COPTIC_PARIS)); assertEquals(true, test1.dayOfMonth().equals(test2.dayOfMonth())); assertEquals(true, test2.dayOfMonth().equals(test1.dayOfMonth())); assertEquals(true, test1.dayOfMonth().equals(test1.dayOfMonth())); assertEquals(true, test2.dayOfMonth().equals(test2.dayOfMonth())); assertEquals(true, test1.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode()); assertEquals(true, test1.dayOfMonth().hashCode() == test1.dayOfMonth().hashCode()); assertEquals(true, test2.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode()); } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Modifier; import java.util.ArrayList; import java.util.Calendar; import java.util.Collections; import java.util.Comparator; import java.util.Date; import java.util.List; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.ISOChronology; /** * This class is a Junit unit test for the * org.joda.time.DateTimeComparator class. * * @author Guy Allard */ public class TestDateTimeComparator extends TestCase { private static final Chronology ISO = ISOChronology.getInstance(); public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestDateTimeComparator.class); } public TestDateTimeComparator(String name) { super(name); } /** * A reference to a DateTime object. */ DateTime aDateTime = null; /** * A reference to a DateTime object. */ DateTime bDateTime = null; /** * A reference to a DateTimeComparator object * (a Comparator) for millis of seconds. */ Comparator cMillis = null; /** * A reference to a DateTimeComparator object * (a Comparator) for seconds. */ Comparator cSecond = null; /** * A reference to a DateTimeComparator object * (a Comparator) for minutes. */ Comparator cMinute = null; /** * A reference to a DateTimeComparator object * (a Comparator) for hours. */ Comparator cHour = null; /** * A reference to a DateTimeComparator object * (a Comparator) for day of the week. */ Comparator cDayOfWeek = null; /** * A reference to a DateTimeComparator object * (a Comparator) for day of the month. */ Comparator cDayOfMonth = null; /** * A reference to a DateTimeComparator object * (a Comparator) for day of the year. */ Comparator cDayOfYear = null; /** * A reference to a DateTimeComparator object * (a Comparator) for week of the weekyear. */ Comparator cWeekOfWeekyear = null; /** * A reference to a DateTimeComparator object * (a Comparator) for year given a week of the year. */ Comparator cWeekyear = null; /** * A reference to a DateTimeComparator object * (a Comparator) for months. */ Comparator cMonth = null; /** * A reference to a DateTimeComparator object * (a Comparator) for year. */ Comparator cYear = null; /** * A reference to a DateTimeComparator object * (a Comparator) for the date portion of an * object. */ Comparator cDate = null; /** * A reference to a DateTimeComparator object * (a Comparator) for the time portion of an * object. */ Comparator cTime = null; /** * Junit <code>setUp()</code> method. */ public void setUp() /* throws Exception */ { Chronology chrono = ISOChronology.getInstanceUTC(); // super.setUp(); // Obtain comparator's cMillis = DateTimeComparator.getInstance(null, DateTimeFieldType.secondOfMinute()); cSecond = DateTimeComparator.getInstance(DateTimeFieldType.secondOfMinute(), DateTimeFieldType.minuteOfHour()); cMinute = DateTimeComparator.getInstance(DateTimeFieldType.minuteOfHour(), DateTimeFieldType.hourOfDay()); cHour = DateTimeComparator.getInstance(DateTimeFieldType.hourOfDay(), DateTimeFieldType.dayOfYear()); cDayOfWeek = DateTimeComparator.getInstance(DateTimeFieldType.dayOfWeek(), DateTimeFieldType.weekOfWeekyear()); cDayOfMonth = DateTimeComparator.getInstance(DateTimeFieldType.dayOfMonth(), DateTimeFieldType.monthOfYear()); cDayOfYear = DateTimeComparator.getInstance(DateTimeFieldType.dayOfYear(), DateTimeFieldType.year()); cWeekOfWeekyear = DateTimeComparator.getInstance(DateTimeFieldType.weekOfWeekyear(), DateTimeFieldType.weekyear()); cWeekyear = DateTimeComparator.getInstance(DateTimeFieldType.weekyear()); cMonth = DateTimeComparator.getInstance(DateTimeFieldType.monthOfYear(), DateTimeFieldType.year()); cYear = DateTimeComparator.getInstance(DateTimeFieldType.year()); cDate = DateTimeComparator.getDateOnlyInstance(); cTime = DateTimeComparator.getTimeOnlyInstance(); } /** * Junit <code>tearDown()</code> method. */ protected void tearDown() /* throws Exception */ { // super.tearDown(); aDateTime = null; bDateTime = null; // cMillis = null; cSecond = null; cMinute = null; cHour = null; cDayOfWeek = null; cDayOfMonth = null; cDayOfYear = null; cWeekOfWeekyear = null; cWeekyear = null; cMonth = null; cYear = null; cDate = null; cTime = null; } //----------------------------------------------------------------------- public void testClass() { assertEquals(true, Modifier.isPublic(DateTimeComparator.class.getModifiers())); assertEquals(false, Modifier.isFinal(DateTimeComparator.class.getModifiers())); assertEquals(1, DateTimeComparator.class.getDeclaredConstructors().length); assertEquals(true, Modifier.isProtected(DateTimeComparator.class.getDeclaredConstructors()[0].getModifiers())); } //----------------------------------------------------------------------- public void testStaticGetInstance() { DateTimeComparator c = DateTimeComparator.getInstance(); assertEquals(null, c.getLowerLimit()); assertEquals(null, c.getUpperLimit()); assertEquals("DateTimeComparator[]", c.toString()); } public void testStaticGetDateOnlyInstance() { DateTimeComparator c = DateTimeComparator.getDateOnlyInstance(); assertEquals(DateTimeFieldType.dayOfYear(), c.getLowerLimit()); assertEquals(null, c.getUpperLimit()); assertEquals("DateTimeComparator[dayOfYear-]", c.toString()); assertSame(DateTimeComparator.getDateOnlyInstance(), DateTimeComparator.getDateOnlyInstance()); } public void testStaticGetTimeOnlyInstance() { DateTimeComparator c = DateTimeComparator.getTimeOnlyInstance(); assertEquals(null, c.getLowerLimit()); assertEquals(DateTimeFieldType.dayOfYear(), c.getUpperLimit()); assertEquals("DateTimeComparator[-dayOfYear]", c.toString()); assertSame(DateTimeComparator.getTimeOnlyInstance(), DateTimeComparator.getTimeOnlyInstance()); } public void testStaticGetInstanceLower() { DateTimeComparator c = DateTimeComparator.getInstance(DateTimeFieldType.hourOfDay()); assertEquals(DateTimeFieldType.hourOfDay(), c.getLowerLimit()); assertEquals(null, c.getUpperLimit()); assertEquals("DateTimeComparator[hourOfDay-]", c.toString()); c = DateTimeComparator.getInstance(null); assertSame(DateTimeComparator.getInstance(), c); } public void testStaticGetInstanceLowerUpper() { DateTimeComparator c = DateTimeComparator.getInstance(DateTimeFieldType.hourOfDay(), DateTimeFieldType.dayOfYear()); assertEquals(DateTimeFieldType.hourOfDay(), c.getLowerLimit()); assertEquals(DateTimeFieldType.dayOfYear(), c.getUpperLimit()); assertEquals("DateTimeComparator[hourOfDay-dayOfYear]", c.toString()); c = DateTimeComparator.getInstance(DateTimeFieldType.hourOfDay(), DateTimeFieldType.hourOfDay()); assertEquals(DateTimeFieldType.hourOfDay(), c.getLowerLimit()); assertEquals(DateTimeFieldType.hourOfDay(), c.getUpperLimit()); assertEquals("DateTimeComparator[hourOfDay]", c.toString()); c = DateTimeComparator.getInstance(null, null); assertSame(DateTimeComparator.getInstance(), c); c = DateTimeComparator.getInstance(DateTimeFieldType.dayOfYear(), null); assertSame(DateTimeComparator.getDateOnlyInstance(), c); c = DateTimeComparator.getInstance(null, DateTimeFieldType.dayOfYear()); assertSame(DateTimeComparator.getTimeOnlyInstance(), c); } //----------------------------------------------------------------------- public void testEqualsHashCode() { DateTimeComparator c1 = DateTimeComparator.getInstance(); assertEquals(true, c1.equals(c1)); assertEquals(false, c1.equals(null)); assertEquals(true, c1.hashCode() == c1.hashCode()); DateTimeComparator c2 = DateTimeComparator.getTimeOnlyInstance(); assertEquals(true, c2.equals(c2)); assertEquals(false, c2.equals(c1)); assertEquals(false, c1.equals(c2)); assertEquals(false, c2.equals(null)); assertEquals(false, c1.hashCode() == c2.hashCode()); DateTimeComparator c3 = DateTimeComparator.getTimeOnlyInstance(); assertEquals(true, c3.equals(c3)); assertEquals(false, c3.equals(c1)); assertEquals(true, c3.equals(c2)); assertEquals(false, c1.equals(c3)); assertEquals(true, c2.equals(c3)); assertEquals(false, c1.hashCode() == c3.hashCode()); assertEquals(true, c2.hashCode() == c3.hashCode()); DateTimeComparator c4 = DateTimeComparator.getDateOnlyInstance(); assertEquals(false, c4.hashCode() == c3.hashCode()); } //----------------------------------------------------------------------- public void testSerialization1() throws Exception { DateTimeField f = ISO.dayOfYear(); f.toString(); DateTimeComparator c = DateTimeComparator.getInstance(DateTimeFieldType.hourOfDay(), DateTimeFieldType.dayOfYear()); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(c); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); DateTimeComparator result = (DateTimeComparator) ois.readObject(); ois.close(); assertEquals(c, result); } //----------------------------------------------------------------------- public void testSerialization2() throws Exception { DateTimeComparator c = DateTimeComparator.getInstance(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(c); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); DateTimeComparator result = (DateTimeComparator) ois.readObject(); ois.close(); assertSame(c, result); } //----------------------------------------------------------------------- /** * Test all basic comparator operation with DateTime objects. */ public void testBasicComps1() { aDateTime = new DateTime( System.currentTimeMillis(), DateTimeZone.UTC ); bDateTime = new DateTime( aDateTime.getMillis(), DateTimeZone.UTC ); assertEquals( "getMillis", aDateTime.getMillis(), bDateTime.getMillis() ); assertEquals( "MILLIS", 0, cMillis.compare( aDateTime, bDateTime ) ); assertEquals( "SECOND", 0, cSecond.compare( aDateTime, bDateTime ) ); assertEquals( "MINUTE", 0, cMinute.compare( aDateTime, bDateTime ) ); assertEquals( "HOUR", 0, cHour.compare( aDateTime, bDateTime ) ); assertEquals( "DOW", 0, cDayOfWeek.compare( aDateTime, bDateTime ) ); assertEquals( "DOM", 0, cDayOfMonth.compare( aDateTime, bDateTime ) ); assertEquals( "DOY", 0, cDayOfYear.compare( aDateTime, bDateTime ) ); assertEquals( "WOW", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) ); assertEquals( "WY", 0, cWeekyear.compare( aDateTime, bDateTime ) ); assertEquals( "MONTH", 0, cMonth.compare( aDateTime, bDateTime ) ); assertEquals( "YEAR", 0, cYear.compare( aDateTime, bDateTime ) ); assertEquals( "DATE", 0, cDate.compare( aDateTime, bDateTime ) ); assertEquals( "TIME", 0, cTime.compare( aDateTime, bDateTime ) ); } // end of testBasicComps /** * Test all basic comparator operation with ReadableInstant objects. */ public void testBasicComps2() { ReadableInstant aDateTime = new DateTime( System.currentTimeMillis(), DateTimeZone.UTC ); ReadableInstant bDateTime = new DateTime( aDateTime.getMillis(), DateTimeZone.UTC ); assertEquals( "getMillis", aDateTime.getMillis(), bDateTime.getMillis() ); assertEquals( "MILLIS", 0, cMillis.compare( aDateTime, bDateTime ) ); assertEquals( "SECOND", 0, cSecond.compare( aDateTime, bDateTime ) ); assertEquals( "MINUTE", 0, cMinute.compare( aDateTime, bDateTime ) ); assertEquals( "HOUR", 0, cHour.compare( aDateTime, bDateTime ) ); assertEquals( "DOW", 0, cDayOfWeek.compare( aDateTime, bDateTime ) ); assertEquals( "DOM", 0, cDayOfMonth.compare( aDateTime, bDateTime ) ); assertEquals( "DOY", 0, cDayOfYear.compare( aDateTime, bDateTime ) ); assertEquals( "WOW", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) ); assertEquals( "WY", 0, cWeekyear.compare( aDateTime, bDateTime ) ); assertEquals( "MONTH", 0, cMonth.compare( aDateTime, bDateTime ) ); assertEquals( "YEAR", 0, cYear.compare( aDateTime, bDateTime ) ); assertEquals( "DATE", 0, cDate.compare( aDateTime, bDateTime ) ); assertEquals( "TIME", 0, cTime.compare( aDateTime, bDateTime ) ); } // end of testBasicComps /** * Test all basic comparator operation with java Date objects. */ public void testBasicComps3() { Date aDateTime = new Date( System.currentTimeMillis() ); Date bDateTime = new Date( aDateTime.getTime() ); assertEquals( "MILLIS", 0, cMillis.compare( aDateTime, bDateTime ) ); assertEquals( "SECOND", 0, cSecond.compare( aDateTime, bDateTime ) ); assertEquals( "MINUTE", 0, cMinute.compare( aDateTime, bDateTime ) ); assertEquals( "HOUR", 0, cHour.compare( aDateTime, bDateTime ) ); assertEquals( "DOW", 0, cDayOfWeek.compare( aDateTime, bDateTime ) ); assertEquals( "DOM", 0, cDayOfMonth.compare( aDateTime, bDateTime ) ); assertEquals( "DOY", 0, cDayOfYear.compare( aDateTime, bDateTime ) ); assertEquals( "WOW", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) ); assertEquals( "WY", 0, cWeekyear.compare( aDateTime, bDateTime ) ); assertEquals( "MONTH", 0, cMonth.compare( aDateTime, bDateTime ) ); assertEquals( "YEAR", 0, cYear.compare( aDateTime, bDateTime ) ); assertEquals( "DATE", 0, cDate.compare( aDateTime, bDateTime ) ); assertEquals( "TIME", 0, cTime.compare( aDateTime, bDateTime ) ); } // end of testBasicComps /** * Test all basic comparator operation with Long objects. */ public void testBasicComps4() { Long aDateTime = new Long( System.currentTimeMillis() ); Long bDateTime = new Long( aDateTime.longValue() ); assertEquals( "MILLIS", 0, cMillis.compare( aDateTime, bDateTime ) ); assertEquals( "SECOND", 0, cSecond.compare( aDateTime, bDateTime ) ); assertEquals( "MINUTE", 0, cMinute.compare( aDateTime, bDateTime ) ); assertEquals( "HOUR", 0, cHour.compare( aDateTime, bDateTime ) ); assertEquals( "DOW", 0, cDayOfWeek.compare( aDateTime, bDateTime ) ); assertEquals( "DOM", 0, cDayOfMonth.compare( aDateTime, bDateTime ) ); assertEquals( "DOY", 0, cDayOfYear.compare( aDateTime, bDateTime ) ); assertEquals( "WOW", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) ); assertEquals( "WY", 0, cWeekyear.compare( aDateTime, bDateTime ) ); assertEquals( "MONTH", 0, cMonth.compare( aDateTime, bDateTime ) ); assertEquals( "YEAR", 0, cYear.compare( aDateTime, bDateTime ) ); assertEquals( "DATE", 0, cDate.compare( aDateTime, bDateTime ) ); assertEquals( "TIME", 0, cTime.compare( aDateTime, bDateTime ) ); } // end of testBasicComps /** * Test all basic comparator operation with Calendar objects. */ public void testBasicComps5() { Calendar aDateTime = Calendar.getInstance(); // right now Calendar bDateTime = aDateTime; assertEquals( "MILLIS", 0, cMillis.compare( aDateTime, bDateTime ) ); assertEquals( "SECOND", 0, cSecond.compare( aDateTime, bDateTime ) ); assertEquals( "MINUTE", 0, cMinute.compare( aDateTime, bDateTime ) ); assertEquals( "HOUR", 0, cHour.compare( aDateTime, bDateTime ) ); assertEquals( "DOW", 0, cDayOfWeek.compare( aDateTime, bDateTime ) ); assertEquals( "DOM", 0, cDayOfMonth.compare( aDateTime, bDateTime ) ); assertEquals( "DOY", 0, cDayOfYear.compare( aDateTime, bDateTime ) ); assertEquals( "WOW", 0, cWeekOfWeekyear.compare( aDateTime, bDateTime ) ); assertEquals( "WY", 0, cWeekyear.compare( aDateTime, bDateTime ) ); assertEquals( "MONTH", 0, cMonth.compare( aDateTime, bDateTime ) ); assertEquals( "YEAR", 0, cYear.compare( aDateTime, bDateTime ) ); assertEquals( "DATE", 0, cDate.compare( aDateTime, bDateTime ) ); assertEquals( "TIME", 0, cTime.compare( aDateTime, bDateTime ) ); } // end of testBasicComps /** * Test unequal comparisons with millis of second comparators. */ public void testMillis() {} // Defects4J: flaky method // public void testMillis() { // aDateTime = new DateTime( System.currentTimeMillis(), DateTimeZone.UTC ); // bDateTime = new DateTime( aDateTime.getMillis() + 1, DateTimeZone.UTC ); // assertEquals( "MillisM1", -1, cMillis.compare( aDateTime, bDateTime ) ); // assertEquals( "MillisP1", 1, cMillis.compare( bDateTime, aDateTime ) ); // } // end of testMillis /** * Test unequal comparisons with second comparators. */ public void testSecond() { aDateTime = getADate( "1969-12-31T23:59:58" ); bDateTime = getADate( "1969-12-31T23:50:59" ); assertEquals( "SecondM1a", -1, cSecond.compare( aDateTime, bDateTime ) ); assertEquals( "SecondP1a", 1, cSecond.compare( bDateTime, aDateTime ) ); aDateTime = getADate( "1970-01-01T00:00:00" ); bDateTime = getADate( "1970-01-01T00:00:01" ); assertEquals( "SecondM1b", -1, cSecond.compare( aDateTime, bDateTime ) ); assertEquals( "SecondP1b", 1, cSecond.compare( bDateTime, aDateTime ) ); } // end of testSecond /** * Test unequal comparisons with minute comparators. */ public void testMinute() { aDateTime = getADate( "1969-12-31T23:58:00" ); bDateTime = getADate( "1969-12-31T23:59:00" ); assertEquals( "MinuteM1a", -1, cMinute.compare( aDateTime, bDateTime ) ); assertEquals( "MinuteP1a", 1, cMinute.compare( bDateTime, aDateTime ) ); aDateTime = getADate( "1970-01-01T00:00:00" ); bDateTime = getADate( "1970-01-01T00:01:00" ); assertEquals( "MinuteM1b", -1, cMinute.compare( aDateTime, bDateTime ) ); assertEquals( "MinuteP1b", 1, cMinute.compare( bDateTime, aDateTime ) ); } // end of testMinute /** * Test unequal comparisons with hour comparators. */ public void testHour() { aDateTime = getADate( "1969-12-31T22:00:00" ); bDateTime = getADate( "1969-12-31T23:00:00" ); assertEquals( "HourM1a", -1, cHour.compare( aDateTime, bDateTime ) ); assertEquals( "HourP1a", 1, cHour.compare( bDateTime, aDateTime ) ); aDateTime = getADate( "1970-01-01T00:00:00" ); bDateTime = getADate( "1970-01-01T01:00:00" ); assertEquals( "HourM1b", -1, cHour.compare( aDateTime, bDateTime ) ); assertEquals( "HourP1b", 1, cHour.compare( bDateTime, aDateTime ) ); aDateTime = getADate( "1969-12-31T23:59:59" ); bDateTime = getADate( "1970-01-01T00:00:00" ); assertEquals( "HourP1c", 1, cHour.compare( aDateTime, bDateTime ) ); assertEquals( "HourM1c", -1, cHour.compare( bDateTime, aDateTime ) ); } // end of testHour /** * Test unequal comparisons with day of week comparators. */ public void testDOW() { /* * Dates chosen when I wrote the code, so I know what day of * the week it is. */ aDateTime = getADate( "2002-04-12T00:00:00" ); bDateTime = getADate( "2002-04-13T00:00:00" ); assertEquals( "DOWM1a", -1, cDayOfWeek.compare( aDateTime, bDateTime ) ); assertEquals( "DOWP1a", 1, cDayOfWeek.compare( bDateTime, aDateTime ) ); } // end of testDOW /** * Test unequal comparisons with day of month comparators. */ public void testDOM() { aDateTime = getADate( "2002-04-12T00:00:00" ); bDateTime = getADate( "2002-04-13T00:00:00" ); assertEquals( "DOMM1a", -1, cDayOfMonth.compare( aDateTime, bDateTime ) ); assertEquals( "DOMP1a", 1, cDayOfMonth.compare( bDateTime, aDateTime ) ); aDateTime = getADate( "2000-12-01T00:00:00" ); bDateTime = getADate( "1814-04-30T00:00:00" ); assertEquals( "DOMM1b", -1, cDayOfMonth.compare( aDateTime, bDateTime ) ); assertEquals( "DOMP1b", 1, cDayOfMonth.compare( bDateTime, aDateTime ) ); } // end of testDOM /** * Test unequal comparisons with day of year comparators. */ public void testDOY() { aDateTime = getADate( "2002-04-12T00:00:00" ); bDateTime = getADate( "2002-04-13T00:00:00" ); assertEquals( "DOYM1a", -1, cDayOfYear.compare( aDateTime, bDateTime ) ); assertEquals( "DOYP1a", 1, cDayOfYear.compare( bDateTime, aDateTime ) ); aDateTime = getADate( "2000-02-29T00:00:00" ); bDateTime = getADate( "1814-11-30T00:00:00" ); assertEquals( "DOYM1b", -1, cDayOfYear.compare( aDateTime, bDateTime ) ); assertEquals( "DOYP1b", 1, cDayOfYear.compare( bDateTime, aDateTime ) ); } // end of testDOY /** * Test unequal comparisons with week of weekyear comparators. */ public void testWOW() { // 1st week of year contains Jan 04. aDateTime = getADate( "2000-01-04T00:00:00" ); bDateTime = getADate( "2000-01-11T00:00:00" ); assertEquals( "WOWM1a", -1, cWeekOfWeekyear.compare( aDateTime, bDateTime ) ); assertEquals( "WOWP1a", 1, cWeekOfWeekyear.compare( bDateTime, aDateTime ) ); aDateTime = getADate( "2000-01-04T00:00:00" ); bDateTime = getADate( "1999-12-31T00:00:00" ); assertEquals( "WOWM1b", -1, cWeekOfWeekyear.compare( aDateTime, bDateTime ) ); assertEquals( "WOWP1b", 1, cWeekOfWeekyear.compare( bDateTime, aDateTime ) ); } // end of testMillis /** * Test unequal comparisons with year given the week comparators. */ public void testWOYY() { // How do I test the end conditions of this? // Don't understand ...... aDateTime = getADate( "1998-12-31T23:59:59" ); bDateTime = getADate( "1999-01-01T00:00:00" ); assertEquals( "YOYYZ", 0, cWeekyear.compare( aDateTime, bDateTime ) ); bDateTime = getADate( "1999-01-04T00:00:00" ); assertEquals( "YOYYM1", -1, cWeekyear.compare( aDateTime, bDateTime ) ); assertEquals( "YOYYP1", 1, cWeekyear.compare( bDateTime, aDateTime ) ); } // end of testWOYY /** * Test unequal comparisons with month comparators. */ public void testMonth() { aDateTime = getADate( "2002-04-30T00:00:00" ); bDateTime = getADate( "2002-05-01T00:00:00" ); assertEquals( "MONTHM1a", -1, cMonth.compare( aDateTime, bDateTime ) ); assertEquals( "MONTHP1a", 1, cMonth.compare( bDateTime, aDateTime ) ); aDateTime = getADate( "1900-01-01T00:00:00" ); bDateTime = getADate( "1899-12-31T00:00:00" ); assertEquals( "MONTHM1b", -1, cMonth.compare( aDateTime, bDateTime ) ); assertEquals( "MONTHP1b", 1, cMonth.compare( bDateTime, aDateTime ) ); } // end of testMonth /** * Test unequal comparisons with year comparators. */ public void testYear() { aDateTime = getADate( "2000-01-01T00:00:00" ); bDateTime = getADate( "2001-01-01T00:00:00" ); assertEquals( "YEARM1a", -1, cYear.compare( aDateTime, bDateTime ) ); assertEquals( "YEARP1a", 1, cYear.compare( bDateTime, aDateTime ) ); aDateTime = getADate( "1968-12-31T23:59:59" ); bDateTime = getADate( "1970-01-01T00:00:00" ); assertEquals( "YEARM1b", -1, cYear.compare( aDateTime, bDateTime ) ); assertEquals( "YEARP1b", 1, cYear.compare( bDateTime, aDateTime ) ); aDateTime = getADate( "1969-12-31T23:59:59" ); bDateTime = getADate( "1970-01-01T00:00:00" ); assertEquals( "YEARM1c", -1, cYear.compare( aDateTime, bDateTime ) ); assertEquals( "YEARP1c", 1, cYear.compare( bDateTime, aDateTime ) ); } // end of testYear /* * 'List' processing tests follow. */ /** * Test sorting with full default comparator. */ public void testListBasic() { String[] dtStrs = { "1999-02-01T00:00:00", "1998-01-20T00:00:00" }; // List sl = loadAList( dtStrs ); boolean isSorted1 = isListSorted( sl ); Collections.sort( sl ); boolean isSorted2 = isListSorted( sl ); assertEquals("ListBasic", !isSorted1, isSorted2); } // end of testListBasic /** * Test sorting with millis of second comparator. */ public void testListMillis() { // List sl = new ArrayList(); long base = 12345L * 1000L; sl.add( new DateTime( base + 999L, DateTimeZone.UTC ) ); sl.add( new DateTime( base + 222L, DateTimeZone.UTC ) ); sl.add( new DateTime( base + 456L, DateTimeZone.UTC ) ); sl.add( new DateTime( base + 888L, DateTimeZone.UTC ) ); sl.add( new DateTime( base + 123L, DateTimeZone.UTC ) ); sl.add( new DateTime( base + 000L, DateTimeZone.UTC ) ); // boolean isSorted1 = isListSorted( sl ); Collections.sort( sl, cMillis ); boolean isSorted2 = isListSorted( sl ); assertEquals("ListLillis", !isSorted1, isSorted2); } // end of testListSecond /** * Test sorting with second comparator. */ public void testListSecond() { String[] dtStrs = { "1999-02-01T00:00:10", "1999-02-01T00:00:30", "1999-02-01T00:00:25", "1999-02-01T00:00:18", "1999-02-01T00:00:01", "1999-02-01T00:00:59", "1999-02-01T00:00:22" }; // List sl = loadAList( dtStrs ); boolean isSorted1 = isListSorted( sl ); Collections.sort( sl, cSecond ); boolean isSorted2 = isListSorted( sl ); assertEquals("ListSecond", !isSorted1, isSorted2); } // end of testListSecond /** * Test sorting with minute comparator. */ public void testListMinute() { String[] dtStrs = { "1999-02-01T00:10:00", "1999-02-01T00:30:00", "1999-02-01T00:25:00", "1999-02-01T00:18:00", "1999-02-01T00:01:00", "1999-02-01T00:59:00", "1999-02-01T00:22:00" }; // List sl = loadAList( dtStrs ); boolean isSorted1 = isListSorted( sl ); Collections.sort( sl, cMinute ); boolean isSorted2 = isListSorted( sl ); assertEquals("ListMinute", !isSorted1, isSorted2); } // end of testListMinute /** * Test sorting with hour comparator. */ public void testListHour() { String[] dtStrs = { "1999-02-01T10:00:00", "1999-02-01T23:00:00", "1999-02-01T01:00:00", "1999-02-01T15:00:00", "1999-02-01T05:00:00", "1999-02-01T20:00:00", "1999-02-01T17:00:00" }; // List sl = loadAList( dtStrs ); boolean isSorted1 = isListSorted( sl ); Collections.sort( sl, cHour ); boolean isSorted2 = isListSorted( sl ); assertEquals("ListHour", !isSorted1, isSorted2); } // end of testListHour /** * Test sorting with day of week comparator. */ public void testListDOW() { String[] dtStrs = { /* 2002-04-15 = Monday */ "2002-04-21T10:00:00", "2002-04-16T10:00:00", "2002-04-15T10:00:00", "2002-04-17T10:00:00", "2002-04-19T10:00:00", "2002-04-18T10:00:00", "2002-04-20T10:00:00" }; // List sl = loadAList( dtStrs ); boolean isSorted1 = isListSorted( sl ); Collections.sort( sl, cDayOfWeek ); boolean isSorted2 = isListSorted( sl ); assertEquals("ListDOW", !isSorted1, isSorted2); } // end of testListDOW /** * Test sorting with day of month comparator. */ public void testListDOM() { String[] dtStrs = { /* 2002-04-14 = Sunday */ "2002-04-20T10:00:00", "2002-04-16T10:00:00", "2002-04-15T10:00:00", "2002-04-17T10:00:00", "2002-04-19T10:00:00", "2002-04-18T10:00:00", "2002-04-14T10:00:00" }; // List sl = loadAList( dtStrs ); boolean isSorted1 = isListSorted( sl ); Collections.sort( sl, cDayOfMonth ); boolean isSorted2 = isListSorted( sl ); assertEquals("ListDOM", !isSorted1, isSorted2); } // end of testListDOM /** * Test sorting with day of year comparator. */ public void testListDOY() { String[] dtStrs = { "2002-04-20T10:00:00", "2002-01-16T10:00:00", "2002-12-31T10:00:00", "2002-09-14T10:00:00", "2002-09-19T10:00:00", "2002-02-14T10:00:00", "2002-10-30T10:00:00" }; // List sl = loadAList( dtStrs ); boolean isSorted1 = isListSorted( sl ); Collections.sort( sl, cDayOfYear ); boolean isSorted2 = isListSorted( sl ); assertEquals("ListDOY", !isSorted1, isSorted2); } // end of testListDOY /** * Test sorting with week of weekyear comparator. */ public void testListWOW() { String[] dtStrs = { "2002-04-01T10:00:00", "2002-01-01T10:00:00", "2002-12-01T10:00:00", "2002-09-01T10:00:00", "2002-09-01T10:00:00", "2002-02-01T10:00:00", "2002-10-01T10:00:00" }; // List sl = loadAList( dtStrs ); boolean isSorted1 = isListSorted( sl ); Collections.sort( sl, cWeekOfWeekyear ); boolean isSorted2 = isListSorted( sl ); assertEquals("ListWOW", !isSorted1, isSorted2); } // end of testListWOW /** * Test sorting with year (given week) comparator. */ public void testListYOYY() { // ?? How to catch end conditions ?? String[] dtStrs = { "2010-04-01T10:00:00", "2002-01-01T10:00:00" }; // List sl = loadAList( dtStrs ); boolean isSorted1 = isListSorted( sl ); Collections.sort( sl, cWeekyear ); boolean isSorted2 = isListSorted( sl ); assertEquals("ListYOYY", !isSorted1, isSorted2); } // end of testListYOYY /** * Test sorting with month comparator. */ public void testListMonth() { String[] dtStrs = { "2002-04-01T10:00:00", "2002-01-01T10:00:00", "2002-12-01T10:00:00", "2002-09-01T10:00:00", "2002-09-01T10:00:00", "2002-02-01T10:00:00", "2002-10-01T10:00:00" }; // List sl = loadAList( dtStrs ); boolean isSorted1 = isListSorted( sl ); Collections.sort( sl, cMonth ); boolean isSorted2 = isListSorted( sl ); assertEquals("ListMonth", !isSorted1, isSorted2); } // end of testListMonth /** * Test sorting with year comparator. */ public void testListYear() { String[] dtStrs = { "1999-02-01T00:00:00", "1998-02-01T00:00:00", "2525-02-01T00:00:00", "1776-02-01T00:00:00", "1863-02-01T00:00:00", "1066-02-01T00:00:00", "2100-02-01T00:00:00" }; // List sl = loadAList( dtStrs ); boolean isSorted1 = isListSorted( sl ); Collections.sort( sl, cYear ); boolean isSorted2 = isListSorted( sl ); assertEquals("ListYear", !isSorted1, isSorted2); } // end of testListYear /** * Test sorting with date only comparator. */ public void testListDate() { String[] dtStrs = { "1999-02-01T00:00:00", "1998-10-03T00:00:00", "2525-05-20T00:00:00", "1776-12-25T00:00:00", "1863-01-31T00:00:00", "1066-09-22T00:00:00", "2100-07-04T00:00:00" }; // List sl = loadAList( dtStrs ); boolean isSorted1 = isListSorted( sl ); Collections.sort( sl, cDate ); boolean isSorted2 = isListSorted( sl ); assertEquals("ListDate", !isSorted1, isSorted2); } // end of testListDate /** * Test sorting with time only comparator. */ public void testListTime() { String[] dtStrs = { "1999-02-01T01:02:05", "1999-02-01T22:22:22", "1999-02-01T05:30:45", "1999-02-01T09:17:59", "1999-02-01T09:17:58", "1999-02-01T15:30:00", "1999-02-01T17:00:44" }; // List sl = loadAList( dtStrs ); boolean isSorted1 = isListSorted( sl ); Collections.sort( sl, cTime ); boolean isSorted2 = isListSorted( sl ); assertEquals("ListTime", !isSorted1, isSorted2); } // end of testListTime /** * Test comparator operation with null object(s). */ public void testNullDT() { // null means now aDateTime = getADate("2000-01-01T00:00:00"); assertTrue(cYear.compare(null, aDateTime) > 0); assertTrue(cYear.compare(aDateTime, null) < 0); } /** * Test comparator operation with an invalid object type. */ public void testInvalidObj() { aDateTime = getADate("2000-01-01T00:00:00"); try { cYear.compare("FreeBird", aDateTime); fail("Invalid object failed"); } catch (IllegalArgumentException cce) {} } // private convenience methods //----------------------------------------------------------------------- /** * Creates a date to test with. */ private DateTime getADate(String s) { DateTime retDT = null; try { retDT = new DateTime(s, DateTimeZone.UTC); } catch (IllegalArgumentException pe) { pe.printStackTrace(); } return retDT; } /** * Load a string array. */ private List loadAList(String[] someStrs) { List newList = new ArrayList(); try { for (int i = 0; i < someStrs.length; ++i) { newList.add(new DateTime(someStrs[i], DateTimeZone.UTC)); } // end of the for } catch (IllegalArgumentException pe) { pe.printStackTrace(); } return newList; } /** * Check if the list is sorted. */ private boolean isListSorted(List tl) { // tl must be populated with DateTime objects. DateTime lhDT = (DateTime)tl.get(0); DateTime rhDT = null; Long lhVal = new Long( lhDT.getMillis() ); Long rhVal = null; for (int i = 1; i < tl.size(); ++i) { rhDT = (DateTime)tl.get(i); rhVal = new Long( rhDT.getMillis() ); if ( lhVal.compareTo( rhVal) > 0 ) return false; // lhVal = rhVal; // swap for next iteration lhDT = rhDT; // swap for next iteration } return true; } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.CopticChronology; /** * This class is a Junit unit test for Chronology. * * @author Stephen Colebourne */ public class TestDateTimeFieldType extends TestCase { public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestDateTimeFieldType.class); } public TestDateTimeFieldType(String name) { super(name); } protected void setUp() throws Exception { } protected void tearDown() throws Exception { } //----------------------------------------------------------------------- public void test_era() throws Exception { assertEquals(DateTimeFieldType.era(), DateTimeFieldType.era()); assertEquals("era", DateTimeFieldType.era().getName()); assertEquals(DurationFieldType.eras(), DateTimeFieldType.era().getDurationType()); assertEquals(null, DateTimeFieldType.era().getRangeDurationType()); assertEquals(CopticChronology.getInstanceUTC().era(), DateTimeFieldType.era().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().era().isSupported(), DateTimeFieldType.era().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DateTimeFieldType.era()); } public void test_centuryOfEra() throws Exception { assertEquals(DateTimeFieldType.centuryOfEra(), DateTimeFieldType.centuryOfEra()); assertEquals("centuryOfEra", DateTimeFieldType.centuryOfEra().getName()); assertEquals(DurationFieldType.centuries(), DateTimeFieldType.centuryOfEra().getDurationType()); assertEquals(DurationFieldType.eras(), DateTimeFieldType.centuryOfEra().getRangeDurationType()); assertEquals(CopticChronology.getInstanceUTC().centuryOfEra(), DateTimeFieldType.centuryOfEra().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().centuryOfEra().isSupported(), DateTimeFieldType.centuryOfEra().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DateTimeFieldType.centuryOfEra()); } public void test_yearOfCentury() throws Exception { assertEquals(DateTimeFieldType.yearOfCentury(), DateTimeFieldType.yearOfCentury()); assertEquals("yearOfCentury", DateTimeFieldType.yearOfCentury().getName()); assertEquals(DurationFieldType.years(), DateTimeFieldType.yearOfCentury().getDurationType()); assertEquals(DurationFieldType.centuries(), DateTimeFieldType.yearOfCentury().getRangeDurationType()); assertEquals(CopticChronology.getInstanceUTC().yearOfCentury(), DateTimeFieldType.yearOfCentury().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().yearOfCentury().isSupported(), DateTimeFieldType.yearOfCentury().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DateTimeFieldType.yearOfCentury()); } public void test_yearOfEra() throws Exception { assertEquals(DateTimeFieldType.yearOfEra(), DateTimeFieldType.yearOfEra()); assertEquals("yearOfEra", DateTimeFieldType.yearOfEra().getName()); assertEquals(DurationFieldType.years(), DateTimeFieldType.yearOfEra().getDurationType()); assertEquals(DurationFieldType.eras(), DateTimeFieldType.yearOfEra().getRangeDurationType()); assertEquals(CopticChronology.getInstanceUTC().yearOfEra(), DateTimeFieldType.yearOfEra().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().yearOfEra().isSupported(), DateTimeFieldType.yearOfEra().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DateTimeFieldType.yearOfEra()); } public void test_year() throws Exception { assertEquals(DateTimeFieldType.year(), DateTimeFieldType.year()); assertEquals("year", DateTimeFieldType.year().getName()); assertEquals(DurationFieldType.years(), DateTimeFieldType.year().getDurationType()); assertEquals(null, DateTimeFieldType.year().getRangeDurationType()); assertEquals(CopticChronology.getInstanceUTC().year(), DateTimeFieldType.year().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().year().isSupported(), DateTimeFieldType.year().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DateTimeFieldType.year()); } public void test_monthOfYear() throws Exception { assertEquals(DateTimeFieldType.monthOfYear(), DateTimeFieldType.monthOfYear()); assertEquals("monthOfYear", DateTimeFieldType.monthOfYear().getName()); assertEquals(DurationFieldType.months(), DateTimeFieldType.monthOfYear().getDurationType()); assertEquals(DurationFieldType.years(), DateTimeFieldType.monthOfYear().getRangeDurationType()); assertEquals(CopticChronology.getInstanceUTC().monthOfYear(), DateTimeFieldType.monthOfYear().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().monthOfYear().isSupported(), DateTimeFieldType.monthOfYear().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DateTimeFieldType.monthOfYear()); } public void test_weekyearOfCentury() throws Exception { assertEquals(DateTimeFieldType.weekyearOfCentury(), DateTimeFieldType.weekyearOfCentury()); assertEquals("weekyearOfCentury", DateTimeFieldType.weekyearOfCentury().getName()); assertEquals(DurationFieldType.weekyears(), DateTimeFieldType.weekyearOfCentury().getDurationType()); assertEquals(DurationFieldType.centuries(), DateTimeFieldType.weekyearOfCentury().getRangeDurationType()); assertEquals(CopticChronology.getInstanceUTC().weekyearOfCentury(), DateTimeFieldType.weekyearOfCentury().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().weekyearOfCentury().isSupported(), DateTimeFieldType.weekyearOfCentury().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DateTimeFieldType.weekyearOfCentury()); } public void test_weekyear() throws Exception { assertEquals(DateTimeFieldType.weekyear(), DateTimeFieldType.weekyear()); assertEquals("weekyear", DateTimeFieldType.weekyear().getName()); assertEquals(DurationFieldType.weekyears(), DateTimeFieldType.weekyear().getDurationType()); assertEquals(null, DateTimeFieldType.weekyear().getRangeDurationType()); assertEquals(CopticChronology.getInstanceUTC().weekyear(), DateTimeFieldType.weekyear().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().weekyear().isSupported(), DateTimeFieldType.weekyear().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DateTimeFieldType.weekyear()); } public void test_weekOfWeekyear() throws Exception { assertEquals(DateTimeFieldType.weekOfWeekyear(), DateTimeFieldType.weekOfWeekyear()); assertEquals("weekOfWeekyear", DateTimeFieldType.weekOfWeekyear().getName()); assertEquals(DurationFieldType.weeks(), DateTimeFieldType.weekOfWeekyear().getDurationType()); assertEquals(DurationFieldType.weekyears(), DateTimeFieldType.weekOfWeekyear().getRangeDurationType()); assertEquals(CopticChronology.getInstanceUTC().weekOfWeekyear(), DateTimeFieldType.weekOfWeekyear().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().weekOfWeekyear().isSupported(), DateTimeFieldType.weekOfWeekyear().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DateTimeFieldType.weekOfWeekyear()); } public void test_dayOfYear() throws Exception { assertEquals(DateTimeFieldType.dayOfYear(), DateTimeFieldType.dayOfYear()); assertEquals("dayOfYear", DateTimeFieldType.dayOfYear().getName()); assertEquals(DurationFieldType.days(), DateTimeFieldType.dayOfYear().getDurationType()); assertEquals(DurationFieldType.years(), DateTimeFieldType.dayOfYear().getRangeDurationType()); assertEquals(CopticChronology.getInstanceUTC().dayOfYear(), DateTimeFieldType.dayOfYear().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().dayOfYear().isSupported(), DateTimeFieldType.dayOfYear().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DateTimeFieldType.dayOfYear()); } public void test_dayOfMonth() throws Exception { assertEquals(DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfMonth()); assertEquals("dayOfMonth", DateTimeFieldType.dayOfMonth().getName()); assertEquals(DurationFieldType.days(), DateTimeFieldType.dayOfMonth().getDurationType()); assertEquals(DurationFieldType.months(), DateTimeFieldType.dayOfMonth().getRangeDurationType()); assertEquals(CopticChronology.getInstanceUTC().dayOfMonth(), DateTimeFieldType.dayOfMonth().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().dayOfMonth().isSupported(), DateTimeFieldType.dayOfMonth().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DateTimeFieldType.dayOfMonth()); } public void test_dayOfWeek() throws Exception { assertEquals(DateTimeFieldType.dayOfWeek(), DateTimeFieldType.dayOfWeek()); assertEquals("dayOfWeek", DateTimeFieldType.dayOfWeek().getName()); assertEquals(DurationFieldType.days(), DateTimeFieldType.dayOfWeek().getDurationType()); assertEquals(DurationFieldType.weeks(), DateTimeFieldType.dayOfWeek().getRangeDurationType()); assertEquals(CopticChronology.getInstanceUTC().dayOfWeek(), DateTimeFieldType.dayOfWeek().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().dayOfWeek().isSupported(), DateTimeFieldType.dayOfWeek().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DateTimeFieldType.dayOfWeek()); } public void test_halfdayOfDay() throws Exception { assertEquals(DateTimeFieldType.halfdayOfDay(), DateTimeFieldType.halfdayOfDay()); assertEquals("halfdayOfDay", DateTimeFieldType.halfdayOfDay().getName()); assertEquals(DurationFieldType.halfdays(), DateTimeFieldType.halfdayOfDay().getDurationType()); assertEquals(DurationFieldType.days(), DateTimeFieldType.halfdayOfDay().getRangeDurationType()); assertEquals(CopticChronology.getInstanceUTC().halfdayOfDay(), DateTimeFieldType.halfdayOfDay().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().halfdayOfDay().isSupported(), DateTimeFieldType.halfdayOfDay().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DateTimeFieldType.halfdayOfDay()); } public void test_clockhourOfDay() throws Exception { assertEquals(DateTimeFieldType.clockhourOfDay(), DateTimeFieldType.clockhourOfDay()); assertEquals("clockhourOfDay", DateTimeFieldType.clockhourOfDay().getName()); assertEquals(DurationFieldType.hours(), DateTimeFieldType.clockhourOfDay().getDurationType()); assertEquals(DurationFieldType.days(), DateTimeFieldType.clockhourOfDay().getRangeDurationType()); assertEquals(CopticChronology.getInstanceUTC().clockhourOfDay(), DateTimeFieldType.clockhourOfDay().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().clockhourOfDay().isSupported(), DateTimeFieldType.clockhourOfDay().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DateTimeFieldType.clockhourOfDay()); } public void test_clockhourOfHalfday() throws Exception { assertEquals(DateTimeFieldType.clockhourOfHalfday(), DateTimeFieldType.clockhourOfHalfday()); assertEquals("clockhourOfHalfday", DateTimeFieldType.clockhourOfHalfday().getName()); assertEquals(DurationFieldType.hours(), DateTimeFieldType.clockhourOfHalfday().getDurationType()); assertEquals(DurationFieldType.halfdays(), DateTimeFieldType.clockhourOfHalfday().getRangeDurationType()); assertEquals(CopticChronology.getInstanceUTC().clockhourOfHalfday(), DateTimeFieldType.clockhourOfHalfday().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().clockhourOfHalfday().isSupported(), DateTimeFieldType.clockhourOfHalfday().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DateTimeFieldType.clockhourOfHalfday()); } public void test_hourOfHalfday() throws Exception { assertEquals(DateTimeFieldType.hourOfHalfday(), DateTimeFieldType.hourOfHalfday()); assertEquals("hourOfHalfday", DateTimeFieldType.hourOfHalfday().getName()); assertEquals(DurationFieldType.hours(), DateTimeFieldType.hourOfHalfday().getDurationType()); assertEquals(DurationFieldType.halfdays(), DateTimeFieldType.hourOfHalfday().getRangeDurationType()); assertEquals(CopticChronology.getInstanceUTC().hourOfHalfday(), DateTimeFieldType.hourOfHalfday().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().hourOfHalfday().isSupported(), DateTimeFieldType.hourOfHalfday().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DateTimeFieldType.hourOfHalfday()); } public void test_hourOfDay() throws Exception { assertEquals(DateTimeFieldType.hourOfDay(), DateTimeFieldType.hourOfDay()); assertEquals("hourOfDay", DateTimeFieldType.hourOfDay().getName()); assertEquals(DurationFieldType.hours(), DateTimeFieldType.hourOfDay().getDurationType()); assertEquals(DurationFieldType.days(), DateTimeFieldType.hourOfDay().getRangeDurationType()); assertEquals(CopticChronology.getInstanceUTC().hourOfDay(), DateTimeFieldType.hourOfDay().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().hourOfDay().isSupported(), DateTimeFieldType.hourOfDay().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DateTimeFieldType.hourOfDay()); } public void test_minuteOfDay() throws Exception { assertEquals(DateTimeFieldType.minuteOfDay(), DateTimeFieldType.minuteOfDay()); assertEquals("minuteOfDay", DateTimeFieldType.minuteOfDay().getName()); assertEquals(DurationFieldType.minutes(), DateTimeFieldType.minuteOfDay().getDurationType()); assertEquals(DurationFieldType.days(), DateTimeFieldType.minuteOfDay().getRangeDurationType()); assertEquals(CopticChronology.getInstanceUTC().minuteOfDay(), DateTimeFieldType.minuteOfDay().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().minuteOfDay().isSupported(), DateTimeFieldType.minuteOfDay().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DateTimeFieldType.minuteOfDay()); } public void test_minuteOfHour() throws Exception { assertEquals(DateTimeFieldType.minuteOfHour(), DateTimeFieldType.minuteOfHour()); assertEquals("minuteOfHour", DateTimeFieldType.minuteOfHour().getName()); assertEquals(DurationFieldType.minutes(), DateTimeFieldType.minuteOfHour().getDurationType()); assertEquals(DurationFieldType.hours(), DateTimeFieldType.minuteOfHour().getRangeDurationType()); assertEquals(CopticChronology.getInstanceUTC().minuteOfHour(), DateTimeFieldType.minuteOfHour().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().minuteOfHour().isSupported(), DateTimeFieldType.minuteOfHour().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DateTimeFieldType.minuteOfHour()); } public void test_secondOfDay() throws Exception { assertEquals(DateTimeFieldType.secondOfDay(), DateTimeFieldType.secondOfDay()); assertEquals("secondOfDay", DateTimeFieldType.secondOfDay().getName()); assertEquals(DurationFieldType.seconds(), DateTimeFieldType.secondOfDay().getDurationType()); assertEquals(DurationFieldType.days(), DateTimeFieldType.secondOfDay().getRangeDurationType()); assertEquals(CopticChronology.getInstanceUTC().secondOfDay(), DateTimeFieldType.secondOfDay().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().secondOfDay().isSupported(), DateTimeFieldType.secondOfDay().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DateTimeFieldType.secondOfDay()); } public void test_secondOfMinute() throws Exception { assertEquals(DateTimeFieldType.secondOfMinute(), DateTimeFieldType.secondOfMinute()); assertEquals("secondOfMinute", DateTimeFieldType.secondOfMinute().getName()); assertEquals(DurationFieldType.seconds(), DateTimeFieldType.secondOfMinute().getDurationType()); assertEquals(DurationFieldType.minutes(), DateTimeFieldType.secondOfMinute().getRangeDurationType()); assertEquals(CopticChronology.getInstanceUTC().secondOfMinute(), DateTimeFieldType.secondOfMinute().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().secondOfMinute().isSupported(), DateTimeFieldType.secondOfMinute().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DateTimeFieldType.secondOfMinute()); } public void test_millisOfDay() throws Exception { assertEquals(DateTimeFieldType.millisOfDay(), DateTimeFieldType.millisOfDay()); assertEquals("millisOfDay", DateTimeFieldType.millisOfDay().getName()); assertEquals(DurationFieldType.millis(), DateTimeFieldType.millisOfDay().getDurationType()); assertEquals(DurationFieldType.days(), DateTimeFieldType.millisOfDay().getRangeDurationType()); assertEquals(CopticChronology.getInstanceUTC().millisOfDay(), DateTimeFieldType.millisOfDay().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().millisOfDay().isSupported(), DateTimeFieldType.millisOfDay().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DateTimeFieldType.millisOfDay()); } public void test_millisOfSecond() throws Exception { assertEquals(DateTimeFieldType.millisOfSecond(), DateTimeFieldType.millisOfSecond()); assertEquals("millisOfSecond", DateTimeFieldType.millisOfSecond().getName()); assertEquals(DurationFieldType.millis(), DateTimeFieldType.millisOfSecond().getDurationType()); assertEquals(DurationFieldType.seconds(), DateTimeFieldType.millisOfSecond().getRangeDurationType()); assertEquals(CopticChronology.getInstanceUTC().millisOfSecond(), DateTimeFieldType.millisOfSecond().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().millisOfSecond().isSupported(), DateTimeFieldType.millisOfSecond().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DateTimeFieldType.millisOfSecond()); } public void test_other() throws Exception { assertEquals(1, DateTimeFieldType.class.getDeclaredClasses().length); Class cls = DateTimeFieldType.class.getDeclaredClasses()[0]; assertEquals(1, cls.getDeclaredConstructors().length); Constructor con = cls.getDeclaredConstructors()[0]; Object[] params = new Object[] { "other", new Byte((byte) 128), DurationFieldType.hours(), DurationFieldType.months()}; con.setAccessible(true); // for Apache Harmony JVM DateTimeFieldType type = (DateTimeFieldType) con.newInstance(params); assertEquals("other", type.getName()); assertSame(DurationFieldType.hours(), type.getDurationType()); assertSame(DurationFieldType.months(), type.getRangeDurationType()); try { type.getField(CopticChronology.getInstanceUTC()); fail(); } catch (InternalError ex) {} DateTimeFieldType result = doSerialization(type); assertEquals(type.getName(), result.getName()); assertNotSame(type, result); } //----------------------------------------------------------------------- private void assertSerialization(DateTimeFieldType type) throws Exception { DateTimeFieldType result = doSerialization(type); assertSame(type, result); } private DateTimeFieldType doSerialization(DateTimeFieldType type) throws Exception { ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(type); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); DateTimeFieldType result = (DateTimeFieldType) ois.readObject(); ois.close(); return result; } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.lang.reflect.Modifier; import java.security.AllPermission; import java.security.CodeSource; import java.security.Permission; import java.security.PermissionCollection; import java.security.Permissions; import java.security.Policy; import java.security.ProtectionDomain; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.DateTimeUtils.MillisProvider; import org.joda.time.base.AbstractInstant; import org.joda.time.chrono.BuddhistChronology; import org.joda.time.chrono.CopticChronology; import org.joda.time.chrono.GJChronology; import org.joda.time.chrono.ISOChronology; import org.joda.time.chrono.JulianChronology; /** * This class is a Junit unit test for DateTimeUtils. * * @author Stephen Colebourne */ public class TestDateTimeUtils extends TestCase { private static final GJChronology GJ = GJChronology.getInstance(); private static final boolean OLD_JDK; static { String str = System.getProperty("java.version"); boolean old = true; if (str.length() > 3 && str.charAt(0) == '1' && str.charAt(1) == '.' && (str.charAt(2) == '4' || str.charAt(2) == '5' || str.charAt(2) == '6')) { old = false; } OLD_JDK = old; } // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; // 2002-04-05 private long TEST_TIME1 = (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; // 2003-05-06 private long TEST_TIME2 = (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private static final Policy RESTRICT; private static final Policy ALLOW; static { // don't call Policy.getPolicy() RESTRICT = new Policy() { public PermissionCollection getPermissions(CodeSource codesource) { Permissions p = new Permissions(); p.add(new AllPermission()); // enable everything return p; } public void refresh() { } public boolean implies(ProtectionDomain domain, Permission permission) { if (permission instanceof JodaTimePermission) { return false; } return true; // return super.implies(domain, permission); } }; ALLOW = new Policy() { public PermissionCollection getPermissions(CodeSource codesource) { Permissions p = new Permissions(); p.add(new AllPermission()); // enable everything return p; } public void refresh() { } }; } public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestDateTimeUtils.class); } public TestDateTimeUtils(String name) { super(name); } protected void setUp() throws Exception { } protected void tearDown() throws Exception { } //----------------------------------------------------------------------- public void testTest() { assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString()); assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString()); assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString()); } //----------------------------------------------------------------------- public void testClass() { Class<?> cls = DateTimeUtils.class; assertEquals(true, Modifier.isPublic(cls.getModifiers())); assertEquals(false, Modifier.isFinal(cls.getModifiers())); assertEquals(1, cls.getDeclaredConstructors().length); assertEquals(true, Modifier.isProtected(cls.getDeclaredConstructors()[0].getModifiers())); new DateTimeUtils() {}; } //----------------------------------------------------------------------- public void testSystemMillis() { long nowSystem = System.currentTimeMillis(); long now = DateTimeUtils.currentTimeMillis(); assertTrue((now >= nowSystem)); assertTrue((now - nowSystem) < 10000L); } //----------------------------------------------------------------------- public void testSystemMillisSecurity() { if (OLD_JDK) { return; } try { try { Policy.setPolicy(RESTRICT); System.setSecurityManager(new SecurityManager()); DateTimeUtils.setCurrentMillisSystem(); fail(); } catch (SecurityException ex) { // ok } finally { System.setSecurityManager(null); Policy.setPolicy(ALLOW); } } finally { DateTimeUtils.setCurrentMillisSystem(); } } //----------------------------------------------------------------------- public void testFixedMillis() { try { DateTimeUtils.setCurrentMillisFixed(0L); assertEquals(0L, DateTimeUtils.currentTimeMillis()); assertEquals(0L, DateTimeUtils.currentTimeMillis()); assertEquals(0L, DateTimeUtils.currentTimeMillis()); } finally { DateTimeUtils.setCurrentMillisSystem(); } long nowSystem = System.currentTimeMillis(); long now = DateTimeUtils.currentTimeMillis(); assertTrue((now >= nowSystem)); assertTrue((now - nowSystem) < 10000L); } //----------------------------------------------------------------------- public void testFixedMillisSecurity() { if (OLD_JDK) { return; } try { try { Policy.setPolicy(RESTRICT); System.setSecurityManager(new SecurityManager()); DateTimeUtils.setCurrentMillisFixed(0L); fail(); } catch (SecurityException ex) { // ok } finally { System.setSecurityManager(null); Policy.setPolicy(ALLOW); } } finally { DateTimeUtils.setCurrentMillisSystem(); } } //----------------------------------------------------------------------- public void testOffsetMillis() { try { // set time to one day ago DateTimeUtils.setCurrentMillisOffset(-24 * 60 * 60 * 1000); long nowSystem = System.currentTimeMillis(); long now = DateTimeUtils.currentTimeMillis(); long nowAdjustDay = now + (24 * 60 * 60 * 1000); assertTrue((now < nowSystem)); assertTrue((nowAdjustDay >= nowSystem)); assertTrue((nowAdjustDay - nowSystem) < 10000L); } finally { DateTimeUtils.setCurrentMillisSystem(); } long nowSystem = System.currentTimeMillis(); long now = DateTimeUtils.currentTimeMillis(); assertTrue((now >= nowSystem)); assertTrue((now - nowSystem) < 10000L); } //----------------------------------------------------------------------- public void testOffsetMillisToZero() { long now1 = 0L; try { // set time to one day ago DateTimeUtils.setCurrentMillisOffset(0); now1 = DateTimeUtils.currentTimeMillis(); } finally { DateTimeUtils.setCurrentMillisSystem(); } long now2 = DateTimeUtils.currentTimeMillis(); assertEquals(now1, now2); } //----------------------------------------------------------------------- public void testOffsetMillisSecurity() { if (OLD_JDK) { return; } try { try { Policy.setPolicy(RESTRICT); System.setSecurityManager(new SecurityManager()); DateTimeUtils.setCurrentMillisOffset(-24 * 60 * 60 * 1000); fail(); } catch (SecurityException ex) { // ok } finally { System.setSecurityManager(null); Policy.setPolicy(ALLOW); } } finally { DateTimeUtils.setCurrentMillisSystem(); } } //----------------------------------------------------------------------- public void testMillisProvider() { try { DateTimeUtils.setCurrentMillisProvider(new MillisProvider() { public long getMillis() { return 1L; } }); assertEquals(1L, DateTimeUtils.currentTimeMillis()); } finally { DateTimeUtils.setCurrentMillisSystem(); } } public void testMillisProvider_null() { try { DateTimeUtils.setCurrentMillisProvider(null); } catch (IllegalArgumentException ex) { // expected } } //----------------------------------------------------------------------- public void testMillisProviderSecurity() { if (OLD_JDK) { return; } try { try { Policy.setPolicy(RESTRICT); System.setSecurityManager(new SecurityManager()); DateTimeUtils.setCurrentMillisProvider(new MillisProvider() { public long getMillis() { return 0L; } }); fail(); } catch (SecurityException ex) { // ok } finally { System.setSecurityManager(null); Policy.setPolicy(ALLOW); } } finally { DateTimeUtils.setCurrentMillisSystem(); } } //----------------------------------------------------------------------- public void testGetInstantMillis_RI() { Instant i = new Instant(123L); assertEquals(123L, DateTimeUtils.getInstantMillis(i)); try { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); assertEquals(TEST_TIME_NOW, DateTimeUtils.getInstantMillis(null)); } finally { DateTimeUtils.setCurrentMillisSystem(); } } //----------------------------------------------------------------------- public void testGetInstantChronology_RI() { DateTime dt = new DateTime(123L, BuddhistChronology.getInstance()); assertEquals(BuddhistChronology.getInstance(), DateTimeUtils.getInstantChronology(dt)); Instant i = new Instant(123L); assertEquals(ISOChronology.getInstanceUTC(), DateTimeUtils.getInstantChronology(i)); AbstractInstant ai = new AbstractInstant() { public long getMillis() { return 0L; } public Chronology getChronology() { return null; // testing for this } }; assertEquals(ISOChronology.getInstance(), DateTimeUtils.getInstantChronology(ai)); assertEquals(ISOChronology.getInstance(), DateTimeUtils.getInstantChronology(null)); } //----------------------------------------------------------------------- public void testGetIntervalChronology_RInterval() { Interval dt = new Interval(123L, 456L, BuddhistChronology.getInstance()); assertEquals(BuddhistChronology.getInstance(), DateTimeUtils.getIntervalChronology(dt)); assertEquals(ISOChronology.getInstance(), DateTimeUtils.getIntervalChronology(null)); MutableInterval ai = new MutableInterval() { private static final long serialVersionUID = 1L; public Chronology getChronology() { return null; // testing for this } }; assertEquals(ISOChronology.getInstance(), DateTimeUtils.getIntervalChronology(ai)); } //----------------------------------------------------------------------- public void testGetIntervalChronology_RI_RI() { DateTime dt1 = new DateTime(123L, BuddhistChronology.getInstance()); DateTime dt2 = new DateTime(123L, CopticChronology.getInstance()); assertEquals(BuddhistChronology.getInstance(), DateTimeUtils.getIntervalChronology(dt1, dt2)); assertEquals(BuddhistChronology.getInstance(), DateTimeUtils.getIntervalChronology(dt1, null)); assertEquals(CopticChronology.getInstance(), DateTimeUtils.getIntervalChronology(null, dt2)); assertEquals(ISOChronology.getInstance(), DateTimeUtils.getIntervalChronology(null, null)); } //----------------------------------------------------------------------- public void testGetReadableInterval_ReadableInterval() { ReadableInterval input = new Interval(0, 100L); assertEquals(input, DateTimeUtils.getReadableInterval(input)); try { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); assertEquals(new Interval(TEST_TIME_NOW, TEST_TIME_NOW), DateTimeUtils.getReadableInterval(null)); } finally { DateTimeUtils.setCurrentMillisSystem(); } } //----------------------------------------------------------------------- public void testGetChronology_Chronology() { assertEquals(BuddhistChronology.getInstance(), DateTimeUtils.getChronology(BuddhistChronology.getInstance())); assertEquals(ISOChronology.getInstance(), DateTimeUtils.getChronology(null)); } //----------------------------------------------------------------------- public void testGetZone_Zone() { assertEquals(PARIS, DateTimeUtils.getZone(PARIS)); assertEquals(DateTimeZone.getDefault(), DateTimeUtils.getZone(null)); } //----------------------------------------------------------------------- public void testGetPeriodType_PeriodType() { assertEquals(PeriodType.dayTime(), DateTimeUtils.getPeriodType(PeriodType.dayTime())); assertEquals(PeriodType.standard(), DateTimeUtils.getPeriodType(null)); } //----------------------------------------------------------------------- public void testGetDurationMillis_RI() { Duration dur = new Duration(123L); assertEquals(123L, DateTimeUtils.getDurationMillis(dur)); assertEquals(0L, DateTimeUtils.getDurationMillis(null)); } //----------------------------------------------------------------------- @SuppressWarnings("deprecation") public void testIsContiguous_RP() { YearMonthDay ymd = new YearMonthDay(2005, 6, 9); assertEquals(true, DateTimeUtils.isContiguous(ymd)); TimeOfDay tod = new TimeOfDay(12, 20, 30, 0); assertEquals(true, DateTimeUtils.isContiguous(tod)); Partial year = new Partial(DateTimeFieldType.year(), 2005); assertEquals(true, DateTimeUtils.isContiguous(year)); Partial hourOfDay = new Partial(DateTimeFieldType.hourOfDay(), 12); assertEquals(true, DateTimeUtils.isContiguous(hourOfDay)); Partial yearHour = year.with(DateTimeFieldType.hourOfDay(), 12); assertEquals(false, DateTimeUtils.isContiguous(yearHour)); Partial ymdd = new Partial(ymd).with(DateTimeFieldType.dayOfWeek(), 2); assertEquals(false, DateTimeUtils.isContiguous(ymdd)); Partial dd = new Partial(DateTimeFieldType.dayOfMonth(), 13).with(DateTimeFieldType.dayOfWeek(), 5); assertEquals(false, DateTimeUtils.isContiguous(dd)); try { DateTimeUtils.isContiguous((ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- @SuppressWarnings("deprecation") public void testIsContiguous_RP_GJChronology() { YearMonthDay ymd = new YearMonthDay(2005, 6, 9, GJ); assertEquals(true, DateTimeUtils.isContiguous(ymd)); TimeOfDay tod = new TimeOfDay(12, 20, 30, 0, GJ); assertEquals(true, DateTimeUtils.isContiguous(tod)); Partial year = new Partial(DateTimeFieldType.year(), 2005, GJ); assertEquals(true, DateTimeUtils.isContiguous(year)); Partial hourOfDay = new Partial(DateTimeFieldType.hourOfDay(), 12, GJ); assertEquals(true, DateTimeUtils.isContiguous(hourOfDay)); Partial yearHour = year.with(DateTimeFieldType.hourOfDay(), 12); assertEquals(false, DateTimeUtils.isContiguous(yearHour)); Partial ymdd = new Partial(ymd).with(DateTimeFieldType.dayOfWeek(), 2); assertEquals(false, DateTimeUtils.isContiguous(ymdd)); Partial dd = new Partial(DateTimeFieldType.dayOfMonth(), 13).with(DateTimeFieldType.dayOfWeek(), 5); assertEquals(false, DateTimeUtils.isContiguous(dd)); try { DateTimeUtils.isContiguous((ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void test_julianDay() { DateTime base = new DateTime(1970, 1, 1, 0, 0, DateTimeZone.UTC); assertEquals(2440587.5d, DateTimeUtils.toJulianDay(base.getMillis()), 0.0001d); assertEquals(2440588, DateTimeUtils.toJulianDayNumber(base.getMillis())); assertEquals(base.getMillis(), DateTimeUtils.fromJulianDay(2440587.5d)); base = base.plusHours(6); assertEquals(2440587.75d, DateTimeUtils.toJulianDay(base.getMillis()), 0.0001d); assertEquals(2440588, DateTimeUtils.toJulianDayNumber(base.getMillis())); assertEquals(base.getMillis(), DateTimeUtils.fromJulianDay(2440587.75d)); base = base.plusHours(6); assertEquals(2440588d, DateTimeUtils.toJulianDay(base.getMillis()), 0.0001d); assertEquals(2440588, DateTimeUtils.toJulianDayNumber(base.getMillis())); assertEquals(base.getMillis(), DateTimeUtils.fromJulianDay(2440588d)); base = base.plusHours(6); assertEquals(2440588.25d, DateTimeUtils.toJulianDay(base.getMillis()), 0.0001d); assertEquals(2440588, DateTimeUtils.toJulianDayNumber(base.getMillis())); assertEquals(base.getMillis(), DateTimeUtils.fromJulianDay(2440588.25d)); base = base.plusHours(6); assertEquals(2440588.5d, DateTimeUtils.toJulianDay(base.getMillis()), 0.0001d); assertEquals(2440589, DateTimeUtils.toJulianDayNumber(base.getMillis())); assertEquals(base.getMillis(), DateTimeUtils.fromJulianDay(2440588.5d)); base = new DateTime(2012, 8, 31, 23, 50, DateTimeZone.UTC); assertEquals(2456171.4930555555, DateTimeUtils.toJulianDay(base.getMillis()), 0.0001d); assertEquals(2456171, DateTimeUtils.toJulianDayNumber(base.getMillis())); base = new DateTime(-4713, 1, 1, 12, 0, JulianChronology.getInstanceUTC()); assertEquals(0d, DateTimeUtils.toJulianDay(base.getMillis()), 0.0001d); assertEquals(0, DateTimeUtils.toJulianDayNumber(base.getMillis())); assertEquals(base.getMillis(), DateTimeUtils.fromJulianDay(0d)); base = new DateTime(-4713, 1, 1, 0, 0, JulianChronology.getInstanceUTC()); assertEquals(-0.5d, DateTimeUtils.toJulianDay(base.getMillis()), 0.0001d); assertEquals(0, DateTimeUtils.toJulianDayNumber(base.getMillis())); assertEquals(base.getMillis(), DateTimeUtils.fromJulianDay(-0.5d)); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.PrintStream; import java.lang.reflect.Modifier; import java.security.AllPermission; import java.security.CodeSource; import java.security.Permission; import java.security.PermissionCollection; import java.security.Permissions; import java.security.Policy; import java.security.ProtectionDomain; import java.text.DateFormatSymbols; import java.util.HashSet; import java.util.LinkedHashMap; import java.util.Locale; import java.util.Map; import java.util.Set; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.tz.DefaultNameProvider; import org.joda.time.tz.NameProvider; import org.joda.time.tz.Provider; import org.joda.time.tz.UTCProvider; import org.joda.time.tz.ZoneInfoProvider; /** * This class is a JUnit test for DateTimeZone. * * @author Stephen Colebourne */ public class TestDateTimeZone extends TestCase { private static final boolean OLD_JDK; static { String str = System.getProperty("java.version"); boolean old = true; if (str.length() > 3 && str.charAt(0) == '1' && str.charAt(1) == '.' && (str.charAt(2) == '4' || str.charAt(2) == '5' || str.charAt(2) == '6')) { old = false; } OLD_JDK = old; } // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365; // 2002-06-09 private long TEST_TIME_SUMMER = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; // 2002-01-09 private long TEST_TIME_WINTER = (y2002days + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; // // 2002-04-05 Fri // private long TEST_TIME1 = // (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY // + 12L * DateTimeConstants.MILLIS_PER_HOUR // + 24L * DateTimeConstants.MILLIS_PER_MINUTE; // // // 2003-05-06 Tue // private long TEST_TIME2 = // (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY // + 14L * DateTimeConstants.MILLIS_PER_HOUR // + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private static final Policy RESTRICT; private static final Policy ALLOW; static { // don't call Policy.getPolicy() RESTRICT = new Policy() { public PermissionCollection getPermissions(CodeSource codesource) { Permissions p = new Permissions(); p.add(new AllPermission()); // enable everything return p; } public void refresh() { } public boolean implies(ProtectionDomain domain, Permission permission) { if (permission instanceof JodaTimePermission) { return false; } return true; // return super.implies(domain, permission); } }; ALLOW = new Policy() { public PermissionCollection getPermissions(CodeSource codesource) { Permissions p = new Permissions(); p.add(new AllPermission()); // enable everything return p; } public void refresh() { } }; } private DateTimeZone zone; private Locale locale; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestDateTimeZone.class); } public TestDateTimeZone(String name) { super(name); } protected void setUp() throws Exception { locale = Locale.getDefault(); zone = DateTimeZone.getDefault(); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { Locale.setDefault(locale); DateTimeZone.setDefault(zone); } //----------------------------------------------------------------------- public void testDefault() { assertNotNull(DateTimeZone.getDefault()); DateTimeZone.setDefault(PARIS); assertSame(PARIS, DateTimeZone.getDefault()); try { DateTimeZone.setDefault(null); fail(); } catch (IllegalArgumentException ex) {} } public void testDefaultSecurity() { if (OLD_JDK) { return; } try { Policy.setPolicy(RESTRICT); System.setSecurityManager(new SecurityManager()); DateTimeZone.setDefault(PARIS); fail(); } catch (SecurityException ex) { // ok } finally { System.setSecurityManager(null); Policy.setPolicy(ALLOW); } } //----------------------------------------------------------------------- public void testForID_String() { assertEquals(DateTimeZone.getDefault(), DateTimeZone.forID((String) null)); DateTimeZone zone = DateTimeZone.forID("Europe/London"); assertEquals("Europe/London", zone.getID()); zone = DateTimeZone.forID("UTC"); assertSame(DateTimeZone.UTC, zone); zone = DateTimeZone.forID("+00:00"); assertSame(DateTimeZone.UTC, zone); zone = DateTimeZone.forID("+00"); assertSame(DateTimeZone.UTC, zone); zone = DateTimeZone.forID("+01:23"); assertEquals("+01:23", zone.getID()); assertEquals(DateTimeConstants.MILLIS_PER_HOUR + (23L * DateTimeConstants.MILLIS_PER_MINUTE), zone.getOffset(TEST_TIME_SUMMER)); zone = DateTimeZone.forID("-02:00"); assertEquals("-02:00", zone.getID()); assertEquals((-2L * DateTimeConstants.MILLIS_PER_HOUR), zone.getOffset(TEST_TIME_SUMMER)); zone = DateTimeZone.forID("-07:05:34.0"); assertEquals("-07:05:34", zone.getID()); assertEquals((-7L * DateTimeConstants.MILLIS_PER_HOUR) + (-5L * DateTimeConstants.MILLIS_PER_MINUTE) + (-34L * DateTimeConstants.MILLIS_PER_SECOND), zone.getOffset(TEST_TIME_SUMMER)); try { DateTimeZone.forID("SST"); fail(); } catch (IllegalArgumentException ex) {} try { DateTimeZone.forID("europe/london"); fail(); } catch (IllegalArgumentException ex) {} try { DateTimeZone.forID("Europe/UK"); fail(); } catch (IllegalArgumentException ex) {} try { DateTimeZone.forID("+"); fail(); } catch (IllegalArgumentException ex) {} try { DateTimeZone.forID("+0"); fail(); } catch (IllegalArgumentException ex) {} } public void testForID_String_old() { Map<String, String> map = new LinkedHashMap<String, String>(); map.put("GMT", "UTC"); map.put("WET", "WET"); map.put("CET", "CET"); map.put("MET", "CET"); map.put("ECT", "CET"); map.put("EET", "EET"); map.put("MIT", "Pacific/Apia"); map.put("HST", "Pacific/Honolulu"); map.put("AST", "America/Anchorage"); map.put("PST", "America/Los_Angeles"); map.put("MST", "America/Denver"); map.put("PNT", "America/Phoenix"); map.put("CST", "America/Chicago"); map.put("EST", "America/New_York"); map.put("IET", "America/Indiana/Indianapolis"); map.put("PRT", "America/Puerto_Rico"); map.put("CNT", "America/St_Johns"); map.put("AGT", "America/Argentina/Buenos_Aires"); map.put("BET", "America/Sao_Paulo"); map.put("ART", "Africa/Cairo"); map.put("CAT", "Africa/Harare"); map.put("EAT", "Africa/Addis_Ababa"); map.put("NET", "Asia/Yerevan"); map.put("PLT", "Asia/Karachi"); map.put("IST", "Asia/Kolkata"); map.put("BST", "Asia/Dhaka"); map.put("VST", "Asia/Ho_Chi_Minh"); map.put("CTT", "Asia/Shanghai"); map.put("JST", "Asia/Tokyo"); map.put("ACT", "Australia/Darwin"); map.put("AET", "Australia/Sydney"); map.put("SST", "Pacific/Guadalcanal"); map.put("NST", "Pacific/Auckland"); for (String key : map.keySet()) { String value = map.get(key); TimeZone juZone = TimeZone.getTimeZone(key); DateTimeZone zone = DateTimeZone.forTimeZone(juZone); assertEquals(value, zone.getID()); // System.out.println(juZone); // System.out.println(juZone.getDisplayName()); // System.out.println(zone); // System.out.println("------"); } } //----------------------------------------------------------------------- public void testForOffsetHours_int() { assertEquals(DateTimeZone.UTC, DateTimeZone.forOffsetHours(0)); assertEquals(DateTimeZone.forID("+03:00"), DateTimeZone.forOffsetHours(3)); assertEquals(DateTimeZone.forID("-02:00"), DateTimeZone.forOffsetHours(-2)); try { DateTimeZone.forOffsetHours(999999); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testForOffsetHoursMinutes_int_int() { assertEquals(DateTimeZone.UTC, DateTimeZone.forOffsetHoursMinutes(0, 0)); assertEquals(DateTimeZone.forID("+23:59"), DateTimeZone.forOffsetHoursMinutes(23, 59)); assertEquals(DateTimeZone.forID("+02:15"), DateTimeZone.forOffsetHoursMinutes(2, 15)); assertEquals(DateTimeZone.forID("+02:00"), DateTimeZone.forOffsetHoursMinutes(2, 0)); try { DateTimeZone.forOffsetHoursMinutes(2, -15); fail(); } catch (IllegalArgumentException ex) {} assertEquals(DateTimeZone.forID("+00:15"), DateTimeZone.forOffsetHoursMinutes(0, 15)); assertEquals(DateTimeZone.forID("+00:00"), DateTimeZone.forOffsetHoursMinutes(0, 0)); assertEquals(DateTimeZone.forID("-00:15"), DateTimeZone.forOffsetHoursMinutes(0, -15)); assertEquals(DateTimeZone.forID("-02:00"), DateTimeZone.forOffsetHoursMinutes(-2, 0)); assertEquals(DateTimeZone.forID("-02:15"), DateTimeZone.forOffsetHoursMinutes(-2, -15)); assertEquals(DateTimeZone.forID("-02:15"), DateTimeZone.forOffsetHoursMinutes(-2, 15)); assertEquals(DateTimeZone.forID("-23:59"), DateTimeZone.forOffsetHoursMinutes(-23, 59)); try { DateTimeZone.forOffsetHoursMinutes(2, 60); fail(); } catch (IllegalArgumentException ex) {} try { DateTimeZone.forOffsetHoursMinutes(-2, 60); fail(); } catch (IllegalArgumentException ex) {} try { DateTimeZone.forOffsetHoursMinutes(24, 0); fail(); } catch (IllegalArgumentException ex) {} try { DateTimeZone.forOffsetHoursMinutes(-24, 0); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testForOffsetMillis_int() { assertSame(DateTimeZone.UTC, DateTimeZone.forOffsetMillis(0)); assertEquals(DateTimeZone.forID("+23:59:59.999"), DateTimeZone.forOffsetMillis((24 * 60 * 60 * 1000) - 1)); assertEquals(DateTimeZone.forID("+03:00"), DateTimeZone.forOffsetMillis(3 * 60 * 60 * 1000)); assertEquals(DateTimeZone.forID("-02:00"), DateTimeZone.forOffsetMillis(-2 * 60 * 60 * 1000)); assertEquals(DateTimeZone.forID("-23:59:59.999"), DateTimeZone.forOffsetMillis((-24 * 60 * 60 * 1000) + 1)); assertEquals(DateTimeZone.forID("+04:45:17.045"), DateTimeZone.forOffsetMillis( 4 * 60 * 60 * 1000 + 45 * 60 * 1000 + 17 * 1000 + 45)); } //----------------------------------------------------------------------- public void testForTimeZone_TimeZone() { assertEquals(DateTimeZone.getDefault(), DateTimeZone.forTimeZone((TimeZone) null)); DateTimeZone zone = DateTimeZone.forTimeZone(TimeZone.getTimeZone("Europe/London")); assertEquals("Europe/London", zone.getID()); assertSame(DateTimeZone.UTC, DateTimeZone.forTimeZone(TimeZone.getTimeZone("UTC"))); zone = DateTimeZone.forTimeZone(TimeZone.getTimeZone("+00:00")); assertSame(DateTimeZone.UTC, zone); zone = DateTimeZone.forTimeZone(TimeZone.getTimeZone("GMT+00:00")); assertSame(DateTimeZone.UTC, zone); zone = DateTimeZone.forTimeZone(TimeZone.getTimeZone("GMT+00:00")); assertSame(DateTimeZone.UTC, zone); zone = DateTimeZone.forTimeZone(TimeZone.getTimeZone("GMT+00")); assertSame(DateTimeZone.UTC, zone); zone = DateTimeZone.forTimeZone(TimeZone.getTimeZone("GMT+01:23")); assertEquals("+01:23", zone.getID()); assertEquals(DateTimeConstants.MILLIS_PER_HOUR + (23L * DateTimeConstants.MILLIS_PER_MINUTE), zone.getOffset(TEST_TIME_SUMMER)); zone = DateTimeZone.forTimeZone(TimeZone.getTimeZone("GMT+1:23")); assertEquals("+01:23", zone.getID()); assertEquals(DateTimeConstants.MILLIS_PER_HOUR + (23L * DateTimeConstants.MILLIS_PER_MINUTE), zone.getOffset(TEST_TIME_SUMMER)); zone = DateTimeZone.forTimeZone(TimeZone.getTimeZone("GMT-02:00")); assertEquals("-02:00", zone.getID()); assertEquals((-2L * DateTimeConstants.MILLIS_PER_HOUR), zone.getOffset(TEST_TIME_SUMMER)); zone = DateTimeZone.forTimeZone(TimeZone.getTimeZone("GMT+2")); assertEquals("+02:00", zone.getID()); assertEquals((2L * DateTimeConstants.MILLIS_PER_HOUR), zone.getOffset(TEST_TIME_SUMMER)); zone = DateTimeZone.forTimeZone(TimeZone.getTimeZone("EST")); assertEquals("America/New_York", zone.getID()); } public void testTimeZoneConversion() { TimeZone jdkTimeZone = TimeZone.getTimeZone("GMT-10"); assertEquals("GMT-10:00", jdkTimeZone.getID()); DateTimeZone jodaTimeZone = DateTimeZone.forTimeZone(jdkTimeZone); assertEquals("-10:00", jodaTimeZone.getID()); assertEquals(jdkTimeZone.getRawOffset(), jodaTimeZone.getOffset(0L)); TimeZone convertedTimeZone = jodaTimeZone.toTimeZone(); assertEquals("GMT-10:00", jdkTimeZone.getID()); assertEquals(jdkTimeZone.getID(), convertedTimeZone.getID()); assertEquals(jdkTimeZone.getRawOffset(), convertedTimeZone.getRawOffset()); } //----------------------------------------------------------------------- public void testGetAvailableIDs() { assertTrue(DateTimeZone.getAvailableIDs().contains("UTC")); } //----------------------------------------------------------------------- public void testProvider() { try { assertNotNull(DateTimeZone.getProvider()); Provider provider = DateTimeZone.getProvider(); DateTimeZone.setProvider(null); assertEquals(provider.getClass(), DateTimeZone.getProvider().getClass()); try { DateTimeZone.setProvider(new MockNullIDSProvider()); fail(); } catch (IllegalArgumentException ex) {} try { DateTimeZone.setProvider(new MockEmptyIDSProvider()); fail(); } catch (IllegalArgumentException ex) {} try { DateTimeZone.setProvider(new MockNoUTCProvider()); fail(); } catch (IllegalArgumentException ex) {} try { DateTimeZone.setProvider(new MockBadUTCProvider()); fail(); } catch (IllegalArgumentException ex) {} Provider prov = new MockOKProvider(); DateTimeZone.setProvider(prov); assertSame(prov, DateTimeZone.getProvider()); assertEquals(2, DateTimeZone.getAvailableIDs().size()); assertTrue(DateTimeZone.getAvailableIDs().contains("UTC")); assertTrue(DateTimeZone.getAvailableIDs().contains("Europe/London")); } finally { DateTimeZone.setProvider(null); assertEquals(ZoneInfoProvider.class, DateTimeZone.getProvider().getClass()); } try { System.setProperty("org.joda.time.DateTimeZone.Provider", "org.joda.time.tz.UTCProvider"); DateTimeZone.setProvider(null); assertEquals(UTCProvider.class, DateTimeZone.getProvider().getClass()); } finally { System.getProperties().remove("org.joda.time.DateTimeZone.Provider"); DateTimeZone.setProvider(null); assertEquals(ZoneInfoProvider.class, DateTimeZone.getProvider().getClass()); } } public void testProvider_badClassName() { try { System.setProperty("org.joda.time.DateTimeZone.Provider", "xxx"); DateTimeZone.setProvider(null); } catch (RuntimeException ex) { // expected assertEquals(ZoneInfoProvider.class, DateTimeZone.getProvider().getClass()); } finally { System.getProperties().remove("org.joda.time.DateTimeZone.Provider"); DateTimeZone.setProvider(null); } } public void testProviderSecurity() { if (OLD_JDK) { return; } try { Policy.setPolicy(RESTRICT); System.setSecurityManager(new SecurityManager()); DateTimeZone.setProvider(new MockOKProvider()); fail(); } catch (SecurityException ex) { // ok } finally { System.setSecurityManager(null); Policy.setPolicy(ALLOW); } } static class MockNullIDSProvider implements Provider { public Set getAvailableIDs() { return null; } public DateTimeZone getZone(String id) { return null; } } static class MockEmptyIDSProvider implements Provider { public Set getAvailableIDs() { return new HashSet(); } public DateTimeZone getZone(String id) { return null; } } static class MockNoUTCProvider implements Provider { public Set getAvailableIDs() { Set set = new HashSet(); set.add("Europe/London"); return set; } public DateTimeZone getZone(String id) { return null; } } static class MockBadUTCProvider implements Provider { public Set getAvailableIDs() { Set set = new HashSet(); set.add("UTC"); set.add("Europe/London"); return set; } public DateTimeZone getZone(String id) { return null; } } static class MockOKProvider implements Provider { public Set getAvailableIDs() { Set set = new HashSet(); set.add("UTC"); set.add("Europe/London"); return set; } public DateTimeZone getZone(String id) { return DateTimeZone.UTC; } } //----------------------------------------------------------------------- public void testNameProvider() { try { assertNotNull(DateTimeZone.getNameProvider()); NameProvider provider = DateTimeZone.getNameProvider(); DateTimeZone.setNameProvider(null); assertEquals(provider.getClass(), DateTimeZone.getNameProvider().getClass()); provider = new MockOKButNullNameProvider(); DateTimeZone.setNameProvider(provider); assertSame(provider, DateTimeZone.getNameProvider()); assertEquals("+00:00", DateTimeZone.UTC.getShortName(TEST_TIME_SUMMER)); assertEquals("+00:00", DateTimeZone.UTC.getName(TEST_TIME_SUMMER)); } finally { DateTimeZone.setNameProvider(null); } try { System.setProperty("org.joda.time.DateTimeZone.NameProvider", "org.joda.time.tz.DefaultNameProvider"); DateTimeZone.setNameProvider(null); assertEquals(DefaultNameProvider.class, DateTimeZone.getNameProvider().getClass()); } finally { System.getProperties().remove("org.joda.time.DateTimeZone.NameProvider"); DateTimeZone.setNameProvider(null); assertEquals(DefaultNameProvider.class, DateTimeZone.getNameProvider().getClass()); } } public void testNameProvider_badClassName() { try { System.setProperty("org.joda.time.DateTimeZone.NameProvider", "xxx"); DateTimeZone.setProvider(null); } catch (RuntimeException ex) { // expected assertEquals(DefaultNameProvider.class, DateTimeZone.getNameProvider().getClass()); } finally { System.getProperties().remove("org.joda.time.DateTimeZone.NameProvider"); DateTimeZone.setProvider(null); } } public void testNameProviderSecurity() { if (OLD_JDK) { return; } try { Policy.setPolicy(RESTRICT); System.setSecurityManager(new SecurityManager()); DateTimeZone.setNameProvider(new MockOKButNullNameProvider()); fail(); } catch (SecurityException ex) { // ok } finally { System.setSecurityManager(null); Policy.setPolicy(ALLOW); } } static class MockOKButNullNameProvider implements NameProvider { public String getShortName(Locale locale, String id, String nameKey) { return null; } public String getName(Locale locale, String id, String nameKey) { return null; } } //----------------------------------------------------------------------- public void testConstructor() { assertEquals(1, DateTimeZone.class.getDeclaredConstructors().length); assertTrue(Modifier.isProtected(DateTimeZone.class.getDeclaredConstructors()[0].getModifiers())); try { new DateTimeZone(null) { public String getNameKey(long instant) { return null; } public int getOffset(long instant) { return 0; } public int getStandardOffset(long instant) { return 0; } public boolean isFixed() { return false; } public long nextTransition(long instant) { return 0; } public long previousTransition(long instant) { return 0; } public boolean equals(Object object) { return false; } }; } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testGetID() { DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); assertEquals("Europe/Paris", zone.getID()); } public void testGetNameKey() { DateTimeZone zone = DateTimeZone.forID("Europe/London"); assertEquals("BST", zone.getNameKey(TEST_TIME_SUMMER)); assertEquals("GMT", zone.getNameKey(TEST_TIME_WINTER)); } static final boolean JDK6; static { boolean jdk6 = true; try { DateFormatSymbols.class.getMethod("getInstance", new Class[] {Locale.class}); } catch (Exception ex) { jdk6 = false; } JDK6 = jdk6; } public void testGetShortName() { DateTimeZone zone = DateTimeZone.forID("Europe/London"); assertEquals("BST", zone.getShortName(TEST_TIME_SUMMER)); assertEquals("GMT", zone.getShortName(TEST_TIME_WINTER)); assertEquals("BST", zone.getShortName(TEST_TIME_SUMMER, Locale.ENGLISH)); } public void testGetShortName_berlin() { DateTimeZone berlin = DateTimeZone.forID("Europe/Berlin"); assertEquals("CET", berlin.getShortName(TEST_TIME_WINTER, Locale.ENGLISH)); assertEquals("CEST", berlin.getShortName(TEST_TIME_SUMMER, Locale.ENGLISH)); if (JDK6) { assertEquals("MEZ", berlin.getShortName(TEST_TIME_WINTER, Locale.GERMAN)); assertEquals("MESZ", berlin.getShortName(TEST_TIME_SUMMER, Locale.GERMAN)); } else { assertEquals("CET", berlin.getShortName(TEST_TIME_WINTER, Locale.GERMAN)); assertEquals("CEST", berlin.getShortName(TEST_TIME_SUMMER, Locale.GERMAN)); } } public void testGetShortNameProviderName() { assertEquals(null, DateTimeZone.getNameProvider().getShortName(null, "Europe/London", "BST")); assertEquals(null, DateTimeZone.getNameProvider().getShortName(Locale.ENGLISH, null, "BST")); assertEquals(null, DateTimeZone.getNameProvider().getShortName(Locale.ENGLISH, "Europe/London", null)); assertEquals(null, DateTimeZone.getNameProvider().getShortName(null, null, null)); } public void testGetShortNameNullKey() { DateTimeZone zone = new MockDateTimeZone("Europe/London"); assertEquals("Europe/London", zone.getShortName(TEST_TIME_SUMMER, Locale.ENGLISH)); } public void testGetName() { DateTimeZone zone = DateTimeZone.forID("Europe/London"); assertEquals("British Summer Time", zone.getName(TEST_TIME_SUMMER)); assertEquals("Greenwich Mean Time", zone.getName(TEST_TIME_WINTER)); assertEquals("British Summer Time", zone.getName(TEST_TIME_SUMMER, Locale.ENGLISH)); } public void testGetName_berlin() { DateTimeZone berlin = DateTimeZone.forID("Europe/Berlin"); assertEquals("Central European Time", berlin.getName(TEST_TIME_WINTER, Locale.ENGLISH)); assertEquals("Central European Summer Time", berlin.getName(TEST_TIME_SUMMER, Locale.ENGLISH)); if (JDK6) { assertEquals("Mitteleurop\u00e4ische Zeit", berlin.getName(TEST_TIME_WINTER, Locale.GERMAN)); assertEquals("Mitteleurop\u00e4ische Sommerzeit", berlin.getName(TEST_TIME_SUMMER, Locale.GERMAN)); } else { assertEquals("Zentraleurop\u00e4ische Zeit", berlin.getName(TEST_TIME_WINTER, Locale.GERMAN)); assertEquals("Zentraleurop\u00e4ische Sommerzeit", berlin.getName(TEST_TIME_SUMMER, Locale.GERMAN)); } } public void testGetNameProviderName() { assertEquals(null, DateTimeZone.getNameProvider().getName(null, "Europe/London", "BST")); assertEquals(null, DateTimeZone.getNameProvider().getName(Locale.ENGLISH, null, "BST")); assertEquals(null, DateTimeZone.getNameProvider().getName(Locale.ENGLISH, "Europe/London", null)); assertEquals(null, DateTimeZone.getNameProvider().getName(null, null, null)); } public void testGetNameNullKey() { DateTimeZone zone = new MockDateTimeZone("Europe/London"); assertEquals("Europe/London", zone.getName(TEST_TIME_SUMMER, Locale.ENGLISH)); } static class MockDateTimeZone extends DateTimeZone { public MockDateTimeZone(String id) { super(id); } public String getNameKey(long instant) { return null; // null } public int getOffset(long instant) { return 0; } public int getStandardOffset(long instant) { return 0; } public boolean isFixed() { return false; } public long nextTransition(long instant) { return 0; } public long previousTransition(long instant) { return 0; } public boolean equals(Object object) { return false; } } //----------------------------------------------------------------------- public void testGetOffset_long() { DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); assertEquals(2L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(TEST_TIME_SUMMER)); assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(TEST_TIME_WINTER)); assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getStandardOffset(TEST_TIME_SUMMER)); assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getStandardOffset(TEST_TIME_WINTER)); assertEquals(2L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffsetFromLocal(TEST_TIME_SUMMER)); assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffsetFromLocal(TEST_TIME_WINTER)); assertEquals(false, zone.isStandardOffset(TEST_TIME_SUMMER)); assertEquals(true, zone.isStandardOffset(TEST_TIME_WINTER)); } public void testGetOffset_RI() { DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); assertEquals(2L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(new Instant(TEST_TIME_SUMMER))); assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(new Instant(TEST_TIME_WINTER))); assertEquals(zone.getOffset(DateTimeUtils.currentTimeMillis()), zone.getOffset(null)); } public void testGetOffsetFixed() { DateTimeZone zone = DateTimeZone.forID("+01:00"); assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(TEST_TIME_SUMMER)); assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(TEST_TIME_WINTER)); assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getStandardOffset(TEST_TIME_SUMMER)); assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getStandardOffset(TEST_TIME_WINTER)); assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffsetFromLocal(TEST_TIME_SUMMER)); assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffsetFromLocal(TEST_TIME_WINTER)); assertEquals(true, zone.isStandardOffset(TEST_TIME_SUMMER)); assertEquals(true, zone.isStandardOffset(TEST_TIME_WINTER)); } public void testGetOffsetFixed_RI() { DateTimeZone zone = DateTimeZone.forID("+01:00"); assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(new Instant(TEST_TIME_SUMMER))); assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(new Instant(TEST_TIME_WINTER))); assertEquals(zone.getOffset(DateTimeUtils.currentTimeMillis()), zone.getOffset(null)); } //----------------------------------------------------------------------- public void testGetMillisKeepLocal() { long millisLondon = TEST_TIME_SUMMER; long millisParis = TEST_TIME_SUMMER - 1L * DateTimeConstants.MILLIS_PER_HOUR; assertEquals(millisLondon, LONDON.getMillisKeepLocal(LONDON, millisLondon)); assertEquals(millisParis, LONDON.getMillisKeepLocal(LONDON, millisParis)); assertEquals(millisLondon, PARIS.getMillisKeepLocal(PARIS, millisLondon)); assertEquals(millisParis, PARIS.getMillisKeepLocal(PARIS, millisParis)); assertEquals(millisParis, LONDON.getMillisKeepLocal(PARIS, millisLondon)); assertEquals(millisLondon, PARIS.getMillisKeepLocal(LONDON, millisParis)); DateTimeZone zone = DateTimeZone.getDefault(); try { DateTimeZone.setDefault(LONDON); assertEquals(millisLondon, PARIS.getMillisKeepLocal(null, millisParis)); } finally { DateTimeZone.setDefault(zone); } } //----------------------------------------------------------------------- public void testIsFixed() { DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); assertEquals(false, zone.isFixed()); assertEquals(true, DateTimeZone.UTC.isFixed()); } //----------------------------------------------------------------------- public void testTransitionFixed() { DateTimeZone zone = DateTimeZone.forID("+01:00"); assertEquals(TEST_TIME_SUMMER, zone.nextTransition(TEST_TIME_SUMMER)); assertEquals(TEST_TIME_WINTER, zone.nextTransition(TEST_TIME_WINTER)); assertEquals(TEST_TIME_SUMMER, zone.previousTransition(TEST_TIME_SUMMER)); assertEquals(TEST_TIME_WINTER, zone.previousTransition(TEST_TIME_WINTER)); } // //----------------------------------------------------------------------- // public void testIsLocalDateTimeOverlap_Berlin() { // DateTimeZone zone = DateTimeZone.forID("Europe/Berlin"); // assertEquals(false, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 10, 28, 1, 0))); // assertEquals(false, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 10, 28, 1, 59, 59, 99))); // assertEquals(true, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 10, 28, 2, 0))); // assertEquals(true, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 10, 28, 2, 30))); // assertEquals(true, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 10, 28, 2, 59, 59, 99))); // assertEquals(false, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 10, 28, 3, 0))); // assertEquals(false, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 10, 28, 4, 0))); // // assertEquals(false, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 3, 25, 1, 30))); // before gap // assertEquals(false, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 3, 25, 2, 30))); // gap // assertEquals(false, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 3, 25, 3, 30))); // after gap // assertEquals(false, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 12, 24, 12, 34))); // } // // //----------------------------------------------------------------------- // public void testIsLocalDateTimeOverlap_NewYork() { // DateTimeZone zone = DateTimeZone.forID("America/New_York"); // assertEquals(false, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 11, 4, 0, 0))); // assertEquals(false, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 11, 4, 0, 59, 59, 99))); // assertEquals(true, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 11, 4, 1, 0))); // assertEquals(true, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 11, 4, 1, 30))); // assertEquals(true, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 11, 4, 1, 59, 59, 99))); // assertEquals(false, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 11, 4, 2, 0))); // assertEquals(false, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 11, 4, 3, 0))); // // assertEquals(false, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 3, 11, 1, 30))); // before gap // assertEquals(false, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 3, 11, 2, 30))); // gap // assertEquals(false, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 3, 11, 3, 30))); // after gap // assertEquals(false, zone.isLocalDateTimeOverlap(new LocalDateTime(2007, 12, 24, 12, 34))); // } //----------------------------------------------------------------------- public void testIsLocalDateTimeGap_Berlin() { DateTimeZone zone = DateTimeZone.forID("Europe/Berlin"); assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 25, 1, 0))); assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 25, 1, 59, 59, 99))); assertEquals(true, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 25, 2, 0))); assertEquals(true, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 25, 2, 30))); assertEquals(true, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 25, 2, 59, 59, 99))); assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 25, 3, 0))); assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 25, 4, 0))); assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 10, 28, 1, 30))); // before overlap assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 10, 28, 2, 30))); // overlap assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 10, 28, 3, 30))); // after overlap assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 12, 24, 12, 34))); } //----------------------------------------------------------------------- public void testIsLocalDateTimeGap_NewYork() { DateTimeZone zone = DateTimeZone.forID("America/New_York"); assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 11, 1, 0))); assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 11, 1, 59, 59, 99))); assertEquals(true, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 11, 2, 0))); assertEquals(true, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 11, 2, 30))); assertEquals(true, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 11, 2, 59, 59, 99))); assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 11, 3, 0))); assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 11, 4, 0))); assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 11, 4, 0, 30))); // before overlap assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 11, 4, 1, 30))); // overlap assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 11, 4, 2, 30))); // after overlap assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 12, 24, 12, 34))); } //----------------------------------------------------------------------- public void testToTimeZone() { DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); TimeZone tz = zone.toTimeZone(); assertEquals("Europe/Paris", tz.getID()); } //----------------------------------------------------------------------- public void testEqualsHashCode() { DateTimeZone zone1 = DateTimeZone.forID("Europe/Paris"); DateTimeZone zone2 = DateTimeZone.forID("Europe/Paris"); assertEquals(true, zone1.equals(zone1)); assertEquals(true, zone1.equals(zone2)); assertEquals(true, zone2.equals(zone1)); assertEquals(true, zone2.equals(zone2)); assertEquals(true, zone1.hashCode() == zone2.hashCode()); DateTimeZone zone3 = DateTimeZone.forID("Europe/London"); assertEquals(true, zone3.equals(zone3)); assertEquals(false, zone1.equals(zone3)); assertEquals(false, zone2.equals(zone3)); assertEquals(false, zone3.equals(zone1)); assertEquals(false, zone3.equals(zone2)); assertEquals(false, zone1.hashCode() == zone3.hashCode()); assertEquals(true, zone3.hashCode() == zone3.hashCode()); DateTimeZone zone4 = DateTimeZone.forID("+01:00"); assertEquals(true, zone4.equals(zone4)); assertEquals(false, zone1.equals(zone4)); assertEquals(false, zone2.equals(zone4)); assertEquals(false, zone3.equals(zone4)); assertEquals(false, zone4.equals(zone1)); assertEquals(false, zone4.equals(zone2)); assertEquals(false, zone4.equals(zone3)); assertEquals(false, zone1.hashCode() == zone4.hashCode()); assertEquals(true, zone4.hashCode() == zone4.hashCode()); DateTimeZone zone5 = DateTimeZone.forID("+02:00"); assertEquals(true, zone5.equals(zone5)); assertEquals(false, zone1.equals(zone5)); assertEquals(false, zone2.equals(zone5)); assertEquals(false, zone3.equals(zone5)); assertEquals(false, zone4.equals(zone5)); assertEquals(false, zone5.equals(zone1)); assertEquals(false, zone5.equals(zone2)); assertEquals(false, zone5.equals(zone3)); assertEquals(false, zone5.equals(zone4)); assertEquals(false, zone1.hashCode() == zone5.hashCode()); assertEquals(true, zone5.hashCode() == zone5.hashCode()); } //----------------------------------------------------------------------- public void testToString() { DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); assertEquals("Europe/Paris", zone.toString()); assertEquals("UTC", DateTimeZone.UTC.toString()); } //----------------------------------------------------------------------- public void testSerialization1() throws Exception { DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(zone); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); DateTimeZone result = (DateTimeZone) ois.readObject(); ois.close(); assertSame(zone, result); } //----------------------------------------------------------------------- public void testSerialization2() throws Exception { DateTimeZone zone = DateTimeZone.forID("+01:00"); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(zone); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); DateTimeZone result = (DateTimeZone) ois.readObject(); ois.close(); assertSame(zone, result); } public void testCommentParse() throws Exception { // A bug in ZoneInfoCompiler's handling of comments broke Europe/Athens // after 1980. This test is included to make sure it doesn't break again. DateTimeZone zone = DateTimeZone.forID("Europe/Athens"); DateTime dt = new DateTime(2005, 5, 5, 20, 10, 15, 0, zone); assertEquals(1115313015000L, dt.getMillis()); } public void testPatchedNameKeysLondon() throws Exception { // the tz database does not have unique name keys [1716305] DateTimeZone zone = DateTimeZone.forID("Europe/London"); DateTime now = new DateTime(2007, 1, 1, 0, 0, 0, 0); String str1 = zone.getName(now.getMillis()); String str2 = zone.getName(now.plusMonths(6).getMillis()); assertEquals(false, str1.equals(str2)); } public void testPatchedNameKeysSydney() throws Exception { // the tz database does not have unique name keys [1716305] DateTimeZone zone = DateTimeZone.forID("Australia/Sydney"); DateTime now = new DateTime(2007, 1, 1, 0, 0, 0, 0); String str1 = zone.getName(now.getMillis()); String str2 = zone.getName(now.plusMonths(6).getMillis()); assertEquals(false, str1.equals(str2)); } public void testPatchedNameKeysSydneyHistoric() throws Exception { // the tz database does not have unique name keys [1716305] DateTimeZone zone = DateTimeZone.forID("Australia/Sydney"); DateTime now = new DateTime(1996, 1, 1, 0, 0, 0, 0); String str1 = zone.getName(now.getMillis()); String str2 = zone.getName(now.plusMonths(6).getMillis()); assertEquals(false, str1.equals(str2)); } public void testPatchedNameKeysGazaHistoric() throws Exception { // the tz database does not have unique name keys [1716305] DateTimeZone zone = DateTimeZone.forID("Africa/Johannesburg"); DateTime now = new DateTime(1943, 1, 1, 0, 0, 0, 0); String str1 = zone.getName(now.getMillis()); String str2 = zone.getName(now.plusMonths(6).getMillis()); assertEquals(false, str1.equals(str2)); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.GregorianChronology; import org.joda.time.tz.DateTimeZoneBuilder; /** * This class is a JUnit test for DateTimeZone. * * @author Stephen Colebourne */ public class TestDateTimeZoneCutover extends TestCase { public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestDateTimeZoneCutover.class); } public TestDateTimeZoneCutover(String name) { super(name); } protected void setUp() throws Exception { } protected void tearDown() throws Exception { } //----------------------------------------------------------------------- //------------------------ Bug [1710316] -------------------------------- //----------------------------------------------------------------------- // The behaviour of getOffsetFromLocal is defined in its javadoc // However, this definition doesn't work for all DateTimeField operations /** Mock zone simulating Asia/Gaza cutover at midnight 2007-04-01 */ private static long CUTOVER_GAZA = 1175378400000L; private static int OFFSET_GAZA = 7200000; // +02:00 private static final DateTimeZone MOCK_GAZA = new MockZone(CUTOVER_GAZA, OFFSET_GAZA, 3600); //----------------------------------------------------------------------- public void test_MockGazaIsCorrect() { DateTime pre = new DateTime(CUTOVER_GAZA - 1L, MOCK_GAZA); assertEquals("2007-03-31T23:59:59.999+02:00", pre.toString()); DateTime at = new DateTime(CUTOVER_GAZA, MOCK_GAZA); assertEquals("2007-04-01T01:00:00.000+03:00", at.toString()); DateTime post = new DateTime(CUTOVER_GAZA + 1L, MOCK_GAZA); assertEquals("2007-04-01T01:00:00.001+03:00", post.toString()); } public void test_getOffsetFromLocal_Gaza() { doTest_getOffsetFromLocal_Gaza(-1, 23, 0, "2007-03-31T23:00:00.000+02:00"); doTest_getOffsetFromLocal_Gaza(-1, 23, 30, "2007-03-31T23:30:00.000+02:00"); doTest_getOffsetFromLocal_Gaza(0, 0, 0, "2007-04-01T01:00:00.000+03:00"); doTest_getOffsetFromLocal_Gaza(0, 0, 30, "2007-04-01T01:30:00.000+03:00"); doTest_getOffsetFromLocal_Gaza(0, 1, 0, "2007-04-01T01:00:00.000+03:00"); doTest_getOffsetFromLocal_Gaza(0, 1, 30, "2007-04-01T01:30:00.000+03:00"); doTest_getOffsetFromLocal_Gaza(0, 2, 0, "2007-04-01T02:00:00.000+03:00"); doTest_getOffsetFromLocal_Gaza(0, 3, 0, "2007-04-01T03:00:00.000+03:00"); doTest_getOffsetFromLocal_Gaza(0, 4, 0, "2007-04-01T04:00:00.000+03:00"); doTest_getOffsetFromLocal_Gaza(0, 5, 0, "2007-04-01T05:00:00.000+03:00"); doTest_getOffsetFromLocal_Gaza(0, 6, 0, "2007-04-01T06:00:00.000+03:00"); } private void doTest_getOffsetFromLocal_Gaza(int days, int hour, int min, String expected) { DateTime dt = new DateTime(2007, 4, 1, hour, min, 0, 0, DateTimeZone.UTC).plusDays(days); int offset = MOCK_GAZA.getOffsetFromLocal(dt.getMillis()); DateTime res = new DateTime(dt.getMillis() - offset, MOCK_GAZA); assertEquals(res.toString(), expected, res.toString()); } public void test_DateTime_roundFloor_Gaza() { DateTime dt = new DateTime(2007, 4, 1, 8, 0, 0, 0, MOCK_GAZA); assertEquals("2007-04-01T08:00:00.000+03:00", dt.toString()); DateTime rounded = dt.dayOfMonth().roundFloorCopy(); assertEquals("2007-04-01T01:00:00.000+03:00", rounded.toString()); } public void test_DateTime_roundCeiling_Gaza() { DateTime dt = new DateTime(2007, 3, 31, 20, 0, 0, 0, MOCK_GAZA); assertEquals("2007-03-31T20:00:00.000+02:00", dt.toString()); DateTime rounded = dt.dayOfMonth().roundCeilingCopy(); assertEquals("2007-04-01T01:00:00.000+03:00", rounded.toString()); } public void test_DateTime_setHourZero_Gaza() { DateTime dt = new DateTime(2007, 4, 1, 8, 0, 0, 0, MOCK_GAZA); assertEquals("2007-04-01T08:00:00.000+03:00", dt.toString()); try { dt.hourOfDay().setCopy(0); fail(); } catch (IllegalFieldValueException ex) { // expected } } public void test_DateTime_withHourZero_Gaza() { DateTime dt = new DateTime(2007, 4, 1, 8, 0, 0, 0, MOCK_GAZA); assertEquals("2007-04-01T08:00:00.000+03:00", dt.toString()); try { dt.withHourOfDay(0); fail(); } catch (IllegalFieldValueException ex) { // expected } } public void test_DateTime_withDay_Gaza() { DateTime dt = new DateTime(2007, 4, 2, 0, 0, 0, 0, MOCK_GAZA); assertEquals("2007-04-02T00:00:00.000+03:00", dt.toString()); DateTime res = dt.withDayOfMonth(1); assertEquals("2007-04-01T01:00:00.000+03:00", res.toString()); } public void test_DateTime_minusHour_Gaza() { DateTime dt = new DateTime(2007, 4, 1, 8, 0, 0, 0, MOCK_GAZA); assertEquals("2007-04-01T08:00:00.000+03:00", dt.toString()); DateTime minus7 = dt.minusHours(7); assertEquals("2007-04-01T01:00:00.000+03:00", minus7.toString()); DateTime minus8 = dt.minusHours(8); assertEquals("2007-03-31T23:00:00.000+02:00", minus8.toString()); DateTime minus9 = dt.minusHours(9); assertEquals("2007-03-31T22:00:00.000+02:00", minus9.toString()); } public void test_DateTime_plusHour_Gaza() { DateTime dt = new DateTime(2007, 3, 31, 16, 0, 0, 0, MOCK_GAZA); assertEquals("2007-03-31T16:00:00.000+02:00", dt.toString()); DateTime plus7 = dt.plusHours(7); assertEquals("2007-03-31T23:00:00.000+02:00", plus7.toString()); DateTime plus8 = dt.plusHours(8); assertEquals("2007-04-01T01:00:00.000+03:00", plus8.toString()); DateTime plus9 = dt.plusHours(9); assertEquals("2007-04-01T02:00:00.000+03:00", plus9.toString()); } public void test_DateTime_minusDay_Gaza() { DateTime dt = new DateTime(2007, 4, 2, 0, 0, 0, 0, MOCK_GAZA); assertEquals("2007-04-02T00:00:00.000+03:00", dt.toString()); DateTime minus1 = dt.minusDays(1); assertEquals("2007-04-01T01:00:00.000+03:00", minus1.toString()); DateTime minus2 = dt.minusDays(2); assertEquals("2007-03-31T00:00:00.000+02:00", minus2.toString()); } public void test_DateTime_plusDay_Gaza() { DateTime dt = new DateTime(2007, 3, 31, 0, 0, 0, 0, MOCK_GAZA); assertEquals("2007-03-31T00:00:00.000+02:00", dt.toString()); DateTime plus1 = dt.plusDays(1); assertEquals("2007-04-01T01:00:00.000+03:00", plus1.toString()); DateTime plus2 = dt.plusDays(2); assertEquals("2007-04-02T00:00:00.000+03:00", plus2.toString()); } public void test_DateTime_plusDayMidGap_Gaza() { DateTime dt = new DateTime(2007, 3, 31, 0, 30, 0, 0, MOCK_GAZA); assertEquals("2007-03-31T00:30:00.000+02:00", dt.toString()); DateTime plus1 = dt.plusDays(1); assertEquals("2007-04-01T01:30:00.000+03:00", plus1.toString()); DateTime plus2 = dt.plusDays(2); assertEquals("2007-04-02T00:30:00.000+03:00", plus2.toString()); } public void test_DateTime_addWrapFieldDay_Gaza() { DateTime dt = new DateTime(2007, 4, 30, 0, 0, 0, 0, MOCK_GAZA); assertEquals("2007-04-30T00:00:00.000+03:00", dt.toString()); DateTime plus1 = dt.dayOfMonth().addWrapFieldToCopy(1); assertEquals("2007-04-01T01:00:00.000+03:00", plus1.toString()); DateTime plus2 = dt.dayOfMonth().addWrapFieldToCopy(2); assertEquals("2007-04-02T00:00:00.000+03:00", plus2.toString()); } public void test_DateTime_withZoneRetainFields_Gaza() { DateTime dt = new DateTime(2007, 4, 1, 0, 0, 0, 0, DateTimeZone.UTC); assertEquals("2007-04-01T00:00:00.000Z", dt.toString()); DateTime res = dt.withZoneRetainFields(MOCK_GAZA); assertEquals("2007-04-01T01:00:00.000+03:00", res.toString()); } public void test_MutableDateTime_withZoneRetainFields_Gaza() { MutableDateTime dt = new MutableDateTime(2007, 4, 1, 0, 0, 0, 0, DateTimeZone.UTC); assertEquals("2007-04-01T00:00:00.000Z", dt.toString()); dt.setZoneRetainFields(MOCK_GAZA); assertEquals("2007-04-01T01:00:00.000+03:00", dt.toString()); } public void test_LocalDate_new_Gaza() { LocalDate date1 = new LocalDate(CUTOVER_GAZA, MOCK_GAZA); assertEquals("2007-04-01", date1.toString()); LocalDate date2 = new LocalDate(CUTOVER_GAZA - 1, MOCK_GAZA); assertEquals("2007-03-31", date2.toString()); } public void test_LocalDate_toDateMidnight_Gaza() { LocalDate date = new LocalDate(2007, 4, 1); try { date.toDateMidnight(MOCK_GAZA); fail(); } catch (IllegalInstantException ex) { assertEquals(true, ex.getMessage().startsWith("Illegal instant due to time zone offset transition")); } } public void test_DateTime_new_Gaza() { try { new DateTime(2007, 4, 1, 0, 0, 0, 0, MOCK_GAZA); fail(); } catch (IllegalInstantException ex) { assertEquals(true, ex.getMessage().indexOf("Illegal instant due to time zone offset transition") >= 0); } } public void test_DateTime_newValid_Gaza() { new DateTime(2007, 3, 31, 19, 0, 0, 0, MOCK_GAZA); new DateTime(2007, 3, 31, 20, 0, 0, 0, MOCK_GAZA); new DateTime(2007, 3, 31, 21, 0, 0, 0, MOCK_GAZA); new DateTime(2007, 3, 31, 22, 0, 0, 0, MOCK_GAZA); new DateTime(2007, 3, 31, 23, 0, 0, 0, MOCK_GAZA); new DateTime(2007, 4, 1, 1, 0, 0, 0, MOCK_GAZA); new DateTime(2007, 4, 1, 2, 0, 0, 0, MOCK_GAZA); new DateTime(2007, 4, 1, 3, 0, 0, 0, MOCK_GAZA); } public void test_DateTime_parse_Gaza() { try { new DateTime("2007-04-01T00:00", MOCK_GAZA); fail(); } catch (IllegalInstantException ex) { assertEquals(true, ex.getMessage().indexOf("Illegal instant due to time zone offset transition") >= 0); } } //----------------------------------------------------------------------- //------------------------ Bug [1710316] -------------------------------- //----------------------------------------------------------------------- /** Mock zone simulating America/Grand_Turk cutover at midnight 2007-04-01 */ private static long CUTOVER_TURK = 1175403600000L; private static int OFFSET_TURK = -18000000; // -05:00 private static final DateTimeZone MOCK_TURK = new MockZone(CUTOVER_TURK, OFFSET_TURK, 3600); //----------------------------------------------------------------------- public void test_MockTurkIsCorrect() { DateTime pre = new DateTime(CUTOVER_TURK - 1L, MOCK_TURK); assertEquals("2007-03-31T23:59:59.999-05:00", pre.toString()); DateTime at = new DateTime(CUTOVER_TURK, MOCK_TURK); assertEquals("2007-04-01T01:00:00.000-04:00", at.toString()); DateTime post = new DateTime(CUTOVER_TURK + 1L, MOCK_TURK); assertEquals("2007-04-01T01:00:00.001-04:00", post.toString()); } public void test_getOffsetFromLocal_Turk() { doTest_getOffsetFromLocal_Turk(-1, 23, 0, "2007-03-31T23:00:00.000-05:00"); doTest_getOffsetFromLocal_Turk(-1, 23, 30, "2007-03-31T23:30:00.000-05:00"); doTest_getOffsetFromLocal_Turk(0, 0, 0, "2007-04-01T01:00:00.000-04:00"); doTest_getOffsetFromLocal_Turk(0, 0, 30, "2007-04-01T01:30:00.000-04:00"); doTest_getOffsetFromLocal_Turk(0, 1, 0, "2007-04-01T01:00:00.000-04:00"); doTest_getOffsetFromLocal_Turk(0, 1, 30, "2007-04-01T01:30:00.000-04:00"); doTest_getOffsetFromLocal_Turk(0, 2, 0, "2007-04-01T02:00:00.000-04:00"); doTest_getOffsetFromLocal_Turk(0, 3, 0, "2007-04-01T03:00:00.000-04:00"); doTest_getOffsetFromLocal_Turk(0, 4, 0, "2007-04-01T04:00:00.000-04:00"); doTest_getOffsetFromLocal_Turk(0, 5, 0, "2007-04-01T05:00:00.000-04:00"); doTest_getOffsetFromLocal_Turk(0, 6, 0, "2007-04-01T06:00:00.000-04:00"); } private void doTest_getOffsetFromLocal_Turk(int days, int hour, int min, String expected) { DateTime dt = new DateTime(2007, 4, 1, hour, min, 0, 0, DateTimeZone.UTC).plusDays(days); int offset = MOCK_TURK.getOffsetFromLocal(dt.getMillis()); DateTime res = new DateTime(dt.getMillis() - offset, MOCK_TURK); assertEquals(res.toString(), expected, res.toString()); } public void test_DateTime_roundFloor_Turk() { DateTime dt = new DateTime(2007, 4, 1, 8, 0, 0, 0, MOCK_TURK); assertEquals("2007-04-01T08:00:00.000-04:00", dt.toString()); DateTime rounded = dt.dayOfMonth().roundFloorCopy(); assertEquals("2007-04-01T01:00:00.000-04:00", rounded.toString()); } public void test_DateTime_roundFloorNotDST_Turk() { DateTime dt = new DateTime(2007, 4, 2, 8, 0, 0, 0, MOCK_TURK); assertEquals("2007-04-02T08:00:00.000-04:00", dt.toString()); DateTime rounded = dt.dayOfMonth().roundFloorCopy(); assertEquals("2007-04-02T00:00:00.000-04:00", rounded.toString()); } public void test_DateTime_roundCeiling_Turk() { DateTime dt = new DateTime(2007, 3, 31, 20, 0, 0, 0, MOCK_TURK); assertEquals("2007-03-31T20:00:00.000-05:00", dt.toString()); DateTime rounded = dt.dayOfMonth().roundCeilingCopy(); assertEquals("2007-04-01T01:00:00.000-04:00", rounded.toString()); } public void test_DateTime_setHourZero_Turk() { DateTime dt = new DateTime(2007, 4, 1, 8, 0, 0, 0, MOCK_TURK); assertEquals("2007-04-01T08:00:00.000-04:00", dt.toString()); try { dt.hourOfDay().setCopy(0); fail(); } catch (IllegalFieldValueException ex) { // expected } } public void test_DateTime_withHourZero_Turk() { DateTime dt = new DateTime(2007, 4, 1, 8, 0, 0, 0, MOCK_TURK); assertEquals("2007-04-01T08:00:00.000-04:00", dt.toString()); try { dt.withHourOfDay(0); fail(); } catch (IllegalFieldValueException ex) { // expected } } public void test_DateTime_withDay_Turk() { DateTime dt = new DateTime(2007, 4, 2, 0, 0, 0, 0, MOCK_TURK); assertEquals("2007-04-02T00:00:00.000-04:00", dt.toString()); DateTime res = dt.withDayOfMonth(1); assertEquals("2007-04-01T01:00:00.000-04:00", res.toString()); } public void test_DateTime_minusHour_Turk() { DateTime dt = new DateTime(2007, 4, 1, 8, 0, 0, 0, MOCK_TURK); assertEquals("2007-04-01T08:00:00.000-04:00", dt.toString()); DateTime minus7 = dt.minusHours(7); assertEquals("2007-04-01T01:00:00.000-04:00", minus7.toString()); DateTime minus8 = dt.minusHours(8); assertEquals("2007-03-31T23:00:00.000-05:00", minus8.toString()); DateTime minus9 = dt.minusHours(9); assertEquals("2007-03-31T22:00:00.000-05:00", minus9.toString()); } public void test_DateTime_plusHour_Turk() { DateTime dt = new DateTime(2007, 3, 31, 16, 0, 0, 0, MOCK_TURK); assertEquals("2007-03-31T16:00:00.000-05:00", dt.toString()); DateTime plus7 = dt.plusHours(7); assertEquals("2007-03-31T23:00:00.000-05:00", plus7.toString()); DateTime plus8 = dt.plusHours(8); assertEquals("2007-04-01T01:00:00.000-04:00", plus8.toString()); DateTime plus9 = dt.plusHours(9); assertEquals("2007-04-01T02:00:00.000-04:00", plus9.toString()); } public void test_DateTime_minusDay_Turk() { DateTime dt = new DateTime(2007, 4, 2, 0, 0, 0, 0, MOCK_TURK); assertEquals("2007-04-02T00:00:00.000-04:00", dt.toString()); DateTime minus1 = dt.minusDays(1); assertEquals("2007-04-01T01:00:00.000-04:00", minus1.toString()); DateTime minus2 = dt.minusDays(2); assertEquals("2007-03-31T00:00:00.000-05:00", minus2.toString()); } public void test_DateTime_plusDay_Turk() { DateTime dt = new DateTime(2007, 3, 31, 0, 0, 0, 0, MOCK_TURK); assertEquals("2007-03-31T00:00:00.000-05:00", dt.toString()); DateTime plus1 = dt.plusDays(1); assertEquals("2007-04-01T01:00:00.000-04:00", plus1.toString()); DateTime plus2 = dt.plusDays(2); assertEquals("2007-04-02T00:00:00.000-04:00", plus2.toString()); } public void test_DateTime_plusDayMidGap_Turk() { DateTime dt = new DateTime(2007, 3, 31, 0, 30, 0, 0, MOCK_TURK); assertEquals("2007-03-31T00:30:00.000-05:00", dt.toString()); DateTime plus1 = dt.plusDays(1); assertEquals("2007-04-01T01:30:00.000-04:00", plus1.toString()); DateTime plus2 = dt.plusDays(2); assertEquals("2007-04-02T00:30:00.000-04:00", plus2.toString()); } public void test_DateTime_addWrapFieldDay_Turk() { DateTime dt = new DateTime(2007, 4, 30, 0, 0, 0, 0, MOCK_TURK); assertEquals("2007-04-30T00:00:00.000-04:00", dt.toString()); DateTime plus1 = dt.dayOfMonth().addWrapFieldToCopy(1); assertEquals("2007-04-01T01:00:00.000-04:00", plus1.toString()); DateTime plus2 = dt.dayOfMonth().addWrapFieldToCopy(2); assertEquals("2007-04-02T00:00:00.000-04:00", plus2.toString()); } public void test_DateTime_withZoneRetainFields_Turk() { DateTime dt = new DateTime(2007, 4, 1, 0, 0, 0, 0, DateTimeZone.UTC); assertEquals("2007-04-01T00:00:00.000Z", dt.toString()); DateTime res = dt.withZoneRetainFields(MOCK_TURK); assertEquals("2007-04-01T01:00:00.000-04:00", res.toString()); } public void test_MutableDateTime_setZoneRetainFields_Turk() { MutableDateTime dt = new MutableDateTime(2007, 4, 1, 0, 0, 0, 0, DateTimeZone.UTC); assertEquals("2007-04-01T00:00:00.000Z", dt.toString()); dt.setZoneRetainFields(MOCK_TURK); assertEquals("2007-04-01T01:00:00.000-04:00", dt.toString()); } public void test_LocalDate_new_Turk() { LocalDate date1 = new LocalDate(CUTOVER_TURK, MOCK_TURK); assertEquals("2007-04-01", date1.toString()); LocalDate date2 = new LocalDate(CUTOVER_TURK - 1, MOCK_TURK); assertEquals("2007-03-31", date2.toString()); } public void test_LocalDate_toDateMidnight_Turk() { LocalDate date = new LocalDate(2007, 4, 1); try { date.toDateMidnight(MOCK_TURK); fail(); } catch (IllegalInstantException ex) { assertEquals(true, ex.getMessage().startsWith("Illegal instant due to time zone offset transition")); } } public void test_DateTime_new_Turk() { try { new DateTime(2007, 4, 1, 0, 0, 0, 0, MOCK_TURK); fail(); } catch (IllegalInstantException ex) { assertEquals(true, ex.getMessage().indexOf("Illegal instant due to time zone offset transition") >= 0); } } public void test_DateTime_newValid_Turk() { new DateTime(2007, 3, 31, 23, 0, 0, 0, MOCK_TURK); new DateTime(2007, 4, 1, 1, 0, 0, 0, MOCK_TURK); new DateTime(2007, 4, 1, 2, 0, 0, 0, MOCK_TURK); new DateTime(2007, 4, 1, 3, 0, 0, 0, MOCK_TURK); new DateTime(2007, 4, 1, 4, 0, 0, 0, MOCK_TURK); new DateTime(2007, 4, 1, 5, 0, 0, 0, MOCK_TURK); new DateTime(2007, 4, 1, 6, 0, 0, 0, MOCK_TURK); } public void test_DateTime_parse_Turk() { try { new DateTime("2007-04-01T00:00", MOCK_TURK); fail(); } catch (IllegalInstantException ex) { assertEquals(true, ex.getMessage().indexOf("Illegal instant due to time zone offset transition") >= 0); } } //----------------------------------------------------------------------- //----------------------------------------------------------------------- //----------------------------------------------------------------------- /** America/New_York cutover from 01:59 to 03:00 on 2007-03-11 */ private static long CUTOVER_NEW_YORK_SPRING = 1173596400000L; // 2007-03-11T03:00:00.000-04:00 private static final DateTimeZone ZONE_NEW_YORK = DateTimeZone.forID("America/New_York"); // DateTime x = new DateTime(2007, 1, 1, 0, 0, 0, 0, ZONE_NEW_YORK); // System.out.println(ZONE_NEW_YORK.nextTransition(x.getMillis())); // DateTime y = new DateTime(ZONE_NEW_YORK.nextTransition(x.getMillis()), ZONE_NEW_YORK); // System.out.println(y); //----------------------------------------------------------------------- public void test_NewYorkIsCorrect_Spring() { DateTime pre = new DateTime(CUTOVER_NEW_YORK_SPRING - 1L, ZONE_NEW_YORK); assertEquals("2007-03-11T01:59:59.999-05:00", pre.toString()); DateTime at = new DateTime(CUTOVER_NEW_YORK_SPRING, ZONE_NEW_YORK); assertEquals("2007-03-11T03:00:00.000-04:00", at.toString()); DateTime post = new DateTime(CUTOVER_NEW_YORK_SPRING + 1L, ZONE_NEW_YORK); assertEquals("2007-03-11T03:00:00.001-04:00", post.toString()); } public void test_getOffsetFromLocal_NewYork_Spring() { doTest_getOffsetFromLocal(3, 11, 1, 0, "2007-03-11T01:00:00.000-05:00", ZONE_NEW_YORK); doTest_getOffsetFromLocal(3, 11, 1,30, "2007-03-11T01:30:00.000-05:00", ZONE_NEW_YORK); doTest_getOffsetFromLocal(3, 11, 2, 0, "2007-03-11T03:00:00.000-04:00", ZONE_NEW_YORK); doTest_getOffsetFromLocal(3, 11, 2,30, "2007-03-11T03:30:00.000-04:00", ZONE_NEW_YORK); doTest_getOffsetFromLocal(3, 11, 3, 0, "2007-03-11T03:00:00.000-04:00", ZONE_NEW_YORK); doTest_getOffsetFromLocal(3, 11, 3,30, "2007-03-11T03:30:00.000-04:00", ZONE_NEW_YORK); doTest_getOffsetFromLocal(3, 11, 4, 0, "2007-03-11T04:00:00.000-04:00", ZONE_NEW_YORK); doTest_getOffsetFromLocal(3, 11, 5, 0, "2007-03-11T05:00:00.000-04:00", ZONE_NEW_YORK); doTest_getOffsetFromLocal(3, 11, 6, 0, "2007-03-11T06:00:00.000-04:00", ZONE_NEW_YORK); doTest_getOffsetFromLocal(3, 11, 7, 0, "2007-03-11T07:00:00.000-04:00", ZONE_NEW_YORK); doTest_getOffsetFromLocal(3, 11, 8, 0, "2007-03-11T08:00:00.000-04:00", ZONE_NEW_YORK); } public void test_DateTime_setHourAcross_NewYork_Spring() { DateTime dt = new DateTime(2007, 3, 11, 0, 0, 0, 0, ZONE_NEW_YORK); assertEquals("2007-03-11T00:00:00.000-05:00", dt.toString()); DateTime res = dt.hourOfDay().setCopy(4); assertEquals("2007-03-11T04:00:00.000-04:00", res.toString()); } public void test_DateTime_setHourForward_NewYork_Spring() { DateTime dt = new DateTime(2007, 3, 11, 0, 0, 0, 0, ZONE_NEW_YORK); assertEquals("2007-03-11T00:00:00.000-05:00", dt.toString()); try { dt.hourOfDay().setCopy(2); fail(); } catch (IllegalFieldValueException ex) { // expected } } public void test_DateTime_setHourBack_NewYork_Spring() { DateTime dt = new DateTime(2007, 3, 11, 8, 0, 0, 0, ZONE_NEW_YORK); assertEquals("2007-03-11T08:00:00.000-04:00", dt.toString()); try { dt.hourOfDay().setCopy(2); fail(); } catch (IllegalFieldValueException ex) { // expected } } //----------------------------------------------------------------------- public void test_DateTime_roundFloor_day_NewYork_Spring_preCutover() { DateTime dt = new DateTime(2007, 3, 11, 1, 30, 0, 0, ZONE_NEW_YORK); assertEquals("2007-03-11T01:30:00.000-05:00", dt.toString()); DateTime rounded = dt.dayOfMonth().roundFloorCopy(); assertEquals("2007-03-11T00:00:00.000-05:00", rounded.toString()); } public void test_DateTime_roundFloor_day_NewYork_Spring_postCutover() { DateTime dt = new DateTime(2007, 3, 11, 3, 30, 0, 0, ZONE_NEW_YORK); assertEquals("2007-03-11T03:30:00.000-04:00", dt.toString()); DateTime rounded = dt.dayOfMonth().roundFloorCopy(); assertEquals("2007-03-11T00:00:00.000-05:00", rounded.toString()); } public void test_DateTime_roundFloor_hour_NewYork_Spring_preCutover() { DateTime dt = new DateTime(2007, 3, 11, 1, 30, 0, 0, ZONE_NEW_YORK); assertEquals("2007-03-11T01:30:00.000-05:00", dt.toString()); DateTime rounded = dt.hourOfDay().roundFloorCopy(); assertEquals("2007-03-11T01:00:00.000-05:00", rounded.toString()); } public void test_DateTime_roundFloor_hour_NewYork_Spring_postCutover() { DateTime dt = new DateTime(2007, 3, 11, 3, 30, 0, 0, ZONE_NEW_YORK); assertEquals("2007-03-11T03:30:00.000-04:00", dt.toString()); DateTime rounded = dt.hourOfDay().roundFloorCopy(); assertEquals("2007-03-11T03:00:00.000-04:00", rounded.toString()); } public void test_DateTime_roundFloor_minute_NewYork_Spring_preCutover() { DateTime dt = new DateTime(2007, 3, 11, 1, 30, 40, 0, ZONE_NEW_YORK); assertEquals("2007-03-11T01:30:40.000-05:00", dt.toString()); DateTime rounded = dt.minuteOfHour().roundFloorCopy(); assertEquals("2007-03-11T01:30:00.000-05:00", rounded.toString()); } public void test_DateTime_roundFloor_minute_NewYork_Spring_postCutover() { DateTime dt = new DateTime(2007, 3, 11, 3, 30, 40, 0, ZONE_NEW_YORK); assertEquals("2007-03-11T03:30:40.000-04:00", dt.toString()); DateTime rounded = dt.minuteOfHour().roundFloorCopy(); assertEquals("2007-03-11T03:30:00.000-04:00", rounded.toString()); } //----------------------------------------------------------------------- public void test_DateTime_roundCeiling_day_NewYork_Spring_preCutover() { DateTime dt = new DateTime(2007, 3, 11, 1, 30, 0, 0, ZONE_NEW_YORK); assertEquals("2007-03-11T01:30:00.000-05:00", dt.toString()); DateTime rounded = dt.dayOfMonth().roundCeilingCopy(); assertEquals("2007-03-12T00:00:00.000-04:00", rounded.toString()); } public void test_DateTime_roundCeiling_day_NewYork_Spring_postCutover() { DateTime dt = new DateTime(2007, 3, 11, 3, 30, 0, 0, ZONE_NEW_YORK); assertEquals("2007-03-11T03:30:00.000-04:00", dt.toString()); DateTime rounded = dt.dayOfMonth().roundCeilingCopy(); assertEquals("2007-03-12T00:00:00.000-04:00", rounded.toString()); } public void test_DateTime_roundCeiling_hour_NewYork_Spring_preCutover() { DateTime dt = new DateTime(2007, 3, 11, 1, 30, 0, 0, ZONE_NEW_YORK); assertEquals("2007-03-11T01:30:00.000-05:00", dt.toString()); DateTime rounded = dt.hourOfDay().roundCeilingCopy(); assertEquals("2007-03-11T03:00:00.000-04:00", rounded.toString()); } public void test_DateTime_roundCeiling_hour_NewYork_Spring_postCutover() { DateTime dt = new DateTime(2007, 3, 11, 3, 30, 0, 0, ZONE_NEW_YORK); assertEquals("2007-03-11T03:30:00.000-04:00", dt.toString()); DateTime rounded = dt.hourOfDay().roundCeilingCopy(); assertEquals("2007-03-11T04:00:00.000-04:00", rounded.toString()); } public void test_DateTime_roundCeiling_minute_NewYork_Spring_preCutover() { DateTime dt = new DateTime(2007, 3, 11, 1, 30, 40, 0, ZONE_NEW_YORK); assertEquals("2007-03-11T01:30:40.000-05:00", dt.toString()); DateTime rounded = dt.minuteOfHour().roundCeilingCopy(); assertEquals("2007-03-11T01:31:00.000-05:00", rounded.toString()); } public void test_DateTime_roundCeiling_minute_NewYork_Spring_postCutover() { DateTime dt = new DateTime(2007, 3, 11, 3, 30, 40, 0, ZONE_NEW_YORK); assertEquals("2007-03-11T03:30:40.000-04:00", dt.toString()); DateTime rounded = dt.minuteOfHour().roundCeilingCopy(); assertEquals("2007-03-11T03:31:00.000-04:00", rounded.toString()); } //----------------------------------------------------------------------- /** America/New_York cutover from 01:59 to 01:00 on 2007-11-04 */ private static long CUTOVER_NEW_YORK_AUTUMN = 1194156000000L; // 2007-11-04T01:00:00.000-05:00 //----------------------------------------------------------------------- public void test_NewYorkIsCorrect_Autumn() { DateTime pre = new DateTime(CUTOVER_NEW_YORK_AUTUMN - 1L, ZONE_NEW_YORK); assertEquals("2007-11-04T01:59:59.999-04:00", pre.toString()); DateTime at = new DateTime(CUTOVER_NEW_YORK_AUTUMN, ZONE_NEW_YORK); assertEquals("2007-11-04T01:00:00.000-05:00", at.toString()); DateTime post = new DateTime(CUTOVER_NEW_YORK_AUTUMN + 1L, ZONE_NEW_YORK); assertEquals("2007-11-04T01:00:00.001-05:00", post.toString()); } public void test_getOffsetFromLocal_NewYork_Autumn() { doTest_getOffsetFromLocal(11, 4, 0, 0, "2007-11-04T00:00:00.000-04:00", ZONE_NEW_YORK); doTest_getOffsetFromLocal(11, 4, 0,30, "2007-11-04T00:30:00.000-04:00", ZONE_NEW_YORK); doTest_getOffsetFromLocal(11, 4, 1, 0, "2007-11-04T01:00:00.000-04:00", ZONE_NEW_YORK); doTest_getOffsetFromLocal(11, 4, 1,30, "2007-11-04T01:30:00.000-04:00", ZONE_NEW_YORK); doTest_getOffsetFromLocal(11, 4, 2, 0, "2007-11-04T02:00:00.000-05:00", ZONE_NEW_YORK); doTest_getOffsetFromLocal(11, 4, 2,30, "2007-11-04T02:30:00.000-05:00", ZONE_NEW_YORK); doTest_getOffsetFromLocal(11, 4, 3, 0, "2007-11-04T03:00:00.000-05:00", ZONE_NEW_YORK); doTest_getOffsetFromLocal(11, 4, 3,30, "2007-11-04T03:30:00.000-05:00", ZONE_NEW_YORK); doTest_getOffsetFromLocal(11, 4, 4, 0, "2007-11-04T04:00:00.000-05:00", ZONE_NEW_YORK); doTest_getOffsetFromLocal(11, 4, 5, 0, "2007-11-04T05:00:00.000-05:00", ZONE_NEW_YORK); doTest_getOffsetFromLocal(11, 4, 6, 0, "2007-11-04T06:00:00.000-05:00", ZONE_NEW_YORK); doTest_getOffsetFromLocal(11, 4, 7, 0, "2007-11-04T07:00:00.000-05:00", ZONE_NEW_YORK); doTest_getOffsetFromLocal(11, 4, 8, 0, "2007-11-04T08:00:00.000-05:00", ZONE_NEW_YORK); } public void test_DateTime_constructor_NewYork_Autumn() { DateTime dt = new DateTime(2007, 11, 4, 1, 30, ZONE_NEW_YORK); assertEquals("2007-11-04T01:30:00.000-04:00", dt.toString()); } public void test_DateTime_plusHour_NewYork_Autumn() { DateTime dt = new DateTime(2007, 11, 3, 18, 0, 0, 0, ZONE_NEW_YORK); assertEquals("2007-11-03T18:00:00.000-04:00", dt.toString()); DateTime plus6 = dt.plusHours(6); assertEquals("2007-11-04T00:00:00.000-04:00", plus6.toString()); DateTime plus7 = dt.plusHours(7); assertEquals("2007-11-04T01:00:00.000-04:00", plus7.toString()); DateTime plus8 = dt.plusHours(8); assertEquals("2007-11-04T01:00:00.000-05:00", plus8.toString()); DateTime plus9 = dt.plusHours(9); assertEquals("2007-11-04T02:00:00.000-05:00", plus9.toString()); } public void test_DateTime_minusHour_NewYork_Autumn() { DateTime dt = new DateTime(2007, 11, 4, 8, 0, 0, 0, ZONE_NEW_YORK); assertEquals("2007-11-04T08:00:00.000-05:00", dt.toString()); DateTime minus6 = dt.minusHours(6); assertEquals("2007-11-04T02:00:00.000-05:00", minus6.toString()); DateTime minus7 = dt.minusHours(7); assertEquals("2007-11-04T01:00:00.000-05:00", minus7.toString()); DateTime minus8 = dt.minusHours(8); assertEquals("2007-11-04T01:00:00.000-04:00", minus8.toString()); DateTime minus9 = dt.minusHours(9); assertEquals("2007-11-04T00:00:00.000-04:00", minus9.toString()); } //----------------------------------------------------------------------- public void test_DateTime_roundFloor_day_NewYork_Autumn_preCutover() { DateTime dt = new DateTime(2007, 11, 4, 1, 30, 0, 0, ZONE_NEW_YORK); assertEquals("2007-11-04T01:30:00.000-04:00", dt.toString()); DateTime rounded = dt.dayOfMonth().roundFloorCopy(); assertEquals("2007-11-04T00:00:00.000-04:00", rounded.toString()); } public void test_DateTime_roundFloor_day_NewYork_Autumn_postCutover() { DateTime dt = new DateTime(2007, 11, 4, 1, 30, 0, 0, ZONE_NEW_YORK).plusHours(1); assertEquals("2007-11-04T01:30:00.000-05:00", dt.toString()); DateTime rounded = dt.dayOfMonth().roundFloorCopy(); assertEquals("2007-11-04T00:00:00.000-04:00", rounded.toString()); } public void test_DateTime_roundFloor_hourOfDay_NewYork_Autumn_preCutover() { DateTime dt = new DateTime(2007, 11, 4, 1, 30, 0, 0, ZONE_NEW_YORK); assertEquals("2007-11-04T01:30:00.000-04:00", dt.toString()); DateTime rounded = dt.hourOfDay().roundFloorCopy(); assertEquals("2007-11-04T01:00:00.000-04:00", rounded.toString()); } public void test_DateTime_roundFloor_hourOfDay_NewYork_Autumn_postCutover() { DateTime dt = new DateTime(2007, 11, 4, 1, 30, 0, 0, ZONE_NEW_YORK).plusHours(1); assertEquals("2007-11-04T01:30:00.000-05:00", dt.toString()); DateTime rounded = dt.hourOfDay().roundFloorCopy(); assertEquals("2007-11-04T01:00:00.000-05:00", rounded.toString()); } public void test_DateTime_roundFloor_minuteOfHour_NewYork_Autumn_preCutover() { DateTime dt = new DateTime(2007, 11, 4, 1, 30, 40, 0, ZONE_NEW_YORK); assertEquals("2007-11-04T01:30:40.000-04:00", dt.toString()); DateTime rounded = dt.minuteOfHour().roundFloorCopy(); assertEquals("2007-11-04T01:30:00.000-04:00", rounded.toString()); } public void test_DateTime_roundFloor_minuteOfHour_NewYork_Autumn_postCutover() { DateTime dt = new DateTime(2007, 11, 4, 1, 30, 40, 0, ZONE_NEW_YORK).plusHours(1); assertEquals("2007-11-04T01:30:40.000-05:00", dt.toString()); DateTime rounded = dt.minuteOfHour().roundFloorCopy(); assertEquals("2007-11-04T01:30:00.000-05:00", rounded.toString()); } public void test_DateTime_roundFloor_secondOfMinute_NewYork_Autumn_preCutover() { DateTime dt = new DateTime(2007, 11, 4, 1, 30, 40, 500, ZONE_NEW_YORK); assertEquals("2007-11-04T01:30:40.500-04:00", dt.toString()); DateTime rounded = dt.secondOfMinute().roundFloorCopy(); assertEquals("2007-11-04T01:30:40.000-04:00", rounded.toString()); } public void test_DateTime_roundFloor_secondOfMinute_NewYork_Autumn_postCutover() { DateTime dt = new DateTime(2007, 11, 4, 1, 30, 40, 500, ZONE_NEW_YORK).plusHours(1); assertEquals("2007-11-04T01:30:40.500-05:00", dt.toString()); DateTime rounded = dt.secondOfMinute().roundFloorCopy(); assertEquals("2007-11-04T01:30:40.000-05:00", rounded.toString()); } //----------------------------------------------------------------------- public void test_DateTime_roundCeiling_day_NewYork_Autumn_preCutover() { DateTime dt = new DateTime(2007, 11, 4, 1, 30, 0, 0, ZONE_NEW_YORK); assertEquals("2007-11-04T01:30:00.000-04:00", dt.toString()); DateTime rounded = dt.dayOfMonth().roundCeilingCopy(); assertEquals("2007-11-05T00:00:00.000-05:00", rounded.toString()); } public void test_DateTime_roundCeiling_day_NewYork_Autumn_postCutover() { DateTime dt = new DateTime(2007, 11, 4, 1, 30, 0, 0, ZONE_NEW_YORK).plusHours(1); assertEquals("2007-11-04T01:30:00.000-05:00", dt.toString()); DateTime rounded = dt.dayOfMonth().roundCeilingCopy(); assertEquals("2007-11-05T00:00:00.000-05:00", rounded.toString()); } public void test_DateTime_roundCeiling_hourOfDay_NewYork_Autumn_preCutover() { DateTime dt = new DateTime(2007, 11, 4, 1, 30, 0, 0, ZONE_NEW_YORK); assertEquals("2007-11-04T01:30:00.000-04:00", dt.toString()); DateTime rounded = dt.hourOfDay().roundCeilingCopy(); assertEquals("2007-11-04T01:00:00.000-05:00", rounded.toString()); } public void test_DateTime_roundCeiling_hourOfDay_NewYork_Autumn_postCutover() { DateTime dt = new DateTime(2007, 11, 4, 1, 30, 0, 0, ZONE_NEW_YORK).plusHours(1); assertEquals("2007-11-04T01:30:00.000-05:00", dt.toString()); DateTime rounded = dt.hourOfDay().roundCeilingCopy(); assertEquals("2007-11-04T02:00:00.000-05:00", rounded.toString()); } public void test_DateTime_roundCeiling_minuteOfHour_NewYork_Autumn_preCutover() { DateTime dt = new DateTime(2007, 11, 4, 1, 30, 40, 0, ZONE_NEW_YORK); assertEquals("2007-11-04T01:30:40.000-04:00", dt.toString()); DateTime rounded = dt.minuteOfHour().roundCeilingCopy(); assertEquals("2007-11-04T01:31:00.000-04:00", rounded.toString()); } public void test_DateTime_roundCeiling_minuteOfHour_NewYork_Autumn_postCutover() { DateTime dt = new DateTime(2007, 11, 4, 1, 30, 40, 0, ZONE_NEW_YORK).plusHours(1); assertEquals("2007-11-04T01:30:40.000-05:00", dt.toString()); DateTime rounded = dt.minuteOfHour().roundCeilingCopy(); assertEquals("2007-11-04T01:31:00.000-05:00", rounded.toString()); } public void test_DateTime_roundCeiling_secondOfMinute_NewYork_Autumn_preCutover() { DateTime dt = new DateTime(2007, 11, 4, 1, 30, 40, 500, ZONE_NEW_YORK); assertEquals("2007-11-04T01:30:40.500-04:00", dt.toString()); DateTime rounded = dt.secondOfMinute().roundCeilingCopy(); assertEquals("2007-11-04T01:30:41.000-04:00", rounded.toString()); } public void test_DateTime_roundCeiling_secondOfMinute_NewYork_Autumn_postCutover() { DateTime dt = new DateTime(2007, 11, 4, 1, 30, 40, 500, ZONE_NEW_YORK).plusHours(1); assertEquals("2007-11-04T01:30:40.500-05:00", dt.toString()); DateTime rounded = dt.secondOfMinute().roundCeilingCopy(); assertEquals("2007-11-04T01:30:41.000-05:00", rounded.toString()); } //----------------------------------------------------------------------- /** Europe/Moscow cutover from 01:59 to 03:00 on 2007-03-25 */ private static long CUTOVER_MOSCOW_SPRING = 1174777200000L; // 2007-03-25T03:00:00.000+04:00 private static final DateTimeZone ZONE_MOSCOW = DateTimeZone.forID("Europe/Moscow"); //----------------------------------------------------------------------- public void test_MoscowIsCorrect_Spring() { // DateTime x = new DateTime(2007, 7, 1, 0, 0, 0, 0, ZONE_MOSCOW); // System.out.println(ZONE_MOSCOW.nextTransition(x.getMillis())); // DateTime y = new DateTime(ZONE_MOSCOW.nextTransition(x.getMillis()), ZONE_MOSCOW); // System.out.println(y); DateTime pre = new DateTime(CUTOVER_MOSCOW_SPRING - 1L, ZONE_MOSCOW); assertEquals("2007-03-25T01:59:59.999+03:00", pre.toString()); DateTime at = new DateTime(CUTOVER_MOSCOW_SPRING, ZONE_MOSCOW); assertEquals("2007-03-25T03:00:00.000+04:00", at.toString()); DateTime post = new DateTime(CUTOVER_MOSCOW_SPRING + 1L, ZONE_MOSCOW); assertEquals("2007-03-25T03:00:00.001+04:00", post.toString()); } public void test_getOffsetFromLocal_Moscow_Spring() { doTest_getOffsetFromLocal(3, 25, 1, 0, "2007-03-25T01:00:00.000+03:00", ZONE_MOSCOW); doTest_getOffsetFromLocal(3, 25, 1,30, "2007-03-25T01:30:00.000+03:00", ZONE_MOSCOW); doTest_getOffsetFromLocal(3, 25, 2, 0, "2007-03-25T03:00:00.000+04:00", ZONE_MOSCOW); doTest_getOffsetFromLocal(3, 25, 2,30, "2007-03-25T03:30:00.000+04:00", ZONE_MOSCOW); doTest_getOffsetFromLocal(3, 25, 3, 0, "2007-03-25T03:00:00.000+04:00", ZONE_MOSCOW); doTest_getOffsetFromLocal(3, 25, 3,30, "2007-03-25T03:30:00.000+04:00", ZONE_MOSCOW); doTest_getOffsetFromLocal(3, 25, 4, 0, "2007-03-25T04:00:00.000+04:00", ZONE_MOSCOW); doTest_getOffsetFromLocal(3, 25, 5, 0, "2007-03-25T05:00:00.000+04:00", ZONE_MOSCOW); doTest_getOffsetFromLocal(3, 25, 6, 0, "2007-03-25T06:00:00.000+04:00", ZONE_MOSCOW); doTest_getOffsetFromLocal(3, 25, 7, 0, "2007-03-25T07:00:00.000+04:00", ZONE_MOSCOW); doTest_getOffsetFromLocal(3, 25, 8, 0, "2007-03-25T08:00:00.000+04:00", ZONE_MOSCOW); } public void test_DateTime_setHourAcross_Moscow_Spring() { DateTime dt = new DateTime(2007, 3, 25, 0, 0, 0, 0, ZONE_MOSCOW); assertEquals("2007-03-25T00:00:00.000+03:00", dt.toString()); DateTime res = dt.hourOfDay().setCopy(4); assertEquals("2007-03-25T04:00:00.000+04:00", res.toString()); } public void test_DateTime_setHourForward_Moscow_Spring() { DateTime dt = new DateTime(2007, 3, 25, 0, 0, 0, 0, ZONE_MOSCOW); assertEquals("2007-03-25T00:00:00.000+03:00", dt.toString()); try { dt.hourOfDay().setCopy(2); fail(); } catch (IllegalFieldValueException ex) { // expected } } public void test_DateTime_setHourBack_Moscow_Spring() { DateTime dt = new DateTime(2007, 3, 25, 8, 0, 0, 0, ZONE_MOSCOW); assertEquals("2007-03-25T08:00:00.000+04:00", dt.toString()); try { dt.hourOfDay().setCopy(2); fail(); } catch (IllegalFieldValueException ex) { // expected } } //----------------------------------------------------------------------- /** America/New_York cutover from 02:59 to 02:00 on 2007-10-28 */ private static long CUTOVER_MOSCOW_AUTUMN = 1193526000000L; // 2007-10-28T02:00:00.000+03:00 //----------------------------------------------------------------------- public void test_MoscowIsCorrect_Autumn() { DateTime pre = new DateTime(CUTOVER_MOSCOW_AUTUMN - 1L, ZONE_MOSCOW); assertEquals("2007-10-28T02:59:59.999+04:00", pre.toString()); DateTime at = new DateTime(CUTOVER_MOSCOW_AUTUMN, ZONE_MOSCOW); assertEquals("2007-10-28T02:00:00.000+03:00", at.toString()); DateTime post = new DateTime(CUTOVER_MOSCOW_AUTUMN + 1L, ZONE_MOSCOW); assertEquals("2007-10-28T02:00:00.001+03:00", post.toString()); } public void test_getOffsetFromLocal_Moscow_Autumn() { doTest_getOffsetFromLocal(10, 28, 0, 0, "2007-10-28T00:00:00.000+04:00", ZONE_MOSCOW); doTest_getOffsetFromLocal(10, 28, 0,30, "2007-10-28T00:30:00.000+04:00", ZONE_MOSCOW); doTest_getOffsetFromLocal(10, 28, 1, 0, "2007-10-28T01:00:00.000+04:00", ZONE_MOSCOW); doTest_getOffsetFromLocal(10, 28, 1,30, "2007-10-28T01:30:00.000+04:00", ZONE_MOSCOW); doTest_getOffsetFromLocal(10, 28, 2, 0, "2007-10-28T02:00:00.000+04:00", ZONE_MOSCOW); doTest_getOffsetFromLocal(10, 28, 2,30, "2007-10-28T02:30:00.000+04:00", ZONE_MOSCOW); doTest_getOffsetFromLocal(10, 28, 2,30,59,999, "2007-10-28T02:30:59.999+04:00", ZONE_MOSCOW); doTest_getOffsetFromLocal(10, 28, 2,59,59,998, "2007-10-28T02:59:59.998+04:00", ZONE_MOSCOW); doTest_getOffsetFromLocal(10, 28, 2,59,59,999, "2007-10-28T02:59:59.999+04:00", ZONE_MOSCOW); doTest_getOffsetFromLocal(10, 28, 3, 0, "2007-10-28T03:00:00.000+03:00", ZONE_MOSCOW); doTest_getOffsetFromLocal(10, 28, 3,30, "2007-10-28T03:30:00.000+03:00", ZONE_MOSCOW); doTest_getOffsetFromLocal(10, 28, 4, 0, "2007-10-28T04:00:00.000+03:00", ZONE_MOSCOW); doTest_getOffsetFromLocal(10, 28, 5, 0, "2007-10-28T05:00:00.000+03:00", ZONE_MOSCOW); doTest_getOffsetFromLocal(10, 28, 6, 0, "2007-10-28T06:00:00.000+03:00", ZONE_MOSCOW); doTest_getOffsetFromLocal(10, 28, 7, 0, "2007-10-28T07:00:00.000+03:00", ZONE_MOSCOW); doTest_getOffsetFromLocal(10, 28, 8, 0, "2007-10-28T08:00:00.000+03:00", ZONE_MOSCOW); } public void test_getOffsetFromLocal_Moscow_Autumn_overlap_mins() { for (int min = 0; min < 60; min++) { if (min < 10) { doTest_getOffsetFromLocal(10, 28, 2, min, "2007-10-28T02:0" + min + ":00.000+04:00", ZONE_MOSCOW); } else { doTest_getOffsetFromLocal(10, 28, 2, min, "2007-10-28T02:" + min + ":00.000+04:00", ZONE_MOSCOW); } } } public void test_DateTime_constructor_Moscow_Autumn() { DateTime dt = new DateTime(2007, 10, 28, 2, 30, ZONE_MOSCOW); assertEquals("2007-10-28T02:30:00.000+04:00", dt.toString()); } public void test_DateTime_plusHour_Moscow_Autumn() { DateTime dt = new DateTime(2007, 10, 27, 19, 0, 0, 0, ZONE_MOSCOW); assertEquals("2007-10-27T19:00:00.000+04:00", dt.toString()); DateTime plus6 = dt.plusHours(6); assertEquals("2007-10-28T01:00:00.000+04:00", plus6.toString()); DateTime plus7 = dt.plusHours(7); assertEquals("2007-10-28T02:00:00.000+04:00", plus7.toString()); DateTime plus8 = dt.plusHours(8); assertEquals("2007-10-28T02:00:00.000+03:00", plus8.toString()); DateTime plus9 = dt.plusHours(9); assertEquals("2007-10-28T03:00:00.000+03:00", plus9.toString()); } public void test_DateTime_minusHour_Moscow_Autumn() { DateTime dt = new DateTime(2007, 10, 28, 9, 0, 0, 0, ZONE_MOSCOW); assertEquals("2007-10-28T09:00:00.000+03:00", dt.toString()); DateTime minus6 = dt.minusHours(6); assertEquals("2007-10-28T03:00:00.000+03:00", minus6.toString()); DateTime minus7 = dt.minusHours(7); assertEquals("2007-10-28T02:00:00.000+03:00", minus7.toString()); DateTime minus8 = dt.minusHours(8); assertEquals("2007-10-28T02:00:00.000+04:00", minus8.toString()); DateTime minus9 = dt.minusHours(9); assertEquals("2007-10-28T01:00:00.000+04:00", minus9.toString()); } //----------------------------------------------------------------------- //----------------------------------------------------------------------- //----------------------------------------------------------------------- /** America/Guatemala cutover from 23:59 to 23:00 on 2006-09-30 */ private static long CUTOVER_GUATEMALA_AUTUMN = 1159678800000L; // 2006-09-30T23:00:00.000-06:00 private static final DateTimeZone ZONE_GUATEMALA = DateTimeZone.forID("America/Guatemala"); //----------------------------------------------------------------------- public void test_GuatemataIsCorrect_Autumn() { DateTime pre = new DateTime(CUTOVER_GUATEMALA_AUTUMN - 1L, ZONE_GUATEMALA); assertEquals("2006-09-30T23:59:59.999-05:00", pre.toString()); DateTime at = new DateTime(CUTOVER_GUATEMALA_AUTUMN, ZONE_GUATEMALA); assertEquals("2006-09-30T23:00:00.000-06:00", at.toString()); DateTime post = new DateTime(CUTOVER_GUATEMALA_AUTUMN + 1L, ZONE_GUATEMALA); assertEquals("2006-09-30T23:00:00.001-06:00", post.toString()); } public void test_getOffsetFromLocal_Guatemata_Autumn() { doTest_getOffsetFromLocal( 2006, 9,30,23, 0, "2006-09-30T23:00:00.000-05:00", ZONE_GUATEMALA); doTest_getOffsetFromLocal( 2006, 9,30,23,30, "2006-09-30T23:30:00.000-05:00", ZONE_GUATEMALA); doTest_getOffsetFromLocal( 2006, 9,30,23, 0, "2006-09-30T23:00:00.000-05:00", ZONE_GUATEMALA); doTest_getOffsetFromLocal( 2006, 9,30,23,30, "2006-09-30T23:30:00.000-05:00", ZONE_GUATEMALA); doTest_getOffsetFromLocal( 2006,10, 1, 0, 0, "2006-10-01T00:00:00.000-06:00", ZONE_GUATEMALA); doTest_getOffsetFromLocal( 2006,10, 1, 0,30, "2006-10-01T00:30:00.000-06:00", ZONE_GUATEMALA); doTest_getOffsetFromLocal( 2006,10, 1, 1, 0, "2006-10-01T01:00:00.000-06:00", ZONE_GUATEMALA); doTest_getOffsetFromLocal( 2006,10, 1, 1,30, "2006-10-01T01:30:00.000-06:00", ZONE_GUATEMALA); doTest_getOffsetFromLocal( 2006,10, 1, 2, 0, "2006-10-01T02:00:00.000-06:00", ZONE_GUATEMALA); doTest_getOffsetFromLocal( 2006,10, 1, 2,30, "2006-10-01T02:30:00.000-06:00", ZONE_GUATEMALA); doTest_getOffsetFromLocal( 2006,10, 1, 3, 0, "2006-10-01T03:00:00.000-06:00", ZONE_GUATEMALA); doTest_getOffsetFromLocal( 2006,10, 1, 3,30, "2006-10-01T03:30:00.000-06:00", ZONE_GUATEMALA); doTest_getOffsetFromLocal( 2006,10, 1, 4, 0, "2006-10-01T04:00:00.000-06:00", ZONE_GUATEMALA); doTest_getOffsetFromLocal( 2006,10, 1, 4,30, "2006-10-01T04:30:00.000-06:00", ZONE_GUATEMALA); doTest_getOffsetFromLocal( 2006,10, 1, 5, 0, "2006-10-01T05:00:00.000-06:00", ZONE_GUATEMALA); doTest_getOffsetFromLocal( 2006,10, 1, 5,30, "2006-10-01T05:30:00.000-06:00", ZONE_GUATEMALA); doTest_getOffsetFromLocal( 2006,10, 1, 6, 0, "2006-10-01T06:00:00.000-06:00", ZONE_GUATEMALA); doTest_getOffsetFromLocal( 2006,10, 1, 6,30, "2006-10-01T06:30:00.000-06:00", ZONE_GUATEMALA); } public void test_DateTime_plusHour_Guatemata_Autumn() { DateTime dt = new DateTime(2006, 9, 30, 20, 0, 0, 0, ZONE_GUATEMALA); assertEquals("2006-09-30T20:00:00.000-05:00", dt.toString()); DateTime plus1 = dt.plusHours(1); assertEquals("2006-09-30T21:00:00.000-05:00", plus1.toString()); DateTime plus2 = dt.plusHours(2); assertEquals("2006-09-30T22:00:00.000-05:00", plus2.toString()); DateTime plus3 = dt.plusHours(3); assertEquals("2006-09-30T23:00:00.000-05:00", plus3.toString()); DateTime plus4 = dt.plusHours(4); assertEquals("2006-09-30T23:00:00.000-06:00", plus4.toString()); DateTime plus5 = dt.plusHours(5); assertEquals("2006-10-01T00:00:00.000-06:00", plus5.toString()); DateTime plus6 = dt.plusHours(6); assertEquals("2006-10-01T01:00:00.000-06:00", plus6.toString()); DateTime plus7 = dt.plusHours(7); assertEquals("2006-10-01T02:00:00.000-06:00", plus7.toString()); } public void test_DateTime_minusHour_Guatemata_Autumn() { DateTime dt = new DateTime(2006, 10, 1, 2, 0, 0, 0, ZONE_GUATEMALA); assertEquals("2006-10-01T02:00:00.000-06:00", dt.toString()); DateTime minus1 = dt.minusHours(1); assertEquals("2006-10-01T01:00:00.000-06:00", minus1.toString()); DateTime minus2 = dt.minusHours(2); assertEquals("2006-10-01T00:00:00.000-06:00", minus2.toString()); DateTime minus3 = dt.minusHours(3); assertEquals("2006-09-30T23:00:00.000-06:00", minus3.toString()); DateTime minus4 = dt.minusHours(4); assertEquals("2006-09-30T23:00:00.000-05:00", minus4.toString()); DateTime minus5 = dt.minusHours(5); assertEquals("2006-09-30T22:00:00.000-05:00", minus5.toString()); DateTime minus6 = dt.minusHours(6); assertEquals("2006-09-30T21:00:00.000-05:00", minus6.toString()); DateTime minus7 = dt.minusHours(7); assertEquals("2006-09-30T20:00:00.000-05:00", minus7.toString()); } //----------------------------------------------------------------------- //----------------------------------------------------------------------- //----------------------------------------------------------------------- public void test_DateTime_JustAfterLastEverOverlap() { // based on America/Argentina/Catamarca in file 2009s DateTimeZone zone = new DateTimeZoneBuilder() .setStandardOffset(-3 * DateTimeConstants.MILLIS_PER_HOUR) .addRecurringSavings("SUMMER", 1 * DateTimeConstants.MILLIS_PER_HOUR, 2000, 2008, 'w', 4, 10, 0, true, 23 * DateTimeConstants.MILLIS_PER_HOUR) .addRecurringSavings("WINTER", 0, 2000, 2008, 'w', 8, 10, 0, true, 0 * DateTimeConstants.MILLIS_PER_HOUR) .toDateTimeZone("Zone", false); LocalDate date = new LocalDate(2008, 8, 10); assertEquals("2008-08-10", date.toString()); DateTime dt = date.toDateTimeAtStartOfDay(zone); assertEquals("2008-08-10T00:00:00.000-03:00", dt.toString()); } // public void test_toDateMidnight_SaoPaolo() { // // RFE: 1684259 // DateTimeZone zone = DateTimeZone.forID("America/Sao_Paulo"); // LocalDate baseDate = new LocalDate(2006, 11, 5); // DateMidnight dm = baseDate.toDateMidnight(zone); // assertEquals("2006-11-05T00:00:00.000-03:00", dm.toString()); // DateTime dt = baseDate.toDateTimeAtMidnight(zone); // assertEquals("2006-11-05T00:00:00.000-03:00", dt.toString()); // } //----------------------------------------------------------------------- private static final DateTimeZone ZONE_PARIS = DateTimeZone.forID("Europe/Paris"); public void testWithMinuteOfHourInDstChange_mockZone() { DateTime cutover = new DateTime(2010, 10, 31, 1, 15, DateTimeZone.forOffsetHoursMinutes(0, 30)); assertEquals("2010-10-31T01:15:00.000+00:30", cutover.toString()); DateTimeZone halfHourZone = new MockZone(cutover.getMillis(), 3600000, -1800); DateTime pre = new DateTime(2010, 10, 31, 1, 0, halfHourZone); assertEquals("2010-10-31T01:00:00.000+01:00", pre.toString()); DateTime post = new DateTime(2010, 10, 31, 1, 59, halfHourZone); assertEquals("2010-10-31T01:59:00.000+00:30", post.toString()); DateTime testPre1 = pre.withMinuteOfHour(30); assertEquals("2010-10-31T01:30:00.000+01:00", testPre1.toString()); // retain offset DateTime testPre2 = pre.withMinuteOfHour(50); assertEquals("2010-10-31T01:50:00.000+00:30", testPre2.toString()); DateTime testPost1 = post.withMinuteOfHour(30); assertEquals("2010-10-31T01:30:00.000+00:30", testPost1.toString()); // retain offset DateTime testPost2 = post.withMinuteOfHour(10); assertEquals("2010-10-31T01:10:00.000+01:00", testPost2.toString()); } public void testWithHourOfDayInDstChange() { DateTime dateTime = new DateTime("2010-10-31T02:30:10.123+02:00", ZONE_PARIS); assertEquals("2010-10-31T02:30:10.123+02:00", dateTime.toString()); DateTime test = dateTime.withHourOfDay(2); assertEquals("2010-10-31T02:30:10.123+02:00", test.toString()); } public void testWithMinuteOfHourInDstChange() { DateTime dateTime = new DateTime("2010-10-31T02:30:10.123+02:00", ZONE_PARIS); assertEquals("2010-10-31T02:30:10.123+02:00", dateTime.toString()); DateTime test = dateTime.withMinuteOfHour(0); assertEquals("2010-10-31T02:00:10.123+02:00", test.toString()); } public void testWithSecondOfMinuteInDstChange() { DateTime dateTime = new DateTime("2010-10-31T02:30:10.123+02:00", ZONE_PARIS); assertEquals("2010-10-31T02:30:10.123+02:00", dateTime.toString()); DateTime test = dateTime.withSecondOfMinute(0); assertEquals("2010-10-31T02:30:00.123+02:00", test.toString()); } public void testWithMillisOfSecondInDstChange_Paris_summer() { DateTime dateTime = new DateTime("2010-10-31T02:30:10.123+02:00", ZONE_PARIS); assertEquals("2010-10-31T02:30:10.123+02:00", dateTime.toString()); DateTime test = dateTime.withMillisOfSecond(0); assertEquals("2010-10-31T02:30:10.000+02:00", test.toString()); } public void testWithMillisOfSecondInDstChange_Paris_winter() { DateTime dateTime = new DateTime("2010-10-31T02:30:10.123+01:00", ZONE_PARIS); assertEquals("2010-10-31T02:30:10.123+01:00", dateTime.toString()); DateTime test = dateTime.withMillisOfSecond(0); assertEquals("2010-10-31T02:30:10.000+01:00", test.toString()); } public void testWithMillisOfSecondInDstChange_NewYork_summer() { DateTime dateTime = new DateTime("2007-11-04T01:30:00.123-04:00", ZONE_NEW_YORK); assertEquals("2007-11-04T01:30:00.123-04:00", dateTime.toString()); DateTime test = dateTime.withMillisOfSecond(0); assertEquals("2007-11-04T01:30:00.000-04:00", test.toString()); } public void testWithMillisOfSecondInDstChange_NewYork_winter() { DateTime dateTime = new DateTime("2007-11-04T01:30:00.123-05:00", ZONE_NEW_YORK); assertEquals("2007-11-04T01:30:00.123-05:00", dateTime.toString()); DateTime test = dateTime.withMillisOfSecond(0); assertEquals("2007-11-04T01:30:00.000-05:00", test.toString()); } public void testPlusMinutesInDstChange() { DateTime dateTime = new DateTime("2010-10-31T02:30:10.123+02:00", ZONE_PARIS); assertEquals("2010-10-31T02:30:10.123+02:00", dateTime.toString()); DateTime test = dateTime.plusMinutes(1); assertEquals("2010-10-31T02:31:10.123+02:00", test.toString()); } public void testPlusSecondsInDstChange() { DateTime dateTime = new DateTime("2010-10-31T02:30:10.123+02:00", ZONE_PARIS); assertEquals("2010-10-31T02:30:10.123+02:00", dateTime.toString()); DateTime test = dateTime.plusSeconds(1); assertEquals("2010-10-31T02:30:11.123+02:00", test.toString()); } public void testPlusMillisInDstChange() { DateTime dateTime = new DateTime("2010-10-31T02:30:10.123+02:00", ZONE_PARIS); assertEquals("2010-10-31T02:30:10.123+02:00", dateTime.toString()); DateTime test = dateTime.plusMillis(1); assertEquals("2010-10-31T02:30:10.124+02:00", test.toString()); } public void testBug2182444_usCentral() { Chronology chronUSCentral = GregorianChronology.getInstance(DateTimeZone.forID("US/Central")); Chronology chronUTC = GregorianChronology.getInstance(DateTimeZone.UTC); DateTime usCentralStandardInUTC = new DateTime(2008, 11, 2, 7, 0, 0, 0, chronUTC); DateTime usCentralDaylightInUTC = new DateTime(2008, 11, 2, 6, 0, 0, 0, chronUTC); assertTrue("Should be standard time", chronUSCentral.getZone().isStandardOffset(usCentralStandardInUTC.getMillis())); assertFalse("Should be daylight time", chronUSCentral.getZone().isStandardOffset(usCentralDaylightInUTC.getMillis())); DateTime usCentralStandardInUSCentral = usCentralStandardInUTC.toDateTime(chronUSCentral); DateTime usCentralDaylightInUSCentral = usCentralDaylightInUTC.toDateTime(chronUSCentral); assertEquals(1, usCentralStandardInUSCentral.getHourOfDay()); assertEquals(usCentralStandardInUSCentral.getHourOfDay(), usCentralDaylightInUSCentral.getHourOfDay()); assertTrue(usCentralStandardInUSCentral.getMillis() != usCentralDaylightInUSCentral.getMillis()); assertEquals(usCentralStandardInUSCentral, usCentralStandardInUSCentral.withHourOfDay(1)); assertEquals(usCentralStandardInUSCentral.getMillis() + 3, usCentralStandardInUSCentral.withMillisOfSecond(3).getMillis()); assertEquals(usCentralDaylightInUSCentral, usCentralDaylightInUSCentral.withHourOfDay(1)); assertEquals(usCentralDaylightInUSCentral.getMillis() + 3, usCentralDaylightInUSCentral.withMillisOfSecond(3).getMillis()); } public void testBug2182444_ausNSW() { Chronology chronAusNSW = GregorianChronology.getInstance(DateTimeZone.forID("Australia/NSW")); Chronology chronUTC = GregorianChronology.getInstance(DateTimeZone.UTC); DateTime australiaNSWStandardInUTC = new DateTime(2008, 4, 5, 16, 0, 0, 0, chronUTC); DateTime australiaNSWDaylightInUTC = new DateTime(2008, 4, 5, 15, 0, 0, 0, chronUTC); assertTrue("Should be standard time", chronAusNSW.getZone().isStandardOffset(australiaNSWStandardInUTC.getMillis())); assertFalse("Should be daylight time", chronAusNSW.getZone().isStandardOffset(australiaNSWDaylightInUTC.getMillis())); DateTime australiaNSWStandardInAustraliaNSW = australiaNSWStandardInUTC.toDateTime(chronAusNSW); DateTime australiaNSWDaylightInAusraliaNSW = australiaNSWDaylightInUTC.toDateTime(chronAusNSW); assertEquals(2, australiaNSWStandardInAustraliaNSW.getHourOfDay()); assertEquals(australiaNSWStandardInAustraliaNSW.getHourOfDay(), australiaNSWDaylightInAusraliaNSW.getHourOfDay()); assertTrue(australiaNSWStandardInAustraliaNSW.getMillis() != australiaNSWDaylightInAusraliaNSW.getMillis()); assertEquals(australiaNSWStandardInAustraliaNSW, australiaNSWStandardInAustraliaNSW.withHourOfDay(2)); assertEquals(australiaNSWStandardInAustraliaNSW.getMillis() + 3, australiaNSWStandardInAustraliaNSW.withMillisOfSecond(3).getMillis()); assertEquals(australiaNSWDaylightInAusraliaNSW, australiaNSWDaylightInAusraliaNSW.withHourOfDay(2)); assertEquals(australiaNSWDaylightInAusraliaNSW.getMillis() + 3, australiaNSWDaylightInAusraliaNSW.withMillisOfSecond(3).getMillis()); } public void testPeriod() { DateTime a = new DateTime("2010-10-31T02:00:00.000+02:00", ZONE_PARIS); DateTime b = new DateTime("2010-10-31T02:01:00.000+02:00", ZONE_PARIS); Period period = new Period(a, b, PeriodType.standard()); assertEquals("PT1M", period.toString()); } public void testForum4013394_retainOffsetWhenRetainFields_sameOffsetsDifferentZones() { final DateTimeZone fromDTZ = DateTimeZone.forID("Europe/London"); final DateTimeZone toDTZ = DateTimeZone.forID("Europe/Lisbon"); DateTime baseBefore = new DateTime(2007, 10, 28, 1, 15, fromDTZ).minusHours(1); DateTime baseAfter = new DateTime(2007, 10, 28, 1, 15, fromDTZ); DateTime testBefore = baseBefore.withZoneRetainFields(toDTZ); DateTime testAfter = baseAfter.withZoneRetainFields(toDTZ); // toString ignores time-zone but includes offset assertEquals(baseBefore.toString(), testBefore.toString()); assertEquals(baseAfter.toString(), testAfter.toString()); } //------------------------------------------------------------------------- public void testBug3192457_adjustOffset() { final DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); DateTime base = new DateTime(2007, 10, 28, 3, 15, zone); DateTime baseBefore = base.minusHours(2); DateTime baseAfter = base.minusHours(1); assertSame(base, base.withEarlierOffsetAtOverlap()); assertSame(base, base.withLaterOffsetAtOverlap()); assertSame(baseBefore, baseBefore.withEarlierOffsetAtOverlap()); assertEquals(baseAfter, baseBefore.withLaterOffsetAtOverlap()); assertSame(baseAfter, baseAfter.withLaterOffsetAtOverlap()); assertEquals(baseBefore, baseAfter.withEarlierOffsetAtOverlap()); } public void testBug3476684_adjustOffset() { final DateTimeZone zone = DateTimeZone.forID("America/Sao_Paulo"); DateTime base = new DateTime(2012, 2, 25, 22, 15, zone); DateTime baseBefore = base.plusHours(1); // 23:15 (first) DateTime baseAfter = base.plusHours(2); // 23:15 (second) assertSame(base, base.withEarlierOffsetAtOverlap()); assertSame(base, base.withLaterOffsetAtOverlap()); assertSame(baseBefore, baseBefore.withEarlierOffsetAtOverlap()); assertEquals(baseAfter, baseBefore.withLaterOffsetAtOverlap()); assertSame(baseAfter, baseAfter.withLaterOffsetAtOverlap()); assertEquals(baseBefore, baseAfter.withEarlierOffsetAtOverlap()); } public void testBug3476684_adjustOffset_springGap() { final DateTimeZone zone = DateTimeZone.forID("America/Sao_Paulo"); DateTime base = new DateTime(2011, 10, 15, 22, 15, zone); DateTime baseBefore = base.plusHours(1); // 23:15 DateTime baseAfter = base.plusHours(2); // 01:15 assertSame(base, base.withEarlierOffsetAtOverlap()); assertSame(base, base.withLaterOffsetAtOverlap()); assertSame(baseBefore, baseBefore.withEarlierOffsetAtOverlap()); assertEquals(baseBefore, baseBefore.withLaterOffsetAtOverlap()); assertSame(baseAfter, baseAfter.withLaterOffsetAtOverlap()); assertEquals(baseAfter, baseAfter.withEarlierOffsetAtOverlap()); } // ensure Summer time picked //----------------------------------------------------------------------- public void testDateTimeCreation_athens() { DateTimeZone zone = DateTimeZone.forID("Europe/Athens"); DateTime base = new DateTime(2011, 10, 30, 3, 15, zone); assertEquals("2011-10-30T03:15:00.000+03:00", base.toString()); assertEquals("2011-10-30T03:15:00.000+02:00", base.plusHours(1).toString()); } public void testDateTimeCreation_paris() { DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); DateTime base = new DateTime(2011, 10, 30, 2, 15, zone); assertEquals("2011-10-30T02:15:00.000+02:00", base.toString()); assertEquals("2011-10-30T02:15:00.000+01:00", base.plusHours(1).toString()); } public void testDateTimeCreation_london() { DateTimeZone zone = DateTimeZone.forID("Europe/London"); DateTime base = new DateTime(2011, 10, 30, 1, 15, zone); assertEquals("2011-10-30T01:15:00.000+01:00", base.toString()); assertEquals("2011-10-30T01:15:00.000Z", base.plusHours(1).toString()); } public void testDateTimeCreation_newYork() { DateTimeZone zone = DateTimeZone.forID("America/New_York"); DateTime base = new DateTime(2010, 11, 7, 1, 15, zone); assertEquals("2010-11-07T01:15:00.000-04:00", base.toString()); assertEquals("2010-11-07T01:15:00.000-05:00", base.plusHours(1).toString()); } public void testDateTimeCreation_losAngeles() { DateTimeZone zone = DateTimeZone.forID("America/Los_Angeles"); DateTime base = new DateTime(2010, 11, 7, 1, 15, zone); assertEquals("2010-11-07T01:15:00.000-07:00", base.toString()); assertEquals("2010-11-07T01:15:00.000-08:00", base.plusHours(1).toString()); } //----------------------------------------------------------------------- //----------------------------------------------------------------------- //----------------------------------------------------------------------- private void doTest_getOffsetFromLocal(int month, int day, int hour, int min, String expected, DateTimeZone zone) { doTest_getOffsetFromLocal(2007, month, day, hour, min, 0, 0, expected, zone); } private void doTest_getOffsetFromLocal(int month, int day, int hour, int min, int sec, int milli, String expected, DateTimeZone zone) { doTest_getOffsetFromLocal(2007, month, day, hour, min, sec, milli, expected, zone); } private void doTest_getOffsetFromLocal(int year, int month, int day, int hour, int min, String expected, DateTimeZone zone) { doTest_getOffsetFromLocal(year, month, day, hour, min, 0, 0, expected, zone); } private void doTest_getOffsetFromLocal(int year, int month, int day, int hour, int min, int sec, int milli, String expected, DateTimeZone zone) { DateTime dt = new DateTime(year, month, day, hour, min, sec, milli, DateTimeZone.UTC); int offset = zone.getOffsetFromLocal(dt.getMillis()); DateTime res = new DateTime(dt.getMillis() - offset, zone); assertEquals(res.toString(), expected, res.toString()); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.base.AbstractInstant; import org.joda.time.chrono.BaseChronology; import org.joda.time.chrono.BuddhistChronology; import org.joda.time.chrono.CopticChronology; import org.joda.time.chrono.GJChronology; import org.joda.time.chrono.GregorianChronology; import org.joda.time.chrono.ISOChronology; import org.joda.time.field.UnsupportedDateTimeField; import org.joda.time.field.UnsupportedDurationField; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; /** * This class is a Junit unit test for DateTime. * * @author Stephen Colebourne */ public class TestDateTime_Basics extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); // the default time zone is set to LONDON in setUp() // we have to hard code LONDON here (instead of ISOChronology.getInstance() etc.) // as TestAll sets up a different time zone for better all-round testing private static final ISOChronology ISO_UTC = ISOChronology.getInstanceUTC(); private static final ISOChronology ISO_DEFAULT = ISOChronology.getInstance(LONDON); private static final ISOChronology ISO_PARIS = ISOChronology.getInstance(PARIS); private static final GJChronology GJ_DEFAULT = GJChronology.getInstance(LONDON); private static final GregorianChronology GREGORIAN_DEFAULT = GregorianChronology.getInstance(LONDON); private static final GregorianChronology GREGORIAN_PARIS = GregorianChronology.getInstance(PARIS); private static final BuddhistChronology BUDDHIST_UTC = BuddhistChronology.getInstanceUTC(); private static final BuddhistChronology BUDDHIST_DEFAULT = BuddhistChronology.getInstance(LONDON); private static final CopticChronology COPTIC_DEFAULT = CopticChronology.getInstance(LONDON); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; // 2002-04-05 private long TEST_TIME1 = (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; // 2003-05-06 private long TEST_TIME2 = (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestDateTime_Basics.class); } public TestDateTime_Basics(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testTest() { assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString()); assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString()); assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString()); } //----------------------------------------------------------------------- public void testGet_DateTimeField() { DateTime test = new DateTime(); assertEquals(1, test.get(ISO_DEFAULT.era())); assertEquals(20, test.get(ISO_DEFAULT.centuryOfEra())); assertEquals(2, test.get(ISO_DEFAULT.yearOfCentury())); assertEquals(2002, test.get(ISO_DEFAULT.yearOfEra())); assertEquals(2002, test.get(ISO_DEFAULT.year())); assertEquals(6, test.get(ISO_DEFAULT.monthOfYear())); assertEquals(9, test.get(ISO_DEFAULT.dayOfMonth())); assertEquals(2002, test.get(ISO_DEFAULT.weekyear())); assertEquals(23, test.get(ISO_DEFAULT.weekOfWeekyear())); assertEquals(7, test.get(ISO_DEFAULT.dayOfWeek())); assertEquals(160, test.get(ISO_DEFAULT.dayOfYear())); assertEquals(0, test.get(ISO_DEFAULT.halfdayOfDay())); assertEquals(1, test.get(ISO_DEFAULT.hourOfHalfday())); assertEquals(1, test.get(ISO_DEFAULT.clockhourOfDay())); assertEquals(1, test.get(ISO_DEFAULT.clockhourOfHalfday())); assertEquals(1, test.get(ISO_DEFAULT.hourOfDay())); assertEquals(0, test.get(ISO_DEFAULT.minuteOfHour())); assertEquals(60, test.get(ISO_DEFAULT.minuteOfDay())); assertEquals(0, test.get(ISO_DEFAULT.secondOfMinute())); assertEquals(60 * 60, test.get(ISO_DEFAULT.secondOfDay())); assertEquals(0, test.get(ISO_DEFAULT.millisOfSecond())); assertEquals(60 * 60 * 1000, test.get(ISO_DEFAULT.millisOfDay())); try { test.get((DateTimeField) null); fail(); } catch (IllegalArgumentException ex) {} } public void testGet_DateTimeFieldType() { DateTime test = new DateTime(); assertEquals(1, test.get(DateTimeFieldType.era())); assertEquals(20, test.get(DateTimeFieldType.centuryOfEra())); assertEquals(2, test.get(DateTimeFieldType.yearOfCentury())); assertEquals(2002, test.get(DateTimeFieldType.yearOfEra())); assertEquals(2002, test.get(DateTimeFieldType.year())); assertEquals(6, test.get(DateTimeFieldType.monthOfYear())); assertEquals(9, test.get(DateTimeFieldType.dayOfMonth())); assertEquals(2002, test.get(DateTimeFieldType.weekyear())); assertEquals(23, test.get(DateTimeFieldType.weekOfWeekyear())); assertEquals(7, test.get(DateTimeFieldType.dayOfWeek())); assertEquals(160, test.get(DateTimeFieldType.dayOfYear())); assertEquals(0, test.get(DateTimeFieldType.halfdayOfDay())); assertEquals(1, test.get(DateTimeFieldType.hourOfHalfday())); assertEquals(1, test.get(DateTimeFieldType.clockhourOfDay())); assertEquals(1, test.get(DateTimeFieldType.clockhourOfHalfday())); assertEquals(1, test.get(DateTimeFieldType.hourOfDay())); assertEquals(0, test.get(DateTimeFieldType.minuteOfHour())); assertEquals(60, test.get(DateTimeFieldType.minuteOfDay())); assertEquals(0, test.get(DateTimeFieldType.secondOfMinute())); assertEquals(60 * 60, test.get(DateTimeFieldType.secondOfDay())); assertEquals(0, test.get(DateTimeFieldType.millisOfSecond())); assertEquals(60 * 60 * 1000, test.get(DateTimeFieldType.millisOfDay())); try { test.get((DateTimeFieldType) null); fail(); } catch (IllegalArgumentException ex) {} } public void testIsSupported_DateTimeFieldType() { DateTime test = new DateTime(); assertEquals(true, test.isSupported(DateTimeFieldType.era())); assertEquals(true, test.isSupported(DateTimeFieldType.centuryOfEra())); assertEquals(true, test.isSupported(DateTimeFieldType.yearOfCentury())); assertEquals(true, test.isSupported(DateTimeFieldType.yearOfEra())); assertEquals(true, test.isSupported(DateTimeFieldType.year())); assertEquals(true, test.isSupported(DateTimeFieldType.monthOfYear())); assertEquals(true, test.isSupported(DateTimeFieldType.dayOfMonth())); assertEquals(true, test.isSupported(DateTimeFieldType.weekyear())); assertEquals(true, test.isSupported(DateTimeFieldType.weekOfWeekyear())); assertEquals(true, test.isSupported(DateTimeFieldType.dayOfWeek())); assertEquals(true, test.isSupported(DateTimeFieldType.dayOfYear())); assertEquals(true, test.isSupported(DateTimeFieldType.halfdayOfDay())); assertEquals(true, test.isSupported(DateTimeFieldType.hourOfHalfday())); assertEquals(true, test.isSupported(DateTimeFieldType.clockhourOfDay())); assertEquals(true, test.isSupported(DateTimeFieldType.clockhourOfHalfday())); assertEquals(true, test.isSupported(DateTimeFieldType.hourOfDay())); assertEquals(true, test.isSupported(DateTimeFieldType.minuteOfHour())); assertEquals(true, test.isSupported(DateTimeFieldType.minuteOfDay())); assertEquals(true, test.isSupported(DateTimeFieldType.secondOfMinute())); assertEquals(true, test.isSupported(DateTimeFieldType.secondOfDay())); assertEquals(true, test.isSupported(DateTimeFieldType.millisOfSecond())); assertEquals(true, test.isSupported(DateTimeFieldType.millisOfDay())); assertEquals(false, test.isSupported(null)); } //----------------------------------------------------------------------- public void testGetters() { DateTime test = new DateTime(); assertEquals(ISO_DEFAULT, test.getChronology()); assertEquals(LONDON, test.getZone()); assertEquals(TEST_TIME_NOW, test.getMillis()); assertEquals(1, test.getEra()); assertEquals(20, test.getCenturyOfEra()); assertEquals(2, test.getYearOfCentury()); assertEquals(2002, test.getYearOfEra()); assertEquals(2002, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(2002, test.getWeekyear()); assertEquals(23, test.getWeekOfWeekyear()); assertEquals(7, test.getDayOfWeek()); assertEquals(160, test.getDayOfYear()); assertEquals(1, test.getHourOfDay()); assertEquals(0, test.getMinuteOfHour()); assertEquals(60, test.getMinuteOfDay()); assertEquals(0, test.getSecondOfMinute()); assertEquals(60 * 60, test.getSecondOfDay()); assertEquals(0, test.getMillisOfSecond()); assertEquals(60 * 60 * 1000, test.getMillisOfDay()); } public void testWithers() { DateTime test = new DateTime(1970, 6, 9, 10, 20, 30, 40, GJ_DEFAULT); check(test.withYear(2000), 2000, 6, 9, 10, 20, 30, 40); check(test.withMonthOfYear(2), 1970, 2, 9, 10, 20, 30, 40); check(test.withDayOfMonth(2), 1970, 6, 2, 10, 20, 30, 40); check(test.withDayOfYear(6), 1970, 1, 6, 10, 20, 30, 40); check(test.withDayOfWeek(6), 1970, 6, 13, 10, 20, 30, 40); check(test.withWeekOfWeekyear(6), 1970, 2, 3, 10, 20, 30, 40); check(test.withWeekyear(1971), 1971, 6, 15, 10, 20, 30, 40); check(test.withYearOfCentury(60), 1960, 6, 9, 10, 20, 30, 40); check(test.withCenturyOfEra(21), 2070, 6, 9, 10, 20, 30, 40); check(test.withYearOfEra(1066), 1066, 6, 9, 10, 20, 30, 40); check(test.withEra(DateTimeConstants.BC), -1970, 6, 9, 10, 20, 30, 40); check(test.withHourOfDay(6), 1970, 6, 9, 6, 20, 30, 40); check(test.withMinuteOfHour(6), 1970, 6, 9, 10, 6, 30, 40); check(test.withSecondOfMinute(6), 1970, 6, 9, 10, 20, 6, 40); check(test.withMillisOfSecond(6), 1970, 6, 9, 10, 20, 30, 6); check(test.withMillisOfDay(61234), 1970, 6, 9, 0, 1, 1, 234); try { test.withMonthOfYear(0); fail(); } catch (IllegalArgumentException ex) {} try { test.withMonthOfYear(13); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testEqualsHashCode() { DateTime test1 = new DateTime(TEST_TIME1); DateTime test2 = new DateTime(TEST_TIME1); assertEquals(true, test1.equals(test2)); assertEquals(true, test2.equals(test1)); assertEquals(true, test1.equals(test1)); assertEquals(true, test2.equals(test2)); assertEquals(true, test1.hashCode() == test2.hashCode()); assertEquals(true, test1.hashCode() == test1.hashCode()); assertEquals(true, test2.hashCode() == test2.hashCode()); DateTime test3 = new DateTime(TEST_TIME2); assertEquals(false, test1.equals(test3)); assertEquals(false, test2.equals(test3)); assertEquals(false, test3.equals(test1)); assertEquals(false, test3.equals(test2)); assertEquals(false, test1.hashCode() == test3.hashCode()); assertEquals(false, test2.hashCode() == test3.hashCode()); assertEquals(false, test1.equals("Hello")); assertEquals(true, test1.equals(new MockInstant())); assertEquals(false, test1.equals(new DateTime(TEST_TIME1, GREGORIAN_DEFAULT))); assertEquals(true, new DateTime(TEST_TIME1, new MockEqualsChronology()).equals(new DateTime(TEST_TIME1, new MockEqualsChronology()))); assertEquals(false, new DateTime(TEST_TIME1, new MockEqualsChronology()).equals(new DateTime(TEST_TIME1, ISO_DEFAULT))); } class MockInstant extends AbstractInstant { public String toString() { return null; } public long getMillis() { return TEST_TIME1; } public Chronology getChronology() { return ISO_DEFAULT; } } class MockEqualsChronology extends BaseChronology { private static final long serialVersionUID = 1L; public boolean equals(Object obj) { return obj instanceof MockEqualsChronology; } public DateTimeZone getZone() { return null; } public Chronology withUTC() { return this; } public Chronology withZone(DateTimeZone zone) { return this; } public String toString() { return ""; } } public void testCompareTo() { DateTime test1 = new DateTime(TEST_TIME1); DateTime test1a = new DateTime(TEST_TIME1); assertEquals(0, test1.compareTo(test1a)); assertEquals(0, test1a.compareTo(test1)); assertEquals(0, test1.compareTo(test1)); assertEquals(0, test1a.compareTo(test1a)); DateTime test2 = new DateTime(TEST_TIME2); assertEquals(-1, test1.compareTo(test2)); assertEquals(+1, test2.compareTo(test1)); DateTime test3 = new DateTime(TEST_TIME2, GREGORIAN_PARIS); assertEquals(-1, test1.compareTo(test3)); assertEquals(+1, test3.compareTo(test1)); assertEquals(0, test3.compareTo(test2)); assertEquals(+1, test2.compareTo(new MockInstant())); assertEquals(0, test1.compareTo(new MockInstant())); try { test1.compareTo(null); fail(); } catch (NullPointerException ex) {} // try { // test1.compareTo(new Date()); // fail(); // } catch (ClassCastException ex) {} } //----------------------------------------------------------------------- public void testIsEqual_long() { assertEquals(false, new DateTime(TEST_TIME1).isEqual(TEST_TIME2)); assertEquals(true, new DateTime(TEST_TIME1).isEqual(TEST_TIME1)); assertEquals(false, new DateTime(TEST_TIME2).isEqual(TEST_TIME1)); } public void testIsEqualNow() { assertEquals(false, new DateTime(TEST_TIME_NOW - 1).isEqualNow()); assertEquals(true, new DateTime(TEST_TIME_NOW).isEqualNow()); assertEquals(false, new DateTime(TEST_TIME_NOW + 1).isEqualNow()); } public void testIsEqual_RI() { DateTime test1 = new DateTime(TEST_TIME1); DateTime test1a = new DateTime(TEST_TIME1); assertEquals(true, test1.isEqual(test1a)); assertEquals(true, test1a.isEqual(test1)); assertEquals(true, test1.isEqual(test1)); assertEquals(true, test1a.isEqual(test1a)); DateTime test2 = new DateTime(TEST_TIME2); assertEquals(false, test1.isEqual(test2)); assertEquals(false, test2.isEqual(test1)); DateTime test3 = new DateTime(TEST_TIME2, GREGORIAN_PARIS); assertEquals(false, test1.isEqual(test3)); assertEquals(false, test3.isEqual(test1)); assertEquals(true, test3.isEqual(test2)); assertEquals(false, test2.isEqual(new MockInstant())); assertEquals(true, test1.isEqual(new MockInstant())); assertEquals(false, new DateTime(TEST_TIME_NOW + 1).isEqual(null)); assertEquals(true, new DateTime(TEST_TIME_NOW).isEqual(null)); assertEquals(false, new DateTime(TEST_TIME_NOW - 1).isEqual(null)); } //----------------------------------------------------------------------- public void testIsBefore_long() { assertEquals(true, new DateTime(TEST_TIME1).isBefore(TEST_TIME2)); assertEquals(false, new DateTime(TEST_TIME1).isBefore(TEST_TIME1)); assertEquals(false, new DateTime(TEST_TIME2).isBefore(TEST_TIME1)); } public void testIsBeforeNow() { assertEquals(true, new DateTime(TEST_TIME_NOW - 1).isBeforeNow()); assertEquals(false, new DateTime(TEST_TIME_NOW).isBeforeNow()); assertEquals(false, new DateTime(TEST_TIME_NOW + 1).isBeforeNow()); } public void testIsBefore_RI() { DateTime test1 = new DateTime(TEST_TIME1); DateTime test1a = new DateTime(TEST_TIME1); assertEquals(false, test1.isBefore(test1a)); assertEquals(false, test1a.isBefore(test1)); assertEquals(false, test1.isBefore(test1)); assertEquals(false, test1a.isBefore(test1a)); DateTime test2 = new DateTime(TEST_TIME2); assertEquals(true, test1.isBefore(test2)); assertEquals(false, test2.isBefore(test1)); DateTime test3 = new DateTime(TEST_TIME2, GREGORIAN_PARIS); assertEquals(true, test1.isBefore(test3)); assertEquals(false, test3.isBefore(test1)); assertEquals(false, test3.isBefore(test2)); assertEquals(false, test2.isBefore(new MockInstant())); assertEquals(false, test1.isBefore(new MockInstant())); assertEquals(false, new DateTime(TEST_TIME_NOW + 1).isBefore(null)); assertEquals(false, new DateTime(TEST_TIME_NOW).isBefore(null)); assertEquals(true, new DateTime(TEST_TIME_NOW - 1).isBefore(null)); } //----------------------------------------------------------------------- public void testIsAfter_long() { assertEquals(false, new DateTime(TEST_TIME1).isAfter(TEST_TIME2)); assertEquals(false, new DateTime(TEST_TIME1).isAfter(TEST_TIME1)); assertEquals(true, new DateTime(TEST_TIME2).isAfter(TEST_TIME1)); } public void testIsAfterNow() { assertEquals(false, new DateTime(TEST_TIME_NOW - 1).isAfterNow()); assertEquals(false, new DateTime(TEST_TIME_NOW).isAfterNow()); assertEquals(true, new DateTime(TEST_TIME_NOW + 1).isAfterNow()); } public void testIsAfter_RI() { DateTime test1 = new DateTime(TEST_TIME1); DateTime test1a = new DateTime(TEST_TIME1); assertEquals(false, test1.isAfter(test1a)); assertEquals(false, test1a.isAfter(test1)); assertEquals(false, test1.isAfter(test1)); assertEquals(false, test1a.isAfter(test1a)); DateTime test2 = new DateTime(TEST_TIME2); assertEquals(false, test1.isAfter(test2)); assertEquals(true, test2.isAfter(test1)); DateTime test3 = new DateTime(TEST_TIME2, GREGORIAN_PARIS); assertEquals(false, test1.isAfter(test3)); assertEquals(true, test3.isAfter(test1)); assertEquals(false, test3.isAfter(test2)); assertEquals(true, test2.isAfter(new MockInstant())); assertEquals(false, test1.isAfter(new MockInstant())); assertEquals(true, new DateTime(TEST_TIME_NOW + 1).isAfter(null)); assertEquals(false, new DateTime(TEST_TIME_NOW).isAfter(null)); assertEquals(false, new DateTime(TEST_TIME_NOW - 1).isAfter(null)); } //----------------------------------------------------------------------- public void testSerialization() throws Exception { DateTime test = new DateTime(TEST_TIME_NOW); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(test); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); DateTime result = (DateTime) ois.readObject(); ois.close(); assertEquals(test, result); } //----------------------------------------------------------------------- public void testToString() { DateTime test = new DateTime(TEST_TIME_NOW); assertEquals("2002-06-09T01:00:00.000+01:00", test.toString()); test = new DateTime(TEST_TIME_NOW, PARIS); assertEquals("2002-06-09T02:00:00.000+02:00", test.toString()); } public void testToString_String() { DateTime test = new DateTime(TEST_TIME_NOW); assertEquals("2002 01", test.toString("yyyy HH")); assertEquals("2002-06-09T01:00:00.000+01:00", test.toString((String) null)); } public void testToString_String_Locale() { DateTime test = new DateTime(TEST_TIME_NOW); assertEquals("Sun 9/6", test.toString("EEE d/M", Locale.ENGLISH)); assertEquals("dim. 9/6", test.toString("EEE d/M", Locale.FRENCH)); assertEquals("2002-06-09T01:00:00.000+01:00", test.toString(null, Locale.ENGLISH)); assertEquals("Sun 9/6", test.toString("EEE d/M", null)); assertEquals("2002-06-09T01:00:00.000+01:00", test.toString(null, null)); } @SuppressWarnings("deprecation") public void testToString_DTFormatter() { DateMidnight test = new DateMidnight(TEST_TIME_NOW); assertEquals("2002 00", test.toString(DateTimeFormat.forPattern("yyyy HH"))); assertEquals("2002-06-09T00:00:00.000+01:00", test.toString((DateTimeFormatter) null)); } //----------------------------------------------------------------------- public void testToInstant() { DateTime test = new DateTime(TEST_TIME1); Instant result = test.toInstant(); assertEquals(TEST_TIME1, result.getMillis()); } public void testToDateTime() { DateTime test = new DateTime(TEST_TIME1); DateTime result = test.toDateTime(); assertSame(test, result); } public void testToDateTimeISO() { DateTime test = new DateTime(TEST_TIME1); DateTime result = test.toDateTimeISO(); assertSame(test, result); test = new DateTime(TEST_TIME1, ISO_PARIS); result = test.toDateTimeISO(); assertSame(DateTime.class, result.getClass()); assertSame(ISOChronology.class, result.getChronology().getClass()); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISO_PARIS, result.getChronology()); assertNotSame(test, result); test = new DateTime(TEST_TIME1, BUDDHIST_DEFAULT); result = test.toDateTimeISO(); assertSame(DateTime.class, result.getClass()); assertSame(ISOChronology.class, result.getChronology().getClass()); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISO_DEFAULT, result.getChronology()); assertNotSame(test, result); test = new DateTime(TEST_TIME1, new MockNullZoneChronology()); result = test.toDateTimeISO(); assertSame(DateTime.class, result.getClass()); assertSame(ISOChronology.class, result.getChronology().getClass()); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISO_DEFAULT, result.getChronology()); assertNotSame(test, result); } public void testToDateTime_DateTimeZone() { DateTime test = new DateTime(TEST_TIME1); DateTime result = test.toDateTime(LONDON); assertSame(test, result); test = new DateTime(TEST_TIME1); result = test.toDateTime(PARIS); assertEquals(test.getMillis(), result.getMillis()); assertEquals(PARIS, result.getZone()); test = new DateTime(TEST_TIME1, PARIS); result = test.toDateTime((DateTimeZone) null); assertEquals(test.getMillis(), result.getMillis()); assertEquals(LONDON, result.getZone()); test = new DateTime(TEST_TIME1); result = test.toDateTime((DateTimeZone) null); assertSame(test, result); } public void testToDateTime_Chronology() { DateTime test = new DateTime(TEST_TIME1); DateTime result = test.toDateTime(ISO_DEFAULT); assertSame(test, result); test = new DateTime(TEST_TIME1); result = test.toDateTime(GREGORIAN_PARIS); assertEquals(test.getMillis(), result.getMillis()); assertEquals(GREGORIAN_PARIS, result.getChronology()); test = new DateTime(TEST_TIME1, GREGORIAN_PARIS); result = test.toDateTime((Chronology) null); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISO_DEFAULT, result.getChronology()); test = new DateTime(TEST_TIME1); result = test.toDateTime((Chronology) null); assertSame(test, result); } public void testToMutableDateTime() { DateTime test = new DateTime(TEST_TIME1, PARIS); MutableDateTime result = test.toMutableDateTime(); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISO_PARIS, result.getChronology()); } public void testToMutableDateTimeISO() { DateTime test = new DateTime(TEST_TIME1, PARIS); MutableDateTime result = test.toMutableDateTimeISO(); assertSame(MutableDateTime.class, result.getClass()); assertSame(ISOChronology.class, result.getChronology().getClass()); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISO_PARIS, result.getChronology()); } public void testToMutableDateTime_DateTimeZone() { DateTime test = new DateTime(TEST_TIME1); MutableDateTime result = test.toMutableDateTime(LONDON); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISO_DEFAULT, result.getChronology()); test = new DateTime(TEST_TIME1); result = test.toMutableDateTime(PARIS); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISO_PARIS, result.getChronology()); test = new DateTime(TEST_TIME1, PARIS); result = test.toMutableDateTime((DateTimeZone) null); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISO_DEFAULT, result.getChronology()); test = new DateTime(TEST_TIME1); result = test.toMutableDateTime((DateTimeZone) null); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISO_DEFAULT, result.getChronology()); } public void testToMutableDateTime_Chronology() { DateTime test = new DateTime(TEST_TIME1); MutableDateTime result = test.toMutableDateTime(ISO_DEFAULT); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISO_DEFAULT, result.getChronology()); test = new DateTime(TEST_TIME1); result = test.toMutableDateTime(GREGORIAN_PARIS); assertEquals(test.getMillis(), result.getMillis()); assertEquals(GREGORIAN_PARIS, result.getChronology()); test = new DateTime(TEST_TIME1, GREGORIAN_PARIS); result = test.toMutableDateTime((Chronology) null); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISO_DEFAULT, result.getChronology()); test = new DateTime(TEST_TIME1); result = test.toMutableDateTime((Chronology) null); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISO_DEFAULT, result.getChronology()); } public void testToDate() { DateTime test = new DateTime(TEST_TIME1); Date result = test.toDate(); assertEquals(test.getMillis(), result.getTime()); } public void testToCalendar_Locale() { DateTime test = new DateTime(TEST_TIME1); Calendar result = test.toCalendar(null); assertEquals(test.getMillis(), result.getTime().getTime()); assertEquals(TimeZone.getTimeZone("Europe/London"), result.getTimeZone()); test = new DateTime(TEST_TIME1, PARIS); result = test.toCalendar(null); assertEquals(test.getMillis(), result.getTime().getTime()); assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone()); test = new DateTime(TEST_TIME1, PARIS); result = test.toCalendar(Locale.UK); assertEquals(test.getMillis(), result.getTime().getTime()); assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone()); } public void testToGregorianCalendar() { DateTime test = new DateTime(TEST_TIME1); GregorianCalendar result = test.toGregorianCalendar(); assertEquals(test.getMillis(), result.getTime().getTime()); assertEquals(TimeZone.getTimeZone("Europe/London"), result.getTimeZone()); test = new DateTime(TEST_TIME1, PARIS); result = test.toGregorianCalendar(); assertEquals(test.getMillis(), result.getTime().getTime()); assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone()); } //----------------------------------------------------------------------- @SuppressWarnings("deprecation") public void testToDateMidnight() { DateTime base = new DateTime(TEST_TIME1, COPTIC_DEFAULT); DateMidnight test = base.toDateMidnight(); assertEquals(new DateMidnight(base, COPTIC_DEFAULT), test); } @SuppressWarnings("deprecation") public void testToYearMonthDay() { DateTime base = new DateTime(TEST_TIME1, COPTIC_DEFAULT); YearMonthDay test = base.toYearMonthDay(); assertEquals(new YearMonthDay(TEST_TIME1, COPTIC_DEFAULT), test); } @SuppressWarnings("deprecation") public void testToTimeOfDay() { DateTime base = new DateTime(TEST_TIME1, COPTIC_DEFAULT); TimeOfDay test = base.toTimeOfDay(); assertEquals(new TimeOfDay(TEST_TIME1, COPTIC_DEFAULT), test); } public void testToLocalDateTime() { DateTime base = new DateTime(TEST_TIME1, COPTIC_DEFAULT); LocalDateTime test = base.toLocalDateTime(); assertEquals(new LocalDateTime(TEST_TIME1, COPTIC_DEFAULT), test); } public void testToLocalDate() { DateTime base = new DateTime(TEST_TIME1, COPTIC_DEFAULT); LocalDate test = base.toLocalDate(); assertEquals(new LocalDate(TEST_TIME1, COPTIC_DEFAULT), test); } public void testToLocalTime() { DateTime base = new DateTime(TEST_TIME1, COPTIC_DEFAULT); LocalTime test = base.toLocalTime(); assertEquals(new LocalTime(TEST_TIME1, COPTIC_DEFAULT), test); } //----------------------------------------------------------------------- public void testWithMillis_long() { DateTime test = new DateTime(TEST_TIME1); DateTime result = test.withMillis(TEST_TIME2); assertEquals(TEST_TIME2, result.getMillis()); assertEquals(test.getChronology(), result.getChronology()); test = new DateTime(TEST_TIME1, GREGORIAN_PARIS); result = test.withMillis(TEST_TIME2); assertEquals(TEST_TIME2, result.getMillis()); assertEquals(test.getChronology(), result.getChronology()); test = new DateTime(TEST_TIME1); result = test.withMillis(TEST_TIME1); assertSame(test, result); } public void testWithChronology_Chronology() { DateTime test = new DateTime(TEST_TIME1); DateTime result = test.withChronology(GREGORIAN_PARIS); assertEquals(test.getMillis(), result.getMillis()); assertEquals(GREGORIAN_PARIS, result.getChronology()); test = new DateTime(TEST_TIME1, GREGORIAN_PARIS); result = test.withChronology(null); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISO_DEFAULT, result.getChronology()); test = new DateTime(TEST_TIME1); result = test.withChronology(null); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISO_DEFAULT, result.getChronology()); test = new DateTime(TEST_TIME1); result = test.withChronology(ISO_DEFAULT); assertSame(test, result); } public void testWithZone_DateTimeZone() { DateTime test = new DateTime(TEST_TIME1); DateTime result = test.withZone(PARIS); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISO_PARIS, result.getChronology()); test = new DateTime(TEST_TIME1, GREGORIAN_PARIS); result = test.withZone(null); assertEquals(test.getMillis(), result.getMillis()); assertEquals(GREGORIAN_DEFAULT, result.getChronology()); test = new DateTime(TEST_TIME1); result = test.withZone(null); assertSame(test, result); } public void testWithZoneRetainFields_DateTimeZone() { DateTime test = new DateTime(TEST_TIME1); DateTime result = test.withZoneRetainFields(PARIS); assertEquals(test.getMillis() - DateTimeConstants.MILLIS_PER_HOUR, result.getMillis()); assertEquals(ISO_PARIS, result.getChronology()); test = new DateTime(TEST_TIME1); result = test.withZoneRetainFields(LONDON); assertSame(test, result); test = new DateTime(TEST_TIME1); result = test.withZoneRetainFields(null); assertSame(test, result); test = new DateTime(TEST_TIME1, GREGORIAN_PARIS); result = test.withZoneRetainFields(null); assertEquals(test.getMillis() + DateTimeConstants.MILLIS_PER_HOUR, result.getMillis()); assertEquals(GREGORIAN_DEFAULT, result.getChronology()); test = new DateTime(TEST_TIME1, new MockNullZoneChronology()); result = test.withZoneRetainFields(LONDON); assertSame(test, result); } //----------------------------------------------------------------------- public void testWithDate_int_int_int() { DateTime test = new DateTime(2002, 4, 5, 1, 2, 3, 4, ISO_UTC); DateTime result = test.withDate(2003, 5, 6); DateTime expected = new DateTime(2003, 5, 6, 1, 2, 3, 4, ISO_UTC); assertEquals(expected, result); test = new DateTime(TEST_TIME1); try { test.withDate(2003, 13, 1); fail(); } catch (IllegalArgumentException ex) {} } public void testWithTime_int_int_int() { DateTime test = new DateTime(TEST_TIME1 - 12345L, BUDDHIST_UTC); DateTime result = test.withTime(12, 24, 0, 0); assertEquals(TEST_TIME1, result.getMillis()); assertEquals(BUDDHIST_UTC, result.getChronology()); test = new DateTime(TEST_TIME1); try { test.withTime(25, 1, 1, 1); fail(); } catch (IllegalArgumentException ex) {} } @SuppressWarnings("deprecation") public void testWithFields_RPartial() { DateTime test = new DateTime(2004, 5, 6, 7, 8, 9, 0); DateTime result = test.withFields(new YearMonthDay(2003, 4, 5)); DateTime expected = new DateTime(2003, 4, 5, 7, 8, 9, 0); assertEquals(expected, result); test = new DateTime(TEST_TIME1); result = test.withFields(null); assertSame(test, result); } //----------------------------------------------------------------------- public void testWithField1() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime result = test.withField(DateTimeFieldType.year(), 2006); assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0), test); assertEquals(new DateTime(2006, 6, 9, 0, 0, 0, 0), result); } public void testWithField2() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); try { test.withField(null, 6); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testWithFieldAdded1() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime result = test.withFieldAdded(DurationFieldType.years(), 6); assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0), test); assertEquals(new DateTime(2010, 6, 9, 0, 0, 0, 0), result); } public void testWithFieldAdded2() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); try { test.withFieldAdded(null, 0); fail(); } catch (IllegalArgumentException ex) {} } public void testWithFieldAdded3() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); try { test.withFieldAdded(null, 6); fail(); } catch (IllegalArgumentException ex) {} } public void testWithFieldAdded4() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime result = test.withFieldAdded(DurationFieldType.years(), 0); assertSame(test, result); } //----------------------------------------------------------------------- public void testWithDurationAdded_long_int() { DateTime test = new DateTime(TEST_TIME1, BUDDHIST_DEFAULT); DateTime result = test.withDurationAdded(123456789L, 1); DateTime expected = new DateTime(TEST_TIME1 + 123456789L, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.withDurationAdded(123456789L, 0); assertSame(test, result); result = test.withDurationAdded(123456789L, 2); expected = new DateTime(TEST_TIME1 + (2L * 123456789L), BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.withDurationAdded(123456789L, -3); expected = new DateTime(TEST_TIME1 - (3L * 123456789L), BUDDHIST_DEFAULT); assertEquals(expected, result); } //----------------------------------------------------------------------- public void testWithDurationAdded_RD_int() { DateTime test = new DateTime(TEST_TIME1, BUDDHIST_DEFAULT); DateTime result = test.withDurationAdded(new Duration(123456789L), 1); DateTime expected = new DateTime(TEST_TIME1 + 123456789L, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.withDurationAdded(null, 1); assertSame(test, result); result = test.withDurationAdded(new Duration(123456789L), 0); assertSame(test, result); result = test.withDurationAdded(new Duration(123456789L), 2); expected = new DateTime(TEST_TIME1 + (2L * 123456789L), BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.withDurationAdded(new Duration(123456789L), -3); expected = new DateTime(TEST_TIME1 - (3L * 123456789L), BUDDHIST_DEFAULT); assertEquals(expected, result); } //----------------------------------------------------------------------- public void testWithDurationAdded_RP_int() { DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BUDDHIST_DEFAULT); DateTime result = test.withPeriodAdded(new Period(1, 2, 3, 4, 5, 6, 7, 8), 1); DateTime expected = new DateTime(2003, 7, 28, 6, 8, 10, 12, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.withPeriodAdded(null, 1); assertSame(test, result); result = test.withPeriodAdded(new Period(1, 2, 3, 4, 5, 6, 7, 8), 0); assertSame(test, result); result = test.withPeriodAdded(new Period(1, 2, 0, 4, 5, 6, 7, 8), 3); expected = new DateTime(2005, 11, 15, 16, 20, 24, 28, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.withPeriodAdded(new Period(1, 2, 0, 1, 1, 2, 3, 4), -1); expected = new DateTime(2001, 3, 2, 0, 0, 0, 0, BUDDHIST_DEFAULT); assertEquals(expected, result); } //----------------------------------------------------------------------- public void testPlus_long() { DateTime test = new DateTime(TEST_TIME1, BUDDHIST_DEFAULT); DateTime result = test.plus(123456789L); DateTime expected = new DateTime(TEST_TIME1 + 123456789L, BUDDHIST_DEFAULT); assertEquals(expected, result); } public void testPlus_RD() { DateTime test = new DateTime(TEST_TIME1, BUDDHIST_DEFAULT); DateTime result = test.plus(new Duration(123456789L)); DateTime expected = new DateTime(TEST_TIME1 + 123456789L, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.plus((ReadableDuration) null); assertSame(test, result); } public void testPlus_RP() { DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BUDDHIST_DEFAULT); DateTime result = test.plus(new Period(1, 2, 3, 4, 5, 6, 7, 8)); DateTime expected = new DateTime(2003, 7, 28, 6, 8, 10, 12, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.plus((ReadablePeriod) null); assertSame(test, result); } public void testPlusYears_int() { DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BUDDHIST_DEFAULT); DateTime result = test.plusYears(1); DateTime expected = new DateTime(2003, 5, 3, 1, 2, 3, 4, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.plusYears(0); assertSame(test, result); } public void testPlusMonths_int() { DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BUDDHIST_DEFAULT); DateTime result = test.plusMonths(1); DateTime expected = new DateTime(2002, 6, 3, 1, 2, 3, 4, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.plusMonths(0); assertSame(test, result); } public void testPlusWeeks_int() { DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BUDDHIST_DEFAULT); DateTime result = test.plusWeeks(1); DateTime expected = new DateTime(2002, 5, 10, 1, 2, 3, 4, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.plusWeeks(0); assertSame(test, result); } public void testPlusDays_int() { DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BUDDHIST_DEFAULT); DateTime result = test.plusDays(1); DateTime expected = new DateTime(2002, 5, 4, 1, 2, 3, 4, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.plusDays(0); assertSame(test, result); } public void testPlusHours_int() { DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BUDDHIST_DEFAULT); DateTime result = test.plusHours(1); DateTime expected = new DateTime(2002, 5, 3, 2, 2, 3, 4, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.plusHours(0); assertSame(test, result); } public void testPlusMinutes_int() { DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BUDDHIST_DEFAULT); DateTime result = test.plusMinutes(1); DateTime expected = new DateTime(2002, 5, 3, 1, 3, 3, 4, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.plusMinutes(0); assertSame(test, result); } public void testPlusSeconds_int() { DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BUDDHIST_DEFAULT); DateTime result = test.plusSeconds(1); DateTime expected = new DateTime(2002, 5, 3, 1, 2, 4, 4, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.plusSeconds(0); assertSame(test, result); } public void testPlusMillis_int() { DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BUDDHIST_DEFAULT); DateTime result = test.plusMillis(1); DateTime expected = new DateTime(2002, 5, 3, 1, 2, 3, 5, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.plusMillis(0); assertSame(test, result); } //----------------------------------------------------------------------- public void testMinus_long() { DateTime test = new DateTime(TEST_TIME1, BUDDHIST_DEFAULT); DateTime result = test.minus(123456789L); DateTime expected = new DateTime(TEST_TIME1 - 123456789L, BUDDHIST_DEFAULT); assertEquals(expected, result); } public void testMinus_RD() { DateTime test = new DateTime(TEST_TIME1, BUDDHIST_DEFAULT); DateTime result = test.minus(new Duration(123456789L)); DateTime expected = new DateTime(TEST_TIME1 - 123456789L, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.minus((ReadableDuration) null); assertSame(test, result); } public void testMinus_RP() { DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BUDDHIST_DEFAULT); DateTime result = test.minus(new Period(1, 1, 1, 1, 1, 1, 1, 1)); DateTime expected = new DateTime(2001, 3, 26, 0, 1, 2, 3, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.minus((ReadablePeriod) null); assertSame(test, result); } public void testMinusYears_int() { DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BUDDHIST_DEFAULT); DateTime result = test.minusYears(1); DateTime expected = new DateTime(2001, 5, 3, 1, 2, 3, 4, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.minusYears(0); assertSame(test, result); } public void testMinusMonths_int() { DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BUDDHIST_DEFAULT); DateTime result = test.minusMonths(1); DateTime expected = new DateTime(2002, 4, 3, 1, 2, 3, 4, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.minusMonths(0); assertSame(test, result); } public void testMinusWeeks_int() { DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BUDDHIST_DEFAULT); DateTime result = test.minusWeeks(1); DateTime expected = new DateTime(2002, 4, 26, 1, 2, 3, 4, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.minusWeeks(0); assertSame(test, result); } public void testMinusDays_int() { DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BUDDHIST_DEFAULT); DateTime result = test.minusDays(1); DateTime expected = new DateTime(2002, 5, 2, 1, 2, 3, 4, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.minusDays(0); assertSame(test, result); } public void testMinusHours_int() { DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BUDDHIST_DEFAULT); DateTime result = test.minusHours(1); DateTime expected = new DateTime(2002, 5, 3, 0, 2, 3, 4, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.minusHours(0); assertSame(test, result); } public void testMinusMinutes_int() { DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BUDDHIST_DEFAULT); DateTime result = test.minusMinutes(1); DateTime expected = new DateTime(2002, 5, 3, 1, 1, 3, 4, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.minusMinutes(0); assertSame(test, result); } public void testMinusSeconds_int() { DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BUDDHIST_DEFAULT); DateTime result = test.minusSeconds(1); DateTime expected = new DateTime(2002, 5, 3, 1, 2, 2, 4, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.minusSeconds(0); assertSame(test, result); } public void testMinusMillis_int() { DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BUDDHIST_DEFAULT); DateTime result = test.minusMillis(1); DateTime expected = new DateTime(2002, 5, 3, 1, 2, 3, 3, BUDDHIST_DEFAULT); assertEquals(expected, result); result = test.minusMillis(0); assertSame(test, result); } //----------------------------------------------------------------------- public void testProperty() { DateTime test = new DateTime(); assertEquals(test.year(), test.property(DateTimeFieldType.year())); assertEquals(test.dayOfWeek(), test.property(DateTimeFieldType.dayOfWeek())); assertEquals(test.secondOfMinute(), test.property(DateTimeFieldType.secondOfMinute())); assertEquals(test.millisOfSecond(), test.property(DateTimeFieldType.millisOfSecond())); DateTimeFieldType bad = new DateTimeFieldType("bad") { private static final long serialVersionUID = 1L; public DurationFieldType getDurationType() { return DurationFieldType.weeks(); } public DurationFieldType getRangeDurationType() { return null; } public DateTimeField getField(Chronology chronology) { return UnsupportedDateTimeField.getInstance(this, UnsupportedDurationField.getInstance(getDurationType())); } }; try { test.property(bad); fail(); } catch (IllegalArgumentException ex) {} try { test.property(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- private void check(DateTime test, int year, int month, int day, int hour, int min, int sec, int mil) { assertEquals(year, test.getYear()); assertEquals(month, test.getMonthOfYear()); assertEquals(day, test.getDayOfMonth()); assertEquals(hour, test.getHourOfDay()); assertEquals(min, test.getMinuteOfHour()); assertEquals(sec, test.getSecondOfMinute()); assertEquals(mil, test.getMillisOfSecond()); } }
/* * Copyright 2001-2010 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.util.Date; import java.util.Locale; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.GregorianChronology; import org.joda.time.chrono.ISOChronology; import org.joda.time.convert.ConverterManager; import org.joda.time.convert.MockZeroNullIntegerConverter; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; /** * This class is a Junit unit test for DateTime. * * @author Stephen Colebourne */ public class TestDateTime_Constructors extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; // 2002-04-05 private long TEST_TIME1 = (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; // 2003-05-06 private long TEST_TIME2 = (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone zone = null; private Locale locale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestDateTime_Constructors.class); } public TestDateTime_Constructors(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); zone = DateTimeZone.getDefault(); locale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); java.util.TimeZone.setDefault(LONDON.toTimeZone()); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(zone); java.util.TimeZone.setDefault(zone.toTimeZone()); Locale.setDefault(locale); zone = null; } //----------------------------------------------------------------------- public void testTest() { assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString()); assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString()); assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString()); } //----------------------------------------------------------------------- /** * Test now () */ public void test_now() throws Throwable { DateTime test = DateTime.now(); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test now (DateTimeZone) */ public void test_now_DateTimeZone() throws Throwable { DateTime test = DateTime.now(PARIS); assertEquals(ISOChronology.getInstance(PARIS), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test now (DateTimeZone=null) */ public void test_now_nullDateTimeZone() throws Throwable { try { DateTime.now((DateTimeZone) null); fail(); } catch (NullPointerException ex) {} } /** * Test now (Chronology) */ public void test_now_Chronology() throws Throwable { DateTime test = DateTime.now(GregorianChronology.getInstance()); assertEquals(GregorianChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test now (Chronology=null) */ public void test_now_nullChronology() throws Throwable { try { DateTime.now((Chronology) null); fail(); } catch (NullPointerException ex) {} } //----------------------------------------------------------------------- public void testParse_noFormatter() throws Throwable { assertEquals(new DateTime(2010, 6, 30, 1, 20, ISOChronology.getInstance(DateTimeZone.forOffsetHours(2))), DateTime.parse("2010-06-30T01:20+02:00")); assertEquals(new DateTime(2010, 1, 2, 14, 50, ISOChronology.getInstance(LONDON)), DateTime.parse("2010-002T14:50")); } public void testParse_formatter() throws Throwable { DateTimeFormatter f = DateTimeFormat.forPattern("yyyy--dd MM HH").withChronology(ISOChronology.getInstance(PARIS)); assertEquals(new DateTime(2010, 6, 30, 13, 0, ISOChronology.getInstance(PARIS)), DateTime.parse("2010--30 06 13", f)); } //----------------------------------------------------------------------- /** * Test constructor () */ public void testConstructor() throws Throwable { DateTime test = new DateTime(); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test constructor (DateTimeZone) */ public void testConstructor_DateTimeZone() throws Throwable { DateTime test = new DateTime(PARIS); assertEquals(ISOChronology.getInstance(PARIS), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test constructor (DateTimeZone=null) */ public void testConstructor_nullDateTimeZone() throws Throwable { DateTime test = new DateTime((DateTimeZone) null); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test constructor (Chronology) */ public void testConstructor_Chronology() throws Throwable { DateTime test = new DateTime(GregorianChronology.getInstance()); assertEquals(GregorianChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test constructor (Chronology=null) */ public void testConstructor_nullChronology() throws Throwable { DateTime test = new DateTime((Chronology) null); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } //----------------------------------------------------------------------- /** * Test constructor (long) */ public void testConstructor_long1() throws Throwable { DateTime test = new DateTime(TEST_TIME1); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME1, test.getMillis()); } /** * Test constructor (long) */ public void testConstructor_long2() throws Throwable { DateTime test = new DateTime(TEST_TIME2); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME2, test.getMillis()); } /** * Test constructor (long, DateTimeZone) */ public void testConstructor_long1_DateTimeZone() throws Throwable { DateTime test = new DateTime(TEST_TIME1, PARIS); assertEquals(ISOChronology.getInstance(PARIS), test.getChronology()); assertEquals(TEST_TIME1, test.getMillis()); } /** * Test constructor (long, DateTimeZone) */ public void testConstructor_long2_DateTimeZone() throws Throwable { DateTime test = new DateTime(TEST_TIME2, PARIS); assertEquals(ISOChronology.getInstance(PARIS), test.getChronology()); assertEquals(TEST_TIME2, test.getMillis()); } /** * Test constructor (long, DateTimeZone=null) */ public void testConstructor_long_nullDateTimeZone() throws Throwable { DateTime test = new DateTime(TEST_TIME1, (DateTimeZone) null); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME1, test.getMillis()); } /** * Test constructor (long, Chronology) */ public void testConstructor_long1_Chronology() throws Throwable { DateTime test = new DateTime(TEST_TIME1, GregorianChronology.getInstance()); assertEquals(GregorianChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME1, test.getMillis()); } /** * Test constructor (long, Chronology) */ public void testConstructor_long2_Chronology() throws Throwable { DateTime test = new DateTime(TEST_TIME2, GregorianChronology.getInstance()); assertEquals(GregorianChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME2, test.getMillis()); } /** * Test constructor (long, Chronology=null) */ public void testConstructor_long_nullChronology() throws Throwable { DateTime test = new DateTime(TEST_TIME1, (Chronology) null); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME1, test.getMillis()); } //----------------------------------------------------------------------- /** * Test constructor (Object) */ public void testConstructor_Object() throws Throwable { Date date = new Date(TEST_TIME1); DateTime test = new DateTime(date); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME1, test.getMillis()); } /** * Test constructor (Object) */ public void testConstructor_invalidObject() throws Throwable { try { new DateTime(new Object()); fail(); } catch (IllegalArgumentException ex) {} } /** * Test constructor (Object=null) */ public void testConstructor_nullObject() throws Throwable { DateTime test = new DateTime((Object) null); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test constructor (Object=null) */ public void testConstructor_badconverterObject() throws Throwable { try { ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE); DateTime test = new DateTime(new Integer(0)); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(0L, test.getMillis()); } finally { ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE); } } public void testConstructor_ObjectString1() throws Throwable { DateTime test = new DateTime("1972-12-03"); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(1972, test.getYear()); assertEquals(12, test.getMonthOfYear()); assertEquals(3, test.getDayOfMonth()); assertEquals(0, test.getHourOfDay()); assertEquals(0, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } public void testConstructor_ObjectString2() throws Throwable { DateTime test = new DateTime("2006-06-03T+14:00"); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(2006, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(2, test.getDayOfMonth()); // timezone assertEquals(11, test.getHourOfDay()); // test zone is +1, so shift back (14 - 1) hours from midnight assertEquals(0, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } public void testConstructor_ObjectString3() throws Throwable { DateTime test = new DateTime("1972-12-03T10:20:30.040"); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(1972, test.getYear()); assertEquals(12, test.getMonthOfYear()); assertEquals(3, test.getDayOfMonth()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } public void testConstructor_ObjectString4() throws Throwable { DateTime test = new DateTime("2006-06-03T10:20:30.040+14:00"); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(2006, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(2, test.getDayOfMonth()); // timezone assertEquals(21, test.getHourOfDay()); // test zone is +1, so shift back (14 - 1) hours from 10am assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } public void testConstructor_ObjectString5() throws Throwable { DateTime test = new DateTime("T10:20:30.040"); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(1, test.getMonthOfYear()); assertEquals(1, test.getDayOfMonth()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } public void testConstructor_ObjectString6() throws Throwable { DateTime test = new DateTime("T10:20:30.040+14:00"); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(1969, test.getYear()); // timezone assertEquals(12, test.getMonthOfYear()); // timezone assertEquals(31, test.getDayOfMonth()); // timezone assertEquals(21, test.getHourOfDay()); // test zone is +1, so shift back (14 - 1) hours from 10am assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } public void testConstructor_ObjectString7() throws Throwable { DateTime test = new DateTime("10"); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(10, test.getYear()); assertEquals(1, test.getMonthOfYear()); assertEquals(1, test.getDayOfMonth()); assertEquals(0, test.getHourOfDay()); assertEquals(0, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } public void testConstructor_ObjectStringEx1() throws Throwable { try { new DateTime("10:20:30.040"); fail(); } catch (IllegalArgumentException ex) { // expected } } public void testConstructor_ObjectStringEx2() throws Throwable { try { new DateTime("10:20:30.040+14:00"); fail(); } catch (IllegalArgumentException ex) { // expected } } //----------------------------------------------------------------------- /** * Test constructor (Object, DateTimeZone) */ public void testConstructor_Object_DateTimeZone() throws Throwable { Date date = new Date(TEST_TIME1); DateTime test = new DateTime(date, PARIS); assertEquals(ISOChronology.getInstance(PARIS), test.getChronology()); assertEquals(TEST_TIME1, test.getMillis()); } /** * Test constructor (Object, DateTimeZone) */ public void testConstructor_invalidObject_DateTimeZone() throws Throwable { try { new DateTime(new Object(), PARIS); fail(); } catch (IllegalArgumentException ex) {} } /** * Test constructor (Object=null, DateTimeZone) */ public void testConstructor_nullObject_DateTimeZone() throws Throwable { DateTime test = new DateTime((Object) null, PARIS); assertEquals(ISOChronology.getInstance(PARIS), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test constructor (Object, DateTimeZone=null) */ public void testConstructor_Object_nullDateTimeZone() throws Throwable { Date date = new Date(TEST_TIME1); DateTime test = new DateTime(date, (DateTimeZone) null); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME1, test.getMillis()); } /** * Test constructor (Object=null, DateTimeZone=null) */ public void testConstructor_nullObject_nullDateTimeZone() throws Throwable { DateTime test = new DateTime((Object) null, (DateTimeZone) null); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test constructor (Object, DateTimeZone) */ public void testConstructor_badconverterObject_DateTimeZone() throws Throwable { try { ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE); DateTime test = new DateTime(new Integer(0), GregorianChronology.getInstance()); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(0L, test.getMillis()); } finally { ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE); } } /** * Test constructor (Object, Chronology) */ public void testConstructor_Object_Chronology() throws Throwable { Date date = new Date(TEST_TIME1); DateTime test = new DateTime(date, GregorianChronology.getInstance()); assertEquals(GregorianChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME1, test.getMillis()); } /** * Test constructor (Object, Chronology) */ public void testConstructor_invalidObject_Chronology() throws Throwable { try { new DateTime(new Object(), GregorianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} } /** * Test constructor (Object=null, Chronology) */ public void testConstructor_nullObject_Chronology() throws Throwable { DateTime test = new DateTime((Object) null, GregorianChronology.getInstance()); assertEquals(GregorianChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test constructor (Object, Chronology=null) */ public void testConstructor_Object_nullChronology() throws Throwable { Date date = new Date(TEST_TIME1); DateTime test = new DateTime(date, (Chronology) null); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME1, test.getMillis()); } /** * Test constructor (Object=null, Chronology=null) */ public void testConstructor_nullObject_nullChronology() throws Throwable { DateTime test = new DateTime((Object) null, (Chronology) null); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test constructor (Object, Chronology) */ public void testConstructor_badconverterObject_Chronology() throws Throwable { try { ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE); DateTime test = new DateTime(new Integer(0), GregorianChronology.getInstance()); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(0L, test.getMillis()); } finally { ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE); } } //----------------------------------------------------------------------- /** * Test constructor (int, int, int, int, int) */ public void testConstructor_int_int_int_int_int() throws Throwable { DateTime test = new DateTime(2002, 6, 9, 1, 0); // +01:00 assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(LONDON, test.getZone()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test constructor (int, int, int, int, int, DateTimeZone) */ public void testConstructor_int_int_int_int_int_DateTimeZone() throws Throwable { DateTime test = new DateTime(2002, 6, 9, 2, 0, PARIS); // +02:00 assertEquals(ISOChronology.getInstance(PARIS), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test constructor (int, int, int, int, int, DateTimeZone=null) */ public void testConstructor_int_int_int_int_int_nullDateTimeZone() throws Throwable { DateTime test = new DateTime(2002, 6, 9, 1, 0, (DateTimeZone) null); // +01:00 assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test constructor (int, int, int, int, int, Chronology) */ public void testConstructor_int_int_int_int_int_Chronology() throws Throwable { DateTime test = new DateTime(2002, 6, 9, 1, 0, GregorianChronology.getInstance()); // +01:00 assertEquals(GregorianChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test constructor (int, int, int, int, int, Chronology=null) */ public void testConstructor_int_int_int_int_int_nullChronology() throws Throwable { DateTime test = new DateTime(2002, 6, 9, 1, 0, (Chronology) null); // +01:00 assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } //----------------------------------------------------------------------- /** * Test constructor (int, int, int, int, int, int) */ public void testConstructor_int_int_int_int_int_int() throws Throwable { DateTime test = new DateTime(2002, 6, 9, 1, 0, 0); // +01:00 assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(LONDON, test.getZone()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test constructor (int, int, int, int, int, int, DateTimeZone) */ public void testConstructor_int_int_int_int_int_int_DateTimeZone() throws Throwable { DateTime test = new DateTime(2002, 6, 9, 2, 0, 0, PARIS); // +02:00 assertEquals(ISOChronology.getInstance(PARIS), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test constructor (int, int, int, int, int, int, DateTimeZone=null) */ public void testConstructor_int_int_int_int_int_int_nullDateTimeZone() throws Throwable { DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, (DateTimeZone) null); // +01:00 assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test constructor (int, int, int, int, int, int, Chronology) */ public void testConstructor_int_int_int_int_int_int_Chronology() throws Throwable { DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, GregorianChronology.getInstance()); // +01:00 assertEquals(GregorianChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test constructor (int, int, int, int, int, int, Chronology=null) */ public void testConstructor_int_int_int_int_int_int_nullChronology() throws Throwable { DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, (Chronology) null); // +01:00 assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } //----------------------------------------------------------------------- /** * Test constructor (int, int, int) */ public void testConstructor_int_int_int_int_int_int_int() throws Throwable { DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, 0); // +01:00 assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(LONDON, test.getZone()); assertEquals(TEST_TIME_NOW, test.getMillis()); try { new DateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0); fail(); } catch (IllegalArgumentException ex) {} try { new DateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0); fail(); } catch (IllegalArgumentException ex) {} try { new DateTime(2002, 0, 9, 0, 0, 0, 0); fail(); } catch (IllegalArgumentException ex) {} try { new DateTime(2002, 13, 9, 0, 0, 0, 0); fail(); } catch (IllegalArgumentException ex) {} try { new DateTime(2002, 6, 0, 0, 0, 0, 0); fail(); } catch (IllegalArgumentException ex) {} try { new DateTime(2002, 6, 31, 0, 0, 0, 0); fail(); } catch (IllegalArgumentException ex) {} new DateTime(2002, 7, 31, 0, 0, 0, 0); try { new DateTime(2002, 7, 32, 0, 0, 0, 0); fail(); } catch (IllegalArgumentException ex) {} } /** * Test constructor (int, int, int, DateTimeZone) */ public void testConstructor_int_int_int_int_int_int_int_DateTimeZone() throws Throwable { DateTime test = new DateTime(2002, 6, 9, 2, 0, 0, 0, PARIS); // +02:00 assertEquals(ISOChronology.getInstance(PARIS), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); try { new DateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0, PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new DateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0, PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new DateTime(2002, 0, 9, 0, 0, 0, 0, PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new DateTime(2002, 13, 9, 0, 0, 0, 0, PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new DateTime(2002, 6, 0, 0, 0, 0, 0, PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new DateTime(2002, 6, 31, 0, 0, 0, 0, PARIS); fail(); } catch (IllegalArgumentException ex) {} new DateTime(2002, 7, 31, 0, 0, 0, 0, PARIS); try { new DateTime(2002, 7, 32, 0, 0, 0, 0, PARIS); fail(); } catch (IllegalArgumentException ex) {} } /** * Test constructor (int, int, int, DateTimeZone=null) */ public void testConstructor_int_int_int_int_int_int_int_nullDateTimeZone() throws Throwable { DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, 0, (DateTimeZone) null); // +01:00 assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test constructor (int, int, int, Chronology) */ public void testConstructor_int_int_int_int_int_int_int_Chronology() throws Throwable { DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, 0, GregorianChronology.getInstance()); // +01:00 assertEquals(GregorianChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); try { new DateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0, GregorianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} try { new DateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0, GregorianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} try { new DateTime(2002, 0, 9, 0, 0, 0, 0, GregorianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} try { new DateTime(2002, 13, 9, 0, 0, 0, 0, GregorianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} try { new DateTime(2002, 6, 0, 0, 0, 0, 0, GregorianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} try { new DateTime(2002, 6, 31, 0, 0, 0, 0, GregorianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} new DateTime(2002, 7, 31, 0, 0, 0, 0, GregorianChronology.getInstance()); try { new DateTime(2002, 7, 32, 0, 0, 0, 0, GregorianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} } /** * Test constructor (int, int, int, Chronology=null) */ public void testConstructor_int_int_int_int_int_int_int_nullChronology() throws Throwable { DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, 0, (Chronology) null); // +01:00 assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.util.Locale; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.CopticChronology; import org.joda.time.chrono.LenientChronology; import org.joda.time.chrono.StrictChronology; /** * This class is a Junit unit test for DateTime. * * @author Stephen Colebourne * @author Mike Schrag */ public class TestDateTime_Properties extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS); //private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; // 2002-04-05 Fri private long TEST_TIME1 = (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; // 2003-05-06 Tue private long TEST_TIME2 = (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone zone = null; private Locale locale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestDateTime_Properties.class); } public TestDateTime_Properties(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); zone = DateTimeZone.getDefault(); locale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(zone); Locale.setDefault(locale); zone = null; } //----------------------------------------------------------------------- public void testTest() { assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString()); assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString()); assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString()); } //----------------------------------------------------------------------- public void testPropertyGetEra() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); assertSame(test.getChronology().era(), test.era().getField()); assertEquals("era", test.era().getName()); assertEquals("Property[era]", test.era().toString()); assertSame(test, test.era().getDateTime()); assertEquals(1, test.era().get()); assertEquals("1", test.era().getAsString()); assertEquals("AD", test.era().getAsText()); assertEquals("AD", test.era().getField().getAsText(1, Locale.ENGLISH)); assertEquals("ap. J.-C.", test.era().getAsText(Locale.FRENCH)); assertEquals("ap. J.-C.", test.era().getField().getAsText(1, Locale.FRENCH)); assertEquals("AD", test.era().getAsShortText()); assertEquals("AD", test.era().getField().getAsShortText(1, Locale.ENGLISH)); assertEquals("ap. J.-C.", test.era().getAsShortText(Locale.FRENCH)); assertEquals("ap. J.-C.", test.era().getField().getAsShortText(1, Locale.FRENCH)); assertEquals(test.getChronology().eras(), test.era().getDurationField()); assertEquals(null, test.era().getRangeDurationField()); assertEquals(2, test.era().getMaximumTextLength(null)); assertEquals(9, test.era().getMaximumTextLength(Locale.FRENCH)); assertEquals(2, test.era().getMaximumShortTextLength(null)); assertEquals(9, test.era().getMaximumShortTextLength(Locale.FRENCH)); } //----------------------------------------------------------------------- public void testPropertyGetYearOfEra() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); assertSame(test.getChronology().yearOfEra(), test.yearOfEra().getField()); assertEquals("yearOfEra", test.yearOfEra().getName()); assertEquals("Property[yearOfEra]", test.yearOfEra().toString()); assertSame(test, test.yearOfEra().getDateTime()); assertEquals(2004, test.yearOfEra().get()); assertEquals("2004", test.yearOfEra().getAsString()); assertEquals("2004", test.yearOfEra().getAsText()); assertEquals("2004", test.yearOfEra().getAsText(Locale.FRENCH)); assertEquals("2004", test.yearOfEra().getAsShortText()); assertEquals("2004", test.yearOfEra().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().years(), test.yearOfEra().getDurationField()); assertEquals(test.getChronology().eras(), test.yearOfEra().getRangeDurationField()); assertEquals(9, test.yearOfEra().getMaximumTextLength(null)); assertEquals(9, test.yearOfEra().getMaximumShortTextLength(null)); } //----------------------------------------------------------------------- public void testPropertyGetCenturyOfEra() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); assertSame(test.getChronology().centuryOfEra(), test.centuryOfEra().getField()); assertEquals("centuryOfEra", test.centuryOfEra().getName()); assertEquals("Property[centuryOfEra]", test.centuryOfEra().toString()); assertSame(test, test.centuryOfEra().getDateTime()); assertEquals(20, test.centuryOfEra().get()); assertEquals("20", test.centuryOfEra().getAsString()); assertEquals("20", test.centuryOfEra().getAsText()); assertEquals("20", test.centuryOfEra().getAsText(Locale.FRENCH)); assertEquals("20", test.centuryOfEra().getAsShortText()); assertEquals("20", test.centuryOfEra().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().centuries(), test.centuryOfEra().getDurationField()); assertEquals(test.getChronology().eras(), test.centuryOfEra().getRangeDurationField()); assertEquals(7, test.centuryOfEra().getMaximumTextLength(null)); assertEquals(7, test.centuryOfEra().getMaximumShortTextLength(null)); } //----------------------------------------------------------------------- public void testPropertyGetYearOfCentury() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); assertSame(test.getChronology().yearOfCentury(), test.yearOfCentury().getField()); assertEquals("yearOfCentury", test.yearOfCentury().getName()); assertEquals("Property[yearOfCentury]", test.yearOfCentury().toString()); assertSame(test, test.yearOfCentury().getDateTime()); assertEquals(4, test.yearOfCentury().get()); assertEquals("4", test.yearOfCentury().getAsString()); assertEquals("4", test.yearOfCentury().getAsText()); assertEquals("4", test.yearOfCentury().getAsText(Locale.FRENCH)); assertEquals("4", test.yearOfCentury().getAsShortText()); assertEquals("4", test.yearOfCentury().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().years(), test.yearOfCentury().getDurationField()); assertEquals(test.getChronology().centuries(), test.yearOfCentury().getRangeDurationField()); assertEquals(2, test.yearOfCentury().getMaximumTextLength(null)); assertEquals(2, test.yearOfCentury().getMaximumShortTextLength(null)); } //----------------------------------------------------------------------- public void testPropertyGetWeekyear() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); assertSame(test.getChronology().weekyear(), test.weekyear().getField()); assertEquals("weekyear", test.weekyear().getName()); assertEquals("Property[weekyear]", test.weekyear().toString()); assertSame(test, test.weekyear().getDateTime()); assertEquals(2004, test.weekyear().get()); assertEquals("2004", test.weekyear().getAsString()); assertEquals("2004", test.weekyear().getAsText()); assertEquals("2004", test.weekyear().getAsText(Locale.FRENCH)); assertEquals("2004", test.weekyear().getAsShortText()); assertEquals("2004", test.weekyear().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().weekyears(), test.weekyear().getDurationField()); assertEquals(null, test.weekyear().getRangeDurationField()); assertEquals(9, test.weekyear().getMaximumTextLength(null)); assertEquals(9, test.weekyear().getMaximumShortTextLength(null)); } //----------------------------------------------------------------------- public void testPropertyGetYear() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); assertSame(test.getChronology().year(), test.year().getField()); assertEquals("year", test.year().getName()); assertEquals("Property[year]", test.year().toString()); assertSame(test, test.year().getDateTime()); assertEquals(2004, test.year().get()); assertEquals("2004", test.year().getAsString()); assertEquals("2004", test.year().getAsText()); assertEquals("2004", test.year().getAsText(Locale.FRENCH)); assertEquals("2004", test.year().getAsShortText()); assertEquals("2004", test.year().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().years(), test.year().getDurationField()); assertEquals(null, test.year().getRangeDurationField()); assertEquals(9, test.year().getMaximumTextLength(null)); assertEquals(9, test.year().getMaximumShortTextLength(null)); assertEquals(-292275054, test.year().getMinimumValue()); assertEquals(-292275054, test.year().getMinimumValueOverall()); assertEquals(292278993, test.year().getMaximumValue()); assertEquals(292278993, test.year().getMaximumValueOverall()); } public void testPropertyLeapYear() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); assertEquals(true, test.year().isLeap()); assertEquals(1, test.year().getLeapAmount()); assertEquals(test.getChronology().days(), test.year().getLeapDurationField()); test = new DateTime(2003, 6, 9, 0, 0, 0, 0); assertEquals(false, test.year().isLeap()); assertEquals(0, test.year().getLeapAmount()); assertEquals(test.getChronology().days(), test.year().getLeapDurationField()); } public void testPropertyAddYear() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime copy = test.year().addToCopy(9); assertEquals("2004-06-09T00:00:00.000+01:00", test.toString()); assertEquals("2013-06-09T00:00:00.000+01:00", copy.toString()); copy = test.year().addToCopy(0); assertEquals("2004-06-09T00:00:00.000+01:00", copy.toString()); copy = test.year().addToCopy(292277023 - 2004); assertEquals(292277023, copy.getYear()); try { test.year().addToCopy(292278993 - 2004 + 1); fail(); } catch (IllegalArgumentException ex) {} copy = test.year().addToCopy(-2004); assertEquals(0, copy.getYear()); copy = test.year().addToCopy(-2005); assertEquals(-1, copy.getYear()); try { test.year().addToCopy(-292275054 - 2004 - 1); fail(); } catch (IllegalArgumentException ex) {} } public void testPropertyAddWrapFieldYear() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime copy = test.year().addWrapFieldToCopy(9); assertEquals("2004-06-09T00:00:00.000+01:00", test.toString()); assertEquals("2013-06-09T00:00:00.000+01:00", copy.toString()); copy = test.year().addWrapFieldToCopy(0); assertEquals(2004, copy.getYear()); copy = test.year().addWrapFieldToCopy(292278993 - 2004 + 1); assertEquals(-292275054, copy.getYear()); copy = test.year().addWrapFieldToCopy(-292275054 - 2004 - 1); assertEquals(292278993, copy.getYear()); } public void testPropertySetYear() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime copy = test.year().setCopy(1960); assertEquals("2004-06-09T00:00:00.000+01:00", test.toString()); assertEquals("1960-06-09T00:00:00.000+01:00", copy.toString()); } public void testPropertySetTextYear() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime copy = test.year().setCopy("1960"); assertEquals("2004-06-09T00:00:00.000+01:00", test.toString()); assertEquals("1960-06-09T00:00:00.000+01:00", copy.toString()); } public void testPropertyCompareToYear() { DateTime test1 = new DateTime(TEST_TIME1); DateTime test2 = new DateTime(TEST_TIME2); assertEquals(true, test1.year().compareTo(test2) < 0); assertEquals(true, test2.year().compareTo(test1) > 0); assertEquals(true, test1.year().compareTo(test1) == 0); try { test1.year().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} } @SuppressWarnings("deprecation") public void testPropertyCompareToYear2() { DateTime test1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); YearMonthDay ymd1 = new YearMonthDay(2003, 6, 9); YearMonthDay ymd2 = new YearMonthDay(2004, 6, 9); YearMonthDay ymd3 = new YearMonthDay(2005, 6, 9); assertEquals(true, test1.year().compareTo(ymd1) > 0); assertEquals(true, test1.year().compareTo(ymd2) == 0); assertEquals(true, test1.year().compareTo(ymd3) < 0); try { test1.year().compareTo((ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} } public void testPropertyEqualsHashCodeYear() { DateTime test1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); assertEquals(true, test1.year().equals(test1.year())); assertEquals(true, test1.year().equals(new DateTime(2004, 6, 9, 0, 0, 0, 0).year())); assertEquals(false, test1.year().equals(new DateTime(2004, 6, 9, 0, 0, 0, 0).monthOfYear())); assertEquals(false, test1.year().equals(new DateTime(2004, 6, 9, 0, 0, 0, 0, CopticChronology.getInstance()).year())); assertEquals(true, test1.year().hashCode() == test1.year().hashCode()); assertEquals(true, test1.year().hashCode() == new DateTime(2004, 6, 9, 0, 0, 0, 0).year().hashCode()); assertEquals(false, test1.year().hashCode() == new DateTime(2004, 6, 9, 0, 0, 0, 0).monthOfYear().hashCode()); assertEquals(false, test1.year().hashCode() == new DateTime(2004, 6, 9, 0, 0, 0, 0, CopticChronology.getInstance()).year().hashCode()); } //----------------------------------------------------------------------- public void testPropertyGetMonthOfYear() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField()); assertEquals("monthOfYear", test.monthOfYear().getName()); assertEquals("Property[monthOfYear]", test.monthOfYear().toString()); assertSame(test, test.monthOfYear().getDateTime()); assertEquals(6, test.monthOfYear().get()); assertEquals("6", test.monthOfYear().getAsString()); assertEquals("June", test.monthOfYear().getAsText()); assertEquals("June", test.monthOfYear().getField().getAsText(6, Locale.ENGLISH)); assertEquals("juin", test.monthOfYear().getAsText(Locale.FRENCH)); assertEquals("juin", test.monthOfYear().getField().getAsText(6, Locale.FRENCH)); assertEquals("Jun", test.monthOfYear().getAsShortText()); assertEquals("Jun", test.monthOfYear().getField().getAsShortText(6, Locale.ENGLISH)); assertEquals("juin", test.monthOfYear().getAsShortText(Locale.FRENCH)); assertEquals("juin", test.monthOfYear().getField().getAsShortText(6, Locale.FRENCH)); assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField()); assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField()); assertEquals(9, test.monthOfYear().getMaximumTextLength(null)); assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null)); test = new DateTime(2004, 7, 9, 0, 0, 0, 0); assertEquals("juillet", test.monthOfYear().getAsText(Locale.FRENCH)); assertEquals("juillet", test.monthOfYear().getField().getAsText(7, Locale.FRENCH)); assertEquals("juil.", test.monthOfYear().getAsShortText(Locale.FRENCH)); assertEquals("juil.", test.monthOfYear().getField().getAsShortText(7, Locale.FRENCH)); assertEquals(1, test.monthOfYear().getMinimumValue()); assertEquals(1, test.monthOfYear().getMinimumValueOverall()); assertEquals(12, test.monthOfYear().getMaximumValue()); assertEquals(12, test.monthOfYear().getMaximumValueOverall()); assertEquals(1, test.monthOfYear().getMinimumValue()); assertEquals(1, test.monthOfYear().getMinimumValueOverall()); assertEquals(12, test.monthOfYear().getMaximumValue()); assertEquals(12, test.monthOfYear().getMaximumValueOverall()); } public void testPropertyLeapMonthOfYear() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); assertEquals(false, test.monthOfYear().isLeap()); assertEquals(0, test.monthOfYear().getLeapAmount()); assertEquals(test.getChronology().days(), test.monthOfYear().getLeapDurationField()); test = new DateTime(2004, 2, 9, 0, 0, 0, 0); assertEquals(true, test.monthOfYear().isLeap()); assertEquals(1, test.monthOfYear().getLeapAmount()); assertEquals(test.getChronology().days(), test.monthOfYear().getLeapDurationField()); test = new DateTime(2003, 6, 9, 0, 0, 0, 0); assertEquals(false, test.monthOfYear().isLeap()); assertEquals(0, test.monthOfYear().getLeapAmount()); assertEquals(test.getChronology().days(), test.monthOfYear().getLeapDurationField()); test = new DateTime(2003, 2, 9, 0, 0, 0, 0); assertEquals(false, test.monthOfYear().isLeap()); assertEquals(0, test.monthOfYear().getLeapAmount()); assertEquals(test.getChronology().days(), test.monthOfYear().getLeapDurationField()); } public void testPropertyAddMonthOfYear() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime copy = test.monthOfYear().addToCopy(6); assertEquals("2004-06-09T00:00:00.000+01:00", test.toString()); assertEquals("2004-12-09T00:00:00.000Z", copy.toString()); copy = test.monthOfYear().addToCopy(7); assertEquals("2005-01-09T00:00:00.000Z", copy.toString()); copy = test.monthOfYear().addToCopy(-5); assertEquals("2004-01-09T00:00:00.000Z", copy.toString()); copy = test.monthOfYear().addToCopy(-6); assertEquals("2003-12-09T00:00:00.000Z", copy.toString()); test = new DateTime(2004, 1, 31, 0, 0, 0, 0); copy = test.monthOfYear().addToCopy(1); assertEquals("2004-01-31T00:00:00.000Z", test.toString()); assertEquals("2004-02-29T00:00:00.000Z", copy.toString()); copy = test.monthOfYear().addToCopy(2); assertEquals("2004-03-31T00:00:00.000+01:00", copy.toString()); copy = test.monthOfYear().addToCopy(3); assertEquals("2004-04-30T00:00:00.000+01:00", copy.toString()); test = new DateTime(2003, 1, 31, 0, 0, 0, 0); copy = test.monthOfYear().addToCopy(1); assertEquals("2003-02-28T00:00:00.000Z", copy.toString()); } public void testPropertyAddWrapFieldMonthOfYear() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime copy = test.monthOfYear().addWrapFieldToCopy(4); assertEquals("2004-06-09T00:00:00.000+01:00", test.toString()); assertEquals("2004-10-09T00:00:00.000+01:00", copy.toString()); copy = test.monthOfYear().addWrapFieldToCopy(8); assertEquals("2004-02-09T00:00:00.000Z", copy.toString()); copy = test.monthOfYear().addWrapFieldToCopy(-8); assertEquals("2004-10-09T00:00:00.000+01:00", copy.toString()); test = new DateTime(2004, 1, 31, 0, 0, 0, 0); copy = test.monthOfYear().addWrapFieldToCopy(1); assertEquals("2004-01-31T00:00:00.000Z", test.toString()); assertEquals("2004-02-29T00:00:00.000Z", copy.toString()); copy = test.monthOfYear().addWrapFieldToCopy(2); assertEquals("2004-03-31T00:00:00.000+01:00", copy.toString()); copy = test.monthOfYear().addWrapFieldToCopy(3); assertEquals("2004-04-30T00:00:00.000+01:00", copy.toString()); test = new DateTime(2005, 1, 31, 0, 0, 0, 0); copy = test.monthOfYear().addWrapFieldToCopy(1); assertEquals("2005-01-31T00:00:00.000Z", test.toString()); assertEquals("2005-02-28T00:00:00.000Z", copy.toString()); } public void testPropertySetMonthOfYear() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime copy = test.monthOfYear().setCopy(12); assertEquals("2004-06-09T00:00:00.000+01:00", test.toString()); assertEquals("2004-12-09T00:00:00.000Z", copy.toString()); test = new DateTime(2004, 1, 31, 0, 0, 0, 0); copy = test.monthOfYear().setCopy(2); assertEquals("2004-02-29T00:00:00.000Z", copy.toString()); try { test.monthOfYear().setCopy(13); fail(); } catch (IllegalArgumentException ex) {} try { test.monthOfYear().setCopy(0); fail(); } catch (IllegalArgumentException ex) {} } public void testPropertySetTextMonthOfYear() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime copy = test.monthOfYear().setCopy("12"); assertEquals("2004-06-09T00:00:00.000+01:00", test.toString()); assertEquals("2004-12-09T00:00:00.000Z", copy.toString()); copy = test.monthOfYear().setCopy("December"); assertEquals("2004-06-09T00:00:00.000+01:00", test.toString()); assertEquals("2004-12-09T00:00:00.000Z", copy.toString()); copy = test.monthOfYear().setCopy("Dec"); assertEquals("2004-06-09T00:00:00.000+01:00", test.toString()); assertEquals("2004-12-09T00:00:00.000Z", copy.toString()); } public void testPropertyCompareToMonthOfYear() { DateTime test1 = new DateTime(TEST_TIME1); DateTime test2 = new DateTime(TEST_TIME2); assertEquals(true, test1.monthOfYear().compareTo(test2) < 0); assertEquals(true, test2.monthOfYear().compareTo(test1) > 0); assertEquals(true, test1.monthOfYear().compareTo(test1) == 0); try { test1.monthOfYear().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} DateTime dt1 = new DateTime(TEST_TIME1); DateTime dt2 = new DateTime(TEST_TIME2); assertEquals(true, test1.monthOfYear().compareTo(dt2) < 0); assertEquals(true, test2.monthOfYear().compareTo(dt1) > 0); assertEquals(true, test1.monthOfYear().compareTo(dt1) == 0); try { test1.monthOfYear().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testPropertyGetDayOfMonth() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField()); assertEquals("dayOfMonth", test.dayOfMonth().getName()); assertEquals("Property[dayOfMonth]", test.dayOfMonth().toString()); assertSame(test, test.dayOfMonth().getDateTime()); assertEquals(9, test.dayOfMonth().get()); assertEquals("9", test.dayOfMonth().getAsString()); assertEquals("9", test.dayOfMonth().getAsText()); assertEquals("9", test.dayOfMonth().getAsText(Locale.FRENCH)); assertEquals("9", test.dayOfMonth().getAsShortText()); assertEquals("9", test.dayOfMonth().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField()); assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField()); assertEquals(2, test.dayOfMonth().getMaximumTextLength(null)); assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null)); assertEquals(1, test.dayOfMonth().getMinimumValue()); assertEquals(1, test.dayOfMonth().getMinimumValueOverall()); assertEquals(30, test.dayOfMonth().getMaximumValue()); assertEquals(31, test.dayOfMonth().getMaximumValueOverall()); assertEquals(false, test.dayOfMonth().isLeap()); assertEquals(0, test.dayOfMonth().getLeapAmount()); assertEquals(null, test.dayOfMonth().getLeapDurationField()); } public void testPropertyGetMaxMinValuesDayOfMonth() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); assertEquals(1, test.dayOfMonth().getMinimumValue()); assertEquals(1, test.dayOfMonth().getMinimumValueOverall()); assertEquals(30, test.dayOfMonth().getMaximumValue()); assertEquals(31, test.dayOfMonth().getMaximumValueOverall()); test = new DateTime(2004, 7, 9, 0, 0, 0, 0); assertEquals(31, test.dayOfMonth().getMaximumValue()); test = new DateTime(2004, 2, 9, 0, 0, 0, 0); assertEquals(29, test.dayOfMonth().getMaximumValue()); test = new DateTime(2003, 2, 9, 0, 0, 0, 0); assertEquals(28, test.dayOfMonth().getMaximumValue()); } public void testPropertyAddDayOfMonth() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime copy = test.dayOfMonth().addToCopy(9); assertEquals("2004-06-09T00:00:00.000+01:00", test.toString()); assertEquals("2004-06-18T00:00:00.000+01:00", copy.toString()); copy = test.dayOfMonth().addToCopy(21); assertEquals("2004-06-30T00:00:00.000+01:00", copy.toString()); copy = test.dayOfMonth().addToCopy(22); assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString()); copy = test.dayOfMonth().addToCopy(22 + 30); assertEquals("2004-07-31T00:00:00.000+01:00", copy.toString()); copy = test.dayOfMonth().addToCopy(22 + 31); assertEquals("2004-08-01T00:00:00.000+01:00", copy.toString()); copy = test.dayOfMonth().addToCopy(21 + 31 + 31 + 30 + 31 + 30 + 31); assertEquals("2004-12-31T00:00:00.000Z", copy.toString()); copy = test.dayOfMonth().addToCopy(22 + 31 + 31 + 30 + 31 + 30 + 31); assertEquals("2005-01-01T00:00:00.000Z", copy.toString()); copy = test.dayOfMonth().addToCopy(-8); assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString()); copy = test.dayOfMonth().addToCopy(-9); assertEquals("2004-05-31T00:00:00.000+01:00", copy.toString()); copy = test.dayOfMonth().addToCopy(-8 - 31 - 30 - 31 - 29 - 31); assertEquals("2004-01-01T00:00:00.000Z", copy.toString()); copy = test.dayOfMonth().addToCopy(-9 - 31 - 30 - 31 - 29 - 31); assertEquals("2003-12-31T00:00:00.000Z", copy.toString()); } public void testPropertyAddWrapFieldDayOfMonth() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime copy = test.dayOfMonth().addWrapFieldToCopy(21); assertEquals("2004-06-09T00:00:00.000+01:00", test.toString()); assertEquals("2004-06-30T00:00:00.000+01:00", copy.toString()); copy = test.dayOfMonth().addWrapFieldToCopy(22); assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString()); copy = test.dayOfMonth().addWrapFieldToCopy(-12); assertEquals("2004-06-27T00:00:00.000+01:00", copy.toString()); test = new DateTime(2004, 7, 9, 0, 0, 0, 0); copy = test.dayOfMonth().addWrapFieldToCopy(21); assertEquals("2004-07-30T00:00:00.000+01:00", copy.toString()); copy = test.dayOfMonth().addWrapFieldToCopy(22); assertEquals("2004-07-31T00:00:00.000+01:00", copy.toString()); copy = test.dayOfMonth().addWrapFieldToCopy(23); assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString()); copy = test.dayOfMonth().addWrapFieldToCopy(-12); assertEquals("2004-07-28T00:00:00.000+01:00", copy.toString()); } public void testPropertySetDayOfMonth() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime copy = test.dayOfMonth().setCopy(12); assertEquals("2004-06-09T00:00:00.000+01:00", test.toString()); assertEquals("2004-06-12T00:00:00.000+01:00", copy.toString()); try { test.dayOfMonth().setCopy(31); fail(); } catch (IllegalArgumentException ex) {} try { test.dayOfMonth().setCopy(0); fail(); } catch (IllegalArgumentException ex) {} } public void testPropertySetTextDayOfMonth() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime copy = test.dayOfMonth().setCopy("12"); assertEquals("2004-06-09T00:00:00.000+01:00", test.toString()); assertEquals("2004-06-12T00:00:00.000+01:00", copy.toString()); } public void testPropertyWithMaximumValueDayOfMonth() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime copy = test.dayOfMonth().withMaximumValue(); assertEquals("2004-06-09T00:00:00.000+01:00", test.toString()); assertEquals("2004-06-30T00:00:00.000+01:00", copy.toString()); } public void testPropertyWithMaximumValueMillisOfDayDSTGap() { DateTimeZone paris = DateTimeZone.forID("Europe/Paris"); DateTime dt = new DateTime(1926, 4, 17, 18, 0, 0, 0, paris); // DST gap 23:00 to 00:00 DateTime test = dt.millisOfDay().withMaximumValue(); assertEquals("1926-04-17T22:59:59.999Z", test.toString()); } public void testPropertyWithMinimumValueDayOfMonth() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime copy = test.dayOfMonth().withMinimumValue(); assertEquals("2004-06-09T00:00:00.000+01:00", test.toString()); assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString()); } public void testPropertyWithMinimumValueMillisOfDayDSTGap() { DateTimeZone gaza = DateTimeZone.forID("Asia/Gaza"); DateTime dt = new DateTime(2001, 4, 20, 18, 0, 0, 0, gaza); // DST gap 00:00 to 01:00 DateTime test = dt.millisOfDay().withMinimumValue(); assertEquals("2001-04-20T01:00:00.000+03:00", test.toString()); } public void testPropertyCompareToDayOfMonth() { DateTime test1 = new DateTime(TEST_TIME1); DateTime test2 = new DateTime(TEST_TIME2); assertEquals(true, test1.dayOfMonth().compareTo(test2) < 0); assertEquals(true, test2.dayOfMonth().compareTo(test1) > 0); assertEquals(true, test1.dayOfMonth().compareTo(test1) == 0); try { test1.dayOfMonth().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} DateTime dt1 = new DateTime(TEST_TIME1); DateTime dt2 = new DateTime(TEST_TIME2); assertEquals(true, test1.dayOfMonth().compareTo(dt2) < 0); assertEquals(true, test2.dayOfMonth().compareTo(dt1) > 0); assertEquals(true, test1.dayOfMonth().compareTo(dt1) == 0); try { test1.dayOfMonth().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testPropertyGetDayOfYear() { // 31+29+31+30+31+9 = 161 DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); assertSame(test.getChronology().dayOfYear(), test.dayOfYear().getField()); assertEquals("dayOfYear", test.dayOfYear().getName()); assertEquals("Property[dayOfYear]", test.dayOfYear().toString()); assertSame(test, test.dayOfYear().getDateTime()); assertEquals(161, test.dayOfYear().get()); assertEquals("161", test.dayOfYear().getAsString()); assertEquals("161", test.dayOfYear().getAsText()); assertEquals("161", test.dayOfYear().getAsText(Locale.FRENCH)); assertEquals("161", test.dayOfYear().getAsShortText()); assertEquals("161", test.dayOfYear().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().days(), test.dayOfYear().getDurationField()); assertEquals(test.getChronology().years(), test.dayOfYear().getRangeDurationField()); assertEquals(3, test.dayOfYear().getMaximumTextLength(null)); assertEquals(3, test.dayOfYear().getMaximumShortTextLength(null)); assertEquals(false, test.dayOfYear().isLeap()); assertEquals(0, test.dayOfYear().getLeapAmount()); assertEquals(null, test.dayOfYear().getLeapDurationField()); } public void testPropertyGetMaxMinValuesDayOfYear() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); assertEquals(1, test.dayOfYear().getMinimumValue()); assertEquals(1, test.dayOfYear().getMinimumValueOverall()); assertEquals(366, test.dayOfYear().getMaximumValue()); assertEquals(366, test.dayOfYear().getMaximumValueOverall()); test = new DateTime(2002, 6, 9, 0, 0, 0, 0); assertEquals(365, test.dayOfYear().getMaximumValue()); assertEquals(366, test.dayOfYear().getMaximumValueOverall()); } public void testPropertyAddDayOfYear() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime copy = test.dayOfYear().addToCopy(9); assertEquals("2004-06-09T00:00:00.000+01:00", test.toString()); assertEquals("2004-06-18T00:00:00.000+01:00", copy.toString()); copy = test.dayOfYear().addToCopy(21); assertEquals("2004-06-30T00:00:00.000+01:00", copy.toString()); copy = test.dayOfYear().addToCopy(22); assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString()); copy = test.dayOfYear().addToCopy(21 + 31 + 31 + 30 + 31 + 30 + 31); assertEquals("2004-12-31T00:00:00.000Z", copy.toString()); copy = test.dayOfYear().addToCopy(22 + 31 + 31 + 30 + 31 + 30 + 31); assertEquals("2005-01-01T00:00:00.000Z", copy.toString()); copy = test.dayOfYear().addToCopy(-8); assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString()); copy = test.dayOfYear().addToCopy(-9); assertEquals("2004-05-31T00:00:00.000+01:00", copy.toString()); copy = test.dayOfYear().addToCopy(-8 - 31 - 30 - 31 - 29 - 31); assertEquals("2004-01-01T00:00:00.000Z", copy.toString()); copy = test.dayOfYear().addToCopy(-9 - 31 - 30 - 31 - 29 - 31); assertEquals("2003-12-31T00:00:00.000Z", copy.toString()); } public void testPropertyAddWrapFieldDayOfYear() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime copy = test.dayOfYear().addWrapFieldToCopy(21); assertEquals("2004-06-09T00:00:00.000+01:00", test.toString()); assertEquals("2004-06-30T00:00:00.000+01:00", copy.toString()); copy = test.dayOfYear().addWrapFieldToCopy(22); assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString()); copy = test.dayOfYear().addWrapFieldToCopy(-12); assertEquals("2004-05-28T00:00:00.000+01:00", copy.toString()); copy = test.dayOfYear().addWrapFieldToCopy(205); assertEquals("2004-12-31T00:00:00.000Z", copy.toString()); copy = test.dayOfYear().addWrapFieldToCopy(206); assertEquals("2004-01-01T00:00:00.000Z", copy.toString()); copy = test.dayOfYear().addWrapFieldToCopy(-160); assertEquals("2004-01-01T00:00:00.000Z", copy.toString()); copy = test.dayOfYear().addWrapFieldToCopy(-161); assertEquals("2004-12-31T00:00:00.000Z", copy.toString()); } public void testPropertySetDayOfYear() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime copy = test.dayOfYear().setCopy(12); assertEquals("2004-06-09T00:00:00.000+01:00", test.toString()); assertEquals("2004-01-12T00:00:00.000Z", copy.toString()); try { test.dayOfYear().setCopy(367); fail(); } catch (IllegalArgumentException ex) {} try { test.dayOfYear().setCopy(0); fail(); } catch (IllegalArgumentException ex) {} } public void testPropertySetTextDayOfYear() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime copy = test.dayOfYear().setCopy("12"); assertEquals("2004-06-09T00:00:00.000+01:00", test.toString()); assertEquals("2004-01-12T00:00:00.000Z", copy.toString()); } public void testPropertyCompareToDayOfYear() { DateTime test1 = new DateTime(TEST_TIME1); DateTime test2 = new DateTime(TEST_TIME2); assertEquals(true, test1.dayOfYear().compareTo(test2) < 0); assertEquals(true, test2.dayOfYear().compareTo(test1) > 0); assertEquals(true, test1.dayOfYear().compareTo(test1) == 0); try { test1.dayOfYear().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} DateTime dt1 = new DateTime(TEST_TIME1); DateTime dt2 = new DateTime(TEST_TIME2); assertEquals(true, test1.dayOfYear().compareTo(dt2) < 0); assertEquals(true, test2.dayOfYear().compareTo(dt1) > 0); assertEquals(true, test1.dayOfYear().compareTo(dt1) == 0); try { test1.dayOfYear().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testPropertyGetWeekOfWeekyear() { // 2002-01-01 = Thu // 2002-12-31 = Thu (+364 days) // 2003-12-30 = Thu (+364 days) // 2004-01-03 = Mon W1 // 2004-01-31 = Mon (+28 days) W5 // 2004-02-28 = Mon (+28 days) W9 // 2004-03-27 = Mon (+28 days) W13 // 2004-04-24 = Mon (+28 days) W17 // 2004-05-23 = Mon (+28 days) W21 // 2004-06-05 = Mon (+14 days) W23 // 2004-06-09 = Fri // 2004-12-25 = Mon W52 // 2005-01-01 = Mon W1 DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); assertSame(test.getChronology().weekOfWeekyear(), test.weekOfWeekyear().getField()); assertEquals("weekOfWeekyear", test.weekOfWeekyear().getName()); assertEquals("Property[weekOfWeekyear]", test.weekOfWeekyear().toString()); assertSame(test, test.weekOfWeekyear().getDateTime()); assertEquals(24, test.weekOfWeekyear().get()); assertEquals("24", test.weekOfWeekyear().getAsString()); assertEquals("24", test.weekOfWeekyear().getAsText()); assertEquals("24", test.weekOfWeekyear().getAsText(Locale.FRENCH)); assertEquals("24", test.weekOfWeekyear().getAsShortText()); assertEquals("24", test.weekOfWeekyear().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().weeks(), test.weekOfWeekyear().getDurationField()); assertEquals(test.getChronology().weekyears(), test.weekOfWeekyear().getRangeDurationField()); assertEquals(2, test.weekOfWeekyear().getMaximumTextLength(null)); assertEquals(2, test.weekOfWeekyear().getMaximumShortTextLength(null)); assertEquals(false, test.weekOfWeekyear().isLeap()); assertEquals(0, test.weekOfWeekyear().getLeapAmount()); assertEquals(null, test.weekOfWeekyear().getLeapDurationField()); } public void testPropertyGetMaxMinValuesWeekOfWeekyear() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); assertEquals(1, test.weekOfWeekyear().getMinimumValue()); assertEquals(1, test.weekOfWeekyear().getMinimumValueOverall()); assertEquals(53, test.weekOfWeekyear().getMaximumValue()); assertEquals(53, test.weekOfWeekyear().getMaximumValueOverall()); test = new DateTime(2005, 6, 9, 0, 0, 0, 0); assertEquals(52, test.weekOfWeekyear().getMaximumValue()); assertEquals(53, test.weekOfWeekyear().getMaximumValueOverall()); } public void testPropertyAddWeekOfWeekyear() { DateTime test = new DateTime(2004, 6, 7, 0, 0, 0, 0); DateTime copy = test.weekOfWeekyear().addToCopy(1); assertEquals("2004-06-07T00:00:00.000+01:00", test.toString()); assertEquals("2004-06-14T00:00:00.000+01:00", copy.toString()); copy = test.weekOfWeekyear().addToCopy(29); assertEquals("2004-12-27T00:00:00.000Z", copy.toString()); copy = test.weekOfWeekyear().addToCopy(30); assertEquals("2005-01-03T00:00:00.000Z", copy.toString()); copy = test.weekOfWeekyear().addToCopy(-22); assertEquals("2004-01-05T00:00:00.000Z", copy.toString()); copy = test.weekOfWeekyear().addToCopy(-23); assertEquals("2003-12-29T00:00:00.000Z", copy.toString()); } public void testPropertyAddWrapFieldWeekOfWeekyear() { DateTime test = new DateTime(2004, 6, 7, 0, 0, 0, 0); DateTime copy = test.weekOfWeekyear().addWrapFieldToCopy(1); assertEquals("2004-06-07T00:00:00.000+01:00", test.toString()); assertEquals("2004-06-14T00:00:00.000+01:00", copy.toString()); copy = test.weekOfWeekyear().addWrapFieldToCopy(29); assertEquals("2004-12-27T00:00:00.000Z", copy.toString()); copy = test.weekOfWeekyear().addWrapFieldToCopy(30); assertEquals("2003-12-29T00:00:00.000Z", copy.toString()); copy = test.weekOfWeekyear().addWrapFieldToCopy(-23); assertEquals("2003-12-29T00:00:00.000Z", copy.toString()); } public void testPropertySetWeekOfWeekyear() { DateTime test = new DateTime(2004, 6, 7, 0, 0, 0, 0); DateTime copy = test.weekOfWeekyear().setCopy(4); assertEquals("2004-06-07T00:00:00.000+01:00", test.toString()); assertEquals("2004-01-19T00:00:00.000Z", copy.toString()); try { test.weekOfWeekyear().setCopy(54); fail(); } catch (IllegalArgumentException ex) {} try { test.weekOfWeekyear().setCopy(0); fail(); } catch (IllegalArgumentException ex) {} } public void testPropertySetTextWeekOfWeekyear() { DateTime test = new DateTime(2004, 6, 7, 0, 0, 0, 0); DateTime copy = test.weekOfWeekyear().setCopy("4"); assertEquals("2004-06-07T00:00:00.000+01:00", test.toString()); assertEquals("2004-01-19T00:00:00.000Z", copy.toString()); } public void testPropertyCompareToWeekOfWeekyear() { DateTime test1 = new DateTime(TEST_TIME1); DateTime test2 = new DateTime(TEST_TIME2); assertEquals(true, test1.weekOfWeekyear().compareTo(test2) < 0); assertEquals(true, test2.weekOfWeekyear().compareTo(test1) > 0); assertEquals(true, test1.weekOfWeekyear().compareTo(test1) == 0); try { test1.weekOfWeekyear().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} DateTime dt1 = new DateTime(TEST_TIME1); DateTime dt2 = new DateTime(TEST_TIME2); assertEquals(true, test1.weekOfWeekyear().compareTo(dt2) < 0); assertEquals(true, test2.weekOfWeekyear().compareTo(dt1) > 0); assertEquals(true, test1.weekOfWeekyear().compareTo(dt1) == 0); try { test1.weekOfWeekyear().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testPropertyGetDayOfWeek() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); assertSame(test.getChronology().dayOfWeek(), test.dayOfWeek().getField()); assertEquals("dayOfWeek", test.dayOfWeek().getName()); assertEquals("Property[dayOfWeek]", test.dayOfWeek().toString()); assertSame(test, test.dayOfWeek().getDateTime()); assertEquals(3, test.dayOfWeek().get()); assertEquals("3", test.dayOfWeek().getAsString()); assertEquals("Wednesday", test.dayOfWeek().getAsText()); assertEquals("Wednesday", test.dayOfWeek().getField().getAsText(3, Locale.ENGLISH)); assertEquals("mercredi", test.dayOfWeek().getAsText(Locale.FRENCH)); assertEquals("mercredi", test.dayOfWeek().getField().getAsText(3, Locale.FRENCH)); assertEquals("Wed", test.dayOfWeek().getAsShortText()); assertEquals("Wed", test.dayOfWeek().getField().getAsShortText(3, Locale.ENGLISH)); assertEquals("mer.", test.dayOfWeek().getAsShortText(Locale.FRENCH)); assertEquals("mer.", test.dayOfWeek().getField().getAsShortText(3, Locale.FRENCH)); assertEquals(test.getChronology().days(), test.dayOfWeek().getDurationField()); assertEquals(test.getChronology().weeks(), test.dayOfWeek().getRangeDurationField()); assertEquals(9, test.dayOfWeek().getMaximumTextLength(null)); assertEquals(8, test.dayOfWeek().getMaximumTextLength(Locale.FRENCH)); assertEquals(3, test.dayOfWeek().getMaximumShortTextLength(null)); assertEquals(4, test.dayOfWeek().getMaximumShortTextLength(Locale.FRENCH)); assertEquals(1, test.dayOfWeek().getMinimumValue()); assertEquals(1, test.dayOfWeek().getMinimumValueOverall()); assertEquals(7, test.dayOfWeek().getMaximumValue()); assertEquals(7, test.dayOfWeek().getMaximumValueOverall()); assertEquals(false, test.dayOfWeek().isLeap()); assertEquals(0, test.dayOfWeek().getLeapAmount()); assertEquals(null, test.dayOfWeek().getLeapDurationField()); } public void testPropertyAddDayOfWeek() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime copy = test.dayOfWeek().addToCopy(1); assertEquals("2004-06-09T00:00:00.000+01:00", test.toString()); assertEquals("2004-06-10T00:00:00.000+01:00", copy.toString()); copy = test.dayOfWeek().addToCopy(21); assertEquals("2004-06-30T00:00:00.000+01:00", copy.toString()); copy = test.dayOfWeek().addToCopy(22); assertEquals("2004-07-01T00:00:00.000+01:00", copy.toString()); copy = test.dayOfWeek().addToCopy(21 + 31 + 31 + 30 + 31 + 30 + 31); assertEquals("2004-12-31T00:00:00.000Z", copy.toString()); copy = test.dayOfWeek().addToCopy(22 + 31 + 31 + 30 + 31 + 30 + 31); assertEquals("2005-01-01T00:00:00.000Z", copy.toString()); copy = test.dayOfWeek().addToCopy(-8); assertEquals("2004-06-01T00:00:00.000+01:00", copy.toString()); copy = test.dayOfWeek().addToCopy(-9); assertEquals("2004-05-31T00:00:00.000+01:00", copy.toString()); copy = test.dayOfWeek().addToCopy(-8 - 31 - 30 - 31 - 29 - 31); assertEquals("2004-01-01T00:00:00.000Z", copy.toString()); copy = test.dayOfWeek().addToCopy(-9 - 31 - 30 - 31 - 29 - 31); assertEquals("2003-12-31T00:00:00.000Z", copy.toString()); } public void testPropertyAddLongDayOfWeek() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime copy = test.dayOfWeek().addToCopy(1L); assertEquals("2004-06-09T00:00:00.000+01:00", test.toString()); assertEquals("2004-06-10T00:00:00.000+01:00", copy.toString()); } public void testPropertyAddWrapFieldDayOfWeek() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); // Wed DateTime copy = test.dayOfWeek().addWrapFieldToCopy(1); assertEquals("2004-06-09T00:00:00.000+01:00", test.toString()); assertEquals("2004-06-10T00:00:00.000+01:00", copy.toString()); copy = test.dayOfWeek().addWrapFieldToCopy(5); assertEquals("2004-06-07T00:00:00.000+01:00", copy.toString()); copy = test.dayOfWeek().addWrapFieldToCopy(-10); assertEquals("2004-06-13T00:00:00.000+01:00", copy.toString()); test = new DateTime(2004, 6, 2, 0, 0, 0, 0); copy = test.dayOfWeek().addWrapFieldToCopy(5); assertEquals("2004-06-02T00:00:00.000+01:00", test.toString()); assertEquals("2004-05-31T00:00:00.000+01:00", copy.toString()); } public void testPropertySetDayOfWeek() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime copy = test.dayOfWeek().setCopy(4); assertEquals("2004-06-09T00:00:00.000+01:00", test.toString()); assertEquals("2004-06-10T00:00:00.000+01:00", copy.toString()); try { test.dayOfWeek().setCopy(8); fail(); } catch (IllegalArgumentException ex) {} try { test.dayOfWeek().setCopy(0); fail(); } catch (IllegalArgumentException ex) {} } public void testPropertySetTextDayOfWeek() { DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime copy = test.dayOfWeek().setCopy("4"); assertEquals("2004-06-09T00:00:00.000+01:00", test.toString()); assertEquals("2004-06-10T00:00:00.000+01:00", copy.toString()); copy = test.dayOfWeek().setCopy("Mon"); assertEquals("2004-06-07T00:00:00.000+01:00", copy.toString()); copy = test.dayOfWeek().setCopy("Tuesday"); assertEquals("2004-06-08T00:00:00.000+01:00", copy.toString()); copy = test.dayOfWeek().setCopy("lundi", Locale.FRENCH); assertEquals("2004-06-07T00:00:00.000+01:00", copy.toString()); } public void testPropertyCompareToDayOfWeek() { DateTime test1 = new DateTime(TEST_TIME1); DateTime test2 = new DateTime(TEST_TIME2); assertEquals(true, test2.dayOfWeek().compareTo(test1) < 0); assertEquals(true, test1.dayOfWeek().compareTo(test2) > 0); assertEquals(true, test1.dayOfWeek().compareTo(test1) == 0); try { test1.dayOfWeek().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} DateTime dt1 = new DateTime(TEST_TIME1); DateTime dt2 = new DateTime(TEST_TIME2); assertEquals(true, test2.dayOfWeek().compareTo(dt1) < 0); assertEquals(true, test1.dayOfWeek().compareTo(dt2) > 0); assertEquals(true, test1.dayOfWeek().compareTo(dt1) == 0); try { test1.dayOfWeek().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testPropertyGetHourOfDay() { DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53); assertSame(test.getChronology().hourOfDay(), test.hourOfDay().getField()); assertEquals("hourOfDay", test.hourOfDay().getName()); assertEquals("Property[hourOfDay]", test.hourOfDay().toString()); assertSame(test, test.hourOfDay().getDateTime()); assertEquals(13, test.hourOfDay().get()); assertEquals("13", test.hourOfDay().getAsString()); assertEquals("13", test.hourOfDay().getAsText()); assertEquals("13", test.hourOfDay().getAsText(Locale.FRENCH)); assertEquals("13", test.hourOfDay().getAsShortText()); assertEquals("13", test.hourOfDay().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().hours(), test.hourOfDay().getDurationField()); assertEquals(test.getChronology().days(), test.hourOfDay().getRangeDurationField()); assertEquals(2, test.hourOfDay().getMaximumTextLength(null)); assertEquals(2, test.hourOfDay().getMaximumShortTextLength(null)); } public void testPropertyGetDifferenceHourOfDay() { DateTime test1 = new DateTime(2004, 6, 9, 13, 30, 0, 0); DateTime test2 = new DateTime(2004, 6, 9, 15, 30, 0, 0); assertEquals(-2, test1.hourOfDay().getDifference(test2)); assertEquals(2, test2.hourOfDay().getDifference(test1)); assertEquals(-2L, test1.hourOfDay().getDifferenceAsLong(test2)); assertEquals(2L, test2.hourOfDay().getDifferenceAsLong(test1)); DateTime test = new DateTime(TEST_TIME_NOW + (13L * DateTimeConstants.MILLIS_PER_HOUR)); assertEquals(13, test.hourOfDay().getDifference(null)); assertEquals(13L, test.hourOfDay().getDifferenceAsLong(null)); } public void testPropertyRoundFloorHourOfDay() { DateTime test = new DateTime(2004, 6, 9, 13, 30, 0, 0); DateTime copy = test.hourOfDay().roundFloorCopy(); assertEquals("2004-06-09T13:00:00.000+01:00", copy.toString()); } public void testPropertyRoundCeilingHourOfDay() { DateTime test = new DateTime(2004, 6, 9, 13, 30, 0, 0); DateTime copy = test.hourOfDay().roundCeilingCopy(); assertEquals("2004-06-09T14:00:00.000+01:00", copy.toString()); } public void testPropertyRoundHalfFloorHourOfDay() { DateTime test = new DateTime(2004, 6, 9, 13, 30, 0, 0); DateTime copy = test.hourOfDay().roundHalfFloorCopy(); assertEquals("2004-06-09T13:00:00.000+01:00", copy.toString()); test = new DateTime(2004, 6, 9, 13, 30, 0, 1); copy = test.hourOfDay().roundHalfFloorCopy(); assertEquals("2004-06-09T14:00:00.000+01:00", copy.toString()); test = new DateTime(2004, 6, 9, 13, 29, 59, 999); copy = test.hourOfDay().roundHalfFloorCopy(); assertEquals("2004-06-09T13:00:00.000+01:00", copy.toString()); } public void testPropertyRoundHalfCeilingHourOfDay() { DateTime test = new DateTime(2004, 6, 9, 13, 30, 0, 0); DateTime copy = test.hourOfDay().roundHalfCeilingCopy(); assertEquals("2004-06-09T14:00:00.000+01:00", copy.toString()); test = new DateTime(2004, 6, 9, 13, 30, 0, 1); copy = test.hourOfDay().roundHalfCeilingCopy(); assertEquals("2004-06-09T14:00:00.000+01:00", copy.toString()); test = new DateTime(2004, 6, 9, 13, 29, 59, 999); copy = test.hourOfDay().roundHalfCeilingCopy(); assertEquals("2004-06-09T13:00:00.000+01:00", copy.toString()); } public void testPropertyRoundHalfEvenHourOfDay() { DateTime test = new DateTime(2004, 6, 9, 13, 30, 0, 0); DateTime copy = test.hourOfDay().roundHalfEvenCopy(); assertEquals("2004-06-09T14:00:00.000+01:00", copy.toString()); test = new DateTime(2004, 6, 9, 14, 30, 0, 0); copy = test.hourOfDay().roundHalfEvenCopy(); assertEquals("2004-06-09T14:00:00.000+01:00", copy.toString()); test = new DateTime(2004, 6, 9, 13, 30, 0, 1); copy = test.hourOfDay().roundHalfEvenCopy(); assertEquals("2004-06-09T14:00:00.000+01:00", copy.toString()); test = new DateTime(2004, 6, 9, 13, 29, 59, 999); copy = test.hourOfDay().roundHalfEvenCopy(); assertEquals("2004-06-09T13:00:00.000+01:00", copy.toString()); } public void testPropertyRemainderHourOfDay() { DateTime test = new DateTime(2004, 6, 9, 13, 30, 0, 0); assertEquals(30L * DateTimeConstants.MILLIS_PER_MINUTE, test.hourOfDay().remainder()); } //----------------------------------------------------------------------- public void testPropertyGetMinuteOfHour() { DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53); assertSame(test.getChronology().minuteOfHour(), test.minuteOfHour().getField()); assertEquals("minuteOfHour", test.minuteOfHour().getName()); assertEquals("Property[minuteOfHour]", test.minuteOfHour().toString()); assertSame(test, test.minuteOfHour().getDateTime()); assertEquals(23, test.minuteOfHour().get()); assertEquals("23", test.minuteOfHour().getAsString()); assertEquals("23", test.minuteOfHour().getAsText()); assertEquals("23", test.minuteOfHour().getAsText(Locale.FRENCH)); assertEquals("23", test.minuteOfHour().getAsShortText()); assertEquals("23", test.minuteOfHour().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().minutes(), test.minuteOfHour().getDurationField()); assertEquals(test.getChronology().hours(), test.minuteOfHour().getRangeDurationField()); assertEquals(2, test.minuteOfHour().getMaximumTextLength(null)); assertEquals(2, test.minuteOfHour().getMaximumShortTextLength(null)); } //----------------------------------------------------------------------- public void testPropertyGetMinuteOfDay() { DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53); assertSame(test.getChronology().minuteOfDay(), test.minuteOfDay().getField()); assertEquals("minuteOfDay", test.minuteOfDay().getName()); assertEquals("Property[minuteOfDay]", test.minuteOfDay().toString()); assertSame(test, test.minuteOfDay().getDateTime()); assertEquals(803, test.minuteOfDay().get()); assertEquals("803", test.minuteOfDay().getAsString()); assertEquals("803", test.minuteOfDay().getAsText()); assertEquals("803", test.minuteOfDay().getAsText(Locale.FRENCH)); assertEquals("803", test.minuteOfDay().getAsShortText()); assertEquals("803", test.minuteOfDay().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().minutes(), test.minuteOfDay().getDurationField()); assertEquals(test.getChronology().days(), test.minuteOfDay().getRangeDurationField()); assertEquals(4, test.minuteOfDay().getMaximumTextLength(null)); assertEquals(4, test.minuteOfDay().getMaximumShortTextLength(null)); } //----------------------------------------------------------------------- public void testPropertyGetSecondOfMinute() { DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53); assertSame(test.getChronology().secondOfMinute(), test.secondOfMinute().getField()); assertEquals("secondOfMinute", test.secondOfMinute().getName()); assertEquals("Property[secondOfMinute]", test.secondOfMinute().toString()); assertSame(test, test.secondOfMinute().getDateTime()); assertEquals(43, test.secondOfMinute().get()); assertEquals("43", test.secondOfMinute().getAsString()); assertEquals("43", test.secondOfMinute().getAsText()); assertEquals("43", test.secondOfMinute().getAsText(Locale.FRENCH)); assertEquals("43", test.secondOfMinute().getAsShortText()); assertEquals("43", test.secondOfMinute().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().seconds(), test.secondOfMinute().getDurationField()); assertEquals(test.getChronology().minutes(), test.secondOfMinute().getRangeDurationField()); assertEquals(2, test.secondOfMinute().getMaximumTextLength(null)); assertEquals(2, test.secondOfMinute().getMaximumShortTextLength(null)); } //----------------------------------------------------------------------- public void testPropertyGetSecondOfDay() { DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53); assertSame(test.getChronology().secondOfDay(), test.secondOfDay().getField()); assertEquals("secondOfDay", test.secondOfDay().getName()); assertEquals("Property[secondOfDay]", test.secondOfDay().toString()); assertSame(test, test.secondOfDay().getDateTime()); assertEquals(48223, test.secondOfDay().get()); assertEquals("48223", test.secondOfDay().getAsString()); assertEquals("48223", test.secondOfDay().getAsText()); assertEquals("48223", test.secondOfDay().getAsText(Locale.FRENCH)); assertEquals("48223", test.secondOfDay().getAsShortText()); assertEquals("48223", test.secondOfDay().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().seconds(), test.secondOfDay().getDurationField()); assertEquals(test.getChronology().days(), test.secondOfDay().getRangeDurationField()); assertEquals(5, test.secondOfDay().getMaximumTextLength(null)); assertEquals(5, test.secondOfDay().getMaximumShortTextLength(null)); } //----------------------------------------------------------------------- public void testPropertyGetMillisOfSecond() { DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53); assertSame(test.getChronology().millisOfSecond(), test.millisOfSecond().getField()); assertEquals("millisOfSecond", test.millisOfSecond().getName()); assertEquals("Property[millisOfSecond]", test.millisOfSecond().toString()); assertSame(test, test.millisOfSecond().getDateTime()); assertEquals(53, test.millisOfSecond().get()); assertEquals("53", test.millisOfSecond().getAsString()); assertEquals("53", test.millisOfSecond().getAsText()); assertEquals("53", test.millisOfSecond().getAsText(Locale.FRENCH)); assertEquals("53", test.millisOfSecond().getAsShortText()); assertEquals("53", test.millisOfSecond().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().millis(), test.millisOfSecond().getDurationField()); assertEquals(test.getChronology().seconds(), test.millisOfSecond().getRangeDurationField()); assertEquals(3, test.millisOfSecond().getMaximumTextLength(null)); assertEquals(3, test.millisOfSecond().getMaximumShortTextLength(null)); } //----------------------------------------------------------------------- public void testPropertyGetMillisOfDay() { DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53); assertSame(test.getChronology().millisOfDay(), test.millisOfDay().getField()); assertEquals("millisOfDay", test.millisOfDay().getName()); assertEquals("Property[millisOfDay]", test.millisOfDay().toString()); assertSame(test, test.millisOfDay().getDateTime()); assertEquals(48223053, test.millisOfDay().get()); assertEquals("48223053", test.millisOfDay().getAsString()); assertEquals("48223053", test.millisOfDay().getAsText()); assertEquals("48223053", test.millisOfDay().getAsText(Locale.FRENCH)); assertEquals("48223053", test.millisOfDay().getAsShortText()); assertEquals("48223053", test.millisOfDay().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().millis(), test.millisOfDay().getDurationField()); assertEquals(test.getChronology().days(), test.millisOfDay().getRangeDurationField()); assertEquals(8, test.millisOfDay().getMaximumTextLength(null)); assertEquals(8, test.millisOfDay().getMaximumShortTextLength(null)); } //----------------------------------------------------------------------- public void testPropertyToIntervalYearOfEra() { DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53); Interval testInterval = test.yearOfEra().toInterval(); assertEquals(new DateTime(2004, 1, 1, 0, 0, 0, 0), testInterval.getStart()); assertEquals(new DateTime(2005, 1, 1, 0, 0, 0, 0), testInterval.getEnd()); } public void testPropertyToIntervalYearOfCentury() { DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53); Interval testInterval = test.yearOfCentury().toInterval(); assertEquals(new DateTime(2004, 1, 1, 0, 0, 0, 0), testInterval.getStart()); assertEquals(new DateTime(2005, 1, 1, 0, 0, 0, 0), testInterval.getEnd()); } public void testPropertyToIntervalYear() { DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53); Interval testInterval = test.year().toInterval(); assertEquals(new DateTime(2004, 1, 1, 0, 0, 0, 0), testInterval.getStart()); assertEquals(new DateTime(2005, 1, 1, 0, 0, 0, 0), testInterval.getEnd()); } public void testPropertyToIntervalMonthOfYear() { DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53); Interval testInterval = test.monthOfYear().toInterval(); assertEquals(new DateTime(2004, 6, 1, 0, 0, 0, 0), testInterval.getStart()); assertEquals(new DateTime(2004, 7, 1, 0, 0, 0, 0), testInterval.getEnd()); } public void testPropertyToIntervalDayOfMonth() { DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53); Interval testInterval = test.dayOfMonth().toInterval(); assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0), testInterval.getStart()); assertEquals(new DateTime(2004, 6, 10, 0, 0, 0, 0), testInterval.getEnd()); DateTime febTest = new DateTime(2004, 2, 29, 13, 23, 43, 53); Interval febTestInterval = febTest.dayOfMonth().toInterval(); assertEquals(new DateTime(2004, 2, 29, 0, 0, 0, 0), febTestInterval.getStart()); assertEquals(new DateTime(2004, 3, 1, 0, 0, 0, 0), febTestInterval.getEnd()); } public void testPropertyToIntervalHourOfDay() { DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53); Interval testInterval = test.hourOfDay().toInterval(); assertEquals(new DateTime(2004, 6, 9, 13, 0, 0, 0), testInterval.getStart()); assertEquals(new DateTime(2004, 6, 9, 14, 0, 0, 0), testInterval.getEnd()); DateTime midnightTest = new DateTime(2004, 6, 9, 23, 23, 43, 53); Interval midnightTestInterval = midnightTest.hourOfDay().toInterval(); assertEquals(new DateTime(2004, 6, 9, 23, 0, 0, 0), midnightTestInterval.getStart()); assertEquals(new DateTime(2004, 6, 10, 0, 0, 0, 0), midnightTestInterval.getEnd()); } public void testPropertyToIntervalMinuteOfHour() { DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53); Interval testInterval = test.minuteOfHour().toInterval(); assertEquals(new DateTime(2004, 6, 9, 13, 23, 0, 0), testInterval.getStart()); assertEquals(new DateTime(2004, 6, 9, 13, 24, 0, 0), testInterval.getEnd()); } public void testPropertyToIntervalSecondOfMinute() { DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53); Interval testInterval = test.secondOfMinute().toInterval(); assertEquals(new DateTime(2004, 6, 9, 13, 23, 43, 0), testInterval.getStart()); assertEquals(new DateTime(2004, 6, 9, 13, 23, 44, 0), testInterval.getEnd()); } public void testPropertyToIntervalMillisOfSecond() { DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53); Interval testInterval = test.millisOfSecond().toInterval(); assertEquals(new DateTime(2004, 6, 9, 13, 23, 43, 53), testInterval.getStart()); assertEquals(new DateTime(2004, 6, 9, 13, 23, 43, 54), testInterval.getEnd()); } public void testPropertyEqualsHashCodeLenient() { DateTime test1 = new DateTime(1970, 6, 9, 0, 0, 0, 0, LenientChronology.getInstance(COPTIC_PARIS)); DateTime test2 = new DateTime(1970, 6, 9, 0, 0, 0, 0, LenientChronology.getInstance(COPTIC_PARIS)); assertEquals(true, test1.dayOfMonth().equals(test2.dayOfMonth())); assertEquals(true, test2.dayOfMonth().equals(test1.dayOfMonth())); assertEquals(true, test1.dayOfMonth().equals(test1.dayOfMonth())); assertEquals(true, test2.dayOfMonth().equals(test2.dayOfMonth())); assertEquals(true, test1.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode()); assertEquals(true, test1.dayOfMonth().hashCode() == test1.dayOfMonth().hashCode()); assertEquals(true, test2.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode()); } public void testPropertyEqualsHashCodeStrict() { DateTime test1 = new DateTime(1970, 6, 9, 0, 0, 0, 0, StrictChronology.getInstance(COPTIC_PARIS)); DateTime test2 = new DateTime(1970, 6, 9, 0, 0, 0, 0, StrictChronology.getInstance(COPTIC_PARIS)); assertEquals(true, test1.dayOfMonth().equals(test2.dayOfMonth())); assertEquals(true, test2.dayOfMonth().equals(test1.dayOfMonth())); assertEquals(true, test1.dayOfMonth().equals(test1.dayOfMonth())); assertEquals(true, test2.dayOfMonth().equals(test2.dayOfMonth())); assertEquals(true, test1.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode()); assertEquals(true, test1.dayOfMonth().hashCode() == test1.dayOfMonth().hashCode()); assertEquals(true, test2.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode()); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import junit.framework.TestCase; import junit.framework.TestSuite; /** * This class is a Junit unit test for Days. * * @author Stephen Colebourne */ public class TestDays extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestDays.class); } public TestDays(String name) { super(name); } protected void setUp() throws Exception { } protected void tearDown() throws Exception { } //----------------------------------------------------------------------- public void testConstants() { assertEquals(0, Days.ZERO.getDays()); assertEquals(1, Days.ONE.getDays()); assertEquals(2, Days.TWO.getDays()); assertEquals(3, Days.THREE.getDays()); assertEquals(4, Days.FOUR.getDays()); assertEquals(5, Days.FIVE.getDays()); assertEquals(6, Days.SIX.getDays()); assertEquals(7, Days.SEVEN.getDays()); assertEquals(Integer.MAX_VALUE, Days.MAX_VALUE.getDays()); assertEquals(Integer.MIN_VALUE, Days.MIN_VALUE.getDays()); } //----------------------------------------------------------------------- public void testFactory_days_int() { assertSame(Days.ZERO, Days.days(0)); assertSame(Days.ONE, Days.days(1)); assertSame(Days.TWO, Days.days(2)); assertSame(Days.THREE, Days.days(3)); assertSame(Days.FOUR, Days.days(4)); assertSame(Days.FIVE, Days.days(5)); assertSame(Days.SIX, Days.days(6)); assertSame(Days.SEVEN, Days.days(7)); assertSame(Days.MAX_VALUE, Days.days(Integer.MAX_VALUE)); assertSame(Days.MIN_VALUE, Days.days(Integer.MIN_VALUE)); assertEquals(-1, Days.days(-1).getDays()); assertEquals(8, Days.days(8).getDays()); } //----------------------------------------------------------------------- public void testFactory_daysBetween_RInstant() { DateTime start = new DateTime(2006, 6, 9, 12, 0, 0, 0, PARIS); DateTime end1 = new DateTime(2006, 6, 12, 12, 0, 0, 0, PARIS); DateTime end2 = new DateTime(2006, 6, 15, 18, 0, 0, 0, PARIS); assertEquals(3, Days.daysBetween(start, end1).getDays()); assertEquals(0, Days.daysBetween(start, start).getDays()); assertEquals(0, Days.daysBetween(end1, end1).getDays()); assertEquals(-3, Days.daysBetween(end1, start).getDays()); assertEquals(6, Days.daysBetween(start, end2).getDays()); } //----------------------------------------------------------------------- @SuppressWarnings("deprecation") public void testFactory_daysBetween_RPartial_LocalDate() { LocalDate start = new LocalDate(2006, 6, 9); LocalDate end1 = new LocalDate(2006, 6, 12); YearMonthDay end2 = new YearMonthDay(2006, 6, 15); assertEquals(3, Days.daysBetween(start, end1).getDays()); assertEquals(0, Days.daysBetween(start, start).getDays()); assertEquals(0, Days.daysBetween(end1, end1).getDays()); assertEquals(-3, Days.daysBetween(end1, start).getDays()); assertEquals(6, Days.daysBetween(start, end2).getDays()); } public void testFactory_daysBetween_RPartial_YearMonth() { YearMonth start1 = new YearMonth(2011, 1); YearMonth start2 = new YearMonth(2012, 1); YearMonth end1 = new YearMonth(2011, 3); YearMonth end2 = new YearMonth(2012, 3); assertEquals(59, Days.daysBetween(start1, end1).getDays()); assertEquals(60, Days.daysBetween(start2, end2).getDays()); assertEquals(-59, Days.daysBetween(end1, start1).getDays()); assertEquals(-60, Days.daysBetween(end2, start2).getDays()); } public void testFactory_daysBetween_RPartial_MonthDay() { MonthDay start1 = new MonthDay(2, 1); MonthDay start2 = new MonthDay(2, 28); MonthDay end1 = new MonthDay(2, 28); MonthDay end2 = new MonthDay(2, 29); assertEquals(27, Days.daysBetween(start1, end1).getDays()); assertEquals(28, Days.daysBetween(start1, end2).getDays()); assertEquals(0, Days.daysBetween(start2, end1).getDays()); assertEquals(1, Days.daysBetween(start2, end2).getDays()); assertEquals(-27, Days.daysBetween(end1, start1).getDays()); assertEquals(-28, Days.daysBetween(end2, start1).getDays()); assertEquals(0, Days.daysBetween(end1, start2).getDays()); assertEquals(-1, Days.daysBetween(end2, start2).getDays()); } //----------------------------------------------------------------------- public void testFactory_daysIn_RInterval() { DateTime start = new DateTime(2006, 6, 9, 12, 0, 0, 0, PARIS); DateTime end1 = new DateTime(2006, 6, 12, 12, 0, 0, 0, PARIS); DateTime end2 = new DateTime(2006, 6, 15, 18, 0, 0, 0, PARIS); assertEquals(0, Days.daysIn((ReadableInterval) null).getDays()); assertEquals(3, Days.daysIn(new Interval(start, end1)).getDays()); assertEquals(0, Days.daysIn(new Interval(start, start)).getDays()); assertEquals(0, Days.daysIn(new Interval(end1, end1)).getDays()); assertEquals(6, Days.daysIn(new Interval(start, end2)).getDays()); } //----------------------------------------------------------------------- public void testFactory_standardDaysIn_RPeriod() { assertEquals(0, Days.standardDaysIn((ReadablePeriod) null).getDays()); assertEquals(0, Days.standardDaysIn(Period.ZERO).getDays()); assertEquals(1, Days.standardDaysIn(new Period(0, 0, 0, 1, 0, 0, 0, 0)).getDays()); assertEquals(123, Days.standardDaysIn(Period.days(123)).getDays()); assertEquals(-987, Days.standardDaysIn(Period.days(-987)).getDays()); assertEquals(1, Days.standardDaysIn(Period.hours(47)).getDays()); assertEquals(2, Days.standardDaysIn(Period.hours(48)).getDays()); assertEquals(2, Days.standardDaysIn(Period.hours(49)).getDays()); assertEquals(14, Days.standardDaysIn(Period.weeks(2)).getDays()); try { Days.standardDaysIn(Period.months(1)); fail(); } catch (IllegalArgumentException ex) { // expeceted } } public void testFactory_parseDays_String() { assertEquals(0, Days.parseDays((String) null).getDays()); assertEquals(0, Days.parseDays("P0D").getDays()); assertEquals(1, Days.parseDays("P1D").getDays()); assertEquals(-3, Days.parseDays("P-3D").getDays()); assertEquals(2, Days.parseDays("P0Y0M2D").getDays()); assertEquals(2, Days.parseDays("P2DT0H0M").getDays()); try { Days.parseDays("P1Y1D"); fail(); } catch (IllegalArgumentException ex) { // expeceted } try { Days.parseDays("P1DT1H"); fail(); } catch (IllegalArgumentException ex) { // expeceted } } //----------------------------------------------------------------------- public void testGetMethods() { Days test = Days.days(20); assertEquals(20, test.getDays()); } public void testGetFieldType() { Days test = Days.days(20); assertEquals(DurationFieldType.days(), test.getFieldType()); } public void testGetPeriodType() { Days test = Days.days(20); assertEquals(PeriodType.days(), test.getPeriodType()); } //----------------------------------------------------------------------- public void testIsGreaterThan() { assertEquals(true, Days.THREE.isGreaterThan(Days.TWO)); assertEquals(false, Days.THREE.isGreaterThan(Days.THREE)); assertEquals(false, Days.TWO.isGreaterThan(Days.THREE)); assertEquals(true, Days.ONE.isGreaterThan(null)); assertEquals(false, Days.days(-1).isGreaterThan(null)); } public void testIsLessThan() { assertEquals(false, Days.THREE.isLessThan(Days.TWO)); assertEquals(false, Days.THREE.isLessThan(Days.THREE)); assertEquals(true, Days.TWO.isLessThan(Days.THREE)); assertEquals(false, Days.ONE.isLessThan(null)); assertEquals(true, Days.days(-1).isLessThan(null)); } //----------------------------------------------------------------------- public void testToString() { Days test = Days.days(20); assertEquals("P20D", test.toString()); test = Days.days(-20); assertEquals("P-20D", test.toString()); } //----------------------------------------------------------------------- public void testSerialization() throws Exception { Days test = Days.SEVEN; ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(test); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); Days result = (Days) ois.readObject(); ois.close(); assertSame(test, result); } //----------------------------------------------------------------------- public void testToStandardWeeks() { Days test = Days.days(14); Weeks expected = Weeks.weeks(2); assertEquals(expected, test.toStandardWeeks()); } public void testToStandardHours() { Days test = Days.days(2); Hours expected = Hours.hours(2 * 24); assertEquals(expected, test.toStandardHours()); try { Days.MAX_VALUE.toStandardHours(); fail(); } catch (ArithmeticException ex) { // expected } } public void testToStandardMinutes() { Days test = Days.days(2); Minutes expected = Minutes.minutes(2 * 24 * 60); assertEquals(expected, test.toStandardMinutes()); try { Days.MAX_VALUE.toStandardMinutes(); fail(); } catch (ArithmeticException ex) { // expected } } public void testToStandardSeconds() { Days test = Days.days(2); Seconds expected = Seconds.seconds(2 * 24 * 60 * 60); assertEquals(expected, test.toStandardSeconds()); try { Days.MAX_VALUE.toStandardSeconds(); fail(); } catch (ArithmeticException ex) { // expected } } public void testToStandardDuration() { Days test = Days.days(20); Duration expected = new Duration(20L * DateTimeConstants.MILLIS_PER_DAY); assertEquals(expected, test.toStandardDuration()); expected = new Duration(((long) Integer.MAX_VALUE) * DateTimeConstants.MILLIS_PER_DAY); assertEquals(expected, Days.MAX_VALUE.toStandardDuration()); } //----------------------------------------------------------------------- public void testPlus_int() { Days test2 = Days.days(2); Days result = test2.plus(3); assertEquals(2, test2.getDays()); assertEquals(5, result.getDays()); assertEquals(1, Days.ONE.plus(0).getDays()); try { Days.MAX_VALUE.plus(1); fail(); } catch (ArithmeticException ex) { // expected } } public void testPlus_Days() { Days test2 = Days.days(2); Days test3 = Days.days(3); Days result = test2.plus(test3); assertEquals(2, test2.getDays()); assertEquals(3, test3.getDays()); assertEquals(5, result.getDays()); assertEquals(1, Days.ONE.plus(Days.ZERO).getDays()); assertEquals(1, Days.ONE.plus((Days) null).getDays()); try { Days.MAX_VALUE.plus(Days.ONE); fail(); } catch (ArithmeticException ex) { // expected } } public void testMinus_int() { Days test2 = Days.days(2); Days result = test2.minus(3); assertEquals(2, test2.getDays()); assertEquals(-1, result.getDays()); assertEquals(1, Days.ONE.minus(0).getDays()); try { Days.MIN_VALUE.minus(1); fail(); } catch (ArithmeticException ex) { // expected } } public void testMinus_Days() { Days test2 = Days.days(2); Days test3 = Days.days(3); Days result = test2.minus(test3); assertEquals(2, test2.getDays()); assertEquals(3, test3.getDays()); assertEquals(-1, result.getDays()); assertEquals(1, Days.ONE.minus(Days.ZERO).getDays()); assertEquals(1, Days.ONE.minus((Days) null).getDays()); try { Days.MIN_VALUE.minus(Days.ONE); fail(); } catch (ArithmeticException ex) { // expected } } public void testMultipliedBy_int() { Days test = Days.days(2); assertEquals(6, test.multipliedBy(3).getDays()); assertEquals(2, test.getDays()); assertEquals(-6, test.multipliedBy(-3).getDays()); assertSame(test, test.multipliedBy(1)); Days halfMax = Days.days(Integer.MAX_VALUE / 2 + 1); try { halfMax.multipliedBy(2); fail(); } catch (ArithmeticException ex) { // expected } } public void testDividedBy_int() { Days test = Days.days(12); assertEquals(6, test.dividedBy(2).getDays()); assertEquals(12, test.getDays()); assertEquals(4, test.dividedBy(3).getDays()); assertEquals(3, test.dividedBy(4).getDays()); assertEquals(2, test.dividedBy(5).getDays()); assertEquals(2, test.dividedBy(6).getDays()); assertSame(test, test.dividedBy(1)); try { Days.ONE.dividedBy(0); fail(); } catch (ArithmeticException ex) { // expected } } public void testNegated() { Days test = Days.days(12); assertEquals(-12, test.negated().getDays()); assertEquals(12, test.getDays()); try { Days.MIN_VALUE.negated(); fail(); } catch (ArithmeticException ex) { // expected } } //----------------------------------------------------------------------- public void testAddToLocalDate() { Days test = Days.days(20); LocalDate date = new LocalDate(2006, 6, 1); LocalDate expected = new LocalDate(2006, 6, 21); assertEquals(expected, date.plus(test)); } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import org.joda.time.chrono.ISOChronology; import junit.framework.TestCase; import junit.framework.TestSuite; /** * This class is a Junit unit test for DurationField. * * @author Stephen Colebourne */ public class TestDurationField extends TestCase { public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestDurationField.class); } public TestDurationField(String name) { super(name); } protected void setUp() throws Exception { } protected void tearDown() throws Exception { } //----------------------------------------------------------------------- public void test_subtract() throws Exception { DurationField fld = ISOChronology.getInstanceUTC().millis(); assertEquals(900, fld.subtract(1000L, 100)); assertEquals(900L, fld.subtract(1000L, 100L)); assertEquals((1000L - Integer.MAX_VALUE), fld.subtract(1000L, Integer.MAX_VALUE)); assertEquals((1000L - Integer.MIN_VALUE), fld.subtract(1000L, Integer.MIN_VALUE)); assertEquals((1000L - Long.MAX_VALUE), fld.subtract(1000L, Long.MAX_VALUE)); try { fld.subtract(-1000L, Long.MIN_VALUE); fail(); } catch (ArithmeticException ex) {} } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.CopticChronology; /** * This class is a Junit unit test for DurationFieldType. * * @author Stephen Colebourne */ public class TestDurationFieldType extends TestCase { public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestDurationFieldType.class); } public TestDurationFieldType(String name) { super(name); } protected void setUp() throws Exception { } protected void tearDown() throws Exception { } //----------------------------------------------------------------------- public void test_eras() throws Exception { assertEquals(DurationFieldType.eras(), DurationFieldType.eras()); assertEquals("eras", DurationFieldType.eras().getName()); assertEquals(CopticChronology.getInstanceUTC().eras(), DurationFieldType.eras().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().eras().isSupported(), DurationFieldType.eras().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DurationFieldType.eras()); } public void test_centuries() throws Exception { assertEquals(DurationFieldType.centuries(), DurationFieldType.centuries()); assertEquals("centuries", DurationFieldType.centuries().getName()); assertEquals(CopticChronology.getInstanceUTC().centuries(), DurationFieldType.centuries().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().centuries().isSupported(), DurationFieldType.centuries().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DurationFieldType.centuries()); } public void test_years() throws Exception { assertEquals(DurationFieldType.years(), DurationFieldType.years()); assertEquals("years", DurationFieldType.years().getName()); assertEquals(CopticChronology.getInstanceUTC().years(), DurationFieldType.years().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().years().isSupported(), DurationFieldType.years().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DurationFieldType.years()); } public void test_months() throws Exception { assertEquals(DurationFieldType.months(), DurationFieldType.months()); assertEquals("months", DurationFieldType.months().getName()); assertEquals(CopticChronology.getInstanceUTC().months(), DurationFieldType.months().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().months().isSupported(), DurationFieldType.months().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DurationFieldType.months()); } public void test_weekyears() throws Exception { assertEquals(DurationFieldType.weekyears(), DurationFieldType.weekyears()); assertEquals("weekyears", DurationFieldType.weekyears().getName()); assertEquals(CopticChronology.getInstanceUTC().weekyears(), DurationFieldType.weekyears().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().weekyears().isSupported(), DurationFieldType.weekyears().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DurationFieldType.weekyears()); } public void test_weeks() throws Exception { assertEquals(DurationFieldType.weeks(), DurationFieldType.weeks()); assertEquals("weeks", DurationFieldType.weeks().getName()); assertEquals(CopticChronology.getInstanceUTC().weeks(), DurationFieldType.weeks().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().weeks().isSupported(), DurationFieldType.weeks().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DurationFieldType.weeks()); } public void test_days() throws Exception { assertEquals(DurationFieldType.days(), DurationFieldType.days()); assertEquals("days", DurationFieldType.days().getName()); assertEquals(CopticChronology.getInstanceUTC().days(), DurationFieldType.days().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().days().isSupported(), DurationFieldType.days().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DurationFieldType.days()); } public void test_halfdays() throws Exception { assertEquals(DurationFieldType.halfdays(), DurationFieldType.halfdays()); assertEquals("halfdays", DurationFieldType.halfdays().getName()); assertEquals(CopticChronology.getInstanceUTC().halfdays(), DurationFieldType.halfdays().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().halfdays().isSupported(), DurationFieldType.halfdays().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DurationFieldType.halfdays()); } public void test_hours() throws Exception { assertEquals(DurationFieldType.hours(), DurationFieldType.hours()); assertEquals("hours", DurationFieldType.hours().getName()); assertEquals(CopticChronology.getInstanceUTC().hours(), DurationFieldType.hours().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().hours().isSupported(), DurationFieldType.hours().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DurationFieldType.hours()); } public void test_minutes() throws Exception { assertEquals(DurationFieldType.minutes(), DurationFieldType.minutes()); assertEquals("minutes", DurationFieldType.minutes().getName()); assertEquals(CopticChronology.getInstanceUTC().minutes(), DurationFieldType.minutes().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().minutes().isSupported(), DurationFieldType.minutes().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DurationFieldType.minutes()); } public void test_seconds() throws Exception { assertEquals(DurationFieldType.seconds(), DurationFieldType.seconds()); assertEquals("seconds", DurationFieldType.seconds().getName()); assertEquals(CopticChronology.getInstanceUTC().seconds(), DurationFieldType.seconds().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().seconds().isSupported(), DurationFieldType.seconds().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DurationFieldType.seconds()); } public void test_millis() throws Exception { assertEquals(DurationFieldType.millis(), DurationFieldType.millis()); assertEquals("millis", DurationFieldType.millis().getName()); assertEquals(CopticChronology.getInstanceUTC().millis(), DurationFieldType.millis().getField(CopticChronology.getInstanceUTC())); assertEquals(CopticChronology.getInstanceUTC().millis().isSupported(), DurationFieldType.millis().isSupported(CopticChronology.getInstanceUTC())); assertSerialization(DurationFieldType.millis()); } public void test_other() throws Exception { assertEquals(1, DurationFieldType.class.getDeclaredClasses().length); Class cls = DurationFieldType.class.getDeclaredClasses()[0]; assertEquals(1, cls.getDeclaredConstructors().length); Constructor con = cls.getDeclaredConstructors()[0]; Object[] params = new Object[] {"other", new Byte((byte) 128)}; DurationFieldType type = (DurationFieldType) con.newInstance(params); assertEquals("other", type.getName()); try { type.getField(CopticChronology.getInstanceUTC()); fail(); } catch (InternalError ex) {} DurationFieldType result = doSerialization(type); assertEquals(type.getName(), result.getName()); assertNotSame(type, result); } //----------------------------------------------------------------------- private void assertSerialization(DurationFieldType type) throws Exception { DurationFieldType result = doSerialization(type); assertSame(type, result); } private DurationFieldType doSerialization(DurationFieldType type) throws Exception { ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(type); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); DurationFieldType result = (DurationFieldType) ois.readObject(); ois.close(); return result; } }
/* * Copyright 2001-2009 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.base.AbstractDuration; import org.joda.time.base.BaseDuration; import org.joda.time.chrono.ISOChronology; /** * This class is a Junit unit test for Duration. * * @author Stephen Colebourne */ public class TestDuration_Basics extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; // 2002-04-05 private long TEST_TIME1 = (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; // 2003-05-06 private long TEST_TIME2 = (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestDuration_Basics.class); } public TestDuration_Basics(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testTest() { assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString()); assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString()); assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString()); } //----------------------------------------------------------------------- public void testGetMillis() { Duration test = new Duration(0L); assertEquals(0, test.getMillis()); test = new Duration(1234567890L); assertEquals(1234567890L, test.getMillis()); } public void testEqualsHashCode() { Duration test1 = new Duration(123L); Duration test2 = new Duration(123L); assertEquals(true, test1.equals(test2)); assertEquals(true, test2.equals(test1)); assertEquals(true, test1.equals(test1)); assertEquals(true, test2.equals(test2)); assertEquals(true, test1.hashCode() == test2.hashCode()); assertEquals(true, test1.hashCode() == test1.hashCode()); assertEquals(true, test2.hashCode() == test2.hashCode()); Duration test3 = new Duration(321L); assertEquals(false, test1.equals(test3)); assertEquals(false, test2.equals(test3)); assertEquals(false, test3.equals(test1)); assertEquals(false, test3.equals(test2)); assertEquals(false, test1.hashCode() == test3.hashCode()); assertEquals(false, test2.hashCode() == test3.hashCode()); assertEquals(false, test1.equals("Hello")); assertEquals(true, test1.equals(new MockDuration(123L))); } class MockDuration extends AbstractDuration { private final long iValue; public MockDuration(long value) { super(); iValue = value; } public long getMillis() { return iValue; } } public void testCompareTo() { Duration test1 = new Duration(123L); Duration test1a = new Duration(123L); assertEquals(0, test1.compareTo(test1a)); assertEquals(0, test1a.compareTo(test1)); assertEquals(0, test1.compareTo(test1)); assertEquals(0, test1a.compareTo(test1a)); Duration test2 = new Duration(321L); assertEquals(-1, test1.compareTo(test2)); assertEquals(+1, test2.compareTo(test1)); assertEquals(+1, test2.compareTo(new MockDuration(123L))); assertEquals(0, test1.compareTo(new MockDuration(123L))); try { test1.compareTo(null); fail(); } catch (NullPointerException ex) {} // try { // test1.compareTo(new Long(123L)); // fail(); // } catch (ClassCastException ex) {} } public void testIsEqual() { Duration test1 = new Duration(123L); Duration test1a = new Duration(123L); assertEquals(true, test1.isEqual(test1a)); assertEquals(true, test1a.isEqual(test1)); assertEquals(true, test1.isEqual(test1)); assertEquals(true, test1a.isEqual(test1a)); Duration test2 = new Duration(321L); assertEquals(false, test1.isEqual(test2)); assertEquals(false, test2.isEqual(test1)); assertEquals(false, test2.isEqual(new MockDuration(123L))); assertEquals(true, test1.isEqual(new MockDuration(123L))); assertEquals(false, test1.isEqual(null)); assertEquals(true, new Duration(0L).isEqual(null)); } public void testIsBefore() { Duration test1 = new Duration(123L); Duration test1a = new Duration(123L); assertEquals(false, test1.isShorterThan(test1a)); assertEquals(false, test1a.isShorterThan(test1)); assertEquals(false, test1.isShorterThan(test1)); assertEquals(false, test1a.isShorterThan(test1a)); Duration test2 = new Duration(321L); assertEquals(true, test1.isShorterThan(test2)); assertEquals(false, test2.isShorterThan(test1)); assertEquals(false, test2.isShorterThan(new MockDuration(123L))); assertEquals(false, test1.isShorterThan(new MockDuration(123L))); assertEquals(false, test1.isShorterThan(null)); assertEquals(false, new Duration(0L).isShorterThan(null)); } public void testIsAfter() { Duration test1 = new Duration(123L); Duration test1a = new Duration(123L); assertEquals(false, test1.isLongerThan(test1a)); assertEquals(false, test1a.isLongerThan(test1)); assertEquals(false, test1.isLongerThan(test1)); assertEquals(false, test1a.isLongerThan(test1a)); Duration test2 = new Duration(321L); assertEquals(false, test1.isLongerThan(test2)); assertEquals(true, test2.isLongerThan(test1)); assertEquals(true, test2.isLongerThan(new MockDuration(123L))); assertEquals(false, test1.isLongerThan(new MockDuration(123L))); assertEquals(true, test1.isLongerThan(null)); assertEquals(false, new Duration(0L).isLongerThan(null)); } //----------------------------------------------------------------------- public void testSerialization() throws Exception { Duration test = new Duration(123L); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(test); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); Duration result = (Duration) ois.readObject(); ois.close(); assertEquals(test, result); } //----------------------------------------------------------------------- public void testGetStandardSeconds() { Duration test = new Duration(0L); assertEquals(0, test.getStandardSeconds()); test = new Duration(1L); assertEquals(0, test.getStandardSeconds()); test = new Duration(999L); assertEquals(0, test.getStandardSeconds()); test = new Duration(1000L); assertEquals(1, test.getStandardSeconds()); test = new Duration(1001L); assertEquals(1, test.getStandardSeconds()); test = new Duration(1999L); assertEquals(1, test.getStandardSeconds()); test = new Duration(2000L); assertEquals(2, test.getStandardSeconds()); test = new Duration(-1L); assertEquals(0, test.getStandardSeconds()); test = new Duration(-999L); assertEquals(0, test.getStandardSeconds()); test = new Duration(-1000L); assertEquals(-1, test.getStandardSeconds()); } //----------------------------------------------------------------------- public void testToString() { long length = (365L + 2L * 30L + 3L * 7L + 4L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 845L; Duration test = new Duration(length); assertEquals("PT" + (length / 1000) + "." + (length % 1000) + "S", test.toString()); assertEquals("PT0S", new Duration(0L).toString()); assertEquals("PT10S", new Duration(10000L).toString()); assertEquals("PT1S", new Duration(1000L).toString()); assertEquals("PT12.345S", new Duration(12345L).toString()); assertEquals("PT-12.345S", new Duration(-12345L).toString()); assertEquals("PT-1.123S", new Duration(-1123L).toString()); assertEquals("PT-0.123S", new Duration(-123L).toString()); assertEquals("PT-0.012S", new Duration(-12L).toString()); assertEquals("PT-0.001S", new Duration(-1L).toString()); } //----------------------------------------------------------------------- public void testToDuration1() { Duration test = new Duration(123L); Duration result = test.toDuration(); assertSame(test, result); } public void testToDuration2() { MockDuration test = new MockDuration(123L); Duration result = test.toDuration(); assertNotSame(test, result); assertEquals(test, result); } //----------------------------------------------------------------------- public void testToStandardDays() { Duration test = new Duration(0L); assertEquals(Days.days(0), test.toStandardDays()); test = new Duration(1L); assertEquals(Days.days(0), test.toStandardDays()); test = new Duration(24 * 60 * 60000L - 1); assertEquals(Days.days(0), test.toStandardDays()); test = new Duration(24 * 60 * 60000L); assertEquals(Days.days(1), test.toStandardDays()); test = new Duration(24 * 60 * 60000L + 1); assertEquals(Days.days(1), test.toStandardDays()); test = new Duration(2 * 24 * 60 * 60000L - 1); assertEquals(Days.days(1), test.toStandardDays()); test = new Duration(2 * 24 * 60 * 60000L); assertEquals(Days.days(2), test.toStandardDays()); test = new Duration(-1L); assertEquals(Days.days(0), test.toStandardDays()); test = new Duration(-24 * 60 * 60000L + 1); assertEquals(Days.days(0), test.toStandardDays()); test = new Duration(-24 * 60 * 60000L); assertEquals(Days.days(-1), test.toStandardDays()); } public void testToStandardDays_overflow() { Duration test = new Duration((((long) Integer.MAX_VALUE) + 1) * 24L * 60L * 60000L); try { test.toStandardDays(); fail(); } catch (ArithmeticException ex) { // expected } } //----------------------------------------------------------------------- public void testToStandardHours() { Duration test = new Duration(0L); assertEquals(Hours.hours(0), test.toStandardHours()); test = new Duration(1L); assertEquals(Hours.hours(0), test.toStandardHours()); test = new Duration(3600000L - 1); assertEquals(Hours.hours(0), test.toStandardHours()); test = new Duration(3600000L); assertEquals(Hours.hours(1), test.toStandardHours()); test = new Duration(3600000L + 1); assertEquals(Hours.hours(1), test.toStandardHours()); test = new Duration(2 * 3600000L - 1); assertEquals(Hours.hours(1), test.toStandardHours()); test = new Duration(2 * 3600000L); assertEquals(Hours.hours(2), test.toStandardHours()); test = new Duration(-1L); assertEquals(Hours.hours(0), test.toStandardHours()); test = new Duration(-3600000L + 1); assertEquals(Hours.hours(0), test.toStandardHours()); test = new Duration(-3600000L); assertEquals(Hours.hours(-1), test.toStandardHours()); } public void testToStandardHours_overflow() { Duration test = new Duration(((long) Integer.MAX_VALUE) * 3600000L + 3600000L); try { test.toStandardHours(); fail(); } catch (ArithmeticException ex) { // expected } } //----------------------------------------------------------------------- public void testToStandardMinutes() { Duration test = new Duration(0L); assertEquals(Minutes.minutes(0), test.toStandardMinutes()); test = new Duration(1L); assertEquals(Minutes.minutes(0), test.toStandardMinutes()); test = new Duration(60000L - 1); assertEquals(Minutes.minutes(0), test.toStandardMinutes()); test = new Duration(60000L); assertEquals(Minutes.minutes(1), test.toStandardMinutes()); test = new Duration(60000L + 1); assertEquals(Minutes.minutes(1), test.toStandardMinutes()); test = new Duration(2 * 60000L - 1); assertEquals(Minutes.minutes(1), test.toStandardMinutes()); test = new Duration(2 * 60000L); assertEquals(Minutes.minutes(2), test.toStandardMinutes()); test = new Duration(-1L); assertEquals(Minutes.minutes(0), test.toStandardMinutes()); test = new Duration(-60000L + 1); assertEquals(Minutes.minutes(0), test.toStandardMinutes()); test = new Duration(-60000L); assertEquals(Minutes.minutes(-1), test.toStandardMinutes()); } public void testToStandardMinutes_overflow() { Duration test = new Duration(((long) Integer.MAX_VALUE) * 60000L + 60000L); try { test.toStandardMinutes(); fail(); } catch (ArithmeticException ex) { // expected } } //----------------------------------------------------------------------- public void testToStandardSeconds() { Duration test = new Duration(0L); assertEquals(Seconds.seconds(0), test.toStandardSeconds()); test = new Duration(1L); assertEquals(Seconds.seconds(0), test.toStandardSeconds()); test = new Duration(999L); assertEquals(Seconds.seconds(0), test.toStandardSeconds()); test = new Duration(1000L); assertEquals(Seconds.seconds(1), test.toStandardSeconds()); test = new Duration(1001L); assertEquals(Seconds.seconds(1), test.toStandardSeconds()); test = new Duration(1999L); assertEquals(Seconds.seconds(1), test.toStandardSeconds()); test = new Duration(2000L); assertEquals(Seconds.seconds(2), test.toStandardSeconds()); test = new Duration(-1L); assertEquals(Seconds.seconds(0), test.toStandardSeconds()); test = new Duration(-999L); assertEquals(Seconds.seconds(0), test.toStandardSeconds()); test = new Duration(-1000L); assertEquals(Seconds.seconds(-1), test.toStandardSeconds()); } public void testToStandardSeconds_overflow() { Duration test = new Duration(((long) Integer.MAX_VALUE) * 1000L + 1000L); try { test.toStandardSeconds(); fail(); } catch (ArithmeticException ex) { // expected } } //----------------------------------------------------------------------- public void testToPeriod() { DateTimeZone zone = DateTimeZone.getDefault(); try { DateTimeZone.setDefault(DateTimeZone.forID("Europe/Paris")); long length = (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; Duration dur = new Duration(length); Period test = dur.toPeriod(); assertEquals(0, test.getYears()); // (4 + (3 * 7) + (2 * 30) + 365) == 450 assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals((450 * 24) + 5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } finally { DateTimeZone.setDefault(zone); } } public void testToPeriod_fixedZone() throws Throwable { DateTimeZone zone = DateTimeZone.getDefault(); try { DateTimeZone.setDefault(DateTimeZone.forOffsetHours(2)); long length = (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; Duration dur = new Duration(length); Period test = dur.toPeriod(); assertEquals(0, test.getYears()); // (4 + (3 * 7) + (2 * 30) + 365) == 450 assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals((450 * 24) + 5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } finally { DateTimeZone.setDefault(zone); } } //----------------------------------------------------------------------- public void testToPeriod_PeriodType() { long length = (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; Duration test = new Duration(length); Period result = test.toPeriod(PeriodType.standard().withMillisRemoved()); assertEquals(new Period(test, PeriodType.standard().withMillisRemoved()), result); assertEquals(new Period(test.getMillis(), PeriodType.standard().withMillisRemoved()), result); } //----------------------------------------------------------------------- public void testToPeriod_Chronology() { long length = (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; Duration test = new Duration(length); Period result = test.toPeriod(ISOChronology.getInstanceUTC()); assertEquals(new Period(test, ISOChronology.getInstanceUTC()), result); assertEquals(new Period(test.getMillis(), ISOChronology.getInstanceUTC()), result); } //----------------------------------------------------------------------- public void testToPeriod_PeriodType_Chronology() { long length = (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; Duration test = new Duration(length); Period result = test.toPeriod(PeriodType.standard().withMillisRemoved(), ISOChronology.getInstanceUTC()); assertEquals(new Period(test, PeriodType.standard().withMillisRemoved(), ISOChronology.getInstanceUTC()), result); assertEquals(new Period(test.getMillis(), PeriodType.standard().withMillisRemoved(), ISOChronology.getInstanceUTC()), result); } //----------------------------------------------------------------------- public void testToPeriodFrom() { long length = (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; Duration test = new Duration(length); DateTime dt = new DateTime(2004, 6, 9, 0, 0, 0, 0); Period result = test.toPeriodFrom(dt); assertEquals(new Period(dt, test), result); } //----------------------------------------------------------------------- public void testToPeriodFrom_PeriodType() { long length = (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; Duration test = new Duration(length); DateTime dt = new DateTime(2004, 6, 9, 0, 0, 0, 0); Period result = test.toPeriodFrom(dt, PeriodType.standard().withMillisRemoved()); assertEquals(new Period(dt, test, PeriodType.standard().withMillisRemoved()), result); } //----------------------------------------------------------------------- public void testToPeriodTo() { long length = (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; Duration test = new Duration(length); DateTime dt = new DateTime(2004, 6, 9, 0, 0, 0, 0); Period result = test.toPeriodTo(dt); assertEquals(new Period(test, dt), result); } //----------------------------------------------------------------------- public void testToPeriodTo_PeriodType() { long length = (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; Duration test = new Duration(length); DateTime dt = new DateTime(2004, 6, 9, 0, 0, 0, 0); Period result = test.toPeriodTo(dt, PeriodType.standard().withMillisRemoved()); assertEquals(new Period(test, dt, PeriodType.standard().withMillisRemoved()), result); } //----------------------------------------------------------------------- public void testToIntervalFrom() { long length = (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; Duration test = new Duration(length); DateTime dt = new DateTime(2004, 6, 9, 0, 0, 0, 0); Interval result = test.toIntervalFrom(dt); assertEquals(new Interval(dt, test), result); } //----------------------------------------------------------------------- public void testToIntervalTo() { long length = (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; Duration test = new Duration(length); DateTime dt = new DateTime(2004, 6, 9, 0, 0, 0, 0); Interval result = test.toIntervalTo(dt); assertEquals(new Interval(test, dt), result); } //----------------------------------------------------------------------- public void testWithMillis1() { Duration test = new Duration(123L); Duration result = test.withMillis(123L); assertSame(test, result); } public void testWithMillis2() { Duration test = new Duration(123L); Duration result = test.withMillis(1234567890L); assertEquals(1234567890L, result.getMillis()); } //----------------------------------------------------------------------- public void testWithDurationAdded_long_int1() { Duration test = new Duration(123L); Duration result = test.withDurationAdded(8000L, 1); assertEquals(8123L, result.getMillis()); } public void testWithDurationAdded_long_int2() { Duration test = new Duration(123L); Duration result = test.withDurationAdded(8000L, 2); assertEquals(16123L, result.getMillis()); } public void testWithDurationAdded_long_int3() { Duration test = new Duration(123L); Duration result = test.withDurationAdded(8000L, -1); assertEquals((123L - 8000L), result.getMillis()); } public void testWithDurationAdded_long_int4() { Duration test = new Duration(123L); Duration result = test.withDurationAdded(0L, 1); assertSame(test, result); } public void testWithDurationAdded_long_int5() { Duration test = new Duration(123L); Duration result = test.withDurationAdded(8000L, 0); assertSame(test, result); } //----------------------------------------------------------------------- public void testPlus_long1() { Duration test = new Duration(123L); Duration result = test.plus(8000L); assertEquals(8123L, result.getMillis()); } public void testPlus_long2() { Duration test = new Duration(123L); Duration result = test.plus(0L); assertSame(test, result); } //----------------------------------------------------------------------- public void testMinus_long1() { Duration test = new Duration(123L); Duration result = test.minus(8000L); assertEquals(123L - 8000L, result.getMillis()); } public void testMinus_long2() { Duration test = new Duration(123L); Duration result = test.minus(0L); assertSame(test, result); } //----------------------------------------------------------------------- public void testMultipliedBy_long1() { Duration test = new Duration(123L); Duration result = test.multipliedBy(2L); assertEquals(246L, result.getMillis()); } public void testMultipliedBy_long2() { Duration test = new Duration(123L); Duration result = test.multipliedBy(1L); assertSame(test, result); } //----------------------------------------------------------------------- public void testDividedBy_long1() { Duration test = new Duration(246L); Duration result = test.dividedBy(2L); assertEquals(123L, result.getMillis()); } public void testDividedBy_long2() { Duration test = new Duration(123L); Duration result = test.dividedBy(1L); assertSame(test, result); } //----------------------------------------------------------------------- public void testNegated_long1() { Duration test = new Duration(246L); Duration result = test.negated(); assertEquals(-246L, result.getMillis()); } public void testNegated_long2() { Duration test = new Duration(-246L); Duration result = test.negated(); assertEquals(246L, result.getMillis()); } public void testNegated_long3() { Duration test = new Duration(Long.MIN_VALUE); try { test.negated(); fail(); } catch(ArithmeticException e) { // expected } } //----------------------------------------------------------------------- public void testWithDurationAdded_RD_int1() { Duration test = new Duration(123L); Duration result = test.withDurationAdded(new Duration(8000L), 1); assertEquals(8123L, result.getMillis()); } public void testWithDurationAdded_RD_int2() { Duration test = new Duration(123L); Duration result = test.withDurationAdded(new Duration(8000L), 2); assertEquals(16123L, result.getMillis()); } public void testWithDurationAdded_RD_int3() { Duration test = new Duration(123L); Duration result = test.withDurationAdded(new Duration(8000L), -1); assertEquals((123L - 8000L), result.getMillis()); } public void testWithDurationAdded_RD_int4() { Duration test = new Duration(123L); Duration result = test.withDurationAdded(new Duration(0L), 1); assertSame(test, result); } public void testWithDurationAdded_RD_int5() { Duration test = new Duration(123L); Duration result = test.withDurationAdded(new Duration(8000L), 0); assertSame(test, result); } public void testWithDurationAdded_RD_int6() { Duration test = new Duration(123L); Duration result = test.withDurationAdded(null, 0); assertSame(test, result); } //----------------------------------------------------------------------- public void testPlus_RD1() { Duration test = new Duration(123L); Duration result = test.plus(new Duration(8000L)); assertEquals(8123L, result.getMillis()); } public void testPlus_RD2() { Duration test = new Duration(123L); Duration result = test.plus(new Duration(0L)); assertSame(test, result); } public void testPlus_RD3() { Duration test = new Duration(123L); Duration result = test.plus(null); assertSame(test, result); } //----------------------------------------------------------------------- public void testMinus_RD1() { Duration test = new Duration(123L); Duration result = test.minus(new Duration(8000L)); assertEquals(123L - 8000L, result.getMillis()); } public void testMinus_RD2() { Duration test = new Duration(123L); Duration result = test.minus(new Duration(0L)); assertSame(test, result); } public void testMinus_RD3() { Duration test = new Duration(123L); Duration result = test.minus(null); assertSame(test, result); } //----------------------------------------------------------------------- public void testMutableDuration() { // no MutableDuration, so... MockMutableDuration test = new MockMutableDuration(123L); assertEquals(123L, test.getMillis()); test.setMillis(2345L); assertEquals(2345L, test.getMillis()); } static class MockMutableDuration extends BaseDuration { public MockMutableDuration(long duration) { super(duration); } public void setMillis(long duration) { super.setMillis(duration); } } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; /** * This class is a JUnit test for Duration. * * @author Stephen Colebourne */ public class TestDuration_Constructors extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; // 2002-04-05 private long TEST_TIME1 = (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; // 2003-05-06 private long TEST_TIME2 = (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestDuration_Constructors.class); } public TestDuration_Constructors(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- /** * Test constructor () */ public void testZERO() throws Throwable { Duration test = Duration.ZERO; assertEquals(0, test.getMillis()); } //----------------------------------------------------------------------- public void testParse_noFormatter() throws Throwable { assertEquals(new Duration(3200), Duration.parse("PT3.2S")); assertEquals(new Duration(6000), Duration.parse("PT6S")); } //----------------------------------------------------------------------- public void testFactory_standardDays_long() throws Throwable { Duration test = Duration.standardDays(1); assertEquals(24L * 60L * 60L * 1000L, test.getMillis()); test = Duration.standardDays(2); assertEquals(2L * 24L * 60L * 60L * 1000L, test.getMillis()); test = Duration.standardDays(0); assertSame(Duration.ZERO, test); } //----------------------------------------------------------------------- public void testFactory_standardHours_long() throws Throwable { Duration test = Duration.standardHours(1); assertEquals(60L * 60L * 1000L, test.getMillis()); test = Duration.standardHours(2); assertEquals(2L * 60L * 60L * 1000L, test.getMillis()); test = Duration.standardHours(0); assertSame(Duration.ZERO, test); } //----------------------------------------------------------------------- public void testFactory_standardMinutes_long() throws Throwable { Duration test = Duration.standardMinutes(1); assertEquals(60L * 1000L, test.getMillis()); test = Duration.standardMinutes(2); assertEquals(2L * 60L * 1000L, test.getMillis()); test = Duration.standardMinutes(0); assertSame(Duration.ZERO, test); } //----------------------------------------------------------------------- public void testFactory_standardSeconds_long() throws Throwable { Duration test = Duration.standardSeconds(1); assertEquals(1000L, test.getMillis()); test = Duration.standardSeconds(2); assertEquals(2L * 1000L, test.getMillis()); test = Duration.standardSeconds(0); assertSame(Duration.ZERO, test); } //----------------------------------------------------------------------- public void testFactory_millis_long() throws Throwable { Duration test = Duration.millis(1); assertEquals(1L, test.getMillis()); test = Duration.millis(2); assertEquals(2L, test.getMillis()); test = Duration.millis(0); assertSame(Duration.ZERO, test); } //----------------------------------------------------------------------- public void testConstructor_long1() throws Throwable { long length = 4 * DateTimeConstants.MILLIS_PER_DAY + 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8; Duration test = new Duration(length); assertEquals(length, test.getMillis()); } //----------------------------------------------------------------------- public void testConstructor_long_long1() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); Duration test = new Duration(dt1.getMillis(), dt2.getMillis()); assertEquals(dt2.getMillis() - dt1.getMillis(), test.getMillis()); } //----------------------------------------------------------------------- public void testConstructor_RI_RI1() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); Duration test = new Duration(dt1, dt2); assertEquals(dt2.getMillis() - dt1.getMillis(), test.getMillis()); } public void testConstructor_RI_RI2() throws Throwable { DateTime dt1 = null; // 2002-06-09T01:00+01:00 DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1); Duration test = new Duration(dt1, dt2); assertEquals(dt2.getMillis() - TEST_TIME_NOW, test.getMillis()); } public void testConstructor_RI_RI3() throws Throwable { DateTime dt1 = new DateTime(2005, 7, 17, 1, 1, 1, 1); DateTime dt2 = null; // 2002-06-09T01:00+01:00 Duration test = new Duration(dt1, dt2); assertEquals(TEST_TIME_NOW - dt1.getMillis(), test.getMillis()); } public void testConstructor_RI_RI4() throws Throwable { DateTime dt1 = null; // 2002-06-09T01:00+01:00 DateTime dt2 = null; // 2002-06-09T01:00+01:00 Duration test = new Duration(dt1, dt2); assertEquals(0L, test.getMillis()); } //----------------------------------------------------------------------- /** * Test constructor (Object) */ public void testConstructor_Object1() throws Throwable { Duration test = new Duration("PT72.345S"); assertEquals(72345, test.getMillis()); } public void testConstructor_Object2() throws Throwable { Duration test = new Duration((Object) null); assertEquals(0L, test.getMillis()); } public void testConstructor_Object3() throws Throwable { long length = 4 * DateTimeConstants.MILLIS_PER_DAY + 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8; Long base = new Long(length); Duration test = new Duration(base); assertEquals(length, test.getMillis()); } public void testConstructor_Object4() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); Duration base = new Duration(dt1, dt2); Duration test = new Duration(base); assertEquals(dt2.getMillis() - dt1.getMillis(), test.getMillis()); } public void testConstructor_Object5() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); Interval base = new Interval(dt1, dt2); Duration test = new Duration(base); assertEquals(dt2.getMillis() - dt1.getMillis(), test.getMillis()); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import junit.framework.TestCase; import junit.framework.TestSuite; /** * This class is a Junit unit test for Hours. * * @author Stephen Colebourne */ public class TestHours extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestHours.class); } public TestHours(String name) { super(name); } protected void setUp() throws Exception { } protected void tearDown() throws Exception { } //----------------------------------------------------------------------- public void testConstants() { assertEquals(0, Hours.ZERO.getHours()); assertEquals(1, Hours.ONE.getHours()); assertEquals(2, Hours.TWO.getHours()); assertEquals(3, Hours.THREE.getHours()); assertEquals(4, Hours.FOUR.getHours()); assertEquals(5, Hours.FIVE.getHours()); assertEquals(6, Hours.SIX.getHours()); assertEquals(7, Hours.SEVEN.getHours()); assertEquals(8, Hours.EIGHT.getHours()); assertEquals(Integer.MAX_VALUE, Hours.MAX_VALUE.getHours()); assertEquals(Integer.MIN_VALUE, Hours.MIN_VALUE.getHours()); } //----------------------------------------------------------------------- public void testFactory_hours_int() { assertSame(Hours.ZERO, Hours.hours(0)); assertSame(Hours.ONE, Hours.hours(1)); assertSame(Hours.TWO, Hours.hours(2)); assertSame(Hours.THREE, Hours.hours(3)); assertSame(Hours.FOUR, Hours.hours(4)); assertSame(Hours.FIVE, Hours.hours(5)); assertSame(Hours.SIX, Hours.hours(6)); assertSame(Hours.SEVEN, Hours.hours(7)); assertSame(Hours.EIGHT, Hours.hours(8)); assertSame(Hours.MAX_VALUE, Hours.hours(Integer.MAX_VALUE)); assertSame(Hours.MIN_VALUE, Hours.hours(Integer.MIN_VALUE)); assertEquals(-1, Hours.hours(-1).getHours()); assertEquals(9, Hours.hours(9).getHours()); } //----------------------------------------------------------------------- public void testFactory_hoursBetween_RInstant() { DateTime start = new DateTime(2006, 6, 9, 12, 0, 0, 0, PARIS); DateTime end1 = new DateTime(2006, 6, 9, 15, 0, 0, 0, PARIS); DateTime end2 = new DateTime(2006, 6, 9, 18, 0, 0, 0, PARIS); assertEquals(3, Hours.hoursBetween(start, end1).getHours()); assertEquals(0, Hours.hoursBetween(start, start).getHours()); assertEquals(0, Hours.hoursBetween(end1, end1).getHours()); assertEquals(-3, Hours.hoursBetween(end1, start).getHours()); assertEquals(6, Hours.hoursBetween(start, end2).getHours()); } public void testFactory_hoursBetween_RPartial() { LocalTime start = new LocalTime(12, 0); LocalTime end1 = new LocalTime(15, 0); @SuppressWarnings("deprecation") TimeOfDay end2 = new TimeOfDay(18, 0); assertEquals(3, Hours.hoursBetween(start, end1).getHours()); assertEquals(0, Hours.hoursBetween(start, start).getHours()); assertEquals(0, Hours.hoursBetween(end1, end1).getHours()); assertEquals(-3, Hours.hoursBetween(end1, start).getHours()); assertEquals(6, Hours.hoursBetween(start, end2).getHours()); } public void testFactory_hoursIn_RInterval() { DateTime start = new DateTime(2006, 6, 9, 12, 0, 0, 0, PARIS); DateTime end1 = new DateTime(2006, 6, 9, 15, 0, 0, 0, PARIS); DateTime end2 = new DateTime(2006, 6, 9, 18, 0, 0, 0, PARIS); assertEquals(0, Hours.hoursIn((ReadableInterval) null).getHours()); assertEquals(3, Hours.hoursIn(new Interval(start, end1)).getHours()); assertEquals(0, Hours.hoursIn(new Interval(start, start)).getHours()); assertEquals(0, Hours.hoursIn(new Interval(end1, end1)).getHours()); assertEquals(6, Hours.hoursIn(new Interval(start, end2)).getHours()); } public void testFactory_standardHoursIn_RPeriod() { assertEquals(0, Hours.standardHoursIn((ReadablePeriod) null).getHours()); assertEquals(0, Hours.standardHoursIn(Period.ZERO).getHours()); assertEquals(1, Hours.standardHoursIn(new Period(0, 0, 0, 0, 1, 0, 0, 0)).getHours()); assertEquals(123, Hours.standardHoursIn(Period.hours(123)).getHours()); assertEquals(-987, Hours.standardHoursIn(Period.hours(-987)).getHours()); assertEquals(1, Hours.standardHoursIn(Period.minutes(119)).getHours()); assertEquals(2, Hours.standardHoursIn(Period.minutes(120)).getHours()); assertEquals(2, Hours.standardHoursIn(Period.minutes(121)).getHours()); assertEquals(48, Hours.standardHoursIn(Period.days(2)).getHours()); try { Hours.standardHoursIn(Period.months(1)); fail(); } catch (IllegalArgumentException ex) { // expeceted } } public void testFactory_parseHours_String() { assertEquals(0, Hours.parseHours((String) null).getHours()); assertEquals(0, Hours.parseHours("PT0H").getHours()); assertEquals(1, Hours.parseHours("PT1H").getHours()); assertEquals(-3, Hours.parseHours("PT-3H").getHours()); assertEquals(2, Hours.parseHours("P0Y0M0DT2H").getHours()); assertEquals(2, Hours.parseHours("PT2H0M").getHours()); try { Hours.parseHours("P1Y1D"); fail(); } catch (IllegalArgumentException ex) { // expeceted } try { Hours.parseHours("P1DT1H"); fail(); } catch (IllegalArgumentException ex) { // expeceted } } //----------------------------------------------------------------------- public void testGetMethods() { Hours test = Hours.hours(20); assertEquals(20, test.getHours()); } public void testGetFieldType() { Hours test = Hours.hours(20); assertEquals(DurationFieldType.hours(), test.getFieldType()); } public void testGetPeriodType() { Hours test = Hours.hours(20); assertEquals(PeriodType.hours(), test.getPeriodType()); } //----------------------------------------------------------------------- public void testIsGreaterThan() { assertEquals(true, Hours.THREE.isGreaterThan(Hours.TWO)); assertEquals(false, Hours.THREE.isGreaterThan(Hours.THREE)); assertEquals(false, Hours.TWO.isGreaterThan(Hours.THREE)); assertEquals(true, Hours.ONE.isGreaterThan(null)); assertEquals(false, Hours.hours(-1).isGreaterThan(null)); } public void testIsLessThan() { assertEquals(false, Hours.THREE.isLessThan(Hours.TWO)); assertEquals(false, Hours.THREE.isLessThan(Hours.THREE)); assertEquals(true, Hours.TWO.isLessThan(Hours.THREE)); assertEquals(false, Hours.ONE.isLessThan(null)); assertEquals(true, Hours.hours(-1).isLessThan(null)); } //----------------------------------------------------------------------- public void testToString() { Hours test = Hours.hours(20); assertEquals("PT20H", test.toString()); test = Hours.hours(-20); assertEquals("PT-20H", test.toString()); } //----------------------------------------------------------------------- public void testSerialization() throws Exception { Hours test = Hours.SEVEN; ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(test); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); Hours result = (Hours) ois.readObject(); ois.close(); assertSame(test, result); } //----------------------------------------------------------------------- public void testToStandardWeeks() { Hours test = Hours.hours(24 * 7 * 2); Weeks expected = Weeks.weeks(2); assertEquals(expected, test.toStandardWeeks()); } public void testToStandardDays() { Hours test = Hours.hours(24 * 2); Days expected = Days.days(2); assertEquals(expected, test.toStandardDays()); } public void testToStandardMinutes() { Hours test = Hours.hours(3); Minutes expected = Minutes.minutes(3 * 60); assertEquals(expected, test.toStandardMinutes()); try { Hours.MAX_VALUE.toStandardMinutes(); fail(); } catch (ArithmeticException ex) { // expected } } public void testToStandardSeconds() { Hours test = Hours.hours(3); Seconds expected = Seconds.seconds(3 * 60 * 60); assertEquals(expected, test.toStandardSeconds()); try { Hours.MAX_VALUE.toStandardSeconds(); fail(); } catch (ArithmeticException ex) { // expected } } public void testToStandardDuration() { Hours test = Hours.hours(20); Duration expected = new Duration(20L * DateTimeConstants.MILLIS_PER_HOUR); assertEquals(expected, test.toStandardDuration()); expected = new Duration(((long) Integer.MAX_VALUE) * DateTimeConstants.MILLIS_PER_HOUR); assertEquals(expected, Hours.MAX_VALUE.toStandardDuration()); } //----------------------------------------------------------------------- public void testPlus_int() { Hours test2 = Hours.hours(2); Hours result = test2.plus(3); assertEquals(2, test2.getHours()); assertEquals(5, result.getHours()); assertEquals(1, Hours.ONE.plus(0).getHours()); try { Hours.MAX_VALUE.plus(1); fail(); } catch (ArithmeticException ex) { // expected } } public void testPlus_Hours() { Hours test2 = Hours.hours(2); Hours test3 = Hours.hours(3); Hours result = test2.plus(test3); assertEquals(2, test2.getHours()); assertEquals(3, test3.getHours()); assertEquals(5, result.getHours()); assertEquals(1, Hours.ONE.plus(Hours.ZERO).getHours()); assertEquals(1, Hours.ONE.plus((Hours) null).getHours()); try { Hours.MAX_VALUE.plus(Hours.ONE); fail(); } catch (ArithmeticException ex) { // expected } } public void testMinus_int() { Hours test2 = Hours.hours(2); Hours result = test2.minus(3); assertEquals(2, test2.getHours()); assertEquals(-1, result.getHours()); assertEquals(1, Hours.ONE.minus(0).getHours()); try { Hours.MIN_VALUE.minus(1); fail(); } catch (ArithmeticException ex) { // expected } } public void testMinus_Hours() { Hours test2 = Hours.hours(2); Hours test3 = Hours.hours(3); Hours result = test2.minus(test3); assertEquals(2, test2.getHours()); assertEquals(3, test3.getHours()); assertEquals(-1, result.getHours()); assertEquals(1, Hours.ONE.minus(Hours.ZERO).getHours()); assertEquals(1, Hours.ONE.minus((Hours) null).getHours()); try { Hours.MIN_VALUE.minus(Hours.ONE); fail(); } catch (ArithmeticException ex) { // expected } } public void testMultipliedBy_int() { Hours test = Hours.hours(2); assertEquals(6, test.multipliedBy(3).getHours()); assertEquals(2, test.getHours()); assertEquals(-6, test.multipliedBy(-3).getHours()); assertSame(test, test.multipliedBy(1)); Hours halfMax = Hours.hours(Integer.MAX_VALUE / 2 + 1); try { halfMax.multipliedBy(2); fail(); } catch (ArithmeticException ex) { // expected } } public void testDividedBy_int() { Hours test = Hours.hours(12); assertEquals(6, test.dividedBy(2).getHours()); assertEquals(12, test.getHours()); assertEquals(4, test.dividedBy(3).getHours()); assertEquals(3, test.dividedBy(4).getHours()); assertEquals(2, test.dividedBy(5).getHours()); assertEquals(2, test.dividedBy(6).getHours()); assertSame(test, test.dividedBy(1)); try { Hours.ONE.dividedBy(0); fail(); } catch (ArithmeticException ex) { // expected } } public void testNegated() { Hours test = Hours.hours(12); assertEquals(-12, test.negated().getHours()); assertEquals(12, test.getHours()); try { Hours.MIN_VALUE.negated(); fail(); } catch (ArithmeticException ex) { // expected } } //----------------------------------------------------------------------- public void testAddToLocalDate() { Hours test = Hours.hours(26); LocalDateTime date = new LocalDateTime(2006, 6, 1, 0, 0, 0, 0); LocalDateTime expected = new LocalDateTime(2006, 6, 2, 2, 0, 0, 0); assertEquals(expected, date.plus(test)); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.GJChronology; import org.joda.time.chrono.ISOChronology; import org.joda.time.chrono.JulianChronology; import org.joda.time.field.FieldUtils; import org.joda.time.field.SkipDateTimeField; /** * Tests IllegalFieldValueException by triggering it from other methods. * * @author Brian S O'Neill */ public class TestIllegalFieldValueException extends TestCase { public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestIllegalFieldValueException.class); } public TestIllegalFieldValueException(String name) { super(name); } public void testVerifyValueBounds() { try { FieldUtils.verifyValueBounds(ISOChronology.getInstance().monthOfYear(), -5, 1, 31); fail(); } catch (IllegalFieldValueException e) { assertEquals(DateTimeFieldType.monthOfYear(), e.getDateTimeFieldType()); assertEquals(null, e.getDurationFieldType()); assertEquals("monthOfYear", e.getFieldName()); assertEquals(new Integer(-5), e.getIllegalNumberValue()); assertEquals(null, e.getIllegalStringValue()); assertEquals("-5", e.getIllegalValueAsString()); assertEquals(new Integer(1), e.getLowerBound()); assertEquals(new Integer(31), e.getUpperBound()); } try { FieldUtils.verifyValueBounds(DateTimeFieldType.hourOfDay(), 27, 0, 23); fail(); } catch (IllegalFieldValueException e) { assertEquals(DateTimeFieldType.hourOfDay(), e.getDateTimeFieldType()); assertEquals(null, e.getDurationFieldType()); assertEquals("hourOfDay", e.getFieldName()); assertEquals(new Integer(27), e.getIllegalNumberValue()); assertEquals(null, e.getIllegalStringValue()); assertEquals("27", e.getIllegalValueAsString()); assertEquals(new Integer(0), e.getLowerBound()); assertEquals(new Integer(23), e.getUpperBound()); } try { FieldUtils.verifyValueBounds("foo", 1, 2, 3); fail(); } catch (IllegalFieldValueException e) { assertEquals(null, e.getDateTimeFieldType()); assertEquals(null, e.getDurationFieldType()); assertEquals("foo", e.getFieldName()); assertEquals(new Integer(1), e.getIllegalNumberValue()); assertEquals(null, e.getIllegalStringValue()); assertEquals("1", e.getIllegalValueAsString()); assertEquals(new Integer(2), e.getLowerBound()); assertEquals(new Integer(3), e.getUpperBound()); } } public void testSkipDateTimeField() { DateTimeField field = new SkipDateTimeField (ISOChronology.getInstanceUTC(), ISOChronology.getInstanceUTC().year(), 1970); try { field.set(0, 1970); fail(); } catch (IllegalFieldValueException e) { assertEquals(DateTimeFieldType.year(), e.getDateTimeFieldType()); assertEquals(null, e.getDurationFieldType()); assertEquals("year", e.getFieldName()); assertEquals(new Integer(1970), e.getIllegalNumberValue()); assertEquals(null, e.getIllegalStringValue()); assertEquals("1970", e.getIllegalValueAsString()); assertEquals(null, e.getLowerBound()); assertEquals(null, e.getUpperBound()); } } public void testSetText() { try { ISOChronology.getInstanceUTC().year().set(0, null, java.util.Locale.US); fail(); } catch (IllegalFieldValueException e) { assertEquals(DateTimeFieldType.year(), e.getDateTimeFieldType()); assertEquals(null, e.getDurationFieldType()); assertEquals("year", e.getFieldName()); assertEquals(null, e.getIllegalNumberValue()); assertEquals(null, e.getIllegalStringValue()); assertEquals("null", e.getIllegalValueAsString()); assertEquals(null, e.getLowerBound()); assertEquals(null, e.getUpperBound()); } try { ISOChronology.getInstanceUTC().year().set(0, "nineteen seventy", java.util.Locale.US); fail(); } catch (IllegalFieldValueException e) { assertEquals(DateTimeFieldType.year(), e.getDateTimeFieldType()); assertEquals(null, e.getDurationFieldType()); assertEquals("year", e.getFieldName()); assertEquals(null, e.getIllegalNumberValue()); assertEquals("nineteen seventy", e.getIllegalStringValue()); assertEquals("nineteen seventy", e.getIllegalValueAsString()); assertEquals(null, e.getLowerBound()); assertEquals(null, e.getUpperBound()); } try { ISOChronology.getInstanceUTC().era().set(0, "long ago", java.util.Locale.US); fail(); } catch (IllegalFieldValueException e) { assertEquals(DateTimeFieldType.era(), e.getDateTimeFieldType()); assertEquals(null, e.getDurationFieldType()); assertEquals("era", e.getFieldName()); assertEquals(null, e.getIllegalNumberValue()); assertEquals("long ago", e.getIllegalStringValue()); assertEquals("long ago", e.getIllegalValueAsString()); assertEquals(null, e.getLowerBound()); assertEquals(null, e.getUpperBound()); } try { ISOChronology.getInstanceUTC().monthOfYear().set(0, "spring", java.util.Locale.US); fail(); } catch (IllegalFieldValueException e) { assertEquals(DateTimeFieldType.monthOfYear(), e.getDateTimeFieldType()); assertEquals(null, e.getDurationFieldType()); assertEquals("monthOfYear", e.getFieldName()); assertEquals(null, e.getIllegalNumberValue()); assertEquals("spring", e.getIllegalStringValue()); assertEquals("spring", e.getIllegalValueAsString()); assertEquals(null, e.getLowerBound()); assertEquals(null, e.getUpperBound()); } try { ISOChronology.getInstanceUTC().dayOfWeek().set(0, "yesterday", java.util.Locale.US); fail(); } catch (IllegalFieldValueException e) { assertEquals(DateTimeFieldType.dayOfWeek(), e.getDateTimeFieldType()); assertEquals(null, e.getDurationFieldType()); assertEquals("dayOfWeek", e.getFieldName()); assertEquals(null, e.getIllegalNumberValue()); assertEquals("yesterday", e.getIllegalStringValue()); assertEquals("yesterday", e.getIllegalValueAsString()); assertEquals(null, e.getLowerBound()); assertEquals(null, e.getUpperBound()); } try { ISOChronology.getInstanceUTC().halfdayOfDay().set(0, "morning", java.util.Locale.US); fail(); } catch (IllegalFieldValueException e) { assertEquals(DateTimeFieldType.halfdayOfDay(), e.getDateTimeFieldType()); assertEquals(null, e.getDurationFieldType()); assertEquals("halfdayOfDay", e.getFieldName()); assertEquals(null, e.getIllegalNumberValue()); assertEquals("morning", e.getIllegalStringValue()); assertEquals("morning", e.getIllegalValueAsString()); assertEquals(null, e.getLowerBound()); assertEquals(null, e.getUpperBound()); } } public void testZoneTransition() { DateTime dt = new DateTime (2005, 4, 3, 1, 0, 0, 0, DateTimeZone.forID("America/Los_Angeles")); try { dt.hourOfDay().setCopy(2); fail(); } catch (IllegalFieldValueException e) { assertEquals(DateTimeFieldType.hourOfDay(), e.getDateTimeFieldType()); assertEquals(null, e.getDurationFieldType()); assertEquals("hourOfDay", e.getFieldName()); assertEquals(new Integer(2), e.getIllegalNumberValue()); assertEquals(null, e.getIllegalStringValue()); assertEquals("2", e.getIllegalValueAsString()); assertEquals(null, e.getLowerBound()); assertEquals(null, e.getUpperBound()); } } public void testJulianYearZero() { DateTime dt = new DateTime(JulianChronology.getInstanceUTC()); try { dt.year().setCopy(0); fail(); } catch (IllegalFieldValueException e) { assertEquals(DateTimeFieldType.year(), e.getDateTimeFieldType()); assertEquals(null, e.getDurationFieldType()); assertEquals("year", e.getFieldName()); assertEquals(new Integer(0), e.getIllegalNumberValue()); assertEquals(null, e.getIllegalStringValue()); assertEquals("0", e.getIllegalValueAsString()); assertEquals(null, e.getLowerBound()); assertEquals(null, e.getUpperBound()); } } public void testGJCutover() { DateTime dt = new DateTime("1582-10-04", GJChronology.getInstanceUTC()); try { dt.dayOfMonth().setCopy(5); fail(); } catch (IllegalFieldValueException e) { assertEquals(DateTimeFieldType.dayOfMonth(), e.getDateTimeFieldType()); assertEquals(null, e.getDurationFieldType()); assertEquals("dayOfMonth", e.getFieldName()); assertEquals(new Integer(5), e.getIllegalNumberValue()); assertEquals(null, e.getIllegalStringValue()); assertEquals("5", e.getIllegalValueAsString()); assertEquals(null, e.getLowerBound()); assertEquals(null, e.getUpperBound()); } dt = new DateTime("1582-10-15", GJChronology.getInstanceUTC()); try { dt.dayOfMonth().setCopy(14); fail(); } catch (IllegalFieldValueException e) { assertEquals(DateTimeFieldType.dayOfMonth(), e.getDateTimeFieldType()); assertEquals(null, e.getDurationFieldType()); assertEquals("dayOfMonth", e.getFieldName()); assertEquals(new Integer(14), e.getIllegalNumberValue()); assertEquals(null, e.getIllegalStringValue()); assertEquals("14", e.getIllegalValueAsString()); assertEquals(null, e.getLowerBound()); assertEquals(null, e.getUpperBound()); } } @SuppressWarnings("deprecation") public void testReadablePartialValidate() { try { new YearMonthDay(1970, -5, 1); fail(); } catch (IllegalFieldValueException e) { assertEquals(DateTimeFieldType.monthOfYear(), e.getDateTimeFieldType()); assertEquals(null, e.getDurationFieldType()); assertEquals("monthOfYear", e.getFieldName()); assertEquals(new Integer(-5), e.getIllegalNumberValue()); assertEquals(null, e.getIllegalStringValue()); assertEquals("-5", e.getIllegalValueAsString()); assertEquals(new Integer(1), e.getLowerBound()); assertEquals(null, e.getUpperBound()); } try { new YearMonthDay(1970, 500, 1); fail(); } catch (IllegalFieldValueException e) { assertEquals(DateTimeFieldType.monthOfYear(), e.getDateTimeFieldType()); assertEquals(null, e.getDurationFieldType()); assertEquals("monthOfYear", e.getFieldName()); assertEquals(new Integer(500), e.getIllegalNumberValue()); assertEquals(null, e.getIllegalStringValue()); assertEquals("500", e.getIllegalValueAsString()); assertEquals(null, e.getLowerBound()); assertEquals(new Integer(12), e.getUpperBound()); } try { new YearMonthDay(1970, 2, 30); fail(); } catch (IllegalFieldValueException e) { assertEquals(DateTimeFieldType.dayOfMonth(), e.getDateTimeFieldType()); assertEquals(null, e.getDurationFieldType()); assertEquals("dayOfMonth", e.getFieldName()); assertEquals(new Integer(30), e.getIllegalNumberValue()); assertEquals(null, e.getIllegalStringValue()); assertEquals("30", e.getIllegalValueAsString()); assertEquals(null, e.getLowerBound()); assertEquals(new Integer(28), e.getUpperBound()); } } // Test extra constructors not currently called by anything public void testOtherConstructors() { IllegalFieldValueException e = new IllegalFieldValueException (DurationFieldType.days(), new Integer(1), new Integer(2), new Integer(3)); assertEquals(null, e.getDateTimeFieldType()); assertEquals(DurationFieldType.days(), e.getDurationFieldType()); assertEquals("days", e.getFieldName()); assertEquals(new Integer(1), e.getIllegalNumberValue()); assertEquals(null, e.getIllegalStringValue()); assertEquals("1", e.getIllegalValueAsString()); assertEquals(new Integer(2), e.getLowerBound()); assertEquals(new Integer(3), e.getUpperBound()); e = new IllegalFieldValueException(DurationFieldType.months(), "five"); assertEquals(null, e.getDateTimeFieldType()); assertEquals(DurationFieldType.months(), e.getDurationFieldType()); assertEquals("months", e.getFieldName()); assertEquals(null, e.getIllegalNumberValue()); assertEquals("five", e.getIllegalStringValue()); assertEquals("five", e.getIllegalValueAsString()); assertEquals(null, e.getLowerBound()); assertEquals(null, e.getUpperBound()); e = new IllegalFieldValueException("months", "five"); assertEquals(null, e.getDateTimeFieldType()); assertEquals(null, e.getDurationFieldType()); assertEquals("months", e.getFieldName()); assertEquals(null, e.getIllegalNumberValue()); assertEquals("five", e.getIllegalStringValue()); assertEquals("five", e.getIllegalValueAsString()); assertEquals(null, e.getLowerBound()); assertEquals(null, e.getUpperBound()); } }
/* * Copyright 2001-2009 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Modifier; import java.util.Date; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.base.AbstractInstant; import org.joda.time.chrono.GregorianChronology; import org.joda.time.chrono.ISOChronology; /** * This class is a Junit unit test for Instant. * * @author Stephen Colebourne */ public class TestInstant_Basics extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; // 2002-04-05 private long TEST_TIME1 = (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; // 2003-05-06 private long TEST_TIME2 = (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestInstant_Basics.class); } public TestInstant_Basics(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testTest() { assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString()); assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString()); assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString()); } //----------------------------------------------------------------------- public void testGet_DateTimeFieldType() { Instant test = new Instant(); // 2002-06-09 assertEquals(1, test.get(DateTimeFieldType.era())); assertEquals(20, test.get(DateTimeFieldType.centuryOfEra())); assertEquals(2, test.get(DateTimeFieldType.yearOfCentury())); assertEquals(2002, test.get(DateTimeFieldType.yearOfEra())); assertEquals(2002, test.get(DateTimeFieldType.year())); assertEquals(6, test.get(DateTimeFieldType.monthOfYear())); assertEquals(9, test.get(DateTimeFieldType.dayOfMonth())); assertEquals(2002, test.get(DateTimeFieldType.weekyear())); assertEquals(23, test.get(DateTimeFieldType.weekOfWeekyear())); assertEquals(7, test.get(DateTimeFieldType.dayOfWeek())); assertEquals(160, test.get(DateTimeFieldType.dayOfYear())); assertEquals(0, test.get(DateTimeFieldType.halfdayOfDay())); assertEquals(0, test.get(DateTimeFieldType.hourOfHalfday())); // UTC zone assertEquals(24, test.get(DateTimeFieldType.clockhourOfDay())); // UTC zone assertEquals(12, test.get(DateTimeFieldType.clockhourOfHalfday())); // UTC zone assertEquals(0, test.get(DateTimeFieldType.hourOfDay())); // UTC zone assertEquals(0, test.get(DateTimeFieldType.minuteOfHour())); assertEquals(0, test.get(DateTimeFieldType.minuteOfDay())); assertEquals(0, test.get(DateTimeFieldType.secondOfMinute())); assertEquals(0, test.get(DateTimeFieldType.secondOfDay())); assertEquals(0, test.get(DateTimeFieldType.millisOfSecond())); assertEquals(0, test.get(DateTimeFieldType.millisOfDay())); try { test.get((DateTimeFieldType) null); fail(); } catch (IllegalArgumentException ex) {} } public void testGet_DateTimeField() { Instant test = new Instant(); // 2002-06-09 assertEquals(1, test.get(ISOChronology.getInstance().era())); assertEquals(20, test.get(ISOChronology.getInstance().centuryOfEra())); assertEquals(2, test.get(ISOChronology.getInstance().yearOfCentury())); assertEquals(2002, test.get(ISOChronology.getInstance().yearOfEra())); assertEquals(2002, test.get(ISOChronology.getInstance().year())); assertEquals(6, test.get(ISOChronology.getInstance().monthOfYear())); assertEquals(9, test.get(ISOChronology.getInstance().dayOfMonth())); assertEquals(2002, test.get(ISOChronology.getInstance().weekyear())); assertEquals(23, test.get(ISOChronology.getInstance().weekOfWeekyear())); assertEquals(7, test.get(ISOChronology.getInstance().dayOfWeek())); assertEquals(160, test.get(ISOChronology.getInstance().dayOfYear())); assertEquals(0, test.get(ISOChronology.getInstance().halfdayOfDay())); assertEquals(1, test.get(ISOChronology.getInstance().hourOfHalfday())); assertEquals(1, test.get(ISOChronology.getInstance().clockhourOfDay())); assertEquals(1, test.get(ISOChronology.getInstance().clockhourOfHalfday())); assertEquals(1, test.get(ISOChronology.getInstance().hourOfDay())); assertEquals(0, test.get(ISOChronology.getInstance().minuteOfHour())); assertEquals(60, test.get(ISOChronology.getInstance().minuteOfDay())); assertEquals(0, test.get(ISOChronology.getInstance().secondOfMinute())); assertEquals(60 * 60, test.get(ISOChronology.getInstance().secondOfDay())); assertEquals(0, test.get(ISOChronology.getInstance().millisOfSecond())); assertEquals(60 * 60 * 1000, test.get(ISOChronology.getInstance().millisOfDay())); try { test.get((DateTimeField) null); fail(); } catch (IllegalArgumentException ex) {} } public void testGetMethods() { Instant test = new Instant(); assertEquals(ISOChronology.getInstanceUTC(), test.getChronology()); assertEquals(DateTimeZone.UTC, test.getZone()); assertEquals(TEST_TIME_NOW, test.getMillis()); } public void testEqualsHashCode() { Instant test1 = new Instant(TEST_TIME1); Instant test2 = new Instant(TEST_TIME1); assertEquals(true, test1.equals(test2)); assertEquals(true, test2.equals(test1)); assertEquals(true, test1.equals(test1)); assertEquals(true, test2.equals(test2)); assertEquals(true, test1.hashCode() == test2.hashCode()); assertEquals(true, test1.hashCode() == test1.hashCode()); assertEquals(true, test2.hashCode() == test2.hashCode()); Instant test3 = new Instant(TEST_TIME2); assertEquals(false, test1.equals(test3)); assertEquals(false, test2.equals(test3)); assertEquals(false, test3.equals(test1)); assertEquals(false, test3.equals(test2)); assertEquals(false, test1.hashCode() == test3.hashCode()); assertEquals(false, test2.hashCode() == test3.hashCode()); assertEquals(false, test1.equals("Hello")); assertEquals(true, test1.equals(new MockInstant())); assertEquals(false, test1.equals(new DateTime(TEST_TIME1))); } class MockInstant extends AbstractInstant { public String toString() { return null; } public long getMillis() { return TEST_TIME1; } public Chronology getChronology() { return ISOChronology.getInstanceUTC(); } } public void testCompareTo() { Instant test1 = new Instant(TEST_TIME1); Instant test1a = new Instant(TEST_TIME1); assertEquals(0, test1.compareTo(test1a)); assertEquals(0, test1a.compareTo(test1)); assertEquals(0, test1.compareTo(test1)); assertEquals(0, test1a.compareTo(test1a)); Instant test2 = new Instant(TEST_TIME2); assertEquals(-1, test1.compareTo(test2)); assertEquals(+1, test2.compareTo(test1)); DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS)); assertEquals(-1, test1.compareTo(test3)); assertEquals(+1, test3.compareTo(test1)); assertEquals(0, test3.compareTo(test2)); assertEquals(+1, test2.compareTo(new MockInstant())); assertEquals(0, test1.compareTo(new MockInstant())); try { test1.compareTo(null); fail(); } catch (NullPointerException ex) {} // try { // test1.compareTo(new Date()); // fail(); // } catch (ClassCastException ex) {} } //----------------------------------------------------------------------- public void testIsEqual_long() { assertEquals(false, new Instant(TEST_TIME1).isEqual(TEST_TIME2)); assertEquals(true, new Instant(TEST_TIME1).isEqual(TEST_TIME1)); assertEquals(false, new Instant(TEST_TIME2).isEqual(TEST_TIME1)); } public void testIsEqualNow() { assertEquals(false, new Instant(TEST_TIME_NOW - 1).isEqualNow()); assertEquals(true, new Instant(TEST_TIME_NOW).isEqualNow()); assertEquals(false, new Instant(TEST_TIME_NOW + 1).isEqualNow()); } public void testIsEqual_RI() { Instant test1 = new Instant(TEST_TIME1); Instant test1a = new Instant(TEST_TIME1); assertEquals(true, test1.isEqual(test1a)); assertEquals(true, test1a.isEqual(test1)); assertEquals(true, test1.isEqual(test1)); assertEquals(true, test1a.isEqual(test1a)); Instant test2 = new Instant(TEST_TIME2); assertEquals(false, test1.isEqual(test2)); assertEquals(false, test2.isEqual(test1)); DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS)); assertEquals(false, test1.isEqual(test3)); assertEquals(false, test3.isEqual(test1)); assertEquals(true, test3.isEqual(test2)); assertEquals(false, test2.isEqual(new MockInstant())); assertEquals(true, test1.isEqual(new MockInstant())); assertEquals(false, new Instant(TEST_TIME_NOW + 1).isEqual(null)); assertEquals(true, new Instant(TEST_TIME_NOW).isEqual(null)); assertEquals(false, new Instant(TEST_TIME_NOW - 1).isEqual(null)); } //----------------------------------------------------------------------- public void testIsBefore_long() { assertEquals(true, new Instant(TEST_TIME1).isBefore(TEST_TIME2)); assertEquals(false, new Instant(TEST_TIME1).isBefore(TEST_TIME1)); assertEquals(false, new Instant(TEST_TIME2).isBefore(TEST_TIME1)); } public void testIsBeforeNow() { assertEquals(true, new Instant(TEST_TIME_NOW - 1).isBeforeNow()); assertEquals(false, new Instant(TEST_TIME_NOW).isBeforeNow()); assertEquals(false, new Instant(TEST_TIME_NOW + 1).isBeforeNow()); } public void testIsBefore_RI() { Instant test1 = new Instant(TEST_TIME1); Instant test1a = new Instant(TEST_TIME1); assertEquals(false, test1.isBefore(test1a)); assertEquals(false, test1a.isBefore(test1)); assertEquals(false, test1.isBefore(test1)); assertEquals(false, test1a.isBefore(test1a)); Instant test2 = new Instant(TEST_TIME2); assertEquals(true, test1.isBefore(test2)); assertEquals(false, test2.isBefore(test1)); DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS)); assertEquals(true, test1.isBefore(test3)); assertEquals(false, test3.isBefore(test1)); assertEquals(false, test3.isBefore(test2)); assertEquals(false, test2.isBefore(new MockInstant())); assertEquals(false, test1.isBefore(new MockInstant())); assertEquals(false, new Instant(TEST_TIME_NOW + 1).isBefore(null)); assertEquals(false, new Instant(TEST_TIME_NOW).isBefore(null)); assertEquals(true, new Instant(TEST_TIME_NOW - 1).isBefore(null)); } //----------------------------------------------------------------------- public void testIsAfter_long() { assertEquals(false, new Instant(TEST_TIME1).isAfter(TEST_TIME2)); assertEquals(false, new Instant(TEST_TIME1).isAfter(TEST_TIME1)); assertEquals(true, new Instant(TEST_TIME2).isAfter(TEST_TIME1)); } public void testIsAfterNow() { assertEquals(false, new Instant(TEST_TIME_NOW - 1).isAfterNow()); assertEquals(false, new Instant(TEST_TIME_NOW).isAfterNow()); assertEquals(true, new Instant(TEST_TIME_NOW + 1).isAfterNow()); } public void testIsAfter_RI() { Instant test1 = new Instant(TEST_TIME1); Instant test1a = new Instant(TEST_TIME1); assertEquals(false, test1.isAfter(test1a)); assertEquals(false, test1a.isAfter(test1)); assertEquals(false, test1.isAfter(test1)); assertEquals(false, test1a.isAfter(test1a)); Instant test2 = new Instant(TEST_TIME2); assertEquals(false, test1.isAfter(test2)); assertEquals(true, test2.isAfter(test1)); DateTime test3 = new DateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS)); assertEquals(false, test1.isAfter(test3)); assertEquals(true, test3.isAfter(test1)); assertEquals(false, test3.isAfter(test2)); assertEquals(true, test2.isAfter(new MockInstant())); assertEquals(false, test1.isAfter(new MockInstant())); assertEquals(true, new Instant(TEST_TIME_NOW + 1).isAfter(null)); assertEquals(false, new Instant(TEST_TIME_NOW).isAfter(null)); assertEquals(false, new Instant(TEST_TIME_NOW - 1).isAfter(null)); } //----------------------------------------------------------------------- public void testSerialization() throws Exception { Instant test = new Instant(TEST_TIME_NOW); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(test); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); Instant result = (Instant) ois.readObject(); ois.close(); assertEquals(test, result); } //----------------------------------------------------------------------- public void testToString() { Instant test = new Instant(TEST_TIME_NOW); assertEquals("2002-06-09T00:00:00.000Z", test.toString()); } //----------------------------------------------------------------------- public void testToInstant() { Instant test = new Instant(TEST_TIME1); Instant result = test.toInstant(); assertSame(test, result); } public void testToDateTime() { Instant test = new Instant(TEST_TIME1); DateTime result = test.toDateTime(); assertEquals(TEST_TIME1, result.getMillis()); assertEquals(ISOChronology.getInstance(), result.getChronology()); } public void testToDateTimeISO() { Instant test = new Instant(TEST_TIME1); DateTime result = test.toDateTimeISO(); assertSame(DateTime.class, result.getClass()); assertSame(ISOChronology.class, result.getChronology().getClass()); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISOChronology.getInstance(), result.getChronology()); } public void testToDateTime_DateTimeZone() { Instant test = new Instant(TEST_TIME1); DateTime result = test.toDateTime(LONDON); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISOChronology.getInstance(LONDON), result.getChronology()); test = new Instant(TEST_TIME1); result = test.toDateTime(PARIS); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISOChronology.getInstance(PARIS), result.getChronology()); test = new Instant(TEST_TIME1); result = test.toDateTime((DateTimeZone) null); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISOChronology.getInstance(), result.getChronology()); } public void testToDateTime_Chronology() { Instant test = new Instant(TEST_TIME1); DateTime result = test.toDateTime(ISOChronology.getInstance()); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISOChronology.getInstance(), result.getChronology()); test = new Instant(TEST_TIME1); result = test.toDateTime(GregorianChronology.getInstance(PARIS)); assertEquals(test.getMillis(), result.getMillis()); assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology()); test = new Instant(TEST_TIME1); result = test.toDateTime((Chronology) null); assertEquals(ISOChronology.getInstance(), result.getChronology()); } public void testToMutableDateTime() { Instant test = new Instant(TEST_TIME1); MutableDateTime result = test.toMutableDateTime(); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISOChronology.getInstance(), result.getChronology()); } public void testToMutableDateTimeISO() { Instant test = new Instant(TEST_TIME1); MutableDateTime result = test.toMutableDateTimeISO(); assertSame(MutableDateTime.class, result.getClass()); assertSame(ISOChronology.class, result.getChronology().getClass()); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISOChronology.getInstance(), result.getChronology()); } public void testToMutableDateTime_DateTimeZone() { Instant test = new Instant(TEST_TIME1); MutableDateTime result = test.toMutableDateTime(LONDON); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISOChronology.getInstance(), result.getChronology()); test = new Instant(TEST_TIME1); result = test.toMutableDateTime(PARIS); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISOChronology.getInstance(PARIS), result.getChronology()); test = new Instant(TEST_TIME1); result = test.toMutableDateTime((DateTimeZone) null); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISOChronology.getInstance(), result.getChronology()); } public void testToMutableDateTime_Chronology() { Instant test = new Instant(TEST_TIME1); MutableDateTime result = test.toMutableDateTime(ISOChronology.getInstance()); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISOChronology.getInstance(), result.getChronology()); test = new Instant(TEST_TIME1); result = test.toMutableDateTime(GregorianChronology.getInstance(PARIS)); assertEquals(test.getMillis(), result.getMillis()); assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology()); test = new Instant(TEST_TIME1); result = test.toMutableDateTime((Chronology) null); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISOChronology.getInstance(), result.getChronology()); } public void testToDate() { Instant test = new Instant(TEST_TIME1); Date result = test.toDate(); assertEquals(test.getMillis(), result.getTime()); } //----------------------------------------------------------------------- public void testWithMillis_long() { Instant test = new Instant(TEST_TIME1); Instant result = test.withMillis(TEST_TIME2); assertEquals(TEST_TIME2, result.getMillis()); assertEquals(test.getChronology(), result.getChronology()); test = new Instant(TEST_TIME1); result = test.withMillis(TEST_TIME1); assertSame(test, result); } //----------------------------------------------------------------------- public void testWithDurationAdded_long_int() { Instant test = new Instant(TEST_TIME1); Instant result = test.withDurationAdded(123456789L, 1); Instant expected = new Instant(TEST_TIME1 + 123456789L); assertEquals(expected, result); result = test.withDurationAdded(123456789L, 0); assertSame(test, result); result = test.withDurationAdded(123456789L, 2); expected = new Instant(TEST_TIME1 + (2L * 123456789L)); assertEquals(expected, result); result = test.withDurationAdded(123456789L, -3); expected = new Instant(TEST_TIME1 - (3L * 123456789L)); assertEquals(expected, result); } //----------------------------------------------------------------------- public void testWithDurationAdded_RD_int() { Instant test = new Instant(TEST_TIME1); Instant result = test.withDurationAdded(new Duration(123456789L), 1); Instant expected = new Instant(TEST_TIME1 + 123456789L); assertEquals(expected, result); result = test.withDurationAdded(null, 1); assertSame(test, result); result = test.withDurationAdded(new Duration(123456789L), 0); assertSame(test, result); result = test.withDurationAdded(new Duration(123456789L), 2); expected = new Instant(TEST_TIME1 + (2L * 123456789L)); assertEquals(expected, result); result = test.withDurationAdded(new Duration(123456789L), -3); expected = new Instant(TEST_TIME1 - (3L * 123456789L)); assertEquals(expected, result); } //----------------------------------------------------------------------- public void testPlus_long() { Instant test = new Instant(TEST_TIME1); Instant result = test.plus(123456789L); Instant expected = new Instant(TEST_TIME1 + 123456789L); assertEquals(expected, result); } public void testPlus_RD() { Instant test = new Instant(TEST_TIME1); Instant result = test.plus(new Duration(123456789L)); Instant expected = new Instant(TEST_TIME1 + 123456789L); assertEquals(expected, result); result = test.plus((ReadableDuration) null); assertSame(test, result); } //----------------------------------------------------------------------- public void testMinus_long() { Instant test = new Instant(TEST_TIME1); Instant result = test.minus(123456789L); Instant expected = new Instant(TEST_TIME1 - 123456789L); assertEquals(expected, result); } public void testMinus_RD() { Instant test = new Instant(TEST_TIME1); Instant result = test.minus(new Duration(123456789L)); Instant expected = new Instant(TEST_TIME1 - 123456789L); assertEquals(expected, result); result = test.minus((ReadableDuration) null); assertSame(test, result); } //----------------------------------------------------------------------- public void testImmutable() { assertTrue(Modifier.isFinal(Instant.class.getModifiers())); } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.util.Date; import java.util.Locale; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.ISOChronology; import org.joda.time.convert.ConverterManager; import org.joda.time.convert.MockZeroNullIntegerConverter; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; /** * This class is a Junit unit test for Instant. * * @author Stephen Colebourne */ public class TestInstant_Constructors extends TestCase { private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); // 1970-06-09 private long TEST_TIME_NOW = (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; // 1970-04-05 private long TEST_TIME1 = (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; // 1971-05-06 private long TEST_TIME2 = (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone zone = null; private Locale locale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestInstant_Constructors.class); } public TestInstant_Constructors(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); zone = DateTimeZone.getDefault(); locale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); java.util.TimeZone.setDefault(LONDON.toTimeZone()); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(zone); java.util.TimeZone.setDefault(zone.toTimeZone()); Locale.setDefault(locale); zone = null; } //----------------------------------------------------------------------- /** * Test now () */ public void test_now() throws Throwable { Instant test = Instant.now(); assertEquals(ISOChronology.getInstanceUTC(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } //----------------------------------------------------------------------- public void testParse_noFormatter() throws Throwable { assertEquals(new DateTime(2010, 6, 30, 0, 20, ISOChronology.getInstance(LONDON)).toInstant(), Instant.parse("2010-06-30T01:20+02:00")); assertEquals(new DateTime(2010, 1, 2, 14, 50, ISOChronology.getInstance(LONDON)).toInstant(), Instant.parse("2010-002T14:50")); } public void testParse_formatter() throws Throwable { DateTimeFormatter f = DateTimeFormat.forPattern("yyyy--dd MM HH").withChronology(ISOChronology.getInstance(PARIS)); assertEquals(new DateTime(2010, 6, 30, 13, 0, ISOChronology.getInstance(PARIS)).toInstant(), Instant.parse("2010--30 06 13", f)); } //----------------------------------------------------------------------- /** * Test constructor () */ public void testConstructor() throws Throwable { Instant test = new Instant(); assertEquals(ISOChronology.getInstanceUTC(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } //----------------------------------------------------------------------- /** * Test constructor (long) */ public void testConstructor_long1() throws Throwable { Instant test = new Instant(TEST_TIME1); assertEquals(ISOChronology.getInstanceUTC(), test.getChronology()); assertEquals(TEST_TIME1, test.getMillis()); } /** * Test constructor (long) */ public void testConstructor_long2() throws Throwable { Instant test = new Instant(TEST_TIME2); assertEquals(ISOChronology.getInstanceUTC(), test.getChronology()); assertEquals(TEST_TIME2, test.getMillis()); } //----------------------------------------------------------------------- /** * Test constructor (Object) */ public void testConstructor_Object() throws Throwable { Date date = new Date(TEST_TIME1); Instant test = new Instant(date); assertEquals(ISOChronology.getInstanceUTC(), test.getChronology()); assertEquals(TEST_TIME1, test.getMillis()); } /** * Test constructor (Object) */ public void testConstructor_invalidObject() throws Throwable { try { new Instant(new Object()); fail(); } catch (IllegalArgumentException ex) {} } /** * Test constructor (Object=null) */ public void testConstructor_nullObject() throws Throwable { Instant test = new Instant((Object) null); assertEquals(ISOChronology.getInstanceUTC(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test constructor (Object=null) */ public void testConstructor_badconverterObject() throws Throwable { try { ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE); Instant test = new Instant(new Integer(0)); assertEquals(ISOChronology.getInstanceUTC(), test.getChronology()); assertEquals(0L, test.getMillis()); } finally { ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE); } } }
/* * Copyright 2001-2011 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.base.AbstractInterval; import org.joda.time.chrono.BuddhistChronology; import org.joda.time.chrono.CopticChronology; import org.joda.time.chrono.GJChronology; import org.joda.time.chrono.ISOChronology; import org.joda.time.chrono.LenientChronology; /** * This class is a Junit unit test for Instant. * * @author Stephen Colebourne */ public class TestInterval_Basics extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone MOSCOW = DateTimeZone.forID("Europe/Moscow"); private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS); private Interval interval37; private Interval interval33; long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; // 2002-04-05 private long TEST_TIME1 = (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; // 2003-05-06 private long TEST_TIME2 = (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestInterval_Basics.class); } public TestInterval_Basics(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(PARIS); TimeZone.setDefault(PARIS.toTimeZone()); Locale.setDefault(Locale.FRANCE); interval37 = new Interval(3, 7); interval33 = new Interval(3, 3); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testTest() { assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString()); assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString()); assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString()); } //----------------------------------------------------------------------- public void testGetMillis() { Interval test = new Interval(TEST_TIME1, TEST_TIME2); assertEquals(TEST_TIME1, test.getStartMillis()); assertEquals(TEST_TIME1, test.getStart().getMillis()); assertEquals(TEST_TIME2, test.getEndMillis()); assertEquals(TEST_TIME2, test.getEnd().getMillis()); assertEquals(TEST_TIME2 - TEST_TIME1, test.toDurationMillis()); assertEquals(TEST_TIME2 - TEST_TIME1, test.toDuration().getMillis()); } public void testGetDuration1() { Interval test = new Interval(TEST_TIME1, TEST_TIME2); assertEquals(TEST_TIME2 - TEST_TIME1, test.toDurationMillis()); assertEquals(TEST_TIME2 - TEST_TIME1, test.toDuration().getMillis()); } public void testGetDuration2() { Interval test = new Interval(TEST_TIME1, TEST_TIME1); assertSame(Duration.ZERO, test.toDuration()); } public void testEqualsHashCode() { Interval test1 = new Interval(TEST_TIME1, TEST_TIME2); Interval test2 = new Interval(TEST_TIME1, TEST_TIME2); assertEquals(true, test1.equals(test2)); assertEquals(true, test2.equals(test1)); assertEquals(true, test1.equals(test1)); assertEquals(true, test2.equals(test2)); assertEquals(true, test1.hashCode() == test2.hashCode()); assertEquals(true, test1.hashCode() == test1.hashCode()); assertEquals(true, test2.hashCode() == test2.hashCode()); Interval test3 = new Interval(TEST_TIME_NOW, TEST_TIME2); assertEquals(false, test1.equals(test3)); assertEquals(false, test2.equals(test3)); assertEquals(false, test3.equals(test1)); assertEquals(false, test3.equals(test2)); assertEquals(false, test1.hashCode() == test3.hashCode()); assertEquals(false, test2.hashCode() == test3.hashCode()); Interval test4 = new Interval(TEST_TIME1, TEST_TIME2, GJChronology.getInstance()); assertEquals(true, test4.equals(test4)); assertEquals(false, test1.equals(test4)); assertEquals(false, test2.equals(test4)); assertEquals(false, test4.equals(test1)); assertEquals(false, test4.equals(test2)); assertEquals(false, test1.hashCode() == test4.hashCode()); assertEquals(false, test2.hashCode() == test4.hashCode()); MutableInterval test5 = new MutableInterval(TEST_TIME1, TEST_TIME2); assertEquals(true, test1.equals(test5)); assertEquals(true, test2.equals(test5)); assertEquals(false, test3.equals(test5)); assertEquals(true, test5.equals(test1)); assertEquals(true, test5.equals(test2)); assertEquals(false, test5.equals(test3)); assertEquals(true, test1.hashCode() == test5.hashCode()); assertEquals(true, test2.hashCode() == test5.hashCode()); assertEquals(false, test3.hashCode() == test5.hashCode()); assertEquals(false, test1.equals("Hello")); assertEquals(true, test1.equals(new MockInterval())); assertEquals(false, test1.equals(new DateTime(TEST_TIME1))); } class MockInterval extends AbstractInterval { public MockInterval() { super(); } public Chronology getChronology() { return ISOChronology.getInstance(); } public long getStartMillis() { return TEST_TIME1; } public long getEndMillis() { return TEST_TIME2; } } public void testEqualsHashCodeLenient() { Interval test1 = new Interval( new DateTime(TEST_TIME1, LenientChronology.getInstance(COPTIC_PARIS)), new DateTime(TEST_TIME2, LenientChronology.getInstance(COPTIC_PARIS))); Interval test2 = new Interval( new DateTime(TEST_TIME1, LenientChronology.getInstance(COPTIC_PARIS)), new DateTime(TEST_TIME2, LenientChronology.getInstance(COPTIC_PARIS))); assertEquals(true, test1.equals(test2)); assertEquals(true, test2.equals(test1)); assertEquals(true, test1.equals(test1)); assertEquals(true, test2.equals(test2)); assertEquals(true, test1.hashCode() == test2.hashCode()); assertEquals(true, test1.hashCode() == test1.hashCode()); assertEquals(true, test2.hashCode() == test2.hashCode()); } public void testEqualsHashCodeStrict() { Interval test1 = new Interval( new DateTime(TEST_TIME1, LenientChronology.getInstance(COPTIC_PARIS)), new DateTime(TEST_TIME2, LenientChronology.getInstance(COPTIC_PARIS))); Interval test2 = new Interval( new DateTime(TEST_TIME1, LenientChronology.getInstance(COPTIC_PARIS)), new DateTime(TEST_TIME2, LenientChronology.getInstance(COPTIC_PARIS))); assertEquals(true, test1.equals(test2)); assertEquals(true, test2.equals(test1)); assertEquals(true, test1.equals(test1)); assertEquals(true, test2.equals(test2)); assertEquals(true, test1.hashCode() == test2.hashCode()); assertEquals(true, test1.hashCode() == test1.hashCode()); assertEquals(true, test2.hashCode() == test2.hashCode()); } //----------------------------------------------------------------------- public void test_useCase_ContainsOverlapAbutGap() { // this is a simple test to ensure that the use case of these methods is OK // when comparing any two intervals they can be in one and only one of these states // (a) have a gap between them, (b) abut or (c) overlap // contains is a subset of overlap Interval test1020 = new Interval(10, 20); // [4,8) [10,20) - gap Interval interval = new Interval(4, 8); assertNotNull(test1020.gap(interval)); assertEquals(false, test1020.abuts(interval)); assertEquals(false, test1020.overlaps(interval)); assertEquals(false, test1020.contains(interval)); assertNotNull(interval.gap(test1020)); assertEquals(false, interval.abuts(test1020)); assertEquals(false, interval.overlaps(test1020)); assertEquals(false, interval.contains(test1020)); // [6,10) [10,20) - abuts interval = new Interval(6, 10); assertNull(test1020.gap(interval)); assertEquals(true, test1020.abuts(interval)); assertEquals(false, test1020.overlaps(interval)); assertEquals(false, test1020.contains(interval)); assertNull(interval.gap(test1020)); assertEquals(true, interval.abuts(test1020)); assertEquals(false, interval.overlaps(test1020)); assertEquals(false, interval.contains(test1020)); // [8,12) [10,20) - overlaps interval = new Interval(8, 12); assertNull(test1020.gap(interval)); assertEquals(false, test1020.abuts(interval)); assertEquals(true, test1020.overlaps(interval)); assertEquals(false, test1020.contains(interval)); assertNull(interval.gap(test1020)); assertEquals(false, interval.abuts(test1020)); assertEquals(true, interval.overlaps(test1020)); assertEquals(false, interval.contains(test1020)); // [10,14) [10,20) - overlaps and contains-one-way interval = new Interval(10, 14); assertNull(test1020.gap(interval)); assertEquals(false, test1020.abuts(interval)); assertEquals(true, test1020.overlaps(interval)); assertEquals(true, test1020.contains(interval)); assertNull(interval.gap(test1020)); assertEquals(false, interval.abuts(test1020)); assertEquals(true, interval.overlaps(test1020)); assertEquals(false, interval.contains(test1020)); // [10,20) [10,20) - overlaps and contains-both-ways assertNull(test1020.gap(interval)); assertEquals(false, test1020.abuts(test1020)); assertEquals(true, test1020.overlaps(test1020)); assertEquals(true, test1020.contains(test1020)); // [10,20) [16,20) - overlaps and contains-one-way interval = new Interval(16, 20); assertNull(test1020.gap(interval)); assertEquals(false, test1020.abuts(interval)); assertEquals(true, test1020.overlaps(interval)); assertEquals(true, test1020.contains(interval)); assertNull(interval.gap(test1020)); assertEquals(false, interval.abuts(test1020)); assertEquals(true, interval.overlaps(test1020)); assertEquals(false, interval.contains(test1020)); // [10,20) [18,22) - overlaps interval = new Interval(18, 22); assertNull(test1020.gap(interval)); assertEquals(false, test1020.abuts(interval)); assertEquals(true, test1020.overlaps(interval)); assertEquals(false, test1020.contains(interval)); assertNull(interval.gap(test1020)); assertEquals(false, interval.abuts(test1020)); assertEquals(true, interval.overlaps(test1020)); assertEquals(false, interval.contains(test1020)); // [10,20) [20,24) - abuts interval = new Interval(20, 24); assertNull(test1020.gap(interval)); assertEquals(true, test1020.abuts(interval)); assertEquals(false, test1020.overlaps(interval)); assertEquals(false, test1020.contains(interval)); assertNull(interval.gap(test1020)); assertEquals(true, interval.abuts(test1020)); assertEquals(false, interval.overlaps(test1020)); assertEquals(false, interval.contains(test1020)); // [10,20) [22,26) - gap interval = new Interval(22, 26); assertNotNull(test1020.gap(interval)); assertEquals(false, test1020.abuts(interval)); assertEquals(false, test1020.overlaps(interval)); assertEquals(false, test1020.contains(interval)); assertNotNull(interval.gap(test1020)); assertEquals(false, interval.abuts(test1020)); assertEquals(false, interval.overlaps(test1020)); assertEquals(false, interval.contains(test1020)); } //----------------------------------------------------------------------- public void test_useCase_ContainsOverlapAbutGap_zeroDuration() { // this is a simple test to ensure that the use case of these methods // is OK when considering a zero duration inerval // when comparing any two intervals they can be in one and only one of these states // (a) have a gap between them, (b) abut or (c) overlap // contains is a subset of overlap Interval test1020 = new Interval(10, 20); // [8,8) [10,20) - gap Interval interval = new Interval(8, 8); assertNotNull(test1020.gap(interval)); assertEquals(false, test1020.abuts(interval)); assertEquals(false, test1020.overlaps(interval)); assertEquals(false, test1020.contains(interval)); assertNotNull(interval.gap(test1020)); assertEquals(false, interval.abuts(test1020)); assertEquals(false, interval.overlaps(test1020)); assertEquals(false, interval.contains(test1020)); // [10,10) [10,20) - abuts and contains-one-way interval = new Interval(10, 10); assertNull(test1020.gap(interval)); assertEquals(true, test1020.abuts(interval)); assertEquals(false, test1020.overlaps(interval)); // abuts, so can't overlap assertEquals(true, test1020.contains(interval)); // normal contains zero-duration assertNull(interval.gap(test1020)); assertEquals(true, interval.abuts(test1020)); assertEquals(false, interval.overlaps(test1020)); // abuts, so can't overlap assertEquals(false, interval.contains(test1020)); // zero-duration does not contain normal // [12,12) [10,20) - contains-one-way and overlaps interval = new Interval(12, 12); assertNull(test1020.gap(interval)); assertEquals(false, test1020.abuts(interval)); assertEquals(true, test1020.overlaps(interval)); assertEquals(true, test1020.contains(interval)); // normal contains zero-duration assertNull(interval.gap(test1020)); assertEquals(false, interval.abuts(test1020)); assertEquals(true, interval.overlaps(test1020)); assertEquals(false, interval.contains(test1020)); // zero-duration does not contain normal // [10,20) [20,20) - abuts interval = new Interval(20, 20); assertNull(test1020.gap(interval)); assertEquals(true, test1020.abuts(interval)); assertEquals(false, test1020.overlaps(interval)); assertEquals(false, test1020.contains(interval)); assertNull(interval.gap(test1020)); assertEquals(true, interval.abuts(test1020)); assertEquals(false, interval.overlaps(test1020)); assertEquals(false, interval.contains(test1020)); // [10,20) [22,22) - gap interval = new Interval(22, 22); assertNotNull(test1020.gap(interval)); assertEquals(false, test1020.abuts(interval)); assertEquals(false, test1020.overlaps(interval)); assertEquals(false, test1020.contains(interval)); assertNotNull(interval.gap(test1020)); assertEquals(false, interval.abuts(test1020)); assertEquals(false, interval.overlaps(test1020)); assertEquals(false, interval.contains(test1020)); } //----------------------------------------------------------------------- public void test_useCase_ContainsOverlapAbutGap_bothZeroDuration() { // this is a simple test to ensure that the use case of these methods // is OK when considering two zero duration inervals // this is the simplest case, as the two intervals either have a gap or not // if not, then they are equal and abut Interval test0808 = new Interval(8, 8); Interval test1010 = new Interval(10, 10); // [8,8) [10,10) - gap assertNotNull(test1010.gap(test0808)); assertEquals(false, test1010.abuts(test0808)); assertEquals(false, test1010.overlaps(test0808)); assertEquals(false, test1010.contains(test0808)); assertNotNull(test0808.gap(test1010)); assertEquals(false, test0808.abuts(test1010)); assertEquals(false, test0808.overlaps(test1010)); assertEquals(false, test0808.contains(test1010)); // [10,10) [10,10) - abuts assertNull(test1010.gap(test1010)); assertEquals(true, test1010.abuts(test1010)); assertEquals(false, test1010.overlaps(test1010)); assertEquals(false, test1010.contains(test1010)); } //----------------------------------------------------------------------- public void testContains_long() { assertEquals(false, interval37.contains(2)); // value before assertEquals(true, interval37.contains(3)); assertEquals(true, interval37.contains(4)); assertEquals(true, interval37.contains(5)); assertEquals(true, interval37.contains(6)); assertEquals(false, interval37.contains(7)); // value after assertEquals(false, interval37.contains(8)); // value after } public void testContains_long_zeroDuration() { assertEquals(false, interval33.contains(2)); // value before assertEquals(false, interval33.contains(3)); // zero length duration contains nothing assertEquals(false, interval33.contains(4)); // value after } //----------------------------------------------------------------------- public void testContainsNow() { DateTimeUtils.setCurrentMillisFixed(2); assertEquals(false, interval37.containsNow()); // value before DateTimeUtils.setCurrentMillisFixed(3); assertEquals(true, interval37.containsNow()); DateTimeUtils.setCurrentMillisFixed(4); assertEquals(true, interval37.containsNow()); DateTimeUtils.setCurrentMillisFixed(6); assertEquals(true, interval37.containsNow()); DateTimeUtils.setCurrentMillisFixed(7); assertEquals(false, interval37.containsNow()); // value after DateTimeUtils.setCurrentMillisFixed(8); assertEquals(false, interval37.containsNow()); // value after DateTimeUtils.setCurrentMillisFixed(2); assertEquals(false, interval33.containsNow()); // value before DateTimeUtils.setCurrentMillisFixed(3); assertEquals(false, interval33.containsNow()); // zero length duration contains nothing DateTimeUtils.setCurrentMillisFixed(4); assertEquals(false, interval33.containsNow()); // value after } //----------------------------------------------------------------------- public void testContains_RI() { assertEquals(false, interval37.contains(new Instant(2))); // value before assertEquals(true, interval37.contains(new Instant(3))); assertEquals(true, interval37.contains(new Instant(4))); assertEquals(true, interval37.contains(new Instant(5))); assertEquals(true, interval37.contains(new Instant(6))); assertEquals(false, interval37.contains(new Instant(7))); // value after assertEquals(false, interval37.contains(new Instant(8))); // value after } public void testContains_RI_null() { DateTimeUtils.setCurrentMillisFixed(2); assertEquals(false, interval37.contains((ReadableInstant) null)); // value before DateTimeUtils.setCurrentMillisFixed(3); assertEquals(true, interval37.contains((ReadableInstant) null)); DateTimeUtils.setCurrentMillisFixed(4); assertEquals(true, interval37.contains((ReadableInstant) null)); DateTimeUtils.setCurrentMillisFixed(6); assertEquals(true, interval37.contains((ReadableInstant) null)); DateTimeUtils.setCurrentMillisFixed(7); assertEquals(false, interval37.contains((ReadableInstant) null)); // value after DateTimeUtils.setCurrentMillisFixed(8); assertEquals(false, interval37.contains((ReadableInstant) null)); // value after } public void testContains_RI_zeroDuration() { assertEquals(false, interval33.contains(new Instant(2))); // value before assertEquals(false, interval33.contains(new Instant(3))); // zero length duration contains nothing assertEquals(false, interval33.contains(new Instant(4))); // value after } //----------------------------------------------------------------------- public void testContains_RInterval() { assertEquals(false, interval37.contains(new Interval(1, 2))); // gap before assertEquals(false, interval37.contains(new Interval(2, 2))); // gap before assertEquals(false, interval37.contains(new Interval(2, 3))); // abuts before assertEquals(true, interval37.contains(new Interval(3, 3))); assertEquals(false, interval37.contains(new Interval(2, 4))); // starts before assertEquals(true, interval37.contains(new Interval(3, 4))); assertEquals(true, interval37.contains(new Interval(4, 4))); assertEquals(false, interval37.contains(new Interval(2, 6))); // starts before assertEquals(true, interval37.contains(new Interval(3, 6))); assertEquals(true, interval37.contains(new Interval(4, 6))); assertEquals(true, interval37.contains(new Interval(5, 6))); assertEquals(true, interval37.contains(new Interval(6, 6))); assertEquals(false, interval37.contains(new Interval(2, 7))); // starts before assertEquals(true, interval37.contains(new Interval(3, 7))); assertEquals(true, interval37.contains(new Interval(4, 7))); assertEquals(true, interval37.contains(new Interval(5, 7))); assertEquals(true, interval37.contains(new Interval(6, 7))); assertEquals(false, interval37.contains(new Interval(7, 7))); // abuts after assertEquals(false, interval37.contains(new Interval(2, 8))); // ends after assertEquals(false, interval37.contains(new Interval(3, 8))); // ends after assertEquals(false, interval37.contains(new Interval(4, 8))); // ends after assertEquals(false, interval37.contains(new Interval(5, 8))); // ends after assertEquals(false, interval37.contains(new Interval(6, 8))); // ends after assertEquals(false, interval37.contains(new Interval(7, 8))); // abuts after assertEquals(false, interval37.contains(new Interval(8, 8))); // gap after assertEquals(false, interval37.contains(new Interval(8, 9))); // gap after assertEquals(false, interval37.contains(new Interval(9, 9))); // gap after } public void testContains_RInterval_null() { DateTimeUtils.setCurrentMillisFixed(2); assertEquals(false, interval37.contains((ReadableInterval) null)); // gap before DateTimeUtils.setCurrentMillisFixed(3); assertEquals(true, interval37.contains((ReadableInterval) null)); DateTimeUtils.setCurrentMillisFixed(4); assertEquals(true, interval37.contains((ReadableInterval) null)); DateTimeUtils.setCurrentMillisFixed(6); assertEquals(true, interval37.contains((ReadableInterval) null)); DateTimeUtils.setCurrentMillisFixed(7); assertEquals(false, interval37.contains((ReadableInterval) null)); // abuts after DateTimeUtils.setCurrentMillisFixed(8); assertEquals(false, interval37.contains((ReadableInterval) null)); // gap after } public void testContains_RInterval_zeroDuration() { assertEquals(false, interval33.contains(interval33)); // zero length duration contains nothing assertEquals(false, interval33.contains(interval37)); // zero-duration cannot contain anything assertEquals(true, interval37.contains(interval33)); assertEquals(false, interval33.contains(new Interval(1, 2))); // zero-duration cannot contain anything assertEquals(false, interval33.contains(new Interval(8, 9))); // zero-duration cannot contain anything assertEquals(false, interval33.contains(new Interval(1, 9))); // zero-duration cannot contain anything DateTimeUtils.setCurrentMillisFixed(2); assertEquals(false, interval33.contains((ReadableInterval) null)); // gap before DateTimeUtils.setCurrentMillisFixed(3); assertEquals(false, interval33.contains((ReadableInterval) null)); // zero length duration contains nothing DateTimeUtils.setCurrentMillisFixed(4); assertEquals(false, interval33.contains((ReadableInterval) null)); // gap after } //----------------------------------------------------------------------- public void testOverlaps_RInterval() { assertEquals(false, interval37.overlaps(new Interval(1, 2))); // gap before assertEquals(false, interval37.overlaps(new Interval(2, 2))); // gap before assertEquals(false, interval37.overlaps(new Interval(2, 3))); // abuts before assertEquals(false, interval37.overlaps(new Interval(3, 3))); // abuts before assertEquals(true, interval37.overlaps(new Interval(2, 4))); assertEquals(true, interval37.overlaps(new Interval(3, 4))); assertEquals(true, interval37.overlaps(new Interval(4, 4))); assertEquals(true, interval37.overlaps(new Interval(2, 6))); assertEquals(true, interval37.overlaps(new Interval(3, 6))); assertEquals(true, interval37.overlaps(new Interval(4, 6))); assertEquals(true, interval37.overlaps(new Interval(5, 6))); assertEquals(true, interval37.overlaps(new Interval(6, 6))); assertEquals(true, interval37.overlaps(new Interval(2, 7))); assertEquals(true, interval37.overlaps(new Interval(3, 7))); assertEquals(true, interval37.overlaps(new Interval(4, 7))); assertEquals(true, interval37.overlaps(new Interval(5, 7))); assertEquals(true, interval37.overlaps(new Interval(6, 7))); assertEquals(false, interval37.overlaps(new Interval(7, 7))); // abuts after assertEquals(true, interval37.overlaps(new Interval(2, 8))); assertEquals(true, interval37.overlaps(new Interval(3, 8))); assertEquals(true, interval37.overlaps(new Interval(4, 8))); assertEquals(true, interval37.overlaps(new Interval(5, 8))); assertEquals(true, interval37.overlaps(new Interval(6, 8))); assertEquals(false, interval37.overlaps(new Interval(7, 8))); // abuts after assertEquals(false, interval37.overlaps(new Interval(8, 8))); // gap after assertEquals(false, interval37.overlaps(new Interval(8, 9))); // gap after assertEquals(false, interval37.overlaps(new Interval(9, 9))); // gap after } public void testOverlaps_RInterval_null() { DateTimeUtils.setCurrentMillisFixed(2); assertEquals(false, interval37.overlaps((ReadableInterval) null)); // gap before DateTimeUtils.setCurrentMillisFixed(3); assertEquals(false, interval37.overlaps((ReadableInterval) null)); // abuts before DateTimeUtils.setCurrentMillisFixed(4); assertEquals(true, interval37.overlaps((ReadableInterval) null)); DateTimeUtils.setCurrentMillisFixed(6); assertEquals(true, interval37.overlaps((ReadableInterval) null)); DateTimeUtils.setCurrentMillisFixed(7); assertEquals(false, interval37.overlaps((ReadableInterval) null)); // abuts after DateTimeUtils.setCurrentMillisFixed(8); assertEquals(false, interval37.overlaps((ReadableInterval) null)); // gap after DateTimeUtils.setCurrentMillisFixed(3); assertEquals(false, interval33.overlaps((ReadableInterval) null)); // abuts before and after } public void testOverlaps_RInterval_zeroDuration() { assertEquals(false, interval33.overlaps(interval33)); // abuts before and after assertEquals(false, interval33.overlaps(interval37)); // abuts before assertEquals(false, interval37.overlaps(interval33)); // abuts before assertEquals(false, interval33.overlaps(new Interval(1, 2))); assertEquals(false, interval33.overlaps(new Interval(8, 9))); assertEquals(true, interval33.overlaps(new Interval(1, 9))); } //----------------------------------------------------------------------- public void testOverlap_RInterval() { assertEquals(null, interval37.overlap(new Interval(1, 2))); // gap before assertEquals(null, interval37.overlap(new Interval(2, 2))); // gap before assertEquals(null, interval37.overlap(new Interval(2, 3))); // abuts before assertEquals(null, interval37.overlap(new Interval(3, 3))); // abuts before assertEquals(new Interval(3, 4), interval37.overlap(new Interval(2, 4))); // truncated start assertEquals(new Interval(3, 4), interval37.overlap(new Interval(3, 4))); assertEquals(new Interval(4, 4), interval37.overlap(new Interval(4, 4))); assertEquals(new Interval(3, 7), interval37.overlap(new Interval(2, 7))); // truncated start assertEquals(new Interval(3, 7), interval37.overlap(new Interval(3, 7))); assertEquals(new Interval(4, 7), interval37.overlap(new Interval(4, 7))); assertEquals(new Interval(5, 7), interval37.overlap(new Interval(5, 7))); assertEquals(new Interval(6, 7), interval37.overlap(new Interval(6, 7))); assertEquals(null, interval37.overlap(new Interval(7, 7))); // abuts after assertEquals(new Interval(3, 7), interval37.overlap(new Interval(2, 8))); // truncated start and end assertEquals(new Interval(3, 7), interval37.overlap(new Interval(3, 8))); // truncated end assertEquals(new Interval(4, 7), interval37.overlap(new Interval(4, 8))); // truncated end assertEquals(new Interval(5, 7), interval37.overlap(new Interval(5, 8))); // truncated end assertEquals(new Interval(6, 7), interval37.overlap(new Interval(6, 8))); // truncated end assertEquals(null, interval37.overlap(new Interval(7, 8))); // abuts after assertEquals(null, interval37.overlap(new Interval(8, 8))); // gap after } public void testOverlap_RInterval_null() { DateTimeUtils.setCurrentMillisFixed(2); assertEquals(null, interval37.overlap((ReadableInterval) null)); // gap before DateTimeUtils.setCurrentMillisFixed(3); assertEquals(null, interval37.overlap((ReadableInterval) null)); // abuts before DateTimeUtils.setCurrentMillisFixed(4); assertEquals(new Interval(4, 4), interval37.overlap((ReadableInterval) null)); DateTimeUtils.setCurrentMillisFixed(6); assertEquals(new Interval(6, 6), interval37.overlap((ReadableInterval) null)); DateTimeUtils.setCurrentMillisFixed(7); assertEquals(null, interval37.overlap((ReadableInterval) null)); // abuts after DateTimeUtils.setCurrentMillisFixed(8); assertEquals(null, interval37.overlap((ReadableInterval) null)); // gap after DateTimeUtils.setCurrentMillisFixed(3); assertEquals(null, interval33.overlap((ReadableInterval) null)); // abuts before and after } public void testOverlap_RInterval_zone() { Interval testA = new Interval(new DateTime(3, LONDON), new DateTime(7, LONDON)); assertEquals(ISOChronology.getInstance(LONDON), testA.getChronology()); Interval testB = new Interval(new DateTime(4, MOSCOW), new DateTime(8, MOSCOW)); assertEquals(ISOChronology.getInstance(MOSCOW), testB.getChronology()); Interval resultAB = testA.overlap(testB); assertEquals(ISOChronology.getInstance(LONDON), resultAB.getChronology()); Interval resultBA = testB.overlap(testA); assertEquals(ISOChronology.getInstance(MOSCOW), resultBA.getChronology()); } public void testOverlap_RInterval_zoneUTC() { Interval testA = new Interval(new Instant(3), new Instant(7)); assertEquals(ISOChronology.getInstanceUTC(), testA.getChronology()); Interval testB = new Interval(new Instant(4), new Instant(8)); assertEquals(ISOChronology.getInstanceUTC(), testB.getChronology()); Interval result = testA.overlap(testB); assertEquals(ISOChronology.getInstanceUTC(), result.getChronology()); } //----------------------------------------------------------------------- public void testGap_RInterval() { assertEquals(new Interval(1, 3), interval37.gap(new Interval(0, 1))); assertEquals(new Interval(1, 3), interval37.gap(new Interval(1, 1))); assertEquals(null, interval37.gap(new Interval(2, 3))); // abuts before assertEquals(null, interval37.gap(new Interval(3, 3))); // abuts before assertEquals(null, interval37.gap(new Interval(4, 6))); // overlaps assertEquals(null, interval37.gap(new Interval(3, 7))); // overlaps assertEquals(null, interval37.gap(new Interval(6, 7))); // overlaps assertEquals(null, interval37.gap(new Interval(7, 7))); // abuts after assertEquals(null, interval37.gap(new Interval(6, 8))); // overlaps assertEquals(null, interval37.gap(new Interval(7, 8))); // abuts after assertEquals(new Interval(7, 8), interval37.gap(new Interval(8, 8))); assertEquals(null, interval37.gap(new Interval(6, 9))); // overlaps assertEquals(null, interval37.gap(new Interval(7, 9))); // abuts after assertEquals(new Interval(7, 8), interval37.gap(new Interval(8, 9))); assertEquals(new Interval(7, 9), interval37.gap(new Interval(9, 9))); } public void testGap_RInterval_null() { DateTimeUtils.setCurrentMillisFixed(2); assertEquals(new Interval(2, 3), interval37.gap((ReadableInterval) null)); DateTimeUtils.setCurrentMillisFixed(3); assertEquals(null, interval37.gap((ReadableInterval) null)); // abuts before DateTimeUtils.setCurrentMillisFixed(4); assertEquals(null, interval37.gap((ReadableInterval) null)); // overlaps DateTimeUtils.setCurrentMillisFixed(6); assertEquals(null, interval37.gap((ReadableInterval) null)); // overlaps DateTimeUtils.setCurrentMillisFixed(7); assertEquals(null, interval37.gap((ReadableInterval) null)); // abuts after DateTimeUtils.setCurrentMillisFixed(8); assertEquals(new Interval(7, 8), interval37.gap((ReadableInterval) null)); } public void testGap_RInterval_zone() { Interval testA = new Interval(new DateTime(3, LONDON), new DateTime(7, LONDON)); assertEquals(ISOChronology.getInstance(LONDON), testA.getChronology()); Interval testB = new Interval(new DateTime(1, MOSCOW), new DateTime(2, MOSCOW)); assertEquals(ISOChronology.getInstance(MOSCOW), testB.getChronology()); Interval resultAB = testA.gap(testB); assertEquals(ISOChronology.getInstance(LONDON), resultAB.getChronology()); Interval resultBA = testB.gap(testA); assertEquals(ISOChronology.getInstance(MOSCOW), resultBA.getChronology()); } public void testGap_RInterval_zoneUTC() { Interval testA = new Interval(new Instant(3), new Instant(7)); assertEquals(ISOChronology.getInstanceUTC(), testA.getChronology()); Interval testB = new Interval(new Instant(1), new Instant(2)); assertEquals(ISOChronology.getInstanceUTC(), testB.getChronology()); Interval result = testA.gap(testB); assertEquals(ISOChronology.getInstanceUTC(), result.getChronology()); } //----------------------------------------------------------------------- public void testAbuts_RInterval() { assertEquals(false, interval37.abuts(new Interval(1, 2))); // gap before assertEquals(false, interval37.abuts(new Interval(2, 2))); // gap before assertEquals(true, interval37.abuts(new Interval(2, 3))); assertEquals(true, interval37.abuts(new Interval(3, 3))); assertEquals(false, interval37.abuts(new Interval(2, 4))); // overlaps assertEquals(false, interval37.abuts(new Interval(3, 4))); // overlaps assertEquals(false, interval37.abuts(new Interval(4, 4))); // overlaps assertEquals(false, interval37.abuts(new Interval(2, 6))); // overlaps assertEquals(false, interval37.abuts(new Interval(3, 6))); // overlaps assertEquals(false, interval37.abuts(new Interval(4, 6))); // overlaps assertEquals(false, interval37.abuts(new Interval(5, 6))); // overlaps assertEquals(false, interval37.abuts(new Interval(6, 6))); // overlaps assertEquals(false, interval37.abuts(new Interval(2, 7))); // overlaps assertEquals(false, interval37.abuts(new Interval(3, 7))); // overlaps assertEquals(false, interval37.abuts(new Interval(4, 7))); // overlaps assertEquals(false, interval37.abuts(new Interval(5, 7))); // overlaps assertEquals(false, interval37.abuts(new Interval(6, 7))); // overlaps assertEquals(true, interval37.abuts(new Interval(7, 7))); assertEquals(false, interval37.abuts(new Interval(2, 8))); // overlaps assertEquals(false, interval37.abuts(new Interval(3, 8))); // overlaps assertEquals(false, interval37.abuts(new Interval(4, 8))); // overlaps assertEquals(false, interval37.abuts(new Interval(5, 8))); // overlaps assertEquals(false, interval37.abuts(new Interval(6, 8))); // overlaps assertEquals(true, interval37.abuts(new Interval(7, 8))); assertEquals(false, interval37.abuts(new Interval(8, 8))); // gap after assertEquals(false, interval37.abuts(new Interval(8, 9))); // gap after assertEquals(false, interval37.abuts(new Interval(9, 9))); // gap after } public void testAbuts_RInterval_null() { DateTimeUtils.setCurrentMillisFixed(2); assertEquals(false, interval37.abuts((ReadableInterval) null)); // gap before DateTimeUtils.setCurrentMillisFixed(3); assertEquals(true, interval37.abuts((ReadableInterval) null)); DateTimeUtils.setCurrentMillisFixed(4); assertEquals(false, interval37.abuts((ReadableInterval) null)); // overlaps DateTimeUtils.setCurrentMillisFixed(6); assertEquals(false, interval37.abuts((ReadableInterval) null)); // overlaps DateTimeUtils.setCurrentMillisFixed(7); assertEquals(true, interval37.abuts((ReadableInterval) null)); DateTimeUtils.setCurrentMillisFixed(8); assertEquals(false, interval37.abuts((ReadableInterval) null)); // gap after } //----------------------------------------------------------------------- public void testIsEqual_RI() { assertEquals(false, interval37.isEqual(interval33)); assertEquals(true, interval37.isEqual(interval37)); } //----------------------------------------------------------------------- public void testIsBefore_long() { assertEquals(false, interval37.isBefore(2)); assertEquals(false, interval37.isBefore(3)); assertEquals(false, interval37.isBefore(4)); assertEquals(false, interval37.isBefore(5)); assertEquals(false, interval37.isBefore(6)); assertEquals(true, interval37.isBefore(7)); assertEquals(true, interval37.isBefore(8)); } public void testIsBeforeNow() { DateTimeUtils.setCurrentMillisFixed(2); assertEquals(false, interval37.isBeforeNow()); DateTimeUtils.setCurrentMillisFixed(3); assertEquals(false, interval37.isBeforeNow()); DateTimeUtils.setCurrentMillisFixed(4); assertEquals(false, interval37.isBeforeNow()); DateTimeUtils.setCurrentMillisFixed(6); assertEquals(false, interval37.isBeforeNow()); DateTimeUtils.setCurrentMillisFixed(7); assertEquals(true, interval37.isBeforeNow()); DateTimeUtils.setCurrentMillisFixed(8); assertEquals(true, interval37.isBeforeNow()); } public void testIsBefore_RI() { assertEquals(false, interval37.isBefore(new Instant(2))); assertEquals(false, interval37.isBefore(new Instant(3))); assertEquals(false, interval37.isBefore(new Instant(4))); assertEquals(false, interval37.isBefore(new Instant(5))); assertEquals(false, interval37.isBefore(new Instant(6))); assertEquals(true, interval37.isBefore(new Instant(7))); assertEquals(true, interval37.isBefore(new Instant(8))); } public void testIsBefore_RI_null() { DateTimeUtils.setCurrentMillisFixed(2); assertEquals(false, interval37.isBefore((ReadableInstant) null)); DateTimeUtils.setCurrentMillisFixed(3); assertEquals(false, interval37.isBefore((ReadableInstant) null)); DateTimeUtils.setCurrentMillisFixed(4); assertEquals(false, interval37.isBefore((ReadableInstant) null)); DateTimeUtils.setCurrentMillisFixed(6); assertEquals(false, interval37.isBefore((ReadableInstant) null)); DateTimeUtils.setCurrentMillisFixed(7); assertEquals(true, interval37.isBefore((ReadableInstant) null)); DateTimeUtils.setCurrentMillisFixed(8); assertEquals(true, interval37.isBefore((ReadableInstant) null)); } public void testIsBefore_RInterval() { assertEquals(false, interval37.isBefore(new Interval(Long.MIN_VALUE, 2))); assertEquals(false, interval37.isBefore(new Interval(Long.MIN_VALUE, 3))); assertEquals(false, interval37.isBefore(new Interval(Long.MIN_VALUE, 4))); assertEquals(false, interval37.isBefore(new Interval(6, Long.MAX_VALUE))); assertEquals(true, interval37.isBefore(new Interval(7, Long.MAX_VALUE))); assertEquals(true, interval37.isBefore(new Interval(8, Long.MAX_VALUE))); } public void testIsBefore_RInterval_null() { DateTimeUtils.setCurrentMillisFixed(2); assertEquals(false, interval37.isBefore((ReadableInterval) null)); DateTimeUtils.setCurrentMillisFixed(3); assertEquals(false, interval37.isBefore((ReadableInterval) null)); DateTimeUtils.setCurrentMillisFixed(4); assertEquals(false, interval37.isBefore((ReadableInterval) null)); DateTimeUtils.setCurrentMillisFixed(6); assertEquals(false, interval37.isBefore((ReadableInterval) null)); DateTimeUtils.setCurrentMillisFixed(7); assertEquals(true, interval37.isBefore((ReadableInterval) null)); DateTimeUtils.setCurrentMillisFixed(8); assertEquals(true, interval37.isBefore((ReadableInterval) null)); } //----------------------------------------------------------------------- public void testIsAfter_long() { assertEquals(true, interval37.isAfter(2)); assertEquals(false, interval37.isAfter(3)); assertEquals(false, interval37.isAfter(4)); assertEquals(false, interval37.isAfter(5)); assertEquals(false, interval37.isAfter(6)); assertEquals(false, interval37.isAfter(7)); assertEquals(false, interval37.isAfter(8)); } public void testIsAfterNow() { DateTimeUtils.setCurrentMillisFixed(2); assertEquals(true, interval37.isAfterNow()); DateTimeUtils.setCurrentMillisFixed(3); assertEquals(false, interval37.isAfterNow()); DateTimeUtils.setCurrentMillisFixed(4); assertEquals(false, interval37.isAfterNow()); DateTimeUtils.setCurrentMillisFixed(6); assertEquals(false, interval37.isAfterNow()); DateTimeUtils.setCurrentMillisFixed(7); assertEquals(false, interval37.isAfterNow()); DateTimeUtils.setCurrentMillisFixed(8); assertEquals(false, interval37.isAfterNow()); } public void testIsAfter_RI() { assertEquals(true, interval37.isAfter(new Instant(2))); assertEquals(false, interval37.isAfter(new Instant(3))); assertEquals(false, interval37.isAfter(new Instant(4))); assertEquals(false, interval37.isAfter(new Instant(5))); assertEquals(false, interval37.isAfter(new Instant(6))); assertEquals(false, interval37.isAfter(new Instant(7))); assertEquals(false, interval37.isAfter(new Instant(8))); } public void testIsAfter_RI_null() { DateTimeUtils.setCurrentMillisFixed(2); assertEquals(true, interval37.isAfter((ReadableInstant) null)); DateTimeUtils.setCurrentMillisFixed(3); assertEquals(false, interval37.isAfter((ReadableInstant) null)); DateTimeUtils.setCurrentMillisFixed(4); assertEquals(false, interval37.isAfter((ReadableInstant) null)); DateTimeUtils.setCurrentMillisFixed(6); assertEquals(false, interval37.isAfter((ReadableInstant) null)); DateTimeUtils.setCurrentMillisFixed(7); assertEquals(false, interval37.isAfter((ReadableInstant) null)); DateTimeUtils.setCurrentMillisFixed(8); assertEquals(false, interval37.isAfter((ReadableInstant) null)); } public void testIsAfter_RInterval() { assertEquals(true, interval37.isAfter(new Interval(Long.MIN_VALUE, 2))); assertEquals(true, interval37.isAfter(new Interval(Long.MIN_VALUE, 3))); assertEquals(false, interval37.isAfter(new Interval(Long.MIN_VALUE, 4))); assertEquals(false, interval37.isAfter(new Interval(6, Long.MAX_VALUE))); assertEquals(false, interval37.isAfter(new Interval(7, Long.MAX_VALUE))); assertEquals(false, interval37.isAfter(new Interval(8, Long.MAX_VALUE))); } public void testIsAfter_RInterval_null() { DateTimeUtils.setCurrentMillisFixed(2); assertEquals(true, interval37.isAfter((ReadableInterval) null)); DateTimeUtils.setCurrentMillisFixed(3); assertEquals(true, interval37.isAfter((ReadableInterval) null)); DateTimeUtils.setCurrentMillisFixed(4); assertEquals(false, interval37.isAfter((ReadableInterval) null)); DateTimeUtils.setCurrentMillisFixed(6); assertEquals(false, interval37.isAfter((ReadableInterval) null)); DateTimeUtils.setCurrentMillisFixed(7); assertEquals(false, interval37.isAfter((ReadableInterval) null)); DateTimeUtils.setCurrentMillisFixed(8); assertEquals(false, interval37.isAfter((ReadableInterval) null)); } //----------------------------------------------------------------------- public void testToInterval1() { Interval test = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS); Interval result = test.toInterval(); assertSame(test, result); } //----------------------------------------------------------------------- public void testToMutableInterval1() { Interval test = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS); MutableInterval result = test.toMutableInterval(); assertEquals(test, result); } //----------------------------------------------------------------------- public void testToPeriod() { DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10, COPTIC_PARIS); DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18, COPTIC_PARIS); Interval base = new Interval(dt1, dt2); Period test = base.toPeriod(); Period expected = new Period(dt1, dt2, PeriodType.standard()); assertEquals(expected, test); } //----------------------------------------------------------------------- public void testToPeriod_PeriodType1() { DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10, COPTIC_PARIS); DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18, COPTIC_PARIS); Interval base = new Interval(dt1, dt2); Period test = base.toPeriod(null); Period expected = new Period(dt1, dt2, PeriodType.standard()); assertEquals(expected, test); } public void testToPeriod_PeriodType2() { DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10); DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18); Interval base = new Interval(dt1, dt2); Period test = base.toPeriod(PeriodType.yearWeekDayTime()); Period expected = new Period(dt1, dt2, PeriodType.yearWeekDayTime()); assertEquals(expected, test); } //----------------------------------------------------------------------- public void testSerialization() throws Exception { Interval test = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(test); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); Interval result = (Interval) ois.readObject(); ois.close(); assertEquals(test, result); } //----------------------------------------------------------------------- public void testToString() { DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10, DateTimeZone.UTC); DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18, DateTimeZone.UTC); Interval test = new Interval(dt1, dt2); assertEquals("2004-06-09T07:08:09.010Z/2005-08-13T12:14:16.018Z", test.toString()); } public void testToString_reparse() { DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10, DateTimeZone.getDefault()); DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18, DateTimeZone.getDefault()); Interval test = new Interval(dt1, dt2); assertEquals(test, new Interval(test.toString())); } //----------------------------------------------------------------------- public void testWithChronology1() { Interval base = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS); Interval test = base.withChronology(BuddhistChronology.getInstance()); assertEquals(new Interval(TEST_TIME1, TEST_TIME2, BuddhistChronology.getInstance()), test); } public void testWithChronology2() { Interval base = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS); Interval test = base.withChronology(null); assertEquals(new Interval(TEST_TIME1, TEST_TIME2, ISOChronology.getInstance()), test); } public void testWithChronology3() { Interval base = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS); Interval test = base.withChronology(COPTIC_PARIS); assertSame(base, test); } //----------------------------------------------------------------------- public void testWithStartMillis_long1() { Interval base = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS); Interval test = base.withStartMillis(TEST_TIME1 - 1); assertEquals(new Interval(TEST_TIME1 - 1, TEST_TIME2, COPTIC_PARIS), test); } public void testWithStartMillis_long2() { Interval test = new Interval(TEST_TIME1, TEST_TIME2); try { test.withStartMillis(TEST_TIME2 + 1); fail(); } catch (IllegalArgumentException ex) {} } public void testWithStartMillis_long3() { Interval base = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS); Interval test = base.withStartMillis(TEST_TIME1); assertSame(base, test); } //----------------------------------------------------------------------- public void testWithStartInstant_RI1() { Interval base = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS); Interval test = base.withStart(new Instant(TEST_TIME1 - 1)); assertEquals(new Interval(TEST_TIME1 - 1, TEST_TIME2, COPTIC_PARIS), test); } public void testWithStartInstant_RI2() { Interval test = new Interval(TEST_TIME1, TEST_TIME2); try { test.withStart(new Instant(TEST_TIME2 + 1)); fail(); } catch (IllegalArgumentException ex) {} } public void testWithStartInstant_RI3() { Interval base = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS); Interval test = base.withStart(null); assertEquals(new Interval(TEST_TIME_NOW, TEST_TIME2, COPTIC_PARIS), test); } //----------------------------------------------------------------------- public void testWithEndMillis_long1() { Interval base = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS); Interval test = base.withEndMillis(TEST_TIME2 - 1); assertEquals(new Interval(TEST_TIME1, TEST_TIME2 - 1, COPTIC_PARIS), test); } public void testWithEndMillis_long2() { Interval test = new Interval(TEST_TIME1, TEST_TIME2); try { test.withEndMillis(TEST_TIME1 - 1); fail(); } catch (IllegalArgumentException ex) {} } public void testWithEndMillis_long3() { Interval base = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS); Interval test = base.withEndMillis(TEST_TIME2); assertSame(base, test); } //----------------------------------------------------------------------- public void testWithEndInstant_RI1() { Interval base = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS); Interval test = base.withEnd(new Instant(TEST_TIME2 - 1)); assertEquals(new Interval(TEST_TIME1, TEST_TIME2 - 1, COPTIC_PARIS), test); } public void testWithEndInstant_RI2() { Interval test = new Interval(TEST_TIME1, TEST_TIME2); try { test.withEnd(new Instant(TEST_TIME1 - 1)); fail(); } catch (IllegalArgumentException ex) {} } public void testWithEndInstant_RI3() { Interval base = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS); Interval test = base.withEnd(null); assertEquals(new Interval(TEST_TIME1, TEST_TIME_NOW, COPTIC_PARIS), test); } //----------------------------------------------------------------------- public void testWithDurationAfterStart1() throws Throwable { Duration dur = new Duration(TEST_TIME2 - TEST_TIME_NOW); Interval base = new Interval(TEST_TIME_NOW, TEST_TIME_NOW, COPTIC_PARIS); Interval test = base.withDurationAfterStart(dur); assertEquals(new Interval(TEST_TIME_NOW, TEST_TIME2, COPTIC_PARIS), test); } public void testWithDurationAfterStart2() throws Throwable { Interval base = new Interval(TEST_TIME_NOW, TEST_TIME2, COPTIC_PARIS); Interval test = base.withDurationAfterStart(null); assertEquals(new Interval(TEST_TIME_NOW, TEST_TIME_NOW, COPTIC_PARIS), test); } public void testWithDurationAfterStart3() throws Throwable { Duration dur = new Duration(-1); Interval base = new Interval(TEST_TIME_NOW, TEST_TIME_NOW); try { base.withDurationAfterStart(dur); fail(); } catch (IllegalArgumentException ex) {} } public void testWithDurationAfterStart4() throws Throwable { Interval base = new Interval(TEST_TIME_NOW, TEST_TIME2, COPTIC_PARIS); Interval test = base.withDurationAfterStart(base.toDuration()); assertSame(base, test); } //----------------------------------------------------------------------- public void testWithDurationBeforeEnd1() throws Throwable { Duration dur = new Duration(TEST_TIME_NOW - TEST_TIME1); Interval base = new Interval(TEST_TIME_NOW, TEST_TIME_NOW, COPTIC_PARIS); Interval test = base.withDurationBeforeEnd(dur); assertEquals(new Interval(TEST_TIME1, TEST_TIME_NOW, COPTIC_PARIS), test); } public void testWithDurationBeforeEnd2() throws Throwable { Interval base = new Interval(TEST_TIME_NOW, TEST_TIME2, COPTIC_PARIS); Interval test = base.withDurationBeforeEnd(null); assertEquals(new Interval(TEST_TIME2, TEST_TIME2, COPTIC_PARIS), test); } public void testWithDurationBeforeEnd3() throws Throwable { Duration dur = new Duration(-1); Interval base = new Interval(TEST_TIME_NOW, TEST_TIME_NOW); try { base.withDurationBeforeEnd(dur); fail(); } catch (IllegalArgumentException ex) {} } public void testWithDurationBeforeEnd4() throws Throwable { Interval base = new Interval(TEST_TIME_NOW, TEST_TIME2, COPTIC_PARIS); Interval test = base.withDurationBeforeEnd(base.toDuration()); assertSame(base, test); } //----------------------------------------------------------------------- public void testWithPeriodAfterStart1() throws Throwable { DateTime dt = new DateTime(TEST_TIME_NOW, COPTIC_PARIS); Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0); Interval base = new Interval(dt, dt); Interval test = base.withPeriodAfterStart(dur); assertEquals(new Interval(dt, dur), test); } public void testWithPeriodAfterStart2() throws Throwable { Interval base = new Interval(TEST_TIME_NOW, TEST_TIME2, COPTIC_PARIS); Interval test = base.withPeriodAfterStart(null); assertEquals(new Interval(TEST_TIME_NOW, TEST_TIME_NOW, COPTIC_PARIS), test); } public void testWithPeriodAfterStart3() throws Throwable { Period per = new Period(0, 0, 0, 0, 0, 0, 0, -1); Interval base = new Interval(TEST_TIME_NOW, TEST_TIME_NOW); try { base.withPeriodAfterStart(per); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testWithPeriodBeforeEnd1() throws Throwable { DateTime dt = new DateTime(TEST_TIME_NOW, COPTIC_PARIS); Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0); Interval base = new Interval(dt, dt); Interval test = base.withPeriodBeforeEnd(dur); assertEquals(new Interval(dur, dt), test); } public void testWithPeriodBeforeEnd2() throws Throwable { Interval base = new Interval(TEST_TIME_NOW, TEST_TIME2, COPTIC_PARIS); Interval test = base.withPeriodBeforeEnd(null); assertEquals(new Interval(TEST_TIME2, TEST_TIME2, COPTIC_PARIS), test); } public void testWithPeriodBeforeEnd3() throws Throwable { Period per = new Period(0, 0, 0, 0, 0, 0, 0, -1); Interval base = new Interval(TEST_TIME_NOW, TEST_TIME_NOW); try { base.withPeriodBeforeEnd(per); fail(); } catch (IllegalArgumentException ex) {} } }
/* * Copyright 2001-2006 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.BuddhistChronology; import org.joda.time.chrono.CopticChronology; import org.joda.time.chrono.GJChronology; import org.joda.time.chrono.ISOChronology; import org.joda.time.convert.ConverterManager; import org.joda.time.convert.IntervalConverter; /** * This class is a JUnit test for Interval. * * @author Stephen Colebourne */ public class TestInterval_Constructors extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; // // 2002-04-05 // private long TEST_TIME1 = // (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY // + 12L * DateTimeConstants.MILLIS_PER_HOUR // + 24L * DateTimeConstants.MILLIS_PER_MINUTE; // // // 2003-05-06 // private long TEST_TIME2 = // (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY // + 14L * DateTimeConstants.MILLIS_PER_HOUR // + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestInterval_Constructors.class); } public TestInterval_Constructors(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(PARIS); TimeZone.setDefault(PARIS.toTimeZone()); Locale.setDefault(Locale.FRANCE); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testParse_noFormatter() throws Throwable { DateTime start = new DateTime(2010, 6, 30, 12, 30, ISOChronology.getInstance(PARIS)); DateTime end = new DateTime(2010, 7, 1, 14, 30, ISOChronology.getInstance(PARIS)); assertEquals(new Interval(start, end), Interval.parse("2010-06-30T12:30/2010-07-01T14:30")); assertEquals(new Interval(start, end), Interval.parse("2010-06-30T12:30/P1DT2H")); assertEquals(new Interval(start, end), Interval.parse("P1DT2H/2010-07-01T14:30")); } //----------------------------------------------------------------------- public void testConstructor_long_long1() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); Interval test = new Interval(dt1.getMillis(), dt2.getMillis()); assertEquals(dt1.getMillis(), test.getStartMillis()); assertEquals(dt2.getMillis(), test.getEndMillis()); assertEquals(ISOChronology.getInstance(), test.getChronology()); } public void testConstructor_long_long2() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); Interval test = new Interval(dt1.getMillis(), dt1.getMillis()); assertEquals(dt1.getMillis(), test.getStartMillis()); assertEquals(dt1.getMillis(), test.getEndMillis()); assertEquals(ISOChronology.getInstance(), test.getChronology()); } public void testConstructor_long_long3() throws Throwable { DateTime dt1 = new DateTime(2005, 7, 10, 1, 1, 1, 1); DateTime dt2 = new DateTime(2004, 6, 9, 0, 0, 0, 0); try { new Interval(dt1.getMillis(), dt2.getMillis()); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testConstructor_long_long_Zone() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); Interval test = new Interval(dt1.getMillis(), dt2.getMillis(), LONDON); assertEquals(dt1.getMillis(), test.getStartMillis()); assertEquals(dt2.getMillis(), test.getEndMillis()); assertEquals(ISOChronology.getInstance(LONDON), test.getChronology()); } public void testConstructor_long_long_nullZone() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); Interval test = new Interval(dt1.getMillis(), dt2.getMillis(), (DateTimeZone) null); assertEquals(dt1.getMillis(), test.getStartMillis()); assertEquals(dt2.getMillis(), test.getEndMillis()); assertEquals(ISOChronology.getInstance(), test.getChronology()); } //----------------------------------------------------------------------- public void testConstructor_long_long_Chronology() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); Interval test = new Interval(dt1.getMillis(), dt2.getMillis(), GJChronology.getInstance()); assertEquals(dt1.getMillis(), test.getStartMillis()); assertEquals(dt2.getMillis(), test.getEndMillis()); assertEquals(GJChronology.getInstance(), test.getChronology()); } public void testConstructor_long_long_nullChronology() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); Interval test = new Interval(dt1.getMillis(), dt2.getMillis(), (Chronology) null); assertEquals(dt1.getMillis(), test.getStartMillis()); assertEquals(dt2.getMillis(), test.getEndMillis()); assertEquals(ISOChronology.getInstance(), test.getChronology()); } //----------------------------------------------------------------------- public void testConstructor_RI_RI1() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); Interval test = new Interval(dt1, dt2); assertEquals(dt1.getMillis(), test.getStartMillis()); assertEquals(dt2.getMillis(), test.getEndMillis()); } public void testConstructor_RI_RI2() throws Throwable { Instant dt1 = new Instant(new DateTime(2004, 6, 9, 0, 0, 0, 0)); Instant dt2 = new Instant(new DateTime(2005, 7, 10, 1, 1, 1, 1)); Interval test = new Interval(dt1, dt2); assertEquals(dt1.getMillis(), test.getStartMillis()); assertEquals(dt2.getMillis(), test.getEndMillis()); } public void testConstructor_RI_RI3() throws Throwable { Interval test = new Interval((ReadableInstant) null, (ReadableInstant) null); assertEquals(TEST_TIME_NOW, test.getStartMillis()); assertEquals(TEST_TIME_NOW, test.getEndMillis()); } public void testConstructor_RI_RI4() throws Throwable { DateTime dt1 = new DateTime(2000, 6, 9, 0, 0, 0, 0); Interval test = new Interval(dt1, (ReadableInstant) null); assertEquals(dt1.getMillis(), test.getStartMillis()); assertEquals(TEST_TIME_NOW, test.getEndMillis()); } public void testConstructor_RI_RI5() throws Throwable { DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); Interval test = new Interval((ReadableInstant) null, dt2); assertEquals(TEST_TIME_NOW, test.getStartMillis()); assertEquals(dt2.getMillis(), test.getEndMillis()); } public void testConstructor_RI_RI6() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); Interval test = new Interval(dt1, dt1); assertEquals(dt1.getMillis(), test.getStartMillis()); assertEquals(dt1.getMillis(), test.getEndMillis()); } public void testConstructor_RI_RI7() throws Throwable { DateTime dt1 = new DateTime(2005, 7, 10, 1, 1, 1, 1); DateTime dt2 = new DateTime(2004, 6, 9, 0, 0, 0, 0); try { new Interval(dt1, dt2); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_RI_RI_chronoStart() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0, GJChronology.getInstance()); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); Interval test = new Interval(dt1, dt2); assertEquals(dt1.getMillis(), test.getStartMillis()); assertEquals(dt2.getMillis(), test.getEndMillis()); assertEquals(GJChronology.getInstance(), test.getChronology()); } public void testConstructor_RI_RI_chronoEnd() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1, GJChronology.getInstance()); Interval test = new Interval(dt1, dt2); assertEquals(dt1.getMillis(), test.getStartMillis()); assertEquals(dt2.getMillis(), test.getEndMillis()); assertEquals(ISOChronology.getInstance(), test.getChronology()); } public void testConstructor_RI_RI_zones() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0, LONDON); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1, PARIS); Interval test = new Interval(dt1, dt2); assertEquals(dt1.getMillis(), test.getStartMillis()); assertEquals(dt2.getMillis(), test.getEndMillis()); assertEquals(ISOChronology.getInstance(LONDON), test.getChronology()); } public void testConstructor_RI_RI_instant() throws Throwable { Instant dt1 = new Instant(12345678L); Instant dt2 = new Instant(22345678L); Interval test = new Interval(dt1, dt2); assertEquals(12345678L, test.getStartMillis()); assertEquals(22345678L, test.getEndMillis()); assertEquals(ISOChronology.getInstanceUTC(), test.getChronology()); } //----------------------------------------------------------------------- public void testConstructor_RI_RP1() throws Throwable { DateTime dt = new DateTime(TEST_TIME_NOW); Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0); long result = TEST_TIME_NOW; result = ISOChronology.getInstance().months().add(result, 6); result = ISOChronology.getInstance().hours().add(result, 1); Interval test = new Interval(dt, dur); assertEquals(dt.getMillis(), test.getStartMillis()); assertEquals(result, test.getEndMillis()); } public void testConstructor_RI_RP2() throws Throwable { Instant dt = new Instant(new DateTime(TEST_TIME_NOW)); Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0); long result = TEST_TIME_NOW; result = ISOChronology.getInstanceUTC().months().add(result, 6); result = ISOChronology.getInstanceUTC().days().add(result, 3); result = ISOChronology.getInstanceUTC().hours().add(result, 1); Interval test = new Interval(dt, dur); assertEquals(dt.getMillis(), test.getStartMillis()); assertEquals(result, test.getEndMillis()); } public void testConstructor_RI_RP3() throws Throwable { DateTime dt = new DateTime(TEST_TIME_NOW, CopticChronology.getInstanceUTC()); Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.standard()); long result = TEST_TIME_NOW; result = CopticChronology.getInstanceUTC().months().add(result, 6); result = CopticChronology.getInstanceUTC().days().add(result, 3); result = CopticChronology.getInstanceUTC().hours().add(result, 1); Interval test = new Interval(dt, dur); assertEquals(dt.getMillis(), test.getStartMillis()); assertEquals(result, test.getEndMillis()); } public void testConstructor_RI_RP4() throws Throwable { DateTime dt = new DateTime(TEST_TIME_NOW); Period dur = new Period(1 * DateTimeConstants.MILLIS_PER_HOUR + 23L); long result = TEST_TIME_NOW; result = ISOChronology.getInstance().hours().add(result, 1); result = ISOChronology.getInstance().millis().add(result, 23); Interval test = new Interval(dt, dur); assertEquals(dt.getMillis(), test.getStartMillis()); assertEquals(result, test.getEndMillis()); } public void testConstructor_RI_RP5() throws Throwable { Interval test = new Interval((ReadableInstant) null, (ReadablePeriod) null); assertEquals(TEST_TIME_NOW, test.getStartMillis()); assertEquals(TEST_TIME_NOW, test.getEndMillis()); } public void testConstructor_RI_RP6() throws Throwable { DateTime dt = new DateTime(TEST_TIME_NOW); Interval test = new Interval(dt, (ReadablePeriod) null); assertEquals(dt.getMillis(), test.getStartMillis()); assertEquals(dt.getMillis(), test.getEndMillis()); } public void testConstructor_RI_RP7() throws Throwable { Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0); long result = TEST_TIME_NOW; result = ISOChronology.getInstance().monthOfYear().add(result, 6); result = ISOChronology.getInstance().hourOfDay().add(result, 1); Interval test = new Interval((ReadableInstant) null, dur); assertEquals(TEST_TIME_NOW, test.getStartMillis()); assertEquals(result, test.getEndMillis()); } public void testConstructor_RI_RP8() throws Throwable { DateTime dt = new DateTime(TEST_TIME_NOW); Period dur = new Period(0, 0, 0, 0, 0, 0, 0, -1); try { new Interval(dt, dur); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testConstructor_RP_RI1() throws Throwable { DateTime dt = new DateTime(TEST_TIME_NOW); Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0); long result = TEST_TIME_NOW; result = ISOChronology.getInstance().months().add(result, -6); result = ISOChronology.getInstance().hours().add(result, -1); Interval test = new Interval(dur, dt); assertEquals(result, test.getStartMillis()); assertEquals(dt.getMillis(), test.getEndMillis()); } public void testConstructor_RP_RI2() throws Throwable { Instant dt = new Instant(new DateTime(TEST_TIME_NOW)); Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0); long result = TEST_TIME_NOW; result = ISOChronology.getInstanceUTC().months().add(result, -6); result = ISOChronology.getInstanceUTC().days().add(result, -3); result = ISOChronology.getInstanceUTC().hours().add(result, -1); Interval test = new Interval(dur, dt); assertEquals(result, test.getStartMillis()); assertEquals(dt.getMillis(), test.getEndMillis()); } public void testConstructor_RP_RI3() throws Throwable { DateTime dt = new DateTime(TEST_TIME_NOW, CopticChronology.getInstanceUTC()); Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.standard()); long result = TEST_TIME_NOW; result = CopticChronology.getInstanceUTC().months().add(result, -6); result = CopticChronology.getInstanceUTC().days().add(result, -3); result = CopticChronology.getInstanceUTC().hours().add(result, -1); Interval test = new Interval(dur, dt); assertEquals(result, test.getStartMillis()); assertEquals(dt.getMillis(), test.getEndMillis()); } public void testConstructor_RP_RI4() throws Throwable { DateTime dt = new DateTime(TEST_TIME_NOW); Period dur = new Period(1 * DateTimeConstants.MILLIS_PER_HOUR + 23L); long result = TEST_TIME_NOW; result = ISOChronology.getInstance().hours().add(result, -1); result = ISOChronology.getInstance().millis().add(result, -23); Interval test = new Interval(dur, dt); assertEquals(result, test.getStartMillis()); assertEquals(dt.getMillis(), test.getEndMillis()); } public void testConstructor_RP_RI5() throws Throwable { Interval test = new Interval((ReadablePeriod) null, (ReadableInstant) null); assertEquals(TEST_TIME_NOW, test.getStartMillis()); assertEquals(TEST_TIME_NOW, test.getEndMillis()); } public void testConstructor_RP_RI6() throws Throwable { DateTime dt = new DateTime(TEST_TIME_NOW); Interval test = new Interval((ReadablePeriod) null, dt); assertEquals(dt.getMillis(), test.getStartMillis()); assertEquals(dt.getMillis(), test.getEndMillis()); } public void testConstructor_RP_RI7() throws Throwable { Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0); long result = TEST_TIME_NOW; result = ISOChronology.getInstance().monthOfYear().add(result, -6); result = ISOChronology.getInstance().hourOfDay().add(result, -1); Interval test = new Interval(dur, (ReadableInstant) null); assertEquals(result, test.getStartMillis()); assertEquals(TEST_TIME_NOW, test.getEndMillis()); } public void testConstructor_RP_RI8() throws Throwable { DateTime dt = new DateTime(TEST_TIME_NOW); Period dur = new Period(0, 0, 0, 0, 0, 0, 0, -1); try { new Interval(dur, dt); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testConstructor_RI_RD1() throws Throwable { long result = TEST_TIME_NOW; result = ISOChronology.getInstance().months().add(result, 6); result = ISOChronology.getInstance().hours().add(result, 1); DateTime dt = new DateTime(TEST_TIME_NOW); Duration dur = new Duration(result - TEST_TIME_NOW); Interval test = new Interval(dt, dur); assertEquals(dt.getMillis(), test.getStartMillis()); assertEquals(result, test.getEndMillis()); } public void testConstructor_RI_RD2() throws Throwable { Interval test = new Interval((ReadableInstant) null, (ReadableDuration) null); assertEquals(TEST_TIME_NOW, test.getStartMillis()); assertEquals(TEST_TIME_NOW, test.getEndMillis()); } public void testConstructor_RI_RD3() throws Throwable { DateTime dt = new DateTime(TEST_TIME_NOW); Interval test = new Interval(dt, (ReadableDuration) null); assertEquals(dt.getMillis(), test.getStartMillis()); assertEquals(dt.getMillis(), test.getEndMillis()); } public void testConstructor_RI_RD4() throws Throwable { long result = TEST_TIME_NOW; result = ISOChronology.getInstance().monthOfYear().add(result, 6); result = ISOChronology.getInstance().hourOfDay().add(result, 1); Duration dur = new Duration(result - TEST_TIME_NOW); Interval test = new Interval((ReadableInstant) null, dur); assertEquals(TEST_TIME_NOW, test.getStartMillis()); assertEquals(result, test.getEndMillis()); } public void testConstructor_RI_RD5() throws Throwable { DateTime dt = new DateTime(TEST_TIME_NOW); Duration dur = new Duration(-1); try { new Interval(dt, dur); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testConstructor_RD_RI1() throws Throwable { long result = TEST_TIME_NOW; result = ISOChronology.getInstance().months().add(result, -6); result = ISOChronology.getInstance().hours().add(result, -1); DateTime dt = new DateTime(TEST_TIME_NOW); Duration dur = new Duration(TEST_TIME_NOW - result); Interval test = new Interval(dur, dt); assertEquals(result, test.getStartMillis()); assertEquals(dt.getMillis(), test.getEndMillis()); } public void testConstructor_RD_RI2() throws Throwable { Interval test = new Interval((ReadableDuration) null, (ReadableInstant) null); assertEquals(TEST_TIME_NOW, test.getStartMillis()); assertEquals(TEST_TIME_NOW, test.getEndMillis()); } public void testConstructor_RD_RI3() throws Throwable { DateTime dt = new DateTime(TEST_TIME_NOW); Interval test = new Interval((ReadableDuration) null, dt); assertEquals(dt.getMillis(), test.getStartMillis()); assertEquals(dt.getMillis(), test.getEndMillis()); } public void testConstructor_RD_RI4() throws Throwable { long result = TEST_TIME_NOW; result = ISOChronology.getInstance().monthOfYear().add(result, -6); result = ISOChronology.getInstance().hourOfDay().add(result, -1); Duration dur = new Duration(TEST_TIME_NOW - result); Interval test = new Interval(dur, (ReadableInstant) null); assertEquals(result, test.getStartMillis()); assertEquals(TEST_TIME_NOW, test.getEndMillis()); } public void testConstructor_RD_RI5() throws Throwable { DateTime dt = new DateTime(TEST_TIME_NOW); Duration dur = new Duration(-1); try { new Interval(dur, dt); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testConstructor_Object1() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); Interval test = new Interval(dt1.toString() + '/' + dt2.toString()); assertEquals(dt1.getMillis(), test.getStartMillis()); assertEquals(dt2.getMillis(), test.getEndMillis()); } public void testConstructor_Object2() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); Interval base = new Interval(dt1, dt2); Interval test = new Interval(base); assertEquals(dt1.getMillis(), test.getStartMillis()); assertEquals(dt2.getMillis(), test.getEndMillis()); } public void testConstructor_Object3() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); MutableInterval base = new MutableInterval(dt1, dt2); Interval test = new Interval(base); assertEquals(dt1.getMillis(), test.getStartMillis()); assertEquals(dt2.getMillis(), test.getEndMillis()); } public void testConstructor_Object4() throws Throwable { MockInterval base = new MockInterval(); Interval test = new Interval(base); assertEquals(base.getStartMillis(), test.getStartMillis()); assertEquals(base.getEndMillis(), test.getEndMillis()); } public void testConstructor_Object5() throws Throwable { IntervalConverter oldConv = ConverterManager.getInstance().getIntervalConverter(""); IntervalConverter conv = new IntervalConverter() { public boolean isReadableInterval(Object object, Chronology chrono) { return false; } public void setInto(ReadWritableInterval interval, Object object, Chronology chrono) { interval.setChronology(chrono); interval.setInterval(1234L, 5678L); } public Class<?> getSupportedType() { return String.class; } }; try { ConverterManager.getInstance().addIntervalConverter(conv); DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); Interval test = new Interval(dt1.toString() + '/' + dt2.toString()); assertEquals(1234L, test.getStartMillis()); assertEquals(5678L, test.getEndMillis()); } finally { ConverterManager.getInstance().addIntervalConverter(oldConv); } } public void testConstructor_Object6() throws Throwable { IntervalConverter oldConv = ConverterManager.getInstance().getIntervalConverter(new Interval(0L, 0L)); IntervalConverter conv = new IntervalConverter() { public boolean isReadableInterval(Object object, Chronology chrono) { return false; } public void setInto(ReadWritableInterval interval, Object object, Chronology chrono) { interval.setChronology(chrono); interval.setInterval(1234L, 5678L); } public Class<?> getSupportedType() { return ReadableInterval.class; } }; try { ConverterManager.getInstance().addIntervalConverter(conv); Interval base = new Interval(-1000L, 1000L); Interval test = new Interval(base); assertEquals(1234L, test.getStartMillis()); assertEquals(5678L, test.getEndMillis()); } finally { ConverterManager.getInstance().addIntervalConverter(oldConv); } } class MockInterval implements ReadableInterval { public Chronology getChronology() { return ISOChronology.getInstance(); } public long getStartMillis() { return 1234L; } public DateTime getStart() { return new DateTime(1234L); } public long getEndMillis() { return 5678L; } public DateTime getEnd() { return new DateTime(5678L); } public long toDurationMillis() { return (5678L - 1234L); } public Duration toDuration() { return new Duration(5678L - 1234L); } public boolean contains(long millisInstant) { return false; } public boolean containsNow() { return false; } public boolean contains(ReadableInstant instant) { return false; } public boolean contains(ReadableInterval interval) { return false; } public boolean overlaps(ReadableInterval interval) { return false; } public boolean isBefore(ReadableInstant instant) { return false; } public boolean isBefore(ReadableInterval interval) { return false; } public boolean isAfter(ReadableInstant instant) { return false; } public boolean isAfter(ReadableInterval interval) { return false; } public Interval toInterval() { return null; } public MutableInterval toMutableInterval() { return null; } public Period toPeriod() { return null; } public Period toPeriod(PeriodType type) { return null; } } //----------------------------------------------------------------------- public void testConstructor_Object_Chronology1() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); Interval base = new Interval(dt1, dt2); Interval test = new Interval(base, BuddhistChronology.getInstance()); assertEquals(dt1.getMillis(), test.getStartMillis()); assertEquals(dt2.getMillis(), test.getEndMillis()); assertEquals(BuddhistChronology.getInstance(), test.getChronology()); } public void testConstructor_Object_Chronology2() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); Interval base = new Interval(dt1, dt2); Interval test = new Interval(base, null); assertEquals(dt1.getMillis(), test.getStartMillis()); assertEquals(dt2.getMillis(), test.getEndMillis()); assertEquals(ISOChronology.getInstance(), test.getChronology()); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Arrays; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import java.util.Locale; import java.util.SimpleTimeZone; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.BuddhistChronology; import org.joda.time.chrono.CopticChronology; import org.joda.time.chrono.GJChronology; import org.joda.time.chrono.GregorianChronology; import org.joda.time.chrono.ISOChronology; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; /** * This class is a Junit unit test for LocalDate. * * @author Stephen Colebourne */ public class TestLocalDateTime_Basics extends TestCase { private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo"); private static final GJChronology GJ_UTC = GJChronology.getInstanceUTC(); private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS); private static final Chronology COPTIC_LONDON = CopticChronology.getInstance(LONDON); private static final Chronology COPTIC_TOKYO = CopticChronology.getInstance(TOKYO); private static final Chronology COPTIC_UTC = CopticChronology.getInstanceUTC(); private static final Chronology ISO_LONDON = ISOChronology.getInstance(LONDON); private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC(); private static final Chronology GREGORIAN_UTC = GregorianChronology.getInstanceUTC(); private static final Chronology BUDDHIST_LONDON = BuddhistChronology.getInstance(LONDON); private static final Chronology BUDDHIST_TOKYO = BuddhistChronology.getInstance(TOKYO); // private long TEST_TIME1 = // (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY // + 12L * DateTimeConstants.MILLIS_PER_HOUR // + 24L * DateTimeConstants.MILLIS_PER_MINUTE; // // private long TEST_TIME2 = // (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY // + 14L * DateTimeConstants.MILLIS_PER_HOUR // + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private int MILLIS_OF_DAY_UTC = (int) (10L * DateTimeConstants.MILLIS_PER_HOUR + 20L * DateTimeConstants.MILLIS_PER_MINUTE + 30L * DateTimeConstants.MILLIS_PER_SECOND + 40L); private long TEST_TIME_NOW_UTC = (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY + MILLIS_OF_DAY_UTC; private DateTimeZone zone = null; private Locale systemDefaultLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestLocalDateTime_Basics.class); } public TestLocalDateTime_Basics(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW_UTC); zone = DateTimeZone.getDefault(); DateTimeZone.setDefault(LONDON); systemDefaultLocale = Locale.getDefault(); Locale.setDefault(Locale.ENGLISH); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(zone); zone = null; Locale.setDefault(systemDefaultLocale); systemDefaultLocale = null; } //----------------------------------------------------------------------- public void testGet_DateTimeFieldType() { LocalDateTime test = new LocalDateTime(1970, 6, 9, 10, 20, 30, 40); assertEquals(1970, test.get(DateTimeFieldType.year())); assertEquals(6, test.get(DateTimeFieldType.monthOfYear())); assertEquals(9, test.get(DateTimeFieldType.dayOfMonth())); assertEquals(2, test.get(DateTimeFieldType.dayOfWeek())); assertEquals(160, test.get(DateTimeFieldType.dayOfYear())); assertEquals(24, test.get(DateTimeFieldType.weekOfWeekyear())); assertEquals(1970, test.get(DateTimeFieldType.weekyear())); assertEquals(10, test.get(DateTimeFieldType.hourOfDay())); assertEquals(20, test.get(DateTimeFieldType.minuteOfHour())); assertEquals(30, test.get(DateTimeFieldType.secondOfMinute())); assertEquals(40, test.get(DateTimeFieldType.millisOfSecond())); assertEquals(MILLIS_OF_DAY_UTC / 60000 , test.get(DateTimeFieldType.minuteOfDay())); assertEquals(MILLIS_OF_DAY_UTC / 1000 , test.get(DateTimeFieldType.secondOfDay())); assertEquals(MILLIS_OF_DAY_UTC , test.get(DateTimeFieldType.millisOfDay())); assertEquals(10, test.get(DateTimeFieldType.hourOfHalfday())); assertEquals(DateTimeConstants.AM, test.get(DateTimeFieldType.halfdayOfDay())); test = new LocalDateTime(1970, 6, 9, 12, 30); assertEquals(0, test.get(DateTimeFieldType.hourOfHalfday())); assertEquals(12, test.get(DateTimeFieldType.clockhourOfHalfday())); assertEquals(12, test.get(DateTimeFieldType.clockhourOfDay())); assertEquals(DateTimeConstants.PM, test.get(DateTimeFieldType.halfdayOfDay())); test = new LocalDateTime(1970, 6, 9, 14, 30); assertEquals(2, test.get(DateTimeFieldType.hourOfHalfday())); assertEquals(2, test.get(DateTimeFieldType.clockhourOfHalfday())); assertEquals(14, test.get(DateTimeFieldType.clockhourOfDay())); assertEquals(DateTimeConstants.PM, test.get(DateTimeFieldType.halfdayOfDay())); test = new LocalDateTime(1970, 6, 9, 0, 30); assertEquals(0, test.get(DateTimeFieldType.hourOfHalfday())); assertEquals(12, test.get(DateTimeFieldType.clockhourOfHalfday())); assertEquals(24, test.get(DateTimeFieldType.clockhourOfDay())); assertEquals(DateTimeConstants.AM, test.get(DateTimeFieldType.halfdayOfDay())); try { test.get(null); fail(); } catch (IllegalArgumentException ex) {} } public void testSize() { LocalDateTime test = new LocalDateTime(); assertEquals(4, test.size()); } public void testGetFieldType_int() { LocalDateTime test = new LocalDateTime(COPTIC_PARIS); assertSame(DateTimeFieldType.year(), test.getFieldType(0)); assertSame(DateTimeFieldType.monthOfYear(), test.getFieldType(1)); assertSame(DateTimeFieldType.dayOfMonth(), test.getFieldType(2)); assertSame(DateTimeFieldType.millisOfDay(), test.getFieldType(3)); try { test.getFieldType(-1); } catch (IndexOutOfBoundsException ex) {} try { test.getFieldType(3); } catch (IndexOutOfBoundsException ex) {} } public void testGetFieldTypes() { LocalDateTime test = new LocalDateTime(COPTIC_PARIS); DateTimeFieldType[] fields = test.getFieldTypes(); assertSame(DateTimeFieldType.year(), fields[0]); assertSame(DateTimeFieldType.monthOfYear(), fields[1]); assertSame(DateTimeFieldType.dayOfMonth(), fields[2]); assertSame(DateTimeFieldType.millisOfDay(), fields[3]); assertNotSame(test.getFieldTypes(), test.getFieldTypes()); } public void testGetField_int() { LocalDateTime test = new LocalDateTime(COPTIC_PARIS); assertSame(COPTIC_UTC.year(), test.getField(0)); assertSame(COPTIC_UTC.monthOfYear(), test.getField(1)); assertSame(COPTIC_UTC.dayOfMonth(), test.getField(2)); assertSame(COPTIC_UTC.millisOfDay(), test.getField(3)); try { test.getField(-1); } catch (IndexOutOfBoundsException ex) {} try { test.getField(3); } catch (IndexOutOfBoundsException ex) {} } public void testGetFields() { LocalDateTime test = new LocalDateTime(COPTIC_PARIS); DateTimeField[] fields = test.getFields(); assertSame(COPTIC_UTC.year(), fields[0]); assertSame(COPTIC_UTC.monthOfYear(), fields[1]); assertSame(COPTIC_UTC.dayOfMonth(), fields[2]); assertSame(COPTIC_UTC.millisOfDay(), fields[3]); assertNotSame(test.getFields(), test.getFields()); } public void testGetValue_int() { LocalDateTime test = new LocalDateTime(ISO_UTC); assertEquals(1970, test.getValue(0)); assertEquals(6, test.getValue(1)); assertEquals(9, test.getValue(2)); assertEquals(MILLIS_OF_DAY_UTC, test.getValue(3)); try { test.getValue(-1); } catch (IndexOutOfBoundsException ex) {} try { test.getValue(3); } catch (IndexOutOfBoundsException ex) {} } public void testGetValues() { LocalDateTime test = new LocalDateTime(ISO_UTC); int[] values = test.getValues(); assertEquals(1970, values[0]); assertEquals(6, values[1]); assertEquals(9, values[2]); assertEquals(MILLIS_OF_DAY_UTC, values[3]); assertNotSame(test.getValues(), test.getValues()); } public void testIsSupported_DateTimeFieldType() { LocalDateTime test = new LocalDateTime(); assertEquals(true, test.isSupported(DateTimeFieldType.year())); assertEquals(true, test.isSupported(DateTimeFieldType.monthOfYear())); assertEquals(true, test.isSupported(DateTimeFieldType.dayOfMonth())); assertEquals(true, test.isSupported(DateTimeFieldType.dayOfWeek())); assertEquals(true, test.isSupported(DateTimeFieldType.dayOfYear())); assertEquals(true, test.isSupported(DateTimeFieldType.weekOfWeekyear())); assertEquals(true, test.isSupported(DateTimeFieldType.weekyear())); assertEquals(true, test.isSupported(DateTimeFieldType.yearOfCentury())); assertEquals(true, test.isSupported(DateTimeFieldType.yearOfEra())); assertEquals(true, test.isSupported(DateTimeFieldType.centuryOfEra())); assertEquals(true, test.isSupported(DateTimeFieldType.weekyearOfCentury())); assertEquals(true, test.isSupported(DateTimeFieldType.era())); assertEquals(true, test.isSupported(DateTimeFieldType.hourOfDay())); assertEquals(true, test.isSupported(DateTimeFieldType.minuteOfHour())); assertEquals(true, test.isSupported(DateTimeFieldType.secondOfMinute())); assertEquals(true, test.isSupported(DateTimeFieldType.millisOfSecond())); assertEquals(true, test.isSupported(DateTimeFieldType.minuteOfDay())); assertEquals(true, test.isSupported(DateTimeFieldType.secondOfDay())); assertEquals(true, test.isSupported(DateTimeFieldType.millisOfDay())); assertEquals(true, test.isSupported(DateTimeFieldType.hourOfHalfday())); assertEquals(true, test.isSupported(DateTimeFieldType.halfdayOfDay())); assertEquals(true, test.isSupported(DateTimeFieldType.clockhourOfHalfday())); assertEquals(true, test.isSupported(DateTimeFieldType.clockhourOfDay())); assertEquals(false, test.isSupported((DateTimeFieldType) null)); } public void testIsSupported_DurationFieldType() { LocalDateTime test = new LocalDateTime(); assertEquals(false, test.isSupported(DurationFieldType.eras())); assertEquals(true, test.isSupported(DurationFieldType.centuries())); assertEquals(true, test.isSupported(DurationFieldType.years())); assertEquals(true, test.isSupported(DurationFieldType.months())); assertEquals(true, test.isSupported(DurationFieldType.weekyears())); assertEquals(true, test.isSupported(DurationFieldType.weeks())); assertEquals(true, test.isSupported(DurationFieldType.days())); assertEquals(true, test.isSupported(DurationFieldType.hours())); assertEquals(true, test.isSupported(DurationFieldType.minutes())); assertEquals(true, test.isSupported(DurationFieldType.seconds())); assertEquals(true, test.isSupported(DurationFieldType.millis())); assertEquals(true, test.isSupported(DurationFieldType.halfdays())); assertEquals(false, test.isSupported((DurationFieldType) null)); } public void testEqualsHashCode() { LocalDateTime test1 = new LocalDateTime(1970, 6, 9, 10, 20, 30, 40, COPTIC_PARIS); LocalDateTime test2 = new LocalDateTime(1970, 6, 9, 10, 20, 30, 40, COPTIC_PARIS); assertEquals(true, test1.equals(test2)); assertEquals(true, test2.equals(test1)); assertEquals(true, test1.equals(test1)); assertEquals(true, test2.equals(test2)); assertEquals(true, test1.hashCode() == test2.hashCode()); assertEquals(true, test1.hashCode() == test1.hashCode()); assertEquals(true, test2.hashCode() == test2.hashCode()); LocalDateTime test3 = new LocalDateTime(1971, 6, 9, 10, 20, 30, 40); assertEquals(false, test1.equals(test3)); assertEquals(false, test2.equals(test3)); assertEquals(false, test3.equals(test1)); assertEquals(false, test3.equals(test2)); assertEquals(false, test1.hashCode() == test3.hashCode()); assertEquals(false, test2.hashCode() == test3.hashCode()); assertEquals(false, test1.equals("Hello")); assertEquals(true, test1.equals(new MockInstant())); Partial partial = new Partial( new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.millisOfDay()}, new int[] {1970, 6, 9, MILLIS_OF_DAY_UTC}, COPTIC_PARIS); assertEquals(true, test1.equals(partial)); assertEquals(true, test1.hashCode() == partial.hashCode()); assertEquals(false, test1.equals(MockPartial.EMPTY_INSTANCE)); } class MockInstant extends MockPartial { public Chronology getChronology() { return COPTIC_UTC; } public DateTimeField[] getFields() { return new DateTimeField[] { COPTIC_UTC.year(), COPTIC_UTC.monthOfYear(), COPTIC_UTC.dayOfMonth(), COPTIC_UTC.millisOfDay(), }; } public int[] getValues() { return new int[] {1970, 6, 9, MILLIS_OF_DAY_UTC}; } } //----------------------------------------------------------------------- public void testCompareTo() { LocalDateTime test1 = new LocalDateTime(2005, 6, 2, 10, 20, 30, 40); LocalDateTime test1a = new LocalDateTime(2005, 6, 2, 10, 20, 30, 40); assertEquals(0, test1.compareTo(test1a)); assertEquals(0, test1a.compareTo(test1)); assertEquals(0, test1.compareTo(test1)); assertEquals(0, test1a.compareTo(test1a)); LocalDateTime test2 = new LocalDateTime(2005, 7, 2, 10, 20, 30, 40); assertEquals(-1, test1.compareTo(test2)); assertEquals(+1, test2.compareTo(test1)); LocalDateTime test3 = new LocalDateTime(2005, 7, 2, 10, 20, 30, 40, GREGORIAN_UTC); assertEquals(-1, test1.compareTo(test3)); assertEquals(+1, test3.compareTo(test1)); assertEquals(0, test3.compareTo(test2)); DateTimeFieldType[] types = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.millisOfDay(), }; int[] values = new int[] {2005, 6, 2, MILLIS_OF_DAY_UTC}; Partial p = new Partial(types, values); assertEquals(0, test1.compareTo(p)); try { test1.compareTo(null); fail(); } catch (NullPointerException ex) {} // try { // test1.compareTo(new Date()); // fail(); // } catch (ClassCastException ex) {} try { @SuppressWarnings("deprecation") YearMonthDay ymd = new YearMonthDay(); test1.compareTo(ymd); fail(); } catch (ClassCastException ex) {} try { @SuppressWarnings("deprecation") TimeOfDay tod = new TimeOfDay(); test1.compareTo(tod); fail(); } catch (ClassCastException ex) {} Partial partial = new Partial() .with(DateTimeFieldType.centuryOfEra(), 1) .with(DateTimeFieldType.halfdayOfDay(), 0) .with(DateTimeFieldType.dayOfMonth(), 9); try { new LocalDateTime(1970, 6, 9, 10, 20, 30, 40).compareTo(partial); fail(); } catch (ClassCastException ex) {} } //----------------------------------------------------------------------- public void testIsEqual_LocalDateTime() { LocalDateTime test1 = new LocalDateTime(2005, 6, 2, 10, 20, 30, 40); LocalDateTime test1a = new LocalDateTime(2005, 6, 2, 10, 20, 30, 40); assertEquals(true, test1.isEqual(test1a)); assertEquals(true, test1a.isEqual(test1)); assertEquals(true, test1.isEqual(test1)); assertEquals(true, test1a.isEqual(test1a)); LocalDateTime test2 = new LocalDateTime(2005, 7, 2, 10, 20, 30, 40); assertEquals(false, test1.isEqual(test2)); assertEquals(false, test2.isEqual(test1)); LocalDateTime test3 = new LocalDateTime(2005, 7, 2, 10, 20, 30, 40, GREGORIAN_UTC); assertEquals(false, test1.isEqual(test3)); assertEquals(false, test3.isEqual(test1)); assertEquals(true, test3.isEqual(test2)); try { new LocalDateTime(2005, 7, 2, 10, 20, 30, 40).isEqual(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testIsBefore_LocalDateTime() { LocalDateTime test1 = new LocalDateTime(2005, 6, 2, 10, 20, 30, 40); LocalDateTime test1a = new LocalDateTime(2005, 6, 2, 10, 20, 30, 40); assertEquals(false, test1.isBefore(test1a)); assertEquals(false, test1a.isBefore(test1)); assertEquals(false, test1.isBefore(test1)); assertEquals(false, test1a.isBefore(test1a)); LocalDateTime test2 = new LocalDateTime(2005, 7, 2, 10, 20, 30, 40); assertEquals(true, test1.isBefore(test2)); assertEquals(false, test2.isBefore(test1)); LocalDateTime test3 = new LocalDateTime(2005, 7, 2, 10, 20, 30, 40, GREGORIAN_UTC); assertEquals(true, test1.isBefore(test3)); assertEquals(false, test3.isBefore(test1)); assertEquals(false, test3.isBefore(test2)); try { new LocalDateTime(2005, 7, 2, 10, 20, 30, 40).isBefore(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testIsAfter_LocalDateTime() { LocalDateTime test1 = new LocalDateTime(2005, 6, 2, 10, 20, 30, 40); LocalDateTime test1a = new LocalDateTime(2005, 6, 2, 10, 20, 30, 40); assertEquals(false, test1.isAfter(test1a)); assertEquals(false, test1a.isAfter(test1)); assertEquals(false, test1.isAfter(test1)); assertEquals(false, test1a.isAfter(test1a)); LocalDateTime test2 = new LocalDateTime(2005, 7, 2, 10, 20, 30, 40); assertEquals(false, test1.isAfter(test2)); assertEquals(true, test2.isAfter(test1)); LocalDateTime test3 = new LocalDateTime(2005, 7, 2, 10, 20, 30, 40, GREGORIAN_UTC); assertEquals(false, test1.isAfter(test3)); assertEquals(true, test3.isAfter(test1)); assertEquals(false, test3.isAfter(test2)); try { new LocalDateTime(2005, 7, 2, 10, 20, 30, 40).isAfter(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testWithDate() { LocalDateTime test = new LocalDateTime(2004, 6, 9, 10, 20, 30, 40); LocalDateTime result = test.withDate(2006, 2, 1); check(test, 2004, 6, 9, 10, 20, 30, 40); check(result, 2006, 2, 1, 10, 20, 30, 40); } //----------------------------------------------------------------------- public void testWithTime() { LocalDateTime test = new LocalDateTime(2004, 6, 9, 10, 20, 30, 40); LocalDateTime result = test.withTime(9, 8, 7, 6); check(test, 2004, 6, 9, 10, 20, 30, 40); check(result, 2004, 6, 9, 9, 8, 7, 6); } //----------------------------------------------------------------------- public void testWithField_DateTimeFieldType_int_1() { LocalDateTime test = new LocalDateTime(2004, 6, 9, 10, 20, 30, 40); LocalDateTime result = test.withField(DateTimeFieldType.year(), 2006); assertEquals(new LocalDateTime(2004, 6, 9, 10, 20, 30, 40), test); assertEquals(new LocalDateTime(2006, 6, 9, 10, 20, 30, 40), result); } public void testWithField_DateTimeFieldType_int_2() { LocalDateTime test = new LocalDateTime(2004, 6, 9, 10, 20, 30, 40); try { test.withField(null, 6); fail(); } catch (IllegalArgumentException ex) {} } public void testWithField_DateTimeFieldType_int_3() { LocalDateTime test = new LocalDateTime(2004, 6, 9, 10, 20, 30, 40); LocalDateTime result = test.withField(DateTimeFieldType.year(), 2004); assertEquals(new LocalDateTime(2004, 6, 9, 10, 20, 30, 40), test); assertSame(test, result); } //----------------------------------------------------------------------- public void testWithFieldAdded_DurationFieldType_int_1() { LocalDateTime test = new LocalDateTime(2004, 6, 9, 10, 20, 30, 40); LocalDateTime result = test.withFieldAdded(DurationFieldType.years(), 6); assertEquals(new LocalDateTime(2004, 6, 9, 10, 20, 30, 40), test); assertEquals(new LocalDateTime(2010, 6, 9, 10, 20, 30, 40), result); } public void testWithFieldAdded_DurationFieldType_int_2() { LocalDateTime test = new LocalDateTime(2004, 6, 9, 10, 20, 30, 40); try { test.withFieldAdded(null, 0); fail(); } catch (IllegalArgumentException ex) {} } public void testWithFieldAdded_DurationFieldType_int_3() { LocalDateTime test = new LocalDateTime(2004, 6, 9, 10, 20, 30, 40); try { test.withFieldAdded(null, 6); fail(); } catch (IllegalArgumentException ex) {} } public void testWithFieldAdded_DurationFieldType_int_4() { LocalDateTime test = new LocalDateTime(2004, 6, 9, 10, 20, 30, 40); LocalDateTime result = test.withFieldAdded(DurationFieldType.years(), 0); assertSame(test, result); } //----------------------------------------------------------------------- public void testPlus_RP() { LocalDateTime test = new LocalDateTime(2002, 5, 3, 10, 20, 30, 40, BUDDHIST_LONDON); LocalDateTime result = test.plus(new Period(1, 2, 3, 4, 29, 6, 7, 8)); LocalDateTime expected = new LocalDateTime(2003, 7, 29, 15, 26, 37, 48, BUDDHIST_LONDON); assertEquals(expected, result); result = test.plus((ReadablePeriod) null); assertSame(test, result); } public void testPlusYears_int() { LocalDateTime test = new LocalDateTime(2002, 5, 3, 10, 20, 30, 40, BUDDHIST_LONDON); LocalDateTime result = test.plusYears(1); LocalDateTime expected = new LocalDateTime(2003, 5, 3, 10, 20, 30, 40, BUDDHIST_LONDON); assertEquals(expected, result); result = test.plusYears(0); assertSame(test, result); } public void testPlusMonths_int() { LocalDateTime test = new LocalDateTime(2002, 5, 3, 10, 20, 30, 40, BUDDHIST_LONDON); LocalDateTime result = test.plusMonths(1); LocalDateTime expected = new LocalDateTime(2002, 6, 3, 10, 20, 30, 40, BUDDHIST_LONDON); assertEquals(expected, result); result = test.plusMonths(0); assertSame(test, result); } public void testPlusWeeks_int() { LocalDateTime test = new LocalDateTime(2002, 5, 3, 10, 20, 30, 40, BUDDHIST_LONDON); LocalDateTime result = test.plusWeeks(1); LocalDateTime expected = new LocalDateTime(2002, 5, 10, 10, 20, 30, 40, BUDDHIST_LONDON); assertEquals(expected, result); result = test.plusWeeks(0); assertSame(test, result); } public void testPlusDays_int() { LocalDateTime test = new LocalDateTime(2002, 5, 3, 10, 20, 30, 40, BUDDHIST_LONDON); LocalDateTime result = test.plusDays(1); LocalDateTime expected = new LocalDateTime(2002, 5, 4, 10, 20, 30, 40, BUDDHIST_LONDON); assertEquals(expected, result); result = test.plusDays(0); assertSame(test, result); } public void testPlusHours_int() { LocalDateTime test = new LocalDateTime(2002, 5, 3, 10, 20, 30, 40, BUDDHIST_LONDON); LocalDateTime result = test.plusHours(1); LocalDateTime expected = new LocalDateTime(2002, 5, 3, 11, 20, 30, 40, BUDDHIST_LONDON); assertEquals(expected, result); result = test.plusHours(0); assertSame(test, result); } public void testPlusMinutes_int() { LocalDateTime test = new LocalDateTime(2002, 5, 3, 10, 20, 30, 40, BUDDHIST_LONDON); LocalDateTime result = test.plusMinutes(1); LocalDateTime expected = new LocalDateTime(2002, 5, 3, 10, 21, 30, 40, BUDDHIST_LONDON); assertEquals(expected, result); result = test.plusMinutes(0); assertSame(test, result); } public void testPlusSeconds_int() { LocalDateTime test = new LocalDateTime(2002, 5, 3, 10, 20, 30, 40, BUDDHIST_LONDON); LocalDateTime result = test.plusSeconds(1); LocalDateTime expected = new LocalDateTime(2002, 5, 3, 10, 20, 31, 40, BUDDHIST_LONDON); assertEquals(expected, result); result = test.plusSeconds(0); assertSame(test, result); } public void testPlusMillis_int() { LocalDateTime test = new LocalDateTime(2002, 5, 3, 10, 20, 30, 40, BUDDHIST_LONDON); LocalDateTime result = test.plusMillis(1); LocalDateTime expected = new LocalDateTime(2002, 5, 3, 10, 20, 30, 41, BUDDHIST_LONDON); assertEquals(expected, result); result = test.plusMillis(0); assertSame(test, result); } //----------------------------------------------------------------------- public void testMinus_RP() { LocalDateTime test = new LocalDateTime(2002, 5, 3, 10, 20, 30, 40, BUDDHIST_LONDON); LocalDateTime result = test.minus(new Period(1, 1, 1, 1, 1, 1, 1, 1)); LocalDateTime expected = new LocalDateTime(2001, 3, 26, 9, 19, 29, 39, BUDDHIST_LONDON); assertEquals(expected, result); result = test.minus((ReadablePeriod) null); assertSame(test, result); } public void testMinusYears_int() { LocalDateTime test = new LocalDateTime(2002, 5, 3, 10, 20, 30, 40, BUDDHIST_LONDON); LocalDateTime result = test.minusYears(1); LocalDateTime expected = new LocalDateTime(2001, 5, 3, 10, 20, 30, 40, BUDDHIST_LONDON); assertEquals(expected, result); result = test.minusYears(0); assertSame(test, result); } public void testMinusMonths_int() { LocalDateTime test = new LocalDateTime(2002, 5, 3, 10, 20, 30, 40, BUDDHIST_LONDON); LocalDateTime result = test.minusMonths(1); LocalDateTime expected = new LocalDateTime(2002, 4, 3, 10, 20, 30, 40, BUDDHIST_LONDON); assertEquals(expected, result); result = test.minusMonths(0); assertSame(test, result); } public void testMinusWeeks_int() { LocalDateTime test = new LocalDateTime(2002, 5, 3, 10, 20, 30, 40, BUDDHIST_LONDON); LocalDateTime result = test.minusWeeks(1); LocalDateTime expected = new LocalDateTime(2002, 4, 26, 10, 20, 30, 40, BUDDHIST_LONDON); assertEquals(expected, result); result = test.minusWeeks(0); assertSame(test, result); } public void testMinusDays_int() { LocalDateTime test = new LocalDateTime(2002, 5, 3, 10, 20, 30, 40, BUDDHIST_LONDON); LocalDateTime result = test.minusDays(1); LocalDateTime expected = new LocalDateTime(2002, 5, 2, 10, 20, 30, 40, BUDDHIST_LONDON); assertEquals(expected, result); result = test.minusDays(0); assertSame(test, result); } public void testMinusHours_int() { LocalDateTime test = new LocalDateTime(2002, 5, 3, 10, 20, 30, 40, BUDDHIST_LONDON); LocalDateTime result = test.minusHours(1); LocalDateTime expected = new LocalDateTime(2002, 5, 3, 9, 20, 30, 40, BUDDHIST_LONDON); assertEquals(expected, result); result = test.minusHours(0); assertSame(test, result); } public void testMinusMinutes_int() { LocalDateTime test = new LocalDateTime(2002, 5, 3, 10, 20, 30, 40, BUDDHIST_LONDON); LocalDateTime result = test.minusMinutes(1); LocalDateTime expected = new LocalDateTime(2002, 5, 3, 10, 19, 30, 40, BUDDHIST_LONDON); assertEquals(expected, result); result = test.minusMinutes(0); assertSame(test, result); } public void testMinusSeconds_int() { LocalDateTime test = new LocalDateTime(2002, 5, 3, 10, 20, 30, 40, BUDDHIST_LONDON); LocalDateTime result = test.minusSeconds(1); LocalDateTime expected = new LocalDateTime(2002, 5, 3, 10, 20, 29, 40, BUDDHIST_LONDON); assertEquals(expected, result); result = test.minusSeconds(0); assertSame(test, result); } public void testMinusMillis_int() { LocalDateTime test = new LocalDateTime(2002, 5, 3, 10, 20, 30, 40, BUDDHIST_LONDON); LocalDateTime result = test.minusMillis(1); LocalDateTime expected = new LocalDateTime(2002, 5, 3, 10, 20, 30, 39, BUDDHIST_LONDON); assertEquals(expected, result); result = test.minusMillis(0); assertSame(test, result); } //----------------------------------------------------------------------- public void testGetters() { LocalDateTime test = new LocalDateTime(1970, 6, 9, 10, 20, 30, 40, GJ_UTC); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(160, test.getDayOfYear()); assertEquals(2, test.getDayOfWeek()); assertEquals(24, test.getWeekOfWeekyear()); assertEquals(1970, test.getWeekyear()); assertEquals(70, test.getYearOfCentury()); assertEquals(20, test.getCenturyOfEra()); assertEquals(1970, test.getYearOfEra()); assertEquals(DateTimeConstants.AD, test.getEra()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); assertEquals(MILLIS_OF_DAY_UTC, test.getMillisOfDay()); } //----------------------------------------------------------------------- public void testWithers() { LocalDateTime test = new LocalDateTime(1970, 6, 9, 10, 20, 30, 40, GJ_UTC); check(test.withYear(2000), 2000, 6, 9, 10, 20, 30, 40); check(test.withMonthOfYear(2), 1970, 2, 9, 10, 20, 30, 40); check(test.withDayOfMonth(2), 1970, 6, 2, 10, 20, 30, 40); check(test.withDayOfYear(6), 1970, 1, 6, 10, 20, 30, 40); check(test.withDayOfWeek(6), 1970, 6, 13, 10, 20, 30, 40); check(test.withWeekOfWeekyear(6), 1970, 2, 3, 10, 20, 30, 40); check(test.withWeekyear(1971), 1971, 6, 15, 10, 20, 30, 40); check(test.withYearOfCentury(60), 1960, 6, 9, 10, 20, 30, 40); check(test.withCenturyOfEra(21), 2070, 6, 9, 10, 20, 30, 40); check(test.withYearOfEra(1066), 1066, 6, 9, 10, 20, 30, 40); check(test.withEra(DateTimeConstants.BC), -1970, 6, 9, 10, 20, 30, 40); check(test.withHourOfDay(6), 1970, 6, 9, 6, 20, 30, 40); check(test.withMinuteOfHour(6), 1970, 6, 9, 10, 6, 30, 40); check(test.withSecondOfMinute(6), 1970, 6, 9, 10, 20, 6, 40); check(test.withMillisOfSecond(6), 1970, 6, 9, 10, 20, 30, 6); check(test.withMillisOfDay(61234), 1970, 6, 9, 0, 1, 1, 234); try { test.withMonthOfYear(0); fail(); } catch (IllegalArgumentException ex) {} try { test.withMonthOfYear(13); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testToDateTime() { LocalDateTime base = new LocalDateTime(2005, 6, 9, 6, 7, 8, 9, COPTIC_PARIS); // PARIS irrelevant DateTime test = base.toDateTime(); check(base, 2005, 6, 9, 6, 7, 8, 9); DateTime expected = new DateTime(2005, 6, 9, 6, 7, 8, 9, COPTIC_LONDON); assertEquals(expected, test); } //----------------------------------------------------------------------- public void testToDateTime_Zone() { LocalDateTime base = new LocalDateTime(2005, 6, 9, 6, 7, 8, 9, COPTIC_PARIS); // PARIS irrelevant DateTime test = base.toDateTime(TOKYO); check(base, 2005, 6, 9, 6, 7, 8, 9); DateTime expected = new DateTime(2005, 6, 9, 6, 7, 8, 9, COPTIC_TOKYO); assertEquals(expected, test); } public void testToDateTime_nullZone() { LocalDateTime base = new LocalDateTime(2005, 6, 9, 6, 7, 8, 9, COPTIC_PARIS); // PARIS irrelevant DateTime test = base.toDateTime((DateTimeZone) null); check(base, 2005, 6, 9, 6, 7, 8, 9); DateTime expected = new DateTime(2005, 6, 9, 6, 7, 8, 9, COPTIC_LONDON); assertEquals(expected, test); } //----------------------------------------------------------------------- public void testToLocalDate() { LocalDateTime base = new LocalDateTime(2005, 6, 9, 6, 7, 8, 9, COPTIC_PARIS); // PARIS irrelevant LocalDate expected = new LocalDate(2005, 6, 9, COPTIC_LONDON); assertEquals(expected,base.toLocalDate()); } public void testToLocalTime() { LocalDateTime base = new LocalDateTime(2005, 6, 9, 6, 7, 8, 9, COPTIC_PARIS); // PARIS irrelevant LocalTime expected = new LocalTime(6, 7, 8, 9, COPTIC_LONDON); assertEquals(expected,base.toLocalTime()); } //----------------------------------------------------------------------- public void testToDateTime_RI() { LocalDateTime base = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40, COPTIC_PARIS); DateTime dt = new DateTime(2002, 1, 3, 4, 5, 6, 7, BUDDHIST_TOKYO); DateTime test = base.toDateTime(dt); check(base, 2005, 6, 9, 10, 20, 30, 40); DateTime expected = new DateTime(2005, 6, 9, 10, 20, 30, 40, BUDDHIST_TOKYO); assertEquals(expected, test); } public void testToDateTime_nullRI() { LocalDateTime base = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40, COPTIC_PARIS); DateTime test = base.toDateTime((ReadableInstant) null); check(base, 2005, 6, 9, 10, 20, 30, 40); DateTime expected = new DateTime(2005, 6, 9, 10, 20, 30, 40, ISO_LONDON); assertEquals(expected, test); } //----------------------------------------------------------------------- public void testToDate_summer() { LocalDateTime base = new LocalDateTime(2005, 7, 9, 10, 20, 30, 40, COPTIC_PARIS); Date test = base.toDate(); check(base, 2005, 7, 9, 10, 20, 30, 40); GregorianCalendar gcal = new GregorianCalendar(); gcal.clear(); gcal.set(Calendar.YEAR, 2005); gcal.set(Calendar.MONTH, Calendar.JULY); gcal.set(Calendar.DAY_OF_MONTH, 9); gcal.set(Calendar.HOUR_OF_DAY, 10); gcal.set(Calendar.MINUTE, 20); gcal.set(Calendar.SECOND, 30); gcal.set(Calendar.MILLISECOND, 40); assertEquals(gcal.getTime(), test); } public void testToDate_winter() { LocalDateTime base = new LocalDateTime(2005, 1, 9, 10, 20, 30, 40, COPTIC_PARIS); Date test = base.toDate(); check(base, 2005, 1, 9, 10, 20, 30, 40); GregorianCalendar gcal = new GregorianCalendar(); gcal.clear(); gcal.set(Calendar.YEAR, 2005); gcal.set(Calendar.MONTH, Calendar.JANUARY); gcal.set(Calendar.DAY_OF_MONTH, 9); gcal.set(Calendar.HOUR_OF_DAY, 10); gcal.set(Calendar.MINUTE, 20); gcal.set(Calendar.SECOND, 30); gcal.set(Calendar.MILLISECOND, 40); assertEquals(gcal.getTime(), test); } public void testToDate_springDST() { LocalDateTime base = new LocalDateTime(2007, 4, 2, 0, 20, 0, 0); SimpleTimeZone testZone = new SimpleTimeZone(3600000, "NoMidnight", Calendar.APRIL, 2, 0, 0, Calendar.OCTOBER, 2, 0, 3600000); TimeZone currentZone = TimeZone.getDefault(); try { TimeZone.setDefault(testZone); Date test = base.toDate(); check(base, 2007, 4, 2, 0, 20, 0, 0); assertEquals("Mon Apr 02 01:00:00 GMT+02:00 2007", test.toString()); } finally { TimeZone.setDefault(currentZone); } } public void testToDate_springDST_2Hour40Savings() { LocalDateTime base = new LocalDateTime(2007, 4, 2, 0, 20, 0, 0); SimpleTimeZone testZone = new SimpleTimeZone(3600000, "NoMidnight", Calendar.APRIL, 2, 0, 0, Calendar.OCTOBER, 2, 0, 3600000, (3600000 / 6) * 16); TimeZone currentZone = TimeZone.getDefault(); try { TimeZone.setDefault(testZone); Date test = base.toDate(); check(base, 2007, 4, 2, 0, 20, 0, 0); assertEquals("Mon Apr 02 02:40:00 GMT+03:40 2007", test.toString()); } finally { TimeZone.setDefault(currentZone); } } public void testToDate_autumnDST() { LocalDateTime base = new LocalDateTime(2007, 10, 2, 0, 20, 30, 0); SimpleTimeZone testZone = new SimpleTimeZone(3600000, "NoMidnight", Calendar.APRIL, 2, 0, 0, Calendar.OCTOBER, 2, 0, 3600000); TimeZone currentZone = TimeZone.getDefault(); try { TimeZone.setDefault(testZone); Date test = base.toDate(); check(base, 2007, 10, 2, 0, 20, 30, 0); assertEquals("Tue Oct 02 00:20:30 GMT+02:00 2007", test.toString()); } finally { TimeZone.setDefault(currentZone); } } //----------------------------------------------------------------------- public void testToDate_summer_Zone() { LocalDateTime base = new LocalDateTime(2005, 7, 9, 10, 20, 30, 40, COPTIC_PARIS); Date test = base.toDate(TimeZone.getDefault()); check(base, 2005, 7, 9, 10, 20, 30, 40); GregorianCalendar gcal = new GregorianCalendar(); gcal.clear(); gcal.set(Calendar.YEAR, 2005); gcal.set(Calendar.MONTH, Calendar.JULY); gcal.set(Calendar.DAY_OF_MONTH, 9); gcal.set(Calendar.HOUR_OF_DAY, 10); gcal.set(Calendar.MINUTE, 20); gcal.set(Calendar.SECOND, 30); gcal.set(Calendar.MILLISECOND, 40); assertEquals(gcal.getTime(), test); } public void testToDate_winter_Zone() { LocalDateTime base = new LocalDateTime(2005, 1, 9, 10, 20, 30, 40, COPTIC_PARIS); Date test = base.toDate(TimeZone.getDefault()); check(base, 2005, 1, 9, 10, 20, 30, 40); GregorianCalendar gcal = new GregorianCalendar(); gcal.clear(); gcal.set(Calendar.YEAR, 2005); gcal.set(Calendar.MONTH, Calendar.JANUARY); gcal.set(Calendar.DAY_OF_MONTH, 9); gcal.set(Calendar.HOUR_OF_DAY, 10); gcal.set(Calendar.MINUTE, 20); gcal.set(Calendar.SECOND, 30); gcal.set(Calendar.MILLISECOND, 40); assertEquals(gcal.getTime(), test); } public void testToDate_springDST_Zone() { LocalDateTime base = new LocalDateTime(2007, 4, 2, 0, 20, 0, 0); SimpleTimeZone testZone = new SimpleTimeZone(3600000, "NoMidnight", Calendar.APRIL, 2, 0, 0, Calendar.OCTOBER, 2, 0, 3600000); TimeZone currentZone = TimeZone.getDefault(); try { TimeZone.setDefault(testZone); Date test = base.toDate(TimeZone.getDefault()); check(base, 2007, 4, 2, 0, 20, 0, 0); assertEquals("Mon Apr 02 01:00:00 GMT+02:00 2007", test.toString()); } finally { TimeZone.setDefault(currentZone); } } public void testToDate_springDST_2Hour40Savings_Zone() { LocalDateTime base = new LocalDateTime(2007, 4, 2, 0, 20, 0, 0); SimpleTimeZone testZone = new SimpleTimeZone(3600000, "NoMidnight", Calendar.APRIL, 2, 0, 0, Calendar.OCTOBER, 2, 0, 3600000, (3600000 / 6) * 16); TimeZone currentZone = TimeZone.getDefault(); try { TimeZone.setDefault(testZone); Date test = base.toDate(TimeZone.getDefault()); check(base, 2007, 4, 2, 0, 20, 0, 0); assertEquals("Mon Apr 02 02:40:00 GMT+03:40 2007", test.toString()); } finally { TimeZone.setDefault(currentZone); } } public void testToDate_autumnDST_Zone() { LocalDateTime base = new LocalDateTime(2007, 10, 2, 0, 20, 30, 0); SimpleTimeZone testZone = new SimpleTimeZone(3600000, "NoMidnight", Calendar.APRIL, 2, 0, 0, Calendar.OCTOBER, 2, 0, 3600000); TimeZone currentZone = TimeZone.getDefault(); try { TimeZone.setDefault(testZone); Date test = base.toDate(TimeZone.getDefault()); check(base, 2007, 10, 2, 0, 20, 30, 0); assertEquals("Tue Oct 02 00:20:30 GMT+02:00 2007", test.toString()); } finally { TimeZone.setDefault(currentZone); } } //----------------------------------------------------------------------- public void testProperty() { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40, GJ_UTC); assertEquals(test.year(), test.property(DateTimeFieldType.year())); assertEquals(test.monthOfYear(), test.property(DateTimeFieldType.monthOfYear())); assertEquals(test.dayOfMonth(), test.property(DateTimeFieldType.dayOfMonth())); assertEquals(test.dayOfWeek(), test.property(DateTimeFieldType.dayOfWeek())); assertEquals(test.dayOfYear(), test.property(DateTimeFieldType.dayOfYear())); assertEquals(test.weekOfWeekyear(), test.property(DateTimeFieldType.weekOfWeekyear())); assertEquals(test.weekyear(), test.property(DateTimeFieldType.weekyear())); assertEquals(test.yearOfCentury(), test.property(DateTimeFieldType.yearOfCentury())); assertEquals(test.yearOfEra(), test.property(DateTimeFieldType.yearOfEra())); assertEquals(test.centuryOfEra(), test.property(DateTimeFieldType.centuryOfEra())); assertEquals(test.era(), test.property(DateTimeFieldType.era())); assertEquals(test.hourOfDay(), test.property(DateTimeFieldType.hourOfDay())); assertEquals(test.minuteOfHour(), test.property(DateTimeFieldType.minuteOfHour())); assertEquals(test.secondOfMinute(), test.property(DateTimeFieldType.secondOfMinute())); assertEquals(test.millisOfSecond(), test.property(DateTimeFieldType.millisOfSecond())); assertEquals(test.millisOfDay(), test.property(DateTimeFieldType.millisOfDay())); try { test.property(null); fail(); } catch (IllegalArgumentException ex) {} assertEquals(test, test.property(DateTimeFieldType.minuteOfDay()).getLocalDateTime()); } //----------------------------------------------------------------------- public void testSerialization() throws Exception { LocalDateTime test = new LocalDateTime(1972, 6, 9, 10, 20, 30, 40, COPTIC_PARIS); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(test); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); LocalDateTime result = (LocalDateTime) ois.readObject(); ois.close(); assertEquals(test, result); assertTrue(Arrays.equals(test.getValues(), result.getValues())); assertTrue(Arrays.equals(test.getFields(), result.getFields())); assertEquals(test.getChronology(), result.getChronology()); assertTrue(result.isSupported(DateTimeFieldType.dayOfMonth())); // check deserialization } //----------------------------------------------------------------------- public void testToString() { LocalDateTime test = new LocalDateTime(2002, 6, 9, 10, 20, 30, 40); assertEquals("2002-06-09T10:20:30.040", test.toString()); } //----------------------------------------------------------------------- public void testToString_String() { LocalDateTime test = new LocalDateTime(2002, 6, 9, 10, 20, 30, 40); assertEquals("2002 10", test.toString("yyyy HH")); assertEquals("2002-06-09T10:20:30.040", test.toString((String) null)); } //----------------------------------------------------------------------- public void testToString_String_Locale() { LocalDateTime test = new LocalDateTime(1970, 6, 9, 10, 20, 30, 40); assertEquals("Tue 9/6", test.toString("EEE d/M", Locale.ENGLISH)); assertEquals("mar. 9/6", test.toString("EEE d/M", Locale.FRENCH)); assertEquals("1970-06-09T10:20:30.040", test.toString(null, Locale.ENGLISH)); assertEquals("Tue 9/6", test.toString("EEE d/M", null)); assertEquals("1970-06-09T10:20:30.040", test.toString(null, null)); } //----------------------------------------------------------------------- public void testToString_DTFormatter() { LocalDateTime test = new LocalDateTime(2002, 6, 9, 10, 20, 30, 40); assertEquals("2002 10", test.toString(DateTimeFormat.forPattern("yyyy HH"))); assertEquals("2002-06-09T10:20:30.040", test.toString((DateTimeFormatter) null)); } //----------------------------------------------------------------------- private void check(LocalDateTime test, int year, int month, int day, int hour, int min, int sec, int mil) { assertEquals(year, test.getYear()); assertEquals(month, test.getMonthOfYear()); assertEquals(day, test.getDayOfMonth()); assertEquals(hour, test.getHourOfDay()); assertEquals(min, test.getMinuteOfHour()); assertEquals(sec, test.getSecondOfMinute()); assertEquals(mil, test.getMillisOfSecond()); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.BuddhistChronology; import org.joda.time.chrono.GregorianChronology; import org.joda.time.chrono.ISOChronology; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; /** * This class is a Junit unit test for LocalDateTime. * * @author Stephen Colebourne */ public class TestLocalDateTime_Constructors extends TestCase { private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone MOSCOW = DateTimeZone.forID("Europe/Moscow"); private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC(); private static final Chronology GREGORIAN_UTC = GregorianChronology.getInstanceUTC(); private static final Chronology GREGORIAN_PARIS = GregorianChronology.getInstance(PARIS); private static final Chronology GREGORIAN_MOSCOW = GregorianChronology.getInstance(MOSCOW); private static final Chronology BUDDHIST_UTC = BuddhistChronology.getInstanceUTC(); private static final int OFFSET_PARIS = PARIS.getOffset(0L) / DateTimeConstants.MILLIS_PER_HOUR; private static final int OFFSET_MOSCOW = MOSCOW.getOffset(0L) / DateTimeConstants.MILLIS_PER_HOUR; private long MILLIS_OF_DAY = 10L * DateTimeConstants.MILLIS_PER_HOUR + 20L * DateTimeConstants.MILLIS_PER_MINUTE + 30L * DateTimeConstants.MILLIS_PER_SECOND + 40L; private long TEST_TIME_NOW = (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY + MILLIS_OF_DAY; private long TEST_TIME1 = (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; private long TEST_TIME2 = (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone zone = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestLocalDateTime_Constructors.class); } public TestLocalDateTime_Constructors(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); zone = DateTimeZone.getDefault(); DateTimeZone.setDefault(MOSCOW); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(zone); zone = null; } //----------------------------------------------------------------------- public void testParse_noFormatter() throws Throwable { assertEquals(new LocalDateTime(2010, 6, 30, 1, 20), LocalDateTime.parse("2010-06-30T01:20")); assertEquals(new LocalDateTime(2010, 1, 2, 14, 50, 30, 432), LocalDateTime.parse("2010-002T14:50:30.432")); } public void testParse_formatter() throws Throwable { DateTimeFormatter f = DateTimeFormat.forPattern("yyyy--dd MM HH").withChronology(ISOChronology.getInstance(PARIS)); assertEquals(new LocalDateTime(2010, 6, 30, 13, 0), LocalDateTime.parse("2010--30 06 13", f)); } //----------------------------------------------------------------------- public void testFactory_fromCalendarFields() throws Exception { GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6); cal.set(Calendar.MILLISECOND, 7); LocalDateTime expected = new LocalDateTime(1970, 2, 3, 4, 5, 6, 7); assertEquals(expected, LocalDateTime.fromCalendarFields(cal)); } public void testFactory_fromCalendarFields_beforeYearZero1() throws Exception { GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6); cal.set(Calendar.ERA, GregorianCalendar.BC); cal.set(Calendar.MILLISECOND, 7); LocalDateTime expected = new LocalDateTime(0, 2, 3, 4, 5, 6, 7); assertEquals(expected, LocalDateTime.fromCalendarFields(cal)); } public void testFactory_fromCalendarFields_beforeYearZero3() throws Exception { GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6); cal.set(Calendar.ERA, GregorianCalendar.BC); cal.set(Calendar.MILLISECOND, 7); LocalDateTime expected = new LocalDateTime(-2, 2, 3, 4, 5, 6, 7); assertEquals(expected, LocalDateTime.fromCalendarFields(cal)); } public void testFactory_fromCalendarFields_null() throws Exception { try { LocalDateTime.fromCalendarFields((Calendar) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testFactory_fromDateFields_after1970() throws Exception { GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6); cal.set(Calendar.MILLISECOND, 7); LocalDateTime expected = new LocalDateTime(1970, 2, 3, 4, 5 ,6, 7); assertEquals(expected, LocalDateTime.fromDateFields(cal.getTime())); } public void testFactory_fromDateFields_before1970() throws Exception { GregorianCalendar cal = new GregorianCalendar(1969, 1, 3, 4, 5, 6); cal.set(Calendar.MILLISECOND, 7); LocalDateTime expected = new LocalDateTime(1969, 2, 3, 4, 5 ,6, 7); assertEquals(expected, LocalDateTime.fromDateFields(cal.getTime())); } public void testFactory_fromDateFields_beforeYearZero1() throws Exception { GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6); cal.set(Calendar.ERA, GregorianCalendar.BC); cal.set(Calendar.MILLISECOND, 7); LocalDateTime expected = new LocalDateTime(0, 2, 3, 4, 5, 6, 7); assertEquals(expected, LocalDateTime.fromDateFields(cal.getTime())); } public void testFactory_fromDateFields_beforeYearZero3() throws Exception { GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6); cal.set(Calendar.ERA, GregorianCalendar.BC); cal.set(Calendar.MILLISECOND, 7); LocalDateTime expected = new LocalDateTime(-2, 2, 3, 4, 5, 6, 7); assertEquals(expected, LocalDateTime.fromDateFields(cal.getTime())); } public void testFactory_fromDateFields_null() throws Exception { try { LocalDateTime.fromDateFields((Date) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testConstructor() throws Throwable { LocalDateTime test = new LocalDateTime(); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(10 + OFFSET_MOSCOW, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); assertEquals(test, LocalDateTime.now()); } //----------------------------------------------------------------------- public void testConstructor_DateTimeZone() throws Throwable { DateTime dt = new DateTime(2005, 6, 8, 23, 59, 0, 0, LONDON); DateTimeUtils.setCurrentMillisFixed(dt.getMillis()); // 23:59 in London is 00:59 the following day in Paris LocalDateTime test = new LocalDateTime(LONDON); assertEquals(ISO_UTC, test.getChronology()); assertEquals(2005, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(8, test.getDayOfMonth()); assertEquals(23, test.getHourOfDay()); assertEquals(59, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); assertEquals(test, LocalDateTime.now(LONDON)); test = new LocalDateTime(PARIS); assertEquals(ISO_UTC, test.getChronology()); assertEquals(2005, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(0, test.getHourOfDay()); assertEquals(59, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); assertEquals(test, LocalDateTime.now(PARIS)); } public void testConstructor_nullDateTimeZone() throws Throwable { LocalDateTime test = new LocalDateTime((DateTimeZone) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(10 + OFFSET_MOSCOW, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } //----------------------------------------------------------------------- public void testConstructor_Chronology() throws Throwable { LocalDateTime test = new LocalDateTime(GREGORIAN_PARIS); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(10 + OFFSET_PARIS, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); assertEquals(test, LocalDateTime.now(GREGORIAN_PARIS)); } public void testConstructor_nullChronology() throws Throwable { LocalDateTime test = new LocalDateTime((Chronology) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(10 + OFFSET_MOSCOW, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } //----------------------------------------------------------------------- public void testConstructor_long1() throws Throwable { LocalDateTime test = new LocalDateTime(TEST_TIME1); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); assertEquals(12 + OFFSET_MOSCOW, test.getHourOfDay()); assertEquals(24, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } public void testConstructor_long2() throws Throwable { LocalDateTime test = new LocalDateTime(TEST_TIME2); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1971, test.getYear()); assertEquals(5, test.getMonthOfYear()); assertEquals(7, test.getDayOfMonth()); assertEquals(14 + OFFSET_MOSCOW, test.getHourOfDay()); assertEquals(28, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } //----------------------------------------------------------------------- public void testConstructor_long1_DateTimeZone() throws Throwable { LocalDateTime test = new LocalDateTime(TEST_TIME1, PARIS); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); assertEquals(12 + OFFSET_PARIS, test.getHourOfDay()); assertEquals(24, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } public void testConstructor_long2_DateTimeZone() throws Throwable { LocalDateTime test = new LocalDateTime(TEST_TIME2, PARIS); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1971, test.getYear()); assertEquals(5, test.getMonthOfYear()); assertEquals(7, test.getDayOfMonth()); assertEquals(14 + OFFSET_PARIS, test.getHourOfDay()); assertEquals(28, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } public void testConstructor_long_nullDateTimeZone() throws Throwable { LocalDateTime test = new LocalDateTime(TEST_TIME1, (DateTimeZone) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); assertEquals(12 + OFFSET_MOSCOW, test.getHourOfDay()); assertEquals(24, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } //----------------------------------------------------------------------- public void testConstructor_long1_Chronology() throws Throwable { LocalDateTime test = new LocalDateTime(TEST_TIME1, GREGORIAN_PARIS); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); assertEquals(12 + OFFSET_PARIS, test.getHourOfDay()); assertEquals(24, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } public void testConstructor_long2_Chronology() throws Throwable { LocalDateTime test = new LocalDateTime(TEST_TIME2, GREGORIAN_PARIS); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(1971, test.getYear()); assertEquals(5, test.getMonthOfYear()); assertEquals(7, test.getDayOfMonth()); assertEquals(14 + OFFSET_PARIS, test.getHourOfDay()); assertEquals(28, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } public void testConstructor_long_nullChronology() throws Throwable { LocalDateTime test = new LocalDateTime(TEST_TIME1, (Chronology) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); assertEquals(12 + OFFSET_MOSCOW, test.getHourOfDay()); assertEquals(24, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } //----------------------------------------------------------------------- public void testConstructor_Object1() throws Throwable { Date date = new Date(TEST_TIME1); LocalDateTime test = new LocalDateTime(date); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); assertEquals(12 + OFFSET_MOSCOW, test.getHourOfDay()); assertEquals(24, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } public void testConstructor_nullObject() throws Throwable { LocalDateTime test = new LocalDateTime((Object) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(10 + OFFSET_MOSCOW, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } public void testConstructor_ObjectString1() throws Throwable { LocalDateTime test = new LocalDateTime("1972-04-06"); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1972, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); assertEquals(0, test.getHourOfDay()); assertEquals(0, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } public void testConstructor_ObjectString2() throws Throwable { LocalDateTime test = new LocalDateTime("1972-037"); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1972, test.getYear()); assertEquals(2, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); assertEquals(0, test.getHourOfDay()); assertEquals(0, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } public void testConstructor_ObjectString3() throws Throwable { LocalDateTime test = new LocalDateTime("1972-04-06T10:20:30.040"); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1972, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } public void testConstructor_ObjectString4() throws Throwable { LocalDateTime test = new LocalDateTime("1972-04-06T10:20"); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1972, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } public void testConstructor_ObjectStringEx1() throws Throwable { try { new LocalDateTime("1970-04-06T+14:00"); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_ObjectStringEx2() throws Throwable { try { new LocalDateTime("1970-04-06T10:20:30.040+14:00"); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_ObjectStringEx3() throws Throwable { try { new LocalDateTime("T10:20:30.040"); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_ObjectStringEx4() throws Throwable { try { new LocalDateTime("T10:20:30.040+14:00"); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_ObjectStringEx5() throws Throwable { try { new LocalDateTime("10:20:30.040"); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_ObjectStringEx6() throws Throwable { try { new LocalDateTime("10:20:30.040+14:00"); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_ObjectLocalDateTime() throws Throwable { LocalDateTime dt = new LocalDateTime(1970, 5, 6, 10, 20, 30, 40, BUDDHIST_UTC); LocalDateTime test = new LocalDateTime(dt); assertEquals(BUDDHIST_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(5, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } public void testConstructor_ObjectLocalDate() throws Throwable { LocalDate date = new LocalDate(1970, 5, 6); try { new LocalDateTime(date); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_ObjectLocalTime() throws Throwable { LocalTime time = new LocalTime(10, 20, 30, 40); try { new LocalDateTime(time); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testConstructor_Object_DateTimeZone() throws Throwable { Date date = new Date(TEST_TIME1); LocalDateTime test = new LocalDateTime(date, PARIS); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); assertEquals(12 + OFFSET_PARIS, test.getHourOfDay()); assertEquals(24, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } public void testConstructor_Object_DateTimeZoneMoscow() throws Throwable { LocalDateTime test = new LocalDateTime("1970-04-06T12:24:00", MOSCOW); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); assertEquals(12, test.getHourOfDay()); assertEquals(24, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } public void testConstructor_Object_DateTimeZoneMoscowBadDateTime() throws Throwable { // 1981-03-31T23:59:59.999+03:00 followed by 1981-04-01T01:00:00.000+04:00 // 1981-09-30T23:59:59.999+04:00 followed by 1981-09-30T23:00:00.000+03:00 // when a DST non-existing time is passed in, it should still work (ie. zone ignored) LocalDateTime test = new LocalDateTime("1981-04-01T00:30:00", MOSCOW); // doesnt exist assertEquals(ISO_UTC, test.getChronology()); assertEquals(1981, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(1, test.getDayOfMonth()); assertEquals(0, test.getHourOfDay()); assertEquals(30, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } public void testConstructor_nullObject_DateTimeZone() throws Throwable { LocalDateTime test = new LocalDateTime((Object) null, PARIS); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(10 + OFFSET_PARIS, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } public void testConstructor_Object_nullDateTimeZone() throws Throwable { Date date = new Date(TEST_TIME1); LocalDateTime test = new LocalDateTime(date, (DateTimeZone) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); assertEquals(12 + OFFSET_MOSCOW, test.getHourOfDay()); assertEquals(24, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } public void testConstructor_nullObject_nullDateTimeZone() throws Throwable { LocalDateTime test = new LocalDateTime((Object) null, (DateTimeZone) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(10 + OFFSET_MOSCOW, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } //----------------------------------------------------------------------- public void testConstructor_Object_Chronology() throws Throwable { Date date = new Date(TEST_TIME1); LocalDateTime test = new LocalDateTime(date, GREGORIAN_PARIS); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); assertEquals(12 + OFFSET_PARIS, test.getHourOfDay()); assertEquals(24, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } public void testConstructor_Object_Chronology_crossChronology() throws Throwable { LocalDateTime input = new LocalDateTime(1970, 4, 6, 12, 30, 0, 0, ISO_UTC); LocalDateTime test = new LocalDateTime(input, BUDDHIST_UTC); assertEquals(BUDDHIST_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); assertEquals(12, test.getHourOfDay()); assertEquals(30, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } public void testConstructor_Object_ChronologyMoscow() throws Throwable { LocalDateTime test = new LocalDateTime("1970-04-06T12:24:00", GREGORIAN_MOSCOW); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); assertEquals(12, test.getHourOfDay()); assertEquals(24, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } public void testConstructor_Object_ChronologyMoscowBadDateTime() throws Throwable { // 1981-03-31T23:59:59.999+03:00 followed by 1981-04-01T01:00:00.000+04:00 // 1981-09-30T23:59:59.999+04:00 followed by 1981-09-30T23:00:00.000+03:00 // when a DST non-existing time is passed in, it should still work (ie. zone ignored) LocalDateTime test = new LocalDateTime("1981-04-01T00:30:00", GREGORIAN_MOSCOW); // doesnt exist assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(1981, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(1, test.getDayOfMonth()); assertEquals(0, test.getHourOfDay()); assertEquals(30, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } public void testConstructor_nullObject_Chronology() throws Throwable { LocalDateTime test = new LocalDateTime((Object) null, GREGORIAN_PARIS); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(10 + OFFSET_PARIS, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } public void testConstructor_Object_nullChronology() throws Throwable { Date date = new Date(TEST_TIME1); LocalDateTime test = new LocalDateTime(date, (Chronology) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); assertEquals(12 + OFFSET_MOSCOW, test.getHourOfDay()); assertEquals(24, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } public void testConstructor_nullObject_nullChronology() throws Throwable { LocalDateTime test = new LocalDateTime((Object) null, (Chronology) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(10 + OFFSET_MOSCOW, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } //----------------------------------------------------------------------- public void testConstructor_int_int_int_int_int() throws Throwable { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20); assertEquals(ISO_UTC, test.getChronology()); assertEquals(2005, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } //----------------------------------------------------------------------- public void testConstructor_int_int_int_int_int_int() throws Throwable { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30); assertEquals(ISO_UTC, test.getChronology()); assertEquals(2005, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } //----------------------------------------------------------------------- public void testConstructor_int_int_int_int_int_int_int() throws Throwable { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40); assertEquals(ISO_UTC, test.getChronology()); assertEquals(2005, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); try { new LocalDateTime(Integer.MIN_VALUE, 6, 9, 10, 20, 30, 40); fail(); } catch (IllegalArgumentException ex) {} try { new LocalDateTime(Integer.MAX_VALUE, 6, 9, 10, 20, 30, 40); fail(); } catch (IllegalArgumentException ex) {} try { new LocalDateTime(2005, 0, 9, 10, 20, 30, 40); fail(); } catch (IllegalArgumentException ex) {} try { new LocalDateTime(2005, 13, 9, 10, 20, 30, 40); fail(); } catch (IllegalArgumentException ex) {} try { new LocalDateTime(2005, 6, 0, 10, 20, 30, 40); fail(); } catch (IllegalArgumentException ex) {} try { new LocalDateTime(2005, 6, 31, 10, 20, 30, 40); fail(); } catch (IllegalArgumentException ex) {} new LocalDateTime(2005, 7, 31, 10, 20, 30, 40); try { new LocalDateTime(2005, 7, 32, 10, 20, 30, 40); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_int_int_int_Chronology() throws Throwable { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40, GREGORIAN_PARIS); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(2005, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(10, test.getHourOfDay()); // PARIS has no effect assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); try { new LocalDateTime(Integer.MIN_VALUE, 6, 9, 10, 20, 30, 40, GREGORIAN_PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new LocalDateTime(Integer.MAX_VALUE, 6, 9, 10, 20, 30, 40, GREGORIAN_PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new LocalDateTime(2005, 0, 9, 10, 20, 30, 40, GREGORIAN_PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new LocalDateTime(2005, 13, 9, 10, 20, 30, 40, GREGORIAN_PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new LocalDateTime(2005, 6, 0, 10, 20, 30, 40, GREGORIAN_PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new LocalDateTime(2005, 6, 31, 10, 20, 30, 40, GREGORIAN_PARIS); fail(); } catch (IllegalArgumentException ex) {} new LocalDateTime(2005, 7, 31, 10, 20, 30, 40, GREGORIAN_PARIS); try { new LocalDateTime(2005, 7, 32, 10, 20, 30, 40, GREGORIAN_PARIS); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_int_int_int_nullChronology() throws Throwable { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40, null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(2005, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); } }
/* * Copyright 2001-2010 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.util.Locale; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.CopticChronology; /** * This class is a Junit unit test for LocalDateTime. * * @author Stephen Colebourne */ public class TestLocalDateTime_Properties extends TestCase { private static final CopticChronology COPTIC_UTC = CopticChronology.getInstanceUTC(); private int MILLIS_OF_DAY = (int) (10L * DateTimeConstants.MILLIS_PER_HOUR + 20L * DateTimeConstants.MILLIS_PER_MINUTE + 30L * DateTimeConstants.MILLIS_PER_SECOND + 40L); private long TEST_TIME_NOW = (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY + MILLIS_OF_DAY; private long TEST_TIME1 = (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 1L * DateTimeConstants.MILLIS_PER_HOUR + 2L * DateTimeConstants.MILLIS_PER_MINUTE + 3L * DateTimeConstants.MILLIS_PER_SECOND + 4L; private long TEST_TIME2 = (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY + 4L * DateTimeConstants.MILLIS_PER_HOUR + 5L * DateTimeConstants.MILLIS_PER_MINUTE + 6L * DateTimeConstants.MILLIS_PER_SECOND + 7L; private DateTimeZone zone = null; private Locale systemDefaultLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestLocalDateTime_Properties.class); } public TestLocalDateTime_Properties(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); zone = DateTimeZone.getDefault(); DateTimeZone.setDefault(DateTimeZone.UTC); systemDefaultLocale = Locale.getDefault(); Locale.setDefault(Locale.ENGLISH); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(zone); zone = null; Locale.setDefault(systemDefaultLocale); systemDefaultLocale = null; } //----------------------------------------------------------------------- public void testPropertyGetYear() { LocalDateTime test = new LocalDateTime(1972, 6, 9, 10, 20, 30, 40); assertSame(test.getChronology().year(), test.year().getField()); assertEquals("year", test.year().getName()); assertEquals("Property[year]", test.year().toString()); assertSame(test, test.year().getLocalDateTime()); assertEquals(1972, test.year().get()); assertEquals("1972", test.year().getAsString()); assertEquals("1972", test.year().getAsText()); assertEquals("1972", test.year().getAsText(Locale.FRENCH)); assertEquals("1972", test.year().getAsShortText()); assertEquals("1972", test.year().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().years(), test.year().getDurationField()); assertEquals(null, test.year().getRangeDurationField()); assertEquals(9, test.year().getMaximumTextLength(null)); assertEquals(9, test.year().getMaximumShortTextLength(null)); } public void testPropertyGetMaxMinValuesYear() { LocalDateTime test = new LocalDateTime(1972, 6, 9, 10, 20, 30, 40); assertEquals(-292275054, test.year().getMinimumValue()); assertEquals(-292275054, test.year().getMinimumValueOverall()); assertEquals(292278993, test.year().getMaximumValue()); assertEquals(292278993, test.year().getMaximumValueOverall()); } public void testPropertyAddToCopyYear() { LocalDateTime test = new LocalDateTime(1972, 6, 9, 10, 20, 30, 40); LocalDateTime copy = test.year().addToCopy(9); check(test, 1972, 6, 9, 10, 20, 30, 40); check(copy, 1981, 6, 9, 10, 20, 30, 40); copy = test.year().addToCopy(0); check(copy, 1972, 6, 9, 10, 20, 30, 40); copy = test.year().addToCopy(292278993 - 1972); check(copy, 292278993, 6, 9, 10, 20, 30, 40); try { test.year().addToCopy(292278993 - 1972 + 1); fail(); } catch (IllegalArgumentException ex) {} check(test, 1972, 6, 9, 10, 20, 30, 40); copy = test.year().addToCopy(-1972); check(copy, 0, 6, 9, 10, 20, 30, 40); copy = test.year().addToCopy(-1973); check(copy, -1, 6, 9, 10, 20, 30, 40); try { test.year().addToCopy(-292275054 - 1972 - 1); fail(); } catch (IllegalArgumentException ex) {} check(test, 1972, 6, 9, 10, 20, 30, 40); } public void testPropertyAddWrapFieldToCopyYear() { LocalDateTime test = new LocalDateTime(1972, 6, 9, 10, 20, 30, 40); LocalDateTime copy = test.year().addWrapFieldToCopy(9); check(test, 1972, 6, 9, 10, 20, 30, 40); check(copy, 1981, 6, 9, 10, 20, 30, 40); copy = test.year().addWrapFieldToCopy(0); check(copy, 1972, 6, 9, 10, 20, 30, 40); copy = test.year().addWrapFieldToCopy(292278993 - 1972 + 1); check(copy, -292275054, 6, 9, 10, 20, 30, 40); copy = test.year().addWrapFieldToCopy(-292275054 - 1972 - 1); check(copy, 292278993, 6, 9, 10, 20, 30, 40); } public void testPropertySetCopyYear() { LocalDateTime test = new LocalDateTime(1972, 6, 9, 10, 20, 30, 40); LocalDateTime copy = test.year().setCopy(12); check(test, 1972, 6, 9, 10, 20, 30, 40); check(copy, 12, 6, 9, 10, 20, 30, 40); } public void testPropertySetCopyTextYear() { LocalDateTime test = new LocalDateTime(1972, 6, 9, 10, 20, 30, 40); LocalDateTime copy = test.year().setCopy("12"); check(test, 1972, 6, 9, 10, 20, 30, 40); check(copy, 12, 6, 9, 10, 20, 30, 40); } public void testPropertyCompareToYear() { LocalDateTime test1 = new LocalDateTime(TEST_TIME1); LocalDateTime test2 = new LocalDateTime(TEST_TIME2); assertEquals(true, test1.year().compareTo(test2) < 0); assertEquals(true, test2.year().compareTo(test1) > 0); assertEquals(true, test1.year().compareTo(test1) == 0); try { test1.year().compareTo((ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} DateTime dt1 = new DateTime(TEST_TIME1); DateTime dt2 = new DateTime(TEST_TIME2); assertEquals(true, test1.year().compareTo(dt2) < 0); assertEquals(true, test2.year().compareTo(dt1) > 0); assertEquals(true, test1.year().compareTo(dt1) == 0); try { test1.year().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testPropertyGetMonth() { LocalDateTime test = new LocalDateTime(1972, 6, 9, 10, 20, 30, 40); assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField()); assertEquals("monthOfYear", test.monthOfYear().getName()); assertEquals("Property[monthOfYear]", test.monthOfYear().toString()); assertSame(test, test.monthOfYear().getLocalDateTime()); assertEquals(6, test.monthOfYear().get()); assertEquals("6", test.monthOfYear().getAsString()); assertEquals("June", test.monthOfYear().getAsText()); assertEquals("juin", test.monthOfYear().getAsText(Locale.FRENCH)); assertEquals("Jun", test.monthOfYear().getAsShortText()); assertEquals("juin", test.monthOfYear().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField()); assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField()); assertEquals(9, test.monthOfYear().getMaximumTextLength(null)); assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null)); test = new LocalDateTime(1972, 7, 9, 10, 20, 30, 40); assertEquals("juillet", test.monthOfYear().getAsText(Locale.FRENCH)); assertEquals("juil.", test.monthOfYear().getAsShortText(Locale.FRENCH)); } public void testPropertyGetMaxMinValuesMonth() { LocalDateTime test = new LocalDateTime(1972, 6, 9, 10, 20, 30, 40); assertEquals(1, test.monthOfYear().getMinimumValue()); assertEquals(1, test.monthOfYear().getMinimumValueOverall()); assertEquals(12, test.monthOfYear().getMaximumValue()); assertEquals(12, test.monthOfYear().getMaximumValueOverall()); } public void testPropertyAddToCopyMonth() { LocalDateTime test = new LocalDateTime(1972, 6, 9, 10, 20, 30, 40); LocalDateTime copy = test.monthOfYear().addToCopy(6); check(test, 1972, 6, 9, 10, 20, 30, 40); check(copy, 1972, 12, 9, 10, 20, 30, 40); copy = test.monthOfYear().addToCopy(7); check(copy, 1973, 1, 9, 10, 20, 30, 40); copy = test.monthOfYear().addToCopy(-5); check(copy, 1972, 1, 9, 10, 20, 30, 40); copy = test.monthOfYear().addToCopy(-6); check(copy, 1971, 12, 9, 10, 20, 30, 40); test = new LocalDateTime(1972, 1, 31, 10, 20, 30, 40); copy = test.monthOfYear().addToCopy(1); check(copy, 1972, 2, 29, 10, 20, 30, 40); copy = test.monthOfYear().addToCopy(2); check(copy, 1972, 3, 31, 10, 20, 30, 40); copy = test.monthOfYear().addToCopy(3); check(copy, 1972, 4, 30, 10, 20, 30, 40); test = new LocalDateTime(1971, 1, 31, 10, 20, 30, 40); copy = test.monthOfYear().addToCopy(1); check(copy, 1971, 2, 28, 10, 20, 30, 40); } public void testPropertyAddWrapFieldToCopyMonth() { LocalDateTime test = new LocalDateTime(1972, 6, 9, 10, 20, 30, 40); LocalDateTime copy = test.monthOfYear().addWrapFieldToCopy(4); check(test, 1972, 6, 9, 10, 20, 30, 40); check(copy, 1972, 10, 9, 10, 20, 30, 40); copy = test.monthOfYear().addWrapFieldToCopy(8); check(copy, 1972, 2, 9, 10, 20, 30, 40); copy = test.monthOfYear().addWrapFieldToCopy(-8); check(copy, 1972, 10, 9, 10, 20, 30, 40); test = new LocalDateTime(1972, 1, 31, 10, 20, 30, 40); copy = test.monthOfYear().addWrapFieldToCopy(1); check(copy, 1972, 2, 29, 10, 20, 30, 40); copy = test.monthOfYear().addWrapFieldToCopy(2); check(copy, 1972, 3, 31, 10, 20, 30, 40); copy = test.monthOfYear().addWrapFieldToCopy(3); check(copy, 1972, 4, 30, 10, 20, 30, 40); test = new LocalDateTime(1971, 1, 31, 10, 20, 30, 40); copy = test.monthOfYear().addWrapFieldToCopy(1); check(copy, 1971, 2, 28, 10, 20, 30, 40); } public void testPropertySetCopyMonth() { LocalDateTime test = new LocalDateTime(1972, 6, 9, 10, 20, 30, 40); LocalDateTime copy = test.monthOfYear().setCopy(12); check(test, 1972, 6, 9, 10, 20, 30, 40); check(copy, 1972, 12, 9, 10, 20, 30, 40); test = new LocalDateTime(1972, 1, 31, 10, 20, 30, 40); copy = test.monthOfYear().setCopy(2); check(copy, 1972, 2, 29, 10, 20, 30, 40); try { test.monthOfYear().setCopy(13); fail(); } catch (IllegalArgumentException ex) {} try { test.monthOfYear().setCopy(0); fail(); } catch (IllegalArgumentException ex) {} } public void testPropertySetCopyTextMonth() { LocalDateTime test = new LocalDateTime(1972, 6, 9, 10, 20, 30, 40); LocalDateTime copy = test.monthOfYear().setCopy("12"); check(test, 1972, 6, 9, 10, 20, 30, 40); check(copy, 1972, 12, 9, 10, 20, 30, 40); copy = test.monthOfYear().setCopy("December"); check(test, 1972, 6, 9, 10, 20, 30, 40); check(copy, 1972, 12, 9, 10, 20, 30, 40); copy = test.monthOfYear().setCopy("Dec"); check(test, 1972, 6, 9, 10, 20, 30, 40); check(copy, 1972, 12, 9, 10, 20, 30, 40); } public void testPropertyCompareToMonth() { LocalDateTime test1 = new LocalDateTime(TEST_TIME1); LocalDateTime test2 = new LocalDateTime(TEST_TIME2); assertEquals(true, test1.monthOfYear().compareTo(test2) < 0); assertEquals(true, test2.monthOfYear().compareTo(test1) > 0); assertEquals(true, test1.monthOfYear().compareTo(test1) == 0); try { test1.monthOfYear().compareTo((ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} DateTime dt1 = new DateTime(TEST_TIME1); DateTime dt2 = new DateTime(TEST_TIME2); assertEquals(true, test1.monthOfYear().compareTo(dt2) < 0); assertEquals(true, test2.monthOfYear().compareTo(dt1) > 0); assertEquals(true, test1.monthOfYear().compareTo(dt1) == 0); try { test1.monthOfYear().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testPropertyGetDay() { LocalDateTime test = new LocalDateTime(1972, 6, 9, 10, 20, 30, 40); assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField()); assertEquals("dayOfMonth", test.dayOfMonth().getName()); assertEquals("Property[dayOfMonth]", test.dayOfMonth().toString()); assertSame(test, test.dayOfMonth().getLocalDateTime()); assertEquals(9, test.dayOfMonth().get()); assertEquals("9", test.dayOfMonth().getAsString()); assertEquals("9", test.dayOfMonth().getAsText()); assertEquals("9", test.dayOfMonth().getAsText(Locale.FRENCH)); assertEquals("9", test.dayOfMonth().getAsShortText()); assertEquals("9", test.dayOfMonth().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField()); assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField()); assertEquals(2, test.dayOfMonth().getMaximumTextLength(null)); assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null)); } public void testPropertyGetMaxMinValuesDay() { LocalDateTime test = new LocalDateTime(1972, 6, 9, 10, 20, 30, 40); assertEquals(1, test.dayOfMonth().getMinimumValue()); assertEquals(1, test.dayOfMonth().getMinimumValueOverall()); assertEquals(30, test.dayOfMonth().getMaximumValue()); assertEquals(31, test.dayOfMonth().getMaximumValueOverall()); test = new LocalDateTime(1972, 7, 9, 10, 20, 30, 40); assertEquals(31, test.dayOfMonth().getMaximumValue()); test = new LocalDateTime(1972, 2, 9, 10, 20, 30, 40); assertEquals(29, test.dayOfMonth().getMaximumValue()); test = new LocalDateTime(1971, 2, 9, 10, 20, 30, 40); assertEquals(28, test.dayOfMonth().getMaximumValue()); } public void testPropertyAddToCopyDay() { LocalDateTime test = new LocalDateTime(1972, 6, 9, 10, 20, 30, 40); LocalDateTime copy = test.dayOfMonth().addToCopy(9); check(test, 1972, 6, 9, 10, 20, 30, 40); check(copy, 1972, 6, 18, 10, 20, 30, 40); copy = test.dayOfMonth().addToCopy(21); check(copy, 1972, 6, 30, 10, 20, 30, 40); copy = test.dayOfMonth().addToCopy(22); check(copy, 1972, 7, 1, 10, 20, 30, 40); copy = test.dayOfMonth().addToCopy(22 + 30); check(copy, 1972, 7, 31, 10, 20, 30, 40); copy = test.dayOfMonth().addToCopy(22 + 31); check(copy, 1972, 8, 1, 10, 20, 30, 40); copy = test.dayOfMonth().addToCopy(21 + 31 + 31 + 30 + 31 + 30 + 31); check(copy, 1972, 12, 31, 10, 20, 30, 40); copy = test.dayOfMonth().addToCopy(22 + 31 + 31 + 30 + 31 + 30 + 31); check(copy, 1973, 1, 1, 10, 20, 30, 40); copy = test.dayOfMonth().addToCopy(-8); check(copy, 1972, 6, 1, 10, 20, 30, 40); copy = test.dayOfMonth().addToCopy(-9); check(copy, 1972, 5, 31, 10, 20, 30, 40); copy = test.dayOfMonth().addToCopy(-8 - 31 - 30 - 31 - 29 - 31); check(copy, 1972, 1, 1, 10, 20, 30, 40); copy = test.dayOfMonth().addToCopy(-9 - 31 - 30 - 31 - 29 - 31); check(copy, 1971, 12, 31, 10, 20, 30, 40); } public void testPropertyAddWrapFieldToCopyDay() { LocalDateTime test = new LocalDateTime(1972, 6, 9, 10, 20, 30, 40); LocalDateTime copy = test.dayOfMonth().addWrapFieldToCopy(21); check(test, 1972, 6, 9, 10, 20, 30, 40); check(copy, 1972, 6, 30, 10, 20, 30, 40); copy = test.dayOfMonth().addWrapFieldToCopy(22); check(copy, 1972, 6, 1, 10, 20, 30, 40); copy = test.dayOfMonth().addWrapFieldToCopy(-12); check(copy, 1972, 6, 27, 10, 20, 30, 40); test = new LocalDateTime(1972, 7, 9, 10, 20, 30, 40); copy = test.dayOfMonth().addWrapFieldToCopy(21); check(copy, 1972, 7, 30, 10, 20, 30, 40); copy = test.dayOfMonth().addWrapFieldToCopy(22); check(copy, 1972, 7, 31, 10, 20, 30, 40); copy = test.dayOfMonth().addWrapFieldToCopy(23); check(copy, 1972, 7, 1, 10, 20, 30, 40); copy = test.dayOfMonth().addWrapFieldToCopy(-12); check(copy, 1972, 7, 28, 10, 20, 30, 40); } public void testPropertySetCopyDay() { LocalDateTime test = new LocalDateTime(1972, 6, 9, 10, 20, 30, 40); LocalDateTime copy = test.dayOfMonth().setCopy(12); check(test, 1972, 6, 9, 10, 20, 30, 40); check(copy, 1972, 6, 12, 10, 20, 30, 40); try { test.dayOfMonth().setCopy(31); fail(); } catch (IllegalArgumentException ex) {} try { test.dayOfMonth().setCopy(0); fail(); } catch (IllegalArgumentException ex) {} } public void testPropertySetCopyTextDay() { LocalDateTime test = new LocalDateTime(1972, 6, 9, 10, 20, 30, 40); LocalDateTime copy = test.dayOfMonth().setCopy("12"); check(test, 1972, 6, 9, 10, 20, 30, 40); check(copy, 1972, 6, 12, 10, 20, 30, 40); } public void testPropertyWithMaximumValueDayOfMonth() { LocalDateTime test = new LocalDateTime(1972, 6, 9, 10, 20, 30, 40); LocalDateTime copy = test.dayOfMonth().withMaximumValue(); check(test, 1972, 6, 9, 10, 20, 30, 40); check(copy, 1972, 6, 30, 10, 20, 30, 40); } public void testPropertyWithMinimumValueDayOfMonth() { LocalDateTime test = new LocalDateTime(1972, 6, 9, 10, 20, 30, 40); LocalDateTime copy = test.dayOfMonth().withMinimumValue(); check(test, 1972, 6, 9, 10, 20, 30, 40); check(copy, 1972, 6, 1, 10, 20, 30, 40); } public void testPropertyCompareToDay() { LocalDateTime test1 = new LocalDateTime(TEST_TIME1); LocalDateTime test2 = new LocalDateTime(TEST_TIME2); assertEquals(true, test1.dayOfMonth().compareTo(test2) < 0); assertEquals(true, test2.dayOfMonth().compareTo(test1) > 0); assertEquals(true, test1.dayOfMonth().compareTo(test1) == 0); try { test1.dayOfMonth().compareTo((ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} DateTime dt1 = new DateTime(TEST_TIME1); DateTime dt2 = new DateTime(TEST_TIME2); assertEquals(true, test1.dayOfMonth().compareTo(dt2) < 0); assertEquals(true, test2.dayOfMonth().compareTo(dt1) > 0); assertEquals(true, test1.dayOfMonth().compareTo(dt1) == 0); try { test1.dayOfMonth().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} } public void testPropertyEquals() { LocalDateTime test1 = new LocalDateTime(2005, 11, 8, 10, 20, 30, 40); LocalDateTime test2 = new LocalDateTime(2005, 11, 9, 10, 20, 30, 40); LocalDateTime test3 = new LocalDateTime(2005, 11, 8, 10, 20, 30, 40, COPTIC_UTC); assertEquals(false, test1.dayOfMonth().equals(test1.year())); assertEquals(false, test1.dayOfMonth().equals(test1.monthOfYear())); assertEquals(true, test1.dayOfMonth().equals(test1.dayOfMonth())); assertEquals(false, test1.dayOfMonth().equals(test2.year())); assertEquals(false, test1.dayOfMonth().equals(test2.monthOfYear())); assertEquals(false, test1.dayOfMonth().equals(test2.dayOfMonth())); assertEquals(false, test1.monthOfYear().equals(test1.year())); assertEquals(true, test1.monthOfYear().equals(test1.monthOfYear())); assertEquals(false, test1.monthOfYear().equals(test1.dayOfMonth())); assertEquals(false, test1.monthOfYear().equals(test2.year())); assertEquals(true, test1.monthOfYear().equals(test2.monthOfYear())); assertEquals(false, test1.monthOfYear().equals(test2.dayOfMonth())); assertEquals(false, test1.dayOfMonth().equals(null)); assertEquals(false, test1.dayOfMonth().equals("any")); // chrono assertEquals(false, test1.dayOfMonth().equals(test3.dayOfMonth())); } public void testPropertyHashCode() { LocalDateTime test1 = new LocalDateTime(2005, 11, 8, 10, 20, 30, 40); LocalDateTime test2 = new LocalDateTime(2005, 11, 9, 10, 20, 30, 40); assertEquals(true, test1.dayOfMonth().hashCode() == test1.dayOfMonth().hashCode()); assertEquals(false, test1.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode()); assertEquals(true, test1.monthOfYear().hashCode() == test1.monthOfYear().hashCode()); assertEquals(true, test1.monthOfYear().hashCode() == test2.monthOfYear().hashCode()); } //----------------------------------------------------------------------- public void testPropertyGetHour() { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40); assertSame(test.getChronology().hourOfDay(), test.hourOfDay().getField()); assertEquals("hourOfDay", test.hourOfDay().getName()); assertEquals("Property[hourOfDay]", test.hourOfDay().toString()); assertSame(test, test.hourOfDay().getLocalDateTime()); assertEquals(10, test.hourOfDay().get()); assertEquals("10", test.hourOfDay().getAsString()); assertEquals("10", test.hourOfDay().getAsText()); assertEquals("10", test.hourOfDay().getAsText(Locale.FRENCH)); assertEquals("10", test.hourOfDay().getAsShortText()); assertEquals("10", test.hourOfDay().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().hours(), test.hourOfDay().getDurationField()); assertEquals(test.getChronology().days(), test.hourOfDay().getRangeDurationField()); assertEquals(2, test.hourOfDay().getMaximumTextLength(null)); assertEquals(2, test.hourOfDay().getMaximumShortTextLength(null)); } public void testPropertyRoundHour() { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20); check(test.hourOfDay().roundCeilingCopy(), 2005, 6, 9, 11, 0, 0, 0); check(test.hourOfDay().roundFloorCopy(), 2005, 6, 9, 10, 0, 0, 0); check(test.hourOfDay().roundHalfCeilingCopy(), 2005, 6, 9, 10, 0, 0, 0); check(test.hourOfDay().roundHalfFloorCopy(), 2005, 6, 9, 10, 0, 0, 0); check(test.hourOfDay().roundHalfEvenCopy(), 2005, 6, 9, 10, 0, 0, 0); test = new LocalDateTime(2005, 6, 9, 10, 40); check(test.hourOfDay().roundCeilingCopy(), 2005, 6, 9, 11, 0, 0, 0); check(test.hourOfDay().roundFloorCopy(), 2005, 6, 9, 10, 0, 0, 0); check(test.hourOfDay().roundHalfCeilingCopy(), 2005, 6, 9, 11, 0, 0, 0); check(test.hourOfDay().roundHalfFloorCopy(), 2005, 6, 9, 11, 0, 0, 0); check(test.hourOfDay().roundHalfEvenCopy(), 2005, 6, 9, 11, 0, 0, 0); test = new LocalDateTime(2005, 6, 9, 10, 30); check(test.hourOfDay().roundCeilingCopy(), 2005, 6, 9, 11, 0, 0, 0); check(test.hourOfDay().roundFloorCopy(), 2005, 6, 9, 10, 0, 0, 0); check(test.hourOfDay().roundHalfCeilingCopy(), 2005, 6, 9, 11, 0, 0, 0); check(test.hourOfDay().roundHalfFloorCopy(), 2005, 6, 9, 10, 0, 0, 0); check(test.hourOfDay().roundHalfEvenCopy(), 2005, 6, 9, 10, 0, 0, 0); test = new LocalDateTime(2005, 6, 9, 11, 30); check(test.hourOfDay().roundCeilingCopy(), 2005, 6, 9, 12, 0, 0, 0); check(test.hourOfDay().roundFloorCopy(), 2005, 6, 9, 11, 0, 0, 0); check(test.hourOfDay().roundHalfCeilingCopy(), 2005, 6, 9, 12, 0, 0, 0); check(test.hourOfDay().roundHalfFloorCopy(), 2005, 6, 9, 11, 0, 0, 0); check(test.hourOfDay().roundHalfEvenCopy(), 2005, 6, 9, 12, 0, 0, 0); } public void testPropertyGetMaxMinValuesHour() { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40); assertEquals(0, test.hourOfDay().getMinimumValue()); assertEquals(0, test.hourOfDay().getMinimumValueOverall()); assertEquals(23, test.hourOfDay().getMaximumValue()); assertEquals(23, test.hourOfDay().getMaximumValueOverall()); } public void testPropertyWithMaxMinValueHour() { LocalDateTime test = new LocalDateTime(2005, 6, 9, 0, 20, 30, 40); check(test.hourOfDay().withMaximumValue(), 2005, 6, 9, 23, 20, 30, 40); check(test.hourOfDay().withMinimumValue(), 2005, 6, 9, 0, 20, 30, 40); } public void testPropertyAddToCopyHour() { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40); LocalDateTime copy = test.hourOfDay().addToCopy(9); check(test, 2005, 6, 9, 10, 20, 30, 40); check(copy, 2005, 6, 9, 19, 20, 30, 40); copy = test.hourOfDay().addToCopy(0); check(copy, 2005, 6, 9, 10, 20, 30, 40); copy = test.hourOfDay().addToCopy(13); check(copy, 2005, 6, 9, 23, 20, 30, 40); copy = test.hourOfDay().addToCopy(14); check(copy, 2005, 6, 10, 0, 20, 30, 40); copy = test.hourOfDay().addToCopy(-10); check(copy, 2005, 6, 9, 0, 20, 30, 40); copy = test.hourOfDay().addToCopy(-11); check(copy, 2005, 6, 8, 23, 20, 30, 40); } public void testPropertyAddWrapFieldToCopyHour() { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40); LocalDateTime copy = test.hourOfDay().addWrapFieldToCopy(9); check(test, 2005, 6, 9, 10, 20, 30, 40); check(copy, 2005, 6, 9, 19, 20, 30, 40); copy = test.hourOfDay().addWrapFieldToCopy(0); check(copy, 2005, 6, 9, 10, 20, 30, 40); copy = test.hourOfDay().addWrapFieldToCopy(18); check(copy, 2005, 6, 9, 4, 20, 30, 40); copy = test.hourOfDay().addWrapFieldToCopy(-15); check(copy, 2005, 6, 9, 19, 20, 30, 40); } public void testPropertySetHour() { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40); LocalDateTime copy = test.hourOfDay().setCopy(12); check(test, 2005, 6, 9, 10, 20, 30, 40); check(copy, 2005, 6, 9, 12, 20, 30, 40); try { test.hourOfDay().setCopy(24); fail(); } catch (IllegalArgumentException ex) {} try { test.hourOfDay().setCopy(-1); fail(); } catch (IllegalArgumentException ex) {} } public void testPropertySetTextHour() { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40); LocalDateTime copy = test.hourOfDay().setCopy("12"); check(test, 2005, 6, 9, 10, 20, 30, 40); check(copy, 2005, 6, 9, 12, 20, 30, 40); } public void testPropertyWithMaximumValueHour() { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40); LocalDateTime copy = test.hourOfDay().withMaximumValue(); check(test, 2005, 6, 9, 10, 20, 30, 40); check(copy, 2005, 6, 9, 23, 20, 30, 40); } public void testPropertyWithMinimumValueHour() { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40); LocalDateTime copy = test.hourOfDay().withMinimumValue(); check(test, 2005, 6, 9, 10, 20, 30, 40); check(copy, 2005, 6, 9, 0, 20, 30, 40); } public void testPropertyCompareToHour() { LocalDateTime test1 = new LocalDateTime(TEST_TIME1); LocalDateTime test2 = new LocalDateTime(TEST_TIME2); assertEquals(true, test1.hourOfDay().compareTo(test2) < 0); assertEquals(true, test2.hourOfDay().compareTo(test1) > 0); assertEquals(true, test1.hourOfDay().compareTo(test1) == 0); try { test1.hourOfDay().compareTo((ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} DateTime dt1 = new DateTime(TEST_TIME1); DateTime dt2 = new DateTime(TEST_TIME2); assertEquals(true, test1.hourOfDay().compareTo(dt2) < 0); assertEquals(true, test2.hourOfDay().compareTo(dt1) > 0); assertEquals(true, test1.hourOfDay().compareTo(dt1) == 0); try { test1.hourOfDay().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testPropertyGetMinute() { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40); assertSame(test.getChronology().minuteOfHour(), test.minuteOfHour().getField()); assertEquals("minuteOfHour", test.minuteOfHour().getName()); assertEquals("Property[minuteOfHour]", test.minuteOfHour().toString()); assertSame(test, test.minuteOfHour().getLocalDateTime()); assertEquals(20, test.minuteOfHour().get()); assertEquals("20", test.minuteOfHour().getAsString()); assertEquals("20", test.minuteOfHour().getAsText()); assertEquals("20", test.minuteOfHour().getAsText(Locale.FRENCH)); assertEquals("20", test.minuteOfHour().getAsShortText()); assertEquals("20", test.minuteOfHour().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().minutes(), test.minuteOfHour().getDurationField()); assertEquals(test.getChronology().hours(), test.minuteOfHour().getRangeDurationField()); assertEquals(2, test.minuteOfHour().getMaximumTextLength(null)); assertEquals(2, test.minuteOfHour().getMaximumShortTextLength(null)); } public void testPropertyGetMaxMinValuesMinute() { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40); assertEquals(0, test.minuteOfHour().getMinimumValue()); assertEquals(0, test.minuteOfHour().getMinimumValueOverall()); assertEquals(59, test.minuteOfHour().getMaximumValue()); assertEquals(59, test.minuteOfHour().getMaximumValueOverall()); } public void testPropertyWithMaxMinValueMinute() { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40); check(test.minuteOfHour().withMaximumValue(), 2005, 6, 9, 10, 59, 30, 40); check(test.minuteOfHour().withMinimumValue(), 2005, 6, 9, 10, 0, 30, 40); } public void testPropertyAddToCopyMinute() { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40); LocalDateTime copy = test.minuteOfHour().addToCopy(9); check(test, 2005, 6, 9, 10, 20, 30, 40); check(copy, 2005, 6, 9, 10, 29, 30, 40); copy = test.minuteOfHour().addToCopy(39); check(copy, 2005, 6, 9, 10, 59, 30, 40); copy = test.minuteOfHour().addToCopy(40); check(copy, 2005, 6, 9, 11, 0, 30, 40); copy = test.minuteOfHour().addToCopy(1 * 60 + 45); check(copy, 2005, 6, 9, 12, 5, 30, 40); copy = test.minuteOfHour().addToCopy(13 * 60 + 39); check(copy, 2005, 6, 9, 23, 59, 30, 40); copy = test.minuteOfHour().addToCopy(13 * 60 + 40); check(copy, 2005, 6, 10, 0, 0, 30, 40); copy = test.minuteOfHour().addToCopy(-9); check(copy, 2005, 6, 9, 10, 11, 30, 40); copy = test.minuteOfHour().addToCopy(-19); check(copy, 2005, 6, 9, 10, 1, 30, 40); copy = test.minuteOfHour().addToCopy(-20); check(copy, 2005, 6, 9, 10, 0, 30, 40); copy = test.minuteOfHour().addToCopy(-21); check(copy, 2005, 6, 9, 9, 59, 30, 40); copy = test.minuteOfHour().addToCopy(-(10 * 60 + 20)); check(copy, 2005, 6, 9, 0, 0, 30, 40); copy = test.minuteOfHour().addToCopy(-(10 * 60 + 21)); check(copy, 2005, 6, 8, 23, 59, 30, 40); } public void testPropertyAddWrapFieldToCopyMinute() { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40); LocalDateTime copy = test.minuteOfHour().addWrapFieldToCopy(9); check(test, 2005, 6, 9, 10, 20, 30, 40); check(copy, 2005, 6, 9, 10, 29, 30, 40); copy = test.minuteOfHour().addWrapFieldToCopy(49); check(copy, 2005, 6, 9, 10, 9, 30, 40); copy = test.minuteOfHour().addWrapFieldToCopy(-47); check(copy, 2005, 6, 9, 10, 33, 30, 40); } public void testPropertySetMinute() { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40); LocalDateTime copy = test.minuteOfHour().setCopy(12); check(test, 2005, 6, 9, 10, 20, 30, 40); check(copy, 2005, 6, 9, 10, 12, 30, 40); try { test.minuteOfHour().setCopy(60); fail(); } catch (IllegalArgumentException ex) {} try { test.minuteOfHour().setCopy(-1); fail(); } catch (IllegalArgumentException ex) {} } public void testPropertySetTextMinute() { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40); LocalDateTime copy = test.minuteOfHour().setCopy("12"); check(test, 2005, 6, 9, 10, 20, 30, 40); check(copy, 2005, 6, 9, 10, 12, 30, 40); } public void testPropertyCompareToMinute() { LocalDateTime test1 = new LocalDateTime(TEST_TIME1); LocalDateTime test2 = new LocalDateTime(TEST_TIME2); assertEquals(true, test1.minuteOfHour().compareTo(test2) < 0); assertEquals(true, test2.minuteOfHour().compareTo(test1) > 0); assertEquals(true, test1.minuteOfHour().compareTo(test1) == 0); try { test1.minuteOfHour().compareTo((ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} DateTime dt1 = new DateTime(TEST_TIME1); DateTime dt2 = new DateTime(TEST_TIME2); assertEquals(true, test1.minuteOfHour().compareTo(dt2) < 0); assertEquals(true, test2.minuteOfHour().compareTo(dt1) > 0); assertEquals(true, test1.minuteOfHour().compareTo(dt1) == 0); try { test1.minuteOfHour().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testPropertyGetSecond() { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40); assertSame(test.getChronology().secondOfMinute(), test.secondOfMinute().getField()); assertEquals("secondOfMinute", test.secondOfMinute().getName()); assertEquals("Property[secondOfMinute]", test.secondOfMinute().toString()); assertSame(test, test.secondOfMinute().getLocalDateTime()); assertEquals(30, test.secondOfMinute().get()); assertEquals("30", test.secondOfMinute().getAsString()); assertEquals("30", test.secondOfMinute().getAsText()); assertEquals("30", test.secondOfMinute().getAsText(Locale.FRENCH)); assertEquals("30", test.secondOfMinute().getAsShortText()); assertEquals("30", test.secondOfMinute().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().seconds(), test.secondOfMinute().getDurationField()); assertEquals(test.getChronology().minutes(), test.secondOfMinute().getRangeDurationField()); assertEquals(2, test.secondOfMinute().getMaximumTextLength(null)); assertEquals(2, test.secondOfMinute().getMaximumShortTextLength(null)); } public void testPropertyGetMaxMinValuesSecond() { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40); assertEquals(0, test.secondOfMinute().getMinimumValue()); assertEquals(0, test.secondOfMinute().getMinimumValueOverall()); assertEquals(59, test.secondOfMinute().getMaximumValue()); assertEquals(59, test.secondOfMinute().getMaximumValueOverall()); } public void testPropertyWithMaxMinValueSecond() { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40); check(test.secondOfMinute().withMaximumValue(), 2005, 6, 9, 10, 20, 59, 40); check(test.secondOfMinute().withMinimumValue(), 2005, 6, 9, 10, 20, 0, 40); } public void testPropertyAddToCopySecond() { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40); LocalDateTime copy = test.secondOfMinute().addToCopy(9); check(test, 2005, 6, 9, 10, 20, 30, 40); check(copy, 2005, 6, 9, 10, 20, 39, 40); copy = test.secondOfMinute().addToCopy(29); check(copy, 2005, 6, 9, 10, 20, 59, 40); copy = test.secondOfMinute().addToCopy(30); check(copy, 2005, 6, 9, 10, 21, 0, 40); copy = test.secondOfMinute().addToCopy(39 * 60 + 29); check(copy, 2005, 6, 9, 10, 59, 59, 40); copy = test.secondOfMinute().addToCopy(39 * 60 + 30); check(copy, 2005, 6, 9, 11, 0, 0, 40); copy = test.secondOfMinute().addToCopy(13 * 60 * 60 + 39 * 60 + 30); check(copy, 2005, 6, 10, 0, 0, 0, 40); copy = test.secondOfMinute().addToCopy(-9); check(copy, 2005, 6, 9, 10, 20, 21, 40); copy = test.secondOfMinute().addToCopy(-30); check(copy, 2005, 6, 9, 10, 20, 0, 40); copy = test.secondOfMinute().addToCopy(-31); check(copy, 2005, 6, 9, 10, 19, 59, 40); copy = test.secondOfMinute().addToCopy(-(10 * 60 * 60 + 20 * 60 + 30)); check(copy, 2005, 6, 9, 0, 0, 0, 40); copy = test.secondOfMinute().addToCopy(-(10 * 60 * 60 + 20 * 60 + 31)); check(copy, 2005, 6, 8, 23, 59, 59, 40); } public void testPropertyAddWrapFieldToCopySecond() { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40); LocalDateTime copy = test.secondOfMinute().addWrapFieldToCopy(9); check(test, 2005, 6, 9, 10, 20, 30, 40); check(copy, 2005, 6, 9, 10, 20, 39, 40); copy = test.secondOfMinute().addWrapFieldToCopy(49); check(copy, 2005, 6, 9, 10, 20, 19, 40); copy = test.secondOfMinute().addWrapFieldToCopy(-47); check(copy, 2005, 6, 9, 10, 20, 43, 40); } public void testPropertySetSecond() { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40); LocalDateTime copy = test.secondOfMinute().setCopy(12); check(test, 2005, 6, 9, 10, 20, 30, 40); check(copy, 2005, 6, 9, 10, 20, 12, 40); try { test.secondOfMinute().setCopy(60); fail(); } catch (IllegalArgumentException ex) {} try { test.secondOfMinute().setCopy(-1); fail(); } catch (IllegalArgumentException ex) {} } public void testPropertySetTextSecond() { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40); LocalDateTime copy = test.secondOfMinute().setCopy("12"); check(test, 2005, 6, 9, 10, 20, 30, 40); check(copy, 2005, 6, 9, 10, 20, 12, 40); } public void testPropertyCompareToSecond() { LocalDateTime test1 = new LocalDateTime(TEST_TIME1); LocalDateTime test2 = new LocalDateTime(TEST_TIME2); assertEquals(true, test1.secondOfMinute().compareTo(test2) < 0); assertEquals(true, test2.secondOfMinute().compareTo(test1) > 0); assertEquals(true, test1.secondOfMinute().compareTo(test1) == 0); try { test1.secondOfMinute().compareTo((ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} DateTime dt1 = new DateTime(TEST_TIME1); DateTime dt2 = new DateTime(TEST_TIME2); assertEquals(true, test1.secondOfMinute().compareTo(dt2) < 0); assertEquals(true, test2.secondOfMinute().compareTo(dt1) > 0); assertEquals(true, test1.secondOfMinute().compareTo(dt1) == 0); try { test1.secondOfMinute().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testPropertyGetMilli() { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40); assertSame(test.getChronology().millisOfSecond(), test.millisOfSecond().getField()); assertEquals("millisOfSecond", test.millisOfSecond().getName()); assertEquals("Property[millisOfSecond]", test.millisOfSecond().toString()); assertSame(test, test.millisOfSecond().getLocalDateTime()); assertEquals(40, test.millisOfSecond().get()); assertEquals("40", test.millisOfSecond().getAsString()); assertEquals("40", test.millisOfSecond().getAsText()); assertEquals("40", test.millisOfSecond().getAsText(Locale.FRENCH)); assertEquals("40", test.millisOfSecond().getAsShortText()); assertEquals("40", test.millisOfSecond().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().millis(), test.millisOfSecond().getDurationField()); assertEquals(test.getChronology().seconds(), test.millisOfSecond().getRangeDurationField()); assertEquals(3, test.millisOfSecond().getMaximumTextLength(null)); assertEquals(3, test.millisOfSecond().getMaximumShortTextLength(null)); } public void testPropertyGetMaxMinValuesMilli() { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40); assertEquals(0, test.millisOfSecond().getMinimumValue()); assertEquals(0, test.millisOfSecond().getMinimumValueOverall()); assertEquals(999, test.millisOfSecond().getMaximumValue()); assertEquals(999, test.millisOfSecond().getMaximumValueOverall()); } public void testPropertyWithMaxMinValueMilli() { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40); check(test.millisOfSecond().withMaximumValue(), 2005, 6, 9, 10, 20, 30, 999); check(test.millisOfSecond().withMinimumValue(), 2005, 6, 9, 10, 20, 30, 0); } public void testPropertyAddToCopyMilli() { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40); LocalDateTime copy = test.millisOfSecond().addToCopy(9); check(test, 2005, 6, 9, 10, 20, 30, 40); check(copy, 2005, 6, 9, 10, 20, 30, 49); copy = test.millisOfSecond().addToCopy(959); check(copy, 2005, 6, 9, 10, 20, 30, 999); copy = test.millisOfSecond().addToCopy(960); check(copy, 2005, 6, 9, 10, 20, 31, 0); copy = test.millisOfSecond().addToCopy(13 * 60 * 60 * 1000 + 39 * 60 * 1000 + 29 * 1000 + 959); check(copy, 2005, 6, 9, 23, 59, 59, 999); copy = test.millisOfSecond().addToCopy(13 * 60 * 60 * 1000 + 39 * 60 * 1000 + 29 * 1000 + 960); check(copy, 2005, 6, 10, 0, 0, 0, 0); copy = test.millisOfSecond().addToCopy(-9); check(copy, 2005, 6, 9, 10, 20, 30, 31); copy = test.millisOfSecond().addToCopy(-40); check(copy, 2005, 6, 9, 10, 20, 30, 0); copy = test.millisOfSecond().addToCopy(-41); check(copy, 2005, 6, 9, 10, 20, 29, 999); copy = test.millisOfSecond().addToCopy(-(10 * 60 * 60 * 1000 + 20 * 60 * 1000 + 30 * 1000 + 40)); check(copy, 2005, 6, 9, 0, 0, 0, 0); copy = test.millisOfSecond().addToCopy(-(10 * 60 * 60 * 1000 + 20 * 60 * 1000 + 30 * 1000 + 41)); check(copy, 2005, 6, 8, 23, 59, 59, 999); } public void testPropertyAddWrapFieldToCopyMilli() { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40); LocalDateTime copy = test.millisOfSecond().addWrapFieldToCopy(9); check(test, 2005, 6, 9, 10, 20, 30, 40); check(copy, 2005, 6, 9, 10, 20, 30, 49); copy = test.millisOfSecond().addWrapFieldToCopy(995); check(copy, 2005, 6, 9, 10, 20, 30, 35); copy = test.millisOfSecond().addWrapFieldToCopy(-47); check(copy, 2005, 6, 9, 10, 20, 30, 993); } public void testPropertySetMilli() { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40); LocalDateTime copy = test.millisOfSecond().setCopy(12); check(test, 2005, 6, 9, 10, 20, 30, 40); check(copy, 2005, 6, 9, 10, 20, 30, 12); try { test.millisOfSecond().setCopy(1000); fail(); } catch (IllegalArgumentException ex) {} try { test.millisOfSecond().setCopy(-1); fail(); } catch (IllegalArgumentException ex) {} } public void testPropertySetTextMilli() { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40); LocalDateTime copy = test.millisOfSecond().setCopy("12"); check(test, 2005, 6, 9, 10, 20, 30, 40); check(copy, 2005, 6, 9, 10, 20, 30, 12); } public void testPropertyCompareToMilli() { LocalDateTime test1 = new LocalDateTime(TEST_TIME1); LocalDateTime test2 = new LocalDateTime(TEST_TIME2); assertEquals(true, test1.millisOfSecond().compareTo(test2) < 0); assertEquals(true, test2.millisOfSecond().compareTo(test1) > 0); assertEquals(true, test1.millisOfSecond().compareTo(test1) == 0); try { test1.millisOfSecond().compareTo((ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} DateTime dt1 = new DateTime(TEST_TIME1); DateTime dt2 = new DateTime(TEST_TIME2); assertEquals(true, test1.millisOfSecond().compareTo(dt2) < 0); assertEquals(true, test2.millisOfSecond().compareTo(dt1) > 0); assertEquals(true, test1.millisOfSecond().compareTo(dt1) == 0); try { test1.millisOfSecond().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- private void check(LocalDateTime test, int year, int month, int day, int hour, int min, int sec, int mil) { assertEquals(year, test.getYear()); assertEquals(month, test.getMonthOfYear()); assertEquals(day, test.getDayOfMonth()); assertEquals(hour, test.getHourOfDay()); assertEquals(min, test.getMinuteOfHour()); assertEquals(sec, test.getSecondOfMinute()); assertEquals(mil, test.getMillisOfSecond()); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Arrays; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import java.util.Locale; import java.util.SimpleTimeZone; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.BuddhistChronology; import org.joda.time.chrono.CopticChronology; import org.joda.time.chrono.GJChronology; import org.joda.time.chrono.GregorianChronology; import org.joda.time.chrono.ISOChronology; import org.joda.time.chrono.LenientChronology; import org.joda.time.chrono.StrictChronology; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; /** * This class is a Junit unit test for LocalDate. * * @author Stephen Colebourne */ public class TestLocalDate_Basics extends TestCase { private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo"); // private static final int OFFSET = 1; private static final GJChronology GJ_UTC = GJChronology.getInstanceUTC(); private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS); private static final Chronology COPTIC_LONDON = CopticChronology.getInstance(LONDON); private static final Chronology COPTIC_TOKYO = CopticChronology.getInstance(TOKYO); private static final Chronology COPTIC_UTC = CopticChronology.getInstanceUTC(); // private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS); private static final Chronology ISO_LONDON = ISOChronology.getInstance(LONDON); // private static final Chronology ISO_TOKYO = ISOChronology.getInstance(TOKYO); // private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC(); private static final Chronology BUDDHIST_PARIS = BuddhistChronology.getInstance(PARIS); private static final Chronology BUDDHIST_LONDON = BuddhistChronology.getInstance(LONDON); private static final Chronology BUDDHIST_TOKYO = BuddhistChronology.getInstance(TOKYO); // private static final Chronology BUDDHIST_UTC = BuddhistChronology.getInstanceUTC(); /** Mock zone simulating Asia/Gaza cutover at midnight 2007-04-01 */ private static long CUTOVER_GAZA = 1175378400000L; private static int OFFSET_GAZA = 7200000; // +02:00 private static final DateTimeZone MOCK_GAZA = new MockZone(CUTOVER_GAZA, OFFSET_GAZA, 3600); private long TEST_TIME_NOW = (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; // private long TEST_TIME1 = // (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY // + 12L * DateTimeConstants.MILLIS_PER_HOUR // + 24L * DateTimeConstants.MILLIS_PER_MINUTE; // // private long TEST_TIME2 = // (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY // + 14L * DateTimeConstants.MILLIS_PER_HOUR // + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone zone = null; private Locale systemDefaultLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestLocalDate_Basics.class); } public TestLocalDate_Basics(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); zone = DateTimeZone.getDefault(); DateTimeZone.setDefault(LONDON); systemDefaultLocale = Locale.getDefault(); Locale.setDefault(Locale.ENGLISH); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(zone); zone = null; Locale.setDefault(systemDefaultLocale); systemDefaultLocale = null; } //----------------------------------------------------------------------- public void testGet_DateTimeFieldType() { LocalDate test = new LocalDate(); assertEquals(1970, test.get(DateTimeFieldType.year())); assertEquals(6, test.get(DateTimeFieldType.monthOfYear())); assertEquals(9, test.get(DateTimeFieldType.dayOfMonth())); assertEquals(2, test.get(DateTimeFieldType.dayOfWeek())); assertEquals(160, test.get(DateTimeFieldType.dayOfYear())); assertEquals(24, test.get(DateTimeFieldType.weekOfWeekyear())); assertEquals(1970, test.get(DateTimeFieldType.weekyear())); try { test.get(null); fail(); } catch (IllegalArgumentException ex) {} try { test.get(DateTimeFieldType.hourOfDay()); fail(); } catch (IllegalArgumentException ex) {} } public void testSize() { LocalDate test = new LocalDate(); assertEquals(3, test.size()); } public void testGetFieldType_int() { LocalDate test = new LocalDate(COPTIC_PARIS); assertSame(DateTimeFieldType.year(), test.getFieldType(0)); assertSame(DateTimeFieldType.monthOfYear(), test.getFieldType(1)); assertSame(DateTimeFieldType.dayOfMonth(), test.getFieldType(2)); try { test.getFieldType(-1); } catch (IndexOutOfBoundsException ex) {} try { test.getFieldType(3); } catch (IndexOutOfBoundsException ex) {} } public void testGetFieldTypes() { LocalDate test = new LocalDate(COPTIC_PARIS); DateTimeFieldType[] fields = test.getFieldTypes(); assertSame(DateTimeFieldType.year(), fields[0]); assertSame(DateTimeFieldType.monthOfYear(), fields[1]); assertSame(DateTimeFieldType.dayOfMonth(), fields[2]); assertNotSame(test.getFieldTypes(), test.getFieldTypes()); } public void testGetField_int() { LocalDate test = new LocalDate(COPTIC_PARIS); assertSame(COPTIC_UTC.year(), test.getField(0)); assertSame(COPTIC_UTC.monthOfYear(), test.getField(1)); assertSame(COPTIC_UTC.dayOfMonth(), test.getField(2)); try { test.getField(-1); } catch (IndexOutOfBoundsException ex) {} try { test.getField(3); } catch (IndexOutOfBoundsException ex) {} } public void testGetFields() { LocalDate test = new LocalDate(COPTIC_PARIS); DateTimeField[] fields = test.getFields(); assertSame(COPTIC_UTC.year(), fields[0]); assertSame(COPTIC_UTC.monthOfYear(), fields[1]); assertSame(COPTIC_UTC.dayOfMonth(), fields[2]); assertNotSame(test.getFields(), test.getFields()); } public void testGetValue_int() { LocalDate test = new LocalDate(); assertEquals(1970, test.getValue(0)); assertEquals(6, test.getValue(1)); assertEquals(9, test.getValue(2)); try { test.getValue(-1); } catch (IndexOutOfBoundsException ex) {} try { test.getValue(3); } catch (IndexOutOfBoundsException ex) {} } public void testGetValues() { LocalDate test = new LocalDate(); int[] values = test.getValues(); assertEquals(1970, values[0]); assertEquals(6, values[1]); assertEquals(9, values[2]); assertNotSame(test.getValues(), test.getValues()); } public void testIsSupported_DateTimeFieldType() { LocalDate test = new LocalDate(COPTIC_PARIS); assertEquals(true, test.isSupported(DateTimeFieldType.year())); assertEquals(true, test.isSupported(DateTimeFieldType.monthOfYear())); assertEquals(true, test.isSupported(DateTimeFieldType.dayOfMonth())); assertEquals(true, test.isSupported(DateTimeFieldType.dayOfWeek())); assertEquals(true, test.isSupported(DateTimeFieldType.dayOfYear())); assertEquals(true, test.isSupported(DateTimeFieldType.weekOfWeekyear())); assertEquals(true, test.isSupported(DateTimeFieldType.weekyear())); assertEquals(true, test.isSupported(DateTimeFieldType.yearOfCentury())); assertEquals(true, test.isSupported(DateTimeFieldType.yearOfEra())); assertEquals(true, test.isSupported(DateTimeFieldType.centuryOfEra())); assertEquals(true, test.isSupported(DateTimeFieldType.weekyearOfCentury())); assertEquals(true, test.isSupported(DateTimeFieldType.era())); assertEquals(false, test.isSupported(DateTimeFieldType.hourOfDay())); assertEquals(false, test.isSupported((DateTimeFieldType) null)); } public void testIsSupported_DurationFieldType() { LocalDate test = new LocalDate(1970, 6, 9); assertEquals(false, test.isSupported(DurationFieldType.eras())); assertEquals(true, test.isSupported(DurationFieldType.centuries())); assertEquals(true, test.isSupported(DurationFieldType.years())); assertEquals(true, test.isSupported(DurationFieldType.months())); assertEquals(true, test.isSupported(DurationFieldType.weekyears())); assertEquals(true, test.isSupported(DurationFieldType.weeks())); assertEquals(true, test.isSupported(DurationFieldType.days())); assertEquals(false, test.isSupported(DurationFieldType.hours())); assertEquals(false, test.isSupported((DurationFieldType) null)); } @SuppressWarnings("deprecation") public void testEqualsHashCode() { LocalDate test1 = new LocalDate(1970, 6, 9, COPTIC_PARIS); LocalDate test2 = new LocalDate(1970, 6, 9, COPTIC_PARIS); assertEquals(true, test1.equals(test2)); assertEquals(true, test2.equals(test1)); assertEquals(true, test1.equals(test1)); assertEquals(true, test2.equals(test2)); assertEquals(true, test1.hashCode() == test2.hashCode()); assertEquals(true, test1.hashCode() == test1.hashCode()); assertEquals(true, test2.hashCode() == test2.hashCode()); LocalDate test3 = new LocalDate(1971, 6, 9); assertEquals(false, test1.equals(test3)); assertEquals(false, test2.equals(test3)); assertEquals(false, test3.equals(test1)); assertEquals(false, test3.equals(test2)); assertEquals(false, test1.hashCode() == test3.hashCode()); assertEquals(false, test2.hashCode() == test3.hashCode()); assertEquals(false, test1.equals("Hello")); assertEquals(true, test1.equals(new MockInstant())); assertEquals(true, test1.equals(new YearMonthDay(1970, 6, 9, COPTIC_PARIS))); assertEquals(true, test1.hashCode() == new YearMonthDay(1970, 6, 9, COPTIC_PARIS).hashCode()); assertEquals(false, test1.equals(MockPartial.EMPTY_INSTANCE)); } class MockInstant extends MockPartial { public Chronology getChronology() { return COPTIC_UTC; } public DateTimeField[] getFields() { return new DateTimeField[] { COPTIC_UTC.year(), COPTIC_UTC.monthOfYear(), COPTIC_UTC.dayOfMonth(), }; } public int[] getValues() { return new int[] {1970, 6, 9}; } } public void testEqualsHashCodeLenient() { LocalDate test1 = new LocalDate(1970, 6, 9, LenientChronology.getInstance(COPTIC_PARIS)); LocalDate test2 = new LocalDate(1970, 6, 9, LenientChronology.getInstance(COPTIC_PARIS)); assertEquals(true, test1.equals(test2)); assertEquals(true, test2.equals(test1)); assertEquals(true, test1.equals(test1)); assertEquals(true, test2.equals(test2)); assertEquals(true, test1.hashCode() == test2.hashCode()); assertEquals(true, test1.hashCode() == test1.hashCode()); assertEquals(true, test2.hashCode() == test2.hashCode()); } public void testEqualsHashCodeStrict() { LocalDate test1 = new LocalDate(1970, 6, 9, StrictChronology.getInstance(COPTIC_PARIS)); LocalDate test2 = new LocalDate(1970, 6, 9, StrictChronology.getInstance(COPTIC_PARIS)); assertEquals(true, test1.equals(test2)); assertEquals(true, test2.equals(test1)); assertEquals(true, test1.equals(test1)); assertEquals(true, test2.equals(test2)); assertEquals(true, test1.hashCode() == test2.hashCode()); assertEquals(true, test1.hashCode() == test1.hashCode()); assertEquals(true, test2.hashCode() == test2.hashCode()); } public void testEqualsHashCodeAPI() { LocalDate test = new LocalDate(1970, 6, 9, COPTIC_PARIS); int expected = 157; expected = 23 * expected + 1970; expected = 23 * expected + COPTIC_UTC.year().getType().hashCode(); expected = 23 * expected + 6; expected = 23 * expected + COPTIC_UTC.monthOfYear().getType().hashCode(); expected = 23 * expected + 9; expected = 23 * expected + COPTIC_UTC.dayOfMonth().getType().hashCode(); expected += COPTIC_UTC.hashCode(); assertEquals(expected, test.hashCode()); } //----------------------------------------------------------------------- @SuppressWarnings("deprecation") public void testCompareTo() { LocalDate test1 = new LocalDate(2005, 6, 2); LocalDate test1a = new LocalDate(2005, 6, 2); assertEquals(0, test1.compareTo(test1a)); assertEquals(0, test1a.compareTo(test1)); assertEquals(0, test1.compareTo(test1)); assertEquals(0, test1a.compareTo(test1a)); LocalDate test2 = new LocalDate(2005, 7, 2); assertEquals(-1, test1.compareTo(test2)); assertEquals(+1, test2.compareTo(test1)); LocalDate test3 = new LocalDate(2005, 7, 2, GregorianChronology.getInstanceUTC()); assertEquals(-1, test1.compareTo(test3)); assertEquals(+1, test3.compareTo(test1)); assertEquals(0, test3.compareTo(test2)); DateTimeFieldType[] types = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth(), }; int[] values = new int[] {2005, 6, 2}; Partial p = new Partial(types, values); assertEquals(0, test1.compareTo(p)); assertEquals(0, test1.compareTo(new YearMonthDay(2005, 6, 2))); try { test1.compareTo(null); fail(); } catch (NullPointerException ex) {} // try { // test1.compareTo(new Date()); // fail(); // } catch (ClassCastException ex) {} try { test1.compareTo(new TimeOfDay()); fail(); } catch (ClassCastException ex) {} Partial partial = new Partial() .with(DateTimeFieldType.centuryOfEra(), 1) .with(DateTimeFieldType.halfdayOfDay(), 0) .with(DateTimeFieldType.dayOfMonth(), 9); try { new LocalDate(1970, 6, 9).compareTo(partial); fail(); } catch (ClassCastException ex) {} } //----------------------------------------------------------------------- public void testIsEqual_LocalDate() { LocalDate test1 = new LocalDate(2005, 6, 2); LocalDate test1a = new LocalDate(2005, 6, 2); assertEquals(true, test1.isEqual(test1a)); assertEquals(true, test1a.isEqual(test1)); assertEquals(true, test1.isEqual(test1)); assertEquals(true, test1a.isEqual(test1a)); LocalDate test2 = new LocalDate(2005, 7, 2); assertEquals(false, test1.isEqual(test2)); assertEquals(false, test2.isEqual(test1)); LocalDate test3 = new LocalDate(2005, 7, 2, GregorianChronology.getInstanceUTC()); assertEquals(false, test1.isEqual(test3)); assertEquals(false, test3.isEqual(test1)); assertEquals(true, test3.isEqual(test2)); try { new LocalDate(2005, 7, 2).isEqual(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testIsBefore_LocalDate() { LocalDate test1 = new LocalDate(2005, 6, 2); LocalDate test1a = new LocalDate(2005, 6, 2); assertEquals(false, test1.isBefore(test1a)); assertEquals(false, test1a.isBefore(test1)); assertEquals(false, test1.isBefore(test1)); assertEquals(false, test1a.isBefore(test1a)); LocalDate test2 = new LocalDate(2005, 7, 2); assertEquals(true, test1.isBefore(test2)); assertEquals(false, test2.isBefore(test1)); LocalDate test3 = new LocalDate(2005, 7, 2, GregorianChronology.getInstanceUTC()); assertEquals(true, test1.isBefore(test3)); assertEquals(false, test3.isBefore(test1)); assertEquals(false, test3.isBefore(test2)); try { new LocalDate(2005, 7, 2).isBefore(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testIsAfter_LocalDate() { LocalDate test1 = new LocalDate(2005, 6, 2); LocalDate test1a = new LocalDate(2005, 6, 2); assertEquals(false, test1.isAfter(test1a)); assertEquals(false, test1a.isAfter(test1)); assertEquals(false, test1.isAfter(test1)); assertEquals(false, test1a.isAfter(test1a)); LocalDate test2 = new LocalDate(2005, 7, 2); assertEquals(false, test1.isAfter(test2)); assertEquals(true, test2.isAfter(test1)); LocalDate test3 = new LocalDate(2005, 7, 2, GregorianChronology.getInstanceUTC()); assertEquals(false, test1.isAfter(test3)); assertEquals(true, test3.isAfter(test1)); assertEquals(false, test3.isAfter(test2)); try { new LocalDate(2005, 7, 2).isAfter(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testWithField_DateTimeFieldType_int_1() { LocalDate test = new LocalDate(2004, 6, 9); LocalDate result = test.withField(DateTimeFieldType.year(), 2006); assertEquals(new LocalDate(2004, 6, 9), test); assertEquals(new LocalDate(2006, 6, 9), result); } public void testWithField_DateTimeFieldType_int_2() { LocalDate test = new LocalDate(2004, 6, 9); try { test.withField(null, 6); fail(); } catch (IllegalArgumentException ex) {} } public void testWithField_DateTimeFieldType_int_3() { LocalDate test = new LocalDate(2004, 6, 9); try { test.withField(DateTimeFieldType.hourOfDay(), 6); fail(); } catch (IllegalArgumentException ex) {} } public void testWithField_DateTimeFieldType_int_4() { LocalDate test = new LocalDate(2004, 6, 9); LocalDate result = test.withField(DateTimeFieldType.year(), 2004); assertEquals(new LocalDate(2004, 6, 9), test); assertSame(test, result); } //----------------------------------------------------------------------- public void testWithFieldAdded_DurationFieldType_int_1() { LocalDate test = new LocalDate(2004, 6, 9); LocalDate result = test.withFieldAdded(DurationFieldType.years(), 6); assertEquals(new LocalDate(2004, 6, 9), test); assertEquals(new LocalDate(2010, 6, 9), result); } public void testWithFieldAdded_DurationFieldType_int_2() { LocalDate test = new LocalDate(2004, 6, 9); try { test.withFieldAdded(null, 0); fail(); } catch (IllegalArgumentException ex) {} } public void testWithFieldAdded_DurationFieldType_int_3() { LocalDate test = new LocalDate(2004, 6, 9); try { test.withFieldAdded(null, 6); fail(); } catch (IllegalArgumentException ex) {} } public void testWithFieldAdded_DurationFieldType_int_4() { LocalDate test = new LocalDate(2004, 6, 9); LocalDate result = test.withFieldAdded(DurationFieldType.years(), 0); assertSame(test, result); } public void testWithFieldAdded_DurationFieldType_int_5() { LocalDate test = new LocalDate(2004, 6, 9); try { test.withFieldAdded(DurationFieldType.hours(), 6); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testPlus_RP() { LocalDate test = new LocalDate(2002, 5, 3, BUDDHIST_LONDON); LocalDate result = test.plus(new Period(1, 2, 3, 4, 29, 6, 7, 8)); LocalDate expected = new LocalDate(2003, 7, 28, BUDDHIST_LONDON); assertEquals(expected, result); result = test.plus((ReadablePeriod) null); assertSame(test, result); } public void testPlusYears_int() { LocalDate test = new LocalDate(2002, 5, 3, BUDDHIST_LONDON); LocalDate result = test.plusYears(1); LocalDate expected = new LocalDate(2003, 5, 3, BUDDHIST_LONDON); assertEquals(expected, result); result = test.plusYears(0); assertSame(test, result); } public void testPlusMonths_int() { LocalDate test = new LocalDate(2002, 5, 3, BUDDHIST_LONDON); LocalDate result = test.plusMonths(1); LocalDate expected = new LocalDate(2002, 6, 3, BUDDHIST_LONDON); assertEquals(expected, result); result = test.plusMonths(0); assertSame(test, result); } public void testPlusWeeks_int() { LocalDate test = new LocalDate(2002, 5, 3, BUDDHIST_LONDON); LocalDate result = test.plusWeeks(1); LocalDate expected = new LocalDate(2002, 5, 10, BUDDHIST_LONDON); assertEquals(expected, result); result = test.plusWeeks(0); assertSame(test, result); } public void testPlusDays_int() { LocalDate test = new LocalDate(2002, 5, 3, BUDDHIST_LONDON); LocalDate result = test.plusDays(1); LocalDate expected = new LocalDate(2002, 5, 4, BUDDHIST_LONDON); assertEquals(expected, result); result = test.plusDays(0); assertSame(test, result); } //----------------------------------------------------------------------- public void testMinus_RP() { LocalDate test = new LocalDate(2002, 5, 3, BUDDHIST_LONDON); LocalDate result = test.minus(new Period(1, 1, 1, 1, 1, 1, 1, 1)); // TODO breaks because it subtracts millis now, and thus goes // into the previous day LocalDate expected = new LocalDate(2001, 3, 26, BUDDHIST_LONDON); assertEquals(expected, result); result = test.minus((ReadablePeriod) null); assertSame(test, result); } public void testMinusYears_int() { LocalDate test = new LocalDate(2002, 5, 3, BUDDHIST_LONDON); LocalDate result = test.minusYears(1); LocalDate expected = new LocalDate(2001, 5, 3, BUDDHIST_LONDON); assertEquals(expected, result); result = test.minusYears(0); assertSame(test, result); } public void testMinusMonths_int() { LocalDate test = new LocalDate(2002, 5, 3, BUDDHIST_LONDON); LocalDate result = test.minusMonths(1); LocalDate expected = new LocalDate(2002, 4, 3, BUDDHIST_LONDON); assertEquals(expected, result); result = test.minusMonths(0); assertSame(test, result); } public void testMinusWeeks_int() { LocalDate test = new LocalDate(2002, 5, 3, BUDDHIST_LONDON); LocalDate result = test.minusWeeks(1); LocalDate expected = new LocalDate(2002, 4, 26, BUDDHIST_LONDON); assertEquals(expected, result); result = test.minusWeeks(0); assertSame(test, result); } public void testMinusDays_int() { LocalDate test = new LocalDate(2002, 5, 3, BUDDHIST_LONDON); LocalDate result = test.minusDays(1); LocalDate expected = new LocalDate(2002, 5, 2, BUDDHIST_LONDON); assertEquals(expected, result); result = test.minusDays(0); assertSame(test, result); } //----------------------------------------------------------------------- public void testGetters() { LocalDate test = new LocalDate(1970, 6, 9, GJ_UTC); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(160, test.getDayOfYear()); assertEquals(2, test.getDayOfWeek()); assertEquals(24, test.getWeekOfWeekyear()); assertEquals(1970, test.getWeekyear()); assertEquals(70, test.getYearOfCentury()); assertEquals(20, test.getCenturyOfEra()); assertEquals(1970, test.getYearOfEra()); assertEquals(DateTimeConstants.AD, test.getEra()); } //----------------------------------------------------------------------- public void testWithers() { LocalDate test = new LocalDate(1970, 6, 9, GJ_UTC); check(test.withYear(2000), 2000, 6, 9); check(test.withMonthOfYear(2), 1970, 2, 9); check(test.withDayOfMonth(2), 1970, 6, 2); check(test.withDayOfYear(6), 1970, 1, 6); check(test.withDayOfWeek(6), 1970, 6, 13); check(test.withWeekOfWeekyear(6), 1970, 2, 3); check(test.withWeekyear(1971), 1971, 6, 15); check(test.withYearOfCentury(60), 1960, 6, 9); check(test.withCenturyOfEra(21), 2070, 6, 9); check(test.withYearOfEra(1066), 1066, 6, 9); check(test.withEra(DateTimeConstants.BC), -1970, 6, 9); try { test.withMonthOfYear(0); fail(); } catch (IllegalArgumentException ex) {} try { test.withMonthOfYear(13); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testToDateTimeAtStartOfDay() { LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); DateTime test = base.toDateTimeAtStartOfDay(); check(base, 2005, 6, 9); assertEquals(new DateTime(2005, 6, 9, 0, 0, 0, 0, COPTIC_LONDON), test); } public void testToDateTimeAtStartOfDay_avoidDST() { LocalDate base = new LocalDate(2007, 4, 1); DateTimeZone.setDefault(MOCK_GAZA); DateTime test = base.toDateTimeAtStartOfDay(); check(base, 2007, 4, 1); assertEquals(new DateTime(2007, 4, 1, 1, 0, 0, 0, MOCK_GAZA), test); } //----------------------------------------------------------------------- public void testToDateTimeAtStartOfDay_Zone() { LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); DateTime test = base.toDateTimeAtStartOfDay(TOKYO); check(base, 2005, 6, 9); assertEquals(new DateTime(2005, 6, 9, 0, 0, 0, 0, COPTIC_TOKYO), test); } public void testToDateTimeAtStartOfDay_Zone_avoidDST() { LocalDate base = new LocalDate(2007, 4, 1); DateTime test = base.toDateTimeAtStartOfDay(MOCK_GAZA); check(base, 2007, 4, 1); assertEquals(new DateTime(2007, 4, 1, 1, 0, 0, 0, MOCK_GAZA), test); } public void testToDateTimeAtStartOfDay_nullZone() { LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); DateTime test = base.toDateTimeAtStartOfDay((DateTimeZone) null); check(base, 2005, 6, 9); assertEquals(new DateTime(2005, 6, 9, 0, 0, 0, 0, COPTIC_LONDON), test); } //----------------------------------------------------------------------- @SuppressWarnings("deprecation") public void testToDateTimeAtMidnight() { LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); DateTime test = base.toDateTimeAtMidnight(); check(base, 2005, 6, 9); assertEquals(new DateTime(2005, 6, 9, 0, 0, 0, 0, COPTIC_LONDON), test); } //----------------------------------------------------------------------- @SuppressWarnings("deprecation") public void testToDateTimeAtMidnight_Zone() { LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); DateTime test = base.toDateTimeAtMidnight(TOKYO); check(base, 2005, 6, 9); assertEquals(new DateTime(2005, 6, 9, 0, 0, 0, 0, COPTIC_TOKYO), test); } @SuppressWarnings("deprecation") public void testToDateTimeAtMidnight_nullZone() { LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); DateTime test = base.toDateTimeAtMidnight((DateTimeZone) null); check(base, 2005, 6, 9); assertEquals(new DateTime(2005, 6, 9, 0, 0, 0, 0, COPTIC_LONDON), test); } //----------------------------------------------------------------------- public void testToDateTimeAtCurrentTime() { LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9); DateTimeUtils.setCurrentMillisFixed(dt.getMillis()); DateTime test = base.toDateTimeAtCurrentTime(); check(base, 2005, 6, 9); DateTime expected = new DateTime(dt.getMillis(), COPTIC_LONDON); expected = expected.year().setCopy(2005); expected = expected.monthOfYear().setCopy(6); expected = expected.dayOfMonth().setCopy(9); assertEquals(expected, test); } //----------------------------------------------------------------------- public void testToDateTimeAtCurrentTime_Zone() { LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9); DateTimeUtils.setCurrentMillisFixed(dt.getMillis()); DateTime test = base.toDateTimeAtCurrentTime(TOKYO); check(base, 2005, 6, 9); DateTime expected = new DateTime(dt.getMillis(), COPTIC_TOKYO); expected = expected.year().setCopy(2005); expected = expected.monthOfYear().setCopy(6); expected = expected.dayOfMonth().setCopy(9); assertEquals(expected, test); } public void testToDateTimeAtCurrentTime_nullZone() { LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9); DateTimeUtils.setCurrentMillisFixed(dt.getMillis()); DateTime test = base.toDateTimeAtCurrentTime((DateTimeZone) null); check(base, 2005, 6, 9); DateTime expected = new DateTime(dt.getMillis(), COPTIC_LONDON); expected = expected.year().setCopy(2005); expected = expected.monthOfYear().setCopy(6); expected = expected.dayOfMonth().setCopy(9); assertEquals(expected, test); } //----------------------------------------------------------------------- public void testToLocalDateTime_LocalTime() { LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant LocalTime tod = new LocalTime(12, 13, 14, 15, COPTIC_TOKYO); LocalDateTime test = base.toLocalDateTime(tod); check(base, 2005, 6, 9); LocalDateTime expected = new LocalDateTime(2005, 6, 9, 12, 13, 14, 15, COPTIC_UTC); assertEquals(expected, test); } public void testToLocalDateTime_nullLocalTime() { LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant try { base.toLocalDateTime((LocalTime) null); fail(); } catch (IllegalArgumentException ex) { // expected } } public void testToLocalDateTime_wrongChronologyLocalTime() { LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant LocalTime tod = new LocalTime(12, 13, 14, 15, BUDDHIST_PARIS); // PARIS irrelevant try { base.toLocalDateTime(tod); fail(); } catch (IllegalArgumentException ex) { // expected } } //----------------------------------------------------------------------- public void testToDateTime_LocalTime() { LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant LocalTime tod = new LocalTime(12, 13, 14, 15, COPTIC_TOKYO); DateTime test = base.toDateTime(tod); check(base, 2005, 6, 9); DateTime expected = new DateTime(2005, 6, 9, 12, 13, 14, 15, COPTIC_LONDON); assertEquals(expected, test); } public void testToDateTime_nullLocalTime() { LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant long now = new DateTime(2004, 5, 8, 12, 13, 14, 15, COPTIC_LONDON).getMillis(); DateTimeUtils.setCurrentMillisFixed(now); DateTime test = base.toDateTime((LocalTime) null); check(base, 2005, 6, 9); DateTime expected = new DateTime(2005, 6, 9, 12, 13, 14, 15, COPTIC_LONDON); assertEquals(expected, test); } //----------------------------------------------------------------------- public void testToDateTime_LocalTime_Zone() { LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant LocalTime tod = new LocalTime(12, 13, 14, 15, COPTIC_TOKYO); DateTime test = base.toDateTime(tod, TOKYO); check(base, 2005, 6, 9); DateTime expected = new DateTime(2005, 6, 9, 12, 13, 14, 15, COPTIC_TOKYO); assertEquals(expected, test); } public void testToDateTime_LocalTime_nullZone() { LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant LocalTime tod = new LocalTime(12, 13, 14, 15, COPTIC_TOKYO); DateTime test = base.toDateTime(tod, null); check(base, 2005, 6, 9); DateTime expected = new DateTime(2005, 6, 9, 12, 13, 14, 15, COPTIC_LONDON); assertEquals(expected, test); } public void testToDateTime_nullLocalTime_Zone() { LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant long now = new DateTime(2004, 5, 8, 12, 13, 14, 15, COPTIC_TOKYO).getMillis(); DateTimeUtils.setCurrentMillisFixed(now); DateTime test = base.toDateTime((LocalTime) null, TOKYO); check(base, 2005, 6, 9); DateTime expected = new DateTime(2005, 6, 9, 12, 13, 14, 15, COPTIC_TOKYO); assertEquals(expected, test); } public void testToDateTime_wrongChronoLocalTime_Zone() { LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant LocalTime tod = new LocalTime(12, 13, 14, 15, BUDDHIST_TOKYO); try { base.toDateTime(tod, LONDON); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- @SuppressWarnings("deprecation") public void testToDateMidnight() { LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); DateMidnight test = base.toDateMidnight(); check(base, 2005, 6, 9); assertEquals(new DateMidnight(2005, 6, 9, COPTIC_LONDON), test); } //----------------------------------------------------------------------- @SuppressWarnings("deprecation") public void testToDateMidnight_Zone() { LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); DateMidnight test = base.toDateMidnight(TOKYO); check(base, 2005, 6, 9); assertEquals(new DateMidnight(2005, 6, 9, COPTIC_TOKYO), test); } @SuppressWarnings("deprecation") public void testToDateMidnight_nullZone() { LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); DateMidnight test = base.toDateMidnight((DateTimeZone) null); check(base, 2005, 6, 9); assertEquals(new DateMidnight(2005, 6, 9, COPTIC_LONDON), test); } //----------------------------------------------------------------------- public void testToDateTime_RI() { LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); DateTime dt = new DateTime(2002, 1, 3, 4, 5, 6, 7); DateTime test = base.toDateTime(dt); check(base, 2005, 6, 9); DateTime expected = dt; expected = expected.year().setCopy(2005); expected = expected.monthOfYear().setCopy(6); expected = expected.dayOfMonth().setCopy(9); assertEquals(expected, test); } public void testToDateTime_nullRI() { LocalDate base = new LocalDate(2005, 6, 9); DateTime dt = new DateTime(2002, 1, 3, 4, 5, 6, 7); DateTimeUtils.setCurrentMillisFixed(dt.getMillis()); DateTime test = base.toDateTime((ReadableInstant) null); check(base, 2005, 6, 9); DateTime expected = dt; expected = expected.year().setCopy(2005); expected = expected.monthOfYear().setCopy(6); expected = expected.dayOfMonth().setCopy(9); assertEquals(expected, test); } //----------------------------------------------------------------------- public void testToInterval() { LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant Interval test = base.toInterval(); check(base, 2005, 6, 9); DateTime start = base.toDateTimeAtStartOfDay(); DateTime end = start.plus(Period.days(1)); Interval expected = new Interval(start, end); assertEquals(expected, test); } //----------------------------------------------------------------------- public void testToInterval_Zone() { LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant Interval test = base.toInterval(TOKYO); check(base, 2005, 6, 9); DateTime start = base.toDateTimeAtStartOfDay(TOKYO); DateTime end = start.plus(Period.days(1)); Interval expected = new Interval(start, end); assertEquals(expected, test); } public void testToInterval_Zone_noMidnight() { LocalDate base = new LocalDate(2006, 4, 1, ISO_LONDON); // LONDON irrelevant DateTimeZone gaza = DateTimeZone.forID("Asia/Gaza"); Interval test = base.toInterval(gaza); check(base, 2006, 4, 1); DateTime start = new DateTime(2006, 4, 1, 1, 0, 0, 0, gaza); DateTime end = new DateTime(2006, 4, 2, 0, 0, 0, 0, gaza); Interval expected = new Interval(start, end); assertEquals(expected, test); } public void testToInterval_nullZone() { LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant Interval test = base.toInterval(null); check(base, 2005, 6, 9); DateTime start = base.toDateTimeAtStartOfDay(LONDON); DateTime end = start.plus(Period.days(1)); Interval expected = new Interval(start, end); assertEquals(expected, test); } //----------------------------------------------------------------------- public void testToDate_summer() { LocalDate base = new LocalDate(2005, 7, 9, COPTIC_PARIS); Date test = base.toDate(); check(base, 2005, 7, 9); GregorianCalendar gcal = new GregorianCalendar(); gcal.clear(); gcal.set(Calendar.YEAR, 2005); gcal.set(Calendar.MONTH, Calendar.JULY); gcal.set(Calendar.DAY_OF_MONTH, 9); assertEquals(gcal.getTime(), test); } public void testToDate_winter() { LocalDate base = new LocalDate(2005, 1, 9, COPTIC_PARIS); Date test = base.toDate(); check(base, 2005, 1, 9); GregorianCalendar gcal = new GregorianCalendar(); gcal.clear(); gcal.set(Calendar.YEAR, 2005); gcal.set(Calendar.MONTH, Calendar.JANUARY); gcal.set(Calendar.DAY_OF_MONTH, 9); assertEquals(gcal.getTime(), test); } public void testToDate_springDST() { LocalDate base = new LocalDate(2007, 4, 2); SimpleTimeZone testZone = new SimpleTimeZone(3600000, "NoMidnight", Calendar.APRIL, 2, 0, 0, Calendar.OCTOBER, 2, 0, 3600000); TimeZone currentZone = TimeZone.getDefault(); try { TimeZone.setDefault(testZone); Date test = base.toDate(); check(base, 2007, 4, 2); assertEquals("Mon Apr 02 01:00:00 GMT+02:00 2007", test.toString()); } finally { TimeZone.setDefault(currentZone); } } public void testToDate_springDST_2Hour40Savings() { LocalDate base = new LocalDate(2007, 4, 2); SimpleTimeZone testZone = new SimpleTimeZone(3600000, "NoMidnight", Calendar.APRIL, 2, 0, 0, Calendar.OCTOBER, 2, 0, 3600000, (3600000 / 6) * 16); TimeZone currentZone = TimeZone.getDefault(); try { TimeZone.setDefault(testZone); Date test = base.toDate(); check(base, 2007, 4, 2); assertEquals("Mon Apr 02 02:40:00 GMT+03:40 2007", test.toString()); } finally { TimeZone.setDefault(currentZone); } } public void testToDate_autumnDST() { LocalDate base = new LocalDate(2007, 10, 2); SimpleTimeZone testZone = new SimpleTimeZone(3600000, "NoMidnight", Calendar.APRIL, 2, 0, 0, Calendar.OCTOBER, 2, 0, 3600000); TimeZone currentZone = TimeZone.getDefault(); try { TimeZone.setDefault(testZone); Date test = base.toDate(); check(base, 2007, 10, 2); assertEquals("Tue Oct 02 00:00:00 GMT+02:00 2007", test.toString()); } finally { TimeZone.setDefault(currentZone); } } //----------------------------------------------------------------------- public void testProperty() { LocalDate test = new LocalDate(2005, 6, 9, GJ_UTC); assertEquals(test.year(), test.property(DateTimeFieldType.year())); assertEquals(test.monthOfYear(), test.property(DateTimeFieldType.monthOfYear())); assertEquals(test.dayOfMonth(), test.property(DateTimeFieldType.dayOfMonth())); assertEquals(test.dayOfWeek(), test.property(DateTimeFieldType.dayOfWeek())); assertEquals(test.dayOfYear(), test.property(DateTimeFieldType.dayOfYear())); assertEquals(test.weekOfWeekyear(), test.property(DateTimeFieldType.weekOfWeekyear())); assertEquals(test.weekyear(), test.property(DateTimeFieldType.weekyear())); assertEquals(test.yearOfCentury(), test.property(DateTimeFieldType.yearOfCentury())); assertEquals(test.yearOfEra(), test.property(DateTimeFieldType.yearOfEra())); assertEquals(test.centuryOfEra(), test.property(DateTimeFieldType.centuryOfEra())); assertEquals(test.era(), test.property(DateTimeFieldType.era())); try { test.property(DateTimeFieldType.millisOfDay()); fail(); } catch (IllegalArgumentException ex) {} try { test.property(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testSerialization() throws Exception { LocalDate test = new LocalDate(1972, 6, 9, COPTIC_PARIS); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(test); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); LocalDate result = (LocalDate) ois.readObject(); ois.close(); assertEquals(test, result); assertTrue(Arrays.equals(test.getValues(), result.getValues())); assertTrue(Arrays.equals(test.getFields(), result.getFields())); assertEquals(test.getChronology(), result.getChronology()); } //----------------------------------------------------------------------- public void testToString() { LocalDate test = new LocalDate(2002, 6, 9); assertEquals("2002-06-09", test.toString()); } //----------------------------------------------------------------------- public void testToString_String() { LocalDate test = new LocalDate(2002, 6, 9); assertEquals("2002 \ufffd\ufffd", test.toString("yyyy HH")); assertEquals("2002-06-09", test.toString((String) null)); } //----------------------------------------------------------------------- public void testToString_String_Locale() { LocalDate test = new LocalDate(1970, 6, 9); assertEquals("Tue 9/6", test.toString("EEE d/M", Locale.ENGLISH)); assertEquals("mar. 9/6", test.toString("EEE d/M", Locale.FRENCH)); assertEquals("1970-06-09", test.toString(null, Locale.ENGLISH)); assertEquals("Tue 9/6", test.toString("EEE d/M", null)); assertEquals("1970-06-09", test.toString(null, null)); } //----------------------------------------------------------------------- public void testToString_DTFormatter() { LocalDate test = new LocalDate(2002, 6, 9); assertEquals("2002 \ufffd\ufffd", test.toString(DateTimeFormat.forPattern("yyyy HH"))); assertEquals("2002-06-09", test.toString((DateTimeFormatter) null)); } //----------------------------------------------------------------------- private void check(LocalDate test, int hour, int min, int sec) { assertEquals(hour, test.getYear()); assertEquals(min, test.getMonthOfYear()); assertEquals(sec, test.getDayOfMonth()); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.BuddhistChronology; import org.joda.time.chrono.GregorianChronology; import org.joda.time.chrono.ISOChronology; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; /** * This class is a Junit unit test for LocalDate. * * @author Stephen Colebourne */ public class TestLocalDate_Constructors extends TestCase { private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC(); private static final Chronology BUDDHIST_UTC = BuddhistChronology.getInstanceUTC(); private static final Chronology GREGORIAN_UTC = GregorianChronology.getInstanceUTC(); private static final Chronology GREGORIAN_PARIS = GregorianChronology.getInstance(PARIS); private long TEST_TIME_NOW = (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; private long TEST_TIME1 = (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; private long TEST_TIME1_ROUNDED = (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY; private long TEST_TIME2 = (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone zone = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestLocalDate_Constructors.class); } public TestLocalDate_Constructors(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); zone = DateTimeZone.getDefault(); DateTimeZone.setDefault(LONDON); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(zone); zone = null; } //----------------------------------------------------------------------- public void testParse_noFormatter() throws Throwable { assertEquals(new LocalDate(2010, 6, 30), LocalDate.parse("2010-06-30")); assertEquals(new LocalDate(2010, 1, 2), LocalDate.parse("2010-002")); } public void testParse_formatter() throws Throwable { DateTimeFormatter f = DateTimeFormat.forPattern("yyyy--dd MM").withChronology(ISOChronology.getInstance(PARIS)); assertEquals(new LocalDate(2010, 6, 30), LocalDate.parse("2010--30 06", f)); } //----------------------------------------------------------------------- public void testFactory_fromCalendarFields() throws Exception { GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6); cal.set(Calendar.MILLISECOND, 7); LocalDate expected = new LocalDate(1970, 2, 3); assertEquals(expected, LocalDate.fromCalendarFields(cal)); } public void testFactory_fromCalendarFields_beforeYearZero1() throws Exception { GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6); cal.set(Calendar.ERA, GregorianCalendar.BC); cal.set(Calendar.MILLISECOND, 7); LocalDate expected = new LocalDate(0, 2, 3); assertEquals(expected, LocalDate.fromCalendarFields(cal)); } public void testFactory_fromCalendarFields_beforeYearZero3() throws Exception { GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6); cal.set(Calendar.ERA, GregorianCalendar.BC); cal.set(Calendar.MILLISECOND, 7); LocalDate expected = new LocalDate(-2, 2, 3); assertEquals(expected, LocalDate.fromCalendarFields(cal)); } public void testFactory_fromCalendarFields_null() throws Exception { try { LocalDate.fromCalendarFields((Calendar) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testFactory_fromDateFields_after1970() throws Exception { GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6); cal.set(Calendar.MILLISECOND, 7); LocalDate expected = new LocalDate(1970, 2, 3); assertEquals(expected, LocalDate.fromDateFields(cal.getTime())); } public void testFactory_fromDateFields_before1970() throws Exception { GregorianCalendar cal = new GregorianCalendar(1969, 1, 3, 4, 5, 6); cal.set(Calendar.MILLISECOND, 7); LocalDate expected = new LocalDate(1969, 2, 3); assertEquals(expected, LocalDate.fromDateFields(cal.getTime())); } public void testFactory_fromDateFields_beforeYearZero1() throws Exception { GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6); cal.set(Calendar.ERA, GregorianCalendar.BC); cal.set(Calendar.MILLISECOND, 7); LocalDate expected = new LocalDate(0, 2, 3); assertEquals(expected, LocalDate.fromDateFields(cal.getTime())); } public void testFactory_fromDateFields_beforeYearZero3() throws Exception { GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6); cal.set(Calendar.ERA, GregorianCalendar.BC); cal.set(Calendar.MILLISECOND, 7); LocalDate expected = new LocalDate(-2, 2, 3); assertEquals(expected, LocalDate.fromDateFields(cal.getTime())); } public void testFactory_fromDateFields_null() throws Exception { try { LocalDate.fromDateFields((Date) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testConstructor() throws Throwable { LocalDate test = new LocalDate(); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(test, LocalDate.now()); } public void testConstructor_DateTimeZone() throws Throwable { DateTime dt = new DateTime(2005, 6, 8, 23, 59, 0, 0, LONDON); DateTimeUtils.setCurrentMillisFixed(dt.getMillis()); // 23:59 in London is 00:59 the following day in Paris LocalDate test = new LocalDate(LONDON); assertEquals(ISO_UTC, test.getChronology()); assertEquals(2005, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(8, test.getDayOfMonth()); assertEquals(test, LocalDate.now(LONDON)); test = new LocalDate(PARIS); assertEquals(ISO_UTC, test.getChronology()); assertEquals(2005, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(test, LocalDate.now(PARIS)); } public void testConstructor_nullDateTimeZone() throws Throwable { DateTime dt = new DateTime(2005, 6, 8, 23, 59, 0, 0, LONDON); DateTimeUtils.setCurrentMillisFixed(dt.getMillis()); // 23:59 in London is 00:59 the following day in Paris LocalDate test = new LocalDate((DateTimeZone) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(2005, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(8, test.getDayOfMonth()); } public void testConstructor_Chronology() throws Throwable { LocalDate test = new LocalDate(GREGORIAN_PARIS); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(test, LocalDate.now(GREGORIAN_PARIS)); } public void testConstructor_nullChronology() throws Throwable { LocalDate test = new LocalDate((Chronology) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); } //----------------------------------------------------------------------- public void testConstructor_long1() throws Throwable { LocalDate test = new LocalDate(TEST_TIME1); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); } public void testConstructor_long2() throws Throwable { LocalDate test = new LocalDate(TEST_TIME2); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1971, test.getYear()); assertEquals(5, test.getMonthOfYear()); assertEquals(7, test.getDayOfMonth()); } public void testConstructor_long1_DateTimeZone() throws Throwable { LocalDate test = new LocalDate(TEST_TIME1, PARIS); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); assertEquals(TEST_TIME1_ROUNDED, test.getLocalMillis()); } public void testConstructor_long2_DateTimeZone() throws Throwable { LocalDate test = new LocalDate(TEST_TIME2, PARIS); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1971, test.getYear()); assertEquals(5, test.getMonthOfYear()); assertEquals(7, test.getDayOfMonth()); } public void testConstructor_long3_DateTimeZone() throws Throwable { DateTime dt = new DateTime(2006, 6, 9, 0, 0, 0, 0, PARIS); DateTime dtUTC = new DateTime(2006, 6, 9, 0, 0, 0, 0, DateTimeZone.UTC); LocalDate test = new LocalDate(dt.getMillis(), PARIS); assertEquals(ISO_UTC, test.getChronology()); assertEquals(2006, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(dtUTC.getMillis(), test.getLocalMillis()); } public void testConstructor_long4_DateTimeZone() throws Throwable { DateTime dt = new DateTime(2006, 6, 9, 23, 59, 59, 999, PARIS); DateTime dtUTC = new DateTime(2006, 6, 9, 0, 0, 0, 0, DateTimeZone.UTC); LocalDate test = new LocalDate(dt.getMillis(), PARIS); assertEquals(ISO_UTC, test.getChronology()); assertEquals(2006, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(dtUTC.getMillis(), test.getLocalMillis()); } public void testConstructor_long_nullDateTimeZone() throws Throwable { LocalDate test = new LocalDate(TEST_TIME1, (DateTimeZone) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); } public void testConstructor_long1_Chronology() throws Throwable { LocalDate test = new LocalDate(TEST_TIME1, GREGORIAN_PARIS); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); } public void testConstructor_long2_Chronology() throws Throwable { LocalDate test = new LocalDate(TEST_TIME2, GREGORIAN_PARIS); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(1971, test.getYear()); assertEquals(5, test.getMonthOfYear()); assertEquals(7, test.getDayOfMonth()); } public void testConstructor_long_nullChronology() throws Throwable { LocalDate test = new LocalDate(TEST_TIME1, (Chronology) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); } //----------------------------------------------------------------------- public void testConstructor_Object1() throws Throwable { Date date = new Date(TEST_TIME1); LocalDate test = new LocalDate(date); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); } public void testConstructor_nullObject() throws Throwable { LocalDate test = new LocalDate((Object) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); } public void testConstructor_ObjectString1() throws Throwable { LocalDate test = new LocalDate("1972-04-06"); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1972, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); } public void testConstructor_ObjectString2() throws Throwable { LocalDate test = new LocalDate("1972-037"); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1972, test.getYear()); assertEquals(2, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); } public void testConstructor_ObjectString3() throws Throwable { LocalDate test = new LocalDate("1972-02"); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1972, test.getYear()); assertEquals(2, test.getMonthOfYear()); assertEquals(1, test.getDayOfMonth()); } public void testConstructor_ObjectStringEx1() throws Throwable { try { new LocalDate("1970-04-06T+14:00"); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_ObjectStringEx2() throws Throwable { try { new LocalDate("1970-04-06T10:20:30.040"); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_ObjectStringEx3() throws Throwable { try { new LocalDate("1970-04-06T10:20:30.040+14:00"); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_ObjectStringEx4() throws Throwable { try { new LocalDate("T10:20:30.040"); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_ObjectStringEx5() throws Throwable { try { new LocalDate("T10:20:30.040+14:00"); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_ObjectStringEx6() throws Throwable { try { new LocalDate("10:20:30.040"); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_ObjectStringEx7() throws Throwable { try { new LocalDate("10:20:30.040+14:00"); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_ObjectLocalDate() throws Throwable { LocalDate date = new LocalDate(1970, 4, 6, BUDDHIST_UTC); LocalDate test = new LocalDate(date); assertEquals(BUDDHIST_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); } public void testConstructor_ObjectLocalTime() throws Throwable { LocalTime time = new LocalTime(10, 20, 30, 40, BUDDHIST_UTC); try { new LocalDate(time); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_ObjectLocalDateTime() throws Throwable { LocalDateTime dt = new LocalDateTime(1970, 5, 6, 10, 20, 30, 40, BUDDHIST_UTC); LocalDate test = new LocalDate(dt); assertEquals(BUDDHIST_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(5, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); } @SuppressWarnings("deprecation") public void testConstructor_ObjectYearMonthDay() throws Throwable { YearMonthDay date = new YearMonthDay(1970, 4, 6, BUDDHIST_UTC); LocalDate test = new LocalDate(date); assertEquals(BUDDHIST_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); } //----------------------------------------------------------------------- public void testConstructor_Object_DateTimeZone() throws Throwable { Date date = new Date(TEST_TIME1); LocalDate test = new LocalDate(date, PARIS); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); } public void testConstructor_nullObject_DateTimeZone() throws Throwable { LocalDate test = new LocalDate((Object) null, PARIS); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); } public void testConstructor_Object_nullDateTimeZone() throws Throwable { Date date = new Date(TEST_TIME1); LocalDate test = new LocalDate(date, (DateTimeZone) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); } public void testConstructor_nullObject_nullDateTimeZone() throws Throwable { LocalDate test = new LocalDate((Object) null, (DateTimeZone) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); } public void testConstructor_Object_Chronology() throws Throwable { Date date = new Date(TEST_TIME1); LocalDate test = new LocalDate(date, GREGORIAN_PARIS); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); } public void testConstructor_Object_Chronology_crossChronology() throws Throwable { LocalDate input = new LocalDate(1970, 4, 6, ISO_UTC); LocalDate test = new LocalDate(input, BUDDHIST_UTC); assertEquals(BUDDHIST_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); } public void testConstructor_nullObject_Chronology() throws Throwable { LocalDate test = new LocalDate((Object) null, GREGORIAN_PARIS); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); } public void testConstructor_Object_nullChronology() throws Throwable { Date date = new Date(TEST_TIME1); LocalDate test = new LocalDate(date, (Chronology) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); } public void testConstructor_nullObject_nullChronology() throws Throwable { LocalDate test = new LocalDate((Object) null, (Chronology) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); } //----------------------------------------------------------------------- public void testConstructor_int_int_int() throws Throwable { LocalDate test = new LocalDate(1970, 6, 9); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); try { new LocalDate(Integer.MIN_VALUE, 6, 9); fail(); } catch (IllegalArgumentException ex) {} try { new LocalDate(Integer.MAX_VALUE, 6, 9); fail(); } catch (IllegalArgumentException ex) {} try { new LocalDate(1970, 0, 9); fail(); } catch (IllegalArgumentException ex) {} try { new LocalDate(1970, 13, 9); fail(); } catch (IllegalArgumentException ex) {} try { new LocalDate(1970, 6, 0); fail(); } catch (IllegalArgumentException ex) {} try { new LocalDate(1970, 6, 31); fail(); } catch (IllegalArgumentException ex) {} new LocalDate(1970, 7, 31); try { new LocalDate(1970, 7, 32); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_int_int_int_Chronology() throws Throwable { LocalDate test = new LocalDate(1970, 6, 9, GREGORIAN_PARIS); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); try { new LocalDate(Integer.MIN_VALUE, 6, 9, GREGORIAN_PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new LocalDate(Integer.MAX_VALUE, 6, 9, GREGORIAN_PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new LocalDate(1970, 0, 9, GREGORIAN_PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new LocalDate(1970, 13, 9, GREGORIAN_PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new LocalDate(1970, 6, 0, GREGORIAN_PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new LocalDate(1970, 6, 31, GREGORIAN_PARIS); fail(); } catch (IllegalArgumentException ex) {} new LocalDate(1970, 7, 31, GREGORIAN_PARIS); try { new LocalDate(1970, 7, 32, GREGORIAN_PARIS); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_int_int_int_nullChronology() throws Throwable { LocalDate test = new LocalDate(1970, 6, 9, null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); } }
/* * Copyright 2001-2010 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.util.Locale; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.CopticChronology; import org.joda.time.chrono.LenientChronology; import org.joda.time.chrono.StrictChronology; /** * This class is a Junit unit test for YearMonthDay. * * @author Stephen Colebourne */ public class TestLocalDate_Properties extends TestCase { private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS); private long TEST_TIME_NOW = (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; private long TEST_TIME1 = (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; private long TEST_TIME2 = (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone zone = null; private Locale systemDefaultLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestLocalDate_Properties.class); } public TestLocalDate_Properties(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); zone = DateTimeZone.getDefault(); DateTimeZone.setDefault(DateTimeZone.UTC); systemDefaultLocale = Locale.getDefault(); Locale.setDefault(Locale.ENGLISH); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(zone); zone = null; Locale.setDefault(systemDefaultLocale); systemDefaultLocale = null; } //----------------------------------------------------------------------- public void testPropertyGetYear() { LocalDate test = new LocalDate(1972, 6, 9); assertSame(test.getChronology().year(), test.year().getField()); assertEquals("year", test.year().getName()); assertEquals("Property[year]", test.year().toString()); assertSame(test, test.year().getLocalDate()); assertEquals(1972, test.year().get()); assertEquals("1972", test.year().getAsString()); assertEquals("1972", test.year().getAsText()); assertEquals("1972", test.year().getAsText(Locale.FRENCH)); assertEquals("1972", test.year().getAsShortText()); assertEquals("1972", test.year().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().years(), test.year().getDurationField()); assertEquals(null, test.year().getRangeDurationField()); assertEquals(9, test.year().getMaximumTextLength(null)); assertEquals(9, test.year().getMaximumShortTextLength(null)); } public void testPropertyGetMaxMinValuesYear() { LocalDate test = new LocalDate(1972, 6, 9); assertEquals(-292275054, test.year().getMinimumValue()); assertEquals(-292275054, test.year().getMinimumValueOverall()); assertEquals(292278993, test.year().getMaximumValue()); assertEquals(292278993, test.year().getMaximumValueOverall()); } public void testPropertyAddToCopyYear() { LocalDate test = new LocalDate(1972, 6, 9); LocalDate copy = test.year().addToCopy(9); check(test, 1972, 6, 9); check(copy, 1981, 6, 9); copy = test.year().addToCopy(0); check(copy, 1972, 6, 9); copy = test.year().addToCopy(292278993 - 1972); check(copy, 292278993, 6, 9); try { test.year().addToCopy(292278993 - 1972 + 1); fail(); } catch (IllegalArgumentException ex) {} check(test, 1972, 6, 9); copy = test.year().addToCopy(-1972); check(copy, 0, 6, 9); copy = test.year().addToCopy(-1973); check(copy, -1, 6, 9); try { test.year().addToCopy(-292275054 - 1972 - 1); fail(); } catch (IllegalArgumentException ex) {} check(test, 1972, 6, 9); } public void testPropertyAddWrapFieldToCopyYear() { LocalDate test = new LocalDate(1972, 6, 9); LocalDate copy = test.year().addWrapFieldToCopy(9); check(test, 1972, 6, 9); check(copy, 1981, 6, 9); copy = test.year().addWrapFieldToCopy(0); check(copy, 1972, 6, 9); copy = test.year().addWrapFieldToCopy(292278993 - 1972 + 1); check(copy, -292275054, 6, 9); copy = test.year().addWrapFieldToCopy(-292275054 - 1972 - 1); check(copy, 292278993, 6, 9); } public void testPropertySetCopyYear() { LocalDate test = new LocalDate(1972, 6, 9); LocalDate copy = test.year().setCopy(12); check(test, 1972, 6, 9); check(copy, 12, 6, 9); } public void testPropertySetCopyTextYear() { LocalDate test = new LocalDate(1972, 6, 9); LocalDate copy = test.year().setCopy("12"); check(test, 1972, 6, 9); check(copy, 12, 6, 9); } public void testPropertyCompareToYear() { LocalDate test1 = new LocalDate(TEST_TIME1); LocalDate test2 = new LocalDate(TEST_TIME2); assertEquals(true, test1.year().compareTo(test2) < 0); assertEquals(true, test2.year().compareTo(test1) > 0); assertEquals(true, test1.year().compareTo(test1) == 0); try { test1.year().compareTo((ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} DateTime dt1 = new DateTime(TEST_TIME1); DateTime dt2 = new DateTime(TEST_TIME2); assertEquals(true, test1.year().compareTo(dt2) < 0); assertEquals(true, test2.year().compareTo(dt1) > 0); assertEquals(true, test1.year().compareTo(dt1) == 0); try { test1.year().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testPropertyGetMonth() { LocalDate test = new LocalDate(1972, 6, 9); assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField()); assertEquals("monthOfYear", test.monthOfYear().getName()); assertEquals("Property[monthOfYear]", test.monthOfYear().toString()); assertSame(test, test.monthOfYear().getLocalDate()); assertEquals(6, test.monthOfYear().get()); assertEquals("6", test.monthOfYear().getAsString()); assertEquals("June", test.monthOfYear().getAsText()); assertEquals("juin", test.monthOfYear().getAsText(Locale.FRENCH)); assertEquals("Jun", test.monthOfYear().getAsShortText()); assertEquals("juin", test.monthOfYear().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField()); assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField()); assertEquals(9, test.monthOfYear().getMaximumTextLength(null)); assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null)); test = new LocalDate(1972, 7, 9); assertEquals("juillet", test.monthOfYear().getAsText(Locale.FRENCH)); assertEquals("juil.", test.monthOfYear().getAsShortText(Locale.FRENCH)); } public void testPropertyGetMaxMinValuesMonth() { LocalDate test = new LocalDate(1972, 6, 9); assertEquals(1, test.monthOfYear().getMinimumValue()); assertEquals(1, test.monthOfYear().getMinimumValueOverall()); assertEquals(12, test.monthOfYear().getMaximumValue()); assertEquals(12, test.monthOfYear().getMaximumValueOverall()); } public void testPropertyAddToCopyMonth() { LocalDate test = new LocalDate(1972, 6, 9); LocalDate copy = test.monthOfYear().addToCopy(6); check(test, 1972, 6, 9); check(copy, 1972, 12, 9); copy = test.monthOfYear().addToCopy(7); check(copy, 1973, 1, 9); copy = test.monthOfYear().addToCopy(-5); check(copy, 1972, 1, 9); copy = test.monthOfYear().addToCopy(-6); check(copy, 1971, 12, 9); test = new LocalDate(1972, 1, 31); copy = test.monthOfYear().addToCopy(1); check(copy, 1972, 2, 29); copy = test.monthOfYear().addToCopy(2); check(copy, 1972, 3, 31); copy = test.monthOfYear().addToCopy(3); check(copy, 1972, 4, 30); test = new LocalDate(1971, 1, 31); copy = test.monthOfYear().addToCopy(1); check(copy, 1971, 2, 28); } public void testPropertyAddWrapFieldToCopyMonth() { LocalDate test = new LocalDate(1972, 6, 9); LocalDate copy = test.monthOfYear().addWrapFieldToCopy(4); check(test, 1972, 6, 9); check(copy, 1972, 10, 9); copy = test.monthOfYear().addWrapFieldToCopy(8); check(copy, 1972, 2, 9); copy = test.monthOfYear().addWrapFieldToCopy(-8); check(copy, 1972, 10, 9); test = new LocalDate(1972, 1, 31); copy = test.monthOfYear().addWrapFieldToCopy(1); check(copy, 1972, 2, 29); copy = test.monthOfYear().addWrapFieldToCopy(2); check(copy, 1972, 3, 31); copy = test.monthOfYear().addWrapFieldToCopy(3); check(copy, 1972, 4, 30); test = new LocalDate(1971, 1, 31); copy = test.monthOfYear().addWrapFieldToCopy(1); check(copy, 1971, 2, 28); } public void testPropertySetCopyMonth() { LocalDate test = new LocalDate(1972, 6, 9); LocalDate copy = test.monthOfYear().setCopy(12); check(test, 1972, 6, 9); check(copy, 1972, 12, 9); test = new LocalDate(1972, 1, 31); copy = test.monthOfYear().setCopy(2); check(copy, 1972, 2, 29); try { test.monthOfYear().setCopy(13); fail(); } catch (IllegalArgumentException ex) {} try { test.monthOfYear().setCopy(0); fail(); } catch (IllegalArgumentException ex) {} } public void testPropertySetCopyTextMonth() { LocalDate test = new LocalDate(1972, 6, 9); LocalDate copy = test.monthOfYear().setCopy("12"); check(test, 1972, 6, 9); check(copy, 1972, 12, 9); copy = test.monthOfYear().setCopy("December"); check(test, 1972, 6, 9); check(copy, 1972, 12, 9); copy = test.monthOfYear().setCopy("Dec"); check(test, 1972, 6, 9); check(copy, 1972, 12, 9); } public void testPropertyCompareToMonth() { LocalDate test1 = new LocalDate(TEST_TIME1); LocalDate test2 = new LocalDate(TEST_TIME2); assertEquals(true, test1.monthOfYear().compareTo(test2) < 0); assertEquals(true, test2.monthOfYear().compareTo(test1) > 0); assertEquals(true, test1.monthOfYear().compareTo(test1) == 0); try { test1.monthOfYear().compareTo((ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} DateTime dt1 = new DateTime(TEST_TIME1); DateTime dt2 = new DateTime(TEST_TIME2); assertEquals(true, test1.monthOfYear().compareTo(dt2) < 0); assertEquals(true, test2.monthOfYear().compareTo(dt1) > 0); assertEquals(true, test1.monthOfYear().compareTo(dt1) == 0); try { test1.monthOfYear().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testPropertyGetDay() { LocalDate test = new LocalDate(1972, 6, 9); assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField()); assertEquals("dayOfMonth", test.dayOfMonth().getName()); assertEquals("Property[dayOfMonth]", test.dayOfMonth().toString()); assertSame(test, test.dayOfMonth().getLocalDate()); assertEquals(9, test.dayOfMonth().get()); assertEquals("9", test.dayOfMonth().getAsString()); assertEquals("9", test.dayOfMonth().getAsText()); assertEquals("9", test.dayOfMonth().getAsText(Locale.FRENCH)); assertEquals("9", test.dayOfMonth().getAsShortText()); assertEquals("9", test.dayOfMonth().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField()); assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField()); assertEquals(2, test.dayOfMonth().getMaximumTextLength(null)); assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null)); } public void testPropertyGetMaxMinValuesDay() { LocalDate test = new LocalDate(1972, 6, 9); assertEquals(1, test.dayOfMonth().getMinimumValue()); assertEquals(1, test.dayOfMonth().getMinimumValueOverall()); assertEquals(30, test.dayOfMonth().getMaximumValue()); assertEquals(31, test.dayOfMonth().getMaximumValueOverall()); test = new LocalDate(1972, 7, 9); assertEquals(31, test.dayOfMonth().getMaximumValue()); test = new LocalDate(1972, 2, 9); assertEquals(29, test.dayOfMonth().getMaximumValue()); test = new LocalDate(1971, 2, 9); assertEquals(28, test.dayOfMonth().getMaximumValue()); } public void testPropertyAddToCopyDay() { LocalDate test = new LocalDate(1972, 6, 9); LocalDate copy = test.dayOfMonth().addToCopy(9); check(test, 1972, 6, 9); check(copy, 1972, 6, 18); copy = test.dayOfMonth().addToCopy(21); check(copy, 1972, 6, 30); copy = test.dayOfMonth().addToCopy(22); check(copy, 1972, 7, 1); copy = test.dayOfMonth().addToCopy(22 + 30); check(copy, 1972, 7, 31); copy = test.dayOfMonth().addToCopy(22 + 31); check(copy, 1972, 8, 1); copy = test.dayOfMonth().addToCopy(21 + 31 + 31 + 30 + 31 + 30 + 31); check(copy, 1972, 12, 31); copy = test.dayOfMonth().addToCopy(22 + 31 + 31 + 30 + 31 + 30 + 31); check(copy, 1973, 1, 1); copy = test.dayOfMonth().addToCopy(-8); check(copy, 1972, 6, 1); copy = test.dayOfMonth().addToCopy(-9); check(copy, 1972, 5, 31); copy = test.dayOfMonth().addToCopy(-8 - 31 - 30 - 31 - 29 - 31); check(copy, 1972, 1, 1); copy = test.dayOfMonth().addToCopy(-9 - 31 - 30 - 31 - 29 - 31); check(copy, 1971, 12, 31); } public void testPropertyAddWrapFieldToCopyDay() { LocalDate test = new LocalDate(1972, 6, 9); LocalDate copy = test.dayOfMonth().addWrapFieldToCopy(21); check(test, 1972, 6, 9); check(copy, 1972, 6, 30); copy = test.dayOfMonth().addWrapFieldToCopy(22); check(copy, 1972, 6, 1); copy = test.dayOfMonth().addWrapFieldToCopy(-12); check(copy, 1972, 6, 27); test = new LocalDate(1972, 7, 9); copy = test.dayOfMonth().addWrapFieldToCopy(21); check(copy, 1972, 7, 30); copy = test.dayOfMonth().addWrapFieldToCopy(22); check(copy, 1972, 7, 31); copy = test.dayOfMonth().addWrapFieldToCopy(23); check(copy, 1972, 7, 1); copy = test.dayOfMonth().addWrapFieldToCopy(-12); check(copy, 1972, 7, 28); } public void testPropertySetCopyDay() { LocalDate test = new LocalDate(1972, 6, 9); LocalDate copy = test.dayOfMonth().setCopy(12); check(test, 1972, 6, 9); check(copy, 1972, 6, 12); try { test.dayOfMonth().setCopy(31); fail(); } catch (IllegalArgumentException ex) {} try { test.dayOfMonth().setCopy(0); fail(); } catch (IllegalArgumentException ex) {} } public void testPropertySetCopyTextDay() { LocalDate test = new LocalDate(1972, 6, 9); LocalDate copy = test.dayOfMonth().setCopy("12"); check(test, 1972, 6, 9); check(copy, 1972, 6, 12); } public void testPropertyWithMaximumValueDayOfMonth() { LocalDate test = new LocalDate(1972, 6, 9); LocalDate copy = test.dayOfMonth().withMaximumValue(); check(test, 1972, 6, 9); check(copy, 1972, 6, 30); } public void testPropertyWithMinimumValueDayOfMonth() { LocalDate test = new LocalDate(1972, 6, 9); LocalDate copy = test.dayOfMonth().withMinimumValue(); check(test, 1972, 6, 9); check(copy, 1972, 6, 1); } public void testPropertyCompareToDay() { LocalDate test1 = new LocalDate(TEST_TIME1); LocalDate test2 = new LocalDate(TEST_TIME2); assertEquals(true, test1.dayOfMonth().compareTo(test2) < 0); assertEquals(true, test2.dayOfMonth().compareTo(test1) > 0); assertEquals(true, test1.dayOfMonth().compareTo(test1) == 0); try { test1.dayOfMonth().compareTo((ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} DateTime dt1 = new DateTime(TEST_TIME1); DateTime dt2 = new DateTime(TEST_TIME2); assertEquals(true, test1.dayOfMonth().compareTo(dt2) < 0); assertEquals(true, test2.dayOfMonth().compareTo(dt1) > 0); assertEquals(true, test1.dayOfMonth().compareTo(dt1) == 0); try { test1.dayOfMonth().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} } public void testPropertyEquals() { LocalDate test1 = new LocalDate(2005, 11, 8); LocalDate test2 = new LocalDate(2005, 11, 9); LocalDate test3 = new LocalDate(2005, 11, 8, CopticChronology.getInstanceUTC()); assertEquals(false, test1.dayOfMonth().equals(test1.year())); assertEquals(false, test1.dayOfMonth().equals(test1.monthOfYear())); assertEquals(true, test1.dayOfMonth().equals(test1.dayOfMonth())); assertEquals(false, test1.dayOfMonth().equals(test2.year())); assertEquals(false, test1.dayOfMonth().equals(test2.monthOfYear())); assertEquals(false, test1.dayOfMonth().equals(test2.dayOfMonth())); assertEquals(false, test1.monthOfYear().equals(test1.year())); assertEquals(true, test1.monthOfYear().equals(test1.monthOfYear())); assertEquals(false, test1.monthOfYear().equals(test1.dayOfMonth())); assertEquals(false, test1.monthOfYear().equals(test2.year())); assertEquals(true, test1.monthOfYear().equals(test2.monthOfYear())); assertEquals(false, test1.monthOfYear().equals(test2.dayOfMonth())); assertEquals(false, test1.dayOfMonth().equals(null)); assertEquals(false, test1.dayOfMonth().equals("any")); // chrono assertEquals(false, test1.dayOfMonth().equals(test3.dayOfMonth())); } public void testPropertyHashCode() { LocalDate test1 = new LocalDate(2005, 11, 8); LocalDate test2 = new LocalDate(2005, 11, 9); assertEquals(true, test1.dayOfMonth().hashCode() == test1.dayOfMonth().hashCode()); assertEquals(false, test1.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode()); assertEquals(true, test1.monthOfYear().hashCode() == test1.monthOfYear().hashCode()); assertEquals(true, test1.monthOfYear().hashCode() == test2.monthOfYear().hashCode()); } public void testPropertyEqualsHashCodeLenient() { LocalDate test1 = new LocalDate(1970, 6, 9, LenientChronology.getInstance(COPTIC_PARIS)); LocalDate test2 = new LocalDate(1970, 6, 9, LenientChronology.getInstance(COPTIC_PARIS)); assertEquals(true, test1.dayOfMonth().equals(test2.dayOfMonth())); assertEquals(true, test2.dayOfMonth().equals(test1.dayOfMonth())); assertEquals(true, test1.dayOfMonth().equals(test1.dayOfMonth())); assertEquals(true, test2.dayOfMonth().equals(test2.dayOfMonth())); assertEquals(true, test1.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode()); assertEquals(true, test1.dayOfMonth().hashCode() == test1.dayOfMonth().hashCode()); assertEquals(true, test2.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode()); } public void testPropertyEqualsHashCodeStrict() { LocalDate test1 = new LocalDate(1970, 6, 9, StrictChronology.getInstance(COPTIC_PARIS)); LocalDate test2 = new LocalDate(1970, 6, 9, StrictChronology.getInstance(COPTIC_PARIS)); assertEquals(true, test1.dayOfMonth().equals(test2.dayOfMonth())); assertEquals(true, test2.dayOfMonth().equals(test1.dayOfMonth())); assertEquals(true, test1.dayOfMonth().equals(test1.dayOfMonth())); assertEquals(true, test2.dayOfMonth().equals(test2.dayOfMonth())); assertEquals(true, test1.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode()); assertEquals(true, test1.dayOfMonth().hashCode() == test1.dayOfMonth().hashCode()); assertEquals(true, test2.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode()); } //----------------------------------------------------------------------- private void check(LocalDate test, int year, int month, int day) { assertEquals(year, test.getYear()); assertEquals(month, test.getMonthOfYear()); assertEquals(day, test.getDayOfMonth()); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Arrays; import java.util.Locale; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.BuddhistChronology; import org.joda.time.chrono.CopticChronology; import org.joda.time.chrono.GregorianChronology; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; /** * This class is a Junit unit test for LocalTime. * * @author Stephen Colebourne */ public class TestLocalTime_Basics extends TestCase { private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo"); private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS); private static final Chronology COPTIC_LONDON = CopticChronology.getInstance(LONDON); private static final Chronology COPTIC_TOKYO = CopticChronology.getInstance(TOKYO); private static final Chronology COPTIC_UTC = CopticChronology.getInstanceUTC(); private static final Chronology BUDDHIST_LONDON = BuddhistChronology.getInstance(LONDON); private long TEST_TIME_NOW = 10L * DateTimeConstants.MILLIS_PER_HOUR + 20L * DateTimeConstants.MILLIS_PER_MINUTE + 30L * DateTimeConstants.MILLIS_PER_SECOND + 40L; // private long TEST_TIME1 = // 1L * DateTimeConstants.MILLIS_PER_HOUR // + 2L * DateTimeConstants.MILLIS_PER_MINUTE // + 3L * DateTimeConstants.MILLIS_PER_SECOND // + 4L; private long TEST_TIME2 = 1L * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; private DateTimeZone zone = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestLocalTime_Basics.class); } public TestLocalTime_Basics(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); zone = DateTimeZone.getDefault(); DateTimeZone.setDefault(LONDON); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(zone); zone = null; } //----------------------------------------------------------------------- public void testGet_DateTimeFieldType() { LocalTime test = new LocalTime(10, 20, 30, 40); assertEquals(10, test.get(DateTimeFieldType.hourOfDay())); assertEquals(20, test.get(DateTimeFieldType.minuteOfHour())); assertEquals(30, test.get(DateTimeFieldType.secondOfMinute())); assertEquals(40, test.get(DateTimeFieldType.millisOfSecond())); assertEquals(TEST_TIME_NOW / 60000 , test.get(DateTimeFieldType.minuteOfDay())); assertEquals(TEST_TIME_NOW / 1000 , test.get(DateTimeFieldType.secondOfDay())); assertEquals(TEST_TIME_NOW , test.get(DateTimeFieldType.millisOfDay())); assertEquals(10, test.get(DateTimeFieldType.hourOfHalfday())); assertEquals(DateTimeConstants.AM, test.get(DateTimeFieldType.halfdayOfDay())); test = new LocalTime(12, 30); assertEquals(0, test.get(DateTimeFieldType.hourOfHalfday())); assertEquals(12, test.get(DateTimeFieldType.clockhourOfHalfday())); assertEquals(12, test.get(DateTimeFieldType.clockhourOfDay())); assertEquals(DateTimeConstants.PM, test.get(DateTimeFieldType.halfdayOfDay())); test = new LocalTime(14, 30); assertEquals(2, test.get(DateTimeFieldType.hourOfHalfday())); assertEquals(2, test.get(DateTimeFieldType.clockhourOfHalfday())); assertEquals(14, test.get(DateTimeFieldType.clockhourOfDay())); assertEquals(DateTimeConstants.PM, test.get(DateTimeFieldType.halfdayOfDay())); test = new LocalTime(0, 30); assertEquals(0, test.get(DateTimeFieldType.hourOfHalfday())); assertEquals(12, test.get(DateTimeFieldType.clockhourOfHalfday())); assertEquals(24, test.get(DateTimeFieldType.clockhourOfDay())); assertEquals(DateTimeConstants.AM, test.get(DateTimeFieldType.halfdayOfDay())); try { test.get(null); fail(); } catch (IllegalArgumentException ex) {} try { test.get(DateTimeFieldType.dayOfMonth()); fail(); } catch (IllegalArgumentException ex) {} } public void testSize() { LocalTime test = new LocalTime(10, 20, 30, 40); assertEquals(4, test.size()); } public void testGetFieldType_int() { LocalTime test = new LocalTime(10, 20, 30, 40); assertSame(DateTimeFieldType.hourOfDay(), test.getFieldType(0)); assertSame(DateTimeFieldType.minuteOfHour(), test.getFieldType(1)); assertSame(DateTimeFieldType.secondOfMinute(), test.getFieldType(2)); assertSame(DateTimeFieldType.millisOfSecond(), test.getFieldType(3)); try { test.getFieldType(-1); } catch (IndexOutOfBoundsException ex) {} try { test.getFieldType(5); } catch (IndexOutOfBoundsException ex) {} } public void testGetFieldTypes() { LocalTime test = new LocalTime(10, 20, 30, 40); DateTimeFieldType[] fields = test.getFieldTypes(); assertSame(DateTimeFieldType.hourOfDay(), fields[0]); assertSame(DateTimeFieldType.minuteOfHour(), fields[1]); assertSame(DateTimeFieldType.secondOfMinute(), fields[2]); assertSame(DateTimeFieldType.millisOfSecond(), fields[3]); assertNotSame(test.getFieldTypes(), test.getFieldTypes()); } public void testGetField_int() { LocalTime test = new LocalTime(10, 20, 30, 40, COPTIC_UTC); assertSame(COPTIC_UTC.hourOfDay(), test.getField(0)); assertSame(COPTIC_UTC.minuteOfHour(), test.getField(1)); assertSame(COPTIC_UTC.secondOfMinute(), test.getField(2)); assertSame(COPTIC_UTC.millisOfSecond(), test.getField(3)); try { test.getField(-1); } catch (IndexOutOfBoundsException ex) {} try { test.getField(5); } catch (IndexOutOfBoundsException ex) {} } public void testGetFields() { LocalTime test = new LocalTime(10, 20, 30, 40, COPTIC_UTC); DateTimeField[] fields = test.getFields(); assertSame(COPTIC_UTC.hourOfDay(), fields[0]); assertSame(COPTIC_UTC.minuteOfHour(), fields[1]); assertSame(COPTIC_UTC.secondOfMinute(), fields[2]); assertSame(COPTIC_UTC.millisOfSecond(), fields[3]); assertNotSame(test.getFields(), test.getFields()); } public void testGetValue_int() { LocalTime test = new LocalTime(10, 20, 30, 40, COPTIC_PARIS); assertEquals(10, test.getValue(0)); assertEquals(20, test.getValue(1)); assertEquals(30, test.getValue(2)); assertEquals(40, test.getValue(3)); try { test.getValue(-1); } catch (IndexOutOfBoundsException ex) {} try { test.getValue(5); } catch (IndexOutOfBoundsException ex) {} } public void testGetValues() { LocalTime test = new LocalTime(10, 20, 30, 40, COPTIC_UTC); int[] values = test.getValues(); assertEquals(10, values[0]); assertEquals(20, values[1]); assertEquals(30, values[2]); assertEquals(40, values[3]); assertNotSame(test.getValues(), test.getValues()); } public void testIsSupported_DateTimeFieldType() { LocalTime test = new LocalTime(10, 20, 30, 40); assertEquals(true, test.isSupported(DateTimeFieldType.hourOfDay())); assertEquals(true, test.isSupported(DateTimeFieldType.minuteOfHour())); assertEquals(true, test.isSupported(DateTimeFieldType.secondOfMinute())); assertEquals(true, test.isSupported(DateTimeFieldType.millisOfSecond())); assertEquals(true, test.isSupported(DateTimeFieldType.minuteOfDay())); assertEquals(true, test.isSupported(DateTimeFieldType.secondOfDay())); assertEquals(true, test.isSupported(DateTimeFieldType.millisOfDay())); assertEquals(true, test.isSupported(DateTimeFieldType.hourOfHalfday())); assertEquals(true, test.isSupported(DateTimeFieldType.halfdayOfDay())); assertEquals(true, test.isSupported(DateTimeFieldType.clockhourOfHalfday())); assertEquals(true, test.isSupported(DateTimeFieldType.clockhourOfDay())); assertEquals(false, test.isSupported(DateTimeFieldType.dayOfMonth())); assertEquals(false, test.isSupported((DateTimeFieldType) null)); DateTimeFieldType d = new DateTimeFieldType("hours") { private static final long serialVersionUID = 1L; public DurationFieldType getDurationType() { return DurationFieldType.hours(); } public DurationFieldType getRangeDurationType() { return null; } public DateTimeField getField(Chronology chronology) { return chronology.hourOfDay(); } }; assertEquals(false, test.isSupported(d)); d = new DateTimeFieldType("hourOfYear") { private static final long serialVersionUID = 1L; public DurationFieldType getDurationType() { return DurationFieldType.hours(); } public DurationFieldType getRangeDurationType() { return DurationFieldType.years(); } public DateTimeField getField(Chronology chronology) { return chronology.hourOfDay(); } }; assertEquals(false, test.isSupported(d)); } public void testIsSupported_DurationFieldType() { LocalTime test = new LocalTime(10, 20, 30, 40); assertEquals(true, test.isSupported(DurationFieldType.hours())); assertEquals(true, test.isSupported(DurationFieldType.minutes())); assertEquals(true, test.isSupported(DurationFieldType.seconds())); assertEquals(true, test.isSupported(DurationFieldType.millis())); assertEquals(true, test.isSupported(DurationFieldType.halfdays())); assertEquals(false, test.isSupported(DurationFieldType.days())); assertEquals(false, test.isSupported((DurationFieldType) null)); } @SuppressWarnings("deprecation") public void testEqualsHashCode() { LocalTime test1 = new LocalTime(10, 20, 30, 40, COPTIC_PARIS); LocalTime test2 = new LocalTime(10, 20, 30, 40, COPTIC_PARIS); assertEquals(true, test1.equals(test2)); assertEquals(true, test2.equals(test1)); assertEquals(true, test1.equals(test1)); assertEquals(true, test2.equals(test2)); assertEquals(true, test1.hashCode() == test2.hashCode()); assertEquals(true, test1.hashCode() == test1.hashCode()); assertEquals(true, test2.hashCode() == test2.hashCode()); LocalTime test3 = new LocalTime(15, 20, 30, 40); assertEquals(false, test1.equals(test3)); assertEquals(false, test2.equals(test3)); assertEquals(false, test3.equals(test1)); assertEquals(false, test3.equals(test2)); assertEquals(false, test1.hashCode() == test3.hashCode()); assertEquals(false, test2.hashCode() == test3.hashCode()); assertEquals(false, test1.equals("Hello")); assertEquals(true, test1.equals(new TimeOfDay(10, 20, 30, 40, COPTIC_UTC))); assertEquals(true, test1.hashCode() == new TimeOfDay(10, 20, 30, 40, COPTIC_UTC).hashCode()); assertEquals(true, test1.equals(new MockInstant())); assertEquals(false, test1.equals(MockPartial.EMPTY_INSTANCE)); } class MockInstant extends MockPartial { public Chronology getChronology() { return COPTIC_UTC; } public DateTimeField[] getFields() { return new DateTimeField[] { COPTIC_UTC.hourOfDay(), COPTIC_UTC.minuteOfHour(), COPTIC_UTC.secondOfMinute(), COPTIC_UTC.millisOfSecond(), }; } public int[] getValues() { return new int[] {10, 20, 30, 40}; } } //----------------------------------------------------------------------- @SuppressWarnings("deprecation") public void testCompareTo() { LocalTime test1 = new LocalTime(10, 20, 30, 40); LocalTime test1a = new LocalTime(10, 20, 30, 40); assertEquals(0, test1.compareTo(test1a)); assertEquals(0, test1a.compareTo(test1)); assertEquals(0, test1.compareTo(test1)); assertEquals(0, test1a.compareTo(test1a)); LocalTime test2 = new LocalTime(10, 20, 35, 40); assertEquals(-1, test1.compareTo(test2)); assertEquals(+1, test2.compareTo(test1)); LocalTime test3 = new LocalTime(10, 20, 35, 40, GregorianChronology.getInstanceUTC()); assertEquals(-1, test1.compareTo(test3)); assertEquals(+1, test3.compareTo(test1)); assertEquals(0, test3.compareTo(test2)); DateTimeFieldType[] types = new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond(), }; int[] values = new int[] {10, 20, 30, 40}; Partial p = new Partial(types, values); assertEquals(0, test1.compareTo(p)); assertEquals(0, test1.compareTo(new TimeOfDay(10, 20, 30, 40))); try { test1.compareTo(null); fail(); } catch (NullPointerException ex) {} // try { // test1.compareTo(new Date()); // fail(); // } catch (ClassCastException ex) {} } //----------------------------------------------------------------------- public void testIsEqual_LocalTime() { LocalTime test1 = new LocalTime(10, 20, 30, 40); LocalTime test1a = new LocalTime(10, 20, 30, 40); assertEquals(true, test1.isEqual(test1a)); assertEquals(true, test1a.isEqual(test1)); assertEquals(true, test1.isEqual(test1)); assertEquals(true, test1a.isEqual(test1a)); LocalTime test2 = new LocalTime(10, 20, 35, 40); assertEquals(false, test1.isEqual(test2)); assertEquals(false, test2.isEqual(test1)); LocalTime test3 = new LocalTime(10, 20, 35, 40, GregorianChronology.getInstanceUTC()); assertEquals(false, test1.isEqual(test3)); assertEquals(false, test3.isEqual(test1)); assertEquals(true, test3.isEqual(test2)); try { new LocalTime(10, 20, 35, 40).isEqual(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testIsBefore_LocalTime() { LocalTime test1 = new LocalTime(10, 20, 30, 40); LocalTime test1a = new LocalTime(10, 20, 30, 40); assertEquals(false, test1.isBefore(test1a)); assertEquals(false, test1a.isBefore(test1)); assertEquals(false, test1.isBefore(test1)); assertEquals(false, test1a.isBefore(test1a)); LocalTime test2 = new LocalTime(10, 20, 35, 40); assertEquals(true, test1.isBefore(test2)); assertEquals(false, test2.isBefore(test1)); LocalTime test3 = new LocalTime(10, 20, 35, 40, GregorianChronology.getInstanceUTC()); assertEquals(true, test1.isBefore(test3)); assertEquals(false, test3.isBefore(test1)); assertEquals(false, test3.isBefore(test2)); try { new LocalTime(10, 20, 35, 40).isBefore(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testIsAfter_LocalTime() { LocalTime test1 = new LocalTime(10, 20, 30, 40); LocalTime test1a = new LocalTime(10, 20, 30, 40); assertEquals(false, test1.isAfter(test1a)); assertEquals(false, test1a.isAfter(test1)); assertEquals(false, test1.isAfter(test1)); assertEquals(false, test1a.isAfter(test1a)); LocalTime test2 = new LocalTime(10, 20, 35, 40); assertEquals(false, test1.isAfter(test2)); assertEquals(true, test2.isAfter(test1)); LocalTime test3 = new LocalTime(10, 20, 35, 40, GregorianChronology.getInstanceUTC()); assertEquals(false, test1.isAfter(test3)); assertEquals(true, test3.isAfter(test1)); assertEquals(false, test3.isAfter(test2)); try { new LocalTime(10, 20, 35, 40).isAfter(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testWithField_DateTimeFieldType_int_1() { LocalTime test = new LocalTime(10, 20, 30, 40); LocalTime result = test.withField(DateTimeFieldType.hourOfDay(), 15); assertEquals(new LocalTime(10, 20, 30, 40), test); assertEquals(new LocalTime(15, 20, 30, 40), result); } public void testWithField_DateTimeFieldType_int_2() { LocalTime test = new LocalTime(10, 20, 30, 40); try { test.withField(null, 6); fail(); } catch (IllegalArgumentException ex) {} } public void testWithField_DateTimeFieldType_int_3() { LocalTime test = new LocalTime(10, 20, 30, 40); try { test.withField(DateTimeFieldType.dayOfMonth(), 6); fail(); } catch (IllegalArgumentException ex) {} } public void testWithField_DateTimeFieldType_int_4() { LocalTime test = new LocalTime(10, 20, 30, 40); LocalTime result = test.withField(DateTimeFieldType.hourOfDay(), 10); assertSame(test, result); } //----------------------------------------------------------------------- public void testWithFieldAdded_DurationFieldType_int_1() { LocalTime test = new LocalTime(10, 20, 30, 40); LocalTime result = test.withFieldAdded(DurationFieldType.hours(), 6); assertEquals(new LocalTime(10, 20, 30, 40), test); assertEquals(new LocalTime(16, 20, 30, 40), result); } public void testWithFieldAdded_DurationFieldType_int_2() { LocalTime test = new LocalTime(10, 20, 30, 40); try { test.withFieldAdded(null, 0); fail(); } catch (IllegalArgumentException ex) {} } public void testWithFieldAdded_DurationFieldType_int_3() { LocalTime test = new LocalTime(10, 20, 30, 40); try { test.withFieldAdded(null, 6); fail(); } catch (IllegalArgumentException ex) {} } public void testWithFieldAdded_DurationFieldType_int_4() { LocalTime test = new LocalTime(10, 20, 30, 40); LocalTime result = test.withFieldAdded(DurationFieldType.hours(), 0); assertSame(test, result); } public void testWithFieldAdded_DurationFieldType_int_5() { LocalTime test = new LocalTime(10, 20, 30, 40); try { test.withFieldAdded(DurationFieldType.days(), 6); fail(); } catch (IllegalArgumentException ex) {} } public void testWithFieldAdded_DurationFieldType_int_6() { LocalTime test = new LocalTime(10, 20, 30, 40); LocalTime result = test.withFieldAdded(DurationFieldType.hours(), 16); assertEquals(new LocalTime(10, 20, 30, 40), test); assertEquals(new LocalTime(2, 20, 30, 40), result); } public void testWithFieldAdded_DurationFieldType_int_7() { LocalTime test = new LocalTime(23, 59, 59, 999); LocalTime result = test.withFieldAdded(DurationFieldType.millis(), 1); assertEquals(new LocalTime(0, 0, 0, 0), result); test = new LocalTime(23, 59, 59, 999); result = test.withFieldAdded(DurationFieldType.seconds(), 1); assertEquals(new LocalTime(0, 0, 0, 999), result); test = new LocalTime(23, 59, 59, 999); result = test.withFieldAdded(DurationFieldType.minutes(), 1); assertEquals(new LocalTime(0, 0, 59, 999), result); test = new LocalTime(23, 59, 59, 999); result = test.withFieldAdded(DurationFieldType.hours(), 1); assertEquals(new LocalTime(0, 59, 59, 999), result); } public void testWithFieldAdded_DurationFieldType_int_8() { LocalTime test = new LocalTime(0, 0, 0, 0); LocalTime result = test.withFieldAdded(DurationFieldType.millis(), -1); assertEquals(new LocalTime(23, 59, 59, 999), result); test = new LocalTime(0, 0, 0, 0); result = test.withFieldAdded(DurationFieldType.seconds(), -1); assertEquals(new LocalTime(23, 59, 59, 0), result); test = new LocalTime(0, 0, 0, 0); result = test.withFieldAdded(DurationFieldType.minutes(), -1); assertEquals(new LocalTime(23, 59, 0, 0), result); test = new LocalTime(0, 0, 0, 0); result = test.withFieldAdded(DurationFieldType.hours(), -1); assertEquals(new LocalTime(23, 0, 0, 0), result); } //----------------------------------------------------------------------- public void testPlus_RP() { LocalTime test = new LocalTime(10, 20, 30, 40, BUDDHIST_LONDON); LocalTime result = test.plus(new Period(1, 2, 3, 4, 5, 6, 7, 8)); LocalTime expected = new LocalTime(15, 26, 37, 48, BUDDHIST_LONDON); assertEquals(expected, result); result = test.plus((ReadablePeriod) null); assertSame(test, result); } public void testPlusHours_int() { LocalTime test = new LocalTime(1, 2, 3, 4, BUDDHIST_LONDON); LocalTime result = test.plusHours(1); LocalTime expected = new LocalTime(2, 2, 3, 4, BUDDHIST_LONDON); assertEquals(expected, result); result = test.plusHours(0); assertSame(test, result); } public void testPlusMinutes_int() { LocalTime test = new LocalTime(1, 2, 3, 4, BUDDHIST_LONDON); LocalTime result = test.plusMinutes(1); LocalTime expected = new LocalTime(1, 3, 3, 4, BUDDHIST_LONDON); assertEquals(expected, result); result = test.plusMinutes(0); assertSame(test, result); } public void testPlusSeconds_int() { LocalTime test = new LocalTime(1, 2, 3, 4, BUDDHIST_LONDON); LocalTime result = test.plusSeconds(1); LocalTime expected = new LocalTime(1, 2, 4, 4, BUDDHIST_LONDON); assertEquals(expected, result); result = test.plusSeconds(0); assertSame(test, result); } public void testPlusMillis_int() { LocalTime test = new LocalTime(1, 2, 3, 4, BUDDHIST_LONDON); LocalTime result = test.plusMillis(1); LocalTime expected = new LocalTime(1, 2, 3, 5, BUDDHIST_LONDON); assertEquals(expected, result); result = test.plusMillis(0); assertSame(test, result); } //----------------------------------------------------------------------- public void testMinus_RP() { LocalTime test = new LocalTime(10, 20, 30, 40, BUDDHIST_LONDON); LocalTime result = test.minus(new Period(1, 1, 1, 1, 1, 1, 1, 1)); LocalTime expected = new LocalTime(9, 19, 29, 39, BUDDHIST_LONDON); assertEquals(expected, result); result = test.minus((ReadablePeriod) null); assertSame(test, result); } public void testMinusHours_int() { LocalTime test = new LocalTime(1, 2, 3, 4, BUDDHIST_LONDON); LocalTime result = test.minusHours(1); LocalTime expected = new LocalTime(0, 2, 3, 4, BUDDHIST_LONDON); assertEquals(expected, result); result = test.minusHours(0); assertSame(test, result); } public void testMinusMinutes_int() { LocalTime test = new LocalTime(1, 2, 3, 4, BUDDHIST_LONDON); LocalTime result = test.minusMinutes(1); LocalTime expected = new LocalTime(1, 1, 3, 4, BUDDHIST_LONDON); assertEquals(expected, result); result = test.minusMinutes(0); assertSame(test, result); } public void testMinusSeconds_int() { LocalTime test = new LocalTime(1, 2, 3, 4, BUDDHIST_LONDON); LocalTime result = test.minusSeconds(1); LocalTime expected = new LocalTime(1, 2, 2, 4, BUDDHIST_LONDON); assertEquals(expected, result); result = test.minusSeconds(0); assertSame(test, result); } public void testMinusMillis_int() { LocalTime test = new LocalTime(1, 2, 3, 4, BUDDHIST_LONDON); LocalTime result = test.minusMillis(1); LocalTime expected = new LocalTime(1, 2, 3, 3, BUDDHIST_LONDON); assertEquals(expected, result); result = test.minusMillis(0); assertSame(test, result); } //----------------------------------------------------------------------- public void testGetters() { LocalTime test = new LocalTime(10, 20, 30, 40); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); assertEquals(TEST_TIME_NOW, test.getMillisOfDay()); } //----------------------------------------------------------------------- public void testWithers() { LocalTime test = new LocalTime(10, 20, 30, 40); check(test.withHourOfDay(6), 6, 20, 30, 40); check(test.withMinuteOfHour(6), 10, 6, 30, 40); check(test.withSecondOfMinute(6), 10, 20, 6, 40); check(test.withMillisOfSecond(6), 10, 20, 30, 6); check(test.withMillisOfDay(61234), 0, 1, 1, 234); try { test.withHourOfDay(-1); fail(); } catch (IllegalArgumentException ex) {} try { test.withHourOfDay(24); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testToDateTimeTodayDefaultZone() { LocalTime base = new LocalTime(10, 20, 30, 40, COPTIC_PARIS); // PARIS irrelevant DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9); DateTimeUtils.setCurrentMillisFixed(dt.getMillis()); DateTime test = base.toDateTimeToday(); check(base, 10, 20, 30, 40); DateTime expected = new DateTime(dt.getMillis(), COPTIC_LONDON); expected = expected.hourOfDay().setCopy(10); expected = expected.minuteOfHour().setCopy(20); expected = expected.secondOfMinute().setCopy(30); expected = expected.millisOfSecond().setCopy(40); assertEquals(expected, test); } //----------------------------------------------------------------------- public void testToDateTimeToday_Zone() { LocalTime base = new LocalTime(10, 20, 30, 40, COPTIC_PARIS); // PARIS irrelevant DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9); DateTimeUtils.setCurrentMillisFixed(dt.getMillis()); DateTime test = base.toDateTimeToday(TOKYO); check(base, 10, 20, 30, 40); DateTime expected = new DateTime(dt.getMillis(), COPTIC_TOKYO); expected = expected.hourOfDay().setCopy(10); expected = expected.minuteOfHour().setCopy(20); expected = expected.secondOfMinute().setCopy(30); expected = expected.millisOfSecond().setCopy(40); assertEquals(expected, test); } public void testToDateTimeToday_nullZone() { LocalTime base = new LocalTime(10, 20, 30, 40, COPTIC_PARIS); // PARIS irrelevant DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9); DateTimeUtils.setCurrentMillisFixed(dt.getMillis()); DateTime test = base.toDateTimeToday((DateTimeZone) null); check(base, 10, 20, 30, 40); DateTime expected = new DateTime(dt.getMillis(), COPTIC_LONDON); expected = expected.hourOfDay().setCopy(10); expected = expected.minuteOfHour().setCopy(20); expected = expected.secondOfMinute().setCopy(30); expected = expected.millisOfSecond().setCopy(40); assertEquals(expected, test); } //----------------------------------------------------------------------- public void testToDateTime_RI() { LocalTime base = new LocalTime(10, 20, 30, 40, COPTIC_PARIS); DateTime dt = new DateTime(0L); // LONDON zone assertEquals("1970-01-01T01:00:00.000+01:00", dt.toString()); DateTime test = base.toDateTime(dt); check(base, 10, 20, 30, 40); assertEquals("1970-01-01T01:00:00.000+01:00", dt.toString()); assertEquals("1970-01-01T10:20:30.040+01:00", test.toString()); } public void testToDateTime_nullRI() { LocalTime base = new LocalTime(1, 2, 3, 4); DateTimeUtils.setCurrentMillisFixed(TEST_TIME2); DateTime test = base.toDateTime((ReadableInstant) null); check(base, 1, 2, 3, 4); assertEquals("1970-01-02T01:02:03.004+01:00", test.toString()); } //----------------------------------------------------------------------- public void testProperty() { LocalTime test = new LocalTime(10, 20, 30, 40); assertEquals(test.hourOfDay(), test.property(DateTimeFieldType.hourOfDay())); assertEquals(test.minuteOfHour(), test.property(DateTimeFieldType.minuteOfHour())); assertEquals(test.secondOfMinute(), test.property(DateTimeFieldType.secondOfMinute())); assertEquals(test.millisOfSecond(), test.property(DateTimeFieldType.millisOfSecond())); assertEquals(test.millisOfDay(), test.property(DateTimeFieldType.millisOfDay())); assertEquals(test, test.property(DateTimeFieldType.minuteOfDay()).getLocalTime()); assertEquals(test, test.property(DateTimeFieldType.secondOfDay()).getLocalTime()); assertEquals(test, test.property(DateTimeFieldType.millisOfDay()).getLocalTime()); assertEquals(test, test.property(DateTimeFieldType.hourOfHalfday()).getLocalTime()); assertEquals(test, test.property(DateTimeFieldType.halfdayOfDay()).getLocalTime()); assertEquals(test, test.property(DateTimeFieldType.clockhourOfHalfday()).getLocalTime()); assertEquals(test, test.property(DateTimeFieldType.clockhourOfDay()).getLocalTime()); try { test.property(DateTimeFieldType.dayOfWeek()); fail(); } catch (IllegalArgumentException ex) {} try { test.property(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testSerialization() throws Exception { LocalTime test = new LocalTime(10, 20, 30, 40, COPTIC_PARIS); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(test); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); LocalTime result = (LocalTime) ois.readObject(); ois.close(); assertEquals(test, result); assertTrue(Arrays.equals(test.getValues(), result.getValues())); assertTrue(Arrays.equals(test.getFields(), result.getFields())); assertEquals(test.getChronology(), result.getChronology()); } //----------------------------------------------------------------------- public void testToString() { LocalTime test = new LocalTime(10, 20, 30, 40); assertEquals("10:20:30.040", test.toString()); } //----------------------------------------------------------------------- public void testToString_String() { LocalTime test = new LocalTime(10, 20, 30, 40); assertEquals("\ufffd\ufffd\ufffd\ufffd 10", test.toString("yyyy HH")); assertEquals("10:20:30.040", test.toString((String) null)); } //----------------------------------------------------------------------- public void testToString_String_Locale() { LocalTime test = new LocalTime(10, 20, 30, 40); assertEquals("10 20", test.toString("H m", Locale.ENGLISH)); assertEquals("10:20:30.040", test.toString(null, Locale.ENGLISH)); assertEquals("10 20", test.toString("H m", null)); assertEquals("10:20:30.040", test.toString(null, null)); } //----------------------------------------------------------------------- public void testToString_DTFormatter() { LocalTime test = new LocalTime(10, 20, 30, 40); assertEquals("\ufffd\ufffd\ufffd\ufffd 10", test.toString(DateTimeFormat.forPattern("yyyy HH"))); assertEquals("10:20:30.040", test.toString((DateTimeFormatter) null)); } //----------------------------------------------------------------------- private void check(LocalTime test, int hour, int min, int sec, int milli) { assertEquals(hour, test.getHourOfDay()); assertEquals(min, test.getMinuteOfHour()); assertEquals(sec, test.getSecondOfMinute()); assertEquals(milli, test.getMillisOfSecond()); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.BuddhistChronology; import org.joda.time.chrono.GJChronology; import org.joda.time.chrono.ISOChronology; import org.joda.time.chrono.JulianChronology; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; /** * This class is a Junit unit test for LocalTime. * * @author Stephen Colebourne */ public class TestLocalTime_Constructors extends TestCase { private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo"); private static final DateTimeZone NEW_YORK = DateTimeZone.forID("America/New_York"); private static final ISOChronology ISO_UTC = ISOChronology.getInstanceUTC(); private static final JulianChronology JULIAN_LONDON = JulianChronology.getInstance(LONDON); private static final JulianChronology JULIAN_PARIS = JulianChronology.getInstance(PARIS); private static final JulianChronology JULIAN_UTC = JulianChronology.getInstanceUTC(); private static final Chronology BUDDHIST_UTC = BuddhistChronology.getInstanceUTC(); private static final int OFFSET_LONDON = LONDON.getOffset(0L) / DateTimeConstants.MILLIS_PER_HOUR; private static final int OFFSET_PARIS = PARIS.getOffset(0L) / DateTimeConstants.MILLIS_PER_HOUR; private long TEST_TIME_NOW = 10L * DateTimeConstants.MILLIS_PER_HOUR + 20L * DateTimeConstants.MILLIS_PER_MINUTE + 30L * DateTimeConstants.MILLIS_PER_SECOND + 40L; private long TEST_TIME1 = 1L * DateTimeConstants.MILLIS_PER_HOUR + 2L * DateTimeConstants.MILLIS_PER_MINUTE + 3L * DateTimeConstants.MILLIS_PER_SECOND + 4L; private long TEST_TIME2 = 1L * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; private DateTimeZone zone = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestLocalTime_Constructors.class); } public TestLocalTime_Constructors(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); zone = DateTimeZone.getDefault(); DateTimeZone.setDefault(LONDON); java.util.TimeZone.setDefault(LONDON.toTimeZone()); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(zone); java.util.TimeZone.setDefault(zone.toTimeZone()); zone = null; } //----------------------------------------------------------------------- /** * Test constructor () */ public void testConstantMidnight() throws Throwable { LocalTime test = LocalTime.MIDNIGHT; assertEquals(ISO_UTC, test.getChronology()); assertEquals(0, test.getHourOfDay()); assertEquals(0, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } //----------------------------------------------------------------------- public void testParse_noFormatter() throws Throwable { assertEquals(new LocalTime(1, 20), LocalTime.parse("01:20")); assertEquals(new LocalTime(14, 50, 30, 432), LocalTime.parse("14:50:30.432")); } public void testParse_formatter() throws Throwable { DateTimeFormatter f = DateTimeFormat.forPattern("HH mm").withChronology(ISOChronology.getInstance(PARIS)); assertEquals(new LocalTime(13, 30), LocalTime.parse("13 30", f)); } //----------------------------------------------------------------------- public void testFactory_FromCalendarFields_Calendar() throws Exception { GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6); cal.set(Calendar.MILLISECOND, 7); LocalTime expected = new LocalTime(4, 5, 6, 7); assertEquals(expected, LocalTime.fromCalendarFields(cal)); try { LocalTime.fromCalendarFields((Calendar) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testFactory_FromDateFields_after1970() throws Exception { GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6); cal.set(Calendar.MILLISECOND, 7); LocalTime expected = new LocalTime(4, 5, 6, 7); assertEquals(expected, LocalTime.fromDateFields(cal.getTime())); } public void testFactory_FromDateFields_before1970() throws Exception { GregorianCalendar cal = new GregorianCalendar(1969, 1, 3, 4, 5, 6); cal.set(Calendar.MILLISECOND, 7); LocalTime expected = new LocalTime(4, 5, 6, 7); assertEquals(expected, LocalTime.fromDateFields(cal.getTime())); } public void testFactory_FromDateFields_null() throws Exception { try { LocalTime.fromDateFields((Date) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testFactoryMillisOfDay_long() throws Throwable { LocalTime test = LocalTime.fromMillisOfDay(TEST_TIME1); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1, test.getHourOfDay()); assertEquals(2, test.getMinuteOfHour()); assertEquals(3, test.getSecondOfMinute()); assertEquals(4, test.getMillisOfSecond()); } //----------------------------------------------------------------------- public void testFactoryMillisOfDay_long_Chronology() throws Throwable { LocalTime test = LocalTime.fromMillisOfDay(TEST_TIME1, JULIAN_LONDON); assertEquals(JULIAN_UTC, test.getChronology()); assertEquals(1, test.getHourOfDay()); assertEquals(2, test.getMinuteOfHour()); assertEquals(3, test.getSecondOfMinute()); assertEquals(4, test.getMillisOfSecond()); } public void testFactoryMillisOfDay_long_nullChronology() throws Throwable { LocalTime test = LocalTime.fromMillisOfDay(TEST_TIME1, null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1, test.getHourOfDay()); assertEquals(2, test.getMinuteOfHour()); assertEquals(3, test.getSecondOfMinute()); assertEquals(4, test.getMillisOfSecond()); } //----------------------------------------------------------------------- public void testConstructor() throws Throwable { LocalTime test = new LocalTime(); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10 + OFFSET_LONDON, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); assertEquals(test, LocalTime.now()); } //----------------------------------------------------------------------- public void testConstructor_DateTimeZone() throws Throwable { DateTime dt = new DateTime(2005, 6, 8, 23, 59, 30, 40, LONDON); DateTimeUtils.setCurrentMillisFixed(dt.getMillis()); // 23:59 in London is 00:59 the following day in Paris LocalTime test = new LocalTime(LONDON); assertEquals(ISO_UTC, test.getChronology()); assertEquals(23, test.getHourOfDay()); assertEquals(59, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); assertEquals(test, LocalTime.now(LONDON)); test = new LocalTime(PARIS); assertEquals(ISO_UTC, test.getChronology()); assertEquals(0, test.getHourOfDay()); assertEquals(59, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); assertEquals(test, LocalTime.now(PARIS)); } public void testConstructor_nullDateTimeZone() throws Throwable { DateTime dt = new DateTime(2005, 6, 8, 23, 59, 30, 40, LONDON); DateTimeUtils.setCurrentMillisFixed(dt.getMillis()); // 23:59 in London is 00:59 the following day in Paris LocalTime test = new LocalTime((DateTimeZone) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(23, test.getHourOfDay()); assertEquals(59, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } //----------------------------------------------------------------------- public void testConstructor_Chronology() throws Throwable { LocalTime test = new LocalTime(JULIAN_LONDON); assertEquals(JULIAN_UTC, test.getChronology()); assertEquals(10 + OFFSET_LONDON, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); assertEquals(test, LocalTime.now(JULIAN_LONDON)); } public void testConstructor_nullChronology() throws Throwable { LocalTime test = new LocalTime((Chronology) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10 + OFFSET_LONDON, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } //----------------------------------------------------------------------- public void testConstructor_long1() throws Throwable { LocalTime test = new LocalTime(TEST_TIME1); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1 + OFFSET_LONDON, test.getHourOfDay()); assertEquals(2, test.getMinuteOfHour()); assertEquals(3, test.getSecondOfMinute()); assertEquals(4, test.getMillisOfSecond()); } public void testConstructor_long2() throws Throwable { LocalTime test = new LocalTime(TEST_TIME2); assertEquals(ISO_UTC, test.getChronology()); assertEquals(5 + OFFSET_LONDON, test.getHourOfDay()); assertEquals(6, test.getMinuteOfHour()); assertEquals(7, test.getSecondOfMinute()); assertEquals(8, test.getMillisOfSecond()); } //----------------------------------------------------------------------- public void testConstructor_long_DateTimeZone() throws Throwable { LocalTime test = new LocalTime(TEST_TIME1, PARIS); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1 + OFFSET_PARIS, test.getHourOfDay()); assertEquals(2, test.getMinuteOfHour()); assertEquals(3, test.getSecondOfMinute()); assertEquals(4, test.getMillisOfSecond()); } public void testConstructor_long_DateTimeZone_2() throws Throwable { DateTime dt = new DateTime(2007, 6, 9, 1, 2, 3, 4, PARIS); DateTime dtUTC = new DateTime(1970, 1, 1, 1, 2, 3, 4, DateTimeZone.UTC); LocalTime test = new LocalTime(dt.getMillis(), PARIS); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1, test.getHourOfDay()); assertEquals(2, test.getMinuteOfHour()); assertEquals(3, test.getSecondOfMinute()); assertEquals(4, test.getMillisOfSecond()); assertEquals(dtUTC.getMillis(), test.getLocalMillis()); } public void testConstructor_long_nullDateTimeZone() throws Throwable { LocalTime test = new LocalTime(TEST_TIME1, (DateTimeZone) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1 + OFFSET_LONDON, test.getHourOfDay()); assertEquals(2, test.getMinuteOfHour()); assertEquals(3, test.getSecondOfMinute()); assertEquals(4, test.getMillisOfSecond()); } //----------------------------------------------------------------------- public void testConstructor_long1_Chronology() throws Throwable { LocalTime test = new LocalTime(TEST_TIME1, JULIAN_PARIS); assertEquals(JULIAN_UTC, test.getChronology()); assertEquals(1 + OFFSET_PARIS, test.getHourOfDay()); assertEquals(2, test.getMinuteOfHour()); assertEquals(3, test.getSecondOfMinute()); assertEquals(4, test.getMillisOfSecond()); } public void testConstructor_long2_Chronology() throws Throwable { LocalTime test = new LocalTime(TEST_TIME2, JULIAN_LONDON); assertEquals(JULIAN_UTC, test.getChronology()); assertEquals(5 + OFFSET_LONDON, test.getHourOfDay()); assertEquals(6, test.getMinuteOfHour()); assertEquals(7, test.getSecondOfMinute()); assertEquals(8, test.getMillisOfSecond()); } public void testConstructor_long_nullChronology() throws Throwable { LocalTime test = new LocalTime(TEST_TIME1, (Chronology) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1 + OFFSET_LONDON, test.getHourOfDay()); assertEquals(2, test.getMinuteOfHour()); assertEquals(3, test.getSecondOfMinute()); assertEquals(4, test.getMillisOfSecond()); } //----------------------------------------------------------------------- public void testConstructor_Object1() throws Throwable { Date date = new Date(TEST_TIME1); LocalTime test = new LocalTime(date); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1 + OFFSET_LONDON, test.getHourOfDay()); assertEquals(2, test.getMinuteOfHour()); assertEquals(3, test.getSecondOfMinute()); assertEquals(4, test.getMillisOfSecond()); } public void testConstructor_Object2() throws Throwable { Calendar cal = new GregorianCalendar(); cal.setTime(new Date(TEST_TIME1)); LocalTime test = new LocalTime(cal); assertEquals(GJChronology.getInstanceUTC(), test.getChronology()); assertEquals(1 + OFFSET_LONDON, test.getHourOfDay()); assertEquals(2, test.getMinuteOfHour()); assertEquals(3, test.getSecondOfMinute()); assertEquals(4, test.getMillisOfSecond()); } public void testConstructor_nullObject() throws Throwable { LocalTime test = new LocalTime((Object) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10 + OFFSET_LONDON, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } public void testConstructor_ObjectString1() throws Throwable { LocalTime test = new LocalTime("10:20:30.040"); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } public void testConstructor_ObjectString1Tokyo() throws Throwable { DateTimeZone.setDefault(TOKYO); LocalTime test = new LocalTime("10:20:30.040"); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } public void testConstructor_ObjectString1NewYork() throws Throwable { DateTimeZone.setDefault(NEW_YORK); LocalTime test = new LocalTime("10:20:30.040"); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } public void testConstructor_ObjectString2() throws Throwable { LocalTime test = new LocalTime("T10:20:30.040"); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } public void testConstructor_ObjectString3() throws Throwable { LocalTime test = new LocalTime("10:20"); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } public void testConstructor_ObjectString4() throws Throwable { LocalTime test = new LocalTime("10"); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10, test.getHourOfDay()); assertEquals(0, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } public void testConstructor_ObjectStringEx1() throws Throwable { try { new LocalTime("1970-04-06"); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_ObjectStringEx2() throws Throwable { try { new LocalTime("1970-04-06T+14:00"); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_ObjectStringEx3() throws Throwable { try { new LocalTime("1970-04-06T10:20:30.040"); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_ObjectStringEx4() throws Throwable { try { new LocalTime("1970-04-06T10:20:30.040+14:00"); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_ObjectStringEx5() throws Throwable { try { new LocalTime("T10:20:30.040+04:00"); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_ObjectStringEx6() throws Throwable { try { new LocalTime("10:20:30.040+04:00"); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_ObjectLocalTime() throws Throwable { LocalTime time = new LocalTime(10, 20, 30, 40, BUDDHIST_UTC); LocalTime test = new LocalTime(time); assertEquals(BUDDHIST_UTC, test.getChronology()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } public void testConstructor_ObjectLocalDate() throws Throwable { LocalDate date = new LocalDate(1970, 4, 6, BUDDHIST_UTC); try { new LocalTime(date); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_ObjectLocalDateTime() throws Throwable { LocalDateTime dt = new LocalDateTime(1970, 5, 6, 10, 20, 30, 40, BUDDHIST_UTC); LocalTime test = new LocalTime(dt); assertEquals(BUDDHIST_UTC, test.getChronology()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } @SuppressWarnings("deprecation") public void testConstructor_ObjectTimeOfDay() throws Throwable { TimeOfDay time = new TimeOfDay(10, 20, 30, 40, BUDDHIST_UTC); LocalTime test = new LocalTime(time); assertEquals(BUDDHIST_UTC, test.getChronology()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } //----------------------------------------------------------------------- public void testConstructor_Object1_DateTimeZone() throws Throwable { Date date = new Date(TEST_TIME1); LocalTime test = new LocalTime(date, PARIS); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1 + OFFSET_PARIS, test.getHourOfDay()); assertEquals(2, test.getMinuteOfHour()); assertEquals(3, test.getSecondOfMinute()); assertEquals(4, test.getMillisOfSecond()); } public void testConstructor_ObjectString_DateTimeZoneLondon() throws Throwable { LocalTime test = new LocalTime("04:20", LONDON); assertEquals(4, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); } public void testConstructor_ObjectString_DateTimeZoneTokyo() throws Throwable { LocalTime test = new LocalTime("04:20", TOKYO); assertEquals(ISO_UTC, test.getChronology()); assertEquals(4, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); } public void testConstructor_ObjectString_DateTimeZoneNewYork() throws Throwable { LocalTime test = new LocalTime("04:20", NEW_YORK); assertEquals(ISO_UTC, test.getChronology()); assertEquals(4, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); } public void testConstructor_nullObject_DateTimeZone() throws Throwable { LocalTime test = new LocalTime((Object) null, PARIS); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10 + OFFSET_PARIS, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } public void testConstructor_Object_nullDateTimeZone() throws Throwable { Date date = new Date(TEST_TIME1); LocalTime test = new LocalTime(date, (DateTimeZone) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1 + OFFSET_LONDON, test.getHourOfDay()); assertEquals(2, test.getMinuteOfHour()); assertEquals(3, test.getSecondOfMinute()); assertEquals(4, test.getMillisOfSecond()); } public void testConstructor_nullObject_nullDateTimeZone() throws Throwable { LocalTime test = new LocalTime((Object) null, (DateTimeZone) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10 + OFFSET_LONDON, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } //----------------------------------------------------------------------- public void testConstructor_Object1_Chronology() throws Throwable { Date date = new Date(TEST_TIME1); LocalTime test = new LocalTime(date, JULIAN_LONDON); assertEquals(JULIAN_UTC, test.getChronology()); assertEquals(1 + OFFSET_LONDON, test.getHourOfDay()); assertEquals(2, test.getMinuteOfHour()); assertEquals(3, test.getSecondOfMinute()); assertEquals(4, test.getMillisOfSecond()); } public void testConstructor_Object2_Chronology() throws Throwable { LocalTime test = new LocalTime("T10:20"); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); try { new LocalTime("T1020"); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_nullObject_Chronology() throws Throwable { LocalTime test = new LocalTime((Object) null, JULIAN_LONDON); assertEquals(JULIAN_UTC, test.getChronology()); assertEquals(10 + OFFSET_LONDON, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } public void testConstructor_Object_nullChronology() throws Throwable { Date date = new Date(TEST_TIME1); LocalTime test = new LocalTime(date, (Chronology) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1 + OFFSET_LONDON, test.getHourOfDay()); assertEquals(2, test.getMinuteOfHour()); assertEquals(3, test.getSecondOfMinute()); assertEquals(4, test.getMillisOfSecond()); } public void testConstructor_nullObject_nullChronology() throws Throwable { LocalTime test = new LocalTime((Object) null, (Chronology) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10 + OFFSET_LONDON, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } //----------------------------------------------------------------------- public void testConstructor_int_int() throws Throwable { LocalTime test = new LocalTime(10, 20); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); try { new LocalTime(-1, 20); fail(); } catch (IllegalArgumentException ex) {} try { new LocalTime(24, 20); fail(); } catch (IllegalArgumentException ex) {} try { new LocalTime(10, -1); fail(); } catch (IllegalArgumentException ex) {} try { new LocalTime(10, 60); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_int_int_int() throws Throwable { LocalTime test = new LocalTime(10, 20, 30); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); try { new LocalTime(-1, 20, 30); fail(); } catch (IllegalArgumentException ex) {} try { new LocalTime(24, 20, 30); fail(); } catch (IllegalArgumentException ex) {} try { new LocalTime(10, -1, 30); fail(); } catch (IllegalArgumentException ex) {} try { new LocalTime(10, 60, 30); fail(); } catch (IllegalArgumentException ex) {} try { new LocalTime(10, 20, -1); fail(); } catch (IllegalArgumentException ex) {} try { new LocalTime(10, 20, 60); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_int_int_int_int() throws Throwable { LocalTime test = new LocalTime(10, 20, 30, 40); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); try { new LocalTime(-1, 20, 30, 40); fail(); } catch (IllegalArgumentException ex) {} try { new LocalTime(24, 20, 30, 40); fail(); } catch (IllegalArgumentException ex) {} try { new LocalTime(10, -1, 30, 40); fail(); } catch (IllegalArgumentException ex) {} try { new LocalTime(10, 60, 30, 40); fail(); } catch (IllegalArgumentException ex) {} try { new LocalTime(10, 20, -1, 40); fail(); } catch (IllegalArgumentException ex) {} try { new LocalTime(10, 20, 60, 40); fail(); } catch (IllegalArgumentException ex) {} try { new LocalTime(10, 20, 30, -1); fail(); } catch (IllegalArgumentException ex) {} try { new LocalTime(10, 20, 30, 1000); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_int_int_int_int_Chronology() throws Throwable { LocalTime test = new LocalTime(10, 20, 30, 40, JULIAN_LONDON); assertEquals(JULIAN_UTC, test.getChronology()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); try { new LocalTime(-1, 20, 30, 40, JULIAN_LONDON); fail(); } catch (IllegalArgumentException ex) {} try { new LocalTime(24, 20, 30, 40, JULIAN_LONDON); fail(); } catch (IllegalArgumentException ex) {} try { new LocalTime(10, -1, 30, 40, JULIAN_LONDON); fail(); } catch (IllegalArgumentException ex) {} try { new LocalTime(10, 60, 30, 40, JULIAN_LONDON); fail(); } catch (IllegalArgumentException ex) {} try { new LocalTime(10, 20, -1, 40, JULIAN_LONDON); fail(); } catch (IllegalArgumentException ex) {} try { new LocalTime(10, 20, 60, 40, JULIAN_LONDON); fail(); } catch (IllegalArgumentException ex) {} try { new LocalTime(10, 20, 30, -1, JULIAN_LONDON); fail(); } catch (IllegalArgumentException ex) {} try { new LocalTime(10, 20, 30, 1000, JULIAN_LONDON); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_int_int_int_int_nullChronology() throws Throwable { LocalTime test = new LocalTime(10, 20, 30, 40, null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } }
/* * Copyright 2001-2006 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.util.Locale; import junit.framework.TestCase; import junit.framework.TestSuite; /** * This class is a Junit unit test for TimeOfDay. * * @author Stephen Colebourne */ public class TestLocalTime_Properties extends TestCase { private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private long TEST_TIME_NOW = 10L * DateTimeConstants.MILLIS_PER_HOUR + 20L * DateTimeConstants.MILLIS_PER_MINUTE + 30L * DateTimeConstants.MILLIS_PER_SECOND + 40L; private long TEST_TIME1 = 1L * DateTimeConstants.MILLIS_PER_HOUR + 2L * DateTimeConstants.MILLIS_PER_MINUTE + 3L * DateTimeConstants.MILLIS_PER_SECOND + 4L; private long TEST_TIME2 = 1L * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; private DateTimeZone zone = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestLocalTime_Properties.class); } public TestLocalTime_Properties(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); zone = DateTimeZone.getDefault(); DateTimeZone.setDefault(LONDON); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(zone); zone = null; } //----------------------------------------------------------------------- public void testPropertyGetHour() { LocalTime test = new LocalTime(10, 20, 30, 40); assertSame(test.getChronology().hourOfDay(), test.hourOfDay().getField()); assertEquals("hourOfDay", test.hourOfDay().getName()); assertEquals("Property[hourOfDay]", test.hourOfDay().toString()); assertSame(test, test.hourOfDay().getLocalTime()); assertEquals(10, test.hourOfDay().get()); assertEquals("10", test.hourOfDay().getAsString()); assertEquals("10", test.hourOfDay().getAsText()); assertEquals("10", test.hourOfDay().getAsText(Locale.FRENCH)); assertEquals("10", test.hourOfDay().getAsShortText()); assertEquals("10", test.hourOfDay().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().hours(), test.hourOfDay().getDurationField()); assertEquals(test.getChronology().days(), test.hourOfDay().getRangeDurationField()); assertEquals(2, test.hourOfDay().getMaximumTextLength(null)); assertEquals(2, test.hourOfDay().getMaximumShortTextLength(null)); } public void testPropertyRoundHour() { LocalTime test = new LocalTime(10, 20); check(test.hourOfDay().roundCeilingCopy(), 11, 0, 0, 0); check(test.hourOfDay().roundFloorCopy(), 10, 0, 0, 0); check(test.hourOfDay().roundHalfCeilingCopy(), 10, 0, 0, 0); check(test.hourOfDay().roundHalfFloorCopy(), 10, 0, 0, 0); check(test.hourOfDay().roundHalfEvenCopy(), 10, 0, 0, 0); test = new LocalTime(10, 40); check(test.hourOfDay().roundCeilingCopy(), 11, 0, 0, 0); check(test.hourOfDay().roundFloorCopy(), 10, 0, 0, 0); check(test.hourOfDay().roundHalfCeilingCopy(), 11, 0, 0, 0); check(test.hourOfDay().roundHalfFloorCopy(), 11, 0, 0, 0); check(test.hourOfDay().roundHalfEvenCopy(), 11, 0, 0, 0); test = new LocalTime(10, 30); check(test.hourOfDay().roundCeilingCopy(), 11, 0, 0, 0); check(test.hourOfDay().roundFloorCopy(), 10, 0, 0, 0); check(test.hourOfDay().roundHalfCeilingCopy(), 11, 0, 0, 0); check(test.hourOfDay().roundHalfFloorCopy(), 10, 0, 0, 0); check(test.hourOfDay().roundHalfEvenCopy(), 10, 0, 0, 0); test = new LocalTime(11, 30); check(test.hourOfDay().roundCeilingCopy(), 12, 0, 0, 0); check(test.hourOfDay().roundFloorCopy(), 11, 0, 0, 0); check(test.hourOfDay().roundHalfCeilingCopy(), 12, 0, 0, 0); check(test.hourOfDay().roundHalfFloorCopy(), 11, 0, 0, 0); check(test.hourOfDay().roundHalfEvenCopy(), 12, 0, 0, 0); } public void testPropertyGetMaxMinValuesHour() { LocalTime test = new LocalTime(10, 20, 30, 40); assertEquals(0, test.hourOfDay().getMinimumValue()); assertEquals(0, test.hourOfDay().getMinimumValueOverall()); assertEquals(23, test.hourOfDay().getMaximumValue()); assertEquals(23, test.hourOfDay().getMaximumValueOverall()); } public void testPropertyWithMaxMinValueHour() { LocalTime test = new LocalTime(10, 20, 30, 40); check(test.hourOfDay().withMaximumValue(), 23, 20, 30, 40); check(test.hourOfDay().withMinimumValue(), 0, 20, 30, 40); } public void testPropertyPlusHour() { LocalTime test = new LocalTime(10, 20, 30, 40); LocalTime copy = test.hourOfDay().addCopy(9); check(test, 10, 20, 30, 40); check(copy, 19, 20, 30, 40); copy = test.hourOfDay().addCopy(0); check(copy, 10, 20, 30, 40); copy = test.hourOfDay().addCopy(13); check(copy, 23, 20, 30, 40); copy = test.hourOfDay().addCopy(14); check(copy, 0, 20, 30, 40); copy = test.hourOfDay().addCopy(-10); check(copy, 0, 20, 30, 40); copy = test.hourOfDay().addCopy(-11); check(copy, 23, 20, 30, 40); } public void testPropertyPlusNoWrapHour() { LocalTime test = new LocalTime(10, 20, 30, 40); LocalTime copy = test.hourOfDay().addNoWrapToCopy(9); check(test, 10, 20, 30, 40); check(copy, 19, 20, 30, 40); copy = test.hourOfDay().addNoWrapToCopy(0); check(copy, 10, 20, 30, 40); copy = test.hourOfDay().addNoWrapToCopy(13); check(copy, 23, 20, 30, 40); try { test.hourOfDay().addNoWrapToCopy(14); fail(); } catch (IllegalArgumentException ex) {} check(test, 10, 20, 30, 40); copy = test.hourOfDay().addNoWrapToCopy(-10); check(copy, 0, 20, 30, 40); try { test.hourOfDay().addNoWrapToCopy(-11); fail(); } catch (IllegalArgumentException ex) {} check(test, 10, 20, 30, 40); } public void testPropertyPlusWrapFieldHour() { LocalTime test = new LocalTime(10, 20, 30, 40); LocalTime copy = test.hourOfDay().addWrapFieldToCopy(9); check(test, 10, 20, 30, 40); check(copy, 19, 20, 30, 40); copy = test.hourOfDay().addWrapFieldToCopy(0); check(copy, 10, 20, 30, 40); copy = test.hourOfDay().addWrapFieldToCopy(18); check(copy, 4, 20, 30, 40); copy = test.hourOfDay().addWrapFieldToCopy(-15); check(copy, 19, 20, 30, 40); } public void testPropertySetHour() { LocalTime test = new LocalTime(10, 20, 30, 40); LocalTime copy = test.hourOfDay().setCopy(12); check(test, 10, 20, 30, 40); check(copy, 12, 20, 30, 40); try { test.hourOfDay().setCopy(24); fail(); } catch (IllegalArgumentException ex) {} try { test.hourOfDay().setCopy(-1); fail(); } catch (IllegalArgumentException ex) {} } public void testPropertySetTextHour() { LocalTime test = new LocalTime(10, 20, 30, 40); LocalTime copy = test.hourOfDay().setCopy("12"); check(test, 10, 20, 30, 40); check(copy, 12, 20, 30, 40); } public void testPropertyWithMaximumValueHour() { LocalTime test = new LocalTime(10, 20, 30, 40); LocalTime copy = test.hourOfDay().withMaximumValue(); check(test, 10, 20, 30, 40); check(copy, 23, 20, 30, 40); } public void testPropertyWithMinimumValueHour() { LocalTime test = new LocalTime(10, 20, 30, 40); LocalTime copy = test.hourOfDay().withMinimumValue(); check(test, 10, 20, 30, 40); check(copy, 0, 20, 30, 40); } public void testPropertyCompareToHour() { LocalTime test1 = new LocalTime(TEST_TIME1); LocalTime test2 = new LocalTime(TEST_TIME2); assertEquals(true, test1.hourOfDay().compareTo(test2) < 0); assertEquals(true, test2.hourOfDay().compareTo(test1) > 0); assertEquals(true, test1.hourOfDay().compareTo(test1) == 0); try { test1.hourOfDay().compareTo((ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} DateTime dt1 = new DateTime(TEST_TIME1); DateTime dt2 = new DateTime(TEST_TIME2); assertEquals(true, test1.hourOfDay().compareTo(dt2) < 0); assertEquals(true, test2.hourOfDay().compareTo(dt1) > 0); assertEquals(true, test1.hourOfDay().compareTo(dt1) == 0); try { test1.hourOfDay().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testPropertyGetMinute() { LocalTime test = new LocalTime(10, 20, 30, 40); assertSame(test.getChronology().minuteOfHour(), test.minuteOfHour().getField()); assertEquals("minuteOfHour", test.minuteOfHour().getName()); assertEquals("Property[minuteOfHour]", test.minuteOfHour().toString()); assertSame(test, test.minuteOfHour().getLocalTime()); assertEquals(20, test.minuteOfHour().get()); assertEquals("20", test.minuteOfHour().getAsString()); assertEquals("20", test.minuteOfHour().getAsText()); assertEquals("20", test.minuteOfHour().getAsText(Locale.FRENCH)); assertEquals("20", test.minuteOfHour().getAsShortText()); assertEquals("20", test.minuteOfHour().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().minutes(), test.minuteOfHour().getDurationField()); assertEquals(test.getChronology().hours(), test.minuteOfHour().getRangeDurationField()); assertEquals(2, test.minuteOfHour().getMaximumTextLength(null)); assertEquals(2, test.minuteOfHour().getMaximumShortTextLength(null)); } public void testPropertyGetMaxMinValuesMinute() { LocalTime test = new LocalTime(10, 20, 30, 40); assertEquals(0, test.minuteOfHour().getMinimumValue()); assertEquals(0, test.minuteOfHour().getMinimumValueOverall()); assertEquals(59, test.minuteOfHour().getMaximumValue()); assertEquals(59, test.minuteOfHour().getMaximumValueOverall()); } public void testPropertyWithMaxMinValueMinute() { LocalTime test = new LocalTime(10, 20, 30, 40); check(test.minuteOfHour().withMaximumValue(), 10, 59, 30, 40); check(test.minuteOfHour().withMinimumValue(), 10, 0, 30, 40); } public void testPropertyPlusMinute() { LocalTime test = new LocalTime(10, 20, 30, 40); LocalTime copy = test.minuteOfHour().addCopy(9); check(test, 10, 20, 30, 40); check(copy, 10, 29, 30, 40); copy = test.minuteOfHour().addCopy(39); check(copy, 10, 59, 30, 40); copy = test.minuteOfHour().addCopy(40); check(copy, 11, 0, 30, 40); copy = test.minuteOfHour().addCopy(1 * 60 + 45); check(copy, 12, 5, 30, 40); copy = test.minuteOfHour().addCopy(13 * 60 + 39); check(copy, 23, 59, 30, 40); copy = test.minuteOfHour().addCopy(13 * 60 + 40); check(copy, 0, 0, 30, 40); copy = test.minuteOfHour().addCopy(-9); check(copy, 10, 11, 30, 40); copy = test.minuteOfHour().addCopy(-19); check(copy, 10, 1, 30, 40); copy = test.minuteOfHour().addCopy(-20); check(copy, 10, 0, 30, 40); copy = test.minuteOfHour().addCopy(-21); check(copy, 9, 59, 30, 40); copy = test.minuteOfHour().addCopy(-(10 * 60 + 20)); check(copy, 0, 0, 30, 40); copy = test.minuteOfHour().addCopy(-(10 * 60 + 21)); check(copy, 23, 59, 30, 40); } public void testPropertyPlusNoWrapMinute() { LocalTime test = new LocalTime(10, 20, 30, 40); LocalTime copy = test.minuteOfHour().addNoWrapToCopy(9); check(test, 10, 20, 30, 40); check(copy, 10, 29, 30, 40); copy = test.minuteOfHour().addNoWrapToCopy(39); check(copy, 10, 59, 30, 40); copy = test.minuteOfHour().addNoWrapToCopy(40); check(copy, 11, 0, 30, 40); copy = test.minuteOfHour().addNoWrapToCopy(1 * 60 + 45); check(copy, 12, 5, 30, 40); copy = test.minuteOfHour().addNoWrapToCopy(13 * 60 + 39); check(copy, 23, 59, 30, 40); try { test.minuteOfHour().addNoWrapToCopy(13 * 60 + 40); fail(); } catch (IllegalArgumentException ex) {} check(test, 10, 20, 30, 40); copy = test.minuteOfHour().addNoWrapToCopy(-9); check(copy, 10, 11, 30, 40); copy = test.minuteOfHour().addNoWrapToCopy(-19); check(copy, 10, 1, 30, 40); copy = test.minuteOfHour().addNoWrapToCopy(-20); check(copy, 10, 0, 30, 40); copy = test.minuteOfHour().addNoWrapToCopy(-21); check(copy, 9, 59, 30, 40); copy = test.minuteOfHour().addNoWrapToCopy(-(10 * 60 + 20)); check(copy, 0, 0, 30, 40); try { test.minuteOfHour().addNoWrapToCopy(-(10 * 60 + 21)); fail(); } catch (IllegalArgumentException ex) {} check(test, 10, 20, 30, 40); } public void testPropertyPlusWrapFieldMinute() { LocalTime test = new LocalTime(10, 20, 30, 40); LocalTime copy = test.minuteOfHour().addWrapFieldToCopy(9); check(test, 10, 20, 30, 40); check(copy, 10, 29, 30, 40); copy = test.minuteOfHour().addWrapFieldToCopy(49); check(copy, 10, 9, 30, 40); copy = test.minuteOfHour().addWrapFieldToCopy(-47); check(copy, 10, 33, 30, 40); } public void testPropertySetMinute() { LocalTime test = new LocalTime(10, 20, 30, 40); LocalTime copy = test.minuteOfHour().setCopy(12); check(test, 10, 20, 30, 40); check(copy, 10, 12, 30, 40); try { test.minuteOfHour().setCopy(60); fail(); } catch (IllegalArgumentException ex) {} try { test.minuteOfHour().setCopy(-1); fail(); } catch (IllegalArgumentException ex) {} } public void testPropertySetTextMinute() { LocalTime test = new LocalTime(10, 20, 30, 40); LocalTime copy = test.minuteOfHour().setCopy("12"); check(test, 10, 20, 30, 40); check(copy, 10, 12, 30, 40); } public void testPropertyCompareToMinute() { LocalTime test1 = new LocalTime(TEST_TIME1); LocalTime test2 = new LocalTime(TEST_TIME2); assertEquals(true, test1.minuteOfHour().compareTo(test2) < 0); assertEquals(true, test2.minuteOfHour().compareTo(test1) > 0); assertEquals(true, test1.minuteOfHour().compareTo(test1) == 0); try { test1.minuteOfHour().compareTo((ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} DateTime dt1 = new DateTime(TEST_TIME1); DateTime dt2 = new DateTime(TEST_TIME2); assertEquals(true, test1.minuteOfHour().compareTo(dt2) < 0); assertEquals(true, test2.minuteOfHour().compareTo(dt1) > 0); assertEquals(true, test1.minuteOfHour().compareTo(dt1) == 0); try { test1.minuteOfHour().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testPropertyGetSecond() { LocalTime test = new LocalTime(10, 20, 30, 40); assertSame(test.getChronology().secondOfMinute(), test.secondOfMinute().getField()); assertEquals("secondOfMinute", test.secondOfMinute().getName()); assertEquals("Property[secondOfMinute]", test.secondOfMinute().toString()); assertSame(test, test.secondOfMinute().getLocalTime()); assertEquals(30, test.secondOfMinute().get()); assertEquals("30", test.secondOfMinute().getAsString()); assertEquals("30", test.secondOfMinute().getAsText()); assertEquals("30", test.secondOfMinute().getAsText(Locale.FRENCH)); assertEquals("30", test.secondOfMinute().getAsShortText()); assertEquals("30", test.secondOfMinute().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().seconds(), test.secondOfMinute().getDurationField()); assertEquals(test.getChronology().minutes(), test.secondOfMinute().getRangeDurationField()); assertEquals(2, test.secondOfMinute().getMaximumTextLength(null)); assertEquals(2, test.secondOfMinute().getMaximumShortTextLength(null)); } public void testPropertyGetMaxMinValuesSecond() { LocalTime test = new LocalTime(10, 20, 30, 40); assertEquals(0, test.secondOfMinute().getMinimumValue()); assertEquals(0, test.secondOfMinute().getMinimumValueOverall()); assertEquals(59, test.secondOfMinute().getMaximumValue()); assertEquals(59, test.secondOfMinute().getMaximumValueOverall()); } public void testPropertyWithMaxMinValueSecond() { LocalTime test = new LocalTime(10, 20, 30, 40); check(test.secondOfMinute().withMaximumValue(), 10, 20, 59, 40); check(test.secondOfMinute().withMinimumValue(), 10, 20, 0, 40); } public void testPropertyPlusSecond() { LocalTime test = new LocalTime(10, 20, 30, 40); LocalTime copy = test.secondOfMinute().addCopy(9); check(test, 10, 20, 30, 40); check(copy, 10, 20, 39, 40); copy = test.secondOfMinute().addCopy(29); check(copy, 10, 20, 59, 40); copy = test.secondOfMinute().addCopy(30); check(copy, 10, 21, 0, 40); copy = test.secondOfMinute().addCopy(39 * 60 + 29); check(copy, 10, 59, 59, 40); copy = test.secondOfMinute().addCopy(39 * 60 + 30); check(copy, 11, 0, 0, 40); copy = test.secondOfMinute().addCopy(13 * 60 * 60 + 39 * 60 + 30); check(copy, 0, 0, 0, 40); copy = test.secondOfMinute().addCopy(-9); check(copy, 10, 20, 21, 40); copy = test.secondOfMinute().addCopy(-30); check(copy, 10, 20, 0, 40); copy = test.secondOfMinute().addCopy(-31); check(copy, 10, 19, 59, 40); copy = test.secondOfMinute().addCopy(-(10 * 60 * 60 + 20 * 60 + 30)); check(copy, 0, 0, 0, 40); copy = test.secondOfMinute().addCopy(-(10 * 60 * 60 + 20 * 60 + 31)); check(copy, 23, 59, 59, 40); } public void testPropertyPlusNoWrapSecond() { LocalTime test = new LocalTime(10, 20, 30, 40); LocalTime copy = test.secondOfMinute().addNoWrapToCopy(9); check(test, 10, 20, 30, 40); check(copy, 10, 20, 39, 40); copy = test.secondOfMinute().addNoWrapToCopy(29); check(copy, 10, 20, 59, 40); copy = test.secondOfMinute().addNoWrapToCopy(30); check(copy, 10, 21, 0, 40); copy = test.secondOfMinute().addNoWrapToCopy(39 * 60 + 29); check(copy, 10, 59, 59, 40); copy = test.secondOfMinute().addNoWrapToCopy(39 * 60 + 30); check(copy, 11, 0, 0, 40); try { test.secondOfMinute().addNoWrapToCopy(13 * 60 * 60 + 39 * 60 + 30); fail(); } catch (IllegalArgumentException ex) {} check(test, 10, 20, 30, 40); copy = test.secondOfMinute().addNoWrapToCopy(-9); check(copy, 10, 20, 21, 40); copy = test.secondOfMinute().addNoWrapToCopy(-30); check(copy, 10, 20, 0, 40); copy = test.secondOfMinute().addNoWrapToCopy(-31); check(copy, 10, 19, 59, 40); copy = test.secondOfMinute().addNoWrapToCopy(-(10 * 60 * 60 + 20 * 60 + 30)); check(copy, 0, 0, 0, 40); try { test.secondOfMinute().addNoWrapToCopy(-(10 * 60 * 60 + 20 * 60 + 31)); fail(); } catch (IllegalArgumentException ex) {} check(test, 10, 20, 30, 40); } public void testPropertyPlusWrapFieldSecond() { LocalTime test = new LocalTime(10, 20, 30, 40); LocalTime copy = test.secondOfMinute().addWrapFieldToCopy(9); check(test, 10, 20, 30, 40); check(copy, 10, 20, 39, 40); copy = test.secondOfMinute().addWrapFieldToCopy(49); check(copy, 10, 20, 19, 40); copy = test.secondOfMinute().addWrapFieldToCopy(-47); check(copy, 10, 20, 43, 40); } public void testPropertySetSecond() { LocalTime test = new LocalTime(10, 20, 30, 40); LocalTime copy = test.secondOfMinute().setCopy(12); check(test, 10, 20, 30, 40); check(copy, 10, 20, 12, 40); try { test.secondOfMinute().setCopy(60); fail(); } catch (IllegalArgumentException ex) {} try { test.secondOfMinute().setCopy(-1); fail(); } catch (IllegalArgumentException ex) {} } public void testPropertySetTextSecond() { LocalTime test = new LocalTime(10, 20, 30, 40); LocalTime copy = test.secondOfMinute().setCopy("12"); check(test, 10, 20, 30, 40); check(copy, 10, 20, 12, 40); } public void testPropertyCompareToSecond() { LocalTime test1 = new LocalTime(TEST_TIME1); LocalTime test2 = new LocalTime(TEST_TIME2); assertEquals(true, test1.secondOfMinute().compareTo(test2) < 0); assertEquals(true, test2.secondOfMinute().compareTo(test1) > 0); assertEquals(true, test1.secondOfMinute().compareTo(test1) == 0); try { test1.secondOfMinute().compareTo((ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} DateTime dt1 = new DateTime(TEST_TIME1); DateTime dt2 = new DateTime(TEST_TIME2); assertEquals(true, test1.secondOfMinute().compareTo(dt2) < 0); assertEquals(true, test2.secondOfMinute().compareTo(dt1) > 0); assertEquals(true, test1.secondOfMinute().compareTo(dt1) == 0); try { test1.secondOfMinute().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testPropertyGetMilli() { LocalTime test = new LocalTime(10, 20, 30, 40); assertSame(test.getChronology().millisOfSecond(), test.millisOfSecond().getField()); assertEquals("millisOfSecond", test.millisOfSecond().getName()); assertEquals("Property[millisOfSecond]", test.millisOfSecond().toString()); assertSame(test, test.millisOfSecond().getLocalTime()); assertEquals(40, test.millisOfSecond().get()); assertEquals("40", test.millisOfSecond().getAsString()); assertEquals("40", test.millisOfSecond().getAsText()); assertEquals("40", test.millisOfSecond().getAsText(Locale.FRENCH)); assertEquals("40", test.millisOfSecond().getAsShortText()); assertEquals("40", test.millisOfSecond().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().millis(), test.millisOfSecond().getDurationField()); assertEquals(test.getChronology().seconds(), test.millisOfSecond().getRangeDurationField()); assertEquals(3, test.millisOfSecond().getMaximumTextLength(null)); assertEquals(3, test.millisOfSecond().getMaximumShortTextLength(null)); } public void testPropertyGetMaxMinValuesMilli() { LocalTime test = new LocalTime(10, 20, 30, 40); assertEquals(0, test.millisOfSecond().getMinimumValue()); assertEquals(0, test.millisOfSecond().getMinimumValueOverall()); assertEquals(999, test.millisOfSecond().getMaximumValue()); assertEquals(999, test.millisOfSecond().getMaximumValueOverall()); } public void testPropertyWithMaxMinValueMilli() { LocalTime test = new LocalTime(10, 20, 30, 40); check(test.millisOfSecond().withMaximumValue(), 10, 20, 30, 999); check(test.millisOfSecond().withMinimumValue(), 10, 20, 30, 0); } public void testPropertyPlusMilli() { LocalTime test = new LocalTime(10, 20, 30, 40); LocalTime copy = test.millisOfSecond().addCopy(9); check(test, 10, 20, 30, 40); check(copy, 10, 20, 30, 49); copy = test.millisOfSecond().addCopy(959); check(copy, 10, 20, 30, 999); copy = test.millisOfSecond().addCopy(960); check(copy, 10, 20, 31, 0); copy = test.millisOfSecond().addCopy(13 * 60 * 60 * 1000 + 39 * 60 * 1000 + 29 * 1000 + 959); check(copy, 23, 59, 59, 999); copy = test.millisOfSecond().addCopy(13 * 60 * 60 * 1000 + 39 * 60 * 1000 + 29 * 1000 + 960); check(copy, 0, 0, 0, 0); copy = test.millisOfSecond().addCopy(-9); check(copy, 10, 20, 30, 31); copy = test.millisOfSecond().addCopy(-40); check(copy, 10, 20, 30, 0); copy = test.millisOfSecond().addCopy(-41); check(copy, 10, 20, 29, 999); copy = test.millisOfSecond().addCopy(-(10 * 60 * 60 * 1000 + 20 * 60 * 1000 + 30 * 1000 + 40)); check(copy, 0, 0, 0, 0); copy = test.millisOfSecond().addCopy(-(10 * 60 * 60 * 1000 + 20 * 60 * 1000 + 30 * 1000 + 41)); check(copy, 23, 59, 59, 999); } public void testPropertyPlusNoWrapMilli() { LocalTime test = new LocalTime(10, 20, 30, 40); LocalTime copy = test.millisOfSecond().addNoWrapToCopy(9); check(test, 10, 20, 30, 40); check(copy, 10, 20, 30, 49); copy = test.millisOfSecond().addNoWrapToCopy(959); check(copy, 10, 20, 30, 999); copy = test.millisOfSecond().addNoWrapToCopy(960); check(copy, 10, 20, 31, 0); copy = test.millisOfSecond().addNoWrapToCopy(13 * 60 * 60 * 1000 + 39 * 60 * 1000 + 29 * 1000 + 959); check(copy, 23, 59, 59, 999); try { test.millisOfSecond().addNoWrapToCopy(13 * 60 * 60 * 1000 + 39 * 60 * 1000 + 29 * 1000 + 960); fail(); } catch (IllegalArgumentException ex) {} check(test, 10, 20, 30, 40); copy = test.millisOfSecond().addNoWrapToCopy(-9); check(copy, 10, 20, 30, 31); copy = test.millisOfSecond().addNoWrapToCopy(-40); check(copy, 10, 20, 30, 0); copy = test.millisOfSecond().addNoWrapToCopy(-41); check(copy, 10, 20, 29, 999); copy = test.millisOfSecond().addNoWrapToCopy(-(10 * 60 * 60 * 1000 + 20 * 60 * 1000 + 30 * 1000 + 40)); check(copy, 0, 0, 0, 0); try { test.millisOfSecond().addNoWrapToCopy(-(10 * 60 * 60 * 1000 + 20 * 60 * 1000 + 30 * 1000 + 41)); fail(); } catch (IllegalArgumentException ex) {} check(test, 10, 20, 30, 40); } public void testPropertyPlusWrapFieldMilli() { LocalTime test = new LocalTime(10, 20, 30, 40); LocalTime copy = test.millisOfSecond().addWrapFieldToCopy(9); check(test, 10, 20, 30, 40); check(copy, 10, 20, 30, 49); copy = test.millisOfSecond().addWrapFieldToCopy(995); check(copy, 10, 20, 30, 35); copy = test.millisOfSecond().addWrapFieldToCopy(-47); check(copy, 10, 20, 30, 993); } public void testPropertySetMilli() { LocalTime test = new LocalTime(10, 20, 30, 40); LocalTime copy = test.millisOfSecond().setCopy(12); check(test, 10, 20, 30, 40); check(copy, 10, 20, 30, 12); try { test.millisOfSecond().setCopy(1000); fail(); } catch (IllegalArgumentException ex) {} try { test.millisOfSecond().setCopy(-1); fail(); } catch (IllegalArgumentException ex) {} } public void testPropertySetTextMilli() { LocalTime test = new LocalTime(10, 20, 30, 40); LocalTime copy = test.millisOfSecond().setCopy("12"); check(test, 10, 20, 30, 40); check(copy, 10, 20, 30, 12); } public void testPropertyCompareToMilli() { LocalTime test1 = new LocalTime(TEST_TIME1); LocalTime test2 = new LocalTime(TEST_TIME2); assertEquals(true, test1.millisOfSecond().compareTo(test2) < 0); assertEquals(true, test2.millisOfSecond().compareTo(test1) > 0); assertEquals(true, test1.millisOfSecond().compareTo(test1) == 0); try { test1.millisOfSecond().compareTo((ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} DateTime dt1 = new DateTime(TEST_TIME1); DateTime dt2 = new DateTime(TEST_TIME2); assertEquals(true, test1.millisOfSecond().compareTo(dt2) < 0); assertEquals(true, test2.millisOfSecond().compareTo(dt1) > 0); assertEquals(true, test1.millisOfSecond().compareTo(dt1) == 0); try { test1.millisOfSecond().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- private void check(LocalTime test, int hour, int min, int sec, int milli) { assertEquals(hour, test.getHourOfDay()); assertEquals(min, test.getMinuteOfHour()); assertEquals(sec, test.getSecondOfMinute()); assertEquals(milli, test.getMillisOfSecond()); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import junit.framework.TestCase; import junit.framework.TestSuite; /** * This class is a Junit unit test for Minutes. * * @author Stephen Colebourne */ public class TestMinutes extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestMinutes.class); } public TestMinutes(String name) { super(name); } protected void setUp() throws Exception { } protected void tearDown() throws Exception { } //----------------------------------------------------------------------- public void testConstants() { assertEquals(0, Minutes.ZERO.getMinutes()); assertEquals(1, Minutes.ONE.getMinutes()); assertEquals(2, Minutes.TWO.getMinutes()); assertEquals(3, Minutes.THREE.getMinutes()); assertEquals(Integer.MAX_VALUE, Minutes.MAX_VALUE.getMinutes()); assertEquals(Integer.MIN_VALUE, Minutes.MIN_VALUE.getMinutes()); } //----------------------------------------------------------------------- public void testFactory_minutes_int() { assertSame(Minutes.ZERO, Minutes.minutes(0)); assertSame(Minutes.ONE, Minutes.minutes(1)); assertSame(Minutes.TWO, Minutes.minutes(2)); assertSame(Minutes.THREE, Minutes.minutes(3)); assertSame(Minutes.MAX_VALUE, Minutes.minutes(Integer.MAX_VALUE)); assertSame(Minutes.MIN_VALUE, Minutes.minutes(Integer.MIN_VALUE)); assertEquals(-1, Minutes.minutes(-1).getMinutes()); assertEquals(4, Minutes.minutes(4).getMinutes()); } //----------------------------------------------------------------------- public void testFactory_minutesBetween_RInstant() { DateTime start = new DateTime(2006, 6, 9, 12, 3, 0, 0, PARIS); DateTime end1 = new DateTime(2006, 6, 9, 12, 6, 0, 0, PARIS); DateTime end2 = new DateTime(2006, 6, 9, 12, 9, 0, 0, PARIS); assertEquals(3, Minutes.minutesBetween(start, end1).getMinutes()); assertEquals(0, Minutes.minutesBetween(start, start).getMinutes()); assertEquals(0, Minutes.minutesBetween(end1, end1).getMinutes()); assertEquals(-3, Minutes.minutesBetween(end1, start).getMinutes()); assertEquals(6, Minutes.minutesBetween(start, end2).getMinutes()); } public void testFactory_minutesBetween_RPartial() { LocalTime start = new LocalTime(12, 3); LocalTime end1 = new LocalTime(12, 6); @SuppressWarnings("deprecation") TimeOfDay end2 = new TimeOfDay(12, 9); assertEquals(3, Minutes.minutesBetween(start, end1).getMinutes()); assertEquals(0, Minutes.minutesBetween(start, start).getMinutes()); assertEquals(0, Minutes.minutesBetween(end1, end1).getMinutes()); assertEquals(-3, Minutes.minutesBetween(end1, start).getMinutes()); assertEquals(6, Minutes.minutesBetween(start, end2).getMinutes()); } public void testFactory_minutesIn_RInterval() { DateTime start = new DateTime(2006, 6, 9, 12, 3, 0, 0, PARIS); DateTime end1 = new DateTime(2006, 6, 9, 12, 6, 0, 0, PARIS); DateTime end2 = new DateTime(2006, 6, 9, 12, 9, 0, 0, PARIS); assertEquals(0, Minutes.minutesIn((ReadableInterval) null).getMinutes()); assertEquals(3, Minutes.minutesIn(new Interval(start, end1)).getMinutes()); assertEquals(0, Minutes.minutesIn(new Interval(start, start)).getMinutes()); assertEquals(0, Minutes.minutesIn(new Interval(end1, end1)).getMinutes()); assertEquals(6, Minutes.minutesIn(new Interval(start, end2)).getMinutes()); } public void testFactory_standardMinutesIn_RPeriod() { assertEquals(0, Minutes.standardMinutesIn((ReadablePeriod) null).getMinutes()); assertEquals(0, Minutes.standardMinutesIn(Period.ZERO).getMinutes()); assertEquals(1, Minutes.standardMinutesIn(new Period(0, 0, 0, 0, 0, 1, 0, 0)).getMinutes()); assertEquals(123, Minutes.standardMinutesIn(Period.minutes(123)).getMinutes()); assertEquals(-987, Minutes.standardMinutesIn(Period.minutes(-987)).getMinutes()); assertEquals(1, Minutes.standardMinutesIn(Period.seconds(119)).getMinutes()); assertEquals(2, Minutes.standardMinutesIn(Period.seconds(120)).getMinutes()); assertEquals(2, Minutes.standardMinutesIn(Period.seconds(121)).getMinutes()); assertEquals(120, Minutes.standardMinutesIn(Period.hours(2)).getMinutes()); try { Minutes.standardMinutesIn(Period.months(1)); fail(); } catch (IllegalArgumentException ex) { // expeceted } } public void testFactory_parseMinutes_String() { assertEquals(0, Minutes.parseMinutes((String) null).getMinutes()); assertEquals(0, Minutes.parseMinutes("PT0M").getMinutes()); assertEquals(1, Minutes.parseMinutes("PT1M").getMinutes()); assertEquals(-3, Minutes.parseMinutes("PT-3M").getMinutes()); assertEquals(2, Minutes.parseMinutes("P0Y0M0DT2M").getMinutes()); assertEquals(2, Minutes.parseMinutes("PT0H2M").getMinutes()); try { Minutes.parseMinutes("P1Y1D"); fail(); } catch (IllegalArgumentException ex) { // expeceted } try { Minutes.parseMinutes("P1DT1M"); fail(); } catch (IllegalArgumentException ex) { // expeceted } } //----------------------------------------------------------------------- public void testGetMethods() { Minutes test = Minutes.minutes(20); assertEquals(20, test.getMinutes()); } public void testGetFieldType() { Minutes test = Minutes.minutes(20); assertEquals(DurationFieldType.minutes(), test.getFieldType()); } public void testGetPeriodType() { Minutes test = Minutes.minutes(20); assertEquals(PeriodType.minutes(), test.getPeriodType()); } //----------------------------------------------------------------------- public void testIsGreaterThan() { assertEquals(true, Minutes.THREE.isGreaterThan(Minutes.TWO)); assertEquals(false, Minutes.THREE.isGreaterThan(Minutes.THREE)); assertEquals(false, Minutes.TWO.isGreaterThan(Minutes.THREE)); assertEquals(true, Minutes.ONE.isGreaterThan(null)); assertEquals(false, Minutes.minutes(-1).isGreaterThan(null)); } public void testIsLessThan() { assertEquals(false, Minutes.THREE.isLessThan(Minutes.TWO)); assertEquals(false, Minutes.THREE.isLessThan(Minutes.THREE)); assertEquals(true, Minutes.TWO.isLessThan(Minutes.THREE)); assertEquals(false, Minutes.ONE.isLessThan(null)); assertEquals(true, Minutes.minutes(-1).isLessThan(null)); } //----------------------------------------------------------------------- public void testToString() { Minutes test = Minutes.minutes(20); assertEquals("PT20M", test.toString()); test = Minutes.minutes(-20); assertEquals("PT-20M", test.toString()); } //----------------------------------------------------------------------- public void testSerialization() throws Exception { Minutes test = Minutes.THREE; ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(test); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); Minutes result = (Minutes) ois.readObject(); ois.close(); assertSame(test, result); } //----------------------------------------------------------------------- public void testToStandardWeeks() { Minutes test = Minutes.minutes(60 * 24 * 7 * 2); Weeks expected = Weeks.weeks(2); assertEquals(expected, test.toStandardWeeks()); } public void testToStandardDays() { Minutes test = Minutes.minutes(60 * 24 * 2); Days expected = Days.days(2); assertEquals(expected, test.toStandardDays()); } public void testToStandardHours() { Minutes test = Minutes.minutes(3 * 60); Hours expected = Hours.hours(3); assertEquals(expected, test.toStandardHours()); } public void testToStandardSeconds() { Minutes test = Minutes.minutes(3); Seconds expected = Seconds.seconds(3 * 60); assertEquals(expected, test.toStandardSeconds()); try { Minutes.MAX_VALUE.toStandardSeconds(); fail(); } catch (ArithmeticException ex) { // expected } } public void testToStandardDuration() { Minutes test = Minutes.minutes(20); Duration expected = new Duration(20L * DateTimeConstants.MILLIS_PER_MINUTE); assertEquals(expected, test.toStandardDuration()); expected = new Duration(((long) Integer.MAX_VALUE) * DateTimeConstants.MILLIS_PER_MINUTE); assertEquals(expected, Minutes.MAX_VALUE.toStandardDuration()); } //----------------------------------------------------------------------- public void testPlus_int() { Minutes test2 = Minutes.minutes(2); Minutes result = test2.plus(3); assertEquals(2, test2.getMinutes()); assertEquals(5, result.getMinutes()); assertEquals(1, Minutes.ONE.plus(0).getMinutes()); try { Minutes.MAX_VALUE.plus(1); fail(); } catch (ArithmeticException ex) { // expected } } public void testPlus_Minutes() { Minutes test2 = Minutes.minutes(2); Minutes test3 = Minutes.minutes(3); Minutes result = test2.plus(test3); assertEquals(2, test2.getMinutes()); assertEquals(3, test3.getMinutes()); assertEquals(5, result.getMinutes()); assertEquals(1, Minutes.ONE.plus(Minutes.ZERO).getMinutes()); assertEquals(1, Minutes.ONE.plus((Minutes) null).getMinutes()); try { Minutes.MAX_VALUE.plus(Minutes.ONE); fail(); } catch (ArithmeticException ex) { // expected } } public void testMinus_int() { Minutes test2 = Minutes.minutes(2); Minutes result = test2.minus(3); assertEquals(2, test2.getMinutes()); assertEquals(-1, result.getMinutes()); assertEquals(1, Minutes.ONE.minus(0).getMinutes()); try { Minutes.MIN_VALUE.minus(1); fail(); } catch (ArithmeticException ex) { // expected } } public void testMinus_Minutes() { Minutes test2 = Minutes.minutes(2); Minutes test3 = Minutes.minutes(3); Minutes result = test2.minus(test3); assertEquals(2, test2.getMinutes()); assertEquals(3, test3.getMinutes()); assertEquals(-1, result.getMinutes()); assertEquals(1, Minutes.ONE.minus(Minutes.ZERO).getMinutes()); assertEquals(1, Minutes.ONE.minus((Minutes) null).getMinutes()); try { Minutes.MIN_VALUE.minus(Minutes.ONE); fail(); } catch (ArithmeticException ex) { // expected } } public void testMultipliedBy_int() { Minutes test = Minutes.minutes(2); assertEquals(6, test.multipliedBy(3).getMinutes()); assertEquals(2, test.getMinutes()); assertEquals(-6, test.multipliedBy(-3).getMinutes()); assertSame(test, test.multipliedBy(1)); Minutes halfMax = Minutes.minutes(Integer.MAX_VALUE / 2 + 1); try { halfMax.multipliedBy(2); fail(); } catch (ArithmeticException ex) { // expected } } public void testDividedBy_int() { Minutes test = Minutes.minutes(12); assertEquals(6, test.dividedBy(2).getMinutes()); assertEquals(12, test.getMinutes()); assertEquals(4, test.dividedBy(3).getMinutes()); assertEquals(3, test.dividedBy(4).getMinutes()); assertEquals(2, test.dividedBy(5).getMinutes()); assertEquals(2, test.dividedBy(6).getMinutes()); assertSame(test, test.dividedBy(1)); try { Minutes.ONE.dividedBy(0); fail(); } catch (ArithmeticException ex) { // expected } } public void testNegated() { Minutes test = Minutes.minutes(12); assertEquals(-12, test.negated().getMinutes()); assertEquals(12, test.getMinutes()); try { Minutes.MIN_VALUE.negated(); fail(); } catch (ArithmeticException ex) { // expected } } //----------------------------------------------------------------------- public void testAddToLocalDate() { Minutes test = Minutes.minutes(26); LocalDateTime date = new LocalDateTime(2006, 6, 1, 0, 0, 0, 0); LocalDateTime expected = new LocalDateTime(2006, 6, 1, 0, 26, 0, 0); assertEquals(expected, date.plus(test)); } }
/* * Copyright 2001-2010 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Arrays; import java.util.Locale; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.BuddhistChronology; import org.joda.time.chrono.CopticChronology; import org.joda.time.chrono.GregorianChronology; import org.joda.time.chrono.ISOChronology; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; /** * This class is a Junit unit test for MonthDay. Based on {@link TestYearMonth_Basics} */ public class TestMonthDay_Basics extends TestCase { private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo"); private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS); // private static final Chronology COPTIC_LONDON = CopticChronology.getInstance(LONDON); private static final Chronology COPTIC_TOKYO = CopticChronology.getInstance(TOKYO); private static final Chronology COPTIC_UTC = CopticChronology.getInstanceUTC(); // private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS); // private static final Chronology ISO_LONDON = ISOChronology.getInstance(LONDON); // private static final Chronology ISO_TOKYO = ISOChronology.getInstance(TOKYO); private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC(); // private static final Chronology BUDDHIST_PARIS = BuddhistChronology.getInstance(PARIS); // private static final Chronology BUDDHIST_LONDON = BuddhistChronology.getInstance(LONDON); private static final Chronology BUDDHIST_TOKYO = BuddhistChronology.getInstance(TOKYO); private static final Chronology BUDDHIST_UTC = BuddhistChronology.getInstanceUTC(); private long TEST_TIME_NOW = (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; private DateTimeZone zone = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestMonthDay_Basics.class); } public TestMonthDay_Basics(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); zone = DateTimeZone.getDefault(); DateTimeZone.setDefault(LONDON); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(zone); zone = null; } //----------------------------------------------------------------------- public void testGet() { MonthDay test = new MonthDay(); assertEquals(6, test.get(DateTimeFieldType.monthOfYear())); assertEquals(9, test.get(DateTimeFieldType.dayOfMonth())); try { test.get(null); fail(); } catch (IllegalArgumentException ex) {} try { test.get(DateTimeFieldType.year()); fail(); } catch (IllegalArgumentException ex) {} } public void testSize() { MonthDay test = new MonthDay(); assertEquals(2, test.size()); } public void testGetFieldType() { MonthDay test = new MonthDay(COPTIC_PARIS); assertSame(DateTimeFieldType.monthOfYear(), test.getFieldType(0)); assertSame(DateTimeFieldType.dayOfMonth(), test.getFieldType(1)); try { test.getFieldType(-1); } catch (IndexOutOfBoundsException ex) {} try { test.getFieldType(2); } catch (IndexOutOfBoundsException ex) {} } public void testGetFieldTypes() { MonthDay test = new MonthDay(COPTIC_PARIS); DateTimeFieldType[] fields = test.getFieldTypes(); assertEquals(2, fields.length); assertSame(DateTimeFieldType.monthOfYear(), fields[0]); assertSame(DateTimeFieldType.dayOfMonth(), fields[1]); assertNotSame(test.getFieldTypes(), test.getFieldTypes()); } public void testGetField() { MonthDay test = new MonthDay(COPTIC_PARIS); assertSame(COPTIC_UTC.monthOfYear(), test.getField(0)); assertSame(COPTIC_UTC.dayOfMonth(), test.getField(1)); try { test.getField(-1); } catch (IndexOutOfBoundsException ex) {} try { test.getField(2); } catch (IndexOutOfBoundsException ex) {} } public void testGetFields() { MonthDay test = new MonthDay(COPTIC_PARIS); DateTimeField[] fields = test.getFields(); assertEquals(2, fields.length); assertSame(COPTIC_UTC.monthOfYear(), fields[0]); assertSame(COPTIC_UTC.dayOfMonth(), fields[1]); assertNotSame(test.getFields(), test.getFields()); } public void testGetValue() { MonthDay test = new MonthDay(); assertEquals(6, test.getValue(0)); assertEquals(9, test.getValue(1)); try { test.getValue(-1); } catch (IndexOutOfBoundsException ex) {} try { test.getValue(2); } catch (IndexOutOfBoundsException ex) {} } public void testGetValues() { MonthDay test = new MonthDay(); int[] values = test.getValues(); assertEquals(2, values.length); assertEquals(6, values[0]); assertEquals(9, values[1]); assertNotSame(test.getValues(), test.getValues()); } public void testIsSupported() { MonthDay test = new MonthDay(COPTIC_PARIS); assertEquals(false, test.isSupported(DateTimeFieldType.year())); assertEquals(true, test.isSupported(DateTimeFieldType.monthOfYear())); assertEquals(true, test.isSupported(DateTimeFieldType.dayOfMonth())); assertEquals(false, test.isSupported(DateTimeFieldType.hourOfDay())); } public void testEqualsHashCode() { MonthDay test1 = new MonthDay(10, 6, COPTIC_PARIS); MonthDay test2 = new MonthDay(10, 6, COPTIC_PARIS); assertEquals(true, test1.equals(test2)); assertEquals(true, test2.equals(test1)); assertEquals(true, test1.equals(test1)); assertEquals(true, test2.equals(test2)); assertEquals(true, test1.hashCode() == test2.hashCode()); assertEquals(true, test1.hashCode() == test1.hashCode()); assertEquals(true, test2.hashCode() == test2.hashCode()); MonthDay test3 = new MonthDay(10, 6); assertEquals(false, test1.equals(test3)); assertEquals(false, test2.equals(test3)); assertEquals(false, test3.equals(test1)); assertEquals(false, test3.equals(test2)); assertEquals(false, test1.hashCode() == test3.hashCode()); assertEquals(false, test2.hashCode() == test3.hashCode()); assertEquals(false, test1.equals("Hello")); assertEquals(true, test1.equals(new MockMD())); assertEquals(false, test1.equals(MockPartial.EMPTY_INSTANCE)); } class MockMD extends MockPartial { @Override public Chronology getChronology() { return COPTIC_UTC; } @Override public DateTimeField[] getFields() { return new DateTimeField[] { COPTIC_UTC.monthOfYear(), COPTIC_UTC.dayOfMonth() }; } @Override public int[] getValues() { return new int[] {10, 6}; } } //----------------------------------------------------------------------- public void testCompareTo() { MonthDay test1 = new MonthDay(6, 6); MonthDay test1a = new MonthDay(6, 6); assertEquals(0, test1.compareTo(test1a)); assertEquals(0, test1a.compareTo(test1)); assertEquals(0, test1.compareTo(test1)); assertEquals(0, test1a.compareTo(test1a)); MonthDay test2 = new MonthDay(6, 7); assertEquals(-1, test1.compareTo(test2)); assertEquals(+1, test2.compareTo(test1)); MonthDay test3 = new MonthDay(6, 7, GregorianChronology.getInstanceUTC()); assertEquals(-1, test1.compareTo(test3)); assertEquals(+1, test3.compareTo(test1)); assertEquals(0, test3.compareTo(test2)); DateTimeFieldType[] types = new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }; int[] values = new int[] {6, 6}; Partial p = new Partial(types, values); assertEquals(0, test1.compareTo(p)); try { test1.compareTo(null); fail(); } catch (NullPointerException ex) {} try { test1.compareTo(new LocalTime()); fail(); } catch (ClassCastException ex) {} Partial partial = new Partial() .with(DateTimeFieldType.centuryOfEra(), 1) .with(DateTimeFieldType.halfdayOfDay(), 0) .with(DateTimeFieldType.dayOfMonth(), 9); try { new MonthDay(10, 6).compareTo(partial); fail(); } catch (ClassCastException ex) {} } //----------------------------------------------------------------------- public void testIsEqual_MD() { MonthDay test1 = new MonthDay(6, 6); MonthDay test1a = new MonthDay(6, 6); assertEquals(true, test1.isEqual(test1a)); assertEquals(true, test1a.isEqual(test1)); assertEquals(true, test1.isEqual(test1)); assertEquals(true, test1a.isEqual(test1a)); MonthDay test2 = new MonthDay(6, 7); assertEquals(false, test1.isEqual(test2)); assertEquals(false, test2.isEqual(test1)); MonthDay test3 = new MonthDay(6, 7, GregorianChronology.getInstanceUTC()); assertEquals(false, test1.isEqual(test3)); assertEquals(false, test3.isEqual(test1)); assertEquals(true, test3.isEqual(test2)); try { new MonthDay(6, 7).isEqual(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testIsBefore_MD() { MonthDay test1 = new MonthDay(6, 6); MonthDay test1a = new MonthDay(6, 6); assertEquals(false, test1.isBefore(test1a)); assertEquals(false, test1a.isBefore(test1)); assertEquals(false, test1.isBefore(test1)); assertEquals(false, test1a.isBefore(test1a)); MonthDay test2 = new MonthDay(6, 7); assertEquals(true, test1.isBefore(test2)); assertEquals(false, test2.isBefore(test1)); MonthDay test3 = new MonthDay(6, 7, GregorianChronology.getInstanceUTC()); assertEquals(true, test1.isBefore(test3)); assertEquals(false, test3.isBefore(test1)); assertEquals(false, test3.isBefore(test2)); try { new MonthDay(6, 7).isBefore(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testIsAfter_MD() { MonthDay test1 = new MonthDay(6, 6); MonthDay test1a = new MonthDay(6, 6); assertEquals(false, test1.isAfter(test1a)); assertEquals(false, test1a.isAfter(test1)); assertEquals(false, test1.isAfter(test1)); assertEquals(false, test1a.isAfter(test1a)); MonthDay test2 = new MonthDay(6, 7); assertEquals(false, test1.isAfter(test2)); assertEquals(true, test2.isAfter(test1)); MonthDay test3 = new MonthDay(6, 7, GregorianChronology.getInstanceUTC()); assertEquals(false, test1.isAfter(test3)); assertEquals(true, test3.isAfter(test1)); assertEquals(false, test3.isAfter(test2)); try { new MonthDay(6, 7).isAfter(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testWithChronologyRetainFields_Chrono() { MonthDay base = new MonthDay(6, 6, COPTIC_PARIS); MonthDay test = base.withChronologyRetainFields(BUDDHIST_TOKYO); check(base, 6, 6); assertEquals(COPTIC_UTC, base.getChronology()); check(test, 6, 6); assertEquals(BUDDHIST_UTC, test.getChronology()); } public void testWithChronologyRetainFields_sameChrono() { MonthDay base = new MonthDay(6, 6, COPTIC_PARIS); MonthDay test = base.withChronologyRetainFields(COPTIC_TOKYO); assertSame(base, test); } public void testWithChronologyRetainFields_nullChrono() { MonthDay base = new MonthDay(6, 6, COPTIC_PARIS); MonthDay test = base.withChronologyRetainFields(null); check(base, 6, 6); assertEquals(COPTIC_UTC, base.getChronology()); check(test, 6, 6); assertEquals(ISO_UTC, test.getChronology()); } //----------------------------------------------------------------------- public void testWithField() { MonthDay test = new MonthDay(9, 6); MonthDay result = test.withField(DateTimeFieldType.monthOfYear(), 10); assertEquals(new MonthDay(9, 6), test); assertEquals(new MonthDay(10, 6), result); } public void testWithField_nullField() { MonthDay test = new MonthDay(9, 6); try { test.withField(null, 6); fail(); } catch (IllegalArgumentException ex) {} } public void testWithField_unknownField() { MonthDay test = new MonthDay(9, 6); try { test.withField(DateTimeFieldType.hourOfDay(), 6); fail(); } catch (IllegalArgumentException ex) {} } public void testWithField_same() { MonthDay test = new MonthDay(9, 6); MonthDay result = test.withField(DateTimeFieldType.monthOfYear(), 9); assertEquals(new MonthDay(9, 6), test); assertSame(test, result); } //----------------------------------------------------------------------- public void testWithFieldAdded() { MonthDay test = new MonthDay(9, 6); MonthDay result = test.withFieldAdded(DurationFieldType.months(), 1); assertEquals(new MonthDay(9, 6), test); assertEquals(new MonthDay(10, 6), result); } public void testWithFieldAdded_nullField_zero() { MonthDay test = new MonthDay(9, 6); try { test.withFieldAdded(null, 0); fail(); } catch (IllegalArgumentException ex) {} } public void testWithFieldAdded_nullField_nonZero() { MonthDay test = new MonthDay(9, 6); try { test.withFieldAdded(null, 6); fail(); } catch (IllegalArgumentException ex) {} } public void testWithFieldAdded_zero() { MonthDay test = new MonthDay(9, 6); MonthDay result = test.withFieldAdded(DurationFieldType.months(), 0); assertSame(test, result); } public void testWithFieldAdded_unknownField() { MonthDay test = new MonthDay(9, 6); try { test.withFieldAdded(DurationFieldType.hours(), 6); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testPlus_RP() { MonthDay test = new MonthDay(6, 5, BuddhistChronology.getInstance()); MonthDay result = test.plus(new Period(1, 2, 3, 4, 5, 6, 7, 8)); MonthDay expected = new MonthDay(8, 9, BuddhistChronology.getInstance()); assertEquals(expected, result); result = test.plus((ReadablePeriod) null); assertSame(test, result); } public void testPlusMonths_int() { MonthDay test = new MonthDay(6, 5, BuddhistChronology.getInstance()); MonthDay result = test.plusMonths(1); MonthDay expected = new MonthDay(7, 5, BuddhistChronology.getInstance()); assertEquals(expected, result); } public void testPlusMonths_int_fromLeap() { MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC()); MonthDay result = test.plusMonths(1); MonthDay expected = new MonthDay(3, 29, ISOChronology.getInstance()); assertEquals(expected, result); } public void testPlusMonths_int_negativeFromLeap() { MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC()); MonthDay result = test.plusMonths(-1); MonthDay expected = new MonthDay(1, 29, ISOChronology.getInstance()); assertEquals(expected, result); } public void testPlusMonths_int_endOfMonthAdjust() { MonthDay test = new MonthDay(3, 31, ISOChronology.getInstanceUTC()); MonthDay result = test.plusMonths(1); MonthDay expected = new MonthDay(4, 30, ISOChronology.getInstance()); assertEquals(expected, result); } public void testPlusMonths_int_negativeEndOfMonthAdjust() { MonthDay test = new MonthDay(3, 31, ISOChronology.getInstanceUTC()); MonthDay result = test.plusMonths(-1); MonthDay expected = new MonthDay(2, 29, ISOChronology.getInstance()); assertEquals(expected, result); } public void testPlusMonths_int_same() { MonthDay test = new MonthDay(6, 5, ISO_UTC); MonthDay result = test.plusMonths(0); assertSame(test, result); } public void testPlusMonths_int_wrap() { MonthDay test = new MonthDay(6, 5, ISO_UTC); MonthDay result = test.plusMonths(10); MonthDay expected = new MonthDay(4, 5, ISO_UTC); assertEquals(expected, result); } public void testPlusMonths_int_adjust() { MonthDay test = new MonthDay(7, 31, ISO_UTC); MonthDay result = test.plusMonths(2); MonthDay expected = new MonthDay(9, 30, ISO_UTC); assertEquals(expected, result); } //------------------------------------------------------------------------- public void testPlusDays_int() { MonthDay test = new MonthDay(5, 10, BuddhistChronology.getInstance()); MonthDay result = test.plusDays(1); MonthDay expected = new MonthDay(5, 11, BuddhistChronology.getInstance()); assertEquals(expected, result); } public void testPlusDays_int_fromLeap() { MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC()); MonthDay result = test.plusDays(1); MonthDay expected = new MonthDay(3, 1, ISOChronology.getInstance()); assertEquals(expected, result); } public void testPlusDays_int_negativeFromLeap() { MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC()); MonthDay result = test.plusDays(-1); MonthDay expected = new MonthDay(2, 28, ISOChronology.getInstance()); assertEquals(expected, result); } public void testPlusDays_same() { MonthDay test = new MonthDay(5, 10, BuddhistChronology.getInstance()); MonthDay result = test.plusDays(0); assertSame(test, result); } //----------------------------------------------------------------------- public void testMinus_RP() { MonthDay test = new MonthDay(6, 5, BuddhistChronology.getInstance()); MonthDay result = test.minus(new Period(1, 1, 1, 1, 1, 1, 1, 1)); MonthDay expected = new MonthDay(5, 4, BuddhistChronology.getInstance()); assertEquals(expected, result); result = test.minus((ReadablePeriod) null); assertSame(test, result); } public void testMinusMonths_int() { MonthDay test = new MonthDay(6, 5, BuddhistChronology.getInstance()); MonthDay result = test.minusMonths(1); MonthDay expected = new MonthDay(5, 5, BuddhistChronology.getInstance()); assertEquals(expected, result); } public void testMinusMonths_int_fromLeap() { MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC()); MonthDay result = test.minusMonths(1); MonthDay expected = new MonthDay(1, 29, ISOChronology.getInstance()); assertEquals(expected, result); } public void testMinusMonths_int_negativeFromLeap() { MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC()); MonthDay result = test.minusMonths(-1); MonthDay expected = new MonthDay(3, 29, ISOChronology.getInstance()); assertEquals(expected, result); } public void testMinusMonths_int_endOfMonthAdjust() { MonthDay test = new MonthDay(3, 31, ISOChronology.getInstanceUTC()); MonthDay result = test.minusMonths(1); MonthDay expected = new MonthDay(2, 29, ISOChronology.getInstance()); assertEquals(expected, result); } public void testMinusMonths_int_negativeEndOfMonthAdjust() { MonthDay test = new MonthDay(3, 31, ISOChronology.getInstanceUTC()); MonthDay result = test.minusMonths(-1); MonthDay expected = new MonthDay(4, 30, ISOChronology.getInstance()); assertEquals(expected, result); } public void testMinusMonths_int_same() { MonthDay test = new MonthDay(6, 5, ISO_UTC); MonthDay result = test.minusMonths(0); assertSame(test, result); } public void testMinusMonths_int_wrap() { MonthDay test = new MonthDay(6, 5, ISO_UTC); MonthDay result = test.minusMonths(10); MonthDay expected = new MonthDay(8, 5, ISO_UTC); assertEquals(expected, result); } public void testMinusMonths_int_adjust() { MonthDay test = new MonthDay(7, 31, ISO_UTC); MonthDay result = test.minusMonths(3); MonthDay expected = new MonthDay(4, 30, ISO_UTC); assertEquals(expected, result); } //------------------------------------------------------------------------- public void testMinusDays_int() { MonthDay test = new MonthDay(5, 11, BuddhistChronology.getInstance()); MonthDay result = test.minusDays(1); MonthDay expected = new MonthDay(5, 10, BuddhistChronology.getInstance()); assertEquals(expected, result); } public void testMinusDays_int_fromLeap() { MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC()); MonthDay result = test.minusDays(1); MonthDay expected = new MonthDay(2, 28, ISOChronology.getInstance()); assertEquals(expected, result); } public void testMinusDays_int_negativeFromLeap() { MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC()); MonthDay result = test.minusDays(-1); MonthDay expected = new MonthDay(3, 1, ISOChronology.getInstance()); assertEquals(expected, result); } public void testMinusDays_same() { MonthDay test = new MonthDay(5, 11, BuddhistChronology.getInstance()); MonthDay result = test.minusDays(0); assertSame(test, result); } //----------------------------------------------------------------------- public void testToLocalDate() { MonthDay base = new MonthDay(6, 6, COPTIC_UTC); LocalDate test = base.toLocalDate(2009); assertEquals(new LocalDate(2009, 6, 6, COPTIC_UTC), test); try { base.toLocalDate(0); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testToDateTime_RI() { MonthDay base = new MonthDay(6, 6, COPTIC_PARIS); DateTime dt = new DateTime(2002, 1, 3, 4, 5, 6, 7); DateTime test = base.toDateTime(dt); check(base, 6, 6); DateTime expected = dt; expected = expected.monthOfYear().setCopy(6); expected = expected.dayOfMonth().setCopy(6); assertEquals(expected, test); } public void testToDateTime_nullRI() { MonthDay base = new MonthDay(6, 6); DateTime dt = new DateTime(2002, 1, 3, 4, 5, 6, 7); DateTimeUtils.setCurrentMillisFixed(dt.getMillis()); DateTime test = base.toDateTime((ReadableInstant) null); check(base, 6, 6); DateTime expected = dt; expected = expected.monthOfYear().setCopy(6); expected = expected.dayOfMonth().setCopy(6); assertEquals(expected, test); } //----------------------------------------------------------------------- public void testWithers() { MonthDay test = new MonthDay(10, 6); check(test.withMonthOfYear(5), 5, 6); check(test.withDayOfMonth(2), 10, 2); try { test.withMonthOfYear(0); fail(); } catch (IllegalArgumentException ex) {} try { test.withMonthOfYear(13); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testProperty() { MonthDay test = new MonthDay(6, 6); assertEquals(test.monthOfYear(), test.property(DateTimeFieldType.monthOfYear())); assertEquals(test.dayOfMonth(), test.property(DateTimeFieldType.dayOfMonth())); try { test.property(DateTimeFieldType.millisOfDay()); fail(); } catch (IllegalArgumentException ex) {} try { test.property(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testSerialization() throws Exception { MonthDay test = new MonthDay(5, 6, COPTIC_PARIS); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(test); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); MonthDay result = (MonthDay) ois.readObject(); ois.close(); assertEquals(test, result); assertTrue(Arrays.equals(test.getValues(), result.getValues())); assertTrue(Arrays.equals(test.getFields(), result.getFields())); assertEquals(test.getChronology(), result.getChronology()); } //----------------------------------------------------------------------- public void testToString() { MonthDay test = new MonthDay(5, 6); assertEquals("--05-06", test.toString()); } //----------------------------------------------------------------------- public void testToString_String() { MonthDay test = new MonthDay(5, 6); assertEquals("05 \ufffd\ufffd", test.toString("MM HH")); assertEquals("--05-06", test.toString((String) null)); } //----------------------------------------------------------------------- public void testToString_String_Locale() { MonthDay test = new MonthDay(5, 6); assertEquals("\ufffd 6/5", test.toString("EEE d/M", Locale.ENGLISH)); assertEquals("\ufffd 6/5", test.toString("EEE d/M", Locale.FRENCH)); assertEquals("--05-06", test.toString(null, Locale.ENGLISH)); assertEquals("\ufffd 6/5", test.toString("EEE d/M", null)); assertEquals("--05-06", test.toString(null, null)); } //----------------------------------------------------------------------- public void testToString_DTFormatter() { MonthDay test = new MonthDay(5, 6); assertEquals("05 \ufffd\ufffd", test.toString(DateTimeFormat.forPattern("MM HH"))); assertEquals("--05-06", test.toString((DateTimeFormatter) null)); } //----------------------------------------------------------------------- private void check(MonthDay test, int month, int day) { assertEquals(month, test.getMonthOfYear()); assertEquals(day, test.getDayOfMonth()); } }
/* * Copyright 2001-2010 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.GregorianChronology; import org.joda.time.chrono.ISOChronology; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; /** * This class is a Junit unit test for MonthDay. Based on {@link TestYearMonth_Constuctors} */ public class TestMonthDay_Constructors extends TestCase { private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC(); private static final Chronology GREGORIAN_UTC = GregorianChronology.getInstanceUTC(); private static final Chronology GREGORIAN_PARIS = GregorianChronology.getInstance(PARIS); private long TEST_TIME_NOW = (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; private long TEST_TIME1 = (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; private long TEST_TIME2 = (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone zone = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestMonthDay_Constructors.class); } public TestMonthDay_Constructors(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); zone = DateTimeZone.getDefault(); DateTimeZone.setDefault(LONDON); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(zone); zone = null; } //----------------------------------------------------------------------- public void testParse_noFormatter() throws Throwable { assertEquals(new MonthDay(6, 30), MonthDay.parse("--06-30")); assertEquals(new MonthDay(2, 29), MonthDay.parse("--02-29")); assertEquals(new MonthDay(6, 30), MonthDay.parse("2010-06-30")); assertEquals(new MonthDay(1, 2), MonthDay.parse("2010-002")); } public void testParse_formatter() throws Throwable { DateTimeFormatter f = DateTimeFormat.forPattern("yyyy--dd MM").withChronology(ISOChronology.getInstance(PARIS)); assertEquals(new MonthDay(6, 30), MonthDay.parse("2010--30 06", f)); } //----------------------------------------------------------------------- public void testFactory_FromCalendarFields() throws Exception { GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6); cal.set(Calendar.MILLISECOND, 7); MonthDay expected = new MonthDay(2, 3); assertEquals(expected, MonthDay.fromCalendarFields(cal)); try { MonthDay.fromCalendarFields(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testFactory_FromDateFields() throws Exception { GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6); cal.set(Calendar.MILLISECOND, 7); MonthDay expected = new MonthDay(2, 3); assertEquals(expected, MonthDay.fromDateFields(cal.getTime())); try { MonthDay.fromDateFields(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- /** * Test constructor () */ public void testConstructor() throws Throwable { MonthDay test = new MonthDay(); assertEquals(ISO_UTC, test.getChronology()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(test, MonthDay.now()); } /** * Test constructor (DateTimeZone) */ public void testConstructor_DateTimeZone() throws Throwable { DateTime dt = new DateTime(2005, 6, 30, 23, 59, 0, 0, LONDON); DateTimeUtils.setCurrentMillisFixed(dt.getMillis()); // 23:59 in London is 00:59 the following day in Paris MonthDay test = new MonthDay(LONDON); assertEquals(ISO_UTC, test.getChronology()); assertEquals(6, test.getMonthOfYear()); assertEquals(30, test.getDayOfMonth()); assertEquals(test, MonthDay.now(LONDON)); test = new MonthDay(PARIS); assertEquals(ISO_UTC, test.getChronology()); assertEquals(7, test.getMonthOfYear()); assertEquals(1, test.getDayOfMonth()); assertEquals(test, MonthDay.now(PARIS)); } /** * Test constructor (DateTimeZone=null) */ public void testConstructor_nullDateTimeZone() throws Throwable { DateTime dt = new DateTime(2005, 6, 30, 23, 59, 0, 0, LONDON); DateTimeUtils.setCurrentMillisFixed(dt.getMillis()); // 23:59 in London is 00:59 the following day in Paris MonthDay test = new MonthDay((DateTimeZone) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(6, test.getMonthOfYear()); assertEquals(30, test.getDayOfMonth()); } /** * Test constructor (Chronology) */ public void testConstructor_Chronology() throws Throwable { MonthDay test = new MonthDay(GREGORIAN_PARIS); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(test, MonthDay.now(GREGORIAN_PARIS)); } /** * Test constructor (Chronology=null) */ public void testConstructor_nullChronology() throws Throwable { MonthDay test = new MonthDay((Chronology) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); } //----------------------------------------------------------------------- /** * Test constructor (long) */ public void testConstructor_long1() throws Throwable { MonthDay test = new MonthDay(TEST_TIME1); assertEquals(ISO_UTC, test.getChronology()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); } /** * Test constructor (long) */ public void testConstructor_long2() throws Throwable { MonthDay test = new MonthDay(TEST_TIME2); assertEquals(ISO_UTC, test.getChronology()); assertEquals(5, test.getMonthOfYear()); assertEquals(7, test.getDayOfMonth()); } /** * Test constructor (long, Chronology) */ public void testConstructor_long1_Chronology() throws Throwable { MonthDay test = new MonthDay(TEST_TIME1, GREGORIAN_PARIS); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); } /** * Test constructor (long, Chronology) */ public void testConstructor_long2_Chronology() throws Throwable { MonthDay test = new MonthDay(TEST_TIME2, GREGORIAN_PARIS); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(5, test.getMonthOfYear()); assertEquals(7, test.getDayOfMonth()); } /** * Test constructor (long, Chronology=null) */ public void testConstructor_long_nullChronology() throws Throwable { MonthDay test = new MonthDay(TEST_TIME1, null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); } //----------------------------------------------------------------------- public void testConstructor_Object() throws Throwable { Date date = new Date(TEST_TIME1); MonthDay test = new MonthDay(date); assertEquals(ISO_UTC, test.getChronology()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); } public void testConstructor_nullObject() throws Throwable { MonthDay test = new MonthDay((Object) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); } public void testConstructor_ObjectString1() throws Throwable { MonthDay test = new MonthDay("1972-12"); assertEquals(ISO_UTC, test.getChronology()); assertEquals(12, test.getMonthOfYear()); assertEquals(1, test.getDayOfMonth()); } public void testConstructor_ObjectString5() throws Throwable { MonthDay test = new MonthDay("10"); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1, test.getMonthOfYear()); assertEquals(1, test.getDayOfMonth()); } public void testConstructor_ObjectStringEx1() throws Throwable { try { new MonthDay("T10:20:30.040"); fail(); } catch (IllegalArgumentException ex) { // expected } } public void testConstructor_ObjectStringEx2() throws Throwable { try { new MonthDay("T10:20:30.040+14:00"); fail(); } catch (IllegalArgumentException ex) { // expected } } public void testConstructor_ObjectStringEx3() throws Throwable { try { new MonthDay("10:20:30.040"); fail(); } catch (IllegalArgumentException ex) { // expected } } public void testConstructor_ObjectStringEx4() throws Throwable { try { new MonthDay("10:20:30.040+14:00"); fail(); } catch (IllegalArgumentException ex) { // expected } } //----------------------------------------------------------------------- /** * Test constructor (Object, Chronology) */ public void testConstructor_Object_Chronology() throws Throwable { Date date = new Date(TEST_TIME1); MonthDay test = new MonthDay(date, GREGORIAN_PARIS); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); } /** * Test constructor (Object=null, Chronology) */ public void testConstructor_nullObject_Chronology() throws Throwable { MonthDay test = new MonthDay((Object) null, GREGORIAN_PARIS); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); } /** * Test constructor (Object, Chronology=null) */ public void testConstructor_Object_nullChronology() throws Throwable { Date date = new Date(TEST_TIME1); MonthDay test = new MonthDay(date, null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); } /** * Test constructor (Object=null, Chronology=null) */ public void testConstructor_nullObject_nullChronology() throws Throwable { MonthDay test = new MonthDay((Object) null, null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); } //----------------------------------------------------------------------- /** * Test constructor (int, int) */ public void testConstructor_int_int() throws Throwable { MonthDay test = new MonthDay(6, 30); assertEquals(ISO_UTC, test.getChronology()); assertEquals(6, test.getMonthOfYear()); assertEquals(30, test.getDayOfMonth()); try { new MonthDay(Integer.MIN_VALUE, 6); fail(); } catch (IllegalArgumentException ex) {} try { new MonthDay(Integer.MAX_VALUE, 6); fail(); } catch (IllegalArgumentException ex) {} try { new MonthDay(1970, 0); fail(); } catch (IllegalArgumentException ex) {} try { new MonthDay(1970, 13); fail(); } catch (IllegalArgumentException ex) {} } /** * Test constructor (int, int, Chronology) */ public void testConstructor_int_int_Chronology() throws Throwable { MonthDay test = new MonthDay(6, 30, GREGORIAN_PARIS); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(6, test.getMonthOfYear()); assertEquals(30, test.getDayOfMonth()); try { new MonthDay(Integer.MIN_VALUE, 6, GREGORIAN_PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new MonthDay(Integer.MAX_VALUE, 6, GREGORIAN_PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new MonthDay(1970, 0, GREGORIAN_PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new MonthDay(1970, 13, GREGORIAN_PARIS); fail(); } catch (IllegalArgumentException ex) {} } /** * Test constructor (int, int, Chronology=null) */ public void testConstructor_int_int_nullChronology() throws Throwable { MonthDay test = new MonthDay(6, 30, null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(6, test.getMonthOfYear()); assertEquals(30, test.getDayOfMonth()); } }
/* * Copyright 2001-2011 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.util.Locale; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.CopticChronology; import org.joda.time.chrono.LenientChronology; import org.joda.time.chrono.StrictChronology; /** * This class is a Junit unit test for MonthDay. Based on {@link TestYearMonth_Propeties} */ public class TestMonthDay_Properties extends TestCase { private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS); private long TEST_TIME_NOW = (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; private long TEST_TIME1 = (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; private long TEST_TIME2 = (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone zone = null; private Locale locale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestMonthDay_Properties.class); } public TestMonthDay_Properties(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); zone = DateTimeZone.getDefault(); locale = Locale.getDefault(); Locale.setDefault(Locale.UK); DateTimeZone.setDefault(DateTimeZone.UTC); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(zone); zone = null; Locale.setDefault(locale); locale = null; } //----------------------------------------------------------------------- public void testPropertyGetMonthOfYear() { MonthDay test = new MonthDay(9, 6); assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField()); assertEquals("monthOfYear", test.monthOfYear().getName()); assertEquals("Property[monthOfYear]", test.monthOfYear().toString()); assertSame(test, test.monthOfYear().getReadablePartial()); assertSame(test, test.monthOfYear().getMonthDay()); assertEquals(9, test.monthOfYear().get()); assertEquals("9", test.monthOfYear().getAsString()); assertEquals("September", test.monthOfYear().getAsText()); assertEquals("septembre", test.monthOfYear().getAsText(Locale.FRENCH)); assertEquals("Sep", test.monthOfYear().getAsShortText()); assertEquals("sept.", test.monthOfYear().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField()); // assertEquals(test.getChronology().days(), test.dayOfMonth().getRangeDurationField()); assertEquals(9, test.monthOfYear().getMaximumTextLength(null)); assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null)); } public void testPropertyGetMaxMinValuesMonthOfYear() { MonthDay test = new MonthDay(10, 6); assertEquals(1, test.monthOfYear().getMinimumValue()); assertEquals(1, test.monthOfYear().getMinimumValueOverall()); assertEquals(12, test.monthOfYear().getMaximumValue()); assertEquals(12, test.monthOfYear().getMaximumValueOverall()); } public void testPropertyAddMonthOfYear() { MonthDay test = new MonthDay(3, 6); MonthDay copy = test.monthOfYear().addToCopy(9); check(test, 3, 6); check(copy, 12, 6); copy = test.monthOfYear().addToCopy(0); check(copy, 3, 6); check(test, 3, 6); copy = test.monthOfYear().addToCopy(-3); check(copy, 12, 6); check(test, 3, 6); } public void testPropertyAddWrapFieldMonthOfYear() { MonthDay test = new MonthDay(5, 6); MonthDay copy = test.monthOfYear().addWrapFieldToCopy(2); check(test, 5, 6); check(copy, 7, 6); copy = test.monthOfYear().addWrapFieldToCopy(2); check(copy, 7, 6); copy = test.monthOfYear().addWrapFieldToCopy(292278993 - 4 + 1); check(copy, 11, 6); copy = test.monthOfYear().addWrapFieldToCopy(-292275054 - 4 - 1); check(copy, 6, 6); } public void testPropertySetMonthOfYear() { MonthDay test = new MonthDay(10, 6); MonthDay copy = test.monthOfYear().setCopy(12); check(test, 10, 6); check(copy, 12, 6); } public void testPropertySetTextMonthOfYear() { MonthDay test = new MonthDay(10, 6); MonthDay copy = test.monthOfYear().setCopy("12"); check(test, 10, 6); check(copy, 12, 6); } public void testPropertyCompareToMonthOfYear() { MonthDay test1 = new MonthDay(TEST_TIME1); MonthDay test2 = new MonthDay(TEST_TIME2); assertEquals(true, test1.monthOfYear().compareTo(test2) < 0); assertEquals(true, test2.monthOfYear().compareTo(test1) > 0); assertEquals(true, test1.monthOfYear().compareTo(test1) == 0); try { test1.monthOfYear().compareTo((ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} DateTime dt1 = new DateTime(TEST_TIME1); DateTime dt2 = new DateTime(TEST_TIME2); assertEquals(true, test1.monthOfYear().compareTo(dt2) < 0); assertEquals(true, test2.monthOfYear().compareTo(dt1) > 0); assertEquals(true, test1.monthOfYear().compareTo(dt1) == 0); try { test1.monthOfYear().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testPropertyGetDayOfMonth() { MonthDay test = new MonthDay(4, 6); assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField()); assertEquals("dayOfMonth", test.dayOfMonth().getName()); assertEquals("Property[dayOfMonth]", test.dayOfMonth().toString()); assertSame(test, test.dayOfMonth().getReadablePartial()); assertSame(test, test.dayOfMonth().getMonthDay()); assertEquals(6, test.dayOfMonth().get()); assertEquals("6", test.dayOfMonth().getAsString()); assertEquals("6", test.dayOfMonth().getAsText()); assertEquals("6", test.dayOfMonth().getAsText(Locale.FRENCH)); assertEquals("6", test.dayOfMonth().getAsShortText()); assertEquals("6", test.dayOfMonth().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField()); assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField()); assertEquals(2, test.dayOfMonth().getMaximumTextLength(null)); assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null)); test = new MonthDay(4, 7); assertEquals("7", test.dayOfMonth().getAsText(Locale.FRENCH)); assertEquals("7", test.dayOfMonth().getAsShortText(Locale.FRENCH)); } public void testPropertyGetMaxMinValuesDayOfMonth() { MonthDay test = new MonthDay(4, 6); assertEquals(1, test.dayOfMonth().getMinimumValue()); assertEquals(1, test.dayOfMonth().getMinimumValueOverall()); assertEquals(30, test.dayOfMonth().getMaximumValue()); assertEquals(31, test.dayOfMonth().getMaximumValueOverall()); } public void testPropertyAddDayOfMonth() { MonthDay test = new MonthDay(4, 6); MonthDay copy = test.dayOfMonth().addToCopy(6); check(test, 4, 6); check(copy, 4, 12); copy = test.dayOfMonth().addToCopy(7); check(copy, 4, 13); copy = test.dayOfMonth().addToCopy(-5); check(copy, 4, 1); copy = test.dayOfMonth().addToCopy(-6); check(copy, 3, 31); } public void testPropertyAddWrapFieldDayOfMonth() { MonthDay test = new MonthDay(4, 6); MonthDay copy = test.dayOfMonth().addWrapFieldToCopy(4); check(test, 4, 6); check(copy, 4, 10); copy = test.dayOfMonth().addWrapFieldToCopy(8); check(copy, 4, 14); copy = test.dayOfMonth().addWrapFieldToCopy(-8); check(copy, 4, 28); } public void testPropertySetDayOfMonth() { MonthDay test = new MonthDay(4, 6); MonthDay copy = test.dayOfMonth().setCopy(12); check(test, 4, 6); check(copy, 4, 12); try { test.dayOfMonth().setCopy(33); fail(); } catch (IllegalArgumentException ex) {} try { test.dayOfMonth().setCopy(0); fail(); } catch (IllegalArgumentException ex) {} } public void testPropertySetTextDayOfMonth() { MonthDay test = new MonthDay(4, 6); MonthDay copy = test.dayOfMonth().setCopy("12"); check(test, 4, 6); check(copy, 4, 12); copy = test.dayOfMonth().setCopy("2"); check(test, 4, 6); check(copy, 4, 2); copy = test.dayOfMonth().setCopy("4"); check(test, 4, 6); check(copy, 4, 4); } public void testPropertyCompareToDayOfMonth() { MonthDay test1 = new MonthDay(TEST_TIME1); MonthDay test2 = new MonthDay(TEST_TIME2); assertEquals(true, test1.dayOfMonth().compareTo(test2) < 0); assertEquals(true, test2.dayOfMonth().compareTo(test1) > 0); assertEquals(true, test1.dayOfMonth().compareTo(test1) == 0); try { test1.dayOfMonth().compareTo((ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} DateTime dt1 = new DateTime(TEST_TIME1); DateTime dt2 = new DateTime(TEST_TIME2); assertEquals(true, test1.dayOfMonth().compareTo(dt2) < 0); assertEquals(true, test2.dayOfMonth().compareTo(dt1) > 0); assertEquals(true, test1.dayOfMonth().compareTo(dt1) == 0); try { test1.dayOfMonth().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testPropertyEquals() { MonthDay test1 = new MonthDay(11, 11); MonthDay test2 = new MonthDay(11, 12); MonthDay test3 = new MonthDay(11, 11, CopticChronology.getInstanceUTC()); assertEquals(true, test1.dayOfMonth().equals(test1.dayOfMonth())); assertEquals(false, test1.dayOfMonth().equals(test1.monthOfYear())); assertEquals(false, test1.dayOfMonth().equals(test2.dayOfMonth())); assertEquals(false, test1.dayOfMonth().equals(test2.monthOfYear())); assertEquals(false, test1.monthOfYear().equals(test1.dayOfMonth())); assertEquals(true, test1.monthOfYear().equals(test1.monthOfYear())); assertEquals(false, test1.monthOfYear().equals(test2.dayOfMonth())); assertEquals(true, test1.monthOfYear().equals(test2.monthOfYear())); assertEquals(false, test1.dayOfMonth().equals(null)); assertEquals(false, test1.dayOfMonth().equals("any")); // chrono assertEquals(false, test1.dayOfMonth().equals(test3.dayOfMonth())); } public void testPropertyHashCode() { MonthDay test1 = new MonthDay(5, 11); MonthDay test2 = new MonthDay(5, 12); assertEquals(true, test1.dayOfMonth().hashCode() == test1.dayOfMonth().hashCode()); assertEquals(false, test1.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode()); assertEquals(true, test1.monthOfYear().hashCode() == test1.monthOfYear().hashCode()); assertEquals(true, test1.monthOfYear().hashCode() == test2.monthOfYear().hashCode()); } public void testPropertyEqualsHashCodeLenient() { MonthDay test1 = new MonthDay(5, 6, LenientChronology.getInstance(COPTIC_PARIS)); MonthDay test2 = new MonthDay(5, 6, LenientChronology.getInstance(COPTIC_PARIS)); assertEquals(true, test1.dayOfMonth().equals(test2.dayOfMonth())); assertEquals(true, test2.dayOfMonth().equals(test1.dayOfMonth())); assertEquals(true, test1.dayOfMonth().equals(test1.dayOfMonth())); assertEquals(true, test2.dayOfMonth().equals(test2.dayOfMonth())); assertEquals(true, test1.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode()); assertEquals(true, test1.dayOfMonth().hashCode() == test1.dayOfMonth().hashCode()); assertEquals(true, test2.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode()); } public void testPropertyEqualsHashCodeStrict() { MonthDay test1 = new MonthDay(5, 6, StrictChronology.getInstance(COPTIC_PARIS)); MonthDay test2 = new MonthDay(5, 6, StrictChronology.getInstance(COPTIC_PARIS)); assertEquals(true, test1.dayOfMonth().equals(test2.dayOfMonth())); assertEquals(true, test2.dayOfMonth().equals(test1.dayOfMonth())); assertEquals(true, test1.dayOfMonth().equals(test1.dayOfMonth())); assertEquals(true, test2.dayOfMonth().equals(test2.dayOfMonth())); assertEquals(true, test1.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode()); assertEquals(true, test1.dayOfMonth().hashCode() == test1.dayOfMonth().hashCode()); assertEquals(true, test2.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode()); } //----------------------------------------------------------------------- private void check(MonthDay test, int monthOfYear, int dayOfMonth) { assertEquals(monthOfYear, test.getMonthOfYear()); assertEquals(dayOfMonth, test.getDayOfMonth()); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import junit.framework.TestCase; import junit.framework.TestSuite; /** * This class is a Junit unit test for Months. * * @author Stephen Colebourne */ public class TestMonths extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestMonths.class); } public TestMonths(String name) { super(name); } protected void setUp() throws Exception { } protected void tearDown() throws Exception { } //----------------------------------------------------------------------- public void testConstants() { assertEquals(0, Months.ZERO.getMonths()); assertEquals(1, Months.ONE.getMonths()); assertEquals(2, Months.TWO.getMonths()); assertEquals(3, Months.THREE.getMonths()); assertEquals(4, Months.FOUR.getMonths()); assertEquals(5, Months.FIVE.getMonths()); assertEquals(6, Months.SIX.getMonths()); assertEquals(7, Months.SEVEN.getMonths()); assertEquals(8, Months.EIGHT.getMonths()); assertEquals(9, Months.NINE.getMonths()); assertEquals(10, Months.TEN.getMonths()); assertEquals(11, Months.ELEVEN.getMonths()); assertEquals(12, Months.TWELVE.getMonths()); assertEquals(Integer.MAX_VALUE, Months.MAX_VALUE.getMonths()); assertEquals(Integer.MIN_VALUE, Months.MIN_VALUE.getMonths()); } //----------------------------------------------------------------------- public void testFactory_months_int() { assertSame(Months.ZERO, Months.months(0)); assertSame(Months.ONE, Months.months(1)); assertSame(Months.TWO, Months.months(2)); assertSame(Months.THREE, Months.months(3)); assertSame(Months.FOUR, Months.months(4)); assertSame(Months.FIVE, Months.months(5)); assertSame(Months.SIX, Months.months(6)); assertSame(Months.SEVEN, Months.months(7)); assertSame(Months.EIGHT, Months.months(8)); assertSame(Months.NINE, Months.months(9)); assertSame(Months.TEN, Months.months(10)); assertSame(Months.ELEVEN, Months.months(11)); assertSame(Months.TWELVE, Months.months(12)); assertSame(Months.MAX_VALUE, Months.months(Integer.MAX_VALUE)); assertSame(Months.MIN_VALUE, Months.months(Integer.MIN_VALUE)); assertEquals(-1, Months.months(-1).getMonths()); assertEquals(13, Months.months(13).getMonths()); } //----------------------------------------------------------------------- public void testFactory_monthsBetween_RInstant() { DateTime start = new DateTime(2006, 6, 9, 12, 0, 0, 0, PARIS); DateTime end1 = new DateTime(2006, 9, 9, 12, 0, 0, 0, PARIS); DateTime end2 = new DateTime(2006, 12, 9, 12, 0, 0, 0, PARIS); assertEquals(3, Months.monthsBetween(start, end1).getMonths()); assertEquals(0, Months.monthsBetween(start, start).getMonths()); assertEquals(0, Months.monthsBetween(end1, end1).getMonths()); assertEquals(-3, Months.monthsBetween(end1, start).getMonths()); assertEquals(6, Months.monthsBetween(start, end2).getMonths()); } //------------------------------------------------------------------------- @SuppressWarnings("deprecation") public void testFactory_monthsBetween_RPartial_LocalDate() { LocalDate start = new LocalDate(2006, 6, 9); LocalDate end1 = new LocalDate(2006, 9, 9); YearMonthDay end2 = new YearMonthDay(2006, 12, 9); assertEquals(3, Months.monthsBetween(start, end1).getMonths()); assertEquals(0, Months.monthsBetween(start, start).getMonths()); assertEquals(0, Months.monthsBetween(end1, end1).getMonths()); assertEquals(-3, Months.monthsBetween(end1, start).getMonths()); assertEquals(6, Months.monthsBetween(start, end2).getMonths()); } public void testFactory_monthsBetween_RPartial_YearMonth() { YearMonth start1 = new YearMonth(2011, 1); for (int i = 0; i < 6; i++) { YearMonth start2 = new YearMonth(2011 + i, 1); YearMonth end = new YearMonth(2011 + i, 3); assertEquals(i * 12 + 2, Months.monthsBetween(start1, end).getMonths()); assertEquals(2, Months.monthsBetween(start2, end).getMonths()); } } public void testFactory_monthsBetween_RPartial_MonthDay() { MonthDay start = new MonthDay(2, 1); MonthDay end1 = new MonthDay(2, 28); MonthDay end2 = new MonthDay(2, 29); MonthDay end3 = new MonthDay(3, 1); assertEquals(0, Months.monthsBetween(start, end1).getMonths()); assertEquals(0, Months.monthsBetween(start, end2).getMonths()); assertEquals(1, Months.monthsBetween(start, end3).getMonths()); assertEquals(0, Months.monthsBetween(end1, start).getMonths()); assertEquals(0, Months.monthsBetween(end2, start).getMonths()); assertEquals(-1, Months.monthsBetween(end3, start).getMonths()); } //------------------------------------------------------------------------- public void testFactory_monthsIn_RInterval() { DateTime start = new DateTime(2006, 6, 9, 12, 0, 0, 0, PARIS); DateTime end1 = new DateTime(2006, 9, 9, 12, 0, 0, 0, PARIS); DateTime end2 = new DateTime(2006, 12, 9, 12, 0, 0, 0, PARIS); assertEquals(0, Months.monthsIn((ReadableInterval) null).getMonths()); assertEquals(3, Months.monthsIn(new Interval(start, end1)).getMonths()); assertEquals(0, Months.monthsIn(new Interval(start, start)).getMonths()); assertEquals(0, Months.monthsIn(new Interval(end1, end1)).getMonths()); assertEquals(6, Months.monthsIn(new Interval(start, end2)).getMonths()); } public void testFactory_parseMonths_String() { assertEquals(0, Months.parseMonths((String) null).getMonths()); assertEquals(0, Months.parseMonths("P0M").getMonths()); assertEquals(1, Months.parseMonths("P1M").getMonths()); assertEquals(-3, Months.parseMonths("P-3M").getMonths()); assertEquals(2, Months.parseMonths("P0Y2M").getMonths()); assertEquals(2, Months.parseMonths("P2MT0H0M").getMonths()); try { Months.parseMonths("P1Y1D"); fail(); } catch (IllegalArgumentException ex) { // expeceted } try { Months.parseMonths("P1MT1H"); fail(); } catch (IllegalArgumentException ex) { // expeceted } } //----------------------------------------------------------------------- public void testGetMethods() { Months test = Months.months(20); assertEquals(20, test.getMonths()); } public void testGetFieldType() { Months test = Months.months(20); assertEquals(DurationFieldType.months(), test.getFieldType()); } public void testGetPeriodType() { Months test = Months.months(20); assertEquals(PeriodType.months(), test.getPeriodType()); } //----------------------------------------------------------------------- public void testIsGreaterThan() { assertEquals(true, Months.THREE.isGreaterThan(Months.TWO)); assertEquals(false, Months.THREE.isGreaterThan(Months.THREE)); assertEquals(false, Months.TWO.isGreaterThan(Months.THREE)); assertEquals(true, Months.ONE.isGreaterThan(null)); assertEquals(false, Months.months(-1).isGreaterThan(null)); } public void testIsLessThan() { assertEquals(false, Months.THREE.isLessThan(Months.TWO)); assertEquals(false, Months.THREE.isLessThan(Months.THREE)); assertEquals(true, Months.TWO.isLessThan(Months.THREE)); assertEquals(false, Months.ONE.isLessThan(null)); assertEquals(true, Months.months(-1).isLessThan(null)); } //----------------------------------------------------------------------- public void testToString() { Months test = Months.months(20); assertEquals("P20M", test.toString()); test = Months.months(-20); assertEquals("P-20M", test.toString()); } //----------------------------------------------------------------------- public void testSerialization() throws Exception { Months test = Months.THREE; ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(test); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); Months result = (Months) ois.readObject(); ois.close(); assertSame(test, result); } //----------------------------------------------------------------------- public void testPlus_int() { Months test2 = Months.months(2); Months result = test2.plus(3); assertEquals(2, test2.getMonths()); assertEquals(5, result.getMonths()); assertEquals(1, Months.ONE.plus(0).getMonths()); try { Months.MAX_VALUE.plus(1); fail(); } catch (ArithmeticException ex) { // expected } } public void testPlus_Months() { Months test2 = Months.months(2); Months test3 = Months.months(3); Months result = test2.plus(test3); assertEquals(2, test2.getMonths()); assertEquals(3, test3.getMonths()); assertEquals(5, result.getMonths()); assertEquals(1, Months.ONE.plus(Months.ZERO).getMonths()); assertEquals(1, Months.ONE.plus((Months) null).getMonths()); try { Months.MAX_VALUE.plus(Months.ONE); fail(); } catch (ArithmeticException ex) { // expected } } public void testMinus_int() { Months test2 = Months.months(2); Months result = test2.minus(3); assertEquals(2, test2.getMonths()); assertEquals(-1, result.getMonths()); assertEquals(1, Months.ONE.minus(0).getMonths()); try { Months.MIN_VALUE.minus(1); fail(); } catch (ArithmeticException ex) { // expected } } public void testMinus_Months() { Months test2 = Months.months(2); Months test3 = Months.months(3); Months result = test2.minus(test3); assertEquals(2, test2.getMonths()); assertEquals(3, test3.getMonths()); assertEquals(-1, result.getMonths()); assertEquals(1, Months.ONE.minus(Months.ZERO).getMonths()); assertEquals(1, Months.ONE.minus((Months) null).getMonths()); try { Months.MIN_VALUE.minus(Months.ONE); fail(); } catch (ArithmeticException ex) { // expected } } public void testMultipliedBy_int() { Months test = Months.months(2); assertEquals(6, test.multipliedBy(3).getMonths()); assertEquals(2, test.getMonths()); assertEquals(-6, test.multipliedBy(-3).getMonths()); assertSame(test, test.multipliedBy(1)); Months halfMax = Months.months(Integer.MAX_VALUE / 2 + 1); try { halfMax.multipliedBy(2); fail(); } catch (ArithmeticException ex) { // expected } } public void testDividedBy_int() { Months test = Months.months(12); assertEquals(6, test.dividedBy(2).getMonths()); assertEquals(12, test.getMonths()); assertEquals(4, test.dividedBy(3).getMonths()); assertEquals(3, test.dividedBy(4).getMonths()); assertEquals(2, test.dividedBy(5).getMonths()); assertEquals(2, test.dividedBy(6).getMonths()); assertSame(test, test.dividedBy(1)); try { Months.ONE.dividedBy(0); fail(); } catch (ArithmeticException ex) { // expected } } public void testNegated() { Months test = Months.months(12); assertEquals(-12, test.negated().getMonths()); assertEquals(12, test.getMonths()); try { Months.MIN_VALUE.negated(); fail(); } catch (ArithmeticException ex) { // expected } } //----------------------------------------------------------------------- public void testAddToLocalDate() { Months test = Months.months(3); LocalDate date = new LocalDate(2006, 6, 1); LocalDate expected = new LocalDate(2006, 9, 1); assertEquals(expected, date.plus(test)); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.ISOChronology; /** * This class is a JUnit test for MutableDateTime. * * @author Stephen Colebourne */ public class TestMutableDateTime_Adds extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; // 2002-04-05 private long TEST_TIME1 = (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; // 2003-05-06 private long TEST_TIME2 = (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestMutableDateTime_Adds.class); } public TestMutableDateTime_Adds(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testTest() { assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString()); assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString()); assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString()); } //----------------------------------------------------------------------- public void testAdd_long1() { MutableDateTime test = new MutableDateTime(TEST_TIME1); test.add(123456L); assertEquals(TEST_TIME1 + 123456L, test.getMillis()); assertEquals(ISOChronology.getInstance(), test.getChronology()); } //----------------------------------------------------------------------- public void testAdd_RD1() { MutableDateTime test = new MutableDateTime(TEST_TIME1); test.add(new Duration(123456L)); assertEquals(TEST_TIME1 + 123456L, test.getMillis()); } public void testAdd_RD2() { MutableDateTime test = new MutableDateTime(TEST_TIME1); test.add((ReadableDuration) null); assertEquals(TEST_TIME1, test.getMillis()); } //----------------------------------------------------------------------- public void testAdd_RD_int1() { MutableDateTime test = new MutableDateTime(TEST_TIME1); test.add(new Duration(123456L), -2); assertEquals(TEST_TIME1 - (2L * 123456L), test.getMillis()); } public void testAdd_RD_int2() { MutableDateTime test = new MutableDateTime(TEST_TIME1); test.add((ReadableDuration) null, 1); assertEquals(TEST_TIME1, test.getMillis()); } //----------------------------------------------------------------------- public void testAdd_RP1() { Period d = new Period(1, 1, 0, 1, 1, 1, 1, 1); MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); assertEquals("2002-06-09T05:06:07.008+01:00", test.toString()); test.add(d); assertEquals("2003-07-10T06:07:08.009+01:00", test.toString()); } public void testAdd_RP2() { MutableDateTime test = new MutableDateTime(TEST_TIME1); test.add((ReadablePeriod) null); assertEquals(TEST_TIME1, test.getMillis()); } //----------------------------------------------------------------------- public void testAdd_RP_int1() { Period d = new Period(0, 0, 0, 0, 0, 0, 1, 2); MutableDateTime test = new MutableDateTime(TEST_TIME1); test.add(d, -2); assertEquals(TEST_TIME1 - (2L * 1002L), test.getMillis()); } public void testAdd_RP_int2() { MutableDateTime test = new MutableDateTime(TEST_TIME1); test.add((ReadablePeriod) null, 1); assertEquals(TEST_TIME1, test.getMillis()); } //----------------------------------------------------------------------- public void testAdd_DurationFieldType_int1() { MutableDateTime test = new MutableDateTime(TEST_TIME1); test.add(DurationFieldType.years(), 8); assertEquals(2010, test.getYear()); } public void testAdd_DurationFieldType_int_dstOverlapSummer_addZero() { MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); assertEquals("2011-10-30T02:30:00.000+02:00", test.toString()); test.add(DurationFieldType.years(), 0); assertEquals("2011-10-30T02:30:00.000+02:00", test.toString()); } public void testAdd_DurationFieldType_int_dstOverlapWinter_addZero() { MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); test.addHours(1); assertEquals("2011-10-30T02:30:00.000+01:00", test.toString()); test.add(DurationFieldType.years(), 0); assertEquals("2011-10-30T02:30:00.000+01:00", test.toString()); } public void testAdd_DurationFieldType_int2() { MutableDateTime test = new MutableDateTime(TEST_TIME1); try { test.add((DurationFieldType) null, 0); fail(); } catch (IllegalArgumentException ex) {} assertEquals(TEST_TIME1, test.getMillis()); } public void testAdd_DurationFieldType_int3() { MutableDateTime test = new MutableDateTime(TEST_TIME1); try { test.add((DurationFieldType) null, 6); fail(); } catch (IllegalArgumentException ex) {} assertEquals(TEST_TIME1, test.getMillis()); } //----------------------------------------------------------------------- public void testAddYears_int1() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); test.addYears(8); assertEquals("2010-06-09T05:06:07.008+01:00", test.toString()); } public void testAddYears_int_dstOverlapSummer_addZero() { MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); assertEquals("2011-10-30T02:30:00.000+02:00", test.toString()); test.addYears(0); assertEquals("2011-10-30T02:30:00.000+02:00", test.toString()); } public void testAddYears_int_dstOverlapWinter_addZero() { MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); test.addHours(1); assertEquals("2011-10-30T02:30:00.000+01:00", test.toString()); test.addYears(0); assertEquals("2011-10-30T02:30:00.000+01:00", test.toString()); } //----------------------------------------------------------------------- public void testAddMonths_int1() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); test.addMonths(6); assertEquals("2002-12-09T05:06:07.008Z", test.toString()); } public void testAddMonths_int_dstOverlapSummer_addZero() { MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); assertEquals("2011-10-30T02:30:00.000+02:00", test.toString()); test.addMonths(0); assertEquals("2011-10-30T02:30:00.000+02:00", test.toString()); } public void testAddMonths_int_dstOverlapWinter_addZero() { MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); test.addHours(1); assertEquals("2011-10-30T02:30:00.000+01:00", test.toString()); test.addMonths(0); assertEquals("2011-10-30T02:30:00.000+01:00", test.toString()); } //----------------------------------------------------------------------- public void testAddDays_int1() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); test.addDays(17); assertEquals("2002-06-26T05:06:07.008+01:00", test.toString()); } public void testAddDays_int_dstOverlapSummer_addZero() { MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); assertEquals("2011-10-30T02:30:00.000+02:00", test.toString()); test.addDays(0); assertEquals("2011-10-30T02:30:00.000+02:00", test.toString()); } public void testAddDays_int_dstOverlapWinter_addZero() { MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); test.addHours(1); assertEquals("2011-10-30T02:30:00.000+01:00", test.toString()); test.addDays(0); assertEquals("2011-10-30T02:30:00.000+01:00", test.toString()); } //----------------------------------------------------------------------- public void testAddWeekyears_int1() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); test.addWeekyears(-1); assertEquals("2001-06-10T05:06:07.008+01:00", test.toString()); } //----------------------------------------------------------------------- public void testAddWeeks_int1() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); test.addWeeks(-21); assertEquals("2002-01-13T05:06:07.008Z", test.toString()); } public void testAddWeeks_int_dstOverlapSummer_addZero() { MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); assertEquals("2011-10-30T02:30:00.000+02:00", test.toString()); test.addWeeks(0); assertEquals("2011-10-30T02:30:00.000+02:00", test.toString()); } public void testAddWeeks_int_dstOverlapWinter_addZero() { MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); test.addHours(1); assertEquals("2011-10-30T02:30:00.000+01:00", test.toString()); test.addWeeks(0); assertEquals("2011-10-30T02:30:00.000+01:00", test.toString()); } //----------------------------------------------------------------------- public void testAddHours_int1() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); test.addHours(13); assertEquals("2002-06-09T18:06:07.008+01:00", test.toString()); } public void testAddHours_int_dstOverlapSummer_addZero() { MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); assertEquals("2011-10-30T02:30:00.000+02:00", test.toString()); test.addHours(0); assertEquals("2011-10-30T02:30:00.000+02:00", test.toString()); } public void testAddHours_int_dstOverlapWinter_addZero() { MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); test.addHours(1); assertEquals("2011-10-30T02:30:00.000+01:00", test.toString()); test.addHours(0); assertEquals("2011-10-30T02:30:00.000+01:00", test.toString()); } //----------------------------------------------------------------------- public void testAddMinutes_int1() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); test.addMinutes(13); assertEquals("2002-06-09T05:19:07.008+01:00", test.toString()); } public void testAddMinutes_int_dstOverlapSummer_addZero() { MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); assertEquals("2011-10-30T02:30:00.000+02:00", test.toString()); test.addMinutes(0); assertEquals("2011-10-30T02:30:00.000+02:00", test.toString()); } public void testAddMinutes_int_dstOverlapWinter_addZero() { MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); test.addHours(1); assertEquals("2011-10-30T02:30:00.000+01:00", test.toString()); test.addMinutes(0); assertEquals("2011-10-30T02:30:00.000+01:00", test.toString()); } //----------------------------------------------------------------------- public void testAddSeconds_int1() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); test.addSeconds(13); assertEquals("2002-06-09T05:06:20.008+01:00", test.toString()); } public void testAddSeconds_int_dstOverlapSummer_addZero() { MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); assertEquals("2011-10-30T02:30:00.000+02:00", test.toString()); test.addSeconds(0); assertEquals("2011-10-30T02:30:00.000+02:00", test.toString()); } public void testAddSeconds_int_dstOverlapWinter_addZero() { MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); test.addHours(1); assertEquals("2011-10-30T02:30:00.000+01:00", test.toString()); test.addSeconds(0); assertEquals("2011-10-30T02:30:00.000+01:00", test.toString()); } //----------------------------------------------------------------------- public void testAddMillis_int1() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); test.addMillis(13); assertEquals("2002-06-09T05:06:07.021+01:00", test.toString()); } public void testAddMillis_int_dstOverlapSummer_addZero() { MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); assertEquals("2011-10-30T02:30:00.000+02:00", test.toString()); test.addMillis(0); assertEquals("2011-10-30T02:30:00.000+02:00", test.toString()); } public void testAddMillis_int_dstOverlapWinter_addZero() { MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); test.addHours(1); assertEquals("2011-10-30T02:30:00.000+01:00", test.toString()); test.addMillis(0); assertEquals("2011-10-30T02:30:00.000+01:00", test.toString()); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.base.AbstractInstant; import org.joda.time.chrono.BaseChronology; import org.joda.time.chrono.GregorianChronology; import org.joda.time.chrono.ISOChronology; import org.joda.time.field.UnsupportedDateTimeField; import org.joda.time.field.UnsupportedDurationField; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; /** * This class is a JUnit test for MutableDateTime. * * @author Stephen Colebourne */ public class TestMutableDateTime_Basics extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; // 2002-04-05 private long TEST_TIME1 = (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; // 2003-05-06 private long TEST_TIME2 = (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestMutableDateTime_Basics.class); } public TestMutableDateTime_Basics(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testTest() { assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString()); assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString()); assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString()); } //----------------------------------------------------------------------- public void testGet_DateTimeField() { MutableDateTime test = new MutableDateTime(); assertEquals(1, test.get(ISOChronology.getInstance().era())); assertEquals(20, test.get(ISOChronology.getInstance().centuryOfEra())); assertEquals(2, test.get(ISOChronology.getInstance().yearOfCentury())); assertEquals(2002, test.get(ISOChronology.getInstance().yearOfEra())); assertEquals(2002, test.get(ISOChronology.getInstance().year())); assertEquals(6, test.get(ISOChronology.getInstance().monthOfYear())); assertEquals(9, test.get(ISOChronology.getInstance().dayOfMonth())); assertEquals(2002, test.get(ISOChronology.getInstance().weekyear())); assertEquals(23, test.get(ISOChronology.getInstance().weekOfWeekyear())); assertEquals(7, test.get(ISOChronology.getInstance().dayOfWeek())); assertEquals(160, test.get(ISOChronology.getInstance().dayOfYear())); assertEquals(0, test.get(ISOChronology.getInstance().halfdayOfDay())); assertEquals(1, test.get(ISOChronology.getInstance().hourOfHalfday())); assertEquals(1, test.get(ISOChronology.getInstance().clockhourOfDay())); assertEquals(1, test.get(ISOChronology.getInstance().clockhourOfHalfday())); assertEquals(1, test.get(ISOChronology.getInstance().hourOfDay())); assertEquals(0, test.get(ISOChronology.getInstance().minuteOfHour())); assertEquals(60, test.get(ISOChronology.getInstance().minuteOfDay())); assertEquals(0, test.get(ISOChronology.getInstance().secondOfMinute())); assertEquals(60 * 60, test.get(ISOChronology.getInstance().secondOfDay())); assertEquals(0, test.get(ISOChronology.getInstance().millisOfSecond())); assertEquals(60 * 60 * 1000, test.get(ISOChronology.getInstance().millisOfDay())); try { test.get((DateTimeField) null); fail(); } catch (IllegalArgumentException ex) {} } public void testGet_DateTimeFieldType() { MutableDateTime test = new MutableDateTime(); assertEquals(1, test.get(DateTimeFieldType.era())); assertEquals(20, test.get(DateTimeFieldType.centuryOfEra())); assertEquals(2, test.get(DateTimeFieldType.yearOfCentury())); assertEquals(2002, test.get(DateTimeFieldType.yearOfEra())); assertEquals(2002, test.get(DateTimeFieldType.year())); assertEquals(6, test.get(DateTimeFieldType.monthOfYear())); assertEquals(9, test.get(DateTimeFieldType.dayOfMonth())); assertEquals(2002, test.get(DateTimeFieldType.weekyear())); assertEquals(23, test.get(DateTimeFieldType.weekOfWeekyear())); assertEquals(7, test.get(DateTimeFieldType.dayOfWeek())); assertEquals(160, test.get(DateTimeFieldType.dayOfYear())); assertEquals(0, test.get(DateTimeFieldType.halfdayOfDay())); assertEquals(1, test.get(DateTimeFieldType.hourOfHalfday())); assertEquals(1, test.get(DateTimeFieldType.clockhourOfDay())); assertEquals(1, test.get(DateTimeFieldType.clockhourOfHalfday())); assertEquals(1, test.get(DateTimeFieldType.hourOfDay())); assertEquals(0, test.get(DateTimeFieldType.minuteOfHour())); assertEquals(60, test.get(DateTimeFieldType.minuteOfDay())); assertEquals(0, test.get(DateTimeFieldType.secondOfMinute())); assertEquals(60 * 60, test.get(DateTimeFieldType.secondOfDay())); assertEquals(0, test.get(DateTimeFieldType.millisOfSecond())); assertEquals(60 * 60 * 1000, test.get(DateTimeFieldType.millisOfDay())); try { test.get((DateTimeFieldType) null); fail(); } catch (IllegalArgumentException ex) {} } public void testGetMethods() { MutableDateTime test = new MutableDateTime(); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(LONDON, test.getZone()); assertEquals(TEST_TIME_NOW, test.getMillis()); assertEquals(1, test.getEra()); assertEquals(20, test.getCenturyOfEra()); assertEquals(2, test.getYearOfCentury()); assertEquals(2002, test.getYearOfEra()); assertEquals(2002, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(2002, test.getWeekyear()); assertEquals(23, test.getWeekOfWeekyear()); assertEquals(7, test.getDayOfWeek()); assertEquals(160, test.getDayOfYear()); assertEquals(1, test.getHourOfDay()); assertEquals(0, test.getMinuteOfHour()); assertEquals(60, test.getMinuteOfDay()); assertEquals(0, test.getSecondOfMinute()); assertEquals(60 * 60, test.getSecondOfDay()); assertEquals(0, test.getMillisOfSecond()); assertEquals(60 * 60 * 1000, test.getMillisOfDay()); } public void testEqualsHashCode() { MutableDateTime test1 = new MutableDateTime(TEST_TIME1); MutableDateTime test2 = new MutableDateTime(TEST_TIME1); assertEquals(true, test1.equals(test2)); assertEquals(true, test2.equals(test1)); assertEquals(true, test1.equals(test1)); assertEquals(true, test2.equals(test2)); assertEquals(true, test1.hashCode() == test2.hashCode()); assertEquals(true, test1.hashCode() == test1.hashCode()); assertEquals(true, test2.hashCode() == test2.hashCode()); MutableDateTime test3 = new MutableDateTime(TEST_TIME2); assertEquals(false, test1.equals(test3)); assertEquals(false, test2.equals(test3)); assertEquals(false, test3.equals(test1)); assertEquals(false, test3.equals(test2)); assertEquals(false, test1.hashCode() == test3.hashCode()); assertEquals(false, test2.hashCode() == test3.hashCode()); DateTime test4 = new DateTime(TEST_TIME2); assertEquals(true, test4.equals(test3)); assertEquals(true, test3.equals(test4)); assertEquals(false, test4.equals(test1)); assertEquals(false, test1.equals(test4)); assertEquals(true, test3.hashCode() == test4.hashCode()); assertEquals(false, test1.hashCode() == test4.hashCode()); MutableDateTime test5 = new MutableDateTime(TEST_TIME2); test5.setRounding(ISOChronology.getInstance().millisOfSecond()); assertEquals(true, test5.equals(test3)); assertEquals(true, test5.equals(test4)); assertEquals(true, test3.equals(test5)); assertEquals(true, test4.equals(test5)); assertEquals(true, test3.hashCode() == test5.hashCode()); assertEquals(true, test4.hashCode() == test5.hashCode()); assertEquals(false, test1.equals("Hello")); assertEquals(true, test1.equals(new MockInstant())); assertEquals(false, test1.equals(new MutableDateTime(TEST_TIME1, GregorianChronology.getInstance()))); assertEquals(true, new MutableDateTime(TEST_TIME1, new MockEqualsChronology()).equals(new MutableDateTime(TEST_TIME1, new MockEqualsChronology()))); assertEquals(false, new MutableDateTime(TEST_TIME1, new MockEqualsChronology()).equals(new MutableDateTime(TEST_TIME1, ISOChronology.getInstance()))); } class MockInstant extends AbstractInstant { public String toString() { return null; } public long getMillis() { return TEST_TIME1; } public Chronology getChronology() { return ISOChronology.getInstance(); } } class MockEqualsChronology extends BaseChronology { private static final long serialVersionUID = 1L; public boolean equals(Object obj) { return obj instanceof MockEqualsChronology; } public DateTimeZone getZone() { return null; } public Chronology withUTC() { return this; } public Chronology withZone(DateTimeZone zone) { return this; } public String toString() { return ""; } } public void testCompareTo() { MutableDateTime test1 = new MutableDateTime(TEST_TIME1); MutableDateTime test1a = new MutableDateTime(TEST_TIME1); assertEquals(0, test1.compareTo(test1a)); assertEquals(0, test1a.compareTo(test1)); assertEquals(0, test1.compareTo(test1)); assertEquals(0, test1a.compareTo(test1a)); MutableDateTime test2 = new MutableDateTime(TEST_TIME2); assertEquals(-1, test1.compareTo(test2)); assertEquals(+1, test2.compareTo(test1)); MutableDateTime test3 = new MutableDateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS)); assertEquals(-1, test1.compareTo(test3)); assertEquals(+1, test3.compareTo(test1)); assertEquals(0, test3.compareTo(test2)); assertEquals(+1, test2.compareTo(new MockInstant())); assertEquals(0, test1.compareTo(new MockInstant())); try { test1.compareTo(null); fail(); } catch (NullPointerException ex) {} // try { // test1.compareTo(new Date()); // fail(); // } catch (ClassCastException ex) {} } public void testIsEqual() { MutableDateTime test1 = new MutableDateTime(TEST_TIME1); MutableDateTime test1a = new MutableDateTime(TEST_TIME1); assertEquals(true, test1.isEqual(test1a)); assertEquals(true, test1a.isEqual(test1)); assertEquals(true, test1.isEqual(test1)); assertEquals(true, test1a.isEqual(test1a)); MutableDateTime test2 = new MutableDateTime(TEST_TIME2); assertEquals(false, test1.isEqual(test2)); assertEquals(false, test2.isEqual(test1)); MutableDateTime test3 = new MutableDateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS)); assertEquals(false, test1.isEqual(test3)); assertEquals(false, test3.isEqual(test1)); assertEquals(true, test3.isEqual(test2)); assertEquals(false, test2.isEqual(new MockInstant())); assertEquals(true, test1.isEqual(new MockInstant())); assertEquals(false, new MutableDateTime(TEST_TIME_NOW + 1).isEqual(null)); assertEquals(true, new MutableDateTime(TEST_TIME_NOW).isEqual(null)); assertEquals(false, new MutableDateTime(TEST_TIME_NOW - 1).isEqual(null)); } public void testIsBefore() { MutableDateTime test1 = new MutableDateTime(TEST_TIME1); MutableDateTime test1a = new MutableDateTime(TEST_TIME1); assertEquals(false, test1.isBefore(test1a)); assertEquals(false, test1a.isBefore(test1)); assertEquals(false, test1.isBefore(test1)); assertEquals(false, test1a.isBefore(test1a)); MutableDateTime test2 = new MutableDateTime(TEST_TIME2); assertEquals(true, test1.isBefore(test2)); assertEquals(false, test2.isBefore(test1)); MutableDateTime test3 = new MutableDateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS)); assertEquals(true, test1.isBefore(test3)); assertEquals(false, test3.isBefore(test1)); assertEquals(false, test3.isBefore(test2)); assertEquals(false, test2.isBefore(new MockInstant())); assertEquals(false, test1.isBefore(new MockInstant())); assertEquals(false, new MutableDateTime(TEST_TIME_NOW + 1).isBefore(null)); assertEquals(false, new MutableDateTime(TEST_TIME_NOW).isBefore(null)); assertEquals(true, new MutableDateTime(TEST_TIME_NOW - 1).isBefore(null)); } public void testIsAfter() { MutableDateTime test1 = new MutableDateTime(TEST_TIME1); MutableDateTime test1a = new MutableDateTime(TEST_TIME1); assertEquals(false, test1.isAfter(test1a)); assertEquals(false, test1a.isAfter(test1)); assertEquals(false, test1.isAfter(test1)); assertEquals(false, test1a.isAfter(test1a)); MutableDateTime test2 = new MutableDateTime(TEST_TIME2); assertEquals(false, test1.isAfter(test2)); assertEquals(true, test2.isAfter(test1)); MutableDateTime test3 = new MutableDateTime(TEST_TIME2, GregorianChronology.getInstance(PARIS)); assertEquals(false, test1.isAfter(test3)); assertEquals(true, test3.isAfter(test1)); assertEquals(false, test3.isAfter(test2)); assertEquals(true, test2.isAfter(new MockInstant())); assertEquals(false, test1.isAfter(new MockInstant())); assertEquals(true, new MutableDateTime(TEST_TIME_NOW + 1).isAfter(null)); assertEquals(false, new MutableDateTime(TEST_TIME_NOW).isAfter(null)); assertEquals(false, new MutableDateTime(TEST_TIME_NOW - 1).isAfter(null)); } //----------------------------------------------------------------------- public void testSerialization() throws Exception { MutableDateTime test = new MutableDateTime(TEST_TIME_NOW); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(test); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); MutableDateTime result = (MutableDateTime) ois.readObject(); ois.close(); assertEquals(test, result); } //----------------------------------------------------------------------- public void testToString() { MutableDateTime test = new MutableDateTime(TEST_TIME_NOW); assertEquals("2002-06-09T01:00:00.000+01:00", test.toString()); test = new MutableDateTime(TEST_TIME_NOW, PARIS); assertEquals("2002-06-09T02:00:00.000+02:00", test.toString()); } public void testToString_String() { MutableDateTime test = new MutableDateTime(TEST_TIME_NOW); assertEquals("2002 01", test.toString("yyyy HH")); assertEquals("2002-06-09T01:00:00.000+01:00", test.toString((String) null)); } public void testToString_String_String() { MutableDateTime test = new MutableDateTime(TEST_TIME_NOW); assertEquals("Sun 9/6", test.toString("EEE d/M", Locale.ENGLISH)); assertEquals("dim. 9/6", test.toString("EEE d/M", Locale.FRENCH)); assertEquals("2002-06-09T01:00:00.000+01:00", test.toString(null, Locale.ENGLISH)); assertEquals("Sun 9/6", test.toString("EEE d/M", null)); assertEquals("2002-06-09T01:00:00.000+01:00", test.toString(null, null)); } public void testToString_DTFormatter() { MutableDateTime test = new MutableDateTime(TEST_TIME_NOW); assertEquals("2002 01", test.toString(DateTimeFormat.forPattern("yyyy HH"))); assertEquals("2002-06-09T01:00:00.000+01:00", test.toString((DateTimeFormatter) null)); } //----------------------------------------------------------------------- public void testToInstant() { MutableDateTime test = new MutableDateTime(TEST_TIME1); Instant result = test.toInstant(); assertEquals(TEST_TIME1, result.getMillis()); } public void testToDateTime() { MutableDateTime test = new MutableDateTime(TEST_TIME1, PARIS); DateTime result = test.toDateTime(); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISOChronology.getInstance(PARIS), result.getChronology()); } public void testToDateTimeISO() { MutableDateTime test = new MutableDateTime(TEST_TIME1, PARIS); DateTime result = test.toDateTimeISO(); assertSame(DateTime.class, result.getClass()); assertSame(ISOChronology.class, result.getChronology().getClass()); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISOChronology.getInstance(PARIS), result.getChronology()); } public void testToDateTime_DateTimeZone() { MutableDateTime test = new MutableDateTime(TEST_TIME1); MutableDateTime result = test.toMutableDateTime(LONDON); assertEquals(test.getMillis(), result.getMillis()); assertEquals(test.getChronology(), result.getChronology()); assertEquals(LONDON, result.getZone()); test = new MutableDateTime(TEST_TIME1); result = test.toMutableDateTime(PARIS); assertEquals(test.getMillis(), result.getMillis()); assertEquals(PARIS, result.getZone()); test = new MutableDateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS)); result = test.toMutableDateTime((DateTimeZone) null); assertEquals(test.getMillis(), result.getMillis()); assertEquals(GregorianChronology.getInstance(LONDON), result.getChronology()); test = new MutableDateTime(TEST_TIME1, PARIS); result = test.toMutableDateTime((DateTimeZone) null); assertEquals(test.getMillis(), result.getMillis()); assertEquals(LONDON, result.getZone()); test = new MutableDateTime(TEST_TIME1); result = test.toMutableDateTime((DateTimeZone) null); assertEquals(test.getMillis(), result.getMillis()); assertEquals(LONDON, result.getZone()); assertEquals(ISOChronology.getInstance(), result.getChronology()); } public void testToDateTime_Chronology() { MutableDateTime test = new MutableDateTime(TEST_TIME1); MutableDateTime result = test.toMutableDateTime(ISOChronology.getInstance()); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISOChronology.getInstance(), result.getChronology()); test = new MutableDateTime(TEST_TIME1); result = test.toMutableDateTime(GregorianChronology.getInstance(PARIS)); assertEquals(test.getMillis(), result.getMillis()); assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology()); test = new MutableDateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS)); result = test.toMutableDateTime((Chronology) null); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISOChronology.getInstance(), result.getChronology()); test = new MutableDateTime(TEST_TIME1); result = test.toMutableDateTime((Chronology) null); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISOChronology.getInstance(), result.getChronology()); } public void testToMutableDateTime() { MutableDateTime test = new MutableDateTime(TEST_TIME1, PARIS); MutableDateTime result = test.toMutableDateTime(); assertTrue(test != result); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISOChronology.getInstance(PARIS), result.getChronology()); } public void testToMutableDateTimeISO() { MutableDateTime test = new MutableDateTime(TEST_TIME1, PARIS); MutableDateTime result = test.toMutableDateTimeISO(); assertSame(MutableDateTime.class, result.getClass()); assertSame(ISOChronology.class, result.getChronology().getClass()); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISOChronology.getInstance(PARIS), result.getChronology()); assertNotSame(test, result); } public void testToMutableDateTime_DateTimeZone() { MutableDateTime test = new MutableDateTime(TEST_TIME1); MutableDateTime result = test.toMutableDateTime(LONDON); assertTrue(test != result); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISOChronology.getInstance(LONDON), result.getChronology()); test = new MutableDateTime(TEST_TIME1); result = test.toMutableDateTime(PARIS); assertTrue(test != result); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISOChronology.getInstance(PARIS), result.getChronology()); test = new MutableDateTime(TEST_TIME1, PARIS); result = test.toMutableDateTime((DateTimeZone) null); assertTrue(test != result); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISOChronology.getInstance(), result.getChronology()); test = new MutableDateTime(TEST_TIME1); result = test.toMutableDateTime((DateTimeZone) null); assertTrue(test != result); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISOChronology.getInstance(), result.getChronology()); } public void testToMutableDateTime_Chronology() { MutableDateTime test = new MutableDateTime(TEST_TIME1); MutableDateTime result = test.toMutableDateTime(ISOChronology.getInstance()); assertTrue(test != result); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISOChronology.getInstance(), result.getChronology()); test = new MutableDateTime(TEST_TIME1); result = test.toMutableDateTime(GregorianChronology.getInstance(PARIS)); assertTrue(test != result); assertEquals(test.getMillis(), result.getMillis()); assertEquals(GregorianChronology.getInstance(PARIS), result.getChronology()); test = new MutableDateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS)); result = test.toMutableDateTime((Chronology) null); assertTrue(test != result); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISOChronology.getInstance(), result.getChronology()); test = new MutableDateTime(TEST_TIME1); result = test.toMutableDateTime((Chronology) null); assertTrue(test != result); assertEquals(test.getMillis(), result.getMillis()); assertEquals(ISOChronology.getInstance(), result.getChronology()); } public void testToDate() { MutableDateTime test = new MutableDateTime(TEST_TIME1); Date result = test.toDate(); assertEquals(test.getMillis(), result.getTime()); } public void testToCalendar_Locale() { MutableDateTime test = new MutableDateTime(TEST_TIME1); Calendar result = test.toCalendar(null); assertEquals(test.getMillis(), result.getTime().getTime()); assertEquals(TimeZone.getTimeZone("Europe/London"), result.getTimeZone()); test = new MutableDateTime(TEST_TIME1, PARIS); result = test.toCalendar(null); assertEquals(test.getMillis(), result.getTime().getTime()); assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone()); test = new MutableDateTime(TEST_TIME1, PARIS); result = test.toCalendar(Locale.UK); assertEquals(test.getMillis(), result.getTime().getTime()); assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone()); } public void testToGregorianCalendar() { MutableDateTime test = new MutableDateTime(TEST_TIME1); GregorianCalendar result = test.toGregorianCalendar(); assertEquals(test.getMillis(), result.getTime().getTime()); assertEquals(TimeZone.getTimeZone("Europe/London"), result.getTimeZone()); test = new MutableDateTime(TEST_TIME1, PARIS); result = test.toGregorianCalendar(); assertEquals(test.getMillis(), result.getTime().getTime()); assertEquals(TimeZone.getTimeZone("Europe/Paris"), result.getTimeZone()); } public void testClone() { MutableDateTime test = new MutableDateTime(TEST_TIME1); MutableDateTime result = (MutableDateTime) test.clone(); assertEquals(true, test.equals(result)); assertEquals(true, test != result); } public void testCopy() { MutableDateTime test = new MutableDateTime(TEST_TIME1); MutableDateTime result = test.copy(); assertEquals(true, test.equals(result)); assertEquals(true, test != result); } public void testRounding1() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); test.setRounding(ISOChronology.getInstance().hourOfDay()); assertEquals("2002-06-09T05:00:00.000+01:00", test.toString()); assertEquals(MutableDateTime.ROUND_FLOOR, test.getRoundingMode()); assertEquals(ISOChronology.getInstance().hourOfDay(), test.getRoundingField()); } public void testRounding2() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_CEILING); assertEquals("2002-06-09T06:00:00.000+01:00", test.toString()); assertEquals(MutableDateTime.ROUND_CEILING, test.getRoundingMode()); assertEquals(ISOChronology.getInstance().hourOfDay(), test.getRoundingField()); } public void testRounding3() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_HALF_CEILING); assertEquals("2002-06-09T05:00:00.000+01:00", test.toString()); assertEquals(MutableDateTime.ROUND_HALF_CEILING, test.getRoundingMode()); assertEquals(ISOChronology.getInstance().hourOfDay(), test.getRoundingField()); test = new MutableDateTime(2002, 6, 9, 5, 30, 0, 0); test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_HALF_CEILING); assertEquals("2002-06-09T06:00:00.000+01:00", test.toString()); } public void testRounding4() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_HALF_FLOOR); assertEquals("2002-06-09T05:00:00.000+01:00", test.toString()); assertEquals(MutableDateTime.ROUND_HALF_FLOOR, test.getRoundingMode()); assertEquals(ISOChronology.getInstance().hourOfDay(), test.getRoundingField()); test = new MutableDateTime(2002, 6, 9, 5, 30, 0, 0); test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_HALF_FLOOR); assertEquals("2002-06-09T05:00:00.000+01:00", test.toString()); } public void testRounding5() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_HALF_EVEN); assertEquals("2002-06-09T05:00:00.000+01:00", test.toString()); assertEquals(MutableDateTime.ROUND_HALF_EVEN, test.getRoundingMode()); assertEquals(ISOChronology.getInstance().hourOfDay(), test.getRoundingField()); test = new MutableDateTime(2002, 6, 9, 5, 30, 0, 0); test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_HALF_EVEN); assertEquals("2002-06-09T06:00:00.000+01:00", test.toString()); test = new MutableDateTime(2002, 6, 9, 4, 30, 0, 0); test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_HALF_EVEN); assertEquals("2002-06-09T04:00:00.000+01:00", test.toString()); } public void testRounding6() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_NONE); assertEquals("2002-06-09T05:06:07.008+01:00", test.toString()); assertEquals(MutableDateTime.ROUND_NONE, test.getRoundingMode()); assertEquals(null, test.getRoundingField()); } public void testRounding7() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); try { test.setRounding(ISOChronology.getInstance().hourOfDay(), -1); fail(); } catch (IllegalArgumentException ex) {} } public void testRounding8() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); assertEquals(MutableDateTime.ROUND_NONE, test.getRoundingMode()); assertEquals(null, test.getRoundingField()); test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_CEILING); assertEquals(MutableDateTime.ROUND_CEILING, test.getRoundingMode()); assertEquals(ISOChronology.getInstance().hourOfDay(), test.getRoundingField()); test.setRounding(ISOChronology.getInstance().hourOfDay(), MutableDateTime.ROUND_NONE); assertEquals(MutableDateTime.ROUND_NONE, test.getRoundingMode()); assertEquals(null, test.getRoundingField()); test.setRounding(null, -1); assertEquals(MutableDateTime.ROUND_NONE, test.getRoundingMode()); assertEquals(null, test.getRoundingField()); test.setRounding(ISOChronology.getInstance().hourOfDay()); assertEquals(MutableDateTime.ROUND_FLOOR, test.getRoundingMode()); assertEquals(ISOChronology.getInstance().hourOfDay(), test.getRoundingField()); test.setRounding(null); assertEquals(MutableDateTime.ROUND_NONE, test.getRoundingMode()); assertEquals(null, test.getRoundingField()); } //----------------------------------------------------------------------- public void testProperty() { MutableDateTime test = new MutableDateTime(); assertEquals(test.year(), test.property(DateTimeFieldType.year())); assertEquals(test.dayOfWeek(), test.property(DateTimeFieldType.dayOfWeek())); assertEquals(test.secondOfMinute(), test.property(DateTimeFieldType.secondOfMinute())); assertEquals(test.millisOfSecond(), test.property(DateTimeFieldType.millisOfSecond())); DateTimeFieldType bad = new DateTimeFieldType("bad") { private static final long serialVersionUID = 1L; public DurationFieldType getDurationType() { return DurationFieldType.weeks(); } public DurationFieldType getRangeDurationType() { return null; } public DateTimeField getField(Chronology chronology) { return UnsupportedDateTimeField.getInstance(this, UnsupportedDurationField.getInstance(getDurationType())); } }; try { test.property(bad); fail(); } catch (IllegalArgumentException ex) {} try { test.property(null); fail(); } catch (IllegalArgumentException ex) {} } }
/* * Copyright 2001-2010 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.util.Date; import java.util.Locale; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.GregorianChronology; import org.joda.time.chrono.ISOChronology; import org.joda.time.convert.ConverterManager; import org.joda.time.convert.MockZeroNullIntegerConverter; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; /** * This class is a Junit unit test for MutableDateTime. * * @author Stephen Colebourne */ public class TestMutableDateTime_Constructors extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; // 2002-04-05 private long TEST_TIME1 = (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; // 2003-05-06 private long TEST_TIME2 = (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone zone = null; private Locale locale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestMutableDateTime_Constructors.class); } public TestMutableDateTime_Constructors(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); zone = DateTimeZone.getDefault(); locale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); java.util.TimeZone.setDefault(LONDON.toTimeZone()); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(zone); java.util.TimeZone.setDefault(zone.toTimeZone()); Locale.setDefault(locale); zone = null; } //----------------------------------------------------------------------- public void testTest() { assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString()); assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString()); assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString()); } //----------------------------------------------------------------------- /** * Test now () */ public void test_now() throws Throwable { MutableDateTime test = MutableDateTime.now(); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test now (DateTimeZone) */ public void test_now_DateTimeZone() throws Throwable { MutableDateTime test = MutableDateTime.now(PARIS); assertEquals(ISOChronology.getInstance(PARIS), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test now (DateTimeZone=null) */ public void test_now_nullDateTimeZone() throws Throwable { try { MutableDateTime.now((DateTimeZone) null); fail(); } catch (NullPointerException ex) {} } /** * Test now (Chronology) */ public void test_now_Chronology() throws Throwable { MutableDateTime test = MutableDateTime.now(GregorianChronology.getInstance()); assertEquals(GregorianChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test now (Chronology=null) */ public void test_now_nullChronology() throws Throwable { try { MutableDateTime.now((Chronology) null); fail(); } catch (NullPointerException ex) {} } //----------------------------------------------------------------------- public void testParse_noFormatter() throws Throwable { assertEquals(new MutableDateTime(2010, 6, 30, 1, 20, 0, 0, ISOChronology.getInstance(DateTimeZone.forOffsetHours(2))), MutableDateTime.parse("2010-06-30T01:20+02:00")); assertEquals(new MutableDateTime(2010, 1, 2, 14, 50, 0, 0, ISOChronology.getInstance(LONDON)), MutableDateTime.parse("2010-002T14:50")); } public void testParse_formatter() throws Throwable { DateTimeFormatter f = DateTimeFormat.forPattern("yyyy--dd MM HH").withChronology(ISOChronology.getInstance(PARIS)); assertEquals(new MutableDateTime(2010, 6, 30, 13, 0, 0, 0, ISOChronology.getInstance(PARIS)), MutableDateTime.parse("2010--30 06 13", f)); } //----------------------------------------------------------------------- /** * Test constructor () */ public void testConstructor() throws Throwable { MutableDateTime test = new MutableDateTime(); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test constructor (DateTimeZone) */ public void testConstructor_DateTimeZone() throws Throwable { MutableDateTime test = new MutableDateTime(PARIS); assertEquals(ISOChronology.getInstance(PARIS), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test constructor (DateTimeZone=null) */ public void testConstructor_nullDateTimeZone() throws Throwable { MutableDateTime test = new MutableDateTime((DateTimeZone) null); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test constructor (Chronology) */ public void testConstructor_Chronology() throws Throwable { MutableDateTime test = new MutableDateTime(GregorianChronology.getInstance()); assertEquals(GregorianChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test constructor (Chronology=null) */ public void testConstructor_nullChronology() throws Throwable { MutableDateTime test = new MutableDateTime((Chronology) null); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } //----------------------------------------------------------------------- /** * Test constructor (long) */ public void testConstructor_long1() throws Throwable { MutableDateTime test = new MutableDateTime(TEST_TIME1); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME1, test.getMillis()); } /** * Test constructor (long) */ public void testConstructor_long2() throws Throwable { MutableDateTime test = new MutableDateTime(TEST_TIME2); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME2, test.getMillis()); } /** * Test constructor (long, DateTimeZone) */ public void testConstructor_long1_DateTimeZone() throws Throwable { MutableDateTime test = new MutableDateTime(TEST_TIME1, PARIS); assertEquals(ISOChronology.getInstance(PARIS), test.getChronology()); assertEquals(TEST_TIME1, test.getMillis()); } /** * Test constructor (long, DateTimeZone) */ public void testConstructor_long2_DateTimeZone() throws Throwable { MutableDateTime test = new MutableDateTime(TEST_TIME2, PARIS); assertEquals(ISOChronology.getInstance(PARIS), test.getChronology()); assertEquals(TEST_TIME2, test.getMillis()); } /** * Test constructor (long, DateTimeZone=null) */ public void testConstructor_long_nullDateTimeZone() throws Throwable { MutableDateTime test = new MutableDateTime(TEST_TIME1, (DateTimeZone) null); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME1, test.getMillis()); } /** * Test constructor (long, Chronology) */ public void testConstructor_long1_Chronology() throws Throwable { MutableDateTime test = new MutableDateTime(TEST_TIME1, GregorianChronology.getInstance()); assertEquals(GregorianChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME1, test.getMillis()); } /** * Test constructor (long, Chronology) */ public void testConstructor_long2_Chronology() throws Throwable { MutableDateTime test = new MutableDateTime(TEST_TIME2, GregorianChronology.getInstance()); assertEquals(GregorianChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME2, test.getMillis()); } /** * Test constructor (long, Chronology=null) */ public void testConstructor_long_nullChronology() throws Throwable { MutableDateTime test = new MutableDateTime(TEST_TIME1, (Chronology) null); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME1, test.getMillis()); } //----------------------------------------------------------------------- /** * Test constructor (Object) */ public void testConstructor_Object() throws Throwable { Date date = new Date(TEST_TIME1); MutableDateTime test = new MutableDateTime(date); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME1, test.getMillis()); } /** * Test constructor (Object) */ public void testConstructor_invalidObject() throws Throwable { try { new MutableDateTime(new Object()); fail(); } catch (IllegalArgumentException ex) {} } /** * Test constructor (Object=null) */ public void testConstructor_nullObject() throws Throwable { MutableDateTime test = new MutableDateTime((Object) null); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test constructor (Object=null) */ public void testConstructor_badconverterObject() throws Throwable { try { ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE); MutableDateTime test = new MutableDateTime(new Integer(0)); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(0L, test.getMillis()); } finally { ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE); } } /** * Test constructor (Object, DateTimeZone) */ public void testConstructor_Object_DateTimeZone() throws Throwable { Date date = new Date(TEST_TIME1); MutableDateTime test = new MutableDateTime(date, PARIS); assertEquals(ISOChronology.getInstance(PARIS), test.getChronology()); assertEquals(TEST_TIME1, test.getMillis()); } /** * Test constructor (Object, DateTimeZone) */ public void testConstructor_invalidObject_DateTimeZone() throws Throwable { try { new MutableDateTime(new Object(), PARIS); fail(); } catch (IllegalArgumentException ex) {} } /** * Test constructor (Object=null, DateTimeZone) */ public void testConstructor_nullObject_DateTimeZone() throws Throwable { MutableDateTime test = new MutableDateTime((Object) null, PARIS); assertEquals(ISOChronology.getInstance(PARIS), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test constructor (Object, DateTimeZone=null) */ public void testConstructor_Object_nullDateTimeZone() throws Throwable { Date date = new Date(TEST_TIME1); MutableDateTime test = new MutableDateTime(date, (DateTimeZone) null); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME1, test.getMillis()); } /** * Test constructor (Object=null, DateTimeZone=null) */ public void testConstructor_nullObject_nullDateTimeZone() throws Throwable { MutableDateTime test = new MutableDateTime((Object) null, (DateTimeZone) null); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test constructor (Object, DateTimeZone) */ public void testConstructor_badconverterObject_DateTimeZone() throws Throwable { try { ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE); MutableDateTime test = new MutableDateTime(new Integer(0), GregorianChronology.getInstance()); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(0L, test.getMillis()); } finally { ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE); } } /** * Test constructor (Object, Chronology) */ public void testConstructor_Object_Chronology() throws Throwable { Date date = new Date(TEST_TIME1); MutableDateTime test = new MutableDateTime(date, GregorianChronology.getInstance()); assertEquals(GregorianChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME1, test.getMillis()); } /** * Test constructor (Object, Chronology) */ public void testConstructor_invalidObject_Chronology() throws Throwable { try { new MutableDateTime(new Object(), GregorianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} } /** * Test constructor (Object=null, Chronology) */ public void testConstructor_nullObject_Chronology() throws Throwable { MutableDateTime test = new MutableDateTime((Object) null, GregorianChronology.getInstance()); assertEquals(GregorianChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test constructor (Object, Chronology=null) */ public void testConstructor_Object_nullChronology() throws Throwable { Date date = new Date(TEST_TIME1); MutableDateTime test = new MutableDateTime(date, (Chronology) null); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME1, test.getMillis()); } /** * Test constructor (Object=null, Chronology=null) */ public void testConstructor_nullObject_nullChronology() throws Throwable { MutableDateTime test = new MutableDateTime((Object) null, (Chronology) null); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test constructor (Object, Chronology) */ public void testConstructor_badconverterObject_Chronology() throws Throwable { try { ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE); MutableDateTime test = new MutableDateTime(new Integer(0), GregorianChronology.getInstance()); assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(0L, test.getMillis()); } finally { ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE); } } //----------------------------------------------------------------------- /** * Test constructor (int, int, int) */ public void testConstructor_int_int_int_int_int_int_int() throws Throwable { MutableDateTime test = new MutableDateTime(2002, 6, 9, 1, 0, 0, 0); // +01:00 assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(LONDON, test.getZone()); assertEquals(TEST_TIME_NOW, test.getMillis()); try { new MutableDateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0); fail(); } catch (IllegalArgumentException ex) {} try { new MutableDateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0); fail(); } catch (IllegalArgumentException ex) {} try { new MutableDateTime(2002, 0, 9, 0, 0, 0, 0); fail(); } catch (IllegalArgumentException ex) {} try { new MutableDateTime(2002, 13, 9, 0, 0, 0, 0); fail(); } catch (IllegalArgumentException ex) {} try { new MutableDateTime(2002, 6, 0, 0, 0, 0, 0); fail(); } catch (IllegalArgumentException ex) {} try { new MutableDateTime(2002, 6, 31, 0, 0, 0, 0); fail(); } catch (IllegalArgumentException ex) {} new MutableDateTime(2002, 7, 31, 0, 0, 0, 0); try { new MutableDateTime(2002, 7, 32, 0, 0, 0, 0); fail(); } catch (IllegalArgumentException ex) {} } /** * Test constructor (int, int, int, DateTimeZone) */ public void testConstructor_int_int_int_int_int_int_int_DateTimeZone() throws Throwable { MutableDateTime test = new MutableDateTime(2002, 6, 9, 2, 0, 0, 0, PARIS); // +02:00 assertEquals(ISOChronology.getInstance(PARIS), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); try { new MutableDateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0, PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new MutableDateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0, PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new MutableDateTime(2002, 0, 9, 0, 0, 0, 0, PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new MutableDateTime(2002, 13, 9, 0, 0, 0, 0, PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new MutableDateTime(2002, 6, 0, 0, 0, 0, 0, PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new MutableDateTime(2002, 6, 31, 0, 0, 0, 0, PARIS); fail(); } catch (IllegalArgumentException ex) {} new MutableDateTime(2002, 7, 31, 0, 0, 0, 0, PARIS); try { new MutableDateTime(2002, 7, 32, 0, 0, 0, 0, PARIS); fail(); } catch (IllegalArgumentException ex) {} } /** * Test constructor (int, int, int, DateTimeZone=null) */ public void testConstructor_int_int_int_int_int_int_int_nullDateTimeZone() throws Throwable { MutableDateTime test = new MutableDateTime(2002, 6, 9, 1, 0, 0, 0, (DateTimeZone) null); // +01:00 assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } /** * Test constructor (int, int, int, Chronology) */ public void testConstructor_int_int_int_int_int_int_int_Chronology() throws Throwable { MutableDateTime test = new MutableDateTime(2002, 6, 9, 1, 0, 0, 0, GregorianChronology.getInstance()); // +01:00 assertEquals(GregorianChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); try { new MutableDateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0, GregorianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} try { new MutableDateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0, GregorianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} try { new MutableDateTime(2002, 0, 9, 0, 0, 0, 0, GregorianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} try { new MutableDateTime(2002, 13, 9, 0, 0, 0, 0, GregorianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} try { new MutableDateTime(2002, 6, 0, 0, 0, 0, 0, GregorianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} try { new MutableDateTime(2002, 6, 31, 0, 0, 0, 0, GregorianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} new MutableDateTime(2002, 7, 31, 0, 0, 0, 0, GregorianChronology.getInstance()); try { new MutableDateTime(2002, 7, 32, 0, 0, 0, 0, GregorianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} } /** * Test constructor (int, int, int, Chronology=null) */ public void testConstructor_int_int_int_int_int_int_int_nullChronology() throws Throwable { MutableDateTime test = new MutableDateTime(2002, 6, 9, 1, 0, 0, 0, (Chronology) null); // +01:00 assertEquals(ISOChronology.getInstance(), test.getChronology()); assertEquals(TEST_TIME_NOW, test.getMillis()); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.util.Locale; import junit.framework.TestCase; import junit.framework.TestSuite; /** * This class is a Junit unit test for DateTime. * * @author Stephen Colebourne * @author Mike Schrag */ public class TestMutableDateTime_Properties extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) //private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; // 2002-04-05 Fri private long TEST_TIME1 = (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; // 2003-05-06 Tue private long TEST_TIME2 = (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone zone = null; private Locale locale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestMutableDateTime_Properties.class); } public TestMutableDateTime_Properties(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); zone = DateTimeZone.getDefault(); locale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(zone); Locale.setDefault(locale); zone = null; } //----------------------------------------------------------------------- public void testTest() { assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString()); assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString()); assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString()); } //----------------------------------------------------------------------- public void testPropertyGetEra() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); assertSame(test.getChronology().era(), test.era().getField()); assertEquals("era", test.era().getName()); assertEquals("Property[era]", test.era().toString()); assertSame(test, test.era().getMutableDateTime()); assertEquals(1, test.era().get()); assertEquals("AD", test.era().getAsText()); assertEquals("ap. J.-C.", test.era().getAsText(Locale.FRENCH)); assertEquals("AD", test.era().getAsShortText()); assertEquals("ap. J.-C.", test.era().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().eras(), test.era().getDurationField()); assertEquals(null, test.era().getRangeDurationField()); assertEquals(2, test.era().getMaximumTextLength(null)); assertEquals(9, test.era().getMaximumTextLength(Locale.FRENCH)); assertEquals(2, test.era().getMaximumShortTextLength(null)); assertEquals(9, test.era().getMaximumShortTextLength(Locale.FRENCH)); } //----------------------------------------------------------------------- public void testPropertyGetYearOfEra() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); assertSame(test.getChronology().yearOfEra(), test.yearOfEra().getField()); assertEquals("yearOfEra", test.yearOfEra().getName()); assertEquals("Property[yearOfEra]", test.yearOfEra().toString()); assertEquals(2004, test.yearOfEra().get()); assertEquals("2004", test.yearOfEra().getAsText()); assertEquals("2004", test.yearOfEra().getAsText(Locale.FRENCH)); assertEquals("2004", test.yearOfEra().getAsShortText()); assertEquals("2004", test.yearOfEra().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().years(), test.yearOfEra().getDurationField()); assertEquals(test.getChronology().eras(), test.yearOfEra().getRangeDurationField()); assertEquals(9, test.yearOfEra().getMaximumTextLength(null)); assertEquals(9, test.yearOfEra().getMaximumShortTextLength(null)); } //----------------------------------------------------------------------- public void testPropertyGetCenturyOfEra() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); assertSame(test.getChronology().centuryOfEra(), test.centuryOfEra().getField()); assertEquals("centuryOfEra", test.centuryOfEra().getName()); assertEquals("Property[centuryOfEra]", test.centuryOfEra().toString()); assertEquals(20, test.centuryOfEra().get()); assertEquals("20", test.centuryOfEra().getAsText()); assertEquals("20", test.centuryOfEra().getAsText(Locale.FRENCH)); assertEquals("20", test.centuryOfEra().getAsShortText()); assertEquals("20", test.centuryOfEra().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().centuries(), test.centuryOfEra().getDurationField()); assertEquals(test.getChronology().eras(), test.centuryOfEra().getRangeDurationField()); assertEquals(7, test.centuryOfEra().getMaximumTextLength(null)); assertEquals(7, test.centuryOfEra().getMaximumShortTextLength(null)); } //----------------------------------------------------------------------- public void testPropertyGetYearOfCentury() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); assertSame(test.getChronology().yearOfCentury(), test.yearOfCentury().getField()); assertEquals("yearOfCentury", test.yearOfCentury().getName()); assertEquals("Property[yearOfCentury]", test.yearOfCentury().toString()); assertEquals(4, test.yearOfCentury().get()); assertEquals("4", test.yearOfCentury().getAsText()); assertEquals("4", test.yearOfCentury().getAsText(Locale.FRENCH)); assertEquals("4", test.yearOfCentury().getAsShortText()); assertEquals("4", test.yearOfCentury().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().years(), test.yearOfCentury().getDurationField()); assertEquals(test.getChronology().centuries(), test.yearOfCentury().getRangeDurationField()); assertEquals(2, test.yearOfCentury().getMaximumTextLength(null)); assertEquals(2, test.yearOfCentury().getMaximumShortTextLength(null)); } //----------------------------------------------------------------------- public void testPropertyGetWeekyear() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); assertSame(test.getChronology().weekyear(), test.weekyear().getField()); assertEquals("weekyear", test.weekyear().getName()); assertEquals("Property[weekyear]", test.weekyear().toString()); assertEquals(2004, test.weekyear().get()); assertEquals("2004", test.weekyear().getAsText()); assertEquals("2004", test.weekyear().getAsText(Locale.FRENCH)); assertEquals("2004", test.weekyear().getAsShortText()); assertEquals("2004", test.weekyear().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().weekyears(), test.weekyear().getDurationField()); assertEquals(null, test.weekyear().getRangeDurationField()); assertEquals(9, test.weekyear().getMaximumTextLength(null)); assertEquals(9, test.weekyear().getMaximumShortTextLength(null)); } //----------------------------------------------------------------------- public void testPropertyGetYear() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); assertSame(test.getChronology().year(), test.year().getField()); assertEquals("year", test.year().getName()); assertEquals("Property[year]", test.year().toString()); assertEquals(2004, test.year().get()); assertEquals("2004", test.year().getAsText()); assertEquals("2004", test.year().getAsText(Locale.FRENCH)); assertEquals("2004", test.year().getAsShortText()); assertEquals("2004", test.year().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().years(), test.year().getDurationField()); assertEquals(null, test.year().getRangeDurationField()); assertEquals(9, test.year().getMaximumTextLength(null)); assertEquals(9, test.year().getMaximumShortTextLength(null)); assertEquals(-292275054, test.year().getMinimumValue()); assertEquals(-292275054, test.year().getMinimumValueOverall()); assertEquals(292278993, test.year().getMaximumValue()); assertEquals(292278993, test.year().getMaximumValueOverall()); } public void testPropertyAddYear() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); test.year().add(9); assertEquals("2013-06-09T00:00:00.000+01:00", test.toString()); } public void testPropertyAddWrapFieldYear() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); test.year().addWrapField(9); assertEquals("2013-06-09T00:00:00.000+01:00", test.toString()); } public void testPropertySetYear() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); test.year().set(1960); assertEquals("1960-06-09T00:00:00.000+01:00", test.toString()); } public void testPropertySetTextYear() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); test.year().set("1960"); assertEquals("1960-06-09T00:00:00.000+01:00", test.toString()); } //----------------------------------------------------------------------- public void testPropertyGetMonthOfYear() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField()); assertEquals("monthOfYear", test.monthOfYear().getName()); assertEquals("Property[monthOfYear]", test.monthOfYear().toString()); assertEquals(6, test.monthOfYear().get()); assertEquals("June", test.monthOfYear().getAsText()); assertEquals("juin", test.monthOfYear().getAsText(Locale.FRENCH)); assertEquals("Jun", test.monthOfYear().getAsShortText()); assertEquals("juin", test.monthOfYear().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField()); assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField()); assertEquals(9, test.monthOfYear().getMaximumTextLength(null)); assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null)); test = new MutableDateTime(2004, 7, 9, 0, 0, 0, 0); assertEquals("juillet", test.monthOfYear().getAsText(Locale.FRENCH)); assertEquals("juil.", test.monthOfYear().getAsShortText(Locale.FRENCH)); assertEquals(1, test.monthOfYear().getMinimumValue()); assertEquals(1, test.monthOfYear().getMinimumValueOverall()); assertEquals(12, test.monthOfYear().getMaximumValue()); assertEquals(12, test.monthOfYear().getMaximumValueOverall()); assertEquals(1, test.monthOfYear().getMinimumValue()); assertEquals(1, test.monthOfYear().getMinimumValueOverall()); assertEquals(12, test.monthOfYear().getMaximumValue()); assertEquals(12, test.monthOfYear().getMaximumValueOverall()); } public void testPropertyAddMonthOfYear() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); test.monthOfYear().add(6); assertEquals("2004-12-09T00:00:00.000Z", test.toString()); } public void testPropertyAddWrapFieldMonthOfYear() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); test.monthOfYear().addWrapField(8); assertEquals("2004-02-09T00:00:00.000Z", test.toString()); } public void testPropertySetMonthOfYear() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); test.monthOfYear().set(12); assertEquals("2004-12-09T00:00:00.000Z", test.toString()); } public void testPropertySetTextMonthOfYear() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); test.monthOfYear().set("12"); assertEquals("2004-12-09T00:00:00.000Z", test.toString()); test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); test.monthOfYear().set("December"); assertEquals("2004-12-09T00:00:00.000Z", test.toString()); test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); test.monthOfYear().set("Dec"); assertEquals("2004-12-09T00:00:00.000Z", test.toString()); } //----------------------------------------------------------------------- public void testPropertyGetDayOfMonth() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField()); assertEquals("dayOfMonth", test.dayOfMonth().getName()); assertEquals("Property[dayOfMonth]", test.dayOfMonth().toString()); assertEquals(9, test.dayOfMonth().get()); assertEquals("9", test.dayOfMonth().getAsText()); assertEquals("9", test.dayOfMonth().getAsText(Locale.FRENCH)); assertEquals("9", test.dayOfMonth().getAsShortText()); assertEquals("9", test.dayOfMonth().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField()); assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField()); assertEquals(2, test.dayOfMonth().getMaximumTextLength(null)); assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null)); assertEquals(1, test.dayOfMonth().getMinimumValue()); assertEquals(1, test.dayOfMonth().getMinimumValueOverall()); assertEquals(30, test.dayOfMonth().getMaximumValue()); assertEquals(31, test.dayOfMonth().getMaximumValueOverall()); assertEquals(false, test.dayOfMonth().isLeap()); assertEquals(0, test.dayOfMonth().getLeapAmount()); assertEquals(null, test.dayOfMonth().getLeapDurationField()); } public void testPropertyAddDayOfMonth() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); test.dayOfMonth().add(9); assertEquals("2004-06-18T00:00:00.000+01:00", test.toString()); } public void testPropertyAddWrapFieldDayOfMonth() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); test.dayOfMonth().addWrapField(22); assertEquals("2004-06-01T00:00:00.000+01:00", test.toString()); } public void testPropertySetDayOfMonth() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); test.dayOfMonth().set(12); assertEquals("2004-06-12T00:00:00.000+01:00", test.toString()); } public void testPropertySetTextDayOfMonth() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); test.dayOfMonth().set("12"); assertEquals("2004-06-12T00:00:00.000+01:00", test.toString()); } //----------------------------------------------------------------------- public void testPropertyGetDayOfYear() { // 31+29+31+30+31+9 = 161 MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); assertSame(test.getChronology().dayOfYear(), test.dayOfYear().getField()); assertEquals("dayOfYear", test.dayOfYear().getName()); assertEquals("Property[dayOfYear]", test.dayOfYear().toString()); assertEquals(161, test.dayOfYear().get()); assertEquals("161", test.dayOfYear().getAsText()); assertEquals("161", test.dayOfYear().getAsText(Locale.FRENCH)); assertEquals("161", test.dayOfYear().getAsShortText()); assertEquals("161", test.dayOfYear().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().days(), test.dayOfYear().getDurationField()); assertEquals(test.getChronology().years(), test.dayOfYear().getRangeDurationField()); assertEquals(3, test.dayOfYear().getMaximumTextLength(null)); assertEquals(3, test.dayOfYear().getMaximumShortTextLength(null)); assertEquals(false, test.dayOfYear().isLeap()); assertEquals(0, test.dayOfYear().getLeapAmount()); assertEquals(null, test.dayOfYear().getLeapDurationField()); } public void testPropertyAddDayOfYear() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); test.dayOfYear().add(9); assertEquals("2004-06-18T00:00:00.000+01:00", test.toString()); } public void testPropertyAddWrapFieldDayOfYear() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); test.dayOfYear().addWrapField(206); assertEquals("2004-01-01T00:00:00.000Z", test.toString()); } public void testPropertySetDayOfYear() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); test.dayOfYear().set(12); assertEquals("2004-01-12T00:00:00.000Z", test.toString()); } public void testPropertySetTextDayOfYear() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); test.dayOfYear().set("12"); assertEquals("2004-01-12T00:00:00.000Z", test.toString()); } //----------------------------------------------------------------------- public void testPropertyGetWeekOfWeekyear() { // 2002-01-01 = Thu // 2002-12-31 = Thu (+364 days) // 2003-12-30 = Thu (+364 days) // 2004-01-03 = Mon W1 // 2004-01-31 = Mon (+28 days) W5 // 2004-02-28 = Mon (+28 days) W9 // 2004-03-27 = Mon (+28 days) W13 // 2004-04-24 = Mon (+28 days) W17 // 2004-05-23 = Mon (+28 days) W21 // 2004-06-05 = Mon (+14 days) W23 // 2004-06-09 = Fri // 2004-12-25 = Mon W52 // 2005-01-01 = Mon W1 MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); assertSame(test.getChronology().weekOfWeekyear(), test.weekOfWeekyear().getField()); assertEquals("weekOfWeekyear", test.weekOfWeekyear().getName()); assertEquals("Property[weekOfWeekyear]", test.weekOfWeekyear().toString()); assertEquals(24, test.weekOfWeekyear().get()); assertEquals("24", test.weekOfWeekyear().getAsText()); assertEquals("24", test.weekOfWeekyear().getAsText(Locale.FRENCH)); assertEquals("24", test.weekOfWeekyear().getAsShortText()); assertEquals("24", test.weekOfWeekyear().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().weeks(), test.weekOfWeekyear().getDurationField()); assertEquals(test.getChronology().weekyears(), test.weekOfWeekyear().getRangeDurationField()); assertEquals(2, test.weekOfWeekyear().getMaximumTextLength(null)); assertEquals(2, test.weekOfWeekyear().getMaximumShortTextLength(null)); assertEquals(false, test.weekOfWeekyear().isLeap()); assertEquals(0, test.weekOfWeekyear().getLeapAmount()); assertEquals(null, test.weekOfWeekyear().getLeapDurationField()); } public void testPropertyAddWeekOfWeekyear() { MutableDateTime test = new MutableDateTime(2004, 6, 7, 0, 0, 0, 0); test.weekOfWeekyear().add(1); assertEquals("2004-06-14T00:00:00.000+01:00", test.toString()); } public void testPropertyAddWrapFieldWeekOfWeekyear() { MutableDateTime test = new MutableDateTime(2004, 6, 7, 0, 0, 0, 0); test.weekOfWeekyear().addWrapField(30); assertEquals("2003-12-29T00:00:00.000Z", test.toString()); } public void testPropertySetWeekOfWeekyear() { MutableDateTime test = new MutableDateTime(2004, 6, 7, 0, 0, 0, 0); test.weekOfWeekyear().set(4); assertEquals("2004-01-19T00:00:00.000Z", test.toString()); } public void testPropertySetTextWeekOfWeekyear() { MutableDateTime test = new MutableDateTime(2004, 6, 7, 0, 0, 0, 0); test.weekOfWeekyear().set("4"); assertEquals("2004-01-19T00:00:00.000Z", test.toString()); } //----------------------------------------------------------------------- public void testPropertyGetDayOfWeek() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); assertSame(test.getChronology().dayOfWeek(), test.dayOfWeek().getField()); assertEquals("dayOfWeek", test.dayOfWeek().getName()); assertEquals("Property[dayOfWeek]", test.dayOfWeek().toString()); assertEquals(3, test.dayOfWeek().get()); assertEquals("Wednesday", test.dayOfWeek().getAsText()); assertEquals("mercredi", test.dayOfWeek().getAsText(Locale.FRENCH)); assertEquals("Wed", test.dayOfWeek().getAsShortText()); assertEquals("mer.", test.dayOfWeek().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().days(), test.dayOfWeek().getDurationField()); assertEquals(test.getChronology().weeks(), test.dayOfWeek().getRangeDurationField()); assertEquals(9, test.dayOfWeek().getMaximumTextLength(null)); assertEquals(8, test.dayOfWeek().getMaximumTextLength(Locale.FRENCH)); assertEquals(3, test.dayOfWeek().getMaximumShortTextLength(null)); assertEquals(4, test.dayOfWeek().getMaximumShortTextLength(Locale.FRENCH)); assertEquals(1, test.dayOfWeek().getMinimumValue()); assertEquals(1, test.dayOfWeek().getMinimumValueOverall()); assertEquals(7, test.dayOfWeek().getMaximumValue()); assertEquals(7, test.dayOfWeek().getMaximumValueOverall()); assertEquals(false, test.dayOfWeek().isLeap()); assertEquals(0, test.dayOfWeek().getLeapAmount()); assertEquals(null, test.dayOfWeek().getLeapDurationField()); } public void testPropertyAddDayOfWeek() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); test.dayOfWeek().add(1); assertEquals("2004-06-10T00:00:00.000+01:00", test.toString()); } public void testPropertyAddLongDayOfWeek() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); test.dayOfWeek().add(1L); assertEquals("2004-06-10T00:00:00.000+01:00", test.toString()); } public void testPropertyAddWrapFieldDayOfWeek() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); // Wed test.dayOfWeek().addWrapField(5); assertEquals("2004-06-07T00:00:00.000+01:00", test.toString()); } public void testPropertySetDayOfWeek() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); test.dayOfWeek().set(4); assertEquals("2004-06-10T00:00:00.000+01:00", test.toString()); } public void testPropertySetTextDayOfWeek() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); test.dayOfWeek().set("4"); assertEquals("2004-06-10T00:00:00.000+01:00", test.toString()); test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); test.dayOfWeek().set("Mon"); assertEquals("2004-06-07T00:00:00.000+01:00", test.toString()); test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); test.dayOfWeek().set("Tuesday"); assertEquals("2004-06-08T00:00:00.000+01:00", test.toString()); test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0); test.dayOfWeek().set("lundi", Locale.FRENCH); assertEquals("2004-06-07T00:00:00.000+01:00", test.toString()); } //----------------------------------------------------------------------- public void testPropertyGetHourOfDay() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53); assertSame(test.getChronology().hourOfDay(), test.hourOfDay().getField()); assertEquals("hourOfDay", test.hourOfDay().getName()); assertEquals("Property[hourOfDay]", test.hourOfDay().toString()); assertEquals(13, test.hourOfDay().get()); assertEquals("13", test.hourOfDay().getAsText()); assertEquals("13", test.hourOfDay().getAsText(Locale.FRENCH)); assertEquals("13", test.hourOfDay().getAsShortText()); assertEquals("13", test.hourOfDay().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().hours(), test.hourOfDay().getDurationField()); assertEquals(test.getChronology().days(), test.hourOfDay().getRangeDurationField()); assertEquals(2, test.hourOfDay().getMaximumTextLength(null)); assertEquals(2, test.hourOfDay().getMaximumShortTextLength(null)); } public void testPropertyRoundFloorHourOfDay() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 0); test.hourOfDay().roundFloor(); assertEquals("2004-06-09T13:00:00.000+01:00", test.toString()); } public void testPropertyRoundCeilingHourOfDay() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 0); test.hourOfDay().roundCeiling(); assertEquals("2004-06-09T14:00:00.000+01:00", test.toString()); } public void testPropertyRoundHalfFloorHourOfDay() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 0); test.hourOfDay().roundHalfFloor(); assertEquals("2004-06-09T13:00:00.000+01:00", test.toString()); test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 1); test.hourOfDay().roundHalfFloor(); assertEquals("2004-06-09T14:00:00.000+01:00", test.toString()); test = new MutableDateTime(2004, 6, 9, 13, 29, 59, 999); test.hourOfDay().roundHalfFloor(); assertEquals("2004-06-09T13:00:00.000+01:00", test.toString()); } public void testPropertyRoundHalfCeilingHourOfDay() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 0); test.hourOfDay().roundHalfCeiling(); assertEquals("2004-06-09T14:00:00.000+01:00", test.toString()); test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 1); test.hourOfDay().roundHalfCeiling(); assertEquals("2004-06-09T14:00:00.000+01:00", test.toString()); test = new MutableDateTime(2004, 6, 9, 13, 29, 59, 999); test.hourOfDay().roundHalfCeiling(); assertEquals("2004-06-09T13:00:00.000+01:00", test.toString()); } public void testPropertyRoundHalfEvenHourOfDay() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 0); test.hourOfDay().roundHalfEven(); assertEquals("2004-06-09T14:00:00.000+01:00", test.toString()); test = new MutableDateTime(2004, 6, 9, 14, 30, 0, 0); test.hourOfDay().roundHalfEven(); assertEquals("2004-06-09T14:00:00.000+01:00", test.toString()); test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 1); test.hourOfDay().roundHalfEven(); assertEquals("2004-06-09T14:00:00.000+01:00", test.toString()); test = new MutableDateTime(2004, 6, 9, 13, 29, 59, 999); test.hourOfDay().roundHalfEven(); assertEquals("2004-06-09T13:00:00.000+01:00", test.toString()); } public void testPropertyRemainderHourOfDay() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 30, 0, 0); assertEquals(30L * DateTimeConstants.MILLIS_PER_MINUTE, test.hourOfDay().remainder()); } //----------------------------------------------------------------------- public void testPropertyGetMinuteOfHour() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53); assertSame(test.getChronology().minuteOfHour(), test.minuteOfHour().getField()); assertEquals("minuteOfHour", test.minuteOfHour().getName()); assertEquals("Property[minuteOfHour]", test.minuteOfHour().toString()); assertEquals(23, test.minuteOfHour().get()); assertEquals("23", test.minuteOfHour().getAsText()); assertEquals("23", test.minuteOfHour().getAsText(Locale.FRENCH)); assertEquals("23", test.minuteOfHour().getAsShortText()); assertEquals("23", test.minuteOfHour().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().minutes(), test.minuteOfHour().getDurationField()); assertEquals(test.getChronology().hours(), test.minuteOfHour().getRangeDurationField()); assertEquals(2, test.minuteOfHour().getMaximumTextLength(null)); assertEquals(2, test.minuteOfHour().getMaximumShortTextLength(null)); } //----------------------------------------------------------------------- public void testPropertyGetMinuteOfDay() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53); assertSame(test.getChronology().minuteOfDay(), test.minuteOfDay().getField()); assertEquals("minuteOfDay", test.minuteOfDay().getName()); assertEquals("Property[minuteOfDay]", test.minuteOfDay().toString()); assertEquals(803, test.minuteOfDay().get()); assertEquals("803", test.minuteOfDay().getAsText()); assertEquals("803", test.minuteOfDay().getAsText(Locale.FRENCH)); assertEquals("803", test.minuteOfDay().getAsShortText()); assertEquals("803", test.minuteOfDay().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().minutes(), test.minuteOfDay().getDurationField()); assertEquals(test.getChronology().days(), test.minuteOfDay().getRangeDurationField()); assertEquals(4, test.minuteOfDay().getMaximumTextLength(null)); assertEquals(4, test.minuteOfDay().getMaximumShortTextLength(null)); } //----------------------------------------------------------------------- public void testPropertyGetSecondOfMinute() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53); assertSame(test.getChronology().secondOfMinute(), test.secondOfMinute().getField()); assertEquals("secondOfMinute", test.secondOfMinute().getName()); assertEquals("Property[secondOfMinute]", test.secondOfMinute().toString()); assertEquals(43, test.secondOfMinute().get()); assertEquals("43", test.secondOfMinute().getAsText()); assertEquals("43", test.secondOfMinute().getAsText(Locale.FRENCH)); assertEquals("43", test.secondOfMinute().getAsShortText()); assertEquals("43", test.secondOfMinute().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().seconds(), test.secondOfMinute().getDurationField()); assertEquals(test.getChronology().minutes(), test.secondOfMinute().getRangeDurationField()); assertEquals(2, test.secondOfMinute().getMaximumTextLength(null)); assertEquals(2, test.secondOfMinute().getMaximumShortTextLength(null)); } //----------------------------------------------------------------------- public void testPropertyGetSecondOfDay() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53); assertSame(test.getChronology().secondOfDay(), test.secondOfDay().getField()); assertEquals("secondOfDay", test.secondOfDay().getName()); assertEquals("Property[secondOfDay]", test.secondOfDay().toString()); assertEquals(48223, test.secondOfDay().get()); assertEquals("48223", test.secondOfDay().getAsText()); assertEquals("48223", test.secondOfDay().getAsText(Locale.FRENCH)); assertEquals("48223", test.secondOfDay().getAsShortText()); assertEquals("48223", test.secondOfDay().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().seconds(), test.secondOfDay().getDurationField()); assertEquals(test.getChronology().days(), test.secondOfDay().getRangeDurationField()); assertEquals(5, test.secondOfDay().getMaximumTextLength(null)); assertEquals(5, test.secondOfDay().getMaximumShortTextLength(null)); } //----------------------------------------------------------------------- public void testPropertyGetMillisOfSecond() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53); assertSame(test.getChronology().millisOfSecond(), test.millisOfSecond().getField()); assertEquals("millisOfSecond", test.millisOfSecond().getName()); assertEquals("Property[millisOfSecond]", test.millisOfSecond().toString()); assertEquals(53, test.millisOfSecond().get()); assertEquals("53", test.millisOfSecond().getAsText()); assertEquals("53", test.millisOfSecond().getAsText(Locale.FRENCH)); assertEquals("53", test.millisOfSecond().getAsShortText()); assertEquals("53", test.millisOfSecond().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().millis(), test.millisOfSecond().getDurationField()); assertEquals(test.getChronology().seconds(), test.millisOfSecond().getRangeDurationField()); assertEquals(3, test.millisOfSecond().getMaximumTextLength(null)); assertEquals(3, test.millisOfSecond().getMaximumShortTextLength(null)); } //----------------------------------------------------------------------- public void testPropertyGetMillisOfDay() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53); assertSame(test.getChronology().millisOfDay(), test.millisOfDay().getField()); assertEquals("millisOfDay", test.millisOfDay().getName()); assertEquals("Property[millisOfDay]", test.millisOfDay().toString()); assertEquals(48223053, test.millisOfDay().get()); assertEquals("48223053", test.millisOfDay().getAsText()); assertEquals("48223053", test.millisOfDay().getAsText(Locale.FRENCH)); assertEquals("48223053", test.millisOfDay().getAsShortText()); assertEquals("48223053", test.millisOfDay().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().millis(), test.millisOfDay().getDurationField()); assertEquals(test.getChronology().days(), test.millisOfDay().getRangeDurationField()); assertEquals(8, test.millisOfDay().getMaximumTextLength(null)); assertEquals(8, test.millisOfDay().getMaximumShortTextLength(null)); } //----------------------------------------------------------------------- public void testPropertyToIntervalYearOfEra() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53); Interval testInterval = test.yearOfEra().toInterval(); assertEquals(new MutableDateTime(2004, 1, 1, 0, 0, 0, 0), testInterval.getStart()); assertEquals(new MutableDateTime(2005, 1, 1, 0, 0, 0, 0), testInterval.getEnd()); assertEquals(new MutableDateTime(2004, 6, 9, 13, 23, 43, 53), test); } public void testPropertyToIntervalYearOfCentury() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53); Interval testInterval = test.yearOfCentury().toInterval(); assertEquals(new MutableDateTime(2004, 1, 1, 0, 0, 0, 0), testInterval.getStart()); assertEquals(new MutableDateTime(2005, 1, 1, 0, 0, 0, 0), testInterval.getEnd()); assertEquals(new MutableDateTime(2004, 6, 9, 13, 23, 43, 53), test); } public void testPropertyToIntervalYear() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53); Interval testInterval = test.year().toInterval(); assertEquals(new MutableDateTime(2004, 1, 1, 0, 0, 0, 0), testInterval.getStart()); assertEquals(new MutableDateTime(2005, 1, 1, 0, 0, 0, 0), testInterval.getEnd()); assertEquals(new MutableDateTime(2004, 6, 9, 13, 23, 43, 53), test); } public void testPropertyToIntervalMonthOfYear() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53); Interval testInterval = test.monthOfYear().toInterval(); assertEquals(new MutableDateTime(2004, 6, 1, 0, 0, 0, 0), testInterval.getStart()); assertEquals(new MutableDateTime(2004, 7, 1, 0, 0, 0, 0), testInterval.getEnd()); assertEquals(new MutableDateTime(2004, 6, 9, 13, 23, 43, 53), test); } public void testPropertyToIntervalDayOfMonth() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53); Interval testInterval = test.dayOfMonth().toInterval(); assertEquals(new MutableDateTime(2004, 6, 9, 0, 0, 0, 0), testInterval.getStart()); assertEquals(new MutableDateTime(2004, 6, 10, 0, 0, 0, 0), testInterval.getEnd()); assertEquals(new MutableDateTime(2004, 6, 9, 13, 23, 43, 53), test); MutableDateTime febTest = new MutableDateTime(2004, 2, 29, 13, 23, 43, 53); Interval febTestInterval = febTest.dayOfMonth().toInterval(); assertEquals(new MutableDateTime(2004, 2, 29, 0, 0, 0, 0), febTestInterval.getStart()); assertEquals(new MutableDateTime(2004, 3, 1, 0, 0, 0, 0), febTestInterval.getEnd()); assertEquals(new MutableDateTime(2004, 2, 29, 13, 23, 43, 53), febTest); } public void testPropertyToIntervalHourOfDay() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53); Interval testInterval = test.hourOfDay().toInterval(); assertEquals(new MutableDateTime(2004, 6, 9, 13, 0, 0, 0), testInterval.getStart()); assertEquals(new MutableDateTime(2004, 6, 9, 14, 0, 0, 0), testInterval.getEnd()); assertEquals(new MutableDateTime(2004, 6, 9, 13, 23, 43, 53), test); MutableDateTime midnightTest = new MutableDateTime(2004, 6, 9, 23, 23, 43, 53); Interval midnightTestInterval = midnightTest.hourOfDay().toInterval(); assertEquals(new MutableDateTime(2004, 6, 9, 23, 0, 0, 0), midnightTestInterval.getStart()); assertEquals(new MutableDateTime(2004, 6, 10, 0, 0, 0, 0), midnightTestInterval.getEnd()); assertEquals(new MutableDateTime(2004, 6, 9, 23, 23, 43, 53), midnightTest); } public void testPropertyToIntervalMinuteOfHour() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53); Interval testInterval = test.minuteOfHour().toInterval(); assertEquals(new MutableDateTime(2004, 6, 9, 13, 23, 0, 0), testInterval.getStart()); assertEquals(new MutableDateTime(2004, 6, 9, 13, 24, 0, 0), testInterval.getEnd()); assertEquals(new MutableDateTime(2004, 6, 9, 13, 23, 43, 53), test); } public void testPropertyToIntervalSecondOfMinute() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53); Interval testInterval = test.secondOfMinute().toInterval(); assertEquals(new MutableDateTime(2004, 6, 9, 13, 23, 43, 0), testInterval.getStart()); assertEquals(new MutableDateTime(2004, 6, 9, 13, 23, 44, 0), testInterval.getEnd()); assertEquals(new MutableDateTime(2004, 6, 9, 13, 23, 43, 53), test); } public void testPropertyToIntervalMillisOfSecond() { MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53); Interval testInterval = test.millisOfSecond().toInterval(); assertEquals(new MutableDateTime(2004, 6, 9, 13, 23, 43, 53), testInterval.getStart()); assertEquals(new MutableDateTime(2004, 6, 9, 13, 23, 43, 54), testInterval.getEnd()); assertEquals(new MutableDateTime(2004, 6, 9, 13, 23, 43, 53), test); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.BuddhistChronology; import org.joda.time.chrono.GregorianChronology; import org.joda.time.chrono.ISOChronology; /** * This class is a JUnit test for MutableDateTime. * * @author Stephen Colebourne */ public class TestMutableDateTime_Sets extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; // 2002-04-05 private long TEST_TIME1 = (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; // 2003-05-06 private long TEST_TIME2 = (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestMutableDateTime_Sets.class); } public TestMutableDateTime_Sets(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testTest() { assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString()); assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString()); assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString()); } //----------------------------------------------------------------------- public void testSetMillis_long1() { MutableDateTime test = new MutableDateTime(TEST_TIME1); test.setMillis(TEST_TIME2); assertEquals(TEST_TIME2, test.getMillis()); assertEquals(ISOChronology.getInstance(), test.getChronology()); } //----------------------------------------------------------------------- public void testSetChronology_Chronology1() { MutableDateTime test = new MutableDateTime(TEST_TIME1); test.setChronology(GregorianChronology.getInstance(PARIS)); assertEquals(TEST_TIME1, test.getMillis()); assertEquals(GregorianChronology.getInstance(PARIS), test.getChronology()); } public void testSetChronology_Chronology2() { MutableDateTime test = new MutableDateTime(TEST_TIME1); test.setChronology(null); assertEquals(TEST_TIME1, test.getMillis()); assertEquals(ISOChronology.getInstance(), test.getChronology()); } //----------------------------------------------------------------------- public void testSetZone_DateTimeZone1() { MutableDateTime test = new MutableDateTime(TEST_TIME1); test.setZone(PARIS); assertEquals(TEST_TIME1, test.getMillis()); assertEquals(ISOChronology.getInstance(PARIS), test.getChronology()); } public void testSetZone_DateTimeZone2() { MutableDateTime test = new MutableDateTime(TEST_TIME1); test.setZone(null); assertEquals(TEST_TIME1, test.getMillis()); assertEquals(ISOChronology.getInstance(), test.getChronology()); } //----------------------------------------------------------------------- public void testSetZoneRetainFields_DateTimeZone1() { MutableDateTime test = new MutableDateTime(TEST_TIME1); test.setZoneRetainFields(PARIS); assertEquals(TEST_TIME1 - DateTimeConstants.MILLIS_PER_HOUR, test.getMillis()); assertEquals(ISOChronology.getInstance(PARIS), test.getChronology()); } public void testSetZoneRetainFields_DateTimeZone2() { MutableDateTime test = new MutableDateTime(TEST_TIME1); test.setZoneRetainFields(null); assertEquals(TEST_TIME1, test.getMillis()); assertEquals(ISOChronology.getInstance(), test.getChronology()); } public void testSetZoneRetainFields_DateTimeZone3() { MutableDateTime test = new MutableDateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS)); test.setZoneRetainFields(null); assertEquals(TEST_TIME1 + DateTimeConstants.MILLIS_PER_HOUR, test.getMillis()); assertEquals(GregorianChronology.getInstance(), test.getChronology()); } public void testSetZoneRetainFields_DateTimeZone4() { Chronology chrono = new MockNullZoneChronology(); MutableDateTime test = new MutableDateTime(TEST_TIME1, chrono); test.setZoneRetainFields(PARIS); assertEquals(TEST_TIME1 - DateTimeConstants.MILLIS_PER_HOUR, test.getMillis()); assertSame(chrono, test.getChronology()); } //----------------------------------------------------------------------- public void testSetMillis_RI1() { MutableDateTime test = new MutableDateTime(TEST_TIME1, BuddhistChronology.getInstance()); test.setMillis(new Instant(TEST_TIME2)); assertEquals(TEST_TIME2, test.getMillis()); assertEquals(BuddhistChronology.getInstance(), test.getChronology()); } public void testSetMillis_RI2() { MutableDateTime test = new MutableDateTime(TEST_TIME1, BuddhistChronology.getInstance()); test.setMillis(null); assertEquals(TEST_TIME_NOW, test.getMillis()); assertEquals(BuddhistChronology.getInstance(), test.getChronology()); } //----------------------------------------------------------------------- public void testSet_DateTimeFieldType_int1() { MutableDateTime test = new MutableDateTime(TEST_TIME1); test.set(DateTimeFieldType.year(), 2010); assertEquals(2010, test.getYear()); } public void testSet_DateTimeFieldType_int2() { MutableDateTime test = new MutableDateTime(TEST_TIME1); try { test.set(null, 0); fail(); } catch (IllegalArgumentException ex) {} assertEquals(TEST_TIME1, test.getMillis()); } public void testSet_DateTimeFieldType_int3() { MutableDateTime test = new MutableDateTime(TEST_TIME1); try { test.set(DateTimeFieldType.monthOfYear(), 13); fail(); } catch (IllegalArgumentException ex) {} assertEquals(TEST_TIME1, test.getMillis()); } //----------------------------------------------------------------------- public void testSetDate_int_int_int1() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501); test.setDate(2010, 12, 3); assertEquals(2010, test.getYear()); assertEquals(12, test.getMonthOfYear()); assertEquals(3, test.getDayOfMonth()); assertEquals(12, test.getHourOfDay()); assertEquals(24, test.getMinuteOfHour()); assertEquals(48, test.getSecondOfMinute()); assertEquals(501, test.getMillisOfSecond()); } public void testSetDate_int_int_int2() { MutableDateTime test = new MutableDateTime(TEST_TIME1); try { test.setDate(2010, 13, 3); fail(); } catch (IllegalArgumentException ex) {} assertEquals(TEST_TIME1, test.getMillis()); } //----------------------------------------------------------------------- public void testSetDate_long1() { long setter = new DateTime(2010, 12, 3, 5, 7, 9, 501).getMillis(); MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501); test.setDate(setter); assertEquals(2010, test.getYear()); assertEquals(12, test.getMonthOfYear()); assertEquals(3, test.getDayOfMonth()); assertEquals(12, test.getHourOfDay()); assertEquals(24, test.getMinuteOfHour()); assertEquals(48, test.getSecondOfMinute()); assertEquals(501, test.getMillisOfSecond()); } //----------------------------------------------------------------------- public void testSetDate_RI1() { DateTime setter = new DateTime(2010, 12, 3, 5, 7, 9, 501); MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501); test.setDate(setter); assertEquals(2010, test.getYear()); assertEquals(12, test.getMonthOfYear()); assertEquals(3, test.getDayOfMonth()); assertEquals(12, test.getHourOfDay()); assertEquals(24, test.getMinuteOfHour()); assertEquals(48, test.getSecondOfMinute()); assertEquals(501, test.getMillisOfSecond()); } public void testSetDate_RI2() { MutableDateTime test = new MutableDateTime(2010, 7, 8, 12, 24, 48, 501); test.setDate(null); // sets to TEST_TIME_NOW assertEquals(2002, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(12, test.getHourOfDay()); assertEquals(24, test.getMinuteOfHour()); assertEquals(48, test.getSecondOfMinute()); assertEquals(501, test.getMillisOfSecond()); } public void testSetDate_RI_same() { MutableDateTime setter = new MutableDateTime(2010, 12, 3, 2, 24, 48, 501, DateTimeZone.forID("America/Los_Angeles")); MutableDateTime test = new MutableDateTime(2010, 12, 3, 2, 24, 48, 501, DateTimeZone.forID("America/Los_Angeles")); test.setDate(setter); assertEquals(2010, test.getYear()); assertEquals(12, test.getMonthOfYear()); assertEquals(3, test.getDayOfMonth()); assertEquals(2, test.getHourOfDay()); assertEquals(24, test.getMinuteOfHour()); assertEquals(48, test.getSecondOfMinute()); assertEquals(501, test.getMillisOfSecond()); } public void testSetDate_RI_different1() { MutableDateTime setter = new MutableDateTime(2010, 12, 1, 0, 0, 0, 0, DateTimeZone.forID("America/Los_Angeles")); MutableDateTime test = new MutableDateTime(2010, 12, 3, 2, 24, 48, 501, DateTimeZone.forID("Europe/Moscow")); test.setDate(setter); assertEquals(2010, test.getYear()); assertEquals(12, test.getMonthOfYear()); assertEquals(1, test.getDayOfMonth()); assertEquals(2, test.getHourOfDay()); assertEquals(24, test.getMinuteOfHour()); assertEquals(48, test.getSecondOfMinute()); assertEquals(501, test.getMillisOfSecond()); } public void testSetDate_RI_different2() { MutableDateTime setter = new MutableDateTime(2010, 12, 1, 0, 0, 0, 0, DateTimeZone.forID("Europe/Moscow")); MutableDateTime test = new MutableDateTime(2010, 12, 3, 2, 24, 48, 501, DateTimeZone.forID("America/Los_Angeles")); test.setDate(setter); assertEquals(2010, test.getYear()); assertEquals(12, test.getMonthOfYear()); assertEquals(1, test.getDayOfMonth()); assertEquals(2, test.getHourOfDay()); assertEquals(24, test.getMinuteOfHour()); assertEquals(48, test.getSecondOfMinute()); assertEquals(501, test.getMillisOfSecond()); } //----------------------------------------------------------------------- public void testSetTime_int_int_int_int1() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501); test.setTime(5, 6, 7, 8); assertEquals(2002, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(5, test.getHourOfDay()); assertEquals(6, test.getMinuteOfHour()); assertEquals(7, test.getSecondOfMinute()); assertEquals(8, test.getMillisOfSecond()); } public void testSetTime_int_int_int2() { MutableDateTime test = new MutableDateTime(TEST_TIME1); try { test.setTime(60, 6, 7, 8); fail(); } catch (IllegalArgumentException ex) {} assertEquals(TEST_TIME1, test.getMillis()); } //----------------------------------------------------------------------- public void testSetTime_long1() { long setter = new DateTime(2010, 12, 3, 5, 7, 9, 11).getMillis(); MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501); test.setTime(setter); assertEquals(2002, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(5, test.getHourOfDay()); assertEquals(7, test.getMinuteOfHour()); assertEquals(9, test.getSecondOfMinute()); assertEquals(11, test.getMillisOfSecond()); } //----------------------------------------------------------------------- public void testSetTime_RI1() { DateTime setter = new DateTime(2010, 12, 3, 5, 7, 9, 11); MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501); test.setTime(setter); assertEquals(2002, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(5, test.getHourOfDay()); assertEquals(7, test.getMinuteOfHour()); assertEquals(9, test.getSecondOfMinute()); assertEquals(11, test.getMillisOfSecond()); } public void testSetTime_RI2() { MutableDateTime test = new MutableDateTime(2010, 7, 8, 12, 24, 48, 501); test.setTime(null); // sets to TEST_TIME_NOW, which has no time part assertEquals(2010, test.getYear()); assertEquals(7, test.getMonthOfYear()); assertEquals(8, test.getDayOfMonth()); assertEquals(new DateTime(TEST_TIME_NOW).getHourOfDay(), test.getHourOfDay()); assertEquals(new DateTime(TEST_TIME_NOW).getMinuteOfHour(), test.getMinuteOfHour()); assertEquals(new DateTime(TEST_TIME_NOW).getSecondOfMinute(), test.getSecondOfMinute()); assertEquals(new DateTime(TEST_TIME_NOW).getMillisOfSecond(), test.getMillisOfSecond()); } public void testSetTime_Object3() { DateTime temp = new DateTime(2010, 12, 3, 5, 7, 9, 11); DateTime setter = new DateTime(temp.getMillis(), new MockNullZoneChronology()); MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501); test.setTime(setter); assertEquals(2002, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(5, test.getHourOfDay()); assertEquals(7, test.getMinuteOfHour()); assertEquals(9, test.getSecondOfMinute()); assertEquals(11, test.getMillisOfSecond()); } //----------------------------------------------------------------------- public void testSetDateTime_int_int_int_int_int_int_int1() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501); test.setDateTime(2010, 12, 3, 5, 6, 7, 8); assertEquals(2010, test.getYear()); assertEquals(12, test.getMonthOfYear()); assertEquals(3, test.getDayOfMonth()); assertEquals(5, test.getHourOfDay()); assertEquals(6, test.getMinuteOfHour()); assertEquals(7, test.getSecondOfMinute()); assertEquals(8, test.getMillisOfSecond()); } public void testSetDateTime_int_int_int_int_int_int_int2() { MutableDateTime test = new MutableDateTime(TEST_TIME1); try { test.setDateTime(2010, 13, 3, 5, 6, 7, 8); fail(); } catch (IllegalArgumentException ex) { } assertEquals(TEST_TIME1, test.getMillis()); } //----------------------------------------------------------------------- public void testSetYear_int1() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); test.setYear(2010); assertEquals("2010-06-09T05:06:07.008+01:00", test.toString()); } //----------------------------------------------------------------------- public void testSetMonthOfYear_int1() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); test.setMonthOfYear(12); assertEquals("2002-12-09T05:06:07.008Z", test.toString()); } public void testSetMonthOfYear_int_dstOverlapSummer_addZero() { MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); assertEquals("2011-10-30T02:30:00.000+02:00", test.toString()); test.setMonthOfYear(10); assertEquals("2011-10-30T02:30:00.000+02:00", test.toString()); } public void testSetMonthOfYear_int_dstOverlapWinter_addZero() { MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); test.addHours(1); assertEquals("2011-10-30T02:30:00.000+01:00", test.toString()); test.setMonthOfYear(10); assertEquals("2011-10-30T02:30:00.000+01:00", test.toString()); } public void testSetMonthOfYear_int2() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); try { test.setMonthOfYear(13); fail(); } catch (IllegalArgumentException ex) {} assertEquals("2002-06-09T05:06:07.008+01:00", test.toString()); } //----------------------------------------------------------------------- public void testSetDayOfMonth_int1() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); test.setDayOfMonth(17); assertEquals("2002-06-17T05:06:07.008+01:00", test.toString()); } public void testSetDayOfMonth_int2() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); try { test.setDayOfMonth(31); fail(); } catch (IllegalArgumentException ex) {} assertEquals("2002-06-09T05:06:07.008+01:00", test.toString()); } public void testSetDayOfMonth_int_dstOverlapSummer_addZero() { MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); assertEquals("2011-10-30T02:30:00.000+02:00", test.toString()); test.setDayOfMonth(30); assertEquals("2011-10-30T02:30:00.000+02:00", test.toString()); } public void testSetDayOfMonth_int_dstOverlapWinter_addZero() { MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); test.addHours(1); assertEquals("2011-10-30T02:30:00.000+01:00", test.toString()); test.setDayOfMonth(30); assertEquals("2011-10-30T02:30:00.000+01:00", test.toString()); } //----------------------------------------------------------------------- public void testSetDayOfYear_int1() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); test.setDayOfYear(3); assertEquals("2002-01-03T05:06:07.008Z", test.toString()); } public void testSetDayOfYear_int_dstOverlapSummer_addZero() { MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); assertEquals("2011-10-30T02:30:00.000+02:00", test.toString()); test.setDayOfYear(303); assertEquals("2011-10-30T02:30:00.000+02:00", test.toString()); } public void testSetDayOfYear_int_dstOverlapWinter_addZero() { MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); test.addHours(1); assertEquals("2011-10-30T02:30:00.000+01:00", test.toString()); test.setDayOfYear(303); assertEquals("2011-10-30T02:30:00.000+01:00", test.toString()); } public void testSetDayOfYear_int2() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); try { test.setDayOfYear(366); fail(); } catch (IllegalArgumentException ex) {} assertEquals("2002-06-09T05:06:07.008+01:00", test.toString()); } //----------------------------------------------------------------------- public void testSetWeekyear_int1() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); test.setWeekyear(2001); assertEquals("2001-06-10T05:06:07.008+01:00", test.toString()); } //----------------------------------------------------------------------- public void testSetWeekOfWeekyear_int1() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); test.setWeekOfWeekyear(2); assertEquals("2002-01-13T05:06:07.008Z", test.toString()); } public void testSetWeekOfWeekyear_int2() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); try { test.setWeekOfWeekyear(53); fail(); } catch (IllegalArgumentException ex) {} assertEquals("2002-06-09T05:06:07.008+01:00", test.toString()); } //----------------------------------------------------------------------- public void testSetDayOfWeek_int1() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); test.setDayOfWeek(5); assertEquals("2002-06-07T05:06:07.008+01:00", test.toString()); } public void testSetDayOfWeek_int2() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); try { test.setDayOfWeek(8); fail(); } catch (IllegalArgumentException ex) {} assertEquals("2002-06-09T05:06:07.008+01:00", test.toString()); } //----------------------------------------------------------------------- public void testSetHourOfDay_int1() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); test.setHourOfDay(13); assertEquals("2002-06-09T13:06:07.008+01:00", test.toString()); } public void testSetHourOfDay_int2() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); try { test.setHourOfDay(24); fail(); } catch (IllegalArgumentException ex) {} assertEquals("2002-06-09T05:06:07.008+01:00", test.toString()); } //----------------------------------------------------------------------- public void testSetMinuteOfHour_int1() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); test.setMinuteOfHour(13); assertEquals("2002-06-09T05:13:07.008+01:00", test.toString()); } public void testSetMinuteOfHour_int2() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); try { test.setMinuteOfHour(60); fail(); } catch (IllegalArgumentException ex) {} assertEquals("2002-06-09T05:06:07.008+01:00", test.toString()); } //----------------------------------------------------------------------- public void testSetMinuteOfDay_int1() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); test.setMinuteOfDay(13); assertEquals("2002-06-09T00:13:07.008+01:00", test.toString()); } public void testSetMinuteOfDay_int2() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); try { test.setMinuteOfDay(24 * 60); fail(); } catch (IllegalArgumentException ex) {} assertEquals("2002-06-09T05:06:07.008+01:00", test.toString()); } //----------------------------------------------------------------------- public void testSetSecondOfMinute_int1() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); test.setSecondOfMinute(13); assertEquals("2002-06-09T05:06:13.008+01:00", test.toString()); } public void testSetSecondOfMinute_int2() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); try { test.setSecondOfMinute(60); fail(); } catch (IllegalArgumentException ex) {} assertEquals("2002-06-09T05:06:07.008+01:00", test.toString()); } //----------------------------------------------------------------------- public void testSetSecondOfDay_int1() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); test.setSecondOfDay(13); assertEquals("2002-06-09T00:00:13.008+01:00", test.toString()); } public void testSetSecondOfDay_int2() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); try { test.setSecondOfDay(24 * 60 * 60); fail(); } catch (IllegalArgumentException ex) {} assertEquals("2002-06-09T05:06:07.008+01:00", test.toString()); } //----------------------------------------------------------------------- public void testSetMilliOfSecond_int1() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); test.setMillisOfSecond(13); assertEquals("2002-06-09T05:06:07.013+01:00", test.toString()); } public void testSetMilliOfSecond_int2() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); try { test.setMillisOfSecond(1000); fail(); } catch (IllegalArgumentException ex) {} assertEquals("2002-06-09T05:06:07.008+01:00", test.toString()); } //----------------------------------------------------------------------- public void testSetMilliOfDay_int1() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); test.setMillisOfDay(13); assertEquals("2002-06-09T00:00:00.013+01:00", test.toString()); } public void testSetMilliOfDay_int2() { MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8); try { test.setMillisOfDay(24 * 60 * 60 * 1000); fail(); } catch (IllegalArgumentException ex) {} assertEquals("2002-06-09T05:06:07.008+01:00", test.toString()); } }
/* * Copyright 2001-2011 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.base.AbstractInterval; import org.joda.time.chrono.CopticChronology; import org.joda.time.chrono.GJChronology; import org.joda.time.chrono.ISOChronology; /** * This class is a Junit unit test for Instant. * * @author Stephen Colebourne */ public class TestMutableInterval_Basics extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; // 2002-04-05 private long TEST_TIME1 = (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; // 2003-05-06 private long TEST_TIME2 = (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestMutableInterval_Basics.class); } public TestMutableInterval_Basics(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testTest() { assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString()); assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString()); assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString()); } //----------------------------------------------------------------------- public void testGetMillis() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); assertEquals(TEST_TIME1, test.getStartMillis()); assertEquals(TEST_TIME1, test.getStart().getMillis()); assertEquals(TEST_TIME2, test.getEndMillis()); assertEquals(TEST_TIME2, test.getEnd().getMillis()); assertEquals(TEST_TIME2 - TEST_TIME1, test.toDurationMillis()); assertEquals(TEST_TIME2 - TEST_TIME1, test.toDuration().getMillis()); } public void testGetDuration1() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); assertEquals(TEST_TIME2 - TEST_TIME1, test.toDurationMillis()); assertEquals(TEST_TIME2 - TEST_TIME1, test.toDuration().getMillis()); } public void testGetDuration2() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME1); assertSame(Duration.ZERO, test.toDuration()); } public void testEqualsHashCode() { MutableInterval test1 = new MutableInterval(TEST_TIME1, TEST_TIME2); MutableInterval test2 = new MutableInterval(TEST_TIME1, TEST_TIME2); assertEquals(true, test1.equals(test2)); assertEquals(true, test2.equals(test1)); assertEquals(true, test1.equals(test1)); assertEquals(true, test2.equals(test2)); assertEquals(true, test1.hashCode() == test2.hashCode()); assertEquals(true, test1.hashCode() == test1.hashCode()); assertEquals(true, test2.hashCode() == test2.hashCode()); MutableInterval test3 = new MutableInterval(TEST_TIME_NOW, TEST_TIME2); assertEquals(false, test1.equals(test3)); assertEquals(false, test2.equals(test3)); assertEquals(false, test3.equals(test1)); assertEquals(false, test3.equals(test2)); assertEquals(false, test1.hashCode() == test3.hashCode()); assertEquals(false, test2.hashCode() == test3.hashCode()); MutableInterval test4 = new MutableInterval(TEST_TIME1, TEST_TIME2, GJChronology.getInstance()); assertEquals(true, test4.equals(test4)); assertEquals(false, test1.equals(test4)); assertEquals(false, test2.equals(test4)); assertEquals(false, test4.equals(test1)); assertEquals(false, test4.equals(test2)); assertEquals(false, test1.hashCode() == test4.hashCode()); assertEquals(false, test2.hashCode() == test4.hashCode()); MutableInterval test5 = new MutableInterval(TEST_TIME1, TEST_TIME2); assertEquals(true, test1.equals(test5)); assertEquals(true, test2.equals(test5)); assertEquals(false, test3.equals(test5)); assertEquals(true, test5.equals(test1)); assertEquals(true, test5.equals(test2)); assertEquals(false, test5.equals(test3)); assertEquals(true, test1.hashCode() == test5.hashCode()); assertEquals(true, test2.hashCode() == test5.hashCode()); assertEquals(false, test3.hashCode() == test5.hashCode()); assertEquals(false, test1.equals("Hello")); assertEquals(true, test1.equals(new MockInterval())); assertEquals(false, test1.equals(new DateTime(TEST_TIME1))); } class MockInterval extends AbstractInterval { public MockInterval() { super(); } public Chronology getChronology() { return ISOChronology.getInstance(); } public long getStartMillis() { return TEST_TIME1; } public long getEndMillis() { return TEST_TIME2; } } //----------------------------------------------------------------------- public void testContains_long() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); assertEquals(true, test.contains(TEST_TIME1)); assertEquals(false, test.contains(TEST_TIME1 - 1)); assertEquals(true, test.contains(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2)); assertEquals(false, test.contains(TEST_TIME2)); assertEquals(true, test.contains(TEST_TIME2 - 1)); } public void testContainsNow() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); DateTimeUtils.setCurrentMillisFixed(TEST_TIME1); assertEquals(true, test.containsNow()); DateTimeUtils.setCurrentMillisFixed(TEST_TIME1 - 1); assertEquals(false, test.containsNow()); DateTimeUtils.setCurrentMillisFixed(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2); assertEquals(true, test.containsNow()); DateTimeUtils.setCurrentMillisFixed(TEST_TIME2); assertEquals(false, test.containsNow()); DateTimeUtils.setCurrentMillisFixed(TEST_TIME2 - 1); assertEquals(true, test.containsNow()); } public void testContains_RI() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); assertEquals(true, test.contains(new Instant(TEST_TIME1))); assertEquals(false, test.contains(new Instant(TEST_TIME1 - 1))); assertEquals(true, test.contains(new Instant(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2))); assertEquals(false, test.contains(new Instant(TEST_TIME2))); assertEquals(true, test.contains(new Instant(TEST_TIME2 - 1))); assertEquals(true, test.contains((ReadableInstant) null)); } //----------------------------------------------------------------------- public void testContains_RInterval() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); assertEquals(true, test.contains(new Interval(TEST_TIME1, TEST_TIME1))); assertEquals(false, test.contains(new Interval(TEST_TIME1 - 1, TEST_TIME1))); assertEquals(true, test.contains(new Interval(TEST_TIME1, TEST_TIME1 + 1))); assertEquals(false, test.contains(new Interval(TEST_TIME1 - 1, TEST_TIME1 + 1))); assertEquals(true, test.contains(new Interval(TEST_TIME1 + 1, TEST_TIME1 + 1))); assertEquals(true, test.contains(new Interval(TEST_TIME1, TEST_TIME2))); assertEquals(false, test.contains(new Interval(TEST_TIME1 - 1, TEST_TIME2))); assertEquals(true, test.contains(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2))); assertEquals(false, test.contains(new Interval(TEST_TIME2, TEST_TIME2))); assertEquals(true, test.contains(new Interval(TEST_TIME2 - 1, TEST_TIME2))); assertEquals(true, test.contains(new Interval(TEST_TIME1, TEST_TIME2 - 1))); assertEquals(false, test.contains(new Interval(TEST_TIME1 - 1, TEST_TIME2 - 1))); assertEquals(true, test.contains(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2 - 1))); assertEquals(true, test.contains(new Interval(TEST_TIME2 - 1, TEST_TIME2 - 1))); assertEquals(true, test.contains(new Interval(TEST_TIME2 - 2, TEST_TIME2 - 1))); assertEquals(false, test.contains(new Interval(TEST_TIME1, TEST_TIME2 + 1))); assertEquals(false, test.contains(new Interval(TEST_TIME1 - 1, TEST_TIME2 + 1))); assertEquals(false, test.contains(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2 + 1))); assertEquals(false, test.contains(new Interval(TEST_TIME2, TEST_TIME2 + 1))); assertEquals(false, test.contains(new Interval(TEST_TIME2 - 1, TEST_TIME2 + 1))); assertEquals(false, test.contains(new Interval(TEST_TIME1 - 2, TEST_TIME1 - 1))); assertEquals(true, test.contains((ReadableInterval) null)); } public void testOverlaps_RInterval() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); assertEquals(false, test.overlaps(new Interval(TEST_TIME1, TEST_TIME1))); assertEquals(false, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME1))); assertEquals(true, test.overlaps(new Interval(TEST_TIME1, TEST_TIME1 + 1))); assertEquals(true, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME1 + 1))); assertEquals(true, test.overlaps(new Interval(TEST_TIME1 + 1, TEST_TIME1 + 1))); assertEquals(true, test.overlaps(new Interval(TEST_TIME1, TEST_TIME2))); assertEquals(true, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME2))); assertEquals(true, test.overlaps(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2))); assertEquals(false, test.overlaps(new Interval(TEST_TIME2, TEST_TIME2))); assertEquals(true, test.overlaps(new Interval(TEST_TIME2 - 1, TEST_TIME2))); assertEquals(true, test.overlaps(new Interval(TEST_TIME1, TEST_TIME2 + 1))); assertEquals(true, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME2 + 1))); assertEquals(true, test.overlaps(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2 + 1))); assertEquals(false, test.overlaps(new Interval(TEST_TIME2, TEST_TIME2 + 1))); assertEquals(true, test.overlaps(new Interval(TEST_TIME2 - 1, TEST_TIME2 + 1))); assertEquals(false, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME1 - 1))); assertEquals(false, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME1))); assertEquals(true, test.overlaps(new Interval(TEST_TIME1 - 1, TEST_TIME1 + 1))); assertEquals(true, test.overlaps((ReadableInterval) null)); MutableInterval empty = new MutableInterval(TEST_TIME1, TEST_TIME1); assertEquals(false, empty.overlaps(empty)); assertEquals(false, empty.overlaps(test)); assertEquals(false, test.overlaps(empty)); } //----------------------------------------------------------------------- public void testIsBefore_long() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); assertEquals(false, test.isBefore(TEST_TIME1 - 1)); assertEquals(false, test.isBefore(TEST_TIME1)); assertEquals(false, test.isBefore(TEST_TIME1 + 1)); assertEquals(false, test.isBefore(TEST_TIME2 - 1)); assertEquals(true, test.isBefore(TEST_TIME2)); assertEquals(true, test.isBefore(TEST_TIME2 + 1)); } public void testIsBeforeNow() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); DateTimeUtils.setCurrentMillisFixed(TEST_TIME2 - 1); assertEquals(false, test.isBeforeNow()); DateTimeUtils.setCurrentMillisFixed(TEST_TIME2); assertEquals(true, test.isBeforeNow()); DateTimeUtils.setCurrentMillisFixed(TEST_TIME2 + 1); assertEquals(true, test.isBeforeNow()); } public void testIsBefore_RI() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); assertEquals(false, test.isBefore(new Instant(TEST_TIME1 - 1))); assertEquals(false, test.isBefore(new Instant(TEST_TIME1))); assertEquals(false, test.isBefore(new Instant(TEST_TIME1 + 1))); assertEquals(false, test.isBefore(new Instant(TEST_TIME2 - 1))); assertEquals(true, test.isBefore(new Instant(TEST_TIME2))); assertEquals(true, test.isBefore(new Instant(TEST_TIME2 + 1))); assertEquals(false, test.isBefore((ReadableInstant) null)); } public void testIsBefore_RInterval() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); assertEquals(false, test.isBefore(new Interval(Long.MIN_VALUE, TEST_TIME1 - 1))); assertEquals(false, test.isBefore(new Interval(Long.MIN_VALUE, TEST_TIME1))); assertEquals(false, test.isBefore(new Interval(Long.MIN_VALUE, TEST_TIME1 + 1))); assertEquals(false, test.isBefore(new Interval(TEST_TIME2 - 1, Long.MAX_VALUE))); assertEquals(true, test.isBefore(new Interval(TEST_TIME2, Long.MAX_VALUE))); assertEquals(true, test.isBefore(new Interval(TEST_TIME2 + 1, Long.MAX_VALUE))); assertEquals(false, test.isBefore((ReadableInterval) null)); } //----------------------------------------------------------------------- public void testIsAfter_long() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); assertEquals(true, test.isAfter(TEST_TIME1 - 1)); assertEquals(false, test.isAfter(TEST_TIME1)); assertEquals(false, test.isAfter(TEST_TIME1 + 1)); assertEquals(false, test.isAfter(TEST_TIME2 - 1)); assertEquals(false, test.isAfter(TEST_TIME2)); assertEquals(false, test.isAfter(TEST_TIME2 + 1)); } public void testIsAfterNow() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); DateTimeUtils.setCurrentMillisFixed(TEST_TIME1 - 1); assertEquals(true, test.isAfterNow()); DateTimeUtils.setCurrentMillisFixed(TEST_TIME1); assertEquals(false, test.isAfterNow()); DateTimeUtils.setCurrentMillisFixed(TEST_TIME1 + 1); assertEquals(false, test.isAfterNow()); } public void testIsAfter_RI() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); assertEquals(true, test.isAfter(new Instant(TEST_TIME1 - 1))); assertEquals(false, test.isAfter(new Instant(TEST_TIME1))); assertEquals(false, test.isAfter(new Instant(TEST_TIME1 + 1))); assertEquals(false, test.isAfter(new Instant(TEST_TIME2 - 1))); assertEquals(false, test.isAfter(new Instant(TEST_TIME2))); assertEquals(false, test.isAfter(new Instant(TEST_TIME2 + 1))); assertEquals(false, test.isAfter((ReadableInstant) null)); } public void testIsAfter_RInterval() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); assertEquals(true, test.isAfter(new Interval(Long.MIN_VALUE, TEST_TIME1 - 1))); assertEquals(true, test.isAfter(new Interval(Long.MIN_VALUE, TEST_TIME1))); assertEquals(false, test.isAfter(new Interval(Long.MIN_VALUE, TEST_TIME1 + 1))); assertEquals(false, test.isAfter(new Interval(TEST_TIME2 - 1, Long.MAX_VALUE))); assertEquals(false, test.isAfter(new Interval(TEST_TIME2, Long.MAX_VALUE))); assertEquals(false, test.isAfter(new Interval(TEST_TIME2 + 1, Long.MAX_VALUE))); assertEquals(false, test.isAfter((ReadableInterval) null)); } //----------------------------------------------------------------------- public void testToInterval1() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS); Interval result = test.toInterval(); assertEquals(test, result); } //----------------------------------------------------------------------- public void testToMutableInterval1() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS); MutableInterval result = test.toMutableInterval(); assertEquals(test, result); assertNotSame(test, result); } //----------------------------------------------------------------------- public void testToPeriod() { DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10, COPTIC_PARIS); DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18, COPTIC_PARIS); MutableInterval base = new MutableInterval(dt1, dt2); Period test = base.toPeriod(); Period expected = new Period(dt1, dt2, PeriodType.standard()); assertEquals(expected, test); } //----------------------------------------------------------------------- public void testToPeriod_PeriodType1() { DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10, COPTIC_PARIS); DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18, COPTIC_PARIS); MutableInterval base = new MutableInterval(dt1, dt2); Period test = base.toPeriod(null); Period expected = new Period(dt1, dt2, PeriodType.standard()); assertEquals(expected, test); } public void testToPeriod_PeriodType2() { DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10); DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18); MutableInterval base = new MutableInterval(dt1, dt2); Period test = base.toPeriod(PeriodType.yearWeekDayTime()); Period expected = new Period(dt1, dt2, PeriodType.yearWeekDayTime()); assertEquals(expected, test); } //----------------------------------------------------------------------- public void testSerialization() throws Exception { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(test); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); MutableInterval result = (MutableInterval) ois.readObject(); ois.close(); assertEquals(test, result); } //----------------------------------------------------------------------- public void testToString() { DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10, DateTimeZone.UTC); DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18, DateTimeZone.UTC); MutableInterval test = new MutableInterval(dt1, dt2); assertEquals("2004-06-09T07:08:09.010Z/2005-08-13T12:14:16.018Z", test.toString()); } //----------------------------------------------------------------------- public void testCopy() { MutableInterval test = new MutableInterval(123L, 456L, COPTIC_PARIS); MutableInterval cloned = test.copy(); assertEquals(test, cloned); assertNotSame(test, cloned); } public void testClone() { MutableInterval test = new MutableInterval(123L, 456L, COPTIC_PARIS); MutableInterval cloned = (MutableInterval) test.clone(); assertEquals(test, cloned); assertNotSame(test, cloned); } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.BuddhistChronology; import org.joda.time.chrono.GJChronology; import org.joda.time.chrono.ISOChronology; import org.joda.time.convert.ConverterManager; import org.joda.time.convert.IntervalConverter; /** * This class is a JUnit test for Interval. * * @author Stephen Colebourne */ public class TestMutableInterval_Constructors extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; // 2002-04-05 private long TEST_TIME1 = (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; // 2003-05-06 private long TEST_TIME2 = (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestMutableInterval_Constructors.class); } public TestMutableInterval_Constructors(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(PARIS); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testTest() { assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString()); assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString()); assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString()); } //----------------------------------------------------------------------- public void testParse_noFormatter() throws Throwable { DateTime start = new DateTime(2010, 6, 30, 12, 30, ISOChronology.getInstance(PARIS)); DateTime end = new DateTime(2010, 7, 1, 14, 30, ISOChronology.getInstance(PARIS)); assertEquals(new MutableInterval(start, end), MutableInterval.parse("2010-06-30T12:30/2010-07-01T14:30")); assertEquals(new MutableInterval(start, end), MutableInterval.parse("2010-06-30T12:30/P1DT2H")); assertEquals(new MutableInterval(start, end), MutableInterval.parse("P1DT2H/2010-07-01T14:30")); } //----------------------------------------------------------------------- public void testConstructor() throws Throwable { MutableInterval test = new MutableInterval(); assertEquals(0L, test.getStartMillis()); assertEquals(0L, test.getEndMillis()); } //----------------------------------------------------------------------- public void testConstructor_long_long1() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); MutableInterval test = new MutableInterval(dt1.getMillis(), dt2.getMillis()); assertEquals(dt1.getMillis(), test.getStartMillis()); assertEquals(dt2.getMillis(), test.getEndMillis()); assertEquals(ISOChronology.getInstance(), test.getChronology()); } public void testConstructor_long_long2() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); MutableInterval test = new MutableInterval(dt1.getMillis(), dt1.getMillis()); assertEquals(dt1.getMillis(), test.getStartMillis()); assertEquals(dt1.getMillis(), test.getEndMillis()); assertEquals(ISOChronology.getInstance(), test.getChronology()); } public void testConstructor_long_long3() throws Throwable { DateTime dt1 = new DateTime(2005, 7, 10, 1, 1, 1, 1); DateTime dt2 = new DateTime(2004, 6, 9, 0, 0, 0, 0); try { new MutableInterval(dt1.getMillis(), dt2.getMillis()); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testConstructor_long_long_Chronology1() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); MutableInterval test = new MutableInterval(dt1.getMillis(), dt2.getMillis(), GJChronology.getInstance()); assertEquals(dt1.getMillis(), test.getStartMillis()); assertEquals(dt2.getMillis(), test.getEndMillis()); assertEquals(GJChronology.getInstance(), test.getChronology()); } public void testConstructor_long_long_Chronology2() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); MutableInterval test = new MutableInterval(dt1.getMillis(), dt2.getMillis(), null); assertEquals(dt1.getMillis(), test.getStartMillis()); assertEquals(dt2.getMillis(), test.getEndMillis()); assertEquals(ISOChronology.getInstance(), test.getChronology()); } //----------------------------------------------------------------------- public void testConstructor_RI_RI1() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); MutableInterval test = new MutableInterval(dt1, dt2); assertEquals(dt1.getMillis(), test.getStartMillis()); assertEquals(dt2.getMillis(), test.getEndMillis()); } public void testConstructor_RI_RI2() throws Throwable { Instant dt1 = new Instant(new DateTime(2004, 6, 9, 0, 0, 0, 0)); Instant dt2 = new Instant(new DateTime(2005, 7, 10, 1, 1, 1, 1)); MutableInterval test = new MutableInterval(dt1, dt2); assertEquals(dt1.getMillis(), test.getStartMillis()); assertEquals(dt2.getMillis(), test.getEndMillis()); } public void testConstructor_RI_RI3() throws Throwable { MutableInterval test = new MutableInterval((ReadableInstant) null, (ReadableInstant) null); assertEquals(TEST_TIME_NOW, test.getStartMillis()); assertEquals(TEST_TIME_NOW, test.getEndMillis()); } public void testConstructor_RI_RI4() throws Throwable { DateTime dt1 = new DateTime(2000, 6, 9, 0, 0, 0, 0); MutableInterval test = new MutableInterval(dt1, (ReadableInstant) null); assertEquals(dt1.getMillis(), test.getStartMillis()); assertEquals(TEST_TIME_NOW, test.getEndMillis()); } public void testConstructor_RI_RI5() throws Throwable { DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); MutableInterval test = new MutableInterval((ReadableInstant) null, dt2); assertEquals(TEST_TIME_NOW, test.getStartMillis()); assertEquals(dt2.getMillis(), test.getEndMillis()); } public void testConstructor_RI_RI6() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); MutableInterval test = new MutableInterval(dt1, dt1); assertEquals(dt1.getMillis(), test.getStartMillis()); assertEquals(dt1.getMillis(), test.getEndMillis()); } public void testConstructor_RI_RI7() throws Throwable { DateTime dt1 = new DateTime(2005, 7, 10, 1, 1, 1, 1); DateTime dt2 = new DateTime(2004, 6, 9, 0, 0, 0, 0); try { new MutableInterval(dt1, dt2); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_RI_RI8() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0, GJChronology.getInstance()); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); MutableInterval test = new MutableInterval(dt1, dt2); assertEquals(dt1.getMillis(), test.getStartMillis()); assertEquals(dt2.getMillis(), test.getEndMillis()); assertEquals(GJChronology.getInstance(), test.getChronology()); } public void testConstructor_RI_RI9() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1, GJChronology.getInstance()); MutableInterval test = new MutableInterval(dt1, dt2); assertEquals(dt1.getMillis(), test.getStartMillis()); assertEquals(dt2.getMillis(), test.getEndMillis()); assertEquals(ISOChronology.getInstance(), test.getChronology()); } //----------------------------------------------------------------------- public void testConstructor_RI_RP1() throws Throwable { DateTime dt = new DateTime(TEST_TIME_NOW); Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0); long result = TEST_TIME_NOW; result = ISOChronology.getInstance().months().add(result, 6); result = ISOChronology.getInstance().hours().add(result, 1); MutableInterval test = new MutableInterval(dt, dur); assertEquals(dt.getMillis(), test.getStartMillis()); assertEquals(result, test.getEndMillis()); } public void testConstructor_RI_RP2() throws Throwable { Instant dt = new Instant(new DateTime(TEST_TIME_NOW)); Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0); long result = TEST_TIME_NOW; result = ISOChronology.getInstanceUTC().months().add(result, 6); result = ISOChronology.getInstanceUTC().days().add(result, 3); result = ISOChronology.getInstanceUTC().hours().add(result, 1); MutableInterval test = new MutableInterval(dt, dur); assertEquals(dt.getMillis(), test.getStartMillis()); assertEquals(result, test.getEndMillis()); } public void testConstructor_RI_RP3() throws Throwable { DateTime dt = new DateTime(TEST_TIME_NOW, ISOChronology.getInstanceUTC()); Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.standard()); long result = TEST_TIME_NOW; result = ISOChronology.getInstanceUTC().months().add(result, 6); result = ISOChronology.getInstanceUTC().days().add(result, 3); result = ISOChronology.getInstanceUTC().hours().add(result, 1); MutableInterval test = new MutableInterval(dt, dur); assertEquals(dt.getMillis(), test.getStartMillis()); assertEquals(result, test.getEndMillis()); } public void testConstructor_RI_RP4() throws Throwable { DateTime dt = new DateTime(TEST_TIME_NOW); Period dur = new Period(1 * DateTimeConstants.MILLIS_PER_HOUR + 23L); long result = TEST_TIME_NOW; result = ISOChronology.getInstance().hours().add(result, 1); result = ISOChronology.getInstance().millis().add(result, 23); MutableInterval test = new MutableInterval(dt, dur); assertEquals(dt.getMillis(), test.getStartMillis()); assertEquals(result, test.getEndMillis()); } public void testConstructor_RI_RP5() throws Throwable { MutableInterval test = new MutableInterval((ReadableInstant) null, (ReadablePeriod) null); assertEquals(TEST_TIME_NOW, test.getStartMillis()); assertEquals(TEST_TIME_NOW, test.getEndMillis()); } public void testConstructor_RI_RP6() throws Throwable { DateTime dt = new DateTime(TEST_TIME_NOW); MutableInterval test = new MutableInterval(dt, (ReadablePeriod) null); assertEquals(dt.getMillis(), test.getStartMillis()); assertEquals(dt.getMillis(), test.getEndMillis()); } public void testConstructor_RI_RP7() throws Throwable { Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0); long result = TEST_TIME_NOW; result = ISOChronology.getInstance().monthOfYear().add(result, 6); result = ISOChronology.getInstance().hourOfDay().add(result, 1); MutableInterval test = new MutableInterval((ReadableInstant) null, dur); assertEquals(TEST_TIME_NOW, test.getStartMillis()); assertEquals(result, test.getEndMillis()); } public void testConstructor_RI_RP8() throws Throwable { DateTime dt = new DateTime(TEST_TIME_NOW); Period dur = new Period(0, 0, 0, 0, 0, 0, 0, -1); try { new MutableInterval(dt, dur); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testConstructor_RP_RI1() throws Throwable { DateTime dt = new DateTime(TEST_TIME_NOW); Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0); long result = TEST_TIME_NOW; result = ISOChronology.getInstance().months().add(result, -6); result = ISOChronology.getInstance().hours().add(result, -1); MutableInterval test = new MutableInterval(dur, dt); assertEquals(result, test.getStartMillis()); assertEquals(dt.getMillis(), test.getEndMillis()); } public void testConstructor_RP_RI2() throws Throwable { Instant dt = new Instant(new DateTime(TEST_TIME_NOW)); Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0); long result = TEST_TIME_NOW; result = ISOChronology.getInstanceUTC().months().add(result, -6); result = ISOChronology.getInstanceUTC().days().add(result, -3); result = ISOChronology.getInstanceUTC().hours().add(result, -1); MutableInterval test = new MutableInterval(dur, dt); assertEquals(result, test.getStartMillis()); assertEquals(dt.getMillis(), test.getEndMillis()); } public void testConstructor_RP_RI3() throws Throwable { DateTime dt = new DateTime(TEST_TIME_NOW, ISOChronology.getInstanceUTC()); Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.standard()); long result = TEST_TIME_NOW; result = ISOChronology.getInstanceUTC().months().add(result, -6); result = ISOChronology.getInstanceUTC().days().add(result, -3); result = ISOChronology.getInstanceUTC().hours().add(result, -1); MutableInterval test = new MutableInterval(dur, dt); assertEquals(result, test.getStartMillis()); assertEquals(dt.getMillis(), test.getEndMillis()); } public void testConstructor_RP_RI4() throws Throwable { DateTime dt = new DateTime(TEST_TIME_NOW); Period dur = new Period(1 * DateTimeConstants.MILLIS_PER_HOUR + 23L); long result = TEST_TIME_NOW; result = ISOChronology.getInstance().hours().add(result, -1); result = ISOChronology.getInstance().millis().add(result, -23); MutableInterval test = new MutableInterval(dur, dt); assertEquals(result, test.getStartMillis()); assertEquals(dt.getMillis(), test.getEndMillis()); } public void testConstructor_RP_RI5() throws Throwable { MutableInterval test = new MutableInterval((ReadablePeriod) null, (ReadableInstant) null); assertEquals(TEST_TIME_NOW, test.getStartMillis()); assertEquals(TEST_TIME_NOW, test.getEndMillis()); } public void testConstructor_RP_RI6() throws Throwable { DateTime dt = new DateTime(TEST_TIME_NOW); MutableInterval test = new MutableInterval((ReadablePeriod) null, dt); assertEquals(dt.getMillis(), test.getStartMillis()); assertEquals(dt.getMillis(), test.getEndMillis()); } public void testConstructor_RP_RI7() throws Throwable { Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0); long result = TEST_TIME_NOW; result = ISOChronology.getInstance().monthOfYear().add(result, -6); result = ISOChronology.getInstance().hourOfDay().add(result, -1); MutableInterval test = new MutableInterval(dur, (ReadableInstant) null); assertEquals(result, test.getStartMillis()); assertEquals(TEST_TIME_NOW, test.getEndMillis()); } public void testConstructor_RP_RI8() throws Throwable { DateTime dt = new DateTime(TEST_TIME_NOW); Period dur = new Period(0, 0, 0, 0, 0, 0, 0, -1); try { new MutableInterval(dur, dt); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testConstructor_RI_RD1() throws Throwable { long result = TEST_TIME_NOW; result = ISOChronology.getInstance().months().add(result, 6); result = ISOChronology.getInstance().hours().add(result, 1); DateTime dt = new DateTime(TEST_TIME_NOW); Duration dur = new Duration(result - TEST_TIME_NOW); MutableInterval test = new MutableInterval(dt, dur); assertEquals(dt.getMillis(), test.getStartMillis()); assertEquals(result, test.getEndMillis()); } public void testConstructor_RI_RD2() throws Throwable { MutableInterval test = new MutableInterval((ReadableInstant) null, (ReadableDuration) null); assertEquals(TEST_TIME_NOW, test.getStartMillis()); assertEquals(TEST_TIME_NOW, test.getEndMillis()); } public void testConstructor_RI_RD3() throws Throwable { DateTime dt = new DateTime(TEST_TIME_NOW); MutableInterval test = new MutableInterval(dt, (ReadableDuration) null); assertEquals(dt.getMillis(), test.getStartMillis()); assertEquals(dt.getMillis(), test.getEndMillis()); } public void testConstructor_RI_RD4() throws Throwable { long result = TEST_TIME_NOW; result = ISOChronology.getInstance().monthOfYear().add(result, 6); result = ISOChronology.getInstance().hourOfDay().add(result, 1); Duration dur = new Duration(result - TEST_TIME_NOW); MutableInterval test = new MutableInterval((ReadableInstant) null, dur); assertEquals(TEST_TIME_NOW, test.getStartMillis()); assertEquals(result, test.getEndMillis()); } public void testConstructor_RI_RD5() throws Throwable { DateTime dt = new DateTime(TEST_TIME_NOW); Duration dur = new Duration(-1); try { new MutableInterval(dt, dur); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testConstructor_RD_RI1() throws Throwable { long result = TEST_TIME_NOW; result = ISOChronology.getInstance().months().add(result, -6); result = ISOChronology.getInstance().hours().add(result, -1); DateTime dt = new DateTime(TEST_TIME_NOW); Duration dur = new Duration(TEST_TIME_NOW - result); MutableInterval test = new MutableInterval(dur, dt); assertEquals(result, test.getStartMillis()); assertEquals(dt.getMillis(), test.getEndMillis()); } public void testConstructor_RD_RI2() throws Throwable { MutableInterval test = new MutableInterval((ReadableDuration) null, (ReadableInstant) null); assertEquals(TEST_TIME_NOW, test.getStartMillis()); assertEquals(TEST_TIME_NOW, test.getEndMillis()); } public void testConstructor_RD_RI3() throws Throwable { DateTime dt = new DateTime(TEST_TIME_NOW); MutableInterval test = new MutableInterval((ReadableDuration) null, dt); assertEquals(dt.getMillis(), test.getStartMillis()); assertEquals(dt.getMillis(), test.getEndMillis()); } public void testConstructor_RD_RI4() throws Throwable { long result = TEST_TIME_NOW; result = ISOChronology.getInstance().monthOfYear().add(result, -6); result = ISOChronology.getInstance().hourOfDay().add(result, -1); Duration dur = new Duration(TEST_TIME_NOW - result); MutableInterval test = new MutableInterval(dur, (ReadableInstant) null); assertEquals(result, test.getStartMillis()); assertEquals(TEST_TIME_NOW, test.getEndMillis()); } public void testConstructor_RD_RI5() throws Throwable { DateTime dt = new DateTime(TEST_TIME_NOW); Duration dur = new Duration(-1); try { new MutableInterval(dur, dt); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testConstructor_Object1() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); MutableInterval test = new MutableInterval(dt1.toString() + '/' + dt2.toString()); assertEquals(dt1.getMillis(), test.getStartMillis()); assertEquals(dt2.getMillis(), test.getEndMillis()); } public void testConstructor_Object2() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); MutableInterval base = new MutableInterval(dt1, dt2); MutableInterval test = new MutableInterval(base); assertEquals(dt1.getMillis(), test.getStartMillis()); assertEquals(dt2.getMillis(), test.getEndMillis()); } public void testConstructor_Object3() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); Interval base = new Interval(dt1, dt2); MutableInterval test = new MutableInterval(base); assertEquals(dt1.getMillis(), test.getStartMillis()); assertEquals(dt2.getMillis(), test.getEndMillis()); } public void testConstructor_Object4() throws Throwable { MockInterval base = new MockInterval(); MutableInterval test = new MutableInterval(base); assertEquals(base.getStartMillis(), test.getStartMillis()); assertEquals(base.getEndMillis(), test.getEndMillis()); } public void testConstructor_Object5() throws Throwable { IntervalConverter oldConv = ConverterManager.getInstance().getIntervalConverter(""); IntervalConverter conv = new IntervalConverter() { public boolean isReadableInterval(Object object, Chronology chrono) { return false; } public void setInto(ReadWritableInterval interval, Object object, Chronology chrono) { interval.setChronology(chrono); interval.setInterval(1234L, 5678L); } public Class<?> getSupportedType() { return String.class; } }; try { ConverterManager.getInstance().addIntervalConverter(conv); DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); MutableInterval test = new MutableInterval(dt1.toString() + '/' + dt2.toString()); assertEquals(1234L, test.getStartMillis()); assertEquals(5678L, test.getEndMillis()); } finally { ConverterManager.getInstance().addIntervalConverter(oldConv); } } public void testConstructor_Object6() throws Throwable { IntervalConverter oldConv = ConverterManager.getInstance().getIntervalConverter(new MutableInterval(0L, 0L)); IntervalConverter conv = new IntervalConverter() { public boolean isReadableInterval(Object object, Chronology chrono) { return false; } public void setInto(ReadWritableInterval interval, Object object, Chronology chrono) { interval.setChronology(chrono); interval.setInterval(1234L, 5678L); } public Class<?> getSupportedType() { return ReadableInterval.class; } }; try { ConverterManager.getInstance().addIntervalConverter(conv); Interval base = new Interval(-1000L, 1000L); MutableInterval test = new MutableInterval(base); assertEquals(1234L, test.getStartMillis()); assertEquals(5678L, test.getEndMillis()); } finally { ConverterManager.getInstance().addIntervalConverter(oldConv); } } class MockInterval implements ReadableInterval { public Chronology getChronology() { return ISOChronology.getInstance(); } public long getStartMillis() { return 1234L; } public DateTime getStart() { return new DateTime(1234L); } public long getEndMillis() { return 5678L; } public DateTime getEnd() { return new DateTime(5678L); } public long toDurationMillis() { return (5678L - 1234L); } public Duration toDuration() { return new Duration(5678L - 1234L); } public boolean contains(long millisInstant) { return false; } public boolean containsNow() { return false; } public boolean contains(ReadableInstant instant) { return false; } public boolean contains(ReadableInterval interval) { return false; } public boolean overlaps(ReadableInterval interval) { return false; } public boolean isBefore(ReadableInstant instant) { return false; } public boolean isBefore(ReadableInterval interval) { return false; } public boolean isAfter(ReadableInstant instant) { return false; } public boolean isAfter(ReadableInterval interval) { return false; } public Interval toInterval() { return null; } public MutableInterval toMutableInterval() { return null; } public Period toPeriod() { return null; } public Period toPeriod(PeriodType type) { return null; } } //----------------------------------------------------------------------- public void testConstructor_Object_Chronology1() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); Interval base = new Interval(dt1, dt2); MutableInterval test = new MutableInterval(base, BuddhistChronology.getInstance()); assertEquals(dt1.getMillis(), test.getStartMillis()); assertEquals(dt2.getMillis(), test.getEndMillis()); assertEquals(BuddhistChronology.getInstance(), test.getChronology()); } public void testConstructor_Object_Chronology2() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); Interval base = new Interval(dt1, dt2); MutableInterval test = new MutableInterval(base, null); assertEquals(dt1.getMillis(), test.getStartMillis()); assertEquals(dt2.getMillis(), test.getEndMillis()); assertEquals(ISOChronology.getInstance(), test.getChronology()); } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.base.AbstractInterval; import org.joda.time.chrono.ISOChronology; /** * This class is a Junit unit test for Instant. * * @author Stephen Colebourne */ public class TestMutableInterval_Updates extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; // 2002-04-05 private long TEST_TIME1 = (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; // 2003-05-06 private long TEST_TIME2 = (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestMutableInterval_Updates.class); } public TestMutableInterval_Updates(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testTest() { assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString()); assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString()); assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString()); } //----------------------------------------------------------------------- public void testSetInterval_long_long1() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); test.setInterval(TEST_TIME1 - 1, TEST_TIME2 + 1); assertEquals(TEST_TIME1 - 1, test.getStartMillis()); assertEquals(TEST_TIME2 + 1, test.getEndMillis()); } public void testSetInterval_long_long2() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); try { test.setInterval(TEST_TIME1 - 1, TEST_TIME1 - 2); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testSetInterval_RI_RI1() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); test.setInterval(new Instant(TEST_TIME1 - 1), new Instant(TEST_TIME2 + 1)); assertEquals(TEST_TIME1 - 1, test.getStartMillis()); assertEquals(TEST_TIME2 + 1, test.getEndMillis()); } public void testSetInterval_RI_RI2() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); try { test.setInterval(new Instant(TEST_TIME1 - 1), new Instant(TEST_TIME1 - 2)); fail(); } catch (IllegalArgumentException ex) {} } public void testSetInterval_RI_RI3() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); test.setInterval(null, new Instant(TEST_TIME2 + 1)); assertEquals(TEST_TIME_NOW, test.getStartMillis()); assertEquals(TEST_TIME2 + 1, test.getEndMillis()); } public void testSetInterval_RI_RI4() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); test.setInterval(new Instant(TEST_TIME1 - 1), null); assertEquals(TEST_TIME1 - 1, test.getStartMillis()); assertEquals(TEST_TIME_NOW, test.getEndMillis()); } public void testSetInterval_RI_RI5() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); test.setInterval(null, null); assertEquals(TEST_TIME_NOW, test.getStartMillis()); assertEquals(TEST_TIME_NOW, test.getEndMillis()); } //----------------------------------------------------------------------- public void testSetInterval_RInterval1() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); test.setInterval(new Interval(TEST_TIME1 - 1, TEST_TIME2 + 1)); assertEquals(TEST_TIME1 - 1, test.getStartMillis()); assertEquals(TEST_TIME2 + 1, test.getEndMillis()); } public void testSetInterval_RInterval2() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); try { test.setInterval(new MockBadInterval()); fail(); } catch (IllegalArgumentException ex) {} } class MockBadInterval extends AbstractInterval { public Chronology getChronology() { return ISOChronology.getInstance(); } public long getStartMillis() { return TEST_TIME1 - 1; } public long getEndMillis() { return TEST_TIME1 - 2; } } public void testSetInterval_RInterval3() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); try { test.setInterval(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testSetStartMillis_long1() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); test.setStartMillis(TEST_TIME1 - 1); assertEquals(TEST_TIME1 - 1, test.getStartMillis()); assertEquals(TEST_TIME2, test.getEndMillis()); } public void testSetStartMillis_long2() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); try { test.setStartMillis(TEST_TIME2 + 1); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testSetStart_RI1() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); test.setStart(new Instant(TEST_TIME1 - 1)); assertEquals(TEST_TIME1 - 1, test.getStartMillis()); assertEquals(TEST_TIME2, test.getEndMillis()); } public void testSetStart_RI2() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); try { test.setStart(new Instant(TEST_TIME2 + 1)); fail(); } catch (IllegalArgumentException ex) {} } public void testSetStart_RI3() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); test.setStart(null); assertEquals(TEST_TIME_NOW, test.getStartMillis()); assertEquals(TEST_TIME2, test.getEndMillis()); } //----------------------------------------------------------------------- public void testSetEndMillis_long1() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); test.setEndMillis(TEST_TIME2 + 1); assertEquals(TEST_TIME1, test.getStartMillis()); assertEquals(TEST_TIME2 + 1, test.getEndMillis()); } public void testSetEndMillis_long2() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); try { test.setEndMillis(TEST_TIME1 - 1); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testSetEnd_RI1() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); test.setEnd(new Instant(TEST_TIME2 + 1)); assertEquals(TEST_TIME1, test.getStartMillis()); assertEquals(TEST_TIME2 + 1, test.getEndMillis()); } public void testSetEnd_RI2() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); try { test.setEnd(new Instant(TEST_TIME1 - 1)); fail(); } catch (IllegalArgumentException ex) {} } public void testSetEnd_RI3() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); test.setEnd(null); assertEquals(TEST_TIME1, test.getStartMillis()); assertEquals(TEST_TIME_NOW, test.getEndMillis()); } //----------------------------------------------------------------------- public void testSetDurationAfterStart_long1() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); test.setDurationAfterStart(123L); assertEquals(TEST_TIME1, test.getStartMillis()); assertEquals(TEST_TIME1 + 123L, test.getEndMillis()); } public void testSeDurationAfterStart_long2() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); try { test.setDurationAfterStart(-1); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testSetDurationAfterStart_RI1() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); test.setDurationAfterStart(new Duration(123L)); assertEquals(TEST_TIME1, test.getStartMillis()); assertEquals(TEST_TIME1 + 123L, test.getEndMillis()); } public void testSeDurationAfterStart_RI2() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); try { test.setDurationAfterStart(new Duration(-1)); fail(); } catch (IllegalArgumentException ex) {} } public void testSetDurationAfterStart_RI3() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); test.setDurationAfterStart(null); assertEquals(TEST_TIME1, test.getStartMillis()); assertEquals(TEST_TIME1, test.getEndMillis()); } //----------------------------------------------------------------------- public void testSetDurationBeforeEnd_long1() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); test.setDurationBeforeEnd(123L); assertEquals(TEST_TIME2 - 123L, test.getStartMillis()); assertEquals(TEST_TIME2, test.getEndMillis()); } public void testSeDurationBeforeEnd_long2() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); try { test.setDurationBeforeEnd(-1); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testSetDurationBeforeEnd_RI1() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); test.setDurationBeforeEnd(new Duration(123L)); assertEquals(TEST_TIME2 - 123L, test.getStartMillis()); assertEquals(TEST_TIME2, test.getEndMillis()); } public void testSeDurationBeforeEnd_RI2() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); try { test.setDurationBeforeEnd(new Duration(-1)); fail(); } catch (IllegalArgumentException ex) {} } public void testSetDurationBeforeEnd_RI3() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); test.setDurationBeforeEnd(null); assertEquals(TEST_TIME2, test.getStartMillis()); assertEquals(TEST_TIME2, test.getEndMillis()); } //----------------------------------------------------------------------- public void testSetPeriodAfterStart_RI1() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); test.setPeriodAfterStart(new Period(123L)); assertEquals(TEST_TIME1, test.getStartMillis()); assertEquals(TEST_TIME1 + 123L, test.getEndMillis()); } public void testSePeriodAfterStart_RI2() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); try { test.setPeriodAfterStart(new Period(-1L)); fail(); } catch (IllegalArgumentException ex) {} } public void testSetPeriodAfterStart_RI3() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); test.setPeriodAfterStart(null); assertEquals(TEST_TIME1, test.getStartMillis()); assertEquals(TEST_TIME1, test.getEndMillis()); } //----------------------------------------------------------------------- public void testSetPeriodBeforeEnd_RI1() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); test.setPeriodBeforeEnd(new Period(123L)); assertEquals(TEST_TIME2 - 123L, test.getStartMillis()); assertEquals(TEST_TIME2, test.getEndMillis()); } public void testSePeriodBeforeEnd_RI2() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); try { test.setPeriodBeforeEnd(new Period(-1L)); fail(); } catch (IllegalArgumentException ex) {} } public void testSetPeriodBeforeEnd_RI3() { MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2); test.setPeriodBeforeEnd(null); assertEquals(TEST_TIME2, test.getStartMillis()); assertEquals(TEST_TIME2, test.getEndMillis()); } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.base.BasePeriod; /** * This class is a Junit unit test for MutableDuration. * * @author Stephen Colebourne */ public class TestMutablePeriod_Basics extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; // 2002-04-05 private long TEST_TIME1 = (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; // 2003-05-06 private long TEST_TIME2 = (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestMutablePeriod_Basics.class); } public TestMutablePeriod_Basics(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testTest() { assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString()); assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString()); assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString()); } //----------------------------------------------------------------------- public void testGetPeriodType() { MutablePeriod test = new MutablePeriod(); assertEquals(PeriodType.standard(), test.getPeriodType()); } public void testGetMethods() { MutablePeriod test = new MutablePeriod(); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getDays()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } public void testEqualsHashCode() { MutablePeriod test1 = new MutablePeriod(123L); MutablePeriod test2 = new MutablePeriod(123L); assertEquals(true, test1.equals(test2)); assertEquals(true, test2.equals(test1)); assertEquals(true, test1.equals(test1)); assertEquals(true, test2.equals(test2)); assertEquals(true, test1.hashCode() == test2.hashCode()); assertEquals(true, test1.hashCode() == test1.hashCode()); assertEquals(true, test2.hashCode() == test2.hashCode()); MutablePeriod test3 = new MutablePeriod(321L); assertEquals(false, test1.equals(test3)); assertEquals(false, test2.equals(test3)); assertEquals(false, test3.equals(test1)); assertEquals(false, test3.equals(test2)); assertEquals(false, test1.hashCode() == test3.hashCode()); assertEquals(false, test2.hashCode() == test3.hashCode()); assertEquals(false, test1.equals("Hello")); assertEquals(true, test1.equals(new MockMutablePeriod(123L))); assertEquals(false, test1.equals(new Period(123L, PeriodType.dayTime()))); } class MockMutablePeriod extends BasePeriod { public MockMutablePeriod(long value) { super(value, null, null); } } //----------------------------------------------------------------------- public void testSerialization() throws Exception { MutablePeriod test = new MutablePeriod(123L); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(test); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); MutablePeriod result = (MutablePeriod) ois.readObject(); ois.close(); assertEquals(test, result); } // //----------------------------------------------------------------------- // public void testAddTo1() { // long expected = TEST_TIME_NOW; // expected = ISOChronology.getInstance().years().add(expected, 1); // expected = ISOChronology.getInstance().months().add(expected, 2); // expected = ISOChronology.getInstance().weeks().add(expected, 3); // expected = ISOChronology.getInstance().days().add(expected, 4); // expected = ISOChronology.getInstance().hours().add(expected, 5); // expected = ISOChronology.getInstance().minutes().add(expected, 6); // expected = ISOChronology.getInstance().seconds().add(expected, 7); // expected = ISOChronology.getInstance().millis().add(expected, 8); // // MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); // long added = test.addTo(TEST_TIME_NOW, 1); // assertEquals(expected, added); // } // // public void testAddTo2() { // long expected = TEST_TIME_NOW; // expected = ISOChronology.getInstance().years().add(expected, -2); // expected = ISOChronology.getInstance().months().add(expected, -4); // expected = ISOChronology.getInstance().weeks().add(expected, -6); // expected = ISOChronology.getInstance().days().add(expected, -8); // expected = ISOChronology.getInstance().hours().add(expected, -10); // expected = ISOChronology.getInstance().minutes().add(expected, -12); // expected = ISOChronology.getInstance().seconds().add(expected, -14); // expected = ISOChronology.getInstance().millis().add(expected, -16); // // MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); // long added = test.addTo(TEST_TIME_NOW, -2); // assertEquals(expected, added); // } // // public void testAddTo3() { // long expected = TEST_TIME_NOW; // MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); // long added = test.addTo(TEST_TIME_NOW, 0); // assertEquals(expected, added); // } // // public void testAddTo4() { // long expected = TEST_TIME_NOW + 100L; // MutablePeriod test = new MutablePeriod(100L); // long added = test.addTo(TEST_TIME_NOW, 1); // assertEquals(expected, added); // } // // //----------------------------------------------------------------------- // public void testAddToWithChronology1() { // long expected = TEST_TIME_NOW; // expected = ISOChronology.getInstance().years().add(expected, 1); // expected = ISOChronology.getInstance().months().add(expected, 2); // expected = ISOChronology.getInstance().weeks().add(expected, 3); // expected = ISOChronology.getInstance().days().add(expected, 4); // expected = ISOChronology.getInstance().hours().add(expected, 5); // expected = ISOChronology.getInstance().minutes().add(expected, 6); // expected = ISOChronology.getInstance().seconds().add(expected, 7); // expected = ISOChronology.getInstance().millis().add(expected, 8); // // MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); // long added = test.addTo(TEST_TIME_NOW, 1, ISOChronology.getInstance()); // assertEquals(expected, added); // } // // public void testAddToWithChronology2() { // long expected = TEST_TIME_NOW; // expected = ISOChronology.getInstanceUTC().years().add(expected, -2); // expected = ISOChronology.getInstanceUTC().months().add(expected, -4); // expected = ISOChronology.getInstanceUTC().weeks().add(expected, -6); // expected = ISOChronology.getInstanceUTC().days().add(expected, -8); // expected = ISOChronology.getInstanceUTC().hours().add(expected, -10); // expected = ISOChronology.getInstanceUTC().minutes().add(expected, -12); // expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14); // expected = ISOChronology.getInstanceUTC().millis().add(expected, -16); // // MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard()); // long added = test.addTo(TEST_TIME_NOW, -2, ISOChronology.getInstanceUTC()); // chrono specified so use it // assertEquals(expected, added); // } // // public void testAddToWithChronology3() { // long expected = TEST_TIME_NOW; // expected = ISOChronology.getInstance().years().add(expected, -2); // expected = ISOChronology.getInstance().months().add(expected, -4); // expected = ISOChronology.getInstance().weeks().add(expected, -6); // expected = ISOChronology.getInstance().days().add(expected, -8); // expected = ISOChronology.getInstance().hours().add(expected, -10); // expected = ISOChronology.getInstance().minutes().add(expected, -12); // expected = ISOChronology.getInstance().seconds().add(expected, -14); // expected = ISOChronology.getInstance().millis().add(expected, -16); // // MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard()); // long added = test.addTo(TEST_TIME_NOW, -2, null); // no chrono so use default // assertEquals(expected, added); // } // // //----------------------------------------------------------------------- // public void testAddToRI1() { // long expected = TEST_TIME_NOW; // expected = ISOChronology.getInstance().years().add(expected, 1); // expected = ISOChronology.getInstance().months().add(expected, 2); // expected = ISOChronology.getInstance().weeks().add(expected, 3); // expected = ISOChronology.getInstance().days().add(expected, 4); // expected = ISOChronology.getInstance().hours().add(expected, 5); // expected = ISOChronology.getInstance().minutes().add(expected, 6); // expected = ISOChronology.getInstance().seconds().add(expected, 7); // expected = ISOChronology.getInstance().millis().add(expected, 8); // // MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); // DateTime added = test.addTo(new Instant(), 1); // Instant has no time zone, use default // assertEquals(expected, added.getMillis()); // assertEquals(ISOChronology.getInstance(), added.getChronology()); // } // // public void testAddToRI2() { // long expected = TEST_TIME_NOW; // expected = ISOChronology.getInstance().years().add(expected, -2); // expected = ISOChronology.getInstance().months().add(expected, -4); // expected = ISOChronology.getInstance().weeks().add(expected, -6); // expected = ISOChronology.getInstance().days().add(expected, -8); // expected = ISOChronology.getInstance().hours().add(expected, -10); // expected = ISOChronology.getInstance().minutes().add(expected, -12); // expected = ISOChronology.getInstance().seconds().add(expected, -14); // expected = ISOChronology.getInstance().millis().add(expected, -16); // // MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard()); // DateTime added = test.addTo(new Instant(), -2); // Instant has no time zone, use default // assertEquals(expected, added.getMillis()); // assertEquals(ISOChronology.getInstance(), added.getChronology()); // } // // public void testAddToRI3() { // long expected = TEST_TIME_NOW; // expected = ISOChronology.getInstanceUTC().years().add(expected, -2); // expected = ISOChronology.getInstanceUTC().months().add(expected, -4); // expected = ISOChronology.getInstanceUTC().weeks().add(expected, -6); // expected = ISOChronology.getInstanceUTC().days().add(expected, -8); // expected = ISOChronology.getInstanceUTC().hours().add(expected, -10); // expected = ISOChronology.getInstanceUTC().minutes().add(expected, -12); // expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14); // expected = ISOChronology.getInstanceUTC().millis().add(expected, -16); // // MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard()); // DateTime added = test.addTo(new DateTime(ISOChronology.getInstanceUTC()), -2); // DateTime has UTC time zone // assertEquals(expected, added.getMillis()); // assertEquals(ISOChronology.getInstanceUTC(), added.getChronology()); // } // // public void testAddToRI4() { // long expected = TEST_TIME_NOW; // expected = ISOChronology.getInstance(PARIS).years().add(expected, -2); // expected = ISOChronology.getInstance(PARIS).months().add(expected, -4); // expected = ISOChronology.getInstance(PARIS).weeks().add(expected, -6); // expected = ISOChronology.getInstance(PARIS).days().add(expected, -8); // expected = ISOChronology.getInstance(PARIS).hours().add(expected, -10); // expected = ISOChronology.getInstance(PARIS).minutes().add(expected, -12); // expected = ISOChronology.getInstance(PARIS).seconds().add(expected, -14); // expected = ISOChronology.getInstance(PARIS).millis().add(expected, -16); // // MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard()); // DateTime added = test.addTo(new DateTime(PARIS), -2); // DateTime has PARIS time zone // assertEquals(expected, added.getMillis()); // assertEquals(ISOChronology.getInstance(PARIS), added.getChronology()); // } // // public void testAddToRI5() { // long expected = TEST_TIME_NOW; // expected = ISOChronology.getInstance().years().add(expected, -2); // expected = ISOChronology.getInstance().months().add(expected, -4); // expected = ISOChronology.getInstance().weeks().add(expected, -6); // expected = ISOChronology.getInstance().days().add(expected, -8); // expected = ISOChronology.getInstance().hours().add(expected, -10); // expected = ISOChronology.getInstance().minutes().add(expected, -12); // expected = ISOChronology.getInstance().seconds().add(expected, -14); // expected = ISOChronology.getInstance().millis().add(expected, -16); // // MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard()); // DateTime added = test.addTo(null, -2); // null has no time zone, use default // assertEquals(expected, added.getMillis()); // assertEquals(ISOChronology.getInstance(), added.getChronology()); // } // // //----------------------------------------------------------------------- // public void testAddIntoRWI1() { // long expected = TEST_TIME_NOW; // expected = ISOChronology.getInstance().years().add(expected, 1); // expected = ISOChronology.getInstance().months().add(expected, 2); // expected = ISOChronology.getInstance().weeks().add(expected, 3); // expected = ISOChronology.getInstance().days().add(expected, 4); // expected = ISOChronology.getInstance().hours().add(expected, 5); // expected = ISOChronology.getInstance().minutes().add(expected, 6); // expected = ISOChronology.getInstance().seconds().add(expected, 7); // expected = ISOChronology.getInstance().millis().add(expected, 8); // // MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); // MutableDateTime mdt = new MutableDateTime(); // test.addInto(mdt, 1); // assertEquals(expected, mdt.getMillis()); // } // // public void testAddIntoRWI2() { // long expected = TEST_TIME_NOW; // expected = ISOChronology.getInstance().years().add(expected, -2); // expected = ISOChronology.getInstance().months().add(expected, -4); // expected = ISOChronology.getInstance().weeks().add(expected, -6); // expected = ISOChronology.getInstance().days().add(expected, -8); // expected = ISOChronology.getInstance().hours().add(expected, -10); // expected = ISOChronology.getInstance().minutes().add(expected, -12); // expected = ISOChronology.getInstance().seconds().add(expected, -14); // expected = ISOChronology.getInstance().millis().add(expected, -16); // // MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard()); // MutableDateTime mdt = new MutableDateTime(); // test.addInto(mdt, -2); // MutableDateTime has a chronology, use it // assertEquals(expected, mdt.getMillis()); // } // // public void testAddIntoRWI3() { // MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); // try { // test.addInto(null, 1); // fail(); // } catch (IllegalArgumentException ex) {} // } //----------------------------------------------------------------------- public void testToString() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); assertEquals("P1Y2M3W4DT5H6M7.008S", test.toString()); test = new MutablePeriod(0, 0, 0, 0, 0, 0, 0, 0); assertEquals("PT0S", test.toString()); test = new MutablePeriod(12345L); assertEquals("PT12.345S", test.toString()); } //----------------------------------------------------------------------- public void testToPeriod() { MutablePeriod test = new MutablePeriod(123L); Period result = test.toPeriod(); assertEquals(test, result); } public void testToMutablePeriod() { MutablePeriod test = new MutablePeriod(123L); MutablePeriod result = test.toMutablePeriod(); assertEquals(test, result); } //----------------------------------------------------------------------- // public void testToDurationMillisFrom() { // MutablePeriod test = new MutablePeriod(123L); // assertEquals(123L, test.toDurationMillisFrom(0L, null)); // } public void testToDurationFrom() { MutablePeriod test = new MutablePeriod(123L); assertEquals(new Duration(123L), test.toDurationFrom(new Instant(0L))); } //----------------------------------------------------------------------- public void testCopy() { MutablePeriod test = new MutablePeriod(123L); MutablePeriod copy = test.copy(); assertEquals(test.getPeriodType(), copy.getPeriodType()); assertEquals(test, copy); } //----------------------------------------------------------------------- public void testClone() { MutablePeriod test = new MutablePeriod(123L); MutablePeriod copy = (MutablePeriod) test.clone(); assertEquals(test.getPeriodType(), copy.getPeriodType()); assertEquals(test, copy); } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.CopticChronology; import org.joda.time.chrono.ISOChronology; /** * This class is a JUnit test for MutableDuration. * * @author Stephen Colebourne */ public class TestMutablePeriod_Constructors extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; // 2002-04-05 private long TEST_TIME1 = (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; // 2003-05-06 private long TEST_TIME2 = (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestMutablePeriod_Constructors.class); } public TestMutablePeriod_Constructors(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testParse_noFormatter() throws Throwable { assertEquals(new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 890), MutablePeriod.parse("P1Y2M3W4DT5H6M7.890S")); } //----------------------------------------------------------------------- /** * Test constructor () */ public void testConstructor1() throws Throwable { MutablePeriod test = new MutablePeriod(); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } //----------------------------------------------------------------------- /** * Test constructor (PeriodType) */ public void testConstructor_PeriodType1() throws Throwable { MutablePeriod test = new MutablePeriod(PeriodType.yearMonthDayTime()); assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } public void testConstructor_PeriodType2() throws Throwable { MutablePeriod test = new MutablePeriod((PeriodType) null); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } //----------------------------------------------------------------------- public void testConstructor_long1() throws Throwable { long length = 4 * DateTimeConstants.MILLIS_PER_DAY + 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8; MutablePeriod test = new MutablePeriod(length); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals((4 * 24) + 5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } public void testConstructor_long2() throws Throwable { long length = 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8; MutablePeriod test = new MutablePeriod(length); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } public void testConstructor_long3() throws Throwable { long length = (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; MutablePeriod test = new MutablePeriod(length); assertEquals(PeriodType.standard(), test.getPeriodType()); // only time fields are precise in AllType assertEquals(0, test.getYears()); // (4 + (3 * 7) + (2 * 30) + 365) == 450 assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals((450 * 24) + 5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } //----------------------------------------------------------------------- public void testConstructor_long_PeriodType1() throws Throwable { long length = 4 * DateTimeConstants.MILLIS_PER_DAY + 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8; MutablePeriod test = new MutablePeriod(length, (PeriodType) null); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals((4 * 24) + 5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } public void testConstructor_long_PeriodType2() throws Throwable { long length = 4 * DateTimeConstants.MILLIS_PER_DAY + 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8; MutablePeriod test = new MutablePeriod(length, PeriodType.millis()); assertEquals(PeriodType.millis(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(length, test.getMillis()); } public void testConstructor_long_PeriodType3() throws Throwable { long length = 4 * DateTimeConstants.MILLIS_PER_DAY + 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8; MutablePeriod test = new MutablePeriod(length, PeriodType.standard()); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals((4 * 24) + 5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } public void testConstructor_long_PeriodType4() throws Throwable { long length = 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8; MutablePeriod test = new MutablePeriod(length, PeriodType.standard().withMillisRemoved()); assertEquals(PeriodType.standard().withMillisRemoved(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(0, test.getMillis()); } //----------------------------------------------------------------------- public void testConstructor_long_Chronology1() throws Throwable { long length = 4 * DateTimeConstants.MILLIS_PER_DAY + 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8; MutablePeriod test = new MutablePeriod(length, ISOChronology.getInstance()); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals((4 * 24) + 5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } public void testConstructor_long_Chronology2() throws Throwable { long length = 4 * DateTimeConstants.MILLIS_PER_DAY + 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8; MutablePeriod test = new MutablePeriod(length, ISOChronology.getInstanceUTC()); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(4, test.getDays()); assertEquals(5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } public void testConstructor_long_Chronology3() throws Throwable { long length = 4 * DateTimeConstants.MILLIS_PER_DAY + 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8; MutablePeriod test = new MutablePeriod(length, (Chronology) null); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals((4 * 24) + 5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } //----------------------------------------------------------------------- public void testConstructor_long_PeriodType_Chronology1() throws Throwable { long length = 4 * DateTimeConstants.MILLIS_PER_DAY + 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8; MutablePeriod test = new MutablePeriod(length, PeriodType.time().withMillisRemoved(), ISOChronology.getInstance()); assertEquals(PeriodType.time().withMillisRemoved(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals((4 * 24) + 5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(0, test.getMillis()); } public void testConstructor_long_PeriodType_Chronology2() throws Throwable { long length = 4 * DateTimeConstants.MILLIS_PER_DAY + 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8; MutablePeriod test = new MutablePeriod(length, PeriodType.standard(), ISOChronology.getInstanceUTC()); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(4, test.getDays()); assertEquals(5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } public void testConstructor_long_PeriodType_Chronology3() throws Throwable { long length = 4 * DateTimeConstants.MILLIS_PER_DAY + 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8; MutablePeriod test = new MutablePeriod(length, PeriodType.standard(), (Chronology) null); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals((4 * 24) + 5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } public void testConstructor_long_PeriodType_Chronology4() throws Throwable { long length = 4 * DateTimeConstants.MILLIS_PER_DAY + 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8; MutablePeriod test = new MutablePeriod(length, (PeriodType) null, (Chronology) null); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals((4 * 24) + 5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } //----------------------------------------------------------------------- /** * Test constructor (4ints) */ public void testConstructor_4int1() throws Throwable { MutablePeriod test = new MutablePeriod(5, 6, 7, 8); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } //----------------------------------------------------------------------- /** * Test constructor (8ints) */ public void testConstructor_8int1() throws Throwable { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(2, test.getMonths()); assertEquals(3, test.getWeeks()); assertEquals(4, test.getDays()); assertEquals(5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } //----------------------------------------------------------------------- /** * Test constructor (8ints) */ public void testConstructor_8int__PeriodType1() throws Throwable { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, null); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(2, test.getMonths()); assertEquals(3, test.getWeeks()); assertEquals(4, test.getDays()); assertEquals(5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } public void testConstructor_8int__PeriodType2() throws Throwable { MutablePeriod test = new MutablePeriod(0, 0, 0, 0, 5, 6, 7, 8, PeriodType.dayTime()); assertEquals(PeriodType.dayTime(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } public void testConstructor_8int__PeriodType3() throws Throwable { try { new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.dayTime()); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testConstructor_long_long1() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis()); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testConstructor_long_long2() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1); MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis()); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(1, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } //----------------------------------------------------------------------- public void testConstructor_long_long_PeriodType1() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), (PeriodType) null); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testConstructor_long_long_PeriodType2() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1); MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), PeriodType.dayTime()); assertEquals(PeriodType.dayTime(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(31, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testConstructor_long_long_PeriodType3() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2004, 6, 9, 1, 1, 1, 1); MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), PeriodType.standard().withMillisRemoved()); assertEquals(PeriodType.standard().withMillisRemoved(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(0, test.getMillis()); } //----------------------------------------------------------------------- public void testConstructor_long_long_Chronology1() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0, CopticChronology.getInstance()); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1, CopticChronology.getInstance()); MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), CopticChronology.getInstance()); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testConstructor_long_long_Chronology2() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), (Chronology) null); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } //----------------------------------------------------------------------- public void testConstructor_long_long_PeriodType_Chronology1() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0, CopticChronology.getInstance()); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1, CopticChronology.getInstance()); MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), (PeriodType) null, CopticChronology.getInstance()); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testConstructor_long_long_PeriodType_Chronology2() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), (PeriodType) null, null); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } //----------------------------------------------------------------------- public void testConstructor_RI_RI1() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); MutablePeriod test = new MutablePeriod(dt1, dt2); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testConstructor_RI_RI2() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1); MutablePeriod test = new MutablePeriod(dt1, dt2); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(1, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testConstructor_RI_RI3() throws Throwable { DateTime dt1 = null; // 2002-06-09T01:00+01:00 DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1); MutablePeriod test = new MutablePeriod(dt1, dt2); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(3, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(1, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(0, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testConstructor_RI_RI4() throws Throwable { DateTime dt1 = new DateTime(2005, 7, 17, 1, 1, 1, 1); DateTime dt2 = null; // 2002-06-09T01:00+01:00 MutablePeriod test = new MutablePeriod(dt1, dt2); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(-3, test.getYears()); assertEquals(-1, test.getMonths()); assertEquals(-1, test.getWeeks()); assertEquals(-1, test.getDays()); assertEquals(0, test.getHours()); assertEquals(-1, test.getMinutes()); assertEquals(-1, test.getSeconds()); assertEquals(-1, test.getMillis()); } public void testConstructor_RI_RI5() throws Throwable { DateTime dt1 = null; // 2002-06-09T01:00+01:00 DateTime dt2 = null; // 2002-06-09T01:00+01:00 MutablePeriod test = new MutablePeriod(dt1, dt2); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } //----------------------------------------------------------------------- public void testConstructor_RI_RI_PeriodType1() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); MutablePeriod test = new MutablePeriod(dt1, dt2, null); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testConstructor_RI_RI_PeriodType2() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1); MutablePeriod test = new MutablePeriod(dt1, dt2, PeriodType.dayTime()); assertEquals(PeriodType.dayTime(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(31, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testConstructor_RI_RI_PeriodType3() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2004, 6, 9, 1, 1, 1, 1); MutablePeriod test = new MutablePeriod(dt1, dt2, PeriodType.standard().withMillisRemoved()); assertEquals(PeriodType.standard().withMillisRemoved(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(0, test.getMillis()); } public void testConstructor_RI_RI_PeriodType4() throws Throwable { DateTime dt1 = null; // 2002-06-09T01:00+01:00 DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1); MutablePeriod test = new MutablePeriod(dt1, dt2, PeriodType.standard()); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(3, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(1, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(0, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testConstructor_RI_RI_PeriodType5() throws Throwable { DateTime dt1 = null; // 2002-06-09T01:00+01:00 DateTime dt2 = null; // 2002-06-09T01:00+01:00 MutablePeriod test = new MutablePeriod(dt1, dt2, PeriodType.standard()); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } //----------------------------------------------------------------------- public void testConstructor_RI_RD1() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); Duration dur = new Interval(dt1, dt2).toDuration(); MutablePeriod test = new MutablePeriod(dt1, dur); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testConstructor_RI_RD2() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); Duration dur = null; MutablePeriod test = new MutablePeriod(dt1, dur); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } //----------------------------------------------------------------------- public void testConstructor_RI_RD_PeriodType1() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); Duration dur = new Interval(dt1, dt2).toDuration(); MutablePeriod test = new MutablePeriod(dt1, dur, PeriodType.yearDayTime()); assertEquals(PeriodType.yearDayTime(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(31, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testConstructor_RI_RD_PeriodType2() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); Duration dur = null; MutablePeriod test = new MutablePeriod(dt1, dur, (PeriodType) null); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } //----------------------------------------------------------------------- /** * Test constructor (Object) */ public void testConstructor_Object1() throws Throwable { MutablePeriod test = new MutablePeriod("P1Y2M3D"); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(2, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(3, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } public void testConstructor_Object2() throws Throwable { MutablePeriod test = new MutablePeriod((Object) null); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } public void testConstructor_Object3() throws Throwable { MutablePeriod test = new MutablePeriod(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.dayTime())); assertEquals(PeriodType.dayTime(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(1, test.getHours()); assertEquals(2, test.getMinutes()); assertEquals(3, test.getSeconds()); assertEquals(4, test.getMillis()); } public void testConstructor_Object4() throws Throwable { Period base = new Period(1, 1, 0, 1, 1, 1, 1, 1, PeriodType.standard()); MutablePeriod test = new MutablePeriod(base); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } //----------------------------------------------------------------------- /** * Test constructor (Object,PeriodType) */ public void testConstructor_Object_PeriodType1() throws Throwable { MutablePeriod test = new MutablePeriod("P1Y2M3D", PeriodType.yearMonthDayTime()); assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(2, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(3, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } public void testConstructor_Object_PeriodType2() throws Throwable { MutablePeriod test = new MutablePeriod((Object) null, PeriodType.yearMonthDayTime()); assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } public void testConstructor_Object_PeriodType3() throws Throwable { MutablePeriod test = new MutablePeriod(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.dayTime()), PeriodType.yearMonthDayTime()); assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(1, test.getHours()); assertEquals(2, test.getMinutes()); assertEquals(3, test.getSeconds()); assertEquals(4, test.getMillis()); } public void testConstructor_Object_PeriodType4() throws Throwable { MutablePeriod test = new MutablePeriod(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.dayTime()), (PeriodType) null); assertEquals(PeriodType.dayTime(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(1, test.getHours()); assertEquals(2, test.getMinutes()); assertEquals(3, test.getSeconds()); assertEquals(4, test.getMillis()); } //----------------------------------------------------------------------- public void testConstructor_Object_Chronology1() throws Throwable { long length = (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; MutablePeriod test = new MutablePeriod(new Duration(length), ISOChronology.getInstance()); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); // (4 + (3 * 7) + (2 * 30) + 365) == 450 assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals((450 * 24) + 5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } public void testConstructor_Object_Chronology2() throws Throwable { long length = (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; MutablePeriod test = new MutablePeriod(new Duration(length), ISOChronology.getInstanceUTC()); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); // (4 + (3 * 7) + (2 * 30) + 365) == 450 assertEquals(0, test.getMonths()); assertEquals(64, test.getWeeks()); assertEquals(2, test.getDays()); assertEquals(5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.ISOChronology; /** * This class is a JUnit test for MutableDuration. * * @author Stephen Colebourne */ public class TestMutablePeriod_Updates extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; // 2002-04-05 private long TEST_TIME1 = (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; // 2003-05-06 private long TEST_TIME2 = (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestMutablePeriod_Updates.class); } public TestMutablePeriod_Updates(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testTest() { assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString()); assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString()); assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString()); } //----------------------------------------------------------------------- public void testClear() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.clear(); assertEquals(new MutablePeriod(), test); test = new MutablePeriod(1, 2, 0, 4, 5, 6, 7, 8, PeriodType.yearMonthDayTime()); test.clear(); assertEquals(new MutablePeriod(PeriodType.yearMonthDayTime()), test); } //----------------------------------------------------------------------- public void testAddYears() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.addYears(10); assertEquals(11, test.getYears()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.addYears(-10); assertEquals(-9, test.getYears()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.addYears(0); assertEquals(1, test.getYears()); } //----------------------------------------------------------------------- public void testAddMonths() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.addMonths(10); assertEquals(12, test.getMonths()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.addMonths(-10); assertEquals(-8, test.getMonths()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.addMonths(0); assertEquals(2, test.getMonths()); } //----------------------------------------------------------------------- public void testAddWeeks() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.addWeeks(10); assertEquals(13, test.getWeeks()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.addWeeks(-10); assertEquals(-7, test.getWeeks()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.addWeeks(0); assertEquals(3, test.getWeeks()); } //----------------------------------------------------------------------- public void testAddDays() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.addDays(10); assertEquals(14, test.getDays()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.addDays(-10); assertEquals(-6, test.getDays()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.addDays(0); assertEquals(4, test.getDays()); } //----------------------------------------------------------------------- public void testAddHours() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.addHours(10); assertEquals(15, test.getHours()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.addHours(-10); assertEquals(-5, test.getHours()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.addHours(0); assertEquals(5, test.getHours()); } //----------------------------------------------------------------------- public void testAddMinutes() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.addMinutes(10); assertEquals(16, test.getMinutes()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.addMinutes(-10); assertEquals(-4, test.getMinutes()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.addMinutes(0); assertEquals(6, test.getMinutes()); } //----------------------------------------------------------------------- public void testAddSeconds() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.addSeconds(10); assertEquals(17, test.getSeconds()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.addSeconds(-10); assertEquals(-3, test.getSeconds()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.addSeconds(0); assertEquals(7, test.getSeconds()); } //----------------------------------------------------------------------- public void testAddMillis() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.addMillis(10); assertEquals(18, test.getMillis()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.addMillis(-10); assertEquals(-2, test.getMillis()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.addMillis(0); assertEquals(8, test.getMillis()); } //----------------------------------------------------------------------- public void testSetYears() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setYears(10); assertEquals(10, test.getYears()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setYears(-10); assertEquals(-10, test.getYears()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setYears(0); assertEquals(0, test.getYears()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setYears(1); assertEquals(1, test.getYears()); test = new MutablePeriod(0, 0, 0, 0, 0, 0, 0, 1, PeriodType.millis()); try { test.setYears(1); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testSetMonths() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setMonths(10); assertEquals(10, test.getMonths()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setMonths(-10); assertEquals(-10, test.getMonths()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setMonths(0); assertEquals(0, test.getMonths()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setMonths(2); assertEquals(2, test.getMonths()); } //----------------------------------------------------------------------- public void testSetWeeks() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setWeeks(10); assertEquals(10, test.getWeeks()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setWeeks(-10); assertEquals(-10, test.getWeeks()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setWeeks(0); assertEquals(0, test.getWeeks()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setWeeks(3); assertEquals(3, test.getWeeks()); } //----------------------------------------------------------------------- public void testSetDays() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setDays(10); assertEquals(10, test.getDays()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setDays(-10); assertEquals(-10, test.getDays()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setDays(0); assertEquals(0, test.getDays()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setDays(4); assertEquals(4, test.getDays()); } //----------------------------------------------------------------------- public void testSetHours() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setHours(10); assertEquals(10, test.getHours()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setHours(-10); assertEquals(-10, test.getHours()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setHours(0); assertEquals(0, test.getHours()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setHours(5); assertEquals(5, test.getHours()); } //----------------------------------------------------------------------- public void testSetMinutes() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setMinutes(10); assertEquals(10, test.getMinutes()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setMinutes(-10); assertEquals(-10, test.getMinutes()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setMinutes(0); assertEquals(0, test.getMinutes()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setMinutes(6); assertEquals(6, test.getMinutes()); } //----------------------------------------------------------------------- public void testSetSeconds() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setSeconds(10); assertEquals(10, test.getSeconds()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setSeconds(-10); assertEquals(-10, test.getSeconds()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setSeconds(0); assertEquals(0, test.getSeconds()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setSeconds(7); assertEquals(7, test.getSeconds()); } //----------------------------------------------------------------------- public void testSetMillis() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setMillis(10); assertEquals(10, test.getMillis()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setMillis(-10); assertEquals(-10, test.getMillis()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setMillis(0); assertEquals(0, test.getMillis()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setMillis(8); assertEquals(8, test.getMillis()); } //----------------------------------------------------------------------- public void testSet_Field() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.set(DurationFieldType.years(), 10); assertEquals(10, test.getYears()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); try { test.set(null, 10); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testAdd_Field() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.add(DurationFieldType.years(), 10); assertEquals(11, test.getYears()); test = new MutablePeriod(0, 0, 0, 0, 0, 0, 0, 1, PeriodType.millis()); test.add(DurationFieldType.years(), 0); assertEquals(0, test.getYears()); assertEquals(1, test.getMillis()); test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); try { test.add(null, 0); fail(); } catch (IllegalArgumentException ex) {} test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); try { test.add(null, 10); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testSetPeriod_8ints1() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setPeriod(11, 12, 13, 14, 15, 16, 17, 18); assertEquals(11, test.getYears()); assertEquals(12, test.getMonths()); assertEquals(13, test.getWeeks()); assertEquals(14, test.getDays()); assertEquals(15, test.getHours()); assertEquals(16, test.getMinutes()); assertEquals(17, test.getSeconds()); assertEquals(18, test.getMillis()); } public void testSetPeriod_8ints2() { MutablePeriod test = new MutablePeriod(100L, PeriodType.millis()); try { test.setPeriod(11, 12, 13, 14, 15, 16, 17, 18); fail(); } catch (IllegalArgumentException ex) {} assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(100, test.getMillis()); } public void testSetPeriod_8ints3() { MutablePeriod test = new MutablePeriod(100L, PeriodType.millis()); test.setPeriod(0, 0, 0, 0, 0, 0, 0, 18); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(18, test.getMillis()); } public void testSetPeriod_8ints4() { MutablePeriod test = new MutablePeriod(0, 0, 0, 0, 5, 6, 7, 8); test.setPeriod(11, 12, 13, 14, 15, 16, 17, 18); assertEquals(11, test.getYears()); assertEquals(12, test.getMonths()); assertEquals(13, test.getWeeks()); assertEquals(14, test.getDays()); assertEquals(15, test.getHours()); assertEquals(16, test.getMinutes()); assertEquals(17, test.getSeconds()); assertEquals(18, test.getMillis()); } //----------------------------------------------------------------------- public void testSetPeriod_RP1() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setPeriod(new MutablePeriod(11, 12, 13, 14, 15, 16, 17, 18)); assertEquals(11, test.getYears()); assertEquals(12, test.getMonths()); assertEquals(13, test.getWeeks()); assertEquals(14, test.getDays()); assertEquals(15, test.getHours()); assertEquals(16, test.getMinutes()); assertEquals(17, test.getSeconds()); assertEquals(18, test.getMillis()); } public void testSetPeriod_RP2() { MutablePeriod test = new MutablePeriod(100L, PeriodType.millis()); try { test.setPeriod(new MutablePeriod(11, 12, 13, 14, 15, 16, 17, 18)); fail(); } catch (IllegalArgumentException ex) {} assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(100, test.getMillis()); } public void testSetPeriod_RP3() { MutablePeriod test = new MutablePeriod(100L, PeriodType.millis()); test.setPeriod(new MutablePeriod(0, 0, 0, 0, 0, 0, 0, 18)); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(18, test.getMillis()); } public void testSetPeriod_RP4() { MutablePeriod test = new MutablePeriod(0, 0, 0, 0, 5, 6, 7, 8); test.setPeriod(new MutablePeriod(11, 12, 13, 14, 15, 16, 17, 18)); assertEquals(11, test.getYears()); assertEquals(12, test.getMonths()); assertEquals(13, test.getWeeks()); assertEquals(14, test.getDays()); assertEquals(15, test.getHours()); assertEquals(16, test.getMinutes()); assertEquals(17, test.getSeconds()); assertEquals(18, test.getMillis()); } public void testSetPeriod_RP5() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setPeriod((ReadablePeriod) null); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } //----------------------------------------------------------------------- public void testSetPeriod_long_long1() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19); DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20); test.setPeriod(dt1.getMillis(), dt2.getMillis()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(1, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testSetPeriod_long_long2() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19); DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20); test.setPeriod(dt2.getMillis(), dt1.getMillis()); assertEquals(-1, test.getYears()); assertEquals(-1, test.getMonths()); assertEquals(-1, test.getWeeks()); assertEquals(-1, test.getDays()); assertEquals(-1, test.getHours()); assertEquals(-1, test.getMinutes()); assertEquals(-1, test.getSeconds()); assertEquals(-1, test.getMillis()); } public void testSetPeriod_long_long3() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19); test.setPeriod(dt1.getMillis(), dt1.getMillis()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } public void testSetPeriod_long_long_NoYears() { MutablePeriod test = new MutablePeriod(PeriodType.standard().withYearsRemoved()); DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19); DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20); test.setPeriod(dt1.getMillis(), dt2.getMillis()); assertEquals(0, test.getYears()); assertEquals(13, test.getMonths()); assertEquals(1, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testSetPeriod_long_long_NoMonths() { MutablePeriod test = new MutablePeriod(PeriodType.standard().withMonthsRemoved()); DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19); DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20); test.setPeriod(dt1.getMillis(), dt2.getMillis()); assertEquals(1, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(5, test.getWeeks()); assertEquals(3, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testSetPeriod_long_long_NoWeeks() { MutablePeriod test = new MutablePeriod(PeriodType.standard().withWeeksRemoved()); DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19); DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20); test.setPeriod(dt1.getMillis(), dt2.getMillis()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(8, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testSetPeriod_long_long_NoDays() { MutablePeriod test = new MutablePeriod(PeriodType.standard().withDaysRemoved()); DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19); DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20); test.setPeriod(dt1.getMillis(), dt2.getMillis()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(1, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(25, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testSetPeriod_long_long_NoHours() { MutablePeriod test = new MutablePeriod(PeriodType.standard().withHoursRemoved()); DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19); DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20); test.setPeriod(dt1.getMillis(), dt2.getMillis()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(1, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(0, test.getHours()); assertEquals(61, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testSetPeriod_long_long_NoMinutes() { MutablePeriod test = new MutablePeriod(PeriodType.standard().withMinutesRemoved()); DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19); DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20); test.setPeriod(dt1.getMillis(), dt2.getMillis()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(1, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(1, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(61, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testSetPeriod_long_long_NoSeconds() { MutablePeriod test = new MutablePeriod(PeriodType.standard().withSecondsRemoved()); DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19); DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20); test.setPeriod(dt1.getMillis(), dt2.getMillis()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(1, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(1001, test.getMillis()); } public void testSetPeriod_long_long_NoMillis() { MutablePeriod test = new MutablePeriod(PeriodType.standard().withMillisRemoved()); DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19); DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20); test.setPeriod(dt1.getMillis(), dt2.getMillis()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(1, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(0, test.getMillis()); } //----------------------------------------------------------------------- public void testSetPeriod_RI_RI1() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19); DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20); test.setPeriod(dt1, dt2); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(1, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testSetPeriod_RI_RI2() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19); DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20); test.setPeriod(dt2, dt1); assertEquals(-1, test.getYears()); assertEquals(-1, test.getMonths()); assertEquals(-1, test.getWeeks()); assertEquals(-1, test.getDays()); assertEquals(-1, test.getHours()); assertEquals(-1, test.getMinutes()); assertEquals(-1, test.getSeconds()); assertEquals(-1, test.getMillis()); } public void testSetPeriod_RI_RI3() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19); test.setPeriod(dt1, dt1); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } //----------------------------------------------------------------------- public void testSetPeriod_RInterval1() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19); DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20); test.setPeriod(new Interval(dt1, dt2)); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(1, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testSetPeriod_RInterval2() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setPeriod((ReadableInterval) null); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } //----------------------------------------------------------------------- public void testSetPeriod_long1() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setPeriod(100L); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(100, test.getMillis()); } public void testSetPeriod_long2() { MutablePeriod test = new MutablePeriod(); test.setPeriod( (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L); // only time fields are precise assertEquals(0, test.getYears()); // (4 + (3 * 7) + (2 * 30) + 365) == 450 assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals((450 * 24) + 5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } // public void testSetPeriod_long3() { // MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType()); // test.setPeriod( // (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + // 5L * DateTimeConstants.MILLIS_PER_HOUR + // 6L * DateTimeConstants.MILLIS_PER_MINUTE + // 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L); // assertEquals(1, test.getYears()); // assertEquals(2, test.getMonths()); // assertEquals(0, test.getWeeks()); // assertEquals(25, test.getDays()); // assertEquals(5, test.getHours()); // assertEquals(6, test.getMinutes()); // assertEquals(7, test.getSeconds()); // assertEquals(8, test.getMillis()); // } // // public void testSetPeriod_long4() { // MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearWeekType()); // test.setPeriod( // (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + // 5L * DateTimeConstants.MILLIS_PER_HOUR + // 6L * DateTimeConstants.MILLIS_PER_MINUTE + // 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L); // assertEquals(1, test.getYears()); // assertEquals(0, test.getMonths()); // assertEquals(12, test.getWeeks()); // assertEquals(1, test.getDays()); // assertEquals(5, test.getHours()); // assertEquals(6, test.getMinutes()); // assertEquals(7, test.getSeconds()); // assertEquals(8, test.getMillis()); // } // // public void testSetPeriod_long_NoYears() { // long ms = // (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + // 5L * DateTimeConstants.MILLIS_PER_HOUR + // 6L * DateTimeConstants.MILLIS_PER_MINUTE + // 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; // MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withYearsRemoved()); // test.setPeriod(ms); // assertEquals(0, test.getYears()); // assertEquals(15, test.getMonths()); // totalDays=365+85=450=15*30 // assertEquals(0, test.getWeeks()); // assertEquals(0, test.getDays()); // assertEquals(5, test.getHours()); // assertEquals(6, test.getMinutes()); // assertEquals(7, test.getSeconds()); // assertEquals(8, test.getMillis()); // assertEquals(ms, test.toDurationMillis()); // } // // public void testSetPeriod_long_NoMonths() { // long ms = // (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + // 5L * DateTimeConstants.MILLIS_PER_HOUR + // 6L * DateTimeConstants.MILLIS_PER_MINUTE + // 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; // MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withMonthsRemoved()); // test.setPeriod(ms); // assertEquals(1, test.getYears()); // assertEquals(0, test.getMonths()); // assertEquals(0, test.getWeeks()); // assertEquals(85, test.getDays()); // assertEquals(5, test.getHours()); // assertEquals(6, test.getMinutes()); // assertEquals(7, test.getSeconds()); // assertEquals(8, test.getMillis()); // assertEquals(ms, test.toDurationMillis()); // } // // public void testSetPeriod_long_NoWeeks() { // long ms = // (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + // 5L * DateTimeConstants.MILLIS_PER_HOUR + // 6L * DateTimeConstants.MILLIS_PER_MINUTE + // 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; // MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearWeekType().withWeeksRemoved()); // test.setPeriod(ms); // assertEquals(1, test.getYears()); // assertEquals(0, test.getMonths()); // assertEquals(0, test.getWeeks()); // assertEquals(85, test.getDays()); // assertEquals(5, test.getHours()); // assertEquals(6, test.getMinutes()); // assertEquals(7, test.getSeconds()); // assertEquals(8, test.getMillis()); // assertEquals(ms, test.toDurationMillis()); // } // // public void testSetPeriod_long_NoDays() { // long ms = // (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + // 5L * DateTimeConstants.MILLIS_PER_HOUR + // 6L * DateTimeConstants.MILLIS_PER_MINUTE + // 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; // MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withDaysRemoved()); // test.setPeriod(ms); // assertEquals(1, test.getYears()); // assertEquals(2, test.getMonths()); // assertEquals(0, test.getWeeks()); // assertEquals(0, test.getDays()); // assertEquals(5 + 25 * 24, test.getHours()); // assertEquals(6, test.getMinutes()); // assertEquals(7, test.getSeconds()); // assertEquals(8, test.getMillis()); // assertEquals(ms, test.toDurationMillis()); // } // // public void testSetPeriod_long_NoHours() { // long ms = // (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + // 5L * DateTimeConstants.MILLIS_PER_HOUR + // 6L * DateTimeConstants.MILLIS_PER_MINUTE + // 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; // MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withHoursRemoved()); // test.setPeriod(ms); // assertEquals(1, test.getYears()); // assertEquals(2, test.getMonths()); // assertEquals(0, test.getWeeks()); // assertEquals(25, test.getDays()); // assertEquals(0, test.getHours()); // assertEquals(6 + 5 * 60, test.getMinutes()); // assertEquals(7, test.getSeconds()); // assertEquals(8, test.getMillis()); // assertEquals(ms, test.toDurationMillis()); // } // // public void testSetPeriod_long_NoMinutes() { // long ms = // (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + // 5L * DateTimeConstants.MILLIS_PER_HOUR + // 6L * DateTimeConstants.MILLIS_PER_MINUTE + // 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; // MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withMinutesRemoved()); // test.setPeriod(ms); // assertEquals(1, test.getYears()); // assertEquals(2, test.getMonths()); // assertEquals(0, test.getWeeks()); // assertEquals(25, test.getDays()); // assertEquals(5, test.getHours()); // assertEquals(0, test.getMinutes()); // assertEquals(7 + 6 * 60, test.getSeconds()); // assertEquals(8, test.getMillis()); // assertEquals(ms, test.toDurationMillis()); // } // // public void testSetPeriod_long_NoSeconds() { // long ms = // (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + // 5L * DateTimeConstants.MILLIS_PER_HOUR + // 6L * DateTimeConstants.MILLIS_PER_MINUTE + // 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; // MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withSecondsRemoved()); // test.setPeriod(ms); // assertEquals(1, test.getYears()); // assertEquals(2, test.getMonths()); // assertEquals(0, test.getWeeks()); // assertEquals(25, test.getDays()); // assertEquals(5, test.getHours()); // assertEquals(6, test.getMinutes()); // assertEquals(0, test.getSeconds()); // assertEquals(8 + 7 * 1000, test.getMillis()); // assertEquals(ms, test.toDurationMillis()); // } // // public void testSetPeriod_long_NoMillis() { // long ms = // (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + // 5L * DateTimeConstants.MILLIS_PER_HOUR + // 6L * DateTimeConstants.MILLIS_PER_MINUTE + // 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; // MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withMillisRemoved()); // test.setPeriod(ms); // assertEquals(1, test.getYears()); // assertEquals(2, test.getMonths()); // assertEquals(0, test.getWeeks()); // assertEquals(25, test.getDays()); // assertEquals(5, test.getHours()); // assertEquals(6, test.getMinutes()); // assertEquals(7, test.getSeconds()); // assertEquals(0, test.getMillis()); // assertEquals(ms - 8, test.toDurationMillis()); // } //----------------------------------------------------------------------- public void testSetPeriod_RD1() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setPeriod(new Duration(100L)); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(100, test.getMillis()); } public void testSetPeriod_RD2() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); long length = (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; test.setPeriod(new Duration(length)); // only time fields are precise assertEquals(0, test.getYears()); // (4 + (3 * 7) + (2 * 30) + 365) == 450 assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals((450 * 24) + 5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } public void testSetPeriod_RD3() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.setPeriod((ReadableDuration) null); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } //----------------------------------------------------------------------- public void testAdd_8ints1() { MutablePeriod test = new MutablePeriod(100L); test.add(1, 2, 3, 4, 5, 6, 7, 8); assertEquals(1, test.getYears()); assertEquals(2, test.getMonths()); assertEquals(3, test.getWeeks()); assertEquals(4, test.getDays()); assertEquals(5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(108, test.getMillis()); } public void testAdd_8ints2() { MutablePeriod test = new MutablePeriod(100L, PeriodType.yearMonthDayTime()); try { test.add(1, 2, 3, 4, 5, 6, 7, 8); fail(); } catch (IllegalArgumentException ex) {} assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(100, test.getMillis()); } //----------------------------------------------------------------------- public void testAdd_long1() { MutablePeriod test = new MutablePeriod(100L); test.add(100L); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(200, test.getMillis()); } public void testAdd_long2() { MutablePeriod test = new MutablePeriod(100L, PeriodType.standard()); long ms = (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; test.add(ms); // only time fields are precise assertEquals(0, test.getYears()); // (4 + (3 * 7) + (2 * 30) + 365) == 450 assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals((450 * 24) + 5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(108, test.getMillis()); } public void testAdd_long3() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.add(2100L); assertEquals(1, test.getYears()); assertEquals(2, test.getMonths()); assertEquals(3, test.getWeeks()); assertEquals(4, test.getDays()); assertEquals(5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(9, test.getSeconds()); assertEquals(108, test.getMillis()); } //----------------------------------------------------------------------- public void testAdd_long_Chronology1() { MutablePeriod test = new MutablePeriod(100L); test.add(100L, ISOChronology.getInstance()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(200, test.getMillis()); } public void testAdd_long_Chronology2() { MutablePeriod test = new MutablePeriod(100L, PeriodType.standard()); long ms = (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; test.add(ms, ISOChronology.getInstance()); // only time fields are precise assertEquals(0, test.getYears()); // (4 + (3 * 7) + (2 * 30) + 365) == 450 days assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals((450 * 24) + 5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(108, test.getMillis()); } public void testAdd_long_Chronology3() { MutablePeriod test = new MutablePeriod(100L, PeriodType.standard()); long ms = (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; test.add(ms, ISOChronology.getInstanceUTC()); // UTC, so weeks and day also precise assertEquals(0, test.getYears()); // (4 + (3 * 7) + (2 * 30) + 365) == 450 days assertEquals(0, test.getMonths()); assertEquals(64, test.getWeeks()); assertEquals(2, test.getDays()); assertEquals(5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(108, test.getMillis()); } //----------------------------------------------------------------------- public void testAdd_RD1() { MutablePeriod test = new MutablePeriod(100L); test.add(new Duration(100L)); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(200, test.getMillis()); } public void testAdd_RD2() { MutablePeriod test = new MutablePeriod(100L, PeriodType.yearMonthDayTime()); long ms = (4L + (3L * 7L)) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; test.add(new Duration(ms)); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals((4 + (3 * 7)) * 24 + 5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(108, test.getMillis()); } public void testAdd_RD3() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.add((ReadableDuration) null); assertEquals(1, test.getYears()); assertEquals(2, test.getMonths()); assertEquals(3, test.getWeeks()); assertEquals(4, test.getDays()); assertEquals(5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } //----------------------------------------------------------------------- public void testAdd_RP1() { MutablePeriod test = new MutablePeriod(100L); test.add(new Period(100L)); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(200, test.getMillis()); } public void testAdd_RP2() { MutablePeriod test = new MutablePeriod(100L, PeriodType.standard()); // All type test.add(new Period(1, 2, 3, 4, 5, 6, 7, 0, PeriodType.standard().withMillisRemoved())); // add field value, ignore different types assertEquals(1, test.getYears()); assertEquals(2, test.getMonths()); assertEquals(3, test.getWeeks()); assertEquals(4, test.getDays()); assertEquals(5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(100, test.getMillis()); } public void testAdd_RP3() { MutablePeriod test = new MutablePeriod(100L, PeriodType.standard()); test.add(new Period(0L)); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(100, test.getMillis()); } public void testAdd_RP4() { MutablePeriod test = new MutablePeriod(1, 2, 0, 4, 5, 6, 7, 8, PeriodType.yearMonthDayTime()); try { test.add(new Period(1, 2, 3, 4, 5, 6, 7, 8)); // cannot set weeks fail(); } catch (IllegalArgumentException ex) {} assertEquals(1, test.getYears()); assertEquals(2, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(4, test.getDays()); assertEquals(5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } public void testAdd_RP5() { MutablePeriod test = new MutablePeriod(1, 2, 0, 4, 5, 6, 7, 8, PeriodType.yearMonthDayTime()); test.add(new Period(1, 2, 0, 4, 5, 6, 7, 8)); // can set weeks as zero assertEquals(2, test.getYears()); assertEquals(4, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(8, test.getDays()); assertEquals(10, test.getHours()); assertEquals(12, test.getMinutes()); assertEquals(14, test.getSeconds()); assertEquals(16, test.getMillis()); } public void testAdd_RP6() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.add((ReadablePeriod) null); assertEquals(1, test.getYears()); assertEquals(2, test.getMonths()); assertEquals(3, test.getWeeks()); assertEquals(4, test.getDays()); assertEquals(5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } //----------------------------------------------------------------------- public void testAdd_RInterval1() { MutablePeriod test = new MutablePeriod(100L); test.add(new Interval(100L, 200L)); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(200, test.getMillis()); } public void testAdd_RInterval2() { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 12, 18, 0, 0, 0, 8); MutablePeriod test = new MutablePeriod(100L); // All type test.add(new Interval(dt1, dt2)); assertEquals(1, test.getYears()); // add field value from interval assertEquals(6, test.getMonths()); // add field value from interval assertEquals(1, test.getWeeks()); // add field value from interval assertEquals(2, test.getDays()); // add field value from interval assertEquals(0, test.getHours()); // time zone OK assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(108, test.getMillis()); } public void testAdd_RInterval3() { MutablePeriod test = new MutablePeriod(100L, PeriodType.yearMonthDayTime()); test.add(new Interval(0L, 0L)); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(100, test.getMillis()); } public void testAdd_RInterval4() { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 17, 0, 0, 0, 8); MutablePeriod test = new MutablePeriod(100L, PeriodType.yearMonthDayTime()); test.add(new Interval(dt1, dt2)); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(0, test.getWeeks()); // no weeks assertEquals(8, test.getDays()); // week added to days assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(108, test.getMillis()); } public void testAdd_RInterval5() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.add((ReadableInterval) null); assertEquals(1, test.getYears()); assertEquals(2, test.getMonths()); assertEquals(3, test.getWeeks()); assertEquals(4, test.getDays()); assertEquals(5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } //----------------------------------------------------------------------- public void testMergePeriod_RP1() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.mergePeriod(new MutablePeriod(0, 0, 0, 14, 15, 16, 17, 18, PeriodType.dayTime())); assertEquals(1, test.getYears()); assertEquals(2, test.getMonths()); assertEquals(3, test.getWeeks()); assertEquals(14, test.getDays()); assertEquals(15, test.getHours()); assertEquals(16, test.getMinutes()); assertEquals(17, test.getSeconds()); assertEquals(18, test.getMillis()); } public void testMergePeriod_RP2() { MutablePeriod test = new MutablePeriod(100L, PeriodType.millis()); try { test.mergePeriod(new MutablePeriod(11, 12, 13, 14, 15, 16, 17, 18)); fail(); } catch (IllegalArgumentException ex) {} assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(100, test.getMillis()); } public void testMergePeriod_RP3() { MutablePeriod test = new MutablePeriod(100L, PeriodType.millis()); test.mergePeriod(new MutablePeriod(0, 0, 0, 0, 0, 0, 0, 18)); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(18, test.getMillis()); } public void testMergePeriod_RP4() { MutablePeriod test = new MutablePeriod(0, 0, 0, 0, 5, 6, 7, 8); test.mergePeriod(new MutablePeriod(11, 12, 13, 14, 15, 16, 17, 18)); assertEquals(11, test.getYears()); assertEquals(12, test.getMonths()); assertEquals(13, test.getWeeks()); assertEquals(14, test.getDays()); assertEquals(15, test.getHours()); assertEquals(16, test.getMinutes()); assertEquals(17, test.getSeconds()); assertEquals(18, test.getMillis()); } public void testMergePeriod_RP5() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); test.mergePeriod((ReadablePeriod) null); assertEquals(1, test.getYears()); assertEquals(2, test.getMonths()); assertEquals(3, test.getWeeks()); assertEquals(4, test.getDays()); assertEquals(5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Arrays; import java.util.Locale; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.BuddhistChronology; import org.joda.time.chrono.CopticChronology; import org.joda.time.chrono.ISOChronology; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; /** * This class is a Junit unit test for Partial. * * @author Stephen Colebourne */ public class TestPartial_Basics extends TestCase { private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo"); private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS); private static final Chronology COPTIC_TOKYO = CopticChronology.getInstance(TOKYO); private static final Chronology COPTIC_UTC = CopticChronology.getInstanceUTC(); private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC(); private static final Chronology BUDDHIST_LONDON = BuddhistChronology.getInstance(LONDON); private static final Chronology BUDDHIST_TOKYO = BuddhistChronology.getInstance(TOKYO); private static final Chronology BUDDHIST_UTC = BuddhistChronology.getInstanceUTC(); private long TEST_TIME_NOW = 10L * DateTimeConstants.MILLIS_PER_HOUR + 20L * DateTimeConstants.MILLIS_PER_MINUTE + 30L * DateTimeConstants.MILLIS_PER_SECOND + 40L; private long TEST_TIME2 = 1L * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; private DateTimeZone zone = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestPartial_Basics.class); } public TestPartial_Basics(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); zone = DateTimeZone.getDefault(); DateTimeZone.setDefault(LONDON); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(zone); zone = null; } //----------------------------------------------------------------------- public void testGet() { Partial test = createHourMinPartial(); assertEquals(10, test.get(DateTimeFieldType.hourOfDay())); assertEquals(20, test.get(DateTimeFieldType.minuteOfHour())); try { test.get(null); fail(); } catch (IllegalArgumentException ex) {} try { test.get(DateTimeFieldType.secondOfMinute()); fail(); } catch (IllegalArgumentException ex) {} } public void testSize() { Partial test = createHourMinPartial(); assertEquals(2, test.size()); } public void testGetFieldType() { Partial test = createHourMinPartial(); assertSame(DateTimeFieldType.hourOfDay(), test.getFieldType(0)); assertSame(DateTimeFieldType.minuteOfHour(), test.getFieldType(1)); try { test.getFieldType(-1); } catch (IndexOutOfBoundsException ex) {} try { test.getFieldType(2); } catch (IndexOutOfBoundsException ex) {} } public void testGetFieldTypes() { Partial test = createHourMinPartial(); DateTimeFieldType[] fields = test.getFieldTypes(); assertEquals(2, fields.length); assertSame(DateTimeFieldType.hourOfDay(), fields[0]); assertSame(DateTimeFieldType.minuteOfHour(), fields[1]); assertNotSame(test.getFieldTypes(), test.getFieldTypes()); } public void testGetField() { Partial test = createHourMinPartial(COPTIC_PARIS); assertSame(CopticChronology.getInstanceUTC().hourOfDay(), test.getField(0)); assertSame(CopticChronology.getInstanceUTC().minuteOfHour(), test.getField(1)); try { test.getField(-1); } catch (IndexOutOfBoundsException ex) {} try { test.getField(5); } catch (IndexOutOfBoundsException ex) {} } public void testGetFields() { Partial test = createHourMinPartial(COPTIC_PARIS); DateTimeField[] fields = test.getFields(); assertEquals(2, fields.length); assertSame(CopticChronology.getInstanceUTC().hourOfDay(), fields[0]); assertSame(CopticChronology.getInstanceUTC().minuteOfHour(), fields[1]); assertNotSame(test.getFields(), test.getFields()); } public void testGetValue() { Partial test = createHourMinPartial(COPTIC_PARIS); assertEquals(10, test.getValue(0)); assertEquals(20, test.getValue(1)); try { test.getValue(-1); } catch (IndexOutOfBoundsException ex) {} try { test.getValue(2); } catch (IndexOutOfBoundsException ex) {} } public void testGetValues() { Partial test = createHourMinPartial(COPTIC_PARIS); int[] values = test.getValues(); assertEquals(2, values.length); assertEquals(10, values[0]); assertEquals(20, values[1]); assertNotSame(test.getValues(), test.getValues()); } public void testIsSupported() { Partial test = createHourMinPartial(COPTIC_PARIS); assertEquals(true, test.isSupported(DateTimeFieldType.hourOfDay())); assertEquals(true, test.isSupported(DateTimeFieldType.minuteOfHour())); assertEquals(false, test.isSupported(DateTimeFieldType.secondOfMinute())); assertEquals(false, test.isSupported(DateTimeFieldType.millisOfSecond())); assertEquals(false, test.isSupported(DateTimeFieldType.dayOfMonth())); } @SuppressWarnings("deprecation") public void testEqualsHashCode() { Partial test1 = createHourMinPartial(COPTIC_PARIS); Partial test2 = createHourMinPartial(COPTIC_PARIS); assertEquals(true, test1.equals(test2)); assertEquals(true, test2.equals(test1)); assertEquals(true, test1.equals(test1)); assertEquals(true, test2.equals(test2)); assertEquals(true, test1.hashCode() == test2.hashCode()); assertEquals(true, test1.hashCode() == test1.hashCode()); assertEquals(true, test2.hashCode() == test2.hashCode()); Partial test3 = createHourMinPartial2(COPTIC_PARIS); assertEquals(false, test1.equals(test3)); assertEquals(false, test2.equals(test3)); assertEquals(false, test3.equals(test1)); assertEquals(false, test3.equals(test2)); assertEquals(false, test1.hashCode() == test3.hashCode()); assertEquals(false, test2.hashCode() == test3.hashCode()); assertEquals(false, test1.equals("Hello")); assertEquals(false, test1.equals(MockPartial.EMPTY_INSTANCE)); assertEquals(new TimeOfDay(10, 20, 30, 40), createTODPartial(ISO_UTC)); } //----------------------------------------------------------------------- @SuppressWarnings("deprecation") public void testCompareTo() { Partial test1 = createHourMinPartial(); Partial test1a = createHourMinPartial(); assertEquals(0, test1.compareTo(test1a)); assertEquals(0, test1a.compareTo(test1)); assertEquals(0, test1.compareTo(test1)); assertEquals(0, test1a.compareTo(test1a)); Partial test2 = createHourMinPartial2(ISO_UTC); assertEquals(-1, test1.compareTo(test2)); assertEquals(+1, test2.compareTo(test1)); Partial test3 = createHourMinPartial2(COPTIC_UTC); assertEquals(-1, test1.compareTo(test3)); assertEquals(+1, test3.compareTo(test1)); assertEquals(0, test3.compareTo(test2)); assertEquals(0, new TimeOfDay(10, 20, 30, 40).compareTo(createTODPartial(ISO_UTC))); try { test1.compareTo(null); fail(); } catch (NullPointerException ex) {} // try { // test1.compareTo(new Date()); // fail(); // } catch (ClassCastException ex) {} try { test1.compareTo(new YearMonthDay()); fail(); } catch (ClassCastException ex) {} try { createTODPartial(ISO_UTC).without(DateTimeFieldType.hourOfDay()).compareTo(new YearMonthDay()); fail(); } catch (ClassCastException ex) {} } //----------------------------------------------------------------------- public void testIsEqual_TOD() { Partial test1 = createHourMinPartial(); Partial test1a = createHourMinPartial(); assertEquals(true, test1.isEqual(test1a)); assertEquals(true, test1a.isEqual(test1)); assertEquals(true, test1.isEqual(test1)); assertEquals(true, test1a.isEqual(test1a)); Partial test2 = createHourMinPartial2(ISO_UTC); assertEquals(false, test1.isEqual(test2)); assertEquals(false, test2.isEqual(test1)); Partial test3 = createHourMinPartial2(COPTIC_UTC); assertEquals(false, test1.isEqual(test3)); assertEquals(false, test3.isEqual(test1)); assertEquals(true, test3.isEqual(test2)); try { createHourMinPartial().isEqual(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testIsBefore_TOD() { Partial test1 = createHourMinPartial(); Partial test1a = createHourMinPartial(); assertEquals(false, test1.isBefore(test1a)); assertEquals(false, test1a.isBefore(test1)); assertEquals(false, test1.isBefore(test1)); assertEquals(false, test1a.isBefore(test1a)); Partial test2 = createHourMinPartial2(ISO_UTC); assertEquals(true, test1.isBefore(test2)); assertEquals(false, test2.isBefore(test1)); Partial test3 = createHourMinPartial2(COPTIC_UTC); assertEquals(true, test1.isBefore(test3)); assertEquals(false, test3.isBefore(test1)); assertEquals(false, test3.isBefore(test2)); try { createHourMinPartial().isBefore(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testIsAfter_TOD() { Partial test1 = createHourMinPartial(); Partial test1a = createHourMinPartial(); assertEquals(false, test1.isAfter(test1a)); assertEquals(false, test1a.isAfter(test1)); assertEquals(false, test1.isAfter(test1)); assertEquals(false, test1a.isAfter(test1a)); Partial test2 = createHourMinPartial2(ISO_UTC); assertEquals(false, test1.isAfter(test2)); assertEquals(true, test2.isAfter(test1)); Partial test3 = createHourMinPartial2(COPTIC_UTC); assertEquals(false, test1.isAfter(test3)); assertEquals(true, test3.isAfter(test1)); assertEquals(false, test3.isAfter(test2)); try { createHourMinPartial().isAfter(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testWithChronologyRetainFields_Chrono() { Partial base = createHourMinPartial(COPTIC_PARIS); Partial test = base.withChronologyRetainFields(BUDDHIST_TOKYO); check(base, 10, 20); assertEquals(COPTIC_UTC, base.getChronology()); check(test, 10, 20); assertEquals(BUDDHIST_UTC, test.getChronology()); } public void testWithChronologyRetainFields_sameChrono() { Partial base = createHourMinPartial(COPTIC_PARIS); Partial test = base.withChronologyRetainFields(COPTIC_TOKYO); assertSame(base, test); } public void testWithChronologyRetainFields_nullChrono() { Partial base = createHourMinPartial(COPTIC_PARIS); Partial test = base.withChronologyRetainFields(null); check(base, 10, 20); assertEquals(COPTIC_UTC, base.getChronology()); check(test, 10, 20); assertEquals(ISO_UTC, test.getChronology()); } //----------------------------------------------------------------------- public void testWith1() { Partial test = createHourMinPartial(); Partial result = test.with(DateTimeFieldType.hourOfDay(), 15); check(test, 10, 20); check(result, 15, 20); } public void testWith2() { Partial test = createHourMinPartial(); try { test.with(null, 6); fail(); } catch (IllegalArgumentException ex) {} check(test, 10, 20); } public void testWith3() { Partial test = createHourMinPartial(); try { test.with(DateTimeFieldType.clockhourOfDay(), 6); fail(); } catch (IllegalArgumentException ex) {} check(test, 10, 20); } public void testWith3a() { Partial test = createHourMinPartial(); Partial result = test.with(DateTimeFieldType.secondOfMinute(), 15); check(test, 10, 20); assertEquals(3, result.size()); assertEquals(true, result.isSupported(DateTimeFieldType.hourOfDay())); assertEquals(true, result.isSupported(DateTimeFieldType.minuteOfHour())); assertEquals(true, result.isSupported(DateTimeFieldType.secondOfMinute())); assertEquals(DateTimeFieldType.hourOfDay(), result.getFieldType(0)); assertEquals(DateTimeFieldType.minuteOfHour(), result.getFieldType(1)); assertEquals(DateTimeFieldType.secondOfMinute(), result.getFieldType(2)); assertEquals(10, result.get(DateTimeFieldType.hourOfDay())); assertEquals(20, result.get(DateTimeFieldType.minuteOfHour())); assertEquals(15, result.get(DateTimeFieldType.secondOfMinute())); } public void testWith3b() { Partial test = createHourMinPartial(); Partial result = test.with(DateTimeFieldType.minuteOfDay(), 15); check(test, 10, 20); assertEquals(3, result.size()); assertEquals(true, result.isSupported(DateTimeFieldType.hourOfDay())); assertEquals(true, result.isSupported(DateTimeFieldType.minuteOfDay())); assertEquals(true, result.isSupported(DateTimeFieldType.minuteOfHour())); assertEquals(DateTimeFieldType.hourOfDay(), result.getFieldType(0)); assertEquals(DateTimeFieldType.minuteOfDay(), result.getFieldType(1)); assertEquals(DateTimeFieldType.minuteOfHour(), result.getFieldType(2)); assertEquals(10, result.get(DateTimeFieldType.hourOfDay())); assertEquals(20, result.get(DateTimeFieldType.minuteOfHour())); assertEquals(15, result.get(DateTimeFieldType.minuteOfDay())); } public void testWith3c() { Partial test = createHourMinPartial(); Partial result = test.with(DateTimeFieldType.dayOfMonth(), 15); check(test, 10, 20); assertEquals(3, result.size()); assertEquals(true, result.isSupported(DateTimeFieldType.dayOfMonth())); assertEquals(true, result.isSupported(DateTimeFieldType.hourOfDay())); assertEquals(true, result.isSupported(DateTimeFieldType.minuteOfHour())); assertEquals(DateTimeFieldType.dayOfMonth(), result.getFieldType(0)); assertEquals(DateTimeFieldType.hourOfDay(), result.getFieldType(1)); assertEquals(DateTimeFieldType.minuteOfHour(), result.getFieldType(2)); assertEquals(10, result.get(DateTimeFieldType.hourOfDay())); assertEquals(20, result.get(DateTimeFieldType.minuteOfHour())); assertEquals(15, result.get(DateTimeFieldType.dayOfMonth())); } public void testWith3d() { Partial test = new Partial(DateTimeFieldType.year(), 2005); Partial result = test.with(DateTimeFieldType.monthOfYear(), 6); assertEquals(2, result.size()); assertEquals(2005, result.get(DateTimeFieldType.year())); assertEquals(6, result.get(DateTimeFieldType.monthOfYear())); } public void testWith3e() { Partial test = new Partial(DateTimeFieldType.era(), 1); Partial result = test.with(DateTimeFieldType.halfdayOfDay(), 0); assertEquals(2, result.size()); assertEquals(1, result.get(DateTimeFieldType.era())); assertEquals(0, result.get(DateTimeFieldType.halfdayOfDay())); assertEquals(0, result.indexOf(DateTimeFieldType.era())); assertEquals(1, result.indexOf(DateTimeFieldType.halfdayOfDay())); } public void testWith3f() { Partial test = new Partial(DateTimeFieldType.halfdayOfDay(), 0); Partial result = test.with(DateTimeFieldType.era(), 1); assertEquals(2, result.size()); assertEquals(1, result.get(DateTimeFieldType.era())); assertEquals(0, result.get(DateTimeFieldType.halfdayOfDay())); assertEquals(0, result.indexOf(DateTimeFieldType.era())); assertEquals(1, result.indexOf(DateTimeFieldType.halfdayOfDay())); } public void testWith4() { Partial test = createHourMinPartial(); Partial result = test.with(DateTimeFieldType.hourOfDay(), 10); assertSame(test, result); } public void testWith_baseHasNoRange() { Partial test = new Partial(DateTimeFieldType.year(), 1); Partial result = test.with(DateTimeFieldType.hourOfDay(), 10); assertEquals(2, result.size()); assertEquals(0, result.indexOf(DateTimeFieldType.year())); assertEquals(1, result.indexOf(DateTimeFieldType.hourOfDay())); } public void testWith_argHasNoRange() { Partial test = new Partial(DateTimeFieldType.hourOfDay(), 1); Partial result = test.with(DateTimeFieldType.year(), 10); assertEquals(2, result.size()); assertEquals(0, result.indexOf(DateTimeFieldType.year())); assertEquals(1, result.indexOf(DateTimeFieldType.hourOfDay())); } public void testWith_baseAndArgHaveNoRange() { Partial test = new Partial(DateTimeFieldType.year(), 1); Partial result = test.with(DateTimeFieldType.era(), 1); assertEquals(2, result.size()); assertEquals(0, result.indexOf(DateTimeFieldType.era())); assertEquals(1, result.indexOf(DateTimeFieldType.year())); } //----------------------------------------------------------------------- public void testWithout1() { Partial test = createHourMinPartial(); Partial result = test.without(DateTimeFieldType.year()); check(test, 10, 20); check(result, 10, 20); } public void testWithout2() { Partial test = createHourMinPartial(); Partial result = test.without((DateTimeFieldType) null); check(test, 10, 20); check(result, 10, 20); } public void testWithout3() { Partial test = createHourMinPartial(); Partial result = test.without(DateTimeFieldType.hourOfDay()); check(test, 10, 20); assertEquals(1, result.size()); assertEquals(false, result.isSupported(DateTimeFieldType.hourOfDay())); assertEquals(true, result.isSupported(DateTimeFieldType.minuteOfHour())); assertEquals(DateTimeFieldType.minuteOfHour(), result.getFieldType(0)); } public void testWithout4() { Partial test = createHourMinPartial(); Partial result = test.without(DateTimeFieldType.minuteOfHour()); check(test, 10, 20); assertEquals(1, result.size()); assertEquals(true, result.isSupported(DateTimeFieldType.hourOfDay())); assertEquals(false, result.isSupported(DateTimeFieldType.minuteOfHour())); assertEquals(DateTimeFieldType.hourOfDay(), result.getFieldType(0)); } public void testWithout5() { Partial test = new Partial(DateTimeFieldType.hourOfDay(), 12); Partial result = test.without(DateTimeFieldType.hourOfDay()); assertEquals(0, result.size()); assertEquals(false, result.isSupported(DateTimeFieldType.hourOfDay())); } //----------------------------------------------------------------------- public void testWithField1() { Partial test = createHourMinPartial(); Partial result = test.withField(DateTimeFieldType.hourOfDay(), 15); check(test, 10, 20); check(result, 15, 20); } public void testWithField2() { Partial test = createHourMinPartial(); try { test.withField(null, 6); fail(); } catch (IllegalArgumentException ex) {} check(test, 10, 20); } public void testWithField3() { Partial test = createHourMinPartial(); try { test.withField(DateTimeFieldType.dayOfMonth(), 6); fail(); } catch (IllegalArgumentException ex) {} check(test, 10, 20); } public void testWithField4() { Partial test = createHourMinPartial(); Partial result = test.withField(DateTimeFieldType.hourOfDay(), 10); assertSame(test, result); } //----------------------------------------------------------------------- public void testWithFieldAdded1() { Partial test = createHourMinPartial(); Partial result = test.withFieldAdded(DurationFieldType.hours(), 6); assertEquals(createHourMinPartial(), test); check(test, 10, 20); check(result, 16, 20); } public void testWithFieldAdded2() { Partial test = createHourMinPartial(); try { test.withFieldAdded(null, 0); fail(); } catch (IllegalArgumentException ex) {} check(test, 10, 20); } public void testWithFieldAdded3() { Partial test = createHourMinPartial(); try { test.withFieldAdded(null, 6); fail(); } catch (IllegalArgumentException ex) {} check(test, 10, 20); } public void testWithFieldAdded4() { Partial test = createHourMinPartial(); Partial result = test.withFieldAdded(DurationFieldType.hours(), 0); assertSame(test, result); } public void testWithFieldAdded5() { Partial test = createHourMinPartial(); try { test.withFieldAdded(DurationFieldType.days(), 6); fail(); } catch (IllegalArgumentException ex) {} check(test, 10, 20); } public void testWithFieldAdded6() { Partial test = createHourMinPartial(); try { test.withFieldAdded(DurationFieldType.hours(), 16); fail(); } catch (IllegalArgumentException ex) { // expected } check(test, 10, 20); } public void testWithFieldAdded7() { Partial test = createHourMinPartial(23, 59, ISO_UTC); try { test.withFieldAdded(DurationFieldType.minutes(), 1); fail(); } catch (IllegalArgumentException ex) { // expected } check(test, 23, 59); test = createHourMinPartial(23, 59, ISO_UTC); try { test.withFieldAdded(DurationFieldType.hours(), 1); fail(); } catch (IllegalArgumentException ex) { // expected } check(test, 23, 59); } public void testWithFieldAdded8() { Partial test = createHourMinPartial(0, 0, ISO_UTC); try { test.withFieldAdded(DurationFieldType.minutes(), -1); fail(); } catch (IllegalArgumentException ex) { // expected } check(test, 0, 0); test = createHourMinPartial(0, 0, ISO_UTC); try { test.withFieldAdded(DurationFieldType.hours(), -1); fail(); } catch (IllegalArgumentException ex) { // expected } check(test, 0, 0); } //----------------------------------------------------------------------- public void testWithFieldAddWrapped1() { Partial test = createHourMinPartial(); Partial result = test.withFieldAddWrapped(DurationFieldType.hours(), 6); assertEquals(createHourMinPartial(), test); check(test, 10, 20); check(result, 16, 20); } public void testWithFieldAddWrapped2() { Partial test = createHourMinPartial(); try { test.withFieldAddWrapped(null, 0); fail(); } catch (IllegalArgumentException ex) {} check(test, 10, 20); } public void testWithFieldAddWrapped3() { Partial test = createHourMinPartial(); try { test.withFieldAddWrapped(null, 6); fail(); } catch (IllegalArgumentException ex) {} check(test, 10, 20); } public void testWithFieldAddWrapped4() { Partial test = createHourMinPartial(); Partial result = test.withFieldAddWrapped(DurationFieldType.hours(), 0); assertSame(test, result); } public void testWithFieldAddWrapped5() { Partial test = createHourMinPartial(); try { test.withFieldAddWrapped(DurationFieldType.days(), 6); fail(); } catch (IllegalArgumentException ex) {} check(test, 10, 20); } public void testWithFieldAddWrapped6() { Partial test = createHourMinPartial(); Partial result = test.withFieldAddWrapped(DurationFieldType.hours(), 16); assertEquals(createHourMinPartial(), test); check(test, 10, 20); check(result, 2, 20); } public void testWithFieldAddWrapped7() { Partial test = createHourMinPartial(23, 59, ISO_UTC); Partial result = test.withFieldAddWrapped(DurationFieldType.minutes(), 1); check(test, 23, 59); check(result, 0, 0); test = createHourMinPartial(23, 59, ISO_UTC); result = test.withFieldAddWrapped(DurationFieldType.hours(), 1); check(test, 23, 59); check(result, 0, 59); } public void testWithFieldAddWrapped8() { Partial test = createHourMinPartial(0, 0, ISO_UTC); Partial result = test.withFieldAddWrapped(DurationFieldType.minutes(), -1); check(test, 0, 0); check(result, 23, 59); test = createHourMinPartial(0, 0, ISO_UTC); result = test.withFieldAddWrapped(DurationFieldType.hours(), -1); check(test, 0, 0); check(result, 23, 0); } //----------------------------------------------------------------------- public void testPlus_RP() { Partial test = createHourMinPartial(BUDDHIST_LONDON); Partial result = test.plus(new Period(1, 2, 3, 4, 5, 6, 7, 8)); check(test, 10, 20); check(result, 15, 26); result = test.plus((ReadablePeriod) null); assertSame(test, result); } //----------------------------------------------------------------------- public void testMinus_RP() { Partial test = createHourMinPartial(BUDDHIST_LONDON); Partial result = test.minus(new Period(1, 1, 1, 1, 1, 1, 1, 1)); check(test, 10, 20); check(result, 9, 19); result = test.minus((ReadablePeriod) null); assertSame(test, result); } //----------------------------------------------------------------------- public void testToDateTime_RI() { Partial base = createHourMinPartial(COPTIC_PARIS); DateTime dt = new DateTime(0L); // LONDON zone assertEquals("1970-01-01T01:00:00.000+01:00", dt.toString()); DateTime test = base.toDateTime(dt); check(base, 10, 20); assertEquals("1970-01-01T01:00:00.000+01:00", dt.toString()); assertEquals("1970-01-01T10:20:00.000+01:00", test.toString()); } public void testToDateTime_nullRI() { Partial base = createHourMinPartial(1, 2, ISO_UTC); DateTimeUtils.setCurrentMillisFixed(TEST_TIME2); DateTime test = base.toDateTime((ReadableInstant) null); check(base, 1, 2); assertEquals("1970-01-02T01:02:07.008+01:00", test.toString()); } //----------------------------------------------------------------------- public void testProperty() { Partial test = createHourMinPartial(); assertNotNull(test.property(DateTimeFieldType.hourOfDay())); assertNotNull(test.property(DateTimeFieldType.minuteOfHour())); try { test.property(DateTimeFieldType.secondOfDay()); fail(); } catch (IllegalArgumentException ex) {} try { test.property(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testSerialization() throws Exception { Partial test = createHourMinPartial(COPTIC_PARIS); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(test); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); Partial result = (Partial) ois.readObject(); ois.close(); assertEquals(test, result); assertTrue(Arrays.equals(test.getValues(), result.getValues())); assertTrue(Arrays.equals(test.getFields(), result.getFields())); assertEquals(test.getChronology(), result.getChronology()); } //----------------------------------------------------------------------- public void testGetFormatter1() { Partial test = new Partial(DateTimeFieldType.year(), 2005); assertEquals("2005", test.getFormatter().print(test)); test = test.with(DateTimeFieldType.monthOfYear(), 6); assertEquals("2005-06", test.getFormatter().print(test)); test = test.with(DateTimeFieldType.dayOfMonth(), 25); assertEquals("2005-06-25", test.getFormatter().print(test)); test = test.without(DateTimeFieldType.monthOfYear()); assertEquals("2005--25", test.getFormatter().print(test)); } public void testGetFormatter2() { Partial test = new Partial(); assertEquals(null, test.getFormatter()); test = test.with(DateTimeFieldType.era(), 1); assertEquals(null, test.getFormatter()); test = test.with(DateTimeFieldType.halfdayOfDay(), 0); assertEquals(null, test.getFormatter()); } public void testGetFormatter3() { Partial test = new Partial(DateTimeFieldType.dayOfWeek(), 5); assertEquals("-W-5", test.getFormatter().print(test)); // contrast with testToString5 test = test.with(DateTimeFieldType.dayOfMonth(), 13); assertEquals("---13", test.getFormatter().print(test)); } //----------------------------------------------------------------------- public void testToString1() { Partial test = createHourMinPartial(); assertEquals("10:20", test.toString()); } public void testToString2() { Partial test = new Partial(); assertEquals("[]", test.toString()); } public void testToString3() { Partial test = new Partial(DateTimeFieldType.year(), 2005); assertEquals("2005", test.toString()); test = test.with(DateTimeFieldType.monthOfYear(), 6); assertEquals("2005-06", test.toString()); test = test.with(DateTimeFieldType.dayOfMonth(), 25); assertEquals("2005-06-25", test.toString()); test = test.without(DateTimeFieldType.monthOfYear()); assertEquals("2005--25", test.toString()); } public void testToString4() { Partial test = new Partial(DateTimeFieldType.dayOfWeek(), 5); assertEquals("-W-5", test.toString()); test = test.with(DateTimeFieldType.dayOfMonth(), 13); assertEquals("[dayOfMonth=13, dayOfWeek=5]", test.toString()); } public void testToString5() { Partial test = new Partial(DateTimeFieldType.era(), 1); assertEquals("[era=1]", test.toString()); test = test.with(DateTimeFieldType.halfdayOfDay(), 0); assertEquals("[era=1, halfdayOfDay=0]", test.toString()); } //----------------------------------------------------------------------- public void testToString_String() { Partial test = createHourMinPartial(); assertEquals("\ufffd\ufffd\ufffd\ufffd 10", test.toString("yyyy HH")); assertEquals("10:20", test.toString((String) null)); } //----------------------------------------------------------------------- public void testToString_String_Locale() { Partial test = createHourMinPartial(); assertEquals("10 20", test.toString("H m", Locale.ENGLISH)); assertEquals("10:20", test.toString(null, Locale.ENGLISH)); assertEquals("10 20", test.toString("H m", null)); assertEquals("10:20", test.toString(null, null)); } //----------------------------------------------------------------------- public void testToString_DTFormatter() { Partial test = createHourMinPartial(); assertEquals("\ufffd\ufffd\ufffd\ufffd 10", test.toString(DateTimeFormat.forPattern("yyyy HH"))); assertEquals("10:20", test.toString((DateTimeFormatter) null)); } //----------------------------------------------------------------------- private Partial createHourMinPartial() { return createHourMinPartial(ISO_UTC); } private Partial createHourMinPartial(Chronology chrono) { return createHourMinPartial(10, 20, chrono); } private Partial createHourMinPartial2(Chronology chrono) { return createHourMinPartial(15, 20, chrono); } private Partial createHourMinPartial(int hour, int min, Chronology chrono) { return new Partial( new DateTimeFieldType[] {DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour()}, new int[] {hour, min}, chrono); } private Partial createTODPartial(Chronology chrono) { return new Partial( new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond()}, new int[] {10, 20, 30, 40}, chrono); } private void check(Partial test, int hour, int min) { assertEquals(test.toString(), hour, test.get(DateTimeFieldType.hourOfDay())); assertEquals(test.toString(), min, test.get(DateTimeFieldType.minuteOfHour())); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.util.Arrays; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.GregorianChronology; import org.joda.time.chrono.ISOChronology; /** * This class is a Junit unit test for Partial. * * @author Stephen Colebourne */ public class TestPartial_Constructors extends TestCase { private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC(); private static final Chronology GREGORIAN_PARIS = GregorianChronology.getInstance(PARIS); private static final Chronology GREGORIAN_UTC = GregorianChronology.getInstanceUTC(); private long TEST_TIME_NOW = 10L * DateTimeConstants.MILLIS_PER_HOUR + 20L * DateTimeConstants.MILLIS_PER_MINUTE + 30L * DateTimeConstants.MILLIS_PER_SECOND + 40L; private DateTimeZone zone = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestPartial_Constructors.class); } public TestPartial_Constructors(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); zone = DateTimeZone.getDefault(); DateTimeZone.setDefault(LONDON); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(zone); zone = null; } //----------------------------------------------------------------------- /** * Test constructor */ public void testConstructor() throws Throwable { Partial test = new Partial(); assertEquals(ISO_UTC, test.getChronology()); assertEquals(0, test.size()); } //----------------------------------------------------------------------- /** * Test constructor */ public void testConstructor_Chrono() throws Throwable { Partial test = new Partial((Chronology) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(0, test.size()); test = new Partial(GREGORIAN_PARIS); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(0, test.size()); } //----------------------------------------------------------------------- /** * Test constructor */ public void testConstructor_Type_int() throws Throwable { Partial test = new Partial(DateTimeFieldType.dayOfYear(), 4); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1, test.size()); assertEquals(4, test.getValue(0)); assertEquals(4, test.get(DateTimeFieldType.dayOfYear())); assertEquals(true, test.isSupported(DateTimeFieldType.dayOfYear())); } /** * Test constructor */ public void testConstructorEx1_Type_int() throws Throwable { try { new Partial(null, 4); fail(); } catch (IllegalArgumentException ex) { assertMessageContains(ex, "must not be null"); } } /** * Test constructor */ public void testConstructorEx2_Type_int() throws Throwable { try { new Partial(DateTimeFieldType.dayOfYear(), 0); fail(); } catch (IllegalArgumentException ex) { // expected } } //----------------------------------------------------------------------- /** * Test constructor */ public void testConstructor_Type_int_Chrono() throws Throwable { Partial test = new Partial(DateTimeFieldType.dayOfYear(), 4, GREGORIAN_PARIS); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(1, test.size()); assertEquals(4, test.getValue(0)); assertEquals(4, test.get(DateTimeFieldType.dayOfYear())); assertEquals(true, test.isSupported(DateTimeFieldType.dayOfYear())); } /** * Test constructor */ public void testConstructorEx_Type_int_Chrono() throws Throwable { try { new Partial(null, 4, ISO_UTC); fail(); } catch (IllegalArgumentException ex) { assertMessageContains(ex, "must not be null"); } } /** * Test constructor */ public void testConstructorEx2_Type_int_Chrono() throws Throwable { try { new Partial(DateTimeFieldType.dayOfYear(), 0, ISO_UTC); fail(); } catch (IllegalArgumentException ex) { // expected } } //----------------------------------------------------------------------- /** * Test constructor */ public void testConstructor_TypeArray_intArray() throws Throwable { DateTimeFieldType[] types = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.dayOfYear() }; int[] values = new int[] {2005, 33}; Partial test = new Partial(types, values); assertEquals(ISO_UTC, test.getChronology()); assertEquals(2, test.size()); assertEquals(2005, test.getValue(0)); assertEquals(2005, test.get(DateTimeFieldType.year())); assertEquals(true, test.isSupported(DateTimeFieldType.year())); assertEquals(33, test.getValue(1)); assertEquals(33, test.get(DateTimeFieldType.dayOfYear())); assertEquals(true, test.isSupported(DateTimeFieldType.dayOfYear())); assertEquals(true, Arrays.equals(test.getFieldTypes(), types)); assertEquals(true, Arrays.equals(test.getValues(), values)); } /** * Test constructor */ public void testConstructor2_TypeArray_intArray() throws Throwable { DateTimeFieldType[] types = new DateTimeFieldType[0]; int[] values = new int[0]; Partial test = new Partial(types, values); assertEquals(ISO_UTC, test.getChronology()); assertEquals(0, test.size()); } /** * Test constructor */ public void testConstructorEx1_TypeArray_intArray() throws Throwable { try { new Partial((DateTimeFieldType[]) null, new int[] {1}); fail(); } catch (IllegalArgumentException ex) { assertMessageContains(ex, "must not be null"); } } /** * Test constructor */ public void testConstructorEx3_TypeArray_intArray() throws Throwable { try { new Partial(new DateTimeFieldType[] {DateTimeFieldType.dayOfYear()}, null); fail(); } catch (IllegalArgumentException ex) { assertMessageContains(ex, "must not be null"); } } /** * Test constructor */ public void testConstructorEx5_TypeArray_intArray() throws Throwable { try { new Partial(new DateTimeFieldType[] {DateTimeFieldType.dayOfYear()}, new int[2]); fail(); } catch (IllegalArgumentException ex) { assertMessageContains(ex, "same length"); } } /** * Test constructor */ public void testConstructorEx6_TypeArray_intArray() throws Throwable { try { new Partial(new DateTimeFieldType[] {null, DateTimeFieldType.dayOfYear()}, new int[2]); fail(); } catch (IllegalArgumentException ex) { assertMessageContains(ex, "contain null"); } try { new Partial(new DateTimeFieldType[] {DateTimeFieldType.dayOfYear(), null}, new int[2]); fail(); } catch (IllegalArgumentException ex) { assertMessageContains(ex, "contain null"); } } /** * Test constructor */ public void testConstructorEx7_TypeArray_intArray() throws Throwable { int[] values = new int[] {1, 1, 1}; DateTimeFieldType[] types = new DateTimeFieldType[] { DateTimeFieldType.dayOfMonth(), DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }; try { new Partial(types, values); fail(); } catch (IllegalArgumentException ex) { assertMessageContains(ex, "must be in order", "largest-smallest"); } types = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.monthOfYear() }; try { new Partial(types, values); fail(); } catch (IllegalArgumentException ex) { assertMessageContains(ex, "must be in order", "largest-smallest"); } types = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.era(), DateTimeFieldType.monthOfYear() }; try { new Partial(types, values); fail(); } catch (IllegalArgumentException ex) { assertMessageContains(ex, "must be in order", "largest-smallest"); } types = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.era() }; try { new Partial(types, values); fail(); } catch (IllegalArgumentException ex) { assertMessageContains(ex, "must be in order", "largest-smallest"); } types = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfYear() }; try { new Partial(types, values); fail(); } catch (IllegalArgumentException ex) { assertMessageContains(ex, "must be in order", "largest-smallest"); } types = new DateTimeFieldType[] { DateTimeFieldType.yearOfEra(), DateTimeFieldType.year(), DateTimeFieldType.dayOfYear() }; try { new Partial(types, values); fail(); } catch (IllegalArgumentException ex) { assertMessageContains(ex, "must be in order", "largest-smallest"); } } /** * Test constructor */ public void testConstructorEx8_TypeArray_intArray() throws Throwable { int[] values = new int[] {1, 1, 1}; DateTimeFieldType[] types = new DateTimeFieldType[] { DateTimeFieldType.era(), DateTimeFieldType.year(), DateTimeFieldType.year() }; try { new Partial(types, values); fail(); } catch (IllegalArgumentException ex) { assertMessageContains(ex, "must not", "duplicate"); } types = new DateTimeFieldType[] { DateTimeFieldType.era(), DateTimeFieldType.era(), DateTimeFieldType.monthOfYear() }; try { new Partial(types, values); fail(); } catch (IllegalArgumentException ex) { assertMessageContains(ex, "must not", "duplicate"); } types = new DateTimeFieldType[] { DateTimeFieldType.dayOfYear(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfMonth() }; try { new Partial(types, values); fail(); } catch (IllegalArgumentException ex) { assertMessageContains(ex, "must not", "duplicate"); } types = new DateTimeFieldType[] { DateTimeFieldType.dayOfMonth(), DateTimeFieldType.clockhourOfDay(), DateTimeFieldType.hourOfDay() }; try { new Partial(types, values); fail(); } catch (IllegalArgumentException ex) { assertMessageContains(ex, "must not", "duplicate"); } } /** * Test constructor */ public void testConstructorEx9_TypeArray_intArray() throws Throwable { int[] values = new int[] {3, 0}; DateTimeFieldType[] types = new DateTimeFieldType[] { DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfWeek()}; try { new Partial(types, values); fail(); } catch (IllegalArgumentException ex) { // expected } } //----------------------------------------------------------------------- /** * Test constructor */ public void testConstructor_TypeArray_intArray_Chrono() throws Throwable { DateTimeFieldType[] types = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.dayOfYear() }; int[] values = new int[] {2005, 33}; Partial test = new Partial(types, values, GREGORIAN_PARIS); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(2, test.size()); assertEquals(2005, test.getValue(0)); assertEquals(2005, test.get(DateTimeFieldType.year())); assertEquals(true, test.isSupported(DateTimeFieldType.year())); assertEquals(33, test.getValue(1)); assertEquals(33, test.get(DateTimeFieldType.dayOfYear())); assertEquals(true, test.isSupported(DateTimeFieldType.dayOfYear())); assertEquals(true, Arrays.equals(test.getFieldTypes(), types)); assertEquals(true, Arrays.equals(test.getValues(), values)); } //----------------------------------------------------------------------- /** * Test constructor */ @SuppressWarnings("deprecation") public void testConstructor_Partial() throws Throwable { YearMonthDay ymd = new YearMonthDay(2005, 6, 25, GREGORIAN_PARIS); Partial test = new Partial(ymd); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(3, test.size()); assertEquals(2005, test.getValue(0)); assertEquals(2005, test.get(DateTimeFieldType.year())); assertEquals(true, test.isSupported(DateTimeFieldType.year())); assertEquals(6, test.getValue(1)); assertEquals(6, test.get(DateTimeFieldType.monthOfYear())); assertEquals(true, test.isSupported(DateTimeFieldType.monthOfYear())); assertEquals(25, test.getValue(2)); assertEquals(25, test.get(DateTimeFieldType.dayOfMonth())); assertEquals(true, test.isSupported(DateTimeFieldType.dayOfMonth())); } /** * Test constructor */ public void testConstructorEx_Partial() throws Throwable { try { new Partial((ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) { assertMessageContains(ex, "must not be null"); } } //----------------------------------------------------------------------- /** * Checks if the exception message is valid. * * @param ex the exception to check * @param str the string to check */ private void assertMessageContains(Exception ex, String str) { assertEquals(ex.getMessage() + ": " + str, true, ex.getMessage().indexOf(str) >= 0); } /** * Checks if the exception message is valid. * * @param ex the exception to check * @param str1 the string to check * @param str2 the string to check */ private void assertMessageContains(Exception ex, String str1, String str2) { assertEquals(ex.getMessage() + ": " + str1 + "/" + str2, true, ex.getMessage().indexOf(str1) >= 0 && ex.getMessage().indexOf(str2) >= 0 && ex.getMessage().indexOf(str1) < ex.getMessage().indexOf(str2)); } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.BuddhistChronology; import org.joda.time.chrono.CopticChronology; import org.joda.time.chrono.ISOChronology; /** * This class is a Junit unit test for Partial. * * @author Stephen Colebourne */ public class TestPartial_Match extends TestCase { private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo"); private static final int OFFSET = 1; private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS); private static final Chronology COPTIC_LONDON = CopticChronology.getInstance(LONDON); private static final Chronology COPTIC_TOKYO = CopticChronology.getInstance(TOKYO); private static final Chronology COPTIC_UTC = CopticChronology.getInstanceUTC(); private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS); private static final Chronology ISO_LONDON = ISOChronology.getInstance(LONDON); private static final Chronology ISO_TOKYO = ISOChronology.getInstance(TOKYO); private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC(); private static final Chronology BUDDHIST_PARIS = BuddhistChronology.getInstance(PARIS); private static final Chronology BUDDHIST_LONDON = BuddhistChronology.getInstance(LONDON); private static final Chronology BUDDHIST_TOKYO = BuddhistChronology.getInstance(TOKYO); private static final Chronology BUDDHIST_UTC = BuddhistChronology.getInstanceUTC(); private long TEST_TIME_NOW = 10L * DateTimeConstants.MILLIS_PER_HOUR + 20L * DateTimeConstants.MILLIS_PER_MINUTE + 30L * DateTimeConstants.MILLIS_PER_SECOND + 40L; private long TEST_TIME1 = 1L * DateTimeConstants.MILLIS_PER_HOUR + 2L * DateTimeConstants.MILLIS_PER_MINUTE + 3L * DateTimeConstants.MILLIS_PER_SECOND + 4L; private long TEST_TIME2 = 1L * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; private DateTimeZone zone = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestPartial_Match.class); } public TestPartial_Match(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); zone = DateTimeZone.getDefault(); DateTimeZone.setDefault(LONDON); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(zone); zone = null; } //----------------------------------------------------------------------- public void testIsMatch_Instant() { // Year=2005, Month=7 (July), DayOfWeek=2 (Tuesday) Partial test = createYMDwPartial(ISO_UTC, 2005, 7, 2); DateTime instant = new DateTime(2005, 7, 5, 0, 0, 0, 0); assertEquals(true, test.isMatch(instant)); instant = new DateTime(2005, 7, 4, 0, 0, 0, 0); assertEquals(false, test.isMatch(instant)); instant = new DateTime(2005, 7, 6, 0, 0, 0, 0); assertEquals(false, test.isMatch(instant)); instant = new DateTime(2005, 7, 12, 0, 0, 0, 0); assertEquals(true, test.isMatch(instant)); instant = new DateTime(2005, 7, 19, 0, 0, 0, 0); assertEquals(true, test.isMatch(instant)); instant = new DateTime(2005, 7, 26, 0, 0, 0, 0); assertEquals(true, test.isMatch(instant)); instant = new DateTime(2005, 8, 2, 0, 0, 0, 0); assertEquals(false, test.isMatch(instant)); instant = new DateTime(2006, 7, 5, 0, 0, 0, 0); assertEquals(false, test.isMatch(instant)); instant = new DateTime(2005, 6, 5, 0, 0, 0, 0); assertEquals(false, test.isMatch(instant)); } //----------------------------------------------------------------------- public void testIsMatch_Partial() { // Year=2005, Month=7 (July), DayOfWeek=2 (Tuesday) Partial test = createYMDwPartial(ISO_UTC, 2005, 7, 2); LocalDate partial = new LocalDate(2005, 7, 5); assertEquals(true, test.isMatch(partial)); partial = new LocalDate(2005, 7, 4); assertEquals(false, test.isMatch(partial)); partial = new LocalDate(2005, 7, 6); assertEquals(false, test.isMatch(partial)); partial = new LocalDate(2005, 7, 12); assertEquals(true, test.isMatch(partial)); partial = new LocalDate(2005, 7, 19); assertEquals(true, test.isMatch(partial)); partial = new LocalDate(2005, 7, 26); assertEquals(true, test.isMatch(partial)); partial = new LocalDate(2005, 8, 2); assertEquals(false, test.isMatch(partial)); partial = new LocalDate(2006, 7, 5); assertEquals(false, test.isMatch(partial)); partial = new LocalDate(2005, 6, 5); assertEquals(false, test.isMatch(partial)); try { test.isMatch((ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- private Partial createYMDwPartial(Chronology chrono, int year, int month, int dow) { return new Partial( new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfWeek()}, new int[] {year, month, dow}, chrono); } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.util.Locale; import junit.framework.TestCase; import junit.framework.TestSuite; /** * This class is a Junit unit test for Partial. * * @author Stephen Colebourne */ public class TestPartial_Properties extends TestCase { private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private DateTimeZone zone = null; private static final DateTimeFieldType[] TYPES = new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }; private static final int[] VALUES = new int[] {10, 20, 30, 40}; private static final int[] VALUES1 = new int[] {1, 2, 3, 4}; private static final int[] VALUES2 = new int[] {5, 6, 7, 8}; // private long TEST_TIME_NOW = // 10L * DateTimeConstants.MILLIS_PER_HOUR // + 20L * DateTimeConstants.MILLIS_PER_MINUTE // + 30L * DateTimeConstants.MILLIS_PER_SECOND // + 40L; // private long TEST_TIME1 = 1L * DateTimeConstants.MILLIS_PER_HOUR + 2L * DateTimeConstants.MILLIS_PER_MINUTE + 3L * DateTimeConstants.MILLIS_PER_SECOND + 4L; private long TEST_TIME2 = 1L * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestPartial_Properties.class); } public TestPartial_Properties(String name) { super(name); } protected void setUp() throws Exception { zone = DateTimeZone.getDefault(); DateTimeZone.setDefault(DateTimeZone.UTC); } protected void tearDown() throws Exception { DateTimeZone.setDefault(zone); zone = null; } //----------------------------------------------------------------------- public void testPropertyGetHour() { Partial test = new Partial(TYPES, VALUES); assertSame(test.getChronology().hourOfDay(), test.property(DateTimeFieldType.hourOfDay()).getField()); assertEquals("hourOfDay", test.property(DateTimeFieldType.hourOfDay()).getName()); assertEquals("Property[hourOfDay]", test.property(DateTimeFieldType.hourOfDay()).toString()); assertSame(test, test.property(DateTimeFieldType.hourOfDay()).getReadablePartial()); assertSame(test, test.property(DateTimeFieldType.hourOfDay()).getPartial()); assertEquals(10, test.property(DateTimeFieldType.hourOfDay()).get()); assertEquals("10", test.property(DateTimeFieldType.hourOfDay()).getAsString()); assertEquals("10", test.property(DateTimeFieldType.hourOfDay()).getAsText()); assertEquals("10", test.property(DateTimeFieldType.hourOfDay()).getAsText(Locale.FRENCH)); assertEquals("10", test.property(DateTimeFieldType.hourOfDay()).getAsShortText()); assertEquals("10", test.property(DateTimeFieldType.hourOfDay()).getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().hours(), test.property(DateTimeFieldType.hourOfDay()).getDurationField()); assertEquals(test.getChronology().days(), test.property(DateTimeFieldType.hourOfDay()).getRangeDurationField()); assertEquals(2, test.property(DateTimeFieldType.hourOfDay()).getMaximumTextLength(null)); assertEquals(2, test.property(DateTimeFieldType.hourOfDay()).getMaximumShortTextLength(null)); } public void testPropertyGetMaxMinValuesHour() { Partial test = new Partial(TYPES, VALUES); assertEquals(0, test.property(DateTimeFieldType.hourOfDay()).getMinimumValue()); assertEquals(0, test.property(DateTimeFieldType.hourOfDay()).getMinimumValueOverall()); assertEquals(23, test.property(DateTimeFieldType.hourOfDay()).getMaximumValue()); assertEquals(23, test.property(DateTimeFieldType.hourOfDay()).getMaximumValueOverall()); } // public void testPropertyAddHour() { // Partial test = new Partial(TYPES, VALUES); // Partial copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(9); // check(test, 10, 20, 30, 40); // check(copy, 19, 20, 30, 40); // // copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(0); // check(copy, 10, 20, 30, 40); // // copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(13); // check(copy, 23, 20, 30, 40); // // copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(14); // check(copy, 0, 20, 30, 40); // // copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(-10); // check(copy, 0, 20, 30, 40); // // copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(-11); // check(copy, 23, 20, 30, 40); // } // public void testPropertyAddHour() { Partial test = new Partial(TYPES, VALUES); Partial copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(9); check(test, 10, 20, 30, 40); check(copy, 19, 20, 30, 40); copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(0); check(copy, 10, 20, 30, 40); copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(13); check(copy, 23, 20, 30, 40); try { test.property(DateTimeFieldType.hourOfDay()).addToCopy(14); fail(); } catch (IllegalArgumentException ex) {} check(test, 10, 20, 30, 40); copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(-10); check(copy, 0, 20, 30, 40); try { test.property(DateTimeFieldType.hourOfDay()).addToCopy(-11); fail(); } catch (IllegalArgumentException ex) {} check(test, 10, 20, 30, 40); } public void testPropertyAddWrapFieldHour() { Partial test = new Partial(TYPES, VALUES); Partial copy = test.property(DateTimeFieldType.hourOfDay()).addWrapFieldToCopy(9); check(test, 10, 20, 30, 40); check(copy, 19, 20, 30, 40); copy = test.property(DateTimeFieldType.hourOfDay()).addWrapFieldToCopy(0); check(copy, 10, 20, 30, 40); copy = test.property(DateTimeFieldType.hourOfDay()).addWrapFieldToCopy(18); check(copy, 4, 20, 30, 40); copy = test.property(DateTimeFieldType.hourOfDay()).addWrapFieldToCopy(-15); check(copy, 19, 20, 30, 40); } public void testPropertySetHour() { Partial test = new Partial(TYPES, VALUES); Partial copy = test.property(DateTimeFieldType.hourOfDay()).setCopy(12); check(test, 10, 20, 30, 40); check(copy, 12, 20, 30, 40); try { test.property(DateTimeFieldType.hourOfDay()).setCopy(24); fail(); } catch (IllegalArgumentException ex) {} try { test.property(DateTimeFieldType.hourOfDay()).setCopy(-1); fail(); } catch (IllegalArgumentException ex) {} } public void testPropertySetTextHour() { Partial test = new Partial(TYPES, VALUES); Partial copy = test.property(DateTimeFieldType.hourOfDay()).setCopy("12"); check(test, 10, 20, 30, 40); check(copy, 12, 20, 30, 40); } public void testPropertyWithMaximumValueHour() { Partial test = new Partial(TYPES, VALUES); Partial copy = test.property(DateTimeFieldType.hourOfDay()).withMaximumValue(); check(test, 10, 20, 30, 40); check(copy, 23, 20, 30, 40); } public void testPropertyWithMinimumValueHour() { Partial test = new Partial(TYPES, VALUES); Partial copy = test.property(DateTimeFieldType.hourOfDay()).withMinimumValue(); check(test, 10, 20, 30, 40); check(copy, 0, 20, 30, 40); } public void testPropertyCompareToHour() { Partial test1 = new Partial(TYPES, VALUES1); Partial test2 = new Partial(TYPES, VALUES2); assertEquals(true, test1.property(DateTimeFieldType.hourOfDay()).compareTo(test2) < 0); assertEquals(true, test2.property(DateTimeFieldType.hourOfDay()).compareTo(test1) > 0); assertEquals(true, test1.property(DateTimeFieldType.hourOfDay()).compareTo(test1) == 0); try { test1.property(DateTimeFieldType.hourOfDay()).compareTo((ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} DateTime dt1 = new DateTime(TEST_TIME1); DateTime dt2 = new DateTime(TEST_TIME2); assertEquals(true, test1.property(DateTimeFieldType.hourOfDay()).compareTo(dt2) < 0); assertEquals(true, test2.property(DateTimeFieldType.hourOfDay()).compareTo(dt1) > 0); assertEquals(true, test1.property(DateTimeFieldType.hourOfDay()).compareTo(dt1) == 0); try { test1.property(DateTimeFieldType.hourOfDay()).compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testPropertyGetMinute() { Partial test = new Partial(TYPES, VALUES); assertSame(test.getChronology().minuteOfHour(), test.property(DateTimeFieldType.minuteOfHour()).getField()); assertEquals("minuteOfHour", test.property(DateTimeFieldType.minuteOfHour()).getName()); assertEquals("Property[minuteOfHour]", test.property(DateTimeFieldType.minuteOfHour()).toString()); assertSame(test, test.property(DateTimeFieldType.minuteOfHour()).getReadablePartial()); assertSame(test, test.property(DateTimeFieldType.minuteOfHour()).getPartial()); assertEquals(20, test.property(DateTimeFieldType.minuteOfHour()).get()); assertEquals("20", test.property(DateTimeFieldType.minuteOfHour()).getAsString()); assertEquals("20", test.property(DateTimeFieldType.minuteOfHour()).getAsText()); assertEquals("20", test.property(DateTimeFieldType.minuteOfHour()).getAsText(Locale.FRENCH)); assertEquals("20", test.property(DateTimeFieldType.minuteOfHour()).getAsShortText()); assertEquals("20", test.property(DateTimeFieldType.minuteOfHour()).getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().minutes(), test.property(DateTimeFieldType.minuteOfHour()).getDurationField()); assertEquals(test.getChronology().hours(), test.property(DateTimeFieldType.minuteOfHour()).getRangeDurationField()); assertEquals(2, test.property(DateTimeFieldType.minuteOfHour()).getMaximumTextLength(null)); assertEquals(2, test.property(DateTimeFieldType.minuteOfHour()).getMaximumShortTextLength(null)); } public void testPropertyGetMaxMinValuesMinute() { Partial test = new Partial(TYPES, VALUES); assertEquals(0, test.property(DateTimeFieldType.minuteOfHour()).getMinimumValue()); assertEquals(0, test.property(DateTimeFieldType.minuteOfHour()).getMinimumValueOverall()); assertEquals(59, test.property(DateTimeFieldType.minuteOfHour()).getMaximumValue()); assertEquals(59, test.property(DateTimeFieldType.minuteOfHour()).getMaximumValueOverall()); } // public void testPropertyAddMinute() { // Partial test = new Partial(TYPES, VALUES); // Partial copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(9); // check(test, 10, 20, 30, 40); // check(copy, 10, 29, 30, 40); // // copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(39); // check(copy, 10, 59, 30, 40); // // copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(40); // check(copy, 11, 0, 30, 40); // // copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(1 * 60 + 45); // check(copy, 12, 5, 30, 40); // // copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(13 * 60 + 39); // check(copy, 23, 59, 30, 40); // // copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(13 * 60 + 40); // check(copy, 0, 0, 30, 40); // // copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-9); // check(copy, 10, 11, 30, 40); // // copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-19); // check(copy, 10, 1, 30, 40); // // copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-20); // check(copy, 10, 0, 30, 40); // // copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-21); // check(copy, 9, 59, 30, 40); // // copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-(10 * 60 + 20)); // check(copy, 0, 0, 30, 40); // // copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-(10 * 60 + 21)); // check(copy, 23, 59, 30, 40); // } public void testPropertyAddMinute() { Partial test = new Partial(TYPES, VALUES); Partial copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(9); check(test, 10, 20, 30, 40); check(copy, 10, 29, 30, 40); copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(39); check(copy, 10, 59, 30, 40); copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(40); check(copy, 11, 0, 30, 40); copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(1 * 60 + 45); check(copy, 12, 5, 30, 40); copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(13 * 60 + 39); check(copy, 23, 59, 30, 40); try { test.property(DateTimeFieldType.minuteOfHour()).addToCopy(13 * 60 + 40); fail(); } catch (IllegalArgumentException ex) {} check(test, 10, 20, 30, 40); copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-9); check(copy, 10, 11, 30, 40); copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-19); check(copy, 10, 1, 30, 40); copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-20); check(copy, 10, 0, 30, 40); copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-21); check(copy, 9, 59, 30, 40); copy = test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-(10 * 60 + 20)); check(copy, 0, 0, 30, 40); try { test.property(DateTimeFieldType.minuteOfHour()).addToCopy(-(10 * 60 + 21)); fail(); } catch (IllegalArgumentException ex) {} check(test, 10, 20, 30, 40); } public void testPropertyAddWrapFieldMinute() { Partial test = new Partial(TYPES, VALUES); Partial copy = test.property(DateTimeFieldType.minuteOfHour()).addWrapFieldToCopy(9); check(test, 10, 20, 30, 40); check(copy, 10, 29, 30, 40); copy = test.property(DateTimeFieldType.minuteOfHour()).addWrapFieldToCopy(49); check(copy, 10, 9, 30, 40); copy = test.property(DateTimeFieldType.minuteOfHour()).addWrapFieldToCopy(-47); check(copy, 10, 33, 30, 40); } public void testPropertySetMinute() { Partial test = new Partial(TYPES, VALUES); Partial copy = test.property(DateTimeFieldType.minuteOfHour()).setCopy(12); check(test, 10, 20, 30, 40); check(copy, 10, 12, 30, 40); try { test.property(DateTimeFieldType.minuteOfHour()).setCopy(60); fail(); } catch (IllegalArgumentException ex) {} try { test.property(DateTimeFieldType.minuteOfHour()).setCopy(-1); fail(); } catch (IllegalArgumentException ex) {} } public void testPropertySetTextMinute() { Partial test = new Partial(TYPES, VALUES); Partial copy = test.property(DateTimeFieldType.minuteOfHour()).setCopy("12"); check(test, 10, 20, 30, 40); check(copy, 10, 12, 30, 40); } public void testPropertyCompareToMinute() { Partial test1 = new Partial(TYPES, VALUES1); Partial test2 = new Partial(TYPES, VALUES2); assertEquals(true, test1.property(DateTimeFieldType.minuteOfHour()).compareTo(test2) < 0); assertEquals(true, test2.property(DateTimeFieldType.minuteOfHour()).compareTo(test1) > 0); assertEquals(true, test1.property(DateTimeFieldType.minuteOfHour()).compareTo(test1) == 0); try { test1.property(DateTimeFieldType.minuteOfHour()).compareTo((ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} DateTime dt1 = new DateTime(TEST_TIME1); DateTime dt2 = new DateTime(TEST_TIME2); assertEquals(true, test1.property(DateTimeFieldType.minuteOfHour()).compareTo(dt2) < 0); assertEquals(true, test2.property(DateTimeFieldType.minuteOfHour()).compareTo(dt1) > 0); assertEquals(true, test1.property(DateTimeFieldType.minuteOfHour()).compareTo(dt1) == 0); try { test1.property(DateTimeFieldType.minuteOfHour()).compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- private void check(Partial test, int hour, int min, int sec, int milli) { assertEquals(hour, test.get(DateTimeFieldType.hourOfDay())); assertEquals(min, test.get(DateTimeFieldType.minuteOfHour())); assertEquals(sec, test.get(DateTimeFieldType.secondOfMinute())); assertEquals(milli, test.get(DateTimeFieldType.millisOfSecond())); } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; /** * This class is a JUnit test for PeriodType. * * @author Stephen Colebourne */ public class TestPeriodType extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; // 2002-04-05 private long TEST_TIME1 = (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; // 2003-05-06 private long TEST_TIME2 = (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestPeriodType.class); } public TestPeriodType(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testTest() { assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString()); assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString()); assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString()); } //----------------------------------------------------------------------- private void assertEqualsAfterSerialization(PeriodType type) throws Exception { ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(type); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); PeriodType result = (PeriodType) ois.readObject(); ois.close(); assertEquals(type, result); } private void assertSameAfterSerialization(PeriodType type) throws Exception { ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(type); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); PeriodType result = (PeriodType) ois.readObject(); ois.close(); assertEquals(type, result); } //----------------------------------------------------------------------- public void testStandard() throws Exception { PeriodType type = PeriodType.standard(); assertEquals(8, type.size()); assertEquals(DurationFieldType.years(), type.getFieldType(0)); assertEquals(DurationFieldType.months(), type.getFieldType(1)); assertEquals(DurationFieldType.weeks(), type.getFieldType(2)); assertEquals(DurationFieldType.days(), type.getFieldType(3)); assertEquals(DurationFieldType.hours(), type.getFieldType(4)); assertEquals(DurationFieldType.minutes(), type.getFieldType(5)); assertEquals(DurationFieldType.seconds(), type.getFieldType(6)); assertEquals(DurationFieldType.millis(), type.getFieldType(7)); assertEquals("Standard", type.getName()); assertEquals("PeriodType[Standard]", type.toString()); assertEquals(true, type.equals(type)); assertEquals(true, type == PeriodType.standard()); assertEquals(false, type.equals(PeriodType.millis())); assertEquals(true, type.hashCode() == type.hashCode()); assertEquals(true, type.hashCode() == PeriodType.standard().hashCode()); assertEquals(false, type.hashCode() == PeriodType.millis().hashCode()); assertSameAfterSerialization(type); } //----------------------------------------------------------------------- public void testYearMonthDayTime() throws Exception { PeriodType type = PeriodType.yearMonthDayTime(); assertEquals(7, type.size()); assertEquals(DurationFieldType.years(), type.getFieldType(0)); assertEquals(DurationFieldType.months(), type.getFieldType(1)); assertEquals(DurationFieldType.days(), type.getFieldType(2)); assertEquals(DurationFieldType.hours(), type.getFieldType(3)); assertEquals(DurationFieldType.minutes(), type.getFieldType(4)); assertEquals(DurationFieldType.seconds(), type.getFieldType(5)); assertEquals(DurationFieldType.millis(), type.getFieldType(6)); assertEquals("YearMonthDayTime", type.getName()); assertEquals("PeriodType[YearMonthDayTime]", type.toString()); assertEquals(true, type.equals(type)); assertEquals(true, type == PeriodType.yearMonthDayTime()); assertEquals(false, type.equals(PeriodType.millis())); assertEquals(true, type.hashCode() == type.hashCode()); assertEquals(true, type.hashCode() == PeriodType.yearMonthDayTime().hashCode()); assertEquals(false, type.hashCode() == PeriodType.millis().hashCode()); assertSameAfterSerialization(type); } //----------------------------------------------------------------------- public void testYearMonthDay() throws Exception { PeriodType type = PeriodType.yearMonthDay(); assertEquals(3, type.size()); assertEquals(DurationFieldType.years(), type.getFieldType(0)); assertEquals(DurationFieldType.months(), type.getFieldType(1)); assertEquals(DurationFieldType.days(), type.getFieldType(2)); assertEquals("YearMonthDay", type.getName()); assertEquals("PeriodType[YearMonthDay]", type.toString()); assertEquals(true, type.equals(type)); assertEquals(true, type == PeriodType.yearMonthDay()); assertEquals(false, type.equals(PeriodType.millis())); assertEquals(true, type.hashCode() == type.hashCode()); assertEquals(true, type.hashCode() == PeriodType.yearMonthDay().hashCode()); assertEquals(false, type.hashCode() == PeriodType.millis().hashCode()); assertSameAfterSerialization(type); } //----------------------------------------------------------------------- public void testYearWeekDayTime() throws Exception { PeriodType type = PeriodType.yearWeekDayTime(); assertEquals(7, type.size()); assertEquals(DurationFieldType.years(), type.getFieldType(0)); assertEquals(DurationFieldType.weeks(), type.getFieldType(1)); assertEquals(DurationFieldType.days(), type.getFieldType(2)); assertEquals(DurationFieldType.hours(), type.getFieldType(3)); assertEquals(DurationFieldType.minutes(), type.getFieldType(4)); assertEquals(DurationFieldType.seconds(), type.getFieldType(5)); assertEquals(DurationFieldType.millis(), type.getFieldType(6)); assertEquals("YearWeekDayTime", type.getName()); assertEquals("PeriodType[YearWeekDayTime]", type.toString()); assertEquals(true, type.equals(type)); assertEquals(true, type == PeriodType.yearWeekDayTime()); assertEquals(false, type.equals(PeriodType.millis())); assertEquals(true, type.hashCode() == type.hashCode()); assertEquals(true, type.hashCode() == PeriodType.yearWeekDayTime().hashCode()); assertEquals(false, type.hashCode() == PeriodType.millis().hashCode()); assertSameAfterSerialization(type); } //----------------------------------------------------------------------- public void testYearWeekDay() throws Exception { PeriodType type = PeriodType.yearWeekDay(); assertEquals(3, type.size()); assertEquals(DurationFieldType.years(), type.getFieldType(0)); assertEquals(DurationFieldType.weeks(), type.getFieldType(1)); assertEquals(DurationFieldType.days(), type.getFieldType(2)); assertEquals("YearWeekDay", type.getName()); assertEquals("PeriodType[YearWeekDay]", type.toString()); assertEquals(true, type.equals(type)); assertEquals(true, type == PeriodType.yearWeekDay()); assertEquals(false, type.equals(PeriodType.millis())); assertEquals(true, type.hashCode() == type.hashCode()); assertEquals(true, type.hashCode() == PeriodType.yearWeekDay().hashCode()); assertEquals(false, type.hashCode() == PeriodType.millis().hashCode()); assertSameAfterSerialization(type); } //----------------------------------------------------------------------- public void testYearDayTime() throws Exception { PeriodType type = PeriodType.yearDayTime(); assertEquals(6, type.size()); assertEquals(DurationFieldType.years(), type.getFieldType(0)); assertEquals(DurationFieldType.days(), type.getFieldType(1)); assertEquals(DurationFieldType.hours(), type.getFieldType(2)); assertEquals(DurationFieldType.minutes(), type.getFieldType(3)); assertEquals(DurationFieldType.seconds(), type.getFieldType(4)); assertEquals(DurationFieldType.millis(), type.getFieldType(5)); assertEquals("YearDayTime", type.getName()); assertEquals("PeriodType[YearDayTime]", type.toString()); assertEquals(true, type.equals(type)); assertEquals(true, type == PeriodType.yearDayTime()); assertEquals(false, type.equals(PeriodType.millis())); assertEquals(true, type.hashCode() == type.hashCode()); assertEquals(true, type.hashCode() == PeriodType.yearDayTime().hashCode()); assertEquals(false, type.hashCode() == PeriodType.millis().hashCode()); assertSameAfterSerialization(type); } //----------------------------------------------------------------------- public void testYearDay() throws Exception { PeriodType type = PeriodType.yearDay(); assertEquals(2, type.size()); assertEquals(DurationFieldType.years(), type.getFieldType(0)); assertEquals(DurationFieldType.days(), type.getFieldType(1)); assertEquals("YearDay", type.getName()); assertEquals("PeriodType[YearDay]", type.toString()); assertEquals(true, type.equals(type)); assertEquals(true, type == PeriodType.yearDay()); assertEquals(false, type.equals(PeriodType.millis())); assertEquals(true, type.hashCode() == type.hashCode()); assertEquals(true, type.hashCode() == PeriodType.yearDay().hashCode()); assertEquals(false, type.hashCode() == PeriodType.millis().hashCode()); assertSameAfterSerialization(type); } //----------------------------------------------------------------------- public void testDayTime() throws Exception { PeriodType type = PeriodType.dayTime(); assertEquals(5, type.size()); assertEquals(DurationFieldType.days(), type.getFieldType(0)); assertEquals(DurationFieldType.hours(), type.getFieldType(1)); assertEquals(DurationFieldType.minutes(), type.getFieldType(2)); assertEquals(DurationFieldType.seconds(), type.getFieldType(3)); assertEquals(DurationFieldType.millis(), type.getFieldType(4)); assertEquals("DayTime", type.getName()); assertEquals("PeriodType[DayTime]", type.toString()); assertEquals(true, type.equals(type)); assertEquals(true, type == PeriodType.dayTime()); assertEquals(false, type.equals(PeriodType.millis())); assertEquals(true, type.hashCode() == type.hashCode()); assertEquals(true, type.hashCode() == PeriodType.dayTime().hashCode()); assertEquals(false, type.hashCode() == PeriodType.millis().hashCode()); assertSameAfterSerialization(type); } //----------------------------------------------------------------------- public void testTime() throws Exception { PeriodType type = PeriodType.time(); assertEquals(4, type.size()); assertEquals(DurationFieldType.hours(), type.getFieldType(0)); assertEquals(DurationFieldType.minutes(), type.getFieldType(1)); assertEquals(DurationFieldType.seconds(), type.getFieldType(2)); assertEquals(DurationFieldType.millis(), type.getFieldType(3)); assertEquals("Time", type.getName()); assertEquals("PeriodType[Time]", type.toString()); assertEquals(true, type.equals(type)); assertEquals(true, type == PeriodType.time()); assertEquals(false, type.equals(PeriodType.millis())); assertEquals(true, type.hashCode() == type.hashCode()); assertEquals(true, type.hashCode() == PeriodType.time().hashCode()); assertEquals(false, type.hashCode() == PeriodType.millis().hashCode()); assertSameAfterSerialization(type); } //----------------------------------------------------------------------- public void testYears() throws Exception { PeriodType type = PeriodType.years(); assertEquals(1, type.size()); assertEquals(DurationFieldType.years(), type.getFieldType(0)); assertEquals("Years", type.getName()); assertEquals("PeriodType[Years]", type.toString()); assertEquals(true, type.equals(type)); assertEquals(true, type == PeriodType.years()); assertEquals(false, type.equals(PeriodType.standard())); assertEquals(true, type.hashCode() == type.hashCode()); assertEquals(true, type.hashCode() == PeriodType.years().hashCode()); assertEquals(false, type.hashCode() == PeriodType.standard().hashCode()); assertSameAfterSerialization(type); } //----------------------------------------------------------------------- public void testMonths() throws Exception { PeriodType type = PeriodType.months(); assertEquals(1, type.size()); assertEquals(DurationFieldType.months(), type.getFieldType(0)); assertEquals("Months", type.getName()); assertEquals("PeriodType[Months]", type.toString()); assertEquals(true, type.equals(type)); assertEquals(true, type == PeriodType.months()); assertEquals(false, type.equals(PeriodType.standard())); assertEquals(true, type.hashCode() == type.hashCode()); assertEquals(true, type.hashCode() == PeriodType.months().hashCode()); assertEquals(false, type.hashCode() == PeriodType.standard().hashCode()); assertSameAfterSerialization(type); } //----------------------------------------------------------------------- public void testWeeks() throws Exception { PeriodType type = PeriodType.weeks(); assertEquals(1, type.size()); assertEquals(DurationFieldType.weeks(), type.getFieldType(0)); assertEquals("Weeks", type.getName()); assertEquals("PeriodType[Weeks]", type.toString()); assertEquals(true, type.equals(type)); assertEquals(true, type == PeriodType.weeks()); assertEquals(false, type.equals(PeriodType.standard())); assertEquals(true, type.hashCode() == type.hashCode()); assertEquals(true, type.hashCode() == PeriodType.weeks().hashCode()); assertEquals(false, type.hashCode() == PeriodType.standard().hashCode()); assertSameAfterSerialization(type); } //----------------------------------------------------------------------- public void testDays() throws Exception { PeriodType type = PeriodType.days(); assertEquals(1, type.size()); assertEquals(DurationFieldType.days(), type.getFieldType(0)); assertEquals("Days", type.getName()); assertEquals("PeriodType[Days]", type.toString()); assertEquals(true, type.equals(type)); assertEquals(true, type == PeriodType.days()); assertEquals(false, type.equals(PeriodType.standard())); assertEquals(true, type.hashCode() == type.hashCode()); assertEquals(true, type.hashCode() == PeriodType.days().hashCode()); assertEquals(false, type.hashCode() == PeriodType.standard().hashCode()); assertSameAfterSerialization(type); } //----------------------------------------------------------------------- public void testHours() throws Exception { PeriodType type = PeriodType.hours(); assertEquals(1, type.size()); assertEquals(DurationFieldType.hours(), type.getFieldType(0)); assertEquals("Hours", type.getName()); assertEquals("PeriodType[Hours]", type.toString()); assertEquals(true, type.equals(type)); assertEquals(true, type == PeriodType.hours()); assertEquals(false, type.equals(PeriodType.standard())); assertEquals(true, type.hashCode() == type.hashCode()); assertEquals(true, type.hashCode() == PeriodType.hours().hashCode()); assertEquals(false, type.hashCode() == PeriodType.standard().hashCode()); assertSameAfterSerialization(type); } //----------------------------------------------------------------------- public void testMinutes() throws Exception { PeriodType type = PeriodType.minutes(); assertEquals(1, type.size()); assertEquals(DurationFieldType.minutes(), type.getFieldType(0)); assertEquals("Minutes", type.getName()); assertEquals("PeriodType[Minutes]", type.toString()); assertEquals(true, type.equals(type)); assertEquals(true, type == PeriodType.minutes()); assertEquals(false, type.equals(PeriodType.standard())); assertEquals(true, type.hashCode() == type.hashCode()); assertEquals(true, type.hashCode() == PeriodType.minutes().hashCode()); assertEquals(false, type.hashCode() == PeriodType.standard().hashCode()); assertSameAfterSerialization(type); } //----------------------------------------------------------------------- public void testSeconds() throws Exception { PeriodType type = PeriodType.seconds(); assertEquals(1, type.size()); assertEquals(DurationFieldType.seconds(), type.getFieldType(0)); assertEquals("Seconds", type.getName()); assertEquals("PeriodType[Seconds]", type.toString()); assertEquals(true, type.equals(type)); assertEquals(true, type == PeriodType.seconds()); assertEquals(false, type.equals(PeriodType.standard())); assertEquals(true, type.hashCode() == type.hashCode()); assertEquals(true, type.hashCode() == PeriodType.seconds().hashCode()); assertEquals(false, type.hashCode() == PeriodType.standard().hashCode()); assertSameAfterSerialization(type); } //----------------------------------------------------------------------- public void testMillis() throws Exception { PeriodType type = PeriodType.millis(); assertEquals(1, type.size()); assertEquals(DurationFieldType.millis(), type.getFieldType(0)); assertEquals("Millis", type.getName()); assertEquals("PeriodType[Millis]", type.toString()); assertEquals(true, type.equals(type)); assertEquals(true, type == PeriodType.millis()); assertEquals(false, type.equals(PeriodType.standard())); assertEquals(true, type.hashCode() == type.hashCode()); assertEquals(true, type.hashCode() == PeriodType.millis().hashCode()); assertEquals(false, type.hashCode() == PeriodType.standard().hashCode()); assertSameAfterSerialization(type); } //----------------------------------------------------------------------- public void testForFields1() throws Exception { PeriodType type = PeriodType.forFields(new DurationFieldType[] { DurationFieldType.years(), }); assertSame(PeriodType.years(), type); type = PeriodType.forFields(new DurationFieldType[] { DurationFieldType.months(), }); assertSame(PeriodType.months(), type); type = PeriodType.forFields(new DurationFieldType[] { DurationFieldType.weeks(), }); assertSame(PeriodType.weeks(), type); type = PeriodType.forFields(new DurationFieldType[] { DurationFieldType.days(), }); assertSame(PeriodType.days(), type); type = PeriodType.forFields(new DurationFieldType[] { DurationFieldType.hours(), }); assertSame(PeriodType.hours(), type); type = PeriodType.forFields(new DurationFieldType[] { DurationFieldType.minutes(), }); assertSame(PeriodType.minutes(), type); type = PeriodType.forFields(new DurationFieldType[] { DurationFieldType.seconds(), }); assertSame(PeriodType.seconds(), type); type = PeriodType.forFields(new DurationFieldType[] { DurationFieldType.millis(), }); assertSame(PeriodType.millis(), type); } public void testForFields2() throws Exception { DurationFieldType[] types = new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.hours(), }; PeriodType type = PeriodType.forFields(types); assertEquals(2, type.size()); assertEquals(DurationFieldType.years(), type.getFieldType(0)); assertEquals(DurationFieldType.hours(), type.getFieldType(1)); assertEquals("StandardNoMonthsNoWeeksNoDaysNoMinutesNoSecondsNoMillis", type.getName()); assertEquals("PeriodType[StandardNoMonthsNoWeeksNoDaysNoMinutesNoSecondsNoMillis]", type.toString()); assertEquals(true, type.equals(type)); assertEquals(true, type == PeriodType.forFields(types)); assertEquals(false, type.equals(PeriodType.millis())); assertEquals(true, type.hashCode() == type.hashCode()); assertEquals(true, type.hashCode() == PeriodType.forFields(types).hashCode()); assertEquals(false, type.hashCode() == PeriodType.millis().hashCode()); assertSameAfterSerialization(type); } public void testForFields3() throws Exception { DurationFieldType[] types = new DurationFieldType[] { DurationFieldType.months(), DurationFieldType.weeks(), }; PeriodType type = PeriodType.forFields(types); assertEquals(2, type.size()); assertEquals(DurationFieldType.months(), type.getFieldType(0)); assertEquals(DurationFieldType.weeks(), type.getFieldType(1)); assertEquals("StandardNoYearsNoDaysNoHoursNoMinutesNoSecondsNoMillis", type.getName()); assertEquals("PeriodType[StandardNoYearsNoDaysNoHoursNoMinutesNoSecondsNoMillis]", type.toString()); assertEquals(true, type.equals(type)); assertEquals(true, type == PeriodType.forFields(types)); assertEquals(false, type.equals(PeriodType.millis())); assertEquals(true, type.hashCode() == type.hashCode()); assertEquals(true, type.hashCode() == PeriodType.forFields(types).hashCode()); assertEquals(false, type.hashCode() == PeriodType.millis().hashCode()); assertSameAfterSerialization(type); } public void testForFields4() throws Exception { DurationFieldType[] types = new DurationFieldType[] { DurationFieldType.weeks(), DurationFieldType.days(), // adding this makes this test unique, so cache is not pre-populated DurationFieldType.months(), }; DurationFieldType[] types2 = new DurationFieldType[] { DurationFieldType.months(), DurationFieldType.days(), DurationFieldType.weeks(), }; PeriodType type = PeriodType.forFields(types); PeriodType type2 = PeriodType.forFields(types2); assertEquals(true, type == type2); } public void testForFields5() throws Exception { DurationFieldType[] types = new DurationFieldType[] { DurationFieldType.centuries(), DurationFieldType.months(), }; try { PeriodType.forFields(types); fail(); } catch (IllegalArgumentException ex) { // expected } try { PeriodType.forFields(types); // repeated for test coverage of cache fail(); } catch (IllegalArgumentException ex) { // expected } } public void testForFields6() throws Exception { DurationFieldType[] types = null; try { PeriodType.forFields(types); fail(); } catch (IllegalArgumentException ex) { // expected } types = new DurationFieldType[0]; try { PeriodType.forFields(types); fail(); } catch (IllegalArgumentException ex) { // expected } types = new DurationFieldType[] { null, DurationFieldType.months(), }; try { PeriodType.forFields(types); fail(); } catch (IllegalArgumentException ex) { // expected } types = new DurationFieldType[] { DurationFieldType.months(), null, }; try { PeriodType.forFields(types); fail(); } catch (IllegalArgumentException ex) { // expected } } // ensure hash key distribution public void testForFields7() throws Exception { DurationFieldType[] types = new DurationFieldType[] { DurationFieldType.weeks(), DurationFieldType.months(), }; DurationFieldType[] types2 = new DurationFieldType[] { DurationFieldType.seconds(), }; PeriodType type = PeriodType.forFields(types); PeriodType type2 = PeriodType.forFields(types2); assertEquals(false, type == type2); assertEquals(false, type.equals(type2)); assertEquals(false, type.hashCode() == type2.hashCode()); } //----------------------------------------------------------------------- public void testMaskYears() throws Exception { PeriodType type = PeriodType.standard().withYearsRemoved(); assertEquals(7, type.size()); assertEquals(DurationFieldType.months(), type.getFieldType(0)); assertEquals(DurationFieldType.weeks(), type.getFieldType(1)); assertEquals(DurationFieldType.days(), type.getFieldType(2)); assertEquals(DurationFieldType.hours(), type.getFieldType(3)); assertEquals(DurationFieldType.minutes(), type.getFieldType(4)); assertEquals(DurationFieldType.seconds(), type.getFieldType(5)); assertEquals(DurationFieldType.millis(), type.getFieldType(6)); assertEquals(true, type.equals(type)); assertEquals(true, type.equals(PeriodType.standard().withYearsRemoved())); assertEquals(false, type.equals(PeriodType.millis())); assertEquals(true, type.hashCode() == type.hashCode()); assertEquals(true, type.hashCode() == PeriodType.standard().withYearsRemoved().hashCode()); assertEquals(false, type.hashCode() == PeriodType.millis().hashCode()); assertEquals("StandardNoYears", type.getName()); assertEquals("PeriodType[StandardNoYears]", type.toString()); assertEqualsAfterSerialization(type); } //----------------------------------------------------------------------- public void testMaskMonths() throws Exception { PeriodType type = PeriodType.standard().withMonthsRemoved(); assertEquals(7, type.size()); assertEquals(DurationFieldType.years(), type.getFieldType(0)); assertEquals(DurationFieldType.weeks(), type.getFieldType(1)); assertEquals(DurationFieldType.days(), type.getFieldType(2)); assertEquals(DurationFieldType.hours(), type.getFieldType(3)); assertEquals(DurationFieldType.minutes(), type.getFieldType(4)); assertEquals(DurationFieldType.seconds(), type.getFieldType(5)); assertEquals(DurationFieldType.millis(), type.getFieldType(6)); assertEquals(true, type.equals(type)); assertEquals(true, type.equals(PeriodType.standard().withMonthsRemoved())); assertEquals(false, type.equals(PeriodType.millis())); assertEquals(true, type.hashCode() == type.hashCode()); assertEquals(true, type.hashCode() == PeriodType.standard().withMonthsRemoved().hashCode()); assertEquals(false, type.hashCode() == PeriodType.millis().hashCode()); assertEquals("StandardNoMonths", type.getName()); assertEquals("PeriodType[StandardNoMonths]", type.toString()); assertEqualsAfterSerialization(type); } //----------------------------------------------------------------------- public void testMaskWeeks() throws Exception { PeriodType type = PeriodType.standard().withWeeksRemoved(); assertEquals(7, type.size()); assertEquals(DurationFieldType.years(), type.getFieldType(0)); assertEquals(DurationFieldType.months(), type.getFieldType(1)); assertEquals(DurationFieldType.days(), type.getFieldType(2)); assertEquals(DurationFieldType.hours(), type.getFieldType(3)); assertEquals(DurationFieldType.minutes(), type.getFieldType(4)); assertEquals(DurationFieldType.seconds(), type.getFieldType(5)); assertEquals(DurationFieldType.millis(), type.getFieldType(6)); assertEquals(true, type.equals(type)); assertEquals(true, type.equals(PeriodType.standard().withWeeksRemoved())); assertEquals(false, type.equals(PeriodType.millis())); assertEquals(true, type.hashCode() == type.hashCode()); assertEquals(true, type.hashCode() == PeriodType.standard().withWeeksRemoved().hashCode()); assertEquals(false, type.hashCode() == PeriodType.millis().hashCode()); assertEquals("StandardNoWeeks", type.getName()); assertEquals("PeriodType[StandardNoWeeks]", type.toString()); assertEqualsAfterSerialization(type); } //----------------------------------------------------------------------- public void testMaskDays() throws Exception { PeriodType type = PeriodType.standard().withDaysRemoved(); assertEquals(7, type.size()); assertEquals(DurationFieldType.years(), type.getFieldType(0)); assertEquals(DurationFieldType.months(), type.getFieldType(1)); assertEquals(DurationFieldType.weeks(), type.getFieldType(2)); assertEquals(DurationFieldType.hours(), type.getFieldType(3)); assertEquals(DurationFieldType.minutes(), type.getFieldType(4)); assertEquals(DurationFieldType.seconds(), type.getFieldType(5)); assertEquals(DurationFieldType.millis(), type.getFieldType(6)); assertEquals(true, type.equals(type)); assertEquals(true, type.equals(PeriodType.standard().withDaysRemoved())); assertEquals(false, type.equals(PeriodType.millis())); assertEquals(true, type.hashCode() == type.hashCode()); assertEquals(true, type.hashCode() == PeriodType.standard().withDaysRemoved().hashCode()); assertEquals(false, type.hashCode() == PeriodType.millis().hashCode()); assertEquals("StandardNoDays", type.getName()); assertEquals("PeriodType[StandardNoDays]", type.toString()); assertEqualsAfterSerialization(type); } //----------------------------------------------------------------------- public void testMaskHours() throws Exception { PeriodType type = PeriodType.standard().withHoursRemoved(); assertEquals(7, type.size()); assertEquals(DurationFieldType.years(), type.getFieldType(0)); assertEquals(DurationFieldType.months(), type.getFieldType(1)); assertEquals(DurationFieldType.weeks(), type.getFieldType(2)); assertEquals(DurationFieldType.days(), type.getFieldType(3)); assertEquals(DurationFieldType.minutes(), type.getFieldType(4)); assertEquals(DurationFieldType.seconds(), type.getFieldType(5)); assertEquals(DurationFieldType.millis(), type.getFieldType(6)); assertEquals(true, type.equals(type)); assertEquals(true, type.equals(PeriodType.standard().withHoursRemoved())); assertEquals(false, type.equals(PeriodType.millis())); assertEquals(true, type.hashCode() == type.hashCode()); assertEquals(true, type.hashCode() == PeriodType.standard().withHoursRemoved().hashCode()); assertEquals(false, type.hashCode() == PeriodType.millis().hashCode()); assertEquals("StandardNoHours", type.getName()); assertEquals("PeriodType[StandardNoHours]", type.toString()); assertEqualsAfterSerialization(type); } //----------------------------------------------------------------------- public void testMaskMinutes() throws Exception { PeriodType type = PeriodType.standard().withMinutesRemoved(); assertEquals(7, type.size()); assertEquals(DurationFieldType.years(), type.getFieldType(0)); assertEquals(DurationFieldType.months(), type.getFieldType(1)); assertEquals(DurationFieldType.weeks(), type.getFieldType(2)); assertEquals(DurationFieldType.days(), type.getFieldType(3)); assertEquals(DurationFieldType.hours(), type.getFieldType(4)); assertEquals(DurationFieldType.seconds(), type.getFieldType(5)); assertEquals(DurationFieldType.millis(), type.getFieldType(6)); assertEquals(true, type.equals(type)); assertEquals(true, type.equals(PeriodType.standard().withMinutesRemoved())); assertEquals(false, type.equals(PeriodType.millis())); assertEquals(true, type.hashCode() == type.hashCode()); assertEquals(true, type.hashCode() == PeriodType.standard().withMinutesRemoved().hashCode()); assertEquals(false, type.hashCode() == PeriodType.millis().hashCode()); assertEquals("StandardNoMinutes", type.getName()); assertEquals("PeriodType[StandardNoMinutes]", type.toString()); assertEqualsAfterSerialization(type); } //----------------------------------------------------------------------- public void testMaskSeconds() throws Exception { PeriodType type = PeriodType.standard().withSecondsRemoved(); assertEquals(7, type.size()); assertEquals(DurationFieldType.years(), type.getFieldType(0)); assertEquals(DurationFieldType.months(), type.getFieldType(1)); assertEquals(DurationFieldType.weeks(), type.getFieldType(2)); assertEquals(DurationFieldType.days(), type.getFieldType(3)); assertEquals(DurationFieldType.hours(), type.getFieldType(4)); assertEquals(DurationFieldType.minutes(), type.getFieldType(5)); assertEquals(DurationFieldType.millis(), type.getFieldType(6)); assertEquals(true, type.equals(type)); assertEquals(true, type.equals(PeriodType.standard().withSecondsRemoved())); assertEquals(false, type.equals(PeriodType.millis())); assertEquals(true, type.hashCode() == type.hashCode()); assertEquals(true, type.hashCode() == PeriodType.standard().withSecondsRemoved().hashCode()); assertEquals(false, type.hashCode() == PeriodType.millis().hashCode()); assertEquals("StandardNoSeconds", type.getName()); assertEquals("PeriodType[StandardNoSeconds]", type.toString()); assertEqualsAfterSerialization(type); } //----------------------------------------------------------------------- public void testMaskMillis() throws Exception { PeriodType type = PeriodType.standard().withMillisRemoved(); assertEquals(7, type.size()); assertEquals(DurationFieldType.years(), type.getFieldType(0)); assertEquals(DurationFieldType.months(), type.getFieldType(1)); assertEquals(DurationFieldType.weeks(), type.getFieldType(2)); assertEquals(DurationFieldType.days(), type.getFieldType(3)); assertEquals(DurationFieldType.hours(), type.getFieldType(4)); assertEquals(DurationFieldType.minutes(), type.getFieldType(5)); assertEquals(DurationFieldType.seconds(), type.getFieldType(6)); assertEquals(true, type.equals(type)); assertEquals(true, type.equals(PeriodType.standard().withMillisRemoved())); assertEquals(false, type.equals(PeriodType.millis())); assertEquals(true, type.hashCode() == type.hashCode()); assertEquals(true, type.hashCode() == PeriodType.standard().withMillisRemoved().hashCode()); assertEquals(false, type.hashCode() == PeriodType.millis().hashCode()); assertEquals("StandardNoMillis", type.getName()); assertEquals("PeriodType[StandardNoMillis]", type.toString()); assertEqualsAfterSerialization(type); } //----------------------------------------------------------------------- public void testMaskHoursMinutesSeconds() throws Exception { PeriodType type = PeriodType.standard().withHoursRemoved().withMinutesRemoved().withSecondsRemoved(); assertEquals(5, type.size()); assertEquals(DurationFieldType.years(), type.getFieldType(0)); assertEquals(DurationFieldType.months(), type.getFieldType(1)); assertEquals(DurationFieldType.weeks(), type.getFieldType(2)); assertEquals(DurationFieldType.days(), type.getFieldType(3)); assertEquals(DurationFieldType.millis(), type.getFieldType(4)); assertEquals(true, type.equals(type)); assertEquals(true, type.equals(PeriodType.standard().withHoursRemoved().withMinutesRemoved().withSecondsRemoved())); assertEquals(false, type.equals(PeriodType.millis())); assertEquals(true, type.hashCode() == type.hashCode()); assertEquals(true, type.hashCode() == PeriodType.standard().withHoursRemoved().withMinutesRemoved().withSecondsRemoved().hashCode()); assertEquals(false, type.hashCode() == PeriodType.millis().hashCode()); assertEquals("StandardNoHoursNoMinutesNoSeconds", type.getName()); assertEquals("PeriodType[StandardNoHoursNoMinutesNoSeconds]", type.toString()); assertEqualsAfterSerialization(type); } //----------------------------------------------------------------------- public void testMaskTwice1() throws Exception { PeriodType type = PeriodType.standard().withYearsRemoved(); PeriodType type2 = type.withYearsRemoved(); assertEquals(true, type == type2); type = PeriodType.standard().withMonthsRemoved(); type2 = type.withMonthsRemoved(); assertEquals(true, type == type2); type = PeriodType.standard().withWeeksRemoved(); type2 = type.withWeeksRemoved(); assertEquals(true, type == type2); type = PeriodType.standard().withDaysRemoved(); type2 = type.withDaysRemoved(); assertEquals(true, type == type2); type = PeriodType.standard().withHoursRemoved(); type2 = type.withHoursRemoved(); assertEquals(true, type == type2); type = PeriodType.standard().withMinutesRemoved(); type2 = type.withMinutesRemoved(); assertEquals(true, type == type2); type = PeriodType.standard().withSecondsRemoved(); type2 = type.withSecondsRemoved(); assertEquals(true, type == type2); type = PeriodType.standard().withMillisRemoved(); type2 = type.withMillisRemoved(); assertEquals(true, type == type2); } //----------------------------------------------------------------------- public void testMaskTwice2() throws Exception { PeriodType type = PeriodType.dayTime(); PeriodType type2 = type.withYearsRemoved(); assertEquals(true, type == type2); type = PeriodType.dayTime(); type2 = type.withMonthsRemoved(); assertEquals(true, type == type2); type = PeriodType.dayTime(); type2 = type.withWeeksRemoved(); assertEquals(true, type == type2); type = PeriodType.millis(); type2 = type.withDaysRemoved(); assertEquals(true, type == type2); type = PeriodType.millis(); type2 = type.withHoursRemoved(); assertEquals(true, type == type2); type = PeriodType.millis(); type2 = type.withMinutesRemoved(); assertEquals(true, type == type2); type = PeriodType.millis(); type2 = type.withSecondsRemoved(); assertEquals(true, type == type2); } //----------------------------------------------------------------------- public void testEquals() throws Exception { PeriodType type = PeriodType.dayTime().withMillisRemoved(); assertEquals(true, type.equals(type)); assertEquals(true, type.equals(PeriodType.dayTime().withMillisRemoved())); assertEquals(false, type.equals(null)); assertEquals(false, type.equals("")); } public void testHashCode() throws Exception { PeriodType type = PeriodType.dayTime().withMillisRemoved(); assertEquals(type.hashCode(), type.hashCode()); } //----------------------------------------------------------------------- public void testIsSupported() throws Exception { PeriodType type = PeriodType.dayTime().withMillisRemoved(); assertEquals(false, type.isSupported(DurationFieldType.years())); assertEquals(false, type.isSupported(DurationFieldType.months())); assertEquals(false, type.isSupported(DurationFieldType.weeks())); assertEquals(true, type.isSupported(DurationFieldType.days())); assertEquals(true, type.isSupported(DurationFieldType.hours())); assertEquals(true, type.isSupported(DurationFieldType.minutes())); assertEquals(true, type.isSupported(DurationFieldType.seconds())); assertEquals(false, type.isSupported(DurationFieldType.millis())); } //----------------------------------------------------------------------- public void testIndexOf() throws Exception { PeriodType type = PeriodType.dayTime().withMillisRemoved(); assertEquals(-1, type.indexOf(DurationFieldType.years())); assertEquals(-1, type.indexOf(DurationFieldType.months())); assertEquals(-1, type.indexOf(DurationFieldType.weeks())); assertEquals(0, type.indexOf(DurationFieldType.days())); assertEquals(1, type.indexOf(DurationFieldType.hours())); assertEquals(2, type.indexOf(DurationFieldType.minutes())); assertEquals(3, type.indexOf(DurationFieldType.seconds())); assertEquals(-1, type.indexOf(DurationFieldType.millis())); } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.math.BigInteger; import java.util.Arrays; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.base.BasePeriod; import org.joda.time.format.PeriodFormat; import org.joda.time.format.PeriodFormatter; /** * This class is a Junit unit test for Duration. * * @author Stephen Colebourne */ public class TestPeriod_Basics extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) //private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; // 2002-04-05 private long TEST_TIME1 = (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; // 2003-05-06 private long TEST_TIME2 = (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestPeriod_Basics.class); } public TestPeriod_Basics(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testTest() { assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString()); assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString()); assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString()); } //----------------------------------------------------------------------- public void testGetPeriodType() { Period test = new Period(0L); assertEquals(PeriodType.standard(), test.getPeriodType()); } public void testGetMethods() { Period test = new Period(0L); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } public void testValueIndexMethods() { Period test = new Period(1, 0, 0, 4, 5, 6, 7, 8, PeriodType.yearDayTime()); assertEquals(6, test.size()); assertEquals(1, test.getValue(0)); assertEquals(4, test.getValue(1)); assertEquals(5, test.getValue(2)); assertEquals(6, test.getValue(3)); assertEquals(7, test.getValue(4)); assertEquals(8, test.getValue(5)); assertEquals(true, Arrays.equals(new int[] {1, 4, 5, 6, 7, 8}, test.getValues())); } public void testTypeIndexMethods() { Period test = new Period(1, 0, 0, 4, 5, 6, 7, 8, PeriodType.yearDayTime()); assertEquals(6, test.size()); assertEquals(DurationFieldType.years(), test.getFieldType(0)); assertEquals(DurationFieldType.days(), test.getFieldType(1)); assertEquals(DurationFieldType.hours(), test.getFieldType(2)); assertEquals(DurationFieldType.minutes(), test.getFieldType(3)); assertEquals(DurationFieldType.seconds(), test.getFieldType(4)); assertEquals(DurationFieldType.millis(), test.getFieldType(5)); assertEquals(true, Arrays.equals(new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis()}, test.getFieldTypes())); } public void testIsSupported() { Period test = new Period(1, 0, 0, 4, 5, 6, 7, 8, PeriodType.yearDayTime()); assertEquals(true, test.isSupported(DurationFieldType.years())); assertEquals(false, test.isSupported(DurationFieldType.months())); assertEquals(false, test.isSupported(DurationFieldType.weeks())); assertEquals(true, test.isSupported(DurationFieldType.days())); assertEquals(true, test.isSupported(DurationFieldType.hours())); assertEquals(true, test.isSupported(DurationFieldType.minutes())); assertEquals(true, test.isSupported(DurationFieldType.seconds())); assertEquals(true, test.isSupported(DurationFieldType.millis())); } public void testIndexOf() { Period test = new Period(1, 0, 0, 4, 5, 6, 7, 8, PeriodType.yearDayTime()); assertEquals(0, test.indexOf(DurationFieldType.years())); assertEquals(-1, test.indexOf(DurationFieldType.months())); assertEquals(-1, test.indexOf(DurationFieldType.weeks())); assertEquals(1, test.indexOf(DurationFieldType.days())); assertEquals(2, test.indexOf(DurationFieldType.hours())); assertEquals(3, test.indexOf(DurationFieldType.minutes())); assertEquals(4, test.indexOf(DurationFieldType.seconds())); assertEquals(5, test.indexOf(DurationFieldType.millis())); } public void testGet() { Period test = new Period(1, 0, 0, 4, 5, 6, 7, 8, PeriodType.yearDayTime()); assertEquals(1, test.get(DurationFieldType.years())); assertEquals(0, test.get(DurationFieldType.months())); assertEquals(0, test.get(DurationFieldType.weeks())); assertEquals(4, test.get(DurationFieldType.days())); assertEquals(5, test.get(DurationFieldType.hours())); assertEquals(6, test.get(DurationFieldType.minutes())); assertEquals(7, test.get(DurationFieldType.seconds())); assertEquals(8, test.get(DurationFieldType.millis())); } public void testEqualsHashCode() { Period test1 = new Period(123L); Period test2 = new Period(123L); assertEquals(true, test1.equals(test2)); assertEquals(true, test2.equals(test1)); assertEquals(true, test1.equals(test1)); assertEquals(true, test2.equals(test2)); assertEquals(true, test1.hashCode() == test2.hashCode()); assertEquals(true, test1.hashCode() == test1.hashCode()); assertEquals(true, test2.hashCode() == test2.hashCode()); Period test3 = new Period(321L); assertEquals(false, test1.equals(test3)); assertEquals(false, test2.equals(test3)); assertEquals(false, test3.equals(test1)); assertEquals(false, test3.equals(test2)); assertEquals(false, test1.hashCode() == test3.hashCode()); assertEquals(false, test2.hashCode() == test3.hashCode()); assertEquals(false, test1.equals("Hello")); assertEquals(true, test1.equals(new MockPeriod(123L))); assertEquals(false, test1.equals(new Period(123L, PeriodType.dayTime()))); } class MockPeriod extends BasePeriod { private static final long serialVersionUID = 1L; public MockPeriod(long value) { super(value, null, null); } } //----------------------------------------------------------------------- public void testSerialization() throws Exception { Period test = new Period(123L); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(test); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); Period result = (Period) ois.readObject(); ois.close(); assertEquals(test, result); } // //----------------------------------------------------------------------- // public void testAddTo1() { // long expected = TEST_TIME_NOW; // expected = ISOChronology.getInstance().years().add(expected, 1); // expected = ISOChronology.getInstance().months().add(expected, 2); // expected = ISOChronology.getInstance().weeks().add(expected, 3); // expected = ISOChronology.getInstance().days().add(expected, 4); // expected = ISOChronology.getInstance().hours().add(expected, 5); // expected = ISOChronology.getInstance().minutes().add(expected, 6); // expected = ISOChronology.getInstance().seconds().add(expected, 7); // expected = ISOChronology.getInstance().millis().add(expected, 8); // // Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8); // long added = test.addTo(TEST_TIME_NOW, 1); // assertEquals(expected, added); // } // // public void testAddTo2() { // long expected = TEST_TIME_NOW; // expected = ISOChronology.getInstance().years().add(expected, -2); // expected = ISOChronology.getInstance().months().add(expected, -4); // expected = ISOChronology.getInstance().weeks().add(expected, -6); // expected = ISOChronology.getInstance().days().add(expected, -8); // expected = ISOChronology.getInstance().hours().add(expected, -10); // expected = ISOChronology.getInstance().minutes().add(expected, -12); // expected = ISOChronology.getInstance().seconds().add(expected, -14); // expected = ISOChronology.getInstance().millis().add(expected, -16); // // Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8); // long added = test.addTo(TEST_TIME_NOW, -2); // assertEquals(expected, added); // } // // public void testAddTo3() { // long expected = TEST_TIME_NOW; // Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8); // long added = test.addTo(TEST_TIME_NOW, 0); // assertEquals(expected, added); // } // // public void testAddTo4() { // long expected = TEST_TIME_NOW + 100L; // Period test = new Period(100L); // long added = test.addTo(TEST_TIME_NOW, 1); // assertEquals(expected, added); // } // // //----------------------------------------------------------------------- // public void testAddToWithChronology1() { // long expected = TEST_TIME_NOW; // expected = ISOChronology.getInstance().years().add(expected, 1); // expected = ISOChronology.getInstance().months().add(expected, 2); // expected = ISOChronology.getInstance().weeks().add(expected, 3); // expected = ISOChronology.getInstance().days().add(expected, 4); // expected = ISOChronology.getInstance().hours().add(expected, 5); // expected = ISOChronology.getInstance().minutes().add(expected, 6); // expected = ISOChronology.getInstance().seconds().add(expected, 7); // expected = ISOChronology.getInstance().millis().add(expected, 8); // // Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8); // long added = test.addTo(TEST_TIME_NOW, 1, ISOChronology.getInstance()); // assertEquals(expected, added); // } // // public void testAddToWithChronology2() { // long expected = TEST_TIME_NOW; // expected = ISOChronology.getInstanceUTC().years().add(expected, -2); // expected = ISOChronology.getInstanceUTC().months().add(expected, -4); // expected = ISOChronology.getInstanceUTC().weeks().add(expected, -6); // expected = ISOChronology.getInstanceUTC().days().add(expected, -8); // expected = ISOChronology.getInstanceUTC().hours().add(expected, -10); // expected = ISOChronology.getInstanceUTC().minutes().add(expected, -12); // expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14); // expected = ISOChronology.getInstanceUTC().millis().add(expected, -16); // // Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard()); // long added = test.addTo(TEST_TIME_NOW, -2, ISOChronology.getInstanceUTC()); // local specified so use it // assertEquals(expected, added); // } // // public void testAddToWithChronology3() { // long expected = TEST_TIME_NOW; // expected = ISOChronology.getInstance().years().add(expected, -2); // expected = ISOChronology.getInstance().months().add(expected, -4); // expected = ISOChronology.getInstance().weeks().add(expected, -6); // expected = ISOChronology.getInstance().days().add(expected, -8); // expected = ISOChronology.getInstance().hours().add(expected, -10); // expected = ISOChronology.getInstance().minutes().add(expected, -12); // expected = ISOChronology.getInstance().seconds().add(expected, -14); // expected = ISOChronology.getInstance().millis().add(expected, -16); // // Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard()); // long added = test.addTo(TEST_TIME_NOW, -2, null); // no chrono specified so use default // assertEquals(expected, added); // } // // //----------------------------------------------------------------------- // public void testAddToRI1() { // long expected = TEST_TIME_NOW; // expected = ISOChronology.getInstance().years().add(expected, 1); // expected = ISOChronology.getInstance().months().add(expected, 2); // expected = ISOChronology.getInstance().weeks().add(expected, 3); // expected = ISOChronology.getInstance().days().add(expected, 4); // expected = ISOChronology.getInstance().hours().add(expected, 5); // expected = ISOChronology.getInstance().minutes().add(expected, 6); // expected = ISOChronology.getInstance().seconds().add(expected, 7); // expected = ISOChronology.getInstance().millis().add(expected, 8); // // Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8); // DateTime added = test.addTo(new Instant(), 1); // Instant has no time zone, use default // assertEquals(expected, added.getMillis()); // assertEquals(ISOChronology.getInstance(), added.getChronology()); // } // // public void testAddToRI2() { // long expected = TEST_TIME_NOW; // expected = ISOChronology.getInstance().years().add(expected, -2); // expected = ISOChronology.getInstance().months().add(expected, -4); // expected = ISOChronology.getInstance().weeks().add(expected, -6); // expected = ISOChronology.getInstance().days().add(expected, -8); // expected = ISOChronology.getInstance().hours().add(expected, -10); // expected = ISOChronology.getInstance().minutes().add(expected, -12); // expected = ISOChronology.getInstance().seconds().add(expected, -14); // expected = ISOChronology.getInstance().millis().add(expected, -16); // // Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard()); // DateTime added = test.addTo(new Instant(), -2); // Instant has no time zone, use default // assertEquals(expected, added.getMillis()); // assertEquals(ISOChronology.getInstance(), added.getChronology()); // } // // public void testAddToRI3() { // long expected = TEST_TIME_NOW; // expected = ISOChronology.getInstanceUTC().years().add(expected, -2); // expected = ISOChronology.getInstanceUTC().months().add(expected, -4); // expected = ISOChronology.getInstanceUTC().weeks().add(expected, -6); // expected = ISOChronology.getInstanceUTC().days().add(expected, -8); // expected = ISOChronology.getInstanceUTC().hours().add(expected, -10); // expected = ISOChronology.getInstanceUTC().minutes().add(expected, -12); // expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14); // expected = ISOChronology.getInstanceUTC().millis().add(expected, -16); // // Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard()); // DateTime added = test.addTo(new DateTime(ISOChronology.getInstanceUTC()), -2); // DateTime has UTC time zone // assertEquals(expected, added.getMillis()); // assertEquals(ISOChronology.getInstanceUTC(), added.getChronology()); // } // // public void testAddToRI4() { // long expected = TEST_TIME_NOW; // expected = ISOChronology.getInstance(PARIS).years().add(expected, -2); // expected = ISOChronology.getInstance(PARIS).months().add(expected, -4); // expected = ISOChronology.getInstance(PARIS).weeks().add(expected, -6); // expected = ISOChronology.getInstance(PARIS).days().add(expected, -8); // expected = ISOChronology.getInstance(PARIS).hours().add(expected, -10); // expected = ISOChronology.getInstance(PARIS).minutes().add(expected, -12); // expected = ISOChronology.getInstance(PARIS).seconds().add(expected, -14); // expected = ISOChronology.getInstance(PARIS).millis().add(expected, -16); // // Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard()); // DateTime added = test.addTo(new DateTime(PARIS), -2); // DateTime has PARIS time zone // assertEquals(expected, added.getMillis()); // assertEquals(ISOChronology.getInstance(PARIS), added.getChronology()); // } // // public void testAddToRI5() { // long expected = TEST_TIME_NOW; // expected = ISOChronology.getInstance().years().add(expected, -2); // expected = ISOChronology.getInstance().months().add(expected, -4); // expected = ISOChronology.getInstance().weeks().add(expected, -6); // expected = ISOChronology.getInstance().days().add(expected, -8); // expected = ISOChronology.getInstance().hours().add(expected, -10); // expected = ISOChronology.getInstance().minutes().add(expected, -12); // expected = ISOChronology.getInstance().seconds().add(expected, -14); // expected = ISOChronology.getInstance().millis().add(expected, -16); // // Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard()); // DateTime added = test.addTo(null, -2); // null has no time zone, use default // assertEquals(expected, added.getMillis()); // assertEquals(ISOChronology.getInstance(), added.getChronology()); // } // // //----------------------------------------------------------------------- // public void testAddIntoRWI1() { // long expected = TEST_TIME_NOW; // expected = ISOChronology.getInstance().years().add(expected, 1); // expected = ISOChronology.getInstance().months().add(expected, 2); // expected = ISOChronology.getInstance().weeks().add(expected, 3); // expected = ISOChronology.getInstance().days().add(expected, 4); // expected = ISOChronology.getInstance().hours().add(expected, 5); // expected = ISOChronology.getInstance().minutes().add(expected, 6); // expected = ISOChronology.getInstance().seconds().add(expected, 7); // expected = ISOChronology.getInstance().millis().add(expected, 8); // // Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8); // MutableDateTime mdt = new MutableDateTime(); // test.addInto(mdt, 1); // assertEquals(expected, mdt.getMillis()); // } // // public void testAddIntoRWI2() { // long expected = TEST_TIME_NOW; // expected = ISOChronology.getInstance().years().add(expected, -2); // expected = ISOChronology.getInstance().months().add(expected, -4); // expected = ISOChronology.getInstance().weeks().add(expected, -6); // expected = ISOChronology.getInstance().days().add(expected, -8); // expected = ISOChronology.getInstance().hours().add(expected, -10); // expected = ISOChronology.getInstance().minutes().add(expected, -12); // expected = ISOChronology.getInstance().seconds().add(expected, -14); // expected = ISOChronology.getInstance().millis().add(expected, -16); // // Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard()); // MutableDateTime mdt = new MutableDateTime(); // test.addInto(mdt, -2); // MutableDateTime has a chronology, use it // assertEquals(expected, mdt.getMillis()); // } // // public void testAddIntoRWI3() { // Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8); // try { // test.addInto(null, 1); // fail(); // } catch (IllegalArgumentException ex) {} // } //----------------------------------------------------------------------- public void testToString() { Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8); assertEquals("P1Y2M3W4DT5H6M7.008S", test.toString()); test = new Period(0, 0, 0, 0, 0, 0, 0, 0); assertEquals("PT0S", test.toString()); test = new Period(12345L); assertEquals("PT12.345S", test.toString()); } //----------------------------------------------------------------------- public void testToString_PeriodFormatter() { Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8); assertEquals("1 year, 2 months, 3 weeks, 4 days, 5 hours, 6 minutes, 7 seconds and 8 milliseconds", test.toString(PeriodFormat.getDefault())); test = new Period(0, 0, 0, 0, 0, 0, 0, 0); assertEquals("0 milliseconds", test.toString(PeriodFormat.getDefault())); } public void testToString_nullPeriodFormatter() { Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8); assertEquals("P1Y2M3W4DT5H6M7.008S", test.toString((PeriodFormatter) null)); } //----------------------------------------------------------------------- public void testToPeriod() { Period test = new Period(123L); Period result = test.toPeriod(); assertSame(test, result); } public void testToMutablePeriod() { Period test = new Period(123L); MutablePeriod result = test.toMutablePeriod(); assertEquals(test, result); } //----------------------------------------------------------------------- // public void testToDurationMillisFrom() { // Period test = new Period(123L); // assertEquals(123L, test.toDurationMillisFrom(0L, null)); // } public void testToDurationFrom() { Period test = new Period(123L); assertEquals(new Duration(123L), test.toDurationFrom(new Instant(0L))); } public void testToDurationTo() { Period test = new Period(123L); assertEquals(new Duration(123L), test.toDurationTo(new Instant(123L))); } //----------------------------------------------------------------------- public void testWithPeriodType1() { Period test = new Period(123L); Period result = test.withPeriodType(PeriodType.standard()); assertSame(test, result); } public void testWithPeriodType2() { Period test = new Period(3123L); Period result = test.withPeriodType(PeriodType.dayTime()); assertEquals(3, result.getSeconds()); assertEquals(123, result.getMillis()); assertEquals(PeriodType.dayTime(), result.getPeriodType()); } public void testWithPeriodType3() { Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard()); try { test.withPeriodType(PeriodType.dayTime()); fail(); } catch (IllegalArgumentException ex) {} } public void testWithPeriodType4() { Period test = new Period(3123L); Period result = test.withPeriodType(null); assertEquals(3, result.getSeconds()); assertEquals(123, result.getMillis()); assertEquals(PeriodType.standard(), result.getPeriodType()); } public void testWithPeriodType5() { Period test = new Period(1, 2, 0, 4, 5, 6, 7, 8, PeriodType.standard()); Period result = test.withPeriodType(PeriodType.yearMonthDayTime()); assertEquals(PeriodType.yearMonthDayTime(), result.getPeriodType()); assertEquals(1, result.getYears()); assertEquals(2, result.getMonths()); assertEquals(0, result.getWeeks()); assertEquals(4, result.getDays()); assertEquals(5, result.getHours()); assertEquals(6, result.getMinutes()); assertEquals(7, result.getSeconds()); assertEquals(8, result.getMillis()); } //----------------------------------------------------------------------- public void testWithFields1() { Period test1 = new Period(1, 2, 3, 4, 5, 6, 7, 8); Period test2 = new Period(0, 0, 0, 0, 0, 0, 0, 9, PeriodType.millis()); Period result = test1.withFields(test2); assertEquals(new Period(1, 2, 3, 4, 5, 6, 7, 8), test1); assertEquals(new Period(0, 0, 0, 0, 0, 0, 0, 9, PeriodType.millis()), test2); assertEquals(new Period(1, 2, 3, 4, 5, 6, 7, 9), result); } public void testWithFields2() { Period test1 = new Period(1, 2, 3, 4, 5, 6, 7, 8); Period test2 = null; Period result = test1.withFields(test2); assertEquals(new Period(1, 2, 3, 4, 5, 6, 7, 8), test1); assertSame(test1, result); } public void testWithFields3() { Period test1 = new Period(0, 0, 0, 0, 0, 0, 0, 9, PeriodType.millis()); Period test2 = new Period(1, 2, 3, 4, 5, 6, 7, 8); try { test1.withFields(test2); fail(); } catch (IllegalArgumentException ex) {} assertEquals(new Period(0, 0, 0, 0, 0, 0, 0, 9, PeriodType.millis()), test1); assertEquals(new Period(1, 2, 3, 4, 5, 6, 7, 8), test2); } //----------------------------------------------------------------------- public void testWithField1() { Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8); Period result = test.withField(DurationFieldType.years(), 6); assertEquals(new Period(1, 2, 3, 4, 5, 6, 7, 8), test); assertEquals(new Period(6, 2, 3, 4, 5, 6, 7, 8), result); } public void testWithField2() { Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8); try { test.withField(null, 6); fail(); } catch (IllegalArgumentException ex) {} } public void testWithField3() { Period test = new Period(0, 0, 0, 0, 5, 6, 7, 8, PeriodType.time()); try { test.withField(DurationFieldType.years(), 6); fail(); } catch (IllegalArgumentException ex) {} } public void testWithField4() { Period test = new Period(0, 0, 0, 0, 5, 6, 7, 8, PeriodType.time()); Period result = test.withField(DurationFieldType.years(), 0); assertEquals(test, result); } //----------------------------------------------------------------------- public void testWithFieldAdded1() { Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8); Period result = test.withFieldAdded(DurationFieldType.years(), 6); assertEquals(new Period(1, 2, 3, 4, 5, 6, 7, 8), test); assertEquals(new Period(7, 2, 3, 4, 5, 6, 7, 8), result); } public void testWithFieldAdded2() { Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8); try { test.withFieldAdded(null, 0); fail(); } catch (IllegalArgumentException ex) {} } public void testWithFieldAdded3() { Period test = new Period(0, 0, 0, 0, 5, 6, 7, 8, PeriodType.time()); try { test.withFieldAdded(DurationFieldType.years(), 6); fail(); } catch (IllegalArgumentException ex) {} } public void testWithFieldAdded4() { Period test = new Period(0, 0, 0, 0, 5, 6, 7, 8, PeriodType.time()); Period result = test.withFieldAdded(DurationFieldType.years(), 0); assertEquals(test, result); } //----------------------------------------------------------------------- public void testPeriodStatics() { Period test; test = Period.years(1); assertEquals(test, new Period(1, 0, 0, 0, 0, 0, 0, 0, PeriodType.standard())); test = Period.months(1); assertEquals(test, new Period(0, 1, 0, 0, 0, 0, 0, 0, PeriodType.standard())); test = Period.weeks(1); assertEquals(test, new Period(0, 0, 1, 0, 0, 0, 0, 0, PeriodType.standard())); test = Period.days(1); assertEquals(test, new Period(0, 0, 0, 1, 0, 0, 0, 0, PeriodType.standard())); test = Period.hours(1); assertEquals(test, new Period(0, 0, 0, 0, 1, 0, 0, 0, PeriodType.standard())); test = Period.minutes(1); assertEquals(test, new Period(0, 0, 0, 0, 0, 1, 0, 0, PeriodType.standard())); test = Period.seconds(1); assertEquals(test, new Period(0, 0, 0, 0, 0, 0, 1, 0, PeriodType.standard())); test = Period.millis(1); assertEquals(test, new Period(0, 0, 0, 0, 0, 0, 0, 1, PeriodType.standard())); } //----------------------------------------------------------------------- public void testWith() { Period test; test = Period.years(5).withYears(1); assertEquals(test, new Period(1, 0, 0, 0, 0, 0, 0, 0, PeriodType.standard())); test = Period.months(5).withMonths(1); assertEquals(test, new Period(0, 1, 0, 0, 0, 0, 0, 0, PeriodType.standard())); test = Period.weeks(5).withWeeks(1); assertEquals(test, new Period(0, 0, 1, 0, 0, 0, 0, 0, PeriodType.standard())); test = Period.days(5).withDays(1); assertEquals(test, new Period(0, 0, 0, 1, 0, 0, 0, 0, PeriodType.standard())); test = Period.hours(5).withHours(1); assertEquals(test, new Period(0, 0, 0, 0, 1, 0, 0, 0, PeriodType.standard())); test = Period.minutes(5).withMinutes(1); assertEquals(test, new Period(0, 0, 0, 0, 0, 1, 0, 0, PeriodType.standard())); test = Period.seconds(5).withSeconds(1); assertEquals(test, new Period(0, 0, 0, 0, 0, 0, 1, 0, PeriodType.standard())); test = Period.millis(5).withMillis(1); assertEquals(test, new Period(0, 0, 0, 0, 0, 0, 0, 1, PeriodType.standard())); test = new Period(0L, PeriodType.millis()); try { test.withYears(1); fail(); } catch (UnsupportedOperationException ex) {} } //----------------------------------------------------------------------- public void testPlus() { Period base = new Period(1, 2, 3, 4, 5, 6, 7, 8); Period baseDaysOnly = new Period(0, 0, 0, 10, 0, 0, 0, 0, PeriodType.days()); Period test = base.plus((ReadablePeriod) null); assertSame(base, test); test = base.plus(Period.years(10)); assertEquals(11, test.getYears()); assertEquals(2, test.getMonths()); assertEquals(3, test.getWeeks()); assertEquals(4, test.getDays()); assertEquals(5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); test = base.plus(Years.years(10)); assertEquals(11, test.getYears()); assertEquals(2, test.getMonths()); assertEquals(3, test.getWeeks()); assertEquals(4, test.getDays()); assertEquals(5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); test = base.plus(Period.days(10)); assertEquals(1, test.getYears()); assertEquals(2, test.getMonths()); assertEquals(3, test.getWeeks()); assertEquals(14, test.getDays()); assertEquals(5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); test = baseDaysOnly.plus(Period.years(0)); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(10, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); test = baseDaysOnly.plus(baseDaysOnly); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(20, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); try { baseDaysOnly.plus(Period.years(1)); fail(); } catch (UnsupportedOperationException ex) {} try { Period.days(Integer.MAX_VALUE).plus(Period.days(1)); fail(); } catch (ArithmeticException ex) {} try { Period.days(Integer.MIN_VALUE).plus(Period.days(-1)); fail(); } catch (ArithmeticException ex) {} } //----------------------------------------------------------------------- public void testMinus() { Period base = new Period(1, 2, 3, 4, 5, 6, 7, 8); Period baseDaysOnly = new Period(0, 0, 0, 10, 0, 0, 0, 0, PeriodType.days()); Period test = base.minus((ReadablePeriod) null); assertSame(base, test); test = base.minus(Period.years(10)); assertEquals(-9, test.getYears()); assertEquals(2, test.getMonths()); assertEquals(3, test.getWeeks()); assertEquals(4, test.getDays()); assertEquals(5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); test = base.minus(Years.years(10)); assertEquals(-9, test.getYears()); assertEquals(2, test.getMonths()); assertEquals(3, test.getWeeks()); assertEquals(4, test.getDays()); assertEquals(5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); test = base.minus(Period.days(10)); assertEquals(1, test.getYears()); assertEquals(2, test.getMonths()); assertEquals(3, test.getWeeks()); assertEquals(-6, test.getDays()); assertEquals(5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); test = baseDaysOnly.minus(Period.years(0)); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(10, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); test = baseDaysOnly.minus(baseDaysOnly); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); try { baseDaysOnly.minus(Period.years(1)); fail(); } catch (UnsupportedOperationException ex) {} try { Period.days(Integer.MAX_VALUE).minus(Period.days(-1)); fail(); } catch (ArithmeticException ex) {} try { Period.days(Integer.MIN_VALUE).minus(Period.days(1)); fail(); } catch (ArithmeticException ex) {} } //----------------------------------------------------------------------- public void testPlusFields() { Period test; test = Period.years(1).plusYears(1); assertEquals(new Period(2, 0, 0, 0, 0, 0, 0, 0, PeriodType.standard()), test); test = Period.months(1).plusMonths(1); assertEquals(new Period(0, 2, 0, 0, 0, 0, 0, 0, PeriodType.standard()), test); test = Period.weeks(1).plusWeeks(1); assertEquals(new Period(0, 0, 2, 0, 0, 0, 0, 0, PeriodType.standard()), test); test = Period.days(1).plusDays(1); assertEquals(new Period(0, 0, 0, 2, 0, 0, 0, 0, PeriodType.standard()), test); test = Period.hours(1).plusHours(1); assertEquals(new Period(0, 0, 0, 0, 2, 0, 0, 0, PeriodType.standard()), test); test = Period.minutes(1).plusMinutes(1); assertEquals(new Period(0, 0, 0, 0, 0, 2, 0, 0, PeriodType.standard()), test); test = Period.seconds(1).plusSeconds(1); assertEquals(new Period(0, 0, 0, 0, 0, 0, 2, 0, PeriodType.standard()), test); test = Period.millis(1).plusMillis(1); assertEquals(new Period(0, 0, 0, 0, 0, 0, 0, 2, PeriodType.standard()), test); test = new Period(0L, PeriodType.millis()); try { test.plusYears(1); fail(); } catch (UnsupportedOperationException ex) {} } public void testPlusFieldsZero() { Period test, result; test = Period.years(1); result = test.plusYears(0); assertSame(test, result); test = Period.months(1); result = test.plusMonths(0); assertSame(test, result); test = Period.weeks(1); result = test.plusWeeks(0); assertSame(test, result); test = Period.days(1); result = test.plusDays(0); assertSame(test, result); test = Period.hours(1); result = test.plusHours(0); assertSame(test, result); test = Period.minutes(1); result = test.plusMinutes(0); assertSame(test, result); test = Period.seconds(1); result = test.plusSeconds(0); assertSame(test, result); test = Period.millis(1); result = test.plusMillis(0); assertSame(test, result); } public void testMinusFields() { Period test; test = Period.years(3).minusYears(1); assertEquals(new Period(2, 0, 0, 0, 0, 0, 0, 0, PeriodType.standard()), test); test = Period.months(3).minusMonths(1); assertEquals(new Period(0, 2, 0, 0, 0, 0, 0, 0, PeriodType.standard()), test); test = Period.weeks(3).minusWeeks(1); assertEquals(new Period(0, 0, 2, 0, 0, 0, 0, 0, PeriodType.standard()), test); test = Period.days(3).minusDays(1); assertEquals(new Period(0, 0, 0, 2, 0, 0, 0, 0, PeriodType.standard()), test); test = Period.hours(3).minusHours(1); assertEquals(new Period(0, 0, 0, 0, 2, 0, 0, 0, PeriodType.standard()), test); test = Period.minutes(3).minusMinutes(1); assertEquals(new Period(0, 0, 0, 0, 0, 2, 0, 0, PeriodType.standard()), test); test = Period.seconds(3).minusSeconds(1); assertEquals(new Period(0, 0, 0, 0, 0, 0, 2, 0, PeriodType.standard()), test); test = Period.millis(3).minusMillis(1); assertEquals(new Period(0, 0, 0, 0, 0, 0, 0, 2, PeriodType.standard()), test); test = new Period(0L, PeriodType.millis()); try { test.minusYears(1); fail(); } catch (UnsupportedOperationException ex) {} } //----------------------------------------------------------------------- public void testMultipliedBy() { Period base = new Period(1, 2, 3, 4, 5, 6, 7, 8); Period test = base.multipliedBy(1); assertSame(base, test); test = base.multipliedBy(0); assertEquals(Period.ZERO, test); test = base.multipliedBy(2); assertEquals(2, test.getYears()); assertEquals(4, test.getMonths()); assertEquals(6, test.getWeeks()); assertEquals(8, test.getDays()); assertEquals(10, test.getHours()); assertEquals(12, test.getMinutes()); assertEquals(14, test.getSeconds()); assertEquals(16, test.getMillis()); test = base.multipliedBy(3); assertEquals(3, test.getYears()); assertEquals(6, test.getMonths()); assertEquals(9, test.getWeeks()); assertEquals(12, test.getDays()); assertEquals(15, test.getHours()); assertEquals(18, test.getMinutes()); assertEquals(21, test.getSeconds()); assertEquals(24, test.getMillis()); test = base.multipliedBy(-4); assertEquals(-4, test.getYears()); assertEquals(-8, test.getMonths()); assertEquals(-12, test.getWeeks()); assertEquals(-16, test.getDays()); assertEquals(-20, test.getHours()); assertEquals(-24, test.getMinutes()); assertEquals(-28, test.getSeconds()); assertEquals(-32, test.getMillis()); try { Period.days(Integer.MAX_VALUE).multipliedBy(2); fail(); } catch (ArithmeticException ex) {} try { Period.days(Integer.MIN_VALUE).multipliedBy(2); fail(); } catch (ArithmeticException ex) {} } //----------------------------------------------------------------------- public void testNegated() { Period base = new Period(1, 2, 3, 4, 5, 6, 7, 8); Period test = Period.ZERO.negated(); assertEquals(Period.ZERO, test); test = base.negated(); assertEquals(-1, test.getYears()); assertEquals(-2, test.getMonths()); assertEquals(-3, test.getWeeks()); assertEquals(-4, test.getDays()); assertEquals(-5, test.getHours()); assertEquals(-6, test.getMinutes()); assertEquals(-7, test.getSeconds()); assertEquals(-8, test.getMillis()); test = Period.days(Integer.MAX_VALUE).negated(); assertEquals(-Integer.MAX_VALUE, test.getDays()); try { Period.days(Integer.MIN_VALUE).negated(); fail(); } catch (ArithmeticException ex) {} } //----------------------------------------------------------------------- public void testToStandardWeeks() { Period test = new Period(0, 0, 3, 4, 5, 6, 7, 8); assertEquals(3, test.toStandardWeeks().getWeeks()); test = new Period(0, 0, 3, 7, 0, 0, 0, 0); assertEquals(4, test.toStandardWeeks().getWeeks()); test = new Period(0, 0, 0, 6, 23, 59, 59, 1000); assertEquals(1, test.toStandardWeeks().getWeeks()); test = new Period(0, 0, Integer.MAX_VALUE, 0, 0, 0, 0, 0); assertEquals(Integer.MAX_VALUE, test.toStandardWeeks().getWeeks()); test = new Period(0, 0, 0, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE); long intMax = Integer.MAX_VALUE; BigInteger expected = BigInteger.valueOf(intMax); expected = expected.add(BigInteger.valueOf(intMax * DateTimeConstants.MILLIS_PER_SECOND)); expected = expected.add(BigInteger.valueOf(intMax * DateTimeConstants.MILLIS_PER_MINUTE)); expected = expected.add(BigInteger.valueOf(intMax * DateTimeConstants.MILLIS_PER_HOUR)); expected = expected.add(BigInteger.valueOf(intMax * DateTimeConstants.MILLIS_PER_DAY)); expected = expected.divide(BigInteger.valueOf(DateTimeConstants.MILLIS_PER_WEEK)); assertTrue(expected.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) < 0); assertEquals(expected.longValue(), test.toStandardWeeks().getWeeks()); test = new Period(0, 0, Integer.MAX_VALUE, 7, 0, 0, 0, 0); try { test.toStandardWeeks(); fail(); } catch (ArithmeticException ex) {} } public void testToStandardWeeks_years() { Period test = Period.years(1); try { test.toStandardWeeks(); fail(); } catch (UnsupportedOperationException ex) {} test = Period.years(-1); try { test.toStandardWeeks(); fail(); } catch (UnsupportedOperationException ex) {} test = Period.years(0); assertEquals(0, test.toStandardWeeks().getWeeks()); } public void testToStandardWeeks_months() { Period test = Period.months(1); try { test.toStandardWeeks(); fail(); } catch (UnsupportedOperationException ex) {} test = Period.months(-1); try { test.toStandardWeeks(); fail(); } catch (UnsupportedOperationException ex) {} test = Period.months(0); assertEquals(0, test.toStandardWeeks().getWeeks()); } //----------------------------------------------------------------------- public void testToStandardDays() { Period test = new Period(0, 0, 0, 4, 5, 6, 7, 8); assertEquals(4, test.toStandardDays().getDays()); test = new Period(0, 0, 1, 4, 0, 0, 0, 0); assertEquals(11, test.toStandardDays().getDays()); test = new Period(0, 0, 0, 0, 23, 59, 59, 1000); assertEquals(1, test.toStandardDays().getDays()); test = new Period(0, 0, 0, Integer.MAX_VALUE, 0, 0, 0, 0); assertEquals(Integer.MAX_VALUE, test.toStandardDays().getDays()); test = new Period(0, 0, 0, 0, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE); long intMax = Integer.MAX_VALUE; BigInteger expected = BigInteger.valueOf(intMax); expected = expected.add(BigInteger.valueOf(intMax * DateTimeConstants.MILLIS_PER_SECOND)); expected = expected.add(BigInteger.valueOf(intMax * DateTimeConstants.MILLIS_PER_MINUTE)); expected = expected.add(BigInteger.valueOf(intMax * DateTimeConstants.MILLIS_PER_HOUR)); expected = expected.divide(BigInteger.valueOf(DateTimeConstants.MILLIS_PER_DAY)); assertTrue(expected.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) < 0); assertEquals(expected.longValue(), test.toStandardDays().getDays()); test = new Period(0, 0, 0, Integer.MAX_VALUE, 24, 0, 0, 0); try { test.toStandardDays(); fail(); } catch (ArithmeticException ex) {} } public void testToStandardDays_years() { Period test = Period.years(1); try { test.toStandardDays(); fail(); } catch (UnsupportedOperationException ex) {} test = Period.years(-1); try { test.toStandardDays(); fail(); } catch (UnsupportedOperationException ex) {} test = Period.years(0); assertEquals(0, test.toStandardDays().getDays()); } public void testToStandardDays_months() { Period test = Period.months(1); try { test.toStandardDays(); fail(); } catch (UnsupportedOperationException ex) {} test = Period.months(-1); try { test.toStandardDays(); fail(); } catch (UnsupportedOperationException ex) {} test = Period.months(0); assertEquals(0, test.toStandardDays().getDays()); } //----------------------------------------------------------------------- public void testToStandardHours() { Period test = new Period(0, 0, 0, 0, 5, 6, 7, 8); assertEquals(5, test.toStandardHours().getHours()); test = new Period(0, 0, 0, 1, 5, 0, 0, 0); assertEquals(29, test.toStandardHours().getHours()); test = new Period(0, 0, 0, 0, 0, 59, 59, 1000); assertEquals(1, test.toStandardHours().getHours()); test = new Period(0, 0, 0, 0, Integer.MAX_VALUE, 0, 0, 0); assertEquals(Integer.MAX_VALUE, test.toStandardHours().getHours()); test = new Period(0, 0, 0, 0, 0, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE); long intMax = Integer.MAX_VALUE; BigInteger expected = BigInteger.valueOf(intMax); expected = expected.add(BigInteger.valueOf(intMax * DateTimeConstants.MILLIS_PER_SECOND)); expected = expected.add(BigInteger.valueOf(intMax * DateTimeConstants.MILLIS_PER_MINUTE)); expected = expected.divide(BigInteger.valueOf(DateTimeConstants.MILLIS_PER_HOUR)); assertTrue(expected.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) < 0); assertEquals(expected.longValue(), test.toStandardHours().getHours()); test = new Period(0, 0, 0, 0, Integer.MAX_VALUE, 60, 0, 0); try { test.toStandardHours(); fail(); } catch (ArithmeticException ex) {} } public void testToStandardHours_years() { Period test = Period.years(1); try { test.toStandardHours(); fail(); } catch (UnsupportedOperationException ex) {} test = Period.years(-1); try { test.toStandardHours(); fail(); } catch (UnsupportedOperationException ex) {} test = Period.years(0); assertEquals(0, test.toStandardHours().getHours()); } public void testToStandardHours_months() { Period test = Period.months(1); try { test.toStandardHours(); fail(); } catch (UnsupportedOperationException ex) {} test = Period.months(-1); try { test.toStandardHours(); fail(); } catch (UnsupportedOperationException ex) {} test = Period.months(0); assertEquals(0, test.toStandardHours().getHours()); } //----------------------------------------------------------------------- public void testToStandardMinutes() { Period test = new Period(0, 0, 0, 0, 0, 6, 7, 8); assertEquals(6, test.toStandardMinutes().getMinutes()); test = new Period(0, 0, 0, 0, 1, 6, 0, 0); assertEquals(66, test.toStandardMinutes().getMinutes()); test = new Period(0, 0, 0, 0, 0, 0, 59, 1000); assertEquals(1, test.toStandardMinutes().getMinutes()); test = new Period(0, 0, 0, 0, 0, Integer.MAX_VALUE, 0, 0); assertEquals(Integer.MAX_VALUE, test.toStandardMinutes().getMinutes()); test = new Period(0, 0, 0, 0, 0, 0, Integer.MAX_VALUE, Integer.MAX_VALUE); long intMax = Integer.MAX_VALUE; BigInteger expected = BigInteger.valueOf(intMax); expected = expected.add(BigInteger.valueOf(intMax * DateTimeConstants.MILLIS_PER_SECOND)); expected = expected.divide(BigInteger.valueOf(DateTimeConstants.MILLIS_PER_MINUTE)); assertTrue(expected.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) < 0); assertEquals(expected.longValue(), test.toStandardMinutes().getMinutes()); test = new Period(0, 0, 0, 0, 0, Integer.MAX_VALUE, 60, 0); try { test.toStandardMinutes(); fail(); } catch (ArithmeticException ex) {} } public void testToStandardMinutes_years() { Period test = Period.years(1); try { test.toStandardMinutes(); fail(); } catch (UnsupportedOperationException ex) {} test = Period.years(-1); try { test.toStandardMinutes(); fail(); } catch (UnsupportedOperationException ex) {} test = Period.years(0); assertEquals(0, test.toStandardMinutes().getMinutes()); } public void testToStandardMinutes_months() { Period test = Period.months(1); try { test.toStandardMinutes(); fail(); } catch (UnsupportedOperationException ex) {} test = Period.months(-1); try { test.toStandardMinutes(); fail(); } catch (UnsupportedOperationException ex) {} test = Period.months(0); assertEquals(0, test.toStandardMinutes().getMinutes()); } //----------------------------------------------------------------------- public void testToStandardSeconds() { Period test = new Period(0, 0, 0, 0, 0, 0, 7, 8); assertEquals(7, test.toStandardSeconds().getSeconds()); test = new Period(0, 0, 0, 0, 0, 1, 3, 0); assertEquals(63, test.toStandardSeconds().getSeconds()); test = new Period(0, 0, 0, 0, 0, 0, 0, 1000); assertEquals(1, test.toStandardSeconds().getSeconds()); test = new Period(0, 0, 0, 0, 0, 0, Integer.MAX_VALUE, 0); assertEquals(Integer.MAX_VALUE, test.toStandardSeconds().getSeconds()); test = new Period(0, 0, 0, 0, 0, 0, 20, Integer.MAX_VALUE); long expected = 20; expected += ((long) Integer.MAX_VALUE) / DateTimeConstants.MILLIS_PER_SECOND; assertEquals(expected, test.toStandardSeconds().getSeconds()); test = new Period(0, 0, 0, 0, 0, 0, Integer.MAX_VALUE, 1000); try { test.toStandardSeconds(); fail(); } catch (ArithmeticException ex) {} } public void testToStandardSeconds_years() { Period test = Period.years(1); try { test.toStandardSeconds(); fail(); } catch (UnsupportedOperationException ex) {} test = Period.years(-1); try { test.toStandardSeconds(); fail(); } catch (UnsupportedOperationException ex) {} test = Period.years(0); assertEquals(0, test.toStandardSeconds().getSeconds()); } public void testToStandardSeconds_months() { Period test = Period.months(1); try { test.toStandardSeconds(); fail(); } catch (UnsupportedOperationException ex) {} test = Period.months(-1); try { test.toStandardSeconds(); fail(); } catch (UnsupportedOperationException ex) {} test = Period.months(0); assertEquals(0, test.toStandardSeconds().getSeconds()); } //----------------------------------------------------------------------- public void testToStandardDuration() { Period test = new Period(0, 0, 0, 0, 0, 0, 0, 8); assertEquals(8, test.toStandardDuration().getMillis()); test = new Period(0, 0, 0, 0, 0, 0, 1, 20); assertEquals(1020, test.toStandardDuration().getMillis()); test = new Period(0, 0, 0, 0, 0, 0, 0, Integer.MAX_VALUE); assertEquals(Integer.MAX_VALUE, test.toStandardDuration().getMillis()); test = new Period(0, 0, 0, 0, 0, 10, 20, Integer.MAX_VALUE); long expected = Integer.MAX_VALUE; expected += 10L * ((long) DateTimeConstants.MILLIS_PER_MINUTE); expected += 20L * ((long) DateTimeConstants.MILLIS_PER_SECOND); assertEquals(expected, test.toStandardDuration().getMillis()); // proof that overflow does not occur BigInteger intMax = BigInteger.valueOf(Integer.MAX_VALUE); BigInteger exp = intMax; exp = exp.add(intMax.multiply(BigInteger.valueOf(DateTimeConstants.MILLIS_PER_SECOND))); exp = exp.add(intMax.multiply(BigInteger.valueOf(DateTimeConstants.MILLIS_PER_MINUTE))); exp = exp.add(intMax.multiply(BigInteger.valueOf(DateTimeConstants.MILLIS_PER_HOUR))); exp = exp.add(intMax.multiply(BigInteger.valueOf(DateTimeConstants.MILLIS_PER_DAY))); exp = exp.add(intMax.multiply(BigInteger.valueOf(DateTimeConstants.MILLIS_PER_WEEK))); assertTrue(exp.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) < 0); // test = new Period(0, 0, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE); // try { // test.toStandardDuration(); // fail(); // } catch (ArithmeticException ex) {} } public void testToStandardDuration_years() { Period test = Period.years(1); try { test.toStandardDuration(); fail(); } catch (UnsupportedOperationException ex) {} test = Period.years(-1); try { test.toStandardDuration(); fail(); } catch (UnsupportedOperationException ex) {} test = Period.years(0); assertEquals(0, test.toStandardDuration().getMillis()); } public void testToStandardDuration_months() { Period test = Period.months(1); try { test.toStandardDuration(); fail(); } catch (UnsupportedOperationException ex) {} test = Period.months(-1); try { test.toStandardDuration(); fail(); } catch (UnsupportedOperationException ex) {} test = Period.months(0); assertEquals(0, test.toStandardDuration().getMillis()); } //----------------------------------------------------------------------- public void testNormalizedStandard_yearMonth1() { Period test = new Period(1, 15, 0, 0, 0, 0, 0, 0); Period result = test.normalizedStandard(); assertEquals(new Period(1, 15, 0, 0, 0, 0, 0, 0), test); assertEquals(new Period(2, 3, 0, 0, 0, 0, 0, 0), result); } public void testNormalizedStandard_yearMonth2() { Period test = new Period(Integer.MAX_VALUE, 15, 0, 0, 0, 0, 0, 0); try { test.normalizedStandard(); fail(); } catch (ArithmeticException ex) {} } public void testNormalizedStandard_weekDay1() { Period test = new Period(0, 0, 1, 12, 0, 0, 0, 0); Period result = test.normalizedStandard(); assertEquals(new Period(0, 0, 1, 12, 0, 0, 0, 0), test); assertEquals(new Period(0, 0, 2, 5, 0, 0, 0, 0), result); } public void testNormalizedStandard_weekDay2() { Period test = new Period(0, 0, Integer.MAX_VALUE, 7, 0, 0, 0, 0); try { test.normalizedStandard(); fail(); } catch (ArithmeticException ex) {} } public void testNormalizedStandard_yearMonthWeekDay() { Period test = new Period(1, 15, 1, 12, 0, 0, 0, 0); Period result = test.normalizedStandard(); assertEquals(new Period(1, 15, 1, 12, 0, 0, 0, 0), test); assertEquals(new Period(2, 3, 2, 5, 0, 0, 0, 0), result); } public void testNormalizedStandard_yearMonthDay() { Period test = new Period(1, 15, 0, 36, 0, 0, 0, 0); Period result = test.normalizedStandard(); assertEquals(new Period(1, 15, 0, 36, 0, 0, 0, 0), test); assertEquals(new Period(2, 3, 5, 1, 0, 0, 0, 0), result); } public void testNormalizedStandard_negative() { Period test = new Period(0, 0, 0, 0, 2, -10, 0, 0); Period result = test.normalizedStandard(); assertEquals(new Period(0, 0, 0, 0, 2, -10, 0, 0), test); assertEquals(new Period(0, 0, 0, 0, 1, 50, 0, 0), result); } public void testNormalizedStandard_fullNegative() { Period test = new Period(0, 0, 0, 0, 1, -70, 0, 0); Period result = test.normalizedStandard(); assertEquals(new Period(0, 0, 0, 0, 1, -70, 0, 0), test); assertEquals(new Period(0, 0, 0, 0, 0, -10, 0, 0), result); } //----------------------------------------------------------------------- public void testNormalizedStandard_periodType_yearMonth1() { Period test = new Period(1, 15, 0, 0, 0, 0, 0, 0); Period result = test.normalizedStandard((PeriodType) null); assertEquals(new Period(1, 15, 0, 0, 0, 0, 0, 0), test); assertEquals(new Period(2, 3, 0, 0, 0, 0, 0, 0), result); } public void testNormalizedStandard_periodType_yearMonth2() { Period test = new Period(Integer.MAX_VALUE, 15, 0, 0, 0, 0, 0, 0); try { test.normalizedStandard((PeriodType) null); fail(); } catch (ArithmeticException ex) {} } public void testNormalizedStandard_periodType_yearMonth3() { Period test = new Period(1, 15, 3, 4, 0, 0, 0, 0); try { test.normalizedStandard(PeriodType.dayTime()); fail(); } catch (UnsupportedOperationException ex) {} } public void testNormalizedStandard_periodType_weekDay1() { Period test = new Period(0, 0, 1, 12, 0, 0, 0, 0); Period result = test.normalizedStandard((PeriodType) null); assertEquals(new Period(0, 0, 1, 12, 0, 0, 0, 0), test); assertEquals(new Period(0, 0, 2, 5, 0, 0, 0, 0), result); } public void testNormalizedStandard_periodType_weekDay2() { Period test = new Period(0, 0, Integer.MAX_VALUE, 7, 0, 0, 0, 0); try { test.normalizedStandard((PeriodType) null); fail(); } catch (ArithmeticException ex) {} } public void testNormalizedStandard_periodType_weekDay3() { Period test = new Period(0, 0, 1, 12, 0, 0, 0, 0); Period result = test.normalizedStandard(PeriodType.dayTime()); assertEquals(new Period(0, 0, 1, 12, 0, 0, 0, 0), test); assertEquals(new Period(0, 0, 0, 19, 0, 0, 0, 0, PeriodType.dayTime()), result); } public void testNormalizedStandard_periodType_yearMonthWeekDay() { Period test = new Period(1, 15, 1, 12, 0, 0, 0, 0); Period result = test.normalizedStandard(PeriodType.yearMonthDayTime()); assertEquals(new Period(1, 15, 1, 12, 0, 0, 0, 0), test); assertEquals(new Period(2, 3, 0, 19, 0, 0, 0, 0, PeriodType.yearMonthDayTime()), result); } public void testNormalizedStandard_periodType_yearMonthDay() { Period test = new Period(1, 15, 0, 36, 27, 0, 0, 0); Period result = test.normalizedStandard(PeriodType.yearMonthDayTime()); assertEquals(new Period(1, 15, 0, 36, 27, 0, 0, 0), test); assertEquals(new Period(2, 3, 0, 37, 3, 0, 0, 0, PeriodType.yearMonthDayTime()), result); } public void testNormalizedStandard_periodType_months1() { Period test = new Period(1, 15, 0, 0, 0, 0, 0, 0); Period result = test.normalizedStandard(PeriodType.months()); assertEquals(new Period(1, 15, 0, 0, 0, 0, 0, 0), test); assertEquals(new Period(0, 27, 0, 0, 0, 0, 0, 0, PeriodType.months()), result); } public void testNormalizedStandard_periodType_months2() { Period test = new Period(-2, 15, 0, 0, 0, 0, 0, 0); Period result = test.normalizedStandard(PeriodType.months()); assertEquals(new Period(-2, 15, 0, 0, 0, 0, 0, 0), test); assertEquals(new Period(0, -9, 0, 0, 0, 0, 0, 0, PeriodType.months()), result); } public void testNormalizedStandard_periodType_months3() { Period test = new Period(0, 4, 0, 0, 0, 0, 0, 0); Period result = test.normalizedStandard(PeriodType.months()); assertEquals(new Period(0, 4, 0, 0, 0, 0, 0, 0), test); assertEquals(new Period(0, 4, 0, 0, 0, 0, 0, 0, PeriodType.months()), result); } public void testNormalizedStandard_periodType_years() { Period test = new Period(1, 15, 0, 0, 0, 0, 0, 0); try { test.normalizedStandard(PeriodType.years()); fail(); } catch (UnsupportedOperationException ex) { // expected } } public void testNormalizedStandard_periodType_monthsWeeks() { PeriodType type = PeriodType.forFields(new DurationFieldType[]{ DurationFieldType.months(), DurationFieldType.weeks(), DurationFieldType.days()}); Period test = new Period(2, 4, 6, 0, 0, 0, 0, 0); Period result = test.normalizedStandard(type); assertEquals(new Period(2, 4, 6, 0, 0, 0, 0, 0), test); assertEquals(new Period(0, 28, 6, 0, 0, 0, 0, 0, type), result); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.CopticChronology; import org.joda.time.chrono.ISOChronology; /** * This class is a JUnit test for Duration. * * @author Stephen Colebourne */ public class TestPeriod_Constructors extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestPeriod_Constructors.class); } public TestPeriod_Constructors(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testConstants() throws Throwable { Period test = Period.ZERO; assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } //----------------------------------------------------------------------- public void testParse_noFormatter() throws Throwable { assertEquals(new Period(1, 2, 3, 4, 5, 6, 7, 890), Period.parse("P1Y2M3W4DT5H6M7.890S")); } //----------------------------------------------------------------------- public void testConstructor1() throws Throwable { Period test = new Period(); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } //----------------------------------------------------------------------- public void testConstructor_long1() throws Throwable { long length = 4 * DateTimeConstants.MILLIS_PER_DAY + 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8; Period test = new Period(length); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals((4 * 24) + 5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } public void testConstructor_long2() throws Throwable { long length = 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8; Period test = new Period(length); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } public void testConstructor_long3() throws Throwable { long length = (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; Period test = new Period(length); assertEquals(PeriodType.standard(), test.getPeriodType()); // only time fields are precise in AllType assertEquals(0, test.getYears()); // (4 + (3 * 7) + (2 * 30) + 365) == 450 assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals((450 * 24) + 5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } public void testConstructor_long_fixedZone() throws Throwable { DateTimeZone zone = DateTimeZone.getDefault(); try { DateTimeZone.setDefault(DateTimeZone.forOffsetHours(2)); long length = (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; Period test = new Period(length); assertEquals(PeriodType.standard(), test.getPeriodType()); // only time fields are precise in AllType assertEquals(0, test.getYears()); // (4 + (3 * 7) + (2 * 30) + 365) == 450 assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals((450 * 24) + 5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } finally { DateTimeZone.setDefault(zone); } } //----------------------------------------------------------------------- public void testConstructor_long_PeriodType1() throws Throwable { long length = 4 * DateTimeConstants.MILLIS_PER_DAY + 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8; Period test = new Period(length, (PeriodType) null); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals((4 * 24) + 5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } public void testConstructor_long_PeriodType2() throws Throwable { long length = 4 * DateTimeConstants.MILLIS_PER_DAY + 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8; Period test = new Period(length, PeriodType.millis()); assertEquals(PeriodType.millis(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(length, test.getMillis()); } public void testConstructor_long_PeriodType3() throws Throwable { long length = 4 * DateTimeConstants.MILLIS_PER_DAY + 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8; Period test = new Period(length, PeriodType.dayTime()); assertEquals(PeriodType.dayTime(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals((4 * 24) + 5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } public void testConstructor_long_PeriodType4() throws Throwable { long length = 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8; Period test = new Period(length, PeriodType.standard().withMillisRemoved()); assertEquals(PeriodType.standard().withMillisRemoved(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(0, test.getMillis()); } //----------------------------------------------------------------------- public void testConstructor_long_Chronology1() throws Throwable { long length = 4 * DateTimeConstants.MILLIS_PER_DAY + 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8; Period test = new Period(length, ISOChronology.getInstance()); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals((4 * 24) + 5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } public void testConstructor_long_Chronology2() throws Throwable { long length = 4 * DateTimeConstants.MILLIS_PER_DAY + 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8; Period test = new Period(length, ISOChronology.getInstanceUTC()); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(4, test.getDays()); assertEquals(5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } public void testConstructor_long_Chronology3() throws Throwable { long length = 4 * DateTimeConstants.MILLIS_PER_DAY + 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8; Period test = new Period(length, (Chronology) null); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals((4 * 24) + 5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } //----------------------------------------------------------------------- public void testConstructor_long_PeriodType_Chronology1() throws Throwable { long length = 4 * DateTimeConstants.MILLIS_PER_DAY + 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8; Period test = new Period(length, PeriodType.time().withMillisRemoved(), ISOChronology.getInstance()); assertEquals(PeriodType.time().withMillisRemoved(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals((4 * 24) + 5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(0, test.getMillis()); } public void testConstructor_long_PeriodType_Chronology2() throws Throwable { long length = 4 * DateTimeConstants.MILLIS_PER_DAY + 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8; Period test = new Period(length, PeriodType.standard(), ISOChronology.getInstanceUTC()); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(4, test.getDays()); assertEquals(5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } public void testConstructor_long_PeriodType_Chronology3() throws Throwable { long length = 4 * DateTimeConstants.MILLIS_PER_DAY + 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8; Period test = new Period(length, PeriodType.standard(), (Chronology) null); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals((4 * 24) + 5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } public void testConstructor_long_PeriodType_Chronology4() throws Throwable { long length = 4 * DateTimeConstants.MILLIS_PER_DAY + 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8; Period test = new Period(length, (PeriodType) null, (Chronology) null); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals((4 * 24) + 5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } //----------------------------------------------------------------------- /** * Test constructor (4ints) */ public void testConstructor_4int1() throws Throwable { Period test = new Period(5, 6, 7, 8); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } //----------------------------------------------------------------------- /** * Test constructor (8ints) */ public void testConstructor_8int1() throws Throwable { Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(2, test.getMonths()); assertEquals(3, test.getWeeks()); assertEquals(4, test.getDays()); assertEquals(5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } //----------------------------------------------------------------------- /** * Test constructor (8ints) */ public void testConstructor_8int__PeriodType1() throws Throwable { Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, null); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(2, test.getMonths()); assertEquals(3, test.getWeeks()); assertEquals(4, test.getDays()); assertEquals(5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } public void testConstructor_8int__PeriodType2() throws Throwable { Period test = new Period(0, 0, 0, 0, 5, 6, 7, 8, PeriodType.dayTime()); assertEquals(PeriodType.dayTime(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } public void testConstructor_8int__PeriodType3() throws Throwable { try { new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.dayTime()); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testConstructor_long_long1() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); Period test = new Period(dt1.getMillis(), dt2.getMillis()); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testConstructor_long_long2() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1); Period test = new Period(dt1.getMillis(), dt2.getMillis()); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(1, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } //----------------------------------------------------------------------- public void testConstructor_long_long_PeriodType1() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); Period test = new Period(dt1.getMillis(), dt2.getMillis(), (PeriodType) null); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testConstructor_long_long_PeriodType2() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1); Period test = new Period(dt1.getMillis(), dt2.getMillis(), PeriodType.dayTime()); assertEquals(PeriodType.dayTime(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(31, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testConstructor_long_long_PeriodType3() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2004, 6, 9, 1, 1, 1, 1); Period test = new Period(dt1.getMillis(), dt2.getMillis(), PeriodType.standard().withMillisRemoved()); assertEquals(PeriodType.standard().withMillisRemoved(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(0, test.getMillis()); } public void testToPeriod_PeriodType3() { DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10); DateTime dt2 = new DateTime(2005, 6, 9, 12, 14, 16, 18); Period test = new Period(dt1.getMillis(), dt2.getMillis(), PeriodType.yearWeekDayTime()); assertEquals(PeriodType.yearWeekDayTime(), test.getPeriodType()); assertEquals(1, test.getYears()); // tests using years and not weekyears assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(5, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(7, test.getSeconds()); assertEquals(8, test.getMillis()); } //----------------------------------------------------------------------- public void testConstructor_long_long_Chronology1() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0, CopticChronology.getInstance()); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1, CopticChronology.getInstance()); Period test = new Period(dt1.getMillis(), dt2.getMillis(), CopticChronology.getInstance()); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testConstructor_long_long_Chronology2() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); Period test = new Period(dt1.getMillis(), dt2.getMillis(), (Chronology) null); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } //----------------------------------------------------------------------- public void testConstructor_long_long_PeriodType_Chronology1() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0, CopticChronology.getInstance()); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1, CopticChronology.getInstance()); Period test = new Period(dt1.getMillis(), dt2.getMillis(), (PeriodType) null, CopticChronology.getInstance()); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testConstructor_long_long_PeriodType_Chronology2() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); Period test = new Period(dt1.getMillis(), dt2.getMillis(), (PeriodType) null, null); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } //----------------------------------------------------------------------- public void testConstructor_RI_RI1() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); Period test = new Period(dt1, dt2); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testConstructor_RI_RI2() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1); Period test = new Period(dt1, dt2); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(1, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testConstructor_RI_RI3() throws Throwable { DateTime dt1 = null; // 2002-06-09T01:00+01:00 DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1); Period test = new Period(dt1, dt2); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(3, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(1, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(0, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testConstructor_RI_RI4() throws Throwable { DateTime dt1 = new DateTime(2005, 7, 17, 1, 1, 1, 1); DateTime dt2 = null; // 2002-06-09T01:00+01:00 Period test = new Period(dt1, dt2); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(-3, test.getYears()); assertEquals(-1, test.getMonths()); assertEquals(-1, test.getWeeks()); assertEquals(-1, test.getDays()); assertEquals(0, test.getHours()); assertEquals(-1, test.getMinutes()); assertEquals(-1, test.getSeconds()); assertEquals(-1, test.getMillis()); } public void testConstructor_RI_RI5() throws Throwable { DateTime dt1 = null; // 2002-06-09T01:00+01:00 DateTime dt2 = null; // 2002-06-09T01:00+01:00 Period test = new Period(dt1, dt2); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } //----------------------------------------------------------------------- public void testConstructor_RI_RI_PeriodType1() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); Period test = new Period(dt1, dt2, null); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testConstructor_RI_RI_PeriodType2() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1); Period test = new Period(dt1, dt2, PeriodType.dayTime()); assertEquals(PeriodType.dayTime(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(31, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testConstructor_RI_RI_PeriodType3() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2004, 6, 9, 1, 1, 1, 1); Period test = new Period(dt1, dt2, PeriodType.standard().withMillisRemoved()); assertEquals(PeriodType.standard().withMillisRemoved(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(0, test.getMillis()); } public void testConstructor_RI_RI_PeriodType4() throws Throwable { DateTime dt1 = null; // 2002-06-09T01:00+01:00 DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1); Period test = new Period(dt1, dt2, PeriodType.standard()); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(3, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(1, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(0, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testConstructor_RI_RI_PeriodType5() throws Throwable { DateTime dt1 = null; // 2002-06-09T01:00+01:00 DateTime dt2 = null; // 2002-06-09T01:00+01:00 Period test = new Period(dt1, dt2, PeriodType.standard()); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } //----------------------------------------------------------------------- @SuppressWarnings("deprecation") public void testConstructor_RP_RP1() throws Throwable { YearMonthDay dt1 = new YearMonthDay(2004, 6, 9); YearMonthDay dt2 = new YearMonthDay(2005, 7, 10); Period test = new Period(dt1, dt2); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } @SuppressWarnings("deprecation") public void testConstructor_RP_RP2() throws Throwable { YearMonthDay dt1 = new YearMonthDay(2004, 6, 9); YearMonthDay dt2 = new YearMonthDay(2005, 5, 17); Period test = new Period(dt1, dt2); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(11, test.getMonths()); assertEquals(1, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } public void testConstructor_RP_RP2Local() throws Throwable { LocalDate dt1 = new LocalDate(2004, 6, 9); LocalDate dt2 = new LocalDate(2005, 5, 17); Period test = new Period(dt1, dt2); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(11, test.getMonths()); assertEquals(1, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } @SuppressWarnings("deprecation") public void testConstructor_RP_RP3() throws Throwable { YearMonthDay dt1 = null; YearMonthDay dt2 = new YearMonthDay(2005, 7, 17); try { new Period(dt1, dt2); fail(); } catch (IllegalArgumentException ex) {} } @SuppressWarnings("deprecation") public void testConstructor_RP_RP4() throws Throwable { YearMonthDay dt1 = new YearMonthDay(2005, 7, 17); YearMonthDay dt2 = null; try { new Period(dt1, dt2); fail(); } catch (IllegalArgumentException ex) {} } @SuppressWarnings("deprecation") public void testConstructor_RP_RP5() throws Throwable { YearMonthDay dt1 = null; YearMonthDay dt2 = null; try { new Period(dt1, dt2); fail(); } catch (IllegalArgumentException ex) {} } @SuppressWarnings("deprecation") public void testConstructor_RP_RP6() throws Throwable { YearMonthDay dt1 = new YearMonthDay(2005, 7, 17); TimeOfDay dt2 = new TimeOfDay(10, 20, 30, 40); try { new Period(dt1, dt2); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_RP_RP7() throws Throwable { Partial dt1 = new Partial().with(DateTimeFieldType.year(), 2005).with(DateTimeFieldType.monthOfYear(), 12); Partial dt2 = new Partial().with(DateTimeFieldType.year(), 2005).with(DateTimeFieldType.hourOfDay(), 14); try { new Period(dt1, dt2); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_RP_RP8() throws Throwable { Partial dt1 = new Partial().with(DateTimeFieldType.year(), 2005).with(DateTimeFieldType.hourOfDay(), 12); Partial dt2 = new Partial().with(DateTimeFieldType.year(), 2005).with(DateTimeFieldType.hourOfDay(), 14); try { new Period(dt1, dt2); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- @SuppressWarnings("deprecation") public void testConstructor_RP_RP_PeriodType1() throws Throwable { YearMonthDay dt1 = new YearMonthDay(2004, 6, 9); YearMonthDay dt2 = new YearMonthDay(2005, 7, 10); Period test = new Period(dt1, dt2, PeriodType.standard()); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } @SuppressWarnings("deprecation") public void testConstructor_RP_RP_PeriodType2() throws Throwable { YearMonthDay dt1 = new YearMonthDay(2004, 6, 9); YearMonthDay dt2 = new YearMonthDay(2005, 5, 17); Period test = new Period(dt1, dt2, PeriodType.yearMonthDay()); assertEquals(PeriodType.yearMonthDay(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(11, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(8, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } public void testConstructor_RP_RP_PeriodType2Local() throws Throwable { LocalDate dt1 = new LocalDate(2004, 6, 9); LocalDate dt2 = new LocalDate(2005, 5, 17); Period test = new Period(dt1, dt2, PeriodType.yearMonthDay()); assertEquals(PeriodType.yearMonthDay(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(11, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(8, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } @SuppressWarnings("deprecation") public void testConstructor_RP_RP_PeriodType3() throws Throwable { YearMonthDay dt1 = null; YearMonthDay dt2 = new YearMonthDay(2005, 7, 17); try { new Period(dt1, dt2, PeriodType.standard()); fail(); } catch (IllegalArgumentException ex) {} } @SuppressWarnings("deprecation") public void testConstructor_RP_RP_PeriodType4() throws Throwable { YearMonthDay dt1 = new YearMonthDay(2005, 7, 17); YearMonthDay dt2 = null; try { new Period(dt1, dt2); fail(); } catch (IllegalArgumentException ex) {} } @SuppressWarnings("deprecation") public void testConstructor_RP_RP_PeriodType5() throws Throwable { YearMonthDay dt1 = null; YearMonthDay dt2 = null; try { new Period(dt1, dt2, PeriodType.standard()); fail(); } catch (IllegalArgumentException ex) {} } @SuppressWarnings("deprecation") public void testConstructor_RP_RP_PeriodType6() throws Throwable { YearMonthDay dt1 = new YearMonthDay(2005, 7, 17); TimeOfDay dt2 = new TimeOfDay(10, 20, 30, 40); try { new Period(dt1, dt2, PeriodType.standard()); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_RP_RP_PeriodType7() throws Throwable { Partial dt1 = new Partial().with(DateTimeFieldType.year(), 2005).with(DateTimeFieldType.monthOfYear(), 12); Partial dt2 = new Partial().with(DateTimeFieldType.year(), 2005).with(DateTimeFieldType.hourOfDay(), 14); try { new Period(dt1, dt2, PeriodType.standard()); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_RP_RP_PeriodType8() throws Throwable { Partial dt1 = new Partial().with(DateTimeFieldType.year(), 2005).with(DateTimeFieldType.hourOfDay(), 12); Partial dt2 = new Partial().with(DateTimeFieldType.year(), 2005).with(DateTimeFieldType.hourOfDay(), 14); try { new Period(dt1, dt2, PeriodType.standard()); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testConstructor_RI_RD1() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); Duration dur = new Interval(dt1, dt2).toDuration(); Period test = new Period(dt1, dur); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testConstructor_RI_RD2() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); Duration dur = null; Period test = new Period(dt1, dur); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } //----------------------------------------------------------------------- public void testConstructor_RI_RD_PeriodType1() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); Duration dur = new Interval(dt1, dt2).toDuration(); Period test = new Period(dt1, dur, PeriodType.yearDayTime()); assertEquals(PeriodType.yearDayTime(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(31, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testConstructor_RI_RD_PeriodType2() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); Duration dur = null; Period test = new Period(dt1, dur, (PeriodType) null); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } //----------------------------------------------------------------------- public void testConstructor_RD_RI1() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); Duration dur = new Interval(dt1, dt2).toDuration(); Period test = new Period(dur, dt2); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testConstructor_RD_RI2() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); Duration dur = null; Period test = new Period(dur, dt1); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } //----------------------------------------------------------------------- public void testConstructor_RD_RI_PeriodType1() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1); Duration dur = new Interval(dt1, dt2).toDuration(); Period test = new Period(dur, dt2, PeriodType.yearDayTime()); assertEquals(PeriodType.yearDayTime(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(31, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } public void testConstructor_RD_RI_PeriodType2() throws Throwable { DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0); Duration dur = null; Period test = new Period(dur, dt1, (PeriodType) null); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } //----------------------------------------------------------------------- /** * Test constructor (Object) */ public void testConstructor_Object1() throws Throwable { Period test = new Period("P1Y2M3D"); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(2, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(3, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } public void testConstructor_Object2() throws Throwable { Period test = new Period((Object) null); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } public void testConstructor_Object3() throws Throwable { Period test = new Period(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.dayTime())); assertEquals(PeriodType.dayTime(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(1, test.getHours()); assertEquals(2, test.getMinutes()); assertEquals(3, test.getSeconds()); assertEquals(4, test.getMillis()); } public void testConstructor_Object4() throws Throwable { Period base = new Period(1, 1, 0, 1, 1, 1, 1, 1, PeriodType.standard()); Period test = new Period(base); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(1, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(1, test.getDays()); assertEquals(1, test.getHours()); assertEquals(1, test.getMinutes()); assertEquals(1, test.getSeconds()); assertEquals(1, test.getMillis()); } //----------------------------------------------------------------------- /** * Test constructor (Object) */ public void testConstructor_Object_PeriodType1() throws Throwable { Period test = new Period("P1Y2M3D", PeriodType.yearMonthDayTime()); assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType()); assertEquals(1, test.getYears()); assertEquals(2, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(3, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } public void testConstructor_Object_PeriodType2() throws Throwable { Period test = new Period((Object) null, PeriodType.yearMonthDayTime()); assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } public void testConstructor_Object_PeriodType3() throws Throwable { Period test = new Period(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.dayTime()), PeriodType.yearMonthDayTime()); assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(1, test.getHours()); assertEquals(2, test.getMinutes()); assertEquals(3, test.getSeconds()); assertEquals(4, test.getMillis()); } public void testConstructor_Object_PeriodType4() throws Throwable { Period test = new Period(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.dayTime()), (PeriodType) null); assertEquals(PeriodType.dayTime(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(1, test.getHours()); assertEquals(2, test.getMinutes()); assertEquals(3, test.getSeconds()); assertEquals(4, test.getMillis()); } //----------------------------------------------------------------------- public void testFactoryYears() throws Throwable { Period test = Period.years(6); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(6, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } public void testFactoryMonths() throws Throwable { Period test = Period.months(6); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(6, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } public void testFactoryWeeks() throws Throwable { Period test = Period.weeks(6); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(6, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } public void testFactoryDays() throws Throwable { Period test = Period.days(6); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(6, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } public void testFactoryHours() throws Throwable { Period test = Period.hours(6); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(6, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } public void testFactoryMinutes() throws Throwable { Period test = Period.minutes(6); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(6, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } public void testFactorySeconds() throws Throwable { Period test = Period.seconds(6); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(6, test.getSeconds()); assertEquals(0, test.getMillis()); } public void testFactoryMillis() throws Throwable { Period test = Period.millis(6); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(0, test.getYears()); assertEquals(0, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(0, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(6, test.getMillis()); } //------------------------------------------------------------------------- public void testConstructor_trickyDifferences_RI_RI_toFeb_standardYear() throws Throwable { DateTime dt1 = new DateTime(2011, 1, 1, 0, 0); DateTime dt2 = new DateTime(2011, 2, 28, 0, 0); Period test = new Period(dt1, dt2); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(new Period(0, 1, 3, 6, 0, 0, 0, 0), test); } public void testConstructor_trickyDifferences_RI_RI_toFeb_leapYear() throws Throwable { DateTime dt1 = new DateTime(2012, 1, 1, 0, 0); DateTime dt2 = new DateTime(2012, 2, 29, 0, 0); Period test = new Period(dt1, dt2); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(new Period(0, 1, 4, 0, 0, 0, 0, 0), test); } public void testConstructor_trickyDifferences_RI_RI_toFeb_exactMonths() throws Throwable { DateTime dt1 = new DateTime(2004, 12, 28, 0, 0); DateTime dt2 = new DateTime(2005, 2, 28, 0, 0); Period test = new Period(dt1, dt2); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(new Period(0, 2, 0, 0, 0, 0, 0, 0), test); } public void testConstructor_trickyDifferences_RI_RI_toFeb_endOfMonth1() throws Throwable { DateTime dt1 = new DateTime(2004, 12, 29, 0, 0); DateTime dt2 = new DateTime(2005, 2, 28, 0, 0); Period test = new Period(dt1, dt2); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(new Period(0, 2, 0, 0, 0, 0, 0, 0), test); } public void testConstructor_trickyDifferences_RI_RI_toFeb_endOfMonth2() throws Throwable { DateTime dt1 = new DateTime(2004, 12, 30, 0, 0); DateTime dt2 = new DateTime(2005, 2, 28, 0, 0); Period test = new Period(dt1, dt2); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(new Period(0, 2, 0, 0, 0, 0, 0, 0), test); } public void testConstructor_trickyDifferences_RI_RI_toFeb_endOfMonth3() throws Throwable { DateTime dt1 = new DateTime(2004, 12, 31, 0, 0); DateTime dt2 = new DateTime(2005, 2, 28, 0, 0); Period test = new Period(dt1, dt2); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(new Period(0, 2, 0, 0, 0, 0, 0, 0), test); } public void testConstructor_trickyDifferences_RI_RI_toMar_endOfMonth1() throws Throwable { DateTime dt1 = new DateTime(2013, 1, 31, 0, 0); DateTime dt2 = new DateTime(2013, 3, 30, 0, 0); Period test = new Period(dt1, dt2); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(new Period(0, 1, 4, 2, 0, 0, 0, 0), test); } public void testConstructor_trickyDifferences_RI_RI_toMar_endOfMonth2() throws Throwable { DateTime dt1 = new DateTime(2013, 1, 31, 0, 0); DateTime dt2 = new DateTime(2013, 3, 31, 0, 0); Period test = new Period(dt1, dt2); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(new Period(0, 2, 0, 0, 0, 0, 0, 0), test); } //------------------------------------------------------------------------- public void testConstructor_trickyDifferences_LD_LD_toFeb_standardYear() throws Throwable { LocalDate dt1 = new LocalDate(2011, 1, 1); LocalDate dt2 = new LocalDate(2011, 2, 28); Period test = new Period(dt1, dt2); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(new Period(0, 1, 3, 6, 0, 0, 0, 0), test); } public void testConstructor_trickyDifferences_LD_LD_toFeb_leapYear() throws Throwable { LocalDate dt1 = new LocalDate(2012, 1, 1); LocalDate dt2 = new LocalDate(2012, 2, 29); Period test = new Period(dt1, dt2); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(new Period(0, 1, 4, 0, 0, 0, 0, 0), test); } public void testConstructor_trickyDifferences_LD_LD_toFeb_exactMonths() throws Throwable { LocalDate dt1 = new LocalDate(2004, 12, 28); LocalDate dt2 = new LocalDate(2005, 2, 28); Period test = new Period(dt1, dt2); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(new Period(0, 2, 0, 0, 0, 0, 0, 0), test); } public void testConstructor_trickyDifferences_LD_LD_toFeb_endOfMonth1() throws Throwable { LocalDate dt1 = new LocalDate(2004, 12, 29); LocalDate dt2 = new LocalDate(2005, 2, 28); Period test = new Period(dt1, dt2); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(new Period(0, 2, 0, 0, 0, 0, 0, 0), test); } public void testConstructor_trickyDifferences_LD_LD_toFeb_endOfMonth2() throws Throwable { LocalDate dt1 = new LocalDate(2004, 12, 30); LocalDate dt2 = new LocalDate(2005, 2, 28); Period test = new Period(dt1, dt2); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(new Period(0, 2, 0, 0, 0, 0, 0, 0), test); } public void testConstructor_trickyDifferences_LD_LD_toFeb_endOfMonth3() throws Throwable { LocalDate dt1 = new LocalDate(2004, 12, 31); LocalDate dt2 = new LocalDate(2005, 2, 28); Period test = new Period(dt1, dt2); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(new Period(0, 2, 0, 0, 0, 0, 0, 0), test); } public void testConstructor_trickyDifferences_LD_LD_toMar_endOfMonth1() throws Throwable { LocalDate dt1 = new LocalDate(2013, 1, 31); LocalDate dt2 = new LocalDate(2013, 3, 30); Period test = new Period(dt1, dt2); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(new Period(0, 1, 4, 2, 0, 0, 0, 0), test); } public void testConstructor_trickyDifferences_LD_LD_toMar_endOfMonth2() throws Throwable { LocalDate dt1 = new LocalDate(2013, 1, 31); LocalDate dt2 = new LocalDate(2013, 3, 31); Period test = new Period(dt1, dt2); assertEquals(PeriodType.standard(), test.getPeriodType()); assertEquals(new Period(0, 2, 0, 0, 0, 0, 0, 0), test); } //----------------------------------------------------------------------- @SuppressWarnings("deprecation") public void testFactoryFieldDifference1() throws Throwable { YearMonthDay start = new YearMonthDay(2005, 4, 9); DateTimeFieldType[] types = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth(), }; Partial end = new Partial(types, new int[] {2004, 6, 7}); Period test = Period.fieldDifference(start, end); assertEquals(PeriodType.yearMonthDay(), test.getPeriodType()); assertEquals(-1, test.getYears()); assertEquals(2, test.getMonths()); assertEquals(0, test.getWeeks()); assertEquals(-2, test.getDays()); assertEquals(0, test.getHours()); assertEquals(0, test.getMinutes()); assertEquals(0, test.getSeconds()); assertEquals(0, test.getMillis()); } @SuppressWarnings("deprecation") public void testFactoryFieldDifference2() throws Throwable { YearMonthDay ymd = new YearMonthDay(2005, 4, 9); try { Period.fieldDifference(ymd, (ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} try { Period.fieldDifference((ReadablePartial) null, ymd); fail(); } catch (IllegalArgumentException ex) {} } @SuppressWarnings("deprecation") public void testFactoryFieldDifference3() throws Throwable { YearMonthDay start = new YearMonthDay(2005, 4, 9); TimeOfDay endTime = new TimeOfDay(12, 30, 40, 0); try { Period.fieldDifference(start, endTime); fail(); } catch (IllegalArgumentException ex) {} } @SuppressWarnings("deprecation") public void testFactoryFieldDifference4() throws Throwable { DateTimeFieldType[] types = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfWeek(), }; YearMonthDay start = new YearMonthDay(2005, 4, 9); Partial end = new Partial(types, new int[] {1, 2, 3}); try { Period.fieldDifference(start, end); fail(); } catch (IllegalArgumentException ex) {} } public void testFactoryFieldDifference5() throws Throwable { DateTimeFieldType[] types = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfWeek(), }; Partial start = new Partial(types, new int[] {1, 2, 3}); Partial end = new Partial(types, new int[] {1, 2, 3}); try { Period.fieldDifference(start, end); fail(); } catch (IllegalArgumentException ex) {} } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import junit.framework.TestCase; import junit.framework.TestSuite; /** * This class is a Junit unit test for Seconds. * * @author Stephen Colebourne */ public class TestSeconds extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestSeconds.class); } public TestSeconds(String name) { super(name); } protected void setUp() throws Exception { } protected void tearDown() throws Exception { } //----------------------------------------------------------------------- public void testConstants() { assertEquals(0, Seconds.ZERO.getSeconds()); assertEquals(1, Seconds.ONE.getSeconds()); assertEquals(2, Seconds.TWO.getSeconds()); assertEquals(3, Seconds.THREE.getSeconds()); assertEquals(Integer.MAX_VALUE, Seconds.MAX_VALUE.getSeconds()); assertEquals(Integer.MIN_VALUE, Seconds.MIN_VALUE.getSeconds()); } //----------------------------------------------------------------------- public void testFactory_seconds_int() { assertSame(Seconds.ZERO, Seconds.seconds(0)); assertSame(Seconds.ONE, Seconds.seconds(1)); assertSame(Seconds.TWO, Seconds.seconds(2)); assertSame(Seconds.THREE, Seconds.seconds(3)); assertSame(Seconds.MAX_VALUE, Seconds.seconds(Integer.MAX_VALUE)); assertSame(Seconds.MIN_VALUE, Seconds.seconds(Integer.MIN_VALUE)); assertEquals(-1, Seconds.seconds(-1).getSeconds()); assertEquals(4, Seconds.seconds(4).getSeconds()); } //----------------------------------------------------------------------- public void testFactory_secondsBetween_RInstant() { DateTime start = new DateTime(2006, 6, 9, 12, 0, 3, 0, PARIS); DateTime end1 = new DateTime(2006, 6, 9, 12, 0, 6, 0, PARIS); DateTime end2 = new DateTime(2006, 6, 9, 12, 0, 9, 0, PARIS); assertEquals(3, Seconds.secondsBetween(start, end1).getSeconds()); assertEquals(0, Seconds.secondsBetween(start, start).getSeconds()); assertEquals(0, Seconds.secondsBetween(end1, end1).getSeconds()); assertEquals(-3, Seconds.secondsBetween(end1, start).getSeconds()); assertEquals(6, Seconds.secondsBetween(start, end2).getSeconds()); } public void testFactory_secondsBetween_RPartial() { LocalTime start = new LocalTime(12, 0, 3); LocalTime end1 = new LocalTime(12, 0, 6); @SuppressWarnings("deprecation") TimeOfDay end2 = new TimeOfDay(12, 0, 9); assertEquals(3, Seconds.secondsBetween(start, end1).getSeconds()); assertEquals(0, Seconds.secondsBetween(start, start).getSeconds()); assertEquals(0, Seconds.secondsBetween(end1, end1).getSeconds()); assertEquals(-3, Seconds.secondsBetween(end1, start).getSeconds()); assertEquals(6, Seconds.secondsBetween(start, end2).getSeconds()); } public void testFactory_secondsIn_RInterval() { DateTime start = new DateTime(2006, 6, 9, 12, 0, 3, 0, PARIS); DateTime end1 = new DateTime(2006, 6, 9, 12, 0, 6, 0, PARIS); DateTime end2 = new DateTime(2006, 6, 9, 12, 0, 9, 0, PARIS); assertEquals(0, Seconds.secondsIn((ReadableInterval) null).getSeconds()); assertEquals(3, Seconds.secondsIn(new Interval(start, end1)).getSeconds()); assertEquals(0, Seconds.secondsIn(new Interval(start, start)).getSeconds()); assertEquals(0, Seconds.secondsIn(new Interval(end1, end1)).getSeconds()); assertEquals(6, Seconds.secondsIn(new Interval(start, end2)).getSeconds()); } public void testFactory_standardSecondsIn_RPeriod() { assertEquals(0, Seconds.standardSecondsIn((ReadablePeriod) null).getSeconds()); assertEquals(0, Seconds.standardSecondsIn(Period.ZERO).getSeconds()); assertEquals(1, Seconds.standardSecondsIn(new Period(0, 0, 0, 0, 0, 0, 1, 0)).getSeconds()); assertEquals(123, Seconds.standardSecondsIn(Period.seconds(123)).getSeconds()); assertEquals(-987, Seconds.standardSecondsIn(Period.seconds(-987)).getSeconds()); assertEquals(2 * 24 * 60 * 60, Seconds.standardSecondsIn(Period.days(2)).getSeconds()); try { Seconds.standardSecondsIn(Period.months(1)); fail(); } catch (IllegalArgumentException ex) { // expeceted } } public void testFactory_parseSeconds_String() { assertEquals(0, Seconds.parseSeconds((String) null).getSeconds()); assertEquals(0, Seconds.parseSeconds("PT0S").getSeconds()); assertEquals(1, Seconds.parseSeconds("PT1S").getSeconds()); assertEquals(-3, Seconds.parseSeconds("PT-3S").getSeconds()); assertEquals(2, Seconds.parseSeconds("P0Y0M0DT2S").getSeconds()); assertEquals(2, Seconds.parseSeconds("PT0H2S").getSeconds()); try { Seconds.parseSeconds("P1Y1D"); fail(); } catch (IllegalArgumentException ex) { // expeceted } try { Seconds.parseSeconds("P1DT1S"); fail(); } catch (IllegalArgumentException ex) { // expeceted } } //----------------------------------------------------------------------- public void testGetMethods() { Seconds test = Seconds.seconds(20); assertEquals(20, test.getSeconds()); } public void testGetFieldType() { Seconds test = Seconds.seconds(20); assertEquals(DurationFieldType.seconds(), test.getFieldType()); } public void testGetPeriodType() { Seconds test = Seconds.seconds(20); assertEquals(PeriodType.seconds(), test.getPeriodType()); } //----------------------------------------------------------------------- public void testIsGreaterThan() { assertEquals(true, Seconds.THREE.isGreaterThan(Seconds.TWO)); assertEquals(false, Seconds.THREE.isGreaterThan(Seconds.THREE)); assertEquals(false, Seconds.TWO.isGreaterThan(Seconds.THREE)); assertEquals(true, Seconds.ONE.isGreaterThan(null)); assertEquals(false, Seconds.seconds(-1).isGreaterThan(null)); } public void testIsLessThan() { assertEquals(false, Seconds.THREE.isLessThan(Seconds.TWO)); assertEquals(false, Seconds.THREE.isLessThan(Seconds.THREE)); assertEquals(true, Seconds.TWO.isLessThan(Seconds.THREE)); assertEquals(false, Seconds.ONE.isLessThan(null)); assertEquals(true, Seconds.seconds(-1).isLessThan(null)); } //----------------------------------------------------------------------- public void testToString() { Seconds test = Seconds.seconds(20); assertEquals("PT20S", test.toString()); test = Seconds.seconds(-20); assertEquals("PT-20S", test.toString()); } //----------------------------------------------------------------------- public void testSerialization() throws Exception { Seconds test = Seconds.THREE; ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(test); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); Seconds result = (Seconds) ois.readObject(); ois.close(); assertSame(test, result); } //----------------------------------------------------------------------- public void testToStandardWeeks() { Seconds test = Seconds.seconds(60 * 60 * 24 * 7 * 2); Weeks expected = Weeks.weeks(2); assertEquals(expected, test.toStandardWeeks()); } public void testToStandardDays() { Seconds test = Seconds.seconds(60 * 60 * 24 * 2); Days expected = Days.days(2); assertEquals(expected, test.toStandardDays()); } public void testToStandardHours() { Seconds test = Seconds.seconds(60 * 60 * 2); Hours expected = Hours.hours(2); assertEquals(expected, test.toStandardHours()); } public void testToStandardMinutes() { Seconds test = Seconds.seconds(60 * 2); Minutes expected = Minutes.minutes(2); assertEquals(expected, test.toStandardMinutes()); } public void testToStandardDuration() { Seconds test = Seconds.seconds(20); Duration expected = new Duration(20L * DateTimeConstants.MILLIS_PER_SECOND); assertEquals(expected, test.toStandardDuration()); expected = new Duration(((long) Integer.MAX_VALUE) * DateTimeConstants.MILLIS_PER_SECOND); assertEquals(expected, Seconds.MAX_VALUE.toStandardDuration()); } //----------------------------------------------------------------------- public void testPlus_int() { Seconds test2 = Seconds.seconds(2); Seconds result = test2.plus(3); assertEquals(2, test2.getSeconds()); assertEquals(5, result.getSeconds()); assertEquals(1, Seconds.ONE.plus(0).getSeconds()); try { Seconds.MAX_VALUE.plus(1); fail(); } catch (ArithmeticException ex) { // expected } } public void testPlus_Seconds() { Seconds test2 = Seconds.seconds(2); Seconds test3 = Seconds.seconds(3); Seconds result = test2.plus(test3); assertEquals(2, test2.getSeconds()); assertEquals(3, test3.getSeconds()); assertEquals(5, result.getSeconds()); assertEquals(1, Seconds.ONE.plus(Seconds.ZERO).getSeconds()); assertEquals(1, Seconds.ONE.plus((Seconds) null).getSeconds()); try { Seconds.MAX_VALUE.plus(Seconds.ONE); fail(); } catch (ArithmeticException ex) { // expected } } public void testMinus_int() { Seconds test2 = Seconds.seconds(2); Seconds result = test2.minus(3); assertEquals(2, test2.getSeconds()); assertEquals(-1, result.getSeconds()); assertEquals(1, Seconds.ONE.minus(0).getSeconds()); try { Seconds.MIN_VALUE.minus(1); fail(); } catch (ArithmeticException ex) { // expected } } public void testMinus_Seconds() { Seconds test2 = Seconds.seconds(2); Seconds test3 = Seconds.seconds(3); Seconds result = test2.minus(test3); assertEquals(2, test2.getSeconds()); assertEquals(3, test3.getSeconds()); assertEquals(-1, result.getSeconds()); assertEquals(1, Seconds.ONE.minus(Seconds.ZERO).getSeconds()); assertEquals(1, Seconds.ONE.minus((Seconds) null).getSeconds()); try { Seconds.MIN_VALUE.minus(Seconds.ONE); fail(); } catch (ArithmeticException ex) { // expected } } public void testMultipliedBy_int() { Seconds test = Seconds.seconds(2); assertEquals(6, test.multipliedBy(3).getSeconds()); assertEquals(2, test.getSeconds()); assertEquals(-6, test.multipliedBy(-3).getSeconds()); assertSame(test, test.multipliedBy(1)); Seconds halfMax = Seconds.seconds(Integer.MAX_VALUE / 2 + 1); try { halfMax.multipliedBy(2); fail(); } catch (ArithmeticException ex) { // expected } } public void testDividedBy_int() { Seconds test = Seconds.seconds(12); assertEquals(6, test.dividedBy(2).getSeconds()); assertEquals(12, test.getSeconds()); assertEquals(4, test.dividedBy(3).getSeconds()); assertEquals(3, test.dividedBy(4).getSeconds()); assertEquals(2, test.dividedBy(5).getSeconds()); assertEquals(2, test.dividedBy(6).getSeconds()); assertSame(test, test.dividedBy(1)); try { Seconds.ONE.dividedBy(0); fail(); } catch (ArithmeticException ex) { // expected } } public void testNegated() { Seconds test = Seconds.seconds(12); assertEquals(-12, test.negated().getSeconds()); assertEquals(12, test.getSeconds()); try { Seconds.MIN_VALUE.negated(); fail(); } catch (ArithmeticException ex) { // expected } } //----------------------------------------------------------------------- public void testAddToLocalDate() { Seconds test = Seconds.seconds(26); LocalDateTime date = new LocalDateTime(2006, 6, 1, 0, 0, 0, 0); LocalDateTime expected = new LocalDateTime(2006, 6, 1, 0, 0, 26, 0); assertEquals(expected, date.plus(test)); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.BuddhistChronology; import org.joda.time.chrono.CopticChronology; import org.joda.time.chrono.GJChronology; import org.joda.time.chrono.GregorianChronology; import org.joda.time.chrono.ISOChronology; import org.joda.time.chrono.JulianChronology; import org.joda.time.field.UnsupportedDateTimeField; import org.joda.time.field.UnsupportedDurationField; /** * This class is a Junit unit test for serialization. * * @author Stephen Colebourne */ public class TestSerialization extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; // 2002-04-05 private long TEST_TIME1 = (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; // 2003-05-06 private long TEST_TIME2 = (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; // private static class MockDelegatedDurationField extends DelegatedDurationField implements Serializable { // private static final long serialVersionUID = 1878496002811998493L; // public MockDelegatedDurationField() { // super(MillisDurationField.INSTANCE); // } // } private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestSerialization.class); } public TestSerialization(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testTest() { assertEquals("2002-06-09T00:00:00.000Z", new Instant(TEST_TIME_NOW).toString()); assertEquals("2002-04-05T12:24:00.000Z", new Instant(TEST_TIME1).toString()); assertEquals("2003-05-06T14:28:00.000Z", new Instant(TEST_TIME2).toString()); } //----------------------------------------------------------------------- public void testSerializedInstant() throws Exception { Instant test = new Instant(); loadAndCompare(test, "Instant", false); inlineCompare(test, false); } public void testSerializedDateTime() throws Exception { DateTime test = new DateTime(); loadAndCompare(test, "DateTime", false); inlineCompare(test, false); } public void testSerializedDateTimeProperty() throws Exception { DateTime.Property test = new DateTime().hourOfDay(); loadAndCompare(test, "DateTimeProperty", false); inlineCompare(test, false); } public void testSerializedMutableDateTime() throws Exception { MutableDateTime test = new MutableDateTime(); loadAndCompare(test, "MutableDateTime", false); inlineCompare(test, false); } public void testSerializedMutableDateTimeProperty() throws Exception { MutableDateTime.Property test = new MutableDateTime().hourOfDay(); loadAndCompare(test, "MutableDateTimeProperty", false); inlineCompare(test, false); } @SuppressWarnings("deprecation") public void testSerializedDateMidnight() throws Exception { DateMidnight test = new DateMidnight(); loadAndCompare(test, "DateMidnight", false); inlineCompare(test, false); } @SuppressWarnings("deprecation") public void testSerializedDateMidnightProperty() throws Exception { DateMidnight.Property test = new DateMidnight().monthOfYear(); loadAndCompare(test, "DateMidnightProperty", false); inlineCompare(test, false); } public void testSerializedLocalDate() throws Exception { LocalDate test = new LocalDate(); loadAndCompare(test, "LocalDate", false); inlineCompare(test, false); } public void testSerializedLocalDateBuddhist() throws Exception { LocalDate test = new LocalDate(BuddhistChronology.getInstanceUTC()); loadAndCompare(test, "LocalDateBuddhist", false); inlineCompare(test, false); } public void testSerializedLocalTime() throws Exception { LocalTime test = new LocalTime(); loadAndCompare(test, "LocalTime", false); inlineCompare(test, false); } public void testSerializedLocalDateTime() throws Exception { LocalDateTime test = new LocalDateTime(); loadAndCompare(test, "LocalDateTime", false); inlineCompare(test, false); } @SuppressWarnings("deprecation") public void testSerializedYearMonthDay() throws Exception { YearMonthDay test = new YearMonthDay(); loadAndCompare(test, "YearMonthDay", false); inlineCompare(test, false); } @SuppressWarnings("deprecation") public void testSerializedTimeOfDay() throws Exception { TimeOfDay test = new TimeOfDay(); loadAndCompare(test, "TimeOfDay", false); inlineCompare(test, false); } public void testSerializedDateTimeZoneUTC() throws Exception { DateTimeZone test = DateTimeZone.UTC; loadAndCompare(test, "DateTimeZoneUTC", true); inlineCompare(test, true); } public void testSerializedDateTimeZone() throws Exception { // have to re-get the zone, as TestDateTimeZone may have // changed the cache, or a SoftReference may have got cleared DateTimeZone test = DateTimeZone.forID("Europe/Paris"); loadAndCompare(test, "DateTimeZone", true); inlineCompare(test, true); } public void testDuration() throws Exception { Duration test = Duration.millis(12345); loadAndCompare(test, "Duration", false); inlineCompare(test, false); } public void testSerializedCopticChronology() throws Exception { CopticChronology test = CopticChronology.getInstance(LONDON); loadAndCompare(test, "CopticChronology", true); inlineCompare(test, true); } public void testSerializedISOChronology() throws Exception { ISOChronology test = ISOChronology.getInstance(PARIS); loadAndCompare(test, "ISOChronology", true); inlineCompare(test, true); } public void testSerializedGJChronology() throws Exception { GJChronology test = GJChronology.getInstance(TOKYO); loadAndCompare(test, "GJChronology", true); inlineCompare(test, true); } public void testSerializedGJChronologyChangedInternals() throws Exception { GJChronology test = GJChronology.getInstance(PARIS, 123L, 2); loadAndCompare(test, "GJChronologyChangedInternals", true); inlineCompare(test, true); } public void testSerializedGregorianChronology() throws Exception { GregorianChronology test = GregorianChronology.getInstance(PARIS); loadAndCompare(test, "GregorianChronology", true); inlineCompare(test, true); } public void testSerializedJulianChronology() throws Exception { JulianChronology test = JulianChronology.getInstance(PARIS); loadAndCompare(test, "JulianChronology", true); inlineCompare(test, true); } public void testSerializedBuddhistChronology() throws Exception { BuddhistChronology test = BuddhistChronology.getInstance(PARIS); loadAndCompare(test, "BuddhistChronology", true); inlineCompare(test, true); } public void testSerializedPeriodType() throws Exception { PeriodType test = PeriodType.dayTime(); loadAndCompare(test, "PeriodType", false); inlineCompare(test, false); } public void testSerializedDateTimeFieldType() throws Exception { DateTimeFieldType test = DateTimeFieldType.clockhourOfDay(); loadAndCompare(test, "DateTimeFieldType", true); inlineCompare(test, true); } public void testSerializedUnsupportedDateTimeField() throws Exception { UnsupportedDateTimeField test = UnsupportedDateTimeField.getInstance( DateTimeFieldType.year(), UnsupportedDurationField.getInstance(DurationFieldType.years())); loadAndCompare(test, "UnsupportedDateTimeField", true); inlineCompare(test, true); } private void loadAndCompare(Serializable test, String filename, boolean same) throws Exception { FileInputStream fis = new FileInputStream("src/test/resources/" + filename + ".dat"); ObjectInputStream ois = new ObjectInputStream(fis); Object obj = ois.readObject(); ois.close(); if (same) { assertSame(test, obj); } else { assertEquals(test, obj); } // try { // fis = new FileInputStream("src/test/resources/" + filename + "2.dat"); // ois = new ObjectInputStream(fis); // obj = ois.readObject(); // ois.close(); // if (same) { // assertSame(test, obj); // } else { // assertEquals(test, obj); // } // } catch (FileNotFoundException ex) { // // ignore // } } public void inlineCompare(Serializable test, boolean same) throws Exception { ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(test); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bais); Object obj = ois.readObject(); ois.close(); if (same) { assertSame(test, obj); } else { assertEquals(test, obj); } } // //----------------------------------------------------------------------- // public void testStoreSerializedInstant() throws Exception { // Instant test = new Instant(); // store(test, "Instant.dat"); // } // // public void testStoreSerializedDateTime() throws Exception { // DateTime test = new DateTime(); // store(test, "DateTime.dat"); // } // // public void testStoreSerializedMutableDateTime() throws Exception { // MutableDateTime test = new MutableDateTime(); // store(test, "MutableDateTime.dat"); // } // // public void testStoreSerializedDateMidnight() throws Exception { // DateMidnight test = new DateMidnight(); // store(test, "DateMidnight.dat"); // } // // public void testStoreSerializedLocalDate() throws Exception { // LocalDate test = new LocalDate(); // store(test, "LocalDate.dat"); // } // // public void testStoreSerializedLocalDateBuddhist() throws Exception { // LocalDate test = new LocalDate(BuddhistChronology.getInstanceUTC()); // store(test, "LocalDateBuddhist.dat"); // } // // public void testStoreSerializedLocalTime() throws Exception { // LocalTime test = new LocalTime(); // store(test, "LocalTime.dat"); // } // // public void testStoreSerializedLocalDateTime() throws Exception { // LocalDateTime test = new LocalDateTime(); // store(test, "LocalDateTime.dat"); // } // // public void testStoreSerializedYearMonthDay() throws Exception { // YearMonthDay test = new YearMonthDay(); // store(test, "YearMonthDay.dat"); // } // // public void testStoreSerializedYearMonthDayProperty() throws Exception { // YearMonthDay.Property test = new YearMonthDay().monthOfYear(); // store(test, "YearMonthDayProperty.dat"); // } // // public void testStoreSerializedTimeOfDay() throws Exception { // TimeOfDay test = new TimeOfDay(); // store(test, "TimeOfDay.dat"); // } // // public void testStoreSerializedTimeOfDayProperty() throws Exception { // TimeOfDay.Property test = new TimeOfDay().hourOfDay(); // store(test, "TimeOfDayProperty.dat"); // } // // public void testStoreSerializedDateTimeZoneUTC() throws Exception { // DateTimeZone test = DateTimeZone.UTC; // store(test, "DateTimeZoneUTC.dat"); // } // // public void testStoreSerializedDateTimeZone() throws Exception { // DateTimeZone test = PARIS; // store(test, "DateTimeZone.dat"); // } // // public void testStoreSerializedCopticChronology() throws Exception { // CopticChronology test = CopticChronology.getInstance(LONDON); // store(test, "CopticChronology.dat"); // } // // public void testStoreSerializedISOChronology() throws Exception { // ISOChronology test = ISOChronology.getInstance(PARIS); // store(test, "ISOChronology.dat"); // } // // public void testStoreSerializedGJChronology() throws Exception { // GJChronology test = GJChronology.getInstance(TOKYO); // store(test, "GJChronology.dat"); // } // // // Format changed in v1.2 - min days in first week not deserialized in v1.0/1.1 // public void testStoreSerializedGJChronologyChangedInternals() throws Exception { // GJChronology test = GJChronology.getInstance(PARIS, 123L, 2); // store(test, "GJChronologyChangedInternals.dat"); // } // // public void testStoreSerializedGregorianChronology() throws Exception { // GregorianChronology test = GregorianChronology.getInstance(PARIS); // store(test, "GregorianChronology.dat"); // } // // public void testStoreSerializedJulianChronology() throws Exception { // JulianChronology test = JulianChronology.getInstance(PARIS); // store(test, "JulianChronology.dat"); // } // // public void testStoreSerializedBuddhistChronology() throws Exception { // BuddhistChronology test = BuddhistChronology.getInstance(PARIS); // store(test, "BuddhistChronology.dat"); // } // // public void testStoreSerializedPeriodType() throws Exception { // PeriodType test = PeriodType.dayTime(); // store(test, "PeriodType.dat"); // } // // public void testStoreSerializedDateTimeFieldType() throws Exception { // DateTimeFieldType test = DateTimeFieldType.clockhourOfDay(); // store(test, "DateTimeFieldType.dat"); // } // // public void testStoreSerializedUnsupportedDateTimeField() throws Exception { // UnsupportedDateTimeField test = UnsupportedDateTimeField.getInstance( // DateTimeFieldType.year(), // UnsupportedDurationField.getInstance(DurationFieldType.years())); // store(test, "UnsupportedDateTimeField.dat"); // } // // public void testStoreSerializedDurationFieldType() throws Exception { // DurationFieldType test = DurationFieldType.MINUTES_TYPE; // store(test, "DurationFieldType.dat"); // } // // public void testStoreSerializedMillisDurationField() throws Exception { // MillisDurationField test = (MillisDurationField) MillisDurationField.INSTANCE; // store(test, "MillisDurationField.dat"); // } // // public void testStoreSerializedDelegatedDurationField() throws Exception { // DelegatedDurationField test = new MockDelegatedDurationField(); // store(test, "DelegatedDurationField.dat"); // } // // public void testStoreSerializedUnsupportedDurationField() throws Exception { // UnsupportedDurationField test = UnsupportedDurationField.getInstance(DurationFieldType.eras()); // store(test, "UnsupportedDurationField.dat"); // } // // format changed (properly defined) in v1.1 // public void testStoreSerializedDateTimeProperty() throws Exception { // DateTime.Property test = new DateTime().hourOfDay(); // store(test, "DateTimeProperty.dat"); // } // // public void testStoreSerializedMutableDateTimeProperty() throws Exception { // MutableDateTime.Property test = new MutableDateTime().hourOfDay(); // store(test, "MutableDateTimeProperty.dat"); // } // // public void testStoreSerializedDateMidnightProperty() throws Exception { // DateMidnight.Property test = new DateMidnight().monthOfYear(); // store(test, "DateMidnightProperty.dat"); // } // // public void testStoreSerializedDateMidnightProperty() throws Exception { // Duration test = Duration.millis(12345); // store(test, "Duration.dat"); // } // private void store(Serializable test, String filename) throws Exception { // FileOutputStream fos = new FileOutputStream("src/test/resources/" + filename); // ObjectOutputStream oos = new ObjectOutputStream(fos); // try { // oos.writeObject(test); // } finally { // oos.close(); // } // oos.close(); // } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.convert.StringConvert; import org.joda.time.chrono.ISOChronology; /** * Test string conversion. * * @author Stephen Colebourne */ public class TestStringConvert extends TestCase { private static final DateTimeZone ZONE = DateTimeZone.forID("+02:00"); public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestStringConvert.class); } public TestStringConvert(String name) { super(name); } protected void setUp() throws Exception { } protected void tearDown() throws Exception { } //----------------------------------------------------------------------- @SuppressWarnings("deprecation") public void testDateMidnight() { DateMidnight test = new DateMidnight(2010, 6, 30, ISOChronology.getInstance(ZONE)); String str = StringConvert.INSTANCE.convertToString(test); assertEquals("2010-06-30T00:00:00.000+02:00", str); assertEquals(test, StringConvert.INSTANCE.convertFromString(DateMidnight.class, str)); } public void testDateTime() { DateTime test = new DateTime(2010, 6, 30, 2, 30, 50, 678, ISOChronology.getInstance(ZONE)); String str = StringConvert.INSTANCE.convertToString(test); assertEquals("2010-06-30T02:30:50.678+02:00", str); assertEquals(test, StringConvert.INSTANCE.convertFromString(DateTime.class, str)); } public void testMutableDateTime() { MutableDateTime test = new MutableDateTime(2010, 6, 30, 2, 30, 50, 678, ISOChronology.getInstance(ZONE)); String str = StringConvert.INSTANCE.convertToString(test); assertEquals("2010-06-30T02:30:50.678+02:00", str); assertEquals(test, StringConvert.INSTANCE.convertFromString(MutableDateTime.class, str)); } public void testLocalDateTime() { LocalDateTime test = new LocalDateTime(2010, 6, 30, 2, 30); String str = StringConvert.INSTANCE.convertToString(test); assertEquals("2010-06-30T02:30:00.000", str); assertEquals(test, StringConvert.INSTANCE.convertFromString(LocalDateTime.class, str)); } public void testLocalDate() { LocalDate test = new LocalDate(2010, 6, 30); String str = StringConvert.INSTANCE.convertToString(test); assertEquals("2010-06-30", str); assertEquals(test, StringConvert.INSTANCE.convertFromString(LocalDate.class, str)); } public void testLocalTime() { LocalTime test = new LocalTime(2, 30, 50, 678); String str = StringConvert.INSTANCE.convertToString(test); assertEquals("02:30:50.678", str); assertEquals(test, StringConvert.INSTANCE.convertFromString(LocalTime.class, str)); } public void testYearMonth() { YearMonth test = new YearMonth(2010, 6); String str = StringConvert.INSTANCE.convertToString(test); assertEquals("2010-06", str); assertEquals(test, StringConvert.INSTANCE.convertFromString(YearMonth.class, str)); } public void testMonthDay() { MonthDay test = new MonthDay(6, 30); String str = StringConvert.INSTANCE.convertToString(test); assertEquals("--06-30", str); assertEquals(test, StringConvert.INSTANCE.convertFromString(MonthDay.class, str)); } public void testMonthDay_leapDay() { MonthDay test = new MonthDay(2, 29); String str = StringConvert.INSTANCE.convertToString(test); assertEquals("--02-29", str); assertEquals(test, StringConvert.INSTANCE.convertFromString(MonthDay.class, str)); } //----------------------------------------------------------------------- public void testTimeZone() { DateTimeZone test = DateTimeZone.forID("Europe/Paris"); String str = StringConvert.INSTANCE.convertToString(test); assertEquals("Europe/Paris", str); assertEquals(test, StringConvert.INSTANCE.convertFromString(DateTimeZone.class, str)); } // public void testInterval() { // DateTime a = new DateTime(2010, 6, 30, 2, 30, 50, 678, ISOChronology.getInstance(ZONE)); // DateTime b = new DateTime(2011, 9, 10, 4, 20, 40, 234, ISOChronology.getInstance(ZONE)); // Interval test = new Interval(a, b); // String str = StringConvert.INSTANCE.convertToString(test); // assertEquals("2010-06-30T02:30:50.678+02:00/2011-09-10T04:20:40.234+02:00", str); // assertEquals(test, StringConvert.INSTANCE.convertFromString(Interval.class, str)); // } public void testDuration() { Duration test = new Duration(12345678L); String str = StringConvert.INSTANCE.convertToString(test); assertEquals("PT12345.678S", str); assertEquals(test, StringConvert.INSTANCE.convertFromString(Duration.class, str)); } public void testPeriod() { Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8); String str = StringConvert.INSTANCE.convertToString(test); assertEquals("P1Y2M3W4DT5H6M7.008S", str); assertEquals(test, StringConvert.INSTANCE.convertFromString(Period.class, str)); } public void testMutablePeriod() { MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); String str = StringConvert.INSTANCE.convertToString(test); assertEquals("P1Y2M3W4DT5H6M7.008S", str); assertEquals(test, StringConvert.INSTANCE.convertFromString(MutablePeriod.class, str)); } public void testYears() { Years test = Years.years(5); String str = StringConvert.INSTANCE.convertToString(test); assertEquals("P5Y", str); assertEquals(test, StringConvert.INSTANCE.convertFromString(Years.class, str)); } public void testMonths() { Months test = Months.months(5); String str = StringConvert.INSTANCE.convertToString(test); assertEquals("P5M", str); assertEquals(test, StringConvert.INSTANCE.convertFromString(Months.class, str)); } public void testWeeks() { Weeks test = Weeks.weeks(5); String str = StringConvert.INSTANCE.convertToString(test); assertEquals("P5W", str); assertEquals(test, StringConvert.INSTANCE.convertFromString(Weeks.class, str)); } public void testDays() { Days test = Days.days(5); String str = StringConvert.INSTANCE.convertToString(test); assertEquals("P5D", str); assertEquals(test, StringConvert.INSTANCE.convertFromString(Days.class, str)); } public void testHours() { Hours test = Hours.hours(5); String str = StringConvert.INSTANCE.convertToString(test); assertEquals("PT5H", str); assertEquals(test, StringConvert.INSTANCE.convertFromString(Hours.class, str)); } public void testMinutes() { Minutes test = Minutes.minutes(5); String str = StringConvert.INSTANCE.convertToString(test); assertEquals("PT5M", str); assertEquals(test, StringConvert.INSTANCE.convertFromString(Minutes.class, str)); } public void testSeconds() { Seconds test = Seconds.seconds(5); String str = StringConvert.INSTANCE.convertToString(test); assertEquals("PT5S", str); assertEquals(test, StringConvert.INSTANCE.convertFromString(Seconds.class, str)); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Arrays; import java.util.Locale; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.BuddhistChronology; import org.joda.time.chrono.CopticChronology; import org.joda.time.chrono.GregorianChronology; import org.joda.time.chrono.ISOChronology; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; /** * This class is a Junit unit test for TimeOfDay. * * @author Stephen Colebourne */ @SuppressWarnings("deprecation") public class TestTimeOfDay_Basics extends TestCase { private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo"); private static final int OFFSET = 1; private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS); private static final Chronology COPTIC_LONDON = CopticChronology.getInstance(LONDON); private static final Chronology COPTIC_TOKYO = CopticChronology.getInstance(TOKYO); private static final Chronology COPTIC_UTC = CopticChronology.getInstanceUTC(); private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC(); private static final Chronology BUDDHIST_TOKYO = BuddhistChronology.getInstance(TOKYO); private static final Chronology BUDDHIST_UTC = BuddhistChronology.getInstanceUTC(); private long TEST_TIME_NOW = 10L * DateTimeConstants.MILLIS_PER_HOUR + 20L * DateTimeConstants.MILLIS_PER_MINUTE + 30L * DateTimeConstants.MILLIS_PER_SECOND + 40L; private long TEST_TIME2 = 1L * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; private DateTimeZone zone = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestTimeOfDay_Basics.class); } public TestTimeOfDay_Basics(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); zone = DateTimeZone.getDefault(); DateTimeZone.setDefault(LONDON); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(zone); zone = null; } //----------------------------------------------------------------------- public void testGet() { TimeOfDay test = new TimeOfDay(); assertEquals(10 + OFFSET, test.get(DateTimeFieldType.hourOfDay())); assertEquals(20, test.get(DateTimeFieldType.minuteOfHour())); assertEquals(30, test.get(DateTimeFieldType.secondOfMinute())); assertEquals(40, test.get(DateTimeFieldType.millisOfSecond())); try { test.get(null); fail(); } catch (IllegalArgumentException ex) {} try { test.get(DateTimeFieldType.dayOfMonth()); fail(); } catch (IllegalArgumentException ex) {} } public void testSize() { TimeOfDay test = new TimeOfDay(); assertEquals(4, test.size()); } public void testGetFieldType() { TimeOfDay test = new TimeOfDay(COPTIC_PARIS); assertSame(DateTimeFieldType.hourOfDay(), test.getFieldType(0)); assertSame(DateTimeFieldType.minuteOfHour(), test.getFieldType(1)); assertSame(DateTimeFieldType.secondOfMinute(), test.getFieldType(2)); assertSame(DateTimeFieldType.millisOfSecond(), test.getFieldType(3)); try { test.getFieldType(-1); } catch (IndexOutOfBoundsException ex) {} try { test.getFieldType(5); } catch (IndexOutOfBoundsException ex) {} } public void testGetFieldTypes() { TimeOfDay test = new TimeOfDay(COPTIC_PARIS); DateTimeFieldType[] fields = test.getFieldTypes(); assertSame(DateTimeFieldType.hourOfDay(), fields[0]); assertSame(DateTimeFieldType.minuteOfHour(), fields[1]); assertSame(DateTimeFieldType.secondOfMinute(), fields[2]); assertSame(DateTimeFieldType.millisOfSecond(), fields[3]); assertNotSame(test.getFieldTypes(), test.getFieldTypes()); } public void testGetField() { TimeOfDay test = new TimeOfDay(COPTIC_PARIS); assertSame(CopticChronology.getInstanceUTC().hourOfDay(), test.getField(0)); assertSame(CopticChronology.getInstanceUTC().minuteOfHour(), test.getField(1)); assertSame(CopticChronology.getInstanceUTC().secondOfMinute(), test.getField(2)); assertSame(CopticChronology.getInstanceUTC().millisOfSecond(), test.getField(3)); try { test.getField(-1); } catch (IndexOutOfBoundsException ex) {} try { test.getField(5); } catch (IndexOutOfBoundsException ex) {} } public void testGetFields() { TimeOfDay test = new TimeOfDay(COPTIC_PARIS); DateTimeField[] fields = test.getFields(); assertSame(CopticChronology.getInstanceUTC().hourOfDay(), fields[0]); assertSame(CopticChronology.getInstanceUTC().minuteOfHour(), fields[1]); assertSame(CopticChronology.getInstanceUTC().secondOfMinute(), fields[2]); assertSame(CopticChronology.getInstanceUTC().millisOfSecond(), fields[3]); assertNotSame(test.getFields(), test.getFields()); } public void testGetValue() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); assertEquals(10, test.getValue(0)); assertEquals(20, test.getValue(1)); assertEquals(30, test.getValue(2)); assertEquals(40, test.getValue(3)); try { test.getValue(-1); } catch (IndexOutOfBoundsException ex) {} try { test.getValue(5); } catch (IndexOutOfBoundsException ex) {} } public void testGetValues() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); int[] values = test.getValues(); assertEquals(10, values[0]); assertEquals(20, values[1]); assertEquals(30, values[2]); assertEquals(40, values[3]); assertNotSame(test.getValues(), test.getValues()); } public void testIsSupported() { TimeOfDay test = new TimeOfDay(COPTIC_PARIS); assertEquals(true, test.isSupported(DateTimeFieldType.hourOfDay())); assertEquals(true, test.isSupported(DateTimeFieldType.minuteOfHour())); assertEquals(true, test.isSupported(DateTimeFieldType.secondOfMinute())); assertEquals(true, test.isSupported(DateTimeFieldType.millisOfSecond())); assertEquals(false, test.isSupported(DateTimeFieldType.dayOfMonth())); } public void testEqualsHashCode() { TimeOfDay test1 = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); TimeOfDay test2 = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); assertEquals(true, test1.equals(test2)); assertEquals(true, test2.equals(test1)); assertEquals(true, test1.equals(test1)); assertEquals(true, test2.equals(test2)); assertEquals(true, test1.hashCode() == test2.hashCode()); assertEquals(true, test1.hashCode() == test1.hashCode()); assertEquals(true, test2.hashCode() == test2.hashCode()); TimeOfDay test3 = new TimeOfDay(15, 20, 30, 40); assertEquals(false, test1.equals(test3)); assertEquals(false, test2.equals(test3)); assertEquals(false, test3.equals(test1)); assertEquals(false, test3.equals(test2)); assertEquals(false, test1.hashCode() == test3.hashCode()); assertEquals(false, test2.hashCode() == test3.hashCode()); assertEquals(false, test1.equals("Hello")); assertEquals(true, test1.equals(new MockInstant())); assertEquals(false, test1.equals(MockPartial.EMPTY_INSTANCE)); } class MockInstant extends MockPartial { public Chronology getChronology() { return CopticChronology.getInstanceUTC(); } public DateTimeField[] getFields() { return new DateTimeField[] { CopticChronology.getInstanceUTC().hourOfDay(), CopticChronology.getInstanceUTC().minuteOfHour(), CopticChronology.getInstanceUTC().secondOfMinute(), CopticChronology.getInstanceUTC().millisOfSecond(), }; } public int[] getValues() { return new int[] {10, 20, 30, 40}; } } //----------------------------------------------------------------------- public void testCompareTo() { TimeOfDay test1 = new TimeOfDay(10, 20, 30, 40); TimeOfDay test1a = new TimeOfDay(10, 20, 30, 40); assertEquals(0, test1.compareTo(test1a)); assertEquals(0, test1a.compareTo(test1)); assertEquals(0, test1.compareTo(test1)); assertEquals(0, test1a.compareTo(test1a)); TimeOfDay test2 = new TimeOfDay(10, 20, 35, 40); assertEquals(-1, test1.compareTo(test2)); assertEquals(+1, test2.compareTo(test1)); TimeOfDay test3 = new TimeOfDay(10, 20, 35, 40, GregorianChronology.getInstanceUTC()); assertEquals(-1, test1.compareTo(test3)); assertEquals(+1, test3.compareTo(test1)); assertEquals(0, test3.compareTo(test2)); DateTimeFieldType[] types = new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond(), }; int[] values = new int[] {10, 20, 30, 40}; Partial p = new Partial(types, values); assertEquals(0, test1.compareTo(p)); try { test1.compareTo(null); fail(); } catch (NullPointerException ex) {} // try { // test1.compareTo(new Date()); // fail(); // } catch (ClassCastException ex) {} } //----------------------------------------------------------------------- public void testIsEqual_TOD() { TimeOfDay test1 = new TimeOfDay(10, 20, 30, 40); TimeOfDay test1a = new TimeOfDay(10, 20, 30, 40); assertEquals(true, test1.isEqual(test1a)); assertEquals(true, test1a.isEqual(test1)); assertEquals(true, test1.isEqual(test1)); assertEquals(true, test1a.isEqual(test1a)); TimeOfDay test2 = new TimeOfDay(10, 20, 35, 40); assertEquals(false, test1.isEqual(test2)); assertEquals(false, test2.isEqual(test1)); TimeOfDay test3 = new TimeOfDay(10, 20, 35, 40, GregorianChronology.getInstanceUTC()); assertEquals(false, test1.isEqual(test3)); assertEquals(false, test3.isEqual(test1)); assertEquals(true, test3.isEqual(test2)); try { new TimeOfDay(10, 20, 35, 40).isEqual(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testIsBefore_TOD() { TimeOfDay test1 = new TimeOfDay(10, 20, 30, 40); TimeOfDay test1a = new TimeOfDay(10, 20, 30, 40); assertEquals(false, test1.isBefore(test1a)); assertEquals(false, test1a.isBefore(test1)); assertEquals(false, test1.isBefore(test1)); assertEquals(false, test1a.isBefore(test1a)); TimeOfDay test2 = new TimeOfDay(10, 20, 35, 40); assertEquals(true, test1.isBefore(test2)); assertEquals(false, test2.isBefore(test1)); TimeOfDay test3 = new TimeOfDay(10, 20, 35, 40, GregorianChronology.getInstanceUTC()); assertEquals(true, test1.isBefore(test3)); assertEquals(false, test3.isBefore(test1)); assertEquals(false, test3.isBefore(test2)); try { new TimeOfDay(10, 20, 35, 40).isBefore(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testIsAfter_TOD() { TimeOfDay test1 = new TimeOfDay(10, 20, 30, 40); TimeOfDay test1a = new TimeOfDay(10, 20, 30, 40); assertEquals(false, test1.isAfter(test1a)); assertEquals(false, test1a.isAfter(test1)); assertEquals(false, test1.isAfter(test1)); assertEquals(false, test1a.isAfter(test1a)); TimeOfDay test2 = new TimeOfDay(10, 20, 35, 40); assertEquals(false, test1.isAfter(test2)); assertEquals(true, test2.isAfter(test1)); TimeOfDay test3 = new TimeOfDay(10, 20, 35, 40, GregorianChronology.getInstanceUTC()); assertEquals(false, test1.isAfter(test3)); assertEquals(true, test3.isAfter(test1)); assertEquals(false, test3.isAfter(test2)); try { new TimeOfDay(10, 20, 35, 40).isAfter(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testWithChronologyRetainFields_Chrono() { TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); TimeOfDay test = base.withChronologyRetainFields(BUDDHIST_TOKYO); check(base, 10, 20, 30, 40); assertEquals(COPTIC_UTC, base.getChronology()); check(test, 10, 20, 30, 40); assertEquals(BUDDHIST_UTC, test.getChronology()); } public void testWithChronologyRetainFields_sameChrono() { TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); TimeOfDay test = base.withChronologyRetainFields(COPTIC_TOKYO); assertSame(base, test); } public void testWithChronologyRetainFields_nullChrono() { TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); TimeOfDay test = base.withChronologyRetainFields(null); check(base, 10, 20, 30, 40); assertEquals(COPTIC_UTC, base.getChronology()); check(test, 10, 20, 30, 40); assertEquals(ISO_UTC, test.getChronology()); } //----------------------------------------------------------------------- public void testWithField1() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); TimeOfDay result = test.withField(DateTimeFieldType.hourOfDay(), 15); assertEquals(new TimeOfDay(10, 20, 30, 40), test); assertEquals(new TimeOfDay(15, 20, 30, 40), result); } public void testWithField2() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); try { test.withField(null, 6); fail(); } catch (IllegalArgumentException ex) {} } public void testWithField3() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); try { test.withField(DateTimeFieldType.dayOfMonth(), 6); fail(); } catch (IllegalArgumentException ex) {} } public void testWithField4() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); TimeOfDay result = test.withField(DateTimeFieldType.hourOfDay(), 10); assertSame(test, result); } //----------------------------------------------------------------------- public void testWithFieldAdded1() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); TimeOfDay result = test.withFieldAdded(DurationFieldType.hours(), 6); assertEquals(new TimeOfDay(10, 20, 30, 40), test); assertEquals(new TimeOfDay(16, 20, 30, 40), result); } public void testWithFieldAdded2() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); try { test.withFieldAdded(null, 0); fail(); } catch (IllegalArgumentException ex) {} } public void testWithFieldAdded3() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); try { test.withFieldAdded(null, 6); fail(); } catch (IllegalArgumentException ex) {} } public void testWithFieldAdded4() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); TimeOfDay result = test.withFieldAdded(DurationFieldType.hours(), 0); assertSame(test, result); } public void testWithFieldAdded5() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); try { test.withFieldAdded(DurationFieldType.days(), 6); fail(); } catch (IllegalArgumentException ex) {} } public void testWithFieldAdded6() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); TimeOfDay result = test.withFieldAdded(DurationFieldType.hours(), 16); assertEquals(new TimeOfDay(10, 20, 30, 40), test); assertEquals(new TimeOfDay(2, 20, 30, 40), result); } public void testWithFieldAdded7() { TimeOfDay test = new TimeOfDay(23, 59, 59, 999); TimeOfDay result = test.withFieldAdded(DurationFieldType.millis(), 1); assertEquals(new TimeOfDay(0, 0, 0, 0), result); test = new TimeOfDay(23, 59, 59, 999); result = test.withFieldAdded(DurationFieldType.seconds(), 1); assertEquals(new TimeOfDay(0, 0, 0, 999), result); test = new TimeOfDay(23, 59, 59, 999); result = test.withFieldAdded(DurationFieldType.minutes(), 1); assertEquals(new TimeOfDay(0, 0, 59, 999), result); test = new TimeOfDay(23, 59, 59, 999); result = test.withFieldAdded(DurationFieldType.hours(), 1); assertEquals(new TimeOfDay(0, 59, 59, 999), result); } public void testWithFieldAdded8() { TimeOfDay test = new TimeOfDay(0, 0, 0, 0); TimeOfDay result = test.withFieldAdded(DurationFieldType.millis(), -1); assertEquals(new TimeOfDay(23, 59, 59, 999), result); test = new TimeOfDay(0, 0, 0, 0); result = test.withFieldAdded(DurationFieldType.seconds(), -1); assertEquals(new TimeOfDay(23, 59, 59, 0), result); test = new TimeOfDay(0, 0, 0, 0); result = test.withFieldAdded(DurationFieldType.minutes(), -1); assertEquals(new TimeOfDay(23, 59, 0, 0), result); test = new TimeOfDay(0, 0, 0, 0); result = test.withFieldAdded(DurationFieldType.hours(), -1); assertEquals(new TimeOfDay(23, 0, 0, 0), result); } //----------------------------------------------------------------------- public void testPlus_RP() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40, BuddhistChronology.getInstance()); TimeOfDay result = test.plus(new Period(1, 2, 3, 4, 5, 6, 7, 8)); TimeOfDay expected = new TimeOfDay(15, 26, 37, 48, BuddhistChronology.getInstance()); assertEquals(expected, result); result = test.plus((ReadablePeriod) null); assertSame(test, result); } public void testPlusHours_int() { TimeOfDay test = new TimeOfDay(1, 2, 3, 4, BuddhistChronology.getInstance()); TimeOfDay result = test.plusHours(1); TimeOfDay expected = new TimeOfDay(2, 2, 3, 4, BuddhistChronology.getInstance()); assertEquals(expected, result); result = test.plusHours(0); assertSame(test, result); } public void testPlusMinutes_int() { TimeOfDay test = new TimeOfDay(1, 2, 3, 4, BuddhistChronology.getInstance()); TimeOfDay result = test.plusMinutes(1); TimeOfDay expected = new TimeOfDay(1, 3, 3, 4, BuddhistChronology.getInstance()); assertEquals(expected, result); result = test.plusMinutes(0); assertSame(test, result); } public void testPlusSeconds_int() { TimeOfDay test = new TimeOfDay(1, 2, 3, 4, BuddhistChronology.getInstance()); TimeOfDay result = test.plusSeconds(1); TimeOfDay expected = new TimeOfDay(1, 2, 4, 4, BuddhistChronology.getInstance()); assertEquals(expected, result); result = test.plusSeconds(0); assertSame(test, result); } public void testPlusMillis_int() { TimeOfDay test = new TimeOfDay(1, 2, 3, 4, BuddhistChronology.getInstance()); TimeOfDay result = test.plusMillis(1); TimeOfDay expected = new TimeOfDay(1, 2, 3, 5, BuddhistChronology.getInstance()); assertEquals(expected, result); result = test.plusMillis(0); assertSame(test, result); } //----------------------------------------------------------------------- public void testMinus_RP() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40, BuddhistChronology.getInstance()); TimeOfDay result = test.minus(new Period(1, 1, 1, 1, 1, 1, 1, 1)); TimeOfDay expected = new TimeOfDay(9, 19, 29, 39, BuddhistChronology.getInstance()); assertEquals(expected, result); result = test.minus((ReadablePeriod) null); assertSame(test, result); } public void testMinusHours_int() { TimeOfDay test = new TimeOfDay(1, 2, 3, 4, BuddhistChronology.getInstance()); TimeOfDay result = test.minusHours(1); TimeOfDay expected = new TimeOfDay(0, 2, 3, 4, BuddhistChronology.getInstance()); assertEquals(expected, result); result = test.minusHours(0); assertSame(test, result); } public void testMinusMinutes_int() { TimeOfDay test = new TimeOfDay(1, 2, 3, 4, BuddhistChronology.getInstance()); TimeOfDay result = test.minusMinutes(1); TimeOfDay expected = new TimeOfDay(1, 1, 3, 4, BuddhistChronology.getInstance()); assertEquals(expected, result); result = test.minusMinutes(0); assertSame(test, result); } public void testMinusSeconds_int() { TimeOfDay test = new TimeOfDay(1, 2, 3, 4, BuddhistChronology.getInstance()); TimeOfDay result = test.minusSeconds(1); TimeOfDay expected = new TimeOfDay(1, 2, 2, 4, BuddhistChronology.getInstance()); assertEquals(expected, result); result = test.minusSeconds(0); assertSame(test, result); } public void testMinusMillis_int() { TimeOfDay test = new TimeOfDay(1, 2, 3, 4, BuddhistChronology.getInstance()); TimeOfDay result = test.minusMillis(1); TimeOfDay expected = new TimeOfDay(1, 2, 3, 3, BuddhistChronology.getInstance()); assertEquals(expected, result); result = test.minusMillis(0); assertSame(test, result); } //----------------------------------------------------------------------- public void testToLocalTime() { TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_UTC); LocalTime test = base.toLocalTime(); assertEquals(new LocalTime(10, 20, 30, 40, COPTIC_UTC), test); } //----------------------------------------------------------------------- public void testToDateTimeToday() { TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); // PARIS irrelevant DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9); DateTimeUtils.setCurrentMillisFixed(dt.getMillis()); DateTime test = base.toDateTimeToday(); check(base, 10, 20, 30, 40); DateTime expected = new DateTime(dt.getMillis(), COPTIC_LONDON); expected = expected.hourOfDay().setCopy(10); expected = expected.minuteOfHour().setCopy(20); expected = expected.secondOfMinute().setCopy(30); expected = expected.millisOfSecond().setCopy(40); assertEquals(expected, test); } //----------------------------------------------------------------------- public void testToDateTimeToday_Zone() { TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); // PARIS irrelevant DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9); DateTimeUtils.setCurrentMillisFixed(dt.getMillis()); DateTime test = base.toDateTimeToday(TOKYO); check(base, 10, 20, 30, 40); DateTime expected = new DateTime(dt.getMillis(), COPTIC_TOKYO); expected = expected.hourOfDay().setCopy(10); expected = expected.minuteOfHour().setCopy(20); expected = expected.secondOfMinute().setCopy(30); expected = expected.millisOfSecond().setCopy(40); assertEquals(expected, test); } public void testToDateTimeToday_nullZone() { TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); // PARIS irrelevant DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9); DateTimeUtils.setCurrentMillisFixed(dt.getMillis()); DateTime test = base.toDateTimeToday((DateTimeZone) null); check(base, 10, 20, 30, 40); DateTime expected = new DateTime(dt.getMillis(), COPTIC_LONDON); expected = expected.hourOfDay().setCopy(10); expected = expected.minuteOfHour().setCopy(20); expected = expected.secondOfMinute().setCopy(30); expected = expected.millisOfSecond().setCopy(40); assertEquals(expected, test); } // Removed as too complex // /** // * Merges two partial together, taking account of the different chronologies. // * // * @param main the main partial // * @param base the partial to use as a base to merge on top of // * @param instant the instant to start from and to use for missing fields // * @return the merged instant // */ // public long merge(ReadablePartial main, ReadablePartial base, long instant) { // DateTimeZone zone = main.getChronology().getZone(); // instant = base.getChronology().withZone(zone).set(base, instant); // return set(main, instant); // } // // //----------------------------------------------------------------------- // /** // * Converts this object to a DateTime using a YearMonthDay to fill in the // * missing fields and using the default time zone. // * This instance is immutable and unaffected by this method call. // * <p> // * The resulting chronology is determined by the chronology of this // * TimeOfDay plus the time zone. // * <p> // * This method makes use of the chronology of the specified YearMonthDay // * in the calculation. This can be significant when mixing chronologies. // * If the YearMonthDay is in the same chronology as this instance the // * method will perform exactly as you might expect. // * <p> // * If the chronologies differ, then both this TimeOfDay and the YearMonthDay // * are converted to the destination chronology and then merged. As a result // * it may be the case that the year, monthOfYear and dayOfMonth fields on // * the result are different from the values returned by the methods on the // * YearMonthDay. // * <p> // * See {@link DateTime#withFields(ReadablePartial)} for an algorithm that // * ignores the chronology. // * // * @param date the date to use, null means today // * @return the DateTime instance // */ // public DateTime toDateTime(YearMonthDay date) { // return toDateTime(date, null); // } // // /** // * Converts this object to a DateTime using a YearMonthDay to fill in the // * missing fields. // * This instance is immutable and unaffected by this method call. // * <p> // * The resulting chronology is determined by the chronology of this // * TimeOfDay plus the time zone. // * <p> // * This method makes use of the chronology of the specified YearMonthDay // * in the calculation. This can be significant when mixing chronologies. // * If the YearMonthDay is in the same chronology as this instance the // * method will perform exactly as you might expect. // * <p> // * If the chronologies differ, then both this TimeOfDay and the YearMonthDay // * are converted to the destination chronology and then merged. As a result // * it may be the case that the year, monthOfYear and dayOfMonth fields on // * the result are different from the values returned by the methods on the // * YearMonthDay. // * <p> // * See {@link DateTime#withFields(ReadablePartial)} for an algorithm that // * ignores the chronology and just assigns the fields. // * // * @param date the date to use, null means today // * @param zone the zone to get the DateTime in, null means default // * @return the DateTime instance // */ // public DateTime toDateTime(YearMonthDay date, DateTimeZone zone) { // Chronology chrono = getChronology().withZone(zone); // if (date == null) { // DateTime dt = new DateTime(chrono); // return dt.withFields(this); // } else { // long millis = chrono.merge(this, date, DateTimeUtils.currentTimeMillis()); // return new DateTime(millis, chrono); // } // } // // //----------------------------------------------------------------------- // public void testToDateTime_YMD() { // TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); // PARIS irrelevant // YearMonthDay ymd = new YearMonthDay(new DateMidnight(2004, 6, 9), BUDDHIST_TOKYO); // // DateTime test = base.toDateTime(ymd); // check(base, 10, 20, 30, 40); // DateTime expected = new DateTime(ymd.toDateMidnight(LONDON), COPTIC_LONDON); // expected = expected.hourOfDay().setCopy(10); // expected = expected.minuteOfHour().setCopy(20); // expected = expected.secondOfMinute().setCopy(30); // expected = expected.millisOfSecond().setCopy(40); // assertEquals(expected, test); // } // // public void testToDateTime_nullYMD() { // TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); // PARIS irrelevant // // DateTime test = base.toDateTime((YearMonthDay) null); // check(base, 10, 20, 30, 40); // DateTime expected = new DateTime(COPTIC_LONDON); // expected = expected.hourOfDay().setCopy(10); // expected = expected.minuteOfHour().setCopy(20); // expected = expected.secondOfMinute().setCopy(30); // expected = expected.millisOfSecond().setCopy(40); // assertEquals(expected, test); // } // // //----------------------------------------------------------------------- // public void testToDateTime_YMD_Zone() { // TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); // PARIS irrelevant // YearMonthDay ymd = new YearMonthDay(new DateMidnight(2004, 6, 9), BUDDHIST_LONDON); // // DateTime test = base.toDateTime(ymd, TOKYO); // check(base, 10, 20, 30, 40); // DateTime expected = new DateTime(ymd.toDateMidnight(TOKYO), COPTIC_TOKYO); // expected = expected.hourOfDay().setCopy(10); // expected = expected.minuteOfHour().setCopy(20); // expected = expected.secondOfMinute().setCopy(30); // expected = expected.millisOfSecond().setCopy(40); // assertEquals(expected, test); // } // // public void testToDateTime_YMD_nullZone() { // TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); // PARIS irrelevant // YearMonthDay ymd = new YearMonthDay(new DateMidnight(2004, 6, 9), BUDDHIST_LONDON); // // DateTime test = base.toDateTime(ymd, null); // check(base, 10, 20, 30, 40); // DateTime expected = new DateTime(ymd.toDateMidnight(LONDON), COPTIC_LONDON); // expected = expected.hourOfDay().setCopy(10); // expected = expected.minuteOfHour().setCopy(20); // expected = expected.secondOfMinute().setCopy(30); // expected = expected.millisOfSecond().setCopy(40); // assertEquals(expected, test); // } // // public void testToDateTime_nullYMD_Zone() { // TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); // PARIS irrelevant // // DateTime test = base.toDateTime((YearMonthDay) null, TOKYO); // check(base, 10, 20, 30, 40); // DateTime expected = new DateTime(COPTIC_TOKYO); // expected = expected.hourOfDay().setCopy(10); // expected = expected.minuteOfHour().setCopy(20); // expected = expected.secondOfMinute().setCopy(30); // expected = expected.millisOfSecond().setCopy(40); // assertEquals(expected, test); // } //----------------------------------------------------------------------- public void testToDateTime_RI() { TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); DateTime dt = new DateTime(0L); // LONDON zone assertEquals("1970-01-01T01:00:00.000+01:00", dt.toString()); DateTime test = base.toDateTime(dt); check(base, 10, 20, 30, 40); assertEquals("1970-01-01T01:00:00.000+01:00", dt.toString()); assertEquals("1970-01-01T10:20:30.040+01:00", test.toString()); } public void testToDateTime_nullRI() { TimeOfDay base = new TimeOfDay(1, 2, 3, 4); DateTimeUtils.setCurrentMillisFixed(TEST_TIME2); DateTime test = base.toDateTime((ReadableInstant) null); check(base, 1, 2, 3, 4); assertEquals("1970-01-02T01:02:03.004+01:00", test.toString()); } //----------------------------------------------------------------------- public void testWithers() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); check(test.withHourOfDay(6), 6, 20, 30, 40); check(test.withMinuteOfHour(6), 10, 6, 30, 40); check(test.withSecondOfMinute(6), 10, 20, 6, 40); check(test.withMillisOfSecond(6), 10, 20, 30, 6); try { test.withHourOfDay(-1); fail(); } catch (IllegalArgumentException ex) {} try { test.withHourOfDay(24); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testProperty() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); assertEquals(test.hourOfDay(), test.property(DateTimeFieldType.hourOfDay())); assertEquals(test.minuteOfHour(), test.property(DateTimeFieldType.minuteOfHour())); assertEquals(test.secondOfMinute(), test.property(DateTimeFieldType.secondOfMinute())); assertEquals(test.millisOfSecond(), test.property(DateTimeFieldType.millisOfSecond())); try { test.property(DateTimeFieldType.millisOfDay()); fail(); } catch (IllegalArgumentException ex) {} try { test.property(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testSerialization() throws Exception { TimeOfDay test = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(test); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); TimeOfDay result = (TimeOfDay) ois.readObject(); ois.close(); assertEquals(test, result); assertTrue(Arrays.equals(test.getValues(), result.getValues())); assertTrue(Arrays.equals(test.getFields(), result.getFields())); assertEquals(test.getChronology(), result.getChronology()); } //----------------------------------------------------------------------- public void testToString() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); assertEquals("T10:20:30.040", test.toString()); } //----------------------------------------------------------------------- public void testToString_String() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); assertEquals("\ufffd\ufffd\ufffd\ufffd 10", test.toString("yyyy HH")); assertEquals("T10:20:30.040", test.toString((String) null)); } //----------------------------------------------------------------------- public void testToString_String_Locale() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); assertEquals("10 20", test.toString("H m", Locale.ENGLISH)); assertEquals("T10:20:30.040", test.toString(null, Locale.ENGLISH)); assertEquals("10 20", test.toString("H m", null)); assertEquals("T10:20:30.040", test.toString(null, null)); } //----------------------------------------------------------------------- public void testToString_DTFormatter() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); assertEquals("\ufffd\ufffd\ufffd\ufffd 10", test.toString(DateTimeFormat.forPattern("yyyy HH"))); assertEquals("T10:20:30.040", test.toString((DateTimeFormatter) null)); } //----------------------------------------------------------------------- private void check(TimeOfDay test, int hour, int min, int sec, int milli) { assertEquals(hour, test.getHourOfDay()); assertEquals(min, test.getMinuteOfHour()); assertEquals(sec, test.getSecondOfMinute()); assertEquals(milli, test.getMillisOfSecond()); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.CopticChronology; import org.joda.time.chrono.GJChronology; import org.joda.time.chrono.ISOChronology; import org.joda.time.chrono.JulianChronology; /** * This class is a Junit unit test for TimeOfDay. * * @author Stephen Colebourne */ @SuppressWarnings("deprecation") public class TestTimeOfDay_Constructors extends TestCase { private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final ISOChronology ISO_UTC = ISOChronology.getInstanceUTC(); private static final int OFFSET = 1; private long TEST_TIME_NOW = 10L * DateTimeConstants.MILLIS_PER_HOUR + 20L * DateTimeConstants.MILLIS_PER_MINUTE + 30L * DateTimeConstants.MILLIS_PER_SECOND + 40L; private long TEST_TIME1 = 1L * DateTimeConstants.MILLIS_PER_HOUR + 2L * DateTimeConstants.MILLIS_PER_MINUTE + 3L * DateTimeConstants.MILLIS_PER_SECOND + 4L; private long TEST_TIME2 = 1L * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; private DateTimeZone zone = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestTimeOfDay_Constructors.class); } public TestTimeOfDay_Constructors(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); zone = DateTimeZone.getDefault(); DateTimeZone.setDefault(LONDON); java.util.TimeZone.setDefault(LONDON.toTimeZone()); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(zone); java.util.TimeZone.setDefault(zone.toTimeZone()); zone = null; } //----------------------------------------------------------------------- /** * Test constructor () */ public void testConstantMidnight() throws Throwable { TimeOfDay test = TimeOfDay.MIDNIGHT; assertEquals(ISO_UTC, test.getChronology()); assertEquals(0, test.getHourOfDay()); assertEquals(0, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } //----------------------------------------------------------------------- public void testFactory_FromCalendarFields() throws Exception { GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6); cal.set(Calendar.MILLISECOND, 7); TimeOfDay expected = new TimeOfDay(4, 5, 6, 7); assertEquals(expected, TimeOfDay.fromCalendarFields(cal)); try { TimeOfDay.fromCalendarFields(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testFactory_FromDateFields_after1970() throws Exception { GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6); cal.set(Calendar.MILLISECOND, 7); TimeOfDay expected = new TimeOfDay(4, 5, 6, 7); assertEquals(expected, TimeOfDay.fromDateFields(cal.getTime())); } public void testFactory_FromDateFields_before1970() throws Exception { GregorianCalendar cal = new GregorianCalendar(1969, 1, 3, 4, 5, 6); cal.set(Calendar.MILLISECOND, 7); TimeOfDay expected = new TimeOfDay(4, 5, 6, 7); assertEquals(expected, TimeOfDay.fromDateFields(cal.getTime())); } public void testFactory_FromDateFields_null() throws Exception { try { TimeOfDay.fromDateFields(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- /** * Test factory (long) */ public void testFactoryMillisOfDay_long1() throws Throwable { TimeOfDay test = TimeOfDay.fromMillisOfDay(TEST_TIME1); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1, test.getHourOfDay()); assertEquals(2, test.getMinuteOfHour()); assertEquals(3, test.getSecondOfMinute()); assertEquals(4, test.getMillisOfSecond()); } /** * Test factory (long, Chronology) */ public void testFactoryMillisOfDay_long1_Chronology() throws Throwable { TimeOfDay test = TimeOfDay.fromMillisOfDay(TEST_TIME1, JulianChronology.getInstance()); assertEquals(JulianChronology.getInstanceUTC(), test.getChronology()); assertEquals(1, test.getHourOfDay()); assertEquals(2, test.getMinuteOfHour()); assertEquals(3, test.getSecondOfMinute()); assertEquals(4, test.getMillisOfSecond()); } /** * Test factory (long, Chronology=null) */ public void testFactoryMillisOfDay_long_nullChronology() throws Throwable { TimeOfDay test = TimeOfDay.fromMillisOfDay(TEST_TIME1, null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1, test.getHourOfDay()); assertEquals(2, test.getMinuteOfHour()); assertEquals(3, test.getSecondOfMinute()); assertEquals(4, test.getMillisOfSecond()); } //----------------------------------------------------------------------- /** * Test constructor () */ public void testConstructor() throws Throwable { TimeOfDay test = new TimeOfDay(); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10 + OFFSET, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } /** * Test constructor (DateTimeZone) */ public void testConstructor_DateTimeZone() throws Throwable { DateTime dt = new DateTime(2005, 6, 8, 23, 59, 30, 40, LONDON); DateTimeUtils.setCurrentMillisFixed(dt.getMillis()); // 23:59 in London is 00:59 the following day in Paris TimeOfDay test = new TimeOfDay(LONDON); assertEquals(ISO_UTC, test.getChronology()); assertEquals(23, test.getHourOfDay()); assertEquals(59, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); test = new TimeOfDay(PARIS); assertEquals(ISO_UTC, test.getChronology()); assertEquals(0, test.getHourOfDay()); assertEquals(59, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } /** * Test constructor (DateTimeZone=null) */ public void testConstructor_nullDateTimeZone() throws Throwable { DateTime dt = new DateTime(2005, 6, 8, 23, 59, 30, 40, LONDON); DateTimeUtils.setCurrentMillisFixed(dt.getMillis()); // 23:59 in London is 00:59 the following day in Paris TimeOfDay test = new TimeOfDay((DateTimeZone) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(23, test.getHourOfDay()); assertEquals(59, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } /** * Test constructor (Chronology) */ public void testConstructor_Chronology() throws Throwable { TimeOfDay test = new TimeOfDay(JulianChronology.getInstance()); assertEquals(JulianChronology.getInstanceUTC(), test.getChronology()); assertEquals(10 + OFFSET, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } /** * Test constructor (Chronology=null) */ public void testConstructor_nullChronology() throws Throwable { TimeOfDay test = new TimeOfDay((Chronology) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10 + OFFSET, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } //----------------------------------------------------------------------- /** * Test constructor (long) */ public void testConstructor_long1() throws Throwable { TimeOfDay test = new TimeOfDay(TEST_TIME1); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1 + OFFSET, test.getHourOfDay()); assertEquals(2, test.getMinuteOfHour()); assertEquals(3, test.getSecondOfMinute()); assertEquals(4, test.getMillisOfSecond()); } /** * Test constructor (long) */ public void testConstructor_long2() throws Throwable { TimeOfDay test = new TimeOfDay(TEST_TIME2); assertEquals(ISO_UTC, test.getChronology()); assertEquals(5 + OFFSET, test.getHourOfDay()); assertEquals(6, test.getMinuteOfHour()); assertEquals(7, test.getSecondOfMinute()); assertEquals(8, test.getMillisOfSecond()); } /** * Test constructor (long, Chronology) */ public void testConstructor_long1_Chronology() throws Throwable { TimeOfDay test = new TimeOfDay(TEST_TIME1, JulianChronology.getInstance()); assertEquals(JulianChronology.getInstanceUTC(), test.getChronology()); assertEquals(1 + OFFSET, test.getHourOfDay()); assertEquals(2, test.getMinuteOfHour()); assertEquals(3, test.getSecondOfMinute()); assertEquals(4, test.getMillisOfSecond()); } /** * Test constructor (long, Chronology) */ public void testConstructor_long2_Chronology() throws Throwable { TimeOfDay test = new TimeOfDay(TEST_TIME2, JulianChronology.getInstance()); assertEquals(JulianChronology.getInstanceUTC(), test.getChronology()); assertEquals(5 + OFFSET, test.getHourOfDay()); assertEquals(6, test.getMinuteOfHour()); assertEquals(7, test.getSecondOfMinute()); assertEquals(8, test.getMillisOfSecond()); } /** * Test constructor (long, Chronology=null) */ public void testConstructor_long_nullChronology() throws Throwable { TimeOfDay test = new TimeOfDay(TEST_TIME1, null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1 + OFFSET, test.getHourOfDay()); assertEquals(2, test.getMinuteOfHour()); assertEquals(3, test.getSecondOfMinute()); assertEquals(4, test.getMillisOfSecond()); } //----------------------------------------------------------------------- /** * Test constructor (Object) */ public void testConstructor_Object1() throws Throwable { Date date = new Date(TEST_TIME1); TimeOfDay test = new TimeOfDay(date); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1 + OFFSET, test.getHourOfDay()); assertEquals(2, test.getMinuteOfHour()); assertEquals(3, test.getSecondOfMinute()); assertEquals(4, test.getMillisOfSecond()); } /** * Test constructor (Object) */ public void testConstructor_Object2() throws Throwable { Calendar cal = new GregorianCalendar(); cal.setTime(new Date(TEST_TIME1)); TimeOfDay test = new TimeOfDay(cal); assertEquals(GJChronology.getInstanceUTC(), test.getChronology()); assertEquals(1 + OFFSET, test.getHourOfDay()); assertEquals(2, test.getMinuteOfHour()); assertEquals(3, test.getSecondOfMinute()); assertEquals(4, test.getMillisOfSecond()); } /** * Test constructor (Object=null) */ public void testConstructor_nullObject() throws Throwable { TimeOfDay test = new TimeOfDay((Object) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10 + OFFSET, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } /** * Test constructor (Object) */ public void testConstructor_todObject() throws Throwable { TimeOfDay base = new TimeOfDay(10, 20, 30, 40, CopticChronology.getInstance(PARIS)); TimeOfDay test = new TimeOfDay(base); assertEquals(CopticChronology.getInstanceUTC(), test.getChronology()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } public void testConstructor_ObjectString1() throws Throwable { TimeOfDay test = new TimeOfDay("10:20:30.040"); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } public void testConstructor_ObjectString2() throws Throwable { TimeOfDay test = new TimeOfDay("10:20:30.040+04:00"); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10 + OFFSET - 4, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } public void testConstructor_ObjectString3() throws Throwable { TimeOfDay test = new TimeOfDay("T10:20:30.040"); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } public void testConstructor_ObjectString4() throws Throwable { TimeOfDay test = new TimeOfDay("T10:20:30.040+04:00"); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10 + OFFSET - 4, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } public void testConstructor_ObjectString5() throws Throwable { TimeOfDay test = new TimeOfDay("10:20"); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } public void testConstructor_ObjectString6() throws Throwable { TimeOfDay test = new TimeOfDay("10"); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10, test.getHourOfDay()); assertEquals(0, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } public void testConstructor_ObjectStringEx1() throws Throwable { try { new TimeOfDay("1970-04-06"); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_ObjectStringEx2() throws Throwable { try { new TimeOfDay("1970-04-06T+14:00"); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_ObjectStringEx3() throws Throwable { try { new TimeOfDay("1970-04-06T10:20:30.040"); fail(); } catch (IllegalArgumentException ex) {} } public void testConstructor_ObjectStringEx4() throws Throwable { try { new TimeOfDay("1970-04-06T10:20:30.040+14:00"); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- /** * Test constructor (Object, Chronology) */ public void testConstructor_Object_Chronology() throws Throwable { Date date = new Date(TEST_TIME1); TimeOfDay test = new TimeOfDay(date, JulianChronology.getInstance()); assertEquals(JulianChronology.getInstanceUTC(), test.getChronology()); assertEquals(1 + OFFSET, test.getHourOfDay()); assertEquals(2, test.getMinuteOfHour()); assertEquals(3, test.getSecondOfMinute()); assertEquals(4, test.getMillisOfSecond()); } /** * Test constructor (Object, Chronology) */ public void testConstructor2_Object_Chronology() throws Throwable { TimeOfDay test = new TimeOfDay("T10:20"); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); try { new TimeOfDay("T1020"); fail(); } catch (IllegalArgumentException ex) {} } /** * Test constructor (Object=null, Chronology) */ public void testConstructor_nullObject_Chronology() throws Throwable { TimeOfDay test = new TimeOfDay((Object) null, JulianChronology.getInstance()); assertEquals(JulianChronology.getInstanceUTC(), test.getChronology()); assertEquals(10 + OFFSET, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } /** * Test constructor (Object, Chronology=null) */ public void testConstructor_Object_nullChronology() throws Throwable { Date date = new Date(TEST_TIME1); TimeOfDay test = new TimeOfDay(date, null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1 + OFFSET, test.getHourOfDay()); assertEquals(2, test.getMinuteOfHour()); assertEquals(3, test.getSecondOfMinute()); assertEquals(4, test.getMillisOfSecond()); } /** * Test constructor (Object=null, Chronology=null) */ public void testConstructor_nullObject_nullChronology() throws Throwable { TimeOfDay test = new TimeOfDay((Object) null, null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10 + OFFSET, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } //----------------------------------------------------------------------- /** * Test constructor (int, int) */ public void testConstructor_int_int() throws Throwable { TimeOfDay test = new TimeOfDay(10, 20); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); try { new TimeOfDay(-1, 20); fail(); } catch (IllegalArgumentException ex) {} try { new TimeOfDay(24, 20); fail(); } catch (IllegalArgumentException ex) {} try { new TimeOfDay(10, -1); fail(); } catch (IllegalArgumentException ex) {} try { new TimeOfDay(10, 60); fail(); } catch (IllegalArgumentException ex) {} } /** * Test constructor (int, int, int, Chronology) */ public void testConstructor_int_int_Chronology() throws Throwable { TimeOfDay test = new TimeOfDay(10, 20, JulianChronology.getInstance()); assertEquals(JulianChronology.getInstanceUTC(), test.getChronology()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); try { new TimeOfDay(-1, 20, JulianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} try { new TimeOfDay(24, 20, JulianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} try { new TimeOfDay(10, -1, JulianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} try { new TimeOfDay(10, 60, JulianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} } /** * Test constructor (int, int, int, Chronology=null) */ public void testConstructor_int_int_nullChronology() throws Throwable { TimeOfDay test = new TimeOfDay(10, 20, null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(0, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } /** * Test constructor (int, int, int) */ public void testConstructor_int_int_int() throws Throwable { TimeOfDay test = new TimeOfDay(10, 20, 30); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); try { new TimeOfDay(-1, 20, 30); fail(); } catch (IllegalArgumentException ex) {} try { new TimeOfDay(24, 20, 30); fail(); } catch (IllegalArgumentException ex) {} try { new TimeOfDay(10, -1, 30); fail(); } catch (IllegalArgumentException ex) {} try { new TimeOfDay(10, 60, 30); fail(); } catch (IllegalArgumentException ex) {} try { new TimeOfDay(10, 20, -1); fail(); } catch (IllegalArgumentException ex) {} try { new TimeOfDay(10, 20, 60); fail(); } catch (IllegalArgumentException ex) {} } /** * Test constructor (int, int, int, Chronology) */ public void testConstructor_int_int_int_Chronology() throws Throwable { TimeOfDay test = new TimeOfDay(10, 20, 30, JulianChronology.getInstance()); assertEquals(JulianChronology.getInstanceUTC(), test.getChronology()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); try { new TimeOfDay(-1, 20, 30, JulianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} try { new TimeOfDay(24, 20, 30, JulianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} try { new TimeOfDay(10, -1, 30, JulianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} try { new TimeOfDay(10, 60, 30, JulianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} try { new TimeOfDay(10, 20, -1, JulianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} try { new TimeOfDay(10, 20, 60, JulianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} } /** * Test constructor (int, int, int, Chronology=null) */ public void testConstructor_int_int_int_nullChronology() throws Throwable { TimeOfDay test = new TimeOfDay(10, 20, 30, null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(0, test.getMillisOfSecond()); } /** * Test constructor (int, int, int, int) */ public void testConstructor_int_int_int_int() throws Throwable { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); try { new TimeOfDay(-1, 20, 30, 40); fail(); } catch (IllegalArgumentException ex) {} try { new TimeOfDay(24, 20, 30, 40); fail(); } catch (IllegalArgumentException ex) {} try { new TimeOfDay(10, -1, 30, 40); fail(); } catch (IllegalArgumentException ex) {} try { new TimeOfDay(10, 60, 30, 40); fail(); } catch (IllegalArgumentException ex) {} try { new TimeOfDay(10, 20, -1, 40); fail(); } catch (IllegalArgumentException ex) {} try { new TimeOfDay(10, 20, 60, 40); fail(); } catch (IllegalArgumentException ex) {} try { new TimeOfDay(10, 20, 30, -1); fail(); } catch (IllegalArgumentException ex) {} try { new TimeOfDay(10, 20, 30, 1000); fail(); } catch (IllegalArgumentException ex) {} } /** * Test constructor (int, int, int, int, Chronology) */ public void testConstructor_int_int_int_int_Chronology() throws Throwable { TimeOfDay test = new TimeOfDay(10, 20, 30, 40, JulianChronology.getInstance()); assertEquals(JulianChronology.getInstanceUTC(), test.getChronology()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); try { new TimeOfDay(-1, 20, 30, 40, JulianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} try { new TimeOfDay(24, 20, 30, 40, JulianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} try { new TimeOfDay(10, -1, 30, 40, JulianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} try { new TimeOfDay(10, 60, 30, 40, JulianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} try { new TimeOfDay(10, 20, -1, 40, JulianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} try { new TimeOfDay(10, 20, 60, 40, JulianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} try { new TimeOfDay(10, 20, 30, -1, JulianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} try { new TimeOfDay(10, 20, 30, 1000, JulianChronology.getInstance()); fail(); } catch (IllegalArgumentException ex) {} } /** * Test constructor (int, int, int, int, Chronology=null) */ public void testConstructor_int_int_int_int_nullChronology() throws Throwable { TimeOfDay test = new TimeOfDay(10, 20, 30, 40, null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10, test.getHourOfDay()); assertEquals(20, test.getMinuteOfHour()); assertEquals(30, test.getSecondOfMinute()); assertEquals(40, test.getMillisOfSecond()); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.util.Locale; import junit.framework.TestCase; import junit.framework.TestSuite; /** * This class is a Junit unit test for TimeOfDay. * * @author Stephen Colebourne */ @SuppressWarnings("deprecation") public class TestTimeOfDay_Properties extends TestCase { private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private long TEST_TIME_NOW = 10L * DateTimeConstants.MILLIS_PER_HOUR + 20L * DateTimeConstants.MILLIS_PER_MINUTE + 30L * DateTimeConstants.MILLIS_PER_SECOND + 40L; private long TEST_TIME1 = 1L * DateTimeConstants.MILLIS_PER_HOUR + 2L * DateTimeConstants.MILLIS_PER_MINUTE + 3L * DateTimeConstants.MILLIS_PER_SECOND + 4L; private long TEST_TIME2 = 1L * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; private DateTimeZone zone = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestTimeOfDay_Properties.class); } public TestTimeOfDay_Properties(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); zone = DateTimeZone.getDefault(); DateTimeZone.setDefault(LONDON); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(zone); zone = null; } //----------------------------------------------------------------------- public void testPropertyGetHour() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); assertSame(test.getChronology().hourOfDay(), test.hourOfDay().getField()); assertEquals("hourOfDay", test.hourOfDay().getName()); assertEquals("Property[hourOfDay]", test.hourOfDay().toString()); assertSame(test, test.hourOfDay().getReadablePartial()); assertSame(test, test.hourOfDay().getTimeOfDay()); assertEquals(10, test.hourOfDay().get()); assertEquals("10", test.hourOfDay().getAsString()); assertEquals("10", test.hourOfDay().getAsText()); assertEquals("10", test.hourOfDay().getAsText(Locale.FRENCH)); assertEquals("10", test.hourOfDay().getAsShortText()); assertEquals("10", test.hourOfDay().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().hours(), test.hourOfDay().getDurationField()); assertEquals(test.getChronology().days(), test.hourOfDay().getRangeDurationField()); assertEquals(2, test.hourOfDay().getMaximumTextLength(null)); assertEquals(2, test.hourOfDay().getMaximumShortTextLength(null)); } public void testPropertyGetMaxMinValuesHour() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); assertEquals(0, test.hourOfDay().getMinimumValue()); assertEquals(0, test.hourOfDay().getMinimumValueOverall()); assertEquals(23, test.hourOfDay().getMaximumValue()); assertEquals(23, test.hourOfDay().getMaximumValueOverall()); } public void testPropertyAddHour() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); TimeOfDay copy = test.hourOfDay().addToCopy(9); check(test, 10, 20, 30, 40); check(copy, 19, 20, 30, 40); copy = test.hourOfDay().addToCopy(0); check(copy, 10, 20, 30, 40); copy = test.hourOfDay().addToCopy(13); check(copy, 23, 20, 30, 40); copy = test.hourOfDay().addToCopy(14); check(copy, 0, 20, 30, 40); copy = test.hourOfDay().addToCopy(-10); check(copy, 0, 20, 30, 40); copy = test.hourOfDay().addToCopy(-11); check(copy, 23, 20, 30, 40); } public void testPropertyAddNoWrapHour() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); TimeOfDay copy = test.hourOfDay().addNoWrapToCopy(9); check(test, 10, 20, 30, 40); check(copy, 19, 20, 30, 40); copy = test.hourOfDay().addNoWrapToCopy(0); check(copy, 10, 20, 30, 40); copy = test.hourOfDay().addNoWrapToCopy(13); check(copy, 23, 20, 30, 40); try { test.hourOfDay().addNoWrapToCopy(14); fail(); } catch (IllegalArgumentException ex) {} check(test, 10, 20, 30, 40); copy = test.hourOfDay().addNoWrapToCopy(-10); check(copy, 0, 20, 30, 40); try { test.hourOfDay().addNoWrapToCopy(-11); fail(); } catch (IllegalArgumentException ex) {} check(test, 10, 20, 30, 40); } public void testPropertyAddWrapFieldHour() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); TimeOfDay copy = test.hourOfDay().addWrapFieldToCopy(9); check(test, 10, 20, 30, 40); check(copy, 19, 20, 30, 40); copy = test.hourOfDay().addWrapFieldToCopy(0); check(copy, 10, 20, 30, 40); copy = test.hourOfDay().addWrapFieldToCopy(18); check(copy, 4, 20, 30, 40); copy = test.hourOfDay().addWrapFieldToCopy(-15); check(copy, 19, 20, 30, 40); } public void testPropertySetHour() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); TimeOfDay copy = test.hourOfDay().setCopy(12); check(test, 10, 20, 30, 40); check(copy, 12, 20, 30, 40); try { test.hourOfDay().setCopy(24); fail(); } catch (IllegalArgumentException ex) {} try { test.hourOfDay().setCopy(-1); fail(); } catch (IllegalArgumentException ex) {} } public void testPropertySetTextHour() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); TimeOfDay copy = test.hourOfDay().setCopy("12"); check(test, 10, 20, 30, 40); check(copy, 12, 20, 30, 40); } public void testPropertyWithMaximumValueHour() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); TimeOfDay copy = test.hourOfDay().withMaximumValue(); check(test, 10, 20, 30, 40); check(copy, 23, 20, 30, 40); } public void testPropertyWithMinimumValueHour() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); TimeOfDay copy = test.hourOfDay().withMinimumValue(); check(test, 10, 20, 30, 40); check(copy, 0, 20, 30, 40); } public void testPropertyCompareToHour() { TimeOfDay test1 = new TimeOfDay(TEST_TIME1); TimeOfDay test2 = new TimeOfDay(TEST_TIME2); assertEquals(true, test1.hourOfDay().compareTo(test2) < 0); assertEquals(true, test2.hourOfDay().compareTo(test1) > 0); assertEquals(true, test1.hourOfDay().compareTo(test1) == 0); try { test1.hourOfDay().compareTo((ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} DateTime dt1 = new DateTime(TEST_TIME1); DateTime dt2 = new DateTime(TEST_TIME2); assertEquals(true, test1.hourOfDay().compareTo(dt2) < 0); assertEquals(true, test2.hourOfDay().compareTo(dt1) > 0); assertEquals(true, test1.hourOfDay().compareTo(dt1) == 0); try { test1.hourOfDay().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testPropertyGetMinute() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); assertSame(test.getChronology().minuteOfHour(), test.minuteOfHour().getField()); assertEquals("minuteOfHour", test.minuteOfHour().getName()); assertEquals("Property[minuteOfHour]", test.minuteOfHour().toString()); assertSame(test, test.minuteOfHour().getReadablePartial()); assertSame(test, test.minuteOfHour().getTimeOfDay()); assertEquals(20, test.minuteOfHour().get()); assertEquals("20", test.minuteOfHour().getAsString()); assertEquals("20", test.minuteOfHour().getAsText()); assertEquals("20", test.minuteOfHour().getAsText(Locale.FRENCH)); assertEquals("20", test.minuteOfHour().getAsShortText()); assertEquals("20", test.minuteOfHour().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().minutes(), test.minuteOfHour().getDurationField()); assertEquals(test.getChronology().hours(), test.minuteOfHour().getRangeDurationField()); assertEquals(2, test.minuteOfHour().getMaximumTextLength(null)); assertEquals(2, test.minuteOfHour().getMaximumShortTextLength(null)); } public void testPropertyGetMaxMinValuesMinute() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); assertEquals(0, test.minuteOfHour().getMinimumValue()); assertEquals(0, test.minuteOfHour().getMinimumValueOverall()); assertEquals(59, test.minuteOfHour().getMaximumValue()); assertEquals(59, test.minuteOfHour().getMaximumValueOverall()); } public void testPropertyAddMinute() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); TimeOfDay copy = test.minuteOfHour().addToCopy(9); check(test, 10, 20, 30, 40); check(copy, 10, 29, 30, 40); copy = test.minuteOfHour().addToCopy(39); check(copy, 10, 59, 30, 40); copy = test.minuteOfHour().addToCopy(40); check(copy, 11, 0, 30, 40); copy = test.minuteOfHour().addToCopy(1 * 60 + 45); check(copy, 12, 5, 30, 40); copy = test.minuteOfHour().addToCopy(13 * 60 + 39); check(copy, 23, 59, 30, 40); copy = test.minuteOfHour().addToCopy(13 * 60 + 40); check(copy, 0, 0, 30, 40); copy = test.minuteOfHour().addToCopy(-9); check(copy, 10, 11, 30, 40); copy = test.minuteOfHour().addToCopy(-19); check(copy, 10, 1, 30, 40); copy = test.minuteOfHour().addToCopy(-20); check(copy, 10, 0, 30, 40); copy = test.minuteOfHour().addToCopy(-21); check(copy, 9, 59, 30, 40); copy = test.minuteOfHour().addToCopy(-(10 * 60 + 20)); check(copy, 0, 0, 30, 40); copy = test.minuteOfHour().addToCopy(-(10 * 60 + 21)); check(copy, 23, 59, 30, 40); } public void testPropertyAddNoWrapMinute() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); TimeOfDay copy = test.minuteOfHour().addNoWrapToCopy(9); check(test, 10, 20, 30, 40); check(copy, 10, 29, 30, 40); copy = test.minuteOfHour().addNoWrapToCopy(39); check(copy, 10, 59, 30, 40); copy = test.minuteOfHour().addNoWrapToCopy(40); check(copy, 11, 0, 30, 40); copy = test.minuteOfHour().addNoWrapToCopy(1 * 60 + 45); check(copy, 12, 5, 30, 40); copy = test.minuteOfHour().addNoWrapToCopy(13 * 60 + 39); check(copy, 23, 59, 30, 40); try { test.minuteOfHour().addNoWrapToCopy(13 * 60 + 40); fail(); } catch (IllegalArgumentException ex) {} check(test, 10, 20, 30, 40); copy = test.minuteOfHour().addNoWrapToCopy(-9); check(copy, 10, 11, 30, 40); copy = test.minuteOfHour().addNoWrapToCopy(-19); check(copy, 10, 1, 30, 40); copy = test.minuteOfHour().addNoWrapToCopy(-20); check(copy, 10, 0, 30, 40); copy = test.minuteOfHour().addNoWrapToCopy(-21); check(copy, 9, 59, 30, 40); copy = test.minuteOfHour().addNoWrapToCopy(-(10 * 60 + 20)); check(copy, 0, 0, 30, 40); try { test.minuteOfHour().addNoWrapToCopy(-(10 * 60 + 21)); fail(); } catch (IllegalArgumentException ex) {} check(test, 10, 20, 30, 40); } public void testPropertyAddWrapFieldMinute() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); TimeOfDay copy = test.minuteOfHour().addWrapFieldToCopy(9); check(test, 10, 20, 30, 40); check(copy, 10, 29, 30, 40); copy = test.minuteOfHour().addWrapFieldToCopy(49); check(copy, 10, 9, 30, 40); copy = test.minuteOfHour().addWrapFieldToCopy(-47); check(copy, 10, 33, 30, 40); } public void testPropertySetMinute() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); TimeOfDay copy = test.minuteOfHour().setCopy(12); check(test, 10, 20, 30, 40); check(copy, 10, 12, 30, 40); try { test.minuteOfHour().setCopy(60); fail(); } catch (IllegalArgumentException ex) {} try { test.minuteOfHour().setCopy(-1); fail(); } catch (IllegalArgumentException ex) {} } public void testPropertySetTextMinute() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); TimeOfDay copy = test.minuteOfHour().setCopy("12"); check(test, 10, 20, 30, 40); check(copy, 10, 12, 30, 40); } public void testPropertyCompareToMinute() { TimeOfDay test1 = new TimeOfDay(TEST_TIME1); TimeOfDay test2 = new TimeOfDay(TEST_TIME2); assertEquals(true, test1.minuteOfHour().compareTo(test2) < 0); assertEquals(true, test2.minuteOfHour().compareTo(test1) > 0); assertEquals(true, test1.minuteOfHour().compareTo(test1) == 0); try { test1.minuteOfHour().compareTo((ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} DateTime dt1 = new DateTime(TEST_TIME1); DateTime dt2 = new DateTime(TEST_TIME2); assertEquals(true, test1.minuteOfHour().compareTo(dt2) < 0); assertEquals(true, test2.minuteOfHour().compareTo(dt1) > 0); assertEquals(true, test1.minuteOfHour().compareTo(dt1) == 0); try { test1.minuteOfHour().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testPropertyGetSecond() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); assertSame(test.getChronology().secondOfMinute(), test.secondOfMinute().getField()); assertEquals("secondOfMinute", test.secondOfMinute().getName()); assertEquals("Property[secondOfMinute]", test.secondOfMinute().toString()); assertSame(test, test.secondOfMinute().getReadablePartial()); assertSame(test, test.secondOfMinute().getTimeOfDay()); assertEquals(30, test.secondOfMinute().get()); assertEquals("30", test.secondOfMinute().getAsString()); assertEquals("30", test.secondOfMinute().getAsText()); assertEquals("30", test.secondOfMinute().getAsText(Locale.FRENCH)); assertEquals("30", test.secondOfMinute().getAsShortText()); assertEquals("30", test.secondOfMinute().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().seconds(), test.secondOfMinute().getDurationField()); assertEquals(test.getChronology().minutes(), test.secondOfMinute().getRangeDurationField()); assertEquals(2, test.secondOfMinute().getMaximumTextLength(null)); assertEquals(2, test.secondOfMinute().getMaximumShortTextLength(null)); } public void testPropertyGetMaxMinValuesSecond() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); assertEquals(0, test.secondOfMinute().getMinimumValue()); assertEquals(0, test.secondOfMinute().getMinimumValueOverall()); assertEquals(59, test.secondOfMinute().getMaximumValue()); assertEquals(59, test.secondOfMinute().getMaximumValueOverall()); } public void testPropertyAddSecond() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); TimeOfDay copy = test.secondOfMinute().addToCopy(9); check(test, 10, 20, 30, 40); check(copy, 10, 20, 39, 40); copy = test.secondOfMinute().addToCopy(29); check(copy, 10, 20, 59, 40); copy = test.secondOfMinute().addToCopy(30); check(copy, 10, 21, 0, 40); copy = test.secondOfMinute().addToCopy(39 * 60 + 29); check(copy, 10, 59, 59, 40); copy = test.secondOfMinute().addToCopy(39 * 60 + 30); check(copy, 11, 0, 0, 40); copy = test.secondOfMinute().addToCopy(13 * 60 * 60 + 39 * 60 + 30); check(copy, 0, 0, 0, 40); copy = test.secondOfMinute().addToCopy(-9); check(copy, 10, 20, 21, 40); copy = test.secondOfMinute().addToCopy(-30); check(copy, 10, 20, 0, 40); copy = test.secondOfMinute().addToCopy(-31); check(copy, 10, 19, 59, 40); copy = test.secondOfMinute().addToCopy(-(10 * 60 * 60 + 20 * 60 + 30)); check(copy, 0, 0, 0, 40); copy = test.secondOfMinute().addToCopy(-(10 * 60 * 60 + 20 * 60 + 31)); check(copy, 23, 59, 59, 40); } public void testPropertyAddNoWrapSecond() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); TimeOfDay copy = test.secondOfMinute().addNoWrapToCopy(9); check(test, 10, 20, 30, 40); check(copy, 10, 20, 39, 40); copy = test.secondOfMinute().addNoWrapToCopy(29); check(copy, 10, 20, 59, 40); copy = test.secondOfMinute().addNoWrapToCopy(30); check(copy, 10, 21, 0, 40); copy = test.secondOfMinute().addNoWrapToCopy(39 * 60 + 29); check(copy, 10, 59, 59, 40); copy = test.secondOfMinute().addNoWrapToCopy(39 * 60 + 30); check(copy, 11, 0, 0, 40); try { test.secondOfMinute().addNoWrapToCopy(13 * 60 * 60 + 39 * 60 + 30); fail(); } catch (IllegalArgumentException ex) {} check(test, 10, 20, 30, 40); copy = test.secondOfMinute().addNoWrapToCopy(-9); check(copy, 10, 20, 21, 40); copy = test.secondOfMinute().addNoWrapToCopy(-30); check(copy, 10, 20, 0, 40); copy = test.secondOfMinute().addNoWrapToCopy(-31); check(copy, 10, 19, 59, 40); copy = test.secondOfMinute().addNoWrapToCopy(-(10 * 60 * 60 + 20 * 60 + 30)); check(copy, 0, 0, 0, 40); try { test.secondOfMinute().addNoWrapToCopy(-(10 * 60 * 60 + 20 * 60 + 31)); fail(); } catch (IllegalArgumentException ex) {} check(test, 10, 20, 30, 40); } public void testPropertyAddWrapFieldSecond() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); TimeOfDay copy = test.secondOfMinute().addWrapFieldToCopy(9); check(test, 10, 20, 30, 40); check(copy, 10, 20, 39, 40); copy = test.secondOfMinute().addWrapFieldToCopy(49); check(copy, 10, 20, 19, 40); copy = test.secondOfMinute().addWrapFieldToCopy(-47); check(copy, 10, 20, 43, 40); } public void testPropertySetSecond() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); TimeOfDay copy = test.secondOfMinute().setCopy(12); check(test, 10, 20, 30, 40); check(copy, 10, 20, 12, 40); try { test.secondOfMinute().setCopy(60); fail(); } catch (IllegalArgumentException ex) {} try { test.secondOfMinute().setCopy(-1); fail(); } catch (IllegalArgumentException ex) {} } public void testPropertySetTextSecond() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); TimeOfDay copy = test.secondOfMinute().setCopy("12"); check(test, 10, 20, 30, 40); check(copy, 10, 20, 12, 40); } public void testPropertyCompareToSecond() { TimeOfDay test1 = new TimeOfDay(TEST_TIME1); TimeOfDay test2 = new TimeOfDay(TEST_TIME2); assertEquals(true, test1.secondOfMinute().compareTo(test2) < 0); assertEquals(true, test2.secondOfMinute().compareTo(test1) > 0); assertEquals(true, test1.secondOfMinute().compareTo(test1) == 0); try { test1.secondOfMinute().compareTo((ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} DateTime dt1 = new DateTime(TEST_TIME1); DateTime dt2 = new DateTime(TEST_TIME2); assertEquals(true, test1.secondOfMinute().compareTo(dt2) < 0); assertEquals(true, test2.secondOfMinute().compareTo(dt1) > 0); assertEquals(true, test1.secondOfMinute().compareTo(dt1) == 0); try { test1.secondOfMinute().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testPropertyGetMilli() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); assertSame(test.getChronology().millisOfSecond(), test.millisOfSecond().getField()); assertEquals("millisOfSecond", test.millisOfSecond().getName()); assertEquals("Property[millisOfSecond]", test.millisOfSecond().toString()); assertSame(test, test.millisOfSecond().getReadablePartial()); assertSame(test, test.millisOfSecond().getTimeOfDay()); assertEquals(40, test.millisOfSecond().get()); assertEquals("40", test.millisOfSecond().getAsString()); assertEquals("40", test.millisOfSecond().getAsText()); assertEquals("40", test.millisOfSecond().getAsText(Locale.FRENCH)); assertEquals("40", test.millisOfSecond().getAsShortText()); assertEquals("40", test.millisOfSecond().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().millis(), test.millisOfSecond().getDurationField()); assertEquals(test.getChronology().seconds(), test.millisOfSecond().getRangeDurationField()); assertEquals(3, test.millisOfSecond().getMaximumTextLength(null)); assertEquals(3, test.millisOfSecond().getMaximumShortTextLength(null)); } public void testPropertyGetMaxMinValuesMilli() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); assertEquals(0, test.millisOfSecond().getMinimumValue()); assertEquals(0, test.millisOfSecond().getMinimumValueOverall()); assertEquals(999, test.millisOfSecond().getMaximumValue()); assertEquals(999, test.millisOfSecond().getMaximumValueOverall()); } public void testPropertyAddMilli() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); TimeOfDay copy = test.millisOfSecond().addToCopy(9); check(test, 10, 20, 30, 40); check(copy, 10, 20, 30, 49); copy = test.millisOfSecond().addToCopy(959); check(copy, 10, 20, 30, 999); copy = test.millisOfSecond().addToCopy(960); check(copy, 10, 20, 31, 0); copy = test.millisOfSecond().addToCopy(13 * 60 * 60 * 1000 + 39 * 60 * 1000 + 29 * 1000 + 959); check(copy, 23, 59, 59, 999); copy = test.millisOfSecond().addToCopy(13 * 60 * 60 * 1000 + 39 * 60 * 1000 + 29 * 1000 + 960); check(copy, 0, 0, 0, 0); copy = test.millisOfSecond().addToCopy(-9); check(copy, 10, 20, 30, 31); copy = test.millisOfSecond().addToCopy(-40); check(copy, 10, 20, 30, 0); copy = test.millisOfSecond().addToCopy(-41); check(copy, 10, 20, 29, 999); copy = test.millisOfSecond().addToCopy(-(10 * 60 * 60 * 1000 + 20 * 60 * 1000 + 30 * 1000 + 40)); check(copy, 0, 0, 0, 0); copy = test.millisOfSecond().addToCopy(-(10 * 60 * 60 * 1000 + 20 * 60 * 1000 + 30 * 1000 + 41)); check(copy, 23, 59, 59, 999); } public void testPropertyAddNoWrapMilli() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); TimeOfDay copy = test.millisOfSecond().addNoWrapToCopy(9); check(test, 10, 20, 30, 40); check(copy, 10, 20, 30, 49); copy = test.millisOfSecond().addNoWrapToCopy(959); check(copy, 10, 20, 30, 999); copy = test.millisOfSecond().addNoWrapToCopy(960); check(copy, 10, 20, 31, 0); copy = test.millisOfSecond().addNoWrapToCopy(13 * 60 * 60 * 1000 + 39 * 60 * 1000 + 29 * 1000 + 959); check(copy, 23, 59, 59, 999); try { test.millisOfSecond().addNoWrapToCopy(13 * 60 * 60 * 1000 + 39 * 60 * 1000 + 29 * 1000 + 960); fail(); } catch (IllegalArgumentException ex) {} check(test, 10, 20, 30, 40); copy = test.millisOfSecond().addNoWrapToCopy(-9); check(copy, 10, 20, 30, 31); copy = test.millisOfSecond().addNoWrapToCopy(-40); check(copy, 10, 20, 30, 0); copy = test.millisOfSecond().addNoWrapToCopy(-41); check(copy, 10, 20, 29, 999); copy = test.millisOfSecond().addNoWrapToCopy(-(10 * 60 * 60 * 1000 + 20 * 60 * 1000 + 30 * 1000 + 40)); check(copy, 0, 0, 0, 0); try { test.millisOfSecond().addNoWrapToCopy(-(10 * 60 * 60 * 1000 + 20 * 60 * 1000 + 30 * 1000 + 41)); fail(); } catch (IllegalArgumentException ex) {} check(test, 10, 20, 30, 40); } public void testPropertyAddWrapFieldMilli() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); TimeOfDay copy = test.millisOfSecond().addWrapFieldToCopy(9); check(test, 10, 20, 30, 40); check(copy, 10, 20, 30, 49); copy = test.millisOfSecond().addWrapFieldToCopy(995); check(copy, 10, 20, 30, 35); copy = test.millisOfSecond().addWrapFieldToCopy(-47); check(copy, 10, 20, 30, 993); } public void testPropertySetMilli() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); TimeOfDay copy = test.millisOfSecond().setCopy(12); check(test, 10, 20, 30, 40); check(copy, 10, 20, 30, 12); try { test.millisOfSecond().setCopy(1000); fail(); } catch (IllegalArgumentException ex) {} try { test.millisOfSecond().setCopy(-1); fail(); } catch (IllegalArgumentException ex) {} } public void testPropertySetTextMilli() { TimeOfDay test = new TimeOfDay(10, 20, 30, 40); TimeOfDay copy = test.millisOfSecond().setCopy("12"); check(test, 10, 20, 30, 40); check(copy, 10, 20, 30, 12); } public void testPropertyCompareToMilli() { TimeOfDay test1 = new TimeOfDay(TEST_TIME1); TimeOfDay test2 = new TimeOfDay(TEST_TIME2); assertEquals(true, test1.millisOfSecond().compareTo(test2) < 0); assertEquals(true, test2.millisOfSecond().compareTo(test1) > 0); assertEquals(true, test1.millisOfSecond().compareTo(test1) == 0); try { test1.millisOfSecond().compareTo((ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} DateTime dt1 = new DateTime(TEST_TIME1); DateTime dt2 = new DateTime(TEST_TIME2); assertEquals(true, test1.millisOfSecond().compareTo(dt2) < 0); assertEquals(true, test2.millisOfSecond().compareTo(dt1) > 0); assertEquals(true, test1.millisOfSecond().compareTo(dt1) == 0); try { test1.millisOfSecond().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- private void check(TimeOfDay test, int hour, int min, int sec, int milli) { assertEquals(hour, test.getHourOfDay()); assertEquals(min, test.getMinuteOfHour()); assertEquals(sec, test.getSecondOfMinute()); assertEquals(milli, test.getMillisOfSecond()); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import junit.framework.TestCase; import junit.framework.TestSuite; /** * This class is a Junit unit test for Weeks. * * @author Stephen Colebourne */ public class TestWeeks extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestWeeks.class); } public TestWeeks(String name) { super(name); } protected void setUp() throws Exception { } protected void tearDown() throws Exception { } //----------------------------------------------------------------------- public void testConstants() { assertEquals(0, Weeks.ZERO.getWeeks()); assertEquals(1, Weeks.ONE.getWeeks()); assertEquals(2, Weeks.TWO.getWeeks()); assertEquals(3, Weeks.THREE.getWeeks()); assertEquals(Integer.MAX_VALUE, Weeks.MAX_VALUE.getWeeks()); assertEquals(Integer.MIN_VALUE, Weeks.MIN_VALUE.getWeeks()); } //----------------------------------------------------------------------- public void testFactory_weeks_int() { assertSame(Weeks.ZERO, Weeks.weeks(0)); assertSame(Weeks.ONE, Weeks.weeks(1)); assertSame(Weeks.TWO, Weeks.weeks(2)); assertSame(Weeks.THREE, Weeks.weeks(3)); assertSame(Weeks.MAX_VALUE, Weeks.weeks(Integer.MAX_VALUE)); assertSame(Weeks.MIN_VALUE, Weeks.weeks(Integer.MIN_VALUE)); assertEquals(-1, Weeks.weeks(-1).getWeeks()); assertEquals(4, Weeks.weeks(4).getWeeks()); } //----------------------------------------------------------------------- public void testFactory_weeksBetween_RInstant() { DateTime start = new DateTime(2006, 6, 9, 12, 0, 0, 0, PARIS); DateTime end1 = new DateTime(2006, 6, 30, 12, 0, 0, 0, PARIS); DateTime end2 = new DateTime(2006, 7, 21, 12, 0, 0, 0, PARIS); assertEquals(3, Weeks.weeksBetween(start, end1).getWeeks()); assertEquals(0, Weeks.weeksBetween(start, start).getWeeks()); assertEquals(0, Weeks.weeksBetween(end1, end1).getWeeks()); assertEquals(-3, Weeks.weeksBetween(end1, start).getWeeks()); assertEquals(6, Weeks.weeksBetween(start, end2).getWeeks()); } @SuppressWarnings("deprecation") public void testFactory_weeksBetween_RPartial() { LocalDate start = new LocalDate(2006, 6, 9); LocalDate end1 = new LocalDate(2006, 6, 30); YearMonthDay end2 = new YearMonthDay(2006, 7, 21); assertEquals(3, Weeks.weeksBetween(start, end1).getWeeks()); assertEquals(0, Weeks.weeksBetween(start, start).getWeeks()); assertEquals(0, Weeks.weeksBetween(end1, end1).getWeeks()); assertEquals(-3, Weeks.weeksBetween(end1, start).getWeeks()); assertEquals(6, Weeks.weeksBetween(start, end2).getWeeks()); } public void testFactory_weeksIn_RInterval() { DateTime start = new DateTime(2006, 6, 9, 12, 0, 0, 0, PARIS); DateTime end1 = new DateTime(2006, 6, 30, 12, 0, 0, 0, PARIS); DateTime end2 = new DateTime(2006, 7, 21, 12, 0, 0, 0, PARIS); assertEquals(0, Weeks.weeksIn((ReadableInterval) null).getWeeks()); assertEquals(3, Weeks.weeksIn(new Interval(start, end1)).getWeeks()); assertEquals(0, Weeks.weeksIn(new Interval(start, start)).getWeeks()); assertEquals(0, Weeks.weeksIn(new Interval(end1, end1)).getWeeks()); assertEquals(6, Weeks.weeksIn(new Interval(start, end2)).getWeeks()); } public void testFactory_standardWeeksIn_RPeriod() { assertEquals(0, Weeks.standardWeeksIn((ReadablePeriod) null).getWeeks()); assertEquals(0, Weeks.standardWeeksIn(Period.ZERO).getWeeks()); assertEquals(1, Weeks.standardWeeksIn(new Period(0, 0, 1, 0, 0, 0, 0, 0)).getWeeks()); assertEquals(123, Weeks.standardWeeksIn(Period.weeks(123)).getWeeks()); assertEquals(-987, Weeks.standardWeeksIn(Period.weeks(-987)).getWeeks()); assertEquals(1, Weeks.standardWeeksIn(Period.days(13)).getWeeks()); assertEquals(2, Weeks.standardWeeksIn(Period.days(14)).getWeeks()); assertEquals(2, Weeks.standardWeeksIn(Period.days(15)).getWeeks()); try { Weeks.standardWeeksIn(Period.months(1)); fail(); } catch (IllegalArgumentException ex) { // expeceted } } public void testFactory_parseWeeks_String() { assertEquals(0, Weeks.parseWeeks((String) null).getWeeks()); assertEquals(0, Weeks.parseWeeks("P0W").getWeeks()); assertEquals(1, Weeks.parseWeeks("P1W").getWeeks()); assertEquals(-3, Weeks.parseWeeks("P-3W").getWeeks()); assertEquals(2, Weeks.parseWeeks("P0Y0M2W").getWeeks()); assertEquals(2, Weeks.parseWeeks("P2WT0H0M").getWeeks()); try { Weeks.parseWeeks("P1Y1D"); fail(); } catch (IllegalArgumentException ex) { // expeceted } try { Weeks.parseWeeks("P1WT1H"); fail(); } catch (IllegalArgumentException ex) { // expeceted } } //----------------------------------------------------------------------- public void testGetMethods() { Weeks test = Weeks.weeks(20); assertEquals(20, test.getWeeks()); } public void testGetFieldType() { Weeks test = Weeks.weeks(20); assertEquals(DurationFieldType.weeks(), test.getFieldType()); } public void testGetPeriodType() { Weeks test = Weeks.weeks(20); assertEquals(PeriodType.weeks(), test.getPeriodType()); } //----------------------------------------------------------------------- public void testIsGreaterThan() { assertEquals(true, Weeks.THREE.isGreaterThan(Weeks.TWO)); assertEquals(false, Weeks.THREE.isGreaterThan(Weeks.THREE)); assertEquals(false, Weeks.TWO.isGreaterThan(Weeks.THREE)); assertEquals(true, Weeks.ONE.isGreaterThan(null)); assertEquals(false, Weeks.weeks(-1).isGreaterThan(null)); } public void testIsLessThan() { assertEquals(false, Weeks.THREE.isLessThan(Weeks.TWO)); assertEquals(false, Weeks.THREE.isLessThan(Weeks.THREE)); assertEquals(true, Weeks.TWO.isLessThan(Weeks.THREE)); assertEquals(false, Weeks.ONE.isLessThan(null)); assertEquals(true, Weeks.weeks(-1).isLessThan(null)); } //----------------------------------------------------------------------- public void testToString() { Weeks test = Weeks.weeks(20); assertEquals("P20W", test.toString()); test = Weeks.weeks(-20); assertEquals("P-20W", test.toString()); } //----------------------------------------------------------------------- public void testSerialization() throws Exception { Weeks test = Weeks.THREE; ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(test); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); Weeks result = (Weeks) ois.readObject(); ois.close(); assertSame(test, result); } //----------------------------------------------------------------------- public void testToStandardDays() { Weeks test = Weeks.weeks(2); Days expected = Days.days(14); assertEquals(expected, test.toStandardDays()); try { Weeks.MAX_VALUE.toStandardDays(); fail(); } catch (ArithmeticException ex) { // expected } } public void testToStandardHours() { Weeks test = Weeks.weeks(2); Hours expected = Hours.hours(2 * 7 * 24); assertEquals(expected, test.toStandardHours()); try { Weeks.MAX_VALUE.toStandardHours(); fail(); } catch (ArithmeticException ex) { // expected } } public void testToStandardMinutes() { Weeks test = Weeks.weeks(2); Minutes expected = Minutes.minutes(2 * 7 * 24 * 60); assertEquals(expected, test.toStandardMinutes()); try { Weeks.MAX_VALUE.toStandardMinutes(); fail(); } catch (ArithmeticException ex) { // expected } } public void testToStandardSeconds() { Weeks test = Weeks.weeks(2); Seconds expected = Seconds.seconds(2 * 7 * 24 * 60 * 60); assertEquals(expected, test.toStandardSeconds()); try { Weeks.MAX_VALUE.toStandardSeconds(); fail(); } catch (ArithmeticException ex) { // expected } } public void testToStandardDuration() { Weeks test = Weeks.weeks(20); Duration expected = new Duration(20L * DateTimeConstants.MILLIS_PER_WEEK); assertEquals(expected, test.toStandardDuration()); expected = new Duration(((long) Integer.MAX_VALUE) * DateTimeConstants.MILLIS_PER_WEEK); assertEquals(expected, Weeks.MAX_VALUE.toStandardDuration()); } //----------------------------------------------------------------------- public void testPlus_int() { Weeks test2 = Weeks.weeks(2); Weeks result = test2.plus(3); assertEquals(2, test2.getWeeks()); assertEquals(5, result.getWeeks()); assertEquals(1, Weeks.ONE.plus(0).getWeeks()); try { Weeks.MAX_VALUE.plus(1); fail(); } catch (ArithmeticException ex) { // expected } } public void testPlus_Weeks() { Weeks test2 = Weeks.weeks(2); Weeks test3 = Weeks.weeks(3); Weeks result = test2.plus(test3); assertEquals(2, test2.getWeeks()); assertEquals(3, test3.getWeeks()); assertEquals(5, result.getWeeks()); assertEquals(1, Weeks.ONE.plus(Weeks.ZERO).getWeeks()); assertEquals(1, Weeks.ONE.plus((Weeks) null).getWeeks()); try { Weeks.MAX_VALUE.plus(Weeks.ONE); fail(); } catch (ArithmeticException ex) { // expected } } public void testMinus_int() { Weeks test2 = Weeks.weeks(2); Weeks result = test2.minus(3); assertEquals(2, test2.getWeeks()); assertEquals(-1, result.getWeeks()); assertEquals(1, Weeks.ONE.minus(0).getWeeks()); try { Weeks.MIN_VALUE.minus(1); fail(); } catch (ArithmeticException ex) { // expected } } public void testMinus_Weeks() { Weeks test2 = Weeks.weeks(2); Weeks test3 = Weeks.weeks(3); Weeks result = test2.minus(test3); assertEquals(2, test2.getWeeks()); assertEquals(3, test3.getWeeks()); assertEquals(-1, result.getWeeks()); assertEquals(1, Weeks.ONE.minus(Weeks.ZERO).getWeeks()); assertEquals(1, Weeks.ONE.minus((Weeks) null).getWeeks()); try { Weeks.MIN_VALUE.minus(Weeks.ONE); fail(); } catch (ArithmeticException ex) { // expected } } public void testMultipliedBy_int() { Weeks test = Weeks.weeks(2); assertEquals(6, test.multipliedBy(3).getWeeks()); assertEquals(2, test.getWeeks()); assertEquals(-6, test.multipliedBy(-3).getWeeks()); assertSame(test, test.multipliedBy(1)); Weeks halfMax = Weeks.weeks(Integer.MAX_VALUE / 2 + 1); try { halfMax.multipliedBy(2); fail(); } catch (ArithmeticException ex) { // expected } } public void testDividedBy_int() { Weeks test = Weeks.weeks(12); assertEquals(6, test.dividedBy(2).getWeeks()); assertEquals(12, test.getWeeks()); assertEquals(4, test.dividedBy(3).getWeeks()); assertEquals(3, test.dividedBy(4).getWeeks()); assertEquals(2, test.dividedBy(5).getWeeks()); assertEquals(2, test.dividedBy(6).getWeeks()); assertSame(test, test.dividedBy(1)); try { Weeks.ONE.dividedBy(0); fail(); } catch (ArithmeticException ex) { // expected } } public void testNegated() { Weeks test = Weeks.weeks(12); assertEquals(-12, test.negated().getWeeks()); assertEquals(12, test.getWeeks()); try { Weeks.MIN_VALUE.negated(); fail(); } catch (ArithmeticException ex) { // expected } } //----------------------------------------------------------------------- public void testAddToLocalDate() { Weeks test = Weeks.weeks(3); LocalDate date = new LocalDate(2006, 6, 1); LocalDate expected = new LocalDate(2006, 6, 22); assertEquals(expected, date.plus(test)); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Arrays; import java.util.Locale; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.BuddhistChronology; import org.joda.time.chrono.CopticChronology; import org.joda.time.chrono.GregorianChronology; import org.joda.time.chrono.ISOChronology; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; /** * This class is a Junit unit test for YearMonthDay. * * @author Stephen Colebourne */ @SuppressWarnings("deprecation") public class TestYearMonthDay_Basics extends TestCase { private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo"); private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS); private static final Chronology COPTIC_LONDON = CopticChronology.getInstance(LONDON); private static final Chronology COPTIC_TOKYO = CopticChronology.getInstance(TOKYO); private static final Chronology COPTIC_UTC = CopticChronology.getInstanceUTC(); private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC(); private static final Chronology BUDDHIST_TOKYO = BuddhistChronology.getInstance(TOKYO); private static final Chronology BUDDHIST_UTC = BuddhistChronology.getInstanceUTC(); private long TEST_TIME_NOW = (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; private DateTimeZone zone = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestYearMonthDay_Basics.class); } public TestYearMonthDay_Basics(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); zone = DateTimeZone.getDefault(); DateTimeZone.setDefault(LONDON); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(zone); zone = null; } //----------------------------------------------------------------------- public void testGet() { YearMonthDay test = new YearMonthDay(); assertEquals(1970, test.get(DateTimeFieldType.year())); assertEquals(6, test.get(DateTimeFieldType.monthOfYear())); assertEquals(9, test.get(DateTimeFieldType.dayOfMonth())); try { test.get(null); fail(); } catch (IllegalArgumentException ex) {} try { test.get(DateTimeFieldType.hourOfDay()); fail(); } catch (IllegalArgumentException ex) {} } public void testSize() { YearMonthDay test = new YearMonthDay(); assertEquals(3, test.size()); } public void testGetFieldType() { YearMonthDay test = new YearMonthDay(COPTIC_PARIS); assertSame(DateTimeFieldType.year(), test.getFieldType(0)); assertSame(DateTimeFieldType.monthOfYear(), test.getFieldType(1)); assertSame(DateTimeFieldType.dayOfMonth(), test.getFieldType(2)); try { test.getFieldType(-1); } catch (IndexOutOfBoundsException ex) {} try { test.getFieldType(3); } catch (IndexOutOfBoundsException ex) {} } public void testGetFieldTypes() { YearMonthDay test = new YearMonthDay(COPTIC_PARIS); DateTimeFieldType[] fields = test.getFieldTypes(); assertSame(DateTimeFieldType.year(), fields[0]); assertSame(DateTimeFieldType.monthOfYear(), fields[1]); assertSame(DateTimeFieldType.dayOfMonth(), fields[2]); assertNotSame(test.getFieldTypes(), test.getFieldTypes()); } public void testGetField() { YearMonthDay test = new YearMonthDay(COPTIC_PARIS); assertSame(COPTIC_UTC.year(), test.getField(0)); assertSame(COPTIC_UTC.monthOfYear(), test.getField(1)); assertSame(COPTIC_UTC.dayOfMonth(), test.getField(2)); try { test.getField(-1); } catch (IndexOutOfBoundsException ex) {} try { test.getField(3); } catch (IndexOutOfBoundsException ex) {} } public void testGetFields() { YearMonthDay test = new YearMonthDay(COPTIC_PARIS); DateTimeField[] fields = test.getFields(); assertSame(COPTIC_UTC.year(), fields[0]); assertSame(COPTIC_UTC.monthOfYear(), fields[1]); assertSame(COPTIC_UTC.dayOfMonth(), fields[2]); assertNotSame(test.getFields(), test.getFields()); } public void testGetValue() { YearMonthDay test = new YearMonthDay(); assertEquals(1970, test.getValue(0)); assertEquals(6, test.getValue(1)); assertEquals(9, test.getValue(2)); try { test.getValue(-1); } catch (IndexOutOfBoundsException ex) {} try { test.getValue(3); } catch (IndexOutOfBoundsException ex) {} } public void testGetValues() { YearMonthDay test = new YearMonthDay(); int[] values = test.getValues(); assertEquals(1970, values[0]); assertEquals(6, values[1]); assertEquals(9, values[2]); assertNotSame(test.getValues(), test.getValues()); } public void testIsSupported() { YearMonthDay test = new YearMonthDay(COPTIC_PARIS); assertEquals(true, test.isSupported(DateTimeFieldType.year())); assertEquals(true, test.isSupported(DateTimeFieldType.monthOfYear())); assertEquals(true, test.isSupported(DateTimeFieldType.dayOfMonth())); assertEquals(false, test.isSupported(DateTimeFieldType.hourOfDay())); } public void testEqualsHashCode() { YearMonthDay test1 = new YearMonthDay(1970, 6, 9, COPTIC_PARIS); YearMonthDay test2 = new YearMonthDay(1970, 6, 9, COPTIC_PARIS); assertEquals(true, test1.equals(test2)); assertEquals(true, test2.equals(test1)); assertEquals(true, test1.equals(test1)); assertEquals(true, test2.equals(test2)); assertEquals(true, test1.hashCode() == test2.hashCode()); assertEquals(true, test1.hashCode() == test1.hashCode()); assertEquals(true, test2.hashCode() == test2.hashCode()); YearMonthDay test3 = new YearMonthDay(1971, 6, 9); assertEquals(false, test1.equals(test3)); assertEquals(false, test2.equals(test3)); assertEquals(false, test3.equals(test1)); assertEquals(false, test3.equals(test2)); assertEquals(false, test1.hashCode() == test3.hashCode()); assertEquals(false, test2.hashCode() == test3.hashCode()); assertEquals(false, test1.equals("Hello")); assertEquals(true, test1.equals(new MockInstant())); assertEquals(false, test1.equals(MockPartial.EMPTY_INSTANCE)); } class MockInstant extends MockPartial { public Chronology getChronology() { return COPTIC_UTC; } public DateTimeField[] getFields() { return new DateTimeField[] { COPTIC_UTC.year(), COPTIC_UTC.monthOfYear(), COPTIC_UTC.dayOfMonth(), }; } public int[] getValues() { return new int[] {1970, 6, 9}; } } //----------------------------------------------------------------------- public void testCompareTo() { YearMonthDay test1 = new YearMonthDay(2005, 6, 2); YearMonthDay test1a = new YearMonthDay(2005, 6, 2); assertEquals(0, test1.compareTo(test1a)); assertEquals(0, test1a.compareTo(test1)); assertEquals(0, test1.compareTo(test1)); assertEquals(0, test1a.compareTo(test1a)); YearMonthDay test2 = new YearMonthDay(2005, 7, 2); assertEquals(-1, test1.compareTo(test2)); assertEquals(+1, test2.compareTo(test1)); YearMonthDay test3 = new YearMonthDay(2005, 7, 2, GregorianChronology.getInstanceUTC()); assertEquals(-1, test1.compareTo(test3)); assertEquals(+1, test3.compareTo(test1)); assertEquals(0, test3.compareTo(test2)); DateTimeFieldType[] types = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth(), }; int[] values = new int[] {2005, 6, 2}; Partial p = new Partial(types, values); assertEquals(0, test1.compareTo(p)); try { test1.compareTo(null); fail(); } catch (NullPointerException ex) {} // try { // test1.compareTo(new Date()); // fail(); // } catch (ClassCastException ex) {} try { test1.compareTo(new TimeOfDay()); fail(); } catch (ClassCastException ex) {} Partial partial = new Partial() .with(DateTimeFieldType.centuryOfEra(), 1) .with(DateTimeFieldType.halfdayOfDay(), 0) .with(DateTimeFieldType.dayOfMonth(), 9); try { new YearMonthDay(1970, 6, 9).compareTo(partial); fail(); } catch (ClassCastException ex) {} } //----------------------------------------------------------------------- public void testIsEqual_YMD() { YearMonthDay test1 = new YearMonthDay(2005, 6, 2); YearMonthDay test1a = new YearMonthDay(2005, 6, 2); assertEquals(true, test1.isEqual(test1a)); assertEquals(true, test1a.isEqual(test1)); assertEquals(true, test1.isEqual(test1)); assertEquals(true, test1a.isEqual(test1a)); YearMonthDay test2 = new YearMonthDay(2005, 7, 2); assertEquals(false, test1.isEqual(test2)); assertEquals(false, test2.isEqual(test1)); YearMonthDay test3 = new YearMonthDay(2005, 7, 2, GregorianChronology.getInstanceUTC()); assertEquals(false, test1.isEqual(test3)); assertEquals(false, test3.isEqual(test1)); assertEquals(true, test3.isEqual(test2)); try { new YearMonthDay(2005, 7, 2).isEqual(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testIsBefore_YMD() { YearMonthDay test1 = new YearMonthDay(2005, 6, 2); YearMonthDay test1a = new YearMonthDay(2005, 6, 2); assertEquals(false, test1.isBefore(test1a)); assertEquals(false, test1a.isBefore(test1)); assertEquals(false, test1.isBefore(test1)); assertEquals(false, test1a.isBefore(test1a)); YearMonthDay test2 = new YearMonthDay(2005, 7, 2); assertEquals(true, test1.isBefore(test2)); assertEquals(false, test2.isBefore(test1)); YearMonthDay test3 = new YearMonthDay(2005, 7, 2, GregorianChronology.getInstanceUTC()); assertEquals(true, test1.isBefore(test3)); assertEquals(false, test3.isBefore(test1)); assertEquals(false, test3.isBefore(test2)); try { new YearMonthDay(2005, 7, 2).isBefore(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testIsAfter_YMD() { YearMonthDay test1 = new YearMonthDay(2005, 6, 2); YearMonthDay test1a = new YearMonthDay(2005, 6, 2); assertEquals(false, test1.isAfter(test1a)); assertEquals(false, test1a.isAfter(test1)); assertEquals(false, test1.isAfter(test1)); assertEquals(false, test1a.isAfter(test1a)); YearMonthDay test2 = new YearMonthDay(2005, 7, 2); assertEquals(false, test1.isAfter(test2)); assertEquals(true, test2.isAfter(test1)); YearMonthDay test3 = new YearMonthDay(2005, 7, 2, GregorianChronology.getInstanceUTC()); assertEquals(false, test1.isAfter(test3)); assertEquals(true, test3.isAfter(test1)); assertEquals(false, test3.isAfter(test2)); try { new YearMonthDay(2005, 7, 2).isAfter(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testWithChronologyRetainFields_Chrono() { YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); YearMonthDay test = base.withChronologyRetainFields(BUDDHIST_TOKYO); check(base, 2005, 6, 9); assertEquals(COPTIC_UTC, base.getChronology()); check(test, 2005, 6, 9); assertEquals(BUDDHIST_UTC, test.getChronology()); } public void testWithChronologyRetainFields_sameChrono() { YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); YearMonthDay test = base.withChronologyRetainFields(COPTIC_TOKYO); assertSame(base, test); } public void testWithChronologyRetainFields_nullChrono() { YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); YearMonthDay test = base.withChronologyRetainFields(null); check(base, 2005, 6, 9); assertEquals(COPTIC_UTC, base.getChronology()); check(test, 2005, 6, 9); assertEquals(ISO_UTC, test.getChronology()); } public void testWithChronologyRetainFields_invalidInNewChrono() { YearMonthDay base = new YearMonthDay(2005, 1, 31, ISO_UTC); try { base.withChronologyRetainFields(COPTIC_UTC); fail(); } catch (IllegalArgumentException ex) { // expected } } //----------------------------------------------------------------------- public void testWithField1() { YearMonthDay test = new YearMonthDay(2004, 6, 9); YearMonthDay result = test.withField(DateTimeFieldType.year(), 2006); assertEquals(new YearMonthDay(2004, 6, 9), test); assertEquals(new YearMonthDay(2006, 6, 9), result); } public void testWithField2() { YearMonthDay test = new YearMonthDay(2004, 6, 9); try { test.withField(null, 6); fail(); } catch (IllegalArgumentException ex) {} } public void testWithField3() { YearMonthDay test = new YearMonthDay(2004, 6, 9); try { test.withField(DateTimeFieldType.hourOfDay(), 6); fail(); } catch (IllegalArgumentException ex) {} } public void testWithField4() { YearMonthDay test = new YearMonthDay(2004, 6, 9); YearMonthDay result = test.withField(DateTimeFieldType.year(), 2004); assertEquals(new YearMonthDay(2004, 6, 9), test); assertSame(test, result); } //----------------------------------------------------------------------- public void testWithFieldAdded1() { YearMonthDay test = new YearMonthDay(2004, 6, 9); YearMonthDay result = test.withFieldAdded(DurationFieldType.years(), 6); assertEquals(new YearMonthDay(2004, 6, 9), test); assertEquals(new YearMonthDay(2010, 6, 9), result); } public void testWithFieldAdded2() { YearMonthDay test = new YearMonthDay(2004, 6, 9); try { test.withFieldAdded(null, 0); fail(); } catch (IllegalArgumentException ex) {} } public void testWithFieldAdded3() { YearMonthDay test = new YearMonthDay(2004, 6, 9); try { test.withFieldAdded(null, 6); fail(); } catch (IllegalArgumentException ex) {} } public void testWithFieldAdded4() { YearMonthDay test = new YearMonthDay(2004, 6, 9); YearMonthDay result = test.withFieldAdded(DurationFieldType.years(), 0); assertSame(test, result); } public void testWithFieldAdded5() { YearMonthDay test = new YearMonthDay(2004, 6, 9); try { test.withFieldAdded(DurationFieldType.hours(), 6); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testPlus_RP() { YearMonthDay test = new YearMonthDay(2002, 5, 3, BuddhistChronology.getInstance()); YearMonthDay result = test.plus(new Period(1, 2, 3, 4, 5, 6, 7, 8)); YearMonthDay expected = new YearMonthDay(2003, 7, 7, BuddhistChronology.getInstance()); assertEquals(expected, result); result = test.plus((ReadablePeriod) null); assertSame(test, result); } public void testPlusYears_int() { YearMonthDay test = new YearMonthDay(2002, 5, 3, BuddhistChronology.getInstance()); YearMonthDay result = test.plusYears(1); YearMonthDay expected = new YearMonthDay(2003, 5, 3, BuddhistChronology.getInstance()); assertEquals(expected, result); result = test.plusYears(0); assertSame(test, result); } public void testPlusMonths_int() { YearMonthDay test = new YearMonthDay(2002, 5, 3, BuddhistChronology.getInstance()); YearMonthDay result = test.plusMonths(1); YearMonthDay expected = new YearMonthDay(2002, 6, 3, BuddhistChronology.getInstance()); assertEquals(expected, result); result = test.plusMonths(0); assertSame(test, result); } public void testPlusDays_int() { YearMonthDay test = new YearMonthDay(2002, 5, 3, BuddhistChronology.getInstance()); YearMonthDay result = test.plusDays(1); YearMonthDay expected = new YearMonthDay(2002, 5, 4, BuddhistChronology.getInstance()); assertEquals(expected, result); result = test.plusDays(0); assertSame(test, result); } //----------------------------------------------------------------------- public void testMinus_RP() { YearMonthDay test = new YearMonthDay(2002, 5, 3, BuddhistChronology.getInstance()); YearMonthDay result = test.minus(new Period(1, 1, 1, 1, 1, 1, 1, 1)); YearMonthDay expected = new YearMonthDay(2001, 4, 2, BuddhistChronology.getInstance()); assertEquals(expected, result); result = test.minus((ReadablePeriod) null); assertSame(test, result); } public void testMinusYears_int() { YearMonthDay test = new YearMonthDay(2002, 5, 3, BuddhistChronology.getInstance()); YearMonthDay result = test.minusYears(1); YearMonthDay expected = new YearMonthDay(2001, 5, 3, BuddhistChronology.getInstance()); assertEquals(expected, result); result = test.minusYears(0); assertSame(test, result); } public void testMinusMonths_int() { YearMonthDay test = new YearMonthDay(2002, 5, 3, BuddhistChronology.getInstance()); YearMonthDay result = test.minusMonths(1); YearMonthDay expected = new YearMonthDay(2002, 4, 3, BuddhistChronology.getInstance()); assertEquals(expected, result); result = test.minusMonths(0); assertSame(test, result); } public void testMinusDays_int() { YearMonthDay test = new YearMonthDay(2002, 5, 3, BuddhistChronology.getInstance()); YearMonthDay result = test.minusDays(1); YearMonthDay expected = new YearMonthDay(2002, 5, 2, BuddhistChronology.getInstance()); assertEquals(expected, result); result = test.minusDays(0); assertSame(test, result); } //----------------------------------------------------------------------- public void testToLocalDate() { YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_UTC); LocalDate test = base.toLocalDate(); assertEquals(new LocalDate(2005, 6, 9, COPTIC_UTC), test); } //----------------------------------------------------------------------- public void testToDateTimeAtMidnight() { YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); DateTime test = base.toDateTimeAtMidnight(); check(base, 2005, 6, 9); assertEquals(new DateTime(2005, 6, 9, 0, 0, 0, 0, COPTIC_LONDON), test); } //----------------------------------------------------------------------- public void testToDateTimeAtMidnight_Zone() { YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); DateTime test = base.toDateTimeAtMidnight(TOKYO); check(base, 2005, 6, 9); assertEquals(new DateTime(2005, 6, 9, 0, 0, 0, 0, COPTIC_TOKYO), test); } public void testToDateTimeAtMidnight_nullZone() { YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); DateTime test = base.toDateTimeAtMidnight((DateTimeZone) null); check(base, 2005, 6, 9); assertEquals(new DateTime(2005, 6, 9, 0, 0, 0, 0, COPTIC_LONDON), test); } //----------------------------------------------------------------------- public void testToDateTimeAtCurrentTime() { YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9); DateTimeUtils.setCurrentMillisFixed(dt.getMillis()); DateTime test = base.toDateTimeAtCurrentTime(); check(base, 2005, 6, 9); DateTime expected = new DateTime(dt.getMillis(), COPTIC_LONDON); expected = expected.year().setCopy(2005); expected = expected.monthOfYear().setCopy(6); expected = expected.dayOfMonth().setCopy(9); assertEquals(expected, test); } //----------------------------------------------------------------------- public void testToDateTimeAtCurrentTime_Zone() { YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9); DateTimeUtils.setCurrentMillisFixed(dt.getMillis()); DateTime test = base.toDateTimeAtCurrentTime(TOKYO); check(base, 2005, 6, 9); DateTime expected = new DateTime(dt.getMillis(), COPTIC_TOKYO); expected = expected.year().setCopy(2005); expected = expected.monthOfYear().setCopy(6); expected = expected.dayOfMonth().setCopy(9); assertEquals(expected, test); } public void testToDateTimeAtCurrentTime_nullZone() { YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9); DateTimeUtils.setCurrentMillisFixed(dt.getMillis()); DateTime test = base.toDateTimeAtCurrentTime((DateTimeZone) null); check(base, 2005, 6, 9); DateTime expected = new DateTime(dt.getMillis(), COPTIC_LONDON); expected = expected.year().setCopy(2005); expected = expected.monthOfYear().setCopy(6); expected = expected.dayOfMonth().setCopy(9); assertEquals(expected, test); } //----------------------------------------------------------------------- public void testToDateTime_TOD() { YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant TimeOfDay tod = new TimeOfDay(12, 13, 14, 15, BUDDHIST_TOKYO); DateTime test = base.toDateTime(tod); check(base, 2005, 6, 9); DateTime expected = new DateTime(2005, 6, 9, 12, 13, 14, 15, COPTIC_LONDON); assertEquals(expected, test); } public void testToDateTime_nullTOD() { YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant long now = new DateTime(2004, 5, 8, 12, 13, 14, 15, COPTIC_LONDON).getMillis(); DateTimeUtils.setCurrentMillisFixed(now); DateTime test = base.toDateTime((TimeOfDay) null); check(base, 2005, 6, 9); DateTime expected = new DateTime(2005, 6, 9, 12, 13, 14, 15, COPTIC_LONDON); assertEquals(expected, test); } //----------------------------------------------------------------------- public void testToDateTime_TOD_Zone() { YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant TimeOfDay tod = new TimeOfDay(12, 13, 14, 15, BUDDHIST_TOKYO); DateTime test = base.toDateTime(tod, TOKYO); check(base, 2005, 6, 9); DateTime expected = new DateTime(2005, 6, 9, 12, 13, 14, 15, COPTIC_TOKYO); assertEquals(expected, test); } public void testToDateTime_TOD_nullZone() { YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant TimeOfDay tod = new TimeOfDay(12, 13, 14, 15, BUDDHIST_TOKYO); DateTime test = base.toDateTime(tod, null); check(base, 2005, 6, 9); DateTime expected = new DateTime(2005, 6, 9, 12, 13, 14, 15, COPTIC_LONDON); assertEquals(expected, test); } public void testToDateTime_nullTOD_Zone() { YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant long now = new DateTime(2004, 5, 8, 12, 13, 14, 15, COPTIC_TOKYO).getMillis(); DateTimeUtils.setCurrentMillisFixed(now); DateTime test = base.toDateTime((TimeOfDay) null, TOKYO); check(base, 2005, 6, 9); DateTime expected = new DateTime(2005, 6, 9, 12, 13, 14, 15, COPTIC_TOKYO); assertEquals(expected, test); } //----------------------------------------------------------------------- public void testToDateMidnight() { YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); DateMidnight test = base.toDateMidnight(); check(base, 2005, 6, 9); assertEquals(new DateMidnight(2005, 6, 9, COPTIC_LONDON), test); } //----------------------------------------------------------------------- public void testToDateMidnight_Zone() { YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); DateMidnight test = base.toDateMidnight(TOKYO); check(base, 2005, 6, 9); assertEquals(new DateMidnight(2005, 6, 9, COPTIC_TOKYO), test); } public void testToDateMidnight_nullZone() { YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); DateMidnight test = base.toDateMidnight((DateTimeZone) null); check(base, 2005, 6, 9); assertEquals(new DateMidnight(2005, 6, 9, COPTIC_LONDON), test); } //----------------------------------------------------------------------- public void testToDateTime_RI() { YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); DateTime dt = new DateTime(2002, 1, 3, 4, 5, 6, 7); DateTime test = base.toDateTime(dt); check(base, 2005, 6, 9); DateTime expected = dt; expected = expected.year().setCopy(2005); expected = expected.monthOfYear().setCopy(6); expected = expected.dayOfMonth().setCopy(9); assertEquals(expected, test); } public void testToDateTime_nullRI() { YearMonthDay base = new YearMonthDay(2005, 6, 9); DateTime dt = new DateTime(2002, 1, 3, 4, 5, 6, 7); DateTimeUtils.setCurrentMillisFixed(dt.getMillis()); DateTime test = base.toDateTime((ReadableInstant) null); check(base, 2005, 6, 9); DateTime expected = dt; expected = expected.year().setCopy(2005); expected = expected.monthOfYear().setCopy(6); expected = expected.dayOfMonth().setCopy(9); assertEquals(expected, test); } //----------------------------------------------------------------------- public void testToInterval() { YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant Interval test = base.toInterval(); check(base, 2005, 6, 9); DateTime start = base.toDateTime(TimeOfDay.MIDNIGHT); DateTime end = start.plus(Period.days(1)); Interval expected = new Interval(start, end); assertEquals(expected, test); } //----------------------------------------------------------------------- public void testToInterval_Zone() { YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant Interval test = base.toInterval(TOKYO); check(base, 2005, 6, 9); DateTime start = base.toDateTime(TimeOfDay.MIDNIGHT, TOKYO); DateTime end = start.plus(Period.days(1)); Interval expected = new Interval(start, end); assertEquals(expected, test); } public void testToInterval_nullZone() { YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant Interval test = base.toInterval(null); check(base, 2005, 6, 9); DateTime start = base.toDateTime(TimeOfDay.MIDNIGHT, LONDON); DateTime end = start.plus(Period.days(1)); Interval expected = new Interval(start, end); assertEquals(expected, test); } //----------------------------------------------------------------------- public void testWithers() { YearMonthDay test = new YearMonthDay(1970, 6, 9); check(test.withYear(2000), 2000, 6, 9); check(test.withMonthOfYear(2), 1970, 2, 9); check(test.withDayOfMonth(2), 1970, 6, 2); try { test.withMonthOfYear(0); fail(); } catch (IllegalArgumentException ex) {} try { test.withMonthOfYear(13); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testProperty() { YearMonthDay test = new YearMonthDay(2005, 6, 9); assertEquals(test.year(), test.property(DateTimeFieldType.year())); assertEquals(test.monthOfYear(), test.property(DateTimeFieldType.monthOfYear())); assertEquals(test.dayOfMonth(), test.property(DateTimeFieldType.dayOfMonth())); try { test.property(DateTimeFieldType.millisOfDay()); fail(); } catch (IllegalArgumentException ex) {} try { test.property(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testSerialization() throws Exception { YearMonthDay test = new YearMonthDay(1972, 6, 9, COPTIC_PARIS); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(test); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); YearMonthDay result = (YearMonthDay) ois.readObject(); ois.close(); assertEquals(test, result); assertTrue(Arrays.equals(test.getValues(), result.getValues())); assertTrue(Arrays.equals(test.getFields(), result.getFields())); assertEquals(test.getChronology(), result.getChronology()); } //----------------------------------------------------------------------- public void testToString() { YearMonthDay test = new YearMonthDay(2002, 6, 9); assertEquals("2002-06-09", test.toString()); } //----------------------------------------------------------------------- public void testToString_String() { YearMonthDay test = new YearMonthDay(2002, 6, 9); assertEquals("2002 \ufffd\ufffd", test.toString("yyyy HH")); assertEquals("2002-06-09", test.toString((String) null)); } //----------------------------------------------------------------------- public void testToString_String_Locale() { YearMonthDay test = new YearMonthDay(2002, 6, 9); assertEquals("\ufffd 9/6", test.toString("EEE d/M", Locale.ENGLISH)); assertEquals("\ufffd 9/6", test.toString("EEE d/M", Locale.FRENCH)); assertEquals("2002-06-09", test.toString(null, Locale.ENGLISH)); assertEquals("\ufffd 9/6", test.toString("EEE d/M", null)); assertEquals("2002-06-09", test.toString(null, null)); } //----------------------------------------------------------------------- public void testToString_DTFormatter() { YearMonthDay test = new YearMonthDay(2002, 6, 9); assertEquals("2002 \ufffd\ufffd", test.toString(DateTimeFormat.forPattern("yyyy HH"))); assertEquals("2002-06-09", test.toString((DateTimeFormatter) null)); } //----------------------------------------------------------------------- private void check(YearMonthDay test, int hour, int min, int sec) { assertEquals(hour, test.getYear()); assertEquals(min, test.getMonthOfYear()); assertEquals(sec, test.getDayOfMonth()); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.GregorianChronology; import org.joda.time.chrono.ISOChronology; /** * This class is a Junit unit test for YearMonthDay. * * @author Stephen Colebourne */ @SuppressWarnings("deprecation") public class TestYearMonthDay_Constructors extends TestCase { private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC(); private static final Chronology GREGORIAN_UTC = GregorianChronology.getInstanceUTC(); private static final Chronology GREGORIAN_PARIS = GregorianChronology.getInstance(PARIS); private long TEST_TIME_NOW = (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; private long TEST_TIME1 = (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; private long TEST_TIME2 = (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone zone = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestYearMonthDay_Constructors.class); } public TestYearMonthDay_Constructors(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); zone = DateTimeZone.getDefault(); DateTimeZone.setDefault(LONDON); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(zone); zone = null; } //----------------------------------------------------------------------- public void testFactory_FromCalendarFields() throws Exception { GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6); cal.set(Calendar.MILLISECOND, 7); YearMonthDay expected = new YearMonthDay(1970, 2, 3); assertEquals(expected, YearMonthDay.fromCalendarFields(cal)); try { YearMonthDay.fromCalendarFields(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testFactory_FromDateFields() throws Exception { GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6); cal.set(Calendar.MILLISECOND, 7); YearMonthDay expected = new YearMonthDay(1970, 2, 3); assertEquals(expected, YearMonthDay.fromDateFields(cal.getTime())); try { YearMonthDay.fromDateFields(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- /** * Test constructor () */ public void testConstructor() throws Throwable { YearMonthDay test = new YearMonthDay(); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); } /** * Test constructor (DateTimeZone) */ public void testConstructor_DateTimeZone() throws Throwable { DateTime dt = new DateTime(2005, 6, 8, 23, 59, 0, 0, LONDON); DateTimeUtils.setCurrentMillisFixed(dt.getMillis()); // 23:59 in London is 00:59 the following day in Paris YearMonthDay test = new YearMonthDay(LONDON); assertEquals(ISO_UTC, test.getChronology()); assertEquals(2005, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(8, test.getDayOfMonth()); test = new YearMonthDay(PARIS); assertEquals(ISO_UTC, test.getChronology()); assertEquals(2005, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); } /** * Test constructor (DateTimeZone=null) */ public void testConstructor_nullDateTimeZone() throws Throwable { DateTime dt = new DateTime(2005, 6, 8, 23, 59, 0, 0, LONDON); DateTimeUtils.setCurrentMillisFixed(dt.getMillis()); // 23:59 in London is 00:59 the following day in Paris YearMonthDay test = new YearMonthDay((DateTimeZone) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(2005, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(8, test.getDayOfMonth()); } /** * Test constructor (Chronology) */ public void testConstructor_Chronology() throws Throwable { YearMonthDay test = new YearMonthDay(GREGORIAN_PARIS); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); } /** * Test constructor (Chronology=null) */ public void testConstructor_nullChronology() throws Throwable { YearMonthDay test = new YearMonthDay((Chronology) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); } //----------------------------------------------------------------------- /** * Test constructor (long) */ public void testConstructor_long1() throws Throwable { YearMonthDay test = new YearMonthDay(TEST_TIME1); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); } /** * Test constructor (long) */ public void testConstructor_long2() throws Throwable { YearMonthDay test = new YearMonthDay(TEST_TIME2); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1971, test.getYear()); assertEquals(5, test.getMonthOfYear()); assertEquals(7, test.getDayOfMonth()); } /** * Test constructor (long, Chronology) */ public void testConstructor_long1_Chronology() throws Throwable { YearMonthDay test = new YearMonthDay(TEST_TIME1, GREGORIAN_PARIS); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); } /** * Test constructor (long, Chronology) */ public void testConstructor_long2_Chronology() throws Throwable { YearMonthDay test = new YearMonthDay(TEST_TIME2, GREGORIAN_PARIS); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(1971, test.getYear()); assertEquals(5, test.getMonthOfYear()); assertEquals(7, test.getDayOfMonth()); } /** * Test constructor (long, Chronology=null) */ public void testConstructor_long_nullChronology() throws Throwable { YearMonthDay test = new YearMonthDay(TEST_TIME1, null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); } //----------------------------------------------------------------------- public void testConstructor_Object() throws Throwable { Date date = new Date(TEST_TIME1); YearMonthDay test = new YearMonthDay(date); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); } public void testConstructor_nullObject() throws Throwable { YearMonthDay test = new YearMonthDay((Object) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); } public void testConstructor_ObjectString1() throws Throwable { YearMonthDay test = new YearMonthDay("1972-12-03"); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1972, test.getYear()); assertEquals(12, test.getMonthOfYear()); assertEquals(3, test.getDayOfMonth()); } public void testConstructor_ObjectString2() throws Throwable { YearMonthDay test = new YearMonthDay("1972-12-03T+14:00"); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1972, test.getYear()); assertEquals(12, test.getMonthOfYear()); assertEquals(2, test.getDayOfMonth()); // timezone } public void testConstructor_ObjectString3() throws Throwable { YearMonthDay test = new YearMonthDay("1972-12-03T10:20:30.040"); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1972, test.getYear()); assertEquals(12, test.getMonthOfYear()); assertEquals(3, test.getDayOfMonth()); } public void testConstructor_ObjectString4() throws Throwable { YearMonthDay test = new YearMonthDay("1972-12-03T10:20:30.040+14:00"); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1972, test.getYear()); assertEquals(12, test.getMonthOfYear()); assertEquals(2, test.getDayOfMonth()); // timezone } public void testConstructor_ObjectString5() throws Throwable { YearMonthDay test = new YearMonthDay("10"); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10, test.getYear()); assertEquals(1, test.getMonthOfYear()); assertEquals(1, test.getDayOfMonth()); } public void testConstructor_ObjectStringEx1() throws Throwable { try { new YearMonthDay("T10:20:30.040"); fail(); } catch (IllegalArgumentException ex) { // expected } } public void testConstructor_ObjectStringEx2() throws Throwable { try { new YearMonthDay("T10:20:30.040+14:00"); fail(); } catch (IllegalArgumentException ex) { // expected } } public void testConstructor_ObjectStringEx3() throws Throwable { try { new YearMonthDay("10:20:30.040"); fail(); } catch (IllegalArgumentException ex) { // expected } } public void testConstructor_ObjectStringEx4() throws Throwable { try { new YearMonthDay("10:20:30.040+14:00"); fail(); } catch (IllegalArgumentException ex) { // expected } } //----------------------------------------------------------------------- /** * Test constructor (Object, Chronology) */ public void testConstructor_Object_Chronology() throws Throwable { Date date = new Date(TEST_TIME1); YearMonthDay test = new YearMonthDay(date, GREGORIAN_PARIS); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); } /** * Test constructor (Object=null, Chronology) */ public void testConstructor_nullObject_Chronology() throws Throwable { YearMonthDay test = new YearMonthDay((Object) null, GREGORIAN_PARIS); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); } /** * Test constructor (Object, Chronology=null) */ public void testConstructor_Object_nullChronology() throws Throwable { Date date = new Date(TEST_TIME1); YearMonthDay test = new YearMonthDay(date, null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); } /** * Test constructor (Object=null, Chronology=null) */ public void testConstructor_nullObject_nullChronology() throws Throwable { YearMonthDay test = new YearMonthDay((Object) null, null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); } //----------------------------------------------------------------------- /** * Test constructor (int, int, int) */ public void testConstructor_int_int_int() throws Throwable { YearMonthDay test = new YearMonthDay(1970, 6, 9); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); try { new YearMonthDay(Integer.MIN_VALUE, 6, 9); fail(); } catch (IllegalArgumentException ex) {} try { new YearMonthDay(Integer.MAX_VALUE, 6, 9); fail(); } catch (IllegalArgumentException ex) {} try { new YearMonthDay(1970, 0, 9); fail(); } catch (IllegalArgumentException ex) {} try { new YearMonthDay(1970, 13, 9); fail(); } catch (IllegalArgumentException ex) {} try { new YearMonthDay(1970, 6, 0); fail(); } catch (IllegalArgumentException ex) {} try { new YearMonthDay(1970, 6, 31); fail(); } catch (IllegalArgumentException ex) {} new YearMonthDay(1970, 7, 31); try { new YearMonthDay(1970, 7, 32); fail(); } catch (IllegalArgumentException ex) {} } /** * Test constructor (int, int, int, Chronology) */ public void testConstructor_int_int_int_Chronology() throws Throwable { YearMonthDay test = new YearMonthDay(1970, 6, 9, GREGORIAN_PARIS); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); try { new YearMonthDay(Integer.MIN_VALUE, 6, 9, GREGORIAN_PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new YearMonthDay(Integer.MAX_VALUE, 6, 9, GREGORIAN_PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new YearMonthDay(1970, 0, 9, GREGORIAN_PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new YearMonthDay(1970, 13, 9, GREGORIAN_PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new YearMonthDay(1970, 6, 0, GREGORIAN_PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new YearMonthDay(1970, 6, 31, GREGORIAN_PARIS); fail(); } catch (IllegalArgumentException ex) {} new YearMonthDay(1970, 7, 31, GREGORIAN_PARIS); try { new YearMonthDay(1970, 7, 32, GREGORIAN_PARIS); fail(); } catch (IllegalArgumentException ex) {} } /** * Test constructor (int, int, int, Chronology=null) */ public void testConstructor_int_int_int_nullChronology() throws Throwable { YearMonthDay test = new YearMonthDay(1970, 6, 9, null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.util.Locale; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.CopticChronology; import org.joda.time.chrono.LenientChronology; import org.joda.time.chrono.StrictChronology; /** * This class is a Junit unit test for YearMonthDay. * * @author Stephen Colebourne */ @SuppressWarnings("deprecation") public class TestYearMonthDay_Properties extends TestCase { private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS); private long TEST_TIME_NOW = (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; private long TEST_TIME1 = (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; private long TEST_TIME2 = (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone zone = null; private Locale systemDefaultLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestYearMonthDay_Properties.class); } public TestYearMonthDay_Properties(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); zone = DateTimeZone.getDefault(); DateTimeZone.setDefault(DateTimeZone.UTC); systemDefaultLocale = Locale.getDefault(); Locale.setDefault(Locale.ENGLISH); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(zone); zone = null; Locale.setDefault(systemDefaultLocale); systemDefaultLocale = null; } //----------------------------------------------------------------------- public void testPropertyGetYear() { YearMonthDay test = new YearMonthDay(1972, 6, 9); assertSame(test.getChronology().year(), test.year().getField()); assertEquals("year", test.year().getName()); assertEquals("Property[year]", test.year().toString()); assertSame(test, test.year().getReadablePartial()); assertSame(test, test.year().getYearMonthDay()); assertEquals(1972, test.year().get()); assertEquals("1972", test.year().getAsString()); assertEquals("1972", test.year().getAsText()); assertEquals("1972", test.year().getAsText(Locale.FRENCH)); assertEquals("1972", test.year().getAsShortText()); assertEquals("1972", test.year().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().years(), test.year().getDurationField()); assertEquals(null, test.year().getRangeDurationField()); assertEquals(9, test.year().getMaximumTextLength(null)); assertEquals(9, test.year().getMaximumShortTextLength(null)); } public void testPropertyGetMaxMinValuesYear() { YearMonthDay test = new YearMonthDay(1972, 6, 9); assertEquals(-292275054, test.year().getMinimumValue()); assertEquals(-292275054, test.year().getMinimumValueOverall()); assertEquals(292278993, test.year().getMaximumValue()); assertEquals(292278993, test.year().getMaximumValueOverall()); } public void testPropertyAddYear() { YearMonthDay test = new YearMonthDay(1972, 6, 9); YearMonthDay copy = test.year().addToCopy(9); check(test, 1972, 6, 9); check(copy, 1981, 6, 9); copy = test.year().addToCopy(0); check(copy, 1972, 6, 9); copy = test.year().addToCopy(292277023 - 1972); check(copy, 292277023, 6, 9); try { test.year().addToCopy(292278993 - 1972 + 1); fail(); } catch (IllegalArgumentException ex) {} check(test, 1972, 6, 9); copy = test.year().addToCopy(-1972); check(copy, 0, 6, 9); copy = test.year().addToCopy(-1973); check(copy, -1, 6, 9); try { test.year().addToCopy(-292275054 - 1972 - 1); fail(); } catch (IllegalArgumentException ex) {} check(test, 1972, 6, 9); } public void testPropertyAddWrapFieldYear() { YearMonthDay test = new YearMonthDay(1972, 6, 9); YearMonthDay copy = test.year().addWrapFieldToCopy(9); check(test, 1972, 6, 9); check(copy, 1981, 6, 9); copy = test.year().addWrapFieldToCopy(0); check(copy, 1972, 6, 9); copy = test.year().addWrapFieldToCopy(292278993 - 1972 + 1); check(copy, -292275054, 6, 9); copy = test.year().addWrapFieldToCopy(-292275054 - 1972 - 1); check(copy, 292278993, 6, 9); } public void testPropertySetYear() { YearMonthDay test = new YearMonthDay(1972, 6, 9); YearMonthDay copy = test.year().setCopy(12); check(test, 1972, 6, 9); check(copy, 12, 6, 9); } public void testPropertySetTextYear() { YearMonthDay test = new YearMonthDay(1972, 6, 9); YearMonthDay copy = test.year().setCopy("12"); check(test, 1972, 6, 9); check(copy, 12, 6, 9); } public void testPropertyCompareToYear() { YearMonthDay test1 = new YearMonthDay(TEST_TIME1); YearMonthDay test2 = new YearMonthDay(TEST_TIME2); assertEquals(true, test1.year().compareTo(test2) < 0); assertEquals(true, test2.year().compareTo(test1) > 0); assertEquals(true, test1.year().compareTo(test1) == 0); try { test1.year().compareTo((ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} DateTime dt1 = new DateTime(TEST_TIME1); DateTime dt2 = new DateTime(TEST_TIME2); assertEquals(true, test1.year().compareTo(dt2) < 0); assertEquals(true, test2.year().compareTo(dt1) > 0); assertEquals(true, test1.year().compareTo(dt1) == 0); try { test1.year().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testPropertyGetMonth() { YearMonthDay test = new YearMonthDay(1972, 6, 9); assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField()); assertEquals("monthOfYear", test.monthOfYear().getName()); assertEquals("Property[monthOfYear]", test.monthOfYear().toString()); assertSame(test, test.monthOfYear().getReadablePartial()); assertSame(test, test.monthOfYear().getYearMonthDay()); assertEquals(6, test.monthOfYear().get()); assertEquals("6", test.monthOfYear().getAsString()); assertEquals("June", test.monthOfYear().getAsText()); assertEquals("juin", test.monthOfYear().getAsText(Locale.FRENCH)); assertEquals("Jun", test.monthOfYear().getAsShortText()); assertEquals("juin", test.monthOfYear().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField()); assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField()); assertEquals(9, test.monthOfYear().getMaximumTextLength(null)); assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null)); test = new YearMonthDay(1972, 7, 9); assertEquals("juillet", test.monthOfYear().getAsText(Locale.FRENCH)); assertEquals("juil.", test.monthOfYear().getAsShortText(Locale.FRENCH)); } public void testPropertyGetMaxMinValuesMonth() { YearMonthDay test = new YearMonthDay(1972, 6, 9); assertEquals(1, test.monthOfYear().getMinimumValue()); assertEquals(1, test.monthOfYear().getMinimumValueOverall()); assertEquals(12, test.monthOfYear().getMaximumValue()); assertEquals(12, test.monthOfYear().getMaximumValueOverall()); } public void testPropertyAddMonth() { YearMonthDay test = new YearMonthDay(1972, 6, 9); YearMonthDay copy = test.monthOfYear().addToCopy(6); check(test, 1972, 6, 9); check(copy, 1972, 12, 9); copy = test.monthOfYear().addToCopy(7); check(copy, 1973, 1, 9); copy = test.monthOfYear().addToCopy(-5); check(copy, 1972, 1, 9); copy = test.monthOfYear().addToCopy(-6); check(copy, 1971, 12, 9); test = new YearMonthDay(1972, 1, 31); copy = test.monthOfYear().addToCopy(1); check(copy, 1972, 2, 29); copy = test.monthOfYear().addToCopy(2); check(copy, 1972, 3, 31); copy = test.monthOfYear().addToCopy(3); check(copy, 1972, 4, 30); test = new YearMonthDay(1971, 1, 31); copy = test.monthOfYear().addToCopy(1); check(copy, 1971, 2, 28); } public void testPropertyAddWrapFieldMonth() { YearMonthDay test = new YearMonthDay(1972, 6, 9); YearMonthDay copy = test.monthOfYear().addWrapFieldToCopy(4); check(test, 1972, 6, 9); check(copy, 1972, 10, 9); copy = test.monthOfYear().addWrapFieldToCopy(8); check(copy, 1972, 2, 9); copy = test.monthOfYear().addWrapFieldToCopy(-8); check(copy, 1972, 10, 9); test = new YearMonthDay(1972, 1, 31); copy = test.monthOfYear().addWrapFieldToCopy(1); check(copy, 1972, 2, 29); copy = test.monthOfYear().addWrapFieldToCopy(2); check(copy, 1972, 3, 31); copy = test.monthOfYear().addWrapFieldToCopy(3); check(copy, 1972, 4, 30); test = new YearMonthDay(1971, 1, 31); copy = test.monthOfYear().addWrapFieldToCopy(1); check(copy, 1971, 2, 28); } public void testPropertySetMonth() { YearMonthDay test = new YearMonthDay(1972, 6, 9); YearMonthDay copy = test.monthOfYear().setCopy(12); check(test, 1972, 6, 9); check(copy, 1972, 12, 9); test = new YearMonthDay(1972, 1, 31); copy = test.monthOfYear().setCopy(2); check(copy, 1972, 2, 29); try { test.monthOfYear().setCopy(13); fail(); } catch (IllegalArgumentException ex) {} try { test.monthOfYear().setCopy(0); fail(); } catch (IllegalArgumentException ex) {} } public void testPropertySetTextMonth() { YearMonthDay test = new YearMonthDay(1972, 6, 9); YearMonthDay copy = test.monthOfYear().setCopy("12"); check(test, 1972, 6, 9); check(copy, 1972, 12, 9); copy = test.monthOfYear().setCopy("December"); check(test, 1972, 6, 9); check(copy, 1972, 12, 9); copy = test.monthOfYear().setCopy("Dec"); check(test, 1972, 6, 9); check(copy, 1972, 12, 9); } public void testPropertyCompareToMonth() { YearMonthDay test1 = new YearMonthDay(TEST_TIME1); YearMonthDay test2 = new YearMonthDay(TEST_TIME2); assertEquals(true, test1.monthOfYear().compareTo(test2) < 0); assertEquals(true, test2.monthOfYear().compareTo(test1) > 0); assertEquals(true, test1.monthOfYear().compareTo(test1) == 0); try { test1.monthOfYear().compareTo((ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} DateTime dt1 = new DateTime(TEST_TIME1); DateTime dt2 = new DateTime(TEST_TIME2); assertEquals(true, test1.monthOfYear().compareTo(dt2) < 0); assertEquals(true, test2.monthOfYear().compareTo(dt1) > 0); assertEquals(true, test1.monthOfYear().compareTo(dt1) == 0); try { test1.monthOfYear().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testPropertyGetDay() { YearMonthDay test = new YearMonthDay(1972, 6, 9); assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField()); assertEquals("dayOfMonth", test.dayOfMonth().getName()); assertEquals("Property[dayOfMonth]", test.dayOfMonth().toString()); assertSame(test, test.dayOfMonth().getReadablePartial()); assertSame(test, test.dayOfMonth().getYearMonthDay()); assertEquals(9, test.dayOfMonth().get()); assertEquals("9", test.dayOfMonth().getAsString()); assertEquals("9", test.dayOfMonth().getAsText()); assertEquals("9", test.dayOfMonth().getAsText(Locale.FRENCH)); assertEquals("9", test.dayOfMonth().getAsShortText()); assertEquals("9", test.dayOfMonth().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField()); assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField()); assertEquals(2, test.dayOfMonth().getMaximumTextLength(null)); assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null)); } public void testPropertyGetMaxMinValuesDay() { YearMonthDay test = new YearMonthDay(1972, 6, 9); assertEquals(1, test.dayOfMonth().getMinimumValue()); assertEquals(1, test.dayOfMonth().getMinimumValueOverall()); assertEquals(30, test.dayOfMonth().getMaximumValue()); assertEquals(31, test.dayOfMonth().getMaximumValueOverall()); test = new YearMonthDay(1972, 7, 9); assertEquals(31, test.dayOfMonth().getMaximumValue()); test = new YearMonthDay(1972, 2, 9); assertEquals(29, test.dayOfMonth().getMaximumValue()); test = new YearMonthDay(1971, 2, 9); assertEquals(28, test.dayOfMonth().getMaximumValue()); } public void testPropertyAddDay() { YearMonthDay test = new YearMonthDay(1972, 6, 9); YearMonthDay copy = test.dayOfMonth().addToCopy(9); check(test, 1972, 6, 9); check(copy, 1972, 6, 18); copy = test.dayOfMonth().addToCopy(21); check(copy, 1972, 6, 30); copy = test.dayOfMonth().addToCopy(22); check(copy, 1972, 7, 1); copy = test.dayOfMonth().addToCopy(22 + 30); check(copy, 1972, 7, 31); copy = test.dayOfMonth().addToCopy(22 + 31); check(copy, 1972, 8, 1); copy = test.dayOfMonth().addToCopy(21 + 31 + 31 + 30 + 31 + 30 + 31); check(copy, 1972, 12, 31); copy = test.dayOfMonth().addToCopy(22 + 31 + 31 + 30 + 31 + 30 + 31); check(copy, 1973, 1, 1); copy = test.dayOfMonth().addToCopy(-8); check(copy, 1972, 6, 1); copy = test.dayOfMonth().addToCopy(-9); check(copy, 1972, 5, 31); copy = test.dayOfMonth().addToCopy(-8 - 31 - 30 - 31 - 29 - 31); check(copy, 1972, 1, 1); copy = test.dayOfMonth().addToCopy(-9 - 31 - 30 - 31 - 29 - 31); check(copy, 1971, 12, 31); } public void testPropertyAddWrapFieldDay() { YearMonthDay test = new YearMonthDay(1972, 6, 9); YearMonthDay copy = test.dayOfMonth().addWrapFieldToCopy(21); check(test, 1972, 6, 9); check(copy, 1972, 6, 30); copy = test.dayOfMonth().addWrapFieldToCopy(22); check(copy, 1972, 6, 1); copy = test.dayOfMonth().addWrapFieldToCopy(-12); check(copy, 1972, 6, 27); test = new YearMonthDay(1972, 7, 9); copy = test.dayOfMonth().addWrapFieldToCopy(21); check(copy, 1972, 7, 30); copy = test.dayOfMonth().addWrapFieldToCopy(22); check(copy, 1972, 7, 31); copy = test.dayOfMonth().addWrapFieldToCopy(23); check(copy, 1972, 7, 1); copy = test.dayOfMonth().addWrapFieldToCopy(-12); check(copy, 1972, 7, 28); } public void testPropertySetDay() { YearMonthDay test = new YearMonthDay(1972, 6, 9); YearMonthDay copy = test.dayOfMonth().setCopy(12); check(test, 1972, 6, 9); check(copy, 1972, 6, 12); try { test.dayOfMonth().setCopy(31); fail(); } catch (IllegalArgumentException ex) {} try { test.dayOfMonth().setCopy(0); fail(); } catch (IllegalArgumentException ex) {} } public void testPropertySetTextDay() { YearMonthDay test = new YearMonthDay(1972, 6, 9); YearMonthDay copy = test.dayOfMonth().setCopy("12"); check(test, 1972, 6, 9); check(copy, 1972, 6, 12); } public void testPropertyWithMaximumValueDayOfMonth() { YearMonthDay test = new YearMonthDay(1972, 6, 9); YearMonthDay copy = test.dayOfMonth().withMaximumValue(); check(test, 1972, 6, 9); check(copy, 1972, 6, 30); } public void testPropertyWithMinimumValueDayOfMonth() { YearMonthDay test = new YearMonthDay(1972, 6, 9); YearMonthDay copy = test.dayOfMonth().withMinimumValue(); check(test, 1972, 6, 9); check(copy, 1972, 6, 1); } public void testPropertyCompareToDay() { YearMonthDay test1 = new YearMonthDay(TEST_TIME1); YearMonthDay test2 = new YearMonthDay(TEST_TIME2); assertEquals(true, test1.dayOfMonth().compareTo(test2) < 0); assertEquals(true, test2.dayOfMonth().compareTo(test1) > 0); assertEquals(true, test1.dayOfMonth().compareTo(test1) == 0); try { test1.dayOfMonth().compareTo((ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} DateTime dt1 = new DateTime(TEST_TIME1); DateTime dt2 = new DateTime(TEST_TIME2); assertEquals(true, test1.dayOfMonth().compareTo(dt2) < 0); assertEquals(true, test2.dayOfMonth().compareTo(dt1) > 0); assertEquals(true, test1.dayOfMonth().compareTo(dt1) == 0); try { test1.dayOfMonth().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} } public void testPropertyEquals() { YearMonthDay test1 = new YearMonthDay(2005, 11, 8); YearMonthDay test2 = new YearMonthDay(2005, 11, 9); YearMonthDay test3 = new YearMonthDay(2005, 11, 8, CopticChronology.getInstanceUTC()); assertEquals(false, test1.dayOfMonth().equals(test1.year())); assertEquals(false, test1.dayOfMonth().equals(test1.monthOfYear())); assertEquals(true, test1.dayOfMonth().equals(test1.dayOfMonth())); assertEquals(false, test1.dayOfMonth().equals(test2.year())); assertEquals(false, test1.dayOfMonth().equals(test2.monthOfYear())); assertEquals(false, test1.dayOfMonth().equals(test2.dayOfMonth())); assertEquals(false, test1.monthOfYear().equals(test1.year())); assertEquals(true, test1.monthOfYear().equals(test1.monthOfYear())); assertEquals(false, test1.monthOfYear().equals(test1.dayOfMonth())); assertEquals(false, test1.monthOfYear().equals(test2.year())); assertEquals(true, test1.monthOfYear().equals(test2.monthOfYear())); assertEquals(false, test1.monthOfYear().equals(test2.dayOfMonth())); assertEquals(false, test1.dayOfMonth().equals(null)); assertEquals(false, test1.dayOfMonth().equals("any")); // chrono assertEquals(false, test1.dayOfMonth().equals(test3.dayOfMonth())); } public void testPropertyHashCode() { YearMonthDay test1 = new YearMonthDay(2005, 11, 8); YearMonthDay test2 = new YearMonthDay(2005, 11, 9); assertEquals(true, test1.dayOfMonth().hashCode() == test1.dayOfMonth().hashCode()); assertEquals(false, test1.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode()); assertEquals(true, test1.monthOfYear().hashCode() == test1.monthOfYear().hashCode()); assertEquals(true, test1.monthOfYear().hashCode() == test2.monthOfYear().hashCode()); } public void testPropertyEqualsHashCodeLenient() { YearMonthDay test1 = new YearMonthDay(1970, 6, 9, LenientChronology.getInstance(COPTIC_PARIS)); YearMonthDay test2 = new YearMonthDay(1970, 6, 9, LenientChronology.getInstance(COPTIC_PARIS)); assertEquals(true, test1.dayOfMonth().equals(test2.dayOfMonth())); assertEquals(true, test2.dayOfMonth().equals(test1.dayOfMonth())); assertEquals(true, test1.dayOfMonth().equals(test1.dayOfMonth())); assertEquals(true, test2.dayOfMonth().equals(test2.dayOfMonth())); assertEquals(true, test1.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode()); assertEquals(true, test1.dayOfMonth().hashCode() == test1.dayOfMonth().hashCode()); assertEquals(true, test2.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode()); } public void testPropertyEqualsHashCodeStrict() { YearMonthDay test1 = new YearMonthDay(1970, 6, 9, StrictChronology.getInstance(COPTIC_PARIS)); YearMonthDay test2 = new YearMonthDay(1970, 6, 9, StrictChronology.getInstance(COPTIC_PARIS)); assertEquals(true, test1.dayOfMonth().equals(test2.dayOfMonth())); assertEquals(true, test2.dayOfMonth().equals(test1.dayOfMonth())); assertEquals(true, test1.dayOfMonth().equals(test1.dayOfMonth())); assertEquals(true, test2.dayOfMonth().equals(test2.dayOfMonth())); assertEquals(true, test1.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode()); assertEquals(true, test1.dayOfMonth().hashCode() == test1.dayOfMonth().hashCode()); assertEquals(true, test2.dayOfMonth().hashCode() == test2.dayOfMonth().hashCode()); } //----------------------------------------------------------------------- private void check(YearMonthDay test, int year, int month, int day) { assertEquals(year, test.getYear()); assertEquals(month, test.getMonthOfYear()); assertEquals(day, test.getDayOfMonth()); } }
/* * Copyright 2001-2009 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Arrays; import java.util.Locale; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.BuddhistChronology; import org.joda.time.chrono.CopticChronology; import org.joda.time.chrono.GregorianChronology; import org.joda.time.chrono.ISOChronology; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; /** * This class is a Junit unit test for YearMonth. * * @author Stephen Colebourne */ public class TestYearMonth_Basics extends TestCase { private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo"); private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS); private static final Chronology COPTIC_LONDON = CopticChronology.getInstance(LONDON); private static final Chronology COPTIC_TOKYO = CopticChronology.getInstance(TOKYO); private static final Chronology COPTIC_UTC = CopticChronology.getInstanceUTC(); // private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS); // private static final Chronology ISO_LONDON = ISOChronology.getInstance(LONDON); // private static final Chronology ISO_TOKYO = ISOChronology.getInstance(TOKYO); private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC(); // private static final Chronology BUDDHIST_PARIS = BuddhistChronology.getInstance(PARIS); // private static final Chronology BUDDHIST_LONDON = BuddhistChronology.getInstance(LONDON); private static final Chronology BUDDHIST_TOKYO = BuddhistChronology.getInstance(TOKYO); private static final Chronology BUDDHIST_UTC = BuddhistChronology.getInstanceUTC(); private long TEST_TIME_NOW = (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; private DateTimeZone zone = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestYearMonth_Basics.class); } public TestYearMonth_Basics(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); zone = DateTimeZone.getDefault(); DateTimeZone.setDefault(LONDON); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(zone); zone = null; } //----------------------------------------------------------------------- public void testGet() { YearMonth test = new YearMonth(); assertEquals(1970, test.get(DateTimeFieldType.year())); assertEquals(6, test.get(DateTimeFieldType.monthOfYear())); try { test.get(null); fail(); } catch (IllegalArgumentException ex) {} try { test.get(DateTimeFieldType.dayOfMonth()); fail(); } catch (IllegalArgumentException ex) {} } public void testSize() { YearMonth test = new YearMonth(); assertEquals(2, test.size()); } public void testGetFieldType() { YearMonth test = new YearMonth(COPTIC_PARIS); assertSame(DateTimeFieldType.year(), test.getFieldType(0)); assertSame(DateTimeFieldType.monthOfYear(), test.getFieldType(1)); try { test.getFieldType(-1); } catch (IndexOutOfBoundsException ex) {} try { test.getFieldType(2); } catch (IndexOutOfBoundsException ex) {} } public void testGetFieldTypes() { YearMonth test = new YearMonth(COPTIC_PARIS); DateTimeFieldType[] fields = test.getFieldTypes(); assertEquals(2, fields.length); assertSame(DateTimeFieldType.year(), fields[0]); assertSame(DateTimeFieldType.monthOfYear(), fields[1]); assertNotSame(test.getFieldTypes(), test.getFieldTypes()); } public void testGetField() { YearMonth test = new YearMonth(COPTIC_PARIS); assertSame(COPTIC_UTC.year(), test.getField(0)); assertSame(COPTIC_UTC.monthOfYear(), test.getField(1)); try { test.getField(-1); } catch (IndexOutOfBoundsException ex) {} try { test.getField(2); } catch (IndexOutOfBoundsException ex) {} } public void testGetFields() { YearMonth test = new YearMonth(COPTIC_PARIS); DateTimeField[] fields = test.getFields(); assertEquals(2, fields.length); assertSame(COPTIC_UTC.year(), fields[0]); assertSame(COPTIC_UTC.monthOfYear(), fields[1]); assertNotSame(test.getFields(), test.getFields()); } public void testGetValue() { YearMonth test = new YearMonth(); assertEquals(1970, test.getValue(0)); assertEquals(6, test.getValue(1)); try { test.getValue(-1); } catch (IndexOutOfBoundsException ex) {} try { test.getValue(2); } catch (IndexOutOfBoundsException ex) {} } public void testGetValues() { YearMonth test = new YearMonth(); int[] values = test.getValues(); assertEquals(2, values.length); assertEquals(1970, values[0]); assertEquals(6, values[1]); assertNotSame(test.getValues(), test.getValues()); } public void testIsSupported() { YearMonth test = new YearMonth(COPTIC_PARIS); assertEquals(true, test.isSupported(DateTimeFieldType.year())); assertEquals(true, test.isSupported(DateTimeFieldType.monthOfYear())); assertEquals(false, test.isSupported(DateTimeFieldType.dayOfMonth())); assertEquals(false, test.isSupported(DateTimeFieldType.hourOfDay())); } public void testEqualsHashCode() { YearMonth test1 = new YearMonth(1970, 6, COPTIC_PARIS); YearMonth test2 = new YearMonth(1970, 6, COPTIC_PARIS); assertEquals(true, test1.equals(test2)); assertEquals(true, test2.equals(test1)); assertEquals(true, test1.equals(test1)); assertEquals(true, test2.equals(test2)); assertEquals(true, test1.hashCode() == test2.hashCode()); assertEquals(true, test1.hashCode() == test1.hashCode()); assertEquals(true, test2.hashCode() == test2.hashCode()); YearMonth test3 = new YearMonth(1971, 6); assertEquals(false, test1.equals(test3)); assertEquals(false, test2.equals(test3)); assertEquals(false, test3.equals(test1)); assertEquals(false, test3.equals(test2)); assertEquals(false, test1.hashCode() == test3.hashCode()); assertEquals(false, test2.hashCode() == test3.hashCode()); assertEquals(false, test1.equals("Hello")); assertEquals(true, test1.equals(new MockYM())); assertEquals(false, test1.equals(MockPartial.EMPTY_INSTANCE)); } class MockYM extends MockPartial { public Chronology getChronology() { return COPTIC_UTC; } public DateTimeField[] getFields() { return new DateTimeField[] { COPTIC_UTC.year(), COPTIC_UTC.monthOfYear(), }; } public int[] getValues() { return new int[] {1970, 6}; } } //----------------------------------------------------------------------- public void testCompareTo() { YearMonth test1 = new YearMonth(2005, 6); YearMonth test1a = new YearMonth(2005, 6); assertEquals(0, test1.compareTo(test1a)); assertEquals(0, test1a.compareTo(test1)); assertEquals(0, test1.compareTo(test1)); assertEquals(0, test1a.compareTo(test1a)); YearMonth test2 = new YearMonth(2005, 7); assertEquals(-1, test1.compareTo(test2)); assertEquals(+1, test2.compareTo(test1)); YearMonth test3 = new YearMonth(2005, 7, GregorianChronology.getInstanceUTC()); assertEquals(-1, test1.compareTo(test3)); assertEquals(+1, test3.compareTo(test1)); assertEquals(0, test3.compareTo(test2)); DateTimeFieldType[] types = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), }; int[] values = new int[] {2005, 6}; Partial p = new Partial(types, values); assertEquals(0, test1.compareTo(p)); try { test1.compareTo(null); fail(); } catch (NullPointerException ex) {} try { test1.compareTo(new LocalTime()); fail(); } catch (ClassCastException ex) {} Partial partial = new Partial() .with(DateTimeFieldType.centuryOfEra(), 1) .with(DateTimeFieldType.halfdayOfDay(), 0) .with(DateTimeFieldType.dayOfMonth(), 9); try { new YearMonth(1970, 6).compareTo(partial); fail(); } catch (ClassCastException ex) {} } //----------------------------------------------------------------------- public void testIsEqual_YM() { YearMonth test1 = new YearMonth(2005, 6); YearMonth test1a = new YearMonth(2005, 6); assertEquals(true, test1.isEqual(test1a)); assertEquals(true, test1a.isEqual(test1)); assertEquals(true, test1.isEqual(test1)); assertEquals(true, test1a.isEqual(test1a)); YearMonth test2 = new YearMonth(2005, 7); assertEquals(false, test1.isEqual(test2)); assertEquals(false, test2.isEqual(test1)); YearMonth test3 = new YearMonth(2005, 7, GregorianChronology.getInstanceUTC()); assertEquals(false, test1.isEqual(test3)); assertEquals(false, test3.isEqual(test1)); assertEquals(true, test3.isEqual(test2)); try { new YearMonth(2005, 7).isEqual(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testIsBefore_YM() { YearMonth test1 = new YearMonth(2005, 6); YearMonth test1a = new YearMonth(2005, 6); assertEquals(false, test1.isBefore(test1a)); assertEquals(false, test1a.isBefore(test1)); assertEquals(false, test1.isBefore(test1)); assertEquals(false, test1a.isBefore(test1a)); YearMonth test2 = new YearMonth(2005, 7); assertEquals(true, test1.isBefore(test2)); assertEquals(false, test2.isBefore(test1)); YearMonth test3 = new YearMonth(2005, 7, GregorianChronology.getInstanceUTC()); assertEquals(true, test1.isBefore(test3)); assertEquals(false, test3.isBefore(test1)); assertEquals(false, test3.isBefore(test2)); try { new YearMonth(2005, 7).isBefore(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testIsAfter_YM() { YearMonth test1 = new YearMonth(2005, 6); YearMonth test1a = new YearMonth(2005, 6); assertEquals(false, test1.isAfter(test1a)); assertEquals(false, test1a.isAfter(test1)); assertEquals(false, test1.isAfter(test1)); assertEquals(false, test1a.isAfter(test1a)); YearMonth test2 = new YearMonth(2005, 7); assertEquals(false, test1.isAfter(test2)); assertEquals(true, test2.isAfter(test1)); YearMonth test3 = new YearMonth(2005, 7, GregorianChronology.getInstanceUTC()); assertEquals(false, test1.isAfter(test3)); assertEquals(true, test3.isAfter(test1)); assertEquals(false, test3.isAfter(test2)); try { new YearMonth(2005, 7).isAfter(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testWithChronologyRetainFields_Chrono() { YearMonth base = new YearMonth(2005, 6, COPTIC_PARIS); YearMonth test = base.withChronologyRetainFields(BUDDHIST_TOKYO); check(base, 2005, 6); assertEquals(COPTIC_UTC, base.getChronology()); check(test, 2005, 6); assertEquals(BUDDHIST_UTC, test.getChronology()); } public void testWithChronologyRetainFields_sameChrono() { YearMonth base = new YearMonth(2005, 6, COPTIC_PARIS); YearMonth test = base.withChronologyRetainFields(COPTIC_TOKYO); assertSame(base, test); } public void testWithChronologyRetainFields_nullChrono() { YearMonth base = new YearMonth(2005, 6, COPTIC_PARIS); YearMonth test = base.withChronologyRetainFields(null); check(base, 2005, 6); assertEquals(COPTIC_UTC, base.getChronology()); check(test, 2005, 6); assertEquals(ISO_UTC, test.getChronology()); } public void testWithChronologyRetainFields_invalidInNewChrono() { YearMonth base = new YearMonth(2005, 13, COPTIC_UTC); try { base.withChronologyRetainFields(ISO_UTC); fail(); } catch (IllegalArgumentException ex) { // expected } } //----------------------------------------------------------------------- public void testWithField() { YearMonth test = new YearMonth(2004, 6); YearMonth result = test.withField(DateTimeFieldType.year(), 2006); assertEquals(new YearMonth(2004, 6), test); assertEquals(new YearMonth(2006, 6), result); } public void testWithField_nullField() { YearMonth test = new YearMonth(2004, 6); try { test.withField(null, 6); fail(); } catch (IllegalArgumentException ex) {} } public void testWithField_unknownField() { YearMonth test = new YearMonth(2004, 6); try { test.withField(DateTimeFieldType.hourOfDay(), 6); fail(); } catch (IllegalArgumentException ex) {} } public void testWithField_same() { YearMonth test = new YearMonth(2004, 6); YearMonth result = test.withField(DateTimeFieldType.year(), 2004); assertEquals(new YearMonth(2004, 6), test); assertSame(test, result); } //----------------------------------------------------------------------- public void testWithFieldAdded() { YearMonth test = new YearMonth(2004, 6); YearMonth result = test.withFieldAdded(DurationFieldType.years(), 6); assertEquals(new YearMonth(2004, 6), test); assertEquals(new YearMonth(2010, 6), result); } public void testWithFieldAdded_nullField_zero() { YearMonth test = new YearMonth(2004, 6); try { test.withFieldAdded(null, 0); fail(); } catch (IllegalArgumentException ex) {} } public void testWithFieldAdded_nullField_nonZero() { YearMonth test = new YearMonth(2004, 6); try { test.withFieldAdded(null, 6); fail(); } catch (IllegalArgumentException ex) {} } public void testWithFieldAdded_zero() { YearMonth test = new YearMonth(2004, 6); YearMonth result = test.withFieldAdded(DurationFieldType.years(), 0); assertSame(test, result); } public void testWithFieldAdded_unknownField() { YearMonth test = new YearMonth(2004, 6); try { test.withFieldAdded(DurationFieldType.hours(), 6); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testPlus_RP() { YearMonth test = new YearMonth(2002, 5, BuddhistChronology.getInstance()); YearMonth result = test.plus(new Period(1, 2, 3, 4, 5, 6, 7, 8)); YearMonth expected = new YearMonth(2003, 7, BuddhistChronology.getInstance()); assertEquals(expected, result); result = test.plus((ReadablePeriod) null); assertSame(test, result); } public void testPlusYears_int() { YearMonth test = new YearMonth(2002, 5, BuddhistChronology.getInstance()); YearMonth result = test.plusYears(1); YearMonth expected = new YearMonth(2003, 5, BuddhistChronology.getInstance()); assertEquals(expected, result); result = test.plusYears(0); assertSame(test, result); } public void testPlusMonths_int() { YearMonth test = new YearMonth(2002, 5, BuddhistChronology.getInstance()); YearMonth result = test.plusMonths(1); YearMonth expected = new YearMonth(2002, 6, BuddhistChronology.getInstance()); assertEquals(expected, result); result = test.plusMonths(0); assertSame(test, result); } //----------------------------------------------------------------------- public void testMinus_RP() { YearMonth test = new YearMonth(2002, 5, BuddhistChronology.getInstance()); YearMonth result = test.minus(new Period(1, 1, 1, 1, 1, 1, 1, 1)); YearMonth expected = new YearMonth(2001, 4, BuddhistChronology.getInstance()); assertEquals(expected, result); result = test.minus((ReadablePeriod) null); assertSame(test, result); } public void testMinusYears_int() { YearMonth test = new YearMonth(2002, 5, BuddhistChronology.getInstance()); YearMonth result = test.minusYears(1); YearMonth expected = new YearMonth(2001, 5, BuddhistChronology.getInstance()); assertEquals(expected, result); result = test.minusYears(0); assertSame(test, result); } public void testMinusMonths_int() { YearMonth test = new YearMonth(2002, 5, BuddhistChronology.getInstance()); YearMonth result = test.minusMonths(1); YearMonth expected = new YearMonth(2002, 4, BuddhistChronology.getInstance()); assertEquals(expected, result); result = test.minusMonths(0); assertSame(test, result); } //----------------------------------------------------------------------- public void testToLocalDate() { YearMonth base = new YearMonth(2005, 6, COPTIC_UTC); LocalDate test = base.toLocalDate(9); assertEquals(new LocalDate(2005, 6, 9, COPTIC_UTC), test); try { base.toLocalDate(0); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testToDateTime_RI() { YearMonth base = new YearMonth(2005, 6, COPTIC_PARIS); DateTime dt = new DateTime(2002, 1, 3, 4, 5, 6, 7); DateTime test = base.toDateTime(dt); check(base, 2005, 6); DateTime expected = dt; expected = expected.year().setCopy(2005); expected = expected.monthOfYear().setCopy(6); assertEquals(expected, test); } public void testToDateTime_nullRI() { YearMonth base = new YearMonth(2005, 6); DateTime dt = new DateTime(2002, 1, 3, 4, 5, 6, 7); DateTimeUtils.setCurrentMillisFixed(dt.getMillis()); DateTime test = base.toDateTime((ReadableInstant) null); check(base, 2005, 6); DateTime expected = dt; expected = expected.year().setCopy(2005); expected = expected.monthOfYear().setCopy(6); assertEquals(expected, test); } //----------------------------------------------------------------------- public void testToInterval() { YearMonth base = new YearMonth(2005, 6, COPTIC_PARIS); // PARIS irrelevant Interval test = base.toInterval(); check(base, 2005, 6); DateTime start = new DateTime(2005, 6, 1, 0, 0, COPTIC_LONDON); DateTime end = new DateTime(2005, 7, 1, 0, 0, COPTIC_LONDON); Interval expected = new Interval(start, end); assertEquals(expected, test); } //----------------------------------------------------------------------- public void testToInterval_Zone() { YearMonth base = new YearMonth(2005, 6, COPTIC_PARIS); // PARIS irrelevant Interval test = base.toInterval(TOKYO); check(base, 2005, 6); DateTime start = new DateTime(2005, 6, 1, 0, 0, COPTIC_TOKYO); DateTime end = new DateTime(2005, 7, 1, 0, 0, COPTIC_TOKYO); Interval expected = new Interval(start, end); assertEquals(expected, test); } public void testToInterval_nullZone() { YearMonth base = new YearMonth(2005, 6, COPTIC_PARIS); // PARIS irrelevant Interval test = base.toInterval(null); check(base, 2005, 6); DateTime start = new DateTime(2005, 6, 1, 0, 0, COPTIC_LONDON); DateTime end = new DateTime(2005, 7, 1, 0, 0, COPTIC_LONDON); Interval expected = new Interval(start, end); assertEquals(expected, test); } //----------------------------------------------------------------------- public void testWithers() { YearMonth test = new YearMonth(1970, 6); check(test.withYear(2000), 2000, 6); check(test.withMonthOfYear(2), 1970, 2); try { test.withMonthOfYear(0); fail(); } catch (IllegalArgumentException ex) {} try { test.withMonthOfYear(13); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testProperty() { YearMonth test = new YearMonth(2005, 6); assertEquals(test.year(), test.property(DateTimeFieldType.year())); assertEquals(test.monthOfYear(), test.property(DateTimeFieldType.monthOfYear())); try { test.property(DateTimeFieldType.millisOfDay()); fail(); } catch (IllegalArgumentException ex) {} try { test.property(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testSerialization() throws Exception { YearMonth test = new YearMonth(1972, 6, COPTIC_PARIS); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(test); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); YearMonth result = (YearMonth) ois.readObject(); ois.close(); assertEquals(test, result); assertTrue(Arrays.equals(test.getValues(), result.getValues())); assertTrue(Arrays.equals(test.getFields(), result.getFields())); assertEquals(test.getChronology(), result.getChronology()); } //----------------------------------------------------------------------- public void testToString() { YearMonth test = new YearMonth(2002, 6); assertEquals("2002-06", test.toString()); } //----------------------------------------------------------------------- public void testToString_String() { YearMonth test = new YearMonth(2002, 6); assertEquals("2002 \ufffd\ufffd", test.toString("yyyy HH")); assertEquals("2002-06", test.toString((String) null)); } //----------------------------------------------------------------------- public void testToString_String_Locale() { YearMonth test = new YearMonth(2002, 6); assertEquals("\ufffd \ufffd/6", test.toString("EEE d/M", Locale.ENGLISH)); assertEquals("\ufffd \ufffd/6", test.toString("EEE d/M", Locale.FRENCH)); assertEquals("2002-06", test.toString(null, Locale.ENGLISH)); assertEquals("\ufffd \ufffd/6", test.toString("EEE d/M", null)); assertEquals("2002-06", test.toString(null, null)); } //----------------------------------------------------------------------- public void testToString_DTFormatter() { YearMonth test = new YearMonth(2002, 6); assertEquals("2002 \ufffd\ufffd", test.toString(DateTimeFormat.forPattern("yyyy HH"))); assertEquals("2002-06", test.toString((DateTimeFormatter) null)); } //----------------------------------------------------------------------- private void check(YearMonth test, int year, int month) { assertEquals(year, test.getYear()); assertEquals(month, test.getMonthOfYear()); } }
/* * Copyright 2001-2009 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.GregorianChronology; import org.joda.time.chrono.ISOChronology; import org.joda.time.format.DateTimeFormat; import org.joda.time.format.DateTimeFormatter; /** * This class is a Junit unit test for YearMonth. * * @author Stephen Colebourne */ public class TestYearMonth_Constructors extends TestCase { private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC(); private static final Chronology GREGORIAN_UTC = GregorianChronology.getInstanceUTC(); private static final Chronology GREGORIAN_PARIS = GregorianChronology.getInstance(PARIS); private long TEST_TIME_NOW = (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; private long TEST_TIME1 = (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; private long TEST_TIME2 = (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone zone = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestYearMonth_Constructors.class); } public TestYearMonth_Constructors(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); zone = DateTimeZone.getDefault(); DateTimeZone.setDefault(LONDON); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(zone); zone = null; } //----------------------------------------------------------------------- public void testParse_noFormatter() throws Throwable { assertEquals(new YearMonth(2010, 6), YearMonth.parse("2010-06-30")); assertEquals(new YearMonth(2010, 1), YearMonth.parse("2010-002")); } public void testParse_formatter() throws Throwable { DateTimeFormatter f = DateTimeFormat.forPattern("yyyy--MM").withChronology(ISOChronology.getInstance(PARIS)); assertEquals(new YearMonth(2010, 6), YearMonth.parse("2010--06", f)); } //----------------------------------------------------------------------- public void testFactory_FromCalendarFields() throws Exception { GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6); cal.set(Calendar.MILLISECOND, 7); YearMonth expected = new YearMonth(1970, 2); assertEquals(expected, YearMonth.fromCalendarFields(cal)); try { YearMonth.fromCalendarFields(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testFactory_FromDateFields() throws Exception { GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6); cal.set(Calendar.MILLISECOND, 7); YearMonth expected = new YearMonth(1970, 2); assertEquals(expected, YearMonth.fromDateFields(cal.getTime())); try { YearMonth.fromDateFields(null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- /** * Test constructor () */ public void testConstructor() throws Throwable { YearMonth test = new YearMonth(); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(test, YearMonth.now()); } /** * Test constructor (DateTimeZone) */ public void testConstructor_DateTimeZone() throws Throwable { DateTime dt = new DateTime(2005, 6, 30, 23, 59, 0, 0, LONDON); DateTimeUtils.setCurrentMillisFixed(dt.getMillis()); // 23:59 in London is 00:59 the following day in Paris YearMonth test = new YearMonth(LONDON); assertEquals(ISO_UTC, test.getChronology()); assertEquals(2005, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(test, YearMonth.now(LONDON)); test = new YearMonth(PARIS); assertEquals(ISO_UTC, test.getChronology()); assertEquals(2005, test.getYear()); assertEquals(7, test.getMonthOfYear()); assertEquals(test, YearMonth.now(PARIS)); } /** * Test constructor (DateTimeZone=null) */ public void testConstructor_nullDateTimeZone() throws Throwable { DateTime dt = new DateTime(2005, 6, 30, 23, 59, 0, 0, LONDON); DateTimeUtils.setCurrentMillisFixed(dt.getMillis()); // 23:59 in London is 00:59 the following day in Paris YearMonth test = new YearMonth((DateTimeZone) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(2005, test.getYear()); assertEquals(6, test.getMonthOfYear()); } /** * Test constructor (Chronology) */ public void testConstructor_Chronology() throws Throwable { YearMonth test = new YearMonth(GREGORIAN_PARIS); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(test, YearMonth.now(GREGORIAN_PARIS)); } /** * Test constructor (Chronology=null) */ public void testConstructor_nullChronology() throws Throwable { YearMonth test = new YearMonth((Chronology) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); } //----------------------------------------------------------------------- /** * Test constructor (long) */ public void testConstructor_long1() throws Throwable { YearMonth test = new YearMonth(TEST_TIME1); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); } /** * Test constructor (long) */ public void testConstructor_long2() throws Throwable { YearMonth test = new YearMonth(TEST_TIME2); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1971, test.getYear()); assertEquals(5, test.getMonthOfYear()); } /** * Test constructor (long, Chronology) */ public void testConstructor_long1_Chronology() throws Throwable { YearMonth test = new YearMonth(TEST_TIME1, GREGORIAN_PARIS); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); } /** * Test constructor (long, Chronology) */ public void testConstructor_long2_Chronology() throws Throwable { YearMonth test = new YearMonth(TEST_TIME2, GREGORIAN_PARIS); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(1971, test.getYear()); assertEquals(5, test.getMonthOfYear()); } /** * Test constructor (long, Chronology=null) */ public void testConstructor_long_nullChronology() throws Throwable { YearMonth test = new YearMonth(TEST_TIME1, null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); } //----------------------------------------------------------------------- public void testConstructor_Object() throws Throwable { Date date = new Date(TEST_TIME1); YearMonth test = new YearMonth(date); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); } public void testConstructor_nullObject() throws Throwable { YearMonth test = new YearMonth((Object) null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); } public void testConstructor_ObjectString1() throws Throwable { YearMonth test = new YearMonth("1972-12"); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1972, test.getYear()); assertEquals(12, test.getMonthOfYear()); } public void testConstructor_ObjectString5() throws Throwable { YearMonth test = new YearMonth("10"); assertEquals(ISO_UTC, test.getChronology()); assertEquals(10, test.getYear()); assertEquals(1, test.getMonthOfYear()); } public void testConstructor_ObjectStringEx1() throws Throwable { try { new YearMonth("T10:20:30.040"); fail(); } catch (IllegalArgumentException ex) { // expected } } public void testConstructor_ObjectStringEx2() throws Throwable { try { new YearMonth("T10:20:30.040+14:00"); fail(); } catch (IllegalArgumentException ex) { // expected } } public void testConstructor_ObjectStringEx3() throws Throwable { try { new YearMonth("10:20:30.040"); fail(); } catch (IllegalArgumentException ex) { // expected } } public void testConstructor_ObjectStringEx4() throws Throwable { try { new YearMonth("10:20:30.040+14:00"); fail(); } catch (IllegalArgumentException ex) { // expected } } //----------------------------------------------------------------------- /** * Test constructor (Object, Chronology) */ public void testConstructor_Object_Chronology() throws Throwable { Date date = new Date(TEST_TIME1); YearMonth test = new YearMonth(date, GREGORIAN_PARIS); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); } /** * Test constructor (Object=null, Chronology) */ public void testConstructor_nullObject_Chronology() throws Throwable { YearMonth test = new YearMonth((Object) null, GREGORIAN_PARIS); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); } /** * Test constructor (Object, Chronology=null) */ public void testConstructor_Object_nullChronology() throws Throwable { Date date = new Date(TEST_TIME1); YearMonth test = new YearMonth(date, null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); } /** * Test constructor (Object=null, Chronology=null) */ public void testConstructor_nullObject_nullChronology() throws Throwable { YearMonth test = new YearMonth((Object) null, null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); } //----------------------------------------------------------------------- /** * Test constructor (int, int) */ public void testConstructor_int_int() throws Throwable { YearMonth test = new YearMonth(1970, 6); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); try { new YearMonth(Integer.MIN_VALUE, 6); fail(); } catch (IllegalArgumentException ex) {} try { new YearMonth(Integer.MAX_VALUE, 6); fail(); } catch (IllegalArgumentException ex) {} try { new YearMonth(1970, 0); fail(); } catch (IllegalArgumentException ex) {} try { new YearMonth(1970, 13); fail(); } catch (IllegalArgumentException ex) {} } /** * Test constructor (int, int, Chronology) */ public void testConstructor_int_int_Chronology() throws Throwable { YearMonth test = new YearMonth(1970, 6, GREGORIAN_PARIS); assertEquals(GREGORIAN_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); try { new YearMonth(Integer.MIN_VALUE, 6, GREGORIAN_PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new YearMonth(Integer.MAX_VALUE, 6, GREGORIAN_PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new YearMonth(1970, 0, GREGORIAN_PARIS); fail(); } catch (IllegalArgumentException ex) {} try { new YearMonth(1970, 13, GREGORIAN_PARIS); fail(); } catch (IllegalArgumentException ex) {} } /** * Test constructor (int, int, Chronology=null) */ public void testConstructor_int_int_nullChronology() throws Throwable { YearMonth test = new YearMonth(1970, 6, null); assertEquals(ISO_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(6, test.getMonthOfYear()); } }
/* * Copyright 2001-2010 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.util.Locale; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.chrono.CopticChronology; import org.joda.time.chrono.LenientChronology; import org.joda.time.chrono.StrictChronology; /** * This class is a Junit unit test for YearMonth. * * @author Stephen Colebourne */ public class TestYearMonth_Properties extends TestCase { private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS); private long TEST_TIME_NOW = (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; private long TEST_TIME1 = (31L + 28L + 31L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY + 12L * DateTimeConstants.MILLIS_PER_HOUR + 24L * DateTimeConstants.MILLIS_PER_MINUTE; private long TEST_TIME2 = (365L + 31L + 28L + 31L + 30L + 7L -1L) * DateTimeConstants.MILLIS_PER_DAY + 14L * DateTimeConstants.MILLIS_PER_HOUR + 28L * DateTimeConstants.MILLIS_PER_MINUTE; private DateTimeZone zone = null; private Locale systemDefaultLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestYearMonth_Properties.class); } public TestYearMonth_Properties(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); zone = DateTimeZone.getDefault(); DateTimeZone.setDefault(DateTimeZone.UTC); systemDefaultLocale = Locale.getDefault(); Locale.setDefault(Locale.ENGLISH); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(zone); zone = null; Locale.setDefault(systemDefaultLocale); systemDefaultLocale = null; } //----------------------------------------------------------------------- public void testPropertyGetYear() { YearMonth test = new YearMonth(1972, 6); assertSame(test.getChronology().year(), test.year().getField()); assertEquals("year", test.year().getName()); assertEquals("Property[year]", test.year().toString()); assertSame(test, test.year().getReadablePartial()); assertSame(test, test.year().getYearMonth()); assertEquals(1972, test.year().get()); assertEquals("1972", test.year().getAsString()); assertEquals("1972", test.year().getAsText()); assertEquals("1972", test.year().getAsText(Locale.FRENCH)); assertEquals("1972", test.year().getAsShortText()); assertEquals("1972", test.year().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().years(), test.year().getDurationField()); assertEquals(null, test.year().getRangeDurationField()); assertEquals(9, test.year().getMaximumTextLength(null)); assertEquals(9, test.year().getMaximumShortTextLength(null)); } public void testPropertyGetMaxMinValuesYear() { YearMonth test = new YearMonth(1972, 6); assertEquals(-292275054, test.year().getMinimumValue()); assertEquals(-292275054, test.year().getMinimumValueOverall()); assertEquals(292278993, test.year().getMaximumValue()); assertEquals(292278993, test.year().getMaximumValueOverall()); } public void testPropertyAddYear() { YearMonth test = new YearMonth(1972, 6); YearMonth copy = test.year().addToCopy(9); check(test, 1972, 6); check(copy, 1981, 6); copy = test.year().addToCopy(0); check(copy, 1972, 6); copy = test.year().addToCopy(292277023 - 1972); check(copy, 292277023, 6); try { test.year().addToCopy(292278993 - 1972 + 1); fail(); } catch (IllegalArgumentException ex) {} check(test, 1972, 6); copy = test.year().addToCopy(-1972); check(copy, 0, 6); copy = test.year().addToCopy(-1973); check(copy, -1, 6); try { test.year().addToCopy(-292275054 - 1972 - 1); fail(); } catch (IllegalArgumentException ex) {} check(test, 1972, 6); } public void testPropertyAddWrapFieldYear() { YearMonth test = new YearMonth(1972, 6); YearMonth copy = test.year().addWrapFieldToCopy(9); check(test, 1972, 6); check(copy, 1981, 6); copy = test.year().addWrapFieldToCopy(0); check(copy, 1972, 6); copy = test.year().addWrapFieldToCopy(292278993 - 1972 + 1); check(copy, -292275054, 6); copy = test.year().addWrapFieldToCopy(-292275054 - 1972 - 1); check(copy, 292278993, 6); } public void testPropertySetYear() { YearMonth test = new YearMonth(1972, 6); YearMonth copy = test.year().setCopy(12); check(test, 1972, 6); check(copy, 12, 6); } public void testPropertySetTextYear() { YearMonth test = new YearMonth(1972, 6); YearMonth copy = test.year().setCopy("12"); check(test, 1972, 6); check(copy, 12, 6); } public void testPropertyCompareToYear() { YearMonth test1 = new YearMonth(TEST_TIME1); YearMonth test2 = new YearMonth(TEST_TIME2); assertEquals(true, test1.year().compareTo(test2) < 0); assertEquals(true, test2.year().compareTo(test1) > 0); assertEquals(true, test1.year().compareTo(test1) == 0); try { test1.year().compareTo((ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} DateTime dt1 = new DateTime(TEST_TIME1); DateTime dt2 = new DateTime(TEST_TIME2); assertEquals(true, test1.year().compareTo(dt2) < 0); assertEquals(true, test2.year().compareTo(dt1) > 0); assertEquals(true, test1.year().compareTo(dt1) == 0); try { test1.year().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testPropertyGetMonth() { YearMonth test = new YearMonth(1972, 6); assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField()); assertEquals("monthOfYear", test.monthOfYear().getName()); assertEquals("Property[monthOfYear]", test.monthOfYear().toString()); assertSame(test, test.monthOfYear().getReadablePartial()); assertSame(test, test.monthOfYear().getYearMonth()); assertEquals(6, test.monthOfYear().get()); assertEquals("6", test.monthOfYear().getAsString()); assertEquals("June", test.monthOfYear().getAsText()); assertEquals("juin", test.monthOfYear().getAsText(Locale.FRENCH)); assertEquals("Jun", test.monthOfYear().getAsShortText()); assertEquals("juin", test.monthOfYear().getAsShortText(Locale.FRENCH)); assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField()); assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField()); assertEquals(9, test.monthOfYear().getMaximumTextLength(null)); assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null)); test = new YearMonth(1972, 7); assertEquals("juillet", test.monthOfYear().getAsText(Locale.FRENCH)); assertEquals("juil.", test.monthOfYear().getAsShortText(Locale.FRENCH)); } public void testPropertyGetMaxMinValuesMonth() { YearMonth test = new YearMonth(1972, 6); assertEquals(1, test.monthOfYear().getMinimumValue()); assertEquals(1, test.monthOfYear().getMinimumValueOverall()); assertEquals(12, test.monthOfYear().getMaximumValue()); assertEquals(12, test.monthOfYear().getMaximumValueOverall()); } public void testPropertyAddMonth() { YearMonth test = new YearMonth(1972, 6); YearMonth copy = test.monthOfYear().addToCopy(6); check(test, 1972, 6); check(copy, 1972, 12); copy = test.monthOfYear().addToCopy(7); check(copy, 1973, 1); copy = test.monthOfYear().addToCopy(-5); check(copy, 1972, 1); copy = test.monthOfYear().addToCopy(-6); check(copy, 1971, 12); } public void testPropertyAddWrapFieldMonth() { YearMonth test = new YearMonth(1972, 6); YearMonth copy = test.monthOfYear().addWrapFieldToCopy(4); check(test, 1972, 6); check(copy, 1972, 10); copy = test.monthOfYear().addWrapFieldToCopy(8); check(copy, 1972, 2); copy = test.monthOfYear().addWrapFieldToCopy(-8); check(copy, 1972, 10); } public void testPropertySetMonth() { YearMonth test = new YearMonth(1972, 6); YearMonth copy = test.monthOfYear().setCopy(12); check(test, 1972, 6); check(copy, 1972, 12); try { test.monthOfYear().setCopy(13); fail(); } catch (IllegalArgumentException ex) {} try { test.monthOfYear().setCopy(0); fail(); } catch (IllegalArgumentException ex) {} } public void testPropertySetTextMonth() { YearMonth test = new YearMonth(1972, 6); YearMonth copy = test.monthOfYear().setCopy("12"); check(test, 1972, 6); check(copy, 1972, 12); copy = test.monthOfYear().setCopy("December"); check(test, 1972, 6); check(copy, 1972, 12); copy = test.monthOfYear().setCopy("Dec"); check(test, 1972, 6); check(copy, 1972, 12); } public void testPropertyCompareToMonth() { YearMonth test1 = new YearMonth(TEST_TIME1); YearMonth test2 = new YearMonth(TEST_TIME2); assertEquals(true, test1.monthOfYear().compareTo(test2) < 0); assertEquals(true, test2.monthOfYear().compareTo(test1) > 0); assertEquals(true, test1.monthOfYear().compareTo(test1) == 0); try { test1.monthOfYear().compareTo((ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} DateTime dt1 = new DateTime(TEST_TIME1); DateTime dt2 = new DateTime(TEST_TIME2); assertEquals(true, test1.monthOfYear().compareTo(dt2) < 0); assertEquals(true, test2.monthOfYear().compareTo(dt1) > 0); assertEquals(true, test1.monthOfYear().compareTo(dt1) == 0); try { test1.monthOfYear().compareTo((ReadableInstant) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testPropertyEquals() { YearMonth test1 = new YearMonth(11, 11); YearMonth test2 = new YearMonth(11, 12); YearMonth test3 = new YearMonth(11, 11, CopticChronology.getInstanceUTC()); assertEquals(true, test1.monthOfYear().equals(test1.monthOfYear())); assertEquals(false, test1.monthOfYear().equals(test1.year())); assertEquals(false, test1.monthOfYear().equals(test2.monthOfYear())); assertEquals(false, test1.monthOfYear().equals(test2.year())); assertEquals(false, test1.year().equals(test1.monthOfYear())); assertEquals(true, test1.year().equals(test1.year())); assertEquals(false, test1.year().equals(test2.monthOfYear())); assertEquals(true, test1.year().equals(test2.year())); assertEquals(false, test1.monthOfYear().equals(null)); assertEquals(false, test1.monthOfYear().equals("any")); // chrono assertEquals(false, test1.monthOfYear().equals(test3.monthOfYear())); } public void testPropertyHashCode() { YearMonth test1 = new YearMonth(2005, 11); YearMonth test2 = new YearMonth(2005, 12); assertEquals(true, test1.monthOfYear().hashCode() == test1.monthOfYear().hashCode()); assertEquals(false, test1.monthOfYear().hashCode() == test2.monthOfYear().hashCode()); assertEquals(true, test1.year().hashCode() == test1.year().hashCode()); assertEquals(true, test1.year().hashCode() == test2.year().hashCode()); } public void testPropertyEqualsHashCodeLenient() { YearMonth test1 = new YearMonth(1970, 6, LenientChronology.getInstance(COPTIC_PARIS)); YearMonth test2 = new YearMonth(1970, 6, LenientChronology.getInstance(COPTIC_PARIS)); assertEquals(true, test1.monthOfYear().equals(test2.monthOfYear())); assertEquals(true, test2.monthOfYear().equals(test1.monthOfYear())); assertEquals(true, test1.monthOfYear().equals(test1.monthOfYear())); assertEquals(true, test2.monthOfYear().equals(test2.monthOfYear())); assertEquals(true, test1.monthOfYear().hashCode() == test2.monthOfYear().hashCode()); assertEquals(true, test1.monthOfYear().hashCode() == test1.monthOfYear().hashCode()); assertEquals(true, test2.monthOfYear().hashCode() == test2.monthOfYear().hashCode()); } public void testPropertyEqualsHashCodeStrict() { YearMonth test1 = new YearMonth(1970, 6, StrictChronology.getInstance(COPTIC_PARIS)); YearMonth test2 = new YearMonth(1970, 6, StrictChronology.getInstance(COPTIC_PARIS)); assertEquals(true, test1.monthOfYear().equals(test2.monthOfYear())); assertEquals(true, test2.monthOfYear().equals(test1.monthOfYear())); assertEquals(true, test1.monthOfYear().equals(test1.monthOfYear())); assertEquals(true, test2.monthOfYear().equals(test2.monthOfYear())); assertEquals(true, test1.monthOfYear().hashCode() == test2.monthOfYear().hashCode()); assertEquals(true, test1.monthOfYear().hashCode() == test1.monthOfYear().hashCode()); assertEquals(true, test2.monthOfYear().hashCode() == test2.monthOfYear().hashCode()); } //----------------------------------------------------------------------- private void check(YearMonth test, int year, int month) { assertEquals(year, test.getYear()); assertEquals(month, test.getMonthOfYear()); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import junit.framework.TestCase; import junit.framework.TestSuite; /** * This class is a Junit unit test for Years. * * @author Stephen Colebourne */ public class TestYears extends TestCase { // Test in 2002/03 as time zones are more well known // (before the late 90's they were all over the place) private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestYears.class); } public TestYears(String name) { super(name); } protected void setUp() throws Exception { } protected void tearDown() throws Exception { } //----------------------------------------------------------------------- public void testConstants() { assertEquals(0, Years.ZERO.getYears()); assertEquals(1, Years.ONE.getYears()); assertEquals(2, Years.TWO.getYears()); assertEquals(3, Years.THREE.getYears()); assertEquals(Integer.MAX_VALUE, Years.MAX_VALUE.getYears()); assertEquals(Integer.MIN_VALUE, Years.MIN_VALUE.getYears()); } //----------------------------------------------------------------------- public void testFactory_years_int() { assertSame(Years.ZERO, Years.years(0)); assertSame(Years.ONE, Years.years(1)); assertSame(Years.TWO, Years.years(2)); assertSame(Years.THREE, Years.years(3)); assertSame(Years.MAX_VALUE, Years.years(Integer.MAX_VALUE)); assertSame(Years.MIN_VALUE, Years.years(Integer.MIN_VALUE)); assertEquals(-1, Years.years(-1).getYears()); assertEquals(4, Years.years(4).getYears()); } //----------------------------------------------------------------------- public void testFactory_yearsBetween_RInstant() { DateTime start = new DateTime(2006, 6, 9, 12, 0, 0, 0, PARIS); DateTime end1 = new DateTime(2009, 6, 9, 12, 0, 0, 0, PARIS); DateTime end2 = new DateTime(2012, 6, 9, 12, 0, 0, 0, PARIS); assertEquals(3, Years.yearsBetween(start, end1).getYears()); assertEquals(0, Years.yearsBetween(start, start).getYears()); assertEquals(0, Years.yearsBetween(end1, end1).getYears()); assertEquals(-3, Years.yearsBetween(end1, start).getYears()); assertEquals(6, Years.yearsBetween(start, end2).getYears()); } @SuppressWarnings("deprecation") public void testFactory_yearsBetween_RPartial() { LocalDate start = new LocalDate(2006, 6, 9); LocalDate end1 = new LocalDate(2009, 6, 9); YearMonthDay end2 = new YearMonthDay(2012, 6, 9); assertEquals(3, Years.yearsBetween(start, end1).getYears()); assertEquals(0, Years.yearsBetween(start, start).getYears()); assertEquals(0, Years.yearsBetween(end1, end1).getYears()); assertEquals(-3, Years.yearsBetween(end1, start).getYears()); assertEquals(6, Years.yearsBetween(start, end2).getYears()); } public void testFactory_yearsIn_RInterval() { DateTime start = new DateTime(2006, 6, 9, 12, 0, 0, 0, PARIS); DateTime end1 = new DateTime(2009, 6, 9, 12, 0, 0, 0, PARIS); DateTime end2 = new DateTime(2012, 6, 9, 12, 0, 0, 0, PARIS); assertEquals(0, Years.yearsIn((ReadableInterval) null).getYears()); assertEquals(3, Years.yearsIn(new Interval(start, end1)).getYears()); assertEquals(0, Years.yearsIn(new Interval(start, start)).getYears()); assertEquals(0, Years.yearsIn(new Interval(end1, end1)).getYears()); assertEquals(6, Years.yearsIn(new Interval(start, end2)).getYears()); } public void testFactory_parseYears_String() { assertEquals(0, Years.parseYears((String) null).getYears()); assertEquals(0, Years.parseYears("P0Y").getYears()); assertEquals(1, Years.parseYears("P1Y").getYears()); assertEquals(-3, Years.parseYears("P-3Y").getYears()); assertEquals(2, Years.parseYears("P2Y0M").getYears()); assertEquals(2, Years.parseYears("P2YT0H0M").getYears()); try { Years.parseYears("P1M1D"); fail(); } catch (IllegalArgumentException ex) { // expeceted } try { Years.parseYears("P1YT1H"); fail(); } catch (IllegalArgumentException ex) { // expeceted } } //----------------------------------------------------------------------- public void testGetMethods() { Years test = Years.years(20); assertEquals(20, test.getYears()); } public void testGetFieldType() { Years test = Years.years(20); assertEquals(DurationFieldType.years(), test.getFieldType()); } public void testGetPeriodType() { Years test = Years.years(20); assertEquals(PeriodType.years(), test.getPeriodType()); } //----------------------------------------------------------------------- public void testIsGreaterThan() { assertEquals(true, Years.THREE.isGreaterThan(Years.TWO)); assertEquals(false, Years.THREE.isGreaterThan(Years.THREE)); assertEquals(false, Years.TWO.isGreaterThan(Years.THREE)); assertEquals(true, Years.ONE.isGreaterThan(null)); assertEquals(false, Years.years(-1).isGreaterThan(null)); } public void testIsLessThan() { assertEquals(false, Years.THREE.isLessThan(Years.TWO)); assertEquals(false, Years.THREE.isLessThan(Years.THREE)); assertEquals(true, Years.TWO.isLessThan(Years.THREE)); assertEquals(false, Years.ONE.isLessThan(null)); assertEquals(true, Years.years(-1).isLessThan(null)); } //----------------------------------------------------------------------- public void testToString() { Years test = Years.years(20); assertEquals("P20Y", test.toString()); test = Years.years(-20); assertEquals("P-20Y", test.toString()); } //----------------------------------------------------------------------- public void testSerialization() throws Exception { Years test = Years.THREE; ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(test); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); Years result = (Years) ois.readObject(); ois.close(); assertSame(test, result); } //----------------------------------------------------------------------- public void testPlus_int() { Years test2 = Years.years(2); Years result = test2.plus(3); assertEquals(2, test2.getYears()); assertEquals(5, result.getYears()); assertEquals(1, Years.ONE.plus(0).getYears()); try { Years.MAX_VALUE.plus(1); fail(); } catch (ArithmeticException ex) { // expected } } public void testPlus_Years() { Years test2 = Years.years(2); Years test3 = Years.years(3); Years result = test2.plus(test3); assertEquals(2, test2.getYears()); assertEquals(3, test3.getYears()); assertEquals(5, result.getYears()); assertEquals(1, Years.ONE.plus(Years.ZERO).getYears()); assertEquals(1, Years.ONE.plus((Years) null).getYears()); try { Years.MAX_VALUE.plus(Years.ONE); fail(); } catch (ArithmeticException ex) { // expected } } public void testMinus_int() { Years test2 = Years.years(2); Years result = test2.minus(3); assertEquals(2, test2.getYears()); assertEquals(-1, result.getYears()); assertEquals(1, Years.ONE.minus(0).getYears()); try { Years.MIN_VALUE.minus(1); fail(); } catch (ArithmeticException ex) { // expected } } public void testMinus_Years() { Years test2 = Years.years(2); Years test3 = Years.years(3); Years result = test2.minus(test3); assertEquals(2, test2.getYears()); assertEquals(3, test3.getYears()); assertEquals(-1, result.getYears()); assertEquals(1, Years.ONE.minus(Years.ZERO).getYears()); assertEquals(1, Years.ONE.minus((Years) null).getYears()); try { Years.MIN_VALUE.minus(Years.ONE); fail(); } catch (ArithmeticException ex) { // expected } } public void testMultipliedBy_int() { Years test = Years.years(2); assertEquals(6, test.multipliedBy(3).getYears()); assertEquals(2, test.getYears()); assertEquals(-6, test.multipliedBy(-3).getYears()); assertSame(test, test.multipliedBy(1)); Years halfMax = Years.years(Integer.MAX_VALUE / 2 + 1); try { halfMax.multipliedBy(2); fail(); } catch (ArithmeticException ex) { // expected } } public void testDividedBy_int() { Years test = Years.years(12); assertEquals(6, test.dividedBy(2).getYears()); assertEquals(12, test.getYears()); assertEquals(4, test.dividedBy(3).getYears()); assertEquals(3, test.dividedBy(4).getYears()); assertEquals(2, test.dividedBy(5).getYears()); assertEquals(2, test.dividedBy(6).getYears()); assertSame(test, test.dividedBy(1)); try { Years.ONE.dividedBy(0); fail(); } catch (ArithmeticException ex) { // expected } } public void testNegated() { Years test = Years.years(12); assertEquals(-12, test.negated().getYears()); assertEquals(12, test.getYears()); try { Years.MIN_VALUE.negated(); fail(); } catch (ArithmeticException ex) { // expected } } //----------------------------------------------------------------------- public void testAddToLocalDate() { Years test = Years.years(3); LocalDate date = new LocalDate(2006, 6, 1); LocalDate expected = new LocalDate(2009, 6, 1); assertEquals(expected, date.plus(test)); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.chrono; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.Chronology; import org.joda.time.DateTime; import org.joda.time.DateTimeConstants; import org.joda.time.DateTimeField; import org.joda.time.DateTimeUtils; import org.joda.time.DateTimeZone; import org.joda.time.Period; /** * This class is a Junit unit test for BuddhistChronology. * * @author Stephen Colebourne */ public class TestBuddhistChronology extends TestCase { private static int SKIP = 1 * DateTimeConstants.MILLIS_PER_DAY; private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo"); private static final Chronology BUDDHIST_UTC = BuddhistChronology.getInstanceUTC(); private static final Chronology JULIAN_UTC = JulianChronology.getInstanceUTC(); private static final Chronology GJ_UTC = GJChronology.getInstanceUTC(); private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC(); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { SKIP = 1 * DateTimeConstants.MILLIS_PER_DAY; junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestBuddhistChronology.class); } public TestBuddhistChronology(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testFactoryUTC() { assertEquals(DateTimeZone.UTC, BuddhistChronology.getInstanceUTC().getZone()); assertSame(BuddhistChronology.class, BuddhistChronology.getInstanceUTC().getClass()); } public void testFactory() { assertEquals(LONDON, BuddhistChronology.getInstance().getZone()); assertSame(BuddhistChronology.class, BuddhistChronology.getInstance().getClass()); } public void testFactory_Zone() { assertEquals(TOKYO, BuddhistChronology.getInstance(TOKYO).getZone()); assertEquals(PARIS, BuddhistChronology.getInstance(PARIS).getZone()); assertEquals(LONDON, BuddhistChronology.getInstance(null).getZone()); assertSame(BuddhistChronology.class, BuddhistChronology.getInstance(TOKYO).getClass()); } //----------------------------------------------------------------------- public void testEquality() { assertSame(BuddhistChronology.getInstance(TOKYO), BuddhistChronology.getInstance(TOKYO)); assertSame(BuddhistChronology.getInstance(LONDON), BuddhistChronology.getInstance(LONDON)); assertSame(BuddhistChronology.getInstance(PARIS), BuddhistChronology.getInstance(PARIS)); assertSame(BuddhistChronology.getInstanceUTC(), BuddhistChronology.getInstanceUTC()); assertSame(BuddhistChronology.getInstance(), BuddhistChronology.getInstance(LONDON)); } public void testWithUTC() { assertSame(BuddhistChronology.getInstanceUTC(), BuddhistChronology.getInstance(LONDON).withUTC()); assertSame(BuddhistChronology.getInstanceUTC(), BuddhistChronology.getInstance(TOKYO).withUTC()); assertSame(BuddhistChronology.getInstanceUTC(), BuddhistChronology.getInstanceUTC().withUTC()); assertSame(BuddhistChronology.getInstanceUTC(), BuddhistChronology.getInstance().withUTC()); } public void testWithZone() { assertSame(BuddhistChronology.getInstance(TOKYO), BuddhistChronology.getInstance(TOKYO).withZone(TOKYO)); assertSame(BuddhistChronology.getInstance(LONDON), BuddhistChronology.getInstance(TOKYO).withZone(LONDON)); assertSame(BuddhistChronology.getInstance(PARIS), BuddhistChronology.getInstance(TOKYO).withZone(PARIS)); assertSame(BuddhistChronology.getInstance(LONDON), BuddhistChronology.getInstance(TOKYO).withZone(null)); assertSame(BuddhistChronology.getInstance(PARIS), BuddhistChronology.getInstance().withZone(PARIS)); assertSame(BuddhistChronology.getInstance(PARIS), BuddhistChronology.getInstanceUTC().withZone(PARIS)); } public void testToString() { assertEquals("BuddhistChronology[Europe/London]", BuddhistChronology.getInstance(LONDON).toString()); assertEquals("BuddhistChronology[Asia/Tokyo]", BuddhistChronology.getInstance(TOKYO).toString()); assertEquals("BuddhistChronology[Europe/London]", BuddhistChronology.getInstance().toString()); assertEquals("BuddhistChronology[UTC]", BuddhistChronology.getInstanceUTC().toString()); } //----------------------------------------------------------------------- public void testDurationFields() { final BuddhistChronology buddhist = BuddhistChronology.getInstance(); assertEquals("eras", buddhist.eras().getName()); assertEquals("centuries", buddhist.centuries().getName()); assertEquals("years", buddhist.years().getName()); assertEquals("weekyears", buddhist.weekyears().getName()); assertEquals("months", buddhist.months().getName()); assertEquals("weeks", buddhist.weeks().getName()); assertEquals("days", buddhist.days().getName()); assertEquals("halfdays", GregorianChronology.getInstance().halfdays().getName()); assertEquals("hours", buddhist.hours().getName()); assertEquals("minutes", buddhist.minutes().getName()); assertEquals("seconds", buddhist.seconds().getName()); assertEquals("millis", buddhist.millis().getName()); assertEquals(false, buddhist.eras().isSupported()); assertEquals(true, buddhist.centuries().isSupported()); assertEquals(true, buddhist.years().isSupported()); assertEquals(true, buddhist.weekyears().isSupported()); assertEquals(true, buddhist.months().isSupported()); assertEquals(true, buddhist.weeks().isSupported()); assertEquals(true, buddhist.days().isSupported()); assertEquals(true, buddhist.halfdays().isSupported()); assertEquals(true, buddhist.hours().isSupported()); assertEquals(true, buddhist.minutes().isSupported()); assertEquals(true, buddhist.seconds().isSupported()); assertEquals(true, buddhist.millis().isSupported()); assertEquals(false, buddhist.centuries().isPrecise()); assertEquals(false, buddhist.years().isPrecise()); assertEquals(false, buddhist.weekyears().isPrecise()); assertEquals(false, buddhist.months().isPrecise()); assertEquals(false, buddhist.weeks().isPrecise()); assertEquals(false, buddhist.days().isPrecise()); assertEquals(false, buddhist.halfdays().isPrecise()); assertEquals(true, buddhist.hours().isPrecise()); assertEquals(true, buddhist.minutes().isPrecise()); assertEquals(true, buddhist.seconds().isPrecise()); assertEquals(true, buddhist.millis().isPrecise()); final BuddhistChronology buddhistUTC = BuddhistChronology.getInstanceUTC(); assertEquals(false, buddhistUTC.centuries().isPrecise()); assertEquals(false, buddhistUTC.years().isPrecise()); assertEquals(false, buddhistUTC.weekyears().isPrecise()); assertEquals(false, buddhistUTC.months().isPrecise()); assertEquals(true, buddhistUTC.weeks().isPrecise()); assertEquals(true, buddhistUTC.days().isPrecise()); assertEquals(true, buddhistUTC.halfdays().isPrecise()); assertEquals(true, buddhistUTC.hours().isPrecise()); assertEquals(true, buddhistUTC.minutes().isPrecise()); assertEquals(true, buddhistUTC.seconds().isPrecise()); assertEquals(true, buddhistUTC.millis().isPrecise()); final DateTimeZone gmt = DateTimeZone.forID("Etc/GMT"); final BuddhistChronology buddhistGMT = BuddhistChronology.getInstance(gmt); assertEquals(false, buddhistGMT.centuries().isPrecise()); assertEquals(false, buddhistGMT.years().isPrecise()); assertEquals(false, buddhistGMT.weekyears().isPrecise()); assertEquals(false, buddhistGMT.months().isPrecise()); assertEquals(true, buddhistGMT.weeks().isPrecise()); assertEquals(true, buddhistGMT.days().isPrecise()); assertEquals(true, buddhistGMT.halfdays().isPrecise()); assertEquals(true, buddhistGMT.hours().isPrecise()); assertEquals(true, buddhistGMT.minutes().isPrecise()); assertEquals(true, buddhistGMT.seconds().isPrecise()); assertEquals(true, buddhistGMT.millis().isPrecise()); } public void testDateFields() { final BuddhistChronology buddhist = BuddhistChronology.getInstance(); assertEquals("era", buddhist.era().getName()); assertEquals("centuryOfEra", buddhist.centuryOfEra().getName()); assertEquals("yearOfCentury", buddhist.yearOfCentury().getName()); assertEquals("yearOfEra", buddhist.yearOfEra().getName()); assertEquals("year", buddhist.year().getName()); assertEquals("monthOfYear", buddhist.monthOfYear().getName()); assertEquals("weekyearOfCentury", buddhist.weekyearOfCentury().getName()); assertEquals("weekyear", buddhist.weekyear().getName()); assertEquals("weekOfWeekyear", buddhist.weekOfWeekyear().getName()); assertEquals("dayOfYear", buddhist.dayOfYear().getName()); assertEquals("dayOfMonth", buddhist.dayOfMonth().getName()); assertEquals("dayOfWeek", buddhist.dayOfWeek().getName()); assertEquals(true, buddhist.era().isSupported()); assertEquals(true, buddhist.centuryOfEra().isSupported()); assertEquals(true, buddhist.yearOfCentury().isSupported()); assertEquals(true, buddhist.yearOfEra().isSupported()); assertEquals(true, buddhist.year().isSupported()); assertEquals(true, buddhist.monthOfYear().isSupported()); assertEquals(true, buddhist.weekyearOfCentury().isSupported()); assertEquals(true, buddhist.weekyear().isSupported()); assertEquals(true, buddhist.weekOfWeekyear().isSupported()); assertEquals(true, buddhist.dayOfYear().isSupported()); assertEquals(true, buddhist.dayOfMonth().isSupported()); assertEquals(true, buddhist.dayOfWeek().isSupported()); assertEquals(buddhist.eras(), buddhist.era().getDurationField()); assertEquals(buddhist.centuries(), buddhist.centuryOfEra().getDurationField()); assertEquals(buddhist.years(), buddhist.yearOfCentury().getDurationField()); assertEquals(buddhist.years(), buddhist.yearOfEra().getDurationField()); assertEquals(buddhist.years(), buddhist.year().getDurationField()); assertEquals(buddhist.months(), buddhist.monthOfYear().getDurationField()); assertEquals(buddhist.weekyears(), buddhist.weekyearOfCentury().getDurationField()); assertEquals(buddhist.weekyears(), buddhist.weekyear().getDurationField()); assertEquals(buddhist.weeks(), buddhist.weekOfWeekyear().getDurationField()); assertEquals(buddhist.days(), buddhist.dayOfYear().getDurationField()); assertEquals(buddhist.days(), buddhist.dayOfMonth().getDurationField()); assertEquals(buddhist.days(), buddhist.dayOfWeek().getDurationField()); assertEquals(null, buddhist.era().getRangeDurationField()); assertEquals(buddhist.eras(), buddhist.centuryOfEra().getRangeDurationField()); assertEquals(buddhist.centuries(), buddhist.yearOfCentury().getRangeDurationField()); assertEquals(buddhist.eras(), buddhist.yearOfEra().getRangeDurationField()); assertEquals(null, buddhist.year().getRangeDurationField()); assertEquals(buddhist.years(), buddhist.monthOfYear().getRangeDurationField()); assertEquals(buddhist.centuries(), buddhist.weekyearOfCentury().getRangeDurationField()); assertEquals(null, buddhist.weekyear().getRangeDurationField()); assertEquals(buddhist.weekyears(), buddhist.weekOfWeekyear().getRangeDurationField()); assertEquals(buddhist.years(), buddhist.dayOfYear().getRangeDurationField()); assertEquals(buddhist.months(), buddhist.dayOfMonth().getRangeDurationField()); assertEquals(buddhist.weeks(), buddhist.dayOfWeek().getRangeDurationField()); } public void testTimeFields() { final BuddhistChronology buddhist = BuddhistChronology.getInstance(); assertEquals("halfdayOfDay", buddhist.halfdayOfDay().getName()); assertEquals("clockhourOfHalfday", buddhist.clockhourOfHalfday().getName()); assertEquals("hourOfHalfday", buddhist.hourOfHalfday().getName()); assertEquals("clockhourOfDay", buddhist.clockhourOfDay().getName()); assertEquals("hourOfDay", buddhist.hourOfDay().getName()); assertEquals("minuteOfDay", buddhist.minuteOfDay().getName()); assertEquals("minuteOfHour", buddhist.minuteOfHour().getName()); assertEquals("secondOfDay", buddhist.secondOfDay().getName()); assertEquals("secondOfMinute", buddhist.secondOfMinute().getName()); assertEquals("millisOfDay", buddhist.millisOfDay().getName()); assertEquals("millisOfSecond", buddhist.millisOfSecond().getName()); assertEquals(true, buddhist.halfdayOfDay().isSupported()); assertEquals(true, buddhist.clockhourOfHalfday().isSupported()); assertEquals(true, buddhist.hourOfHalfday().isSupported()); assertEquals(true, buddhist.clockhourOfDay().isSupported()); assertEquals(true, buddhist.hourOfDay().isSupported()); assertEquals(true, buddhist.minuteOfDay().isSupported()); assertEquals(true, buddhist.minuteOfHour().isSupported()); assertEquals(true, buddhist.secondOfDay().isSupported()); assertEquals(true, buddhist.secondOfMinute().isSupported()); assertEquals(true, buddhist.millisOfDay().isSupported()); assertEquals(true, buddhist.millisOfSecond().isSupported()); } //----------------------------------------------------------------------- public void testEpoch() { DateTime epoch = new DateTime(1, 1, 1, 0, 0, 0, 0, BUDDHIST_UTC); assertEquals(new DateTime(-543, 1, 1, 0, 0, 0, 0, JULIAN_UTC), epoch.withChronology(JULIAN_UTC)); } public void testEra() { assertEquals(1, BuddhistChronology.BE); try { new DateTime(-1, 13, 5, 0, 0, 0, 0, BUDDHIST_UTC); fail(); } catch (IllegalArgumentException ex) {} } public void testKeyYears() { DateTime bd = new DateTime(2513, 1, 1, 0, 0, 0, 0, BUDDHIST_UTC); DateTime jd = new DateTime(1970, 1, 1, 0, 0, 0, 0, GJ_UTC); assertEquals(jd, bd.withChronology(GJ_UTC)); assertEquals(2513, bd.getYear()); assertEquals(2513, bd.getYearOfEra()); assertEquals(2513, bd.plus(Period.weeks(1)).getWeekyear()); bd = new DateTime(2126, 1, 1, 0, 0, 0, 0, BUDDHIST_UTC); jd = new DateTime(1583, 1, 1, 0, 0, 0, 0, GJ_UTC); assertEquals(jd, bd.withChronology(GJ_UTC)); assertEquals(2126, bd.getYear()); assertEquals(2126, bd.getYearOfEra()); assertEquals(2126, bd.plus(Period.weeks(1)).getWeekyear()); bd = new DateTime(2125, 1, 1, 0, 0, 0, 0, BUDDHIST_UTC); jd = new DateTime(1582, 1, 1, 0, 0, 0, 0, GJ_UTC); assertEquals(jd, bd.withChronology(GJ_UTC)); assertEquals(2125, bd.getYear()); assertEquals(2125, bd.getYearOfEra()); assertEquals(2125, bd.plus(Period.weeks(1)).getWeekyear()); bd = new DateTime(544, 1, 1, 0, 0, 0, 0, BUDDHIST_UTC); jd = new DateTime(1, 1, 1, 0, 0, 0, 0, GJ_UTC); assertEquals(jd, bd.withChronology(GJ_UTC)); assertEquals(544, bd.getYear()); assertEquals(544, bd.getYearOfEra()); assertEquals(544, bd.plus(Period.weeks(1)).getWeekyear()); bd = new DateTime(543, 1, 1, 0, 0, 0, 0, BUDDHIST_UTC); jd = new DateTime(-1, 1, 1, 0, 0, 0, 0, GJ_UTC); assertEquals(jd, bd.withChronology(GJ_UTC)); assertEquals(543, bd.getYear()); assertEquals(543, bd.getYearOfEra()); assertEquals(543, bd.plus(Period.weeks(1)).getWeekyear()); bd = new DateTime(1, 1, 1, 0, 0, 0, 0, BUDDHIST_UTC); jd = new DateTime(-543, 1, 1, 0, 0, 0, 0, GJ_UTC); assertEquals(jd, bd.withChronology(GJ_UTC)); assertEquals(1, bd.getYear()); assertEquals(1, bd.getYearOfEra()); assertEquals(1, bd.plus(Period.weeks(1)).getWeekyear()); } public void testCalendar() { if (TestAll.FAST) { return; } System.out.println("\nTestBuddhistChronology.testCalendar"); DateTime epoch = new DateTime(1, 1, 1, 0, 0, 0, 0, BUDDHIST_UTC); long millis = epoch.getMillis(); long end = new DateTime(3000, 1, 1, 0, 0, 0, 0, ISO_UTC).getMillis(); DateTimeField dayOfWeek = BUDDHIST_UTC.dayOfWeek(); DateTimeField weekOfWeekyear = GJ_UTC.weekOfWeekyear(); DateTimeField dayOfYear = BUDDHIST_UTC.dayOfYear(); DateTimeField dayOfMonth = BUDDHIST_UTC.dayOfMonth(); DateTimeField monthOfYear = BUDDHIST_UTC.monthOfYear(); DateTimeField year = BUDDHIST_UTC.year(); DateTimeField yearOfEra = BUDDHIST_UTC.yearOfEra(); DateTimeField era = BUDDHIST_UTC.era(); DateTimeField gjDayOfWeek = GJ_UTC.dayOfWeek(); DateTimeField gjWeekOfWeekyear = GJ_UTC.weekOfWeekyear(); DateTimeField gjDayOfYear = GJ_UTC.dayOfYear(); DateTimeField gjDayOfMonth = GJ_UTC.dayOfMonth(); DateTimeField gjMonthOfYear = GJ_UTC.monthOfYear(); DateTimeField gjYear = GJ_UTC.year(); while (millis < end) { assertEquals(gjDayOfWeek.get(millis), dayOfWeek.get(millis)); assertEquals(gjDayOfYear.get(millis), dayOfYear.get(millis)); assertEquals(gjDayOfMonth.get(millis), dayOfMonth.get(millis)); assertEquals(gjMonthOfYear.get(millis), monthOfYear.get(millis)); assertEquals(gjWeekOfWeekyear.get(millis), weekOfWeekyear.get(millis)); assertEquals(1, era.get(millis)); int yearValue = gjYear.get(millis); if (yearValue <= 0) { yearValue++; } yearValue += 543; assertEquals(yearValue, year.get(millis)); assertEquals(yearValue, yearOfEra.get(millis)); millis += SKIP; } } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.chrono; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.Chronology; import org.joda.time.DateTime; import org.joda.time.DateTimeConstants; import org.joda.time.DateTimeField; import org.joda.time.DateTimeUtils; import org.joda.time.DateTimeZone; import org.joda.time.DurationField; import org.joda.time.DurationFieldType; import org.joda.time.DateTime.Property; /** * This class is a Junit unit test for CopticChronology. * * @author Stephen Colebourne */ public class TestCopticChronology extends TestCase { private static final int MILLIS_PER_DAY = DateTimeConstants.MILLIS_PER_DAY; private static long SKIP = 1 * MILLIS_PER_DAY; private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo"); private static final Chronology COPTIC_UTC = CopticChronology.getInstanceUTC(); private static final Chronology JULIAN_UTC = JulianChronology.getInstanceUTC(); private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC(); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * MILLIS_PER_DAY; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { SKIP = 1 * MILLIS_PER_DAY; return new TestSuite(TestCopticChronology.class); } public TestCopticChronology(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testFactoryUTC() { assertEquals(DateTimeZone.UTC, CopticChronology.getInstanceUTC().getZone()); assertSame(CopticChronology.class, CopticChronology.getInstanceUTC().getClass()); } public void testFactory() { assertEquals(LONDON, CopticChronology.getInstance().getZone()); assertSame(CopticChronology.class, CopticChronology.getInstance().getClass()); } public void testFactory_Zone() { assertEquals(TOKYO, CopticChronology.getInstance(TOKYO).getZone()); assertEquals(PARIS, CopticChronology.getInstance(PARIS).getZone()); assertEquals(LONDON, CopticChronology.getInstance(null).getZone()); assertSame(CopticChronology.class, CopticChronology.getInstance(TOKYO).getClass()); } //----------------------------------------------------------------------- public void testEquality() { assertSame(CopticChronology.getInstance(TOKYO), CopticChronology.getInstance(TOKYO)); assertSame(CopticChronology.getInstance(LONDON), CopticChronology.getInstance(LONDON)); assertSame(CopticChronology.getInstance(PARIS), CopticChronology.getInstance(PARIS)); assertSame(CopticChronology.getInstanceUTC(), CopticChronology.getInstanceUTC()); assertSame(CopticChronology.getInstance(), CopticChronology.getInstance(LONDON)); } public void testWithUTC() { assertSame(CopticChronology.getInstanceUTC(), CopticChronology.getInstance(LONDON).withUTC()); assertSame(CopticChronology.getInstanceUTC(), CopticChronology.getInstance(TOKYO).withUTC()); assertSame(CopticChronology.getInstanceUTC(), CopticChronology.getInstanceUTC().withUTC()); assertSame(CopticChronology.getInstanceUTC(), CopticChronology.getInstance().withUTC()); } public void testWithZone() { assertSame(CopticChronology.getInstance(TOKYO), CopticChronology.getInstance(TOKYO).withZone(TOKYO)); assertSame(CopticChronology.getInstance(LONDON), CopticChronology.getInstance(TOKYO).withZone(LONDON)); assertSame(CopticChronology.getInstance(PARIS), CopticChronology.getInstance(TOKYO).withZone(PARIS)); assertSame(CopticChronology.getInstance(LONDON), CopticChronology.getInstance(TOKYO).withZone(null)); assertSame(CopticChronology.getInstance(PARIS), CopticChronology.getInstance().withZone(PARIS)); assertSame(CopticChronology.getInstance(PARIS), CopticChronology.getInstanceUTC().withZone(PARIS)); } public void testToString() { assertEquals("CopticChronology[Europe/London]", CopticChronology.getInstance(LONDON).toString()); assertEquals("CopticChronology[Asia/Tokyo]", CopticChronology.getInstance(TOKYO).toString()); assertEquals("CopticChronology[Europe/London]", CopticChronology.getInstance().toString()); assertEquals("CopticChronology[UTC]", CopticChronology.getInstanceUTC().toString()); } //----------------------------------------------------------------------- public void testDurationFields() { final CopticChronology coptic = CopticChronology.getInstance(); assertEquals("eras", coptic.eras().getName()); assertEquals("centuries", coptic.centuries().getName()); assertEquals("years", coptic.years().getName()); assertEquals("weekyears", coptic.weekyears().getName()); assertEquals("months", coptic.months().getName()); assertEquals("weeks", coptic.weeks().getName()); assertEquals("days", coptic.days().getName()); assertEquals("halfdays", coptic.halfdays().getName()); assertEquals("hours", coptic.hours().getName()); assertEquals("minutes", coptic.minutes().getName()); assertEquals("seconds", coptic.seconds().getName()); assertEquals("millis", coptic.millis().getName()); assertEquals(false, coptic.eras().isSupported()); assertEquals(true, coptic.centuries().isSupported()); assertEquals(true, coptic.years().isSupported()); assertEquals(true, coptic.weekyears().isSupported()); assertEquals(true, coptic.months().isSupported()); assertEquals(true, coptic.weeks().isSupported()); assertEquals(true, coptic.days().isSupported()); assertEquals(true, coptic.halfdays().isSupported()); assertEquals(true, coptic.hours().isSupported()); assertEquals(true, coptic.minutes().isSupported()); assertEquals(true, coptic.seconds().isSupported()); assertEquals(true, coptic.millis().isSupported()); assertEquals(false, coptic.centuries().isPrecise()); assertEquals(false, coptic.years().isPrecise()); assertEquals(false, coptic.weekyears().isPrecise()); assertEquals(false, coptic.months().isPrecise()); assertEquals(false, coptic.weeks().isPrecise()); assertEquals(false, coptic.days().isPrecise()); assertEquals(false, coptic.halfdays().isPrecise()); assertEquals(true, coptic.hours().isPrecise()); assertEquals(true, coptic.minutes().isPrecise()); assertEquals(true, coptic.seconds().isPrecise()); assertEquals(true, coptic.millis().isPrecise()); final CopticChronology copticUTC = CopticChronology.getInstanceUTC(); assertEquals(false, copticUTC.centuries().isPrecise()); assertEquals(false, copticUTC.years().isPrecise()); assertEquals(false, copticUTC.weekyears().isPrecise()); assertEquals(false, copticUTC.months().isPrecise()); assertEquals(true, copticUTC.weeks().isPrecise()); assertEquals(true, copticUTC.days().isPrecise()); assertEquals(true, copticUTC.halfdays().isPrecise()); assertEquals(true, copticUTC.hours().isPrecise()); assertEquals(true, copticUTC.minutes().isPrecise()); assertEquals(true, copticUTC.seconds().isPrecise()); assertEquals(true, copticUTC.millis().isPrecise()); final DateTimeZone gmt = DateTimeZone.forID("Etc/GMT"); final CopticChronology copticGMT = CopticChronology.getInstance(gmt); assertEquals(false, copticGMT.centuries().isPrecise()); assertEquals(false, copticGMT.years().isPrecise()); assertEquals(false, copticGMT.weekyears().isPrecise()); assertEquals(false, copticGMT.months().isPrecise()); assertEquals(true, copticGMT.weeks().isPrecise()); assertEquals(true, copticGMT.days().isPrecise()); assertEquals(true, copticGMT.halfdays().isPrecise()); assertEquals(true, copticGMT.hours().isPrecise()); assertEquals(true, copticGMT.minutes().isPrecise()); assertEquals(true, copticGMT.seconds().isPrecise()); assertEquals(true, copticGMT.millis().isPrecise()); } public void testDateFields() { final CopticChronology coptic = CopticChronology.getInstance(); assertEquals("era", coptic.era().getName()); assertEquals("centuryOfEra", coptic.centuryOfEra().getName()); assertEquals("yearOfCentury", coptic.yearOfCentury().getName()); assertEquals("yearOfEra", coptic.yearOfEra().getName()); assertEquals("year", coptic.year().getName()); assertEquals("monthOfYear", coptic.monthOfYear().getName()); assertEquals("weekyearOfCentury", coptic.weekyearOfCentury().getName()); assertEquals("weekyear", coptic.weekyear().getName()); assertEquals("weekOfWeekyear", coptic.weekOfWeekyear().getName()); assertEquals("dayOfYear", coptic.dayOfYear().getName()); assertEquals("dayOfMonth", coptic.dayOfMonth().getName()); assertEquals("dayOfWeek", coptic.dayOfWeek().getName()); assertEquals(true, coptic.era().isSupported()); assertEquals(true, coptic.centuryOfEra().isSupported()); assertEquals(true, coptic.yearOfCentury().isSupported()); assertEquals(true, coptic.yearOfEra().isSupported()); assertEquals(true, coptic.year().isSupported()); assertEquals(true, coptic.monthOfYear().isSupported()); assertEquals(true, coptic.weekyearOfCentury().isSupported()); assertEquals(true, coptic.weekyear().isSupported()); assertEquals(true, coptic.weekOfWeekyear().isSupported()); assertEquals(true, coptic.dayOfYear().isSupported()); assertEquals(true, coptic.dayOfMonth().isSupported()); assertEquals(true, coptic.dayOfWeek().isSupported()); assertEquals(coptic.eras(), coptic.era().getDurationField()); assertEquals(coptic.centuries(), coptic.centuryOfEra().getDurationField()); assertEquals(coptic.years(), coptic.yearOfCentury().getDurationField()); assertEquals(coptic.years(), coptic.yearOfEra().getDurationField()); assertEquals(coptic.years(), coptic.year().getDurationField()); assertEquals(coptic.months(), coptic.monthOfYear().getDurationField()); assertEquals(coptic.weekyears(), coptic.weekyearOfCentury().getDurationField()); assertEquals(coptic.weekyears(), coptic.weekyear().getDurationField()); assertEquals(coptic.weeks(), coptic.weekOfWeekyear().getDurationField()); assertEquals(coptic.days(), coptic.dayOfYear().getDurationField()); assertEquals(coptic.days(), coptic.dayOfMonth().getDurationField()); assertEquals(coptic.days(), coptic.dayOfWeek().getDurationField()); assertEquals(null, coptic.era().getRangeDurationField()); assertEquals(coptic.eras(), coptic.centuryOfEra().getRangeDurationField()); assertEquals(coptic.centuries(), coptic.yearOfCentury().getRangeDurationField()); assertEquals(coptic.eras(), coptic.yearOfEra().getRangeDurationField()); assertEquals(null, coptic.year().getRangeDurationField()); assertEquals(coptic.years(), coptic.monthOfYear().getRangeDurationField()); assertEquals(coptic.centuries(), coptic.weekyearOfCentury().getRangeDurationField()); assertEquals(null, coptic.weekyear().getRangeDurationField()); assertEquals(coptic.weekyears(), coptic.weekOfWeekyear().getRangeDurationField()); assertEquals(coptic.years(), coptic.dayOfYear().getRangeDurationField()); assertEquals(coptic.months(), coptic.dayOfMonth().getRangeDurationField()); assertEquals(coptic.weeks(), coptic.dayOfWeek().getRangeDurationField()); } public void testTimeFields() { final CopticChronology coptic = CopticChronology.getInstance(); assertEquals("halfdayOfDay", coptic.halfdayOfDay().getName()); assertEquals("clockhourOfHalfday", coptic.clockhourOfHalfday().getName()); assertEquals("hourOfHalfday", coptic.hourOfHalfday().getName()); assertEquals("clockhourOfDay", coptic.clockhourOfDay().getName()); assertEquals("hourOfDay", coptic.hourOfDay().getName()); assertEquals("minuteOfDay", coptic.minuteOfDay().getName()); assertEquals("minuteOfHour", coptic.minuteOfHour().getName()); assertEquals("secondOfDay", coptic.secondOfDay().getName()); assertEquals("secondOfMinute", coptic.secondOfMinute().getName()); assertEquals("millisOfDay", coptic.millisOfDay().getName()); assertEquals("millisOfSecond", coptic.millisOfSecond().getName()); assertEquals(true, coptic.halfdayOfDay().isSupported()); assertEquals(true, coptic.clockhourOfHalfday().isSupported()); assertEquals(true, coptic.hourOfHalfday().isSupported()); assertEquals(true, coptic.clockhourOfDay().isSupported()); assertEquals(true, coptic.hourOfDay().isSupported()); assertEquals(true, coptic.minuteOfDay().isSupported()); assertEquals(true, coptic.minuteOfHour().isSupported()); assertEquals(true, coptic.secondOfDay().isSupported()); assertEquals(true, coptic.secondOfMinute().isSupported()); assertEquals(true, coptic.millisOfDay().isSupported()); assertEquals(true, coptic.millisOfSecond().isSupported()); } //----------------------------------------------------------------------- public void testEpoch() { DateTime epoch = new DateTime(1, 1, 1, 0, 0, 0, 0, COPTIC_UTC); assertEquals(new DateTime(284, 8, 29, 0, 0, 0, 0, JULIAN_UTC), epoch.withChronology(JULIAN_UTC)); } public void testEra() { assertEquals(1, CopticChronology.AM); try { new DateTime(-1, 13, 5, 0, 0, 0, 0, COPTIC_UTC); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- /** * Tests era, year, monthOfYear, dayOfMonth and dayOfWeek. */ public void testCalendar() { if (TestAll.FAST) { return; } System.out.println("\nTestCopticChronology.testCalendar"); DateTime epoch = new DateTime(1, 1, 1, 0, 0, 0, 0, COPTIC_UTC); long millis = epoch.getMillis(); long end = new DateTime(3000, 1, 1, 0, 0, 0, 0, ISO_UTC).getMillis(); DateTimeField dayOfWeek = COPTIC_UTC.dayOfWeek(); DateTimeField dayOfYear = COPTIC_UTC.dayOfYear(); DateTimeField dayOfMonth = COPTIC_UTC.dayOfMonth(); DateTimeField monthOfYear = COPTIC_UTC.monthOfYear(); DateTimeField year = COPTIC_UTC.year(); DateTimeField yearOfEra = COPTIC_UTC.yearOfEra(); DateTimeField era = COPTIC_UTC.era(); int expectedDOW = new DateTime(284, 8, 29, 0, 0, 0, 0, JULIAN_UTC).getDayOfWeek(); int expectedDOY = 1; int expectedDay = 1; int expectedMonth = 1; int expectedYear = 1; while (millis < end) { int dowValue = dayOfWeek.get(millis); int doyValue = dayOfYear.get(millis); int dayValue = dayOfMonth.get(millis); int monthValue = monthOfYear.get(millis); int yearValue = year.get(millis); int yearOfEraValue = yearOfEra.get(millis); int monthLen = dayOfMonth.getMaximumValue(millis); if (monthValue < 1 || monthValue > 13) { fail("Bad month: " + millis); } // test era assertEquals(1, era.get(millis)); assertEquals("AM", era.getAsText(millis)); assertEquals("AM", era.getAsShortText(millis)); // test date assertEquals(expectedYear, yearValue); assertEquals(expectedYear, yearOfEraValue); assertEquals(expectedMonth, monthValue); assertEquals(expectedDay, dayValue); assertEquals(expectedDOW, dowValue); assertEquals(expectedDOY, doyValue); // test leap year assertEquals(yearValue % 4 == 3, year.isLeap(millis)); // test month length if (monthValue == 13) { assertEquals(yearValue % 4 == 3, monthOfYear.isLeap(millis)); if (yearValue % 4 == 3) { assertEquals(6, monthLen); } else { assertEquals(5, monthLen); } } else { assertEquals(30, monthLen); } // recalculate date expectedDOW = (((expectedDOW + 1) - 1) % 7) + 1; expectedDay++; expectedDOY++; if (expectedDay == 31 && expectedMonth < 13) { expectedDay = 1; expectedMonth++; } else if (expectedMonth == 13) { if (expectedYear % 4 == 3 && expectedDay == 7) { expectedDay = 1; expectedMonth = 1; expectedYear++; expectedDOY = 1; } else if (expectedYear % 4 != 3 && expectedDay == 6) { expectedDay = 1; expectedMonth = 1; expectedYear++; expectedDOY = 1; } } millis += SKIP; } } public void testSampleDate() { DateTime dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, ISO_UTC).withChronology(COPTIC_UTC); assertEquals(CopticChronology.AM, dt.getEra()); assertEquals(18, dt.getCenturyOfEra()); // TODO confirm assertEquals(20, dt.getYearOfCentury()); assertEquals(1720, dt.getYearOfEra()); assertEquals(1720, dt.getYear()); Property fld = dt.year(); assertEquals(false, fld.isLeap()); assertEquals(0, fld.getLeapAmount()); assertEquals(DurationFieldType.days(), fld.getLeapDurationField().getType()); assertEquals(new DateTime(1721, 10, 2, 0, 0, 0, 0, COPTIC_UTC), fld.addToCopy(1)); assertEquals(10, dt.getMonthOfYear()); fld = dt.monthOfYear(); assertEquals(false, fld.isLeap()); assertEquals(0, fld.getLeapAmount()); assertEquals(DurationFieldType.days(), fld.getLeapDurationField().getType()); assertEquals(1, fld.getMinimumValue()); assertEquals(1, fld.getMinimumValueOverall()); assertEquals(13, fld.getMaximumValue()); assertEquals(13, fld.getMaximumValueOverall()); assertEquals(new DateTime(1721, 1, 2, 0, 0, 0, 0, COPTIC_UTC), fld.addToCopy(4)); assertEquals(new DateTime(1720, 1, 2, 0, 0, 0, 0, COPTIC_UTC), fld.addWrapFieldToCopy(4)); assertEquals(2, dt.getDayOfMonth()); fld = dt.dayOfMonth(); assertEquals(false, fld.isLeap()); assertEquals(0, fld.getLeapAmount()); assertEquals(null, fld.getLeapDurationField()); assertEquals(1, fld.getMinimumValue()); assertEquals(1, fld.getMinimumValueOverall()); assertEquals(30, fld.getMaximumValue()); assertEquals(30, fld.getMaximumValueOverall()); assertEquals(new DateTime(1720, 10, 3, 0, 0, 0, 0, COPTIC_UTC), fld.addToCopy(1)); assertEquals(DateTimeConstants.WEDNESDAY, dt.getDayOfWeek()); fld = dt.dayOfWeek(); assertEquals(false, fld.isLeap()); assertEquals(0, fld.getLeapAmount()); assertEquals(null, fld.getLeapDurationField()); assertEquals(1, fld.getMinimumValue()); assertEquals(1, fld.getMinimumValueOverall()); assertEquals(7, fld.getMaximumValue()); assertEquals(7, fld.getMaximumValueOverall()); assertEquals(new DateTime(1720, 10, 3, 0, 0, 0, 0, COPTIC_UTC), fld.addToCopy(1)); assertEquals(9 * 30 + 2, dt.getDayOfYear()); fld = dt.dayOfYear(); assertEquals(false, fld.isLeap()); assertEquals(0, fld.getLeapAmount()); assertEquals(null, fld.getLeapDurationField()); assertEquals(1, fld.getMinimumValue()); assertEquals(1, fld.getMinimumValueOverall()); assertEquals(365, fld.getMaximumValue()); assertEquals(366, fld.getMaximumValueOverall()); assertEquals(new DateTime(1720, 10, 3, 0, 0, 0, 0, COPTIC_UTC), fld.addToCopy(1)); assertEquals(0, dt.getHourOfDay()); assertEquals(0, dt.getMinuteOfHour()); assertEquals(0, dt.getSecondOfMinute()); assertEquals(0, dt.getMillisOfSecond()); } public void testSampleDateWithZone() { DateTime dt = new DateTime(2004, 6, 9, 12, 0, 0, 0, PARIS).withChronology(COPTIC_UTC); assertEquals(CopticChronology.AM, dt.getEra()); assertEquals(1720, dt.getYear()); assertEquals(1720, dt.getYearOfEra()); assertEquals(10, dt.getMonthOfYear()); assertEquals(2, dt.getDayOfMonth()); assertEquals(10, dt.getHourOfDay()); // PARIS is UTC+2 in summer (12-2=10) assertEquals(0, dt.getMinuteOfHour()); assertEquals(0, dt.getSecondOfMinute()); assertEquals(0, dt.getMillisOfSecond()); } public void testDurationYear() { // Leap 1723 DateTime dt20 = new DateTime(1720, 10, 2, 0, 0, 0, 0, COPTIC_UTC); DateTime dt21 = new DateTime(1721, 10, 2, 0, 0, 0, 0, COPTIC_UTC); DateTime dt22 = new DateTime(1722, 10, 2, 0, 0, 0, 0, COPTIC_UTC); DateTime dt23 = new DateTime(1723, 10, 2, 0, 0, 0, 0, COPTIC_UTC); DateTime dt24 = new DateTime(1724, 10, 2, 0, 0, 0, 0, COPTIC_UTC); DurationField fld = dt20.year().getDurationField(); assertEquals(COPTIC_UTC.years(), fld); assertEquals(1L * 365L * MILLIS_PER_DAY, fld.getMillis(1, dt20.getMillis())); assertEquals(2L * 365L * MILLIS_PER_DAY, fld.getMillis(2, dt20.getMillis())); assertEquals(3L * 365L * MILLIS_PER_DAY, fld.getMillis(3, dt20.getMillis())); assertEquals((4L * 365L + 1L) * MILLIS_PER_DAY, fld.getMillis(4, dt20.getMillis())); assertEquals(((4L * 365L + 1L) * MILLIS_PER_DAY) / 4, fld.getMillis(1)); assertEquals(((4L * 365L + 1L) * MILLIS_PER_DAY) / 2, fld.getMillis(2)); assertEquals(1L * 365L * MILLIS_PER_DAY, fld.getMillis(1L, dt20.getMillis())); assertEquals(2L * 365L * MILLIS_PER_DAY, fld.getMillis(2L, dt20.getMillis())); assertEquals(3L * 365L * MILLIS_PER_DAY, fld.getMillis(3L, dt20.getMillis())); assertEquals((4L * 365L + 1L) * MILLIS_PER_DAY, fld.getMillis(4L, dt20.getMillis())); assertEquals(((4L * 365L + 1L) * MILLIS_PER_DAY) / 4, fld.getMillis(1L)); assertEquals(((4L * 365L + 1L) * MILLIS_PER_DAY) / 2, fld.getMillis(2L)); assertEquals(((4L * 365L + 1L) * MILLIS_PER_DAY) / 4, fld.getUnitMillis()); assertEquals(0, fld.getValue(1L * 365L * MILLIS_PER_DAY - 1L, dt20.getMillis())); assertEquals(1, fld.getValue(1L * 365L * MILLIS_PER_DAY, dt20.getMillis())); assertEquals(1, fld.getValue(1L * 365L * MILLIS_PER_DAY + 1L, dt20.getMillis())); assertEquals(1, fld.getValue(2L * 365L * MILLIS_PER_DAY - 1L, dt20.getMillis())); assertEquals(2, fld.getValue(2L * 365L * MILLIS_PER_DAY, dt20.getMillis())); assertEquals(2, fld.getValue(2L * 365L * MILLIS_PER_DAY + 1L, dt20.getMillis())); assertEquals(2, fld.getValue(3L * 365L * MILLIS_PER_DAY - 1L, dt20.getMillis())); assertEquals(3, fld.getValue(3L * 365L * MILLIS_PER_DAY, dt20.getMillis())); assertEquals(3, fld.getValue(3L * 365L * MILLIS_PER_DAY + 1L, dt20.getMillis())); assertEquals(3, fld.getValue((4L * 365L + 1L) * MILLIS_PER_DAY - 1L, dt20.getMillis())); assertEquals(4, fld.getValue((4L * 365L + 1L) * MILLIS_PER_DAY, dt20.getMillis())); assertEquals(4, fld.getValue((4L * 365L + 1L) * MILLIS_PER_DAY + 1L, dt20.getMillis())); assertEquals(dt21.getMillis(), fld.add(dt20.getMillis(), 1)); assertEquals(dt22.getMillis(), fld.add(dt20.getMillis(), 2)); assertEquals(dt23.getMillis(), fld.add(dt20.getMillis(), 3)); assertEquals(dt24.getMillis(), fld.add(dt20.getMillis(), 4)); assertEquals(dt21.getMillis(), fld.add(dt20.getMillis(), 1L)); assertEquals(dt22.getMillis(), fld.add(dt20.getMillis(), 2L)); assertEquals(dt23.getMillis(), fld.add(dt20.getMillis(), 3L)); assertEquals(dt24.getMillis(), fld.add(dt20.getMillis(), 4L)); } public void testDurationMonth() { // Leap 1723 DateTime dt11 = new DateTime(1723, 11, 2, 0, 0, 0, 0, COPTIC_UTC); DateTime dt12 = new DateTime(1723, 12, 2, 0, 0, 0, 0, COPTIC_UTC); DateTime dt13 = new DateTime(1723, 13, 2, 0, 0, 0, 0, COPTIC_UTC); DateTime dt01 = new DateTime(1724, 1, 2, 0, 0, 0, 0, COPTIC_UTC); DurationField fld = dt11.monthOfYear().getDurationField(); assertEquals(COPTIC_UTC.months(), fld); assertEquals(1L * 30L * MILLIS_PER_DAY, fld.getMillis(1, dt11.getMillis())); assertEquals(2L * 30L * MILLIS_PER_DAY, fld.getMillis(2, dt11.getMillis())); assertEquals((2L * 30L + 6L) * MILLIS_PER_DAY, fld.getMillis(3, dt11.getMillis())); assertEquals((3L * 30L + 6L) * MILLIS_PER_DAY, fld.getMillis(4, dt11.getMillis())); assertEquals(1L * 30L * MILLIS_PER_DAY, fld.getMillis(1)); assertEquals(2L * 30L * MILLIS_PER_DAY, fld.getMillis(2)); assertEquals(13L * 30L * MILLIS_PER_DAY, fld.getMillis(13)); assertEquals(1L * 30L * MILLIS_PER_DAY, fld.getMillis(1L, dt11.getMillis())); assertEquals(2L * 30L * MILLIS_PER_DAY, fld.getMillis(2L, dt11.getMillis())); assertEquals((2L * 30L + 6L) * MILLIS_PER_DAY, fld.getMillis(3L, dt11.getMillis())); assertEquals((3L * 30L + 6L) * MILLIS_PER_DAY, fld.getMillis(4L, dt11.getMillis())); assertEquals(1L * 30L * MILLIS_PER_DAY, fld.getMillis(1L)); assertEquals(2L * 30L * MILLIS_PER_DAY, fld.getMillis(2L)); assertEquals(13L * 30L * MILLIS_PER_DAY, fld.getMillis(13L)); assertEquals(0, fld.getValue(1L * 30L * MILLIS_PER_DAY - 1L, dt11.getMillis())); assertEquals(1, fld.getValue(1L * 30L * MILLIS_PER_DAY, dt11.getMillis())); assertEquals(1, fld.getValue(1L * 30L * MILLIS_PER_DAY + 1L, dt11.getMillis())); assertEquals(1, fld.getValue(2L * 30L * MILLIS_PER_DAY - 1L, dt11.getMillis())); assertEquals(2, fld.getValue(2L * 30L * MILLIS_PER_DAY, dt11.getMillis())); assertEquals(2, fld.getValue(2L * 30L * MILLIS_PER_DAY + 1L, dt11.getMillis())); assertEquals(2, fld.getValue((2L * 30L + 6L) * MILLIS_PER_DAY - 1L, dt11.getMillis())); assertEquals(3, fld.getValue((2L * 30L + 6L) * MILLIS_PER_DAY, dt11.getMillis())); assertEquals(3, fld.getValue((2L * 30L + 6L) * MILLIS_PER_DAY + 1L, dt11.getMillis())); assertEquals(3, fld.getValue((3L * 30L + 6L) * MILLIS_PER_DAY - 1L, dt11.getMillis())); assertEquals(4, fld.getValue((3L * 30L + 6L) * MILLIS_PER_DAY, dt11.getMillis())); assertEquals(4, fld.getValue((3L * 30L + 6L) * MILLIS_PER_DAY + 1L, dt11.getMillis())); assertEquals(dt12.getMillis(), fld.add(dt11.getMillis(), 1)); assertEquals(dt13.getMillis(), fld.add(dt11.getMillis(), 2)); assertEquals(dt01.getMillis(), fld.add(dt11.getMillis(), 3)); assertEquals(dt12.getMillis(), fld.add(dt11.getMillis(), 1L)); assertEquals(dt13.getMillis(), fld.add(dt11.getMillis(), 2L)); assertEquals(dt01.getMillis(), fld.add(dt11.getMillis(), 3L)); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.chrono; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.Chronology; import org.joda.time.DateTime; import org.joda.time.DateTimeConstants; import org.joda.time.DateTimeField; import org.joda.time.DateTimeUtils; import org.joda.time.DateTimeZone; import org.joda.time.DurationField; import org.joda.time.DurationFieldType; import org.joda.time.DateTime.Property; /** * This class is a Junit unit test for EthiopicChronology. * * @author Stephen Colebourne */ public class TestEthiopicChronology extends TestCase { private static final int MILLIS_PER_DAY = DateTimeConstants.MILLIS_PER_DAY; private static long SKIP = 1 * MILLIS_PER_DAY; private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo"); private static final Chronology ETHIOPIC_UTC = EthiopicChronology.getInstanceUTC(); private static final Chronology JULIAN_UTC = JulianChronology.getInstanceUTC(); private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC(); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * MILLIS_PER_DAY; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { SKIP = 1 * MILLIS_PER_DAY; return new TestSuite(TestEthiopicChronology.class); } public TestEthiopicChronology(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testFactoryUTC() { assertEquals(DateTimeZone.UTC, EthiopicChronology.getInstanceUTC().getZone()); assertSame(EthiopicChronology.class, EthiopicChronology.getInstanceUTC().getClass()); } public void testFactory() { assertEquals(LONDON, EthiopicChronology.getInstance().getZone()); assertSame(EthiopicChronology.class, EthiopicChronology.getInstance().getClass()); } public void testFactory_Zone() { assertEquals(TOKYO, EthiopicChronology.getInstance(TOKYO).getZone()); assertEquals(PARIS, EthiopicChronology.getInstance(PARIS).getZone()); assertEquals(LONDON, EthiopicChronology.getInstance(null).getZone()); assertSame(EthiopicChronology.class, EthiopicChronology.getInstance(TOKYO).getClass()); } //----------------------------------------------------------------------- public void testEquality() { assertSame(EthiopicChronology.getInstance(TOKYO), EthiopicChronology.getInstance(TOKYO)); assertSame(EthiopicChronology.getInstance(LONDON), EthiopicChronology.getInstance(LONDON)); assertSame(EthiopicChronology.getInstance(PARIS), EthiopicChronology.getInstance(PARIS)); assertSame(EthiopicChronology.getInstanceUTC(), EthiopicChronology.getInstanceUTC()); assertSame(EthiopicChronology.getInstance(), EthiopicChronology.getInstance(LONDON)); } public void testWithUTC() { assertSame(EthiopicChronology.getInstanceUTC(), EthiopicChronology.getInstance(LONDON).withUTC()); assertSame(EthiopicChronology.getInstanceUTC(), EthiopicChronology.getInstance(TOKYO).withUTC()); assertSame(EthiopicChronology.getInstanceUTC(), EthiopicChronology.getInstanceUTC().withUTC()); assertSame(EthiopicChronology.getInstanceUTC(), EthiopicChronology.getInstance().withUTC()); } public void testWithZone() { assertSame(EthiopicChronology.getInstance(TOKYO), EthiopicChronology.getInstance(TOKYO).withZone(TOKYO)); assertSame(EthiopicChronology.getInstance(LONDON), EthiopicChronology.getInstance(TOKYO).withZone(LONDON)); assertSame(EthiopicChronology.getInstance(PARIS), EthiopicChronology.getInstance(TOKYO).withZone(PARIS)); assertSame(EthiopicChronology.getInstance(LONDON), EthiopicChronology.getInstance(TOKYO).withZone(null)); assertSame(EthiopicChronology.getInstance(PARIS), EthiopicChronology.getInstance().withZone(PARIS)); assertSame(EthiopicChronology.getInstance(PARIS), EthiopicChronology.getInstanceUTC().withZone(PARIS)); } public void testToString() { assertEquals("EthiopicChronology[Europe/London]", EthiopicChronology.getInstance(LONDON).toString()); assertEquals("EthiopicChronology[Asia/Tokyo]", EthiopicChronology.getInstance(TOKYO).toString()); assertEquals("EthiopicChronology[Europe/London]", EthiopicChronology.getInstance().toString()); assertEquals("EthiopicChronology[UTC]", EthiopicChronology.getInstanceUTC().toString()); } //----------------------------------------------------------------------- public void testDurationFields() { final EthiopicChronology ethiopic = EthiopicChronology.getInstance(); assertEquals("eras", ethiopic.eras().getName()); assertEquals("centuries", ethiopic.centuries().getName()); assertEquals("years", ethiopic.years().getName()); assertEquals("weekyears", ethiopic.weekyears().getName()); assertEquals("months", ethiopic.months().getName()); assertEquals("weeks", ethiopic.weeks().getName()); assertEquals("days", ethiopic.days().getName()); assertEquals("halfdays", ethiopic.halfdays().getName()); assertEquals("hours", ethiopic.hours().getName()); assertEquals("minutes", ethiopic.minutes().getName()); assertEquals("seconds", ethiopic.seconds().getName()); assertEquals("millis", ethiopic.millis().getName()); assertEquals(false, ethiopic.eras().isSupported()); assertEquals(true, ethiopic.centuries().isSupported()); assertEquals(true, ethiopic.years().isSupported()); assertEquals(true, ethiopic.weekyears().isSupported()); assertEquals(true, ethiopic.months().isSupported()); assertEquals(true, ethiopic.weeks().isSupported()); assertEquals(true, ethiopic.days().isSupported()); assertEquals(true, ethiopic.halfdays().isSupported()); assertEquals(true, ethiopic.hours().isSupported()); assertEquals(true, ethiopic.minutes().isSupported()); assertEquals(true, ethiopic.seconds().isSupported()); assertEquals(true, ethiopic.millis().isSupported()); assertEquals(false, ethiopic.centuries().isPrecise()); assertEquals(false, ethiopic.years().isPrecise()); assertEquals(false, ethiopic.weekyears().isPrecise()); assertEquals(false, ethiopic.months().isPrecise()); assertEquals(false, ethiopic.weeks().isPrecise()); assertEquals(false, ethiopic.days().isPrecise()); assertEquals(false, ethiopic.halfdays().isPrecise()); assertEquals(true, ethiopic.hours().isPrecise()); assertEquals(true, ethiopic.minutes().isPrecise()); assertEquals(true, ethiopic.seconds().isPrecise()); assertEquals(true, ethiopic.millis().isPrecise()); final EthiopicChronology ethiopicUTC = EthiopicChronology.getInstanceUTC(); assertEquals(false, ethiopicUTC.centuries().isPrecise()); assertEquals(false, ethiopicUTC.years().isPrecise()); assertEquals(false, ethiopicUTC.weekyears().isPrecise()); assertEquals(false, ethiopicUTC.months().isPrecise()); assertEquals(true, ethiopicUTC.weeks().isPrecise()); assertEquals(true, ethiopicUTC.days().isPrecise()); assertEquals(true, ethiopicUTC.halfdays().isPrecise()); assertEquals(true, ethiopicUTC.hours().isPrecise()); assertEquals(true, ethiopicUTC.minutes().isPrecise()); assertEquals(true, ethiopicUTC.seconds().isPrecise()); assertEquals(true, ethiopicUTC.millis().isPrecise()); final DateTimeZone gmt = DateTimeZone.forID("Etc/GMT"); final EthiopicChronology ethiopicGMT = EthiopicChronology.getInstance(gmt); assertEquals(false, ethiopicGMT.centuries().isPrecise()); assertEquals(false, ethiopicGMT.years().isPrecise()); assertEquals(false, ethiopicGMT.weekyears().isPrecise()); assertEquals(false, ethiopicGMT.months().isPrecise()); assertEquals(true, ethiopicGMT.weeks().isPrecise()); assertEquals(true, ethiopicGMT.days().isPrecise()); assertEquals(true, ethiopicGMT.halfdays().isPrecise()); assertEquals(true, ethiopicGMT.hours().isPrecise()); assertEquals(true, ethiopicGMT.minutes().isPrecise()); assertEquals(true, ethiopicGMT.seconds().isPrecise()); assertEquals(true, ethiopicGMT.millis().isPrecise()); } public void testDateFields() { final EthiopicChronology ethiopic = EthiopicChronology.getInstance(); assertEquals("era", ethiopic.era().getName()); assertEquals("centuryOfEra", ethiopic.centuryOfEra().getName()); assertEquals("yearOfCentury", ethiopic.yearOfCentury().getName()); assertEquals("yearOfEra", ethiopic.yearOfEra().getName()); assertEquals("year", ethiopic.year().getName()); assertEquals("monthOfYear", ethiopic.monthOfYear().getName()); assertEquals("weekyearOfCentury", ethiopic.weekyearOfCentury().getName()); assertEquals("weekyear", ethiopic.weekyear().getName()); assertEquals("weekOfWeekyear", ethiopic.weekOfWeekyear().getName()); assertEquals("dayOfYear", ethiopic.dayOfYear().getName()); assertEquals("dayOfMonth", ethiopic.dayOfMonth().getName()); assertEquals("dayOfWeek", ethiopic.dayOfWeek().getName()); assertEquals(true, ethiopic.era().isSupported()); assertEquals(true, ethiopic.centuryOfEra().isSupported()); assertEquals(true, ethiopic.yearOfCentury().isSupported()); assertEquals(true, ethiopic.yearOfEra().isSupported()); assertEquals(true, ethiopic.year().isSupported()); assertEquals(true, ethiopic.monthOfYear().isSupported()); assertEquals(true, ethiopic.weekyearOfCentury().isSupported()); assertEquals(true, ethiopic.weekyear().isSupported()); assertEquals(true, ethiopic.weekOfWeekyear().isSupported()); assertEquals(true, ethiopic.dayOfYear().isSupported()); assertEquals(true, ethiopic.dayOfMonth().isSupported()); assertEquals(true, ethiopic.dayOfWeek().isSupported()); assertEquals(ethiopic.eras(), ethiopic.era().getDurationField()); assertEquals(ethiopic.centuries(), ethiopic.centuryOfEra().getDurationField()); assertEquals(ethiopic.years(), ethiopic.yearOfCentury().getDurationField()); assertEquals(ethiopic.years(), ethiopic.yearOfEra().getDurationField()); assertEquals(ethiopic.years(), ethiopic.year().getDurationField()); assertEquals(ethiopic.months(), ethiopic.monthOfYear().getDurationField()); assertEquals(ethiopic.weekyears(), ethiopic.weekyearOfCentury().getDurationField()); assertEquals(ethiopic.weekyears(), ethiopic.weekyear().getDurationField()); assertEquals(ethiopic.weeks(), ethiopic.weekOfWeekyear().getDurationField()); assertEquals(ethiopic.days(), ethiopic.dayOfYear().getDurationField()); assertEquals(ethiopic.days(), ethiopic.dayOfMonth().getDurationField()); assertEquals(ethiopic.days(), ethiopic.dayOfWeek().getDurationField()); assertEquals(null, ethiopic.era().getRangeDurationField()); assertEquals(ethiopic.eras(), ethiopic.centuryOfEra().getRangeDurationField()); assertEquals(ethiopic.centuries(), ethiopic.yearOfCentury().getRangeDurationField()); assertEquals(ethiopic.eras(), ethiopic.yearOfEra().getRangeDurationField()); assertEquals(null, ethiopic.year().getRangeDurationField()); assertEquals(ethiopic.years(), ethiopic.monthOfYear().getRangeDurationField()); assertEquals(ethiopic.centuries(), ethiopic.weekyearOfCentury().getRangeDurationField()); assertEquals(null, ethiopic.weekyear().getRangeDurationField()); assertEquals(ethiopic.weekyears(), ethiopic.weekOfWeekyear().getRangeDurationField()); assertEquals(ethiopic.years(), ethiopic.dayOfYear().getRangeDurationField()); assertEquals(ethiopic.months(), ethiopic.dayOfMonth().getRangeDurationField()); assertEquals(ethiopic.weeks(), ethiopic.dayOfWeek().getRangeDurationField()); } public void testTimeFields() { final EthiopicChronology ethiopic = EthiopicChronology.getInstance(); assertEquals("halfdayOfDay", ethiopic.halfdayOfDay().getName()); assertEquals("clockhourOfHalfday", ethiopic.clockhourOfHalfday().getName()); assertEquals("hourOfHalfday", ethiopic.hourOfHalfday().getName()); assertEquals("clockhourOfDay", ethiopic.clockhourOfDay().getName()); assertEquals("hourOfDay", ethiopic.hourOfDay().getName()); assertEquals("minuteOfDay", ethiopic.minuteOfDay().getName()); assertEquals("minuteOfHour", ethiopic.minuteOfHour().getName()); assertEquals("secondOfDay", ethiopic.secondOfDay().getName()); assertEquals("secondOfMinute", ethiopic.secondOfMinute().getName()); assertEquals("millisOfDay", ethiopic.millisOfDay().getName()); assertEquals("millisOfSecond", ethiopic.millisOfSecond().getName()); assertEquals(true, ethiopic.halfdayOfDay().isSupported()); assertEquals(true, ethiopic.clockhourOfHalfday().isSupported()); assertEquals(true, ethiopic.hourOfHalfday().isSupported()); assertEquals(true, ethiopic.clockhourOfDay().isSupported()); assertEquals(true, ethiopic.hourOfDay().isSupported()); assertEquals(true, ethiopic.minuteOfDay().isSupported()); assertEquals(true, ethiopic.minuteOfHour().isSupported()); assertEquals(true, ethiopic.secondOfDay().isSupported()); assertEquals(true, ethiopic.secondOfMinute().isSupported()); assertEquals(true, ethiopic.millisOfDay().isSupported()); assertEquals(true, ethiopic.millisOfSecond().isSupported()); } //----------------------------------------------------------------------- public void testEpoch() { DateTime epoch = new DateTime(1, 1, 1, 0, 0, 0, 0, ETHIOPIC_UTC); assertEquals(new DateTime(8, 8, 29, 0, 0, 0, 0, JULIAN_UTC), epoch.withChronology(JULIAN_UTC)); } public void testEra() { assertEquals(1, EthiopicChronology.EE); try { new DateTime(-1, 13, 5, 0, 0, 0, 0, ETHIOPIC_UTC); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- /** * Tests era, year, monthOfYear, dayOfMonth and dayOfWeek. */ public void testCalendar() { if (TestAll.FAST) { return; } System.out.println("\nTestEthiopicChronology.testCalendar"); DateTime epoch = new DateTime(1, 1, 1, 0, 0, 0, 0, ETHIOPIC_UTC); long millis = epoch.getMillis(); long end = new DateTime(3000, 1, 1, 0, 0, 0, 0, ISO_UTC).getMillis(); DateTimeField dayOfWeek = ETHIOPIC_UTC.dayOfWeek(); DateTimeField dayOfYear = ETHIOPIC_UTC.dayOfYear(); DateTimeField dayOfMonth = ETHIOPIC_UTC.dayOfMonth(); DateTimeField monthOfYear = ETHIOPIC_UTC.monthOfYear(); DateTimeField year = ETHIOPIC_UTC.year(); DateTimeField yearOfEra = ETHIOPIC_UTC.yearOfEra(); DateTimeField era = ETHIOPIC_UTC.era(); int expectedDOW = new DateTime(8, 8, 29, 0, 0, 0, 0, JULIAN_UTC).getDayOfWeek(); int expectedDOY = 1; int expectedDay = 1; int expectedMonth = 1; int expectedYear = 1; while (millis < end) { int dowValue = dayOfWeek.get(millis); int doyValue = dayOfYear.get(millis); int dayValue = dayOfMonth.get(millis); int monthValue = monthOfYear.get(millis); int yearValue = year.get(millis); int yearOfEraValue = yearOfEra.get(millis); int monthLen = dayOfMonth.getMaximumValue(millis); if (monthValue < 1 || monthValue > 13) { fail("Bad month: " + millis); } // test era assertEquals(1, era.get(millis)); assertEquals("EE", era.getAsText(millis)); assertEquals("EE", era.getAsShortText(millis)); // test date assertEquals(expectedYear, yearValue); assertEquals(expectedYear, yearOfEraValue); assertEquals(expectedMonth, monthValue); assertEquals(expectedDay, dayValue); assertEquals(expectedDOW, dowValue); assertEquals(expectedDOY, doyValue); // test leap year assertEquals(yearValue % 4 == 3, year.isLeap(millis)); // test month length if (monthValue == 13) { assertEquals(yearValue % 4 == 3, monthOfYear.isLeap(millis)); if (yearValue % 4 == 3) { assertEquals(6, monthLen); } else { assertEquals(5, monthLen); } } else { assertEquals(30, monthLen); } // recalculate date expectedDOW = (((expectedDOW + 1) - 1) % 7) + 1; expectedDay++; expectedDOY++; if (expectedDay == 31 && expectedMonth < 13) { expectedDay = 1; expectedMonth++; } else if (expectedMonth == 13) { if (expectedYear % 4 == 3 && expectedDay == 7) { expectedDay = 1; expectedMonth = 1; expectedYear++; expectedDOY = 1; } else if (expectedYear % 4 != 3 && expectedDay == 6) { expectedDay = 1; expectedMonth = 1; expectedYear++; expectedDOY = 1; } } millis += SKIP; } } public void testSampleDate() { DateTime dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, ISO_UTC).withChronology(ETHIOPIC_UTC); assertEquals(EthiopicChronology.EE, dt.getEra()); assertEquals(20, dt.getCenturyOfEra()); // TODO confirm assertEquals(96, dt.getYearOfCentury()); assertEquals(1996, dt.getYearOfEra()); assertEquals(1996, dt.getYear()); Property fld = dt.year(); assertEquals(false, fld.isLeap()); assertEquals(0, fld.getLeapAmount()); assertEquals(DurationFieldType.days(), fld.getLeapDurationField().getType()); assertEquals(new DateTime(1997, 10, 2, 0, 0, 0, 0, ETHIOPIC_UTC), fld.addToCopy(1)); assertEquals(10, dt.getMonthOfYear()); fld = dt.monthOfYear(); assertEquals(false, fld.isLeap()); assertEquals(0, fld.getLeapAmount()); assertEquals(DurationFieldType.days(), fld.getLeapDurationField().getType()); assertEquals(1, fld.getMinimumValue()); assertEquals(1, fld.getMinimumValueOverall()); assertEquals(13, fld.getMaximumValue()); assertEquals(13, fld.getMaximumValueOverall()); assertEquals(new DateTime(1997, 1, 2, 0, 0, 0, 0, ETHIOPIC_UTC), fld.addToCopy(4)); assertEquals(new DateTime(1996, 1, 2, 0, 0, 0, 0, ETHIOPIC_UTC), fld.addWrapFieldToCopy(4)); assertEquals(2, dt.getDayOfMonth()); fld = dt.dayOfMonth(); assertEquals(false, fld.isLeap()); assertEquals(0, fld.getLeapAmount()); assertEquals(null, fld.getLeapDurationField()); assertEquals(1, fld.getMinimumValue()); assertEquals(1, fld.getMinimumValueOverall()); assertEquals(30, fld.getMaximumValue()); assertEquals(30, fld.getMaximumValueOverall()); assertEquals(new DateTime(1996, 10, 3, 0, 0, 0, 0, ETHIOPIC_UTC), fld.addToCopy(1)); assertEquals(DateTimeConstants.WEDNESDAY, dt.getDayOfWeek()); fld = dt.dayOfWeek(); assertEquals(false, fld.isLeap()); assertEquals(0, fld.getLeapAmount()); assertEquals(null, fld.getLeapDurationField()); assertEquals(1, fld.getMinimumValue()); assertEquals(1, fld.getMinimumValueOverall()); assertEquals(7, fld.getMaximumValue()); assertEquals(7, fld.getMaximumValueOverall()); assertEquals(new DateTime(1996, 10, 3, 0, 0, 0, 0, ETHIOPIC_UTC), fld.addToCopy(1)); assertEquals(9 * 30 + 2, dt.getDayOfYear()); fld = dt.dayOfYear(); assertEquals(false, fld.isLeap()); assertEquals(0, fld.getLeapAmount()); assertEquals(null, fld.getLeapDurationField()); assertEquals(1, fld.getMinimumValue()); assertEquals(1, fld.getMinimumValueOverall()); assertEquals(365, fld.getMaximumValue()); assertEquals(366, fld.getMaximumValueOverall()); assertEquals(new DateTime(1996, 10, 3, 0, 0, 0, 0, ETHIOPIC_UTC), fld.addToCopy(1)); assertEquals(0, dt.getHourOfDay()); assertEquals(0, dt.getMinuteOfHour()); assertEquals(0, dt.getSecondOfMinute()); assertEquals(0, dt.getMillisOfSecond()); } public void testSampleDateWithZone() { DateTime dt = new DateTime(2004, 6, 9, 12, 0, 0, 0, PARIS).withChronology(ETHIOPIC_UTC); assertEquals(EthiopicChronology.EE, dt.getEra()); assertEquals(1996, dt.getYear()); assertEquals(1996, dt.getYearOfEra()); assertEquals(10, dt.getMonthOfYear()); assertEquals(2, dt.getDayOfMonth()); assertEquals(10, dt.getHourOfDay()); // PARIS is UTC+2 in summer (12-2=10) assertEquals(0, dt.getMinuteOfHour()); assertEquals(0, dt.getSecondOfMinute()); assertEquals(0, dt.getMillisOfSecond()); } public void testDurationYear() { // Leap 1999, NotLeap 1996,97,98 DateTime dt96 = new DateTime(1996, 10, 2, 0, 0, 0, 0, ETHIOPIC_UTC); DateTime dt97 = new DateTime(1997, 10, 2, 0, 0, 0, 0, ETHIOPIC_UTC); DateTime dt98 = new DateTime(1998, 10, 2, 0, 0, 0, 0, ETHIOPIC_UTC); DateTime dt99 = new DateTime(1999, 10, 2, 0, 0, 0, 0, ETHIOPIC_UTC); DateTime dt00 = new DateTime(2000, 10, 2, 0, 0, 0, 0, ETHIOPIC_UTC); DurationField fld = dt96.year().getDurationField(); assertEquals(ETHIOPIC_UTC.years(), fld); assertEquals(1L * 365L * MILLIS_PER_DAY, fld.getMillis(1, dt96.getMillis())); assertEquals(2L * 365L * MILLIS_PER_DAY, fld.getMillis(2, dt96.getMillis())); assertEquals(3L * 365L * MILLIS_PER_DAY, fld.getMillis(3, dt96.getMillis())); assertEquals((4L * 365L + 1L) * MILLIS_PER_DAY, fld.getMillis(4, dt96.getMillis())); assertEquals(((4L * 365L + 1L) * MILLIS_PER_DAY) / 4, fld.getMillis(1)); assertEquals(((4L * 365L + 1L) * MILLIS_PER_DAY) / 2, fld.getMillis(2)); assertEquals(1L * 365L * MILLIS_PER_DAY, fld.getMillis(1L, dt96.getMillis())); assertEquals(2L * 365L * MILLIS_PER_DAY, fld.getMillis(2L, dt96.getMillis())); assertEquals(3L * 365L * MILLIS_PER_DAY, fld.getMillis(3L, dt96.getMillis())); assertEquals((4L * 365L + 1L) * MILLIS_PER_DAY, fld.getMillis(4L, dt96.getMillis())); assertEquals(((4L * 365L + 1L) * MILLIS_PER_DAY) / 4, fld.getMillis(1L)); assertEquals(((4L * 365L + 1L) * MILLIS_PER_DAY) / 2, fld.getMillis(2L)); assertEquals(((4L * 365L + 1L) * MILLIS_PER_DAY) / 4, fld.getUnitMillis()); assertEquals(0, fld.getValue(1L * 365L * MILLIS_PER_DAY - 1L, dt96.getMillis())); assertEquals(1, fld.getValue(1L * 365L * MILLIS_PER_DAY, dt96.getMillis())); assertEquals(1, fld.getValue(1L * 365L * MILLIS_PER_DAY + 1L, dt96.getMillis())); assertEquals(1, fld.getValue(2L * 365L * MILLIS_PER_DAY - 1L, dt96.getMillis())); assertEquals(2, fld.getValue(2L * 365L * MILLIS_PER_DAY, dt96.getMillis())); assertEquals(2, fld.getValue(2L * 365L * MILLIS_PER_DAY + 1L, dt96.getMillis())); assertEquals(2, fld.getValue(3L * 365L * MILLIS_PER_DAY - 1L, dt96.getMillis())); assertEquals(3, fld.getValue(3L * 365L * MILLIS_PER_DAY, dt96.getMillis())); assertEquals(3, fld.getValue(3L * 365L * MILLIS_PER_DAY + 1L, dt96.getMillis())); assertEquals(3, fld.getValue((4L * 365L + 1L) * MILLIS_PER_DAY - 1L, dt96.getMillis())); assertEquals(4, fld.getValue((4L * 365L + 1L) * MILLIS_PER_DAY, dt96.getMillis())); assertEquals(4, fld.getValue((4L * 365L + 1L) * MILLIS_PER_DAY + 1L, dt96.getMillis())); assertEquals(dt97.getMillis(), fld.add(dt96.getMillis(), 1)); assertEquals(dt98.getMillis(), fld.add(dt96.getMillis(), 2)); assertEquals(dt99.getMillis(), fld.add(dt96.getMillis(), 3)); assertEquals(dt00.getMillis(), fld.add(dt96.getMillis(), 4)); assertEquals(dt97.getMillis(), fld.add(dt96.getMillis(), 1L)); assertEquals(dt98.getMillis(), fld.add(dt96.getMillis(), 2L)); assertEquals(dt99.getMillis(), fld.add(dt96.getMillis(), 3L)); assertEquals(dt00.getMillis(), fld.add(dt96.getMillis(), 4L)); } public void testDurationMonth() { // Leap 1999, NotLeap 1996,97,98 DateTime dt11 = new DateTime(1999, 11, 2, 0, 0, 0, 0, ETHIOPIC_UTC); DateTime dt12 = new DateTime(1999, 12, 2, 0, 0, 0, 0, ETHIOPIC_UTC); DateTime dt13 = new DateTime(1999, 13, 2, 0, 0, 0, 0, ETHIOPIC_UTC); DateTime dt01 = new DateTime(2000, 1, 2, 0, 0, 0, 0, ETHIOPIC_UTC); DurationField fld = dt11.monthOfYear().getDurationField(); assertEquals(ETHIOPIC_UTC.months(), fld); assertEquals(1L * 30L * MILLIS_PER_DAY, fld.getMillis(1, dt11.getMillis())); assertEquals(2L * 30L * MILLIS_PER_DAY, fld.getMillis(2, dt11.getMillis())); assertEquals((2L * 30L + 6L) * MILLIS_PER_DAY, fld.getMillis(3, dt11.getMillis())); assertEquals((3L * 30L + 6L) * MILLIS_PER_DAY, fld.getMillis(4, dt11.getMillis())); assertEquals(1L * 30L * MILLIS_PER_DAY, fld.getMillis(1)); assertEquals(2L * 30L * MILLIS_PER_DAY, fld.getMillis(2)); assertEquals(13L * 30L * MILLIS_PER_DAY, fld.getMillis(13)); assertEquals(1L * 30L * MILLIS_PER_DAY, fld.getMillis(1L, dt11.getMillis())); assertEquals(2L * 30L * MILLIS_PER_DAY, fld.getMillis(2L, dt11.getMillis())); assertEquals((2L * 30L + 6L) * MILLIS_PER_DAY, fld.getMillis(3L, dt11.getMillis())); assertEquals((3L * 30L + 6L) * MILLIS_PER_DAY, fld.getMillis(4L, dt11.getMillis())); assertEquals(1L * 30L * MILLIS_PER_DAY, fld.getMillis(1L)); assertEquals(2L * 30L * MILLIS_PER_DAY, fld.getMillis(2L)); assertEquals(13L * 30L * MILLIS_PER_DAY, fld.getMillis(13L)); assertEquals(0, fld.getValue(1L * 30L * MILLIS_PER_DAY - 1L, dt11.getMillis())); assertEquals(1, fld.getValue(1L * 30L * MILLIS_PER_DAY, dt11.getMillis())); assertEquals(1, fld.getValue(1L * 30L * MILLIS_PER_DAY + 1L, dt11.getMillis())); assertEquals(1, fld.getValue(2L * 30L * MILLIS_PER_DAY - 1L, dt11.getMillis())); assertEquals(2, fld.getValue(2L * 30L * MILLIS_PER_DAY, dt11.getMillis())); assertEquals(2, fld.getValue(2L * 30L * MILLIS_PER_DAY + 1L, dt11.getMillis())); assertEquals(2, fld.getValue((2L * 30L + 6L) * MILLIS_PER_DAY - 1L, dt11.getMillis())); assertEquals(3, fld.getValue((2L * 30L + 6L) * MILLIS_PER_DAY, dt11.getMillis())); assertEquals(3, fld.getValue((2L * 30L + 6L) * MILLIS_PER_DAY + 1L, dt11.getMillis())); assertEquals(3, fld.getValue((3L * 30L + 6L) * MILLIS_PER_DAY - 1L, dt11.getMillis())); assertEquals(4, fld.getValue((3L * 30L + 6L) * MILLIS_PER_DAY, dt11.getMillis())); assertEquals(4, fld.getValue((3L * 30L + 6L) * MILLIS_PER_DAY + 1L, dt11.getMillis())); assertEquals(dt12.getMillis(), fld.add(dt11.getMillis(), 1)); assertEquals(dt13.getMillis(), fld.add(dt11.getMillis(), 2)); assertEquals(dt01.getMillis(), fld.add(dt11.getMillis(), 3)); assertEquals(dt12.getMillis(), fld.add(dt11.getMillis(), 1L)); assertEquals(dt13.getMillis(), fld.add(dt11.getMillis(), 2L)); assertEquals(dt01.getMillis(), fld.add(dt11.getMillis(), 3L)); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.chrono; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.DateMidnight; import org.joda.time.DateTime; import org.joda.time.DateTimeConstants; import org.joda.time.DateTimeUtils; import org.joda.time.DateTimeZone; import org.joda.time.DurationField; import org.joda.time.DurationFieldType; import org.joda.time.IllegalFieldValueException; import org.joda.time.Instant; import org.joda.time.Period; import org.joda.time.TimeOfDay; import org.joda.time.YearMonthDay; /** * This class is a Junit unit test for GJChronology. * * @author Stephen Colebourne */ @SuppressWarnings("deprecation") public class TestGJChronology extends TestCase { private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestGJChronology.class); } public TestGJChronology(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testFactoryUTC() { assertEquals(DateTimeZone.UTC, GJChronology.getInstanceUTC().getZone()); assertSame(GJChronology.class, GJChronology.getInstanceUTC().getClass()); } public void testFactory() { assertEquals(LONDON, GJChronology.getInstance().getZone()); assertSame(GJChronology.class, GJChronology.getInstance().getClass()); } public void testFactory_Zone() { assertEquals(TOKYO, GJChronology.getInstance(TOKYO).getZone()); assertEquals(PARIS, GJChronology.getInstance(PARIS).getZone()); assertEquals(LONDON, GJChronology.getInstance(null).getZone()); assertSame(GJChronology.class, GJChronology.getInstance(TOKYO).getClass()); } public void testFactory_Zone_long_int() { GJChronology chrono = GJChronology.getInstance(TOKYO, 0L, 2); assertEquals(TOKYO, chrono.getZone()); assertEquals(new Instant(0L), chrono.getGregorianCutover()); assertEquals(2, chrono.getMinimumDaysInFirstWeek()); assertSame(GJChronology.class, GJChronology.getInstance(TOKYO, 0L, 2).getClass()); try { GJChronology.getInstance(TOKYO, 0L, 0); fail(); } catch (IllegalArgumentException ex) {} try { GJChronology.getInstance(TOKYO, 0L, 8); fail(); } catch (IllegalArgumentException ex) {} } public void testFactory_Zone_RI() { GJChronology chrono = GJChronology.getInstance(TOKYO, new Instant(0L)); assertEquals(TOKYO, chrono.getZone()); assertEquals(new Instant(0L), chrono.getGregorianCutover()); assertSame(GJChronology.class, GJChronology.getInstance(TOKYO, new Instant(0L)).getClass()); DateTime cutover = new DateTime(1582, 10, 15, 0, 0, 0, 0, DateTimeZone.UTC); chrono = GJChronology.getInstance(TOKYO, null); assertEquals(TOKYO, chrono.getZone()); assertEquals(cutover.toInstant(), chrono.getGregorianCutover()); } public void testFactory_Zone_RI_int() { GJChronology chrono = GJChronology.getInstance(TOKYO, new Instant(0L), 2); assertEquals(TOKYO, chrono.getZone()); assertEquals(new Instant(0L), chrono.getGregorianCutover()); assertEquals(2, chrono.getMinimumDaysInFirstWeek()); assertSame(GJChronology.class, GJChronology.getInstance(TOKYO, new Instant(0L), 2).getClass()); DateTime cutover = new DateTime(1582, 10, 15, 0, 0, 0, 0, DateTimeZone.UTC); chrono = GJChronology.getInstance(TOKYO, null, 2); assertEquals(TOKYO, chrono.getZone()); assertEquals(cutover.toInstant(), chrono.getGregorianCutover()); assertEquals(2, chrono.getMinimumDaysInFirstWeek()); try { GJChronology.getInstance(TOKYO, new Instant(0L), 0); fail(); } catch (IllegalArgumentException ex) {} try { GJChronology.getInstance(TOKYO, new Instant(0L), 8); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testEquality() { assertSame(GJChronology.getInstance(TOKYO), GJChronology.getInstance(TOKYO)); assertSame(GJChronology.getInstance(LONDON), GJChronology.getInstance(LONDON)); assertSame(GJChronology.getInstance(PARIS), GJChronology.getInstance(PARIS)); assertSame(GJChronology.getInstanceUTC(), GJChronology.getInstanceUTC()); assertSame(GJChronology.getInstance(), GJChronology.getInstance(LONDON)); } public void testWithUTC() { assertSame(GJChronology.getInstanceUTC(), GJChronology.getInstance(LONDON).withUTC()); assertSame(GJChronology.getInstanceUTC(), GJChronology.getInstance(TOKYO).withUTC()); assertSame(GJChronology.getInstanceUTC(), GJChronology.getInstanceUTC().withUTC()); assertSame(GJChronology.getInstanceUTC(), GJChronology.getInstance().withUTC()); } public void testWithZone() { assertSame(GJChronology.getInstance(TOKYO), GJChronology.getInstance(TOKYO).withZone(TOKYO)); assertSame(GJChronology.getInstance(LONDON), GJChronology.getInstance(TOKYO).withZone(LONDON)); assertSame(GJChronology.getInstance(PARIS), GJChronology.getInstance(TOKYO).withZone(PARIS)); assertSame(GJChronology.getInstance(LONDON), GJChronology.getInstance(TOKYO).withZone(null)); assertSame(GJChronology.getInstance(PARIS), GJChronology.getInstance().withZone(PARIS)); assertSame(GJChronology.getInstance(PARIS), GJChronology.getInstanceUTC().withZone(PARIS)); } public void testToString() { assertEquals("GJChronology[Europe/London]", GJChronology.getInstance(LONDON).toString()); assertEquals("GJChronology[Asia/Tokyo]", GJChronology.getInstance(TOKYO).toString()); assertEquals("GJChronology[Europe/London]", GJChronology.getInstance().toString()); assertEquals("GJChronology[UTC]", GJChronology.getInstanceUTC().toString()); assertEquals("GJChronology[UTC,cutover=1970-01-01]", GJChronology.getInstance(DateTimeZone.UTC, 0L, 4).toString()); assertEquals("GJChronology[UTC,cutover=1970-01-01T00:00:00.001Z,mdfw=2]", GJChronology.getInstance(DateTimeZone.UTC, 1L, 2).toString()); } //----------------------------------------------------------------------- public void testDurationFields() { final GJChronology gj = GJChronology.getInstance(); assertEquals("eras", gj.eras().getName()); assertEquals("centuries", gj.centuries().getName()); assertEquals("years", gj.years().getName()); assertEquals("weekyears", gj.weekyears().getName()); assertEquals("months", gj.months().getName()); assertEquals("weeks", gj.weeks().getName()); assertEquals("halfdays", gj.halfdays().getName()); assertEquals("days", gj.days().getName()); assertEquals("hours", gj.hours().getName()); assertEquals("minutes", gj.minutes().getName()); assertEquals("seconds", gj.seconds().getName()); assertEquals("millis", gj.millis().getName()); assertEquals(false, gj.eras().isSupported()); assertEquals(true, gj.centuries().isSupported()); assertEquals(true, gj.years().isSupported()); assertEquals(true, gj.weekyears().isSupported()); assertEquals(true, gj.months().isSupported()); assertEquals(true, gj.weeks().isSupported()); assertEquals(true, gj.days().isSupported()); assertEquals(true, gj.halfdays().isSupported()); assertEquals(true, gj.hours().isSupported()); assertEquals(true, gj.minutes().isSupported()); assertEquals(true, gj.seconds().isSupported()); assertEquals(true, gj.millis().isSupported()); assertEquals(false, gj.centuries().isPrecise()); assertEquals(false, gj.years().isPrecise()); assertEquals(false, gj.weekyears().isPrecise()); assertEquals(false, gj.months().isPrecise()); assertEquals(false, gj.weeks().isPrecise()); assertEquals(false, gj.days().isPrecise()); assertEquals(false, gj.halfdays().isPrecise()); assertEquals(true, gj.hours().isPrecise()); assertEquals(true, gj.minutes().isPrecise()); assertEquals(true, gj.seconds().isPrecise()); assertEquals(true, gj.millis().isPrecise()); final GJChronology gjUTC = GJChronology.getInstanceUTC(); assertEquals(false, gjUTC.centuries().isPrecise()); assertEquals(false, gjUTC.years().isPrecise()); assertEquals(false, gjUTC.weekyears().isPrecise()); assertEquals(false, gjUTC.months().isPrecise()); assertEquals(true, gjUTC.weeks().isPrecise()); assertEquals(true, gjUTC.days().isPrecise()); assertEquals(true, gjUTC.halfdays().isPrecise()); assertEquals(true, gjUTC.hours().isPrecise()); assertEquals(true, gjUTC.minutes().isPrecise()); assertEquals(true, gjUTC.seconds().isPrecise()); assertEquals(true, gjUTC.millis().isPrecise()); final DateTimeZone gmt = DateTimeZone.forID("Etc/GMT"); final GJChronology gjGMT = GJChronology.getInstance(gmt); assertEquals(false, gjGMT.centuries().isPrecise()); assertEquals(false, gjGMT.years().isPrecise()); assertEquals(false, gjGMT.weekyears().isPrecise()); assertEquals(false, gjGMT.months().isPrecise()); assertEquals(true, gjGMT.weeks().isPrecise()); assertEquals(true, gjGMT.days().isPrecise()); assertEquals(true, gjGMT.halfdays().isPrecise()); assertEquals(true, gjGMT.hours().isPrecise()); assertEquals(true, gjGMT.minutes().isPrecise()); assertEquals(true, gjGMT.seconds().isPrecise()); assertEquals(true, gjGMT.millis().isPrecise()); } public void testDateFields() { final GJChronology gj = GJChronology.getInstance(); assertEquals("era", gj.era().getName()); assertEquals("centuryOfEra", gj.centuryOfEra().getName()); assertEquals("yearOfCentury", gj.yearOfCentury().getName()); assertEquals("yearOfEra", gj.yearOfEra().getName()); assertEquals("year", gj.year().getName()); assertEquals("monthOfYear", gj.monthOfYear().getName()); assertEquals("weekyearOfCentury", gj.weekyearOfCentury().getName()); assertEquals("weekyear", gj.weekyear().getName()); assertEquals("weekOfWeekyear", gj.weekOfWeekyear().getName()); assertEquals("dayOfYear", gj.dayOfYear().getName()); assertEquals("dayOfMonth", gj.dayOfMonth().getName()); assertEquals("dayOfWeek", gj.dayOfWeek().getName()); assertEquals(true, gj.era().isSupported()); assertEquals(true, gj.centuryOfEra().isSupported()); assertEquals(true, gj.yearOfCentury().isSupported()); assertEquals(true, gj.yearOfEra().isSupported()); assertEquals(true, gj.year().isSupported()); assertEquals(true, gj.monthOfYear().isSupported()); assertEquals(true, gj.weekyearOfCentury().isSupported()); assertEquals(true, gj.weekyear().isSupported()); assertEquals(true, gj.weekOfWeekyear().isSupported()); assertEquals(true, gj.dayOfYear().isSupported()); assertEquals(true, gj.dayOfMonth().isSupported()); assertEquals(true, gj.dayOfWeek().isSupported()); assertEquals(gj.eras(), gj.era().getDurationField()); assertEquals(gj.centuries(), gj.centuryOfEra().getDurationField()); assertEquals(gj.years(), gj.yearOfCentury().getDurationField()); assertEquals(gj.years(), gj.yearOfEra().getDurationField()); assertEquals(gj.years(), gj.year().getDurationField()); assertEquals(gj.months(), gj.monthOfYear().getDurationField()); assertEquals(gj.weekyears(), gj.weekyearOfCentury().getDurationField()); assertEquals(gj.weekyears(), gj.weekyear().getDurationField()); assertEquals(gj.weeks(), gj.weekOfWeekyear().getDurationField()); assertEquals(gj.days(), gj.dayOfYear().getDurationField()); assertEquals(gj.days(), gj.dayOfMonth().getDurationField()); assertEquals(gj.days(), gj.dayOfWeek().getDurationField()); assertEquals(null, gj.era().getRangeDurationField()); assertEquals(gj.eras(), gj.centuryOfEra().getRangeDurationField()); assertEquals(gj.centuries(), gj.yearOfCentury().getRangeDurationField()); assertEquals(gj.eras(), gj.yearOfEra().getRangeDurationField()); assertEquals(null, gj.year().getRangeDurationField()); assertEquals(gj.years(), gj.monthOfYear().getRangeDurationField()); assertEquals(gj.centuries(), gj.weekyearOfCentury().getRangeDurationField()); assertEquals(null, gj.weekyear().getRangeDurationField()); assertEquals(gj.weekyears(), gj.weekOfWeekyear().getRangeDurationField()); assertEquals(gj.years(), gj.dayOfYear().getRangeDurationField()); assertEquals(gj.months(), gj.dayOfMonth().getRangeDurationField()); assertEquals(gj.weeks(), gj.dayOfWeek().getRangeDurationField()); } public void testTimeFields() { final GJChronology gj = GJChronology.getInstance(); assertEquals("halfdayOfDay", gj.halfdayOfDay().getName()); assertEquals("clockhourOfHalfday", gj.clockhourOfHalfday().getName()); assertEquals("hourOfHalfday", gj.hourOfHalfday().getName()); assertEquals("clockhourOfDay", gj.clockhourOfDay().getName()); assertEquals("hourOfDay", gj.hourOfDay().getName()); assertEquals("minuteOfDay", gj.minuteOfDay().getName()); assertEquals("minuteOfHour", gj.minuteOfHour().getName()); assertEquals("secondOfDay", gj.secondOfDay().getName()); assertEquals("secondOfMinute", gj.secondOfMinute().getName()); assertEquals("millisOfDay", gj.millisOfDay().getName()); assertEquals("millisOfSecond", gj.millisOfSecond().getName()); assertEquals(true, gj.halfdayOfDay().isSupported()); assertEquals(true, gj.clockhourOfHalfday().isSupported()); assertEquals(true, gj.hourOfHalfday().isSupported()); assertEquals(true, gj.clockhourOfDay().isSupported()); assertEquals(true, gj.hourOfDay().isSupported()); assertEquals(true, gj.minuteOfDay().isSupported()); assertEquals(true, gj.minuteOfHour().isSupported()); assertEquals(true, gj.secondOfDay().isSupported()); assertEquals(true, gj.secondOfMinute().isSupported()); assertEquals(true, gj.millisOfDay().isSupported()); assertEquals(true, gj.millisOfSecond().isSupported()); } public void testIllegalDates() { try { new DateTime(1582, 10, 5, 0, 0, 0, 0, GJChronology.getInstance(DateTimeZone.UTC)); fail("Constructed illegal date"); } catch (IllegalArgumentException e) { /* good */ } try { new DateTime(1582, 10, 14, 0, 0, 0, 0, GJChronology.getInstance(DateTimeZone.UTC)); fail("Constructed illegal date"); } catch (IllegalArgumentException e) { /* good */ } } public void testParseEquivalence() { testParse("1581-01-01T01:23:45.678", 1581, 1, 1, 1, 23, 45, 678); testParse("1581-06-30", 1581, 6, 30, 0, 0, 0, 0); testParse("1582-01-01T01:23:45.678", 1582, 1, 1, 1, 23, 45, 678); testParse("1582-06-30T01:23:45.678", 1582, 6, 30, 1, 23, 45, 678); testParse("1582-10-04", 1582, 10, 4, 0, 0, 0, 0); testParse("1582-10-15", 1582, 10, 15, 0, 0, 0, 0); testParse("1582-12-31", 1582, 12, 31, 0, 0, 0, 0); testParse("1583-12-31", 1583, 12, 31, 0, 0, 0, 0); } private void testParse(String str, int year, int month, int day, int hour, int minute, int second, int millis) { assertEquals(new DateTime(str, GJChronology.getInstance(DateTimeZone.UTC)), new DateTime(year, month, day, hour, minute, second, millis, GJChronology.getInstance(DateTimeZone.UTC))); } public void testCutoverAddYears() { testAdd("1582-01-01", DurationFieldType.years(), 1, "1583-01-01"); testAdd("1582-02-15", DurationFieldType.years(), 1, "1583-02-15"); testAdd("1582-02-28", DurationFieldType.years(), 1, "1583-02-28"); testAdd("1582-03-01", DurationFieldType.years(), 1, "1583-03-01"); testAdd("1582-09-30", DurationFieldType.years(), 1, "1583-09-30"); testAdd("1582-10-01", DurationFieldType.years(), 1, "1583-10-01"); testAdd("1582-10-04", DurationFieldType.years(), 1, "1583-10-04"); testAdd("1582-10-15", DurationFieldType.years(), 1, "1583-10-15"); testAdd("1582-10-16", DurationFieldType.years(), 1, "1583-10-16"); // Leap years... testAdd("1580-01-01", DurationFieldType.years(), 4, "1584-01-01"); testAdd("1580-02-29", DurationFieldType.years(), 4, "1584-02-29"); testAdd("1580-10-01", DurationFieldType.years(), 4, "1584-10-01"); testAdd("1580-10-10", DurationFieldType.years(), 4, "1584-10-10"); testAdd("1580-10-15", DurationFieldType.years(), 4, "1584-10-15"); testAdd("1580-12-31", DurationFieldType.years(), 4, "1584-12-31"); } public void testCutoverAddWeekyears() { testAdd("1582-W01-1", DurationFieldType.weekyears(), 1, "1583-W01-1"); testAdd("1582-W39-1", DurationFieldType.weekyears(), 1, "1583-W39-1"); testAdd("1583-W45-1", DurationFieldType.weekyears(), 1, "1584-W45-1"); // This test fails, but I'm not sure if its worth fixing. The date // falls after the cutover, but in the cutover year. The add operation // is performed completely within the gregorian calendar, with no // crossing of the cutover. As a result, no special correction is // applied. Since the full gregorian year of 1582 has a different week // numbers than the full julian year of 1582, the week number is off by // one after the addition. // //testAdd("1582-W42-1", DurationFieldType.weekyears(), 1, "1583-W42-1"); // Leap years... testAdd("1580-W01-1", DurationFieldType.weekyears(), 4, "1584-W01-1"); testAdd("1580-W30-7", DurationFieldType.weekyears(), 4, "1584-W30-7"); testAdd("1580-W50-7", DurationFieldType.weekyears(), 4, "1584-W50-7"); } public void testCutoverAddMonths() { testAdd("1582-01-01", DurationFieldType.months(), 1, "1582-02-01"); testAdd("1582-01-01", DurationFieldType.months(), 6, "1582-07-01"); testAdd("1582-01-01", DurationFieldType.months(), 12, "1583-01-01"); testAdd("1582-11-15", DurationFieldType.months(), 1, "1582-12-15"); testAdd("1582-09-04", DurationFieldType.months(), 2, "1582-11-04"); testAdd("1582-09-05", DurationFieldType.months(), 2, "1582-11-05"); testAdd("1582-09-10", DurationFieldType.months(), 2, "1582-11-10"); testAdd("1582-09-15", DurationFieldType.months(), 2, "1582-11-15"); // Leap years... testAdd("1580-01-01", DurationFieldType.months(), 48, "1584-01-01"); testAdd("1580-02-29", DurationFieldType.months(), 48, "1584-02-29"); testAdd("1580-10-01", DurationFieldType.months(), 48, "1584-10-01"); testAdd("1580-10-10", DurationFieldType.months(), 48, "1584-10-10"); testAdd("1580-10-15", DurationFieldType.months(), 48, "1584-10-15"); testAdd("1580-12-31", DurationFieldType.months(), 48, "1584-12-31"); } public void testCutoverAddWeeks() { testAdd("1582-01-01", DurationFieldType.weeks(), 1, "1582-01-08"); testAdd("1583-01-01", DurationFieldType.weeks(), 1, "1583-01-08"); // Weeks are precise, and so cutover is not ignored. testAdd("1582-10-01", DurationFieldType.weeks(), 2, "1582-10-25"); testAdd("1582-W01-1", DurationFieldType.weeks(), 51, "1583-W01-1"); } public void testCutoverAddDays() { testAdd("1582-10-03", DurationFieldType.days(), 1, "1582-10-04"); testAdd("1582-10-04", DurationFieldType.days(), 1, "1582-10-15"); testAdd("1582-10-15", DurationFieldType.days(), 1, "1582-10-16"); testAdd("1582-09-30", DurationFieldType.days(), 10, "1582-10-20"); testAdd("1582-10-04", DurationFieldType.days(), 10, "1582-10-24"); testAdd("1582-10-15", DurationFieldType.days(), 10, "1582-10-25"); } public void testYearEndAddDays() { testAdd("1582-11-05", DurationFieldType.days(), 28, "1582-12-03"); testAdd("1582-12-05", DurationFieldType.days(), 28, "1583-01-02"); testAdd("2005-11-05", DurationFieldType.days(), 28, "2005-12-03"); testAdd("2005-12-05", DurationFieldType.days(), 28, "2006-01-02"); } public void testSubtractDays() { // This is a test for a bug in version 1.0. The dayOfMonth range // duration field did not match the monthOfYear duration field. This // caused an exception to be thrown when subtracting days. DateTime dt = new DateTime (1112306400000L, GJChronology.getInstance(DateTimeZone.forID("Europe/Berlin"))); YearMonthDay ymd = dt.toYearMonthDay(); while (ymd.toDateTimeAtMidnight().getDayOfWeek() != DateTimeConstants.MONDAY) { ymd = ymd.minus(Period.days(1)); } } private void testAdd(String start, DurationFieldType type, int amt, String end) { DateTime dtStart = new DateTime(start, GJChronology.getInstance(DateTimeZone.UTC)); DateTime dtEnd = new DateTime(end, GJChronology.getInstance(DateTimeZone.UTC)); assertEquals(dtEnd, dtStart.withFieldAdded(type, amt)); assertEquals(dtStart, dtEnd.withFieldAdded(type, -amt)); DurationField field = type.getField(GJChronology.getInstance(DateTimeZone.UTC)); int diff = field.getDifference(dtEnd.getMillis(), dtStart.getMillis()); assertEquals(amt, diff); if (type == DurationFieldType.years() || type == DurationFieldType.months() || type == DurationFieldType.days()) { YearMonthDay ymdStart = new YearMonthDay(start, GJChronology.getInstance(DateTimeZone.UTC)); YearMonthDay ymdEnd = new YearMonthDay(end, GJChronology.getInstance(DateTimeZone.UTC)); assertEquals(ymdEnd, ymdStart.withFieldAdded(type, amt)); assertEquals(ymdStart, ymdEnd.withFieldAdded(type, -amt)); } } public void testTimeOfDayAdd() { TimeOfDay start = new TimeOfDay(12, 30, GJChronology.getInstance()); TimeOfDay end = new TimeOfDay(10, 30, GJChronology.getInstance()); assertEquals(end, start.plusHours(22)); assertEquals(start, end.minusHours(22)); assertEquals(end, start.plusMinutes(22 * 60)); assertEquals(start, end.minusMinutes(22 * 60)); } public void testMaximumValue() { DateMidnight dt = new DateMidnight(1570, 1, 1, GJChronology.getInstance()); while (dt.getYear() < 1590) { dt = dt.plusDays(1); YearMonthDay ymd = dt.toYearMonthDay(); assertEquals(dt.year().getMaximumValue(), ymd.year().getMaximumValue()); assertEquals(dt.monthOfYear().getMaximumValue(), ymd.monthOfYear().getMaximumValue()); assertEquals(dt.dayOfMonth().getMaximumValue(), ymd.dayOfMonth().getMaximumValue()); } } public void testPartialGetAsText() { GJChronology chrono = GJChronology.getInstance(TOKYO); assertEquals("January", new YearMonthDay("2005-01-01", chrono).monthOfYear().getAsText()); assertEquals("Jan", new YearMonthDay("2005-01-01", chrono).monthOfYear().getAsShortText()); } public void testLeapYearRulesConstruction() { // 1500 not leap in Gregorian, but is leap in Julian DateMidnight dt = new DateMidnight(1500, 2, 29, GJChronology.getInstanceUTC()); assertEquals(dt.getYear(), 1500); assertEquals(dt.getMonthOfYear(), 2); assertEquals(dt.getDayOfMonth(), 29); } public void testLeapYearRulesConstructionInvalid() { // 1500 not leap in Gregorian, but is leap in Julian try { new DateMidnight(1500, 2, 30, GJChronology.getInstanceUTC()); fail(); } catch (IllegalFieldValueException ex) { // good } } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.chrono; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.Chronology; import org.joda.time.DateTime; import org.joda.time.DateTimeZone; import org.joda.time.LocalDate; /** * Test. */ public class TestGJDate extends TestCase { public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestGJDate.class); } public TestGJDate(String name) { super(name); } protected void setUp() throws Exception { } protected void tearDown() throws Exception { } //----------------------------------------------------------------------- private static final Chronology GJ_CHRONOLOGY = GJChronology.getInstanceUTC(); //----------------------------------------------------------------------- public void test_plusYears_positiveToPositive() { LocalDate date = new LocalDate(3, 6, 30, GJ_CHRONOLOGY); LocalDate expected = new LocalDate(7, 6, 30, GJ_CHRONOLOGY); assertEquals(expected, date.plusYears(4)); } public void test_plusYears_positiveToZero() { LocalDate date = new LocalDate(3, 6, 30, GJ_CHRONOLOGY); LocalDate expected = new LocalDate(-1, 6, 30, GJ_CHRONOLOGY); assertEquals(expected, date.plusYears(-3)); } public void test_plusYears_positiveToNegative() { LocalDate date = new LocalDate(3, 6, 30, GJ_CHRONOLOGY); LocalDate expected = new LocalDate(-2, 6, 30, GJ_CHRONOLOGY); assertEquals(expected, date.plusYears(-4)); } //----------------------------------------------------------------------- public void test_plusYears_negativeToNegative() { LocalDate date = new LocalDate(-3, 6, 30, GJ_CHRONOLOGY); LocalDate expected = new LocalDate(-1, 6, 30, GJ_CHRONOLOGY); assertEquals(expected, date.plusYears(2)); } public void test_plusYears_negativeToZero() { LocalDate date = new LocalDate(-3, 6, 30, GJ_CHRONOLOGY); LocalDate expected = new LocalDate(1, 6, 30, GJ_CHRONOLOGY); assertEquals(expected, date.plusYears(3)); } public void test_plusYears_negativeToPositive() { LocalDate date = new LocalDate(-3, 6, 30, GJ_CHRONOLOGY); LocalDate expected = new LocalDate(2, 6, 30, GJ_CHRONOLOGY); assertEquals(expected, date.plusYears(4)); } //----------------------------------------------------------------------- public void test_plusYears_positiveToPositive_crossCutover() { LocalDate date = new LocalDate(3, 6, 30, GJ_CHRONOLOGY); LocalDate expected = new LocalDate(2007, 6, 30, GJ_CHRONOLOGY); assertEquals(expected, date.plusYears(2004)); } public void test_plusYears_positiveToZero_crossCutover() { LocalDate date = new LocalDate(2003, 6, 30, GJ_CHRONOLOGY); LocalDate expected = new LocalDate(-1, 6, 30, GJ_CHRONOLOGY); assertEquals(expected, date.plusYears(-2003)); } public void test_plusYears_positiveToNegative_crossCutover() { LocalDate date = new LocalDate(2003, 6, 30, GJ_CHRONOLOGY); LocalDate expected = new LocalDate(-2, 6, 30, GJ_CHRONOLOGY); assertEquals(expected, date.plusYears(-2004)); } public void test_plusYears_negativeToPositive_crossCutover() { LocalDate date = new LocalDate(-3, 6, 30, GJ_CHRONOLOGY); LocalDate expected = new LocalDate(2002, 6, 30, GJ_CHRONOLOGY); assertEquals(expected, date.plusYears(2004)); } //----------------------------------------------------------------------- public void test_plusWeekyears_positiveToZero_crossCutover() { LocalDate date = new LocalDate(2003, 6, 30, GJ_CHRONOLOGY); LocalDate expected = new LocalDate(-1, 6, 30, GJ_CHRONOLOGY).withWeekOfWeekyear(date.getWeekOfWeekyear()).withDayOfWeek(date.getDayOfWeek()); assertEquals(expected, date.weekyear().addToCopy(-2003)); } public void test_plusWeekyears_positiveToNegative_crossCutover() { LocalDate date = new LocalDate(2003, 6, 30, GJ_CHRONOLOGY); LocalDate expected = new LocalDate(-2, 6, 30, GJ_CHRONOLOGY).withWeekOfWeekyear(date.getWeekOfWeekyear()).withDayOfWeek(date.getDayOfWeek()); assertEquals(expected, date.weekyear().addToCopy(-2004)); } //----------------------------------------------------------------------- public void test_cutoverPreZero() { DateTime cutover = new LocalDate(-2, 6, 30, ISOChronology.getInstanceUTC()).toDateTimeAtStartOfDay(DateTimeZone.UTC); try { GJChronology.getInstance(DateTimeZone.UTC, cutover); fail(); } catch (IllegalArgumentException ex) { // expected } } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.chrono; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.Chronology; import org.joda.time.DateMidnight; import org.joda.time.DateTimeConstants; import org.joda.time.DateTimeUtils; import org.joda.time.DateTimeZone; import org.joda.time.YearMonthDay; /** * This class is a Junit unit test for GregorianChronology. * * @author Stephen Colebourne */ @SuppressWarnings("deprecation") public class TestGregorianChronology extends TestCase { private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestGregorianChronology.class); } public TestGregorianChronology(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testFactoryUTC() { assertEquals(DateTimeZone.UTC, GregorianChronology.getInstanceUTC().getZone()); assertSame(GregorianChronology.class, GregorianChronology.getInstanceUTC().getClass()); } public void testFactory() { assertEquals(LONDON, GregorianChronology.getInstance().getZone()); assertSame(GregorianChronology.class, GregorianChronology.getInstance().getClass()); } public void testFactory_Zone() { assertEquals(TOKYO, GregorianChronology.getInstance(TOKYO).getZone()); assertEquals(PARIS, GregorianChronology.getInstance(PARIS).getZone()); assertEquals(LONDON, GregorianChronology.getInstance(null).getZone()); assertSame(GregorianChronology.class, GregorianChronology.getInstance(TOKYO).getClass()); } public void testFactory_Zone_int() { GregorianChronology chrono = GregorianChronology.getInstance(TOKYO, 2); assertEquals(TOKYO, chrono.getZone()); assertEquals(2, chrono.getMinimumDaysInFirstWeek()); try { GregorianChronology.getInstance(TOKYO, 0); fail(); } catch (IllegalArgumentException ex) {} try { GregorianChronology.getInstance(TOKYO, 8); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testEquality() { assertSame(GregorianChronology.getInstance(TOKYO), GregorianChronology.getInstance(TOKYO)); assertSame(GregorianChronology.getInstance(LONDON), GregorianChronology.getInstance(LONDON)); assertSame(GregorianChronology.getInstance(PARIS), GregorianChronology.getInstance(PARIS)); assertSame(GregorianChronology.getInstanceUTC(), GregorianChronology.getInstanceUTC()); assertSame(GregorianChronology.getInstance(), GregorianChronology.getInstance(LONDON)); } public void testWithUTC() { assertSame(GregorianChronology.getInstanceUTC(), GregorianChronology.getInstance(LONDON).withUTC()); assertSame(GregorianChronology.getInstanceUTC(), GregorianChronology.getInstance(TOKYO).withUTC()); assertSame(GregorianChronology.getInstanceUTC(), GregorianChronology.getInstanceUTC().withUTC()); assertSame(GregorianChronology.getInstanceUTC(), GregorianChronology.getInstance().withUTC()); } public void testWithZone() { assertSame(GregorianChronology.getInstance(TOKYO), GregorianChronology.getInstance(TOKYO).withZone(TOKYO)); assertSame(GregorianChronology.getInstance(LONDON), GregorianChronology.getInstance(TOKYO).withZone(LONDON)); assertSame(GregorianChronology.getInstance(PARIS), GregorianChronology.getInstance(TOKYO).withZone(PARIS)); assertSame(GregorianChronology.getInstance(LONDON), GregorianChronology.getInstance(TOKYO).withZone(null)); assertSame(GregorianChronology.getInstance(PARIS), GregorianChronology.getInstance().withZone(PARIS)); assertSame(GregorianChronology.getInstance(PARIS), GregorianChronology.getInstanceUTC().withZone(PARIS)); } public void testToString() { assertEquals("GregorianChronology[Europe/London]", GregorianChronology.getInstance(LONDON).toString()); assertEquals("GregorianChronology[Asia/Tokyo]", GregorianChronology.getInstance(TOKYO).toString()); assertEquals("GregorianChronology[Europe/London]", GregorianChronology.getInstance().toString()); assertEquals("GregorianChronology[UTC]", GregorianChronology.getInstanceUTC().toString()); assertEquals("GregorianChronology[UTC,mdfw=2]", GregorianChronology.getInstance(DateTimeZone.UTC, 2).toString()); } //----------------------------------------------------------------------- public void testDurationFields() { final GregorianChronology greg = GregorianChronology.getInstance(); assertEquals("eras", greg.eras().getName()); assertEquals("centuries", greg.centuries().getName()); assertEquals("years", greg.years().getName()); assertEquals("weekyears", greg.weekyears().getName()); assertEquals("months", greg.months().getName()); assertEquals("weeks", greg.weeks().getName()); assertEquals("days", greg.days().getName()); assertEquals("halfdays", greg.halfdays().getName()); assertEquals("hours", greg.hours().getName()); assertEquals("minutes", greg.minutes().getName()); assertEquals("seconds", greg.seconds().getName()); assertEquals("millis", greg.millis().getName()); assertEquals(false, greg.eras().isSupported()); assertEquals(true, greg.centuries().isSupported()); assertEquals(true, greg.years().isSupported()); assertEquals(true, greg.weekyears().isSupported()); assertEquals(true, greg.months().isSupported()); assertEquals(true, greg.weeks().isSupported()); assertEquals(true, greg.days().isSupported()); assertEquals(true, greg.halfdays().isSupported()); assertEquals(true, greg.hours().isSupported()); assertEquals(true, greg.minutes().isSupported()); assertEquals(true, greg.seconds().isSupported()); assertEquals(true, greg.millis().isSupported()); assertEquals(false, greg.centuries().isPrecise()); assertEquals(false, greg.years().isPrecise()); assertEquals(false, greg.weekyears().isPrecise()); assertEquals(false, greg.months().isPrecise()); assertEquals(false, greg.weeks().isPrecise()); assertEquals(false, greg.days().isPrecise()); assertEquals(false, greg.halfdays().isPrecise()); assertEquals(true, greg.hours().isPrecise()); assertEquals(true, greg.minutes().isPrecise()); assertEquals(true, greg.seconds().isPrecise()); assertEquals(true, greg.millis().isPrecise()); final GregorianChronology gregUTC = GregorianChronology.getInstanceUTC(); assertEquals(false, gregUTC.centuries().isPrecise()); assertEquals(false, gregUTC.years().isPrecise()); assertEquals(false, gregUTC.weekyears().isPrecise()); assertEquals(false, gregUTC.months().isPrecise()); assertEquals(true, gregUTC.weeks().isPrecise()); assertEquals(true, gregUTC.days().isPrecise()); assertEquals(true, gregUTC.halfdays().isPrecise()); assertEquals(true, gregUTC.hours().isPrecise()); assertEquals(true, gregUTC.minutes().isPrecise()); assertEquals(true, gregUTC.seconds().isPrecise()); assertEquals(true, gregUTC.millis().isPrecise()); final DateTimeZone gmt = DateTimeZone.forID("Etc/GMT"); final GregorianChronology gregGMT = GregorianChronology.getInstance(gmt); assertEquals(false, gregGMT.centuries().isPrecise()); assertEquals(false, gregGMT.years().isPrecise()); assertEquals(false, gregGMT.weekyears().isPrecise()); assertEquals(false, gregGMT.months().isPrecise()); assertEquals(true, gregGMT.weeks().isPrecise()); assertEquals(true, gregGMT.days().isPrecise()); assertEquals(true, gregGMT.halfdays().isPrecise()); assertEquals(true, gregGMT.hours().isPrecise()); assertEquals(true, gregGMT.minutes().isPrecise()); assertEquals(true, gregGMT.seconds().isPrecise()); assertEquals(true, gregGMT.millis().isPrecise()); } public void testDateFields() { final GregorianChronology greg = GregorianChronology.getInstance(); assertEquals("era", greg.era().getName()); assertEquals("centuryOfEra", greg.centuryOfEra().getName()); assertEquals("yearOfCentury", greg.yearOfCentury().getName()); assertEquals("yearOfEra", greg.yearOfEra().getName()); assertEquals("year", greg.year().getName()); assertEquals("monthOfYear", greg.monthOfYear().getName()); assertEquals("weekyearOfCentury", greg.weekyearOfCentury().getName()); assertEquals("weekyear", greg.weekyear().getName()); assertEquals("weekOfWeekyear", greg.weekOfWeekyear().getName()); assertEquals("dayOfYear", greg.dayOfYear().getName()); assertEquals("dayOfMonth", greg.dayOfMonth().getName()); assertEquals("dayOfWeek", greg.dayOfWeek().getName()); assertEquals(true, greg.era().isSupported()); assertEquals(true, greg.centuryOfEra().isSupported()); assertEquals(true, greg.yearOfCentury().isSupported()); assertEquals(true, greg.yearOfEra().isSupported()); assertEquals(true, greg.year().isSupported()); assertEquals(true, greg.monthOfYear().isSupported()); assertEquals(true, greg.weekyearOfCentury().isSupported()); assertEquals(true, greg.weekyear().isSupported()); assertEquals(true, greg.weekOfWeekyear().isSupported()); assertEquals(true, greg.dayOfYear().isSupported()); assertEquals(true, greg.dayOfMonth().isSupported()); assertEquals(true, greg.dayOfWeek().isSupported()); assertEquals(greg.eras(), greg.era().getDurationField()); assertEquals(greg.centuries(), greg.centuryOfEra().getDurationField()); assertEquals(greg.years(), greg.yearOfCentury().getDurationField()); assertEquals(greg.years(), greg.yearOfEra().getDurationField()); assertEquals(greg.years(), greg.year().getDurationField()); assertEquals(greg.months(), greg.monthOfYear().getDurationField()); assertEquals(greg.weekyears(), greg.weekyearOfCentury().getDurationField()); assertEquals(greg.weekyears(), greg.weekyear().getDurationField()); assertEquals(greg.weeks(), greg.weekOfWeekyear().getDurationField()); assertEquals(greg.days(), greg.dayOfYear().getDurationField()); assertEquals(greg.days(), greg.dayOfMonth().getDurationField()); assertEquals(greg.days(), greg.dayOfWeek().getDurationField()); assertEquals(null, greg.era().getRangeDurationField()); assertEquals(greg.eras(), greg.centuryOfEra().getRangeDurationField()); assertEquals(greg.centuries(), greg.yearOfCentury().getRangeDurationField()); assertEquals(greg.eras(), greg.yearOfEra().getRangeDurationField()); assertEquals(null, greg.year().getRangeDurationField()); assertEquals(greg.years(), greg.monthOfYear().getRangeDurationField()); assertEquals(greg.centuries(), greg.weekyearOfCentury().getRangeDurationField()); assertEquals(null, greg.weekyear().getRangeDurationField()); assertEquals(greg.weekyears(), greg.weekOfWeekyear().getRangeDurationField()); assertEquals(greg.years(), greg.dayOfYear().getRangeDurationField()); assertEquals(greg.months(), greg.dayOfMonth().getRangeDurationField()); assertEquals(greg.weeks(), greg.dayOfWeek().getRangeDurationField()); } public void testTimeFields() { final GregorianChronology greg = GregorianChronology.getInstance(); assertEquals("halfdayOfDay", greg.halfdayOfDay().getName()); assertEquals("clockhourOfHalfday", greg.clockhourOfHalfday().getName()); assertEquals("hourOfHalfday", greg.hourOfHalfday().getName()); assertEquals("clockhourOfDay", greg.clockhourOfDay().getName()); assertEquals("hourOfDay", greg.hourOfDay().getName()); assertEquals("minuteOfDay", greg.minuteOfDay().getName()); assertEquals("minuteOfHour", greg.minuteOfHour().getName()); assertEquals("secondOfDay", greg.secondOfDay().getName()); assertEquals("secondOfMinute", greg.secondOfMinute().getName()); assertEquals("millisOfDay", greg.millisOfDay().getName()); assertEquals("millisOfSecond", greg.millisOfSecond().getName()); assertEquals(true, greg.halfdayOfDay().isSupported()); assertEquals(true, greg.clockhourOfHalfday().isSupported()); assertEquals(true, greg.hourOfHalfday().isSupported()); assertEquals(true, greg.clockhourOfDay().isSupported()); assertEquals(true, greg.hourOfDay().isSupported()); assertEquals(true, greg.minuteOfDay().isSupported()); assertEquals(true, greg.minuteOfHour().isSupported()); assertEquals(true, greg.secondOfDay().isSupported()); assertEquals(true, greg.secondOfMinute().isSupported()); assertEquals(true, greg.millisOfDay().isSupported()); assertEquals(true, greg.millisOfSecond().isSupported()); } public void testMaximumValue() { YearMonthDay ymd1 = new YearMonthDay(1999, DateTimeConstants.FEBRUARY, 1); DateMidnight dm1 = new DateMidnight(1999, DateTimeConstants.FEBRUARY, 1); Chronology chrono = GregorianChronology.getInstance(); assertEquals(28, chrono.dayOfMonth().getMaximumValue(ymd1)); assertEquals(28, chrono.dayOfMonth().getMaximumValue(dm1.getMillis())); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.chrono; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.DateMidnight; import org.joda.time.DateTime; import org.joda.time.DateTimeConstants; import org.joda.time.DateTimeFieldType; import org.joda.time.DateTimeUtils; import org.joda.time.DateTimeZone; import org.joda.time.DurationField; import org.joda.time.DurationFieldType; import org.joda.time.IllegalFieldValueException; import org.joda.time.Partial; import org.joda.time.TimeOfDay; import org.joda.time.YearMonthDay; /** * This class is a Junit unit test for ISOChronology. * * @author Stephen Colebourne */ @SuppressWarnings("deprecation") public class TestISOChronology extends TestCase { private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestISOChronology.class); } public TestISOChronology(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testFactoryUTC() { assertEquals(DateTimeZone.UTC, ISOChronology.getInstanceUTC().getZone()); assertSame(ISOChronology.class, ISOChronology.getInstanceUTC().getClass()); } public void testFactory() { assertEquals(LONDON, ISOChronology.getInstance().getZone()); assertSame(ISOChronology.class, ISOChronology.getInstance().getClass()); } public void testFactory_Zone() { assertEquals(TOKYO, ISOChronology.getInstance(TOKYO).getZone()); assertEquals(PARIS, ISOChronology.getInstance(PARIS).getZone()); assertEquals(LONDON, ISOChronology.getInstance(null).getZone()); assertSame(ISOChronology.class, ISOChronology.getInstance(TOKYO).getClass()); } //----------------------------------------------------------------------- public void testEquality() { assertSame(ISOChronology.getInstance(TOKYO), ISOChronology.getInstance(TOKYO)); assertSame(ISOChronology.getInstance(LONDON), ISOChronology.getInstance(LONDON)); assertSame(ISOChronology.getInstance(PARIS), ISOChronology.getInstance(PARIS)); assertSame(ISOChronology.getInstanceUTC(), ISOChronology.getInstanceUTC()); assertSame(ISOChronology.getInstance(), ISOChronology.getInstance(LONDON)); } public void testWithUTC() { assertSame(ISOChronology.getInstanceUTC(), ISOChronology.getInstance(LONDON).withUTC()); assertSame(ISOChronology.getInstanceUTC(), ISOChronology.getInstance(TOKYO).withUTC()); assertSame(ISOChronology.getInstanceUTC(), ISOChronology.getInstanceUTC().withUTC()); assertSame(ISOChronology.getInstanceUTC(), ISOChronology.getInstance().withUTC()); } public void testWithZone() { assertSame(ISOChronology.getInstance(TOKYO), ISOChronology.getInstance(TOKYO).withZone(TOKYO)); assertSame(ISOChronology.getInstance(LONDON), ISOChronology.getInstance(TOKYO).withZone(LONDON)); assertSame(ISOChronology.getInstance(PARIS), ISOChronology.getInstance(TOKYO).withZone(PARIS)); assertSame(ISOChronology.getInstance(LONDON), ISOChronology.getInstance(TOKYO).withZone(null)); assertSame(ISOChronology.getInstance(PARIS), ISOChronology.getInstance().withZone(PARIS)); assertSame(ISOChronology.getInstance(PARIS), ISOChronology.getInstanceUTC().withZone(PARIS)); } public void testToString() { assertEquals("ISOChronology[Europe/London]", ISOChronology.getInstance(LONDON).toString()); assertEquals("ISOChronology[Asia/Tokyo]", ISOChronology.getInstance(TOKYO).toString()); assertEquals("ISOChronology[Europe/London]", ISOChronology.getInstance().toString()); assertEquals("ISOChronology[UTC]", ISOChronology.getInstanceUTC().toString()); } //----------------------------------------------------------------------- public void testDurationFields() { final ISOChronology iso = ISOChronology.getInstance(); assertEquals("eras", iso.eras().getName()); assertEquals("centuries", iso.centuries().getName()); assertEquals("years", iso.years().getName()); assertEquals("weekyears", iso.weekyears().getName()); assertEquals("months", iso.months().getName()); assertEquals("weeks", iso.weeks().getName()); assertEquals("days", iso.days().getName()); assertEquals("halfdays", iso.halfdays().getName()); assertEquals("hours", iso.hours().getName()); assertEquals("minutes", iso.minutes().getName()); assertEquals("seconds", iso.seconds().getName()); assertEquals("millis", iso.millis().getName()); assertEquals(false, iso.eras().isSupported()); assertEquals(true, iso.centuries().isSupported()); assertEquals(true, iso.years().isSupported()); assertEquals(true, iso.weekyears().isSupported()); assertEquals(true, iso.months().isSupported()); assertEquals(true, iso.weeks().isSupported()); assertEquals(true, iso.days().isSupported()); assertEquals(true, iso.halfdays().isSupported()); assertEquals(true, iso.hours().isSupported()); assertEquals(true, iso.minutes().isSupported()); assertEquals(true, iso.seconds().isSupported()); assertEquals(true, iso.millis().isSupported()); assertEquals(false, iso.centuries().isPrecise()); assertEquals(false, iso.years().isPrecise()); assertEquals(false, iso.weekyears().isPrecise()); assertEquals(false, iso.months().isPrecise()); assertEquals(false, iso.weeks().isPrecise()); assertEquals(false, iso.days().isPrecise()); assertEquals(false, iso.halfdays().isPrecise()); assertEquals(true, iso.hours().isPrecise()); assertEquals(true, iso.minutes().isPrecise()); assertEquals(true, iso.seconds().isPrecise()); assertEquals(true, iso.millis().isPrecise()); final ISOChronology isoUTC = ISOChronology.getInstanceUTC(); assertEquals(false, isoUTC.centuries().isPrecise()); assertEquals(false, isoUTC.years().isPrecise()); assertEquals(false, isoUTC.weekyears().isPrecise()); assertEquals(false, isoUTC.months().isPrecise()); assertEquals(true, isoUTC.weeks().isPrecise()); assertEquals(true, isoUTC.days().isPrecise()); assertEquals(true, isoUTC.halfdays().isPrecise()); assertEquals(true, isoUTC.hours().isPrecise()); assertEquals(true, isoUTC.minutes().isPrecise()); assertEquals(true, isoUTC.seconds().isPrecise()); assertEquals(true, isoUTC.millis().isPrecise()); final DateTimeZone gmt = DateTimeZone.forID("Etc/GMT"); final ISOChronology isoGMT = ISOChronology.getInstance(gmt); assertEquals(false, isoGMT.centuries().isPrecise()); assertEquals(false, isoGMT.years().isPrecise()); assertEquals(false, isoGMT.weekyears().isPrecise()); assertEquals(false, isoGMT.months().isPrecise()); assertEquals(true, isoGMT.weeks().isPrecise()); assertEquals(true, isoGMT.days().isPrecise()); assertEquals(true, isoGMT.halfdays().isPrecise()); assertEquals(true, isoGMT.hours().isPrecise()); assertEquals(true, isoGMT.minutes().isPrecise()); assertEquals(true, isoGMT.seconds().isPrecise()); assertEquals(true, isoGMT.millis().isPrecise()); final DateTimeZone offset = DateTimeZone.forOffsetHours(1); final ISOChronology isoOffset1 = ISOChronology.getInstance(offset); assertEquals(false, isoOffset1.centuries().isPrecise()); assertEquals(false, isoOffset1.years().isPrecise()); assertEquals(false, isoOffset1.weekyears().isPrecise()); assertEquals(false, isoOffset1.months().isPrecise()); assertEquals(true, isoOffset1.weeks().isPrecise()); assertEquals(true, isoOffset1.days().isPrecise()); assertEquals(true, isoOffset1.halfdays().isPrecise()); assertEquals(true, isoOffset1.hours().isPrecise()); assertEquals(true, isoOffset1.minutes().isPrecise()); assertEquals(true, isoOffset1.seconds().isPrecise()); assertEquals(true, isoOffset1.millis().isPrecise()); } public void testDateFields() { final ISOChronology iso = ISOChronology.getInstance(); assertEquals("era", iso.era().getName()); assertEquals("centuryOfEra", iso.centuryOfEra().getName()); assertEquals("yearOfCentury", iso.yearOfCentury().getName()); assertEquals("yearOfEra", iso.yearOfEra().getName()); assertEquals("year", iso.year().getName()); assertEquals("monthOfYear", iso.monthOfYear().getName()); assertEquals("weekyearOfCentury", iso.weekyearOfCentury().getName()); assertEquals("weekyear", iso.weekyear().getName()); assertEquals("weekOfWeekyear", iso.weekOfWeekyear().getName()); assertEquals("dayOfYear", iso.dayOfYear().getName()); assertEquals("dayOfMonth", iso.dayOfMonth().getName()); assertEquals("dayOfWeek", iso.dayOfWeek().getName()); assertEquals(true, iso.era().isSupported()); assertEquals(true, iso.centuryOfEra().isSupported()); assertEquals(true, iso.yearOfCentury().isSupported()); assertEquals(true, iso.yearOfEra().isSupported()); assertEquals(true, iso.year().isSupported()); assertEquals(true, iso.monthOfYear().isSupported()); assertEquals(true, iso.weekyearOfCentury().isSupported()); assertEquals(true, iso.weekyear().isSupported()); assertEquals(true, iso.weekOfWeekyear().isSupported()); assertEquals(true, iso.dayOfYear().isSupported()); assertEquals(true, iso.dayOfMonth().isSupported()); assertEquals(true, iso.dayOfWeek().isSupported()); assertEquals(iso.eras(), iso.era().getDurationField()); assertEquals(iso.centuries(), iso.centuryOfEra().getDurationField()); assertEquals(iso.years(), iso.yearOfCentury().getDurationField()); assertEquals(iso.years(), iso.yearOfEra().getDurationField()); assertEquals(iso.years(), iso.year().getDurationField()); assertEquals(iso.months(), iso.monthOfYear().getDurationField()); assertEquals(iso.weekyears(), iso.weekyearOfCentury().getDurationField()); assertEquals(iso.weekyears(), iso.weekyear().getDurationField()); assertEquals(iso.weeks(), iso.weekOfWeekyear().getDurationField()); assertEquals(iso.days(), iso.dayOfYear().getDurationField()); assertEquals(iso.days(), iso.dayOfMonth().getDurationField()); assertEquals(iso.days(), iso.dayOfWeek().getDurationField()); assertEquals(null, iso.era().getRangeDurationField()); assertEquals(iso.eras(), iso.centuryOfEra().getRangeDurationField()); assertEquals(iso.centuries(), iso.yearOfCentury().getRangeDurationField()); assertEquals(iso.eras(), iso.yearOfEra().getRangeDurationField()); assertEquals(null, iso.year().getRangeDurationField()); assertEquals(iso.years(), iso.monthOfYear().getRangeDurationField()); assertEquals(iso.centuries(), iso.weekyearOfCentury().getRangeDurationField()); assertEquals(null, iso.weekyear().getRangeDurationField()); assertEquals(iso.weekyears(), iso.weekOfWeekyear().getRangeDurationField()); assertEquals(iso.years(), iso.dayOfYear().getRangeDurationField()); assertEquals(iso.months(), iso.dayOfMonth().getRangeDurationField()); assertEquals(iso.weeks(), iso.dayOfWeek().getRangeDurationField()); } public void testTimeFields() { final ISOChronology iso = ISOChronology.getInstance(); assertEquals("halfdayOfDay", iso.halfdayOfDay().getName()); assertEquals("clockhourOfHalfday", iso.clockhourOfHalfday().getName()); assertEquals("hourOfHalfday", iso.hourOfHalfday().getName()); assertEquals("clockhourOfDay", iso.clockhourOfDay().getName()); assertEquals("hourOfDay", iso.hourOfDay().getName()); assertEquals("minuteOfDay", iso.minuteOfDay().getName()); assertEquals("minuteOfHour", iso.minuteOfHour().getName()); assertEquals("secondOfDay", iso.secondOfDay().getName()); assertEquals("secondOfMinute", iso.secondOfMinute().getName()); assertEquals("millisOfDay", iso.millisOfDay().getName()); assertEquals("millisOfSecond", iso.millisOfSecond().getName()); assertEquals(true, iso.halfdayOfDay().isSupported()); assertEquals(true, iso.clockhourOfHalfday().isSupported()); assertEquals(true, iso.hourOfHalfday().isSupported()); assertEquals(true, iso.clockhourOfDay().isSupported()); assertEquals(true, iso.hourOfDay().isSupported()); assertEquals(true, iso.minuteOfDay().isSupported()); assertEquals(true, iso.minuteOfHour().isSupported()); assertEquals(true, iso.secondOfDay().isSupported()); assertEquals(true, iso.secondOfMinute().isSupported()); assertEquals(true, iso.millisOfDay().isSupported()); assertEquals(true, iso.millisOfSecond().isSupported()); } public void testMaxYear() { final ISOChronology chrono = ISOChronology.getInstanceUTC(); final int maxYear = chrono.year().getMaximumValue(); DateTime start = new DateTime(maxYear, 1, 1, 0, 0, 0, 0, chrono); DateTime end = new DateTime(maxYear, 12, 31, 23, 59, 59, 999, chrono); assertTrue(start.getMillis() > 0); assertTrue(end.getMillis() > start.getMillis()); assertEquals(maxYear, start.getYear()); assertEquals(maxYear, end.getYear()); long delta = end.getMillis() - start.getMillis(); long expectedDelta = (start.year().isLeap() ? 366L : 365L) * DateTimeConstants.MILLIS_PER_DAY - 1; assertEquals(expectedDelta, delta); assertEquals(start, new DateTime(maxYear + "-01-01T00:00:00.000Z", chrono)); assertEquals(end, new DateTime(maxYear + "-12-31T23:59:59.999Z", chrono)); try { start.plusYears(1); fail(); } catch (IllegalFieldValueException e) { } try { end.plusYears(1); fail(); } catch (IllegalFieldValueException e) { } assertEquals(maxYear + 1, chrono.year().get(Long.MAX_VALUE)); } public void testMinYear() { final ISOChronology chrono = ISOChronology.getInstanceUTC(); final int minYear = chrono.year().getMinimumValue(); DateTime start = new DateTime(minYear, 1, 1, 0, 0, 0, 0, chrono); DateTime end = new DateTime(minYear, 12, 31, 23, 59, 59, 999, chrono); assertTrue(start.getMillis() < 0); assertTrue(end.getMillis() > start.getMillis()); assertEquals(minYear, start.getYear()); assertEquals(minYear, end.getYear()); long delta = end.getMillis() - start.getMillis(); long expectedDelta = (start.year().isLeap() ? 366L : 365L) * DateTimeConstants.MILLIS_PER_DAY - 1; assertEquals(expectedDelta, delta); assertEquals(start, new DateTime(minYear + "-01-01T00:00:00.000Z", chrono)); assertEquals(end, new DateTime(minYear + "-12-31T23:59:59.999Z", chrono)); try { start.minusYears(1); fail(); } catch (IllegalFieldValueException e) { } try { end.minusYears(1); fail(); } catch (IllegalFieldValueException e) { } assertEquals(minYear - 1, chrono.year().get(Long.MIN_VALUE)); } public void testCutoverAddYears() { testAdd("1582-01-01", DurationFieldType.years(), 1, "1583-01-01"); testAdd("1582-02-15", DurationFieldType.years(), 1, "1583-02-15"); testAdd("1582-02-28", DurationFieldType.years(), 1, "1583-02-28"); testAdd("1582-03-01", DurationFieldType.years(), 1, "1583-03-01"); testAdd("1582-09-30", DurationFieldType.years(), 1, "1583-09-30"); testAdd("1582-10-01", DurationFieldType.years(), 1, "1583-10-01"); testAdd("1582-10-04", DurationFieldType.years(), 1, "1583-10-04"); testAdd("1582-10-15", DurationFieldType.years(), 1, "1583-10-15"); testAdd("1582-10-16", DurationFieldType.years(), 1, "1583-10-16"); testAdd("1580-01-01", DurationFieldType.years(), 4, "1584-01-01"); testAdd("1580-02-29", DurationFieldType.years(), 4, "1584-02-29"); testAdd("1580-10-01", DurationFieldType.years(), 4, "1584-10-01"); testAdd("1580-10-10", DurationFieldType.years(), 4, "1584-10-10"); testAdd("1580-10-15", DurationFieldType.years(), 4, "1584-10-15"); testAdd("1580-12-31", DurationFieldType.years(), 4, "1584-12-31"); } public void testAddMonths() { testAdd("1582-01-01", DurationFieldType.months(), 1, "1582-02-01"); testAdd("1582-01-01", DurationFieldType.months(), 6, "1582-07-01"); testAdd("1582-01-01", DurationFieldType.months(), 12, "1583-01-01"); testAdd("1582-11-15", DurationFieldType.months(), 1, "1582-12-15"); testAdd("1582-09-04", DurationFieldType.months(), 2, "1582-11-04"); testAdd("1582-09-05", DurationFieldType.months(), 2, "1582-11-05"); testAdd("1582-09-10", DurationFieldType.months(), 2, "1582-11-10"); testAdd("1582-09-15", DurationFieldType.months(), 2, "1582-11-15"); testAdd("1580-01-01", DurationFieldType.months(), 48, "1584-01-01"); testAdd("1580-02-29", DurationFieldType.months(), 48, "1584-02-29"); testAdd("1580-10-01", DurationFieldType.months(), 48, "1584-10-01"); testAdd("1580-10-10", DurationFieldType.months(), 48, "1584-10-10"); testAdd("1580-10-15", DurationFieldType.months(), 48, "1584-10-15"); testAdd("1580-12-31", DurationFieldType.months(), 48, "1584-12-31"); } private void testAdd(String start, DurationFieldType type, int amt, String end) { DateTime dtStart = new DateTime(start, ISOChronology.getInstanceUTC()); DateTime dtEnd = new DateTime(end, ISOChronology.getInstanceUTC()); assertEquals(dtEnd, dtStart.withFieldAdded(type, amt)); assertEquals(dtStart, dtEnd.withFieldAdded(type, -amt)); DurationField field = type.getField(ISOChronology.getInstanceUTC()); int diff = field.getDifference(dtEnd.getMillis(), dtStart.getMillis()); assertEquals(amt, diff); if (type == DurationFieldType.years() || type == DurationFieldType.months() || type == DurationFieldType.days()) { YearMonthDay ymdStart = new YearMonthDay(start, ISOChronology.getInstanceUTC()); YearMonthDay ymdEnd = new YearMonthDay(end, ISOChronology.getInstanceUTC()); assertEquals(ymdEnd, ymdStart.withFieldAdded(type, amt)); assertEquals(ymdStart, ymdEnd.withFieldAdded(type, -amt)); } } public void testTimeOfDayAdd() { TimeOfDay start = new TimeOfDay(12, 30); TimeOfDay end = new TimeOfDay(10, 30); assertEquals(end, start.plusHours(22)); assertEquals(start, end.minusHours(22)); assertEquals(end, start.plusMinutes(22 * 60)); assertEquals(start, end.minusMinutes(22 * 60)); } public void testPartialDayOfYearAdd() { Partial start = new Partial().with(DateTimeFieldType.year(), 2000).with(DateTimeFieldType.dayOfYear(), 366); Partial end = new Partial().with(DateTimeFieldType.year(), 2004).with(DateTimeFieldType.dayOfYear(), 366); assertEquals(end, start.withFieldAdded(DurationFieldType.days(), 365 + 365 + 365 + 366)); assertEquals(start, end.withFieldAdded(DurationFieldType.days(), -(365 + 365 + 365 + 366))); } public void testMaximumValue() { DateMidnight dt = new DateMidnight(1570, 1, 1); while (dt.getYear() < 1590) { dt = dt.plusDays(1); YearMonthDay ymd = dt.toYearMonthDay(); assertEquals(dt.year().getMaximumValue(), ymd.year().getMaximumValue()); assertEquals(dt.monthOfYear().getMaximumValue(), ymd.monthOfYear().getMaximumValue()); assertEquals(dt.dayOfMonth().getMaximumValue(), ymd.dayOfMonth().getMaximumValue()); } } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.chrono; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.Chronology; import org.joda.time.DateTime; import org.joda.time.DateTimeConstants; import org.joda.time.DateTimeField; import org.joda.time.DateTimeUtils; import org.joda.time.DateTimeZone; import org.joda.time.DurationFieldType; import org.joda.time.DateTime.Property; /** * This class is a Junit unit test for IslamicChronology. * * @author Stephen Colebourne */ public class TestIslamicChronology extends TestCase { private static long SKIP = 1 * DateTimeConstants.MILLIS_PER_DAY; private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo"); private static final Chronology ISLAMIC_UTC = IslamicChronology.getInstanceUTC(); private static final Chronology JULIAN_UTC = JulianChronology.getInstanceUTC(); private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC(); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { SKIP = 1 * DateTimeConstants.MILLIS_PER_DAY; return new TestSuite(TestIslamicChronology.class); } public TestIslamicChronology(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testFactoryUTC() { assertEquals(DateTimeZone.UTC, IslamicChronology.getInstanceUTC().getZone()); assertSame(IslamicChronology.class, IslamicChronology.getInstanceUTC().getClass()); } public void testFactory() { assertEquals(LONDON, IslamicChronology.getInstance().getZone()); assertSame(IslamicChronology.class, IslamicChronology.getInstance().getClass()); } public void testFactory_Zone() { assertEquals(TOKYO, IslamicChronology.getInstance(TOKYO).getZone()); assertEquals(PARIS, IslamicChronology.getInstance(PARIS).getZone()); assertEquals(LONDON, IslamicChronology.getInstance(null).getZone()); assertSame(IslamicChronology.class, IslamicChronology.getInstance(TOKYO).getClass()); } //----------------------------------------------------------------------- public void testEquality() { assertSame(IslamicChronology.getInstance(TOKYO), IslamicChronology.getInstance(TOKYO)); assertSame(IslamicChronology.getInstance(LONDON), IslamicChronology.getInstance(LONDON)); assertSame(IslamicChronology.getInstance(PARIS), IslamicChronology.getInstance(PARIS)); assertSame(IslamicChronology.getInstanceUTC(), IslamicChronology.getInstanceUTC()); assertSame(IslamicChronology.getInstance(), IslamicChronology.getInstance(LONDON)); } public void testWithUTC() { assertSame(IslamicChronology.getInstanceUTC(), IslamicChronology.getInstance(LONDON).withUTC()); assertSame(IslamicChronology.getInstanceUTC(), IslamicChronology.getInstance(TOKYO).withUTC()); assertSame(IslamicChronology.getInstanceUTC(), IslamicChronology.getInstanceUTC().withUTC()); assertSame(IslamicChronology.getInstanceUTC(), IslamicChronology.getInstance().withUTC()); } public void testWithZone() { assertSame(IslamicChronology.getInstance(TOKYO), IslamicChronology.getInstance(TOKYO).withZone(TOKYO)); assertSame(IslamicChronology.getInstance(LONDON), IslamicChronology.getInstance(TOKYO).withZone(LONDON)); assertSame(IslamicChronology.getInstance(PARIS), IslamicChronology.getInstance(TOKYO).withZone(PARIS)); assertSame(IslamicChronology.getInstance(LONDON), IslamicChronology.getInstance(TOKYO).withZone(null)); assertSame(IslamicChronology.getInstance(PARIS), IslamicChronology.getInstance().withZone(PARIS)); assertSame(IslamicChronology.getInstance(PARIS), IslamicChronology.getInstanceUTC().withZone(PARIS)); } public void testToString() { assertEquals("IslamicChronology[Europe/London]", IslamicChronology.getInstance(LONDON).toString()); assertEquals("IslamicChronology[Asia/Tokyo]", IslamicChronology.getInstance(TOKYO).toString()); assertEquals("IslamicChronology[Europe/London]", IslamicChronology.getInstance().toString()); assertEquals("IslamicChronology[UTC]", IslamicChronology.getInstanceUTC().toString()); } //----------------------------------------------------------------------- public void testDurationFields() { final IslamicChronology islamic = IslamicChronology.getInstance(); assertEquals("eras", islamic.eras().getName()); assertEquals("centuries", islamic.centuries().getName()); assertEquals("years", islamic.years().getName()); assertEquals("weekyears", islamic.weekyears().getName()); assertEquals("months", islamic.months().getName()); assertEquals("weeks", islamic.weeks().getName()); assertEquals("days", islamic.days().getName()); assertEquals("halfdays", islamic.halfdays().getName()); assertEquals("hours", islamic.hours().getName()); assertEquals("minutes", islamic.minutes().getName()); assertEquals("seconds", islamic.seconds().getName()); assertEquals("millis", islamic.millis().getName()); assertEquals(false, islamic.eras().isSupported()); assertEquals(true, islamic.centuries().isSupported()); assertEquals(true, islamic.years().isSupported()); assertEquals(true, islamic.weekyears().isSupported()); assertEquals(true, islamic.months().isSupported()); assertEquals(true, islamic.weeks().isSupported()); assertEquals(true, islamic.days().isSupported()); assertEquals(true, islamic.halfdays().isSupported()); assertEquals(true, islamic.hours().isSupported()); assertEquals(true, islamic.minutes().isSupported()); assertEquals(true, islamic.seconds().isSupported()); assertEquals(true, islamic.millis().isSupported()); assertEquals(false, islamic.centuries().isPrecise()); assertEquals(false, islamic.years().isPrecise()); assertEquals(false, islamic.weekyears().isPrecise()); assertEquals(false, islamic.months().isPrecise()); assertEquals(false, islamic.weeks().isPrecise()); assertEquals(false, islamic.days().isPrecise()); assertEquals(false, islamic.halfdays().isPrecise()); assertEquals(true, islamic.hours().isPrecise()); assertEquals(true, islamic.minutes().isPrecise()); assertEquals(true, islamic.seconds().isPrecise()); assertEquals(true, islamic.millis().isPrecise()); final IslamicChronology islamicUTC = IslamicChronology.getInstanceUTC(); assertEquals(false, islamicUTC.centuries().isPrecise()); assertEquals(false, islamicUTC.years().isPrecise()); assertEquals(false, islamicUTC.weekyears().isPrecise()); assertEquals(false, islamicUTC.months().isPrecise()); assertEquals(true, islamicUTC.weeks().isPrecise()); assertEquals(true, islamicUTC.days().isPrecise()); assertEquals(true, islamicUTC.halfdays().isPrecise()); assertEquals(true, islamicUTC.hours().isPrecise()); assertEquals(true, islamicUTC.minutes().isPrecise()); assertEquals(true, islamicUTC.seconds().isPrecise()); assertEquals(true, islamicUTC.millis().isPrecise()); final DateTimeZone gmt = DateTimeZone.forID("Etc/GMT"); final IslamicChronology islamicGMT = IslamicChronology.getInstance(gmt); assertEquals(false, islamicGMT.centuries().isPrecise()); assertEquals(false, islamicGMT.years().isPrecise()); assertEquals(false, islamicGMT.weekyears().isPrecise()); assertEquals(false, islamicGMT.months().isPrecise()); assertEquals(true, islamicGMT.weeks().isPrecise()); assertEquals(true, islamicGMT.days().isPrecise()); assertEquals(true, islamicGMT.halfdays().isPrecise()); assertEquals(true, islamicGMT.hours().isPrecise()); assertEquals(true, islamicGMT.minutes().isPrecise()); assertEquals(true, islamicGMT.seconds().isPrecise()); assertEquals(true, islamicGMT.millis().isPrecise()); } public void testDateFields() { final IslamicChronology islamic = IslamicChronology.getInstance(); assertEquals("era", islamic.era().getName()); assertEquals("centuryOfEra", islamic.centuryOfEra().getName()); assertEquals("yearOfCentury", islamic.yearOfCentury().getName()); assertEquals("yearOfEra", islamic.yearOfEra().getName()); assertEquals("year", islamic.year().getName()); assertEquals("monthOfYear", islamic.monthOfYear().getName()); assertEquals("weekyearOfCentury", islamic.weekyearOfCentury().getName()); assertEquals("weekyear", islamic.weekyear().getName()); assertEquals("weekOfWeekyear", islamic.weekOfWeekyear().getName()); assertEquals("dayOfYear", islamic.dayOfYear().getName()); assertEquals("dayOfMonth", islamic.dayOfMonth().getName()); assertEquals("dayOfWeek", islamic.dayOfWeek().getName()); assertEquals(true, islamic.era().isSupported()); assertEquals(true, islamic.centuryOfEra().isSupported()); assertEquals(true, islamic.yearOfCentury().isSupported()); assertEquals(true, islamic.yearOfEra().isSupported()); assertEquals(true, islamic.year().isSupported()); assertEquals(true, islamic.monthOfYear().isSupported()); assertEquals(true, islamic.weekyearOfCentury().isSupported()); assertEquals(true, islamic.weekyear().isSupported()); assertEquals(true, islamic.weekOfWeekyear().isSupported()); assertEquals(true, islamic.dayOfYear().isSupported()); assertEquals(true, islamic.dayOfMonth().isSupported()); assertEquals(true, islamic.dayOfWeek().isSupported()); assertEquals(islamic.eras(), islamic.era().getDurationField()); assertEquals(islamic.centuries(), islamic.centuryOfEra().getDurationField()); assertEquals(islamic.years(), islamic.yearOfCentury().getDurationField()); assertEquals(islamic.years(), islamic.yearOfEra().getDurationField()); assertEquals(islamic.years(), islamic.year().getDurationField()); assertEquals(islamic.months(), islamic.monthOfYear().getDurationField()); assertEquals(islamic.weekyears(), islamic.weekyearOfCentury().getDurationField()); assertEquals(islamic.weekyears(), islamic.weekyear().getDurationField()); assertEquals(islamic.weeks(), islamic.weekOfWeekyear().getDurationField()); assertEquals(islamic.days(), islamic.dayOfYear().getDurationField()); assertEquals(islamic.days(), islamic.dayOfMonth().getDurationField()); assertEquals(islamic.days(), islamic.dayOfWeek().getDurationField()); assertEquals(null, islamic.era().getRangeDurationField()); assertEquals(islamic.eras(), islamic.centuryOfEra().getRangeDurationField()); assertEquals(islamic.centuries(), islamic.yearOfCentury().getRangeDurationField()); assertEquals(islamic.eras(), islamic.yearOfEra().getRangeDurationField()); assertEquals(null, islamic.year().getRangeDurationField()); assertEquals(islamic.years(), islamic.monthOfYear().getRangeDurationField()); assertEquals(islamic.centuries(), islamic.weekyearOfCentury().getRangeDurationField()); assertEquals(null, islamic.weekyear().getRangeDurationField()); assertEquals(islamic.weekyears(), islamic.weekOfWeekyear().getRangeDurationField()); assertEquals(islamic.years(), islamic.dayOfYear().getRangeDurationField()); assertEquals(islamic.months(), islamic.dayOfMonth().getRangeDurationField()); assertEquals(islamic.weeks(), islamic.dayOfWeek().getRangeDurationField()); } public void testTimeFields() { final IslamicChronology islamic = IslamicChronology.getInstance(); assertEquals("halfdayOfDay", islamic.halfdayOfDay().getName()); assertEquals("clockhourOfHalfday", islamic.clockhourOfHalfday().getName()); assertEquals("hourOfHalfday", islamic.hourOfHalfday().getName()); assertEquals("clockhourOfDay", islamic.clockhourOfDay().getName()); assertEquals("hourOfDay", islamic.hourOfDay().getName()); assertEquals("minuteOfDay", islamic.minuteOfDay().getName()); assertEquals("minuteOfHour", islamic.minuteOfHour().getName()); assertEquals("secondOfDay", islamic.secondOfDay().getName()); assertEquals("secondOfMinute", islamic.secondOfMinute().getName()); assertEquals("millisOfDay", islamic.millisOfDay().getName()); assertEquals("millisOfSecond", islamic.millisOfSecond().getName()); assertEquals(true, islamic.halfdayOfDay().isSupported()); assertEquals(true, islamic.clockhourOfHalfday().isSupported()); assertEquals(true, islamic.hourOfHalfday().isSupported()); assertEquals(true, islamic.clockhourOfDay().isSupported()); assertEquals(true, islamic.hourOfDay().isSupported()); assertEquals(true, islamic.minuteOfDay().isSupported()); assertEquals(true, islamic.minuteOfHour().isSupported()); assertEquals(true, islamic.secondOfDay().isSupported()); assertEquals(true, islamic.secondOfMinute().isSupported()); assertEquals(true, islamic.millisOfDay().isSupported()); assertEquals(true, islamic.millisOfSecond().isSupported()); } //----------------------------------------------------------------------- public void testEpoch() { DateTime epoch = new DateTime(1, 1, 1, 0, 0, 0, 0, ISLAMIC_UTC); DateTime expectedEpoch = new DateTime(622, 7, 16, 0, 0, 0, 0, JULIAN_UTC); assertEquals(expectedEpoch.getMillis(), epoch.getMillis()); } public void testEra() { assertEquals(1, IslamicChronology.AH); try { new DateTime(-1, 13, 5, 0, 0, 0, 0, ISLAMIC_UTC); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testFieldConstructor() { DateTime date = new DateTime(1364, 12, 6, 0, 0, 0, 0, ISLAMIC_UTC); DateTime expectedDate = new DateTime(1945, 11, 12, 0, 0, 0, 0, ISO_UTC); assertEquals(expectedDate.getMillis(), date.getMillis()); } //----------------------------------------------------------------------- /** * Tests era, year, monthOfYear, dayOfMonth and dayOfWeek. */ public void testCalendar() { if (TestAll.FAST) { return; } System.out.println("\nTestIslamicChronology.testCalendar"); DateTime epoch = new DateTime(1, 1, 1, 0, 0, 0, 0, ISLAMIC_UTC); long millis = epoch.getMillis(); long end = new DateTime(3000, 1, 1, 0, 0, 0, 0, ISO_UTC).getMillis(); DateTimeField dayOfWeek = ISLAMIC_UTC.dayOfWeek(); DateTimeField dayOfYear = ISLAMIC_UTC.dayOfYear(); DateTimeField dayOfMonth = ISLAMIC_UTC.dayOfMonth(); DateTimeField monthOfYear = ISLAMIC_UTC.monthOfYear(); DateTimeField year = ISLAMIC_UTC.year(); DateTimeField yearOfEra = ISLAMIC_UTC.yearOfEra(); DateTimeField era = ISLAMIC_UTC.era(); int expectedDOW = new DateTime(622, 7, 16, 0, 0, 0, 0, JULIAN_UTC).getDayOfWeek(); int expectedDOY = 1; int expectedDay = 1; int expectedMonth = 1; int expectedYear = 1; while (millis < end) { int dowValue = dayOfWeek.get(millis); int doyValue = dayOfYear.get(millis); int dayValue = dayOfMonth.get(millis); int monthValue = monthOfYear.get(millis); int yearValue = year.get(millis); int yearOfEraValue = yearOfEra.get(millis); int dayOfYearLen = dayOfYear.getMaximumValue(millis); int monthLen = dayOfMonth.getMaximumValue(millis); if (monthValue < 1 || monthValue > 12) { fail("Bad month: " + millis); } // test era assertEquals(1, era.get(millis)); assertEquals("AH", era.getAsText(millis)); assertEquals("AH", era.getAsShortText(millis)); // test date assertEquals(expectedDOY, doyValue); assertEquals(expectedMonth, monthValue); assertEquals(expectedDay, dayValue); assertEquals(expectedDOW, dowValue); assertEquals(expectedYear, yearValue); assertEquals(expectedYear, yearOfEraValue); // test leap year boolean leap = ((11 * yearValue + 14) % 30) < 11; assertEquals(leap, year.isLeap(millis)); // test month length switch (monthValue) { case 1: case 3: case 5: case 7: case 9: case 11: assertEquals(30, monthLen); break; case 2: case 4: case 6: case 8: case 10: assertEquals(29, monthLen); break; case 12: assertEquals((leap ? 30 : 29), monthLen); break; } // test year length assertEquals((leap ? 355 : 354), dayOfYearLen); // recalculate date expectedDOW = (((expectedDOW + 1) - 1) % 7) + 1; expectedDay++; expectedDOY++; if (expectedDay > monthLen) { expectedDay = 1; expectedMonth++; if (expectedMonth == 13) { expectedMonth = 1; expectedDOY = 1; expectedYear++; } } millis += SKIP; } } public void testSampleDate1() { DateTime dt = new DateTime(1945, 11, 12, 0, 0, 0, 0, ISO_UTC); dt = dt.withChronology(ISLAMIC_UTC); assertEquals(IslamicChronology.AH, dt.getEra()); assertEquals(14, dt.getCenturyOfEra()); // TODO confirm assertEquals(64, dt.getYearOfCentury()); assertEquals(1364, dt.getYearOfEra()); assertEquals(1364, dt.getYear()); Property fld = dt.year(); assertEquals(false, fld.isLeap()); assertEquals(0, fld.getLeapAmount()); assertEquals(DurationFieldType.days(), fld.getLeapDurationField().getType()); assertEquals(new DateTime(1365, 12, 6, 0, 0, 0, 0, ISLAMIC_UTC), fld.addToCopy(1)); assertEquals(12, dt.getMonthOfYear()); fld = dt.monthOfYear(); assertEquals(false, fld.isLeap()); assertEquals(0, fld.getLeapAmount()); assertEquals(DurationFieldType.days(), fld.getLeapDurationField().getType()); assertEquals(1, fld.getMinimumValue()); assertEquals(1, fld.getMinimumValueOverall()); assertEquals(12, fld.getMaximumValue()); assertEquals(12, fld.getMaximumValueOverall()); assertEquals(new DateTime(1365, 1, 6, 0, 0, 0, 0, ISLAMIC_UTC), fld.addToCopy(1)); assertEquals(new DateTime(1364, 1, 6, 0, 0, 0, 0, ISLAMIC_UTC), fld.addWrapFieldToCopy(1)); assertEquals(6, dt.getDayOfMonth()); fld = dt.dayOfMonth(); assertEquals(false, fld.isLeap()); assertEquals(0, fld.getLeapAmount()); assertEquals(null, fld.getLeapDurationField()); assertEquals(1, fld.getMinimumValue()); assertEquals(1, fld.getMinimumValueOverall()); assertEquals(29, fld.getMaximumValue()); assertEquals(30, fld.getMaximumValueOverall()); assertEquals(new DateTime(1364, 12, 7, 0, 0, 0, 0, ISLAMIC_UTC), fld.addToCopy(1)); assertEquals(DateTimeConstants.MONDAY, dt.getDayOfWeek()); fld = dt.dayOfWeek(); assertEquals(false, fld.isLeap()); assertEquals(0, fld.getLeapAmount()); assertEquals(null, fld.getLeapDurationField()); assertEquals(1, fld.getMinimumValue()); assertEquals(1, fld.getMinimumValueOverall()); assertEquals(7, fld.getMaximumValue()); assertEquals(7, fld.getMaximumValueOverall()); assertEquals(new DateTime(1364, 12, 7, 0, 0, 0, 0, ISLAMIC_UTC), fld.addToCopy(1)); assertEquals(6 * 30 + 5 * 29 + 6, dt.getDayOfYear()); fld = dt.dayOfYear(); assertEquals(false, fld.isLeap()); assertEquals(0, fld.getLeapAmount()); assertEquals(null, fld.getLeapDurationField()); assertEquals(1, fld.getMinimumValue()); assertEquals(1, fld.getMinimumValueOverall()); assertEquals(354, fld.getMaximumValue()); assertEquals(355, fld.getMaximumValueOverall()); assertEquals(new DateTime(1364, 12, 7, 0, 0, 0, 0, ISLAMIC_UTC), fld.addToCopy(1)); assertEquals(0, dt.getHourOfDay()); assertEquals(0, dt.getMinuteOfHour()); assertEquals(0, dt.getSecondOfMinute()); assertEquals(0, dt.getMillisOfSecond()); } public void testSampleDate2() { DateTime dt = new DateTime(2005, 11, 26, 0, 0, 0, 0, ISO_UTC); dt = dt.withChronology(ISLAMIC_UTC); assertEquals(IslamicChronology.AH, dt.getEra()); assertEquals(15, dt.getCenturyOfEra()); // TODO confirm assertEquals(26, dt.getYearOfCentury()); assertEquals(1426, dt.getYearOfEra()); assertEquals(1426, dt.getYear()); Property fld = dt.year(); assertEquals(true, fld.isLeap()); assertEquals(1, fld.getLeapAmount()); assertEquals(DurationFieldType.days(), fld.getLeapDurationField().getType()); assertEquals(10, dt.getMonthOfYear()); fld = dt.monthOfYear(); assertEquals(false, fld.isLeap()); assertEquals(0, fld.getLeapAmount()); assertEquals(DurationFieldType.days(), fld.getLeapDurationField().getType()); assertEquals(1, fld.getMinimumValue()); assertEquals(1, fld.getMinimumValueOverall()); assertEquals(12, fld.getMaximumValue()); assertEquals(12, fld.getMaximumValueOverall()); assertEquals(24, dt.getDayOfMonth()); fld = dt.dayOfMonth(); assertEquals(false, fld.isLeap()); assertEquals(0, fld.getLeapAmount()); assertEquals(null, fld.getLeapDurationField()); assertEquals(1, fld.getMinimumValue()); assertEquals(1, fld.getMinimumValueOverall()); assertEquals(29, fld.getMaximumValue()); assertEquals(30, fld.getMaximumValueOverall()); assertEquals(DateTimeConstants.SATURDAY, dt.getDayOfWeek()); fld = dt.dayOfWeek(); assertEquals(false, fld.isLeap()); assertEquals(0, fld.getLeapAmount()); assertEquals(null, fld.getLeapDurationField()); assertEquals(1, fld.getMinimumValue()); assertEquals(1, fld.getMinimumValueOverall()); assertEquals(7, fld.getMaximumValue()); assertEquals(7, fld.getMaximumValueOverall()); assertEquals(5 * 30 + 4 * 29 + 24, dt.getDayOfYear()); fld = dt.dayOfYear(); assertEquals(false, fld.isLeap()); assertEquals(0, fld.getLeapAmount()); assertEquals(null, fld.getLeapDurationField()); assertEquals(1, fld.getMinimumValue()); assertEquals(1, fld.getMinimumValueOverall()); assertEquals(355, fld.getMaximumValue()); assertEquals(355, fld.getMaximumValueOverall()); assertEquals(0, dt.getHourOfDay()); assertEquals(0, dt.getMinuteOfHour()); assertEquals(0, dt.getSecondOfMinute()); assertEquals(0, dt.getMillisOfSecond()); } public void testSampleDate3() { DateTime dt = new DateTime(1426, 12, 24, 0, 0, 0, 0, ISLAMIC_UTC); assertEquals(IslamicChronology.AH, dt.getEra()); assertEquals(1426, dt.getYear()); Property fld = dt.year(); assertEquals(true, fld.isLeap()); assertEquals(1, fld.getLeapAmount()); assertEquals(DurationFieldType.days(), fld.getLeapDurationField().getType()); assertEquals(12, dt.getMonthOfYear()); fld = dt.monthOfYear(); assertEquals(true, fld.isLeap()); assertEquals(1, fld.getLeapAmount()); assertEquals(DurationFieldType.days(), fld.getLeapDurationField().getType()); assertEquals(1, fld.getMinimumValue()); assertEquals(1, fld.getMinimumValueOverall()); assertEquals(12, fld.getMaximumValue()); assertEquals(12, fld.getMaximumValueOverall()); assertEquals(24, dt.getDayOfMonth()); fld = dt.dayOfMonth(); assertEquals(false, fld.isLeap()); assertEquals(0, fld.getLeapAmount()); assertEquals(null, fld.getLeapDurationField()); assertEquals(1, fld.getMinimumValue()); assertEquals(1, fld.getMinimumValueOverall()); assertEquals(30, fld.getMaximumValue()); assertEquals(30, fld.getMaximumValueOverall()); assertEquals(DateTimeConstants.TUESDAY, dt.getDayOfWeek()); fld = dt.dayOfWeek(); assertEquals(false, fld.isLeap()); assertEquals(0, fld.getLeapAmount()); assertEquals(null, fld.getLeapDurationField()); assertEquals(1, fld.getMinimumValue()); assertEquals(1, fld.getMinimumValueOverall()); assertEquals(7, fld.getMaximumValue()); assertEquals(7, fld.getMaximumValueOverall()); assertEquals(6 * 30 + 5 * 29 + 24, dt.getDayOfYear()); fld = dt.dayOfYear(); assertEquals(false, fld.isLeap()); assertEquals(0, fld.getLeapAmount()); assertEquals(null, fld.getLeapDurationField()); assertEquals(1, fld.getMinimumValue()); assertEquals(1, fld.getMinimumValueOverall()); assertEquals(355, fld.getMaximumValue()); assertEquals(355, fld.getMaximumValueOverall()); assertEquals(0, dt.getHourOfDay()); assertEquals(0, dt.getMinuteOfHour()); assertEquals(0, dt.getSecondOfMinute()); assertEquals(0, dt.getMillisOfSecond()); } public void testSampleDateWithZone() { DateTime dt = new DateTime(2005, 11, 26, 12, 0, 0, 0, PARIS).withChronology(ISLAMIC_UTC); assertEquals(IslamicChronology.AH, dt.getEra()); assertEquals(1426, dt.getYear()); assertEquals(10, dt.getMonthOfYear()); assertEquals(24, dt.getDayOfMonth()); assertEquals(11, dt.getHourOfDay()); // PARIS is UTC+1 in summer (12-1=11) assertEquals(0, dt.getMinuteOfHour()); assertEquals(0, dt.getSecondOfMinute()); assertEquals(0, dt.getMillisOfSecond()); } public void test15BasedLeapYear() { assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(1)); assertEquals(true, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(2)); assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(3)); assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(4)); assertEquals(true, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(5)); assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(6)); assertEquals(true, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(7)); assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(8)); assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(9)); assertEquals(true, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(10)); assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(11)); assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(12)); assertEquals(true, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(13)); assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(14)); assertEquals(true, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(15)); assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(16)); assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(17)); assertEquals(true, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(18)); assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(19)); assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(20)); assertEquals(true, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(21)); assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(22)); assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(23)); assertEquals(true, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(24)); assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(25)); assertEquals(true, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(26)); assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(27)); assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(28)); assertEquals(true, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(29)); assertEquals(false, IslamicChronology.LEAP_YEAR_15_BASED.isLeapYear(30)); } public void test16BasedLeapYear() { assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(1)); assertEquals(true, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(2)); assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(3)); assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(4)); assertEquals(true, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(5)); assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(6)); assertEquals(true, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(7)); assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(8)); assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(9)); assertEquals(true, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(10)); assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(11)); assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(12)); assertEquals(true, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(13)); assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(14)); assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(15)); assertEquals(true, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(16)); assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(17)); assertEquals(true, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(18)); assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(19)); assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(20)); assertEquals(true, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(21)); assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(22)); assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(23)); assertEquals(true, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(24)); assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(25)); assertEquals(true, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(26)); assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(27)); assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(28)); assertEquals(true, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(29)); assertEquals(false, IslamicChronology.LEAP_YEAR_16_BASED.isLeapYear(30)); } public void testIndianBasedLeapYear() { assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(1)); assertEquals(true, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(2)); assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(3)); assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(4)); assertEquals(true, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(5)); assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(6)); assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(7)); assertEquals(true, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(8)); assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(9)); assertEquals(true, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(10)); assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(11)); assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(12)); assertEquals(true, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(13)); assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(14)); assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(15)); assertEquals(true, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(16)); assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(17)); assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(18)); assertEquals(true, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(19)); assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(20)); assertEquals(true, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(21)); assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(22)); assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(23)); assertEquals(true, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(24)); assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(25)); assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(26)); assertEquals(true, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(27)); assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(28)); assertEquals(true, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(29)); assertEquals(false, IslamicChronology.LEAP_YEAR_INDIAN.isLeapYear(30)); } public void testHabashAlHasibBasedLeapYear() { assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(1)); assertEquals(true, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(2)); assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(3)); assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(4)); assertEquals(true, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(5)); assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(6)); assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(7)); assertEquals(true, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(8)); assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(9)); assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(10)); assertEquals(true, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(11)); assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(12)); assertEquals(true, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(13)); assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(14)); assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(15)); assertEquals(true, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(16)); assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(17)); assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(18)); assertEquals(true, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(19)); assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(20)); assertEquals(true, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(21)); assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(22)); assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(23)); assertEquals(true, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(24)); assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(25)); assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(26)); assertEquals(true, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(27)); assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(28)); assertEquals(false, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(29)); assertEquals(true, IslamicChronology.LEAP_YEAR_HABASH_AL_HASIB.isLeapYear(30)); } }
/* * Copyright 2001-2013 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.chrono; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.DateTimeConstants; import org.joda.time.DateTimeUtils; import org.joda.time.DateTimeZone; /** * This class is a Junit unit test for JulianChronology. * * @author Stephen Colebourne */ public class TestJulianChronology extends TestCase { private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestJulianChronology.class); } public TestJulianChronology(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testFactoryUTC() { assertEquals(DateTimeZone.UTC, JulianChronology.getInstanceUTC().getZone()); assertSame(JulianChronology.class, JulianChronology.getInstanceUTC().getClass()); } public void testFactory() { assertEquals(LONDON, JulianChronology.getInstance().getZone()); assertSame(JulianChronology.class, JulianChronology.getInstance().getClass()); } public void testFactory_Zone() { assertEquals(TOKYO, JulianChronology.getInstance(TOKYO).getZone()); assertEquals(PARIS, JulianChronology.getInstance(PARIS).getZone()); assertEquals(LONDON, JulianChronology.getInstance(null).getZone()); assertSame(JulianChronology.class, JulianChronology.getInstance(TOKYO).getClass()); } public void testFactory_Zone_int() { JulianChronology chrono = JulianChronology.getInstance(TOKYO, 2); assertEquals(TOKYO, chrono.getZone()); assertEquals(2, chrono.getMinimumDaysInFirstWeek()); try { JulianChronology.getInstance(TOKYO, 0); fail(); } catch (IllegalArgumentException ex) {} try { JulianChronology.getInstance(TOKYO, 8); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testEquality() { assertSame(JulianChronology.getInstance(TOKYO), JulianChronology.getInstance(TOKYO)); assertSame(JulianChronology.getInstance(LONDON), JulianChronology.getInstance(LONDON)); assertSame(JulianChronology.getInstance(PARIS), JulianChronology.getInstance(PARIS)); assertSame(JulianChronology.getInstanceUTC(), JulianChronology.getInstanceUTC()); assertSame(JulianChronology.getInstance(), JulianChronology.getInstance(LONDON)); } public void testWithUTC() { assertSame(JulianChronology.getInstanceUTC(), JulianChronology.getInstance(LONDON).withUTC()); assertSame(JulianChronology.getInstanceUTC(), JulianChronology.getInstance(TOKYO).withUTC()); assertSame(JulianChronology.getInstanceUTC(), JulianChronology.getInstanceUTC().withUTC()); assertSame(JulianChronology.getInstanceUTC(), JulianChronology.getInstance().withUTC()); } public void testWithZone() { assertSame(JulianChronology.getInstance(TOKYO), JulianChronology.getInstance(TOKYO).withZone(TOKYO)); assertSame(JulianChronology.getInstance(LONDON), JulianChronology.getInstance(TOKYO).withZone(LONDON)); assertSame(JulianChronology.getInstance(PARIS), JulianChronology.getInstance(TOKYO).withZone(PARIS)); assertSame(JulianChronology.getInstance(LONDON), JulianChronology.getInstance(TOKYO).withZone(null)); assertSame(JulianChronology.getInstance(PARIS), JulianChronology.getInstance().withZone(PARIS)); assertSame(JulianChronology.getInstance(PARIS), JulianChronology.getInstanceUTC().withZone(PARIS)); } public void testToString() { assertEquals("JulianChronology[Europe/London]", JulianChronology.getInstance(LONDON).toString()); assertEquals("JulianChronology[Asia/Tokyo]", JulianChronology.getInstance(TOKYO).toString()); assertEquals("JulianChronology[Europe/London]", JulianChronology.getInstance().toString()); assertEquals("JulianChronology[UTC]", JulianChronology.getInstanceUTC().toString()); assertEquals("JulianChronology[UTC,mdfw=2]", JulianChronology.getInstance(DateTimeZone.UTC, 2).toString()); } //----------------------------------------------------------------------- public void testDurationFields() { final JulianChronology julian = JulianChronology.getInstance(); assertEquals("eras", julian.eras().getName()); assertEquals("centuries", julian.centuries().getName()); assertEquals("years", julian.years().getName()); assertEquals("weekyears", julian.weekyears().getName()); assertEquals("months", julian.months().getName()); assertEquals("weeks", julian.weeks().getName()); assertEquals("days", julian.days().getName()); assertEquals("halfdays", julian.halfdays().getName()); assertEquals("hours", julian.hours().getName()); assertEquals("minutes", julian.minutes().getName()); assertEquals("seconds", julian.seconds().getName()); assertEquals("millis", julian.millis().getName()); assertEquals(false, julian.eras().isSupported()); assertEquals(true, julian.centuries().isSupported()); assertEquals(true, julian.years().isSupported()); assertEquals(true, julian.weekyears().isSupported()); assertEquals(true, julian.months().isSupported()); assertEquals(true, julian.weeks().isSupported()); assertEquals(true, julian.days().isSupported()); assertEquals(true, julian.halfdays().isSupported()); assertEquals(true, julian.hours().isSupported()); assertEquals(true, julian.minutes().isSupported()); assertEquals(true, julian.seconds().isSupported()); assertEquals(true, julian.millis().isSupported()); assertEquals(false, julian.centuries().isPrecise()); assertEquals(false, julian.years().isPrecise()); assertEquals(false, julian.weekyears().isPrecise()); assertEquals(false, julian.months().isPrecise()); assertEquals(false, julian.weeks().isPrecise()); assertEquals(false, julian.days().isPrecise()); assertEquals(false, julian.halfdays().isPrecise()); assertEquals(true, julian.hours().isPrecise()); assertEquals(true, julian.minutes().isPrecise()); assertEquals(true, julian.seconds().isPrecise()); assertEquals(true, julian.millis().isPrecise()); final JulianChronology julianUTC = JulianChronology.getInstanceUTC(); assertEquals(false, julianUTC.centuries().isPrecise()); assertEquals(false, julianUTC.years().isPrecise()); assertEquals(false, julianUTC.weekyears().isPrecise()); assertEquals(false, julianUTC.months().isPrecise()); assertEquals(true, julianUTC.weeks().isPrecise()); assertEquals(true, julianUTC.days().isPrecise()); assertEquals(true, julianUTC.halfdays().isPrecise()); assertEquals(true, julianUTC.hours().isPrecise()); assertEquals(true, julianUTC.minutes().isPrecise()); assertEquals(true, julianUTC.seconds().isPrecise()); assertEquals(true, julianUTC.millis().isPrecise()); final DateTimeZone gmt = DateTimeZone.forID("Etc/GMT"); final JulianChronology julianGMT = JulianChronology.getInstance(gmt); assertEquals(false, julianGMT.centuries().isPrecise()); assertEquals(false, julianGMT.years().isPrecise()); assertEquals(false, julianGMT.weekyears().isPrecise()); assertEquals(false, julianGMT.months().isPrecise()); assertEquals(true, julianGMT.weeks().isPrecise()); assertEquals(true, julianGMT.days().isPrecise()); assertEquals(true, julianGMT.halfdays().isPrecise()); assertEquals(true, julianGMT.hours().isPrecise()); assertEquals(true, julianGMT.minutes().isPrecise()); assertEquals(true, julianGMT.seconds().isPrecise()); assertEquals(true, julianGMT.millis().isPrecise()); } public void testDateFields() { final JulianChronology julian = JulianChronology.getInstance(); assertEquals("era", julian.era().getName()); assertEquals("centuryOfEra", julian.centuryOfEra().getName()); assertEquals("yearOfCentury", julian.yearOfCentury().getName()); assertEquals("yearOfEra", julian.yearOfEra().getName()); assertEquals("year", julian.year().getName()); assertEquals("monthOfYear", julian.monthOfYear().getName()); assertEquals("weekyearOfCentury", julian.weekyearOfCentury().getName()); assertEquals("weekyear", julian.weekyear().getName()); assertEquals("weekOfWeekyear", julian.weekOfWeekyear().getName()); assertEquals("dayOfYear", julian.dayOfYear().getName()); assertEquals("dayOfMonth", julian.dayOfMonth().getName()); assertEquals("dayOfWeek", julian.dayOfWeek().getName()); assertEquals(true, julian.era().isSupported()); assertEquals(true, julian.centuryOfEra().isSupported()); assertEquals(true, julian.yearOfCentury().isSupported()); assertEquals(true, julian.yearOfEra().isSupported()); assertEquals(true, julian.year().isSupported()); assertEquals(true, julian.monthOfYear().isSupported()); assertEquals(true, julian.weekyearOfCentury().isSupported()); assertEquals(true, julian.weekyear().isSupported()); assertEquals(true, julian.weekOfWeekyear().isSupported()); assertEquals(true, julian.dayOfYear().isSupported()); assertEquals(true, julian.dayOfMonth().isSupported()); assertEquals(true, julian.dayOfWeek().isSupported()); assertEquals(julian.eras(), julian.era().getDurationField()); assertEquals(julian.centuries(), julian.centuryOfEra().getDurationField()); assertEquals(julian.years(), julian.yearOfCentury().getDurationField()); assertEquals(julian.years(), julian.yearOfEra().getDurationField()); assertEquals(julian.years(), julian.year().getDurationField()); assertEquals(julian.months(), julian.monthOfYear().getDurationField()); assertEquals(julian.weekyears(), julian.weekyearOfCentury().getDurationField()); assertEquals(julian.weekyears(), julian.weekyear().getDurationField()); assertEquals(julian.weeks(), julian.weekOfWeekyear().getDurationField()); assertEquals(julian.days(), julian.dayOfYear().getDurationField()); assertEquals(julian.days(), julian.dayOfMonth().getDurationField()); assertEquals(julian.days(), julian.dayOfWeek().getDurationField()); assertEquals(null, julian.era().getRangeDurationField()); assertEquals(julian.eras(), julian.centuryOfEra().getRangeDurationField()); assertEquals(julian.centuries(), julian.yearOfCentury().getRangeDurationField()); assertEquals(julian.eras(), julian.yearOfEra().getRangeDurationField()); assertEquals(null, julian.year().getRangeDurationField()); assertEquals(julian.years(), julian.monthOfYear().getRangeDurationField()); assertEquals(julian.centuries(), julian.weekyearOfCentury().getRangeDurationField()); assertEquals(null, julian.weekyear().getRangeDurationField()); assertEquals(julian.weekyears(), julian.weekOfWeekyear().getRangeDurationField()); assertEquals(julian.years(), julian.dayOfYear().getRangeDurationField()); assertEquals(julian.months(), julian.dayOfMonth().getRangeDurationField()); assertEquals(julian.weeks(), julian.dayOfWeek().getRangeDurationField()); } public void testTimeFields() { final JulianChronology julian = JulianChronology.getInstance(); assertEquals("halfdayOfDay", julian.halfdayOfDay().getName()); assertEquals("clockhourOfHalfday", julian.clockhourOfHalfday().getName()); assertEquals("hourOfHalfday", julian.hourOfHalfday().getName()); assertEquals("clockhourOfDay", julian.clockhourOfDay().getName()); assertEquals("hourOfDay", julian.hourOfDay().getName()); assertEquals("minuteOfDay", julian.minuteOfDay().getName()); assertEquals("minuteOfHour", julian.minuteOfHour().getName()); assertEquals("secondOfDay", julian.secondOfDay().getName()); assertEquals("secondOfMinute", julian.secondOfMinute().getName()); assertEquals("millisOfDay", julian.millisOfDay().getName()); assertEquals("millisOfSecond", julian.millisOfSecond().getName()); assertEquals(true, julian.halfdayOfDay().isSupported()); assertEquals(true, julian.clockhourOfHalfday().isSupported()); assertEquals(true, julian.hourOfHalfday().isSupported()); assertEquals(true, julian.clockhourOfDay().isSupported()); assertEquals(true, julian.hourOfDay().isSupported()); assertEquals(true, julian.minuteOfDay().isSupported()); assertEquals(true, julian.minuteOfHour().isSupported()); assertEquals(true, julian.secondOfDay().isSupported()); assertEquals(true, julian.secondOfMinute().isSupported()); assertEquals(true, julian.millisOfDay().isSupported()); assertEquals(true, julian.millisOfSecond().isSupported()); } }
/* * Copyright 2001-2007 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.chrono; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.Chronology; import org.joda.time.DateTime; import org.joda.time.DateTimeZone; import org.joda.time.MockZone; /** * * @author Brian S O'Neill * @author Blair Martin */ public class TestLenientChronology extends TestCase { public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestLenientChronology.class); } public TestLenientChronology(String name) { super(name); } protected void setUp() throws Exception { } protected void tearDown() throws Exception { } //----------------------------------------------------------------------- public void test_setYear() { Chronology zone = LenientChronology.getInstance(ISOChronology.getInstanceUTC()); DateTime dt = new DateTime(2007, 1, 1, 0, 0 ,0, 0, zone); assertEquals("2007-01-01T00:00:00.000Z", dt.toString()); dt = dt.withYear(2008); assertEquals("2008-01-01T00:00:00.000Z", dt.toString()); } //----------------------------------------------------------------------- public void test_setMonthOfYear() { Chronology zone = LenientChronology.getInstance(ISOChronology.getInstanceUTC()); DateTime dt = new DateTime(2007, 1, 1, 0, 0 ,0, 0, zone); assertEquals("2007-01-01T00:00:00.000Z", dt.toString()); dt = dt.withMonthOfYear(13); assertEquals("2008-01-01T00:00:00.000Z", dt.toString()); dt = dt.withMonthOfYear(0); assertEquals("2007-12-01T00:00:00.000Z", dt.toString()); } //----------------------------------------------------------------------- public void test_setDayOfMonth() { Chronology zone = LenientChronology.getInstance(ISOChronology.getInstanceUTC()); DateTime dt = new DateTime(2007, 1, 1, 0, 0 ,0, 0, zone); assertEquals("2007-01-01T00:00:00.000Z", dt.toString()); dt = dt.withDayOfMonth(32); assertEquals("2007-02-01T00:00:00.000Z", dt.toString()); dt = dt.withDayOfMonth(0); assertEquals("2007-01-31T00:00:00.000Z", dt.toString()); } //----------------------------------------------------------------------- public void test_setHourOfDay() { Chronology zone = LenientChronology.getInstance(ISOChronology.getInstanceUTC()); DateTime dt = new DateTime(2007, 1, 1, 0, 0 ,0, 0, zone); assertEquals("2007-01-01T00:00:00.000Z", dt.toString()); dt = dt.withHourOfDay(24); assertEquals("2007-01-02T00:00:00.000Z", dt.toString()); dt = dt.withHourOfDay(-1); assertEquals("2007-01-01T23:00:00.000Z", dt.toString()); } //----------------------------------------------------------------------- //------------------------ Bug ------------------------------------------ //----------------------------------------------------------------------- public void testNearDstTransition() { // This is just a regression test. Test case provided by Blair Martin. int hour = 23; DateTime dt; dt = new DateTime(2006, 10, 29, hour, 0, 0, 0, ISOChronology.getInstance(DateTimeZone.forID("America/Los_Angeles"))); assertEquals(hour, dt.getHourOfDay()); // OK - no LenientChronology dt = new DateTime(2006, 10, 29, hour, 0, 0, 0, LenientChronology.getInstance (ISOChronology.getInstance(DateTimeZone.forOffsetHours(-8)))); assertEquals(hour, dt.getHourOfDay()); // OK - no TZ ID dt = new DateTime(2006, 10, 29, hour, 0, 0, 0, LenientChronology.getInstance (ISOChronology.getInstance(DateTimeZone.forID("America/Los_Angeles")))); assertEquals(hour, dt.getHourOfDay()); // Used to fail - hour was 22 } //----------------------------------------------------------------------- //------------------------ Bug [1755161] -------------------------------- //----------------------------------------------------------------------- /** Mock zone simulating America/Grand_Turk cutover at midnight 2007-04-01 */ private static long CUTOVER_TURK = 1175403600000L; private static int OFFSET_TURK = -18000000; // -05:00 private static final DateTimeZone MOCK_TURK = new MockZone(CUTOVER_TURK, OFFSET_TURK, 3600); //----------------------------------------------------------------------- public void test_MockTurkIsCorrect() { DateTime pre = new DateTime(CUTOVER_TURK - 1L, MOCK_TURK); assertEquals("2007-03-31T23:59:59.999-05:00", pre.toString()); DateTime at = new DateTime(CUTOVER_TURK, MOCK_TURK); assertEquals("2007-04-01T01:00:00.000-04:00", at.toString()); DateTime post = new DateTime(CUTOVER_TURK + 1L, MOCK_TURK); assertEquals("2007-04-01T01:00:00.001-04:00", post.toString()); } public void test_lenientChrononolgy_Chicago() { DateTimeZone zone = DateTimeZone.forID("America/Chicago"); Chronology lenient = LenientChronology.getInstance(ISOChronology.getInstance(zone)); DateTime dt = new DateTime(2007, 3, 11, 2, 30, 0, 0, lenient); assertEquals("2007-03-11T03:30:00.000-05:00", dt.toString()); } public void test_lenientChrononolgy_Turk() { Chronology lenient = LenientChronology.getInstance(ISOChronology.getInstance(MOCK_TURK)); DateTime dt = new DateTime(2007, 4, 1, 0, 30, 0, 0, lenient); assertEquals("2007-04-01T01:30:00.000-04:00", dt.toString()); } public void test_strictChrononolgy_Chicago() { DateTimeZone zone = DateTimeZone.forID("America/Chicago"); Chronology lenient = StrictChronology.getInstance(ISOChronology.getInstance(zone)); try { new DateTime(2007, 3, 11, 2, 30, 0, 0, lenient); fail(); } catch (IllegalArgumentException ex) { // expected } } public void test_isoChrononolgy_Chicago() { DateTimeZone zone = DateTimeZone.forID("America/Chicago"); Chronology lenient = ISOChronology.getInstance(zone); try { new DateTime(2007, 3, 11, 2, 30, 0, 0, lenient); fail(); } catch (IllegalArgumentException ex) { // expected } } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.convert; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Modifier; import java.util.Arrays; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.Chronology; import org.joda.time.DateTimeZone; import org.joda.time.TimeOfDay; import org.joda.time.chrono.BuddhistChronology; import org.joda.time.chrono.GJChronology; import org.joda.time.chrono.GregorianChronology; import org.joda.time.chrono.ISOChronology; import org.joda.time.chrono.JulianChronology; /** * This class is a Junit unit test for CalendarConverter. * * @author Stephen Colebourne */ public class TestCalendarConverter extends TestCase { private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone MOSCOW = DateTimeZone.forID("Europe/Moscow"); private static Chronology JULIAN; private static Chronology ISO; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestCalendarConverter.class); } public TestCalendarConverter(String name) { super(name); } protected void setUp() throws Exception { JULIAN = JulianChronology.getInstance(); ISO = ISOChronology.getInstance(); } //----------------------------------------------------------------------- public void testSingleton() throws Exception { Class cls = CalendarConverter.class; assertEquals(false, Modifier.isPublic(cls.getModifiers())); assertEquals(false, Modifier.isProtected(cls.getModifiers())); assertEquals(false, Modifier.isPrivate(cls.getModifiers())); Constructor con = cls.getDeclaredConstructor((Class[]) null); assertEquals(1, cls.getDeclaredConstructors().length); assertEquals(true, Modifier.isProtected(con.getModifiers())); Field fld = cls.getDeclaredField("INSTANCE"); assertEquals(false, Modifier.isPublic(fld.getModifiers())); assertEquals(false, Modifier.isProtected(fld.getModifiers())); assertEquals(false, Modifier.isPrivate(fld.getModifiers())); } //----------------------------------------------------------------------- public void testSupportedType() throws Exception { assertEquals(Calendar.class, CalendarConverter.INSTANCE.getSupportedType()); } //----------------------------------------------------------------------- public void testGetInstantMillis_Object_Chronology() throws Exception { GregorianCalendar cal = new GregorianCalendar(); cal.setTime(new Date(123L)); assertEquals(123L, CalendarConverter.INSTANCE.getInstantMillis(cal, JULIAN)); assertEquals(123L, cal.getTime().getTime()); } //----------------------------------------------------------------------- public void testGetChronology_Object_Zone() throws Exception { GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Paris")); assertEquals(GJChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(cal, MOSCOW)); cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow")); assertEquals(GJChronology.getInstance(), CalendarConverter.INSTANCE.getChronology(cal, (DateTimeZone) null)); cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow")); cal.setGregorianChange(new Date(0L)); assertEquals(GJChronology.getInstance(MOSCOW, 0L, 4), CalendarConverter.INSTANCE.getChronology(cal, MOSCOW)); cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow")); cal.setGregorianChange(new Date(Long.MAX_VALUE)); assertEquals(JulianChronology.getInstance(PARIS), CalendarConverter.INSTANCE.getChronology(cal, PARIS)); cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow")); cal.setGregorianChange(new Date(Long.MIN_VALUE)); assertEquals(GregorianChronology.getInstance(PARIS), CalendarConverter.INSTANCE.getChronology(cal, PARIS)); Calendar uc = new MockUnknownCalendar(TimeZone.getTimeZone("Europe/Moscow")); assertEquals(ISOChronology.getInstance(PARIS), CalendarConverter.INSTANCE.getChronology(uc, PARIS)); try { Calendar bc = (Calendar) Class.forName("sun.util.BuddhistCalendar").newInstance(); bc.setTimeZone(TimeZone.getTimeZone("Europe/Moscow")); assertEquals(BuddhistChronology.getInstance(PARIS), CalendarConverter.INSTANCE.getChronology(bc, PARIS)); } catch (ClassNotFoundException ex) { // ignore } } public void testGetChronology_Object_nullChronology() throws Exception { GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Paris")); assertEquals(GJChronology.getInstance(PARIS), CalendarConverter.INSTANCE.getChronology(cal, (Chronology) null)); cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow")); cal.setGregorianChange(new Date(0L)); assertEquals(GJChronology.getInstance(MOSCOW, 0L, 4), CalendarConverter.INSTANCE.getChronology(cal, (Chronology) null)); cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow")); cal.setGregorianChange(new Date(Long.MAX_VALUE)); assertEquals(JulianChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(cal, (Chronology) null)); cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Moscow")); cal.setGregorianChange(new Date(Long.MIN_VALUE)); assertEquals(GregorianChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(cal, (Chronology) null)); cal = new GregorianCalendar(new MockUnknownTimeZone()); assertEquals(GJChronology.getInstance(), CalendarConverter.INSTANCE.getChronology(cal, (Chronology) null)); Calendar uc = new MockUnknownCalendar(TimeZone.getTimeZone("Europe/Moscow")); assertEquals(ISOChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(uc, (Chronology) null)); try { Calendar bc = (Calendar) Class.forName("sun.util.BuddhistCalendar").newInstance(); bc.setTimeZone(TimeZone.getTimeZone("Europe/Moscow")); assertEquals(BuddhistChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(bc, (Chronology) null)); } catch (ClassNotFoundException ex) { // ignore } } public void testGetChronology_Object_Chronology() throws Exception { GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("Europe/Paris")); assertEquals(JULIAN, CalendarConverter.INSTANCE.getChronology(cal, JULIAN)); } //----------------------------------------------------------------------- public void testGetPartialValues() throws Exception { GregorianCalendar cal = new GregorianCalendar(); cal.setTime(new Date(12345678L)); TimeOfDay tod = new TimeOfDay(); int[] expected = ISO.get(tod, 12345678L); int[] actual = CalendarConverter.INSTANCE.getPartialValues(tod, cal, ISO); assertEquals(true, Arrays.equals(expected, actual)); } //----------------------------------------------------------------------- public void testToString() { assertEquals("Converter[java.util.Calendar]", CalendarConverter.INSTANCE.toString()); } }
/* * Copyright 2001-2006 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.convert; import java.io.Serializable; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Modifier; import java.security.AllPermission; import java.security.CodeSource; import java.security.Permission; import java.security.PermissionCollection; import java.security.Permissions; import java.security.Policy; import java.security.ProtectionDomain; import java.util.Calendar; import java.util.Date; import java.util.GregorianCalendar; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.Chronology; import org.joda.time.DateTime; import org.joda.time.DateTimeZone; import org.joda.time.Duration; import org.joda.time.ReadablePartial; import org.joda.time.ReadablePeriod; import org.joda.time.Period; import org.joda.time.PeriodType; import org.joda.time.Interval; import org.joda.time.JodaTimePermission; import org.joda.time.ReadWritablePeriod; import org.joda.time.ReadWritableInterval; import org.joda.time.ReadableDateTime; import org.joda.time.ReadableDuration; import org.joda.time.ReadableInstant; import org.joda.time.ReadableInterval; import org.joda.time.TimeOfDay; import org.joda.time.format.DateTimeFormatter; /** * This class is a JUnit test for ConverterManager. * * @author Stephen Colebourne */ public class TestConverterManager extends TestCase { private static final boolean OLD_JDK; static { String str = System.getProperty("java.version"); boolean old = true; if (str.length() > 3 && str.charAt(0) == '1' && str.charAt(1) == '.' && (str.charAt(2) == '4' || str.charAt(2) == '5' || str.charAt(2) == '6')) { old = false; } OLD_JDK = old; } private static final Policy RESTRICT; private static final Policy ALLOW; static { // don't call Policy.getPolicy() RESTRICT = new Policy() { public PermissionCollection getPermissions(CodeSource codesource) { Permissions p = new Permissions(); p.add(new AllPermission()); // enable everything return p; } public void refresh() { } public boolean implies(ProtectionDomain domain, Permission permission) { if (permission instanceof JodaTimePermission) { return false; } return true; // return super.implies(domain, permission); } }; ALLOW = new Policy() { public PermissionCollection getPermissions(CodeSource codesource) { Permissions p = new Permissions(); p.add(new AllPermission()); // enable everything return p; } public void refresh() { } }; } public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestConverterManager.class); } public TestConverterManager(String name) { super(name); } //----------------------------------------------------------------------- public void testSingleton() throws Exception { Class cls = ConverterManager.class; assertEquals(true, Modifier.isPublic(cls.getModifiers())); Constructor con = cls.getDeclaredConstructor((Class[]) null); assertEquals(1, cls.getDeclaredConstructors().length); assertEquals(true, Modifier.isProtected(con.getModifiers())); Field fld = cls.getDeclaredField("INSTANCE"); assertEquals(true, Modifier.isPrivate(fld.getModifiers())); } //----------------------------------------------------------------------- public void testGetInstantConverter() { InstantConverter c = ConverterManager.getInstance().getInstantConverter(new Long(0L)); assertEquals(Long.class, c.getSupportedType()); c = ConverterManager.getInstance().getInstantConverter(new DateTime()); assertEquals(ReadableInstant.class, c.getSupportedType()); c = ConverterManager.getInstance().getInstantConverter(""); assertEquals(String.class, c.getSupportedType()); c = ConverterManager.getInstance().getInstantConverter(new Date()); assertEquals(Date.class, c.getSupportedType()); c = ConverterManager.getInstance().getInstantConverter(new GregorianCalendar()); assertEquals(Calendar.class, c.getSupportedType()); c = ConverterManager.getInstance().getInstantConverter(null); assertEquals(null, c.getSupportedType()); try { ConverterManager.getInstance().getInstantConverter(Boolean.TRUE); fail(); } catch (IllegalArgumentException ex) {} } public void testGetInstantConverterRemovedNull() { try { ConverterManager.getInstance().removeInstantConverter(NullConverter.INSTANCE); try { ConverterManager.getInstance().getInstantConverter(null); fail(); } catch (IllegalArgumentException ex) {} } finally { ConverterManager.getInstance().addInstantConverter(NullConverter.INSTANCE); } assertEquals(6, ConverterManager.getInstance().getInstantConverters().length); } public void testGetInstantConverterOKMultipleMatches() { InstantConverter c = new InstantConverter() { public long getInstantMillis(Object object, Chronology chrono) {return 0;} public Chronology getChronology(Object object, DateTimeZone zone) {return null;} public Chronology getChronology(Object object, Chronology chrono) {return null;} public Class getSupportedType() {return ReadableDateTime.class;} }; try { ConverterManager.getInstance().addInstantConverter(c); InstantConverter ok = ConverterManager.getInstance().getInstantConverter(new DateTime()); // ReadableDateTime and ReadableInstant both match, but RI discarded as less specific assertEquals(ReadableDateTime.class, ok.getSupportedType()); } finally { ConverterManager.getInstance().removeInstantConverter(c); } assertEquals(6, ConverterManager.getInstance().getInstantConverters().length); } public void testGetInstantConverterBadMultipleMatches() { InstantConverter c = new InstantConverter() { public long getInstantMillis(Object object, Chronology chrono) {return 0;} public Chronology getChronology(Object object, DateTimeZone zone) {return null;} public Chronology getChronology(Object object, Chronology chrono) {return null;} public Class getSupportedType() {return Serializable.class;} }; try { ConverterManager.getInstance().addInstantConverter(c); try { ConverterManager.getInstance().getInstantConverter(new DateTime()); fail(); } catch (IllegalStateException ex) { // Serializable and ReadableInstant both match, so cannot pick } } finally { ConverterManager.getInstance().removeInstantConverter(c); } assertEquals(6, ConverterManager.getInstance().getInstantConverters().length); } //----------------------------------------------------------------------- public void testGetInstantConverters() { InstantConverter[] array = ConverterManager.getInstance().getInstantConverters(); assertEquals(6, array.length); } //----------------------------------------------------------------------- public void testAddInstantConverter1() { InstantConverter c = new InstantConverter() { public long getInstantMillis(Object object, Chronology chrono) {return 0;} public Chronology getChronology(Object object, DateTimeZone zone) {return null;} public Chronology getChronology(Object object, Chronology chrono) {return null;} public Class getSupportedType() {return Boolean.class;} }; try { InstantConverter removed = ConverterManager.getInstance().addInstantConverter(c); assertEquals(null, removed); assertEquals(Boolean.class, ConverterManager.getInstance().getInstantConverter(Boolean.TRUE).getSupportedType()); assertEquals(7, ConverterManager.getInstance().getInstantConverters().length); } finally { ConverterManager.getInstance().removeInstantConverter(c); } assertEquals(6, ConverterManager.getInstance().getInstantConverters().length); } public void testAddInstantConverter2() { InstantConverter c = new InstantConverter() { public long getInstantMillis(Object object, Chronology chrono) {return 0;} public Chronology getChronology(Object object, DateTimeZone zone) {return null;} public Chronology getChronology(Object object, Chronology chrono) {return null;} public Class getSupportedType() {return String.class;} }; try { InstantConverter removed = ConverterManager.getInstance().addInstantConverter(c); assertEquals(StringConverter.INSTANCE, removed); assertEquals(String.class, ConverterManager.getInstance().getInstantConverter("").getSupportedType()); assertEquals(6, ConverterManager.getInstance().getInstantConverters().length); } finally { ConverterManager.getInstance().addInstantConverter(StringConverter.INSTANCE); } assertEquals(6, ConverterManager.getInstance().getInstantConverters().length); } public void testAddInstantConverter3() { InstantConverter removed = ConverterManager.getInstance().addInstantConverter(StringConverter.INSTANCE); assertEquals(null, removed); assertEquals(6, ConverterManager.getInstance().getInstantConverters().length); } public void testAddInstantConverter4() { InstantConverter removed = ConverterManager.getInstance().addInstantConverter(null); assertEquals(null, removed); assertEquals(6, ConverterManager.getInstance().getInstantConverters().length); } public void testAddInstantConverterSecurity() { if (OLD_JDK) { return; } try { Policy.setPolicy(RESTRICT); System.setSecurityManager(new SecurityManager()); ConverterManager.getInstance().addInstantConverter(StringConverter.INSTANCE); fail(); } catch (SecurityException ex) { // ok } finally { System.setSecurityManager(null); Policy.setPolicy(ALLOW); } assertEquals(6, ConverterManager.getInstance().getInstantConverters().length); } //----------------------------------------------------------------------- public void testRemoveInstantConverter1() { try { InstantConverter removed = ConverterManager.getInstance().removeInstantConverter(StringConverter.INSTANCE); assertEquals(StringConverter.INSTANCE, removed); assertEquals(5, ConverterManager.getInstance().getInstantConverters().length); } finally { ConverterManager.getInstance().addInstantConverter(StringConverter.INSTANCE); } assertEquals(6, ConverterManager.getInstance().getInstantConverters().length); } public void testRemoveInstantConverter2() { InstantConverter c = new InstantConverter() { public long getInstantMillis(Object object, Chronology chrono) {return 0;} public Chronology getChronology(Object object, DateTimeZone zone) {return null;} public Chronology getChronology(Object object, Chronology chrono) {return null;} public Class getSupportedType() {return Boolean.class;} }; InstantConverter removed = ConverterManager.getInstance().removeInstantConverter(c); assertEquals(null, removed); assertEquals(6, ConverterManager.getInstance().getInstantConverters().length); } public void testRemoveInstantConverter3() { InstantConverter removed = ConverterManager.getInstance().removeInstantConverter(null); assertEquals(null, removed); assertEquals(6, ConverterManager.getInstance().getInstantConverters().length); } public void testRemoveInstantConverterSecurity() { if (OLD_JDK) { return; } try { Policy.setPolicy(RESTRICT); System.setSecurityManager(new SecurityManager()); ConverterManager.getInstance().removeInstantConverter(StringConverter.INSTANCE); fail(); } catch (SecurityException ex) { // ok } finally { System.setSecurityManager(null); Policy.setPolicy(ALLOW); } assertEquals(6, ConverterManager.getInstance().getInstantConverters().length); } //----------------------------------------------------------------------- //----------------------------------------------------------------------- private static final int PARTIAL_SIZE = 7; public void testGetPartialConverter() { PartialConverter c = ConverterManager.getInstance().getPartialConverter(new Long(0L)); assertEquals(Long.class, c.getSupportedType()); c = ConverterManager.getInstance().getPartialConverter(new TimeOfDay()); assertEquals(ReadablePartial.class, c.getSupportedType()); c = ConverterManager.getInstance().getPartialConverter(new DateTime()); assertEquals(ReadableInstant.class, c.getSupportedType()); c = ConverterManager.getInstance().getPartialConverter(""); assertEquals(String.class, c.getSupportedType()); c = ConverterManager.getInstance().getPartialConverter(new Date()); assertEquals(Date.class, c.getSupportedType()); c = ConverterManager.getInstance().getPartialConverter(new GregorianCalendar()); assertEquals(Calendar.class, c.getSupportedType()); c = ConverterManager.getInstance().getPartialConverter(null); assertEquals(null, c.getSupportedType()); try { ConverterManager.getInstance().getPartialConverter(Boolean.TRUE); fail(); } catch (IllegalArgumentException ex) {} } public void testGetPartialConverterRemovedNull() { try { ConverterManager.getInstance().removePartialConverter(NullConverter.INSTANCE); try { ConverterManager.getInstance().getPartialConverter(null); fail(); } catch (IllegalArgumentException ex) {} } finally { ConverterManager.getInstance().addPartialConverter(NullConverter.INSTANCE); } assertEquals(PARTIAL_SIZE, ConverterManager.getInstance().getPartialConverters().length); } public void testGetPartialConverterOKMultipleMatches() { PartialConverter c = new PartialConverter() { public int[] getPartialValues(ReadablePartial partial, Object object, Chronology chrono) {return null;} public int[] getPartialValues(ReadablePartial partial, Object object, Chronology chrono, DateTimeFormatter parser) {return null;} public Chronology getChronology(Object object, DateTimeZone zone) {return null;} public Chronology getChronology(Object object, Chronology chrono) {return null;} public Class getSupportedType() {return ReadableDateTime.class;} }; try { ConverterManager.getInstance().addPartialConverter(c); PartialConverter ok = ConverterManager.getInstance().getPartialConverter(new DateTime()); // ReadableDateTime and ReadablePartial both match, but RI discarded as less specific assertEquals(ReadableDateTime.class, ok.getSupportedType()); } finally { ConverterManager.getInstance().removePartialConverter(c); } assertEquals(PARTIAL_SIZE, ConverterManager.getInstance().getPartialConverters().length); } public void testGetPartialConverterBadMultipleMatches() { PartialConverter c = new PartialConverter() { public int[] getPartialValues(ReadablePartial partial, Object object, Chronology chrono) {return null;} public int[] getPartialValues(ReadablePartial partial, Object object, Chronology chrono, DateTimeFormatter parser) {return null;} public Chronology getChronology(Object object, DateTimeZone zone) {return null;} public Chronology getChronology(Object object, Chronology chrono) {return null;} public Class getSupportedType() {return Serializable.class;} }; try { ConverterManager.getInstance().addPartialConverter(c); try { ConverterManager.getInstance().getPartialConverter(new DateTime()); fail(); } catch (IllegalStateException ex) { // Serializable and ReadablePartial both match, so cannot pick } } finally { ConverterManager.getInstance().removePartialConverter(c); } assertEquals(PARTIAL_SIZE, ConverterManager.getInstance().getPartialConverters().length); } //----------------------------------------------------------------------- public void testGetPartialConverters() { PartialConverter[] array = ConverterManager.getInstance().getPartialConverters(); assertEquals(PARTIAL_SIZE, array.length); } //----------------------------------------------------------------------- public void testAddPartialConverter1() { PartialConverter c = new PartialConverter() { public int[] getPartialValues(ReadablePartial partial, Object object, Chronology chrono) {return null;} public int[] getPartialValues(ReadablePartial partial, Object object, Chronology chrono, DateTimeFormatter parser) {return null;} public Chronology getChronology(Object object, DateTimeZone zone) {return null;} public Chronology getChronology(Object object, Chronology chrono) {return null;} public Class getSupportedType() {return Boolean.class;} }; try { PartialConverter removed = ConverterManager.getInstance().addPartialConverter(c); assertEquals(null, removed); assertEquals(Boolean.class, ConverterManager.getInstance().getPartialConverter(Boolean.TRUE).getSupportedType()); assertEquals(PARTIAL_SIZE + 1, ConverterManager.getInstance().getPartialConverters().length); } finally { ConverterManager.getInstance().removePartialConverter(c); } assertEquals(PARTIAL_SIZE, ConverterManager.getInstance().getPartialConverters().length); } public void testAddPartialConverter2() { PartialConverter c = new PartialConverter() { public int[] getPartialValues(ReadablePartial partial, Object object, Chronology chrono) {return null;} public int[] getPartialValues(ReadablePartial partial, Object object, Chronology chrono, DateTimeFormatter parser) {return null;} public Chronology getChronology(Object object, DateTimeZone zone) {return null;} public Chronology getChronology(Object object, Chronology chrono) {return null;} public Class getSupportedType() {return String.class;} }; try { PartialConverter removed = ConverterManager.getInstance().addPartialConverter(c); assertEquals(StringConverter.INSTANCE, removed); assertEquals(String.class, ConverterManager.getInstance().getPartialConverter("").getSupportedType()); assertEquals(PARTIAL_SIZE, ConverterManager.getInstance().getPartialConverters().length); } finally { ConverterManager.getInstance().addPartialConverter(StringConverter.INSTANCE); } assertEquals(PARTIAL_SIZE, ConverterManager.getInstance().getPartialConverters().length); } public void testAddPartialConverter3() { PartialConverter removed = ConverterManager.getInstance().addPartialConverter(StringConverter.INSTANCE); assertEquals(null, removed); assertEquals(PARTIAL_SIZE, ConverterManager.getInstance().getPartialConverters().length); } public void testAddPartialConverter4() { PartialConverter removed = ConverterManager.getInstance().addPartialConverter(null); assertEquals(null, removed); assertEquals(PARTIAL_SIZE, ConverterManager.getInstance().getPartialConverters().length); } public void testAddPartialConverterSecurity() { if (OLD_JDK) { return; } try { Policy.setPolicy(RESTRICT); System.setSecurityManager(new SecurityManager()); ConverterManager.getInstance().addPartialConverter(StringConverter.INSTANCE); fail(); } catch (SecurityException ex) { // ok } finally { System.setSecurityManager(null); Policy.setPolicy(ALLOW); } assertEquals(PARTIAL_SIZE, ConverterManager.getInstance().getPartialConverters().length); } //----------------------------------------------------------------------- public void testRemovePartialConverter1() { try { PartialConverter removed = ConverterManager.getInstance().removePartialConverter(StringConverter.INSTANCE); assertEquals(StringConverter.INSTANCE, removed); assertEquals(PARTIAL_SIZE - 1, ConverterManager.getInstance().getPartialConverters().length); } finally { ConverterManager.getInstance().addPartialConverter(StringConverter.INSTANCE); } assertEquals(PARTIAL_SIZE, ConverterManager.getInstance().getPartialConverters().length); } public void testRemovePartialConverter2() { PartialConverter c = new PartialConverter() { public int[] getPartialValues(ReadablePartial partial, Object object, Chronology chrono) {return null;} public int[] getPartialValues(ReadablePartial partial, Object object, Chronology chrono, DateTimeFormatter parser) {return null;} public Chronology getChronology(Object object, DateTimeZone zone) {return null;} public Chronology getChronology(Object object, Chronology chrono) {return null;} public Class getSupportedType() {return Boolean.class;} }; PartialConverter removed = ConverterManager.getInstance().removePartialConverter(c); assertEquals(null, removed); assertEquals(PARTIAL_SIZE, ConverterManager.getInstance().getPartialConverters().length); } public void testRemovePartialConverter3() { PartialConverter removed = ConverterManager.getInstance().removePartialConverter(null); assertEquals(null, removed); assertEquals(PARTIAL_SIZE, ConverterManager.getInstance().getPartialConverters().length); } public void testRemovePartialConverterSecurity() { if (OLD_JDK) { return; } try { Policy.setPolicy(RESTRICT); System.setSecurityManager(new SecurityManager()); ConverterManager.getInstance().removeInstantConverter(StringConverter.INSTANCE); fail(); } catch (SecurityException ex) { // ok } finally { System.setSecurityManager(null); Policy.setPolicy(ALLOW); } assertEquals(PARTIAL_SIZE, ConverterManager.getInstance().getPartialConverters().length); } //----------------------------------------------------------------------- //----------------------------------------------------------------------- private static int DURATION_SIZE = 5; public void testGetDurationConverter() { DurationConverter c = ConverterManager.getInstance().getDurationConverter(new Long(0L)); assertEquals(Long.class, c.getSupportedType()); c = ConverterManager.getInstance().getDurationConverter(new Duration(123L)); assertEquals(ReadableDuration.class, c.getSupportedType()); c = ConverterManager.getInstance().getDurationConverter(new Interval(0L, 1000L)); assertEquals(ReadableInterval.class, c.getSupportedType()); c = ConverterManager.getInstance().getDurationConverter(""); assertEquals(String.class, c.getSupportedType()); c = ConverterManager.getInstance().getDurationConverter(null); assertEquals(null, c.getSupportedType()); try { ConverterManager.getInstance().getDurationConverter(Boolean.TRUE); fail(); } catch (IllegalArgumentException ex) {} } public void testGetDurationConverterRemovedNull() { try { ConverterManager.getInstance().removeDurationConverter(NullConverter.INSTANCE); try { ConverterManager.getInstance().getDurationConverter(null); fail(); } catch (IllegalArgumentException ex) {} } finally { ConverterManager.getInstance().addDurationConverter(NullConverter.INSTANCE); } assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length); } //----------------------------------------------------------------------- public void testGetDurationConverters() { DurationConverter[] array = ConverterManager.getInstance().getDurationConverters(); assertEquals(DURATION_SIZE, array.length); } //----------------------------------------------------------------------- public void testAddDurationConverter1() { DurationConverter c = new DurationConverter() { public long getDurationMillis(Object object) {return 0;} public Class getSupportedType() {return Boolean.class;} }; try { DurationConverter removed = ConverterManager.getInstance().addDurationConverter(c); assertEquals(null, removed); assertEquals(Boolean.class, ConverterManager.getInstance().getDurationConverter(Boolean.TRUE).getSupportedType()); assertEquals(DURATION_SIZE + 1, ConverterManager.getInstance().getDurationConverters().length); } finally { ConverterManager.getInstance().removeDurationConverter(c); } assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length); } public void testAddDurationConverter2() { DurationConverter c = new DurationConverter() { public long getDurationMillis(Object object) {return 0;} public Class getSupportedType() {return String.class;} }; try { DurationConverter removed = ConverterManager.getInstance().addDurationConverter(c); assertEquals(StringConverter.INSTANCE, removed); assertEquals(String.class, ConverterManager.getInstance().getDurationConverter("").getSupportedType()); assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length); } finally { ConverterManager.getInstance().addDurationConverter(StringConverter.INSTANCE); } assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length); } public void testAddDurationConverter3() { DurationConverter removed = ConverterManager.getInstance().addDurationConverter(null); assertEquals(null, removed); assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length); } public void testAddDurationConverterSecurity() { if (OLD_JDK) { return; } try { Policy.setPolicy(RESTRICT); System.setSecurityManager(new SecurityManager()); ConverterManager.getInstance().addDurationConverter(StringConverter.INSTANCE); fail(); } catch (SecurityException ex) { // ok } finally { System.setSecurityManager(null); Policy.setPolicy(ALLOW); } assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length); } //----------------------------------------------------------------------- public void testRemoveDurationConverter1() { try { DurationConverter removed = ConverterManager.getInstance().removeDurationConverter(StringConverter.INSTANCE); assertEquals(StringConverter.INSTANCE, removed); assertEquals(DURATION_SIZE - 1, ConverterManager.getInstance().getDurationConverters().length); } finally { ConverterManager.getInstance().addDurationConverter(StringConverter.INSTANCE); } assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length); } public void testRemoveDurationConverter2() { DurationConverter c = new DurationConverter() { public long getDurationMillis(Object object) {return 0;} public Class getSupportedType() {return Boolean.class;} }; DurationConverter removed = ConverterManager.getInstance().removeDurationConverter(c); assertEquals(null, removed); assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length); } public void testRemoveDurationConverter3() { DurationConverter removed = ConverterManager.getInstance().removeDurationConverter(null); assertEquals(null, removed); assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length); } public void testRemoveDurationConverterSecurity() { if (OLD_JDK) { return; } try { Policy.setPolicy(RESTRICT); System.setSecurityManager(new SecurityManager()); ConverterManager.getInstance().removeDurationConverter(StringConverter.INSTANCE); fail(); } catch (SecurityException ex) { // ok } finally { System.setSecurityManager(null); Policy.setPolicy(ALLOW); } assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length); } //----------------------------------------------------------------------- //----------------------------------------------------------------------- private static int PERIOD_SIZE = 5; public void testGetPeriodConverter() { PeriodConverter c = ConverterManager.getInstance().getPeriodConverter(new Period(1, 2, 3, 4, 5, 6, 7, 8)); assertEquals(ReadablePeriod.class, c.getSupportedType()); c = ConverterManager.getInstance().getPeriodConverter(new Duration(123L)); assertEquals(ReadableDuration.class, c.getSupportedType()); c = ConverterManager.getInstance().getPeriodConverter(new Interval(0L, 1000L)); assertEquals(ReadableInterval.class, c.getSupportedType()); c = ConverterManager.getInstance().getPeriodConverter(""); assertEquals(String.class, c.getSupportedType()); c = ConverterManager.getInstance().getPeriodConverter(null); assertEquals(null, c.getSupportedType()); try { ConverterManager.getInstance().getPeriodConverter(Boolean.TRUE); fail(); } catch (IllegalArgumentException ex) {} } public void testGetPeriodConverterRemovedNull() { try { ConverterManager.getInstance().removePeriodConverter(NullConverter.INSTANCE); try { ConverterManager.getInstance().getPeriodConverter(null); fail(); } catch (IllegalArgumentException ex) {} } finally { ConverterManager.getInstance().addPeriodConverter(NullConverter.INSTANCE); } assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length); } //----------------------------------------------------------------------- public void testGetPeriodConverters() { PeriodConverter[] array = ConverterManager.getInstance().getPeriodConverters(); assertEquals(PERIOD_SIZE, array.length); } //----------------------------------------------------------------------- public void testAddPeriodConverter1() { PeriodConverter c = new PeriodConverter() { public void setInto(ReadWritablePeriod duration, Object object, Chronology c) {} public PeriodType getPeriodType(Object object) {return null;} public Class getSupportedType() {return Boolean.class;} }; try { PeriodConverter removed = ConverterManager.getInstance().addPeriodConverter(c); assertEquals(null, removed); assertEquals(Boolean.class, ConverterManager.getInstance().getPeriodConverter(Boolean.TRUE).getSupportedType()); assertEquals(PERIOD_SIZE + 1, ConverterManager.getInstance().getPeriodConverters().length); } finally { ConverterManager.getInstance().removePeriodConverter(c); } assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length); } public void testAddPeriodConverter2() { PeriodConverter c = new PeriodConverter() { public void setInto(ReadWritablePeriod duration, Object object, Chronology c) {} public PeriodType getPeriodType(Object object) {return null;} public Class getSupportedType() {return String.class;} }; try { PeriodConverter removed = ConverterManager.getInstance().addPeriodConverter(c); assertEquals(StringConverter.INSTANCE, removed); assertEquals(String.class, ConverterManager.getInstance().getPeriodConverter("").getSupportedType()); assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length); } finally { ConverterManager.getInstance().addPeriodConverter(StringConverter.INSTANCE); } assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length); } public void testAddPeriodConverter3() { PeriodConverter removed = ConverterManager.getInstance().addPeriodConverter(null); assertEquals(null, removed); assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length); } public void testAddPeriodConverterSecurity() { if (OLD_JDK) { return; } try { Policy.setPolicy(RESTRICT); System.setSecurityManager(new SecurityManager()); ConverterManager.getInstance().addPeriodConverter(StringConverter.INSTANCE); fail(); } catch (SecurityException ex) { // ok } finally { System.setSecurityManager(null); Policy.setPolicy(ALLOW); } assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length); } //----------------------------------------------------------------------- public void testRemovePeriodConverter1() { try { PeriodConverter removed = ConverterManager.getInstance().removePeriodConverter(StringConverter.INSTANCE); assertEquals(StringConverter.INSTANCE, removed); assertEquals(PERIOD_SIZE - 1, ConverterManager.getInstance().getPeriodConverters().length); } finally { ConverterManager.getInstance().addPeriodConverter(StringConverter.INSTANCE); } assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length); } public void testRemovePeriodConverter2() { PeriodConverter c = new PeriodConverter() { public void setInto(ReadWritablePeriod duration, Object object, Chronology c) {} public PeriodType getPeriodType(Object object) {return null;} public Class getSupportedType() {return Boolean.class;} }; PeriodConverter removed = ConverterManager.getInstance().removePeriodConverter(c); assertEquals(null, removed); assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length); } public void testRemovePeriodConverter3() { PeriodConverter removed = ConverterManager.getInstance().removePeriodConverter(null); assertEquals(null, removed); assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length); } public void testRemovePeriodConverterSecurity() { if (OLD_JDK) { return; } try { Policy.setPolicy(RESTRICT); System.setSecurityManager(new SecurityManager()); ConverterManager.getInstance().removePeriodConverter(StringConverter.INSTANCE); fail(); } catch (SecurityException ex) { // ok } finally { System.setSecurityManager(null); Policy.setPolicy(ALLOW); } assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length); } //----------------------------------------------------------------------- //----------------------------------------------------------------------- private static int INTERVAL_SIZE = 3; public void testGetIntervalConverter() { IntervalConverter c = ConverterManager.getInstance().getIntervalConverter(new Interval(0L, 1000L)); assertEquals(ReadableInterval.class, c.getSupportedType()); c = ConverterManager.getInstance().getIntervalConverter(""); assertEquals(String.class, c.getSupportedType()); c = ConverterManager.getInstance().getIntervalConverter(null); assertEquals(null, c.getSupportedType()); try { ConverterManager.getInstance().getIntervalConverter(Boolean.TRUE); fail(); } catch (IllegalArgumentException ex) {} try { ConverterManager.getInstance().getIntervalConverter(new Long(0)); fail(); } catch (IllegalArgumentException ex) {} } public void testGetIntervalConverterRemovedNull() { try { ConverterManager.getInstance().removeIntervalConverter(NullConverter.INSTANCE); try { ConverterManager.getInstance().getIntervalConverter(null); fail(); } catch (IllegalArgumentException ex) {} } finally { ConverterManager.getInstance().addIntervalConverter(NullConverter.INSTANCE); } assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length); } //----------------------------------------------------------------------- public void testGetIntervalConverters() { IntervalConverter[] array = ConverterManager.getInstance().getIntervalConverters(); assertEquals(INTERVAL_SIZE, array.length); } //----------------------------------------------------------------------- public void testAddIntervalConverter1() { IntervalConverter c = new IntervalConverter() { public boolean isReadableInterval(Object object, Chronology chrono) {return false;} public void setInto(ReadWritableInterval interval, Object object, Chronology chrono) {} public Class getSupportedType() {return Boolean.class;} }; try { IntervalConverter removed = ConverterManager.getInstance().addIntervalConverter(c); assertEquals(null, removed); assertEquals(Boolean.class, ConverterManager.getInstance().getIntervalConverter(Boolean.TRUE).getSupportedType()); assertEquals(INTERVAL_SIZE + 1, ConverterManager.getInstance().getIntervalConverters().length); } finally { ConverterManager.getInstance().removeIntervalConverter(c); } assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length); } public void testAddIntervalConverter2() { IntervalConverter c = new IntervalConverter() { public boolean isReadableInterval(Object object, Chronology chrono) {return false;} public void setInto(ReadWritableInterval interval, Object object, Chronology chrono) {} public Class getSupportedType() {return String.class;} }; try { IntervalConverter removed = ConverterManager.getInstance().addIntervalConverter(c); assertEquals(StringConverter.INSTANCE, removed); assertEquals(String.class, ConverterManager.getInstance().getIntervalConverter("").getSupportedType()); assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length); } finally { ConverterManager.getInstance().addIntervalConverter(StringConverter.INSTANCE); } assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length); } public void testAddIntervalConverter3() { IntervalConverter removed = ConverterManager.getInstance().addIntervalConverter(null); assertEquals(null, removed); assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length); } public void testAddIntervalConverterSecurity() { if (OLD_JDK) { return; } try { Policy.setPolicy(RESTRICT); System.setSecurityManager(new SecurityManager()); ConverterManager.getInstance().addIntervalConverter(StringConverter.INSTANCE); fail(); } catch (SecurityException ex) { // ok } finally { System.setSecurityManager(null); Policy.setPolicy(ALLOW); } assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length); } //----------------------------------------------------------------------- public void testRemoveIntervalConverter1() { try { IntervalConverter removed = ConverterManager.getInstance().removeIntervalConverter(StringConverter.INSTANCE); assertEquals(StringConverter.INSTANCE, removed); assertEquals(INTERVAL_SIZE - 1, ConverterManager.getInstance().getIntervalConverters().length); } finally { ConverterManager.getInstance().addIntervalConverter(StringConverter.INSTANCE); } assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length); } public void testRemoveIntervalConverter2() { IntervalConverter c = new IntervalConverter() { public boolean isReadableInterval(Object object, Chronology chrono) {return false;} public void setInto(ReadWritableInterval interval, Object object, Chronology chrono) {} public Class getSupportedType() {return Boolean.class;} }; IntervalConverter removed = ConverterManager.getInstance().removeIntervalConverter(c); assertEquals(null, removed); assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length); } public void testRemoveIntervalConverter3() { IntervalConverter removed = ConverterManager.getInstance().removeIntervalConverter(null); assertEquals(null, removed); assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length); } public void testRemoveIntervalConverterSecurity() { if (OLD_JDK) { return; } try { Policy.setPolicy(RESTRICT); System.setSecurityManager(new SecurityManager()); ConverterManager.getInstance().removeIntervalConverter(StringConverter.INSTANCE); fail(); } catch (SecurityException ex) { // ok } finally { System.setSecurityManager(null); Policy.setPolicy(ALLOW); } assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length); } //----------------------------------------------------------------------- public void testToString() { assertEquals("ConverterManager[6 instant,7 partial,5 duration,5 period,3 interval]", ConverterManager.getInstance().toString()); } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.convert; import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import java.util.Calendar; import java.util.GregorianCalendar; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.DateMidnight; import org.joda.time.DateTime; import org.joda.time.ReadWritableDateTime; import org.joda.time.ReadWritableInstant; import org.joda.time.ReadableDateTime; import org.joda.time.ReadableInstant; /** * This class is a JUnit test for ConverterSet. * Mostly for coverage. * * @author Stephen Colebourne */ public class TestConverterSet extends TestCase { private static final Converter c1 = new Converter() { public Class getSupportedType() {return Boolean.class;} }; private static final Converter c2 = new Converter() { public Class getSupportedType() {return Character.class;} }; private static final Converter c3 = new Converter() { public Class getSupportedType() {return Byte.class;} }; private static final Converter c4 = new Converter() { public Class getSupportedType() {return Short.class;} }; private static final Converter c4a = new Converter() { public Class getSupportedType() {return Short.class;} }; private static final Converter c5 = new Converter() { public Class getSupportedType() {return Integer.class;} }; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestConverterSet.class); } public TestConverterSet(String name) { super(name); } //----------------------------------------------------------------------- public void testClass() throws Exception { Class cls = ConverterSet.class; assertEquals(false, Modifier.isPublic(cls.getModifiers())); assertEquals(false, Modifier.isProtected(cls.getModifiers())); assertEquals(false, Modifier.isPrivate(cls.getModifiers())); assertEquals(1, cls.getDeclaredConstructors().length); Constructor con = cls.getDeclaredConstructors()[0]; assertEquals(false, Modifier.isPublic(con.getModifiers())); assertEquals(false, Modifier.isProtected(con.getModifiers())); assertEquals(false, Modifier.isPrivate(con.getModifiers())); } //----------------------------------------------------------------------- public void testBigHashtable() { Converter[] array = new Converter[] { c1, c2, c3, c4, }; ConverterSet set = new ConverterSet(array); set.select(Boolean.class); set.select(Character.class); set.select(Byte.class); set.select(Short.class); set.select(Integer.class); set.select(Long.class); set.select(Float.class); set.select(Double.class); set.select(null); set.select(Calendar.class); set.select(GregorianCalendar.class); set.select(DateTime.class); set.select(DateMidnight.class); set.select(ReadableInstant.class); set.select(ReadableDateTime.class); set.select(ReadWritableInstant.class); // 16 set.select(ReadWritableDateTime.class); set.select(DateTime.class); assertEquals(4, set.size()); } //----------------------------------------------------------------------- public void testAddNullRemoved1() { Converter[] array = new Converter[] { c1, c2, c3, c4, }; ConverterSet set = new ConverterSet(array); ConverterSet result = set.add(c5, null); assertEquals(4, set.size()); assertEquals(5, result.size()); } public void testAddNullRemoved2() { Converter[] array = new Converter[] { c1, c2, c3, c4, }; ConverterSet set = new ConverterSet(array); ConverterSet result = set.add(c4, null); assertSame(set, result); } public void testAddNullRemoved3() { Converter[] array = new Converter[] { c1, c2, c3, c4, }; ConverterSet set = new ConverterSet(array); ConverterSet result = set.add(c4a, null); assertTrue(set != result); assertEquals(4, set.size()); assertEquals(4, result.size()); } //----------------------------------------------------------------------- public void testRemoveNullRemoved1() { Converter[] array = new Converter[] { c1, c2, c3, c4, }; ConverterSet set = new ConverterSet(array); ConverterSet result = set.remove(c3, null); assertEquals(4, set.size()); assertEquals(3, result.size()); } public void testRemoveNullRemoved2() { Converter[] array = new Converter[] { c1, c2, c3, c4, }; ConverterSet set = new ConverterSet(array); ConverterSet result = set.remove(c5, null); assertSame(set, result); } //----------------------------------------------------------------------- public void testRemoveBadIndex1() { Converter[] array = new Converter[] { c1, c2, c3, c4, }; ConverterSet set = new ConverterSet(array); try { set.remove(200, null); fail(); } catch (IndexOutOfBoundsException ex) {} assertEquals(4, set.size()); } public void testRemoveBadIndex2() { Converter[] array = new Converter[] { c1, c2, c3, c4, }; ConverterSet set = new ConverterSet(array); try { set.remove(-1, null); fail(); } catch (IndexOutOfBoundsException ex) {} assertEquals(4, set.size()); } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.convert; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Modifier; import java.util.Arrays; import java.util.Date; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.Chronology; import org.joda.time.DateTimeZone; import org.joda.time.TimeOfDay; import org.joda.time.chrono.CopticChronology; import org.joda.time.chrono.ISOChronology; import org.joda.time.chrono.JulianChronology; /** * This class is a Junit unit test for DateConverter. * * @author Stephen Colebourne */ public class TestDateConverter extends TestCase { private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS); private static Chronology ISO; private static Chronology JULIAN; private static Chronology COPTIC; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestDateConverter.class); } public TestDateConverter(String name) { super(name); } protected void setUp() throws Exception { JULIAN = JulianChronology.getInstance(); COPTIC = CopticChronology.getInstance(); ISO = ISOChronology.getInstance(); } //----------------------------------------------------------------------- public void testSingleton() throws Exception { Class cls = DateConverter.class; assertEquals(false, Modifier.isPublic(cls.getModifiers())); assertEquals(false, Modifier.isProtected(cls.getModifiers())); assertEquals(false, Modifier.isPrivate(cls.getModifiers())); Constructor con = cls.getDeclaredConstructor((Class[]) null); assertEquals(1, cls.getDeclaredConstructors().length); assertEquals(true, Modifier.isProtected(con.getModifiers())); Field fld = cls.getDeclaredField("INSTANCE"); assertEquals(false, Modifier.isPublic(fld.getModifiers())); assertEquals(false, Modifier.isProtected(fld.getModifiers())); assertEquals(false, Modifier.isPrivate(fld.getModifiers())); } //----------------------------------------------------------------------- public void testSupportedType() throws Exception { assertEquals(Date.class, DateConverter.INSTANCE.getSupportedType()); } //----------------------------------------------------------------------- public void testGetInstantMillis_Object_Chronology() throws Exception { Date date = new Date(123L); long millis = DateConverter.INSTANCE.getInstantMillis(date, JULIAN); assertEquals(123L, millis); assertEquals(123L, DateConverter.INSTANCE.getInstantMillis(date, (Chronology) null)); } //----------------------------------------------------------------------- public void testGetChronology_Object_Zone() throws Exception { assertEquals(ISO_PARIS, DateConverter.INSTANCE.getChronology(new Date(123L), PARIS)); assertEquals(ISO, DateConverter.INSTANCE.getChronology(new Date(123L), (DateTimeZone) null)); } public void testGetChronology_Object_Chronology() throws Exception { assertEquals(JULIAN, DateConverter.INSTANCE.getChronology(new Date(123L), JULIAN)); assertEquals(ISO, DateConverter.INSTANCE.getChronology(new Date(123L), (Chronology) null)); } //----------------------------------------------------------------------- public void testGetPartialValues() throws Exception { TimeOfDay tod = new TimeOfDay(); int[] expected = COPTIC.get(tod, 12345678L); int[] actual = DateConverter.INSTANCE.getPartialValues(tod, new Date(12345678L), COPTIC); assertEquals(true, Arrays.equals(expected, actual)); } //----------------------------------------------------------------------- public void testToString() { assertEquals("Converter[java.util.Date]", DateConverter.INSTANCE.toString()); } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.convert; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Modifier; import java.util.Arrays; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.Chronology; import org.joda.time.DateTimeZone; import org.joda.time.TimeOfDay; import org.joda.time.chrono.ISOChronology; import org.joda.time.chrono.JulianChronology; /** * This class is a Junit unit test for LongConverter. * * @author Stephen Colebourne */ public class TestLongConverter extends TestCase { private static final DateTimeZone UTC = DateTimeZone.UTC; private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS); private static Chronology JULIAN; private static Chronology ISO; private DateTimeZone zone = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestLongConverter.class); } public TestLongConverter(String name) { super(name); } protected void setUp() throws Exception { JULIAN = JulianChronology.getInstance(); ISO = ISOChronology.getInstance(); } //----------------------------------------------------------------------- public void testSingleton() throws Exception { Class cls = LongConverter.class; assertEquals(false, Modifier.isPublic(cls.getModifiers())); assertEquals(false, Modifier.isProtected(cls.getModifiers())); assertEquals(false, Modifier.isPrivate(cls.getModifiers())); Constructor con = cls.getDeclaredConstructor((Class[]) null); assertEquals(1, cls.getDeclaredConstructors().length); assertEquals(true, Modifier.isProtected(con.getModifiers())); Field fld = cls.getDeclaredField("INSTANCE"); assertEquals(false, Modifier.isPublic(fld.getModifiers())); assertEquals(false, Modifier.isProtected(fld.getModifiers())); assertEquals(false, Modifier.isPrivate(fld.getModifiers())); } //----------------------------------------------------------------------- public void testSupportedType() throws Exception { assertEquals(Long.class, LongConverter.INSTANCE.getSupportedType()); } //----------------------------------------------------------------------- public void testGetInstantMillis_Object_Chronology() throws Exception { assertEquals(123L, LongConverter.INSTANCE.getInstantMillis(new Long(123L), JULIAN)); assertEquals(123L, LongConverter.INSTANCE.getInstantMillis(new Long(123L), (Chronology) null)); } //----------------------------------------------------------------------- public void testGetChronology_Object_Zone() throws Exception { assertEquals(ISO_PARIS, LongConverter.INSTANCE.getChronology(new Long(123L), PARIS)); assertEquals(ISO, LongConverter.INSTANCE.getChronology(new Long(123L), (DateTimeZone) null)); } public void testGetChronology_Object_Chronology() throws Exception { assertEquals(JULIAN, LongConverter.INSTANCE.getChronology(new Long(123L), JULIAN)); assertEquals(ISO, LongConverter.INSTANCE.getChronology(new Long(123L), (Chronology) null)); } //----------------------------------------------------------------------- public void testGetPartialValues() throws Exception { TimeOfDay tod = new TimeOfDay(); int[] expected = ISOChronology.getInstance().get(tod, 12345678L); int[] actual = LongConverter.INSTANCE.getPartialValues(tod, new Long(12345678L), ISOChronology.getInstance()); assertEquals(true, Arrays.equals(expected, actual)); } //----------------------------------------------------------------------- public void testGetDurationMillis_Object() throws Exception { assertEquals(123L, LongConverter.INSTANCE.getDurationMillis(new Long(123L))); } //----------------------------------------------------------------------- public void testToString() { assertEquals("Converter[java.lang.Long]", LongConverter.INSTANCE.toString()); } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.convert; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Modifier; import java.util.Arrays; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.Chronology; import org.joda.time.DateTimeConstants; import org.joda.time.DateTimeUtils; import org.joda.time.DateTimeZone; import org.joda.time.MutableInterval; import org.joda.time.MutablePeriod; import org.joda.time.PeriodType; import org.joda.time.TimeOfDay; import org.joda.time.chrono.CopticChronology; import org.joda.time.chrono.GJChronology; import org.joda.time.chrono.ISOChronology; import org.joda.time.chrono.JulianChronology; /** * This class is a Junit unit test for NullConverter. * * @author Stephen Colebourne */ public class TestNullConverter extends TestCase { private long TEST_TIME_NOW = 20 * DateTimeConstants.MILLIS_PER_DAY + 10L * DateTimeConstants.MILLIS_PER_HOUR + 20L * DateTimeConstants.MILLIS_PER_MINUTE + 30L * DateTimeConstants.MILLIS_PER_SECOND + 40L; private static final DateTimeZone UTC = DateTimeZone.UTC; private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS); private static Chronology ISO; private static Chronology JULIAN; private DateTimeZone zone = null; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestNullConverter.class); } public TestNullConverter(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(DateTimeZone.forID("Europe/London")); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); ISO = ISOChronology.getInstance(); JULIAN = JulianChronology.getInstance(); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testSingleton() throws Exception { Class cls = NullConverter.class; assertEquals(false, Modifier.isPublic(cls.getModifiers())); assertEquals(false, Modifier.isProtected(cls.getModifiers())); assertEquals(false, Modifier.isPrivate(cls.getModifiers())); Constructor con = cls.getDeclaredConstructor((Class[]) null); assertEquals(1, cls.getDeclaredConstructors().length); assertEquals(true, Modifier.isProtected(con.getModifiers())); Field fld = cls.getDeclaredField("INSTANCE"); assertEquals(false, Modifier.isPublic(fld.getModifiers())); assertEquals(false, Modifier.isProtected(fld.getModifiers())); assertEquals(false, Modifier.isPrivate(fld.getModifiers())); } //----------------------------------------------------------------------- public void testSupportedType() throws Exception { assertEquals(null, NullConverter.INSTANCE.getSupportedType()); } //----------------------------------------------------------------------- public void testGetInstantMillis_Object_Chronology() throws Exception { assertEquals(TEST_TIME_NOW, NullConverter.INSTANCE.getInstantMillis(null, JULIAN)); assertEquals(TEST_TIME_NOW, NullConverter.INSTANCE.getInstantMillis(null, (Chronology) null)); } //----------------------------------------------------------------------- public void testGetChronology_Object_Zone() throws Exception { assertEquals(ISO_PARIS, NullConverter.INSTANCE.getChronology(null, PARIS)); assertEquals(ISO, NullConverter.INSTANCE.getChronology(null, (DateTimeZone) null)); } public void testGetChronology_Object_Chronology() throws Exception { assertEquals(JULIAN, NullConverter.INSTANCE.getChronology(null, JULIAN)); assertEquals(ISO, NullConverter.INSTANCE.getChronology(null, (Chronology) null)); } //----------------------------------------------------------------------- public void testGetPartialValues() throws Exception { TimeOfDay tod = new TimeOfDay(); int[] expected = new int[] {10 + 1, 20, 30, 40}; // now int[] actual = NullConverter.INSTANCE.getPartialValues(tod, null, ISOChronology.getInstance()); assertEquals(true, Arrays.equals(expected, actual)); } //----------------------------------------------------------------------- public void testGetDurationMillis_Object() throws Exception { assertEquals(0L, NullConverter.INSTANCE.getDurationMillis(null)); } //----------------------------------------------------------------------- public void testGetPeriodType_Object() throws Exception { assertEquals(PeriodType.standard(), NullConverter.INSTANCE.getPeriodType(null)); } public void testSetInto_Object() throws Exception { MutablePeriod m = new MutablePeriod(PeriodType.millis()); NullConverter.INSTANCE.setInto(m, null, null); assertEquals(0L, m.getMillis()); } //----------------------------------------------------------------------- public void testIsReadableInterval_Object_Chronology() throws Exception { assertEquals(false, NullConverter.INSTANCE.isReadableInterval(null, null)); } public void testSetInto_Object_Chronology1() throws Exception { MutableInterval m = new MutableInterval(1000L, 2000L, GJChronology.getInstance()); NullConverter.INSTANCE.setInto(m, null, null); assertEquals(TEST_TIME_NOW, m.getStartMillis()); assertEquals(TEST_TIME_NOW, m.getEndMillis()); assertEquals(ISOChronology.getInstance(), m.getChronology()); } public void testSetInto_Object_Chronology2() throws Exception { MutableInterval m = new MutableInterval(1000L, 2000L, GJChronology.getInstance()); NullConverter.INSTANCE.setInto(m, null, CopticChronology.getInstance()); assertEquals(TEST_TIME_NOW, m.getStartMillis()); assertEquals(TEST_TIME_NOW, m.getEndMillis()); assertEquals(CopticChronology.getInstance(), m.getChronology()); } //----------------------------------------------------------------------- public void testToString() { assertEquals("Converter[null]", NullConverter.INSTANCE.toString()); } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.convert; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Modifier; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.Chronology; import org.joda.time.DateTimeConstants; import org.joda.time.DateTimeZone; import org.joda.time.Duration; import org.joda.time.PeriodType; import org.joda.time.MutablePeriod; import org.joda.time.ReadableDuration; import org.joda.time.chrono.ISOChronology; import org.joda.time.chrono.JulianChronology; /** * This class is a Junit unit test for ReadableDurationConverter. * * @author Stephen Colebourne */ public class TestReadableDurationConverter extends TestCase { private static final DateTimeZone UTC = DateTimeZone.UTC; private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS); private static Chronology JULIAN; private static Chronology ISO; private DateTimeZone zone = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestReadableDurationConverter.class); } public TestReadableDurationConverter(String name) { super(name); } @Override protected void setUp() throws Exception { super.setUp(); JULIAN = JulianChronology.getInstance(); ISO = ISOChronology.getInstance(); zone = DateTimeZone.getDefault(); DateTimeZone.setDefault(PARIS); } @Override protected void tearDown() throws Exception { super.tearDown(); DateTimeZone.setDefault(zone); } //----------------------------------------------------------------------- public void testSingleton() throws Exception { Class cls = ReadableDurationConverter.class; assertEquals(false, Modifier.isPublic(cls.getModifiers())); assertEquals(false, Modifier.isProtected(cls.getModifiers())); assertEquals(false, Modifier.isPrivate(cls.getModifiers())); Constructor con = cls.getDeclaredConstructor((Class[]) null); assertEquals(1, cls.getDeclaredConstructors().length); assertEquals(true, Modifier.isProtected(con.getModifiers())); Field fld = cls.getDeclaredField("INSTANCE"); assertEquals(false, Modifier.isPublic(fld.getModifiers())); assertEquals(false, Modifier.isProtected(fld.getModifiers())); assertEquals(false, Modifier.isPrivate(fld.getModifiers())); } //----------------------------------------------------------------------- public void testSupportedType() throws Exception { assertEquals(ReadableDuration.class, ReadableDurationConverter.INSTANCE.getSupportedType()); } //----------------------------------------------------------------------- public void testGetDurationMillis_Object() throws Exception { assertEquals(123L, ReadableDurationConverter.INSTANCE.getDurationMillis(new Duration(123L))); } //----------------------------------------------------------------------- public void testGetPeriodType_Object() throws Exception { assertEquals(PeriodType.standard(), ReadableDurationConverter.INSTANCE.getPeriodType(new Duration(123L))); } public void testSetInto_Object() throws Exception { MutablePeriod m = new MutablePeriod(PeriodType.yearMonthDayTime()); ReadableDurationConverter.INSTANCE.setInto(m, new Duration( 3L * DateTimeConstants.MILLIS_PER_DAY + 4L * DateTimeConstants.MILLIS_PER_MINUTE + 5L ), null); assertEquals(0, m.getYears()); assertEquals(0, m.getMonths()); assertEquals(0, m.getWeeks()); assertEquals(0, m.getDays()); assertEquals(3 * 24, m.getHours()); assertEquals(4, m.getMinutes()); assertEquals(0, m.getSeconds()); assertEquals(5, m.getMillis()); } //----------------------------------------------------------------------- public void testToString() { assertEquals("Converter[org.joda.time.ReadableDuration]", ReadableDurationConverter.INSTANCE.toString()); } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.convert; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Modifier; import java.util.Arrays; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.Chronology; import org.joda.time.DateTime; import org.joda.time.DateTimeZone; import org.joda.time.Instant; import org.joda.time.MutableDateTime; import org.joda.time.ReadableInstant; import org.joda.time.TimeOfDay; import org.joda.time.chrono.ISOChronology; import org.joda.time.chrono.JulianChronology; /** * This class is a Junit unit test for ReadableInstantConverter. * * @author Stephen Colebourne */ public class TestReadableInstantConverter extends TestCase { private static final DateTimeZone UTC = DateTimeZone.UTC; private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS); private static Chronology JULIAN; private static Chronology ISO; private DateTimeZone zone = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestReadableInstantConverter.class); } public TestReadableInstantConverter(String name) { super(name); } protected void setUp() throws Exception { JULIAN = JulianChronology.getInstance(); ISO = ISOChronology.getInstance(); } //----------------------------------------------------------------------- public void testSingleton() throws Exception { Class cls = ReadableInstantConverter.class; assertEquals(false, Modifier.isPublic(cls.getModifiers())); assertEquals(false, Modifier.isProtected(cls.getModifiers())); assertEquals(false, Modifier.isPrivate(cls.getModifiers())); Constructor con = cls.getDeclaredConstructor((Class[]) null); assertEquals(1, cls.getDeclaredConstructors().length); assertEquals(true, Modifier.isProtected(con.getModifiers())); Field fld = cls.getDeclaredField("INSTANCE"); assertEquals(false, Modifier.isPublic(fld.getModifiers())); assertEquals(false, Modifier.isProtected(fld.getModifiers())); assertEquals(false, Modifier.isPrivate(fld.getModifiers())); } //----------------------------------------------------------------------- public void testSupportedType() throws Exception { assertEquals(ReadableInstant.class, ReadableInstantConverter.INSTANCE.getSupportedType()); } //----------------------------------------------------------------------- public void testGetInstantMillis_Object_Chronology() throws Exception { assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new Instant(123L), JULIAN)); assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new DateTime(123L), JULIAN)); assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new Instant(123L), (Chronology) null)); assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new DateTime(123L), (Chronology) null)); } //----------------------------------------------------------------------- public void testGetChronology_Object_Zone() throws Exception { assertEquals(ISO_PARIS, ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L), PARIS)); assertEquals(ISO_PARIS, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L), PARIS)); assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L), DateTimeZone.getDefault())); assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L), DateTimeZone.getDefault())); assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L), (DateTimeZone) null)); assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L), (DateTimeZone) null)); assertEquals(ISO_PARIS, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L, new MockBadChronology()), PARIS)); MutableDateTime mdt = new MutableDateTime() { public Chronology getChronology() { return null; // bad } }; assertEquals(ISO_PARIS, ReadableInstantConverter.INSTANCE.getChronology(mdt, PARIS)); } public void testGetChronology_Object_nullChronology() throws Exception { assertEquals(ISO.withUTC(), ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L), (Chronology) null)); assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L), (Chronology) null)); MutableDateTime mdt = new MutableDateTime() { public Chronology getChronology() { return null; // bad } }; assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(mdt, (Chronology) null)); } public void testGetChronology_Object_Chronology() throws Exception { assertEquals(JULIAN, ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L), JULIAN)); assertEquals(JULIAN, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L), JULIAN)); } //----------------------------------------------------------------------- public void testGetPartialValues() throws Exception { TimeOfDay tod = new TimeOfDay(); int[] expected = ISOChronology.getInstance().get(tod, 12345678L); int[] actual = ReadableInstantConverter.INSTANCE.getPartialValues(tod, new Instant(12345678L), ISOChronology.getInstance()); assertEquals(true, Arrays.equals(expected, actual)); } //----------------------------------------------------------------------- public void testToString() { assertEquals("Converter[org.joda.time.ReadableInstant]", ReadableInstantConverter.INSTANCE.toString()); } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.convert; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Modifier; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.Chronology; import org.joda.time.DateTimeZone; import org.joda.time.Interval; import org.joda.time.MutableInterval; import org.joda.time.MutablePeriod; import org.joda.time.PeriodType; import org.joda.time.ReadableInterval; import org.joda.time.chrono.BuddhistChronology; import org.joda.time.chrono.CopticChronology; import org.joda.time.chrono.GJChronology; import org.joda.time.chrono.ISOChronology; import org.joda.time.chrono.JulianChronology; /** * This class is a JUnit test for ReadableIntervalConverter. * * @author Stephen Colebourne */ public class TestReadableIntervalConverter extends TestCase { private static final DateTimeZone UTC = DateTimeZone.UTC; private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS); private static Chronology JULIAN; private static Chronology ISO; private DateTimeZone zone = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestReadableIntervalConverter.class); } public TestReadableIntervalConverter(String name) { super(name); } protected void setUp() throws Exception { JULIAN = JulianChronology.getInstance(); ISO = ISOChronology.getInstance(); } //----------------------------------------------------------------------- public void testSingleton() throws Exception { Class cls = ReadableIntervalConverter.class; assertEquals(false, Modifier.isPublic(cls.getModifiers())); assertEquals(false, Modifier.isProtected(cls.getModifiers())); assertEquals(false, Modifier.isPrivate(cls.getModifiers())); Constructor con = cls.getDeclaredConstructor((Class[]) null); assertEquals(1, cls.getDeclaredConstructors().length); assertEquals(true, Modifier.isProtected(con.getModifiers())); Field fld = cls.getDeclaredField("INSTANCE"); assertEquals(false, Modifier.isPublic(fld.getModifiers())); assertEquals(false, Modifier.isProtected(fld.getModifiers())); assertEquals(false, Modifier.isPrivate(fld.getModifiers())); } //----------------------------------------------------------------------- public void testSupportedType() throws Exception { assertEquals(ReadableInterval.class, ReadableIntervalConverter.INSTANCE.getSupportedType()); } //----------------------------------------------------------------------- public void testGetDurationMillis_Object() throws Exception { Interval i = new Interval(100L, 223L); assertEquals(123L, ReadableIntervalConverter.INSTANCE.getDurationMillis(i)); } //----------------------------------------------------------------------- public void testGetPeriodType_Object() throws Exception { Interval i = new Interval(100L, 223L); assertEquals(PeriodType.standard(), ReadableIntervalConverter.INSTANCE.getPeriodType(i)); } public void testSetIntoPeriod_Object1() throws Exception { Interval i = new Interval(100L, 223L); MutablePeriod m = new MutablePeriod(PeriodType.millis()); ReadableIntervalConverter.INSTANCE.setInto(m, i, null); assertEquals(0, m.getYears()); assertEquals(0, m.getMonths()); assertEquals(0, m.getWeeks()); assertEquals(0, m.getDays()); assertEquals(0, m.getHours()); assertEquals(0, m.getMinutes()); assertEquals(0, m.getSeconds()); assertEquals(123, m.getMillis()); } public void testSetIntoPeriod_Object2() throws Exception { Interval i = new Interval(100L, 223L); MutablePeriod m = new MutablePeriod(PeriodType.millis()); ReadableIntervalConverter.INSTANCE.setInto(m, i, CopticChronology.getInstance()); assertEquals(0, m.getYears()); assertEquals(0, m.getMonths()); assertEquals(0, m.getWeeks()); assertEquals(0, m.getDays()); assertEquals(0, m.getHours()); assertEquals(0, m.getMinutes()); assertEquals(0, m.getSeconds()); assertEquals(123, m.getMillis()); } //----------------------------------------------------------------------- public void testIsReadableInterval_Object_Chronology() throws Exception { Interval i = new Interval(1234L, 5678L); assertEquals(true, ReadableIntervalConverter.INSTANCE.isReadableInterval(i, null)); } public void testSetIntoInterval_Object1() throws Exception { Interval i = new Interval(0L, 123L, CopticChronology.getInstance()); MutableInterval m = new MutableInterval(-1000L, 1000L, BuddhistChronology.getInstance()); ReadableIntervalConverter.INSTANCE.setInto(m, i, null); assertEquals(0L, m.getStartMillis()); assertEquals(123L, m.getEndMillis()); assertEquals(CopticChronology.getInstance(), m.getChronology()); } public void testSetIntoInterval_Object2() throws Exception { Interval i = new Interval(0L, 123L, CopticChronology.getInstance()); MutableInterval m = new MutableInterval(-1000L, 1000L, BuddhistChronology.getInstance()); ReadableIntervalConverter.INSTANCE.setInto(m, i, GJChronology.getInstance()); assertEquals(0L, m.getStartMillis()); assertEquals(123L, m.getEndMillis()); assertEquals(GJChronology.getInstance(), m.getChronology()); } public void testSetIntoInterval_Object3() throws Exception { MutableInterval i = new MutableInterval(0L, 123L) { public Chronology getChronology() { return null; // bad } }; MutableInterval m = new MutableInterval(-1000L, 1000L, BuddhistChronology.getInstance()); ReadableIntervalConverter.INSTANCE.setInto(m, i, GJChronology.getInstance()); assertEquals(0L, m.getStartMillis()); assertEquals(123L, m.getEndMillis()); assertEquals(GJChronology.getInstance(), m.getChronology()); } public void testSetIntoInterval_Object4() throws Exception { MutableInterval i = new MutableInterval(0L, 123L) { public Chronology getChronology() { return null; // bad } }; MutableInterval m = new MutableInterval(-1000L, 1000L, BuddhistChronology.getInstance()); ReadableIntervalConverter.INSTANCE.setInto(m, i, null); assertEquals(0L, m.getStartMillis()); assertEquals(123L, m.getEndMillis()); assertEquals(ISOChronology.getInstance(), m.getChronology()); } //----------------------------------------------------------------------- public void testToString() { assertEquals("Converter[org.joda.time.ReadableInterval]", ReadableIntervalConverter.INSTANCE.toString()); } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.convert; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Modifier; import java.util.Arrays; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.Chronology; import org.joda.time.DateTimeField; import org.joda.time.DateTimeZone; import org.joda.time.ReadablePartial; import org.joda.time.TimeOfDay; import org.joda.time.YearMonthDay; import org.joda.time.base.BasePartial; import org.joda.time.chrono.BuddhistChronology; import org.joda.time.chrono.ISOChronology; import org.joda.time.chrono.JulianChronology; /** * This class is a Junit unit test for ReadablePartialConverter. * * @author Stephen Colebourne */ public class TestReadablePartialConverter extends TestCase { private static final DateTimeZone UTC = DateTimeZone.UTC; private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS); private static Chronology JULIAN; private static Chronology ISO; private static Chronology BUDDHIST; private DateTimeZone zone = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestReadablePartialConverter.class); } public TestReadablePartialConverter(String name) { super(name); } protected void setUp() throws Exception { JULIAN = JulianChronology.getInstance(); ISO = ISOChronology.getInstance(); BUDDHIST = BuddhistChronology.getInstance(); } //----------------------------------------------------------------------- public void testSingleton() throws Exception { Class cls = ReadablePartialConverter.class; assertEquals(false, Modifier.isPublic(cls.getModifiers())); assertEquals(false, Modifier.isProtected(cls.getModifiers())); assertEquals(false, Modifier.isPrivate(cls.getModifiers())); Constructor con = cls.getDeclaredConstructor((Class[]) null); assertEquals(1, cls.getDeclaredConstructors().length); assertEquals(true, Modifier.isProtected(con.getModifiers())); Field fld = cls.getDeclaredField("INSTANCE"); assertEquals(false, Modifier.isPublic(fld.getModifiers())); assertEquals(false, Modifier.isProtected(fld.getModifiers())); assertEquals(false, Modifier.isPrivate(fld.getModifiers())); } //----------------------------------------------------------------------- public void testSupportedType() throws Exception { assertEquals(ReadablePartial.class, ReadablePartialConverter.INSTANCE.getSupportedType()); } //----------------------------------------------------------------------- public void testGetChronology_Object_Zone() throws Exception { assertEquals(ISO_PARIS, ReadablePartialConverter.INSTANCE.getChronology(new TimeOfDay(123L), PARIS)); assertEquals(ISO, ReadablePartialConverter.INSTANCE.getChronology(new TimeOfDay(123L), DateTimeZone.getDefault())); assertEquals(ISO, ReadablePartialConverter.INSTANCE.getChronology(new TimeOfDay(123L), (DateTimeZone) null)); } public void testGetChronology_Object_Chronology() throws Exception { assertEquals(JULIAN, ReadablePartialConverter.INSTANCE.getChronology(new TimeOfDay(123L, BUDDHIST), JULIAN)); assertEquals(JULIAN, ReadablePartialConverter.INSTANCE.getChronology(new TimeOfDay(123L), JULIAN)); assertEquals(BUDDHIST.withUTC(), ReadablePartialConverter.INSTANCE.getChronology(new TimeOfDay(123L, BUDDHIST), (Chronology) null)); } //----------------------------------------------------------------------- public void testGetPartialValues() throws Exception { TimeOfDay tod = new TimeOfDay(); int[] expected = new int[] {1, 2, 3, 4}; int[] actual = ReadablePartialConverter.INSTANCE.getPartialValues(tod, new TimeOfDay(1, 2, 3, 4), ISOChronology.getInstance(PARIS)); assertEquals(true, Arrays.equals(expected, actual)); try { ReadablePartialConverter.INSTANCE.getPartialValues(tod, new YearMonthDay(2005, 6, 9), JULIAN); fail(); } catch (IllegalArgumentException ex) {} try { ReadablePartialConverter.INSTANCE.getPartialValues(tod, new MockTOD(), JULIAN); fail(); } catch (IllegalArgumentException ex) {} } static class MockTOD extends BasePartial { protected DateTimeField getField(int index, Chronology chrono) { switch (index) { case 0: return chrono.hourOfDay(); case 1: return chrono.minuteOfHour(); case 2: return chrono.year(); case 3: return chrono.era(); } return null; } public int size() { return 4; } } //----------------------------------------------------------------------- public void testToString() { assertEquals("Converter[org.joda.time.ReadablePartial]", ReadablePartialConverter.INSTANCE.toString()); } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.convert; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Modifier; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.Chronology; import org.joda.time.DateTimeZone; import org.joda.time.PeriodType; import org.joda.time.MutablePeriod; import org.joda.time.ReadablePeriod; import org.joda.time.Period; import org.joda.time.chrono.ISOChronology; import org.joda.time.chrono.JulianChronology; /** * This class is a Junit unit test for ReadablePeriodConverter. * * @author Stephen Colebourne */ public class TestReadablePeriodConverter extends TestCase { private static final DateTimeZone UTC = DateTimeZone.UTC; private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS); private static Chronology JULIAN; private static Chronology ISO; private DateTimeZone zone = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestReadablePeriodConverter.class); } public TestReadablePeriodConverter(String name) { super(name); } protected void setUp() throws Exception { JULIAN = JulianChronology.getInstance(); ISO = ISOChronology.getInstance(); } //----------------------------------------------------------------------- public void testSingleton() throws Exception { Class cls = ReadablePeriodConverter.class; assertEquals(false, Modifier.isPublic(cls.getModifiers())); assertEquals(false, Modifier.isProtected(cls.getModifiers())); assertEquals(false, Modifier.isPrivate(cls.getModifiers())); Constructor con = cls.getDeclaredConstructor((Class[]) null); assertEquals(1, cls.getDeclaredConstructors().length); assertEquals(true, Modifier.isProtected(con.getModifiers())); Field fld = cls.getDeclaredField("INSTANCE"); assertEquals(false, Modifier.isPublic(fld.getModifiers())); assertEquals(false, Modifier.isProtected(fld.getModifiers())); assertEquals(false, Modifier.isPrivate(fld.getModifiers())); } //----------------------------------------------------------------------- public void testSupportedType() throws Exception { assertEquals(ReadablePeriod.class, ReadablePeriodConverter.INSTANCE.getSupportedType()); } //----------------------------------------------------------------------- public void testGetPeriodType_Object() throws Exception { assertEquals(PeriodType.standard(), ReadablePeriodConverter.INSTANCE.getPeriodType(new Period(123L, PeriodType.standard()))); assertEquals(PeriodType.yearMonthDayTime(), ReadablePeriodConverter.INSTANCE.getPeriodType(new Period(123L, PeriodType.yearMonthDayTime()))); } public void testSetInto_Object() throws Exception { MutablePeriod m = new MutablePeriod(PeriodType.yearMonthDayTime()); ReadablePeriodConverter.INSTANCE.setInto(m, new Period(0, 0, 0, 3, 0, 4, 0, 5), null); assertEquals(0, m.getYears()); assertEquals(0, m.getMonths()); assertEquals(0, m.getWeeks()); assertEquals(3, m.getDays()); assertEquals(0, m.getHours()); assertEquals(4, m.getMinutes()); assertEquals(0, m.getSeconds()); assertEquals(5, m.getMillis()); } //----------------------------------------------------------------------- public void testToString() { assertEquals("Converter[org.joda.time.ReadablePeriod]", ReadablePeriodConverter.INSTANCE.toString()); } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.convert; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Modifier; import java.util.Arrays; import java.util.Locale; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.Chronology; import org.joda.time.DateTime; import org.joda.time.DateTimeZone; import org.joda.time.MutableInterval; import org.joda.time.MutablePeriod; import org.joda.time.PeriodType; import org.joda.time.TimeOfDay; import org.joda.time.chrono.BuddhistChronology; import org.joda.time.chrono.ISOChronology; import org.joda.time.chrono.JulianChronology; /** * This class is a Junit unit test for StringConverter. * * @author Stephen Colebourne */ public class TestStringConverter extends TestCase { private static final DateTimeZone ONE_HOUR = DateTimeZone.forOffsetHours(1); private static final DateTimeZone SIX = DateTimeZone.forOffsetHours(6); private static final DateTimeZone SEVEN = DateTimeZone.forOffsetHours(7); private static final DateTimeZone EIGHT = DateTimeZone.forOffsetHours(8); private static final DateTimeZone UTC = DateTimeZone.UTC; private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final Chronology ISO_EIGHT = ISOChronology.getInstance(EIGHT); private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS); private static final Chronology ISO_LONDON = ISOChronology.getInstance(LONDON); private static Chronology ISO; private static Chronology JULIAN; private DateTimeZone zone = null; private Locale locale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestStringConverter.class); } public TestStringConverter(String name) { super(name); } protected void setUp() throws Exception { zone = DateTimeZone.getDefault(); locale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); Locale.setDefault(Locale.UK); JULIAN = JulianChronology.getInstance(); ISO = ISOChronology.getInstance(); } protected void tearDown() throws Exception { DateTimeZone.setDefault(zone); Locale.setDefault(locale); zone = null; } //----------------------------------------------------------------------- public void testSingleton() throws Exception { Class cls = StringConverter.class; assertEquals(false, Modifier.isPublic(cls.getModifiers())); assertEquals(false, Modifier.isProtected(cls.getModifiers())); assertEquals(false, Modifier.isPrivate(cls.getModifiers())); Constructor con = cls.getDeclaredConstructor((Class[]) null); assertEquals(1, cls.getDeclaredConstructors().length); assertEquals(true, Modifier.isProtected(con.getModifiers())); Field fld = cls.getDeclaredField("INSTANCE"); assertEquals(false, Modifier.isPublic(fld.getModifiers())); assertEquals(false, Modifier.isProtected(fld.getModifiers())); assertEquals(false, Modifier.isPrivate(fld.getModifiers())); } //----------------------------------------------------------------------- public void testSupportedType() throws Exception { assertEquals(String.class, StringConverter.INSTANCE.getSupportedType()); } //----------------------------------------------------------------------- public void testGetInstantMillis_Object() throws Exception { DateTime dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, EIGHT); assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.501+08:00", ISO_EIGHT)); dt = new DateTime(2004, 1, 1, 0, 0, 0, 0, EIGHT); assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004T+08:00", ISO_EIGHT)); dt = new DateTime(2004, 6, 1, 0, 0, 0, 0, EIGHT); assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06T+08:00", ISO_EIGHT)); dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, EIGHT); assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T+08:00", ISO_EIGHT)); dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, EIGHT); assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-161T+08:00", ISO_EIGHT)); dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, EIGHT); assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-W24-3T+08:00", ISO_EIGHT)); dt = new DateTime(2004, 6, 7, 0, 0, 0, 0, EIGHT); assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-W24T+08:00", ISO_EIGHT)); dt = new DateTime(2004, 6, 9, 12, 0, 0, 0, EIGHT); assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12+08:00", ISO_EIGHT)); dt = new DateTime(2004, 6, 9, 12, 24, 0, 0, EIGHT); assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24+08:00", ISO_EIGHT)); dt = new DateTime(2004, 6, 9, 12, 24, 48, 0, EIGHT); assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48+08:00", ISO_EIGHT)); dt = new DateTime(2004, 6, 9, 12, 30, 0, 0, EIGHT); assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12.5+08:00", ISO_EIGHT)); dt = new DateTime(2004, 6, 9, 12, 24, 30, 0, EIGHT); assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24.5+08:00", ISO_EIGHT)); dt = new DateTime(2004, 6, 9, 12, 24, 48, 500, EIGHT); assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.5+08:00", ISO_EIGHT)); dt = new DateTime(2004, 6, 9, 12, 24, 48, 501); assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.501", ISO)); } public void testGetInstantMillis_Object_Zone() throws Exception { DateTime dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, PARIS); assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.501+02:00", ISO_PARIS)); dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, PARIS); assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.501", ISO_PARIS)); dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, LONDON); assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.501+01:00", ISO_LONDON)); dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, LONDON); assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.501", ISO_LONDON)); } public void testGetInstantMillis_Object_Chronology() throws Exception { DateTime dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, JulianChronology.getInstance(LONDON)); assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis("2004-06-09T12:24:48.501+01:00", JULIAN)); } public void testGetInstantMillisInvalid() { try { StringConverter.INSTANCE.getInstantMillis("", (Chronology) null); fail(); } catch (IllegalArgumentException ex) {} try { StringConverter.INSTANCE.getInstantMillis("X", (Chronology) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testGetChronology_Object_Zone() throws Exception { assertEquals(ISOChronology.getInstance(PARIS), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501+01:00", PARIS)); assertEquals(ISOChronology.getInstance(PARIS), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501", PARIS)); assertEquals(ISOChronology.getInstance(LONDON), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501+01:00", (DateTimeZone) null)); assertEquals(ISOChronology.getInstance(LONDON), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501", (DateTimeZone) null)); } public void testGetChronology_Object_Chronology() throws Exception { assertEquals(JulianChronology.getInstance(LONDON), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501+01:00", JULIAN)); assertEquals(JulianChronology.getInstance(LONDON), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501", JULIAN)); assertEquals(ISOChronology.getInstance(LONDON), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501+01:00", (Chronology) null)); assertEquals(ISOChronology.getInstance(LONDON), StringConverter.INSTANCE.getChronology("2004-06-09T12:24:48.501", (Chronology) null)); } //----------------------------------------------------------------------- public void testGetPartialValues() throws Exception { TimeOfDay tod = new TimeOfDay(); int[] expected = new int[] {3, 4, 5, 6}; int[] actual = StringConverter.INSTANCE.getPartialValues(tod, "T03:04:05.006", ISOChronology.getInstance()); assertEquals(true, Arrays.equals(expected, actual)); } //----------------------------------------------------------------------- public void testGetDateTime() throws Exception { DateTime base = new DateTime(2004, 6, 9, 12, 24, 48, 501, PARIS); DateTime test = new DateTime(base.toString(), PARIS); assertEquals(base, test); } public void testGetDateTime1() throws Exception { DateTime test = new DateTime("2004-06-09T12:24:48.501+01:00"); assertEquals(2004, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(12, test.getHourOfDay()); assertEquals(24, test.getMinuteOfHour()); assertEquals(48, test.getSecondOfMinute()); assertEquals(501, test.getMillisOfSecond()); assertEquals(LONDON, test.getZone()); } public void testGetDateTime2() throws Exception { DateTime test = new DateTime("2004-06-09T12:24:48.501"); assertEquals(2004, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(12, test.getHourOfDay()); assertEquals(24, test.getMinuteOfHour()); assertEquals(48, test.getSecondOfMinute()); assertEquals(501, test.getMillisOfSecond()); assertEquals(LONDON, test.getZone()); } public void testGetDateTime3() throws Exception { DateTime test = new DateTime("2004-06-09T12:24:48.501+02:00", PARIS); assertEquals(2004, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(12, test.getHourOfDay()); assertEquals(24, test.getMinuteOfHour()); assertEquals(48, test.getSecondOfMinute()); assertEquals(501, test.getMillisOfSecond()); assertEquals(PARIS, test.getZone()); } public void testGetDateTime4() throws Exception { DateTime test = new DateTime("2004-06-09T12:24:48.501", PARIS); assertEquals(2004, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(12, test.getHourOfDay()); assertEquals(24, test.getMinuteOfHour()); assertEquals(48, test.getSecondOfMinute()); assertEquals(501, test.getMillisOfSecond()); assertEquals(PARIS, test.getZone()); } public void testGetDateTime5() throws Exception { DateTime test = new DateTime("2004-06-09T12:24:48.501+02:00", JulianChronology.getInstance(PARIS)); assertEquals(2004, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(12, test.getHourOfDay()); assertEquals(24, test.getMinuteOfHour()); assertEquals(48, test.getSecondOfMinute()); assertEquals(501, test.getMillisOfSecond()); assertEquals(PARIS, test.getZone()); } public void testGetDateTime6() throws Exception { DateTime test = new DateTime("2004-06-09T12:24:48.501", JulianChronology.getInstance(PARIS)); assertEquals(2004, test.getYear()); assertEquals(6, test.getMonthOfYear()); assertEquals(9, test.getDayOfMonth()); assertEquals(12, test.getHourOfDay()); assertEquals(24, test.getMinuteOfHour()); assertEquals(48, test.getSecondOfMinute()); assertEquals(501, test.getMillisOfSecond()); assertEquals(PARIS, test.getZone()); } //----------------------------------------------------------------------- public void testGetDurationMillis_Object1() throws Exception { long millis = StringConverter.INSTANCE.getDurationMillis("PT12.345S"); assertEquals(12345, millis); millis = StringConverter.INSTANCE.getDurationMillis("pt12.345s"); assertEquals(12345, millis); millis = StringConverter.INSTANCE.getDurationMillis("pt12s"); assertEquals(12000, millis); millis = StringConverter.INSTANCE.getDurationMillis("pt12.s"); assertEquals(12000, millis); millis = StringConverter.INSTANCE.getDurationMillis("pt-12.32s"); assertEquals(-12320, millis); millis = StringConverter.INSTANCE.getDurationMillis("pt-0.32s"); assertEquals(-320, millis); millis = StringConverter.INSTANCE.getDurationMillis("pt-0.0s"); assertEquals(0, millis); millis = StringConverter.INSTANCE.getDurationMillis("pt0.0s"); assertEquals(0, millis); millis = StringConverter.INSTANCE.getDurationMillis("pt12.3456s"); assertEquals(12345, millis); } public void testGetDurationMillis_Object2() throws Exception { try { StringConverter.INSTANCE.getDurationMillis("P2Y6M9DXYZ"); fail(); } catch (IllegalArgumentException ex) {} try { StringConverter.INSTANCE.getDurationMillis("PTS"); fail(); } catch (IllegalArgumentException ex) {} try { StringConverter.INSTANCE.getDurationMillis("XT0S"); fail(); } catch (IllegalArgumentException ex) {} try { StringConverter.INSTANCE.getDurationMillis("PX0S"); fail(); } catch (IllegalArgumentException ex) {} try { StringConverter.INSTANCE.getDurationMillis("PT0X"); fail(); } catch (IllegalArgumentException ex) {} try { StringConverter.INSTANCE.getDurationMillis("PTXS"); fail(); } catch (IllegalArgumentException ex) {} try { StringConverter.INSTANCE.getDurationMillis("PT0.0.0S"); fail(); } catch (IllegalArgumentException ex) {} try { StringConverter.INSTANCE.getDurationMillis("PT0-00S"); fail(); } catch (IllegalArgumentException ex) {} try { StringConverter.INSTANCE.getDurationMillis("PT-.001S"); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testGetPeriodType_Object() throws Exception { assertEquals(PeriodType.standard(), StringConverter.INSTANCE.getPeriodType("P2Y6M9D")); } public void testSetIntoPeriod_Object1() throws Exception { MutablePeriod m = new MutablePeriod(PeriodType.yearMonthDayTime()); StringConverter.INSTANCE.setInto(m, "P2Y6M9DT12H24M48S", null); assertEquals(2, m.getYears()); assertEquals(6, m.getMonths()); assertEquals(9, m.getDays()); assertEquals(12, m.getHours()); assertEquals(24, m.getMinutes()); assertEquals(48, m.getSeconds()); assertEquals(0, m.getMillis()); } public void testSetIntoPeriod_Object2() throws Exception { MutablePeriod m = new MutablePeriod(PeriodType.yearWeekDayTime()); StringConverter.INSTANCE.setInto(m, "P2Y4W3DT12H24M48S", null); assertEquals(2, m.getYears()); assertEquals(4, m.getWeeks()); assertEquals(3, m.getDays()); assertEquals(12, m.getHours()); assertEquals(24, m.getMinutes()); assertEquals(48, m.getSeconds()); assertEquals(0, m.getMillis()); } public void testSetIntoPeriod_Object3() throws Exception { MutablePeriod m = new MutablePeriod(PeriodType.yearWeekDayTime()); StringConverter.INSTANCE.setInto(m, "P2Y4W3DT12H24M48.034S", null); assertEquals(2, m.getYears()); assertEquals(4, m.getWeeks()); assertEquals(3, m.getDays()); assertEquals(12, m.getHours()); assertEquals(24, m.getMinutes()); assertEquals(48, m.getSeconds()); assertEquals(34, m.getMillis()); } public void testSetIntoPeriod_Object4() throws Exception { MutablePeriod m = new MutablePeriod(PeriodType.yearWeekDayTime()); StringConverter.INSTANCE.setInto(m, "P2Y4W3DT12H24M.056S", null); assertEquals(2, m.getYears()); assertEquals(4, m.getWeeks()); assertEquals(3, m.getDays()); assertEquals(12, m.getHours()); assertEquals(24, m.getMinutes()); assertEquals(0, m.getSeconds()); assertEquals(56, m.getMillis()); } public void testSetIntoPeriod_Object5() throws Exception { MutablePeriod m = new MutablePeriod(PeriodType.yearWeekDayTime()); StringConverter.INSTANCE.setInto(m, "P2Y4W3DT12H24M56.S", null); assertEquals(2, m.getYears()); assertEquals(4, m.getWeeks()); assertEquals(3, m.getDays()); assertEquals(12, m.getHours()); assertEquals(24, m.getMinutes()); assertEquals(56, m.getSeconds()); assertEquals(0, m.getMillis()); } public void testSetIntoPeriod_Object6() throws Exception { MutablePeriod m = new MutablePeriod(PeriodType.yearWeekDayTime()); StringConverter.INSTANCE.setInto(m, "P2Y4W3DT12H24M56.1234567S", null); assertEquals(2, m.getYears()); assertEquals(4, m.getWeeks()); assertEquals(3, m.getDays()); assertEquals(12, m.getHours()); assertEquals(24, m.getMinutes()); assertEquals(56, m.getSeconds()); assertEquals(123, m.getMillis()); } public void testSetIntoPeriod_Object7() throws Exception { MutablePeriod m = new MutablePeriod(1, 0, 1, 1, 1, 1, 1, 1, PeriodType.yearWeekDayTime()); StringConverter.INSTANCE.setInto(m, "P2Y4W3D", null); assertEquals(2, m.getYears()); assertEquals(4, m.getWeeks()); assertEquals(3, m.getDays()); assertEquals(0, m.getHours()); assertEquals(0, m.getMinutes()); assertEquals(0, m.getSeconds()); assertEquals(0, m.getMillis()); } public void testSetIntoPeriod_Object8() throws Exception { MutablePeriod m = new MutablePeriod(); try { StringConverter.INSTANCE.setInto(m, "", null); fail(); } catch (IllegalArgumentException ex) {} try { StringConverter.INSTANCE.setInto(m, "PXY", null); fail(); } catch (IllegalArgumentException ex) {} try { StringConverter.INSTANCE.setInto(m, "PT0SXY", null); fail(); } catch (IllegalArgumentException ex) {} try { StringConverter.INSTANCE.setInto(m, "P2Y4W3DT12H24M48SX", null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testIsReadableInterval_Object_Chronology() throws Exception { assertEquals(false, StringConverter.INSTANCE.isReadableInterval("", null)); } public void testSetIntoInterval_Object_Chronology1() throws Exception { MutableInterval m = new MutableInterval(-1000L, 1000L); StringConverter.INSTANCE.setInto(m, "2004-06-09/P1Y2M", null); assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0), m.getStart()); assertEquals(new DateTime(2005, 8, 9, 0, 0, 0, 0), m.getEnd()); assertEquals(ISOChronology.getInstance(), m.getChronology()); } public void testSetIntoInterval_Object_Chronology2() throws Exception { MutableInterval m = new MutableInterval(-1000L, 1000L); StringConverter.INSTANCE.setInto(m, "P1Y2M/2004-06-09", null); assertEquals(new DateTime(2003, 4, 9, 0, 0, 0, 0), m.getStart()); assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0), m.getEnd()); assertEquals(ISOChronology.getInstance(), m.getChronology()); } public void testSetIntoInterval_Object_Chronology3() throws Exception { MutableInterval m = new MutableInterval(-1000L, 1000L); StringConverter.INSTANCE.setInto(m, "2003-08-09/2004-06-09", null); assertEquals(new DateTime(2003, 8, 9, 0, 0, 0, 0), m.getStart()); assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0), m.getEnd()); assertEquals(ISOChronology.getInstance(), m.getChronology()); } public void testSetIntoInterval_Object_Chronology4() throws Exception { MutableInterval m = new MutableInterval(-1000L, 1000L); StringConverter.INSTANCE.setInto(m, "2004-06-09T+06:00/P1Y2M", null); assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0, SIX).withChronology(null), m.getStart()); assertEquals(new DateTime(2005, 8, 9, 0, 0, 0, 0, SIX).withChronology(null), m.getEnd()); assertEquals(ISOChronology.getInstance(), m.getChronology()); } public void testSetIntoInterval_Object_Chronology5() throws Exception { MutableInterval m = new MutableInterval(-1000L, 1000L); StringConverter.INSTANCE.setInto(m, "P1Y2M/2004-06-09T+06:00", null); assertEquals(new DateTime(2003, 4, 9, 0, 0, 0, 0, SIX).withChronology(null), m.getStart()); assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0, SIX).withChronology(null), m.getEnd()); assertEquals(ISOChronology.getInstance(), m.getChronology()); } public void testSetIntoInterval_Object_Chronology6() throws Exception { MutableInterval m = new MutableInterval(-1000L, 1000L); StringConverter.INSTANCE.setInto(m, "2003-08-09T+06:00/2004-06-09T+07:00", null); assertEquals(new DateTime(2003, 8, 9, 0, 0, 0, 0, SIX).withChronology(null), m.getStart()); assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0, SEVEN).withChronology(null), m.getEnd()); assertEquals(ISOChronology.getInstance(), m.getChronology()); } public void testSetIntoInterval_Object_Chronology7() throws Exception { MutableInterval m = new MutableInterval(-1000L, 1000L); StringConverter.INSTANCE.setInto(m, "2003-08-09/2004-06-09", BuddhistChronology.getInstance()); assertEquals(new DateTime(2003, 8, 9, 0, 0, 0, 0, BuddhistChronology.getInstance()), m.getStart()); assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0, BuddhistChronology.getInstance()), m.getEnd()); assertEquals(BuddhistChronology.getInstance(), m.getChronology()); } public void testSetIntoInterval_Object_Chronology8() throws Exception { MutableInterval m = new MutableInterval(-1000L, 1000L); StringConverter.INSTANCE.setInto(m, "2003-08-09T+06:00/2004-06-09T+07:00", BuddhistChronology.getInstance(EIGHT)); assertEquals(new DateTime(2003, 8, 9, 0, 0, 0, 0, BuddhistChronology.getInstance(SIX)).withZone(EIGHT), m.getStart()); assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0, BuddhistChronology.getInstance(SEVEN)).withZone(EIGHT), m.getEnd()); assertEquals(BuddhistChronology.getInstance(EIGHT), m.getChronology()); } public void testSetIntoIntervalEx_Object_Chronology1() throws Exception { MutableInterval m = new MutableInterval(-1000L, 1000L); try { StringConverter.INSTANCE.setInto(m, "", null); fail(); } catch (IllegalArgumentException ex) {} } public void testSetIntoIntervalEx_Object_Chronology2() throws Exception { MutableInterval m = new MutableInterval(-1000L, 1000L); try { StringConverter.INSTANCE.setInto(m, "/", null); fail(); } catch (IllegalArgumentException ex) {} } public void testSetIntoIntervalEx_Object_Chronology3() throws Exception { MutableInterval m = new MutableInterval(-1000L, 1000L); try { StringConverter.INSTANCE.setInto(m, "P1Y/", null); fail(); } catch (IllegalArgumentException ex) {} } public void testSetIntoIntervalEx_Object_Chronology4() throws Exception { MutableInterval m = new MutableInterval(-1000L, 1000L); try { StringConverter.INSTANCE.setInto(m, "/P1Y", null); fail(); } catch (IllegalArgumentException ex) {} } public void testSetIntoIntervalEx_Object_Chronology5() throws Exception { MutableInterval m = new MutableInterval(-1000L, 1000L); try { StringConverter.INSTANCE.setInto(m, "P1Y/P2Y", null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testToString() { assertEquals("Converter[java.lang.String]", StringConverter.INSTANCE.toString()); } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.field; import java.util.Arrays; import java.util.Locale; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.Chronology; import org.joda.time.DateTimeField; import org.joda.time.DateTimeFieldType; import org.joda.time.DurationField; import org.joda.time.DurationFieldType; import org.joda.time.TimeOfDay; import org.joda.time.base.BasePartial; import org.joda.time.chrono.ISOChronology; /** * This class is a Junit unit test for BaseDateTimeField. * * @author Stephen Colebourne */ public class TestBaseDateTimeField extends TestCase { public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestBaseDateTimeField.class); } public TestBaseDateTimeField(String name) { super(name); } protected void setUp() throws Exception { } protected void tearDown() throws Exception { } //----------------------------------------------------------------------- public void test_constructor() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals(DateTimeFieldType.secondOfMinute(), field.getType()); try { field = new MockBaseDateTimeField(null); fail(); } catch (IllegalArgumentException ex) {} } public void test_getType() { BaseDateTimeField field = new MockBaseDateTimeField(DateTimeFieldType.secondOfDay()); assertEquals(DateTimeFieldType.secondOfDay(), field.getType()); } public void test_getName() { BaseDateTimeField field = new MockBaseDateTimeField(DateTimeFieldType.secondOfDay()); assertEquals("secondOfDay", field.getName()); } public void test_toString() { BaseDateTimeField field = new MockBaseDateTimeField(DateTimeFieldType.secondOfDay()); assertEquals("DateTimeField[secondOfDay]", field.toString()); } public void test_isSupported() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals(true, field.isSupported()); } public void test_get() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals(0, field.get(0)); assertEquals(1, field.get(60)); assertEquals(2, field.get(123)); } //----------------------------------------------------------------------- public void test_getAsText_long_Locale() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals("29", field.getAsText(60L * 29, Locale.ENGLISH)); assertEquals("29", field.getAsText(60L * 29, null)); } public void test_getAsText_long() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals("29", field.getAsText(60L * 29)); } public void test_getAsText_RP_int_Locale() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals("20", field.getAsText(new TimeOfDay(12, 30, 40, 50), 20, Locale.ENGLISH)); assertEquals("20", field.getAsText(new TimeOfDay(12, 30, 40, 50), 20, null)); } public void test_getAsText_RP_Locale() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals("40", field.getAsText(new TimeOfDay(12, 30, 40, 50), Locale.ENGLISH)); assertEquals("40", field.getAsText(new TimeOfDay(12, 30, 40, 50), null)); } public void test_getAsText_int_Locale() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals("80", field.getAsText(80, Locale.ENGLISH)); assertEquals("80", field.getAsText(80, null)); } //----------------------------------------------------------------------- public void test_getAsShortText_long_Locale() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals("29", field.getAsShortText(60L * 29, Locale.ENGLISH)); assertEquals("29", field.getAsShortText(60L * 29, null)); } public void test_getAsShortText_long() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals("29", field.getAsShortText(60L * 29)); } public void test_getAsShortText_RP_int_Locale() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals("20", field.getAsShortText(new TimeOfDay(12, 30, 40, 50), 20, Locale.ENGLISH)); assertEquals("20", field.getAsShortText(new TimeOfDay(12, 30, 40, 50), 20, null)); } public void test_getAsShortText_RP_Locale() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals("40", field.getAsShortText(new TimeOfDay(12, 30, 40, 50), Locale.ENGLISH)); assertEquals("40", field.getAsShortText(new TimeOfDay(12, 30, 40, 50), null)); } public void test_getAsShortText_int_Locale() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals("80", field.getAsShortText(80, Locale.ENGLISH)); assertEquals("80", field.getAsShortText(80, null)); } //----------------------------------------------------------------------- public void test_add_long_int() { MockCountingDurationField.add_int = 0; BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals(61, field.add(1L, 1)); assertEquals(1, MockCountingDurationField.add_int); } public void test_add_long_long() { MockCountingDurationField.add_long = 0; BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals(61, field.add(1L, 1L)); assertEquals(1, MockCountingDurationField.add_long); } public void test_add_RP_int_intarray_int() { int[] values = new int[] {10, 20, 30, 40}; int[] expected = new int[] {10, 20, 30, 40}; BaseDateTimeField field = new MockStandardBaseDateTimeField(); int[] result = field.add(new TimeOfDay(), 2, values, 0); assertEquals(true, Arrays.equals(expected, result)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 31, 40}; result = field.add(new TimeOfDay(), 2, values, 1); assertEquals(true, Arrays.equals(expected, result)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 21, 0, 40}; result = field.add(new TimeOfDay(), 2, values, 30); assertEquals(true, Arrays.equals(expected, result)); values = new int[] {23, 59, 30, 40}; try { field.add(new TimeOfDay(), 2, values, 30); fail(); } catch (IllegalArgumentException ex) {} values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 29, 40}; result = field.add(new TimeOfDay(), 2, values, -1); assertEquals(true, Arrays.equals(expected, result)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 19, 59, 40}; result = field.add(new TimeOfDay(), 2, values, -31); assertEquals(true, Arrays.equals(expected, result)); values = new int[] {0, 0, 30, 40}; try { field.add(new TimeOfDay(), 2, values, -31); fail(); } catch (IllegalArgumentException ex) {} values = new int[] {0, 0}; try { field.add(new MockPartial(), 0, values, 1000); fail(); } catch (IllegalArgumentException ex) {} values = new int[] {1, 0}; try { field.add(new MockPartial(), 0, values, -1000); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void test_addWrapField_long_int() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals(1029, field.addWrapField(60L * 29, 0)); assertEquals(1059, field.addWrapField(60L * 29, 30)); assertEquals(1000, field.addWrapField(60L * 29, 31)); } public void test_addWrapField_RP_int_intarray_int() { BaseDateTimeField field = new MockBaseDateTimeField(); int[] values = new int[] {10, 20, 30, 40}; int[] expected = new int[] {10, 20, 30, 40}; int[] result = field.addWrapField(new TimeOfDay(), 2, values, 0); assertEquals(true, Arrays.equals(result, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 59, 40}; result = field.addWrapField(new TimeOfDay(), 2, values, 29); assertEquals(true, Arrays.equals(result, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 0, 40}; result = field.addWrapField(new TimeOfDay(), 2, values, 30); assertEquals(true, Arrays.equals(result, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 1, 40}; result = field.addWrapField(new TimeOfDay(), 2, values, 31); assertEquals(true, Arrays.equals(result, expected)); } //----------------------------------------------------------------------- public void test_getDifference_long_long() { MockCountingDurationField.difference_long = 0; BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals(30, field.getDifference(0L, 0L)); assertEquals(1, MockCountingDurationField.difference_long); } public void test_getDifferenceAsLong_long_long() { MockCountingDurationField.difference_long = 0; BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals(30, field.getDifferenceAsLong(0L, 0L)); assertEquals(1, MockCountingDurationField.difference_long); } //----------------------------------------------------------------------- public void test_set_long_int() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals(1000, field.set(0L, 0)); assertEquals(1029, field.set(0L, 29)); } public void test_set_RP_int_intarray_int() { BaseDateTimeField field = new MockBaseDateTimeField(); int[] values = new int[] {10, 20, 30, 40}; int[] expected = new int[] {10, 20, 30, 40}; int[] result = field.set(new TimeOfDay(), 2, values, 30); assertEquals(true, Arrays.equals(result, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 29, 40}; result = field.set(new TimeOfDay(), 2, values, 29); assertEquals(true, Arrays.equals(result, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 30, 40}; try { field.set(new TimeOfDay(), 2, values, 60); fail(); } catch (IllegalArgumentException ex) {} assertEquals(true, Arrays.equals(values, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 30, 40}; try { field.set(new TimeOfDay(), 2, values, -1); fail(); } catch (IllegalArgumentException ex) {} assertEquals(true, Arrays.equals(values, expected)); } public void test_set_long_String_Locale() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals(1000, field.set(0L, "0", null)); assertEquals(1029, field.set(0L, "29", Locale.ENGLISH)); } public void test_set_long_String() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals(1000, field.set(0L, "0")); assertEquals(1029, field.set(0L, "29")); } public void test_set_RP_int_intarray_String_Locale() { BaseDateTimeField field = new MockBaseDateTimeField(); int[] values = new int[] {10, 20, 30, 40}; int[] expected = new int[] {10, 20, 30, 40}; int[] result = field.set(new TimeOfDay(), 2, values, "30", null); assertEquals(true, Arrays.equals(result, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 29, 40}; result = field.set(new TimeOfDay(), 2, values, "29", Locale.ENGLISH); assertEquals(true, Arrays.equals(result, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 30, 40}; try { field.set(new TimeOfDay(), 2, values, "60", null); fail(); } catch (IllegalArgumentException ex) {} assertEquals(true, Arrays.equals(values, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 30, 40}; try { field.set(new TimeOfDay(), 2, values, "-1", null); fail(); } catch (IllegalArgumentException ex) {} assertEquals(true, Arrays.equals(values, expected)); } public void test_convertText() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals(0, field.convertText("0", null)); assertEquals(29, field.convertText("29", null)); try { field.convertText("2A", null); fail(); } catch (IllegalArgumentException ex) {} try { field.convertText(null, null); fail(); } catch (IllegalArgumentException ex) {} } //------------------------------------------------------------------------ // public abstract DurationField getDurationField(); // // public abstract DurationField getRangeDurationField(); public void test_isLeap_long() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals(false, field.isLeap(0L)); } public void test_getLeapAmount_long() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals(0, field.getLeapAmount(0L)); } public void test_getLeapDurationField() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals(null, field.getLeapDurationField()); } //----------------------------------------------------------------------- public void test_getMinimumValue() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals(0, field.getMinimumValue()); } public void test_getMinimumValue_long() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals(0, field.getMinimumValue(0L)); } public void test_getMinimumValue_RP() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals(0, field.getMinimumValue(new TimeOfDay())); } public void test_getMinimumValue_RP_intarray() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals(0, field.getMinimumValue(new TimeOfDay(), new int[4])); } public void test_getMaximumValue() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals(59, field.getMaximumValue()); } public void test_getMaximumValue_long() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals(59, field.getMaximumValue(0L)); } public void test_getMaximumValue_RP() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals(59, field.getMaximumValue(new TimeOfDay())); } public void test_getMaximumValue_RP_intarray() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals(59, field.getMaximumValue(new TimeOfDay(), new int[4])); } //----------------------------------------------------------------------- public void test_getMaximumTextLength_Locale() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals(2, field.getMaximumTextLength(Locale.ENGLISH)); field = new MockBaseDateTimeField() { public int getMaximumValue() { return 5; } }; assertEquals(1, field.getMaximumTextLength(Locale.ENGLISH)); field = new MockBaseDateTimeField() { public int getMaximumValue() { return 555; } }; assertEquals(3, field.getMaximumTextLength(Locale.ENGLISH)); field = new MockBaseDateTimeField() { public int getMaximumValue() { return 5555; } }; assertEquals(4, field.getMaximumTextLength(Locale.ENGLISH)); field = new MockBaseDateTimeField() { public int getMaximumValue() { return -1; } }; assertEquals(2, field.getMaximumTextLength(Locale.ENGLISH)); } public void test_getMaximumShortTextLength_Locale() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals(2, field.getMaximumShortTextLength(Locale.ENGLISH)); } //------------------------------------------------------------------------ public void test_roundFloor_long() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals(0L, field.roundFloor(0L)); assertEquals(0L, field.roundFloor(29L)); assertEquals(0L, field.roundFloor(30L)); assertEquals(0L, field.roundFloor(31L)); assertEquals(60L, field.roundFloor(60L)); } public void test_roundCeiling_long() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals(0L, field.roundCeiling(0L)); assertEquals(60L, field.roundCeiling(29L)); assertEquals(60L, field.roundCeiling(30L)); assertEquals(60L, field.roundCeiling(31L)); assertEquals(60L, field.roundCeiling(60L)); } public void test_roundHalfFloor_long() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals(0L, field.roundHalfFloor(0L)); assertEquals(0L, field.roundHalfFloor(29L)); assertEquals(0L, field.roundHalfFloor(30L)); assertEquals(60L, field.roundHalfFloor(31L)); assertEquals(60L, field.roundHalfFloor(60L)); } public void test_roundHalfCeiling_long() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals(0L, field.roundHalfCeiling(0L)); assertEquals(0L, field.roundHalfCeiling(29L)); assertEquals(60L, field.roundHalfCeiling(30L)); assertEquals(60L, field.roundHalfCeiling(31L)); assertEquals(60L, field.roundHalfCeiling(60L)); } public void test_roundHalfEven_long() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals(0L, field.roundHalfEven(0L)); assertEquals(0L, field.roundHalfEven(29L)); assertEquals(0L, field.roundHalfEven(30L)); assertEquals(60L, field.roundHalfEven(31L)); assertEquals(60L, field.roundHalfEven(60L)); assertEquals(60L, field.roundHalfEven(89L)); assertEquals(120L, field.roundHalfEven(90L)); assertEquals(120L, field.roundHalfEven(91L)); } public void test_remainder_long() { BaseDateTimeField field = new MockBaseDateTimeField(); assertEquals(0L, field.remainder(0L)); assertEquals(29L, field.remainder(29L)); assertEquals(30L, field.remainder(30L)); assertEquals(31L, field.remainder(31L)); assertEquals(0L, field.remainder(60L)); } //----------------------------------------------------------------------- static class MockBaseDateTimeField extends BaseDateTimeField { protected MockBaseDateTimeField() { super(DateTimeFieldType.secondOfMinute()); } protected MockBaseDateTimeField(DateTimeFieldType type) { super(type); } public int get(long instant) { return (int) (instant / 60L); } public long set(long instant, int value) { return 1000 + value; } public DurationField getDurationField() { return new MockCountingDurationField(DurationFieldType.seconds()); } public DurationField getRangeDurationField() { return new MockCountingDurationField(DurationFieldType.minutes()); } public int getMinimumValue() { return 0; } public int getMaximumValue() { return 59; } public long roundFloor(long instant) { return (instant / 60L) * 60L; } public boolean isLenient() { return false; } } static class MockStandardBaseDateTimeField extends MockBaseDateTimeField { protected MockStandardBaseDateTimeField() { super(); } public DurationField getDurationField() { return ISOChronology.getInstanceUTC().seconds(); } public DurationField getRangeDurationField() { return ISOChronology.getInstanceUTC().minutes(); } } //----------------------------------------------------------------------- static class MockCountingDurationField extends BaseDurationField { static int add_int = 0; static int add_long = 0; static int difference_long = 0; protected MockCountingDurationField(DurationFieldType type) { super(type); } public boolean isPrecise() { return false; } public long getUnitMillis() { return 0; } public long getValueAsLong(long duration, long instant) { return 0; } public long getMillis(int value, long instant) { return 0; } public long getMillis(long value, long instant) { return 0; } public long add(long instant, int value) { add_int++; return instant + (value * 60L); } public long add(long instant, long value) { add_long++; return instant + (value * 60L); } public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { difference_long++; return 30; } } static class MockPartial extends BasePartial { protected DateTimeField getField(int index, Chronology chrono) { if (index == 0) { return ISOChronology.getInstanceUTC().minuteOfHour(); } if (index == 1) { return ISOChronology.getInstanceUTC().millisOfSecond(); } return null; } public int size() { return 2; } } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.field; import junit.framework.TestCase; import junit.framework.TestSuite; /** * * * @author Brian S O'Neill */ public class TestFieldUtils extends TestCase { public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestFieldUtils.class); } public TestFieldUtils(String name) { super(name); } public void testSafeAddInt() { assertEquals(0, FieldUtils.safeAdd(0, 0)); assertEquals(5, FieldUtils.safeAdd(2, 3)); assertEquals(-1, FieldUtils.safeAdd(2, -3)); assertEquals(1, FieldUtils.safeAdd(-2, 3)); assertEquals(-5, FieldUtils.safeAdd(-2, -3)); assertEquals(Integer.MAX_VALUE - 1, FieldUtils.safeAdd(Integer.MAX_VALUE, -1)); assertEquals(Integer.MIN_VALUE + 1, FieldUtils.safeAdd(Integer.MIN_VALUE, 1)); assertEquals(-1, FieldUtils.safeAdd(Integer.MIN_VALUE, Integer.MAX_VALUE)); assertEquals(-1, FieldUtils.safeAdd(Integer.MAX_VALUE, Integer.MIN_VALUE)); try { FieldUtils.safeAdd(Integer.MAX_VALUE, 1); fail(); } catch (ArithmeticException e) { } try { FieldUtils.safeAdd(Integer.MAX_VALUE, 100); fail(); } catch (ArithmeticException e) { } try { FieldUtils.safeAdd(Integer.MAX_VALUE, Integer.MAX_VALUE); fail(); } catch (ArithmeticException e) { } try { FieldUtils.safeAdd(Integer.MIN_VALUE, -1); fail(); } catch (ArithmeticException e) { } try { FieldUtils.safeAdd(Integer.MIN_VALUE, -100); fail(); } catch (ArithmeticException e) { } try { FieldUtils.safeAdd(Integer.MIN_VALUE, Integer.MIN_VALUE); fail(); } catch (ArithmeticException e) { } } public void testSafeAddLong() { assertEquals(0L, FieldUtils.safeAdd(0L, 0L)); assertEquals(5L, FieldUtils.safeAdd(2L, 3L)); assertEquals(-1L, FieldUtils.safeAdd(2L, -3L)); assertEquals(1L, FieldUtils.safeAdd(-2L, 3L)); assertEquals(-5L, FieldUtils.safeAdd(-2L, -3L)); assertEquals(Long.MAX_VALUE - 1, FieldUtils.safeAdd(Long.MAX_VALUE, -1L)); assertEquals(Long.MIN_VALUE + 1, FieldUtils.safeAdd(Long.MIN_VALUE, 1L)); assertEquals(-1, FieldUtils.safeAdd(Long.MIN_VALUE, Long.MAX_VALUE)); assertEquals(-1, FieldUtils.safeAdd(Long.MAX_VALUE, Long.MIN_VALUE)); try { FieldUtils.safeAdd(Long.MAX_VALUE, 1L); fail(); } catch (ArithmeticException e) { } try { FieldUtils.safeAdd(Long.MAX_VALUE, 100L); fail(); } catch (ArithmeticException e) { } try { FieldUtils.safeAdd(Long.MAX_VALUE, Long.MAX_VALUE); fail(); } catch (ArithmeticException e) { } try { FieldUtils.safeAdd(Long.MIN_VALUE, -1L); fail(); } catch (ArithmeticException e) { } try { FieldUtils.safeAdd(Long.MIN_VALUE, -100L); fail(); } catch (ArithmeticException e) { } try { FieldUtils.safeAdd(Long.MIN_VALUE, Long.MIN_VALUE); fail(); } catch (ArithmeticException e) { } } public void testSafeSubtractLong() { assertEquals(0L, FieldUtils.safeSubtract(0L, 0L)); assertEquals(-1L, FieldUtils.safeSubtract(2L, 3L)); assertEquals(5L, FieldUtils.safeSubtract(2L, -3L)); assertEquals(-5L, FieldUtils.safeSubtract(-2L, 3L)); assertEquals(1L, FieldUtils.safeSubtract(-2L, -3L)); assertEquals(Long.MAX_VALUE - 1, FieldUtils.safeSubtract(Long.MAX_VALUE, 1L)); assertEquals(Long.MIN_VALUE + 1, FieldUtils.safeSubtract(Long.MIN_VALUE, -1L)); assertEquals(0, FieldUtils.safeSubtract(Long.MIN_VALUE, Long.MIN_VALUE)); assertEquals(0, FieldUtils.safeSubtract(Long.MAX_VALUE, Long.MAX_VALUE)); try { FieldUtils.safeSubtract(Long.MIN_VALUE, 1L); fail(); } catch (ArithmeticException e) { } try { FieldUtils.safeSubtract(Long.MIN_VALUE, 100L); fail(); } catch (ArithmeticException e) { } try { FieldUtils.safeSubtract(Long.MIN_VALUE, Long.MAX_VALUE); fail(); } catch (ArithmeticException e) { } try { FieldUtils.safeSubtract(Long.MAX_VALUE, -1L); fail(); } catch (ArithmeticException e) { } try { FieldUtils.safeSubtract(Long.MAX_VALUE, -100L); fail(); } catch (ArithmeticException e) { } try { FieldUtils.safeSubtract(Long.MAX_VALUE, Long.MIN_VALUE); fail(); } catch (ArithmeticException e) { } } //----------------------------------------------------------------------- public void testSafeMultiplyLongLong() { assertEquals(0L, FieldUtils.safeMultiply(0L, 0L)); assertEquals(1L, FieldUtils.safeMultiply(1L, 1L)); assertEquals(3L, FieldUtils.safeMultiply(1L, 3L)); assertEquals(3L, FieldUtils.safeMultiply(3L, 1L)); assertEquals(6L, FieldUtils.safeMultiply(2L, 3L)); assertEquals(-6L, FieldUtils.safeMultiply(2L, -3L)); assertEquals(-6L, FieldUtils.safeMultiply(-2L, 3L)); assertEquals(6L, FieldUtils.safeMultiply(-2L, -3L)); assertEquals(Long.MAX_VALUE, FieldUtils.safeMultiply(Long.MAX_VALUE, 1L)); assertEquals(Long.MIN_VALUE, FieldUtils.safeMultiply(Long.MIN_VALUE, 1L)); assertEquals(-Long.MAX_VALUE, FieldUtils.safeMultiply(Long.MAX_VALUE, -1L)); try { FieldUtils.safeMultiply(Long.MIN_VALUE, -1L); fail(); } catch (ArithmeticException e) { } try { FieldUtils.safeMultiply(-1L, Long.MIN_VALUE); fail(); } catch (ArithmeticException e) { } try { FieldUtils.safeMultiply(Long.MIN_VALUE, 100L); fail(); } catch (ArithmeticException e) { } try { FieldUtils.safeMultiply(Long.MIN_VALUE, Long.MAX_VALUE); fail(); } catch (ArithmeticException e) { } try { FieldUtils.safeMultiply(Long.MAX_VALUE, Long.MIN_VALUE); fail(); } catch (ArithmeticException e) { } } //----------------------------------------------------------------------- public void testSafeMultiplyLongInt() { assertEquals(0L, FieldUtils.safeMultiply(0L, 0)); assertEquals(1L, FieldUtils.safeMultiply(1L, 1)); assertEquals(3L, FieldUtils.safeMultiply(1L, 3)); assertEquals(3L, FieldUtils.safeMultiply(3L, 1)); assertEquals(6L, FieldUtils.safeMultiply(2L, 3)); assertEquals(-6L, FieldUtils.safeMultiply(2L, -3)); assertEquals(-6L, FieldUtils.safeMultiply(-2L, 3)); assertEquals(6L, FieldUtils.safeMultiply(-2L, -3)); assertEquals(-1L * Integer.MIN_VALUE, FieldUtils.safeMultiply(-1L, Integer.MIN_VALUE)); assertEquals(Long.MAX_VALUE, FieldUtils.safeMultiply(Long.MAX_VALUE, 1)); assertEquals(Long.MIN_VALUE, FieldUtils.safeMultiply(Long.MIN_VALUE, 1)); assertEquals(-Long.MAX_VALUE, FieldUtils.safeMultiply(Long.MAX_VALUE, -1)); try { FieldUtils.safeMultiply(Long.MIN_VALUE, -1); fail(); } catch (ArithmeticException e) { } try { FieldUtils.safeMultiply(Long.MIN_VALUE, 100); fail(); } catch (ArithmeticException e) { } try { FieldUtils.safeMultiply(Long.MIN_VALUE, Integer.MAX_VALUE); fail(); } catch (ArithmeticException e) { } try { FieldUtils.safeMultiply(Long.MAX_VALUE, Integer.MIN_VALUE); fail(); } catch (ArithmeticException e) { } } //----------------------------------------------------------------------- public void testSafeDivideLongLong() { assertEquals(1L, FieldUtils.safeDivide(1L, 1L)); assertEquals(1L, FieldUtils.safeDivide(3L, 3L)); assertEquals(0L, FieldUtils.safeDivide(1L, 3L)); assertEquals(3L, FieldUtils.safeDivide(3L, 1L)); assertEquals(1L, FieldUtils.safeDivide(5L, 3L)); assertEquals(-1L, FieldUtils.safeDivide(5L, -3L)); assertEquals(-1L, FieldUtils.safeDivide(-5L, 3L)); assertEquals(1L, FieldUtils.safeDivide(-5L, -3L)); assertEquals(2L, FieldUtils.safeDivide(6L, 3L)); assertEquals(-2L, FieldUtils.safeDivide(6L, -3L)); assertEquals(-2L, FieldUtils.safeDivide(-6L, 3L)); assertEquals(2L, FieldUtils.safeDivide(-6L, -3L)); assertEquals(2L, FieldUtils.safeDivide(7L, 3L)); assertEquals(-2L, FieldUtils.safeDivide(7L, -3L)); assertEquals(-2L, FieldUtils.safeDivide(-7L, 3L)); assertEquals(2L, FieldUtils.safeDivide(-7L, -3L)); assertEquals(Long.MAX_VALUE, FieldUtils.safeDivide(Long.MAX_VALUE, 1L)); assertEquals(Long.MIN_VALUE, FieldUtils.safeDivide(Long.MIN_VALUE, 1L)); assertEquals(-Long.MAX_VALUE, FieldUtils.safeDivide(Long.MAX_VALUE, -1L)); try { FieldUtils.safeDivide(Long.MIN_VALUE, -1L); fail(); } catch (ArithmeticException e) { } try { FieldUtils.safeDivide(1L, 0L); fail(); } catch (ArithmeticException e) { } } }
/* * Copyright 2001-2009 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.field; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.DurationField; import org.joda.time.DurationFieldType; import org.joda.time.chrono.ISOChronology; /** * This class is a Junit unit test for PeriodFormatterBuilder. * * @author Stephen Colebourne */ public class TestMillisDurationField extends TestCase { public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestMillisDurationField.class); } public TestMillisDurationField(String name) { super(name); } protected void setUp() throws Exception { } protected void tearDown() throws Exception { } //----------------------------------------------------------------------- public void test_getType() { assertEquals(DurationFieldType.millis(), MillisDurationField.INSTANCE.getType()); } public void test_getName() { assertEquals("millis", MillisDurationField.INSTANCE.getName()); } public void test_isSupported() { assertEquals(true, MillisDurationField.INSTANCE.isSupported()); } public void test_isPrecise() { assertEquals(true, MillisDurationField.INSTANCE.isPrecise()); } public void test_getUnitMillis() { assertEquals(1, MillisDurationField.INSTANCE.getUnitMillis()); } public void test_toString() { assertEquals("DurationField[millis]", MillisDurationField.INSTANCE.toString()); } //----------------------------------------------------------------------- public void test_getValue_long() { assertEquals(0, MillisDurationField.INSTANCE.getValue(0L)); assertEquals(1234, MillisDurationField.INSTANCE.getValue(1234L)); assertEquals(-1234, MillisDurationField.INSTANCE.getValue(-1234L)); try { MillisDurationField.INSTANCE.getValue(((long) (Integer.MAX_VALUE)) + 1L); fail(); } catch (ArithmeticException ex) {} } public void test_getValueAsLong_long() { assertEquals(0L, MillisDurationField.INSTANCE.getValueAsLong(0L)); assertEquals(1234L, MillisDurationField.INSTANCE.getValueAsLong(1234L)); assertEquals(-1234L, MillisDurationField.INSTANCE.getValueAsLong(-1234L)); assertEquals(((long) (Integer.MAX_VALUE)) + 1L, MillisDurationField.INSTANCE.getValueAsLong(((long) (Integer.MAX_VALUE)) + 1L)); } public void test_getValue_long_long() { assertEquals(0, MillisDurationField.INSTANCE.getValue(0L, 567L)); assertEquals(1234, MillisDurationField.INSTANCE.getValue(1234L, 567L)); assertEquals(-1234, MillisDurationField.INSTANCE.getValue(-1234L, 567L)); try { MillisDurationField.INSTANCE.getValue(((long) (Integer.MAX_VALUE)) + 1L, 567L); fail(); } catch (ArithmeticException ex) {} } public void test_getValueAsLong_long_long() { assertEquals(0L, MillisDurationField.INSTANCE.getValueAsLong(0L, 567L)); assertEquals(1234L, MillisDurationField.INSTANCE.getValueAsLong(1234L, 567L)); assertEquals(-1234L, MillisDurationField.INSTANCE.getValueAsLong(-1234L, 567L)); assertEquals(((long) (Integer.MAX_VALUE)) + 1L, MillisDurationField.INSTANCE.getValueAsLong(((long) (Integer.MAX_VALUE)) + 1L, 567L)); } //----------------------------------------------------------------------- public void test_getMillis_int() { assertEquals(0, MillisDurationField.INSTANCE.getMillis(0)); assertEquals(1234, MillisDurationField.INSTANCE.getMillis(1234)); assertEquals(-1234, MillisDurationField.INSTANCE.getMillis(-1234)); } public void test_getMillis_long() { assertEquals(0L, MillisDurationField.INSTANCE.getMillis(0L)); assertEquals(1234L, MillisDurationField.INSTANCE.getMillis(1234L)); assertEquals(-1234L, MillisDurationField.INSTANCE.getMillis(-1234L)); } public void test_getMillis_int_long() { assertEquals(0, MillisDurationField.INSTANCE.getMillis(0, 567L)); assertEquals(1234, MillisDurationField.INSTANCE.getMillis(1234, 567L)); assertEquals(-1234, MillisDurationField.INSTANCE.getMillis(-1234, 567L)); } public void test_getMillis_long_long() { assertEquals(0L, MillisDurationField.INSTANCE.getMillis(0L, 567L)); assertEquals(1234L, MillisDurationField.INSTANCE.getMillis(1234L, 567L)); assertEquals(-1234L, MillisDurationField.INSTANCE.getMillis(-1234L, 567L)); } //----------------------------------------------------------------------- public void test_add_long_int() { assertEquals(567L, MillisDurationField.INSTANCE.add(567L, 0)); assertEquals(567L + 1234L, MillisDurationField.INSTANCE.add(567L, 1234)); assertEquals(567L - 1234L, MillisDurationField.INSTANCE.add(567L, -1234)); try { MillisDurationField.INSTANCE.add(Long.MAX_VALUE, 1); fail(); } catch (ArithmeticException ex) {} } public void test_add_long_long() { assertEquals(567L, MillisDurationField.INSTANCE.add(567L, 0L)); assertEquals(567L + 1234L, MillisDurationField.INSTANCE.add(567L, 1234L)); assertEquals(567L - 1234L, MillisDurationField.INSTANCE.add(567L, -1234L)); try { MillisDurationField.INSTANCE.add(Long.MAX_VALUE, 1L); fail(); } catch (ArithmeticException ex) {} } //----------------------------------------------------------------------- public void test_getDifference_long_int() { assertEquals(567, MillisDurationField.INSTANCE.getDifference(567L, 0L)); assertEquals(567 - 1234, MillisDurationField.INSTANCE.getDifference(567L, 1234L)); assertEquals(567 + 1234, MillisDurationField.INSTANCE.getDifference(567L, -1234L)); try { MillisDurationField.INSTANCE.getDifference(Long.MAX_VALUE, 1L); fail(); } catch (ArithmeticException ex) {} } public void test_getDifferenceAsLong_long_long() { assertEquals(567L, MillisDurationField.INSTANCE.getDifferenceAsLong(567L, 0L)); assertEquals(567L - 1234L, MillisDurationField.INSTANCE.getDifferenceAsLong(567L, 1234L)); assertEquals(567L + 1234L, MillisDurationField.INSTANCE.getDifferenceAsLong(567L, -1234L)); try { MillisDurationField.INSTANCE.getDifferenceAsLong(Long.MAX_VALUE, -1L); fail(); } catch (ArithmeticException ex) {} } //----------------------------------------------------------------------- public void test_compareTo() { assertEquals(0, MillisDurationField.INSTANCE.compareTo(MillisDurationField.INSTANCE)); assertEquals(-1, MillisDurationField.INSTANCE.compareTo(ISOChronology.getInstance().seconds())); DurationField dummy = new PreciseDurationField(DurationFieldType.seconds(), 0); assertEquals(1, MillisDurationField.INSTANCE.compareTo(dummy)); // try { // MillisDurationField.INSTANCE.compareTo(""); // fail(); // } catch (ClassCastException ex) {} try { MillisDurationField.INSTANCE.compareTo(null); fail(); } catch (NullPointerException ex) {} } //----------------------------------------------------------------------- public void testSerialization() throws Exception { DurationField test = MillisDurationField.INSTANCE; ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(test); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); DurationField result = (DurationField) ois.readObject(); ois.close(); assertSame(test, result); } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.field; import java.util.Arrays; import java.util.Locale; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.DateTimeFieldType; import org.joda.time.DurationField; import org.joda.time.DurationFieldType; import org.joda.time.TimeOfDay; import org.joda.time.chrono.ISOChronology; /** * This class is a Junit unit test for PreciseDateTimeField. * * @author Stephen Colebourne */ public class TestOffsetDateTimeField extends TestCase { public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestOffsetDateTimeField.class); } public TestOffsetDateTimeField(String name) { super(name); } protected void setUp() throws Exception { } protected void tearDown() throws Exception { } //----------------------------------------------------------------------- public void test_constructor1() { OffsetDateTimeField field = new OffsetDateTimeField( ISOChronology.getInstance().secondOfMinute(), 3 ); assertEquals(DateTimeFieldType.secondOfMinute(), field.getType()); assertEquals(3, field.getOffset()); try { field = new OffsetDateTimeField(null, 3); fail(); } catch (IllegalArgumentException ex) {} try { field = new OffsetDateTimeField(ISOChronology.getInstance().secondOfMinute(), 0); fail(); } catch (IllegalArgumentException ex) {} try { field = new OffsetDateTimeField(UnsupportedDateTimeField.getInstance( DateTimeFieldType.secondOfMinute(), UnsupportedDurationField.getInstance(DurationFieldType.seconds())), 0); fail(); } catch (IllegalArgumentException ex) {} } public void test_constructor2() { OffsetDateTimeField field = new OffsetDateTimeField( ISOChronology.getInstance().secondOfMinute(), DateTimeFieldType.secondOfDay(), 3 ); assertEquals(DateTimeFieldType.secondOfDay(), field.getType()); assertEquals(3, field.getOffset()); try { field = new OffsetDateTimeField(null, DateTimeFieldType.secondOfDay(), 3); fail(); } catch (IllegalArgumentException ex) {} try { field = new OffsetDateTimeField(ISOChronology.getInstance().secondOfMinute(), null, 3); fail(); } catch (IllegalArgumentException ex) {} try { field = new OffsetDateTimeField(ISOChronology.getInstance().secondOfMinute(), DateTimeFieldType.secondOfDay(), 0); fail(); } catch (IllegalArgumentException ex) {} } public void test_getType() { OffsetDateTimeField field = new OffsetDateTimeField( ISOChronology.getInstance().secondOfMinute(), 3 ); assertEquals(DateTimeFieldType.secondOfMinute(), field.getType()); } public void test_getName() { OffsetDateTimeField field = new OffsetDateTimeField( ISOChronology.getInstance().secondOfMinute(), 3 ); assertEquals("secondOfMinute", field.getName()); } public void test_toString() { OffsetDateTimeField field = new OffsetDateTimeField( ISOChronology.getInstance().secondOfMinute(), 3 ); assertEquals("DateTimeField[secondOfMinute]", field.toString()); } public void test_isSupported() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals(true, field.isSupported()); } public void test_isLenient() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals(false, field.isLenient()); } public void test_getOffset() { OffsetDateTimeField field = new OffsetDateTimeField( ISOChronology.getInstance().secondOfMinute(), 5 ); assertEquals(5, field.getOffset()); } public void test_get() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals(0 + 3, field.get(0)); assertEquals(6 + 3, field.get(6000)); } //----------------------------------------------------------------------- public void test_getAsText_long_Locale() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals("32", field.getAsText(1000L * 29, Locale.ENGLISH)); assertEquals("32", field.getAsText(1000L * 29, null)); } public void test_getAsText_long() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals("32", field.getAsText(1000L * 29)); } public void test_getAsText_RP_int_Locale() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals("20", field.getAsText(new TimeOfDay(12, 30, 40, 50), 20, Locale.ENGLISH)); assertEquals("20", field.getAsText(new TimeOfDay(12, 30, 40, 50), 20, null)); } public void test_getAsText_RP_Locale() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals("40", field.getAsText(new TimeOfDay(12, 30, 40, 50), Locale.ENGLISH)); assertEquals("40", field.getAsText(new TimeOfDay(12, 30, 40, 50), null)); } public void test_getAsText_int_Locale() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals("80", field.getAsText(80, Locale.ENGLISH)); assertEquals("80", field.getAsText(80, null)); } //----------------------------------------------------------------------- public void test_getAsShortText_long_Locale() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals("32", field.getAsShortText(1000L * 29, Locale.ENGLISH)); assertEquals("32", field.getAsShortText(1000L * 29, null)); } public void test_getAsShortText_long() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals("32", field.getAsShortText(1000L * 29)); } public void test_getAsShortText_RP_int_Locale() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals("20", field.getAsShortText(new TimeOfDay(12, 30, 40, 50), 20, Locale.ENGLISH)); assertEquals("20", field.getAsShortText(new TimeOfDay(12, 30, 40, 50), 20, null)); } public void test_getAsShortText_RP_Locale() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals("40", field.getAsShortText(new TimeOfDay(12, 30, 40, 50), Locale.ENGLISH)); assertEquals("40", field.getAsShortText(new TimeOfDay(12, 30, 40, 50), null)); } public void test_getAsShortText_int_Locale() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals("80", field.getAsShortText(80, Locale.ENGLISH)); assertEquals("80", field.getAsShortText(80, null)); } //----------------------------------------------------------------------- public void test_add_long_int() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals(1001, field.add(1L, 1)); } public void test_add_long_long() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals(1001, field.add(1L, 1L)); } public void test_add_RP_int_intarray_int() { int[] values = new int[] {10, 20, 30, 40}; int[] expected = new int[] {10, 20, 30, 40}; OffsetDateTimeField field = new MockStandardDateTimeField(); int[] result = field.add(new TimeOfDay(), 2, values, 0); assertEquals(true, Arrays.equals(expected, result)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 31, 40}; result = field.add(new TimeOfDay(), 2, values, 1); assertEquals(true, Arrays.equals(expected, result)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 62, 40}; result = field.add(new TimeOfDay(), 2, values, 32); assertEquals(true, Arrays.equals(expected, result)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 21, 3, 40}; result = field.add(new TimeOfDay(), 2, values, 33); assertEquals(true, Arrays.equals(expected, result)); values = new int[] {23, 59, 30, 40}; try { field.add(new TimeOfDay(), 2, values, 33); fail(); } catch (IllegalArgumentException ex) {} values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 29, 40}; result = field.add(new TimeOfDay(), 2, values, -1); assertEquals(true, Arrays.equals(expected, result)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 19, 59, 40}; result = field.add(new TimeOfDay(), 2, values, -31); assertEquals(true, Arrays.equals(expected, result)); values = new int[] {0, 0, 30, 40}; try { field.add(new TimeOfDay(), 2, values, -31); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void test_addWrapField_long_int() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals(29 * 1000L, field.addWrapField(1000L * 29, 0)); assertEquals(59 * 1000L, field.addWrapField(1000L * 29, 30)); assertEquals(0L, field.addWrapField(1000L * 29, 31)); } public void test_addWrapField_RP_int_intarray_int() { OffsetDateTimeField field = new MockOffsetDateTimeField(); int[] values = new int[] {10, 20, 30, 40}; int[] expected = new int[] {10, 20, 30, 40}; int[] result = field.addWrapField(new TimeOfDay(), 2, values, 0); assertEquals(true, Arrays.equals(result, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 59, 40}; result = field.addWrapField(new TimeOfDay(), 2, values, 29); assertEquals(true, Arrays.equals(result, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 3, 40}; result = field.addWrapField(new TimeOfDay(), 2, values, 33); assertEquals(true, Arrays.equals(result, expected)); } //----------------------------------------------------------------------- public void test_getDifference_long_long() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals(-21, field.getDifference(20000L, 41000L)); } public void test_getDifferenceAsLong_long_long() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals(-21L, field.getDifferenceAsLong(20000L, 41000L)); } //----------------------------------------------------------------------- public void test_set_long_int() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals(3120L, field.set(2120L, 6)); assertEquals(26120L, field.set(120L, 29)); assertEquals(57120L, field.set(2120L, 60)); } public void test_set_RP_int_intarray_int() { OffsetDateTimeField field = new MockOffsetDateTimeField(); int[] values = new int[] {10, 20, 30, 40}; int[] expected = new int[] {10, 20, 30, 40}; int[] result = field.set(new TimeOfDay(), 2, values, 30); assertEquals(true, Arrays.equals(result, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 29, 40}; result = field.set(new TimeOfDay(), 2, values, 29); assertEquals(true, Arrays.equals(result, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 30, 40}; try { field.set(new TimeOfDay(), 2, values, 63); fail(); } catch (IllegalArgumentException ex) {} assertEquals(true, Arrays.equals(values, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 30, 40}; try { field.set(new TimeOfDay(), 2, values, 2); fail(); } catch (IllegalArgumentException ex) {} assertEquals(true, Arrays.equals(values, expected)); } public void test_set_long_String_Locale() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals(3050L, field.set(50L, "6", null)); assertEquals(26050L, field.set(50L, "29", Locale.ENGLISH)); } public void test_set_long_String() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals(3050L, field.set(50L, "6")); assertEquals(26050L, field.set(50L, "29")); } public void test_set_RP_int_intarray_String_Locale() { OffsetDateTimeField field = new MockOffsetDateTimeField(); int[] values = new int[] {10, 20, 30, 40}; int[] expected = new int[] {10, 20, 30, 40}; int[] result = field.set(new TimeOfDay(), 2, values, "30", null); assertEquals(true, Arrays.equals(result, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 29, 40}; result = field.set(new TimeOfDay(), 2, values, "29", Locale.ENGLISH); assertEquals(true, Arrays.equals(result, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 30, 40}; try { field.set(new TimeOfDay(), 2, values, "63", null); fail(); } catch (IllegalArgumentException ex) {} assertEquals(true, Arrays.equals(values, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 30, 40}; try { field.set(new TimeOfDay(), 2, values, "2", null); fail(); } catch (IllegalArgumentException ex) {} assertEquals(true, Arrays.equals(values, expected)); } public void test_convertText() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals(0, field.convertText("0", null)); assertEquals(29, field.convertText("29", null)); try { field.convertText("2A", null); fail(); } catch (IllegalArgumentException ex) {} try { field.convertText(null, null); fail(); } catch (IllegalArgumentException ex) {} } //------------------------------------------------------------------------ // public abstract DurationField getDurationField(); // // public abstract DurationField getRangeDurationField(); public void test_isLeap_long() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals(false, field.isLeap(0L)); } public void test_getLeapAmount_long() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals(0, field.getLeapAmount(0L)); } public void test_getLeapDurationField() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals(null, field.getLeapDurationField()); } //----------------------------------------------------------------------- public void test_getMinimumValue() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals(3, field.getMinimumValue()); } public void test_getMinimumValue_long() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals(3, field.getMinimumValue(0L)); } public void test_getMinimumValue_RP() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals(3, field.getMinimumValue(new TimeOfDay())); } public void test_getMinimumValue_RP_intarray() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals(3, field.getMinimumValue(new TimeOfDay(), new int[4])); } public void test_getMaximumValue() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals(62, field.getMaximumValue()); } public void test_getMaximumValue_long() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals(62, field.getMaximumValue(0L)); } public void test_getMaximumValue_RP() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals(62, field.getMaximumValue(new TimeOfDay())); } public void test_getMaximumValue_RP_intarray() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals(62, field.getMaximumValue(new TimeOfDay(), new int[4])); } //----------------------------------------------------------------------- public void test_getMaximumTextLength_Locale() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals(2, field.getMaximumTextLength(Locale.ENGLISH)); } public void test_getMaximumShortTextLength_Locale() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals(2, field.getMaximumShortTextLength(Locale.ENGLISH)); } //------------------------------------------------------------------------ public void test_roundFloor_long() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals(-2000L, field.roundFloor(-1001L)); assertEquals(-1000L, field.roundFloor(-1000L)); assertEquals(-1000L, field.roundFloor(-999L)); assertEquals(-1000L, field.roundFloor(-1L)); assertEquals(0L, field.roundFloor(0L)); assertEquals(0L, field.roundFloor(1L)); assertEquals(0L, field.roundFloor(499L)); assertEquals(0L, field.roundFloor(500L)); assertEquals(0L, field.roundFloor(501L)); assertEquals(1000L, field.roundFloor(1000L)); } public void test_roundCeiling_long() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals(-1000L, field.roundCeiling(-1001L)); assertEquals(-1000L, field.roundCeiling(-1000L)); assertEquals(0L, field.roundCeiling(-999L)); assertEquals(0L, field.roundCeiling(-1L)); assertEquals(0L, field.roundCeiling(0L)); assertEquals(1000L, field.roundCeiling(1L)); assertEquals(1000L, field.roundCeiling(499L)); assertEquals(1000L, field.roundCeiling(500L)); assertEquals(1000L, field.roundCeiling(501L)); assertEquals(1000L, field.roundCeiling(1000L)); } public void test_roundHalfFloor_long() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals(0L, field.roundHalfFloor(0L)); assertEquals(0L, field.roundHalfFloor(499L)); assertEquals(0L, field.roundHalfFloor(500L)); assertEquals(1000L, field.roundHalfFloor(501L)); assertEquals(1000L, field.roundHalfFloor(1000L)); } public void test_roundHalfCeiling_long() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals(0L, field.roundHalfCeiling(0L)); assertEquals(0L, field.roundHalfCeiling(499L)); assertEquals(1000L, field.roundHalfCeiling(500L)); assertEquals(1000L, field.roundHalfCeiling(501L)); assertEquals(1000L, field.roundHalfCeiling(1000L)); } public void test_roundHalfEven_long() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals(0L, field.roundHalfEven(0L)); assertEquals(0L, field.roundHalfEven(499L)); assertEquals(0L, field.roundHalfEven(500L)); assertEquals(1000L, field.roundHalfEven(501L)); assertEquals(1000L, field.roundHalfEven(1000L)); assertEquals(1000L, field.roundHalfEven(1499L)); assertEquals(2000L, field.roundHalfEven(1500L)); assertEquals(2000L, field.roundHalfEven(1501L)); } public void test_remainder_long() { OffsetDateTimeField field = new MockOffsetDateTimeField(); assertEquals(0L, field.remainder(0L)); assertEquals(499L, field.remainder(499L)); assertEquals(500L, field.remainder(500L)); assertEquals(501L, field.remainder(501L)); assertEquals(0L, field.remainder(1000L)); } //----------------------------------------------------------------------- static class MockOffsetDateTimeField extends OffsetDateTimeField { protected MockOffsetDateTimeField() { super(ISOChronology.getInstance().secondOfMinute(), 3); } } static class MockStandardDateTimeField extends MockOffsetDateTimeField { protected MockStandardDateTimeField() { super(); } public DurationField getDurationField() { return ISOChronology.getInstanceUTC().seconds(); } public DurationField getRangeDurationField() { return ISOChronology.getInstanceUTC().minutes(); } } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.field; import java.util.Arrays; import java.util.Locale; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.DateTimeFieldType; import org.joda.time.DurationField; import org.joda.time.DurationFieldType; import org.joda.time.TimeOfDay; import org.joda.time.chrono.ISOChronology; /** * This class is a Junit unit test for PreciseDateTimeField. * * @author Stephen Colebourne */ public class TestPreciseDateTimeField extends TestCase { public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestPreciseDateTimeField.class); } public TestPreciseDateTimeField(String name) { super(name); } protected void setUp() throws Exception { } protected void tearDown() throws Exception { } //----------------------------------------------------------------------- public void test_constructor() { BaseDateTimeField field = new PreciseDateTimeField( DateTimeFieldType.secondOfMinute(), ISOChronology.getInstanceUTC().millis(), ISOChronology.getInstanceUTC().hours() ); assertEquals(DateTimeFieldType.secondOfMinute(), field.getType()); try { field = new PreciseDateTimeField(null, null, null); fail(); } catch (IllegalArgumentException ex) {} try { field = new PreciseDateTimeField( DateTimeFieldType.minuteOfHour(), new MockImpreciseDurationField(DurationFieldType.minutes()), ISOChronology.getInstanceUTC().hours()); fail(); } catch (IllegalArgumentException ex) {} try { field = new PreciseDateTimeField( DateTimeFieldType.minuteOfHour(), ISOChronology.getInstanceUTC().hours(), new MockImpreciseDurationField(DurationFieldType.minutes())); fail(); } catch (IllegalArgumentException ex) {} try { field = new PreciseDateTimeField( DateTimeFieldType.minuteOfHour(), ISOChronology.getInstanceUTC().hours(), ISOChronology.getInstanceUTC().hours()); fail(); } catch (IllegalArgumentException ex) {} try { field = new PreciseDateTimeField( DateTimeFieldType.minuteOfHour(), new MockZeroDurationField(DurationFieldType.minutes()), ISOChronology.getInstanceUTC().hours()); fail(); } catch (IllegalArgumentException ex) {} } public void test_getType() { BaseDateTimeField field = new PreciseDateTimeField( DateTimeFieldType.secondOfDay(), ISOChronology.getInstanceUTC().millis(), ISOChronology.getInstanceUTC().hours() ); assertEquals(DateTimeFieldType.secondOfDay(), field.getType()); } public void test_getName() { BaseDateTimeField field = new PreciseDateTimeField( DateTimeFieldType.secondOfDay(), ISOChronology.getInstanceUTC().millis(), ISOChronology.getInstanceUTC().hours() ); assertEquals("secondOfDay", field.getName()); } public void test_toString() { BaseDateTimeField field = new PreciseDateTimeField( DateTimeFieldType.secondOfDay(), ISOChronology.getInstanceUTC().millis(), ISOChronology.getInstanceUTC().hours() ); assertEquals("DateTimeField[secondOfDay]", field.toString()); } public void test_isSupported() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals(true, field.isSupported()); } public void test_getRange() { PreciseDateTimeField field = new MockPreciseDateTimeField(); assertEquals(60, field.getRange()); } public void test_get() { PreciseDateTimeField field = new MockPreciseDateTimeField(); assertEquals(0, field.get(0)); assertEquals(1, field.get(60)); assertEquals(2, field.get(123)); } //----------------------------------------------------------------------- public void test_getAsText_long_Locale() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals("29", field.getAsText(60L * 29, Locale.ENGLISH)); assertEquals("29", field.getAsText(60L * 29, null)); } public void test_getAsText_long() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals("29", field.getAsText(60L * 29)); } public void test_getAsText_RP_int_Locale() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals("20", field.getAsText(new TimeOfDay(12, 30, 40, 50), 20, Locale.ENGLISH)); assertEquals("20", field.getAsText(new TimeOfDay(12, 30, 40, 50), 20, null)); } public void test_getAsText_RP_Locale() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals("40", field.getAsText(new TimeOfDay(12, 30, 40, 50), Locale.ENGLISH)); assertEquals("40", field.getAsText(new TimeOfDay(12, 30, 40, 50), null)); } public void test_getAsText_int_Locale() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals("80", field.getAsText(80, Locale.ENGLISH)); assertEquals("80", field.getAsText(80, null)); } //----------------------------------------------------------------------- public void test_getAsShortText_long_Locale() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals("29", field.getAsShortText(60L * 29, Locale.ENGLISH)); assertEquals("29", field.getAsShortText(60L * 29, null)); } public void test_getAsShortText_long() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals("29", field.getAsShortText(60L * 29)); } public void test_getAsShortText_RP_int_Locale() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals("20", field.getAsShortText(new TimeOfDay(12, 30, 40, 50), 20, Locale.ENGLISH)); assertEquals("20", field.getAsShortText(new TimeOfDay(12, 30, 40, 50), 20, null)); } public void test_getAsShortText_RP_Locale() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals("40", field.getAsShortText(new TimeOfDay(12, 30, 40, 50), Locale.ENGLISH)); assertEquals("40", field.getAsShortText(new TimeOfDay(12, 30, 40, 50), null)); } public void test_getAsShortText_int_Locale() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals("80", field.getAsShortText(80, Locale.ENGLISH)); assertEquals("80", field.getAsShortText(80, null)); } //----------------------------------------------------------------------- public void test_add_long_int() { MockCountingDurationField.add_int = 0; BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals(61, field.add(1L, 1)); assertEquals(1, MockCountingDurationField.add_int); } public void test_add_long_long() { MockCountingDurationField.add_long = 0; BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals(61, field.add(1L, 1L)); assertEquals(1, MockCountingDurationField.add_long); } public void test_add_RP_int_intarray_int() { int[] values = new int[] {10, 20, 30, 40}; int[] expected = new int[] {10, 20, 30, 40}; BaseDateTimeField field = new MockStandardDateTimeField(); int[] result = field.add(new TimeOfDay(), 2, values, 0); assertEquals(true, Arrays.equals(expected, result)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 31, 40}; result = field.add(new TimeOfDay(), 2, values, 1); assertEquals(true, Arrays.equals(expected, result)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 21, 0, 40}; result = field.add(new TimeOfDay(), 2, values, 30); assertEquals(true, Arrays.equals(expected, result)); values = new int[] {23, 59, 30, 40}; try { field.add(new TimeOfDay(), 2, values, 30); fail(); } catch (IllegalArgumentException ex) {} values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 29, 40}; result = field.add(new TimeOfDay(), 2, values, -1); assertEquals(true, Arrays.equals(expected, result)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 19, 59, 40}; result = field.add(new TimeOfDay(), 2, values, -31); assertEquals(true, Arrays.equals(expected, result)); values = new int[] {0, 0, 30, 40}; try { field.add(new TimeOfDay(), 2, values, -31); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void test_addWrapField_long_int() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals(29 * 60L, field.addWrapField(60L * 29, 0)); assertEquals(59 * 60L, field.addWrapField(60L * 29, 30)); assertEquals(0 * 60L, field.addWrapField(60L * 29, 31)); } public void test_addWrapField_RP_int_intarray_int() { BaseDateTimeField field = new MockPreciseDateTimeField(); int[] values = new int[] {10, 20, 30, 40}; int[] expected = new int[] {10, 20, 30, 40}; int[] result = field.addWrapField(new TimeOfDay(), 2, values, 0); assertEquals(true, Arrays.equals(result, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 59, 40}; result = field.addWrapField(new TimeOfDay(), 2, values, 29); assertEquals(true, Arrays.equals(result, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 0, 40}; result = field.addWrapField(new TimeOfDay(), 2, values, 30); assertEquals(true, Arrays.equals(result, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 1, 40}; result = field.addWrapField(new TimeOfDay(), 2, values, 31); assertEquals(true, Arrays.equals(result, expected)); } //----------------------------------------------------------------------- public void test_getDifference_long_long() { MockCountingDurationField.difference_long = 0; BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals(30, field.getDifference(0L, 0L)); assertEquals(1, MockCountingDurationField.difference_long); } public void test_getDifferenceAsLong_long_long() { MockCountingDurationField.difference_long = 0; BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals(30, field.getDifferenceAsLong(0L, 0L)); assertEquals(1, MockCountingDurationField.difference_long); } //----------------------------------------------------------------------- public void test_set_long_int() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals(0, field.set(120L, 0)); assertEquals(29 * 60, field.set(120L, 29)); } public void test_set_RP_int_intarray_int() { BaseDateTimeField field = new MockPreciseDateTimeField(); int[] values = new int[] {10, 20, 30, 40}; int[] expected = new int[] {10, 20, 30, 40}; int[] result = field.set(new TimeOfDay(), 2, values, 30); assertEquals(true, Arrays.equals(result, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 29, 40}; result = field.set(new TimeOfDay(), 2, values, 29); assertEquals(true, Arrays.equals(result, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 30, 40}; try { field.set(new TimeOfDay(), 2, values, 60); fail(); } catch (IllegalArgumentException ex) {} assertEquals(true, Arrays.equals(values, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 30, 40}; try { field.set(new TimeOfDay(), 2, values, -1); fail(); } catch (IllegalArgumentException ex) {} assertEquals(true, Arrays.equals(values, expected)); } public void test_set_long_String_Locale() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals(0, field.set(0L, "0", null)); assertEquals(29 * 60, field.set(0L, "29", Locale.ENGLISH)); } public void test_set_long_String() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals(0, field.set(0L, "0")); assertEquals(29 * 60, field.set(0L, "29")); } public void test_set_RP_int_intarray_String_Locale() { BaseDateTimeField field = new MockPreciseDateTimeField(); int[] values = new int[] {10, 20, 30, 40}; int[] expected = new int[] {10, 20, 30, 40}; int[] result = field.set(new TimeOfDay(), 2, values, "30", null); assertEquals(true, Arrays.equals(result, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 29, 40}; result = field.set(new TimeOfDay(), 2, values, "29", Locale.ENGLISH); assertEquals(true, Arrays.equals(result, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 30, 40}; try { field.set(new TimeOfDay(), 2, values, "60", null); fail(); } catch (IllegalArgumentException ex) {} assertEquals(true, Arrays.equals(values, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 30, 40}; try { field.set(new TimeOfDay(), 2, values, "-1", null); fail(); } catch (IllegalArgumentException ex) {} assertEquals(true, Arrays.equals(values, expected)); } public void test_convertText() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals(0, field.convertText("0", null)); assertEquals(29, field.convertText("29", null)); try { field.convertText("2A", null); fail(); } catch (IllegalArgumentException ex) {} try { field.convertText(null, null); fail(); } catch (IllegalArgumentException ex) {} } //------------------------------------------------------------------------ // public abstract DurationField getDurationField(); // // public abstract DurationField getRangeDurationField(); public void test_isLeap_long() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals(false, field.isLeap(0L)); } public void test_getLeapAmount_long() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals(0, field.getLeapAmount(0L)); } public void test_getLeapDurationField() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals(null, field.getLeapDurationField()); } //----------------------------------------------------------------------- public void test_getMinimumValue() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals(0, field.getMinimumValue()); } public void test_getMinimumValue_long() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals(0, field.getMinimumValue(0L)); } public void test_getMinimumValue_RP() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals(0, field.getMinimumValue(new TimeOfDay())); } public void test_getMinimumValue_RP_intarray() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals(0, field.getMinimumValue(new TimeOfDay(), new int[4])); } public void test_getMaximumValue() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals(59, field.getMaximumValue()); } public void test_getMaximumValue_long() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals(59, field.getMaximumValue(0L)); } public void test_getMaximumValue_RP() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals(59, field.getMaximumValue(new TimeOfDay())); } public void test_getMaximumValue_RP_intarray() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals(59, field.getMaximumValue(new TimeOfDay(), new int[4])); } //----------------------------------------------------------------------- public void test_getMaximumTextLength_Locale() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals(2, field.getMaximumTextLength(Locale.ENGLISH)); } public void test_getMaximumShortTextLength_Locale() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals(2, field.getMaximumShortTextLength(Locale.ENGLISH)); } //------------------------------------------------------------------------ public void test_roundFloor_long() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals(-120L, field.roundFloor(-61L)); assertEquals(-60L, field.roundFloor(-60L)); assertEquals(-60L, field.roundFloor(-59L)); assertEquals(-60L, field.roundFloor(-1L)); assertEquals(0L, field.roundFloor(0L)); assertEquals(0L, field.roundFloor(1L)); assertEquals(0L, field.roundFloor(29L)); assertEquals(0L, field.roundFloor(30L)); assertEquals(0L, field.roundFloor(31L)); assertEquals(60L, field.roundFloor(60L)); } public void test_roundCeiling_long() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals(-60L, field.roundCeiling(-61L)); assertEquals(-60L, field.roundCeiling(-60L)); assertEquals(0L, field.roundCeiling(-59L)); assertEquals(0L, field.roundCeiling(-1L)); assertEquals(0L, field.roundCeiling(0L)); assertEquals(60L, field.roundCeiling(1L)); assertEquals(60L, field.roundCeiling(29L)); assertEquals(60L, field.roundCeiling(30L)); assertEquals(60L, field.roundCeiling(31L)); assertEquals(60L, field.roundCeiling(60L)); } public void test_roundHalfFloor_long() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals(0L, field.roundHalfFloor(0L)); assertEquals(0L, field.roundHalfFloor(29L)); assertEquals(0L, field.roundHalfFloor(30L)); assertEquals(60L, field.roundHalfFloor(31L)); assertEquals(60L, field.roundHalfFloor(60L)); } public void test_roundHalfCeiling_long() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals(0L, field.roundHalfCeiling(0L)); assertEquals(0L, field.roundHalfCeiling(29L)); assertEquals(60L, field.roundHalfCeiling(30L)); assertEquals(60L, field.roundHalfCeiling(31L)); assertEquals(60L, field.roundHalfCeiling(60L)); } public void test_roundHalfEven_long() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals(0L, field.roundHalfEven(0L)); assertEquals(0L, field.roundHalfEven(29L)); assertEquals(0L, field.roundHalfEven(30L)); assertEquals(60L, field.roundHalfEven(31L)); assertEquals(60L, field.roundHalfEven(60L)); assertEquals(60L, field.roundHalfEven(89L)); assertEquals(120L, field.roundHalfEven(90L)); assertEquals(120L, field.roundHalfEven(91L)); } public void test_remainder_long() { BaseDateTimeField field = new MockPreciseDateTimeField(); assertEquals(0L, field.remainder(0L)); assertEquals(29L, field.remainder(29L)); assertEquals(30L, field.remainder(30L)); assertEquals(31L, field.remainder(31L)); assertEquals(0L, field.remainder(60L)); } //----------------------------------------------------------------------- static class MockPreciseDateTimeField extends PreciseDateTimeField { protected MockPreciseDateTimeField() { super(DateTimeFieldType.secondOfMinute(), new MockCountingDurationField(DurationFieldType.seconds(), 60), new MockCountingDurationField(DurationFieldType.minutes(), 60 * 60)); } protected MockPreciseDateTimeField( DateTimeFieldType type, DurationField dur, DurationField range) { super(type, dur, range); } } static class MockStandardDateTimeField extends MockPreciseDateTimeField { protected MockStandardDateTimeField() { super(); } public DurationField getDurationField() { return ISOChronology.getInstanceUTC().seconds(); } public DurationField getRangeDurationField() { return ISOChronology.getInstanceUTC().minutes(); } } //----------------------------------------------------------------------- static class MockCountingDurationField extends BaseDurationField { static int add_int = 0; static int add_long = 0; static int difference_long = 0; int unit; protected MockCountingDurationField(DurationFieldType type, int unit) { super(type); this.unit = unit; } public boolean isPrecise() { return true; } public long getUnitMillis() { return unit; } public long getValueAsLong(long duration, long instant) { return 0; } public long getMillis(int value, long instant) { return 0; } public long getMillis(long value, long instant) { return 0; } public long add(long instant, int value) { add_int++; return instant + (value * 60L); } public long add(long instant, long value) { add_long++; return instant + (value * 60L); } public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { difference_long++; return 30; } } //----------------------------------------------------------------------- static class MockZeroDurationField extends BaseDurationField { protected MockZeroDurationField(DurationFieldType type) { super(type); } public boolean isPrecise() { return true; } public long getUnitMillis() { return 0; // this is zero } public long getValueAsLong(long duration, long instant) { return 0; } public long getMillis(int value, long instant) { return 0; } public long getMillis(long value, long instant) { return 0; } public long add(long instant, int value) { return 0; } public long add(long instant, long value) { return 0; } public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { return 0; } } //----------------------------------------------------------------------- static class MockImpreciseDurationField extends BaseDurationField { protected MockImpreciseDurationField(DurationFieldType type) { super(type); } public boolean isPrecise() { return false; // this is false } public long getUnitMillis() { return 0; } public long getValueAsLong(long duration, long instant) { return 0; } public long getMillis(int value, long instant) { return 0; } public long getMillis(long value, long instant) { return 0; } public long add(long instant, int value) { return 0; } public long add(long instant, long value) { return 0; } public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { return 0; } } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.field; import java.util.Arrays; import java.util.Locale; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.DateTimeFieldType; import org.joda.time.DurationField; import org.joda.time.DurationFieldType; import org.joda.time.TimeOfDay; import org.joda.time.chrono.ISOChronology; /** * This class is a Junit unit test for PreciseDurationDateTimeField. * * @author Stephen Colebourne */ public class TestPreciseDurationDateTimeField extends TestCase { public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestPreciseDurationDateTimeField.class); } public TestPreciseDurationDateTimeField(String name) { super(name); } protected void setUp() throws Exception { } protected void tearDown() throws Exception { } //----------------------------------------------------------------------- public void test_constructor() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals(DateTimeFieldType.secondOfMinute(), field.getType()); try { field = new MockPreciseDurationDateTimeField(null, null); fail(); } catch (IllegalArgumentException ex) {} try { field = new MockPreciseDurationDateTimeField( DateTimeFieldType.minuteOfHour(), new MockImpreciseDurationField(DurationFieldType.minutes())); fail(); } catch (IllegalArgumentException ex) {} try { field = new MockPreciseDurationDateTimeField( DateTimeFieldType.minuteOfHour(), new MockZeroDurationField(DurationFieldType.minutes())); fail(); } catch (IllegalArgumentException ex) {} } public void test_getType() { BaseDateTimeField field = new MockPreciseDurationDateTimeField( DateTimeFieldType.secondOfDay(), new MockCountingDurationField(DurationFieldType.minutes())); assertEquals(DateTimeFieldType.secondOfDay(), field.getType()); } public void test_getName() { BaseDateTimeField field = new MockPreciseDurationDateTimeField( DateTimeFieldType.secondOfDay(), new MockCountingDurationField(DurationFieldType.minutes())); assertEquals("secondOfDay", field.getName()); } public void test_toString() { BaseDateTimeField field = new MockPreciseDurationDateTimeField( DateTimeFieldType.secondOfDay(), new MockCountingDurationField(DurationFieldType.minutes())); assertEquals("DateTimeField[secondOfDay]", field.toString()); } public void test_isSupported() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals(true, field.isSupported()); } public void test_isLenient() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals(false, field.isLenient()); } public void test_get() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals(0, field.get(0)); assertEquals(1, field.get(60)); assertEquals(2, field.get(123)); } //----------------------------------------------------------------------- public void test_getAsText_long_Locale() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals("29", field.getAsText(60L * 29, Locale.ENGLISH)); assertEquals("29", field.getAsText(60L * 29, null)); } public void test_getAsText_long() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals("29", field.getAsText(60L * 29)); } public void test_getAsText_RP_int_Locale() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals("20", field.getAsText(new TimeOfDay(12, 30, 40, 50), 20, Locale.ENGLISH)); assertEquals("20", field.getAsText(new TimeOfDay(12, 30, 40, 50), 20, null)); } public void test_getAsText_RP_Locale() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals("40", field.getAsText(new TimeOfDay(12, 30, 40, 50), Locale.ENGLISH)); assertEquals("40", field.getAsText(new TimeOfDay(12, 30, 40, 50), null)); } public void test_getAsText_int_Locale() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals("80", field.getAsText(80, Locale.ENGLISH)); assertEquals("80", field.getAsText(80, null)); } //----------------------------------------------------------------------- public void test_getAsShortText_long_Locale() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals("29", field.getAsShortText(60L * 29, Locale.ENGLISH)); assertEquals("29", field.getAsShortText(60L * 29, null)); } public void test_getAsShortText_long() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals("29", field.getAsShortText(60L * 29)); } public void test_getAsShortText_RP_int_Locale() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals("20", field.getAsShortText(new TimeOfDay(12, 30, 40, 50), 20, Locale.ENGLISH)); assertEquals("20", field.getAsShortText(new TimeOfDay(12, 30, 40, 50), 20, null)); } public void test_getAsShortText_RP_Locale() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals("40", field.getAsShortText(new TimeOfDay(12, 30, 40, 50), Locale.ENGLISH)); assertEquals("40", field.getAsShortText(new TimeOfDay(12, 30, 40, 50), null)); } public void test_getAsShortText_int_Locale() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals("80", field.getAsShortText(80, Locale.ENGLISH)); assertEquals("80", field.getAsShortText(80, null)); } //----------------------------------------------------------------------- public void test_add_long_int() { MockCountingDurationField.add_int = 0; BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals(61, field.add(1L, 1)); assertEquals(1, MockCountingDurationField.add_int); } public void test_add_long_long() { MockCountingDurationField.add_long = 0; BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals(61, field.add(1L, 1L)); assertEquals(1, MockCountingDurationField.add_long); } public void test_add_RP_int_intarray_int() { int[] values = new int[] {10, 20, 30, 40}; int[] expected = new int[] {10, 20, 30, 40}; BaseDateTimeField field = new MockStandardBaseDateTimeField(); int[] result = field.add(new TimeOfDay(), 2, values, 0); assertEquals(true, Arrays.equals(expected, result)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 31, 40}; result = field.add(new TimeOfDay(), 2, values, 1); assertEquals(true, Arrays.equals(expected, result)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 21, 0, 40}; result = field.add(new TimeOfDay(), 2, values, 30); assertEquals(true, Arrays.equals(expected, result)); values = new int[] {23, 59, 30, 40}; try { field.add(new TimeOfDay(), 2, values, 30); fail(); } catch (IllegalArgumentException ex) {} values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 29, 40}; result = field.add(new TimeOfDay(), 2, values, -1); assertEquals(true, Arrays.equals(expected, result)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 19, 59, 40}; result = field.add(new TimeOfDay(), 2, values, -31); assertEquals(true, Arrays.equals(expected, result)); values = new int[] {0, 0, 30, 40}; try { field.add(new TimeOfDay(), 2, values, -31); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void test_addWrapField_long_int() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals(29 * 60L, field.addWrapField(60L * 29, 0)); assertEquals(59 * 60L, field.addWrapField(60L * 29, 30)); assertEquals(0 * 60L, field.addWrapField(60L * 29, 31)); } public void test_addWrapField_RP_int_intarray_int() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); int[] values = new int[] {10, 20, 30, 40}; int[] expected = new int[] {10, 20, 30, 40}; int[] result = field.addWrapField(new TimeOfDay(), 2, values, 0); assertEquals(true, Arrays.equals(result, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 59, 40}; result = field.addWrapField(new TimeOfDay(), 2, values, 29); assertEquals(true, Arrays.equals(result, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 0, 40}; result = field.addWrapField(new TimeOfDay(), 2, values, 30); assertEquals(true, Arrays.equals(result, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 1, 40}; result = field.addWrapField(new TimeOfDay(), 2, values, 31); assertEquals(true, Arrays.equals(result, expected)); } //----------------------------------------------------------------------- public void test_getDifference_long_long() { MockCountingDurationField.difference_long = 0; BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals(30, field.getDifference(0L, 0L)); assertEquals(1, MockCountingDurationField.difference_long); } public void test_getDifferenceAsLong_long_long() { MockCountingDurationField.difference_long = 0; BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals(30, field.getDifferenceAsLong(0L, 0L)); assertEquals(1, MockCountingDurationField.difference_long); } //----------------------------------------------------------------------- public void test_set_long_int() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals(0, field.set(120L, 0)); assertEquals(29 * 60, field.set(120L, 29)); } public void test_set_RP_int_intarray_int() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); int[] values = new int[] {10, 20, 30, 40}; int[] expected = new int[] {10, 20, 30, 40}; int[] result = field.set(new TimeOfDay(), 2, values, 30); assertEquals(true, Arrays.equals(result, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 29, 40}; result = field.set(new TimeOfDay(), 2, values, 29); assertEquals(true, Arrays.equals(result, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 30, 40}; try { field.set(new TimeOfDay(), 2, values, 60); fail(); } catch (IllegalArgumentException ex) {} assertEquals(true, Arrays.equals(values, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 30, 40}; try { field.set(new TimeOfDay(), 2, values, -1); fail(); } catch (IllegalArgumentException ex) {} assertEquals(true, Arrays.equals(values, expected)); } public void test_set_long_String_Locale() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals(0, field.set(0L, "0", null)); assertEquals(29 * 60, field.set(0L, "29", Locale.ENGLISH)); } public void test_set_long_String() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals(0, field.set(0L, "0")); assertEquals(29 * 60, field.set(0L, "29")); } public void test_set_RP_int_intarray_String_Locale() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); int[] values = new int[] {10, 20, 30, 40}; int[] expected = new int[] {10, 20, 30, 40}; int[] result = field.set(new TimeOfDay(), 2, values, "30", null); assertEquals(true, Arrays.equals(result, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 29, 40}; result = field.set(new TimeOfDay(), 2, values, "29", Locale.ENGLISH); assertEquals(true, Arrays.equals(result, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 30, 40}; try { field.set(new TimeOfDay(), 2, values, "60", null); fail(); } catch (IllegalArgumentException ex) {} assertEquals(true, Arrays.equals(values, expected)); values = new int[] {10, 20, 30, 40}; expected = new int[] {10, 20, 30, 40}; try { field.set(new TimeOfDay(), 2, values, "-1", null); fail(); } catch (IllegalArgumentException ex) {} assertEquals(true, Arrays.equals(values, expected)); } public void test_convertText() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals(0, field.convertText("0", null)); assertEquals(29, field.convertText("29", null)); try { field.convertText("2A", null); fail(); } catch (IllegalArgumentException ex) {} try { field.convertText(null, null); fail(); } catch (IllegalArgumentException ex) {} } //------------------------------------------------------------------------ // public abstract DurationField getDurationField(); // // public abstract DurationField getRangeDurationField(); public void test_isLeap_long() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals(false, field.isLeap(0L)); } public void test_getLeapAmount_long() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals(0, field.getLeapAmount(0L)); } public void test_getLeapDurationField() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals(null, field.getLeapDurationField()); } //----------------------------------------------------------------------- public void test_getMinimumValue() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals(0, field.getMinimumValue()); } public void test_getMinimumValue_long() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals(0, field.getMinimumValue(0L)); } public void test_getMinimumValue_RP() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals(0, field.getMinimumValue(new TimeOfDay())); } public void test_getMinimumValue_RP_intarray() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals(0, field.getMinimumValue(new TimeOfDay(), new int[4])); } public void test_getMaximumValue() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals(59, field.getMaximumValue()); } public void test_getMaximumValue_long() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals(59, field.getMaximumValue(0L)); } public void test_getMaximumValue_RP() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals(59, field.getMaximumValue(new TimeOfDay())); } public void test_getMaximumValue_RP_intarray() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals(59, field.getMaximumValue(new TimeOfDay(), new int[4])); } //----------------------------------------------------------------------- public void test_getMaximumTextLength_Locale() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals(2, field.getMaximumTextLength(Locale.ENGLISH)); field = new MockPreciseDurationDateTimeField() { public int getMaximumValue() { return 5; } }; assertEquals(1, field.getMaximumTextLength(Locale.ENGLISH)); field = new MockPreciseDurationDateTimeField() { public int getMaximumValue() { return 555; } }; assertEquals(3, field.getMaximumTextLength(Locale.ENGLISH)); field = new MockPreciseDurationDateTimeField() { public int getMaximumValue() { return 5555; } }; assertEquals(4, field.getMaximumTextLength(Locale.ENGLISH)); field = new MockPreciseDurationDateTimeField() { public int getMaximumValue() { return -1; } }; assertEquals(2, field.getMaximumTextLength(Locale.ENGLISH)); } public void test_getMaximumShortTextLength_Locale() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals(2, field.getMaximumShortTextLength(Locale.ENGLISH)); } //------------------------------------------------------------------------ public void test_roundFloor_long() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals(-120L, field.roundFloor(-61L)); assertEquals(-60L, field.roundFloor(-60L)); assertEquals(-60L, field.roundFloor(-59L)); assertEquals(-60L, field.roundFloor(-1L)); assertEquals(0L, field.roundFloor(0L)); assertEquals(0L, field.roundFloor(1L)); assertEquals(0L, field.roundFloor(29L)); assertEquals(0L, field.roundFloor(30L)); assertEquals(0L, field.roundFloor(31L)); assertEquals(60L, field.roundFloor(60L)); } public void test_roundCeiling_long() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals(-60L, field.roundCeiling(-61L)); assertEquals(-60L, field.roundCeiling(-60L)); assertEquals(0L, field.roundCeiling(-59L)); assertEquals(0L, field.roundCeiling(-1L)); assertEquals(0L, field.roundCeiling(0L)); assertEquals(60L, field.roundCeiling(1L)); assertEquals(60L, field.roundCeiling(29L)); assertEquals(60L, field.roundCeiling(30L)); assertEquals(60L, field.roundCeiling(31L)); assertEquals(60L, field.roundCeiling(60L)); } public void test_roundHalfFloor_long() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals(0L, field.roundHalfFloor(0L)); assertEquals(0L, field.roundHalfFloor(29L)); assertEquals(0L, field.roundHalfFloor(30L)); assertEquals(60L, field.roundHalfFloor(31L)); assertEquals(60L, field.roundHalfFloor(60L)); } public void test_roundHalfCeiling_long() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals(0L, field.roundHalfCeiling(0L)); assertEquals(0L, field.roundHalfCeiling(29L)); assertEquals(60L, field.roundHalfCeiling(30L)); assertEquals(60L, field.roundHalfCeiling(31L)); assertEquals(60L, field.roundHalfCeiling(60L)); } public void test_roundHalfEven_long() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals(0L, field.roundHalfEven(0L)); assertEquals(0L, field.roundHalfEven(29L)); assertEquals(0L, field.roundHalfEven(30L)); assertEquals(60L, field.roundHalfEven(31L)); assertEquals(60L, field.roundHalfEven(60L)); assertEquals(60L, field.roundHalfEven(89L)); assertEquals(120L, field.roundHalfEven(90L)); assertEquals(120L, field.roundHalfEven(91L)); } public void test_remainder_long() { BaseDateTimeField field = new MockPreciseDurationDateTimeField(); assertEquals(0L, field.remainder(0L)); assertEquals(29L, field.remainder(29L)); assertEquals(30L, field.remainder(30L)); assertEquals(31L, field.remainder(31L)); assertEquals(0L, field.remainder(60L)); } //----------------------------------------------------------------------- static class MockPreciseDurationDateTimeField extends PreciseDurationDateTimeField { protected MockPreciseDurationDateTimeField() { super(DateTimeFieldType.secondOfMinute(), new MockCountingDurationField(DurationFieldType.seconds())); } protected MockPreciseDurationDateTimeField(DateTimeFieldType type, DurationField dur) { super(type, dur); } public int get(long instant) { return (int) (instant / 60L); } public DurationField getRangeDurationField() { return new MockCountingDurationField(DurationFieldType.minutes()); } public int getMaximumValue() { return 59; } } static class MockStandardBaseDateTimeField extends MockPreciseDurationDateTimeField { protected MockStandardBaseDateTimeField() { super(); } public DurationField getDurationField() { return ISOChronology.getInstanceUTC().seconds(); } public DurationField getRangeDurationField() { return ISOChronology.getInstanceUTC().minutes(); } } //----------------------------------------------------------------------- static class MockCountingDurationField extends BaseDurationField { static int add_int = 0; static int add_long = 0; static int difference_long = 0; protected MockCountingDurationField(DurationFieldType type) { super(type); } public boolean isPrecise() { return true; } public long getUnitMillis() { return 60; } public long getValueAsLong(long duration, long instant) { return 0; } public long getMillis(int value, long instant) { return 0; } public long getMillis(long value, long instant) { return 0; } public long add(long instant, int value) { add_int++; return instant + (value * 60L); } public long add(long instant, long value) { add_long++; return instant + (value * 60L); } public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { difference_long++; return 30; } } //----------------------------------------------------------------------- static class MockZeroDurationField extends BaseDurationField { protected MockZeroDurationField(DurationFieldType type) { super(type); } public boolean isPrecise() { return true; } public long getUnitMillis() { return 0; // this is zero } public long getValueAsLong(long duration, long instant) { return 0; } public long getMillis(int value, long instant) { return 0; } public long getMillis(long value, long instant) { return 0; } public long add(long instant, int value) { return 0; } public long add(long instant, long value) { return 0; } public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { return 0; } } //----------------------------------------------------------------------- static class MockImpreciseDurationField extends BaseDurationField { protected MockImpreciseDurationField(DurationFieldType type) { super(type); } public boolean isPrecise() { return false; // this is false } public long getUnitMillis() { return 0; } public long getValueAsLong(long duration, long instant) { return 0; } public long getMillis(int value, long instant) { return 0; } public long getMillis(long value, long instant) { return 0; } public long add(long instant, int value) { return 0; } public long add(long instant, long value) { return 0; } public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { return 0; } } }
/* * Copyright 2001-2009 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.field; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.DurationField; import org.joda.time.DurationFieldType; import org.joda.time.chrono.ISOChronology; /** * This class is a Junit unit test for PreciseDurationField. * * @author Stephen Colebourne */ public class TestPreciseDurationField extends TestCase { private static final long LONG_INTEGER_MAX = Integer.MAX_VALUE; private static final int INTEGER_MAX = Integer.MAX_VALUE; private static final long LONG_MAX = Long.MAX_VALUE; private PreciseDurationField iField; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestPreciseDurationField.class); } public TestPreciseDurationField(String name) { super(name); } protected void setUp() throws Exception { iField = new PreciseDurationField(DurationFieldType.seconds(), 1000); } protected void tearDown() throws Exception { iField = null; } //----------------------------------------------------------------------- public void test_constructor() { try { new PreciseDurationField(null, 10); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void test_getType() { assertEquals(DurationFieldType.seconds(), iField.getType()); } public void test_getName() { assertEquals("seconds", iField.getName()); } public void test_isSupported() { assertEquals(true, iField.isSupported()); } public void test_isPrecise() { assertEquals(true, iField.isPrecise()); } public void test_getUnitMillis() { assertEquals(1000, iField.getUnitMillis()); } public void test_toString() { assertEquals("DurationField[seconds]", iField.toString()); } //----------------------------------------------------------------------- public void test_getValue_long() { assertEquals(0, iField.getValue(0L)); assertEquals(12345, iField.getValue(12345678L)); assertEquals(-1, iField.getValue(-1234L)); assertEquals(INTEGER_MAX, iField.getValue(LONG_INTEGER_MAX * 1000L + 999L)); try { iField.getValue(LONG_INTEGER_MAX * 1000L + 1000L); fail(); } catch (ArithmeticException ex) {} } public void test_getValueAsLong_long() { assertEquals(0L, iField.getValueAsLong(0L)); assertEquals(12345L, iField.getValueAsLong(12345678L)); assertEquals(-1L, iField.getValueAsLong(-1234L)); assertEquals(LONG_INTEGER_MAX + 1L, iField.getValueAsLong(LONG_INTEGER_MAX * 1000L + 1000L)); } public void test_getValue_long_long() { assertEquals(0, iField.getValue(0L, 567L)); assertEquals(12345, iField.getValue(12345678L, 567L)); assertEquals(-1, iField.getValue(-1234L, 567L)); assertEquals(INTEGER_MAX, iField.getValue(LONG_INTEGER_MAX * 1000L + 999L, 567L)); try { iField.getValue(LONG_INTEGER_MAX * 1000L + 1000L, 567L); fail(); } catch (ArithmeticException ex) {} } public void test_getValueAsLong_long_long() { assertEquals(0L, iField.getValueAsLong(0L, 567L)); assertEquals(12345L, iField.getValueAsLong(12345678L, 567L)); assertEquals(-1L, iField.getValueAsLong(-1234L, 567L)); assertEquals(LONG_INTEGER_MAX + 1L, iField.getValueAsLong(LONG_INTEGER_MAX * 1000L + 1000L, 567L)); } //----------------------------------------------------------------------- public void test_getMillis_int() { assertEquals(0, iField.getMillis(0)); assertEquals(1234000L, iField.getMillis(1234)); assertEquals(-1234000L, iField.getMillis(-1234)); assertEquals(LONG_INTEGER_MAX * 1000L, iField.getMillis(INTEGER_MAX)); } public void test_getMillis_long() { assertEquals(0L, iField.getMillis(0L)); assertEquals(1234000L, iField.getMillis(1234L)); assertEquals(-1234000L, iField.getMillis(-1234L)); try { iField.getMillis(LONG_MAX); fail(); } catch (ArithmeticException ex) {} } public void test_getMillis_int_long() { assertEquals(0L, iField.getMillis(0, 567L)); assertEquals(1234000L, iField.getMillis(1234, 567L)); assertEquals(-1234000L, iField.getMillis(-1234, 567L)); assertEquals(LONG_INTEGER_MAX * 1000L, iField.getMillis(INTEGER_MAX, 567L)); } public void test_getMillis_long_long() { assertEquals(0L, iField.getMillis(0L, 567L)); assertEquals(1234000L, iField.getMillis(1234L, 567L)); assertEquals(-1234000L, iField.getMillis(-1234L, 567L)); try { iField.getMillis(LONG_MAX, 567L); fail(); } catch (ArithmeticException ex) {} } //----------------------------------------------------------------------- public void test_add_long_int() { assertEquals(567L, iField.add(567L, 0)); assertEquals(567L + 1234000L, iField.add(567L, 1234)); assertEquals(567L - 1234000L, iField.add(567L, -1234)); try { iField.add(LONG_MAX, 1); fail(); } catch (ArithmeticException ex) {} } public void test_add_long_long() { assertEquals(567L, iField.add(567L, 0L)); assertEquals(567L + 1234000L, iField.add(567L, 1234L)); assertEquals(567L - 1234000L, iField.add(567L, -1234L)); try { iField.add(LONG_MAX, 1L); fail(); } catch (ArithmeticException ex) {} try { iField.add(1L, LONG_MAX); fail(); } catch (ArithmeticException ex) {} } //----------------------------------------------------------------------- public void test_getDifference_long_int() { assertEquals(0, iField.getDifference(1L, 0L)); assertEquals(567, iField.getDifference(567000L, 0L)); assertEquals(567 - 1234, iField.getDifference(567000L, 1234000L)); assertEquals(567 + 1234, iField.getDifference(567000L, -1234000L)); try { iField.getDifference(LONG_MAX, -1L); fail(); } catch (ArithmeticException ex) {} } public void test_getDifferenceAsLong_long_long() { assertEquals(0L, iField.getDifferenceAsLong(1L, 0L)); assertEquals(567L, iField.getDifferenceAsLong(567000L, 0L)); assertEquals(567L - 1234L, iField.getDifferenceAsLong(567000L, 1234000L)); assertEquals(567L + 1234L, iField.getDifferenceAsLong(567000L, -1234000L)); try { iField.getDifferenceAsLong(LONG_MAX, -1L); fail(); } catch (ArithmeticException ex) {} } //----------------------------------------------------------------------- public void test_equals() { assertEquals(true, iField.equals(iField)); assertEquals(false, iField.equals(ISOChronology.getInstance().minutes())); DurationField dummy = new PreciseDurationField(DurationFieldType.seconds(), 0); assertEquals(false, iField.equals(dummy)); dummy = new PreciseDurationField(DurationFieldType.seconds(), 1000); assertEquals(true, iField.equals(dummy)); dummy = new PreciseDurationField(DurationFieldType.millis(), 1000); assertEquals(false, iField.equals(dummy)); assertEquals(false, iField.equals("")); assertEquals(false, iField.equals(null)); } public void test_hashCode() { assertEquals(true, iField.hashCode() == iField.hashCode()); assertEquals(false, iField.hashCode() == ISOChronology.getInstance().minutes().hashCode()); DurationField dummy = new PreciseDurationField(DurationFieldType.seconds(), 0); assertEquals(false, iField.hashCode() == dummy.hashCode()); dummy = new PreciseDurationField(DurationFieldType.seconds(), 1000); assertEquals(true, iField.hashCode() == dummy.hashCode()); dummy = new PreciseDurationField(DurationFieldType.millis(), 1000); assertEquals(false, iField.hashCode() == dummy.hashCode()); } //----------------------------------------------------------------------- public void test_compareTo() { assertEquals(0, iField.compareTo(iField)); assertEquals(-1, iField.compareTo(ISOChronology.getInstance().minutes())); DurationField dummy = new PreciseDurationField(DurationFieldType.seconds(), 0); assertEquals(1, iField.compareTo(dummy)); // try { // iField.compareTo(""); // fail(); // } catch (ClassCastException ex) {} try { iField.compareTo(null); fail(); } catch (NullPointerException ex) {} } //----------------------------------------------------------------------- public void testSerialization() throws Exception { DurationField test = iField; ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(test); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); DurationField result = (DurationField) ois.readObject(); ois.close(); assertEquals(test, result); } }
/* * Copyright 2001-2009 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.field; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.DurationField; import org.joda.time.DurationFieldType; import org.joda.time.chrono.ISOChronology; /** * This class is a Junit unit test for PreciseDurationField. * * @author Stephen Colebourne */ public class TestScaledDurationField extends TestCase { private static final long LONG_INTEGER_MAX = Integer.MAX_VALUE; private static final int INTEGER_MAX = Integer.MAX_VALUE; private static final long LONG_MAX = Long.MAX_VALUE; private ScaledDurationField iField; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestScaledDurationField.class); } public TestScaledDurationField(String name) { super(name); } protected void setUp() throws Exception { DurationField base = MillisDurationField.INSTANCE; iField = new ScaledDurationField(base, DurationFieldType.minutes(), 90); } protected void tearDown() throws Exception { iField = null; } //----------------------------------------------------------------------- public void test_constructor() { try { new ScaledDurationField(null, DurationFieldType.minutes(), 10); fail(); } catch (IllegalArgumentException ex) {} try { new ScaledDurationField(MillisDurationField.INSTANCE, null, 10); fail(); } catch (IllegalArgumentException ex) {} try { new ScaledDurationField(MillisDurationField.INSTANCE, DurationFieldType.minutes(), 0); fail(); } catch (IllegalArgumentException ex) {} try { new ScaledDurationField(MillisDurationField.INSTANCE, DurationFieldType.minutes(), 1); fail(); } catch (IllegalArgumentException ex) {} } public void test_getScalar() { assertEquals(90, iField.getScalar()); } //----------------------------------------------------------------------- public void test_getType() { assertEquals(DurationFieldType.minutes(), iField.getType()); } public void test_getName() { assertEquals("minutes", iField.getName()); } public void test_isSupported() { assertEquals(true, iField.isSupported()); } public void test_isPrecise() { assertEquals(true, iField.isPrecise()); } public void test_getUnitMillis() { assertEquals(90, iField.getUnitMillis()); } public void test_toString() { assertEquals("DurationField[minutes]", iField.toString()); } //----------------------------------------------------------------------- public void test_getValue_long() { assertEquals(0, iField.getValue(0L)); assertEquals(12345678 / 90, iField.getValue(12345678L)); assertEquals(-1234 / 90, iField.getValue(-1234L)); assertEquals(INTEGER_MAX / 90, iField.getValue(LONG_INTEGER_MAX)); try { iField.getValue(LONG_INTEGER_MAX + 1L); fail(); } catch (ArithmeticException ex) {} } public void test_getValueAsLong_long() { assertEquals(0L, iField.getValueAsLong(0L)); assertEquals(12345678L / 90, iField.getValueAsLong(12345678L)); assertEquals(-1234 / 90L, iField.getValueAsLong(-1234L)); assertEquals(LONG_INTEGER_MAX + 1L, iField.getValueAsLong(LONG_INTEGER_MAX * 90L + 90L)); } public void test_getValue_long_long() { assertEquals(0, iField.getValue(0L, 567L)); assertEquals(12345678 / 90, iField.getValue(12345678L, 567L)); assertEquals(-1234 / 90, iField.getValue(-1234L, 567L)); assertEquals(INTEGER_MAX / 90, iField.getValue(LONG_INTEGER_MAX, 567L)); try { iField.getValue(LONG_INTEGER_MAX + 1L, 567L); fail(); } catch (ArithmeticException ex) {} } public void test_getValueAsLong_long_long() { assertEquals(0L, iField.getValueAsLong(0L, 567L)); assertEquals(12345678 / 90L, iField.getValueAsLong(12345678L, 567L)); assertEquals(-1234 / 90L, iField.getValueAsLong(-1234L, 567L)); assertEquals(LONG_INTEGER_MAX + 1L, iField.getValueAsLong(LONG_INTEGER_MAX * 90L + 90L, 567L)); } //----------------------------------------------------------------------- public void test_getMillis_int() { assertEquals(0, iField.getMillis(0)); assertEquals(1234L * 90L, iField.getMillis(1234)); assertEquals(-1234L * 90L, iField.getMillis(-1234)); assertEquals(LONG_INTEGER_MAX * 90L, iField.getMillis(INTEGER_MAX)); } public void test_getMillis_long() { assertEquals(0L, iField.getMillis(0L)); assertEquals(1234L * 90L, iField.getMillis(1234L)); assertEquals(-1234L * 90L, iField.getMillis(-1234L)); try { iField.getMillis(LONG_MAX); fail(); } catch (ArithmeticException ex) {} } public void test_getMillis_int_long() { assertEquals(0L, iField.getMillis(0, 567L)); assertEquals(1234L * 90L, iField.getMillis(1234, 567L)); assertEquals(-1234L * 90L, iField.getMillis(-1234, 567L)); assertEquals(LONG_INTEGER_MAX * 90L, iField.getMillis(INTEGER_MAX, 567L)); } public void test_getMillis_long_long() { assertEquals(0L, iField.getMillis(0L, 567L)); assertEquals(1234L * 90L, iField.getMillis(1234L, 567L)); assertEquals(-1234L * 90L, iField.getMillis(-1234L, 567L)); try { iField.getMillis(LONG_MAX, 567L); fail(); } catch (ArithmeticException ex) {} } //----------------------------------------------------------------------- public void test_add_long_int() { assertEquals(567L, iField.add(567L, 0)); assertEquals(567L + 1234L * 90L, iField.add(567L, 1234)); assertEquals(567L - 1234L * 90L, iField.add(567L, -1234)); try { iField.add(LONG_MAX, 1); fail(); } catch (ArithmeticException ex) {} } public void test_add_long_long() { assertEquals(567L, iField.add(567L, 0L)); assertEquals(567L + 1234L * 90L, iField.add(567L, 1234L)); assertEquals(567L - 1234L * 90L, iField.add(567L, -1234L)); try { iField.add(LONG_MAX, 1L); fail(); } catch (ArithmeticException ex) {} try { iField.add(1L, LONG_MAX); fail(); } catch (ArithmeticException ex) {} } //----------------------------------------------------------------------- public void test_getDifference_long_int() { assertEquals(0, iField.getDifference(1L, 0L)); assertEquals(567, iField.getDifference(567L * 90L, 0L)); assertEquals(567 - 1234, iField.getDifference(567L * 90L, 1234L * 90L)); assertEquals(567 + 1234, iField.getDifference(567L * 90L, -1234L * 90L)); try { iField.getDifference(LONG_MAX, -1L); fail(); } catch (ArithmeticException ex) {} } public void test_getDifferenceAsLong_long_long() { assertEquals(0L, iField.getDifferenceAsLong(1L, 0L)); assertEquals(567L, iField.getDifferenceAsLong(567L * 90L, 0L)); assertEquals(567L - 1234L, iField.getDifferenceAsLong(567L * 90L, 1234L * 90L)); assertEquals(567L + 1234L, iField.getDifferenceAsLong(567L * 90L, -1234L * 90L)); try { iField.getDifferenceAsLong(LONG_MAX, -1L); fail(); } catch (ArithmeticException ex) {} } //----------------------------------------------------------------------- public void test_equals() { assertEquals(true, iField.equals(iField)); assertEquals(false, iField.equals(ISOChronology.getInstance().minutes())); DurationField dummy = new ScaledDurationField(MillisDurationField.INSTANCE, DurationFieldType.minutes(), 2); assertEquals(false, iField.equals(dummy)); dummy = new ScaledDurationField(MillisDurationField.INSTANCE, DurationFieldType.minutes(), 90); assertEquals(true, iField.equals(dummy)); dummy = new ScaledDurationField(MillisDurationField.INSTANCE, DurationFieldType.millis(), 90); assertEquals(false, iField.equals(dummy)); assertEquals(false, iField.equals("")); assertEquals(false, iField.equals(null)); } public void test_hashCode() { assertEquals(iField.hashCode(), iField.hashCode()); assertEquals(false, iField.hashCode() == ISOChronology.getInstance().minutes().hashCode()); DurationField dummy = new ScaledDurationField(MillisDurationField.INSTANCE, DurationFieldType.minutes(), 2); assertEquals(false, iField.hashCode() == dummy.hashCode()); dummy = new ScaledDurationField(MillisDurationField.INSTANCE, DurationFieldType.minutes(), 90); assertEquals(true, iField.hashCode() == dummy.hashCode()); dummy = new ScaledDurationField(MillisDurationField.INSTANCE, DurationFieldType.millis(), 90); assertEquals(false, iField.hashCode() == dummy.hashCode()); } //----------------------------------------------------------------------- public void test_compareTo() { assertEquals(0, iField.compareTo(iField)); assertEquals(-1, iField.compareTo(ISOChronology.getInstance().minutes())); DurationField dummy = new PreciseDurationField(DurationFieldType.minutes(), 0); assertEquals(1, iField.compareTo(dummy)); // try { // iField.compareTo(""); // fail(); // } catch (ClassCastException ex) {} try { iField.compareTo(null); fail(); } catch (NullPointerException ex) {} } //----------------------------------------------------------------------- public void testSerialization() throws Exception { DurationField test = iField; ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(test); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); DurationField result = (DurationField) ois.readObject(); ois.close(); assertEquals(test, result); } }
/* * Copyright 2001-2006 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.field; import java.util.Locale; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.DateTimeField; import org.joda.time.DateTimeFieldType; import org.joda.time.DurationFieldType; import org.joda.time.LocalTime; import org.joda.time.ReadablePartial; /** * This class is a JUnit test to test only the UnsupportedDateTimeField class. * This set of test cases exercises everything described in the Javadoc for this * class. * * @author Jeremy R. Rickard */ public class TestUnsupportedDateTimeField extends TestCase { private DurationFieldType weeks; private DurationFieldType months; private DateTimeFieldType dateTimeFieldTypeOne; private ReadablePartial localTime; public static TestSuite suite() { return new TestSuite(TestUnsupportedDateTimeField.class); } protected void setUp() throws Exception { weeks = DurationFieldType.weeks(); months = DurationFieldType.months(); dateTimeFieldTypeOne = DateTimeFieldType.centuryOfEra(); localTime = new LocalTime(); } /** * Passing null values into UnsupportedDateTimeField.getInstance() should * throw an IllegalArguementsException */ public void testNullValuesToGetInstanceThrowsException() { try { UnsupportedDateTimeField.getInstance(null, null); assertTrue(false); } catch (IllegalArgumentException e) { assertTrue(true); } } /** * * This test exercises the logic in UnsupportedDateTimeField.getInstance. If * getInstance() is invoked twice with: - the same DateTimeFieldType - * different duration fields * * Then the field returned in the first invocation should not be equal to * the field returned by the second invocation. In otherwords, the generated * instance should be the same for a unique pairing of * DateTimeFieldType/DurationField */ public void testDifferentDurationReturnDifferentObjects() { /** * The fields returned by getInstance should be the same when the * duration is the same for both method calls. */ DateTimeField fieldOne = UnsupportedDateTimeField.getInstance( dateTimeFieldTypeOne, UnsupportedDurationField .getInstance(weeks)); DateTimeField fieldTwo = UnsupportedDateTimeField.getInstance( dateTimeFieldTypeOne, UnsupportedDurationField .getInstance(weeks)); assertSame(fieldOne, fieldTwo); /** * The fields returned by getInstance should NOT be the same when the * duration is the same for both method calls. */ DateTimeField fieldThree = UnsupportedDateTimeField.getInstance( dateTimeFieldTypeOne, UnsupportedDurationField .getInstance(months)); assertNotSame(fieldOne, fieldThree); } /** * The getName() method should return the same value as the getName() method * of the DateTimeFieldType that was used to create the instance. * */ public void testPublicGetNameMethod() { DateTimeField fieldOne = UnsupportedDateTimeField.getInstance( dateTimeFieldTypeOne, UnsupportedDurationField .getInstance(weeks)); assertSame(fieldOne.getName(), dateTimeFieldTypeOne.getName()); } /** * As this is an unsupported date/time field, some normal methods will * always return false, as they are not supported. Verify that each method * correctly returns null. */ public void testAlwaysFalseReturnTypes() { DateTimeField fieldOne = UnsupportedDateTimeField.getInstance( dateTimeFieldTypeOne, UnsupportedDurationField .getInstance(weeks)); assertFalse(fieldOne.isLenient()); assertFalse(fieldOne.isSupported()); } /** * According to the JavaDocs, there are two methods that should always * return null. * getRangeDurationField() * getLeapDurationField() * * Ensure that these are in fact null. */ public void testMethodsThatShouldAlwaysReturnNull() { DateTimeField fieldOne = UnsupportedDateTimeField.getInstance( dateTimeFieldTypeOne, UnsupportedDurationField .getInstance(weeks)); assertNull(fieldOne.getLeapDurationField()); assertNull(fieldOne.getRangeDurationField()); } /** * As this is an unsupported date/time field, many normal methods are * unsupported and throw an UnsupportedOperationException. Verify that each * method correctly throws this exception. * add(ReadablePartial instant, * int fieldIndex, int[] values, int valueToAdd) * addWrapField(long * instant, int value) * addWrapField(ReadablePartial instant, int * fieldIndex, int[] values, int valueToAdd) * * addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int * valueToAdd) * get(long instant) * getAsShortText(int fieldValue, Locale * locale) * getAsShortText(long instant) * getAsShortText(long instant, * Locale locale) * getAsShortText(ReadablePartial partial, int fieldValue, * Locale locale) * getAsShortText(ReadablePartial partial, Locale locale) * * getAsText(int fieldValue, Locale locale) * getAsText(long instant) * * getAsText(long instant, Locale locale) * getAsText(ReadablePartial * partial, int fieldValue, Locale locale) * getAsText(ReadablePartial * partial, Locale locale) * getLeapAmount(long instant) * * getMaximumShortTextLength(Locale locale) * getMaximumTextLength(Locale * locale) * getMaximumValue() * getMaximumValue(long instant) * * getMaximumValue(ReadablePartial instant) * * getMaximumValue(ReadablePartial instant, int[] values) * * getMinimumValue() * getMinimumValue(long instant) * * getMinimumValue(ReadablePartial instant) * * getMinimumValue(ReadablePartial instant, int[] values) * isLeap(long * instant) * remainder(long instant) * roundCeiling(long instant) * * roundFloor(long instant) * roundHalfCeiling(long instant) * * roundHalfEven(long instant) * roundHalfFloor(long instant) * set(long * instant, int value) * set(long instant, String text) * set(long instant, * String text, Locale locale) * set(ReadablePartial instant, int * fieldIndex, int[] values, int newValue) * set(ReadablePartial instant, * int fieldIndex, int[] values, String text, Locale locale) */ public void testUnsupportedMethods() { DateTimeField fieldOne = UnsupportedDateTimeField.getInstance( dateTimeFieldTypeOne, UnsupportedDurationField .getInstance(weeks)); // add(ReadablePartial instant, int fieldIndex, int[] values, int // valueToAdd) try { fieldOne.add(localTime, 0, new int[] { 0, 100 }, 100); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // addWrapField(long instant, int value) try { fieldOne.addWrapField(100000L, 250); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // addWrapField(ReadablePartial instant, int fieldIndex, int[] values, // int valueToAdd) try { fieldOne.addWrapField(localTime, 0, new int[] { 0, 100 }, 100); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, // int valueToAdd) try { fieldOne.addWrapPartial(localTime, 0, new int[] { 0, 100 }, 100); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.get(long instant) try { fieldOne.get(1000L); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.getAsShortText(int fieldValue, // Locale locale) try { fieldOne.getAsShortText(0, Locale.getDefault()); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.getAsShortText(long instant) try { fieldOne.getAsShortText(100000L); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.getAsShortText(long instant, Locale locale) try { fieldOne.getAsShortText(100000L, Locale.getDefault()); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.getAsShortText(ReadablePartial partial, // int fieldValue, // Locale locale) try { fieldOne.getAsShortText(localTime, 0, Locale.getDefault()); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.getAsShortText(ReadablePartial partial, // Locale locale) try { fieldOne.getAsShortText(localTime, Locale.getDefault()); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.getAsText(int fieldValue, // Locale locale) try { fieldOne.getAsText(0, Locale.getDefault()); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.getAsText(long instant) try { fieldOne.getAsText(1000L); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.getAsText(long instant, Locale locale) try { fieldOne.getAsText(1000L, Locale.getDefault()); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.getAsText(ReadablePartial partial, // int fieldValue, // Locale locale) try { fieldOne.getAsText(localTime, 0, Locale.getDefault()); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.getAsText(ReadablePartial partial, // Locale locale) try { fieldOne.getAsText(localTime, Locale.getDefault()); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.getLeapAmount(long instant) is unsupported // and should always thrown an UnsupportedOperationException try { fieldOne.getLeapAmount(System.currentTimeMillis()); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.getMaximumShortTextLength(Locale locale) // is unsupported and should always thrown an // UnsupportedOperationException try { fieldOne.getMaximumShortTextLength(Locale.getDefault()); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.getMaximumTextLength(Locale locale) // is unsupported and should always thrown an // UnsupportedOperationException try { fieldOne.getMaximumTextLength(Locale.getDefault()); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.getMaximumValue() is unsupported // and should always thrown an UnsupportedOperationException try { fieldOne.getMaximumValue(); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.getMaximumValue(long instant) // is unsupported and should always thrown an // UnsupportedOperationException try { fieldOne.getMaximumValue(1000000L); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.getMaximumValue(ReadablePartial instant) // is unsupported and should always thrown an // UnsupportedOperationException try { fieldOne.getMaximumValue(localTime); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.getMaximumValue(ReadablePartial instant, // int[] values) // is unsupported and should always thrown an // UnsupportedOperationException try { fieldOne.getMaximumValue(localTime, new int[] { 0 }); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.getMinumumValue() is unsupported // and should always thrown an UnsupportedOperationException try { fieldOne.getMinimumValue(); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.getMinumumValue(long instant) is unsupported // and should always thrown an UnsupportedOperationException try { fieldOne.getMinimumValue(10000000L); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.getMinumumValue(ReadablePartial instant) // is unsupported and should always thrown an // UnsupportedOperationException try { fieldOne.getMinimumValue(localTime); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.getMinumumValue(ReadablePartial instant, // int[] values) is unsupported // and should always thrown an UnsupportedOperationException try { fieldOne.getMinimumValue(localTime, new int[] { 0 }); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.isLeap(long instant) is unsupported and // should always thrown an UnsupportedOperationException try { fieldOne.isLeap(System.currentTimeMillis()); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.remainder(long instant) is unsupported and // should always thrown an UnsupportedOperationException try { fieldOne.remainder(1000000L); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.roundCeiling(long instant) is unsupported // and // should always thrown an UnsupportedOperationException try { fieldOne.roundCeiling(1000000L); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.roundFloor(long instant) is unsupported and // should always thrown an UnsupportedOperationException try { fieldOne.roundFloor(1000000L); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.roundHalfCeiling(long instant) is // unsupported and // should always thrown an UnsupportedOperationException try { fieldOne.roundHalfCeiling(1000000L); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.roundHalfEven(long instant) is unsupported // and // should always thrown an UnsupportedOperationException try { fieldOne.roundHalfEven(1000000L); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.roundHalfFloor(long instant) is unsupported // and // should always thrown an UnsupportedOperationException try { fieldOne.roundHalfFloor(1000000L); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.set(long instant, int value) is unsupported // and // should always thrown an UnsupportedOperationException try { fieldOne.set(1000000L, 1000); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.set(long instant, String test) is // unsupported and // should always thrown an UnsupportedOperationException try { fieldOne.set(1000000L, "Unsupported Operation"); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.set(long instant, String text, Locale // locale) // is unsupported and should always thrown an // UnsupportedOperationException try { fieldOne .set(1000000L, "Unsupported Operation", Locale.getDefault()); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.set(ReadablePartial instant, // int fieldIndex, // int[] values, // int newValue) is unsupported and // should always thrown an UnsupportedOperationException try { fieldOne.set(localTime, 0, new int[] { 0 }, 10000); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } // UnsupportedDateTimeField.set(ReadablePartial instant, // int fieldIndex, // int[] values, // String text, // Locale locale) is unsupported and // should always thrown an UnsupportedOperationException try { fieldOne.set(localTime, 0, new int[] { 0 }, "Unsupported Operation", Locale.getDefault()); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } } /** * As this is an unsupported date/time field, many normal methods are * unsupported. Some delegate and can possibly throw an * UnsupportedOperationException or have a valid return. Verify that each * method correctly throws this exception when appropriate and delegates * correctly based on the Duration used to get the instance. */ public void testDelegatedMethods() { DateTimeField fieldOne = UnsupportedDateTimeField.getInstance( dateTimeFieldTypeOne, UnsupportedDurationField .getInstance(weeks)); PreciseDurationField hoursDuration = new PreciseDurationField( DurationFieldType.hours(), 10L); DateTimeField fieldTwo = UnsupportedDateTimeField.getInstance( dateTimeFieldTypeOne, hoursDuration); // UnsupportedDateTimeField.add(long instant, int value) should // throw an UnsupportedOperationException when the duration does // not support the operation, otherwise it delegates to the duration. // First // try it with an UnsupportedDurationField, then a PreciseDurationField. try { fieldOne.add(System.currentTimeMillis(), 100); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } try { long currentTime = System.currentTimeMillis(); long firstComputation = hoursDuration.add(currentTime, 100); long secondComputation = fieldTwo.add(currentTime, 100); assertEquals(firstComputation,secondComputation); } catch (UnsupportedOperationException e) { assertTrue(false); } // UnsupportedDateTimeField.add(long instant, long value) should // throw an UnsupportedOperationException when the duration does // not support the operation, otherwise it delegates to the duration. // First // try it with an UnsupportedDurationField, then a PreciseDurationField. try { fieldOne.add(System.currentTimeMillis(), 1000L); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } try { long currentTime = System.currentTimeMillis(); long firstComputation = hoursDuration.add(currentTime, 1000L); long secondComputation = fieldTwo.add(currentTime, 1000L); assertTrue(firstComputation == secondComputation); assertEquals(firstComputation,secondComputation); } catch (UnsupportedOperationException e) { assertTrue(false); } // UnsupportedDateTimeField.getDifference(long minuendInstant, // long subtrahendInstant) // should throw an UnsupportedOperationException when the duration does // not support the operation, otherwise return the result from the // delegated call. try { fieldOne.getDifference(100000L, 1000L); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } try { int firstDifference = hoursDuration.getDifference(100000L, 1000L); int secondDifference = fieldTwo.getDifference(100000L, 1000L); assertEquals(firstDifference,secondDifference); } catch (UnsupportedOperationException e) { assertTrue(false); } // UnsupportedDateTimeField.getDifferenceAsLong(long minuendInstant, // long subtrahendInstant) // should throw an UnsupportedOperationException when the duration does // not support the operation, otherwise return the result from the // delegated call. try { fieldOne.getDifferenceAsLong(100000L, 1000L); assertTrue(false); } catch (UnsupportedOperationException e) { assertTrue(true); } try { long firstDifference = hoursDuration.getDifference(100000L, 1000L); long secondDifference = fieldTwo.getDifference(100000L, 1000L); assertEquals(firstDifference,secondDifference); } catch (UnsupportedOperationException e) { assertTrue(false); } } /** * The toString method should return a suitable debug message (not null). * Ensure that the toString method returns a string with length greater than * 0 (and not null) * */ public void testToString() { DateTimeField fieldOne = UnsupportedDateTimeField.getInstance( dateTimeFieldTypeOne, UnsupportedDurationField .getInstance(weeks)); String debugMessage = fieldOne.toString(); assertNotNull(debugMessage); assertTrue(debugMessage.length() > 0); } }
/* * Copyright 2001-2006 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.format; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.Chronology; import org.joda.time.DateTime; import org.joda.time.DateTimeConstants; import org.joda.time.DateTimeFieldType; import org.joda.time.DateTimeUtils; import org.joda.time.DateTimeZone; import org.joda.time.chrono.GJChronology; /** * This class is a Junit unit test for DateTime Formating. * * @author Stephen Colebourne * @author Fredrik Borgh */ public class TestDateTimeFormat extends TestCase { private static final DateTimeZone UTC = DateTimeZone.UTC; private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo"); private static final DateTimeZone NEWYORK = DateTimeZone.forID("America/New_York"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestDateTimeFormat.class); } public TestDateTimeFormat(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testSubclassableConstructor() { DateTimeFormat f = new DateTimeFormat() { // test constructor is protected }; assertNotNull(f); } //----------------------------------------------------------------------- public void testFormat_era() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("G").withLocale(Locale.UK); assertEquals(dt.toString(), "AD", f.print(dt)); dt = dt.withZone(NEWYORK); assertEquals(dt.toString(), "AD", f.print(dt)); dt = dt.withZone(PARIS); assertEquals(dt.toString(), "AD", f.print(dt)); } //----------------------------------------------------------------------- public void testFormat_centuryOfEra() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("C").withLocale(Locale.UK); assertEquals(dt.toString(), "20", f.print(dt)); dt = dt.withZone(NEWYORK); assertEquals(dt.toString(), "20", f.print(dt)); dt = dt.withZone(TOKYO); assertEquals(dt.toString(), "20", f.print(dt)); dt = new DateTime(-123, 6, 9, 10, 20, 30, 40, UTC); assertEquals(dt.toString(), "1", f.print(dt)); } //----------------------------------------------------------------------- public void testFormat_yearOfEra() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("Y").withLocale(Locale.UK); assertEquals(dt.toString(), "2004", f.print(dt)); dt = dt.withZone(NEWYORK); assertEquals(dt.toString(), "2004", f.print(dt)); dt = dt.withZone(TOKYO); assertEquals(dt.toString(), "2004", f.print(dt)); dt = new DateTime(-123, 6, 9, 10, 20, 30, 40, UTC); assertEquals(dt.toString(), "124", f.print(dt)); // 124th year of BCE } public void testFormat_yearOfEra_twoDigit() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("YY").withLocale(Locale.UK); assertEquals(dt.toString(), "04", f.print(dt)); dt = new DateTime(-123, 6, 9, 10, 20, 30, 40, UTC); assertEquals(dt.toString(), "23", f.print(dt)); // current time set to 2002-06-09 f = f.withZoneUTC(); DateTime expect = null; expect = new DateTime(2004, 1, 1, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("04")); expect = new DateTime(1922, 1, 1, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("22")); expect = new DateTime(2021, 1, 1, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("21")); // Added tests to ensure single sign digit parse fails properly try { f.parseDateTime("-"); fail(); } catch (IllegalArgumentException ex) {} try { f.parseDateTime("+"); fail(); } catch (IllegalArgumentException ex) {} // Added tests for pivot year setting f = f.withPivotYear(new Integer(2050)); expect = new DateTime(2000, 1, 1, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("00")); expect = new DateTime(2099, 1, 1, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("99")); // Added tests to ensure two digit parsing is lenient for DateTimeFormat f = DateTimeFormat.forPattern("YY").withLocale(Locale.UK); f = f.withZoneUTC(); f.parseDateTime("5"); f.parseDateTime("005"); f.parseDateTime("+50"); f.parseDateTime("-50"); } public void testFormat_yearOfEraParse() { Chronology chrono = GJChronology.getInstanceUTC(); DateTimeFormatter f = DateTimeFormat .forPattern("YYYY-MM GG") .withChronology(chrono) .withLocale(Locale.UK); DateTime dt = new DateTime(2005, 10, 1, 0, 0, 0, 0, chrono); assertEquals(dt, f.parseDateTime("2005-10 AD")); assertEquals(dt, f.parseDateTime("2005-10 CE")); dt = new DateTime(-2005, 10, 1, 0, 0, 0, 0, chrono); assertEquals(dt, f.parseDateTime("2005-10 BC")); assertEquals(dt, f.parseDateTime("2005-10 BCE")); } //----------------------------------------------------------------------- public void testFormat_year() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("y").withLocale(Locale.UK); assertEquals(dt.toString(), "2004", f.print(dt)); dt = dt.withZone(NEWYORK); assertEquals(dt.toString(), "2004", f.print(dt)); dt = dt.withZone(TOKYO); assertEquals(dt.toString(), "2004", f.print(dt)); dt = new DateTime(-123, 6, 9, 10, 20, 30, 40, UTC); assertEquals(dt.toString(), "-123", f.print(dt)); // Added tests to ensure single sign digit parse fails properly try { f.parseDateTime("-"); fail(); } catch (IllegalArgumentException ex) {} try { f.parseDateTime("+"); fail(); } catch (IllegalArgumentException ex) {} } public void testFormat_year_twoDigit() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("yy").withLocale(Locale.UK); assertEquals(dt.toString(), "04", f.print(dt)); dt = new DateTime(-123, 6, 9, 10, 20, 30, 40, UTC); assertEquals(dt.toString(), "23", f.print(dt)); // current time set to 2002-06-09 f = f.withZoneUTC(); DateTime expect = null; expect = new DateTime(2004, 1, 1, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("04")); expect = new DateTime(1922, 1, 1, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("22")); expect = new DateTime(2021, 1, 1, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("21")); // Added tests to ensure single sign digit parse fails properly try { f.parseDateTime("-"); fail(); } catch (IllegalArgumentException ex) {} try { f.parseDateTime("+"); fail(); } catch (IllegalArgumentException ex) {} // Added tests for pivot year setting f = f.withPivotYear(new Integer(2050)); expect = new DateTime(2000, 1, 1, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("00")); expect = new DateTime(2099, 1, 1, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("99")); // Added tests to ensure two digit parsing is strict by default for // DateTimeFormatterBuilder f = new DateTimeFormatterBuilder().appendTwoDigitYear(2000).toFormatter(); f = f.withZoneUTC(); try { f.parseDateTime("5"); fail(); } catch (IllegalArgumentException ex) {} try { f.parseDateTime("005"); fail(); } catch (IllegalArgumentException ex) {} try { f.parseDateTime("+50"); fail(); } catch (IllegalArgumentException ex) {} try { f.parseDateTime("-50"); fail(); } catch (IllegalArgumentException ex) {} // Added tests to ensure two digit parsing is lenient for DateTimeFormat f = DateTimeFormat.forPattern("yy").withLocale(Locale.UK); f = f.withZoneUTC(); f.parseDateTime("5"); f.parseDateTime("005"); f.parseDateTime("+50"); f.parseDateTime("-50"); // Added tests for lenient two digit parsing f = new DateTimeFormatterBuilder().appendTwoDigitYear(2000, true).toFormatter(); f = f.withZoneUTC(); expect = new DateTime(2004, 1, 1, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("04")); expect = new DateTime(4, 1, 1, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("+04")); expect = new DateTime(-4, 1, 1, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("-04")); expect = new DateTime(4, 1, 1, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("4")); expect = new DateTime(-4, 1, 1, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("-4")); expect = new DateTime(4, 1, 1, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("004")); expect = new DateTime(4, 1, 1, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("+004")); expect = new DateTime(-4, 1, 1, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("-004")); expect = new DateTime(3004, 1, 1, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("3004")); expect = new DateTime(3004, 1, 1, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("+3004")); expect = new DateTime(-3004, 1, 1, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("-3004")); try { f.parseDateTime("-"); fail(); } catch (IllegalArgumentException ex) {} try { f.parseDateTime("+"); fail(); } catch (IllegalArgumentException ex) {} } public void testFormat_year_long() { DateTime dt = new DateTime(278004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("yyyy"); assertEquals(dt.toString(), "278004", f.print(dt)); // for coverage f = DateTimeFormat.forPattern("yyyyMMdd"); assertEquals(dt.toString(), "2780040609", f.print(dt)); // for coverage f = DateTimeFormat.forPattern("yyyyddMM"); assertEquals(dt.toString(), "2780040906", f.print(dt)); } //----------------------------------------------------------------------- public void testFormat_weekyear() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("x").withLocale(Locale.UK); assertEquals(dt.toString(), "2004", f.print(dt)); dt = dt.withZone(NEWYORK); assertEquals(dt.toString(), "2004", f.print(dt)); dt = dt.withZone(TOKYO); assertEquals(dt.toString(), "2004", f.print(dt)); dt = new DateTime(-123, 6, 9, 10, 20, 30, 40, UTC); assertEquals(dt.toString(), "-123", f.print(dt)); } public void testFormat_weekyearOfEra_twoDigit() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("xx").withLocale(Locale.UK); assertEquals(dt.toString(), "04", f.print(dt)); dt = new DateTime(-123, 6, 9, 10, 20, 30, 40, UTC); assertEquals(dt.toString(), "23", f.print(dt)); // current time set to 2002-06-09 f = f.withZoneUTC(); DateTime expect = null; expect = new DateTime(2003, 12, 29, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("04")); expect = new DateTime(1922, 1, 2, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("22")); expect = new DateTime(2021, 1, 4, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("21")); // Added tests to ensure single sign digit parse fails properly try { f.parseDateTime("-"); fail(); } catch (IllegalArgumentException ex) {} try { f.parseDateTime("+"); fail(); } catch (IllegalArgumentException ex) {} // Added tests for pivot year setting f = f.withPivotYear(new Integer(2050)); expect = new DateTime(2000, 1, 3, 0, 0, 0, 0, DateTimeZone.UTC); assertEquals(expect, f.parseDateTime("00")); expect = new DateTime(2098, 12, 29, 0, 0, 0, 0, DateTimeZone.UTC); assertEquals(expect, f.parseDateTime("99")); // Added tests to ensure two digit parsing is strict by default for // DateTimeFormatterBuilder f = new DateTimeFormatterBuilder().appendTwoDigitWeekyear(2000).toFormatter(); f = f.withZoneUTC(); try { f.parseDateTime("5"); fail(); } catch (IllegalArgumentException ex) {} try { f.parseDateTime("005"); fail(); } catch (IllegalArgumentException ex) {} try { f.parseDateTime("+50"); fail(); } catch (IllegalArgumentException ex) {} try { f.parseDateTime("-50"); fail(); } catch (IllegalArgumentException ex) {} // Added tests to ensure two digit parsing is lenient for DateTimeFormat f = DateTimeFormat.forPattern("xx").withLocale(Locale.UK); f = f.withZoneUTC(); f.parseDateTime("5"); f.parseDateTime("005"); f.parseDateTime("+50"); f.parseDateTime("-50"); // Added tests for lenient two digit parsing f = new DateTimeFormatterBuilder().appendTwoDigitWeekyear(2000, true).toFormatter(); f = f.withZoneUTC(); expect = new DateTime(2003, 12, 29, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("04")); expect = new DateTime(3, 12, 29, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("+04")); expect = new DateTime(-4, 1, 1, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("-04")); expect = new DateTime(3, 12, 29, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("4")); expect = new DateTime(-4, 1, 1, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("-4")); expect = new DateTime(3, 12, 29, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("004")); expect = new DateTime(3, 12, 29, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("+004")); expect = new DateTime(-4, 1, 1, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("-004")); expect = new DateTime(3004, 1, 2, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("3004")); expect = new DateTime(3004, 1, 2, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("+3004")); expect = new DateTime(-3004, 1, 4, 0, 0, 0, 0, UTC); assertEquals(expect, f.parseDateTime("-3004")); try { f.parseDateTime("-"); fail(); } catch (IllegalArgumentException ex) {} try { f.parseDateTime("+"); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testFormat_weekOfWeekyear() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("w").withLocale(Locale.UK); assertEquals(dt.toString(), "24", f.print(dt)); dt = dt.withZone(NEWYORK); assertEquals(dt.toString(), "24", f.print(dt)); dt = dt.withZone(TOKYO); assertEquals(dt.toString(), "24", f.print(dt)); } //----------------------------------------------------------------------- public void testFormat_dayOfWeek() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("e").withLocale(Locale.UK); assertEquals(dt.toString(), "3", f.print(dt)); dt = dt.withZone(NEWYORK); assertEquals(dt.toString(), "3", f.print(dt)); dt = dt.withZone(TOKYO); assertEquals(dt.toString(), "3", f.print(dt)); } //----------------------------------------------------------------------- public void testFormat_dayOfWeekShortText() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("E").withLocale(Locale.UK); assertEquals(dt.toString(), "Wed", f.print(dt)); dt = dt.withZone(NEWYORK); assertEquals(dt.toString(), "Wed", f.print(dt)); dt = dt.withZone(TOKYO); assertEquals(dt.toString(), "Wed", f.print(dt)); f = f.withLocale(Locale.FRENCH); assertEquals(dt.toString(), "mer.", f.print(dt)); } //----------------------------------------------------------------------- public void testFormat_dayOfWeekText() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("EEEE").withLocale(Locale.UK); assertEquals(dt.toString(), "Wednesday", f.print(dt)); dt = dt.withZone(NEWYORK); assertEquals(dt.toString(), "Wednesday", f.print(dt)); dt = dt.withZone(TOKYO); assertEquals(dt.toString(), "Wednesday", f.print(dt)); f = f.withLocale(Locale.FRENCH); assertEquals(dt.toString(), "mercredi", f.print(dt)); } //----------------------------------------------------------------------- public void testFormat_dayOfYearText() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("D").withLocale(Locale.UK); assertEquals(dt.toString(), "161", f.print(dt)); dt = dt.withZone(NEWYORK); assertEquals(dt.toString(), "161", f.print(dt)); dt = dt.withZone(TOKYO); assertEquals(dt.toString(), "161", f.print(dt)); } //----------------------------------------------------------------------- public void testFormat_monthOfYear() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("M").withLocale(Locale.UK); assertEquals(dt.toString(), "6", f.print(dt)); dt = dt.withZone(NEWYORK); assertEquals(dt.toString(), "6", f.print(dt)); dt = dt.withZone(TOKYO); assertEquals(dt.toString(), "6", f.print(dt)); } //----------------------------------------------------------------------- public void testFormat_monthOfYearShortText() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("MMM").withLocale(Locale.UK); assertEquals(dt.toString(), "Jun", f.print(dt)); dt = dt.withZone(NEWYORK); assertEquals(dt.toString(), "Jun", f.print(dt)); dt = dt.withZone(TOKYO); assertEquals(dt.toString(), "Jun", f.print(dt)); f = f.withLocale(Locale.FRENCH); assertEquals(dt.toString(), "juin", f.print(dt)); } //----------------------------------------------------------------------- public void testFormat_monthOfYearText() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("MMMM").withLocale(Locale.UK); assertEquals(dt.toString(), "June", f.print(dt)); dt = dt.withZone(NEWYORK); assertEquals(dt.toString(), "June", f.print(dt)); dt = dt.withZone(TOKYO); assertEquals(dt.toString(), "June", f.print(dt)); f = f.withLocale(Locale.FRENCH); assertEquals(dt.toString(), "juin", f.print(dt)); } //----------------------------------------------------------------------- public void testFormat_dayOfMonth() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("d").withLocale(Locale.UK); assertEquals(dt.toString(), "9", f.print(dt)); dt = dt.withZone(NEWYORK); assertEquals(dt.toString(), "9", f.print(dt)); dt = dt.withZone(TOKYO); assertEquals(dt.toString(), "9", f.print(dt)); } //----------------------------------------------------------------------- public void testFormat_halfdayOfDay() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("a").withLocale(Locale.UK); assertEquals(dt.toString(), "AM", f.print(dt)); dt = dt.withZone(NEWYORK); assertEquals(dt.toString(), "AM", f.print(dt)); dt = dt.withZone(TOKYO); assertEquals(dt.toString(), "PM", f.print(dt)); } //----------------------------------------------------------------------- public void testFormat_hourOfHalfday() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("K").withLocale(Locale.UK); assertEquals(dt.toString(), "10", f.print(dt)); dt = dt.withZone(NEWYORK); assertEquals(dt.toString(), "6", f.print(dt)); dt = dt.withZone(TOKYO); assertEquals(dt.toString(), "7", f.print(dt)); dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, UTC); assertEquals(dt.toString(), "0", f.print(dt)); } //----------------------------------------------------------------------- public void testFormat_clockhourOfHalfday() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("h").withLocale(Locale.UK); assertEquals(dt.toString(), "10", f.print(dt)); dt = dt.withZone(NEWYORK); assertEquals(dt.toString(), "6", f.print(dt)); dt = dt.withZone(TOKYO); assertEquals(dt.toString(), "7", f.print(dt)); dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, UTC); assertEquals(dt.toString(), "12", f.print(dt)); } //----------------------------------------------------------------------- public void testFormat_hourOfDay() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("H").withLocale(Locale.UK); assertEquals(dt.toString(), "10", f.print(dt)); dt = dt.withZone(NEWYORK); assertEquals(dt.toString(), "6", f.print(dt)); dt = dt.withZone(TOKYO); assertEquals(dt.toString(), "19", f.print(dt)); dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, UTC); assertEquals(dt.toString(), "0", f.print(dt)); } //----------------------------------------------------------------------- public void testFormat_clockhourOfDay() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("k").withLocale(Locale.UK); assertEquals(dt.toString(), "10", f.print(dt)); dt = dt.withZone(NEWYORK); assertEquals(dt.toString(), "6", f.print(dt)); dt = dt.withZone(TOKYO); assertEquals(dt.toString(), "19", f.print(dt)); dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, UTC); assertEquals(dt.toString(), "24", f.print(dt)); } //----------------------------------------------------------------------- public void testFormat_minute() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("m").withLocale(Locale.UK); assertEquals(dt.toString(), "20", f.print(dt)); dt = dt.withZone(NEWYORK); assertEquals(dt.toString(), "20", f.print(dt)); dt = dt.withZone(TOKYO); assertEquals(dt.toString(), "20", f.print(dt)); } //----------------------------------------------------------------------- public void testFormat_second() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("s").withLocale(Locale.UK); assertEquals(dt.toString(), "30", f.print(dt)); dt = dt.withZone(NEWYORK); assertEquals(dt.toString(), "30", f.print(dt)); dt = dt.withZone(TOKYO); assertEquals(dt.toString(), "30", f.print(dt)); } //----------------------------------------------------------------------- public void testFormat_fractionOfSecond() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("SSS").withLocale(Locale.UK); assertEquals(dt.toString(), "040", f.print(dt)); dt = dt.withZone(NEWYORK); assertEquals(dt.toString(), "040", f.print(dt)); dt = dt.withZone(TOKYO); assertEquals(dt.toString(), "040", f.print(dt)); } //----------------------------------------------------------------------- public void testFormat_fractionOfSecondLong() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("SSSSSS").withLocale(Locale.UK); assertEquals(dt.toString(), "040000", f.print(dt)); dt = dt.withZone(NEWYORK); assertEquals(dt.toString(), "040000", f.print(dt)); dt = dt.withZone(TOKYO); assertEquals(dt.toString(), "040000", f.print(dt)); } //----------------------------------------------------------------------- public void testFormat_zoneText() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("z").withLocale(Locale.UK); assertEquals(dt.toString(), "UTC", f.print(dt)); dt = dt.withZone(NEWYORK); assertEquals(dt.toString(), "EDT", f.print(dt)); dt = dt.withZone(TOKYO); assertEquals(dt.toString(), "JST", f.print(dt)); } public void testFormat_zoneLongText() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("zzzz").withLocale(Locale.UK); assertEquals(dt.toString(), "Coordinated Universal Time", f.print(dt)); dt = dt.withZone(NEWYORK); assertEquals(dt.toString(), "Eastern Daylight Time", f.print(dt)); dt = dt.withZone(TOKYO); assertEquals(dt.toString(), "Japan Standard Time", f.print(dt)); } //----------------------------------------------------------------------- public void testFormat_zoneAmount() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("Z").withLocale(Locale.UK); assertEquals(dt.toString(), "+0000", f.print(dt)); dt = dt.withZone(NEWYORK); assertEquals(dt.toString(), "-0400", f.print(dt)); dt = dt.withZone(TOKYO); assertEquals(dt.toString(), "+0900", f.print(dt)); } public void testFormat_zoneAmountColon() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("ZZ").withLocale(Locale.UK); assertEquals(dt.toString(), "+00:00", f.print(dt)); dt = dt.withZone(NEWYORK); assertEquals(dt.toString(), "-04:00", f.print(dt)); dt = dt.withZone(TOKYO); assertEquals(dt.toString(), "+09:00", f.print(dt)); } public void testFormat_zoneAmountID() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("ZZZ").withLocale(Locale.UK); assertEquals(dt.toString(), "UTC", f.print(dt)); dt = dt.withZone(NEWYORK); assertEquals(dt.toString(), "America/New_York", f.print(dt)); dt = dt.withZone(TOKYO); assertEquals(dt.toString(), "Asia/Tokyo", f.print(dt)); } //----------------------------------------------------------------------- public void testFormat_other() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("'Hello' ''"); assertEquals("Hello '", f.print(dt)); } public void testFormat_invalid() { try { DateTimeFormat.forPattern(null); fail(); } catch (IllegalArgumentException ex) {} try { DateTimeFormat.forPattern(""); fail(); } catch (IllegalArgumentException ex) {} try { DateTimeFormat.forPattern("A"); fail(); } catch (IllegalArgumentException ex) {} try { DateTimeFormat.forPattern("dd/mm/AA"); fail(); } catch (IllegalArgumentException ex) {} } public void testFormat_samples() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); DateTimeFormatter f = DateTimeFormat.forPattern("yyyy-MM-dd HH.mm.ss"); assertEquals("2004-06-09 10.20.30", f.print(dt)); } public void testFormat_shortBasicParse() { // Tests special two digit parse to make sure it properly switches // between lenient and strict parsing. DateTime dt = new DateTime(2004, 3, 9, 0, 0, 0, 0); DateTimeFormatter f = DateTimeFormat.forPattern("yyMMdd"); assertEquals(dt, f.parseDateTime("040309")); try { assertEquals(dt, f.parseDateTime("20040309")); fail(); } catch (IllegalArgumentException ex) {} f = DateTimeFormat.forPattern("yy/MM/dd"); assertEquals(dt, f.parseDateTime("04/03/09")); assertEquals(dt, f.parseDateTime("2004/03/09")); } //----------------------------------------------------------------------- public void testParse_pivotYear() { DateTimeFormatter dateFormatter = DateTimeFormat.forPattern("dd.MM.yy").withPivotYear(2050).withZoneUTC(); DateTime date = dateFormatter.parseDateTime("25.12.15"); assertEquals(date.getYear(), 2015); date = dateFormatter.parseDateTime("25.12.00"); assertEquals(date.getYear(), 2000); date = dateFormatter.parseDateTime("25.12.99"); assertEquals(date.getYear(), 2099); } public void testParse_pivotYear_ignored4DigitYear() { DateTimeFormatter dateFormatter = DateTimeFormat.forPattern("dd.MM.yyyy").withPivotYear(2050).withZoneUTC(); DateTime date = dateFormatter.parseDateTime("25.12.15"); assertEquals(date.getYear(), 15); date = dateFormatter.parseDateTime("25.12.00"); assertEquals(date.getYear(), 0); date = dateFormatter.parseDateTime("25.12.99"); assertEquals(date.getYear(), 99); } //----------------------------------------------------------------------- public void testFormatParse_textMonthJanShort_UK() { DateTimeFormatter dateFormatter = DateTimeFormat.forPattern("dd MMM yyyy") .withLocale(Locale.UK).withZoneUTC(); String str = new DateTime(2007, 1, 23, 0, 0, 0, 0, UTC).toString(dateFormatter); assertEquals(str, "23 Jan 2007"); DateTime date = dateFormatter.parseDateTime(str); check(date, 2007, 1, 23); } public void testFormatParse_textMonthJanShortLowerCase_UK() { DateTimeFormatter dateFormatter = DateTimeFormat.forPattern("dd MMM yyyy") .withLocale(Locale.UK).withZoneUTC(); DateTime date = dateFormatter.parseDateTime("23 jan 2007"); check(date, 2007, 1, 23); } public void testFormatParse_textMonthJanShortUpperCase_UK() { DateTimeFormatter dateFormatter = DateTimeFormat.forPattern("dd MMM yyyy") .withLocale(Locale.UK).withZoneUTC(); DateTime date = dateFormatter.parseDateTime("23 JAN 2007"); check(date, 2007, 1, 23); } public void testParse_textMonthJanLong_UK() { DateTimeFormatter dateFormatter = DateTimeFormat.forPattern("dd MMM yyyy") .withLocale(Locale.UK).withZoneUTC(); DateTime date = dateFormatter.parseDateTime("23 January 2007"); check(date, 2007, 1, 23); } public void testFormatParse_textMonthJanLongLowerCase_UK() { DateTimeFormatter dateFormatter = DateTimeFormat.forPattern("dd MMM yyyy") .withLocale(Locale.UK).withZoneUTC(); DateTime date = dateFormatter.parseDateTime("23 january 2007"); check(date, 2007, 1, 23); } public void testFormatParse_textMonthJanLongUpperCase_UK() { DateTimeFormatter dateFormatter = DateTimeFormat.forPattern("dd MMM yyyy") .withLocale(Locale.UK).withZoneUTC(); DateTime date = dateFormatter.parseDateTime("23 JANUARY 2007"); check(date, 2007, 1, 23); } public void testFormatParse_textMonthJanShort_France() { DateTimeFormatter dateFormatter = DateTimeFormat.forPattern("dd MMM yyyy") .withLocale(Locale.FRANCE).withZoneUTC(); String str = new DateTime(2007, 1, 23, 0, 0, 0, 0, UTC).toString(dateFormatter); assertEquals("23 janv. 2007", str); DateTime date = dateFormatter.parseDateTime(str); check(date, 2007, 1, 23); } public void testFormatParse_textMonthJanLong_France() { DateTimeFormatter dateFormatter = DateTimeFormat.forPattern("dd MMM yyyy") .withLocale(Locale.FRANCE).withZoneUTC(); DateTime date = dateFormatter.parseDateTime("23 janvier 2007"); check(date, 2007, 1, 23); } public void testFormatParse_textMonthApr_France() { DateTimeFormatter dateFormatter = DateTimeFormat.forPattern("dd MMM yyyy") .withLocale(Locale.FRANCE).withZoneUTC(); String str = new DateTime(2007, 2, 23, 0, 0, 0, 0, UTC).toString(dateFormatter); assertEquals("23 f\u00E9vr. 2007", str); // e acute DateTime date = dateFormatter.parseDateTime(str); check(date, 2007, 2, 23); } public void testFormatParse_textMonthAtEnd_France() { DateTimeFormatter dateFormatter = DateTimeFormat.forPattern("dd MMM") .withLocale(Locale.FRANCE).withZoneUTC(); String str = new DateTime(2007, 6, 23, 0, 0, 0, 0, UTC).toString(dateFormatter); assertEquals("23 juin", str); DateTime date = dateFormatter.parseDateTime(str); check(date, 2000, 6, 23); } public void testFormatParse_textMonthAtEnd_France_withSpecifiedDefault() { DateTimeFormatter dateFormatter = DateTimeFormat.forPattern("dd MMM") .withLocale(Locale.FRANCE).withZoneUTC().withDefaultYear(1980); String str = new DateTime(2007, 6, 23, 0, 0, 0, 0, UTC).toString(dateFormatter); assertEquals("23 juin", str); DateTime date = dateFormatter.parseDateTime(str); check(date, 1980, 6, 23); } public void testFormatParse_textMonthApr_Korean() { DateTimeFormatter dateFormatter = DateTimeFormat.forPattern("EEEE, d MMMM yyyy HH:mm") .withLocale(Locale.KOREAN).withZoneUTC(); String str = new DateTime(2007, 3, 8, 22, 0, 0, 0, UTC).toString(dateFormatter); DateTime date = dateFormatter.parseDateTime(str); assertEquals(new DateTime(2007, 3, 8, 22, 0, 0, 0, UTC), date); } //----------------------------------------------------------------------- public void testFormatParse_textHalfdayAM_UK() { DateTimeFormatter dateFormatter = new DateTimeFormatterBuilder() .appendLiteral('$') .appendClockhourOfHalfday(2) .appendLiteral('-') .appendHalfdayOfDayText() .appendLiteral('-') .appendYear(4, 4) .toFormatter() .withLocale(Locale.UK).withZoneUTC(); String str = new DateTime(2007, 6, 23, 18, 0, 0, 0, UTC).toString(dateFormatter); assertEquals("$06-PM-2007", str); DateTime date = dateFormatter.parseDateTime(str); check(date, 2007, 1, 1); } public void testFormatParse_textHalfdayAM_France() { DateTimeFormatter dateFormatter = new DateTimeFormatterBuilder() .appendLiteral('$') .appendClockhourOfHalfday(2) .appendLiteral('-') .appendHalfdayOfDayText() .appendLiteral('-') .appendYear(4, 4) .toFormatter() .withLocale(Locale.FRANCE).withZoneUTC(); String str = new DateTime(2007, 6, 23, 18, 0, 0, 0, UTC).toString(dateFormatter); assertEquals("$06-PM-2007", str); DateTime date = dateFormatter.parseDateTime(str); check(date, 2007, 1, 1); } //----------------------------------------------------------------------- public void testFormatParse_textEraAD_UK() { DateTimeFormatter dateFormatter = new DateTimeFormatterBuilder() .appendLiteral('$') .appendEraText() .appendYear(4, 4) .toFormatter() .withLocale(Locale.UK).withZoneUTC(); String str = new DateTime(2007, 6, 23, 0, 0, 0, 0, UTC).toString(dateFormatter); assertEquals("$AD2007", str); DateTime date = dateFormatter.parseDateTime(str); check(date, 2007, 1, 1); } public void testFormatParse_textEraAD_France() { DateTimeFormatter dateFormatter = new DateTimeFormatterBuilder() .appendLiteral('$') .appendEraText() .appendYear(4, 4) .toFormatter() .withLocale(Locale.FRANCE).withZoneUTC(); String str = new DateTime(2007, 6, 23, 0, 0, 0, 0, UTC).toString(dateFormatter); assertEquals("$ap. J.-C.2007", str); DateTime date = dateFormatter.parseDateTime(str); check(date, 2007, 1, 1); } public void testFormatParse_textEraBC_France() { DateTimeFormatter dateFormatter = new DateTimeFormatterBuilder() .appendLiteral('$') .appendEraText() .appendYear(4, 4) .toFormatter() .withLocale(Locale.FRANCE).withZoneUTC(); String str = new DateTime(-1, 6, 23, 0, 0, 0, 0, UTC).toString(dateFormatter); assertEquals("$BC-0001", str); DateTime date = dateFormatter.parseDateTime(str); check(date, -1, 1, 1); } //----------------------------------------------------------------------- public void testFormatParse_textYear_UK() { DateTimeFormatter dateFormatter = new DateTimeFormatterBuilder() .appendLiteral('$') .appendText(DateTimeFieldType.year()) .toFormatter() .withLocale(Locale.UK).withZoneUTC(); String str = new DateTime(2007, 6, 23, 0, 0, 0, 0, UTC).toString(dateFormatter); assertEquals("$2007", str); try { dateFormatter.parseDateTime(str); fail(); } catch (IllegalArgumentException ex) { // expected } } public void testFormatParse_textYear_France() { DateTimeFormatter dateFormatter = new DateTimeFormatterBuilder() .appendLiteral('$') .appendText(DateTimeFieldType.year()) .toFormatter() .withLocale(Locale.FRANCE).withZoneUTC(); String str = new DateTime(2007, 6, 23, 0, 0, 0, 0, UTC).toString(dateFormatter); assertEquals("$2007", str); try { dateFormatter.parseDateTime(str); fail(); } catch (IllegalArgumentException ex) { // expected } } //----------------------------------------------------------------------- public void testFormatParse_textAdjoiningHelloWorld_UK() { DateTimeFormatter dateFormatter = new DateTimeFormatterBuilder() .appendLiteral('$') .appendDayOfMonth(2) .appendMonthOfYearShortText() .appendLiteral("HelloWorld") .toFormatter() .withLocale(Locale.UK).withZoneUTC(); String str = new DateTime(2007, 6, 23, 0, 0, 0, 0, UTC).toString(dateFormatter); assertEquals("$23JunHelloWorld", str); dateFormatter.parseDateTime(str); } public void testFormatParse_textAdjoiningMonthDOW_UK() { DateTimeFormatter dateFormatter = new DateTimeFormatterBuilder() .appendLiteral('$') .appendDayOfMonth(2) .appendMonthOfYearShortText() .appendDayOfWeekShortText() .toFormatter() .withLocale(Locale.UK).withZoneUTC(); String str = new DateTime(2007, 6, 23, 0, 0, 0, 0, UTC).toString(dateFormatter); assertEquals("$23JunSat", str); dateFormatter.parseDateTime(str); } //----------------------------------------------------------------------- public void testFormatParse_zoneId_noColon() { DateTimeFormatter dateFormatter = DateTimeFormat.forPattern("HH:mm Z").withZoneUTC(); String str = new DateTime(2007, 6, 23, 1, 2, 0, 0, UTC).toString(dateFormatter); assertEquals("01:02 +0000", str); DateTime parsed = dateFormatter.parseDateTime(str); assertEquals(1, parsed.getHourOfDay()); assertEquals(2, parsed.getMinuteOfHour()); } public void testFormatParse_zoneId_noColon_parseZ() { DateTimeFormatter dateFormatter = DateTimeFormat.forPattern("HH:mm Z").withZoneUTC(); DateTime parsed = dateFormatter.parseDateTime("01:02 Z"); assertEquals(1, parsed.getHourOfDay()); assertEquals(2, parsed.getMinuteOfHour()); } public void testFormatParse_zoneId_colon() { DateTimeFormatter dateFormatter = DateTimeFormat.forPattern("HH:mm ZZ").withZoneUTC(); String str = new DateTime(2007, 6, 23, 1, 2, 0, 0, UTC).toString(dateFormatter); assertEquals("01:02 +00:00", str); DateTime parsed = dateFormatter.parseDateTime(str); assertEquals(1, parsed.getHourOfDay()); assertEquals(2, parsed.getMinuteOfHour()); } public void testFormatParse_zoneId_colon_parseZ() { DateTimeFormatter dateFormatter = DateTimeFormat.forPattern("HH:mm ZZ").withZoneUTC(); DateTime parsed = dateFormatter.parseDateTime("01:02 Z"); assertEquals(1, parsed.getHourOfDay()); assertEquals(2, parsed.getMinuteOfHour()); } //----------------------------------------------------------------------- private void check(DateTime test, int hour, int min, int sec) { assertEquals(hour, test.getYear()); assertEquals(min, test.getMonthOfYear()); assertEquals(sec, test.getDayOfMonth()); } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.format; import java.text.DateFormat; import java.util.Locale; import java.util.SimpleTimeZone; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.DateTime; import org.joda.time.DateTimeConstants; import org.joda.time.DateTimeUtils; import org.joda.time.DateTimeZone; /** * This class is a Junit unit test for DateTimeFormat styles. * * @author Stephen Colebourne */ public class TestDateTimeFormatStyle extends TestCase { private static final Locale UK = Locale.UK; private static final Locale US = Locale.US; private static final Locale FRANCE = Locale.FRANCE; private static final DateTimeZone UTC = DateTimeZone.UTC; private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo"); private static final DateTimeZone NEWYORK = DateTimeZone.forID("America/New_York"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestDateTimeFormatStyle.class); } public TestDateTimeFormatStyle(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testForStyle_stringLengths() { try { DateTimeFormat.forStyle(null); fail(); } catch (IllegalArgumentException ex) {} try { DateTimeFormat.forStyle(""); fail(); } catch (IllegalArgumentException ex) {} try { DateTimeFormat.forStyle("S"); fail(); } catch (IllegalArgumentException ex) {} try { DateTimeFormat.forStyle("SSS"); fail(); } catch (IllegalArgumentException ex) {} } public void testForStyle_invalidStrings() { try { DateTimeFormat.forStyle("AA"); fail(); } catch (IllegalArgumentException ex) {} try { DateTimeFormat.forStyle("--"); fail(); } catch (IllegalArgumentException ex) {} try { DateTimeFormat.forStyle("ss"); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testForStyle_shortDate() throws Exception { DateTimeFormatter f = DateTimeFormat.shortDate(); DateTimeFormatter g = DateTimeFormat.forStyle("S-"); assertSame(g, f); DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0); String expect = DateFormat.getDateInstance(DateFormat.SHORT, UK).format(dt.toDate()); assertEquals(expect, f.print(dt)); expect = DateFormat.getDateInstance(DateFormat.SHORT, US).format(dt.toDate()); assertEquals(expect, f.withLocale(US).print(dt)); expect = DateFormat.getDateInstance(DateFormat.SHORT, FRANCE).format(dt.toDate()); assertEquals(expect, f.withLocale(FRANCE).print(dt)); DateTime date = new DateTime( DateFormat.getDateInstance(DateFormat.SHORT, FRANCE).parse(expect)); assertEquals(date, f.withLocale(FRANCE).parseDateTime(expect)); } public void testForStyle_shortTime() throws Exception { DateTimeFormatter f = DateTimeFormat.shortTime(); DateTimeFormatter g = DateTimeFormat.forStyle("-S"); assertSame(g, f); DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0); String expect = DateFormat.getTimeInstance(DateFormat.SHORT, UK).format(dt.toDate()); assertEquals(expect, f.print(dt)); expect = DateFormat.getTimeInstance(DateFormat.SHORT, US).format(dt.toDate()); assertEquals(expect, f.withLocale(US).print(dt)); expect = DateFormat.getTimeInstance(DateFormat.SHORT, FRANCE).format(dt.toDate()); assertEquals(expect, f.withLocale(FRANCE).print(dt)); if (TimeZone.getDefault() instanceof SimpleTimeZone) { // skip test, as it needs historical time zone info } else { DateTime date = new DateTime( DateFormat.getTimeInstance(DateFormat.SHORT, FRANCE).parse(expect)); assertEquals(date, f.withLocale(FRANCE).parseDateTime(expect)); } } public void testForStyle_shortDateTime() throws Exception { DateTimeFormatter f = DateTimeFormat.shortDateTime(); DateTimeFormatter g = DateTimeFormat.forStyle("SS"); assertSame(g, f); DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0); String expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, UK).format(dt.toDate()); assertEquals(expect, f.print(dt)); expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, US).format(dt.toDate()); assertEquals(expect, f.withLocale(US).print(dt)); expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, FRANCE).format(dt.toDate()); assertEquals(expect, f.withLocale(FRANCE).print(dt)); DateTime date = new DateTime( DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, FRANCE).parse(expect)); assertEquals(date, f.withLocale(FRANCE).parseDateTime(expect)); } //----------------------------------------------------------------------- public void testForStyle_mediumDate() throws Exception { DateTimeFormatter f = DateTimeFormat.mediumDate(); DateTimeFormatter g = DateTimeFormat.forStyle("M-"); assertSame(g, f); DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0); String expect = DateFormat.getDateInstance(DateFormat.MEDIUM, UK).format(dt.toDate()); assertEquals(expect, f.print(dt)); expect = DateFormat.getDateInstance(DateFormat.MEDIUM, US).format(dt.toDate()); assertEquals(expect, f.withLocale(US).print(dt)); expect = DateFormat.getDateInstance(DateFormat.MEDIUM, FRANCE).format(dt.toDate()); assertEquals(expect, f.withLocale(FRANCE).print(dt)); } public void testForStyle_mediumTime() throws Exception { DateTimeFormatter f = DateTimeFormat.mediumTime(); DateTimeFormatter g = DateTimeFormat.forStyle("-M"); assertSame(g, f); DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0); String expect = DateFormat.getTimeInstance(DateFormat.MEDIUM, UK).format(dt.toDate()); assertEquals(expect, f.print(dt)); expect = DateFormat.getTimeInstance(DateFormat.MEDIUM, US).format(dt.toDate()); assertEquals(expect, f.withLocale(US).print(dt)); expect = DateFormat.getTimeInstance(DateFormat.MEDIUM, FRANCE).format(dt.toDate()); assertEquals(expect, f.withLocale(FRANCE).print(dt)); } public void testForStyle_mediumDateTime() throws Exception { DateTimeFormatter f = DateTimeFormat.mediumDateTime(); DateTimeFormatter g = DateTimeFormat.forStyle("MM"); assertSame(g, f); DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0); String expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM, UK).format(dt.toDate()); assertEquals(expect, f.print(dt)); expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM, US).format(dt.toDate()); assertEquals(expect, f.withLocale(US).print(dt)); expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM, FRANCE).format(dt.toDate()); assertEquals(expect, f.withLocale(FRANCE).print(dt)); } //----------------------------------------------------------------------- public void testForStyle_longDate() throws Exception { DateTimeFormatter f = DateTimeFormat.longDate(); DateTimeFormatter g = DateTimeFormat.forStyle("L-"); assertSame(g, f); DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0); String expect = DateFormat.getDateInstance(DateFormat.LONG, UK).format(dt.toDate()); assertEquals(expect, f.print(dt)); expect = DateFormat.getDateInstance(DateFormat.LONG, US).format(dt.toDate()); assertEquals(expect, f.withLocale(US).print(dt)); expect = DateFormat.getDateInstance(DateFormat.LONG, FRANCE).format(dt.toDate()); assertEquals(expect, f.withLocale(FRANCE).print(dt)); } public void testForStyle_longTime() throws Exception { DateTimeFormatter f = DateTimeFormat.longTime(); DateTimeFormatter g = DateTimeFormat.forStyle("-L"); assertSame(g, f); DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0); String expect = DateFormat.getTimeInstance(DateFormat.LONG, UK).format(dt.toDate()); assertEquals(expect, f.print(dt)); expect = DateFormat.getTimeInstance(DateFormat.LONG, US).format(dt.toDate()); assertEquals(expect, f.withLocale(US).print(dt)); expect = DateFormat.getTimeInstance(DateFormat.LONG, FRANCE).format(dt.toDate()); assertEquals(expect, f.withLocale(FRANCE).print(dt)); } public void testForStyle_longDateTime() throws Exception { DateTimeFormatter f = DateTimeFormat.longDateTime(); DateTimeFormatter g = DateTimeFormat.forStyle("LL"); assertSame(g, f); DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0); String expect = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG, UK).format(dt.toDate()); assertEquals(expect, f.print(dt)); expect = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG, US).format(dt.toDate()); assertEquals(expect, f.withLocale(US).print(dt)); expect = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG, FRANCE).format(dt.toDate()); assertEquals(expect, f.withLocale(FRANCE).print(dt)); } //----------------------------------------------------------------------- public void testForStyle_fullDate() throws Exception { DateTimeFormatter f = DateTimeFormat.fullDate(); DateTimeFormatter g = DateTimeFormat.forStyle("F-"); assertSame(g, f); DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0); String expect = DateFormat.getDateInstance(DateFormat.FULL, UK).format(dt.toDate()); assertEquals(expect, f.print(dt)); expect = DateFormat.getDateInstance(DateFormat.FULL, US).format(dt.toDate()); assertEquals(expect, f.withLocale(US).print(dt)); expect = DateFormat.getDateInstance(DateFormat.FULL, FRANCE).format(dt.toDate()); assertEquals(expect, f.withLocale(FRANCE).print(dt)); } public void testForStyle_fullTime() throws Exception { DateTimeFormatter f = DateTimeFormat.fullTime(); DateTimeFormatter g = DateTimeFormat.forStyle("-F"); assertSame(g, f); DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0); String expect = DateFormat.getTimeInstance(DateFormat.FULL, UK).format(dt.toDate()); assertEquals(expect, f.print(dt)); expect = DateFormat.getTimeInstance(DateFormat.FULL, US).format(dt.toDate()); assertEquals(expect, f.withLocale(US).print(dt)); expect = DateFormat.getTimeInstance(DateFormat.FULL, FRANCE).format(dt.toDate()); assertEquals(expect, f.withLocale(FRANCE).print(dt)); } public void testForStyle_fullDateTime() throws Exception { DateTimeFormatter f = DateTimeFormat.fullDateTime(); DateTimeFormatter g = DateTimeFormat.forStyle("FF"); assertSame(g, f); DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0); String expect = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL, UK).format(dt.toDate()); assertEquals(expect, f.print(dt)); expect = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL, US).format(dt.toDate()); assertEquals(expect, f.withLocale(US).print(dt)); expect = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL, FRANCE).format(dt.toDate()); assertEquals(expect, f.withLocale(FRANCE).print(dt)); } //----------------------------------------------------------------------- public void testForStyle_shortMediumDateTime() throws Exception { DateTimeFormatter f = DateTimeFormat.forStyle("SM"); DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0); String expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.MEDIUM, UK).format(dt.toDate()); assertEquals(expect, f.print(dt)); expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.MEDIUM, US).format(dt.toDate()); assertEquals(expect, f.withLocale(US).print(dt)); expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.MEDIUM, FRANCE).format(dt.toDate()); assertEquals(expect, f.withLocale(FRANCE).print(dt)); } public void testForStyle_shortLongDateTime() throws Exception { DateTimeFormatter f = DateTimeFormat.forStyle("SL"); DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0); String expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.LONG, UK).format(dt.toDate()); assertEquals(expect, f.print(dt)); expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.LONG, US).format(dt.toDate()); assertEquals(expect, f.withLocale(US).print(dt)); expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.LONG, FRANCE).format(dt.toDate()); assertEquals(expect, f.withLocale(FRANCE).print(dt)); } public void testForStyle_shortFullDateTime() throws Exception { DateTimeFormatter f = DateTimeFormat.forStyle("SF"); DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0); String expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.FULL, UK).format(dt.toDate()); assertEquals(expect, f.print(dt)); expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.FULL, US).format(dt.toDate()); assertEquals(expect, f.withLocale(US).print(dt)); expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.FULL, FRANCE).format(dt.toDate()); assertEquals(expect, f.withLocale(FRANCE).print(dt)); } //----------------------------------------------------------------------- public void testForStyle_mediumShortDateTime() throws Exception { DateTimeFormatter f = DateTimeFormat.forStyle("MS"); DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0); String expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.SHORT, UK).format(dt.toDate()); assertEquals(expect, f.print(dt)); expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.SHORT, US).format(dt.toDate()); assertEquals(expect, f.withLocale(US).print(dt)); expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.SHORT, FRANCE).format(dt.toDate()); assertEquals(expect, f.withLocale(FRANCE).print(dt)); } public void testForStyle_mediumLongDateTime() throws Exception { DateTimeFormatter f = DateTimeFormat.forStyle("ML"); DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0); String expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.LONG, UK).format(dt.toDate()); assertEquals(expect, f.print(dt)); expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.LONG, US).format(dt.toDate()); assertEquals(expect, f.withLocale(US).print(dt)); expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.LONG, FRANCE).format(dt.toDate()); assertEquals(expect, f.withLocale(FRANCE).print(dt)); } public void testForStyle_mediumFullDateTime() throws Exception { DateTimeFormatter f = DateTimeFormat.forStyle("MF"); DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0); String expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.FULL, UK).format(dt.toDate()); assertEquals(expect, f.print(dt)); expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.FULL, US).format(dt.toDate()); assertEquals(expect, f.withLocale(US).print(dt)); expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.FULL, FRANCE).format(dt.toDate()); assertEquals(expect, f.withLocale(FRANCE).print(dt)); } }
/* * Copyright 2001-2011 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.format; import java.io.CharArrayWriter; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.Chronology; import org.joda.time.DateTime; import org.joda.time.DateTimeConstants; import org.joda.time.DateTimeUtils; import org.joda.time.DateTimeZone; import org.joda.time.LocalDate; import org.joda.time.LocalDateTime; import org.joda.time.LocalTime; import org.joda.time.MutableDateTime; import org.joda.time.ReadablePartial; import org.joda.time.chrono.BuddhistChronology; import org.joda.time.chrono.GJChronology; import org.joda.time.chrono.ISOChronology; /** * This class is a Junit unit test for DateTime Formating. * * @author Stephen Colebourne */ public class TestDateTimeFormatter extends TestCase { private static final DateTimeZone UTC = DateTimeZone.UTC; private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo"); private static final DateTimeZone NEWYORK = DateTimeZone.forID("America/New_York"); private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC(); private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS); private static final Chronology BUDDHIST_PARIS = BuddhistChronology.getInstance(PARIS); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; private DateTimeFormatter f = null; private DateTimeFormatter g = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestDateTimeFormatter.class); } public TestDateTimeFormatter(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); f = new DateTimeFormatterBuilder() .appendDayOfWeekShortText() .appendLiteral(' ') .append(ISODateTimeFormat.dateTimeNoMillis()) .toFormatter(); g = ISODateTimeFormat.dateTimeNoMillis(); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; f = null; g = null; } //----------------------------------------------------------------------- public void testPrint_simple() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("Wed 2004-06-09T10:20:30Z", f.print(dt)); dt = dt.withZone(PARIS); assertEquals("Wed 2004-06-09T12:20:30+02:00", f.print(dt)); dt = dt.withZone(NEWYORK); assertEquals("Wed 2004-06-09T06:20:30-04:00", f.print(dt)); dt = dt.withChronology(BUDDHIST_PARIS); assertEquals("Wed 2547-06-09T12:20:30+02:00", f.print(dt)); } //----------------------------------------------------------------------- public void testPrint_locale() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("mer. 2004-06-09T10:20:30Z", f.withLocale(Locale.FRENCH).print(dt)); assertEquals("Wed 2004-06-09T10:20:30Z", f.withLocale(null).print(dt)); } //----------------------------------------------------------------------- public void testPrint_zone() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("Wed 2004-06-09T06:20:30-04:00", f.withZone(NEWYORK).print(dt)); assertEquals("Wed 2004-06-09T12:20:30+02:00", f.withZone(PARIS).print(dt)); assertEquals("Wed 2004-06-09T10:20:30Z", f.withZone(null).print(dt)); dt = dt.withZone(NEWYORK); assertEquals("Wed 2004-06-09T06:20:30-04:00", f.withZone(NEWYORK).print(dt)); assertEquals("Wed 2004-06-09T12:20:30+02:00", f.withZone(PARIS).print(dt)); assertEquals("Wed 2004-06-09T10:20:30Z", f.withZoneUTC().print(dt)); assertEquals("Wed 2004-06-09T06:20:30-04:00", f.withZone(null).print(dt)); } //----------------------------------------------------------------------- public void testPrint_chrono() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("Wed 2004-06-09T12:20:30+02:00", f.withChronology(ISO_PARIS).print(dt)); assertEquals("Wed 2547-06-09T12:20:30+02:00", f.withChronology(BUDDHIST_PARIS).print(dt)); assertEquals("Wed 2004-06-09T10:20:30Z", f.withChronology(null).print(dt)); dt = dt.withChronology(BUDDHIST_PARIS); assertEquals("Wed 2004-06-09T12:20:30+02:00", f.withChronology(ISO_PARIS).print(dt)); assertEquals("Wed 2547-06-09T12:20:30+02:00", f.withChronology(BUDDHIST_PARIS).print(dt)); assertEquals("Wed 2004-06-09T10:20:30Z", f.withChronology(ISO_UTC).print(dt)); assertEquals("Wed 2547-06-09T12:20:30+02:00", f.withChronology(null).print(dt)); } //----------------------------------------------------------------------- public void testPrint_bufferMethods() throws Exception { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); StringBuffer buf = new StringBuffer(); f.printTo(buf, dt); assertEquals("Wed 2004-06-09T10:20:30Z", buf.toString()); buf = new StringBuffer(); f.printTo(buf, dt.getMillis()); assertEquals("Wed 2004-06-09T11:20:30+01:00", buf.toString()); buf = new StringBuffer(); ISODateTimeFormat.yearMonthDay().printTo(buf, dt.toYearMonthDay()); assertEquals("2004-06-09", buf.toString()); buf = new StringBuffer(); try { ISODateTimeFormat.yearMonthDay().printTo(buf, (ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testPrint_writerMethods() throws Exception { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); CharArrayWriter out = new CharArrayWriter(); f.printTo(out, dt); assertEquals("Wed 2004-06-09T10:20:30Z", out.toString()); out = new CharArrayWriter(); f.printTo(out, dt.getMillis()); assertEquals("Wed 2004-06-09T11:20:30+01:00", out.toString()); out = new CharArrayWriter(); ISODateTimeFormat.yearMonthDay().printTo(out, dt.toYearMonthDay()); assertEquals("2004-06-09", out.toString()); out = new CharArrayWriter(); try { ISODateTimeFormat.yearMonthDay().printTo(out, (ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testPrint_appendableMethods() throws Exception { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); StringBuilder buf = new StringBuilder(); f.printTo(buf, dt); assertEquals("Wed 2004-06-09T10:20:30Z", buf.toString()); buf = new StringBuilder(); f.printTo(buf, dt.getMillis()); assertEquals("Wed 2004-06-09T11:20:30+01:00", buf.toString()); buf = new StringBuilder(); ISODateTimeFormat.yearMonthDay().printTo(buf, dt.toLocalDate()); assertEquals("2004-06-09", buf.toString()); buf = new StringBuilder(); try { ISODateTimeFormat.yearMonthDay().printTo(buf, (ReadablePartial) null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testPrint_chrono_and_zone() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("Wed 2004-06-09T10:20:30Z", f.withChronology(null).withZone(null).print(dt)); assertEquals("Wed 2004-06-09T12:20:30+02:00", f.withChronology(ISO_PARIS).withZone(null).print(dt)); assertEquals("Wed 2004-06-09T12:20:30+02:00", f.withChronology(ISO_PARIS).withZone(PARIS).print(dt)); assertEquals("Wed 2004-06-09T06:20:30-04:00", f.withChronology(ISO_PARIS).withZone(NEWYORK).print(dt)); assertEquals("Wed 2004-06-09T06:20:30-04:00", f.withChronology(null).withZone(NEWYORK).print(dt)); dt = dt.withChronology(ISO_PARIS); assertEquals("Wed 2004-06-09T12:20:30+02:00", f.withChronology(null).withZone(null).print(dt)); assertEquals("Wed 2004-06-09T12:20:30+02:00", f.withChronology(ISO_PARIS).withZone(null).print(dt)); assertEquals("Wed 2004-06-09T12:20:30+02:00", f.withChronology(ISO_PARIS).withZone(PARIS).print(dt)); assertEquals("Wed 2004-06-09T06:20:30-04:00", f.withChronology(ISO_PARIS).withZone(NEWYORK).print(dt)); assertEquals("Wed 2004-06-09T06:20:30-04:00", f.withChronology(null).withZone(NEWYORK).print(dt)); dt = dt.withChronology(BUDDHIST_PARIS); assertEquals("Wed 2547-06-09T12:20:30+02:00", f.withChronology(null).withZone(null).print(dt)); assertEquals("Wed 2004-06-09T12:20:30+02:00", f.withChronology(ISO_PARIS).withZone(null).print(dt)); assertEquals("Wed 2004-06-09T12:20:30+02:00", f.withChronology(ISO_PARIS).withZone(PARIS).print(dt)); assertEquals("Wed 2004-06-09T06:20:30-04:00", f.withChronology(ISO_PARIS).withZone(NEWYORK).print(dt)); assertEquals("Wed 2547-06-09T06:20:30-04:00", f.withChronology(null).withZone(NEWYORK).print(dt)); } public void testWithGetLocale() { DateTimeFormatter f2 = f.withLocale(Locale.FRENCH); assertEquals(Locale.FRENCH, f2.getLocale()); assertSame(f2, f2.withLocale(Locale.FRENCH)); f2 = f.withLocale(null); assertEquals(null, f2.getLocale()); assertSame(f2, f2.withLocale(null)); } public void testWithGetZone() { DateTimeFormatter f2 = f.withZone(PARIS); assertEquals(PARIS, f2.getZone()); assertSame(f2, f2.withZone(PARIS)); f2 = f.withZone(null); assertEquals(null, f2.getZone()); assertSame(f2, f2.withZone(null)); } public void testWithGetChronology() { DateTimeFormatter f2 = f.withChronology(BUDDHIST_PARIS); assertEquals(BUDDHIST_PARIS, f2.getChronology()); assertSame(f2, f2.withChronology(BUDDHIST_PARIS)); f2 = f.withChronology(null); assertEquals(null, f2.getChronology()); assertSame(f2, f2.withChronology(null)); } public void testWithGetPivotYear() { DateTimeFormatter f2 = f.withPivotYear(13); assertEquals(new Integer(13), f2.getPivotYear()); assertSame(f2, f2.withPivotYear(13)); f2 = f.withPivotYear(new Integer(14)); assertEquals(new Integer(14), f2.getPivotYear()); assertSame(f2, f2.withPivotYear(new Integer(14))); f2 = f.withPivotYear(null); assertEquals(null, f2.getPivotYear()); assertSame(f2, f2.withPivotYear(null)); } public void testWithGetOffsetParsedMethods() { DateTimeFormatter f2 = f; assertEquals(false, f2.isOffsetParsed()); assertEquals(null, f2.getZone()); f2 = f.withOffsetParsed(); assertEquals(true, f2.isOffsetParsed()); assertEquals(null, f2.getZone()); f2 = f2.withZone(PARIS); assertEquals(false, f2.isOffsetParsed()); assertEquals(PARIS, f2.getZone()); f2 = f2.withOffsetParsed(); assertEquals(true, f2.isOffsetParsed()); assertEquals(null, f2.getZone()); f2 = f.withOffsetParsed(); assertNotSame(f, f2); DateTimeFormatter f3 = f2.withOffsetParsed(); assertSame(f2, f3); } public void testPrinterParserMethods() { DateTimeFormatter f2 = new DateTimeFormatter(f.getPrinter(), f.getParser()); assertEquals(f.getPrinter(), f2.getPrinter()); assertEquals(f.getParser(), f2.getParser()); assertEquals(true, f2.isPrinter()); assertEquals(true, f2.isParser()); assertNotNull(f2.print(0L)); assertNotNull(f2.parseDateTime("Thu 1970-01-01T00:00:00Z")); f2 = new DateTimeFormatter(f.getPrinter(), null); assertEquals(f.getPrinter(), f2.getPrinter()); assertEquals(null, f2.getParser()); assertEquals(true, f2.isPrinter()); assertEquals(false, f2.isParser()); assertNotNull(f2.print(0L)); try { f2.parseDateTime("Thu 1970-01-01T00:00:00Z"); fail(); } catch (UnsupportedOperationException ex) {} f2 = new DateTimeFormatter(null, f.getParser()); assertEquals(null, f2.getPrinter()); assertEquals(f.getParser(), f2.getParser()); assertEquals(false, f2.isPrinter()); assertEquals(true, f2.isParser()); try { f2.print(0L); fail(); } catch (UnsupportedOperationException ex) {} assertNotNull(f2.parseDateTime("Thu 1970-01-01T00:00:00Z")); } //----------------------------------------------------------------------- public void testParseLocalDate_simple() { assertEquals(new LocalDate(2004, 6, 9), g.parseLocalDate("2004-06-09T10:20:30Z")); assertEquals(new LocalDate(2004, 6, 9), g.parseLocalDate("2004-06-09T10:20:30+18:00")); assertEquals(new LocalDate(2004, 6, 9), g.parseLocalDate("2004-06-09T10:20:30-18:00")); assertEquals(new LocalDate(2004, 6, 9, BUDDHIST_PARIS), g.withChronology(BUDDHIST_PARIS).parseLocalDate("2004-06-09T10:20:30Z")); try { g.parseDateTime("ABC"); fail(); } catch (IllegalArgumentException ex) {} } public void testParseLocalDate_yearOfEra() { Chronology chrono = GJChronology.getInstanceUTC(); DateTimeFormatter f = DateTimeFormat .forPattern("YYYY-MM GG") .withChronology(chrono) .withLocale(Locale.UK); LocalDate date = new LocalDate(2005, 10, 1, chrono); assertEquals(date, f.parseLocalDate("2005-10 AD")); assertEquals(date, f.parseLocalDate("2005-10 CE")); date = new LocalDate(-2005, 10, 1, chrono); assertEquals(date, f.parseLocalDate("2005-10 BC")); assertEquals(date, f.parseLocalDate("2005-10 BCE")); } public void testParseLocalDate_yearOfCentury() { Chronology chrono = GJChronology.getInstanceUTC(); DateTimeFormatter f = DateTimeFormat .forPattern("yy M d") .withChronology(chrono) .withLocale(Locale.UK) .withPivotYear(2050); LocalDate date = new LocalDate(2050, 8, 4, chrono); assertEquals(date, f.parseLocalDate("50 8 4")); } public void testParseLocalDate_monthDay_feb29() { Chronology chrono = GJChronology.getInstanceUTC(); DateTimeFormatter f = DateTimeFormat .forPattern("M d") .withChronology(chrono) .withLocale(Locale.UK); assertEquals(new LocalDate(2000, 2, 29, chrono), f.parseLocalDate("2 29")); } public void testParseLocalDate_monthDay_withDefaultYear_feb29() { Chronology chrono = GJChronology.getInstanceUTC(); DateTimeFormatter f = DateTimeFormat .forPattern("M d") .withChronology(chrono) .withLocale(Locale.UK) .withDefaultYear(2012); assertEquals(new LocalDate(2012, 2, 29, chrono), f.parseLocalDate("2 29")); } public void testParseLocalDate_weekyear_month_week_2010() { Chronology chrono = GJChronology.getInstanceUTC(); DateTimeFormatter f = DateTimeFormat.forPattern("xxxx-MM-ww").withChronology(chrono); assertEquals(new LocalDate(2010, 1, 4, chrono), f.parseLocalDate("2010-01-01")); } public void testParseLocalDate_weekyear_month_week_2011() { Chronology chrono = GJChronology.getInstanceUTC(); DateTimeFormatter f = DateTimeFormat.forPattern("xxxx-MM-ww").withChronology(chrono); assertEquals(new LocalDate(2011, 1, 3, chrono), f.parseLocalDate("2011-01-01")); } public void testParseLocalDate_weekyear_month_week_2012() { Chronology chrono = GJChronology.getInstanceUTC(); DateTimeFormatter f = DateTimeFormat.forPattern("xxxx-MM-ww").withChronology(chrono); assertEquals(new LocalDate(2012, 1, 2, chrono), f.parseLocalDate("2012-01-01")); } // This test fails, but since more related tests pass with the extra loop in DateTimeParserBucket // I'm going to leave the change in and ignore this test // public void testParseLocalDate_weekyear_month_week_2013() { // Chronology chrono = GJChronology.getInstanceUTC(); // DateTimeFormatter f = DateTimeFormat.forPattern("xxxx-MM-ww").withChronology(chrono); // assertEquals(new LocalDate(2012, 12, 31, chrono), f.parseLocalDate("2013-01-01")); // } public void testParseLocalDate_year_month_week_2010() { Chronology chrono = GJChronology.getInstanceUTC(); DateTimeFormatter f = DateTimeFormat.forPattern("yyyy-MM-ww").withChronology(chrono); assertEquals(new LocalDate(2010, 1, 4, chrono), f.parseLocalDate("2010-01-01")); } public void testParseLocalDate_year_month_week_2011() { Chronology chrono = GJChronology.getInstanceUTC(); DateTimeFormatter f = DateTimeFormat.forPattern("yyyy-MM-ww").withChronology(chrono); assertEquals(new LocalDate(2011, 1, 3, chrono), f.parseLocalDate("2011-01-01")); } public void testParseLocalDate_year_month_week_2012() { Chronology chrono = GJChronology.getInstanceUTC(); DateTimeFormatter f = DateTimeFormat.forPattern("yyyy-MM-ww").withChronology(chrono); assertEquals(new LocalDate(2012, 1, 2, chrono), f.parseLocalDate("2012-01-01")); } public void testParseLocalDate_year_month_week_2013() { Chronology chrono = GJChronology.getInstanceUTC(); DateTimeFormatter f = DateTimeFormat.forPattern("yyyy-MM-ww").withChronology(chrono); assertEquals(new LocalDate(2012, 12, 31, chrono), f.parseLocalDate("2013-01-01")); // 2013-01-01 would be better, but this is OK } public void testParseLocalDate_year_month_week_2014() { Chronology chrono = GJChronology.getInstanceUTC(); DateTimeFormatter f = DateTimeFormat.forPattern("yyyy-MM-ww").withChronology(chrono); assertEquals(new LocalDate(2013, 12, 30, chrono), f.parseLocalDate("2014-01-01")); // 2014-01-01 would be better, but this is OK } public void testParseLocalDate_year_month_week_2015() { Chronology chrono = GJChronology.getInstanceUTC(); DateTimeFormatter f = DateTimeFormat.forPattern("yyyy-MM-ww").withChronology(chrono); assertEquals(new LocalDate(2014, 12, 29, chrono), f.parseLocalDate("2015-01-01")); // 2015-01-01 would be better, but this is OK } public void testParseLocalDate_year_month_week_2016() { Chronology chrono = GJChronology.getInstanceUTC(); DateTimeFormatter f = DateTimeFormat.forPattern("yyyy-MM-ww").withChronology(chrono); assertEquals(new LocalDate(2016, 1, 4, chrono), f.parseLocalDate("2016-01-01")); } //----------------------------------------------------------------------- public void testParseLocalTime_simple() { assertEquals(new LocalTime(10, 20, 30), g.parseLocalTime("2004-06-09T10:20:30Z")); assertEquals(new LocalTime(10, 20, 30), g.parseLocalTime("2004-06-09T10:20:30+18:00")); assertEquals(new LocalTime(10, 20, 30), g.parseLocalTime("2004-06-09T10:20:30-18:00")); assertEquals(new LocalTime(10, 20, 30, 0, BUDDHIST_PARIS), g.withChronology(BUDDHIST_PARIS).parseLocalTime("2004-06-09T10:20:30Z")); try { g.parseDateTime("ABC"); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testParseLocalDateTime_simple() { assertEquals(new LocalDateTime(2004, 6, 9, 10, 20, 30), g.parseLocalDateTime("2004-06-09T10:20:30Z")); assertEquals(new LocalDateTime(2004, 6, 9, 10, 20, 30), g.parseLocalDateTime("2004-06-09T10:20:30+18:00")); assertEquals(new LocalDateTime(2004, 6, 9, 10, 20, 30), g.parseLocalDateTime("2004-06-09T10:20:30-18:00")); assertEquals(new LocalDateTime(2004, 6, 9, 10, 20, 30, 0, BUDDHIST_PARIS), g.withChronology(BUDDHIST_PARIS).parseLocalDateTime("2004-06-09T10:20:30Z")); try { g.parseDateTime("ABC"); fail(); } catch (IllegalArgumentException ex) {} } public void testParseLocalDateTime_monthDay_feb29() { Chronology chrono = GJChronology.getInstanceUTC(); DateTimeFormatter f = DateTimeFormat .forPattern("M d H m") .withChronology(chrono) .withLocale(Locale.UK); assertEquals(new LocalDateTime(2000, 2, 29, 13, 40, 0, 0, chrono), f.parseLocalDateTime("2 29 13 40")); } public void testParseLocalDateTime_monthDay_withDefaultYear_feb29() { Chronology chrono = GJChronology.getInstanceUTC(); DateTimeFormatter f = DateTimeFormat .forPattern("M d H m") .withChronology(chrono) .withLocale(Locale.UK) .withDefaultYear(2012); assertEquals(new LocalDateTime(2012, 2, 29, 13, 40, 0, 0, chrono), f.parseLocalDateTime("2 29 13 40")); } //----------------------------------------------------------------------- public void testParseDateTime_simple() { DateTime expect = null; expect = new DateTime(2004, 6, 9, 11, 20, 30, 0, LONDON); assertEquals(expect, g.parseDateTime("2004-06-09T10:20:30Z")); try { g.parseDateTime("ABC"); fail(); } catch (IllegalArgumentException ex) {} } public void testParseDateTime_zone() { DateTime expect = null; expect = new DateTime(2004, 6, 9, 11, 20, 30, 0, LONDON); assertEquals(expect, g.withZone(LONDON).parseDateTime("2004-06-09T10:20:30Z")); expect = new DateTime(2004, 6, 9, 11, 20, 30, 0, LONDON); assertEquals(expect, g.withZone(null).parseDateTime("2004-06-09T10:20:30Z")); expect = new DateTime(2004, 6, 9, 12, 20, 30, 0, PARIS); assertEquals(expect, g.withZone(PARIS).parseDateTime("2004-06-09T10:20:30Z")); } public void testParseDateTime_zone2() { DateTime expect = null; expect = new DateTime(2004, 6, 9, 11, 20, 30, 0, LONDON); assertEquals(expect, g.withZone(LONDON).parseDateTime("2004-06-09T06:20:30-04:00")); expect = new DateTime(2004, 6, 9, 11, 20, 30, 0, LONDON); assertEquals(expect, g.withZone(null).parseDateTime("2004-06-09T06:20:30-04:00")); expect = new DateTime(2004, 6, 9, 12, 20, 30, 0, PARIS); assertEquals(expect, g.withZone(PARIS).parseDateTime("2004-06-09T06:20:30-04:00")); } public void testParseDateTime_zone3() { DateTimeFormatter h = new DateTimeFormatterBuilder() .append(ISODateTimeFormat.date()) .appendLiteral('T') .append(ISODateTimeFormat.timeElementParser()) .toFormatter(); DateTime expect = null; expect = new DateTime(2004, 6, 9, 10, 20, 30, 0, LONDON); assertEquals(expect, h.withZone(LONDON).parseDateTime("2004-06-09T10:20:30")); expect = new DateTime(2004, 6, 9, 10, 20, 30, 0, LONDON); assertEquals(expect, h.withZone(null).parseDateTime("2004-06-09T10:20:30")); expect = new DateTime(2004, 6, 9, 10, 20, 30, 0, PARIS); assertEquals(expect, h.withZone(PARIS).parseDateTime("2004-06-09T10:20:30")); } public void testParseDateTime_simple_precedence() { DateTime expect = null; // use correct day of week expect = new DateTime(2004, 6, 9, 11, 20, 30, 0, LONDON); assertEquals(expect, f.parseDateTime("Wed 2004-06-09T10:20:30Z")); // use wrong day of week expect = new DateTime(2004, 6, 7, 11, 20, 30, 0, LONDON); // DayOfWeek takes precedence, because week < month in length assertEquals(expect, f.parseDateTime("Mon 2004-06-09T10:20:30Z")); } public void testParseDateTime_offsetParsed() { DateTime expect = null; expect = new DateTime(2004, 6, 9, 10, 20, 30, 0, UTC); assertEquals(expect, g.withOffsetParsed().parseDateTime("2004-06-09T10:20:30Z")); expect = new DateTime(2004, 6, 9, 6, 20, 30, 0, DateTimeZone.forOffsetHours(-4)); assertEquals(expect, g.withOffsetParsed().parseDateTime("2004-06-09T06:20:30-04:00")); expect = new DateTime(2004, 6, 9, 10, 20, 30, 0, UTC); assertEquals(expect, g.withZone(PARIS).withOffsetParsed().parseDateTime("2004-06-09T10:20:30Z")); expect = new DateTime(2004, 6, 9, 12, 20, 30, 0, PARIS); assertEquals(expect, g.withOffsetParsed().withZone(PARIS).parseDateTime("2004-06-09T10:20:30Z")); } public void testParseDateTime_chrono() { DateTime expect = null; expect = new DateTime(2004, 6, 9, 12, 20, 30, 0, PARIS); assertEquals(expect, g.withChronology(ISO_PARIS).parseDateTime("2004-06-09T10:20:30Z")); expect = new DateTime(2004, 6, 9, 11, 20, 30, 0,LONDON); assertEquals(expect, g.withChronology(null).parseDateTime("2004-06-09T10:20:30Z")); expect = new DateTime(2547, 6, 9, 12, 20, 30, 0, BUDDHIST_PARIS); assertEquals(expect, g.withChronology(BUDDHIST_PARIS).parseDateTime("2547-06-09T10:20:30Z")); expect = new DateTime(2004, 6, 9, 10, 29, 51, 0, BUDDHIST_PARIS); // zone is +00:09:21 in 1451 assertEquals(expect, g.withChronology(BUDDHIST_PARIS).parseDateTime("2004-06-09T10:20:30Z")); } //----------------------------------------------------------------------- public void testParseMutableDateTime_simple() { MutableDateTime expect = null; expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON); assertEquals(expect, g.parseMutableDateTime("2004-06-09T10:20:30Z")); try { g.parseMutableDateTime("ABC"); fail(); } catch (IllegalArgumentException ex) {} } public void testParseMutableDateTime_zone() { MutableDateTime expect = null; expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON); assertEquals(expect, g.withZone(LONDON).parseMutableDateTime("2004-06-09T10:20:30Z")); expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON); assertEquals(expect, g.withZone(null).parseMutableDateTime("2004-06-09T10:20:30Z")); expect = new MutableDateTime(2004, 6, 9, 12, 20, 30, 0, PARIS); assertEquals(expect, g.withZone(PARIS).parseMutableDateTime("2004-06-09T10:20:30Z")); } public void testParseMutableDateTime_zone2() { MutableDateTime expect = null; expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON); assertEquals(expect, g.withZone(LONDON).parseMutableDateTime("2004-06-09T06:20:30-04:00")); expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON); assertEquals(expect, g.withZone(null).parseMutableDateTime("2004-06-09T06:20:30-04:00")); expect = new MutableDateTime(2004, 6, 9, 12, 20, 30, 0, PARIS); assertEquals(expect, g.withZone(PARIS).parseMutableDateTime("2004-06-09T06:20:30-04:00")); } public void testParseMutableDateTime_zone3() { DateTimeFormatter h = new DateTimeFormatterBuilder() .append(ISODateTimeFormat.date()) .appendLiteral('T') .append(ISODateTimeFormat.timeElementParser()) .toFormatter(); MutableDateTime expect = null; expect = new MutableDateTime(2004, 6, 9, 10, 20, 30, 0, LONDON); assertEquals(expect, h.withZone(LONDON).parseMutableDateTime("2004-06-09T10:20:30")); expect = new MutableDateTime(2004, 6, 9, 10, 20, 30, 0, LONDON); assertEquals(expect, h.withZone(null).parseMutableDateTime("2004-06-09T10:20:30")); expect = new MutableDateTime(2004, 6, 9, 10, 20, 30, 0, PARIS); assertEquals(expect, h.withZone(PARIS).parseMutableDateTime("2004-06-09T10:20:30")); } public void testParseMutableDateTime_simple_precedence() { MutableDateTime expect = null; // use correct day of week expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON); assertEquals(expect, f.parseDateTime("Wed 2004-06-09T10:20:30Z")); // use wrong day of week expect = new MutableDateTime(2004, 6, 7, 11, 20, 30, 0, LONDON); // DayOfWeek takes precedence, because week < month in length assertEquals(expect, f.parseDateTime("Mon 2004-06-09T10:20:30Z")); } public void testParseMutableDateTime_offsetParsed() { MutableDateTime expect = null; expect = new MutableDateTime(2004, 6, 9, 10, 20, 30, 0, UTC); assertEquals(expect, g.withOffsetParsed().parseMutableDateTime("2004-06-09T10:20:30Z")); expect = new MutableDateTime(2004, 6, 9, 6, 20, 30, 0, DateTimeZone.forOffsetHours(-4)); assertEquals(expect, g.withOffsetParsed().parseMutableDateTime("2004-06-09T06:20:30-04:00")); expect = new MutableDateTime(2004, 6, 9, 10, 20, 30, 0, UTC); assertEquals(expect, g.withZone(PARIS).withOffsetParsed().parseMutableDateTime("2004-06-09T10:20:30Z")); expect = new MutableDateTime(2004, 6, 9, 12, 20, 30, 0, PARIS); assertEquals(expect, g.withOffsetParsed().withZone(PARIS).parseMutableDateTime("2004-06-09T10:20:30Z")); } public void testParseMutableDateTime_chrono() { MutableDateTime expect = null; expect = new MutableDateTime(2004, 6, 9, 12, 20, 30, 0, PARIS); assertEquals(expect, g.withChronology(ISO_PARIS).parseMutableDateTime("2004-06-09T10:20:30Z")); expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0,LONDON); assertEquals(expect, g.withChronology(null).parseMutableDateTime("2004-06-09T10:20:30Z")); expect = new MutableDateTime(2547, 6, 9, 12, 20, 30, 0, BUDDHIST_PARIS); assertEquals(expect, g.withChronology(BUDDHIST_PARIS).parseMutableDateTime("2547-06-09T10:20:30Z")); expect = new MutableDateTime(2004, 6, 9, 10, 29, 51, 0, BUDDHIST_PARIS); // zone is +00:09:21 in 1451 assertEquals(expect, g.withChronology(BUDDHIST_PARIS).parseMutableDateTime("2004-06-09T10:20:30Z")); } //----------------------------------------------------------------------- public void testParseInto_simple() { MutableDateTime expect = null; expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON); MutableDateTime result = new MutableDateTime(0L); assertEquals(20, g.parseInto(result, "2004-06-09T10:20:30Z", 0)); assertEquals(expect, result); try { g.parseInto(null, "2004-06-09T10:20:30Z", 0); fail(); } catch (IllegalArgumentException ex) {} assertEquals(~0, g.parseInto(result, "ABC", 0)); assertEquals(~10, g.parseInto(result, "2004-06-09", 0)); assertEquals(~13, g.parseInto(result, "XX2004-06-09T", 2)); } public void testParseInto_zone() { MutableDateTime expect = null; MutableDateTime result = null; expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON); result = new MutableDateTime(0L); assertEquals(20, g.withZone(LONDON).parseInto(result, "2004-06-09T10:20:30Z", 0)); assertEquals(expect, result); expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON); result = new MutableDateTime(0L); assertEquals(20, g.withZone(null).parseInto(result, "2004-06-09T10:20:30Z", 0)); assertEquals(expect, result); expect = new MutableDateTime(2004, 6, 9, 12, 20, 30, 0, PARIS); result = new MutableDateTime(0L); assertEquals(20, g.withZone(PARIS).parseInto(result, "2004-06-09T10:20:30Z", 0)); assertEquals(expect, result); } public void testParseInto_zone2() { MutableDateTime expect = null; MutableDateTime result = null; expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON); result = new MutableDateTime(0L); assertEquals(25, g.withZone(LONDON).parseInto(result, "2004-06-09T06:20:30-04:00", 0)); assertEquals(expect, result); expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON); assertEquals(25, g.withZone(null).parseInto(result, "2004-06-09T06:20:30-04:00", 0)); assertEquals(expect, result); expect = new MutableDateTime(2004, 6, 9, 12, 20, 30, 0, PARIS); assertEquals(25, g.withZone(PARIS).parseInto(result, "2004-06-09T06:20:30-04:00", 0)); assertEquals(expect, result); } public void testParseInto_zone3() { DateTimeFormatter h = new DateTimeFormatterBuilder() .append(ISODateTimeFormat.date()) .appendLiteral('T') .append(ISODateTimeFormat.timeElementParser()) .toFormatter(); MutableDateTime expect = null; MutableDateTime result = null; expect = new MutableDateTime(2004, 6, 9, 10, 20, 30, 0, LONDON); result = new MutableDateTime(0L); assertEquals(19, h.withZone(LONDON).parseInto(result, "2004-06-09T10:20:30", 0)); assertEquals(expect, result); expect = new MutableDateTime(2004, 6, 9, 10, 20, 30, 0, LONDON); result = new MutableDateTime(0L); assertEquals(19, h.withZone(null).parseInto(result, "2004-06-09T10:20:30", 0)); assertEquals(expect, result); expect = new MutableDateTime(2004, 6, 9, 10, 20, 30, 0, PARIS); result = new MutableDateTime(0L); assertEquals(19, h.withZone(PARIS).parseInto(result, "2004-06-09T10:20:30", 0)); assertEquals(expect, result); } public void testParseInto_simple_precedence() { MutableDateTime expect = null; MutableDateTime result = null; expect = new MutableDateTime(2004, 6, 7, 11, 20, 30, 0, LONDON); result = new MutableDateTime(0L); // DayOfWeek takes precedence, because week < month in length assertEquals(24, f.parseInto(result, "Mon 2004-06-09T10:20:30Z", 0)); assertEquals(expect, result); } public void testParseInto_offsetParsed() { MutableDateTime expect = null; MutableDateTime result = null; expect = new MutableDateTime(2004, 6, 9, 10, 20, 30, 0, UTC); result = new MutableDateTime(0L); assertEquals(20, g.withOffsetParsed().parseInto(result, "2004-06-09T10:20:30Z", 0)); assertEquals(expect, result); expect = new MutableDateTime(2004, 6, 9, 6, 20, 30, 0, DateTimeZone.forOffsetHours(-4)); result = new MutableDateTime(0L); assertEquals(25, g.withOffsetParsed().parseInto(result, "2004-06-09T06:20:30-04:00", 0)); assertEquals(expect, result); expect = new MutableDateTime(2004, 6, 9, 10, 20, 30, 0, UTC); result = new MutableDateTime(0L); assertEquals(20, g.withZone(PARIS).withOffsetParsed().parseInto(result, "2004-06-09T10:20:30Z", 0)); assertEquals(expect, result); expect = new MutableDateTime(2004, 6, 9, 12, 20, 30, 0, PARIS); result = new MutableDateTime(0L); assertEquals(20, g.withOffsetParsed().withZone(PARIS).parseInto(result, "2004-06-09T10:20:30Z", 0)); assertEquals(expect, result); } public void testParseInto_chrono() { MutableDateTime expect = null; MutableDateTime result = null; expect = new MutableDateTime(2004, 6, 9, 12, 20, 30, 0, PARIS); result = new MutableDateTime(0L); assertEquals(20, g.withChronology(ISO_PARIS).parseInto(result, "2004-06-09T10:20:30Z", 0)); assertEquals(expect, result); expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON); result = new MutableDateTime(0L); assertEquals(20, g.withChronology(null).parseInto(result, "2004-06-09T10:20:30Z", 0)); assertEquals(expect, result); expect = new MutableDateTime(2547, 6, 9, 12, 20, 30, 0, BUDDHIST_PARIS); result = new MutableDateTime(0L); assertEquals(20, g.withChronology(BUDDHIST_PARIS).parseInto(result, "2547-06-09T10:20:30Z", 0)); assertEquals(expect, result); expect = new MutableDateTime(2004, 6, 9, 10, 29, 51, 0, BUDDHIST_PARIS); result = new MutableDateTime(0L); assertEquals(20, g.withChronology(BUDDHIST_PARIS).parseInto(result, "2004-06-09T10:20:30Z", 0)); assertEquals(expect, result); } public void testParseInto_monthOnly() { DateTimeFormatter f = DateTimeFormat.forPattern("M").withLocale(Locale.UK); MutableDateTime result = new MutableDateTime(2004, 1, 9, 12, 20, 30, 0, LONDON); assertEquals(1, f.parseInto(result, "5", 0)); assertEquals(new MutableDateTime(2004, 5, 9, 12, 20, 30, 0, LONDON), result); } public void testParseInto_monthOnly_baseStartYear() { DateTimeFormatter f = DateTimeFormat.forPattern("M").withLocale(Locale.UK); MutableDateTime result = new MutableDateTime(2004, 1, 1, 12, 20, 30, 0, TOKYO); assertEquals(1, f.parseInto(result, "5", 0)); assertEquals(new MutableDateTime(2004, 5, 1, 12, 20, 30, 0, TOKYO), result); } public void testParseInto_monthOnly_parseStartYear() { DateTimeFormatter f = DateTimeFormat.forPattern("M").withLocale(Locale.UK); MutableDateTime result = new MutableDateTime(2004, 2, 1, 12, 20, 30, 0, TOKYO); assertEquals(1, f.parseInto(result, "1", 0)); assertEquals(new MutableDateTime(2004, 1, 1, 12, 20, 30, 0, TOKYO), result); } public void testParseInto_monthOnly_baseEndYear() { DateTimeFormatter f = DateTimeFormat.forPattern("M").withLocale(Locale.UK); MutableDateTime result = new MutableDateTime(2004, 12, 31, 12, 20, 30, 0, TOKYO); assertEquals(1, f.parseInto(result, "5", 0)); assertEquals(new MutableDateTime(2004, 5, 31, 12, 20, 30, 0, TOKYO), result); } public void testParseInto_monthOnly_parseEndYear() { DateTimeFormatter f = DateTimeFormat.forPattern("M").withLocale(Locale.UK); MutableDateTime result = new MutableDateTime(2004, 1, 31, 12, 20, 30, 0,TOKYO); assertEquals(2, f.parseInto(result, "12", 0)); assertEquals(new MutableDateTime(2004, 12, 31, 12, 20, 30, 0, TOKYO), result); } public void testParseInto_monthDay_feb29() { DateTimeFormatter f = DateTimeFormat.forPattern("M d").withLocale(Locale.UK); MutableDateTime result = new MutableDateTime(2004, 1, 9, 12, 20, 30, 0, LONDON); assertEquals(4, f.parseInto(result, "2 29", 0)); assertEquals(new MutableDateTime(2004, 2, 29, 12, 20, 30, 0, LONDON), result); } public void testParseInto_monthDay_feb29_startOfYear() { DateTimeFormatter f = DateTimeFormat.forPattern("M d").withLocale(Locale.UK); MutableDateTime result = new MutableDateTime(2004, 1, 1, 0, 0, 0, 0, LONDON); assertEquals(4, f.parseInto(result, "2 29", 0)); assertEquals(new MutableDateTime(2004, 2, 29, 0, 0, 0, 0, LONDON), result); } public void testParseInto_monthDay_feb29_OfYear() { DateTimeFormatter f = DateTimeFormat.forPattern("M d").withLocale(Locale.UK); MutableDateTime result = new MutableDateTime(2004, 12, 31, 23, 59, 59, 999, LONDON); assertEquals(4, f.parseInto(result, "2 29", 0)); assertEquals(new MutableDateTime(2004, 2, 29, 23, 59, 59, 999, LONDON), result); } public void testParseInto_monthDay_feb29_newYork() { DateTimeFormatter f = DateTimeFormat.forPattern("M d").withLocale(Locale.UK); MutableDateTime result = new MutableDateTime(2004, 1, 9, 12, 20, 30, 0, NEWYORK); assertEquals(4, f.parseInto(result, "2 29", 0)); assertEquals(new MutableDateTime(2004, 2, 29, 12, 20, 30, 0, NEWYORK), result); } public void testParseInto_monthDay_feb29_newYork_startOfYear() { DateTimeFormatter f = DateTimeFormat.forPattern("M d").withLocale(Locale.UK); MutableDateTime result = new MutableDateTime(2004, 1, 1, 0, 0, 0, 0, NEWYORK); assertEquals(4, f.parseInto(result, "2 29", 0)); assertEquals(new MutableDateTime(2004, 2, 29, 0, 0, 0, 0, NEWYORK), result); } public void testParseInto_monthDay_feb29_newYork_endOfYear() { DateTimeFormatter f = DateTimeFormat.forPattern("M d").withLocale(Locale.UK); MutableDateTime result = new MutableDateTime(2004, 12, 31, 23, 59, 59, 999, NEWYORK); assertEquals(4, f.parseInto(result, "2 29", 0)); assertEquals(new MutableDateTime(2004, 2, 29, 23, 59, 59, 999, NEWYORK), result); } public void testParseInto_monthDay_feb29_tokyo() { DateTimeFormatter f = DateTimeFormat.forPattern("M d").withLocale(Locale.UK); MutableDateTime result = new MutableDateTime(2004, 1, 9, 12, 20, 30, 0, TOKYO); assertEquals(4, f.parseInto(result, "2 29", 0)); assertEquals(new MutableDateTime(2004, 2, 29, 12, 20, 30, 0, TOKYO), result); } public void testParseInto_monthDay_feb29_tokyo_startOfYear() { DateTimeFormatter f = DateTimeFormat.forPattern("M d").withLocale(Locale.UK); MutableDateTime result = new MutableDateTime(2004, 1, 1, 0, 0, 0, 0, TOKYO); assertEquals(4, f.parseInto(result, "2 29", 0)); assertEquals(new MutableDateTime(2004, 2, 29, 0, 0, 0, 0, TOKYO), result); } public void testParseInto_monthDay_feb29_tokyo_endOfYear() { DateTimeFormatter f = DateTimeFormat.forPattern("M d").withLocale(Locale.UK); MutableDateTime result = new MutableDateTime(2004, 12, 31, 23, 59, 59, 999, TOKYO); assertEquals(4, f.parseInto(result, "2 29", 0)); assertEquals(new MutableDateTime(2004, 2, 29, 23, 59, 59, 999, TOKYO), result); } public void testParseInto_monthDay_withDefaultYear_feb29() { DateTimeFormatter f = DateTimeFormat.forPattern("M d").withDefaultYear(2012); MutableDateTime result = new MutableDateTime(2004, 1, 9, 12, 20, 30, 0, LONDON); assertEquals(4, f.parseInto(result, "2 29", 0)); assertEquals(new MutableDateTime(2004, 2, 29, 12, 20, 30, 0, LONDON), result); } public void testParseInto_monthDay_withDefaultYear_feb29_newYork() { DateTimeFormatter f = DateTimeFormat.forPattern("M d").withDefaultYear(2012); MutableDateTime result = new MutableDateTime(2004, 1, 9, 12, 20, 30, 0, NEWYORK); assertEquals(4, f.parseInto(result, "2 29", 0)); assertEquals(new MutableDateTime(2004, 2, 29, 12, 20, 30, 0, NEWYORK), result); } public void testParseInto_monthDay_withDefaultYear_feb29_newYork_endOfYear() { DateTimeFormatter f = DateTimeFormat.forPattern("M d").withDefaultYear(2012); MutableDateTime result = new MutableDateTime(2004, 12, 9, 12, 20, 30, 0, NEWYORK); assertEquals(4, f.parseInto(result, "2 29", 0)); assertEquals(new MutableDateTime(2004, 2, 29, 12, 20, 30, 0, NEWYORK), result); } public void testParseMillis_fractionOfSecondLong() { DateTimeFormatter f = new DateTimeFormatterBuilder() .appendSecondOfDay(2).appendLiteral('.').appendFractionOfSecond(1, 9) .toFormatter().withZoneUTC(); assertEquals(10512, f.parseMillis("10.5123456")); assertEquals(10512, f.parseMillis("10.512999")); } //----------------------------------------------------------------------- // Ensure time zone name switches properly at the zone DST transition. public void testZoneNameNearTransition() { DateTime inDST_1 = new DateTime(2005, 10, 30, 1, 0, 0, 0, NEWYORK); DateTime inDST_2 = new DateTime(2005, 10, 30, 1, 59, 59, 999, NEWYORK); DateTime onDST = new DateTime(2005, 10, 30, 2, 0, 0, 0, NEWYORK); DateTime outDST = new DateTime(2005, 10, 30, 2, 0, 0, 1, NEWYORK); DateTime outDST_2 = new DateTime(2005, 10, 30, 2, 0, 1, 0, NEWYORK); DateTimeFormatter fmt = DateTimeFormat.forPattern("yyy-MM-dd HH:mm:ss.S zzzz"); assertEquals("2005-10-30 01:00:00.0 Eastern Daylight Time", fmt.print(inDST_1)); assertEquals("2005-10-30 01:59:59.9 Eastern Daylight Time", fmt.print(inDST_2)); assertEquals("2005-10-30 02:00:00.0 Eastern Standard Time", fmt.print(onDST)); assertEquals("2005-10-30 02:00:00.0 Eastern Standard Time", fmt.print(outDST)); assertEquals("2005-10-30 02:00:01.0 Eastern Standard Time", fmt.print(outDST_2)); } // Ensure time zone name switches properly at the zone DST transition. public void testZoneShortNameNearTransition() { DateTime inDST_1 = new DateTime(2005, 10, 30, 1, 0, 0, 0, NEWYORK); DateTime inDST_2 = new DateTime(2005, 10, 30, 1, 59, 59, 999, NEWYORK); DateTime onDST = new DateTime(2005, 10, 30, 2, 0, 0, 0, NEWYORK); DateTime outDST = new DateTime(2005, 10, 30, 2, 0, 0, 1, NEWYORK); DateTime outDST_2 = new DateTime(2005, 10, 30, 2, 0, 1, 0, NEWYORK); DateTimeFormatter fmt = DateTimeFormat.forPattern("yyy-MM-dd HH:mm:ss.S z"); assertEquals("2005-10-30 01:00:00.0 EDT", fmt.print(inDST_1)); assertEquals("2005-10-30 01:59:59.9 EDT", fmt.print(inDST_2)); assertEquals("2005-10-30 02:00:00.0 EST", fmt.print(onDST)); assertEquals("2005-10-30 02:00:00.0 EST", fmt.print(outDST)); assertEquals("2005-10-30 02:00:01.0 EST", fmt.print(outDST_2)); } }
/* * Copyright 2001-2011 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.format; import java.util.LinkedHashMap; import java.util.Locale; import java.util.Map; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.DateTime; import org.joda.time.DateTimeFieldType; import org.joda.time.DateTimeZone; import org.joda.time.LocalDateTime; /** * This class is a Junit unit test for DateTimeFormatterBuilder. * * @author Stephen Colebourne * @author Brian S O'Neill */ public class TestDateTimeFormatterBuilder extends TestCase { private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo"); private static final DateTimeZone NEW_YORK = DateTimeZone.forID("America/New_York"); private static final DateTimeZone LOS_ANGELES = DateTimeZone.forID("America/Los_Angeles"); public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestDateTimeFormatterBuilder.class); } public TestDateTimeFormatterBuilder(String name) { super(name); } protected void setUp() throws Exception { } protected void tearDown() throws Exception { } //----------------------------------------------------------------------- public void test_toFormatter() { DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); try { bld.toFormatter(); fail(); } catch (UnsupportedOperationException ex) {} bld.appendLiteral('X'); assertNotNull(bld.toFormatter()); } public void test_toPrinter() { DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); try { bld.toPrinter(); fail(); } catch (UnsupportedOperationException ex) {} bld.appendLiteral('X'); assertNotNull(bld.toPrinter()); } public void test_toParser() { DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); try { bld.toParser(); fail(); } catch (UnsupportedOperationException ex) {} bld.appendLiteral('X'); assertNotNull(bld.toParser()); } //----------------------------------------------------------------------- public void test_canBuildFormatter() { DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); assertEquals(false, bld.canBuildFormatter()); bld.appendLiteral('X'); assertEquals(true, bld.canBuildFormatter()); } public void test_canBuildPrinter() { DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); assertEquals(false, bld.canBuildPrinter()); bld.appendLiteral('X'); assertEquals(true, bld.canBuildPrinter()); } public void test_canBuildParser() { DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); assertEquals(false, bld.canBuildParser()); bld.appendLiteral('X'); assertEquals(true, bld.canBuildParser()); } //----------------------------------------------------------------------- public void test_append_Formatter() { DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); bld.appendLiteral('Y'); DateTimeFormatter f = bld.toFormatter(); DateTimeFormatterBuilder bld2 = new DateTimeFormatterBuilder(); bld2.appendLiteral('X'); bld2.append(f); bld2.appendLiteral('Z'); assertEquals("XYZ", bld2.toFormatter().print(0L)); } //----------------------------------------------------------------------- public void test_append_Printer() { DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); bld.appendLiteral('Y'); DateTimePrinter p = bld.toPrinter(); DateTimeFormatterBuilder bld2 = new DateTimeFormatterBuilder(); bld2.appendLiteral('X'); bld2.append(p); bld2.appendLiteral('Z'); DateTimeFormatter f = bld2.toFormatter(); assertEquals(true, f.isPrinter()); assertEquals(false, f.isParser()); assertEquals("XYZ", f.print(0L)); } public void test_append_nullPrinter() { try { DateTimeFormatterBuilder bld2 = new DateTimeFormatterBuilder(); bld2.append((DateTimePrinter) null); fail(); } catch (IllegalArgumentException ex) { // expected } } //----------------------------------------------------------------------- public void test_append_Parser() { DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); bld.appendLiteral('Y'); DateTimeParser p = bld.toParser(); DateTimeFormatterBuilder bld2 = new DateTimeFormatterBuilder(); bld2.appendLiteral('X'); bld2.append(p); bld2.appendLiteral('Z'); DateTimeFormatter f = bld2.toFormatter(); assertEquals(false, f.isPrinter()); assertEquals(true, f.isParser()); assertEquals(0, f.withZoneUTC().parseMillis("XYZ")); } public void test_append_nullParser() { try { DateTimeFormatterBuilder bld2 = new DateTimeFormatterBuilder(); bld2.append((DateTimeParser) null); fail(); } catch (IllegalArgumentException ex) { // expected } } //----------------------------------------------------------------------- public void test_append_Printer_nullParser() { DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); bld.appendLiteral('Y'); DateTimePrinter p = bld.toPrinter(); try { DateTimeFormatterBuilder bld2 = new DateTimeFormatterBuilder(); bld2.append(p, (DateTimeParser) null); fail(); } catch (IllegalArgumentException ex) { // expected } } public void test_append_nullPrinter_Parser() { DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); bld.appendLiteral('Y'); DateTimeParser p = bld.toParser(); try { DateTimeFormatterBuilder bld2 = new DateTimeFormatterBuilder(); bld2.append((DateTimePrinter) null, p); fail(); } catch (IllegalArgumentException ex) { // expected } } //----------------------------------------------------------------------- public void test_appendOptional_Parser() { DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); bld.appendLiteral('Y'); DateTimeParser p = bld.toParser(); DateTimeFormatterBuilder bld2 = new DateTimeFormatterBuilder(); bld2.appendLiteral('X'); bld2.appendOptional(p); bld2.appendLiteral('Z'); DateTimeFormatter f = bld2.toFormatter(); assertEquals(false, f.isPrinter()); assertEquals(true, f.isParser()); assertEquals(0, f.withZoneUTC().parseMillis("XYZ")); } public void test_appendOptional_nullParser() { try { DateTimeFormatterBuilder bld2 = new DateTimeFormatterBuilder(); bld2.appendOptional((DateTimeParser) null); fail(); } catch (IllegalArgumentException ex) { // expected } } //----------------------------------------------------------------------- public void test_appendFixedDecimal() { DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); bld.appendFixedDecimal(DateTimeFieldType.year(), 4); DateTimeFormatter f = bld.toFormatter(); assertEquals("2007", f.print(new DateTime("2007-01-01"))); assertEquals("0123", f.print(new DateTime("123-01-01"))); assertEquals("0001", f.print(new DateTime("1-2-3"))); assertEquals("99999", f.print(new DateTime("99999-2-3"))); assertEquals("-0099", f.print(new DateTime("-99-2-3"))); assertEquals("0000", f.print(new DateTime("0-2-3"))); assertEquals(2001, f.parseDateTime("2001").getYear()); try { f.parseDateTime("-2001"); fail(); } catch (IllegalArgumentException e) { } try { f.parseDateTime("200"); fail(); } catch (IllegalArgumentException e) { } try { f.parseDateTime("20016"); fail(); } catch (IllegalArgumentException e) { } bld = new DateTimeFormatterBuilder(); bld.appendFixedDecimal(DateTimeFieldType.hourOfDay(), 2); bld.appendLiteral(':'); bld.appendFixedDecimal(DateTimeFieldType.minuteOfHour(), 2); bld.appendLiteral(':'); bld.appendFixedDecimal(DateTimeFieldType.secondOfMinute(), 2); f = bld.toFormatter(); assertEquals("01:02:34", f.print(new DateTime("T1:2:34"))); DateTime dt = f.parseDateTime("01:02:34"); assertEquals(1, dt.getHourOfDay()); assertEquals(2, dt.getMinuteOfHour()); assertEquals(34, dt.getSecondOfMinute()); try { f.parseDateTime("0145:02:34"); fail(); } catch (IllegalArgumentException e) { } try { f.parseDateTime("01:0:34"); fail(); } catch (IllegalArgumentException e) { } } //----------------------------------------------------------------------- public void test_appendFixedSignedDecimal() { DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); bld.appendFixedSignedDecimal(DateTimeFieldType.year(), 4); DateTimeFormatter f = bld.toFormatter(); assertEquals("2007", f.print(new DateTime("2007-01-01"))); assertEquals("0123", f.print(new DateTime("123-01-01"))); assertEquals("0001", f.print(new DateTime("1-2-3"))); assertEquals("99999", f.print(new DateTime("99999-2-3"))); assertEquals("-0099", f.print(new DateTime("-99-2-3"))); assertEquals("0000", f.print(new DateTime("0-2-3"))); assertEquals(2001, f.parseDateTime("2001").getYear()); assertEquals(-2001, f.parseDateTime("-2001").getYear()); assertEquals(2001, f.parseDateTime("+2001").getYear()); try { f.parseDateTime("20016"); fail(); } catch (IllegalArgumentException e) { } } //----------------------------------------------------------------------- public void test_appendTimeZoneId() { DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); bld.appendTimeZoneId(); DateTimeFormatter f = bld.toFormatter(); assertEquals("Asia/Tokyo", f.print(new DateTime(2007, 3, 4, 0, 0, 0, TOKYO))); assertEquals(TOKYO, f.parseDateTime("Asia/Tokyo").getZone()); try { f.parseDateTime("Nonsense"); fail(); } catch (IllegalArgumentException e) { } } public void test_printParseZoneTokyo() { DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder() .appendPattern("yyyy-MM-dd HH:mm ").appendTimeZoneId(); DateTimeFormatter f = bld.toFormatter(); DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, TOKYO); assertEquals("2007-03-04 12:30 Asia/Tokyo", f.print(dt)); assertEquals(dt, f.parseDateTime("2007-03-04 12:30 Asia/Tokyo")); } public void test_printParseZoneParis() { DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder() .appendPattern("yyyy-MM-dd HH:mm ").appendTimeZoneId(); DateTimeFormatter f = bld.toFormatter(); DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, PARIS); assertEquals("2007-03-04 12:30 Europe/Paris", f.print(dt)); assertEquals(dt, f.parseDateTime("2007-03-04 12:30 Europe/Paris")); assertEquals(dt, f.withOffsetParsed().parseDateTime("2007-03-04 12:30 Europe/Paris")); } public void test_printParseZoneDawsonCreek() { // clashes with shorter Dawson DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder() .appendPattern("yyyy-MM-dd HH:mm ").appendTimeZoneId(); DateTimeFormatter f = bld.toFormatter(); DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, DateTimeZone.forID("America/Dawson_Creek")); assertEquals("2007-03-04 12:30 America/Dawson_Creek", f.print(dt)); assertEquals(dt, f.parseDateTime("2007-03-04 12:30 America/Dawson_Creek")); } public void test_printParseZoneBahiaBanderas() { DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder() .appendPattern("yyyy-MM-dd HH:mm ").appendTimeZoneId(); DateTimeFormatter f = bld.toFormatter(); DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, DateTimeZone.forID("America/Bahia_Banderas")); assertEquals("2007-03-04 12:30 America/Bahia_Banderas", f.print(dt)); assertEquals(dt, f.parseDateTime("2007-03-04 12:30 America/Bahia_Banderas")); } public void test_printParseOffset() { DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder() .appendPattern("yyyy-MM-dd HH:mm ").appendTimeZoneOffset("Z", true, 2, 2); DateTimeFormatter f = bld.toFormatter(); DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, TOKYO); assertEquals("2007-03-04 12:30 +09:00", f.print(dt)); assertEquals(dt.withZone(DateTimeZone.getDefault()), f.parseDateTime("2007-03-04 12:30 +09:00")); assertEquals(dt, f.withZone(TOKYO).parseDateTime("2007-03-04 12:30 +09:00")); assertEquals(dt.withZone(DateTimeZone.forOffsetHours(9)), f.withOffsetParsed().parseDateTime("2007-03-04 12:30 +09:00")); } public void test_printParseOffsetAndZone() { DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder() .appendPattern("yyyy-MM-dd HH:mm ").appendTimeZoneOffset("Z", true, 2, 2).appendLiteral(' ').appendTimeZoneId(); DateTimeFormatter f = bld.toFormatter(); DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, TOKYO); assertEquals("2007-03-04 12:30 +09:00 Asia/Tokyo", f.print(dt)); assertEquals(dt, f.withZone(TOKYO).parseDateTime("2007-03-04 12:30 +09:00 Asia/Tokyo")); assertEquals(dt.withZone(PARIS), f.withZone(PARIS).parseDateTime("2007-03-04 12:30 +09:00 Asia/Tokyo")); assertEquals(dt.withZone(DateTimeZone.forOffsetHours(9)), f.withOffsetParsed().parseDateTime("2007-03-04 12:30 +09:00 Asia/Tokyo")); } public void test_parseWrongOffset() { DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder() .appendPattern("yyyy-MM-dd HH:mm ").appendTimeZoneOffset("Z", true, 2, 2); DateTimeFormatter f = bld.toFormatter(); DateTime expected = new DateTime(2007, 3, 4, 12, 30, 0, DateTimeZone.forOffsetHours(7)); // parses offset time then adjusts to requested zone assertEquals(expected.withZone(TOKYO), f.withZone(TOKYO).parseDateTime("2007-03-04 12:30 +07:00")); // parses offset time returning offset zone assertEquals(expected, f.withOffsetParsed().parseDateTime("2007-03-04 12:30 +07:00")); // parses offset time then converts to default zone assertEquals(expected.withZone(DateTimeZone.getDefault()), f.parseDateTime("2007-03-04 12:30 +07:00")); } public void test_parseWrongOffsetAndZone() { DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder() .appendPattern("yyyy-MM-dd HH:mm ").appendTimeZoneOffset("Z", true, 2, 2).appendLiteral(' ').appendTimeZoneId(); DateTimeFormatter f = bld.toFormatter(); DateTime expected = new DateTime(2007, 3, 4, 12, 30, 0, DateTimeZone.forOffsetHours(7)); // parses offset time then adjusts to parsed zone assertEquals(expected.withZone(TOKYO), f.parseDateTime("2007-03-04 12:30 +07:00 Asia/Tokyo")); // parses offset time then adjusts to requested zone assertEquals(expected.withZone(TOKYO), f.withZone(TOKYO).parseDateTime("2007-03-04 12:30 +07:00 Asia/Tokyo")); // parses offset time returning offset zone (ignores zone) assertEquals(expected, f.withOffsetParsed().parseDateTime("2007-03-04 12:30 +07:00 Asia/Tokyo")); } //----------------------------------------------------------------------- public void test_localPrintParseZoneTokyo() { DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder() .appendPattern("yyyy-MM-dd HH:mm ").appendTimeZoneId(); DateTimeFormatter f = bld.toFormatter(); DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, TOKYO); assertEquals("2007-03-04 12:30 Asia/Tokyo", f.print(dt)); LocalDateTime expected = new LocalDateTime(2007, 3, 4, 12, 30); assertEquals(expected, f.parseLocalDateTime("2007-03-04 12:30 Asia/Tokyo")); } public void test_localPrintParseOffset() { DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder() .appendPattern("yyyy-MM-dd HH:mm ").appendTimeZoneOffset("Z", true, 2, 2); DateTimeFormatter f = bld.toFormatter(); DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, TOKYO); assertEquals("2007-03-04 12:30 +09:00", f.print(dt)); LocalDateTime expected = new LocalDateTime(2007, 3, 4, 12, 30); assertEquals(expected, f.parseLocalDateTime("2007-03-04 12:30 +09:00")); assertEquals(expected, f.withZone(TOKYO).parseLocalDateTime("2007-03-04 12:30 +09:00")); assertEquals(expected, f.withOffsetParsed().parseLocalDateTime("2007-03-04 12:30 +09:00")); } public void test_localPrintParseOffsetAndZone() { DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder() .appendPattern("yyyy-MM-dd HH:mm ").appendTimeZoneOffset("Z", true, 2, 2).appendLiteral(' ').appendTimeZoneId(); DateTimeFormatter f = bld.toFormatter(); DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, TOKYO); assertEquals("2007-03-04 12:30 +09:00 Asia/Tokyo", f.print(dt)); LocalDateTime expected = new LocalDateTime(2007, 3, 4, 12, 30); assertEquals(expected, f.withZone(TOKYO).parseLocalDateTime("2007-03-04 12:30 +09:00 Asia/Tokyo")); assertEquals(expected, f.withZone(PARIS).parseLocalDateTime("2007-03-04 12:30 +09:00 Asia/Tokyo")); } public void test_localParseWrongOffsetAndZone() { DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder() .appendPattern("yyyy-MM-dd HH:mm ").appendTimeZoneOffset("Z", true, 2, 2).appendLiteral(' ').appendTimeZoneId(); DateTimeFormatter f = bld.toFormatter(); LocalDateTime expected = new LocalDateTime(2007, 3, 4, 12, 30); // parses offset time then adjusts to parsed zone assertEquals(expected, f.parseLocalDateTime("2007-03-04 12:30 +07:00 Asia/Tokyo")); // parses offset time then adjusts to requested zone assertEquals(expected, f.withZone(TOKYO).parseLocalDateTime("2007-03-04 12:30 +07:00 Asia/Tokyo")); // parses offset time returning offset zone (ignores zone) assertEquals(expected, f.withOffsetParsed().parseLocalDateTime("2007-03-04 12:30 +07:00 Asia/Tokyo")); } //----------------------------------------------------------------------- public void test_printParseShortName() { DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder() .appendPattern("yyyy-MM-dd HH:mm ").appendTimeZoneShortName(); DateTimeFormatter f = bld.toFormatter().withLocale(Locale.ENGLISH); assertEquals(true, f.isPrinter()); assertEquals(false, f.isParser()); DateTime dt1 = new DateTime(2011, 1, 4, 12, 30, 0, LONDON); assertEquals("2011-01-04 12:30 GMT", f.print(dt1)); DateTime dt2 = new DateTime(2011, 7, 4, 12, 30, 0, LONDON); assertEquals("2011-07-04 12:30 BST", f.print(dt2)); try { f.parseDateTime("2007-03-04 12:30 GMT"); fail(); } catch (UnsupportedOperationException e) { } } public void test_printParseShortNameWithLookup() { Map<String, DateTimeZone> lookup = new LinkedHashMap<String, DateTimeZone>(); lookup.put("GMT", LONDON); lookup.put("BST", LONDON); DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder() .appendPattern("yyyy-MM-dd HH:mm ").appendTimeZoneShortName(lookup); DateTimeFormatter f = bld.toFormatter().withLocale(Locale.ENGLISH); assertEquals(true, f.isPrinter()); assertEquals(true, f.isParser()); DateTime dt1 = new DateTime(2011, 1, 4, 12, 30, 0, LONDON); assertEquals("2011-01-04 12:30 GMT", f.print(dt1)); DateTime dt2 = new DateTime(2011, 7, 4, 12, 30, 0, LONDON); assertEquals("2011-07-04 12:30 BST", f.print(dt2)); assertEquals(dt1, f.parseDateTime("2011-01-04 12:30 GMT")); assertEquals(dt2, f.parseDateTime("2011-07-04 12:30 BST")); try { f.parseDateTime("2007-03-04 12:30 EST"); fail(); } catch (IllegalArgumentException e) { } } public void test_printParseShortNameWithAutoLookup() { DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder() .appendPattern("yyyy-MM-dd HH:mm ").appendTimeZoneShortName(null); DateTimeFormatter f = bld.toFormatter().withLocale(Locale.ENGLISH); assertEquals(true, f.isPrinter()); assertEquals(true, f.isParser()); DateTime dt1 = new DateTime(2011, 1, 4, 12, 30, 0, NEW_YORK); assertEquals("2011-01-04 12:30 EST", f.print(dt1)); DateTime dt2 = new DateTime(2011, 7, 4, 12, 30, 0, NEW_YORK); assertEquals("2011-07-04 12:30 EDT", f.print(dt2)); DateTime dt3 = new DateTime(2011, 1, 4, 12, 30, 0, LOS_ANGELES); assertEquals("2011-01-04 12:30 PST", f.print(dt3)); DateTime dt4 = new DateTime(2011, 7, 4, 12, 30, 0, LOS_ANGELES); assertEquals("2011-07-04 12:30 PDT", f.print(dt4)); DateTime dt5 = new DateTime(2011, 7, 4, 12, 30, 0, DateTimeZone.UTC); assertEquals("2011-07-04 12:30 UTC", f.print(dt5)); assertEquals(dt1.getZone() + " " + f.parseDateTime("2011-01-04 12:30 EST").getZone(), dt1, f.parseDateTime("2011-01-04 12:30 EST")); assertEquals(dt2, f.parseDateTime("2011-07-04 12:30 EDT")); assertEquals(dt3, f.parseDateTime("2011-01-04 12:30 PST")); assertEquals(dt4, f.parseDateTime("2011-07-04 12:30 PDT")); assertEquals(dt5, f.parseDateTime("2011-07-04 12:30 UT")); assertEquals(dt5, f.parseDateTime("2011-07-04 12:30 UTC")); try { f.parseDateTime("2007-03-04 12:30 PPP"); fail(); } catch (IllegalArgumentException e) { } } //----------------------------------------------------------------------- public void test_printParseLongName() { DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder() .appendPattern("yyyy-MM-dd HH:mm ").appendTimeZoneName(); DateTimeFormatter f = bld.toFormatter().withLocale(Locale.ENGLISH); assertEquals(true, f.isPrinter()); assertEquals(false, f.isParser()); DateTime dt1 = new DateTime(2011, 1, 4, 12, 30, 0, LONDON); assertEquals("2011-01-04 12:30 Greenwich Mean Time", f.print(dt1)); DateTime dt2 = new DateTime(2011, 7, 4, 12, 30, 0, LONDON); assertEquals("2011-07-04 12:30 British Summer Time", f.print(dt2)); try { f.parseDateTime("2007-03-04 12:30 GMT"); fail(); } catch (UnsupportedOperationException e) { } } public void test_printParseLongNameWithLookup() { Map<String, DateTimeZone> lookup = new LinkedHashMap<String, DateTimeZone>(); lookup.put("Greenwich Mean Time", LONDON); lookup.put("British Summer Time", LONDON); DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder() .appendPattern("yyyy-MM-dd HH:mm ").appendTimeZoneName(lookup); DateTimeFormatter f = bld.toFormatter().withLocale(Locale.ENGLISH); assertEquals(true, f.isPrinter()); assertEquals(true, f.isParser()); DateTime dt1 = new DateTime(2011, 1, 4, 12, 30, 0, LONDON); assertEquals("2011-01-04 12:30 Greenwich Mean Time", f.print(dt1)); DateTime dt2 = new DateTime(2011, 7, 4, 12, 30, 0, LONDON); assertEquals("2011-07-04 12:30 British Summer Time", f.print(dt2)); assertEquals(dt1, f.parseDateTime("2011-01-04 12:30 Greenwich Mean Time")); assertEquals(dt2, f.parseDateTime("2011-07-04 12:30 British Summer Time")); try { f.parseDateTime("2007-03-04 12:30 EST"); fail(); } catch (IllegalArgumentException e) { } } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.format; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.DateTime; import org.joda.time.DateTimeConstants; import org.joda.time.DateTimeFieldType; import org.joda.time.DateTimeUtils; import org.joda.time.DateTimeZone; import org.joda.time.Partial; /** * This class is a Junit unit test for ISODateTimeFormat. * * @author Stephen Colebourne */ public class TestISODateTimeFormat extends TestCase { private static final DateTimeZone UTC = DateTimeZone.UTC; private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestISODateTimeFormat.class); } public TestISODateTimeFormat(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testSubclassableConstructor() { ISODateTimeFormat f = new ISODateTimeFormat() { // test constructor is protected }; assertNotNull(f); } //----------------------------------------------------------------------- public void testFormat_date() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("2004-06-09", ISODateTimeFormat.date().print(dt)); dt = dt.withZone(LONDON); assertEquals("2004-06-09", ISODateTimeFormat.date().print(dt)); dt = dt.withZone(PARIS); assertEquals("2004-06-09", ISODateTimeFormat.date().print(dt)); } public void testFormat_date_partial() { Partial dt = new Partial( new DateTimeFieldType[] {DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth()}, new int[] {2004, 6, 9}); assertEquals("2004-06-09", ISODateTimeFormat.date().print(dt)); } public void testFormat_time() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("10:20:30.040Z", ISODateTimeFormat.time().print(dt)); dt = dt.withZone(LONDON); assertEquals("11:20:30.040+01:00", ISODateTimeFormat.time().print(dt)); dt = dt.withZone(PARIS); assertEquals("12:20:30.040+02:00", ISODateTimeFormat.time().print(dt)); } public void testFormat_time_partial() { Partial dt = new Partial( new DateTimeFieldType[] {DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond()}, new int[] {10, 20, 30, 40}); assertEquals("10:20:30.040", ISODateTimeFormat.time().print(dt)); } public void testFormat_timeNoMillis() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("10:20:30Z", ISODateTimeFormat.timeNoMillis().print(dt)); dt = dt.withZone(LONDON); assertEquals("11:20:30+01:00", ISODateTimeFormat.timeNoMillis().print(dt)); dt = dt.withZone(PARIS); assertEquals("12:20:30+02:00", ISODateTimeFormat.timeNoMillis().print(dt)); } public void testFormat_timeNoMillis_partial() { Partial dt = new Partial( new DateTimeFieldType[] {DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond()}, new int[] {10, 20, 30, 40}); assertEquals("10:20:30", ISODateTimeFormat.timeNoMillis().print(dt)); } public void testFormat_tTime() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("T10:20:30.040Z", ISODateTimeFormat.tTime().print(dt)); dt = dt.withZone(LONDON); assertEquals("T11:20:30.040+01:00", ISODateTimeFormat.tTime().print(dt)); dt = dt.withZone(PARIS); assertEquals("T12:20:30.040+02:00", ISODateTimeFormat.tTime().print(dt)); } public void testFormat_tTimeNoMillis() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("T10:20:30Z", ISODateTimeFormat.tTimeNoMillis().print(dt)); dt = dt.withZone(LONDON); assertEquals("T11:20:30+01:00", ISODateTimeFormat.tTimeNoMillis().print(dt)); dt = dt.withZone(PARIS); assertEquals("T12:20:30+02:00", ISODateTimeFormat.tTimeNoMillis().print(dt)); } public void testFormat_dateTime() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("2004-06-09T10:20:30.040Z", ISODateTimeFormat.dateTime().print(dt)); dt = dt.withZone(LONDON); assertEquals("2004-06-09T11:20:30.040+01:00", ISODateTimeFormat.dateTime().print(dt)); dt = dt.withZone(PARIS); assertEquals("2004-06-09T12:20:30.040+02:00", ISODateTimeFormat.dateTime().print(dt)); // dt = dt.withZone(LONDON); // assertEquals("2004-06-09T11:20:30.040+01:00", ISODateTimeFormat.getInstance(PARIS).dateTime().print(dt)); // // dt = dt.withZone(LONDON); // assertEquals("2004-06-09T12:20:30.040+02:00", ISODateTimeFormat.dateTime().print(dt.getMillis(), PARIS)); // // dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, CopticChronology.getInstance()); // assertEquals("2288-02-19T10:20:30.040Z", ISODateTimeFormat.dateTime().print(dt)); // // dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, CopticChronology.getInstance()); // assertEquals("2004-06-09T10:20:30.040Z", ISODateTimeFormat.getInstance(CopticChronology.getInstance()).dateTime().print(dt)); } public void testFormat_dateTimeNoMillis() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("2004-06-09T10:20:30Z", ISODateTimeFormat.dateTimeNoMillis().print(dt)); dt = dt.withZone(LONDON); assertEquals("2004-06-09T11:20:30+01:00", ISODateTimeFormat.dateTimeNoMillis().print(dt)); dt = dt.withZone(PARIS); assertEquals("2004-06-09T12:20:30+02:00", ISODateTimeFormat.dateTimeNoMillis().print(dt)); } public void testFormat_ordinalDate() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("2004-161", ISODateTimeFormat.ordinalDate().print(dt)); dt = dt.withZone(LONDON); assertEquals("2004-161", ISODateTimeFormat.ordinalDate().print(dt)); dt = dt.withZone(PARIS); assertEquals("2004-161", ISODateTimeFormat.ordinalDate().print(dt)); } public void testFormat_ordinalDateTime() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("2004-161T10:20:30.040Z", ISODateTimeFormat.ordinalDateTime().print(dt)); dt = dt.withZone(LONDON); assertEquals("2004-161T11:20:30.040+01:00", ISODateTimeFormat.ordinalDateTime().print(dt)); dt = dt.withZone(PARIS); assertEquals("2004-161T12:20:30.040+02:00", ISODateTimeFormat.ordinalDateTime().print(dt)); } public void testFormat_ordinalDateTimeNoMillis() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("2004-161T10:20:30Z", ISODateTimeFormat.ordinalDateTimeNoMillis().print(dt)); dt = dt.withZone(LONDON); assertEquals("2004-161T11:20:30+01:00", ISODateTimeFormat.ordinalDateTimeNoMillis().print(dt)); dt = dt.withZone(PARIS); assertEquals("2004-161T12:20:30+02:00", ISODateTimeFormat.ordinalDateTimeNoMillis().print(dt)); } public void testFormat_weekDate() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("2004-W24-3", ISODateTimeFormat.weekDate().print(dt)); dt = dt.withZone(LONDON); assertEquals("2004-W24-3", ISODateTimeFormat.weekDate().print(dt)); dt = dt.withZone(PARIS); assertEquals("2004-W24-3", ISODateTimeFormat.weekDate().print(dt)); } public void testFormat_weekDateTime() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("2004-W24-3T10:20:30.040Z", ISODateTimeFormat.weekDateTime().print(dt)); dt = dt.withZone(LONDON); assertEquals("2004-W24-3T11:20:30.040+01:00", ISODateTimeFormat.weekDateTime().print(dt)); dt = dt.withZone(PARIS); assertEquals("2004-W24-3T12:20:30.040+02:00", ISODateTimeFormat.weekDateTime().print(dt)); } public void testFormat_weekDateTimeNoMillis() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("2004-W24-3T10:20:30Z", ISODateTimeFormat.weekDateTimeNoMillis().print(dt)); dt = dt.withZone(LONDON); assertEquals("2004-W24-3T11:20:30+01:00", ISODateTimeFormat.weekDateTimeNoMillis().print(dt)); dt = dt.withZone(PARIS); assertEquals("2004-W24-3T12:20:30+02:00", ISODateTimeFormat.weekDateTimeNoMillis().print(dt)); } //----------------------------------------------------------------------- public void testFormat_basicDate() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("20040609", ISODateTimeFormat.basicDate().print(dt)); dt = dt.withZone(LONDON); assertEquals("20040609", ISODateTimeFormat.basicDate().print(dt)); dt = dt.withZone(PARIS); assertEquals("20040609", ISODateTimeFormat.basicDate().print(dt)); } public void testFormat_basicTime() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("102030.040Z", ISODateTimeFormat.basicTime().print(dt)); dt = dt.withZone(LONDON); assertEquals("112030.040+0100", ISODateTimeFormat.basicTime().print(dt)); dt = dt.withZone(PARIS); assertEquals("122030.040+0200", ISODateTimeFormat.basicTime().print(dt)); } public void testFormat_basicTimeNoMillis() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("102030Z", ISODateTimeFormat.basicTimeNoMillis().print(dt)); dt = dt.withZone(LONDON); assertEquals("112030+0100", ISODateTimeFormat.basicTimeNoMillis().print(dt)); dt = dt.withZone(PARIS); assertEquals("122030+0200", ISODateTimeFormat.basicTimeNoMillis().print(dt)); } public void testFormat_basicTTime() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("T102030.040Z", ISODateTimeFormat.basicTTime().print(dt)); dt = dt.withZone(LONDON); assertEquals("T112030.040+0100", ISODateTimeFormat.basicTTime().print(dt)); dt = dt.withZone(PARIS); assertEquals("T122030.040+0200", ISODateTimeFormat.basicTTime().print(dt)); } public void testFormat_basicTTimeNoMillis() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("T102030Z", ISODateTimeFormat.basicTTimeNoMillis().print(dt)); dt = dt.withZone(LONDON); assertEquals("T112030+0100", ISODateTimeFormat.basicTTimeNoMillis().print(dt)); dt = dt.withZone(PARIS); assertEquals("T122030+0200", ISODateTimeFormat.basicTTimeNoMillis().print(dt)); } public void testFormat_basicDateTime() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("20040609T102030.040Z", ISODateTimeFormat.basicDateTime().print(dt)); dt = dt.withZone(LONDON); assertEquals("20040609T112030.040+0100", ISODateTimeFormat.basicDateTime().print(dt)); dt = dt.withZone(PARIS); assertEquals("20040609T122030.040+0200", ISODateTimeFormat.basicDateTime().print(dt)); } public void testFormat_basicDateTimeNoMillis() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("20040609T102030Z", ISODateTimeFormat.basicDateTimeNoMillis().print(dt)); dt = dt.withZone(LONDON); assertEquals("20040609T112030+0100", ISODateTimeFormat.basicDateTimeNoMillis().print(dt)); dt = dt.withZone(PARIS); assertEquals("20040609T122030+0200", ISODateTimeFormat.basicDateTimeNoMillis().print(dt)); } public void testFormat_basicOrdinalDate() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("2004161", ISODateTimeFormat.basicOrdinalDate().print(dt)); dt = dt.withZone(LONDON); assertEquals("2004161", ISODateTimeFormat.basicOrdinalDate().print(dt)); dt = dt.withZone(PARIS); assertEquals("2004161", ISODateTimeFormat.basicOrdinalDate().print(dt)); } public void testFormat_basicOrdinalDateTime() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("2004161T102030.040Z", ISODateTimeFormat.basicOrdinalDateTime().print(dt)); dt = dt.withZone(LONDON); assertEquals("2004161T112030.040+0100", ISODateTimeFormat.basicOrdinalDateTime().print(dt)); dt = dt.withZone(PARIS); assertEquals("2004161T122030.040+0200", ISODateTimeFormat.basicOrdinalDateTime().print(dt)); } public void testFormat_basicOrdinalDateTimeNoMillis() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("2004161T102030Z", ISODateTimeFormat.basicOrdinalDateTimeNoMillis().print(dt)); dt = dt.withZone(LONDON); assertEquals("2004161T112030+0100", ISODateTimeFormat.basicOrdinalDateTimeNoMillis().print(dt)); dt = dt.withZone(PARIS); assertEquals("2004161T122030+0200", ISODateTimeFormat.basicOrdinalDateTimeNoMillis().print(dt)); } public void testFormat_basicWeekDate() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("2004W243", ISODateTimeFormat.basicWeekDate().print(dt)); dt = dt.withZone(LONDON); assertEquals("2004W243", ISODateTimeFormat.basicWeekDate().print(dt)); dt = dt.withZone(PARIS); assertEquals("2004W243", ISODateTimeFormat.basicWeekDate().print(dt)); } public void testFormat_basicWeekDateTime() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("2004W243T102030.040Z", ISODateTimeFormat.basicWeekDateTime().print(dt)); dt = dt.withZone(LONDON); assertEquals("2004W243T112030.040+0100", ISODateTimeFormat.basicWeekDateTime().print(dt)); dt = dt.withZone(PARIS); assertEquals("2004W243T122030.040+0200", ISODateTimeFormat.basicWeekDateTime().print(dt)); } public void testFormat_basicWeekDateTimeNoMillis() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("2004W243T102030Z", ISODateTimeFormat.basicWeekDateTimeNoMillis().print(dt)); dt = dt.withZone(LONDON); assertEquals("2004W243T112030+0100", ISODateTimeFormat.basicWeekDateTimeNoMillis().print(dt)); dt = dt.withZone(PARIS); assertEquals("2004W243T122030+0200", ISODateTimeFormat.basicWeekDateTimeNoMillis().print(dt)); } //----------------------------------------------------------------------- public void testFormat_year() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("2004", ISODateTimeFormat.year().print(dt)); dt = dt.withZone(LONDON); assertEquals("2004", ISODateTimeFormat.year().print(dt)); dt = dt.withZone(PARIS); assertEquals("2004", ISODateTimeFormat.year().print(dt)); } public void testFormat_yearMonth() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("2004-06", ISODateTimeFormat.yearMonth().print(dt)); dt = dt.withZone(LONDON); assertEquals("2004-06", ISODateTimeFormat.yearMonth().print(dt)); dt = dt.withZone(PARIS); assertEquals("2004-06", ISODateTimeFormat.yearMonth().print(dt)); } public void testFormat_yearMonthDay() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("2004-06-09", ISODateTimeFormat.yearMonthDay().print(dt)); dt = dt.withZone(LONDON); assertEquals("2004-06-09", ISODateTimeFormat.yearMonthDay().print(dt)); dt = dt.withZone(PARIS); assertEquals("2004-06-09", ISODateTimeFormat.yearMonthDay().print(dt)); } public void testFormat_weekyear() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("2004", ISODateTimeFormat.weekyear().print(dt)); dt = dt.withZone(LONDON); assertEquals("2004", ISODateTimeFormat.weekyear().print(dt)); dt = dt.withZone(PARIS); assertEquals("2004", ISODateTimeFormat.weekyear().print(dt)); } public void testFormat_weekyearWeek() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("2004-W24", ISODateTimeFormat.weekyearWeek().print(dt)); dt = dt.withZone(LONDON); assertEquals("2004-W24", ISODateTimeFormat.weekyearWeek().print(dt)); dt = dt.withZone(PARIS); assertEquals("2004-W24", ISODateTimeFormat.weekyearWeek().print(dt)); } public void testFormat_weekyearWeekDay() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("2004-W24-3", ISODateTimeFormat.weekyearWeekDay().print(dt)); dt = dt.withZone(LONDON); assertEquals("2004-W24-3", ISODateTimeFormat.weekyearWeekDay().print(dt)); dt = dt.withZone(PARIS); assertEquals("2004-W24-3", ISODateTimeFormat.weekyearWeekDay().print(dt)); } //----------------------------------------------------------------------- public void testFormat_hour() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("10", ISODateTimeFormat.hour().print(dt)); dt = dt.withZone(LONDON); assertEquals("11", ISODateTimeFormat.hour().print(dt)); dt = dt.withZone(PARIS); assertEquals("12", ISODateTimeFormat.hour().print(dt)); } public void testFormat_hourMinute() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("10:20", ISODateTimeFormat.hourMinute().print(dt)); dt = dt.withZone(LONDON); assertEquals("11:20", ISODateTimeFormat.hourMinute().print(dt)); dt = dt.withZone(PARIS); assertEquals("12:20", ISODateTimeFormat.hourMinute().print(dt)); } public void testFormat_hourMinuteSecond() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("10:20:30", ISODateTimeFormat.hourMinuteSecond().print(dt)); dt = dt.withZone(LONDON); assertEquals("11:20:30", ISODateTimeFormat.hourMinuteSecond().print(dt)); dt = dt.withZone(PARIS); assertEquals("12:20:30", ISODateTimeFormat.hourMinuteSecond().print(dt)); } public void testFormat_hourMinuteSecondMillis() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("10:20:30.040", ISODateTimeFormat.hourMinuteSecondMillis().print(dt)); dt = dt.withZone(LONDON); assertEquals("11:20:30.040", ISODateTimeFormat.hourMinuteSecondMillis().print(dt)); dt = dt.withZone(PARIS); assertEquals("12:20:30.040", ISODateTimeFormat.hourMinuteSecondMillis().print(dt)); } public void testFormat_hourMinuteSecondFraction() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("10:20:30.040", ISODateTimeFormat.hourMinuteSecondFraction().print(dt)); dt = dt.withZone(LONDON); assertEquals("11:20:30.040", ISODateTimeFormat.hourMinuteSecondFraction().print(dt)); dt = dt.withZone(PARIS); assertEquals("12:20:30.040", ISODateTimeFormat.hourMinuteSecondFraction().print(dt)); } //----------------------------------------------------------------------- public void testFormat_dateHour() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("2004-06-09T10", ISODateTimeFormat.dateHour().print(dt)); dt = dt.withZone(LONDON); assertEquals("2004-06-09T11", ISODateTimeFormat.dateHour().print(dt)); dt = dt.withZone(PARIS); assertEquals("2004-06-09T12", ISODateTimeFormat.dateHour().print(dt)); } public void testFormat_dateHourMinute() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("2004-06-09T10:20", ISODateTimeFormat.dateHourMinute().print(dt)); dt = dt.withZone(LONDON); assertEquals("2004-06-09T11:20", ISODateTimeFormat.dateHourMinute().print(dt)); dt = dt.withZone(PARIS); assertEquals("2004-06-09T12:20", ISODateTimeFormat.dateHourMinute().print(dt)); } public void testFormat_dateHourMinuteSecond() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("2004-06-09T10:20:30", ISODateTimeFormat.dateHourMinuteSecond().print(dt)); dt = dt.withZone(LONDON); assertEquals("2004-06-09T11:20:30", ISODateTimeFormat.dateHourMinuteSecond().print(dt)); dt = dt.withZone(PARIS); assertEquals("2004-06-09T12:20:30", ISODateTimeFormat.dateHourMinuteSecond().print(dt)); } public void testFormat_dateHourMinuteSecondMillis() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("2004-06-09T10:20:30.040", ISODateTimeFormat.dateHourMinuteSecondMillis().print(dt)); dt = dt.withZone(LONDON); assertEquals("2004-06-09T11:20:30.040", ISODateTimeFormat.dateHourMinuteSecondMillis().print(dt)); dt = dt.withZone(PARIS); assertEquals("2004-06-09T12:20:30.040", ISODateTimeFormat.dateHourMinuteSecondMillis().print(dt)); } public void testFormat_dateHourMinuteSecondFraction() { DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC); assertEquals("2004-06-09T10:20:30.040", ISODateTimeFormat.dateHourMinuteSecondFraction().print(dt)); dt = dt.withZone(LONDON); assertEquals("2004-06-09T11:20:30.040", ISODateTimeFormat.dateHourMinuteSecondFraction().print(dt)); dt = dt.withZone(PARIS); assertEquals("2004-06-09T12:20:30.040", ISODateTimeFormat.dateHourMinuteSecondFraction().print(dt)); } }
/* * Copyright 2001-2006 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.format; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.DateTime; import org.joda.time.DateTimeZone; /** * This class is a Junit unit test for ISODateTimeFormat parsing. * * @author Stephen Colebourne */ public class TestISODateTimeFormatParsing extends TestCase { private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestISODateTimeFormatParsing.class); } public TestISODateTimeFormatParsing(String name) { super(name); } protected void setUp() throws Exception { originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(DateTimeZone.forID("Europe/London")); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void test_dateParser() { DateTimeFormatter parser = ISODateTimeFormat.dateParser(); assertParse(parser, true, "2006-06-09"); assertParse(parser, true, "2006-W27-3"); assertParse(parser, true, "2006-123"); assertParse(parser, true, "2006-06-09T+02:00"); assertParse(parser, true, "2006-W27-3T+02:00"); assertParse(parser, true, "2006-123T+02:00"); assertParse(parser, false, "2006-06-09T10:20:30.040"); assertParse(parser, false, "2006-W27-3T10:20:30.040"); assertParse(parser, false, "2006-123T10:20:30.040"); assertParse(parser, false, "2006-06-09T10:20:30.040+02:00"); assertParse(parser, false, "2006-W27-3T10:20:30.040+02:00"); assertParse(parser, false, "2006-123T10:20:30.040+02:00"); assertParse(parser, false, "T10:20:30.040"); assertParse(parser, false, "T10.5"); assertParse(parser, false, "T10:20:30.040+02:00"); assertParse(parser, false, "T10.5+02:00"); assertParse(parser, false, "10:20:30.040"); assertParse(parser, false, "10.5"); assertParse(parser, false, "10:20:30.040+02:00"); assertParse(parser, false, "10.5+02:00"); } //----------------------------------------------------------------------- public void test_localDateParser() { DateTimeFormatter parser = ISODateTimeFormat.localDateParser(); assertEquals(DateTimeZone.UTC, parser.getZone()); assertParse(parser, true, "2006-06-09"); assertParse(parser, true, "2006-W27-3"); assertParse(parser, true, "2006-123"); assertParse(parser, false, "2006-06-09T+02:00"); assertParse(parser, false, "2006-W27-3T+02:00"); assertParse(parser, false, "2006-123T+02:00"); assertParse(parser, false, "2006-06-09T10:20:30.040"); assertParse(parser, false, "2006-W27-3T10:20:30.040"); assertParse(parser, false, "2006-123T10:20:30.040"); assertParse(parser, false, "2006-06-09T10:20:30.040+02:00"); assertParse(parser, false, "2006-W27-3T10:20:30.040+02:00"); assertParse(parser, false, "2006-123T10:20:30.040+02:00"); assertParse(parser, false, "T10:20:30.040"); assertParse(parser, false, "T10.5"); assertParse(parser, false, "T10:20:30.040+02:00"); assertParse(parser, false, "T10.5+02:00"); assertParse(parser, false, "10:20:30.040"); assertParse(parser, false, "10.5"); assertParse(parser, false, "10:20:30.040+02:00"); assertParse(parser, false, "10.5+02:00"); } //----------------------------------------------------------------------- public void test_dateElementParser() { DateTimeFormatter parser = ISODateTimeFormat.dateElementParser(); assertParse(parser, "2006-06-09", new DateTime(2006, 6, 9, 0, 0, 0, 0)); assertParse(parser, "2006-06-9", new DateTime(2006, 6, 9, 0, 0, 0, 0)); assertParse(parser, "2006-6-09", new DateTime(2006, 6, 9, 0, 0, 0, 0)); assertParse(parser, "2006-6-9", new DateTime(2006, 6, 9, 0, 0, 0, 0)); assertParse(parser, true, "2006-W27-3"); assertParse(parser, true, "2006-123"); assertParse(parser, false, "2006-06-09T+02:00"); assertParse(parser, false, "2006-W27-3T+02:00"); assertParse(parser, false, "2006-123T+02:00"); assertParse(parser, false, "2006-06-09T10:20:30.040"); assertParse(parser, false, "2006-W27-3T10:20:30.040"); assertParse(parser, false, "2006-123T10:20:30.040"); assertParse(parser, false, "2006-06-09T10:20:30.040+02:00"); assertParse(parser, false, "2006-W27-3T10:20:30.040+02:00"); assertParse(parser, false, "2006-123T10:20:30.040+02:00"); assertParse(parser, false, "T10:20:30.040"); assertParse(parser, false, "T10.5"); assertParse(parser, false, "T10:20:30.040+02:00"); assertParse(parser, false, "T10.5+02:00"); assertParse(parser, false, "10:20:30.040"); assertParse(parser, false, "10.5"); assertParse(parser, false, "10:20:30.040+02:00"); assertParse(parser, false, "10.5+02:00"); } //----------------------------------------------------------------------- public void test_timeParser() { DateTimeZone.setDefault(DateTimeZone.UTC); DateTimeFormatter parser = ISODateTimeFormat.timeParser(); assertParse(parser, false, "2006-06-09"); assertParse(parser, false, "2006-W27-3"); assertParse(parser, false, "2006-123"); assertParse(parser, false, "2006-06-09T+02:00"); assertParse(parser, false, "2006-W27-3T+02:00"); assertParse(parser, false, "2006-123T+02:00"); assertParse(parser, false, "2006-06-09T10:20:30.040"); assertParse(parser, false, "2006-W27-3T10:20:30.040"); assertParse(parser, false, "2006-123T10:20:30.040"); assertParse(parser, false, "2006-06-09T10:20:30.040+02:00"); assertParse(parser, false, "2006-W27-3T10:20:30.040+02:00"); assertParse(parser, false, "2006-123T10:20:30.040+02:00"); assertParse(parser, "T10:20:30.040000000", new DateTime(1970, 1, 1, 10, 20, 30, 40)); assertParse(parser, "T10:20:30.004", new DateTime(1970, 1, 1, 10, 20, 30, 4)); assertParse(parser, "T10:20:30.040", new DateTime(1970, 1, 1, 10, 20, 30, 40)); assertParse(parser, "T10:20:30.400", new DateTime(1970, 1, 1, 10, 20, 30, 400)); assertParse(parser, "T10.5", new DateTime(1970, 1, 1, 10, 30, 0, 0)); assertParse(parser, "T10:20:30.040+02:00", new DateTime(1970, 1, 1, 8, 20, 30, 40)); assertParse(parser, "T10.5+02:00", new DateTime(1970, 1, 1, 8, 30, 0, 0)); assertParse(parser, true, "10:20:30.040"); assertParse(parser, true, "10.5"); assertParse(parser, true, "10:20:30.040+02:00"); assertParse(parser, true, "10.5+02:00"); } //----------------------------------------------------------------------- public void test_localTimeParser() { DateTimeFormatter parser = ISODateTimeFormat.localTimeParser(); assertEquals(DateTimeZone.UTC, parser.getZone()); assertParse(parser, false, "2006-06-09"); assertParse(parser, false, "2006-W27-3"); assertParse(parser, false, "2006-123"); assertParse(parser, false, "2006-06-09T+02:00"); assertParse(parser, false, "2006-W27-3T+02:00"); assertParse(parser, false, "2006-123T+02:00"); assertParse(parser, false, "2006-06-09T10:20:30.040"); assertParse(parser, false, "2006-W27-3T10:20:30.040"); assertParse(parser, false, "2006-123T10:20:30.040"); assertParse(parser, false, "2006-06-09T10:20:30.040+02:00"); assertParse(parser, false, "2006-W27-3T10:20:30.040+02:00"); assertParse(parser, false, "2006-123T10:20:30.040+02:00"); assertParse(parser, true, "T10:20:30.040"); assertParse(parser, true, "T10.5"); assertParse(parser, false, "T10:20:30.040+02:00"); assertParse(parser, false, "T10.5+02:00"); assertParse(parser, true, "10:20:30.040"); assertParse(parser, true, "10.5"); assertParse(parser, false, "10:20:30.040+02:00"); assertParse(parser, false, "10.5+02:00"); assertParse(parser, true, "00:00:10.512345678"); assertEquals(10512, parser.parseMillis("00:00:10.512345678")); } //----------------------------------------------------------------------- public void test_timeElementParser() { DateTimeFormatter parser = ISODateTimeFormat.timeElementParser(); assertParse(parser, false, "2006-06-09"); assertParse(parser, false, "2006-W27-3"); assertParse(parser, false, "2006-123"); assertParse(parser, false, "2006-06-09T+02:00"); assertParse(parser, false, "2006-W27-3T+02:00"); assertParse(parser, false, "2006-123T+02:00"); assertParse(parser, false, "2006-06-09T10:20:30.040"); assertParse(parser, false, "2006-W27-3T10:20:30.040"); assertParse(parser, false, "2006-123T10:20:30.040"); assertParse(parser, false, "2006-06-09T10:20:30.040+02:00"); assertParse(parser, false, "2006-W27-3T10:20:30.040+02:00"); assertParse(parser, false, "2006-123T10:20:30.040+02:00"); assertParse(parser, false, "T10:20:30.040"); assertParse(parser, false, "T10.5"); assertParse(parser, false, "T10:20:30.040+02:00"); assertParse(parser, false, "T10.5+02:00"); assertParse(parser, true, "10:20:30.040"); assertParse(parser, true, "10.5"); assertParse(parser, false, "10:20:30.040+02:00"); assertParse(parser, false, "10.5+02:00"); assertParse(parser, true, "00:00:10.512345678"); // result is offset by London DST in 1970-01-01 assertEquals(10512, parser.parseMillis("00:00:10.512345678") + DateTimeZone.getDefault().getOffset(0L)); } //----------------------------------------------------------------------- public void test_dateTimeParser() { DateTimeFormatter parser = ISODateTimeFormat.dateTimeParser(); assertParse(parser, true, "2006-06-09"); assertParse(parser, true, "2006-W27-3"); assertParse(parser, true, "2006-123"); assertParse(parser, true, "2006-06-09T+02:00"); assertParse(parser, true, "2006-W27-3T+02:00"); assertParse(parser, true, "2006-123T+02:00"); assertParse(parser, true, "2006-06-09T10:20:30.040"); assertParse(parser, true, "2006-W27-3T10:20:30.040"); assertParse(parser, true, "2006-123T10:20:30.040"); assertParse(parser, true, "2006-06-09T10:20:30.040+02:00"); assertParse(parser, true, "2006-W27-3T10:20:30.040+02:00"); assertParse(parser, true, "2006-123T10:20:30.040+02:00"); assertParse(parser, true, "T10:20:30.040"); assertParse(parser, true, "T10.5"); assertParse(parser, true, "T10:20:30.040+02:00"); assertParse(parser, true, "T10.5+02:00"); assertParse(parser, false, "10:20:30.040"); assertParse(parser, false, "10.5"); assertParse(parser, false, "10:20:30.040+02:00"); assertParse(parser, false, "10.5+02:00"); } //----------------------------------------------------------------------- public void test_dateOptionalTimeParser() { DateTimeFormatter parser = ISODateTimeFormat.dateOptionalTimeParser(); assertParse(parser, true, "2006-06-09"); assertParse(parser, true, "2006-W27-3"); assertParse(parser, true, "2006-123"); assertParse(parser, true, "2006-06-09T+02:00"); assertParse(parser, true, "2006-W27-3T+02:00"); assertParse(parser, true, "2006-123T+02:00"); assertParse(parser, true, "2006-06-09T10:20:30.040"); assertParse(parser, true, "2006-W27-3T10:20:30.040"); assertParse(parser, true, "2006-123T10:20:30.040"); assertParse(parser, true, "2006-06-09T10:20:30.040+02:00"); assertParse(parser, true, "2006-W27-3T10:20:30.040+02:00"); assertParse(parser, true, "2006-123T10:20:30.040+02:00"); assertParse(parser, false, "T10:20:30.040"); assertParse(parser, false, "T10.5"); assertParse(parser, false, "T10:20:30.040+02:00"); assertParse(parser, false, "T10.5+02:00"); assertParse(parser, false, "10:20:30.040"); assertParse(parser, false, "10.5"); assertParse(parser, false, "10:20:30.040+02:00"); assertParse(parser, false, "10.5+02:00"); } //----------------------------------------------------------------------- public void test_localDateOptionalTimeParser() { DateTimeFormatter parser = ISODateTimeFormat.localDateOptionalTimeParser(); assertEquals(DateTimeZone.UTC, parser.getZone()); assertParse(parser, true, "2006-06-09"); assertParse(parser, true, "2006-W27-3"); assertParse(parser, true, "2006-123"); assertParse(parser, false, "2006-06-09T+02:00"); assertParse(parser, false, "2006-W27-3T+02:00"); assertParse(parser, false, "2006-123T+02:00"); assertParse(parser, true, "2006-06-09T10:20:30.040"); assertParse(parser, true, "2006-W27-3T10:20:30.040"); assertParse(parser, true, "2006-123T10:20:30.040"); assertParse(parser, false, "2006-06-09T10:20:30.040+02:00"); assertParse(parser, false, "2006-W27-3T10:20:30.040+02:00"); assertParse(parser, false, "2006-123T10:20:30.040+02:00"); assertParse(parser, false, "T10:20:30.040"); assertParse(parser, false, "T10.5"); assertParse(parser, false, "T10:20:30.040+02:00"); assertParse(parser, false, "T10.5+02:00"); assertParse(parser, false, "10:20:30.040"); assertParse(parser, false, "10.5"); assertParse(parser, false, "10:20:30.040+02:00"); assertParse(parser, false, "10.5+02:00"); } //----------------------------------------------------------------------- //----------------------------------------------------------------------- //----------------------------------------------------------------------- public void test_date() { DateTimeFormatter parser = ISODateTimeFormat.date(); assertParse(parser, "2006-02-04", new DateTime(2006, 2, 4, 0, 0, 0, 0)); assertParse(parser, "2006-2-04", new DateTime(2006, 2, 4, 0, 0, 0, 0)); assertParse(parser, "2006-02-4", new DateTime(2006, 2, 4, 0, 0, 0, 0)); assertParse(parser, "2006-2-4", new DateTime(2006, 2, 4, 0, 0, 0, 0)); assertParse(parser, false, "2006-02-"); assertParse(parser, false, "2006-02"); assertParse(parser, false, "2006--4"); assertParse(parser, false, "2006-1"); assertParse(parser, false, "2006"); } //----------------------------------------------------------------------- public void test_time() { DateTimeZone.setDefault(DateTimeZone.UTC); DateTimeFormatter parser = ISODateTimeFormat.time(); assertParse(parser, "10:20:30.400999999Z", new DateTime(1970, 1, 1, 10, 20, 30, 400)); assertParse(parser, "10:20:30.400Z", new DateTime(1970, 1, 1, 10, 20, 30, 400)); assertParse(parser, "10:20:30.40Z", new DateTime(1970, 1, 1, 10, 20, 30, 400)); assertParse(parser, "10:20:30.4Z", new DateTime(1970, 1, 1, 10, 20, 30, 400)); assertParse(parser, "5:6:7.8Z", new DateTime(1970, 1, 1, 5, 6, 7, 800)); assertParse(parser, false, "10:20.400Z"); assertParse(parser, false, "10:2.400Z"); assertParse(parser, false, "10.400Z"); assertParse(parser, false, "1.400Z"); } //----------------------------------------------------------------------- public void test_timeNoMillis() { DateTimeZone.setDefault(DateTimeZone.UTC); DateTimeFormatter parser = ISODateTimeFormat.timeNoMillis(); assertParse(parser, "10:20:30Z", new DateTime(1970, 1, 1, 10, 20, 30, 0)); assertParse(parser, "5:6:7Z", new DateTime(1970, 1, 1, 5, 6, 7, 0)); assertParse(parser, false, "10:20Z"); assertParse(parser, false, "10:2Z"); assertParse(parser, false, "10Z"); assertParse(parser, false, "1Z"); } //----------------------------------------------------------------------- public void test_tTime() { DateTimeZone.setDefault(DateTimeZone.UTC); DateTimeFormatter parser = ISODateTimeFormat.tTime(); assertParse(parser, "T10:20:30.400999999Z", new DateTime(1970, 1, 1, 10, 20, 30, 400)); assertParse(parser, "T10:20:30.400Z", new DateTime(1970, 1, 1, 10, 20, 30, 400)); assertParse(parser, "T10:20:30.40Z", new DateTime(1970, 1, 1, 10, 20, 30, 400)); assertParse(parser, "T10:20:30.4Z", new DateTime(1970, 1, 1, 10, 20, 30, 400)); assertParse(parser, "T5:6:7.8Z", new DateTime(1970, 1, 1, 5, 6, 7, 800)); assertParse(parser, false, "T10:20.400Z"); assertParse(parser, false, "T102.400Z"); assertParse(parser, false, "T10.400Z"); assertParse(parser, false, "T1.400Z"); } //----------------------------------------------------------------------- public void test_tTimeNoMillis() { DateTimeZone.setDefault(DateTimeZone.UTC); DateTimeFormatter parser = ISODateTimeFormat.tTimeNoMillis(); assertParse(parser, "T10:20:30Z", new DateTime(1970, 1, 1, 10, 20, 30, 0)); assertParse(parser, "T5:6:7Z", new DateTime(1970, 1, 1, 5, 6, 7, 0)); assertParse(parser, false, "T10:20Z"); assertParse(parser, false, "T10:2Z"); assertParse(parser, false, "T10Z"); assertParse(parser, false, "T1Z"); } //----------------------------------------------------------------------- public void test_dateTime() { DateTimeZone.setDefault(DateTimeZone.UTC); DateTimeFormatter parser = ISODateTimeFormat.dateTime(); assertParse(parser, "2006-02-04T10:20:30.400999999Z", new DateTime(2006, 2, 4, 10, 20, 30, 400)); assertParse(parser, "2006-02-04T10:20:30.400Z", new DateTime(2006, 2, 4, 10, 20, 30, 400)); assertParse(parser, "2006-02-04T10:20:30.40Z", new DateTime(2006, 2, 4, 10, 20, 30, 400)); assertParse(parser, "2006-02-04T10:20:30.4Z", new DateTime(2006, 2, 4, 10, 20, 30, 400)); assertParse(parser, "2006-02-4T10:20:30.400Z", new DateTime(2006, 2, 4, 10, 20, 30, 400)); assertParse(parser, "2006-2-04T10:20:30.400Z", new DateTime(2006, 2, 4, 10, 20, 30, 400)); assertParse(parser, "2006-2-4T10:20:30.400Z", new DateTime(2006, 2, 4, 10, 20, 30, 400)); assertParse(parser, "2006-02-04T5:6:7.800Z", new DateTime(2006, 2, 4, 5, 6, 7, 800)); assertParse(parser, false, "2006-02-T10:20:30.400Z"); assertParse(parser, false, "2006-12T10:20:30.400Z"); assertParse(parser, false, "2006-1T10:20:30.400Z"); assertParse(parser, false, "2006T10:20:30.400Z"); assertParse(parser, false, "200T10:20:30.400Z"); assertParse(parser, false, "20T10:20:30.400Z"); assertParse(parser, false, "2T10:20:30.400Z"); assertParse(parser, false, "2006-02-04T10:20.400Z"); assertParse(parser, false, "2006-02-04T10:2.400Z"); assertParse(parser, false, "2006-02-04T10.400Z"); assertParse(parser, false, "2006-02-04T1.400Z"); } //----------------------------------------------------------------------- public void test_dateTimeNoMillis() { DateTimeZone.setDefault(DateTimeZone.UTC); DateTimeFormatter parser = ISODateTimeFormat.dateTimeNoMillis(); assertParse(parser, "2006-02-04T10:20:30Z", new DateTime(2006, 2, 4, 10, 20, 30, 0)); assertParse(parser, "2006-02-4T10:20:30Z", new DateTime(2006, 2, 4, 10, 20, 30, 0)); assertParse(parser, "2006-2-04T10:20:30Z", new DateTime(2006, 2, 4, 10, 20, 30, 0)); assertParse(parser, "2006-2-4T10:20:30Z", new DateTime(2006, 2, 4, 10, 20, 30, 0)); assertParse(parser, "2006-02-04T5:6:7Z", new DateTime(2006, 2, 4, 5, 6, 7, 0)); assertParse(parser, false, "2006-02-T10:20:30Z"); assertParse(parser, false, "2006-12T10:20:30Z"); assertParse(parser, false, "2006-1T10:20:30Z"); assertParse(parser, false, "2006T10:20:30Z"); assertParse(parser, false, "200T10:20:30Z"); assertParse(parser, false, "20T10:20:30Z"); assertParse(parser, false, "2T10:20:30Z"); assertParse(parser, false, "2006-02-04T10:20Z"); assertParse(parser, false, "2006-02-04T10:2Z"); assertParse(parser, false, "2006-02-04T10Z"); assertParse(parser, false, "2006-02-04T1Z"); } //----------------------------------------------------------------------- public void test_ordinalDate() { DateTimeFormatter parser = ISODateTimeFormat.ordinalDate(); assertParse(parser, "2006-123", new DateTime(2006, 1, 1, 0, 0, 0, 0).withDayOfYear(123)); assertParse(parser, "2006-12", new DateTime(2006, 1, 1, 0, 0, 0, 0).withDayOfYear(12)); assertParse(parser, "2006-1", new DateTime(2006, 1, 1, 0, 0, 0, 0).withDayOfYear(1)); assertParse(parser, false, "2006-"); assertParse(parser, false, "2006"); } //----------------------------------------------------------------------- public void test_ordinalDateTime() { DateTimeZone.setDefault(DateTimeZone.UTC); DateTimeFormatter parser = ISODateTimeFormat.ordinalDateTime(); assertParse(parser, "2006-123T10:20:30.400999999Z", new DateTime(2006, 1, 1, 10, 20, 30, 400).withDayOfYear(123)); assertParse(parser, "2006-123T10:20:30.400Z", new DateTime(2006, 1, 1, 10, 20, 30, 400).withDayOfYear(123)); assertParse(parser, "2006-123T10:20:30.40Z", new DateTime(2006, 1, 1, 10, 20, 30, 400).withDayOfYear(123)); assertParse(parser, "2006-123T10:20:30.4Z", new DateTime(2006, 1, 1, 10, 20, 30, 400).withDayOfYear(123)); assertParse(parser, "2006-12T10:20:30.400Z", new DateTime(2006, 1, 1, 10, 20, 30, 400).withDayOfYear(12)); assertParse(parser, "2006-1T10:20:30.400Z", new DateTime(2006, 1, 1, 10, 20, 30, 400).withDayOfYear(1)); assertParse(parser, "2006-123T5:6:7.800Z", new DateTime(2006, 1, 1, 5, 6, 7, 800).withDayOfYear(123)); assertParse(parser, false, "2006-T10:20:30.400Z"); assertParse(parser, false, "2006T10:20:30.400Z"); assertParse(parser, false, "2006-123T10:20.400Z"); assertParse(parser, false, "2006-123T10:2.400Z"); assertParse(parser, false, "2006-123T10.400Z"); assertParse(parser, false, "2006-123T1.400Z"); } //----------------------------------------------------------------------- public void test_ordinalDateTimeNoMillis() { DateTimeZone.setDefault(DateTimeZone.UTC); DateTimeFormatter parser = ISODateTimeFormat.ordinalDateTimeNoMillis(); assertParse(parser, "2006-123T10:20:30Z", new DateTime(2006, 1, 1, 10, 20, 30, 0).withDayOfYear(123)); assertParse(parser, "2006-12T10:20:30Z", new DateTime(2006, 1, 1, 10, 20, 30, 0).withDayOfYear(12)); assertParse(parser, "2006-1T10:20:30Z", new DateTime(2006, 1, 1, 10, 20, 30, 0).withDayOfYear(1)); assertParse(parser, "2006-123T5:6:7Z", new DateTime(2006, 1, 1, 5, 6, 7, 0).withDayOfYear(123)); assertParse(parser, false, "2006-T10:20:30Z"); assertParse(parser, false, "2006T10:20:30Z"); assertParse(parser, false, "2006-123T10:20Z"); assertParse(parser, false, "2006-123T10:2Z"); assertParse(parser, false, "2006-123T10Z"); assertParse(parser, false, "2006-123T1Z"); } //----------------------------------------------------------------------- public void test_weekDate() { DateTimeFormatter parser = ISODateTimeFormat.weekDate(); assertParse(parser, "2006-W27-3", new DateTime(2006, 6, 1, 0, 0, 0, 0).withWeekOfWeekyear(27).withDayOfWeek(3)); assertParse(parser, "2006-W2-3", new DateTime(2006, 6, 1, 0, 0, 0, 0).withWeekOfWeekyear(2).withDayOfWeek(3)); assertParse(parser, false, "2006-W-3"); assertParse(parser, false, "2006-W27-"); assertParse(parser, false, "2006-W27"); assertParse(parser, false, "2006-W2"); assertParse(parser, false, "2006-W"); } //----------------------------------------------------------------------- public void test_weekDateTime() { DateTimeZone.setDefault(DateTimeZone.UTC); DateTimeFormatter parser = ISODateTimeFormat.weekDateTime(); assertParse(parser, "2006-W27-3T10:20:30.400999999Z", new DateTime(2006, 6, 1, 10, 20, 30, 400).withWeekOfWeekyear(27).withDayOfWeek(3)); assertParse(parser, "2006-W27-3T10:20:30.400Z", new DateTime(2006, 6, 1, 10, 20, 30, 400).withWeekOfWeekyear(27).withDayOfWeek(3)); assertParse(parser, "2006-W27-3T10:20:30.40Z", new DateTime(2006, 6, 1, 10, 20, 30, 400).withWeekOfWeekyear(27).withDayOfWeek(3)); assertParse(parser, "2006-W27-3T10:20:30.4Z", new DateTime(2006, 6, 1, 10, 20, 30, 400).withWeekOfWeekyear(27).withDayOfWeek(3)); assertParse(parser, "2006-W2-3T10:20:30.400Z", new DateTime(2006, 6, 1, 10, 20, 30, 400).withWeekOfWeekyear(2).withDayOfWeek(3)); assertParse(parser, "2006-W27-3T5:6:7.800Z", new DateTime(2006, 6, 1, 5, 6, 7, 800).withWeekOfWeekyear(27).withDayOfWeek(3)); assertParse(parser, false, "2006-W27-T10:20:30.400Z"); assertParse(parser, false, "2006-W27T10:20:30.400Z"); assertParse(parser, false, "2006-W2T10:20:30.400Z"); assertParse(parser, false, "2006-W-3T10:20:30.400Z"); assertParse(parser, false, "2006-W27-3T10:20.400Z"); assertParse(parser, false, "2006-W27-3T10:2.400Z"); assertParse(parser, false, "2006-W27-3T10.400Z"); assertParse(parser, false, "2006-W27-3T1.400Z"); } //----------------------------------------------------------------------- public void test_weekDateTimeNoMillis() { DateTimeZone.setDefault(DateTimeZone.UTC); DateTimeFormatter parser = ISODateTimeFormat.weekDateTimeNoMillis(); assertParse(parser, "2006-W27-3T10:20:30Z", new DateTime(2006, 6, 1, 10, 20, 30, 0).withWeekOfWeekyear(27).withDayOfWeek(3)); assertParse(parser, "2006-W2-3T10:20:30Z", new DateTime(2006, 6, 1, 10, 20, 30, 0).withWeekOfWeekyear(2).withDayOfWeek(3)); assertParse(parser, "2006-W27-3T5:6:7Z", new DateTime(2006, 6, 1, 5, 6, 7, 0).withWeekOfWeekyear(27).withDayOfWeek(3)); assertParse(parser, false, "2006-W27-T10:20:30Z"); assertParse(parser, false, "2006-W27T10:20:30Z"); assertParse(parser, false, "2006-W2T10:20:30Z"); assertParse(parser, false, "2006-W-3T10:20:30Z"); assertParse(parser, false, "2006-W27-3T10:20Z"); assertParse(parser, false, "2006-W27-3T10:2Z"); assertParse(parser, false, "2006-W27-3T10Z"); assertParse(parser, false, "2006-W27-3T1Z"); } //----------------------------------------------------------------------- //----------------------------------------------------------------------- //----------------------------------------------------------------------- public void test_basicDate() { DateTimeFormatter parser = ISODateTimeFormat.basicDate(); assertParse(parser, "20060204", new DateTime(2006, 2, 4, 0, 0, 0, 0)); assertParse(parser, false, "2006024"); assertParse(parser, false, "200602"); assertParse(parser, false, "20061"); assertParse(parser, false, "2006"); } //----------------------------------------------------------------------- public void test_basicTime() { DateTimeZone.setDefault(DateTimeZone.UTC); DateTimeFormatter parser = ISODateTimeFormat.basicTime(); assertParse(parser, "102030.400999999Z", new DateTime(1970, 1, 1, 10, 20, 30, 400)); assertParse(parser, "102030.400Z", new DateTime(1970, 1, 1, 10, 20, 30, 400)); assertParse(parser, "102030.40Z", new DateTime(1970, 1, 1, 10, 20, 30, 400)); assertParse(parser, "102030.4Z", new DateTime(1970, 1, 1, 10, 20, 30, 400)); assertParse(parser, false, "10203.400Z"); assertParse(parser, false, "1020.400Z"); assertParse(parser, false, "102.400Z"); assertParse(parser, false, "10.400Z"); assertParse(parser, false, "1.400Z"); } //----------------------------------------------------------------------- public void test_basicTimeNoMillis() { DateTimeZone.setDefault(DateTimeZone.UTC); DateTimeFormatter parser = ISODateTimeFormat.basicTimeNoMillis(); assertParse(parser, "102030Z", new DateTime(1970, 1, 1, 10, 20, 30, 0)); assertParse(parser, false, "10203Z"); assertParse(parser, false, "1020Z"); assertParse(parser, false, "102Z"); assertParse(parser, false, "10Z"); assertParse(parser, false, "1Z"); } //----------------------------------------------------------------------- public void test_basicTTime() { DateTimeZone.setDefault(DateTimeZone.UTC); DateTimeFormatter parser = ISODateTimeFormat.basicTTime(); assertParse(parser, "T102030.400999999Z", new DateTime(1970, 1, 1, 10, 20, 30, 400)); assertParse(parser, "T102030.400Z", new DateTime(1970, 1, 1, 10, 20, 30, 400)); assertParse(parser, "T102030.40Z", new DateTime(1970, 1, 1, 10, 20, 30, 400)); assertParse(parser, "T102030.4Z", new DateTime(1970, 1, 1, 10, 20, 30, 400)); assertParse(parser, false, "T10203.400Z"); assertParse(parser, false, "T1020.400Z"); assertParse(parser, false, "T102.400Z"); assertParse(parser, false, "T10.400Z"); assertParse(parser, false, "T1.400Z"); } //----------------------------------------------------------------------- public void test_basicTTimeNoMillis() { DateTimeZone.setDefault(DateTimeZone.UTC); DateTimeFormatter parser = ISODateTimeFormat.basicTTimeNoMillis(); assertParse(parser, "T102030Z", new DateTime(1970, 1, 1, 10, 20, 30, 0)); assertParse(parser, false, "T10203Z"); assertParse(parser, false, "T1020Z"); assertParse(parser, false, "T102Z"); assertParse(parser, false, "T10Z"); assertParse(parser, false, "T1Z"); } //----------------------------------------------------------------------- public void test_basicDateTime() { DateTimeZone.setDefault(DateTimeZone.UTC); DateTimeFormatter parser = ISODateTimeFormat.basicDateTime(); assertParse(parser, "20061204T102030.400999999Z", new DateTime(2006, 12, 4, 10, 20, 30, 400)); assertParse(parser, "20061204T102030.400Z", new DateTime(2006, 12, 4, 10, 20, 30, 400)); assertParse(parser, "20061204T102030.40Z", new DateTime(2006, 12, 4, 10, 20, 30, 400)); assertParse(parser, "20061204T102030.4Z", new DateTime(2006, 12, 4, 10, 20, 30, 400)); assertParse(parser, false, "2006120T102030.400Z"); assertParse(parser, false, "200612T102030.400Z"); assertParse(parser, false, "20061T102030.400Z"); assertParse(parser, false, "2006T102030.400Z"); assertParse(parser, false, "200T102030.400Z"); assertParse(parser, false, "20T102030.400Z"); assertParse(parser, false, "2T102030.400Z"); assertParse(parser, false, "20061204T10203.400Z"); assertParse(parser, false, "20061204T1020.400Z"); assertParse(parser, false, "20061204T102.400Z"); assertParse(parser, false, "20061204T10.400Z"); assertParse(parser, false, "20061204T1.400Z"); } //----------------------------------------------------------------------- public void test_basicDateTimeNoMillis() { DateTimeZone.setDefault(DateTimeZone.UTC); DateTimeFormatter parser = ISODateTimeFormat.basicDateTimeNoMillis(); assertParse(parser, "20061204T102030Z", new DateTime(2006, 12, 4, 10, 20, 30, 0)); assertParse(parser, false, "2006120T102030Z"); assertParse(parser, false, "200612T102030Z"); assertParse(parser, false, "20061T102030Z"); assertParse(parser, false, "2006T102030Z"); assertParse(parser, false, "200T102030Z"); assertParse(parser, false, "20T102030Z"); assertParse(parser, false, "2T102030Z"); assertParse(parser, false, "20061204T10203Z"); assertParse(parser, false, "20061204T1020Z"); assertParse(parser, false, "20061204T102Z"); assertParse(parser, false, "20061204T10Z"); assertParse(parser, false, "20061204T1Z"); } //----------------------------------------------------------------------- public void test_basicOrdinalDate() { DateTimeFormatter parser = ISODateTimeFormat.basicOrdinalDate(); assertParse(parser, "2006123", new DateTime(2006, 1, 1, 0, 0, 0, 0).withDayOfYear(123)); assertParse(parser, false, "200612"); assertParse(parser, false, "20061"); assertParse(parser, false, "2006"); } //----------------------------------------------------------------------- public void test_basicOrdinalDateTime() { DateTimeZone.setDefault(DateTimeZone.UTC); DateTimeFormatter parser = ISODateTimeFormat.basicOrdinalDateTime(); assertParse(parser, "2006123T102030.400999999Z", new DateTime(2006, 1, 1, 10, 20, 30, 400).withDayOfYear(123)); assertParse(parser, "2006123T102030.400Z", new DateTime(2006, 1, 1, 10, 20, 30, 400).withDayOfYear(123)); assertParse(parser, "2006123T102030.40Z", new DateTime(2006, 1, 1, 10, 20, 30, 400).withDayOfYear(123)); assertParse(parser, "2006123T102030.4Z", new DateTime(2006, 1, 1, 10, 20, 30, 400).withDayOfYear(123)); assertParse(parser, false, "200612T102030.400Z"); assertParse(parser, false, "20061T102030.400Z"); assertParse(parser, false, "2006T102030.400Z"); assertParse(parser, false, "200T102030.400Z"); assertParse(parser, false, "20T102030.400Z"); assertParse(parser, false, "2T102030.400Z"); assertParse(parser, false, "2006123T10203.400Z"); assertParse(parser, false, "2006123T1020.400Z"); assertParse(parser, false, "2006123T102.400Z"); assertParse(parser, false, "2006123T10.400Z"); assertParse(parser, false, "2006123T1.400Z"); } //----------------------------------------------------------------------- public void test_basicOrdinalDateTimeNoMillis() { DateTimeZone.setDefault(DateTimeZone.UTC); DateTimeFormatter parser = ISODateTimeFormat.basicOrdinalDateTimeNoMillis(); assertParse(parser, "2006123T102030Z", new DateTime(2006, 1, 1, 10, 20, 30, 0).withDayOfYear(123)); assertParse(parser, false, "200612T102030Z"); assertParse(parser, false, "20061T102030Z"); assertParse(parser, false, "2006T102030Z"); assertParse(parser, false, "200T102030Z"); assertParse(parser, false, "20T102030Z"); assertParse(parser, false, "2T102030Z"); assertParse(parser, false, "2006123T10203Z"); assertParse(parser, false, "2006123T1020Z"); assertParse(parser, false, "2006123T102Z"); assertParse(parser, false, "2006123T10Z"); assertParse(parser, false, "2006123T1Z"); } //----------------------------------------------------------------------- public void test_basicWeekDate() { DateTimeFormatter parser = ISODateTimeFormat.basicWeekDate(); assertParse(parser, "2006W273", new DateTime(2006, 6, 1, 0, 0, 0, 0).withWeekOfWeekyear(27).withDayOfWeek(3)); assertParse(parser, false, "2006W27"); assertParse(parser, false, "2006W2"); assertParse(parser, false, "2006W"); } //----------------------------------------------------------------------- public void test_basicWeekDateTime() { DateTimeZone.setDefault(DateTimeZone.UTC); DateTimeFormatter parser = ISODateTimeFormat.basicWeekDateTime(); assertParse(parser, "2006W273T102030.400999999Z", new DateTime(2006, 6, 1, 10, 20, 30, 400).withWeekOfWeekyear(27).withDayOfWeek(3)); assertParse(parser, "2006W273T102030.400Z", new DateTime(2006, 6, 1, 10, 20, 30, 400).withWeekOfWeekyear(27).withDayOfWeek(3)); assertParse(parser, "2006W273T102030.40Z", new DateTime(2006, 6, 1, 10, 20, 30, 400).withWeekOfWeekyear(27).withDayOfWeek(3)); assertParse(parser, "2006W273T102030.4Z", new DateTime(2006, 6, 1, 10, 20, 30, 400).withWeekOfWeekyear(27).withDayOfWeek(3)); assertParse(parser, false, "2006W27T102030.400Z"); assertParse(parser, false, "2006W2T102030.400Z"); assertParse(parser, false, "2006W273T10203.400Z"); assertParse(parser, false, "2006W273T1020.400Z"); assertParse(parser, false, "2006W273T102.400Z"); assertParse(parser, false, "2006W273T10.400Z"); assertParse(parser, false, "2006W273T1.400Z"); } //----------------------------------------------------------------------- public void test_basicWeekDateTimeNoMillis() { DateTimeZone.setDefault(DateTimeZone.UTC); DateTimeFormatter parser = ISODateTimeFormat.basicWeekDateTimeNoMillis(); assertParse(parser, "2006W273T102030Z", new DateTime(2006, 6, 1, 10, 20, 30, 0).withWeekOfWeekyear(27).withDayOfWeek(3)); assertParse(parser, false, "2006W27T102030Z"); assertParse(parser, false, "2006W2T102030Z"); assertParse(parser, false, "2006W273T10203Z"); assertParse(parser, false, "2006W273T1020Z"); assertParse(parser, false, "2006W273T102Z"); assertParse(parser, false, "2006W273T10Z"); assertParse(parser, false, "2006W273T1Z"); } //----------------------------------------------------------------------- //----------------------------------------------------------------------- //----------------------------------------------------------------------- public void test_hourMinute() { DateTimeZone.setDefault(DateTimeZone.UTC); DateTimeFormatter parser = ISODateTimeFormat.hourMinute(); assertParse(parser, "10:20", new DateTime(1970, 1, 1, 10, 20, 0, 0)); assertParse(parser, "5:6", new DateTime(1970, 1, 1, 5, 6, 0, 0)); assertParse(parser, false, "10:20:30.400999999"); assertParse(parser, false, "10:20:30.400"); assertParse(parser, false, "10:20:30"); assertParse(parser, false, "10:20.400"); assertParse(parser, false, "10:2.400"); assertParse(parser, false, "10.400"); assertParse(parser, false, "1.400"); } //----------------------------------------------------------------------- public void test_hourMinuteSecond() { DateTimeZone.setDefault(DateTimeZone.UTC); DateTimeFormatter parser = ISODateTimeFormat.hourMinuteSecond(); assertParse(parser, "10:20:30", new DateTime(1970, 1, 1, 10, 20, 30, 0)); assertParse(parser, "5:6:7", new DateTime(1970, 1, 1, 5, 6, 7, 0)); assertParse(parser, false, "10:20:30.400999999"); assertParse(parser, false, "10:20:30.400"); assertParse(parser, false, "10:20:30.4"); assertParse(parser, false, "10:20.400"); assertParse(parser, false, "10:2.400"); assertParse(parser, false, "10.400"); assertParse(parser, false, "1.400"); } //----------------------------------------------------------------------- public void test_hourMinuteSecondMillis() { DateTimeZone.setDefault(DateTimeZone.UTC); DateTimeFormatter parser = ISODateTimeFormat.hourMinuteSecondMillis(); assertParse(parser, "10:20:30.400", new DateTime(1970, 1, 1, 10, 20, 30, 400)); assertParse(parser, "10:20:30.40", new DateTime(1970, 1, 1, 10, 20, 30, 400)); assertParse(parser, "10:20:30.4", new DateTime(1970, 1, 1, 10, 20, 30, 400)); assertParse(parser, "5:6:7.8", new DateTime(1970, 1, 1, 5, 6, 7, 800)); assertParse(parser, false, "10:20:30.400999999"); assertParse(parser, false, "10:20.400"); assertParse(parser, false, "10:2.400"); assertParse(parser, false, "10.400"); assertParse(parser, false, "1.400"); } //----------------------------------------------------------------------- public void test_hourMinuteSecondFraction() { DateTimeZone.setDefault(DateTimeZone.UTC); DateTimeFormatter parser = ISODateTimeFormat.hourMinuteSecondFraction(); assertParse(parser, "10:20:30.400999999", new DateTime(1970, 1, 1, 10, 20, 30, 400)); assertParse(parser, "10:20:30.400", new DateTime(1970, 1, 1, 10, 20, 30, 400)); assertParse(parser, "10:20:30.40", new DateTime(1970, 1, 1, 10, 20, 30, 400)); assertParse(parser, "10:20:30.4", new DateTime(1970, 1, 1, 10, 20, 30, 400)); assertParse(parser, "5:6:7.8", new DateTime(1970, 1, 1, 5, 6, 7, 800)); assertParse(parser, false, "10:20.400"); assertParse(parser, false, "10:2.400"); assertParse(parser, false, "10.400"); assertParse(parser, false, "1.400"); } //----------------------------------------------------------------------- //----------------------------------------------------------------------- //----------------------------------------------------------------------- private void assertParse(DateTimeFormatter parser, boolean expected, String str) { if (expected) { parser.parseMillis(str); } else { try { parser.parseMillis(str); fail(); } catch (IllegalArgumentException ex) { // expected } } } private void assertParse(DateTimeFormatter parser, String str, DateTime expected) { DateTime dt = parser.parseDateTime(str); assertEquals(expected, dt); } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.format; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.List; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.DateTimeFieldType; import org.joda.time.Partial; /** * This class is a Junit unit test for ISODateTimeFormat. * * @author Stephen Colebourne */ public class TestISODateTimeFormat_Fields extends TestCase { public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestISODateTimeFormat_Fields.class); } public TestISODateTimeFormat_Fields(String name) { super(name); } protected void setUp() throws Exception { } protected void tearDown() throws Exception { } //----------------------------------------------------------------------- public void testForFields_null() { try { ISODateTimeFormat.forFields((Collection) null, true, true); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testForFields_empty() { try { ISODateTimeFormat.forFields(new ArrayList(), true, true); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- //----------------------------------------------------------------------- //----------------------------------------------------------------------- public void testForFields_calBased_YMD() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth(), }; int[] values = new int[] {2005, 6, 25}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true); assertEquals("2005-06-25", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, true, false); assertEquals("2005-06-25", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, true); assertEquals("20050625", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("20050625", f.print(new Partial(fields, values))); assertEquals(0, types.size()); } //----------------------------------------------------------------------- public void testForFields_calBased_YMD_unmodifiable() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth(), }; int[] values = new int[] {2005, 6, 25}; List types = Collections.unmodifiableList(new ArrayList(Arrays.asList(fields))); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true); assertEquals("2005-06-25", f.print(new Partial(fields, values))); assertEquals(3, types.size()); types = Arrays.asList(fields); f = ISODateTimeFormat.forFields(types, true, true); assertEquals("2005-06-25", f.print(new Partial(fields, values))); assertEquals(3, types.size()); } //----------------------------------------------------------------------- public void testForFields_calBased_YMD_duplicates() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth(), }; DateTimeFieldType[] dupFields = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.monthOfYear(), }; int[] values = new int[] {2005, 6, 25}; List types = new ArrayList(Arrays.asList(dupFields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true); assertEquals("2005-06-25", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = Arrays.asList(dupFields); f = ISODateTimeFormat.forFields(types, true, true); assertEquals("2005-06-25", f.print(new Partial(fields, values))); assertEquals(4, types.size()); } //----------------------------------------------------------------------- public void testForFields_calBased_Y() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.year(), }; int[] values = new int[] {2005}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true); assertEquals("2005", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, true, false); assertEquals("2005", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, true); assertEquals("2005", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("2005", f.print(new Partial(fields, values))); assertEquals(0, types.size()); } //----------------------------------------------------------------------- public void testForFields_calBased_M() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), }; int[] values = new int[] {6}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true); assertEquals("--06", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, true, false); assertEquals("--06", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, true); assertEquals("--06", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("--06", f.print(new Partial(fields, values))); assertEquals(0, types.size()); } //----------------------------------------------------------------------- public void testForFields_calBased_D() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.dayOfMonth(), }; int[] values = new int[] {25}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true); assertEquals("---25", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, true, false); assertEquals("---25", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, true); assertEquals("---25", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("---25", f.print(new Partial(fields, values))); assertEquals(0, types.size()); } //----------------------------------------------------------------------- public void testForFields_calBased_YM() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), }; int[] values = new int[] {2005, 6}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true); assertEquals("2005-06", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, true, false); assertEquals("2005-06", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, true); assertEquals("2005-06", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("2005-06", f.print(new Partial(fields, values))); assertEquals(0, types.size()); } //----------------------------------------------------------------------- public void testForFields_calBased_MD() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth(), }; int[] values = new int[] {6, 25}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true); assertEquals("--06-25", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, true, false); assertEquals("--06-25", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, true); assertEquals("--0625", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("--0625", f.print(new Partial(fields, values))); assertEquals(0, types.size()); } //----------------------------------------------------------------------- public void testForFields_calBased_YD() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), }; int[] values = new int[] {2005, 25}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, false); assertEquals("2005--25", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("2005--25", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); try { ISODateTimeFormat.forFields(types, true, true); fail(); } catch (IllegalArgumentException ex) {} types = new ArrayList(Arrays.asList(fields)); try { ISODateTimeFormat.forFields(types, false, true); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- //----------------------------------------------------------------------- //----------------------------------------------------------------------- public void testForFields_weekBased_YWD() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.weekyear(), DateTimeFieldType.weekOfWeekyear(), DateTimeFieldType.dayOfWeek(), }; int[] values = new int[] {2005, 8, 5}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true); assertEquals("2005-W08-5", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, true, false); assertEquals("2005-W08-5", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, true); assertEquals("2005W085", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("2005W085", f.print(new Partial(fields, values))); assertEquals(0, types.size()); } //----------------------------------------------------------------------- public void testForFields_weekBased_Y() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.weekyear(), }; int[] values = new int[] {2005}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true); assertEquals("2005", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, true, false); assertEquals("2005", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, true); assertEquals("2005", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("2005", f.print(new Partial(fields, values))); assertEquals(0, types.size()); } //----------------------------------------------------------------------- public void testForFields_weekBased_W() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.weekOfWeekyear(), }; int[] values = new int[] {8}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true); assertEquals("-W08", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, true, false); assertEquals("-W08", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, true); assertEquals("-W08", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("-W08", f.print(new Partial(fields, values))); assertEquals(0, types.size()); } //----------------------------------------------------------------------- public void testForFields_weekBased_D() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.dayOfWeek(), }; int[] values = new int[] {5}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true); assertEquals("-W-5", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, true, false); assertEquals("-W-5", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, true); assertEquals("-W-5", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("-W-5", f.print(new Partial(fields, values))); assertEquals(0, types.size()); } //----------------------------------------------------------------------- public void testForFields_weekBased_YW() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.weekyear(), DateTimeFieldType.weekOfWeekyear(), }; int[] values = new int[] {2005, 8}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true); assertEquals("2005-W08", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, true, false); assertEquals("2005-W08", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, true); assertEquals("2005W08", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("2005W08", f.print(new Partial(fields, values))); assertEquals(0, types.size()); } //----------------------------------------------------------------------- public void testForFields_weekBased_WD() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.weekOfWeekyear(), DateTimeFieldType.dayOfWeek(), }; int[] values = new int[] {8, 5}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true); assertEquals("-W08-5", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, true, false); assertEquals("-W08-5", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, true); assertEquals("-W085", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("-W085", f.print(new Partial(fields, values))); assertEquals(0, types.size()); } //----------------------------------------------------------------------- public void testForFields_weekBased_YD() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.weekyear(), DateTimeFieldType.dayOfWeek(), }; int[] values = new int[] {2005, 5}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, false); assertEquals("2005-W-5", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("2005W-5", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); try { ISODateTimeFormat.forFields(types, true, true); fail(); } catch (IllegalArgumentException ex) {} types = new ArrayList(Arrays.asList(fields)); try { ISODateTimeFormat.forFields(types, false, true); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- //----------------------------------------------------------------------- //----------------------------------------------------------------------- public void testForFields_ordinalBased_YD() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.dayOfYear(), }; int[] values = new int[] {2005, 177}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true); assertEquals("2005-177", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, true, false); assertEquals("2005-177", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, true); assertEquals("2005177", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("2005177", f.print(new Partial(fields, values))); assertEquals(0, types.size()); } //----------------------------------------------------------------------- public void testForFields_ordinalBased_Y() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.year(), }; int[] values = new int[] {2005}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true); assertEquals("2005", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, true, false); assertEquals("2005", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, true); assertEquals("2005", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("2005", f.print(new Partial(fields, values))); assertEquals(0, types.size()); } //----------------------------------------------------------------------- public void testForFields_ordinalBased_D() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.dayOfYear(), }; int[] values = new int[] {177}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true); assertEquals("-177", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, true, false); assertEquals("-177", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, true); assertEquals("-177", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("-177", f.print(new Partial(fields, values))); assertEquals(0, types.size()); } //----------------------------------------------------------------------- //----------------------------------------------------------------------- //----------------------------------------------------------------------- public void testForFields_time_HMSm() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond(), }; int[] values = new int[] {10, 20, 30, 40}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true); assertEquals("10:20:30.040", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, true, false); assertEquals("10:20:30.040", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, true); assertEquals("102030.040", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("102030.040", f.print(new Partial(fields, values))); assertEquals(0, types.size()); } //----------------------------------------------------------------------- public void testForFields_time_HMS() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), }; int[] values = new int[] {10, 20, 30}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true); assertEquals("10:20:30", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, true, false); assertEquals("10:20:30", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, true); assertEquals("102030", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("102030", f.print(new Partial(fields, values))); assertEquals(0, types.size()); } //----------------------------------------------------------------------- public void testForFields_time_HM() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), }; int[] values = new int[] {10, 20}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true); assertEquals("10:20", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, true, false); assertEquals("10:20", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, true); assertEquals("1020", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("1020", f.print(new Partial(fields, values))); assertEquals(0, types.size()); } //----------------------------------------------------------------------- public void testForFields_time_H() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), }; int[] values = new int[] {10}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true); assertEquals("10", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, true, false); assertEquals("10", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, true); assertEquals("10", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("10", f.print(new Partial(fields, values))); assertEquals(0, types.size()); } //----------------------------------------------------------------------- public void testForFields_time_MSm() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond(), }; int[] values = new int[] {20, 30, 40}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true); assertEquals("-20:30.040", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, true, false); assertEquals("-20:30.040", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, true); assertEquals("-2030.040", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("-2030.040", f.print(new Partial(fields, values))); assertEquals(0, types.size()); } //----------------------------------------------------------------------- public void testForFields_time_MS() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), }; int[] values = new int[] {20, 30}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true); assertEquals("-20:30", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, true, false); assertEquals("-20:30", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, true); assertEquals("-2030", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("-2030", f.print(new Partial(fields, values))); assertEquals(0, types.size()); } //----------------------------------------------------------------------- public void testForFields_time_M() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.minuteOfHour(), }; int[] values = new int[] {20}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true); assertEquals("-20", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, true, false); assertEquals("-20", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, true); assertEquals("-20", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("-20", f.print(new Partial(fields, values))); assertEquals(0, types.size()); } //----------------------------------------------------------------------- public void testForFields_time_Sm() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond(), }; int[] values = new int[] {30, 40}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true); assertEquals("--30.040", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, true, false); assertEquals("--30.040", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, true); assertEquals("--30.040", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("--30.040", f.print(new Partial(fields, values))); assertEquals(0, types.size()); } //----------------------------------------------------------------------- public void testForFields_time_S() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.secondOfMinute(), }; int[] values = new int[] {30}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true); assertEquals("--30", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, true, false); assertEquals("--30", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, true); assertEquals("--30", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("--30", f.print(new Partial(fields, values))); assertEquals(0, types.size()); } //----------------------------------------------------------------------- public void testForFields_time_m() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.millisOfSecond(), }; int[] values = new int[] {40}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, false); assertEquals("---.040", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("---.040", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); try { ISODateTimeFormat.forFields(types, true, true); fail(); } catch (IllegalArgumentException ex) {} types = new ArrayList(Arrays.asList(fields)); try { ISODateTimeFormat.forFields(types, false, true); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testForFields_time_Hm() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.millisOfSecond(), }; int[] values = new int[] {10, 40}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, false); assertEquals("10--.040", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("10--.040", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); try { ISODateTimeFormat.forFields(types, true, true); fail(); } catch (IllegalArgumentException ex) {} types = new ArrayList(Arrays.asList(fields)); try { ISODateTimeFormat.forFields(types, false, true); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testForFields_time_HS() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.secondOfMinute(), }; int[] values = new int[] {10, 30}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, false); assertEquals("10-30", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("10-30", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); try { ISODateTimeFormat.forFields(types, true, true); fail(); } catch (IllegalArgumentException ex) {} types = new ArrayList(Arrays.asList(fields)); try { ISODateTimeFormat.forFields(types, false, true); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testForFields_time_Mm() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.minuteOfHour(), DateTimeFieldType.millisOfSecond(), }; int[] values = new int[] {20, 40}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, false); assertEquals("-20-.040", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("-20-.040", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); try { ISODateTimeFormat.forFields(types, true, true); fail(); } catch (IllegalArgumentException ex) {} types = new ArrayList(Arrays.asList(fields)); try { ISODateTimeFormat.forFields(types, false, true); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testForFields_time_HSm() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond(), }; int[] values = new int[] {10, 30, 40}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, false); assertEquals("10-30.040", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("10-30.040", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); try { ISODateTimeFormat.forFields(types, true, true); fail(); } catch (IllegalArgumentException ex) {} types = new ArrayList(Arrays.asList(fields)); try { ISODateTimeFormat.forFields(types, false, true); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testForFields_time_HMm() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.millisOfSecond(), }; int[] values = new int[] {10, 20, 40}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, false); assertEquals("10:20-.040", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("1020-.040", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); try { ISODateTimeFormat.forFields(types, true, true); fail(); } catch (IllegalArgumentException ex) {} types = new ArrayList(Arrays.asList(fields)); try { ISODateTimeFormat.forFields(types, false, true); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- //----------------------------------------------------------------------- //----------------------------------------------------------------------- public void testForFields_datetime_YMDH() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.hourOfDay(), }; int[] values = new int[] {2005, 6, 25, 12}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true); assertEquals("2005-06-25T12", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, true, false); assertEquals("2005-06-25T12", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, true); assertEquals("20050625T12", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("20050625T12", f.print(new Partial(fields, values))); assertEquals(0, types.size()); } //----------------------------------------------------------------------- public void testForFields_datetime_DH() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.dayOfMonth(), DateTimeFieldType.hourOfDay(), }; int[] values = new int[] {25, 12}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true); assertEquals("---25T12", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, true, false); assertEquals("---25T12", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, true); assertEquals("---25T12", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("---25T12", f.print(new Partial(fields, values))); assertEquals(0, types.size()); } //----------------------------------------------------------------------- public void testForFields_datetime_YH() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.hourOfDay(), }; int[] values = new int[] {2005, 12}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, false); assertEquals("2005T12", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("2005T12", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); try { ISODateTimeFormat.forFields(types, true, true); fail(); } catch (IllegalArgumentException ex) {} types = new ArrayList(Arrays.asList(fields)); try { ISODateTimeFormat.forFields(types, false, true); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testForFields_datetime_DM() { DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.dayOfMonth(), DateTimeFieldType.minuteOfHour(), }; int[] values = new int[] {25, 20}; List types = new ArrayList(Arrays.asList(fields)); DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, false); assertEquals("---25T-20", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); f = ISODateTimeFormat.forFields(types, false, false); assertEquals("---25T-20", f.print(new Partial(fields, values))); assertEquals(0, types.size()); types = new ArrayList(Arrays.asList(fields)); try { ISODateTimeFormat.forFields(types, true, true); fail(); } catch (IllegalArgumentException ex) {} types = new ArrayList(Arrays.asList(fields)); try { ISODateTimeFormat.forFields(types, false, true); fail(); } catch (IllegalArgumentException ex) {} } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.format; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.DateTimeConstants; import org.joda.time.DateTimeUtils; import org.joda.time.DateTimeZone; import org.joda.time.Period; import org.joda.time.PeriodType; /** * This class is a Junit unit test for ISOPeriodFormat. * * @author Stephen Colebourne */ public class TestISOPeriodFormat extends TestCase { private static final Period PERIOD = new Period(1, 2, 3, 4, 5, 6, 7, 8); private static final Period EMPTY_PERIOD = new Period(0, 0, 0, 0, 0, 0, 0, 0); private static final Period YEAR_DAY_PERIOD = new Period(1, 0, 0, 4, 5, 6, 7, 8, PeriodType.yearDayTime()); private static final Period EMPTY_YEAR_DAY_PERIOD = new Period(0, 0, 0, 0, 0, 0, 0, 0, PeriodType.yearDayTime()); private static final Period TIME_PERIOD = new Period(0, 0, 0, 0, 5, 6, 7, 8); private static final Period DATE_PERIOD = new Period(1, 2, 3, 4, 0, 0, 0, 0); private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestISOPeriodFormat.class); } public TestISOPeriodFormat(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testSubclassableConstructor() { ISOPeriodFormat f = new ISOPeriodFormat() { // test constructor is protected }; assertNotNull(f); } //----------------------------------------------------------------------- public void testFormatStandard() { Period p = new Period(1, 2, 3, 4, 5, 6, 7, 8); assertEquals("P1Y2M3W4DT5H6M7.008S", ISOPeriodFormat.standard().print(p)); p = new Period(1, 2, 3, 4, 5, 6 ,7, 0); assertEquals("P1Y2M3W4DT5H6M7S", ISOPeriodFormat.standard().print(p)); p = new Period(0); assertEquals("PT0S", ISOPeriodFormat.standard().print(p)); p = new Period(0, PeriodType.standard().withMillisRemoved().withSecondsRemoved()); assertEquals("PT0M", ISOPeriodFormat.standard().print(p)); assertEquals("P1Y4DT5H6M7.008S", ISOPeriodFormat.standard().print(YEAR_DAY_PERIOD)); assertEquals("PT0S", ISOPeriodFormat.standard().print(EMPTY_YEAR_DAY_PERIOD)); assertEquals("P1Y2M3W4D", ISOPeriodFormat.standard().print(DATE_PERIOD)); assertEquals("PT5H6M7.008S", ISOPeriodFormat.standard().print(TIME_PERIOD)); } public void testFormatStandard_negative() { Period p = new Period(-1, -2, -3, -4, -5, -6, -7, -8); assertEquals("P-1Y-2M-3W-4DT-5H-6M-7.008S", ISOPeriodFormat.standard().print(p)); p = Period.years(-54); assertEquals("P-54Y", ISOPeriodFormat.standard().print(p)); p = Period.seconds(4).withMillis(-8); assertEquals("PT3.992S", ISOPeriodFormat.standard().print(p)); p = Period.seconds(-4).withMillis(8); assertEquals("PT-3.992S", ISOPeriodFormat.standard().print(p)); p = Period.seconds(-23); assertEquals("PT-23S", ISOPeriodFormat.standard().print(p)); p = Period.millis(-8); assertEquals("PT-0.008S", ISOPeriodFormat.standard().print(p)); } //----------------------------------------------------------------------- public void testFormatAlternate() { Period p = new Period(1, 2, 3, 4, 5, 6 ,7, 8); assertEquals("P00010204T050607.008", ISOPeriodFormat.alternate().print(p)); p = new Period(1, 2, 3, 4, 5, 6 ,7, 0); assertEquals("P00010204T050607", ISOPeriodFormat.alternate().print(p)); p = new Period(0); assertEquals("P00000000T000000", ISOPeriodFormat.alternate().print(p)); p = new Period(0, PeriodType.standard().withMillisRemoved().withSecondsRemoved()); assertEquals("P00000000T000000", ISOPeriodFormat.alternate().print(p)); assertEquals("P00010004T050607.008", ISOPeriodFormat.alternate().print(YEAR_DAY_PERIOD)); assertEquals("P00000000T000000", ISOPeriodFormat.alternate().print(EMPTY_YEAR_DAY_PERIOD)); assertEquals("P00010204T000000", ISOPeriodFormat.alternate().print(DATE_PERIOD)); assertEquals("P00000000T050607.008", ISOPeriodFormat.alternate().print(TIME_PERIOD)); } //----------------------------------------------------------------------- public void testFormatAlternateExtended() { Period p = new Period(1, 2, 3, 4, 5, 6 ,7, 8); assertEquals("P0001-02-04T05:06:07.008", ISOPeriodFormat.alternateExtended().print(p)); p = new Period(1, 2, 3, 4, 5, 6 ,7, 0); assertEquals("P0001-02-04T05:06:07", ISOPeriodFormat.alternateExtended().print(p)); p = new Period(0); assertEquals("P0000-00-00T00:00:00", ISOPeriodFormat.alternateExtended().print(p)); p = new Period(0, PeriodType.standard().withMillisRemoved().withSecondsRemoved()); assertEquals("P0000-00-00T00:00:00", ISOPeriodFormat.alternateExtended().print(p)); assertEquals("P0001-00-04T05:06:07.008", ISOPeriodFormat.alternateExtended().print(YEAR_DAY_PERIOD)); assertEquals("P0000-00-00T00:00:00", ISOPeriodFormat.alternateExtended().print(EMPTY_YEAR_DAY_PERIOD)); assertEquals("P0001-02-04T00:00:00", ISOPeriodFormat.alternateExtended().print(DATE_PERIOD)); assertEquals("P0000-00-00T05:06:07.008", ISOPeriodFormat.alternateExtended().print(TIME_PERIOD)); } //----------------------------------------------------------------------- public void testFormatAlternateWithWeeks() { Period p = new Period(1, 2, 3, 4, 5, 6 ,7, 8); assertEquals("P0001W0304T050607.008", ISOPeriodFormat.alternateWithWeeks().print(p)); p = new Period(1, 2, 3, 4, 5, 6 ,7, 0); assertEquals("P0001W0304T050607", ISOPeriodFormat.alternateWithWeeks().print(p)); p = new Period(0); assertEquals("P0000W0000T000000", ISOPeriodFormat.alternateWithWeeks().print(p)); p = new Period(0, PeriodType.standard().withMillisRemoved().withSecondsRemoved()); assertEquals("P0000W0000T000000", ISOPeriodFormat.alternateWithWeeks().print(p)); assertEquals("P0001W0004T050607.008", ISOPeriodFormat.alternateWithWeeks().print(YEAR_DAY_PERIOD)); assertEquals("P0000W0000T000000", ISOPeriodFormat.alternateWithWeeks().print(EMPTY_YEAR_DAY_PERIOD)); assertEquals("P0001W0304T000000", ISOPeriodFormat.alternateWithWeeks().print(DATE_PERIOD)); assertEquals("P0000W0000T050607.008", ISOPeriodFormat.alternateWithWeeks().print(TIME_PERIOD)); } //----------------------------------------------------------------------- public void testFormatAlternateExtendedWithWeeks() { Period p = new Period(1, 2, 3, 4, 5, 6 ,7, 8); assertEquals("P0001-W03-04T05:06:07.008", ISOPeriodFormat.alternateExtendedWithWeeks().print(p)); p = new Period(1, 2, 3, 4, 5, 6 ,7, 0); assertEquals("P0001-W03-04T05:06:07", ISOPeriodFormat.alternateExtendedWithWeeks().print(p)); p = new Period(0); assertEquals("P0000-W00-00T00:00:00", ISOPeriodFormat.alternateExtendedWithWeeks().print(p)); p = new Period(0, PeriodType.standard().withMillisRemoved().withSecondsRemoved()); assertEquals("P0000-W00-00T00:00:00", ISOPeriodFormat.alternateExtendedWithWeeks().print(p)); assertEquals("P0001-W00-04T05:06:07.008", ISOPeriodFormat.alternateExtendedWithWeeks().print(YEAR_DAY_PERIOD)); assertEquals("P0000-W00-00T00:00:00", ISOPeriodFormat.alternateExtendedWithWeeks().print(EMPTY_YEAR_DAY_PERIOD)); assertEquals("P0001-W03-04T00:00:00", ISOPeriodFormat.alternateExtendedWithWeeks().print(DATE_PERIOD)); assertEquals("P0000-W00-00T05:06:07.008", ISOPeriodFormat.alternateExtendedWithWeeks().print(TIME_PERIOD)); } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.format; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.DateTimeConstants; import org.joda.time.DateTimeUtils; import org.joda.time.DateTimeZone; import org.joda.time.Period; import org.joda.time.PeriodType; /** * This class is a Junit unit test for ISOPeriodFormat. * * @author Stephen Colebourne */ public class TestISOPeriodFormatParsing extends TestCase { private static final Period PERIOD = new Period(1, 2, 3, 4, 5, 6, 7, 8); private static final Period EMPTY_PERIOD = new Period(0, 0, 0, 0, 0, 0, 0, 0); private static final Period YEAR_DAY_PERIOD = new Period(1, 0, 0, 4, 5, 6, 7, 8, PeriodType.yearDayTime()); private static final Period EMPTY_YEAR_DAY_PERIOD = new Period(0, 0, 0, 0, 0, 0, 0, 0, PeriodType.yearDayTime()); private static final Period TIME_PERIOD = new Period(0, 0, 0, 0, 5, 6, 7, 8); private static final Period DATE_PERIOD = new Period(1, 2, 3, 4, 0, 0, 0, 0); private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L - 1L) * DateTimeConstants.MILLIS_PER_DAY; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestISOPeriodFormatParsing.class); } public TestISOPeriodFormatParsing(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testParseStandard1() { PeriodFormatter parser = ISOPeriodFormat.standard(); Period p = parser.parsePeriod("P1Y2M3W4DT5H6M7.008S"); assertEquals(new Period(1, 2, 3, 4, 5, 6, 7, 8), p); } //----------------------------------------------------------------------- public void testParseStandard2() { PeriodFormatter parser = ISOPeriodFormat.standard(); Period p = parser.parsePeriod("P0Y0M0W0DT5H6M7.008S"); assertEquals(new Period(0, 0, 0, 0, 5, 6, 7, 8), p); } //----------------------------------------------------------------------- public void testParseStandard3() { PeriodFormatter parser = ISOPeriodFormat.standard(); Period p = parser.parsePeriod("P0DT5H6M7.008S"); assertEquals(new Period(0, 0, 0, 0, 5, 6, 7, 8), p); } //----------------------------------------------------------------------- public void testParseStandard4() { PeriodFormatter parser = ISOPeriodFormat.standard(); Period p = parser.parsePeriod("P2Y3DT5H6M7.008S"); assertEquals(new Period(2, 0, 0, 3, 5, 6, 7, 8), p); } //----------------------------------------------------------------------- public void testParseStandard5() { PeriodFormatter parser = ISOPeriodFormat.standard(); Period p = parser.parsePeriod("P2YT5H6M7.008S"); assertEquals(new Period(2, 0, 0, 0, 5, 6, 7, 8), p); } //----------------------------------------------------------------------- public void testParseStandard6() { PeriodFormatter parser = ISOPeriodFormat.standard(); Period p = parser.parsePeriod("PT5H6M7.008S"); assertEquals(new Period(0, 0, 0, 0, 5, 6, 7, 8), p); } //----------------------------------------------------------------------- public void testParseStandard7() { PeriodFormatter parser = ISOPeriodFormat.standard(); Period p = parser.parsePeriod("P1Y2M3W4D"); assertEquals(new Period(1, 2, 3, 4, 0, 0, 0, 0), p); } //----------------------------------------------------------------------- public void testParseStandard8() { PeriodFormatter parser = ISOPeriodFormat.standard(); Period p = parser.parsePeriod("PT5H6M7S"); assertEquals(new Period(0, 0, 0, 0, 5, 6, 7, 0), p); } //----------------------------------------------------------------------- public void testParseStandard9() { PeriodFormatter parser = ISOPeriodFormat.standard(); Period p = parser.parsePeriod("PT0S"); assertEquals(new Period(0, 0, 0, 0, 0, 0, 0, 0), p); } //----------------------------------------------------------------------- public void testParseStandard10() { PeriodFormatter parser = ISOPeriodFormat.standard(); Period p = parser.parsePeriod("P0D"); assertEquals(new Period(0, 0, 0, 0, 0, 0, 0, 0), p); } //----------------------------------------------------------------------- public void testParseStandard11() { PeriodFormatter parser = ISOPeriodFormat.standard(); Period p = parser.parsePeriod("P0Y"); assertEquals(new Period(0, 0, 0, 0, 0, 0, 0, 0), p); } //----------------------------------------------------------------------- public void testParseStandardFail1() { PeriodFormatter parser = ISOPeriodFormat.standard(); try { parser.parsePeriod("P1Y2S"); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testParseStandardFail2() { PeriodFormatter parser = ISOPeriodFormat.standard(); try { parser.parsePeriod("PS"); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testParseStandardFail3() { PeriodFormatter parser = ISOPeriodFormat.standard(); try { parser.parsePeriod("PTS"); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testParseStandardFail4() { PeriodFormatter parser = ISOPeriodFormat.standard(); try { parser.parsePeriod("PXS"); fail(); } catch (IllegalArgumentException ex) {} } }
/* * Copyright 2001-2012 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.format; import java.util.Locale; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.Period; /** * This class is a Junit unit test for PeriodFormat. * * @author Stephen Colebourne */ public class TestPeriodFormat extends TestCase { private static final Locale EN = new Locale("en"); private static final Locale FR = new Locale("fr"); private static final Locale PT = new Locale("pt"); private static final Locale ES = new Locale("es"); private static final Locale DE = new Locale("de"); private static final Locale NL = new Locale("nl"); private static final Locale DA = new Locale("da"); private static final Locale JA = new Locale("ja"); private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestPeriodFormat.class); } public TestPeriodFormat(String name) { super(name); } protected void setUp() throws Exception { originalLocale = Locale.getDefault(); Locale.setDefault(DE); } protected void tearDown() throws Exception { Locale.setDefault(originalLocale); originalLocale = null; } //----------------------------------------------------------------------- public void testSubclassableConstructor() { PeriodFormat f = new PeriodFormat() { // test constructor is protected }; assertNotNull(f); } //----------------------------------------------------------------------- // getDefault() //----------------------------------------------------------------------- public void test_getDefault_formatStandard() { Period p = new Period(0, 0, 0, 1, 5, 6 ,7, 8); assertEquals("1 day, 5 hours, 6 minutes, 7 seconds and 8 milliseconds", PeriodFormat.getDefault().print(p)); } //----------------------------------------------------------------------- public void test_getDefault_FormatOneField() { Period p = Period.days(2); assertEquals("2 days", PeriodFormat.getDefault().print(p)); } //----------------------------------------------------------------------- public void test_getDefault_formatTwoFields() { Period p = Period.days(2).withHours(5); assertEquals("2 days and 5 hours", PeriodFormat.getDefault().print(p)); } //----------------------------------------------------------------------- public void test_getDefault_parseOneField() { Period p = Period.days(2); assertEquals(p, PeriodFormat.getDefault().parsePeriod("2 days")); } //----------------------------------------------------------------------- public void test_getDefault_parseTwoFields() { Period p = Period.days(2).withHours(5); assertEquals(p, PeriodFormat.getDefault().parsePeriod("2 days and 5 hours")); } //----------------------------------------------------------------------- public void test_getDefault_checkRedundantSeparator() { try { PeriodFormat.getDefault().parsePeriod("2 days and 5 hours "); fail("No exception was caught"); } catch (Exception e) { assertEquals(IllegalArgumentException.class, e.getClass()); } } //----------------------------------------------------------------------- public void test_getDefault_cached() { assertSame(PeriodFormat.getDefault(), PeriodFormat.getDefault()); } //----------------------------------------------------------------------- // wordBased() - default locale (de) //----------------------------------------------------------------------- public void test_wordBased_default() { Period p = new Period(0, 0, 0, 1, 5, 6 ,7, 8); assertEquals("1 Tag, 5 Stunden, 6 Minuten, 7 Sekunden und 8 Millisekunden", PeriodFormat.wordBased().print(p)); } //----------------------------------------------------------------------- // wordBased(Locale.FRENCH) //----------------------------------------------------------------------- public void test_wordBased_fr_formatStandard() { Period p = new Period(0, 0, 0, 1, 5, 6 ,7, 8); assertEquals("1 jour, 5 heures, 6 minutes, 7 secondes et 8 millisecondes", PeriodFormat.wordBased(FR).print(p)); } //----------------------------------------------------------------------- public void test_wordBased_fr_FormatOneField() { Period p = Period.days(2); assertEquals("2 jours", PeriodFormat.wordBased(FR).print(p)); } //----------------------------------------------------------------------- public void test_wordBased_fr_formatTwoFields() { Period p = Period.days(2).withHours(5); assertEquals("2 jours et 5 heures", PeriodFormat.wordBased(FR).print(p)); } //----------------------------------------------------------------------- public void test_wordBased_fr_parseOneField() { Period p = Period.days(2); assertEquals(p, PeriodFormat.wordBased(FR).parsePeriod("2 jours")); } //----------------------------------------------------------------------- public void test_wordBased_fr_parseTwoFields() { Period p = Period.days(2).withHours(5); assertEquals(p, PeriodFormat.wordBased(FR).parsePeriod("2 jours et 5 heures")); } //----------------------------------------------------------------------- public void test_wordBased_fr_cached() { assertSame(PeriodFormat.wordBased(FR), PeriodFormat.wordBased(FR)); } //----------------------------------------------------------------------- // wordBased(Locale pt) //----------------------------------------------------------------------- public void test_wordBased_pt_formatStandard() { Period p = new Period(0, 0, 0, 1, 5, 6 ,7, 8); assertEquals("1 dia, 5 horas, 6 minutos, 7 segundos e 8 milissegundos", PeriodFormat.wordBased(PT).print(p)); } //----------------------------------------------------------------------- public void test_wordBased_pt_FormatOneField() { Period p = Period.days(2); assertEquals("2 dias", PeriodFormat.wordBased(PT).print(p)); } //----------------------------------------------------------------------- public void test_wordBased_pt_formatTwoFields() { Period p = Period.days(2).withHours(5); assertEquals("2 dias e 5 horas", PeriodFormat.wordBased(PT).print(p)); } //----------------------------------------------------------------------- public void test_wordBased_pt_parseOneField() { Period p = Period.days(2); assertEquals(p, PeriodFormat.wordBased(PT).parsePeriod("2 dias")); } //----------------------------------------------------------------------- public void test_wordBased_pt_parseTwoFields() { Period p = Period.days(2).withHours(5); assertEquals(p, PeriodFormat.wordBased(PT).parsePeriod("2 dias e 5 horas")); } //----------------------------------------------------------------------- public void test_wordBased_pt_cached() { assertSame(PeriodFormat.wordBased(PT), PeriodFormat.wordBased(PT)); } //----------------------------------------------------------------------- // wordBased(Locale es) //----------------------------------------------------------------------- public void test_wordBased_es_formatStandard() { Period p = new Period(0, 0, 0, 1, 5, 6 ,7, 8); assertEquals("1 d\u00EDa, 5 horas, 6 minutos, 7 segundos y 8 milisegundos", PeriodFormat.wordBased(ES).print(p)); } //----------------------------------------------------------------------- public void test_wordBased_es_FormatOneField() { Period p = Period.days(2); assertEquals("2 d\u00EDas", PeriodFormat.wordBased(ES).print(p)); } //----------------------------------------------------------------------- public void test_wordBased_es_formatTwoFields() { Period p = Period.days(2).withHours(5); assertEquals("2 d\u00EDas y 5 horas", PeriodFormat.wordBased(ES).print(p)); } //----------------------------------------------------------------------- public void test_wordBased_es_parseOneField() { Period p = Period.days(2); assertEquals(p, PeriodFormat.wordBased(ES).parsePeriod("2 d\u00EDas")); } //----------------------------------------------------------------------- public void test_wordBased_es_parseTwoFields() { Period p = Period.days(2).withHours(5); assertEquals(p, PeriodFormat.wordBased(ES).parsePeriod("2 d\u00EDas y 5 horas")); } //----------------------------------------------------------------------- public void test_wordBased_es_cached() { assertSame(PeriodFormat.wordBased(ES), PeriodFormat.wordBased(ES)); } //----------------------------------------------------------------------- // wordBased(Locale de) //----------------------------------------------------------------------- public void test_wordBased_de_formatStandard() { Period p = new Period(0, 0, 0, 1, 5, 6 ,7, 8); assertEquals("1 Tag, 5 Stunden, 6 Minuten, 7 Sekunden und 8 Millisekunden", PeriodFormat.wordBased(DE).print(p)); } //----------------------------------------------------------------------- public void test_wordBased_de_FormatOneField() { Period p = Period.days(2); assertEquals("2 Tage", PeriodFormat.wordBased(DE).print(p)); } //----------------------------------------------------------------------- public void test_wordBased_de_formatTwoFields() { Period p = Period.days(2).withHours(5); assertEquals("2 Tage und 5 Stunden", PeriodFormat.wordBased(DE).print(p)); } //----------------------------------------------------------------------- public void test_wordBased_de_parseOneField() { Period p = Period.days(2); assertEquals(p, PeriodFormat.wordBased(DE).parsePeriod("2 Tage")); } //----------------------------------------------------------------------- public void test_wordBased_de_parseTwoFields() { Period p = Period.days(2).withHours(5); assertEquals(p, PeriodFormat.wordBased(DE).parsePeriod("2 Tage und 5 Stunden")); } //----------------------------------------------------------------------- public void test_wordBased_de_cached() { assertSame(PeriodFormat.wordBased(DE), PeriodFormat.wordBased(DE)); } //----------------------------------------------------------------------- // wordBased(Locale nl) //----------------------------------------------------------------------- public void test_wordBased_nl_formatStandard() { Period p = new Period(0, 0, 0, 1, 5, 6 ,7, 8); assertEquals("1 dag, 5 uur, 6 minuten, 7 seconden en 8 milliseconden", PeriodFormat.wordBased(NL).print(p)); } //----------------------------------------------------------------------- public void test_wordBased_nl_FormatOneField() { Period p = Period.days(2); assertEquals("2 dagen", PeriodFormat.wordBased(NL).print(p)); } //----------------------------------------------------------------------- public void test_wordBased_nl_formatTwoFields() { Period p = Period.days(2).withHours(5); assertEquals("2 dagen en 5 uur", PeriodFormat.wordBased(NL).print(p)); } //----------------------------------------------------------------------- public void test_wordBased_nl_parseOneField() { Period p = Period.days(2); assertEquals(p, PeriodFormat.wordBased(NL).parsePeriod("2 dagen")); } //----------------------------------------------------------------------- public void test_wordBased_nl_parseTwoFields() { Period p = Period.days(2).withHours(5); assertEquals(p, PeriodFormat.wordBased(NL).parsePeriod("2 dagen en 5 uur")); } //----------------------------------------------------------------------- public void test_wordBased_nl_cached() { assertSame(PeriodFormat.wordBased(NL), PeriodFormat.wordBased(NL)); } //----------------------------------------------------------------------- // wordBased(Locale da) //----------------------------------------------------------------------- public void test_wordBased_da_formatMultiple() { Period p = new Period(2, 3, 4, 2, 5, 6 ,7, 8); assertEquals("2 \u00E5r, 3 m\u00E5neder, 4 uger, 2 dage, 5 timer, 6 minutter, 7 sekunder og 8 millisekunder", PeriodFormat.wordBased(DA).print(p)); } //----------------------------------------------------------------------- public void test_wordBased_da_formatSinglular() { Period p = new Period(1, 1, 1, 1, 1, 1, 1, 1); assertEquals("1 \u00E5r, 1 m\u00E5ned, 1 uge, 1 dag, 1 time, 1 minut, 1 sekund og 1 millisekund", PeriodFormat.wordBased(DA).print(p)); } //----------------------------------------------------------------------- public void test_wordBased_da_cached() { assertSame(PeriodFormat.wordBased(DA), PeriodFormat.wordBased(DA)); } //----------------------------------------------------------------------- // wordBased(Locale ja) //----------------------------------------------------------------------- public void test_wordBased_ja_formatMultiple() { Period p = new Period(2, 3, 4, 2, 5, 6 ,7, 8); assertEquals("2\u5E743\u304B\u67084\u9031\u95932\u65E55\u6642\u95936\u52067\u79D28\u30DF\u30EA\u79D2", PeriodFormat.wordBased(JA).print(p)); } //----------------------------------------------------------------------- public void test_wordBased_ja_formatSingular() { Period p = new Period(1, 1, 1, 1, 1, 1, 1, 1); assertEquals("1\u5E741\u304B\u67081\u9031\u95931\u65E51\u6642\u95931\u52061\u79D21\u30DF\u30EA\u79D2", PeriodFormat.wordBased(JA).print(p)); } //----------------------------------------------------------------------- public void test_wordBased_ja_cached() { assertSame(PeriodFormat.wordBased(JA), PeriodFormat.wordBased(JA)); } //----------------------------------------------------------------------- public void test_wordBased_ja_parseOneField() { Period p = Period.days(2); assertEquals(p, PeriodFormat.wordBased(JA).parsePeriod("2\u65E5")); } //----------------------------------------------------------------------- public void test_wordBased_ja_parseTwoFields() { Period p = Period.days(2).withHours(5); assertEquals(p, PeriodFormat.wordBased(JA).parsePeriod("2\u65E55\u6642\u9593")); } //----------------------------------------------------------------------- public void test_wordBased_ja_checkRedundantSeparator() { try { // Spaces are not valid separators in Japanese PeriodFormat.wordBased(JA).parsePeriod("2\u65E5 "); fail("No exception was caught"); } catch (Exception e) { assertEquals(IllegalArgumentException.class, e.getClass()); } } //----------------------------------------------------------------------- // Cross check languages //----------------------------------------------------------------------- public void test_wordBased_fr_from_de() { Locale.setDefault(DE); Period p = new Period(0, 0, 0, 1, 5, 6 ,7, 8); assertEquals("1 jour, 5 heures, 6 minutes, 7 secondes et 8 millisecondes", PeriodFormat.wordBased(FR).print(p)); } public void test_wordBased_fr_from_nl() { Locale.setDefault(NL); Period p = new Period(0, 0, 0, 1, 5, 6 ,7, 8); assertEquals("1 jour, 5 heures, 6 minutes, 7 secondes et 8 millisecondes", PeriodFormat.wordBased(FR).print(p)); } public void test_wordBased_en_from_de() { Locale.setDefault(DE); Period p = new Period(0, 0, 0, 1, 5, 6 ,7, 8); assertEquals("1 day, 5 hours, 6 minutes, 7 seconds and 8 milliseconds", PeriodFormat.wordBased(EN).print(p)); } public void test_wordBased_en_from_nl() { Locale.setDefault(NL); Period p = new Period(0, 0, 0, 1, 5, 6 ,7, 8); assertEquals("1 day, 5 hours, 6 minutes, 7 seconds and 8 milliseconds", PeriodFormat.wordBased(EN).print(p)); } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.format; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.DateTimeConstants; import org.joda.time.DateTimeUtils; import org.joda.time.DateTimeZone; import org.joda.time.Period; import org.joda.time.PeriodType; /** * This class is a Junit unit test for PeriodFormat. * * @author Stephen Colebourne */ public class TestPeriodFormatParsing extends TestCase { private static final Period PERIOD = new Period(1, 2, 3, 4, 5, 6, 7, 8); private static final Period EMPTY_PERIOD = new Period(0, 0, 0, 0, 0, 0, 0, 0); private static final Period YEAR_DAY_PERIOD = new Period(1, 0, 0, 4, 5, 6, 7, 8, PeriodType.yearDayTime()); private static final Period EMPTY_YEAR_DAY_PERIOD = new Period(0, 0, 0, 0, 0, 0, 0, 0, PeriodType.yearDayTime()); private static final Period TIME_PERIOD = new Period(0, 0, 0, 0, 5, 6, 7, 8); private static final Period DATE_PERIOD = new Period(1, 2, 3, 4, 0, 0, 0, 0); private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L - 1L) * DateTimeConstants.MILLIS_PER_DAY; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestPeriodFormatParsing.class); } public TestPeriodFormatParsing(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testParseStandard1() {} // Defects4J: flaky method // public void testParseStandard1() { // PeriodFormatter parser = PeriodFormat.getDefault(); // Period p = parser.parsePeriod("6 years, 3 months and 2 days"); // assertEquals(new Period(6, 3, 0, 2, 0, 0, 0, 0), p); // } public void testParseCustom1() { PeriodFormatter formatter = new PeriodFormatterBuilder() .printZeroAlways() .appendHours() .appendSuffix(":") .minimumPrintedDigits(2) .appendMinutes() .toFormatter(); Period p; p = new Period(47, 55, 0, 0); assertEquals("47:55", formatter.print(p)); assertEquals(p, formatter.parsePeriod("47:55")); assertEquals(p, formatter.parsePeriod("047:055")); p = new Period(7, 5, 0, 0); assertEquals("7:05", formatter.print(p)); assertEquals(p, formatter.parsePeriod("7:05")); assertEquals(p, formatter.parsePeriod("7:5")); assertEquals(p, formatter.parsePeriod("07:05")); p = new Period(0, 5, 0, 0); assertEquals("0:05", formatter.print(p)); assertEquals(p, formatter.parsePeriod("0:05")); assertEquals(p, formatter.parsePeriod("0:5")); assertEquals(p, formatter.parsePeriod("00:005")); assertEquals(p, formatter.parsePeriod("0:005")); p = new Period(0, 0, 0, 0); assertEquals("0:00", formatter.print(p)); assertEquals(p, formatter.parsePeriod("0:00")); assertEquals(p, formatter.parsePeriod("0:0")); assertEquals(p, formatter.parsePeriod("00:00")); } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.format; import java.io.CharArrayWriter; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.Chronology; import org.joda.time.DateTimeConstants; import org.joda.time.DateTimeUtils; import org.joda.time.DateTimeZone; import org.joda.time.MutablePeriod; import org.joda.time.Period; import org.joda.time.PeriodType; import org.joda.time.chrono.BuddhistChronology; import org.joda.time.chrono.ISOChronology; /** * This class is a Junit unit test for Period Formating. * * @author Stephen Colebourne */ public class TestPeriodFormatter extends TestCase { private static final DateTimeZone UTC = DateTimeZone.UTC; private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo"); private static final DateTimeZone NEWYORK = DateTimeZone.forID("America/New_York"); private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC(); private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS); private static final Chronology BUDDHIST_PARIS = BuddhistChronology.getInstance(PARIS); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; private PeriodFormatter f = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestPeriodFormatter.class); } public TestPeriodFormatter(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); f = ISOPeriodFormat.standard(); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; f = null; } //----------------------------------------------------------------------- public void testPrint_simple() { Period p = new Period(1, 2, 3, 4, 5, 6, 7, 8); assertEquals("P1Y2M3W4DT5H6M7.008S", f.print(p)); } //----------------------------------------------------------------------- public void testPrint_bufferMethods() throws Exception { Period p = new Period(1, 2, 3, 4, 5, 6, 7, 8); StringBuffer buf = new StringBuffer(); f.printTo(buf, p); assertEquals("P1Y2M3W4DT5H6M7.008S", buf.toString()); buf = new StringBuffer(); try { f.printTo(buf, null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testPrint_writerMethods() throws Exception { Period p = new Period(1, 2, 3, 4, 5, 6, 7, 8); CharArrayWriter out = new CharArrayWriter(); f.printTo(out, p); assertEquals("P1Y2M3W4DT5H6M7.008S", out.toString()); out = new CharArrayWriter(); try { f.printTo(out, null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testWithGetLocaleMethods() { PeriodFormatter f2 = f.withLocale(Locale.FRENCH); assertEquals(Locale.FRENCH, f2.getLocale()); assertSame(f2, f2.withLocale(Locale.FRENCH)); f2 = f.withLocale(null); assertEquals(null, f2.getLocale()); assertSame(f2, f2.withLocale(null)); } public void testWithGetParseTypeMethods() { PeriodFormatter f2 = f.withParseType(PeriodType.dayTime()); assertEquals(PeriodType.dayTime(), f2.getParseType()); assertSame(f2, f2.withParseType(PeriodType.dayTime())); f2 = f.withParseType(null); assertEquals(null, f2.getParseType()); assertSame(f2, f2.withParseType(null)); } public void testPrinterParserMethods() { Period p = new Period(1, 2, 3, 4, 5, 6, 7, 8); PeriodFormatter f2 = new PeriodFormatter(f.getPrinter(), f.getParser()); assertEquals(f.getPrinter(), f2.getPrinter()); assertEquals(f.getParser(), f2.getParser()); assertEquals(true, f2.isPrinter()); assertEquals(true, f2.isParser()); assertNotNull(f2.print(p)); assertNotNull(f2.parsePeriod("P1Y2M3W4DT5H6M7.008S")); f2 = new PeriodFormatter(f.getPrinter(), null); assertEquals(f.getPrinter(), f2.getPrinter()); assertEquals(null, f2.getParser()); assertEquals(true, f2.isPrinter()); assertEquals(false, f2.isParser()); assertNotNull(f2.print(p)); try { assertNotNull(f2.parsePeriod("P1Y2M3W4DT5H6M7.008S")); fail(); } catch (UnsupportedOperationException ex) {} f2 = new PeriodFormatter(null, f.getParser()); assertEquals(null, f2.getPrinter()); assertEquals(f.getParser(), f2.getParser()); assertEquals(false, f2.isPrinter()); assertEquals(true, f2.isParser()); try { f2.print(p); fail(); } catch (UnsupportedOperationException ex) {} assertNotNull(f2.parsePeriod("P1Y2M3W4DT5H6M7.008S")); } //----------------------------------------------------------------------- public void testParsePeriod_simple() { Period expect = new Period(1, 2, 3, 4, 5, 6, 7, 8); assertEquals(expect, f.parsePeriod("P1Y2M3W4DT5H6M7.008S")); try { f.parsePeriod("ABC"); fail(); } catch (IllegalArgumentException ex) {} } public void testParsePeriod_parseType() { Period expect = new Period(0, 0, 0, 4, 5, 6, 7, 8, PeriodType.dayTime()); assertEquals(expect, f.withParseType(PeriodType.dayTime()).parsePeriod("P4DT5H6M7.008S")); try { f.withParseType(PeriodType.dayTime()).parsePeriod("P3W4DT5H6M7.008S"); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testParseMutablePeriod_simple() { MutablePeriod expect = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); assertEquals(expect, f.parseMutablePeriod("P1Y2M3W4DT5H6M7.008S")); try { f.parseMutablePeriod("ABC"); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testParseInto_simple() { MutablePeriod expect = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8); MutablePeriod result = new MutablePeriod(); assertEquals(20, f.parseInto(result, "P1Y2M3W4DT5H6M7.008S", 0)); assertEquals(expect, result); try { f.parseInto(null, "P1Y2M3W4DT5H6M7.008S", 0); fail(); } catch (IllegalArgumentException ex) {} assertEquals(~0, f.parseInto(result, "ABC", 0)); } }
/* * Copyright 2001-2006 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.format; import java.util.Locale; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.DateTimeConstants; import org.joda.time.DateTimeUtils; import org.joda.time.DateTimeZone; import org.joda.time.Period; import org.joda.time.PeriodType; /** * This class is a Junit unit test for PeriodFormatterBuilder. * * @author Stephen Colebourne */ public class TestPeriodFormatterBuilder extends TestCase { private static final Period PERIOD = new Period(1, 2, 3, 4, 5, 6, 7, 8); private static final Period EMPTY_PERIOD = new Period(0, 0, 0, 0, 0, 0, 0, 0); private static final Period YEAR_DAY_PERIOD = new Period(1, 0, 0, 4, 5, 6, 7, 8, PeriodType.yearDayTime()); private static final Period EMPTY_YEAR_DAY_PERIOD = new Period(0, 0, 0, 0, 0, 0, 0, 0, PeriodType.yearDayTime()); private static final Period TIME_PERIOD = new Period(0, 0, 0, 0, 5, 6, 7, 8); private static final Period DATE_PERIOD = new Period(1, 2, 3, 4, 0, 0, 0, 0); //private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris"); private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London"); //private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo"); long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365; // 2002-06-09 private long TEST_TIME_NOW = (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY; private DateTimeZone originalDateTimeZone = null; private TimeZone originalTimeZone = null; private Locale originalLocale = null; private PeriodFormatterBuilder builder; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestPeriodFormatterBuilder.class); } public TestPeriodFormatterBuilder(String name) { super(name); } protected void setUp() throws Exception { DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW); originalDateTimeZone = DateTimeZone.getDefault(); originalTimeZone = TimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(LONDON); TimeZone.setDefault(TimeZone.getTimeZone("Europe/London")); Locale.setDefault(Locale.UK); builder = new PeriodFormatterBuilder(); } protected void tearDown() throws Exception { DateTimeUtils.setCurrentMillisSystem(); DateTimeZone.setDefault(originalDateTimeZone); TimeZone.setDefault(originalTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testToFormatterPrinterParser() { builder.appendYears(); assertNotNull(builder.toFormatter()); assertNotNull(builder.toPrinter()); assertNotNull(builder.toParser()); } //----------------------------------------------------------------------- public void testFormatYears() { PeriodFormatter f = builder.appendYears().toFormatter(); assertEquals("1", f.print(PERIOD)); assertEquals(1, f.getPrinter().calculatePrintedLength(PERIOD, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null)); Period p = new Period(0, 0, 0, 0, 0, 0, 0, 0); assertEquals("0", f.print(p)); assertEquals(1, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); } public void testFormatMonths() { PeriodFormatter f = builder.appendMonths().toFormatter(); assertEquals("2", f.print(PERIOD)); assertEquals(1, f.getPrinter().calculatePrintedLength(PERIOD, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null)); Period p = new Period(0, 0, 0, 0, 0, 0, 0, 0); assertEquals("0", f.print(p)); assertEquals(1, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); } public void testFormatWeeks() { PeriodFormatter f = builder.appendWeeks().toFormatter(); assertEquals("3", f.print(PERIOD)); assertEquals(1, f.getPrinter().calculatePrintedLength(PERIOD, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null)); Period p = new Period(0, 0, 0, 0, 0, 0, 0, 0); assertEquals("0", f.print(p)); assertEquals(1, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); } public void testFormatDays() { PeriodFormatter f = builder.appendDays().toFormatter(); assertEquals("4", f.print(PERIOD)); assertEquals(1, f.getPrinter().calculatePrintedLength(PERIOD, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null)); Period p = new Period(0, 0, 0, 0, 0, 0, 0, 0); assertEquals("0", f.print(p)); assertEquals(1, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); } public void testFormatHours() { PeriodFormatter f = builder.appendHours().toFormatter(); assertEquals("5", f.print(PERIOD)); assertEquals(1, f.getPrinter().calculatePrintedLength(PERIOD, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null)); Period p = new Period(0, 0, 0, 0, 0, 0, 0, 0); assertEquals("0", f.print(p)); assertEquals(1, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); } public void testFormatMinutes() { PeriodFormatter f = builder.appendMinutes().toFormatter(); assertEquals("6", f.print(PERIOD)); assertEquals(1, f.getPrinter().calculatePrintedLength(PERIOD, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null)); Period p = new Period(0, 0, 0, 0, 0, 0, 0, 0); assertEquals("0", f.print(p)); assertEquals(1, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); } public void testFormatSeconds() { PeriodFormatter f = builder.appendSeconds().toFormatter(); assertEquals("7", f.print(PERIOD)); assertEquals(1, f.getPrinter().calculatePrintedLength(PERIOD, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null)); Period p = new Period(0, 0, 0, 0, 0, 0, 0, 0); assertEquals("0", f.print(p)); assertEquals(1, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); } public void testFormatSecondsWithMillis() { PeriodFormatter f = builder.appendSecondsWithMillis().toFormatter(); Period p = new Period(0, 0, 0, 0, 0, 0, 7, 0); assertEquals("7.000", f.print(p)); assertEquals(5, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); p = new Period(0, 0, 0, 0, 0, 0, 7, 1); assertEquals("7.001", f.print(p)); assertEquals(5, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); p = new Period(0, 0, 0, 0, 0, 0, 7, 999); assertEquals("7.999", f.print(p)); assertEquals(5, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); p = new Period(0, 0, 0, 0, 0, 0, 7, 1000); assertEquals("8.000", f.print(p)); assertEquals(5, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); p = new Period(0, 0, 0, 0, 0, 0, 7, 1001); assertEquals("8.001", f.print(p)); assertEquals(5, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); p = new Period(0, 0, 0, 0, 0, 0, 7, -1); assertEquals("6.999", f.print(p)); assertEquals(5, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); p = new Period(0, 0, 0, 0, 0, 0, -7, 1); assertEquals("-6.999", f.print(p)); assertEquals(6, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); p = new Period(0, 0, 0, 0, 0, 0, -7, -1); assertEquals("-7.001", f.print(p)); assertEquals(6, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); p = new Period(0, 0, 0, 0, 0, 0, 0, 0); assertEquals("0.000", f.print(p)); assertEquals(5, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); } public void testFormatSecondsWithOptionalMillis() { PeriodFormatter f = builder.appendSecondsWithOptionalMillis().toFormatter(); Period p = new Period(0, 0, 0, 0, 0, 0, 7, 0); assertEquals("7", f.print(p)); assertEquals(1, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); p = new Period(0, 0, 0, 0, 0, 0, 7, 1); assertEquals("7.001", f.print(p)); assertEquals(5, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); p = new Period(0, 0, 0, 0, 0, 0, 7, 999); assertEquals("7.999", f.print(p)); assertEquals(5, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); p = new Period(0, 0, 0, 0, 0, 0, 7, 1000); assertEquals("8", f.print(p)); assertEquals(1, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); p = new Period(0, 0, 0, 0, 0, 0, 7, 1001); assertEquals("8.001", f.print(p)); assertEquals(5, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); p = new Period(0, 0, 0, 0, 0, 0, 7, -1); assertEquals("6.999", f.print(p)); assertEquals(5, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); p = new Period(0, 0, 0, 0, 0, 0, -7, 1); assertEquals("-6.999", f.print(p)); assertEquals(6, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); p = new Period(0, 0, 0, 0, 0, 0, -7, -1); assertEquals("-7.001", f.print(p)); assertEquals(6, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); p = new Period(0, 0, 0, 0, 0, 0, 0, 0); assertEquals("0", f.print(p)); assertEquals(1, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); } public void testFormatMillis() { PeriodFormatter f = builder.appendMillis().toFormatter(); assertEquals("8", f.print(PERIOD)); assertEquals(1, f.getPrinter().calculatePrintedLength(PERIOD, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null)); Period p = new Period(0, 0, 0, 0, 0, 0, 0, 0); assertEquals("0", f.print(p)); assertEquals(1, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); } public void testFormatMillis3Digit() { PeriodFormatter f = builder.appendMillis3Digit().toFormatter(); assertEquals("008", f.print(PERIOD)); assertEquals(3, f.getPrinter().calculatePrintedLength(PERIOD, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null)); Period p = new Period(0, 0, 0, 0, 0, 0, 0, 0); assertEquals("000", f.print(p)); assertEquals(3, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); } //----------------------------------------------------------------------- public void testFormatPrefixSimple1() { PeriodFormatter f = builder.appendPrefix("Years:").appendYears().toFormatter(); assertEquals("Years:1", f.print(PERIOD)); assertEquals(7, f.getPrinter().calculatePrintedLength(PERIOD, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null)); Period p = new Period(0, 0, 0, 0, 0, 0, 0, 0); assertEquals("Years:0", f.print(p)); assertEquals(7, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); } public void testFormatPrefixSimple2() { PeriodFormatter f = builder.appendPrefix("Hours:").appendHours().toFormatter(); assertEquals("Hours:5", f.print(PERIOD)); assertEquals(7, f.getPrinter().calculatePrintedLength(PERIOD, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null)); Period p = new Period(0, 0, 0, 0, 0, 0, 0, 0); assertEquals("Hours:0", f.print(p)); assertEquals(7, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); } public void testFormatPrefixSimple3() { try { builder.appendPrefix(null); fail(); } catch (IllegalArgumentException ex) {} } public void testFormatPrefixPlural1() { PeriodFormatter f = builder.appendPrefix("Year:", "Years:").appendYears().toFormatter(); assertEquals("Year:1", f.print(PERIOD)); assertEquals(6, f.getPrinter().calculatePrintedLength(PERIOD, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null)); Period p = new Period(0, 0, 0, 0, 0, 0, 0, 0); assertEquals("Years:0", f.print(p)); assertEquals(7, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); } public void testFormatPrefixPlural2() { PeriodFormatter f = builder.appendPrefix("Hour:", "Hours:").appendHours().toFormatter(); assertEquals("Hours:5", f.print(PERIOD)); assertEquals(7, f.getPrinter().calculatePrintedLength(PERIOD, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null)); Period p = new Period(0, 0, 0, 0, 0, 0, 0, 0); assertEquals("Hours:0", f.print(p)); assertEquals(7, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); } public void testFormatPrefixPlural3() { try { builder.appendPrefix(null, ""); fail(); } catch (IllegalArgumentException ex) {} try { builder.appendPrefix("", null); fail(); } catch (IllegalArgumentException ex) {} try { builder.appendPrefix(null, null); fail(); } catch (IllegalArgumentException ex) {} } //----------------------------------------------------------------------- public void testFormatSuffixSimple1() { PeriodFormatter f = builder.appendYears().appendSuffix(" years").toFormatter(); assertEquals("1 years", f.print(PERIOD)); assertEquals(7, f.getPrinter().calculatePrintedLength(PERIOD, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null)); Period p = new Period(0, 0, 0, 0, 0, 0, 0, 0); assertEquals("0 years", f.print(p)); assertEquals(7, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); } public void testFormatSuffixSimple2() { PeriodFormatter f = builder.appendHours().appendSuffix(" hours").toFormatter(); assertEquals("5 hours", f.print(PERIOD)); assertEquals(7, f.getPrinter().calculatePrintedLength(PERIOD, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null)); Period p = new Period(0, 0, 0, 0, 0, 0, 0, 0); assertEquals("0 hours", f.print(p)); assertEquals(7, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); } public void testFormatSuffixSimple3() { try { builder.appendSuffix(null); fail(); } catch (IllegalArgumentException ex) {} } public void testFormatSuffixSimple4() { try { builder.appendSuffix(" hours"); fail(); } catch (IllegalStateException ex) {} } public void testFormatSuffixPlural1() { PeriodFormatter f = builder.appendYears().appendSuffix(" year", " years").toFormatter(); assertEquals("1 year", f.print(PERIOD)); assertEquals(6, f.getPrinter().calculatePrintedLength(PERIOD, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null)); Period p = new Period(0, 0, 0, 0, 0, 0, 0, 0); assertEquals("0 years", f.print(p)); assertEquals(7, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); } public void testFormatSuffixPlural2() { PeriodFormatter f = builder.appendHours().appendSuffix(" hour", " hours").toFormatter(); assertEquals("5 hours", f.print(PERIOD)); assertEquals(7, f.getPrinter().calculatePrintedLength(PERIOD, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null)); Period p = new Period(0, 0, 0, 0, 0, 0, 0, 0); assertEquals("0 hours", f.print(p)); assertEquals(7, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); } public void testFormatSuffixPlural3() { try { builder.appendSuffix(null, ""); fail(); } catch (IllegalArgumentException ex) {} try { builder.appendSuffix("", null); fail(); } catch (IllegalArgumentException ex) {} try { builder.appendSuffix(null, null); fail(); } catch (IllegalArgumentException ex) {} } public void testFormatSuffixPlural4() { try { builder.appendSuffix(" hour", " hours"); fail(); } catch (IllegalStateException ex) {} } //----------------------------------------------------------------------- public void testFormatPrefixSuffix() { PeriodFormatter f = builder.appendPrefix("P").appendYears().appendSuffix("Y").toFormatter(); assertEquals("P1Y", f.print(PERIOD)); assertEquals(3, f.getPrinter().calculatePrintedLength(PERIOD, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null)); Period p = new Period(0, 0, 0, 0, 0, 0, 0, 0); assertEquals("P0Y", f.print(p)); assertEquals(3, f.getPrinter().calculatePrintedLength(p, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null)); } //----------------------------------------------------------------------- public void testFormatSeparatorSimple() { PeriodFormatter f = builder.appendYears().appendSeparator("T").appendHours().toFormatter(); assertEquals("1T5", f.print(PERIOD)); assertEquals(3, f.getPrinter().calculatePrintedLength(PERIOD, null)); assertEquals(2, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null)); assertEquals("5", f.print(TIME_PERIOD)); assertEquals(1, f.getPrinter().calculatePrintedLength(TIME_PERIOD, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(TIME_PERIOD, Integer.MAX_VALUE, null)); assertEquals("1", f.print(DATE_PERIOD)); assertEquals(1, f.getPrinter().calculatePrintedLength(DATE_PERIOD, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(DATE_PERIOD, Integer.MAX_VALUE, null)); } public void testFormatSeparatorComplex() { PeriodFormatter f = builder .appendYears().appendSeparator(", ", " and ") .appendHours().appendSeparator(", ", " and ") .appendMinutes().appendSeparator(", ", " and ") .toFormatter(); assertEquals("1, 5 and 6", f.print(PERIOD)); assertEquals(10, f.getPrinter().calculatePrintedLength(PERIOD, null)); assertEquals(3, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null)); assertEquals("5 and 6", f.print(TIME_PERIOD)); assertEquals(7, f.getPrinter().calculatePrintedLength(TIME_PERIOD, null)); assertEquals(2, f.getPrinter().countFieldsToPrint(TIME_PERIOD, Integer.MAX_VALUE, null)); assertEquals("1", f.print(DATE_PERIOD)); assertEquals(1, f.getPrinter().calculatePrintedLength(DATE_PERIOD, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(DATE_PERIOD, Integer.MAX_VALUE, null)); } public void testFormatSeparatorIfFieldsAfter() { PeriodFormatter f = builder.appendYears().appendSeparatorIfFieldsAfter("T").appendHours().toFormatter(); assertEquals("1T5", f.print(PERIOD)); assertEquals(3, f.getPrinter().calculatePrintedLength(PERIOD, null)); assertEquals(2, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null)); assertEquals("T5", f.print(TIME_PERIOD)); assertEquals(2, f.getPrinter().calculatePrintedLength(TIME_PERIOD, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(TIME_PERIOD, Integer.MAX_VALUE, null)); assertEquals("1", f.print(DATE_PERIOD)); assertEquals(1, f.getPrinter().calculatePrintedLength(DATE_PERIOD, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(DATE_PERIOD, Integer.MAX_VALUE, null)); } public void testFormatSeparatorIfFieldsBefore() { PeriodFormatter f = builder.appendYears().appendSeparatorIfFieldsBefore("T").appendHours().toFormatter(); assertEquals("1T5", f.print(PERIOD)); assertEquals(3, f.getPrinter().calculatePrintedLength(PERIOD, null)); assertEquals(2, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null)); assertEquals("5", f.print(TIME_PERIOD)); assertEquals(1, f.getPrinter().calculatePrintedLength(TIME_PERIOD, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(TIME_PERIOD, Integer.MAX_VALUE, null)); assertEquals("1T", f.print(DATE_PERIOD)); assertEquals(2, f.getPrinter().calculatePrintedLength(DATE_PERIOD, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(DATE_PERIOD, Integer.MAX_VALUE, null)); } //----------------------------------------------------------------------- public void testFormatLiteral() { PeriodFormatter f = builder.appendLiteral("HELLO").toFormatter(); assertEquals("HELLO", f.print(PERIOD)); assertEquals(5, f.getPrinter().calculatePrintedLength(PERIOD, null)); assertEquals(0, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null)); } public void testFormatAppendFormatter() { PeriodFormatter base = builder.appendYears().appendLiteral("-").toFormatter(); PeriodFormatter f = new PeriodFormatterBuilder().append(base).appendYears().toFormatter(); assertEquals("1-1", f.print(PERIOD)); assertEquals(3, f.getPrinter().calculatePrintedLength(PERIOD, null)); assertEquals(2, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null)); } public void testFormatMinDigits() { PeriodFormatter f = new PeriodFormatterBuilder().minimumPrintedDigits(4).appendYears().toFormatter(); assertEquals("0001", f.print(PERIOD)); assertEquals(4, f.getPrinter().calculatePrintedLength(PERIOD, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null)); } //----------------------------------------------------------------------- public void testFormatPrintZeroDefault() { PeriodFormatter f = new PeriodFormatterBuilder() .appendYears().appendLiteral("-") .appendMonths().appendLiteral("-") .appendWeeks().appendLiteral("-") .appendDays().toFormatter(); assertEquals("1-2-3-4", f.print(PERIOD)); assertEquals(7, f.getPrinter().calculatePrintedLength(PERIOD, null)); assertEquals(4, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null)); assertEquals("---0", f.print(EMPTY_YEAR_DAY_PERIOD)); assertEquals(4, f.getPrinter().calculatePrintedLength(EMPTY_YEAR_DAY_PERIOD, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(EMPTY_YEAR_DAY_PERIOD, Integer.MAX_VALUE, null)); assertEquals("1---4", f.print(YEAR_DAY_PERIOD)); assertEquals(5, f.getPrinter().calculatePrintedLength(YEAR_DAY_PERIOD, null)); assertEquals(2, f.getPrinter().countFieldsToPrint(YEAR_DAY_PERIOD, Integer.MAX_VALUE, null)); assertEquals("---0", f.print(EMPTY_PERIOD)); assertEquals(4, f.getPrinter().calculatePrintedLength(EMPTY_PERIOD, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(EMPTY_PERIOD, Integer.MAX_VALUE, null)); // test only last instance of same field is output f = new PeriodFormatterBuilder() .appendYears().appendLiteral("-") .appendYears().toFormatter(); assertEquals("-0", f.print(EMPTY_PERIOD)); assertEquals(2, f.getPrinter().calculatePrintedLength(EMPTY_PERIOD, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(EMPTY_PERIOD, Integer.MAX_VALUE, null)); } public void testFormatPrintZeroRarelyLast() { PeriodFormatter f = new PeriodFormatterBuilder() .printZeroRarelyLast() .appendYears().appendLiteral("-") .appendMonths().appendLiteral("-") .appendWeeks().appendLiteral("-") .appendDays().toFormatter(); assertEquals("1-2-3-4", f.print(PERIOD)); assertEquals(7, f.getPrinter().calculatePrintedLength(PERIOD, null)); assertEquals(4, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null)); assertEquals("---0", f.print(EMPTY_YEAR_DAY_PERIOD)); assertEquals(4, f.getPrinter().calculatePrintedLength(EMPTY_YEAR_DAY_PERIOD, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(EMPTY_YEAR_DAY_PERIOD, Integer.MAX_VALUE, null)); assertEquals("1---4", f.print(YEAR_DAY_PERIOD)); assertEquals(5, f.getPrinter().calculatePrintedLength(YEAR_DAY_PERIOD, null)); assertEquals(2, f.getPrinter().countFieldsToPrint(YEAR_DAY_PERIOD, Integer.MAX_VALUE, null)); assertEquals("---0", f.print(EMPTY_PERIOD)); assertEquals(4, f.getPrinter().calculatePrintedLength(EMPTY_PERIOD, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(EMPTY_PERIOD, Integer.MAX_VALUE, null)); } public void testFormatPrintZeroRarelyFirst() { PeriodFormatter f = new PeriodFormatterBuilder() .printZeroRarelyFirst() .appendYears().appendLiteral("-") .appendMonths().appendLiteral("-") .appendWeeks().appendLiteral("-") .appendDays().toFormatter(); assertEquals("1-2-3-4", f.print(PERIOD)); assertEquals(7, f.getPrinter().calculatePrintedLength(PERIOD, null)); assertEquals(4, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null)); assertEquals("0---", f.print(EMPTY_YEAR_DAY_PERIOD)); assertEquals(4, f.getPrinter().calculatePrintedLength(EMPTY_YEAR_DAY_PERIOD, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(EMPTY_YEAR_DAY_PERIOD, Integer.MAX_VALUE, null)); assertEquals("1---4", f.print(YEAR_DAY_PERIOD)); assertEquals(5, f.getPrinter().calculatePrintedLength(YEAR_DAY_PERIOD, null)); assertEquals(2, f.getPrinter().countFieldsToPrint(YEAR_DAY_PERIOD, Integer.MAX_VALUE, null)); assertEquals("0---", f.print(EMPTY_PERIOD)); assertEquals(4, f.getPrinter().calculatePrintedLength(EMPTY_PERIOD, null)); assertEquals(1, f.getPrinter().countFieldsToPrint(EMPTY_PERIOD, Integer.MAX_VALUE, null)); } public void testFormatPrintZeroRarelyFirstYears() { PeriodFormatter f = new PeriodFormatterBuilder() .printZeroRarelyFirst() .appendYears().toFormatter(); assertEquals("0", f.print(EMPTY_PERIOD)); } public void testFormatPrintZeroRarelyFirstMonths() { PeriodFormatter f = new PeriodFormatterBuilder() .printZeroRarelyFirst() .appendMonths().toFormatter(); assertEquals("0", f.print(EMPTY_PERIOD)); } public void testFormatPrintZeroRarelyFirstWeeks() { PeriodFormatter f = new PeriodFormatterBuilder() .printZeroRarelyFirst() .appendWeeks().toFormatter(); assertEquals("0", f.print(EMPTY_PERIOD)); } public void testFormatPrintZeroRarelyFirstDays() { PeriodFormatter f = new PeriodFormatterBuilder() .printZeroRarelyFirst() .appendDays().toFormatter(); assertEquals("0", f.print(EMPTY_PERIOD)); } public void testFormatPrintZeroRarelyFirstHours() { PeriodFormatter f = new PeriodFormatterBuilder() .printZeroRarelyFirst() .appendHours().toFormatter(); assertEquals("0", f.print(EMPTY_PERIOD)); } public void testFormatPrintZeroRarelyFirstMinutes() { PeriodFormatter f = new PeriodFormatterBuilder() .printZeroRarelyFirst() .appendMinutes().toFormatter(); assertEquals("0", f.print(EMPTY_PERIOD)); } public void testFormatPrintZeroRarelyFirstSeconds() { PeriodFormatter f = new PeriodFormatterBuilder() .printZeroRarelyFirst() .appendSeconds().toFormatter(); assertEquals("0", f.print(EMPTY_PERIOD)); } public void testFormatPrintZeroIfSupported() { PeriodFormatter f = new PeriodFormatterBuilder() .printZeroIfSupported() .appendYears().appendLiteral("-") .appendMonths().appendLiteral("-") .appendWeeks().appendLiteral("-") .appendDays().toFormatter(); assertEquals("1-2-3-4", f.print(PERIOD)); assertEquals(7, f.getPrinter().calculatePrintedLength(PERIOD, null)); assertEquals(4, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null)); assertEquals("0---0", f.print(EMPTY_YEAR_DAY_PERIOD)); assertEquals(5, f.getPrinter().calculatePrintedLength(EMPTY_YEAR_DAY_PERIOD, null)); assertEquals(2, f.getPrinter().countFieldsToPrint(EMPTY_YEAR_DAY_PERIOD, Integer.MAX_VALUE, null)); assertEquals("1---4", f.print(YEAR_DAY_PERIOD)); assertEquals(5, f.getPrinter().calculatePrintedLength(YEAR_DAY_PERIOD, null)); assertEquals(2, f.getPrinter().countFieldsToPrint(YEAR_DAY_PERIOD, Integer.MAX_VALUE, null)); assertEquals("0-0-0-0", f.print(EMPTY_PERIOD)); assertEquals(7, f.getPrinter().calculatePrintedLength(EMPTY_PERIOD, null)); assertEquals(4, f.getPrinter().countFieldsToPrint(EMPTY_PERIOD, Integer.MAX_VALUE, null)); } public void testFormatPrintZeroAlways() { PeriodFormatter f = new PeriodFormatterBuilder() .printZeroAlways() .appendYears().appendLiteral("-") .appendMonths().appendLiteral("-") .appendWeeks().appendLiteral("-") .appendDays().toFormatter(); assertEquals("1-2-3-4", f.print(PERIOD)); assertEquals(7, f.getPrinter().calculatePrintedLength(PERIOD, null)); assertEquals(4, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null)); assertEquals("0-0-0-0", f.print(EMPTY_YEAR_DAY_PERIOD)); assertEquals(7, f.getPrinter().calculatePrintedLength(EMPTY_YEAR_DAY_PERIOD, null)); assertEquals(4, f.getPrinter().countFieldsToPrint(EMPTY_YEAR_DAY_PERIOD, Integer.MAX_VALUE, null)); assertEquals("1-0-0-4", f.print(YEAR_DAY_PERIOD)); assertEquals(7, f.getPrinter().calculatePrintedLength(YEAR_DAY_PERIOD, null)); assertEquals(4, f.getPrinter().countFieldsToPrint(YEAR_DAY_PERIOD, Integer.MAX_VALUE, null)); assertEquals("0-0-0-0", f.print(EMPTY_PERIOD)); assertEquals(7, f.getPrinter().calculatePrintedLength(EMPTY_PERIOD, null)); assertEquals(4, f.getPrinter().countFieldsToPrint(EMPTY_PERIOD, Integer.MAX_VALUE, null)); } public void testFormatPrintZeroNever() { PeriodFormatter f = new PeriodFormatterBuilder() .printZeroNever() .appendYears().appendLiteral("-") .appendMonths().appendLiteral("-") .appendWeeks().appendLiteral("-") .appendDays().toFormatter(); assertEquals("1-2-3-4", f.print(PERIOD)); assertEquals(7, f.getPrinter().calculatePrintedLength(PERIOD, null)); assertEquals(4, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null)); assertEquals("---", f.print(EMPTY_YEAR_DAY_PERIOD)); assertEquals(3, f.getPrinter().calculatePrintedLength(EMPTY_YEAR_DAY_PERIOD, null)); assertEquals(0, f.getPrinter().countFieldsToPrint(EMPTY_YEAR_DAY_PERIOD, Integer.MAX_VALUE, null)); assertEquals("1---4", f.print(YEAR_DAY_PERIOD)); assertEquals(5, f.getPrinter().calculatePrintedLength(YEAR_DAY_PERIOD, null)); assertEquals(2, f.getPrinter().countFieldsToPrint(YEAR_DAY_PERIOD, Integer.MAX_VALUE, null)); assertEquals("---", f.print(EMPTY_PERIOD)); assertEquals(3, f.getPrinter().calculatePrintedLength(EMPTY_PERIOD, null)); assertEquals(0, f.getPrinter().countFieldsToPrint(EMPTY_PERIOD, Integer.MAX_VALUE, null)); } //----------------------------------------------------------------------- public void testFormatAppend_PrinterParser_null_null() { try { new PeriodFormatterBuilder().append(null, null); fail(); } catch (IllegalArgumentException ex) {} } public void testFormatAppend_PrinterParser_Printer_null() { PeriodPrinter printer = new PeriodFormatterBuilder().appendYears().appendLiteral("-").toPrinter(); PeriodFormatterBuilder bld = new PeriodFormatterBuilder().append(printer, null).appendMonths(); assertNotNull(bld.toPrinter()); assertNull(bld.toParser()); PeriodFormatter f = bld.toFormatter(); assertEquals("1-2", f.print(PERIOD)); try { f.parsePeriod("1-2"); fail(); } catch (UnsupportedOperationException ex) {} } public void testFormatAppend_PrinterParser_null_Parser() { PeriodParser parser = new PeriodFormatterBuilder().appendWeeks().appendLiteral("-").toParser(); PeriodFormatterBuilder bld = new PeriodFormatterBuilder().append(null, parser).appendMonths(); assertNull(bld.toPrinter()); assertNotNull(bld.toParser()); PeriodFormatter f = bld.toFormatter(); try { f.print(PERIOD); fail(); } catch (UnsupportedOperationException ex) {} assertEquals(new Period(0, 2, 1, 0, 0, 0, 0, 0), f.parsePeriod("1-2")); } public void testFormatAppend_PrinterParser_PrinterParser() { PeriodPrinter printer = new PeriodFormatterBuilder().appendYears().appendLiteral("-").toPrinter(); PeriodParser parser = new PeriodFormatterBuilder().appendWeeks().appendLiteral("-").toParser(); PeriodFormatterBuilder bld = new PeriodFormatterBuilder().append(printer, parser).appendMonths(); assertNotNull(bld.toPrinter()); assertNotNull(bld.toParser()); PeriodFormatter f = bld.toFormatter(); assertEquals("1-2", f.print(PERIOD)); assertEquals(new Period(0, 2, 1, 0, 0, 0, 0, 0), f.parsePeriod("1-2")); } public void testFormatAppend_PrinterParser_Printer_null_null_Parser() { PeriodPrinter printer = new PeriodFormatterBuilder().appendYears().appendLiteral("-").toPrinter(); PeriodParser parser = new PeriodFormatterBuilder().appendWeeks().appendLiteral("-").toParser(); PeriodFormatterBuilder bld = new PeriodFormatterBuilder().append(printer, null).append(null, parser); assertNull(bld.toPrinter()); assertNull(bld.toParser()); try { bld.toFormatter(); fail(); } catch (IllegalStateException ex) {} } public void testFormatAppend_PrinterParserThenClear() { PeriodPrinter printer = new PeriodFormatterBuilder().appendYears().appendLiteral("-").toPrinter(); PeriodParser parser = new PeriodFormatterBuilder().appendWeeks().appendLiteral("-").toParser(); PeriodFormatterBuilder bld = new PeriodFormatterBuilder().append(printer, null).append(null, parser); assertNull(bld.toPrinter()); assertNull(bld.toParser()); bld.clear(); bld.appendMonths(); assertNotNull(bld.toPrinter()); assertNotNull(bld.toParser()); } public void testBug2495455() { PeriodFormatter pfmt1 = new PeriodFormatterBuilder() .appendLiteral("P") .appendYears() .appendSuffix("Y") .appendMonths() .appendSuffix("M") .appendWeeks() .appendSuffix("W") .appendDays() .appendSuffix("D") .appendSeparatorIfFieldsAfter("T") .appendHours() .appendSuffix("H") .appendMinutes() .appendSuffix("M") .appendSecondsWithOptionalMillis() .appendSuffix("S") .toFormatter(); PeriodFormatter pfmt2 = new PeriodFormatterBuilder() .append(ISOPeriodFormat.standard()) .toFormatter(); pfmt1.parsePeriod("PT1003199059S"); pfmt2.parsePeriod("PT1003199059S"); } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.format; import java.util.Locale; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.Chronology; import org.joda.time.DateTime; import org.joda.time.DateTimeZone; import org.joda.time.MutableDateTime; import org.joda.time.chrono.ISOChronology; /** * Makes sure that text fields are correct for English. * * @author Brian S O'Neill */ public class TestTextFields extends TestCase { private static final DateTimeZone[] ZONES = { DateTimeZone.UTC, DateTimeZone.forID("Europe/Paris"), DateTimeZone.forID("Europe/London"), DateTimeZone.forID("Asia/Tokyo"), DateTimeZone.forID("America/Los_Angeles"), }; private static final String[] MONTHS = { null, "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" }; private static final String[] WEEKDAYS = { null, "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday" }; private static final String[] HALFDAYS = { "AM", "PM" }; private DateTimeZone originalDateTimeZone = null; private Locale originalLocale = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestTextFields.class); } public TestTextFields(String name) { super(name); } protected void setUp() throws Exception { originalDateTimeZone = DateTimeZone.getDefault(); originalLocale = Locale.getDefault(); DateTimeZone.setDefault(ZONES[0]); Locale.setDefault(Locale.ENGLISH); } protected void tearDown() throws Exception { DateTimeZone.setDefault(originalDateTimeZone); Locale.setDefault(originalLocale); originalDateTimeZone = null; originalLocale = null; } //----------------------------------------------------------------------- public void testMonthNames_monthStart() { DateTimeFormatter printer = DateTimeFormat.forPattern("MMMM"); for (int i=0; i<ZONES.length; i++) { for (int month=1; month<=12; month++) { DateTime dt = new DateTime(2004, month, 1, 1, 20, 30, 40, ZONES[i]); String monthText = printer.print(dt); assertEquals(MONTHS[month], monthText); } } } public void testMonthNames_monthMiddle() { DateTimeFormatter printer = DateTimeFormat.forPattern("MMMM"); for (int i=0; i<ZONES.length; i++) { for (int month=1; month<=12; month++) { DateTime dt = new DateTime(2004, month, 15, 12, 20, 30, 40, ZONES[i]); String monthText = printer.print(dt); assertEquals(MONTHS[month], monthText); } } } public void testMonthNames_monthEnd() { DateTimeFormatter printer = DateTimeFormat.forPattern("MMMM"); for (int i=0; i<ZONES.length; i++) { Chronology chrono = ISOChronology.getInstance(ZONES[i]); for (int month=1; month<=12; month++) { DateTime dt = new DateTime(2004, month, 1, 23, 20, 30, 40, chrono); int lastDay = chrono.dayOfMonth().getMaximumValue(dt.getMillis()); dt = new DateTime(2004, month, lastDay, 23, 20, 30, 40, chrono); String monthText = printer.print(dt); assertEquals(MONTHS[month], monthText); } } } public void testWeekdayNames() { DateTimeFormatter printer = DateTimeFormat.forPattern("EEEE"); for (int i=0; i<ZONES.length; i++) { MutableDateTime mdt = new MutableDateTime(2004, 1, 1, 1, 20, 30, 40, ZONES[i]); for (int day=1; day<=366; day++) { mdt.setDayOfYear(day); int weekday = mdt.getDayOfWeek(); String weekdayText = printer.print(mdt); assertEquals(WEEKDAYS[weekday], weekdayText); } } } public void testHalfdayNames() { DateTimeFormatter printer = DateTimeFormat.forPattern("a"); for (int i=0; i<ZONES.length; i++) { Chronology chrono = ISOChronology.getInstance(ZONES[i]); MutableDateTime mdt = new MutableDateTime(2004, 5, 30, 0, 20, 30, 40, chrono); for (int hour=0; hour<24; hour++) { mdt.setHourOfDay(hour); int halfday = mdt.get(chrono.halfdayOfDay()); String halfdayText = printer.print(mdt); assertEquals(HALFDAYS[halfday], halfdayText); } } } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.tz; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.DateTime; import org.joda.time.DateTimeZone; import org.joda.time.format.DateTimeFormatter; import org.joda.time.format.DateTimeFormatterBuilder; /** * Test cases for DateTimeZoneBuilder. * * @author Brian S O'Neill */ public class TestBuilder extends TestCase { public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestBuilder.class); } static final DateTimeFormatter OFFSET_FORMATTER = new DateTimeFormatterBuilder() .appendTimeZoneOffset(null, true, 2, 4) .toFormatter(); // Each row is {transition, nameKey, standardOffset, offset} static final String[][] AMERICA_LOS_ANGELES_DATA = { {null, "LMT", "-07:52:58", "-07:52:58"}, {"1883-11-18T19:52:58.000Z", "PST", "-08:00", "-08:00"}, {"1918-03-31T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1918-10-27T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1919-03-30T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1919-10-26T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1942-02-09T02:00:00.000-08:00", "PWT", "-08:00", "-07:00"}, {"1945-08-14T23:00:00.000Z", "PPT", "-08:00", "-07:00"}, {"1945-09-30T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1948-03-14T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1949-01-01T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1950-04-30T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1950-09-24T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1951-04-29T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1951-09-30T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1952-04-27T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1952-09-28T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1953-04-26T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1953-09-27T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1954-04-25T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1954-09-26T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1955-04-24T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1955-09-25T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1956-04-29T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1956-09-30T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1957-04-28T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1957-09-29T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1958-04-27T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1958-09-28T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1959-04-26T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1959-09-27T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1960-04-24T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1960-09-25T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1961-04-30T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1961-09-24T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1962-04-29T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1962-10-28T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1963-04-28T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1963-10-27T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1964-04-26T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1964-10-25T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1965-04-25T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1965-10-31T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1966-04-24T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1966-10-30T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1967-04-30T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1967-10-29T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1968-04-28T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1968-10-27T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1969-04-27T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1969-10-26T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1970-04-26T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1970-10-25T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1971-04-25T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1971-10-31T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1972-04-30T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1972-10-29T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1973-04-29T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1973-10-28T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1974-01-06T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1974-10-27T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1975-02-23T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1975-10-26T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1976-04-25T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1976-10-31T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1977-04-24T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1977-10-30T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1978-04-30T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1978-10-29T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1979-04-29T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1979-10-28T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1980-04-27T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1980-10-26T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1981-04-26T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1981-10-25T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1982-04-25T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1982-10-31T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1983-04-24T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1983-10-30T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1984-04-29T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1984-10-28T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1985-04-28T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1985-10-27T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1986-04-27T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1986-10-26T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1987-04-05T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1987-10-25T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1988-04-03T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1988-10-30T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1989-04-02T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1989-10-29T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1990-04-01T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1990-10-28T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1991-04-07T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1991-10-27T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1992-04-05T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1992-10-25T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1993-04-04T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1993-10-31T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1994-04-03T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1994-10-30T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1995-04-02T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1995-10-29T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1996-04-07T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1996-10-27T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1997-04-06T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1997-10-26T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1998-04-05T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1998-10-25T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"1999-04-04T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"1999-10-31T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, {"2000-04-02T02:00:00.000-08:00", "PDT", "-08:00", "-07:00"}, {"2000-10-29T02:00:00.000-07:00", "PST", "-08:00", "-08:00"}, }; static DateTimeZoneBuilder buildAmericaLosAngelesBuilder() { return new DateTimeZoneBuilder() .addCutover(-2147483648, 'w', 1, 1, 0, false, 0) .setStandardOffset(-28378000) .setFixedSavings("LMT", 0) .addCutover(1883, 'w', 11, 18, 0, false, 43200000) .setStandardOffset(-28800000) .addRecurringSavings("PDT", 3600000, 1918, 1919, 'w', 3, -1, 7, false, 7200000) .addRecurringSavings("PST", 0, 1918, 1919, 'w', 10, -1, 7, false, 7200000) .addRecurringSavings("PWT", 3600000, 1942, 1942, 'w', 2, 9, 0, false, 7200000) .addRecurringSavings("PPT", 3600000, 1945, 1945, 'u', 8, 14, 0, false, 82800000) .addRecurringSavings("PST", 0, 1945, 1945, 'w', 9, 30, 0, false, 7200000) .addRecurringSavings("PDT", 3600000, 1948, 1948, 'w', 3, 14, 0, false, 7200000) .addRecurringSavings("PST", 0, 1949, 1949, 'w', 1, 1, 0, false, 7200000) .addRecurringSavings("PDT", 3600000, 1950, 1966, 'w', 4, -1, 7, false, 7200000) .addRecurringSavings("PST", 0, 1950, 1961, 'w', 9, -1, 7, false, 7200000) .addRecurringSavings("PST", 0, 1962, 1966, 'w', 10, -1, 7, false, 7200000) .addRecurringSavings("PST", 0, 1967, 2147483647, 'w', 10, -1, 7, false, 7200000) .addRecurringSavings("PDT", 3600000, 1967, 1973, 'w', 4, -1, 7, false, 7200000) .addRecurringSavings("PDT", 3600000, 1974, 1974, 'w', 1, 6, 0, false, 7200000) .addRecurringSavings("PDT", 3600000, 1975, 1975, 'w', 2, 23, 0, false, 7200000) .addRecurringSavings("PDT", 3600000, 1976, 1986, 'w', 4, -1, 7, false, 7200000) .addRecurringSavings("PDT", 3600000, 1987, 2147483647, 'w', 4, 1, 7, true, 7200000); } static DateTimeZone buildAmericaLosAngeles() { return buildAmericaLosAngelesBuilder().toDateTimeZone("America/Los_Angeles", true); } private DateTimeZone originalDateTimeZone = null; public TestBuilder(String name) { super(name); } protected void setUp() throws Exception { originalDateTimeZone = DateTimeZone.getDefault(); DateTimeZone.setDefault(DateTimeZone.UTC); } protected void tearDown() throws Exception { DateTimeZone.setDefault(originalDateTimeZone); } public void testID() { DateTimeZone tz = buildAmericaLosAngeles(); assertEquals("America/Los_Angeles", tz.getID()); assertEquals(false, tz.isFixed()); } public void testForwardTransitions() { DateTimeZone tz = buildAmericaLosAngeles(); testForwardTransitions(tz, AMERICA_LOS_ANGELES_DATA); } static void testForwardTransitions(DateTimeZone tz, String[][] data) { long instant = Long.MIN_VALUE; for (int i=0; i<data.length; i++) { String[] row = data[i]; long expectedInstant = instant; if (row[0] != null) { instant = tz.nextTransition(instant); expectedInstant = new DateTime(row[0]).getMillis(); } String expectedKey = row[1]; int expectedStandardOffset = -(int) OFFSET_FORMATTER.parseMillis(row[2]); int expectedOffset = -(int) OFFSET_FORMATTER.parseMillis(row[3]); assertEquals(expectedInstant, instant); assertEquals(expectedKey, tz.getNameKey(instant)); assertEquals(expectedStandardOffset, tz.getStandardOffset(instant)); assertEquals(expectedOffset, tz.getOffset(instant)); // Sample a few instants between transitions. if (i < data.length - 1) { long nextInstant = new DateTime(data[i + 1][0]).getMillis(); long span = (nextInstant - instant) / 10; for (int j=1; j<10; j++) { long between = instant + j * span; assertEquals(expectedKey, tz.getNameKey(between)); assertEquals(expectedStandardOffset, tz.getStandardOffset(between)); assertEquals(expectedOffset, tz.getOffset(between)); } } } } public void testReverseTransitions() { DateTimeZone tz = buildAmericaLosAngeles(); testReverseTransitions(tz, AMERICA_LOS_ANGELES_DATA); } static void testReverseTransitions(DateTimeZone tz, String[][] data) { long instant = new DateTime(data[data.length - 1][0]).getMillis(); for (int i=data.length; --i>=1; ) { String[] row = data[i]; String[] prevRow = data[i - 1]; instant = tz.previousTransition(instant); long expectedInstant = new DateTime(row[0]).getMillis() - 1; String expectedKey = prevRow[1]; int expectedStandardOffset = -(int) OFFSET_FORMATTER.parseMillis(prevRow[2]); int expectedOffset = -(int) OFFSET_FORMATTER.parseMillis(prevRow[3]); assertEquals(expectedInstant, instant); assertEquals(expectedKey, tz.getNameKey(instant)); assertEquals(expectedStandardOffset, tz.getStandardOffset(instant)); assertEquals(expectedOffset, tz.getOffset(instant)); } } public void testSerialization() throws IOException { DateTimeZone tz = testSerialization (buildAmericaLosAngelesBuilder(), "America/Los_Angeles"); assertEquals(false, tz.isFixed()); testForwardTransitions(tz, AMERICA_LOS_ANGELES_DATA); testReverseTransitions(tz, AMERICA_LOS_ANGELES_DATA); } static DateTimeZone testSerialization(DateTimeZoneBuilder builder, String id) throws IOException { ByteArrayOutputStream out = new ByteArrayOutputStream(); builder.writeTo("America/Los_Angeles", out); ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray()); DateTimeZone tz = DateTimeZoneBuilder.readFrom(in, id); assertEquals(id, tz.getID()); return tz; } public void testFixed() throws IOException { DateTimeZoneBuilder builder = new DateTimeZoneBuilder() .setStandardOffset(3600000) .setFixedSavings("LMT", 0); DateTimeZone tz = builder.toDateTimeZone("Test", true); for (int i=0; i<2; i++) { assertEquals("Test", tz.getID()); assertEquals(true, tz.isFixed()); assertEquals(3600000, tz.getOffset(0)); assertEquals(3600000, tz.getStandardOffset(0)); assertEquals(0, tz.nextTransition(0)); assertEquals(0, tz.previousTransition(0)); tz = testSerialization(builder, "Test"); } } }
/* * Copyright 2001-2012 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.tz; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.DateTimeZone; /** * Test cases for FixedDateTimeZone. * * @author Stephen Colebourne */ public class TestCachedDateTimeZone extends TestCase { public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestCachedDateTimeZone.class); } private DateTimeZone originalDateTimeZone = null; public TestCachedDateTimeZone(String name) { super(name); } protected void setUp() throws Exception { originalDateTimeZone = DateTimeZone.getDefault(); DateTimeZone.setDefault(DateTimeZone.UTC); } protected void tearDown() throws Exception { DateTimeZone.setDefault(originalDateTimeZone); } public void test_caching() throws Exception { CachedDateTimeZone zone1 = CachedDateTimeZone.forZone(DateTimeZone.forID("Europe/Paris")); CachedDateTimeZone zone2 = CachedDateTimeZone.forZone(DateTimeZone.forID("Europe/Paris")); assertSame(zone1, zone2); } //----------------------------------------------------------------------- public void testSerialization() throws Exception { CachedDateTimeZone test = CachedDateTimeZone.forZone(DateTimeZone.forID("Europe/Paris")); ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(test); byte[] bytes = baos.toByteArray(); oos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); CachedDateTimeZone result = (CachedDateTimeZone) ois.readObject(); ois.close(); assertEquals(test, result); } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.tz; import java.io.ByteArrayInputStream; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.util.StringTokenizer; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.DateTime; import org.joda.time.DateTimeZone; import org.joda.time.tz.ZoneInfoCompiler.DateTimeOfYear; /** * Test cases for ZoneInfoCompiler. * * @author Brian S O'Neill */ public class TestCompiler extends TestCase { public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestCompiler.class); } static final String AMERICA_LOS_ANGELES_FILE = "# Rules for building just America/Los_Angeles time zone.\n" + "\n" + "Rule US 1918 1919 - Mar lastSun 2:00 1:00 D\n" + "Rule US 1918 1919 - Oct lastSun 2:00 0 S\n" + "Rule US 1942 only - Feb 9 2:00 1:00 W # War\n" + "Rule US 1945 only - Aug 14 23:00u 1:00 P # Peace\n" + "Rule US 1945 only - Sep 30 2:00 0 S\n" + "Rule US 1967 max - Oct lastSun 2:00 0 S\n" + "Rule US 1967 1973 - Apr lastSun 2:00 1:00 D\n" + "Rule US 1974 only - Jan 6 2:00 1:00 D\n" + "Rule US 1975 only - Feb 23 2:00 1:00 D\n" + "Rule US 1976 1986 - Apr lastSun 2:00 1:00 D\n" + "Rule US 1987 max - Apr Sun>=1 2:00 1:00 D\n" + "\n" + "Rule CA 1948 only - Mar 14 2:00 1:00 D\n" + "Rule CA 1949 only - Jan 1 2:00 0 S\n" + "Rule CA 1950 1966 - Apr lastSun 2:00 1:00 D\n" + "Rule CA 1950 1961 - Sep lastSun 2:00 0 S\n" + "Rule CA 1962 1966 - Oct lastSun 2:00 0 S\n" + "\n" + "Zone America/Los_Angeles -7:52:58 - LMT 1883 Nov 18 12:00\n" + " -8:00 US P%sT 1946\n" + " -8:00 CA P%sT 1967\n" + " -8:00 US P%sT"; private DateTimeZone originalDateTimeZone = null; public TestCompiler(String name) { super(name); } protected void setUp() throws Exception { originalDateTimeZone = DateTimeZone.getDefault(); DateTimeZone.setDefault(DateTimeZone.UTC); } protected void tearDown() throws Exception { DateTimeZone.setDefault(originalDateTimeZone); } //----------------------------------------------------------------------- public void testDateTimeZoneBuilder() throws Exception { // test multithreading, issue #18 getTestDataTimeZoneBuilder().toDateTimeZone("TestDTZ1", true); final DateTimeZone[] zone = new DateTimeZone[1]; Thread t = new Thread(new Runnable() { public void run() { zone[0] = getTestDataTimeZoneBuilder().toDateTimeZone("TestDTZ2", true); } }); t.start(); t.join(); assertNotNull(zone[0]); } private DateTimeZoneBuilder getTestDataTimeZoneBuilder() { return new DateTimeZoneBuilder() .addCutover(1601, 'w', 1, 1, 1, false, 7200000) .setStandardOffset(3600000) .addRecurringSavings("", 3600000, 1601, Integer.MAX_VALUE, 'w', 3, -1, 1, false, 7200000) .addRecurringSavings("", 0, 1601, Integer.MAX_VALUE, 'w', 10, -1, 1, false, 10800000); } //----------------------------------------------------------------------- public void testCompile() throws Exception { Provider provider = compileAndLoad(AMERICA_LOS_ANGELES_FILE); DateTimeZone tz = provider.getZone("America/Los_Angeles"); assertEquals("America/Los_Angeles", tz.getID()); assertEquals(false, tz.isFixed()); TestBuilder.testForwardTransitions(tz, TestBuilder.AMERICA_LOS_ANGELES_DATA); TestBuilder.testReverseTransitions(tz, TestBuilder.AMERICA_LOS_ANGELES_DATA); } private Provider compileAndLoad(String data) throws Exception { File tempDir = createDataFile(data); File destDir = makeTempDir(); ZoneInfoCompiler.main(new String[] { "-src", tempDir.getAbsolutePath(), "-dst", destDir.getAbsolutePath(), "tzdata" }); // Mark all files to be deleted on exit. deleteOnExit(destDir); return new ZoneInfoProvider(destDir); } private File createDataFile(String data) throws IOException { File tempDir = makeTempDir(); File tempFile = new File(tempDir, "tzdata"); tempFile.deleteOnExit(); InputStream in = new ByteArrayInputStream(data.getBytes("UTF-8")); FileOutputStream out = new FileOutputStream(tempFile); byte[] buf = new byte[1000]; int amt; while ((amt = in.read(buf)) > 0) { out.write(buf, 0, amt); } out.close(); in.close(); return tempDir; } private File makeTempDir() { File tempDir = new File(System.getProperty("java.io.tmpdir")); tempDir = new File(tempDir, "joda-test-" + (new java.util.Random().nextInt() & 0xffffff)); tempDir.mkdirs(); tempDir.deleteOnExit(); return tempDir; } private void deleteOnExit(File tempFile) { tempFile.deleteOnExit(); if (tempFile.isDirectory()) { File[] files = tempFile.listFiles(); for (int i=0; i<files.length; i++) { deleteOnExit(files[i]); } } } //----------------------------------------------------------------------- public void test_2400_fromDay() { StringTokenizer st = new StringTokenizer("Apr Sun>=1 24:00"); DateTimeOfYear test = new DateTimeOfYear(st); assertEquals(4, test.iMonthOfYear); // Apr assertEquals(2, test.iDayOfMonth); // 2nd assertEquals(1, test.iDayOfWeek); // Mon assertEquals(0, test.iMillisOfDay); // 00:00 assertEquals(true, test.iAdvanceDayOfWeek); } public void test_2400_last() { StringTokenizer st = new StringTokenizer("Mar lastSun 24:00"); DateTimeOfYear test = new DateTimeOfYear(st); assertEquals(4, test.iMonthOfYear); // Apr assertEquals(1, test.iDayOfMonth); // 1st assertEquals(1, test.iDayOfWeek); // Mon assertEquals(0, test.iMillisOfDay); // 00:00 assertEquals(false, test.iAdvanceDayOfWeek); } public void test_Amman_2003() { DateTimeZone zone = DateTimeZone.forID("Asia/Amman"); DateTime dt = new DateTime(2003, 3, 1, 0, 0, zone); long next = zone.nextTransition(dt.getMillis()); assertEquals(next, new DateTime(2003, 3, 28, 0, 0, DateTimeZone.forOffsetHours(2)).getMillis()); } public void test_Amman_2004() { DateTimeZone zone = DateTimeZone.forID("Asia/Amman"); DateTime dt = new DateTime(2004, 3, 1, 0, 0, zone); long next = zone.nextTransition(dt.getMillis()); assertEquals(next, new DateTime(2004, 3, 26, 0, 0, DateTimeZone.forOffsetHours(2)).getMillis()); } public void test_Amman_2005() { DateTimeZone zone = DateTimeZone.forID("Asia/Amman"); DateTime dt = new DateTime(2005, 3, 1, 0, 0, zone); long next = zone.nextTransition(dt.getMillis()); assertEquals(next, new DateTime(2005, 4, 1, 0, 0, DateTimeZone.forOffsetHours(2)).getMillis()); } public void test_Amman_2006() { DateTimeZone zone = DateTimeZone.forID("Asia/Amman"); DateTime dt = new DateTime(2006, 3, 1, 0, 0, zone); long next = zone.nextTransition(dt.getMillis()); assertEquals(next, new DateTime(2006, 3, 31, 0, 0, DateTimeZone.forOffsetHours(2)).getMillis()); } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.tz; import java.util.Date; import java.util.TimeZone; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.DateTimeZone; /** * Test cases for FixedDateTimeZone. * * @author Stephen Colebourne */ public class TestFixedDateTimeZone extends TestCase { public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestFixedDateTimeZone.class); } private DateTimeZone originalDateTimeZone = null; public TestFixedDateTimeZone(String name) { super(name); } protected void setUp() throws Exception { originalDateTimeZone = DateTimeZone.getDefault(); DateTimeZone.setDefault(DateTimeZone.UTC); } protected void tearDown() throws Exception { DateTimeZone.setDefault(originalDateTimeZone); } public void testEquals() throws Exception { FixedDateTimeZone zone1 = new FixedDateTimeZone("A", "B", 1, 5); FixedDateTimeZone zone1b = new FixedDateTimeZone("A", "B", 1, 5); FixedDateTimeZone zone2 = new FixedDateTimeZone("A", "C", 1, 5); FixedDateTimeZone zone3 = new FixedDateTimeZone("A", "B", 2, 5); FixedDateTimeZone zone4 = new FixedDateTimeZone("A", "B", 1, 6); assertEquals(true, zone1.equals(zone1)); assertEquals(true, zone1.equals(zone1b)); assertEquals(true, zone1.equals(zone2)); // second arg ignored assertEquals(false, zone1.equals(zone3)); assertEquals(false, zone1.equals(zone4)); } public void testHashCode() throws Exception { FixedDateTimeZone zone1 = new FixedDateTimeZone("A", "B", 1, 5); FixedDateTimeZone zone1b = new FixedDateTimeZone("A", "B", 1, 5); FixedDateTimeZone zone2 = new FixedDateTimeZone("A", "C", 1, 5); FixedDateTimeZone zone3 = new FixedDateTimeZone("A", "B", 2, 5); FixedDateTimeZone zone4 = new FixedDateTimeZone("A", "B", 1, 6); assertEquals(true, zone1.hashCode() == zone1.hashCode()); assertEquals(true, zone1.hashCode() == zone1b.hashCode()); assertEquals(true, zone1.hashCode() == zone2.hashCode()); // second arg ignored assertEquals(false, zone1.hashCode() == zone3.hashCode()); assertEquals(false, zone1.hashCode() == zone4.hashCode()); } public void testToTimeZone1() throws Exception { FixedDateTimeZone zone = new FixedDateTimeZone("+00:01", "+00:01", 60000, 60000); java.util.TimeZone tz = zone.toTimeZone(); assertEquals(60000, tz.getRawOffset()); assertEquals(60000, getOffset(tz, 1167638400000L)); assertEquals(60000, getOffset(tz, 1185951600000L)); } public void testToTimeZone2() throws Exception { FixedDateTimeZone zone = new FixedDateTimeZone("A", "B", 1, 5); java.util.TimeZone tz = zone.toTimeZone(); assertEquals(1, tz.getRawOffset()); assertEquals(1, getOffset(tz, 1167638400000L)); assertEquals(1, getOffset(tz, 1185951600000L)); } /** Make test compile on JDK 1.3. */ private int getOffset(TimeZone zone, long millis) { Date date = new Date(millis); if (zone.inDaylightTime(date)) { return zone.getRawOffset() + 3600000; } return zone.getRawOffset(); } }
/* * Copyright 2001-2005 Stephen Colebourne * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.joda.time.tz; import java.lang.reflect.Constructor; import java.lang.reflect.Modifier; import java.util.Set; import junit.framework.TestCase; import junit.framework.TestSuite; import org.joda.time.DateTimeZone; /** * This class is a JUnit test for UTCProvider. * * @author Stephen Colebourne */ public class TestUTCProvider extends TestCase { private DateTimeZone zone = null; public static void main(String[] args) { junit.textui.TestRunner.run(suite()); } public static TestSuite suite() { return new TestSuite(TestUTCProvider.class); } public TestUTCProvider(String name) { super(name); } //----------------------------------------------------------------------- public void testClass() throws Exception { Class cls = UTCProvider.class; assertEquals(true, Modifier.isPublic(cls.getModifiers())); Constructor con = cls.getDeclaredConstructor((Class[]) null); assertEquals(1, cls.getDeclaredConstructors().length); assertEquals(true, Modifier.isPublic(con.getModifiers())); } //----------------------------------------------------------------------- public void testGetAvailableIDs() throws Exception { Provider p = new UTCProvider(); Set set = p.getAvailableIDs(); assertEquals(1, set.size()); assertEquals("UTC", set.iterator().next()); } //----------------------------------------------------------------------- public void testGetZone_String() throws Exception { Provider p = new UTCProvider(); assertSame(DateTimeZone.UTC, p.getZone("UTC")); assertEquals(null, p.getZone(null)); assertEquals(null, p.getZone("Europe/London")); assertEquals(null, p.getZone("Blah")); } }
