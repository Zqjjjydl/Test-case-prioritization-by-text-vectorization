/* * Copyright 2011 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.debugging.sourcemap; import junit.framework.TestCase; /** * @author johnlenz@google.com (John Lenz) */ public class Base64Test extends TestCase { public void testBase64() { for (int i = 0; i < 64; i++) { testValue(i); } } public void testBase64EncodeInt() { assertEquals("AAAAAA", Base64.base64EncodeInt(0)); assertEquals("AAAAAQ", Base64.base64EncodeInt(1)); assertEquals("AAAAKg", Base64.base64EncodeInt(42)); assertEquals("////nA", Base64.base64EncodeInt(-100)); assertEquals("/////w", Base64.base64EncodeInt(0xffffffff)); } private void testValue(int value) { assertEquals(value, Base64.fromBase64(Base64.toBase64(value))); } }
/* * Copyright 2011 The Closure Compiler Authors. All rights reserved. * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are * met: * * * Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer. * * Redistributions in binary form must reproduce the above * copyright notice, this list of conditions and the following * disclaimer in the documentation and/or other materials provided * with the distribution. * * Neither the name of Google Inc. nor the names of its * contributors may be used to endorse or promote products derived * from this software without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */ package com.google.debugging.sourcemap; import junit.framework.TestCase; /** * @author johnlenz@google.com (John Lenz) */ public class Base64VLQTest extends TestCase { public void testBase64VLQSelectedValues1() { for (int i = 0; i < 63; i++) { testValue(i); } } public void testBase64VLQSelectedValues2() { int base = 1; for (int i = 0; i < 30; i++) { testValue(base-1); testValue(base); base *= 2; } } public void testBase64VLQSelectedSignedValues1() { for (int i = -(64*64-1); i < (64*64-1); i++) { testValue(i); } } public void testBase64VLQSelectedSignedValues2() { int base = 1; for (int i = 0; i < 30; i++) { testValue(base-1); testValue(base); base *= 2; } base = -1; for (int i = 0; i < 30; i++) { testValue(base-1); testValue(base); base *= 2; } } static class CharIteratorImpl implements Base64VLQ.CharIterator { private int current; private int length; private CharSequence cs; void set(CharSequence sb) { this.current = 0; this.length = sb.length(); this.cs = sb; } @Override public boolean hasNext() { return current < length; } @Override public char next() { return cs.charAt(current++); } } // Disable this test if it is flaky. public void testSpeed() {} // Defects4J: flaky method // public void testSpeed() { // long start = System.currentTimeMillis(); // CharIteratorImpl ci = new CharIteratorImpl(); // try { // StringBuilder sb = new StringBuilder(); // for (int i = 0; i < 1000000; i++) { // Base64VLQ.encode(sb, i); // ci.set(sb); // int result = Base64VLQ.decode(ci); // assertEquals(i, result); // sb.setLength(0); // } // } catch (Exception e) { // throw new RuntimeException("failed.", e); // } // long end = System.currentTimeMillis(); // // Was 200ms or less, use a larger number to prevent flakiness // assertTrue("too slow", end-start < 1000); // } private void testValue(int value) { try { StringBuilder sb = new StringBuilder(); Base64VLQ.encode(sb, value); CharIteratorImpl ci = new CharIteratorImpl(); ci.set(sb); int result = Base64VLQ.decode(ci); assertEquals(value, result); } catch (Exception e) { throw new RuntimeException("failed for value " + value, e); } } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.debugging.sourcemap; import com.google.debugging.sourcemap.SourceMapConsumerV1; import com.google.debugging.sourcemap.SourceMapParseException; import com.google.debugging.sourcemap.proto.Mapping.OriginalMapping; import junit.framework.TestCase; public class SourceMapConsumerV1Test extends TestCase { public SourceMapConsumerV1Test() { } public SourceMapConsumerV1Test(String name) { super(name); } public void testGetMappingForLine() throws Exception { StringBuilder sb = new StringBuilder(); sb.append("/** Begin line maps. **/{ count : 2 }\n"); sb.append("[0,,,,1,,2]\n"); sb.append("[3,,,,,,,]\n"); sb.append("/** Begin file information. **/\n"); sb.append("['test.js']\n"); sb.append("['foo.js']\n"); sb.append("/** Begin mapping definitions. **/\n"); sb.append("['test.js', 0, 1]\n"); sb.append("['bleg.js', 5, 8, 'hello']\n"); sb.append("['bleg.js', 12, 78]\n"); sb.append("['foo.js', 15, 16, 'yo!']"); SourceMapConsumerV1 sourceMap = new SourceMapConsumerV1(); sourceMap.parse(sb.toString()); OriginalMapping mapping = sourceMap.getMappingForLine(1, 1); assertNotNull(mapping); assertEquals("test.js", mapping.getOriginalFile()); assertEquals(0, mapping.getLineNumber()); assertEquals(1, mapping.getColumnPosition()); assertEquals("", mapping.getIdentifier()); mapping = sourceMap.getMappingForLine(1, 6); assertNotNull(mapping); assertEquals("bleg.js", mapping.getOriginalFile()); assertEquals(5, mapping.getLineNumber()); assertEquals(8, mapping.getColumnPosition()); assertEquals("hello", mapping.getIdentifier()); mapping = sourceMap.getMappingForLine(2, 4); assertNotNull(mapping); assertEquals("foo.js", mapping.getOriginalFile()); assertEquals(15, mapping.getLineNumber()); assertEquals(16, mapping.getColumnPosition()); assertEquals("yo!", mapping.getIdentifier()); assertNull(sourceMap.getMappingForLine(Integer.MAX_VALUE, 1)); assertNotNull(sourceMap.getMappingForLine(1, Integer.MAX_VALUE)); } public void testLineEdges() throws Exception { StringBuilder sb = new StringBuilder(); sb.append("/** Begin line maps. **/{ count : 2 }\n"); sb.append("[100]\n"); sb.append("[200]\n"); sb.append("/** Begin file information. **/\n"); sb.append("['test.js']\n"); sb.append("['foo.js']\n"); sb.append("/** Begin mapping definitions. **/\n"); for (int i = 0; i <= 200; i++) { sb.append("['foo.js', ").append(i).append(", 1]\n"); } SourceMapConsumerV1 sourceMap = new SourceMapConsumerV1(); sourceMap.parse(sb.toString()); OriginalMapping mapping = sourceMap.getMappingForLine(-1, 1); assertNull(mapping); mapping = sourceMap.getMappingForLine(0, 1); assertNull(mapping); mapping = sourceMap.getMappingForLine(1, 1); assertEquals(100, mapping.getLineNumber()); mapping = sourceMap.getMappingForLine(2, 1); assertEquals(200, mapping.getLineNumber()); mapping = sourceMap.getMappingForLine(3, 1); assertNull(mapping); } public void testColumnEdges() throws Exception { StringBuilder sb = new StringBuilder(); sb.append("/** Begin line maps. **/{ count : 1 }\n"); sb.append("[100, 101]\n"); sb.append("/** Begin file information. **/\n"); sb.append("\n"); sb.append("/** Begin mapping definitions. **/\n"); for (int i = 0; i <= 200; i++) { sb.append("['foo.js', ").append(i).append(", 1]\n"); } SourceMapConsumerV1 sourceMap = new SourceMapConsumerV1(); sourceMap.parse(sb.toString()); OriginalMapping mapping = sourceMap.getMappingForLine(1, -1); assertNull(mapping); mapping = sourceMap.getMappingForLine(1, 0); assertNull(mapping); mapping = sourceMap.getMappingForLine(1, 1); assertEquals(100, mapping.getLineNumber()); mapping = sourceMap.getMappingForLine(1, 2); assertEquals(101, mapping.getLineNumber()); // Columns beyond the end of the line are treated the same // as the last column. mapping = sourceMap.getMappingForLine(1, 3); assertEquals(101, mapping.getLineNumber()); } public void testNegativeOneInLineMap() throws Exception { StringBuilder sb = new StringBuilder(); sb.append("/** Begin line maps. **/{ count : 1 }\n"); sb.append("[200,-1,199,-1]\n"); sb.append("/** Begin file information. **/\n"); sb.append("\n"); sb.append("/** Begin mapping definitions. **/\n"); for (int i = 0; i <= 200; i++) { sb.append("['foo.js', 1, ").append(i).append("]\n"); } SourceMapConsumerV1 sourceMap = new SourceMapConsumerV1(); sourceMap.parse(sb.toString()); OriginalMapping mapping = sourceMap.getMappingForLine(1, 2); assertNull(mapping); mapping = sourceMap.getMappingForLine(1, 4); assertNull(mapping); } public void testSimpleParse() throws Exception { StringBuilder sb = new StringBuilder(); sb.append("/** Begin line maps. **/{ count : 1 }\n"); sb.append("[0,,,,1,2]\n"); sb.append("/** Begin file information. **/\n"); sb.append("['test.js']\n"); sb.append("/** Begin mapping definitions. **/\n"); sb.append("['test.js', 0, 1]\n"); sb.append("['test.js', 0, 1, 'hello']\n"); sb.append("['test.js', 0, 1]"); SourceMapConsumerV1 sourceMap = new SourceMapConsumerV1(); sourceMap.parse(sb.toString()); } public void testBlankLine() throws Exception { StringBuilder sb = new StringBuilder(); sb.append("/** Begin line maps. **/{ count : 1 }\n"); sb.append("\n"); sb.append("/** Begin file information. **/\n"); sb.append("\n"); sb.append("/** Begin mapping definitions. **/\n"); SourceMapConsumerV1 sourceMap = new SourceMapConsumerV1(); sourceMap.parse(sb.toString()); } public void testCountFailure() throws Exception { StringBuilder sb = new StringBuilder(); sb.append("/** Begin line maps. **/{ counter : 1 }\n"); assertException("Missing 'count'", sb); } public void testInvalidCountFailure() throws Exception { StringBuilder sb = new StringBuilder(); sb.append("/** Begin line maps. **/{ count : 0 }\n"); assertException("Count must be >= 1", sb); } public void testInvalidJSONFailure() throws Exception { StringBuilder sb = new StringBuilder(); sb.append("/** Begin line maps. **/{ count : 2 }\n"); sb.append("[0,,,,2\n"); assertExceptionStartsWith("JSON parse exception: org.json.JSONException: " + "Expected a ',' or ']' at ", sb); } public void testInvalidHeaderFailure() throws Exception { StringBuilder sb = new StringBuilder(); sb.append("/** Begin line maps. **/{ count : 1 }\n"); sb.append("[0,,,1]\n"); sb.append("[3,,,4]\n"); assertException( "Expected /** Begin file information. **/ got [3,,,4]", sb); } public void testInvalidPostHeaderToken() throws Exception { StringBuilder sb = new StringBuilder(); sb.append("/** Begin line maps. **/{ count : 1 }\n"); sb.append("[0,,,1]\n"); sb.append("/** Begin file information. **/f\n"); assertException("Expected /** Begin file information. **/" + " got /** Begin file information. **/f", sb); } public void testInvalidMappingArrayFailure() throws Exception { StringBuilder sb = new StringBuilder(); sb.append("/** Begin line maps. **/{ count : 1 }\n"); sb.append("[0,,,,1,2]\n"); sb.append("/** Begin file information. **/\n"); sb.append("['test.js']\n"); sb.append("/** Begin mapping definitions. **/\n"); sb.append("['test.js', 0]\n"); assertException("Invalid mapping array", sb); } public void testMultipleLineFragments() throws Exception { StringBuilder sb = new StringBuilder(); sb.append("/** Begin line maps. **/{ count : 1 }\n"); sb.append("[0,1,2,3,260,261,262]\n"); sb.append("/** Begin file information. **/\n"); sb.append("\n"); sb.append("/** Begin mapping definitions. **/\n"); for (int i = 0; i < 262; i++) { sb.append("['frog/test" + i + ".js', " + i + ", 1]\n"); } sb.append("['frog/testigloo.js', 500, 1]"); SourceMapConsumerV1 sourceMap = new SourceMapConsumerV1(); sourceMap.parse(sb.toString()); OriginalMapping mapping = sourceMap.getMappingForLine(1, 1); assertNotNull(mapping); assertEquals("frog/test0.js", mapping.getOriginalFile()); assertEquals(0, mapping.getLineNumber()); assertEquals(1, mapping.getColumnPosition()); assertEquals("", mapping.getIdentifier()); mapping = sourceMap.getMappingForLine(1, 6); assertNotNull(mapping); assertEquals("frog/test261.js", mapping.getOriginalFile()); assertEquals(261, mapping.getLineNumber()); assertEquals(1, mapping.getColumnPosition()); } public void testMultipleMappingFragments() throws Exception { StringBuilder sb = new StringBuilder(); sb.append("/** Begin line maps. **/{ count : 1 }\n"); sb.append("[0,1,2,3,260,261,262,1023]\n"); sb.append("/** Begin file information. **/\n"); sb.append("\n"); sb.append("/** Begin mapping definitions. **/\n"); for (int i = 0; i < 2000; i++) { sb.append("['frog/test" + (i / 100) + ".js', " + i + ", 1]\n"); } sb.append("['frog/testigloo.js', 500, 1]"); SourceMapConsumerV1 sourceMap = new SourceMapConsumerV1(); sourceMap.parse(sb.toString()); OriginalMapping mapping = sourceMap.getMappingForLine(1, 1); assertNotNull(mapping); assertEquals("frog/test0.js", mapping.getOriginalFile()); assertEquals(0, mapping.getLineNumber()); assertEquals(1, mapping.getColumnPosition()); assertEquals("", mapping.getIdentifier()); mapping = sourceMap.getMappingForLine(1, 6); assertNotNull(mapping); assertEquals("frog/test2.js", mapping.getOriginalFile()); assertEquals(261, mapping.getLineNumber()); assertEquals(1, mapping.getColumnPosition()); mapping = sourceMap.getMappingForLine(1, 8); assertNotNull(mapping); assertEquals("frog/test10.js", mapping.getOriginalFile()); assertEquals(1023, mapping.getLineNumber()); assertEquals(1, mapping.getColumnPosition()); } private void assertException(String exception, StringBuilder sb) { boolean exceptionRaised = false; try { SourceMapConsumerV1 sourceMap = new SourceMapConsumerV1(); sourceMap.parse(sb.toString()); } catch (SourceMapParseException pe) { assertEquals(exception, pe.getMessage()); exceptionRaised = true; } assertTrue(exceptionRaised); } private void assertExceptionStartsWith(String exception, StringBuilder sb) { boolean exceptionRaised = false; try { SourceMapConsumerV1 sourceMap = new SourceMapConsumerV1(); sourceMap.parse(sb.toString()); } catch (SourceMapParseException pe) { assertTrue( "expected <" + exception +"> but was <"+ pe.getMessage() +">", pe.getMessage().startsWith(exception)); exceptionRaised = true; } assertTrue(exceptionRaised); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.debugging.sourcemap; import com.google.debugging.sourcemap.SourceMapConsumerV2; import com.google.debugging.sourcemap.SourceMapParseException; import com.google.debugging.sourcemap.proto.Mapping.OriginalMapping; import junit.framework.TestCase; public class SourceMapConsumerV2Test extends TestCase { public SourceMapConsumerV2Test() { } public SourceMapConsumerV2Test(String name) { super(name); } public void testEmptyMap() throws Exception { StringBuilder sb = new StringBuilder(); sb.append("{\n"); sb.append("\"version\": 2,\n"); sb.append("\"file\": \"somefile.js\",\n"); sb.append("\"lineCount\": 0,\n"); sb.append("\"lineMaps\": [],\n"); sb.append("\"sources\": [],\n"); sb.append("\"mappings\": []\n"); sb.append("}\n"); SourceMapConsumerV2 sourceMap = new SourceMapConsumerV2(); sourceMap.parse(sb.toString()); } public void testGetMappingForLine() throws Exception { // Input Code: function f(foo, bar) { foo = foo + bar + 2; return foo; } String mapData = "{\n" + "\"version\":2,\n" + "\"file\":\"testcode\",\n" + "\"lineCount\":1,\n" + "\"lineMaps\":" + "[\"cAEBABIBA/ICA+ADICA/ICA+IDA9AEYBMBA5\"],\n" + "\"sources\":[\"testcode\"],\n" + "\"mappings\":[[0,1,9,\"f\"],\n" + "[0,1,9,\"f\"],\n" + "[0,1,10],\n" + "[0,1,11,\"foo\"],\n" + "[0,1,16,\"bar\"],\n" + "[0,1,21],\n" + "[0,1,23],\n" + "[0,1,23,\"foo\"],\n" + "[0,1,29,\"foo\"],\n" + "[0,1,35,\"bar\"],\n" + "[0,1,41],\n" + "[0,1,44],\n" + "[0,1,51,\"foo\"],\n" + "]\n" + "}\n"; SourceMapConsumerV2 sourceMap = new SourceMapConsumerV2(); sourceMap.parse(mapData); OriginalMapping mapping = sourceMap.getMappingForLine(1, 10); assertNotNull(mapping); assertEquals("testcode", mapping.getOriginalFile()); assertEquals(1, mapping.getLineNumber()); assertEquals(9, mapping.getColumnPosition()); assertEquals("f", mapping.getIdentifier()); mapping = sourceMap.getMappingForLine(1, 40); assertNotNull(mapping); assertEquals("testcode", mapping.getOriginalFile()); assertEquals(1, mapping.getLineNumber()); assertEquals(44, mapping.getColumnPosition()); assertEquals("", mapping.getIdentifier()); mapping = sourceMap.getMappingForLine(1, 42); assertNotNull(mapping); assertEquals("testcode", mapping.getOriginalFile()); assertEquals(1, mapping.getLineNumber()); assertEquals(51, mapping.getColumnPosition()); assertEquals("foo", mapping.getIdentifier()); assertNull(sourceMap.getMappingForLine(Integer.MAX_VALUE, 1)); assertNull(sourceMap.getMappingForLine(1, Integer.MAX_VALUE)); } public void testGetMappingForLineWithNameIndex() throws Exception { String mapData = "{\n" + "\"version\":2,\n" + "\"file\":\"testcode\",\n" + "\"lineCount\":1,\n" + "\"lineMaps\":" + "[\"cAEBABIBA/ICA+ADICA/ICA+IDA9AEYBMBA5\"],\n" + "\"sources\":[\"testcode\"],\n" + "\"names\": [\"f\"],\n" + "\"mappings\":[[0,1,9,0],\n" + "[0,1,9,0]\n" + "]\n" + "}\n"; SourceMapConsumerV2 sourceMap = new SourceMapConsumerV2(); sourceMap.parse(mapData); OriginalMapping mapping = sourceMap.getMappingForLine(1, 10); assertNotNull(mapping); assertEquals("testcode", mapping.getOriginalFile()); assertEquals(1, mapping.getLineNumber()); assertEquals(9, mapping.getColumnPosition()); assertEquals("f", mapping.getIdentifier()); } public void testInvalidJSONFailure() throws Exception { StringBuilder sb = new StringBuilder(); sb.append("notjson"); assertExceptionStartsWith("JSON parse exception: org.json.JSONException: " + "A JSONObject text must begin " + "with '{' at character 1", sb); } public void testUnknownVersion() throws Exception { StringBuilder sb = new StringBuilder(); sb.append("{\"version\": 3}"); assertException("Unknown version: 3", sb); } public void testMissingFile() throws Exception { StringBuilder sb = new StringBuilder(); sb.append("{\"version\": 2, \"file\": \"\"}"); assertException("File entry is missing or empty", sb); } private void assertException(String exception, StringBuilder sb) { boolean exceptionRaised = false; try { SourceMapConsumerV2 sourceMap = new SourceMapConsumerV2(); sourceMap.parse(sb.toString()); } catch (SourceMapParseException pe) { assertEquals(exception, pe.getMessage()); exceptionRaised = true; } assertTrue(exceptionRaised); } private void assertExceptionStartsWith(String exception, StringBuilder sb) { boolean exceptionRaised = false; try { SourceMapConsumerV2 sourceMap = new SourceMapConsumerV2(); sourceMap.parse(sb.toString()); } catch (SourceMapParseException pe) { assertTrue( "expected <" + exception +"> but was <"+ pe.getMessage() +">", pe.getMessage().startsWith(exception)); exceptionRaised = true; } assertTrue(exceptionRaised); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.debugging.sourcemap; import com.google.javascript.jscomp.SourceMap; import com.google.javascript.jscomp.SourceMap.Format; /** * Tests for {@link SourceMap}. * */ public class SourceMapGeneratorV1Test extends SourceMapTestCase { public SourceMapGeneratorV1Test() { disableColumnValidation(); } @Override protected SourceMapConsumer getSourceMapConsumer() { return new SourceMapConsumerV1(); } @Override protected Format getSourceMapFormat() { return SourceMap.Format.V1; } @Override public void setUp() { detailLevel = SourceMap.DetailLevel.ALL; } public void testBasicMapping() throws Exception { compileAndCheck("function __BASIC__() { }"); } public void testLiteralMappings() throws Exception { compileAndCheck("function __BASIC__(__PARAM1__, __PARAM2__) { " + "var __VAR__ = '__STR__'; }"); } public void testMultilineMapping() throws Exception { compileAndCheck("function __BASIC__(__PARAM1__, __PARAM2__) {\n" + "var __VAR__ = '__STR__';\n" + "var __ANO__ = \"__STR2__\";\n" + "}"); } public void testMultiFunctionMapping() throws Exception { compileAndCheck("function __BASIC__(__PARAM1__, __PARAM2__) {\n" + "var __VAR__ = '__STR__';\n" + "var __ANO__ = \"__STR2__\";\n" + "}\n\n" + "function __BASIC2__(__PARAM3__, __PARAM4__) {\n" + "var __VAR2__ = '__STR2__';\n" + "var __ANO2__ = \"__STR3__\";\n" + "}\n\n"); } public void testGoldenOutput0() throws Exception { // Empty source map test checkSourceMap("", "/** Begin line maps. **/{ \"file\" : \"testcode\"," + " \"count\": 1 }\n" + "[]\n" + "/** Begin file information. **/\n" + "[]\n" + "/** Begin mapping definitions. **/\n"); } public void testFunctionNameOutput1() throws Exception { checkSourceMap("function f() {}", "/** Begin line maps. **/{ \"file\" : \"testcode\", " + "\"count\": 1 }\n" + "[0,0,0,0,0,0,0,0,1,1,2,2,3,3]\n" + "/** Begin file information. **/\n" + "[]\n" + "/** Begin mapping definitions. **/\n" + "[\"testcode\",1,0,\"f\"]\n" + "[\"testcode\",1,9,\"f\"]\n" + "[\"testcode\",1,10]\n" + "[\"testcode\",1,13]\n"); } public void testFunctionNameOutput2() throws Exception { checkSourceMap("a.b.c = function () {};", "/** Begin line maps. **/{ \"file\" : \"testcode\", " + "\"count\": 1 }\n" + "[3,2,2,1,1,0,4,4,4,4,4,4,4,4,5,5,6,6]\n" + "/** Begin file information. **/\n" + "[]\n" + "/** Begin mapping definitions. **/\n" + "[\"testcode\",1,0]\n" + "[\"testcode\",1,0,\"c\"]\n" + "[\"testcode\",1,0,\"b\"]\n" + "[\"testcode\",1,0,\"a\"]\n" + "[\"testcode\",1,8,\"a.b.c\"]\n" + "[\"testcode\",1,17]\n" + "[\"testcode\",1,20]\n"); } public void testFunctionNameOutput3() throws Exception { checkSourceMap("var q = function () {};", "/** Begin line maps. **/{ \"file\" : \"testcode\", " + "\"count\": 1 }\n" + "[0,0,0,0,1,1,2,2,2,2,2,2,2,2,3,3,4,4]\n" + "/** Begin file information. **/\n" + "[]\n" + "/** Begin mapping definitions. **/\n" + "[\"testcode\",1,0]\n" + "[\"testcode\",1,4,\"q\"]\n" + "[\"testcode\",1,8,\"q\"]\n" + "[\"testcode\",1,17]\n" + "[\"testcode\",1,20]\n"); } public void testFunctionNameOutput4() throws Exception { checkSourceMap("({ 'q' : function () {} })", "/** Begin line maps. **/{ \"file\" : \"testcode\", " + "\"count\": 1 }\n" + "[0,0,1,1,1,0,2,2,2,2,2,2,2,2,3,3,4,4,0,0]\n" + "/** Begin file information. **/\n" + "[]\n" + "/** Begin mapping definitions. **/\n" + "[\"testcode\",1,1]\n" + "[\"testcode\",1,3]\n" + "[\"testcode\",1,9,\"q\"]\n" + "[\"testcode\",1,18]\n" + "[\"testcode\",1,21]\n"); } public void testGoldenOutput1() throws Exception { detailLevel = SourceMap.DetailLevel.ALL; checkSourceMap("function f(foo, bar) { foo = foo + bar + 2; return foo; }", "/** Begin line maps. **/{ \"file\" : \"testcode\", " + "\"count\": 1 }\n" + "[0,0,0,0,0,0,0,0,1,1,2,3,3,3,2,4,4,4,2,5,7,7,7,6,8,8,8,6," + "9,9,9,6,10,11,11,11,11,11,11,11,12,12,12,12,5]\n" + "/** Begin file information. **/\n" + "[]\n" + "/** Begin mapping definitions. **/\n" + "[\"testcode\",1,0,\"f\"]\n" + "[\"testcode\",1,9,\"f\"]\n" + "[\"testcode\",1,10]\n" + "[\"testcode\",1,11,\"foo\"]\n" + "[\"testcode\",1,16,\"bar\"]\n" + "[\"testcode\",1,21]\n" + "[\"testcode\",1,23]\n" + "[\"testcode\",1,23,\"foo\"]\n" + "[\"testcode\",1,29,\"foo\"]\n" + "[\"testcode\",1,35,\"bar\"]\n" + "[\"testcode\",1,41]\n" + "[\"testcode\",1,44]\n" + "[\"testcode\",1,51,\"foo\"]\n"); detailLevel = SourceMap.DetailLevel.SYMBOLS; checkSourceMap("function f(foo, bar) { foo = foo + bar + 2; return foo; }", "/** Begin line maps. **/{ \"file\" : \"testcode\", " + "\"count\": 1 }\n" + "[0,0,0,0,0,0,0,0,1,1,0,2,2,2,0,3,3,3,0,0,4,4,4,0,5,5,5,0," + "6,6,6,0,0,0,0,0,0,0,0,0,7,7,7,7,0]\n" + "/** Begin file information. **/\n" + "[]\n" + "/** Begin mapping definitions. **/\n" + "[\"testcode\",1,0,\"f\"]\n" + "[\"testcode\",1,9,\"f\"]\n" + "[\"testcode\",1,11,\"foo\"]\n" + "[\"testcode\",1,16,\"bar\"]\n" + "[\"testcode\",1,23,\"foo\"]\n" + "[\"testcode\",1,29,\"foo\"]\n" + "[\"testcode\",1,35,\"bar\"]\n" + "[\"testcode\",1,51,\"foo\"]\n"); } public void testGoldenOutput2() throws Exception { checkSourceMap("function f(foo, bar) {\r\n\n\n\nfoo = foo + bar + foo;" + "\nreturn foo;\n}", "/** Begin line maps. **/{ \"file\" : \"testcode\", " + "\"count\": 1 }\n" + "[0,0,0,0,0,0,0,0,1,1,2,3,3,3,2,4,4,4,2,5,7,7,7,6,8,8,8," + "6,9,9,9,6,10,10,10,11,11,11,11,11,11,11,12,12,12," + "12,5]\n" + "/** Begin file information. **/\n" + "[]\n" + "/** Begin mapping definitions. **/\n" + "[\"testcode\",1,0,\"f\"]\n" + "[\"testcode\",1,9,\"f\"]\n" + "[\"testcode\",1,10]\n" + "[\"testcode\",1,11,\"foo\"]\n" + "[\"testcode\",1,16,\"bar\"]\n" + "[\"testcode\",1,21]\n" + "[\"testcode\",5,0]\n" + "[\"testcode\",5,0,\"foo\"]\n" + "[\"testcode\",5,6,\"foo\"]\n" + "[\"testcode\",5,12,\"bar\"]\n" + "[\"testcode\",5,18,\"foo\"]\n" + "[\"testcode\",6,0]\n" + "[\"testcode\",6,7,\"foo\"]\n"); } public void testGoldenOutput3() throws Exception { checkSourceMap("c:\\myfile.js", "foo;", "/** Begin line maps. **/{ \"file\" : \"testcode\", " + "\"count\": 1 }\n" + "[0,0,0]\n" + "/** Begin file information. **/\n" + "[]\n" + "/** Begin mapping definitions. **/\n" + "[\"c:\\\\myfile.js\",1,0,\"foo\"]\n"); } public void testGoldenOutput4() throws Exception { checkSourceMap("c:\\myfile.js", "foo; boo; goo;", "/** Begin line maps. **/" + "{ \"file\" : \"testcode\", \"count\": 1 }\n" + "[0,0,0,1,1,1,1,2,2,2,2]\n" + "/** Begin file information. **/\n" + "[]\n" + "/** Begin mapping definitions. **/\n" + "[\"c:\\\\myfile.js\",1,0,\"foo\"]\n" + "[\"c:\\\\myfile.js\",1,7,\"boo\"]\n" + "[\"c:\\\\myfile.js\",1,14,\"goo\"]\n"); } public void testGoldenOutput5() throws Exception { detailLevel = SourceMap.DetailLevel.ALL; checkSourceMap("c:\\myfile.js", "/** @preserve\n" + " * this is a test.\n" + " */\n" + "var foo=a + 'this is a really long line that will force the" + " mapping to span multiple lines 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + "' + c + d + e;", "/** Begin line maps. **/" + "{ \"file\" : \"testcode\", \"count\": 6 }\n" + "[]\n" + "[]\n" + "[]\n" + "[]\n" + "[0,0,0,0,1,1,1,1,2,1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3," + "3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3]\n" + "[4,1,5,1,6]\n" + "/** Begin file information. **/\n" + "[]\n" + "[]\n" + "[]\n" + "[]\n" + "[]\n" + "[]\n" + "/** Begin mapping definitions. **/\n" + "[\"c:\\\\myfile.js\",4,0]\n" + "[\"c:\\\\myfile.js\",4,4,\"foo\"]\n" + "[\"c:\\\\myfile.js\",4,8,\"a\"]\n" + "[\"c:\\\\myfile.js\",4,12]\n" + "[\"c:\\\\myfile.js\",4,1314,\"c\"]\n" + "[\"c:\\\\myfile.js\",4,1318,\"d\"]\n" + "[\"c:\\\\myfile.js\",4,1322,\"e\"]\n"); detailLevel = SourceMap.DetailLevel.SYMBOLS; checkSourceMap("c:\\myfile.js", "/** @preserve\n" + " * this is a test.\n" + " */\n" + "var foo=a + 'this is a really long line that will force the" + " mapping to span multiple lines 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + "' + c + d + e;", "/** Begin line maps. **/" + "{ \"file\" : \"testcode\", \"count\": 6 }\n" + "[]\n" + "[]\n" + "[]\n" + "[]\n" + "[-1,-1,-1,-1,0,0,0,0,1]\n" + "[2,0,3,0,4]\n" + "/** Begin file information. **/\n" + "[]\n" + "[]\n" + "[]\n" + "[]\n" + "[]\n" + "[]\n" + "/** Begin mapping definitions. **/\n" + "[\"c:\\\\myfile.js\",4,4,\"foo\"]\n" + "[\"c:\\\\myfile.js\",4,8,\"a\"]\n" + "[\"c:\\\\myfile.js\",4,1314,\"c\"]\n" + "[\"c:\\\\myfile.js\",4,1318,\"d\"]\n" + "[\"c:\\\\myfile.js\",4,1322,\"e\"]\n"); } public void testBasicDeterminism() throws Exception { RunResult result1 = compile("file1", "foo;", "file2", "bar;"); RunResult result2 = compile("file2", "foo;", "file1", "bar;"); String map1 = getSourceMap(result1); String map2 = getSourceMap(result2); // Assert that the files section of the maps are the same. The actual // entries will differ, so we cannot do a simple full comparison. // Line 5 has the file information. String files1 = map1.split("\n")[4]; String files2 = map2.split("\n")[4]; assertEquals(files1, files2); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.debugging.sourcemap; import com.google.debugging.sourcemap.SourceMapGeneratorV2.LineMapEncoder; import com.google.javascript.jscomp.SourceMap; import com.google.javascript.jscomp.SourceMap.Format; import java.io.IOException; /** * Tests for {@link SourceMap}. * */ public class SourceMapGeneratorV2Test extends SourceMapTestCase { public SourceMapGeneratorV2Test() { disableColumnValidation(); } @Override protected SourceMapConsumer getSourceMapConsumer() { return new SourceMapConsumerV2(); } @Override protected Format getSourceMapFormat() { return SourceMap.Format.V2; } @Override public void setUp() { detailLevel = SourceMap.DetailLevel.ALL; } public void testBasicMapping() throws Exception { compileAndCheck("function __BASIC__() { }"); } public void testBasicMappingGoldenOutput() throws Exception { // Empty source map test checkSourceMap("function __BASIC__() { }", //"/** Source Map **/\n" + "{\n" + "\"version\":2,\n" + "\"file\":\"testcode\",\n" + "\"lineCount\":1,\n" + "\"lineMaps\":[\"cAkBEBEB\"],\n" + "\"mappings\":[[0,1,0,0],\n" + "[0,1,9,0],\n" + "[0,1,18],\n" + "[0,1,21],\n" + "],\n" + "\"sources\":[\"testcode\"],\n" + "\"names\":[\"__BASIC__\"]\n" + "}\n"); } public void testLiteralMappings() throws Exception { compileAndCheck("function __BASIC__(__PARAM1__, __PARAM2__) { " + "var __VAR__ = '__STR__'; }"); } public void testLiteralMappingsGoldenOutput() throws Exception { // Empty source map test checkSourceMap("function __BASIC__(__PARAM1__, __PARAM2__) { " + "var __VAR__ = '__STR__'; }", //"/** Source Map **/\n" + "{\n" + "\"version\":2,\n" + "\"file\":\"testcode\",\n" + "\"lineCount\":1,\n" + "\"lineMaps\":[\"cAkBABkBA/kCA+ADMBcBgBA9\"],\n" + "\"mappings\":[[0,1,0,0],\n" + "[0,1,9,0],\n" + "[0,1,18],\n" + "[0,1,19,1],\n" + "[0,1,31,2],\n" + "[0,1,43],\n" + "[0,1,45],\n" + "[0,1,49,3],\n" + "[0,1,59],\n" + "],\n" + "\"sources\":[\"testcode\"],\n" + "\"names\":[" + "\"__BASIC__\",\"__PARAM1__\",\"__PARAM2__\"," + "\"__VAR__\"]\n" + "}\n"); } public void testMultilineMapping() throws Exception { compileAndCheck("function __BASIC__(__PARAM1__, __PARAM2__) {\n" + "var __VAR__ = '__STR__';\n" + "var __ANO__ = \"__STR2__\";\n" + "}"); } public void testMultiFunctionMapping() throws Exception { compileAndCheck("function __BASIC__(__PARAM1__, __PARAM2__) {\n" + "var __VAR__ = '__STR__';\n" + "var __ANO__ = \"__STR2__\";\n" + "}\n\n" + "function __BASIC2__(__PARAM3__, __PARAM4__) {\n" + "var __VAR2__ = '__STR2__';\n" + "var __ANO2__ = \"__STR3__\";\n" + "}\n\n"); } public void testGoldenOutput0() throws Exception { // Empty source map test checkSourceMap("", "{\n" + "\"version\":2,\n" + "\"file\":\"testcode\",\n" + "\"lineCount\":1,\n" + "\"lineMaps\":[\"\"],\n" + "\"mappings\":[],\n" + "\"sources\":[\"testcode\"],\n" + "\"names\":[]\n" + "}\n"); } public void testGoldenOutput1() throws Exception { detailLevel = SourceMap.DetailLevel.ALL; checkSourceMap( "function f(foo, bar) { foo = foo + bar + 2; return foo; }", "{\n" + "\"version\":2,\n" + "\"file\":\"testcode\",\n" + "\"lineCount\":1,\n" + "\"lineMaps\":[\"cAEBABIBA/ICA+ADICA/ICA+IDA9AEYBMBA5\"],\n" + "\"mappings\":[[0,1,0,0],\n" + "[0,1,9,0],\n" + "[0,1,10],\n" + "[0,1,11,1],\n" + "[0,1,16,2],\n" + "[0,1,21],\n" + "[0,1,23],\n" + "[0,1,23,1],\n" + "[0,1,29,1],\n" + "[0,1,35,2],\n" + "[0,1,41],\n" + "[0,1,44],\n" + "[0,1,51,1],\n" + "],\n" + "\"sources\":[\"testcode\"],\n" + "\"names\":[\"f\",\"foo\",\"bar\"]\n" + "}\n"); detailLevel = SourceMap.DetailLevel.SYMBOLS; checkSourceMap("function f(foo, bar) { foo = foo + bar + 2; return foo; }", "{\n" + "\"version\":2,\n" + "\"file\":\"testcode\",\n" + "\"lineCount\":1,\n" + "\"lineMaps\":[\"cAEBA/ICA+IDE9IEA8IFA7IGg6MHA5\"],\n" + "\"mappings\":[[0,1,0,0],\n" + "[0,1,9,0],\n" + "[0,1,11,1],\n" + "[0,1,16,2],\n" + "[0,1,23,1],\n" + "[0,1,29,1],\n" + "[0,1,35,2],\n" + "[0,1,51,1],\n" + "],\n" + "\"sources\":[\"testcode\"],\n" + "\"names\":[\"f\",\"foo\",\"bar\"]\n" + "}\n"); } public void testGoldenOutput2() throws Exception { checkSourceMap("function f(foo, bar) {\r\n\n\n\nfoo = foo + bar + foo;" + "\nreturn foo;\n}", "{\n" + "\"version\":2,\n" + "\"file\":\"testcode\",\n" + "\"lineCount\":1,\n" + "\"lineMaps\":[" + "\"cAEBABIBA/ICA+ADICA/ICA+IDA9IEYBMBA5\"],\n" + "\"mappings\":[[0,1,0,0],\n" + "[0,1,9,0],\n" + "[0,1,10],\n" + "[0,1,11,1],\n" + "[0,1,16,2],\n" + "[0,1,21],\n" + "[0,5,0],\n" + "[0,5,0,1],\n" + "[0,5,6,1],\n" + "[0,5,12,2],\n" + "[0,5,18,1],\n" + "[0,6,0],\n" + "[0,6,7,1],\n" + "],\n" + "\"sources\":[\"testcode\"],\n" + "\"names\":[\"f\",\"foo\",\"bar\"]\n" + "}\n"); } public void testGoldenOutput3() throws Exception { checkSourceMap("c:\\myfile.js", "foo;", "{\n" + "\"version\":2,\n" + "\"file\":\"testcode\",\n" + "\"lineCount\":1,\n" + "\"lineMaps\":[\"IA\"],\n" + "\"mappings\":[[0,1,0,0],\n" + "],\n" + "\"sources\":[\"c:\\\\myfile.js\"],\n" + "\"names\":[\"foo\"]\n" + "}\n"); } public void testGoldenOutput4() throws Exception { checkSourceMap("c:\\myfile.js", "foo; boo; goo;", "{\n" + "\"version\":2,\n" + "\"file\":\"testcode\",\n" + "\"lineCount\":1,\n" + "\"lineMaps\":[\"IAMBMB\"],\n" + "\"mappings\":[[0,1,0,0],\n" + "[0,1,7,1],\n" + "[0,1,14,2],\n" + "],\n" + "\"sources\":[\"c:\\\\myfile.js\"],\n" + "\"names\":[\"foo\",\"boo\",\"goo\"]\n" + "}\n"); } public void testGoldenOutput5() throws Exception { detailLevel = SourceMap.DetailLevel.ALL; checkSourceMap("c:\\myfile.js", "/** @preserve\n" + " * this is a test.\n" + " */\n" + "var foo=a + 'this is a really long line that will force the" + " mapping to span multiple lines 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + "' + c + d + e;", "{\n" + "\"version\":2,\n" + "\"file\":\"testcode\",\n" + "\"lineCount\":6,\n" + "\"lineMaps\":[\"\",\n" + "\"\",\n" + "\"\",\n" + "\"\",\n" + "\"MAMBABA/!!AUSC\",\n" + "\"AEA9AEA8AF\"],\n" + "\"mappings\":[[0,4,0],\n" + "[0,4,4,0],\n" + "[0,4,8,1],\n" + "[0,4,12],\n" + "[0,4,1314,2],\n" + "[0,4,1318,3],\n" + "[0,4,1322,4],\n" + "],\n" + "\"sources\":[\"c:\\\\myfile.js\"],\n" + "\"names\":[\"foo\",\"a\",\"c\",\"d\",\"e\"]\n" + "}\n"); detailLevel = SourceMap.DetailLevel.SYMBOLS; checkSourceMap("c:\\myfile.js", "/** @preserve\n" + " * this is a test.\n" + " */\n" + "var foo=a + 'this is a really long line that will force the" + " mapping to span multiple lines 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + "' + c + d + e;", "{\n" + "\"version\":2,\n" + "\"file\":\"testcode\",\n" + "\"lineCount\":6,\n" + "\"lineMaps\":[\"\",\n" + "\"\",\n" + "\"\",\n" + "\"\",\n" + "\"M/MBAB\",\n" + "\"ACA+ADA9AE\"],\n" + "\"mappings\":[[0,4,4,0],\n" + "[0,4,8,1],\n" + "[0,4,1314,2],\n" + "[0,4,1318,3],\n" + "[0,4,1322,4],\n" + "],\n" + "\"sources\":[\"c:\\\\myfile.js\"],\n" + "\"names\":[\"foo\",\"a\",\"c\",\"d\",\"e\"]\n" + "}\n"); } public void testBasicDeterminism() throws Exception { RunResult result1 = compile("file1", "foo;", "file2", "bar;"); RunResult result2 = compile("file2", "foo;", "file1", "bar;"); String map1 = getSourceMap(result1); String map2 = getSourceMap(result2); // Assert that the files section of the maps are the same. The actual // entries will differ, so we cannot do a simple full comparison. // Line 5 has the file information. String files1 = map1.split("\n")[4]; String files2 = map2.split("\n")[4]; assertEquals(files1, files2); } private int getRelativeId(int id, int lastId) { int length = LineMapEncoder.getRelativeMappingIdLength(id, lastId); int result = LineMapEncoder.getRelativeMappingId(id, length, lastId); int inverse = SourceMapLineDecoder.getIdFromRelativeId( result, length, lastId); assertEquals(id, inverse); return result; } public void testEncodingRelativeId() { assertEquals(0, getRelativeId(0, 0)); assertEquals(64 + (-1), getRelativeId(-1, 0)); assertEquals(64 + (-32), getRelativeId(0, 32)); assertEquals(31, getRelativeId(31, 0)); assertEquals(4096 + (-33), getRelativeId(0, 33)); assertEquals(32, getRelativeId(32, 0)); } public void testEncodingIdLength() { assertEquals(1, LineMapEncoder.getRelativeMappingIdLength(0, 0)); assertEquals(1, LineMapEncoder.getRelativeMappingIdLength(-1, 0)); assertEquals(1, LineMapEncoder.getRelativeMappingIdLength(0, 32)); assertEquals(1, LineMapEncoder.getRelativeMappingIdLength(31, 0)); assertEquals(2, LineMapEncoder.getRelativeMappingIdLength(0, 33)); assertEquals(2, LineMapEncoder.getRelativeMappingIdLength(32, 0)); assertEquals(2, LineMapEncoder.getRelativeMappingIdLength(2047, 0)); assertEquals(3, LineMapEncoder.getRelativeMappingIdLength(2048, 0)); assertEquals(2, LineMapEncoder.getRelativeMappingIdLength(0, 2048)); assertEquals(3, LineMapEncoder.getRelativeMappingIdLength(0, 2049)); } private String getEntry(int id, int lastId, int reps) throws IOException { StringBuilder sb = new StringBuilder(); LineMapEncoder.encodeEntry(sb, id, lastId, reps); return sb.toString(); } public void testEncoding() throws IOException { assertEquals("AA", getEntry(0, 0, 1)); assertEquals("EA", getEntry(0, 0, 2)); assertEquals("8A", getEntry(0, 0, 16)); assertEquals("!AQA", getEntry(0, 0, 17)); assertEquals("!ARA", getEntry(0, 0, 18)); assertEquals("!A+A", getEntry(0, 0, 63)); assertEquals("!A/A", getEntry(0, 0, 64)); assertEquals("!!ABAA", getEntry(0, 0, 65)); assertEquals("!!A//A", getEntry(0, 0, 4096)); assertEquals("!!!ABAAA", getEntry(0, 0, 4097)); assertEquals("Af", getEntry(31, 0, 1)); assertEquals("BAg", getEntry(32, 0, 1)); assertEquals("AB", getEntry(32, 31, 1)); assertEquals("!AQf", getEntry(31, 0, 17)); assertEquals("!BQAg", getEntry(32, 0, 17)); assertEquals("!AQB", getEntry(32, 31, 17)); assertEquals("!A/B", getEntry(32, 31, 64)); assertEquals("!!ABAB", getEntry(32, 31, 65)); } }
/* * Copyright 2011 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.debugging.sourcemap; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.SourceMap; import com.google.javascript.jscomp.SourceMap.Format; import java.io.IOException; import java.io.StringWriter; import java.util.LinkedHashMap; import java.util.List; /** * @author johnlenz@google.com (John Lenz) */ public class SourceMapGeneratorV3Test extends SourceMapTestCase { public SourceMapGeneratorV3Test() { } @Override protected SourceMapConsumer getSourceMapConsumer() { return new SourceMapConsumerV3(); } @Override protected Format getSourceMapFormat() { return SourceMap.Format.V3; } public void testBasicMapping1() throws Exception { compileAndCheck("function __BASIC__() { }"); } public void testBasicMappingGoldenOutput() throws Exception { // Empty source map test checkSourceMap("function __BASIC__() { }", "{\n" + "\"version\":3,\n" + "\"file\":\"testcode\",\n" + "\"lineCount\":1,\n" + "\"mappings\":\"AAAAA,QAASA,UAAS,EAAG;\",\n" + "\"sources\":[\"testcode\"],\n" + "\"names\":[\"__BASIC__\"]\n" + "}\n"); } public void testBasicMapping2() throws Exception { compileAndCheck("function __BASIC__(__PARAM1__) {}"); } public void testLiteralMappings() throws Exception { compileAndCheck("function __BASIC__(__PARAM1__, __PARAM2__) { " + "var __VAR__ = '__STR__'; }"); } public void testLiteralMappingsGoldenOutput() throws Exception { // Empty source map test checkSourceMap("function __BASIC__(__PARAM1__, __PARAM2__) { " + "var __VAR__ = '__STR__'; }", "{\n" + "\"version\":3,\n" + "\"file\":\"testcode\",\n" + "\"lineCount\":1,\n" + "\"mappings\":\"AAAAA,QAASA,UAAS,CAACC,UAAD,CAAaC,UAAb," + "CAAyB,CAAE,IAAIC,QAAU,SAAhB;\",\n" + "\"sources\":[\"testcode\"],\n" + "\"names\":[\"__BASIC__\",\"__PARAM1__\",\"__PARAM2__\"," + "\"__VAR__\"]\n" + "}\n"); } public void testMultilineMapping() throws Exception { compileAndCheck("function __BASIC__(__PARAM1__, __PARAM2__) {\n" + "var __VAR__ = '__STR__';\n" + "var __ANO__ = \"__STR2__\";\n" + "}"); } public void testMultilineMapping2() throws Exception { compileAndCheck("function __BASIC__(__PARAM1__, __PARAM2__) {\n" + "var __VAR__ = 1;\n" + "var __ANO__ = 2;\n" + "}"); } public void testMultiFunctionMapping() throws Exception { compileAndCheck("function __BASIC__(__PARAM1__, __PARAM2__) {\n" + "var __VAR__ = '__STR__';\n" + "var __ANO__ = \"__STR2__\";\n" + "}\n" + "function __BASIC2__(__PARAM3__, __PARAM4__) {\n" + "var __VAR2__ = '__STR2__';\n" + "var __ANO2__ = \"__STR3__\";\n" + "}\n"); } public void testGoldenOutput0() throws Exception { // Empty source map test checkSourceMap("", "{\n" + "\"version\":3,\n" + "\"file\":\"testcode\",\n" + "\"lineCount\":1,\n" + "\"mappings\":\";\",\n" + "\"sources\":[],\n" + "\"names\":[]\n" + "}\n"); } public void testGoldenOutput0a() throws Exception { // Empty source map test checkSourceMap("a;", "{\n" + "\"version\":3,\n" + "\"file\":\"testcode\",\n" + "\"lineCount\":1,\n" + "\"mappings\":\"AAAAA;\",\n" + "\"sources\":[\"testcode\"],\n" + "\"names\":[\"a\"]\n" + "}\n"); } public void testGoldenOutput1() throws Exception { detailLevel = SourceMap.DetailLevel.ALL; checkSourceMap("function f(foo, bar) { foo = foo + bar + 2; return foo; }", "{\n" + "\"version\":3,\n" + "\"file\":\"testcode\",\n" + "\"lineCount\":1,\n" + "\"mappings\":\"AAAAA,QAASA,EAAC,CAACC,GAAD,CAAMC,GAAN," + "CAAW,CAAED,GAAA,CAAMA,GAAN,CAAYC,GAAZ,CAAkB,CAAG," + "OAAOD,IAA9B;\",\n" + "\"sources\":[\"testcode\"],\n" + "\"names\":[\"f\",\"foo\",\"bar\"]\n" + "}\n"); detailLevel = SourceMap.DetailLevel.SYMBOLS; checkSourceMap("function f(foo, bar) { foo = foo + bar + 2; return foo; }", "{\n" + "\"version\":3,\n" + "\"file\":\"testcode\",\n" + "\"lineCount\":1,\n" + "\"mappings\":\"AAAAA,QAASA,EAATA,CAAWC,GAAXD,CAAgBE," + "GAAhBF,EAAuBC,GAAvBD,CAA6BC,GAA7BD,CAAmCE,GAAnCF," + "SAAmDC,IAAnDD;\",\n" + "\"sources\":[\"testcode\"],\n" + "\"names\":[\"f\",\"foo\",\"bar\"]\n" + "}\n"); } public void testGoldenOutput2() throws Exception { checkSourceMap("function f(foo, bar) {\r\n\n\n\nfoo = foo + bar + foo;" + "\nreturn foo;\n}", "{\n" + "\"version\":3,\n" + "\"file\":\"testcode\",\n" + "\"lineCount\":1,\n" + "\"mappings\":\"AAAAA,QAASA,EAAC,CAACC,GAAD,CAAMC,GAAN," + "CAAW,CAIrBD,GAAA,CAAMA,GAAN,CAAYC,GAAZ,CAAkBD," + "GAClB,OAAOA,IALc;\",\n" + "\"sources\":[\"testcode\"],\n" + "\"names\":[\"f\",\"foo\",\"bar\"]\n" + "}\n"); } public void testGoldenOutput3() throws Exception { checkSourceMap("c:\\myfile.js", "foo;", "{\n" + "\"version\":3,\n" + "\"file\":\"testcode\",\n" + "\"lineCount\":1,\n" + "\"mappings\":\"AAAAA;\",\n" + "\"sources\":[\"c:\\\\myfile.js\"],\n" + "\"names\":[\"foo\"]\n" + "}\n"); } public void testGoldenOutput4() throws Exception { checkSourceMap("c:\\myfile.js", "foo; boo; goo;", "{\n" + "\"version\":3,\n" + "\"file\":\"testcode\",\n" + "\"lineCount\":1,\n" + "\"mappings\":\"AAAAA,GAAOC,IAAOC;\",\n" + "\"sources\":[\"c:\\\\myfile.js\"],\n" + "\"names\":[\"foo\",\"boo\",\"goo\"]\n" + "}\n"); } public void testGoldenOutput5() throws Exception { detailLevel = SourceMap.DetailLevel.ALL; checkSourceMap( "c:\\myfile.js", "/** @preserve\n" + " * this is a test.\n" + " */\n" + "var foo=a + 'this is a really long line that will force the" + " mapping to span multiple lines 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + "' + c + d + e;", "{\n" + "\"version\":3,\n" + "\"file\":\"testcode\",\n" + "\"lineCount\":6,\n" + "\"mappings\":\"A;;;;AAGA,IAAIA,IAAIC,CAAJD,CAAQ,mxCAARA;AAA8xCE," + "CAA9xCF,CAAkyCG,CAAlyCH,CAAsyCI;\",\n" + "\"sources\":[\"c:\\\\myfile.js\"],\n" + "\"names\":[\"foo\",\"a\",\"c\",\"d\",\"e\"]\n" + "}\n"); detailLevel = SourceMap.DetailLevel.SYMBOLS; checkSourceMap("c:\\myfile.js", "/** @preserve\n" + " * this is a test.\n" + " */\n" + "var foo=a + 'this is a really long line that will force the" + " mapping to span multiple lines 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + " 123456789 123456789 123456789 123456789 123456789" + "' + c + d + e;", "{\n" + "\"version\":3,\n" + "\"file\":\"testcode\",\n" + "\"lineCount\":6,\n" + "\"mappings\":\"A;;;;IAGIA,IAAIC,CAAJD;AAA8xCE,CAA9xCF,CAAkyCG," + "CAAlyCH,CAAsyCI;\",\n" + "\"sources\":[\"c:\\\\myfile.js\"],\n" + "\"names\":[\"foo\",\"a\",\"c\",\"d\",\"e\"]\n" + "}\n"); } public void testBasicDeterminism() throws Exception { RunResult result1 = compile("file1", "foo;", "file2", "bar;"); RunResult result2 = compile("file2", "foo;", "file1", "bar;"); String map1 = getSourceMap(result1); String map2 = getSourceMap(result2); // Assert that the files section of the maps are the same. The actual // entries will differ, so we cannot do a simple full comparison. // Line 5 has the file information. String files1 = map1.split("\n")[4]; String files2 = map2.split("\n")[4]; assertEquals(files1, files2); } public void testWriteMetaMap() throws IOException { StringWriter out = new StringWriter(); String name = "./app.js"; List<SourceMapSection> appSections = Lists.newArrayList( SourceMapSection.forURL("src1", 0, 0), SourceMapSection.forURL("src2", 100, 10), SourceMapSection.forURL("src3", 150, 5)); SourceMapGeneratorV3 generator = new SourceMapGeneratorV3(); generator.appendIndexMapTo(out, name, appSections); assertEquals( "{\n" + "\"version\":3,\n" + "\"file\":\"./app.js\",\n" + "\"sections\":[\n" + "{\n" + "\"offset\":{\n" + "\"line\":0,\n" + "\"column\":0\n" + "},\n" + "\"url\":\"src1\"\n" + "},\n" + "{\n" + "\"offset\":{\n" + "\"line\":100,\n" + "\"column\":10\n" + "},\n" + "\"url\":\"src2\"\n" + "},\n" + "{\n" + "\"offset\":{\n" + "\"line\":150,\n" + "\"column\":5\n" + "},\n" + "\"url\":\"src3\"\n" + "}\n" + "]\n" + "}\n", out.toString()); } private String getEmptyMapFor(String name) throws IOException { StringWriter out = new StringWriter(); SourceMapGeneratorV3 generator = new SourceMapGeneratorV3(); generator.appendTo(out, name); return out.toString(); } public void testWriteMetaMap2() throws IOException { StringWriter out = new StringWriter(); String name = "./app.js"; List<SourceMapSection> appSections = Lists.newArrayList( // Map and URLs can be mixed. SourceMapSection.forMap(getEmptyMapFor("./part.js"), 0, 0), SourceMapSection.forURL("src2", 100, 10)); SourceMapGeneratorV3 generator = new SourceMapGeneratorV3(); generator.appendIndexMapTo(out, name, appSections); assertEquals( "{\n" + "\"version\":3,\n" + "\"file\":\"./app.js\",\n" + "\"sections\":[\n" + "{\n" + "\"offset\":{\n" + "\"line\":0,\n" + "\"column\":0\n" + "},\n" + "\"map\":{\n" + "\"version\":3,\n" + "\"file\":\"./part.js\",\n" + "\"lineCount\":1,\n" + "\"mappings\":\";\",\n" + "\"sources\":[],\n" + "\"names\":[]\n" + "}\n" + "\n" + "},\n" + "{\n" + "\"offset\":{\n" + "\"line\":100,\n" + "\"column\":10\n" + "},\n" + "\"url\":\"src2\"\n" + "}\n" + "]\n" + "}\n", out.toString()); } public void testParseSourceMetaMap() throws Exception { final String INPUT1 = "file1"; final String INPUT2 = "file2"; LinkedHashMap<String, String> inputs = Maps.newLinkedHashMap(); inputs.put(INPUT1, "var __FOO__ = 1;"); inputs.put(INPUT2, "var __BAR__ = 2;"); RunResult result1 = compile(inputs.get(INPUT1), INPUT1); RunResult result2 = compile(inputs.get(INPUT2), INPUT2); final String MAP1 = "map1"; final String MAP2 = "map2"; final LinkedHashMap<String, String> maps = Maps.newLinkedHashMap(); maps.put(MAP1, result1.sourceMapFileContent); maps.put(MAP2, result2.sourceMapFileContent); List<SourceMapSection> sections = Lists.newArrayList(); StringBuilder output = new StringBuilder(); FilePosition offset = appendAndCount(output, result1.generatedSource); sections.add(SourceMapSection.forURL(MAP1, 0, 0)); output.append(result2.generatedSource); sections.add( SourceMapSection.forURL(MAP2, offset.getLine(), offset.getColumn())); SourceMapGeneratorV3 generator = new SourceMapGeneratorV3(); StringBuilder mapContents = new StringBuilder(); generator.appendIndexMapTo(mapContents, "out.js", sections); check(inputs, output.toString(), mapContents.toString(), new SourceMapSupplier() { @Override public String getSourceMap(String url){ return maps.get(url); }}); } public void testSourceMapMerging() throws Exception { final String INPUT1 = "file1"; final String INPUT2 = "file2"; LinkedHashMap<String, String> inputs = Maps.newLinkedHashMap(); inputs.put(INPUT1, "var __FOO__ = 1;"); inputs.put(INPUT2, "var __BAR__ = 2;"); RunResult result1 = compile(inputs.get(INPUT1), INPUT1); RunResult result2 = compile(inputs.get(INPUT2), INPUT2); StringBuilder output = new StringBuilder(); FilePosition offset = appendAndCount(output, result1.generatedSource); output.append(result2.generatedSource); SourceMapGeneratorV3 generator = new SourceMapGeneratorV3(); generator.mergeMapSection(0, 0, result1.sourceMapFileContent); generator.mergeMapSection(offset.getLine(), offset.getColumn(), result2.sourceMapFileContent); StringBuilder mapContents = new StringBuilder(); generator.appendTo(mapContents, "out.js"); check(inputs, output.toString(), mapContents.toString()); } FilePosition count(String js) { int line = 0, column = 0; for (int i = 0; i < js.length(); i++) { if (js.charAt(i) == '\n') { line++; column = 0; } else { column++; } } return new FilePosition(line, column); } FilePosition appendAndCount(Appendable out, String js) throws IOException { out.append(js); return count(js); } }
/* * Copyright 2006 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Tests for {@link AliasExternals}. * */ public class AliasExternalsTest extends CompilerTestCase { private static String EXTERNS = // Globals "/** @const */ var window;" + "/** @const */ var document;" + "var arguments;var _USER_ID;var ActiveXObject;" + "function eval(x) {}" + // Properties "window.setTimeout;" + "window.eval;" + "props.window;props.innerHTML;props.length;props.prototype;props.length;" + // More globals "/** @noalias */ var RangeObject; " + "var /** @noalias */ RuntimeObject, SelectionObject;" + "/** @noalias */ function NoAliasFunction() {};"; // Blacklist and whitelist of globals. Assign to these before running test // if you want to factor them in to the test, otherwise they will be null. private String unaliasableGlobals; private String aliasableGlobals; public AliasExternalsTest() { super(EXTERNS); } @Override protected int getNumRepetitions() { // This pass only runs once. return 1; } @Override public void setUp() { super.enableLineNumberCheck(false); super.enableNormalize(); unaliasableGlobals = null; aliasableGlobals = null; } /** * Test standard global aliasing. */ public void testGlobalAlias() { test("window.setTimeout(function() {}, 0);" + "var doc=window.document;" + "window.alert(\"foo\");" + "window.eval(\"1\");" + "window.location.href=\"http://www.example.com\";" + "function foo() {var window = \"bar\"; return window}foo();", "var GLOBAL_window=window;" + formatPropNameDecl("setTimeout") + "GLOBAL_window[$$PROP_setTimeout](function() {}, 0);" + "var doc=GLOBAL_window.document;" + "GLOBAL_window.alert(\"foo\");" + "GLOBAL_window.eval(\"1\");" + "GLOBAL_window.location.href=\"http://www.example.com\";" + "function foo() {var window = \"bar\"; return window}foo();"); } /** * Some globals should not be aliased because they have special meaning * within the language (like arguments). */ public void testUnaliasable() { test("function foo() {" + "var x=arguments.length;" + "var y=arguments.length;" + "var z=arguments.length;" + "var w=arguments.length;" + "return x + y + z + w" + "};foo();", formatPropNameDecl("length") + "function foo() {" + "var x=arguments[$$PROP_length];" + "var y=arguments[$$PROP_length];" + "var z=arguments[$$PROP_length];" + "var w=arguments[$$PROP_length];" + "return x + y + z + w" + "};foo();"); test("var x=new ActiveXObject();" + "x.foo=\"bar\";" + "var y=new ActiveXObject();" + "y.foo=\"bar\";" + "var z=new ActiveXObject();" + "z.foo=\"bar\";", "var x=new ActiveXObject();" + "x.foo=\"bar\";" + "var y=new ActiveXObject();" + "y.foo=\"bar\";" + "var z=new ActiveXObject();" + "z.foo=\"bar\";"); test("var _a=eval('foo'),_b=eval('foo'),_c=eval('foo'),_d=eval('foo')," + "_e=eval('foo'),_f=eval('foo'),_g=eval('foo');", "var _a=eval('foo'),_b=eval('foo'),_c=eval('foo'),_d=eval('foo')," + "_e=eval('foo'),_f=eval('foo'),_g=eval('foo');"); } /** * Test using a whitelist to explicitly alias only specific * identifiers. */ public void testAliasableGlobals() { aliasableGlobals = "notused,length"; test("function foo() {" + "var x=arguments.length;" + "var y=arguments.length;" + "var z=arguments.length;" + "var w=arguments.length;" + "return x + y + z + w" + "};foo();", formatPropNameDecl("length") + "function foo() {" + "var x=arguments[$$PROP_length];" + "var y=arguments[$$PROP_length];" + "var z=arguments[$$PROP_length];" + "var w=arguments[$$PROP_length];" + "return x + y + z + w" + "};foo();"); aliasableGlobals = "notused,notlength"; test("function foo() {" + "var x=arguments.length;" + "var y=arguments.length;" + "var z=arguments.length;" + "var w=arguments.length;" + "return x + y + z + w" + "};foo();", "function foo() {" + "var x=arguments.length;" + "var y=arguments.length;" + "var z=arguments.length;" + "var w=arguments.length;" + "return x + y + z + w" + "};foo();"); } /** * Test combined usage of aliasable and unaliasable global lists. */ public void testAliasableAndUnaliasableGlobals() { // Only aliasable provided - OK aliasableGlobals = "foo,bar"; unaliasableGlobals = ""; test("var x;", "var x;"); // Only unaliasable provided - OK aliasableGlobals = ""; unaliasableGlobals = "baz,qux"; test("var x;", "var x;"); // Both provided - bad aliasableGlobals = "foo,bar"; unaliasableGlobals = "baz,qux"; try { test("var x;", "var x;"); fail("Expected an IllegalArgumentException"); } catch (IllegalArgumentException ex) { // pass } } /** * Global variables that get re-assigned should not be aliased. */ public void testGlobalAssigment() { test("var x=_USER_ID+window;" + "var y=_USER_ID+window;" + "var z=_USER_ID+window;" + "var w=x+y+z;" + "_USER_ID = \"foo\";" + "window++;", "var x=_USER_ID+window;" + "var y=_USER_ID+window;" + "var z=_USER_ID+window;" + "var w=x+y+z;" + "_USER_ID = \"foo\";" + "window++"); } public void testNewOperator() { test("var x;new x(window);window;window;window;window;window", "var GLOBAL_window=window; var x;" + " new x(GLOBAL_window);GLOBAL_window;GLOBAL_window;" + " GLOBAL_window;GLOBAL_window;GLOBAL_window"); } /** * Test the standard replacement for GETPROP */ public void testGetProp() { test("function foo(a,b){return a.length > b.length;}", formatPropNameDecl("length") + "function foo(a, b){return a[$$PROP_length] > b[$$PROP_length];}"); test("Foo.prototype.bar = function() { return 'foo'; }", formatPropNameDecl("prototype") + "Foo[$$PROP_prototype].bar = function() { return 'foo'; }"); test("Foo.notreplaced = 5", "Foo.notreplaced=5"); } /** * Ops that should be ignored */ public void testIgnoredOps() { testSame("function foo() { this.length-- }"); testSame("function foo() { this.length++ }"); testSame("function foo() { this.length+=5 }"); testSame("function foo() { this.length-=5 }"); } /** * Test property setting */ public void testSetProp() { test("function foo() { this.innerHTML = 'hello!'; }", formatSetPropFn("innerHTML") + "function foo() { SETPROP_innerHTML(this, 'hello!'); }"); } /** * Test for modifying both parent and child, as all replacements * are on a single pass and modifying both involves being careful with * references. */ public void testParentChild() { test("a.length = b.length = c.length;", formatSetPropFn("length") + formatPropNameDecl("length") + "SETPROP_length(a, SETPROP_length(b, c[$$PROP_length]))"); } private static final String MODULE_SRC_ONE = "a=b.length;a=b.length;a=b.length;"; private static final String MODULE_SRC_TWO = "c=d.length;"; /** * Test that the code is placed in the first module when there are no * dependencies. */ public void testModulesWithoutDependencies() { test(createModules(MODULE_SRC_ONE, MODULE_SRC_TWO), new String[] { "var $$PROP_length=\"length\";a=b[$$PROP_length];" + "a=b[$$PROP_length];a=b[$$PROP_length];", "c=d[$$PROP_length];"}); } /** * Test that the code is placed in the first module when the second module * depends on the first. */ public void testModulesWithDependencies() { test(createModuleChain(MODULE_SRC_ONE, MODULE_SRC_TWO), new String[] { "var $$PROP_length=\"length\";a=b[$$PROP_length];" + "a=b[$$PROP_length];a=b[$$PROP_length];", "c=d[$$PROP_length];"}); } public void testPropAccessorPushedDeeper1() { test(createModuleChain("var a = \"foo\";", "var b = a.length;"), new String[] { "var a = \"foo\";", formatPropNameDecl("length") + "var b = a[$$PROP_length]" }); } public void testPropAccessorPushedDeeper2() { test(createModuleChain( "var a = \"foo\";", "var b = a.length;", "var c = a.length;"), new String[] { "var a = \"foo\";", formatPropNameDecl("length") + "var b = a[$$PROP_length]", "var c = a[$$PROP_length]" }); } public void testPropAccessorPushedDeeper3() { test(createModuleStar( "var a = \"foo\";", "var b = a.length;", "var c = a.length;"), new String[] { formatPropNameDecl("length") + "var a = \"foo\";", "var b = a[$$PROP_length]", "var c = a[$$PROP_length]" }); } public void testPropAccessorNotPushedDeeper() { test(createModuleChain("var a = \"foo\"; var b = a.length;", "var c = a.length;"), new String[] { formatPropNameDecl("length") + "var a = \"foo\"; var b = a[$$PROP_length]", "var c = a[$$PROP_length]" }); } public void testPropMutatorPushedDeeper() { test(createModuleChain("var a = [1];", "a.length = 0;"), new String[] { "var a = [1];", formatSetPropFn("length") + "SETPROP_length(a, 0);" }); } public void testPropMutatorNotPushedDeeper() { test(createModuleChain( "var a = [1]; a.length = 1;", "a.length = 0;"), new String[] { formatSetPropFn("length") + "var a = [1]; SETPROP_length(a, 1);", "SETPROP_length(a, 0);" }); } public void testGlobalAliasPushedDeeper() { test(createModuleChain( "var a = 1;", "var b = window, c = window, d = window, e = window;"), new String[] { "var a = 1;", "var GLOBAL_window = window;" + "var b = GLOBAL_window, c = GLOBAL_window, " + " d = GLOBAL_window, e = GLOBAL_window;" }); } public void testGlobalAliasNotPushedDeeper() { test(createModuleChain( "var a = 1, b = window;", "var c = window, d = window, e = window;"), new String[] { "var GLOBAL_window = window;" + "var a = 1, b = GLOBAL_window;", "var c = GLOBAL_window, " + " d = GLOBAL_window, e = GLOBAL_window;" }); } public void testNoAliasAnnotationForSingleVar() { testSame("[RangeObject, RangeObject, RangeObject]"); } public void testNoAliasAnnotationForMultiVarDeclaration() { test("[RuntimeObject, RuntimeObject, RuntimeObject," + " SelectionObject, SelectionObject, SelectionObject]", "var GLOBAL_SelectionObject = SelectionObject;" + "[RuntimeObject, RuntimeObject, RuntimeObject," + " GLOBAL_SelectionObject, GLOBAL_SelectionObject," + " GLOBAL_SelectionObject]"); } public void testNoAliasAnnotationForFunction() { testSame("[NoAliasFunction(), NoAliasFunction(), NoAliasFunction()]"); } private String formatPropNameDecl(String prop) { return "var $$PROP_" + prop + "='" + prop + "';"; } private String formatSetPropFn(String prop) { String mutatorName = "SETPROP_" + prop; String arg1 = mutatorName + "$a"; String arg2 = mutatorName + "$b"; return "function " + mutatorName + "(" + arg1 + "," + arg2 + ") {" + "return " + arg1 + "." + prop + "=" + arg2 + ";}"; } @Override protected CompilerPass getProcessor(Compiler compiler) { AliasExternals ae = new AliasExternals( compiler, compiler.getModuleGraph(), unaliasableGlobals, aliasableGlobals); ae.setRequiredUsage(1); return ae; } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Tests for {@link AliasKeywords}. * */ public class AliasKeywordsTest extends CompilerTestCase { private static final int ENOUGH_TO_ALIAS_LITERAL = AliasKeywords.MIN_OCCURRENCES_REQUIRED_TO_ALIAS_LITERAL; private static final int TOO_FEW_TO_ALIAS_LITERAL = ENOUGH_TO_ALIAS_LITERAL - 1; private static final int ENOUGH_TO_ALIAS_THROW = AliasKeywords.MIN_OCCURRENCES_REQUIRED_TO_ALIAS_THROW; private static final int TOO_FEW_TO_ALIAS_THROW = ENOUGH_TO_ALIAS_THROW - 1; @Override public void setUp() { super.enableLineNumberCheck(false); super.enableNormalize(); } @Override public CompilerPass getProcessor(Compiler compiler) { return new AliasKeywords(compiler); } @Override protected int getNumRepetitions() { return 1; } /** * Generate code of the form 'if (<keyword>);' repeated numReps * times, with prepend prepended. * * For example, generateCode("true", 2, "var a=b;") generates * <code>var a=b;if (true);if (true);</code> */ private static String generateCode( String keyword, int numReps, String prepend) { StringBuilder sb = new StringBuilder(prepend); for (int i = 0; i < numReps; i++) { sb.append("if ("); sb.append(keyword); sb.append(");"); } return sb.toString(); } private static String generateCode(String keyword, int numReps) { return generateCode(keyword, numReps, ""); } private static String generatePreProcessThrowCode(int repititions, String whatToThrow) { StringBuilder sb = new StringBuilder(); for (int i = 0; i < repititions; i++) { sb.append("throw "); sb.append(whatToThrow); sb.append(";"); } return sb.toString(); } private static String generatePostProcessThrowCode( int repetitions, String code, String whatToThrow) { StringBuilder sb = new StringBuilder(); sb.append("function "); sb.append(AliasKeywords.ALIAS_THROW); sb.append("(jscomp_throw_param){throw jscomp_throw_param;}"); sb.append(code); for (int i = 0; i < repetitions; i++) { sb.append(AliasKeywords.ALIAS_THROW); sb.append("("); sb.append(whatToThrow); sb.append(");"); } return sb.toString(); } /** * Don't generate aliases if the keyword is not referenced enough. */ public void testDontAlias() { testSame(generateCode("true", TOO_FEW_TO_ALIAS_LITERAL)); testSame(generateCode("false", TOO_FEW_TO_ALIAS_LITERAL)); testSame(generateCode("null", TOO_FEW_TO_ALIAS_LITERAL)); testSame(generateCode("void 0", TOO_FEW_TO_ALIAS_LITERAL)); testSame(generatePreProcessThrowCode(TOO_FEW_TO_ALIAS_THROW, "1")); // Don't alias void nodes other than "void 0". testSame(generateCode("void 1", ENOUGH_TO_ALIAS_LITERAL)); testSame(generateCode("void x", ENOUGH_TO_ALIAS_LITERAL)); testSame(generateCode("void f()", ENOUGH_TO_ALIAS_LITERAL)); } /** * Generate aliases if the keyword is referenced >= ENOUGH_TO_ALIAS * times. */ public void testAlias() { test(generateCode("true", ENOUGH_TO_ALIAS_LITERAL), generateCode(AliasKeywords.ALIAS_TRUE, ENOUGH_TO_ALIAS_LITERAL, "var JSCompiler_alias_TRUE=true;")); test(generateCode("false", ENOUGH_TO_ALIAS_LITERAL), generateCode(AliasKeywords.ALIAS_FALSE, ENOUGH_TO_ALIAS_LITERAL, "var JSCompiler_alias_FALSE=false;")); test(generateCode("null", ENOUGH_TO_ALIAS_LITERAL), generateCode(AliasKeywords.ALIAS_NULL, ENOUGH_TO_ALIAS_LITERAL, "var JSCompiler_alias_NULL=null;")); test(generateCode("void 0", ENOUGH_TO_ALIAS_LITERAL), generateCode(AliasKeywords.ALIAS_VOID, ENOUGH_TO_ALIAS_LITERAL, "var JSCompiler_alias_VOID=void 0;")); test(generatePreProcessThrowCode(ENOUGH_TO_ALIAS_THROW, "1"), generatePostProcessThrowCode(ENOUGH_TO_ALIAS_THROW, "", "1")); } public void testAliasTrueFalseNull() { StringBuilder actual = new StringBuilder(); actual.append(generateCode("true", ENOUGH_TO_ALIAS_LITERAL)); actual.append(generateCode("false", ENOUGH_TO_ALIAS_LITERAL)); actual.append(generateCode("null", ENOUGH_TO_ALIAS_LITERAL)); actual.append(generateCode("void 0", ENOUGH_TO_ALIAS_LITERAL)); StringBuilder expected = new StringBuilder(); expected.append( "var JSCompiler_alias_VOID=void 0;" + "var JSCompiler_alias_TRUE=true;" + "var JSCompiler_alias_NULL=null;" + "var JSCompiler_alias_FALSE=false;"); expected.append( generateCode(AliasKeywords.ALIAS_TRUE, ENOUGH_TO_ALIAS_LITERAL)); expected.append( generateCode(AliasKeywords.ALIAS_FALSE, ENOUGH_TO_ALIAS_LITERAL)); expected.append( generateCode(AliasKeywords.ALIAS_NULL, ENOUGH_TO_ALIAS_LITERAL)); expected.append( generateCode(AliasKeywords.ALIAS_VOID, ENOUGH_TO_ALIAS_LITERAL)); test(actual.toString(), expected.toString()); } public void testAliasThrowKeywordLiteral() { int repitions = Math.max(ENOUGH_TO_ALIAS_THROW, ENOUGH_TO_ALIAS_LITERAL); String afterCode = generatePostProcessThrowCode( repitions, "var JSCompiler_alias_TRUE=true;", AliasKeywords.ALIAS_TRUE); test(generatePreProcessThrowCode(repitions, "true"), afterCode); } public void testExistingAliasDefinitionFails() { try { testSame("var JSCompiler_alias_TRUE='foo';"); fail(); } catch (RuntimeException expected) { // expected exception assertTrue(-1 != expected.getMessage().indexOf( "Existing alias definition")); } } public void testWithNoInputs() { testSame(new String[] {}); } }
/* * Copyright 2007 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.ImmutableSet; import java.util.*; /** * Tests for {@link AliasStrings}. * */ public class AliasStringsTest extends CompilerTestCase { private static final String EXTERNS = "alert"; private static final Set<String> ALL_STRINGS = null; private Set<String> strings = ALL_STRINGS; private JSModuleGraph moduleGraph = null; private boolean hashReduction = false; public AliasStringsTest() { super(EXTERNS); } @Override public void setUp() { super.enableLineNumberCheck(false); } @Override public CompilerPass getProcessor(Compiler compiler) { AliasStrings pass = new AliasStrings(compiler, moduleGraph, strings, "(?i)secret", false); if (hashReduction) pass.unitTestHashReductionMask = 0; return pass; } public void testAssignment() { strings = ImmutableSet.of("none", "width", "overimaginative"); // Strings not in alias list testSame("var foo='foo'"); testSame("a='titanium',b='titanium',c='titanium',d='titanium'"); // Not worth aliasing: testSame("myStr='width'"); testSame("Bar.prototype.start='none'"); // Worth aliasing: test("a='overimaginative';b='overimaginative'", "var $$S_overimaginative='overimaginative';" + "a=$$S_overimaginative;b=$$S_overimaginative"); testSame("var width=1234"); testSame("width=1234;width=10000;width=9900;width=17;"); } public void testSeveral() { strings = ImmutableSet.of("", "px", "none", "width"); test("function f() {" + "var styles=['width',100,'px','display','none'].join('')}", "var $$S_='';" + "var $$S_none='none';" + "var $$S_px='px';" + "var $$S_width='width';" + "function f() {var styles=[$$S_width,100,$$S_px,'display'," + "$$S_none].join($$S_)}"); } public void testSortedOutput() { strings = ImmutableSet.of("aba", "aaa", "aca", "bca", "bba"); test("function f() {return ['aba', 'aaa', 'aca', 'bca', 'bba']}", "var $$S_aaa='aaa';" + "var $$S_aba='aba';" + "var $$S_aca='aca';" + "var $$S_bba='bba';" + "var $$S_bca='bca';" + "function f() {" + " return [$$S_aba, $$S_aaa, $$S_aca, $$S_bca, $$S_bba]}"); } public void testObjectLiterals() { strings = ImmutableSet.of("px", "!@#$%^&*()"); test("var foo={px:435}", "var foo={px:435}"); // string as key test("var foo={'px':435}", "var foo={'px':435}"); test("bar=function f(){return {'px':435}}", "bar=function f(){return {'px':435}}"); test("function f() {var foo={bar:'!@#$%^&*()'}}", "var $$S_$21$40$23$24$25$5e$26$2a$28$29='!@#$%^&*()';" + "function f() {var foo={bar:$$S_$21$40$23$24$25$5e$26$2a$28$29}}"); test("function f() {var foo={px:435,foo:'px',bar:'baz'}}", "var $$S_px='px';" + "function f() {var foo={px:435,foo:$$S_px,bar:'baz'}}"); } public void testGetProp() { strings = ImmutableSet.of("px", "width"); testSame("function f(){element.style.px=1234}"); test("function f(){shape.width.units='px'}", "var $$S_px='px';function f(){shape.width.units=$$S_px}"); test("function f(){shape['width'].units='pt'}", "var $$S_width='width';" + "function f(){shape[$$S_width].units='pt'}"); } public void testFunctionCalls() { strings = ImmutableSet.of("", ",", "overimaginative"); // Not worth aliasing testSame("alert('')"); testSame("var a=[1,2,3];a.join(',')"); // worth aliasing test("f('overimaginative', 'overimaginative')", "var $$S_overimaginative='overimaginative';" + "f($$S_overimaginative,$$S_overimaginative)"); } public void testRegularExpressions() { strings = ImmutableSet.of("px"); testSame("/px/.match('10px')"); } public void testBlackList() { test("(function (){var f=\'sec ret\';g=\"TOPseCreT\"})", "var $$S_sec$20ret='sec ret';" + "(function (){var f=$$S_sec$20ret;g=\"TOPseCreT\"})"); } public void testLongStableAlias() { strings = ALL_STRINGS; // Check long strings get a hash code test("a='Antidisestablishmentarianism';" + "b='Antidisestablishmentarianism';", "var $$S_Antidisestablishment_506eaf9c=" + " 'Antidisestablishmentarianism';" + "a=$$S_Antidisestablishment_506eaf9c;" + "b=$$S_Antidisestablishment_506eaf9c"); // Check that small changes give different hash codes test("a='AntidisestablishmentarianIsm';" + "b='AntidisestablishmentarianIsm';", "var $$S_Antidisestablishment_6823e97c=" + " 'AntidisestablishmentarianIsm';" + "a=$$S_Antidisestablishment_6823e97c;" + "b=$$S_Antidisestablishment_6823e97c"); // TODO(user): check that hash code collisions are handled. } public void testLongStableAliasHashCollision() { strings = ALL_STRINGS; hashReduction = true; // Check that hash code collisions generate different alias // variable names test("f('Antidisestablishmentarianism');" + "f('Antidisestablishmentarianism');" + "f('Antidisestablishmentarianismo');" + "f('Antidisestablishmentarianismo');", "var $$S_Antidisestablishment_0=" + " 'Antidisestablishmentarianism';" + "var $$S_Antidisestablishment_0_1=" + " 'Antidisestablishmentarianismo';" + "f($$S_Antidisestablishment_0);" + "f($$S_Antidisestablishment_0);" + "f($$S_Antidisestablishment_0_1);" + "f($$S_Antidisestablishment_0_1);"); } public void testStringsThatAreGlobalVarValues() { strings = ALL_STRINGS; testSame("var foo='foo'; var bar='';"); // Regular array testSame("var foo=['foo','bar'];"); // Nested array testSame("var foo=['foo',['bar']];"); // Same string is in a global array and a local in a function test("var foo=['foo', 'bar'];function bar() {return 'foo';}", "var $$S_foo='foo';" + "var foo=[$$S_foo, 'bar'];function bar() {return $$S_foo;}"); // Regular object literal testSame("var foo={'foo': 'bar'};"); // Nested object literal testSame("var foo={'foo': {'bar': 'baz'}};"); // Same string is in a global object literal (as key) and local in a // function test("var foo={'foo': 'bar'};function bar() {return 'foo';}", "var $$S_foo='foo';var foo={'foo': 'bar'};" + "function bar() {return $$S_foo;}"); // Same string is in a global object literal (as value) and local in a // function test("var foo={'foo': 'foo'};function bar() {return 'foo';}", "var $$S_foo='foo';" + "var foo={'foo': $$S_foo};function bar() {return $$S_foo;}"); } public void testStringsInModules() { strings = ALL_STRINGS; // Aliases must be placed in the correct module. The alias for // '------adios------' must be lifted from m2 and m3 and go in the // common parent module m1 JSModule[] modules = createModuleBush( // m0 "function f(a) { alert('f:' + a); }" + "function g() { alert('ciao'); }", // m1 "f('-------hi-------');" + "f('bye');" + "function h(a) { alert('h:' + a); }", // m2 "f('-------hi-------');" + "h('ciao' + '------adios------');" + "(function() { alert('zzz'); })();", // m3 "f('-------hi-------'); alert('------adios------');" + "h('-----peaches-----'); h('-----peaches-----');"); moduleGraph = new JSModuleGraph(modules); test(modules, new String[] { // m1 "var $$S_ciao = 'ciao';" + "var $$S_f$3a = 'f:';" + "function f(a) { alert($$S_f$3a + a); }" + "function g() { alert($$S_ciao); }", // m2 "var $$S_$2d$2d$2d$2d$2d$2d$2dhi$2d$2d$2d$2d$2d$2d$2d" + " = '-------hi-------';" + "var $$S_$2d$2d$2d$2d$2d$2d_adios$2d$2d$2d$2d$2d$2d" + " = '------adios------'; " + "var $$S_h$3a = 'h:';" + "f($$S_$2d$2d$2d$2d$2d$2d$2dhi$2d$2d$2d$2d$2d$2d$2d);" + "f('bye');" + "function h(a) { alert($$S_h$3a + a); }", // m3 "var $$S_zzz = 'zzz';" + "f($$S_$2d$2d$2d$2d$2d$2d$2dhi$2d$2d$2d$2d$2d$2d$2d);" + "h($$S_ciao + $$S_$2d$2d$2d$2d$2d$2d_adios$2d$2d$2d$2d$2d$2d);" + "(function() { alert($$S_zzz) })();", // m4 "var $$S_$2d$2d$2d$2d$2dpeaches$2d$2d$2d$2d$2d" + " = '-----peaches-----';" + "f($$S_$2d$2d$2d$2d$2d$2d$2dhi$2d$2d$2d$2d$2d$2d$2d);" + "alert($$S_$2d$2d$2d$2d$2d$2d_adios$2d$2d$2d$2d$2d$2d);" + "h($$S_$2d$2d$2d$2d$2dpeaches$2d$2d$2d$2d$2d);" + "h($$S_$2d$2d$2d$2d$2dpeaches$2d$2d$2d$2d$2d);", }); moduleGraph = null; } public void testStringsInModules2() { strings = ALL_STRINGS; // Aliases must be placed in the correct module. The alias for // '------adios------' must be lifted from m2 and m3 and go in the // common parent module m1 JSModule[] modules = createModuleBush( // m0 "function g() { alert('ciao'); }", // m1 "function h(a) { alert('h:' + a); }", // m2 "h('ciao' + 'adios');", // m3 "g();"); moduleGraph = new JSModuleGraph(modules); test(modules, new String[] { // m1 "var $$S_ciao = 'ciao';" + "function g() { alert($$S_ciao); }", // m2 "var $$S_h$3a = 'h:';" + "function h(a) { alert($$S_h$3a + a); }", // m3 "h($$S_ciao + 'adios');", // m4 "g();", }); moduleGraph = null; } public void testEmptyModules() { JSModule[] modules = createModuleStar( // m0 "", // m1 "function foo() { f('good') }", // m2 "function foo() { f('good') }"); moduleGraph = new JSModuleGraph(modules); test(modules, new String[] { // m0 "var $$S_good='good'", // m1 "function foo() {f($$S_good)}", // m2 "function foo() {f($$S_good)}",}); moduleGraph = null; } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.Maps; import com.google.javascript.jscomp.CompilerOptions.LanguageMode; import com.google.javascript.rhino.Node; import java.util.Map; /** * Unit test for AmbiguateProperties Compiler pass. * */ public class AmbiguatePropertiesTest extends CompilerTestCase { private AmbiguateProperties lastPass; private static final String EXTERNS = "Function.prototype.call=function(){};" + "Function.prototype.inherits=function(){};" + "prop.toString;" + "var google = { gears: { factory: {}, workerPool: {} } };"; public AmbiguatePropertiesTest() { super(EXTERNS); enableNormalize(); enableTypeCheck(CheckLevel.WARNING); enableClosurePass(); } @Override public CompilerPass getProcessor(final Compiler compiler) { return new CompilerPass() { @Override public void process(Node externs, Node root) { lastPass = new AmbiguateProperties(compiler, new char[]{'$'}); lastPass.process(externs, root); } }; } @Override protected int getNumRepetitions() { return 1; } @Override protected CompilerOptions getOptions() { // no missing properties check CompilerOptions options = new CompilerOptions(); options.setLanguageIn(LanguageMode.ECMASCRIPT5); return options; } public void testOneVar1() { test("/** @constructor */ var Foo = function(){};Foo.prototype.b = 0;", "var Foo = function(){};Foo.prototype.a = 0;"); } public void testOneVar2() { testSame("/** @constructor */ var Foo = function(){};" + "Foo.prototype = {b: 0};"); } public void testOneVar3() { testSame("/** @constructor */ var Foo = function(){};" + "Foo.prototype = {get b() {return 0}};"); } public void testOneVar4() { testSame("/** @constructor */ var Foo = function(){};" + "Foo.prototype = {set b(a) {}};"); } public void testTwoVar1() { String js = "" + "/** @constructor */ var Foo = function(){};\n" + "Foo.prototype.z=0;\n" + "Foo.prototype.z=0;\n" + "Foo.prototype.x=0;"; String output = "" + "var Foo = function(){};\n" + "Foo.prototype.a=0;\n" + "Foo.prototype.a=0;\n" + "Foo.prototype.b=0;"; test(js, output); } public void testTwoVar2() { String js = "" + "/** @constructor */ var Foo = function(){};\n" + "Foo.prototype={z:0, z:1, x:0};\n"; // TODO(johnlenz): It would be nice to handle this type of declaration. testSame(js); } public void testTwoIndependentVar() { String js = "" + "/** @constructor */ var Foo = function(){};\n" + "Foo.prototype.b = 0;\n" + "/** @constructor */ var Bar = function(){};\n" + "Bar.prototype.c = 0;"; String output = "" + "var Foo = function(){};" + "Foo.prototype.a=0;" + "var Bar = function(){};" + "Bar.prototype.a=0;"; test(js, output); } public void testTwoTypesTwoVar() { String js = "" + "/** @constructor */ var Foo = function(){};\n" + "Foo.prototype.r = 0;\n" + "Foo.prototype.g = 0;\n" + "/** @constructor */ var Bar = function(){};\n" + "Bar.prototype.c = 0;" + "Bar.prototype.r = 0;"; String output = "" + "var Foo = function(){};" + "Foo.prototype.a=0;" + "Foo.prototype.b=0;" + "var Bar = function(){};" + "Bar.prototype.b=0;" + "Bar.prototype.a=0;"; test(js, output); } public void testUnion() { String js = "" + "/** @constructor */ var Foo = function(){};\n" + "/** @constructor */ var Bar = function(){};\n" + "Foo.prototype.foodoo=0;\n" + "Bar.prototype.bardoo=0;\n" + "/** @type {Foo|Bar} */\n" + "var U;\n" + "U.joint;" + "U.joint"; String output = "" + "var Foo = function(){};\n" + "var Bar = function(){};\n" + "Foo.prototype.b=0;\n" + "Bar.prototype.b=0;\n" + "var U;\n" + "U.a;" + "U.a"; test(js, output); } public void testUnions() { String js = "" + "/** @constructor */ var Foo = function(){};\n" + "/** @constructor */ var Bar = function(){};\n" + "/** @constructor */ var Baz = function(){};\n" + "/** @constructor */ var Bat = function(){};\n" + "Foo.prototype.lone1=0;\n" + "Bar.prototype.lone2=0;\n" + "Baz.prototype.lone3=0;\n" + "Bat.prototype.lone4=0;\n" + "/** @type {Foo|Bar} */\n" + "var U1;\n" + "U1.j1;" + "U1.j2;" + "/** @type {Baz|Bar} */\n" + "var U2;\n" + "U2.j3;" + "U2.j4;" + "/** @type {Baz|Bat} */\n" + "var U3;" + "U3.j5;" + "U3.j6"; String output = "" + "var Foo = function(){};\n" + "var Bar = function(){};\n" + "var Baz = function(){};\n" + "var Bat = function(){};\n" + "Foo.prototype.c=0;\n" + "Bar.prototype.e=0;\n" + "Baz.prototype.e=0;\n" + "Bat.prototype.c=0;\n" + "var U1;\n" + "U1.a;" + "U1.b;" + "var U2;\n" + "U2.c;" + "U2.d;" + "var U3;" + "U3.a;" + "U3.b"; test(js, output); } public void testExtends() { String js = "" + "/** @constructor */ var Foo = function(){};\n" + "Foo.prototype.x=0;\n" + "/** @constructor \n @extends Foo */ var Bar = function(){};\n" + "goog.inherits(Bar, Foo);\n" + "Bar.prototype.y=0;\n" + "Bar.prototype.z=0;\n" + "/** @constructor */ var Baz = function(){};\n" + "Baz.prototype.l=0;\n" + "Baz.prototype.m=0;\n" + "Baz.prototype.n=0;\n" + "(new Baz).m\n"; String output = "" + "/** @constructor */ var Foo = function(){};\n" + "Foo.prototype.a=0;\n" + "/** @constructor \n @extends Foo */ var Bar = function(){};\n" + "goog.inherits(Bar, Foo);\n" + "Bar.prototype.b=0;\n" + "Bar.prototype.c=0;\n" + "/** @constructor */ var Baz = function(){};\n" + "Baz.prototype.b=0;\n" + "Baz.prototype.a=0;\n" + "Baz.prototype.c=0;\n" + "(new Baz).a\n"; test(js, output); } public void testLotsOfVars() { StringBuilder js = new StringBuilder(); StringBuilder output = new StringBuilder(); js.append("/** @constructor */ var Foo = function(){};\n"); js.append("/** @constructor */ var Bar = function(){};\n"); output.append(js.toString()); int vars = 10; for (int i = 0; i < vars; i++) { js.append("Foo.prototype.var" + i + " = 0;"); js.append("Bar.prototype.var" + (i + 10000) + " = 0;"); output.append("Foo.prototype." + (char) ('a' + i) + "=0;"); output.append("Bar.prototype." + (char) ('a' + i) + "=0;"); } test(js.toString(), output.toString()); } public void testLotsOfClasses() { StringBuilder b = new StringBuilder(); int classes = 10; for (int i = 0; i < classes; i++) { String c = "Foo" + i; b.append("/** @constructor */ var " + c + " = function(){};\n"); b.append(c + ".prototype.varness" + i + " = 0;"); } String js = b.toString(); test(js, js.replaceAll("varness\\d+", "a")); } public void testFunctionType() { String js = "" + "/** @constructor */ function Foo(){};\n" + "/** @return {Bar} */\n" + "Foo.prototype.fun = function() { return new Bar(); };\n" + "/** @constructor */ function Bar(){};\n" + "Bar.prototype.bazz;\n" + "(new Foo).fun().bazz();"; String output = "" + "function Foo(){};\n" + "Foo.prototype.a = function() { return new Bar(); };\n" + "function Bar(){};\n" + "Bar.prototype.a;\n" + "(new Foo).a().a();"; test(js, output); } public void testPrototypePropertiesAsObjLitKeys1() { test("/** @constructor */ function Bar() {};" + "Bar.prototype = {2: function(){}, getA: function(){}};", "/** @constructor */ function Bar() {};" + "Bar.prototype = {2: function(){}, a: function(){}};"); } public void testPrototypePropertiesAsObjLitKeys2() { testSame("/** @constructor */ function Bar() {};" + "Bar.prototype = {2: function(){}, 'getA': function(){}};"); } public void testQuotedPrototypeProperty() { testSame("/** @constructor */ function Bar() {};" + "Bar.prototype['getA'] = function(){};" + "var bar = new Bar();" + "bar['getA']();"); } public void testOverlappingOriginalAndGeneratedNames() { test("/** @constructor */ function Bar(){};" + "Bar.prototype.b = function(){};" + "Bar.prototype.a = function(){};" + "var bar = new Bar();" + "bar.b();", "function Bar(){};" + "Bar.prototype.a = function(){};" + "Bar.prototype.b = function(){};" + "var bar = new Bar();" + "bar.a();"); } public void testPropertyAddedToObject() { testSame("var foo = {}; foo.prop = '';"); } public void testPropertyAddedToFunction() { test("var foo = function(){}; foo.prop = '';", "var foo = function(){}; foo.a = '';"); } public void testPropertyOfObjectOfUnknownType() { testSame("var foo = x(); foo.prop = '';"); } public void testPropertyOnParamOfUnknownType() { testSame("/** @constructor */ function Foo(){};\n" + "Foo.prototype.prop = 0;" + "function go(aFoo){\n" + " aFoo.prop = 1;" + "}"); } public void testSetPropertyOfGlobalThis() { testSame("this.prop = 'bar'"); } public void testReadPropertyOfGlobalThis() { testSame("f(this.prop);"); } public void testSetQuotedPropertyOfThis() { testSame("this['prop'] = 'bar';"); } public void testExternedPropertyName() { test("/** @constructor */ var Bar = function(){};" + "/** @override */ Bar.prototype.toString = function(){};" + "Bar.prototype.func = function(){};" + "var bar = new Bar();" + "bar.toString();", "var Bar = function(){};" + "Bar.prototype.toString = function(){};" + "Bar.prototype.a = function(){};" + "var bar = new Bar();" + "bar.toString();"); } public void testExternedPropertyNameDefinedByObjectLiteral() { testSame("/**@constructor*/function Bar(){};Bar.prototype.factory"); } public void testStaticAndInstanceMethodWithSameName() { test("/** @constructor */function Bar(){}; Bar.getA = function(){}; " + "Bar.prototype.getA = function(){}; Bar.getA();" + "var bar = new Bar(); bar.getA();", "function Bar(){}; Bar.a = function(){};" + "Bar.prototype.a = function(){}; Bar.a();" + "var bar = new Bar(); bar.a();"); } public void testStaticAndInstanceProperties() { test("/** @constructor */function Bar(){};" + "Bar.getA = function(){}; " + "Bar.prototype.getB = function(){};", "function Bar(){}; Bar.a = function(){};" + "Bar.prototype.a = function(){};"); } public void testStaticAndSubInstanceProperties() { String js = "" + "/** @constructor */ var Foo = function(){};\n" + "Foo.x=0;\n" + "/** @constructor \n @extends Foo */ var Bar = function(){};\n" + "goog.inherits(Bar, Foo);\n" + "Bar.y=0;\n" + "Bar.prototype.z=0;\n"; String output = "" + "/** @constructor */ var Foo = function(){};\n" + "Foo.a=0;\n" + "/** @constructor \n @extends Foo */ var Bar = function(){};\n" + "goog.inherits(Bar, Foo);\n" + "Bar.a=0;\n" + "Bar.prototype.a=0;\n"; test(js, output); } public void testStaticWithFunctions() { String js = "" + "/** @constructor */ var Foo = function() {};\n" + "Foo.x = 0;" + "/** @param {!Function} x */ function f(x) { x.y = 1 }" + "f(Foo)"; String output = "" + "/** @constructor */ var Foo = function() {};\n" + "Foo.a = 0;" + "/** @param {!Function} x */ function f(x) { x.y = 1 }" + "f(Foo)"; test(js, output); js = "" + "/** @constructor */ var Foo = function() {};\n" + "Foo.x = 0;" + "/** @param {!Function} x */ function f(x) { x.y = 1; x.x = 2;}" + "f(Foo)"; test(js, js); js = "" + "/** @constructor */ var Foo = function() {};\n" + "Foo.x = 0;" + "/** @constructor */ var Bar = function() {};\n" + "Bar.y = 0;"; output = "" + "/** @constructor */ var Foo = function() {};\n" + "Foo.a = 0;" + "/** @constructor */ var Bar = function() {};\n" + "Bar.a = 0;"; test(js, output); } public void testTypeMismatch() { testSame(EXTERNS, "/** @constructor */var Foo = function(){};\n" + "/** @constructor */var Bar = function(){};\n" + "Foo.prototype.b = 0;\n" + "/** @type {Foo} */\n" + "var F = new Bar();", TypeValidator.TYPE_MISMATCH_WARNING, "initializing variable\n" + "found : Bar\n" + "required: (Foo|null)"); } public void testRenamingMap() { String js = "" + "/** @constructor */ var Foo = function(){};\n" + "Foo.prototype.z=0;\n" + "Foo.prototype.z=0;\n" + "Foo.prototype.x=0;\n" + "Foo.prototype.y=0;"; String output = "" + "var Foo = function(){};\n" + "Foo.prototype.a=0;\n" + "Foo.prototype.a=0;\n" + "Foo.prototype.b=0;\n" + "Foo.prototype.c=0;"; test(js, output); Map<String, String> answerMap = Maps.newHashMap(); answerMap.put("x", "b"); answerMap.put("y", "c"); answerMap.put("z", "a"); assertEquals(answerMap, lastPass.getRenamingMap()); } public void testInline() { String js = "" + "/** @interface */ function Foo(){}\n" + "Foo.prototype.x = function(){};\n" + "/**\n" + " * @constructor\n" + " * @implements {Foo}\n" + " */\n" + "function Bar(){}\n" + "/** @inheritDoc */\n" + "Bar.prototype.x = function() { return this.y; };\n" + "Bar.prototype.z = function() {};\n" // Simulates inline getters. + "/** @type {Foo} */ (new Bar).y;"; String output = "" + "function Foo(){}\n" + "Foo.prototype.a = function(){};\n" + "function Bar(){}\n" + "Bar.prototype.a = function() { return this.b; };\n" + "Bar.prototype.c = function() {};\n" // Simulates inline getters. + "(new Bar).b;"; test(js, output); } public void testImplementsAndExtends() { String js = "" + "/** @interface */ function Foo() {}\n" + "/**\n" + " * @constructor\n" + " */\n" + "function Bar(){}\n" + "Bar.prototype.y = function() { return 3; };\n" + "/**\n" + " * @constructor\n" + " * @extends {Bar}\n" + " * @implements {Foo}\n" + " */\n" + "function SubBar(){ }\n" + "/** @param {Foo} x */ function f(x) { x.z = 3; }\n" + "/** @param {SubBar} x */ function g(x) { x.z = 3; }"; String output = "" + "function Foo(){}\n" + "function Bar(){}\n" + "Bar.prototype.b = function() { return 3; };\n" + "function SubBar(){}\n" + "function f(x) { x.a = 3; }\n" + "function g(x) { x.a = 3; }"; test(js, output); } public void testImplementsAndExtends2() { String js = "" + "/** @interface */ function A() {}\n" + "/**\n" + " * @constructor\n" + " */\n" + "function C1(){}\n" + "/**\n" + " * @constructor\n" + " * @extends {C1}\n" + " * @implements {A}\n" + " */\n" + "function C2(){}\n" + "/** @param {C1} x */ function f(x) { x.y = 3; }\n" + "/** @param {A} x */ function g(x) { x.z = 3; }\n"; String output = "" + "function A(){}\n" + "function C1(){}\n" + "function C2(){}\n" + "function f(x) { x.a = 3; }\n" + "function g(x) { x.b = 3; }\n"; test(js, output); } public void testExtendsInterface() { String js = "" + "/** @interface */ function A() {}\n" + "/** @interface \n @extends {A} */ function B() {}\n" + "/** @param {A} x */ function f(x) { x.y = 3; }\n" + "/** @param {B} x */ function g(x) { x.z = 3; }\n"; String output = "" + "function A(){}\n" + "function B(){}\n" + "function f(x) { x.a = 3; }\n" + "function g(x) { x.b = 3; }\n"; test(js, output); } public void testFunctionSubType() { String js = "" + "Function.prototype.a = 1;\n" + "function f() {}\n" + "f.y = 2;\n"; String output = "" + "Function.prototype.a = 1;\n" + "function f() {}\n" + "f.b = 2;\n"; test(js, output); } public void testFunctionSubType2() { String js = "" + "Function.prototype.a = 1;\n" + "/** @constructor */ function F() {}\n" + "F.y = 2;\n"; String output = "" + "Function.prototype.a = 1;\n" + "function F() {}\n" + "F.b = 2;\n"; test(js, output); } public void testPredeclaredType() { String js = "goog.addDependency('zzz.js', ['goog.Foo'], []);" + "/** @constructor */ " + "function A() {" + " this.x = 3;" + "}" + "/** @param {goog.Foo} x */" + "function f(x) { x.y = 4; }"; String result = "0;" + "/** @constructor */ " + "function A() {" + " this.a = 3;" + "}" + "/** @param {goog.Foo} x */" + "function f(x) { x.y = 4; }"; test(js, result); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import junit.framework.TestCase; import java.util.List; /** * Unit tests for {@link AstParallelizer}. * */ public class AstParallelizerTest extends TestCase { private static final String HOLDER = AstParallelizer.TEMP_NAME; public void testNoSplit() { splitFunctions("", ""); splitFunctions("var x", "var x"); splitFunctions("var x", "var x"); splitFunctions("x()", "x()"); } public void testSplitNamedFuntion() { splitFunctions("function foo() { foo() } foo()", "function " + HOLDER + "() {} foo()", "function foo() { foo() }"); } public void testSplitNamedFuntionWithArgs() { splitFunctions("function foo(x) { foo(1) } foo(1)", "function " + HOLDER + "() {} foo(1)", "function foo(x) { foo(1) }"); } // TODO(johnlenz): This test is invalid it relies on allowing // nameless function statements, which does not parse. public void disable_testSplitAnonFuntion() { splitFunctions("var foo = function(x) { foo(1) }; foo(1)", "var foo = function " + HOLDER + "() {}; foo(1)", "(function(x) { foo(1) })"); } // TODO(johnlenz): This test is invalid it relies on allowing // nameless function statements, which does not parse. public void disable_testSplitInplaceCall() { splitFunctions("(function() { print('hi') })()", "(function " + HOLDER + "() {})()", "(function() { print('hi') })"); } // TODO(johnlenz): This test is invalid it relies on allowing // nameless function statements, which does not parse. public void disable_testSplitMupltiFuntions() { splitFunctions("var foo = function(x) { foo(1) }; foo();" + "var bar = function(x,y) { bar(1,2) }; bar(1,2)", // Output Root "var foo = function " + HOLDER + "() {}; foo();" + "var bar = function " + HOLDER + "() {}; bar(1,2)", // foo "(function(x) { foo(1) })", // bar "(function(x,y) { bar(1,2) })"); } // TODO(johnlenz): This test is invalid it relies on allowing // nameless function statements, which does not parse. public void disable_testInnerFunctions() { splitFunctions("var foo = function() {var bar = function() {}}", "var foo = function " + HOLDER + "() {}", "function() {var bar = function() {}}"); } public void testSplitFileLevel() { splitFiles(new String[] { "var a", "var b", "var c"}); splitFiles(new String[] { "var a", "var b", "var c", "var d", "function e() {}"}); } /** * Splits at function level with {@link AstParallelizer#split()}, verify the * output matches what is expected and then verify * {@link AstParallelizer#join()} can reverse the whole process. */ private void splitFunctions(String input, String ... output) { Compiler compiler = new Compiler(); Node original = compiler.parseTestCode(input); Node root = original.cloneTree(); AstParallelizer parallelizer = AstParallelizer.createNewFunctionLevelAstParallelizer(root, true); List<Node> forest = parallelizer.split(); assertEquals(output.length, forest.size()); int i = 0; for (Node n : forest) { Node tree = compiler.parseTestCode(output[i++]); assertEquals(compiler.toSource(tree), compiler.toSource(n)); } parallelizer.join(); assertTrue(original.isEquivalentTo(root)); } private void splitFiles(String[] input) { Compiler compiler = new Compiler(); List<SourceFile> files = Lists.newArrayList(); for (int i = 0; i < input.length; i ++) { files.add(SourceFile.fromCode("file" + i, input[i])); } compiler.init( ImmutableList.<SourceFile>of(), files, new CompilerOptions()); compiler.parse(); Node original = compiler.getRoot(); Node root = original.cloneTree(); AstParallelizer parallelizer = AstParallelizer.createNewFileLevelAstParallelizer(root); List<Node> forest = parallelizer.split(); assertEquals(input.length, forest.size()); int i = 0; for (Node n : forest) { Node tree = compiler.parseTestCode(input[i++]); assertEquals(compiler.toSource(tree), compiler.toSource(n)); } parallelizer.join(); assertTrue(original.isEquivalentTo(root)); } }
/* * Copyright 2011 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.jscomp.AstValidator.ViolationHandler; import com.google.javascript.rhino.InputId; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.SimpleSourceFile; /** * @author johnlenz@google.com (John Lenz) */ public class AstValidatorTest extends CompilerTestCase { private boolean lastCheckWasValid = true; @Override protected CompilerPass getProcessor(Compiler compiler) { return createValidator(); } private AstValidator createValidator() { lastCheckWasValid = true; return new AstValidator(new ViolationHandler() { @Override public void handleViolation(String message, Node n) { lastCheckWasValid = false; } }); } @Override protected int getNumRepetitions() { return 1; } @Override protected void setUp() throws Exception { super.enableAstValidation(false); super.disableNormalize(); super.enableLineNumberCheck(false); super.setUp(); } public void testForIn() { valid("for(var a in b);"); valid("for(var a = 1 in b);"); valid("for(a in b);"); valid("for(a in []);"); valid("for(a in {});"); } public void testDebugger() { valid("debugger;"); } public void testValidScript() { Node n = new Node(Token.SCRIPT); expectInvalid(n, Check.SCRIPT); n.setInputId(new InputId("something_input")); n.setStaticSourceFile(new SimpleSourceFile("something", false)); expectValid(n, Check.SCRIPT); expectInvalid(n, Check.STATEMENT); expectInvalid(n, Check.EXPRESSION); } public void testValidStatement1() { Node n = new Node(Token.RETURN); expectInvalid(n, Check.EXPRESSION); expectValid(n, Check.STATEMENT); expectInvalid(n, Check.SCRIPT); } public void testValidExpression1() { Node n = new Node(Token.ARRAYLIT, new Node(Token.EMPTY)); expectValid(n, Check.EXPRESSION); expectInvalid(n, Check.STATEMENT); expectInvalid(n, Check.SCRIPT); } public void testValidExpression2() { Node n = new Node(Token.NOT, new Node(Token.TRUE)); expectValid(n, Check.EXPRESSION); expectInvalid(n, Check.STATEMENT); expectInvalid(n, Check.SCRIPT); } public void testInvalidEmptyStatement() { Node n = new Node(Token.EMPTY, new Node(Token.TRUE)); expectInvalid(n, Check.STATEMENT); n.detachChildren(); expectValid(n, Check.STATEMENT); } private void valid(String code) { testSame(code); assertTrue(lastCheckWasValid); } private enum Check { SCRIPT, STATEMENT, EXPRESSION } private boolean doCheck(Node n, Check level) { AstValidator validator = createValidator(); switch (level) { case SCRIPT: validator.validateScript(n); break; case STATEMENT: validator.validateStatement(n); break; case EXPRESSION: validator.validateExpression(n); break; } return lastCheckWasValid; } private void expectInvalid(Node n, Check level) { assertFalse(doCheck(n, level)); } private void expectValid(Node n, Check level) { assertTrue(doCheck(n, level)); } }
/* * Copyright 2007 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.jscomp.BasicErrorManager.ErrorWithLevel; import com.google.javascript.jscomp.BasicErrorManager.LeveledJSErrorComparator; import com.google.javascript.jscomp.CheckLevel; import junit.framework.TestCase; /** * Tests {@link BasicErrorManager}. * */ public class BasicErrorManagerTest extends TestCase { private static final String NULL_SOURCE = null; private LeveledJSErrorComparator comparator = new LeveledJSErrorComparator(); static final CheckLevel E = CheckLevel.ERROR; private static final DiagnosticType FOO_TYPE = DiagnosticType.error("TEST_FOO", "Foo"); private static final DiagnosticType JOO_TYPE = DiagnosticType.error("TEST_JOO", "Joo"); public void testOrderingBothNull() throws Exception { assertEquals(0, comparator.compare(null, null)); } public void testOrderingSourceName1() throws Exception { JSError e1 = JSError.make(NULL_SOURCE, -1, -1, FOO_TYPE); JSError e2 = JSError.make("a", -1, -1, FOO_TYPE); assertSmaller(error(e1), error(e2)); } public void testOrderingSourceName2() throws Exception { JSError e1 = JSError.make("a", -1, -1, FOO_TYPE); JSError e2 = JSError.make("b", -1, -1, FOO_TYPE); assertSmaller(error(e1), error(e2)); } public void testOrderingLineno1() throws Exception { JSError e1 = JSError.make(NULL_SOURCE, -1, -1, FOO_TYPE); JSError e2 = JSError.make(NULL_SOURCE, 2, -1, FOO_TYPE); assertSmaller(error(e1), error(e2)); } public void testOrderingLineno2() throws Exception { JSError e1 = JSError.make(NULL_SOURCE, 8, -1, FOO_TYPE); JSError e2 = JSError.make(NULL_SOURCE, 56, -1, FOO_TYPE); assertSmaller(error(e1), error(e2)); } public void testOrderingCheckLevel() throws Exception { JSError e1 = JSError.make(NULL_SOURCE, -1, -1, FOO_TYPE); JSError e2 = JSError.make(NULL_SOURCE, -1, -1, FOO_TYPE); assertSmaller(warning(e1), error(e2)); } public void testOrderingCharno1() throws Exception { JSError e1 = JSError.make(NULL_SOURCE, 5, -1, FOO_TYPE); JSError e2 = JSError.make(NULL_SOURCE, 5, 2, FOO_TYPE); assertSmaller(error(e1), error(e2)); // CheckLevel preempts charno comparison assertSmaller(warning(e1), error(e2)); } public void testOrderingCharno2() throws Exception { JSError e1 = JSError.make(NULL_SOURCE, 8, 7, FOO_TYPE); JSError e2 = JSError.make(NULL_SOURCE, 8, 5, FOO_TYPE); assertSmaller(error(e2), error(e1)); // CheckLevel preempts charno comparison assertSmaller(warning(e2), error(e1)); } public void testOrderingDescription() throws Exception { JSError e1 = JSError.make(NULL_SOURCE, -1, -1, FOO_TYPE); JSError e2 = JSError.make(NULL_SOURCE, -1, -1, JOO_TYPE); assertSmaller(error(e1), error(e2)); } private ErrorWithLevel error(JSError e) { return new ErrorWithLevel(e, CheckLevel.ERROR); } private ErrorWithLevel warning(JSError e) { return new ErrorWithLevel(e, CheckLevel.WARNING); } private void assertSmaller(ErrorWithLevel p1, ErrorWithLevel p2) { int p1p2 = comparator.compare(p1, p2); assertTrue(Integer.toString(p1p2), p1p2 < 0); int p2p1 = comparator.compare(p2, p1); assertTrue(Integer.toString(p2p1), p2p1 > 0); } }
/* * Copyright 2010 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.jscomp.CallGraph.Callsite; import com.google.javascript.jscomp.CallGraph.Function; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Collection; import java.util.List; import java.util.Set; /** * Tests for CallGraph. * * @author dcc@google.com (Devin Coughlin) */ public class CallGraphTest extends CompilerTestCase { private CallGraph currentProcessor; private boolean createForwardCallGraph; private boolean createBackwardCallGraph; @Override protected CompilerPass getProcessor(Compiler compiler) { // We store the new callgraph so it can be tested later currentProcessor = new CallGraph(compiler, createForwardCallGraph, createBackwardCallGraph); return currentProcessor; } static final String SHARED_EXTERNS = "var ExternalFunction = function(a) {}\n" + "var externalnamespace = {}\n" + "externalnamespace.prop = function(){};\n"; public void testGetFunctionForAstNode() { String source = "function A() {};\n"; CallGraph callgraph = compileAndRunForward(source); CallGraph.Function functionA = callgraph.getUniqueFunctionWithName("A"); Node functionANode = functionA.getAstNode(); assertEquals(functionA, callgraph.getFunctionForAstNode(functionANode)); } public void testGetAllFunctions() { String source = "function A() {}\n" + "var B = function() {\n" + "(function C(){A()})()\n" + "};\n"; CallGraph callgraph = compileAndRunForward(source); Collection<CallGraph.Function> functions = callgraph.getAllFunctions(); // 3 Functions, plus one for the main function assertEquals(4, functions.size()); CallGraph.Function functionA = callgraph.getUniqueFunctionWithName("A"); CallGraph.Function functionB = callgraph.getUniqueFunctionWithName("B"); CallGraph.Function functionC = callgraph.getUniqueFunctionWithName("C"); assertEquals("A", NodeUtil.getFunctionName(functionA.getAstNode())); assertEquals("B", NodeUtil.getFunctionName(functionB.getAstNode())); assertEquals("C", NodeUtil.getFunctionName(functionC.getAstNode())); } public void testGetAllFunctionsContainsNormalFunction() { String source = "function A(){}\n"; CallGraph callgraph = compileAndRunForward(source); Collection<CallGraph.Function> allFunctions = callgraph.getAllFunctions(); // 2 functions: one for A() and one for the main function assertEquals(2, allFunctions.size()); assertTrue(allFunctions.contains(callgraph.getUniqueFunctionWithName("A"))); assertTrue(allFunctions.contains(callgraph.getMainFunction())); } public void testGetAllFunctionsContainsVarAssignedLiteralFunction() { String source = "var A = function(){}\n"; CallGraph callgraph = compileAndRunForward(source); Collection<CallGraph.Function> allFunctions = callgraph.getAllFunctions(); // 2 functions: one for A() and one for the global function assertEquals(2, allFunctions.size()); Function functionA = callgraph.getUniqueFunctionWithName("A"); assertTrue(allFunctions.contains(functionA)); assertTrue(allFunctions.contains(callgraph.getMainFunction())); } public void testGetAllFunctionsContainsNamespaceAssignedLiteralFunction() { String source = "var namespace = {};\n" + "namespace.A = function(){};\n"; CallGraph callgraph = compileAndRunForward(source); Collection<CallGraph.Function> allFunctions = callgraph.getAllFunctions(); // 2 functions: one for namespace.A() and one for the global function assertEquals(2, allFunctions.size()); assertTrue(allFunctions.contains( callgraph.getUniqueFunctionWithName("namespace.A"))); assertTrue(allFunctions.contains(callgraph.getMainFunction())); } public void testGetAllFunctionsContainsLocalFunction() { String source = "var A = function(){var B = function(){}};\n"; CallGraph callgraph = compileAndRunForward(source); Collection<CallGraph.Function> allFunctions = callgraph.getAllFunctions(); // 3 functions: one for A, B, and global function assertEquals(3, allFunctions.size()); assertTrue(allFunctions.contains(callgraph.getUniqueFunctionWithName("A"))); assertTrue(allFunctions.contains(callgraph.getUniqueFunctionWithName("B"))); assertTrue(allFunctions.contains(callgraph.getMainFunction())); } public void testGetAllFunctionsContainsAnonymousFunction() { String source = "var A = function(){(function(){})();};\n"; CallGraph callgraph = compileAndRunForward(source); Collection<CallGraph.Function> allFunctions = callgraph.getAllFunctions(); // 3 functions: A, anonymous, and global function assertEquals(3, allFunctions.size()); assertTrue(allFunctions.contains(callgraph.getUniqueFunctionWithName("A"))); assertTrue( allFunctions.contains(callgraph.getUniqueFunctionWithName(null))); assertTrue(allFunctions.contains(callgraph.getMainFunction())); } public void testGetCallsiteForAstNode() { String source = "function A() {B()};\n" + "function B(){};\n"; CallGraph callgraph = compileAndRunBackward(source); CallGraph.Function functionA = callgraph.getUniqueFunctionWithName("A"); CallGraph.Callsite callToB = functionA.getCallsitesInFunction().iterator().next(); Node callsiteNode = callToB.getAstNode(); assertEquals(callToB, callgraph.getCallsiteForAstNode(callsiteNode)); } public void testFunctionGetCallsites() { String source = "function A() {var x; x()}\n" + "var B = function() {\n" + "(function C(){A()})()\n" + "};\n"; CallGraph callgraph = compileAndRunForward(source); CallGraph.Function functionA = callgraph.getUniqueFunctionWithName("A"); Collection<CallGraph.Callsite> callsitesInA = functionA.getCallsitesInFunction(); assertEquals(1, callsitesInA.size()); CallGraph.Callsite firstCallsiteInA = callsitesInA.iterator().next(); Node aTargetExpression = firstCallsiteInA.getAstNode().getFirstChild(); assertEquals(Token.NAME, aTargetExpression.getType()); assertEquals("x", aTargetExpression.getString()); CallGraph.Function functionB = callgraph.getUniqueFunctionWithName("B"); Collection<CallGraph.Callsite> callsitesInB = functionB.getCallsitesInFunction(); assertEquals(1, callsitesInB.size()); CallGraph.Callsite firstCallsiteInB = callsitesInB.iterator().next(); Node bTargetExpression = firstCallsiteInB.getAstNode().getFirstChild(); assertEquals(Token.FUNCTION, bTargetExpression.getType()); assertEquals("C", NodeUtil.getFunctionName(bTargetExpression)); CallGraph.Function functionC = callgraph.getUniqueFunctionWithName("C"); Collection<CallGraph.Callsite> callsitesInC = functionC.getCallsitesInFunction(); assertEquals(1, callsitesInC.size()); CallGraph.Callsite firstCallsiteInC = callsitesInC.iterator().next(); Node cTargetExpression = firstCallsiteInC.getAstNode().getFirstChild(); assertEquals(Token.NAME, aTargetExpression.getType()); assertEquals("A", cTargetExpression.getString()); } public void testFindNewInFunction() { String source = "function A() {var x; new x(1,2)}\n;"; CallGraph callgraph = compileAndRunForward(source); CallGraph.Function functionA = callgraph.getUniqueFunctionWithName("A"); Collection<CallGraph.Callsite> callsitesInA = functionA.getCallsitesInFunction(); assertEquals(1, callsitesInA.size()); Node callsiteInA = callsitesInA.iterator().next().getAstNode(); assertEquals(Token.NEW, callsiteInA.getType()); Node aTargetExpression = callsiteInA.getFirstChild(); assertEquals(Token.NAME, aTargetExpression.getType()); assertEquals("x", aTargetExpression.getString()); } public void testFindCallsiteTargetGlobalName() { String source = "function A() {}\n" + "function B() {}\n" + "function C() {A()}\n"; CallGraph callgraph = compileAndRunForward(source); CallGraph.Function functionC = callgraph.getUniqueFunctionWithName("C"); assertNotNull(functionC); CallGraph.Callsite callsiteInC = functionC.getCallsitesInFunction().iterator().next(); assertNotNull(callsiteInC); Collection<CallGraph.Function> targetsOfCallsiteInC = callsiteInC.getPossibleTargets(); assertNotNull(targetsOfCallsiteInC); assertEquals(1, targetsOfCallsiteInC.size()); } public void testFindCallsiteTargetAliasedGlobalProperty() { String source = "var namespace = {};\n" + "namespace.A = function() {};\n" + "function C() {namespace.A()}\n"; CallGraph callgraph = compileAndRunForward(source); CallGraph.Function functionC = callgraph.getUniqueFunctionWithName("C"); assertNotNull(functionC); CallGraph.Callsite callsiteInC = functionC.getCallsitesInFunction().iterator().next(); assertNotNull(callsiteInC); Collection<CallGraph.Function> targetsOfCallsiteInC = callsiteInC.getPossibleTargets(); assertNotNull(targetsOfCallsiteInC); assertEquals(1, targetsOfCallsiteInC.size()); } public void testGetAllCallsitesContainsMultiple() { String source = "function A() {}\n" + "var B = function() {\n" + "(function (){A()})()\n" + "};\n" + "A();\n" + "B();\n"; CallGraph callgraph = compileAndRunBackward(source); Collection<CallGraph.Callsite> allCallsites = callgraph.getAllCallsites(); assertEquals(4, allCallsites.size()); } public void testGetAllCallsitesContainsGlobalSite() { String source = "function A(){}\n" + "A();\n"; CallGraph callgraph = compileAndRunBackward(source); Collection<CallGraph.Callsite> allCallsites = callgraph.getAllCallsites(); assertEquals(1, allCallsites.size()); Node callsiteNode = allCallsites.iterator().next().getAstNode(); assertEquals(Token.CALL, callsiteNode.getType()); assertEquals("A", callsiteNode.getFirstChild().getString()); } public void testGetAllCallsitesContainsLocalSite() { String source = "function A(){}\n" + "function B(){A();}\n"; CallGraph callgraph = compileAndRunBackward(source); Collection<CallGraph.Callsite> allCallsites = callgraph.getAllCallsites(); assertEquals(1, allCallsites.size()); Node callsiteNode = allCallsites.iterator().next().getAstNode(); assertEquals(Token.CALL, callsiteNode.getType()); assertEquals("A", callsiteNode.getFirstChild().getString()); } public void testGetAllCallsitesContainsLiteralSite() { String source = "function A(){(function(a){})();}\n"; CallGraph callgraph = compileAndRunBackward(source); Collection<CallGraph.Callsite> allCallsites = callgraph.getAllCallsites(); assertEquals(1, allCallsites.size()); Node callsiteNode = allCallsites.iterator().next().getAstNode(); assertEquals(Token.CALL, callsiteNode.getType()); assertEquals(Token.FUNCTION, callsiteNode.getFirstChild().getType()); } public void testGetAllCallsitesContainsConstructorSite() { String source = "function A(){}\n" + "function B(){new A();}\n"; CallGraph callgraph = compileAndRunBackward(source); Collection<CallGraph.Callsite> allCallsites = callgraph.getAllCallsites(); assertEquals(1, allCallsites.size()); Node callsiteNode = allCallsites.iterator().next().getAstNode(); assertEquals(Token.NEW, callsiteNode.getType()); assertEquals("A", callsiteNode.getFirstChild().getString()); } /** * Test getting a backward directed graph on a backward call graph * and propagating over it. */ public void testGetDirectedGraph_backwardOnBackward() { // For this test we create a simple callback that, when applied until a // fixedpoint, computes whether a function is "poisoned" by an extern. // A function is poisoned if it calls an extern or if it calls another // poisoned function. String source = "function A(){};\n" + "function B(){ExternalFunction(6); C(); D();}\n" + "function C(){B(); A();};\n" + "function D(){A();};\n" + "function E(){C()};\n" + "A();\n"; CallGraph callgraph = compileAndRunBackward(source); final Set<Function> poisonedFunctions = Sets.newHashSet(); // Set up initial poisoned functions for (Callsite callsite : callgraph.getAllCallsites()) { if (callsite.hasExternTarget()) { poisonedFunctions.add(callsite.getContainingFunction()); } } // Propagate poison from callees to callers EdgeCallback<CallGraph.Function, CallGraph.Callsite> edgeCallback = new EdgeCallback<CallGraph.Function, CallGraph.Callsite>() { @Override public boolean traverseEdge(Function callee, Callsite callsite, Function caller) { boolean changed; if (poisonedFunctions.contains(callee)) { changed = poisonedFunctions.add(caller); // Returns true if added } else { changed = false; } return changed; } }; FixedPointGraphTraversal.newTraversal(edgeCallback) .computeFixedPoint(callgraph.getBackwardDirectedGraph()); // We expect B, C, and E to poisoned. assertEquals(3, poisonedFunctions.size()); assertTrue(poisonedFunctions.contains( callgraph.getUniqueFunctionWithName("B"))); assertTrue(poisonedFunctions.contains( callgraph.getUniqueFunctionWithName("C"))); assertTrue(poisonedFunctions.contains( callgraph.getUniqueFunctionWithName("E"))); } /** * Test getting a backward directed graph on a forward call graph * and propagating over it. */ public void testGetDirectedGraph_backwardOnForward() { // For this test we create a simple callback that, when applied until a // fixedpoint, computes whether a function is "poisoned" by an extern. // A function is poisoned if it calls an extern or if it calls another // poisoned function. String source = "function A(){};\n" + "function B(){ExternalFunction(6); C(); D();}\n" + "function C(){B(); A();};\n" + "function D(){A();};\n" + "function E(){C()};\n" + "A();\n"; CallGraph callgraph = compileAndRunForward(source); final Set<Function> poisonedFunctions = Sets.newHashSet(); // Set up initial poisoned functions for (Callsite callsite : callgraph.getAllCallsites()) { if (callsite.hasExternTarget()) { poisonedFunctions.add(callsite.getContainingFunction()); } } // Propagate poison from callees to callers EdgeCallback<CallGraph.Function, CallGraph.Callsite> edgeCallback = new EdgeCallback<CallGraph.Function, CallGraph.Callsite>() { @Override public boolean traverseEdge(Function callee, Callsite callsite, Function caller) { boolean changed; if (poisonedFunctions.contains(callee)) { changed = poisonedFunctions.add(caller); // Returns true if added } else { changed = false; } return changed; } }; FixedPointGraphTraversal.newTraversal(edgeCallback) .computeFixedPoint(callgraph.getBackwardDirectedGraph()); // We expect B, C, and E to poisoned. assertEquals(3, poisonedFunctions.size()); assertTrue(poisonedFunctions.contains( callgraph.getUniqueFunctionWithName("B"))); assertTrue(poisonedFunctions.contains( callgraph.getUniqueFunctionWithName("C"))); assertTrue(poisonedFunctions.contains( callgraph.getUniqueFunctionWithName("E"))); } /** * Test getting a forward directed graph on a forward call graph * and propagating over it. */ public void testGetDirectedGraph_forwardOnForward() { // For this test we create a simple callback that, when applied until a // fixedpoint, computes whether a function is reachable from an initial // set of "root" nodes. String source = "function A(){B()};\n" + "function B(){C();D()}\n" + "function C(){B()};\n" + "function D(){};\n" + "function E(){C()};\n" + "function X(){Y()};\n" + "function Y(){Z()};\n" + "function Z(){};" + "B();\n"; CallGraph callgraph = compileAndRunForward(source); final Set<Function> reachableFunctions = Sets.newHashSet(); // We assume the main function and X are our roots reachableFunctions.add(callgraph.getMainFunction()); reachableFunctions.add(callgraph.getUniqueFunctionWithName("X")); // Propagate reachability from callers to callees EdgeCallback<CallGraph.Function, CallGraph.Callsite> edgeCallback = new EdgeCallback<CallGraph.Function, CallGraph.Callsite>() { @Override public boolean traverseEdge(Function caller, Callsite callsite, Function callee) { boolean changed; if (reachableFunctions.contains(caller)) { changed = reachableFunctions.add(callee); // Returns true if added } else { changed = false; } return changed; } }; FixedPointGraphTraversal.newTraversal(edgeCallback) .computeFixedPoint(callgraph.getForwardDirectedGraph()); // We expect B, C, D, X, Y, Z and the main function should be reachable. // A and E should not be reachable. assertEquals(7, reachableFunctions.size()); assertTrue(reachableFunctions.contains( callgraph.getUniqueFunctionWithName("B"))); assertTrue(reachableFunctions.contains( callgraph.getUniqueFunctionWithName("C"))); assertTrue(reachableFunctions.contains( callgraph.getUniqueFunctionWithName("D"))); assertTrue(reachableFunctions.contains( callgraph.getUniqueFunctionWithName("X"))); assertTrue(reachableFunctions.contains( callgraph.getUniqueFunctionWithName("Y"))); assertTrue(reachableFunctions.contains( callgraph.getUniqueFunctionWithName("Z"))); assertTrue(reachableFunctions.contains( callgraph.getMainFunction())); assertFalse(reachableFunctions.contains( callgraph.getUniqueFunctionWithName("A"))); assertFalse(reachableFunctions.contains( callgraph.getUniqueFunctionWithName("E"))); } /** * Test getting a backward directed graph on a forward call graph * and propagating over it. */ public void testGetDirectedGraph_forwardOnBackward() { // For this test we create a simple callback that, when applied until a // fixedpoint, computes whether a function is reachable from an initial // set of "root" nodes. String source = "function A(){B()};\n" + "function B(){C();D()}\n" + "function C(){B()};\n" + "function D(){};\n" + "function E(){C()};\n" + "function X(){Y()};\n" + "function Y(){Z()};\n" + "function Z(){};" + "B();\n"; CallGraph callgraph = compileAndRunBackward(source); final Set<Function> reachableFunctions = Sets.newHashSet(); // We assume the main function and X are our roots reachableFunctions.add(callgraph.getMainFunction()); reachableFunctions.add(callgraph.getUniqueFunctionWithName("X")); // Propagate reachability from callers to callees EdgeCallback<CallGraph.Function, CallGraph.Callsite> edgeCallback = new EdgeCallback<CallGraph.Function, CallGraph.Callsite>() { @Override public boolean traverseEdge(Function caller, Callsite callsite, Function callee) { boolean changed; if (reachableFunctions.contains(caller)) { changed = reachableFunctions.add(callee); // Returns true if added } else { changed = false; } return changed; } }; FixedPointGraphTraversal.newTraversal(edgeCallback) .computeFixedPoint(callgraph.getForwardDirectedGraph()); // We expect B, C, D, X, Y, Z and the main function should be reachable. // A and E should not be reachable. assertEquals(7, reachableFunctions.size()); assertTrue(reachableFunctions.contains( callgraph.getUniqueFunctionWithName("B"))); assertTrue(reachableFunctions.contains( callgraph.getUniqueFunctionWithName("C"))); assertTrue(reachableFunctions.contains( callgraph.getUniqueFunctionWithName("D"))); assertTrue(reachableFunctions.contains( callgraph.getUniqueFunctionWithName("X"))); assertTrue(reachableFunctions.contains( callgraph.getUniqueFunctionWithName("Y"))); assertTrue(reachableFunctions.contains( callgraph.getUniqueFunctionWithName("Z"))); assertTrue(reachableFunctions.contains( callgraph.getMainFunction())); assertFalse(reachableFunctions.contains( callgraph.getUniqueFunctionWithName("A"))); assertFalse(reachableFunctions.contains( callgraph.getUniqueFunctionWithName("E"))); } public void testFunctionIsMain() { String source = "function A(){};\n" + "A();\n"; CallGraph callgraph = compileAndRunForward(source); CallGraph.Function mainFunction = callgraph.getMainFunction(); assertTrue(mainFunction.isMain()); assertNotNull(mainFunction.getBodyNode()); assertTrue(mainFunction.getBodyNode().isBlock()); CallGraph.Function functionA = callgraph.getUniqueFunctionWithName("A"); assertFalse(functionA.isMain()); } public void testFunctionGetAstNode() { String source = "function A(){};\n" + "A();\n"; CallGraph callgraph = compileAndRunForward(source); CallGraph.Function mainFunction = callgraph.getMainFunction(); // Main function's AST node should be the global block assertTrue(mainFunction.getAstNode().isBlock()); CallGraph.Function functionA = callgraph.getUniqueFunctionWithName("A"); // Regular function's AST node should be the function for A assertTrue(functionA.getAstNode().isFunction()); assertEquals("A", NodeUtil.getFunctionName(functionA.getAstNode())); } public void testFunctionGetBodyNode() { String source = "function A(){};\n" + "A();\n"; CallGraph callgraph = compileAndRunForward(source); CallGraph.Function mainFunction = callgraph.getMainFunction(); // Main function's body node should its AST node assertEquals(mainFunction.getAstNode(), mainFunction.getBodyNode()); CallGraph.Function functionA = callgraph.getUniqueFunctionWithName("A"); // Regular function's body node should be the block for A assertTrue(functionA.getBodyNode().isBlock()); assertEquals(NodeUtil.getFunctionBody(functionA.getAstNode()), functionA.getBodyNode()); } public void testFunctionGetName() { String source = "function A(){};\n" + "A();\n"; CallGraph callgraph = compileAndRunForward(source); CallGraph.Function mainFunction = callgraph.getMainFunction(); // Main function's name should be CallGraph.MAIN_FUNCTION_NAME assertEquals(CallGraph.MAIN_FUNCTION_NAME, mainFunction.getName()); CallGraph.Function functionA = callgraph.getUniqueFunctionWithName("A"); // Regular function's name should be its name assertEquals(NodeUtil.getFunctionName(functionA.getAstNode()), functionA.getName()); } public void testFunctionGetCallsitesInFunction() { String source = "function A(){};\n" + "function B(){A()};\n" + "A();\n" + "B();\n"; CallGraph callgraph = compileAndRunForward(source); // Main function calls A and B CallGraph.Function mainFunction = callgraph.getMainFunction(); List<String> callsiteNamesInMain = getCallsiteTargetNames(mainFunction.getCallsitesInFunction()); assertEquals(2, callsiteNamesInMain.size()); assertTrue(callsiteNamesInMain.contains("A")); assertTrue(callsiteNamesInMain.contains("B")); // A calls no functions CallGraph.Function functionA = callgraph.getUniqueFunctionWithName("A"); assertEquals(0, functionA.getCallsitesInFunction().size()); // B calls A CallGraph.Function functionB = callgraph.getUniqueFunctionWithName("B"); List<String> callsiteNamesInB = getCallsiteTargetNames(functionB.getCallsitesInFunction()); assertEquals(1, callsiteNamesInB.size()); assertTrue(callsiteNamesInMain.contains("A")); } public void testFunctionGetCallsitesInFunction_ignoreInnerFunction() { String source = "function A(){var B = function(){C();}};\n" + "function C(){};\n"; CallGraph callgraph = compileAndRunForward(source); // A calls no functions (and especially not C) CallGraph.Function functionA = callgraph.getUniqueFunctionWithName("A"); assertEquals(0, functionA.getCallsitesInFunction().size()); } public void testFunctionGetCallsitesPossiblyTargetingFunction() { String source = "function A(){B()};\n" + "function B(){C();C();};\n" + "function C(){C()};\n" + "A();\n"; CallGraph callgraph = compileAndRunBackward(source); Function main = callgraph.getMainFunction(); Function functionA = callgraph.getUniqueFunctionWithName("A"); Function functionB = callgraph.getUniqueFunctionWithName("B"); Function functionC = callgraph.getUniqueFunctionWithName("C"); assertEquals(0, main.getCallsitesPossiblyTargetingFunction().size()); Collection<Callsite> callsitesTargetingA = functionA.getCallsitesPossiblyTargetingFunction(); // A is called only from the main function assertEquals(1, callsitesTargetingA.size()); assertEquals(main, callsitesTargetingA.iterator().next().getContainingFunction()); Collection<Callsite> callsitesTargetingB = functionB.getCallsitesPossiblyTargetingFunction(); // B is called only from A assertEquals(1, callsitesTargetingB.size()); assertEquals(functionA, callsitesTargetingB.iterator().next().getContainingFunction()); Collection<Callsite> callsitesTargetingC = functionC.getCallsitesPossiblyTargetingFunction(); // C is called 3 times: twice from B and once from C assertEquals(3, callsitesTargetingC.size()); Collection<Callsite> expectedFunctionsCallingC = Sets.newHashSet(functionB.getCallsitesInFunction()); expectedFunctionsCallingC.addAll(functionC.getCallsitesInFunction()); assertTrue(callsitesTargetingC.containsAll(expectedFunctionsCallingC)); } public void testFunctionGetCallsitesInFunction_newIsCallsite() { String source = "function A(){};\n" + "function C(){new A()};\n"; CallGraph callgraph = compileAndRunForward(source); // The call to new A() in C() should count as a callsite CallGraph.Function functionC = callgraph.getUniqueFunctionWithName("C"); assertEquals(1, functionC.getCallsitesInFunction().size()); } public void testFunctionGetIsAliased() { // Aliased by VAR assignment String source = "function A(){};\n" + "var ns = {};\n" + "ns.B = function() {};\n" + "var C = function() {}\n" + "var D = function() {}\n" + "var aliasA = A;\n" + "var aliasB = ns.B;\n" + "var aliasC = C;\n" + "D();"; compileAndRunForward(source); assertFunctionAliased(true, "A"); assertFunctionAliased(true, "ns.B"); assertFunctionAliased(true, "C"); assertFunctionAliased(false, "D"); // Aliased by normal assignment source = "function A(){};\n" + "var ns = {};\n" + "ns.B = function() {};\n" + "var C = function() {}\n" + "ns.D = function() {}\n" + "var aliasA;\n" + "aliasA = A;\n" + "var aliasB = {};\n" + "aliasB.foo = ns.B;\n" + "var aliasC;\n" + "aliasC = C;\n" + "ns.D();"; compileAndRunForward(source); assertFunctionAliased(true, "A"); assertFunctionAliased(true, "ns.B"); assertFunctionAliased(true, "C"); assertFunctionAliased(false, "ns.D"); // Aliased by passing as parameter source = "function A(){};\n" + "var ns = {};\n" + "ns.B = function() {};\n" + "var C = function() {}\n" + "function D() {}\n" + "var foo = function(a) {}\n" + "foo(A);\n" + "foo(ns.B)\n" + "foo(C);\n" + "D();"; compileAndRunForward(source); assertFunctionAliased(true, "A"); assertFunctionAliased(true, "ns.B"); assertFunctionAliased(true, "C"); assertFunctionAliased(false, "D"); // Not aliased by being target of call source = "function A(){};\n" + "var ns = {};\n" + "ns.B = function() {};\n" + "var C = function() {}\n" + "A();\n" + "ns.B();\n" + "C();\n"; compileAndRunForward(source); assertFunctionAliased(false, "A"); assertFunctionAliased(false, "ns.B"); assertFunctionAliased(false, "C"); // Not aliased by GET{PROP,ELEM} source = "function A(){};\n" + "var ns = {};\n" + "ns.B = function() {};\n" + "var C = function() {}\n" + "A.foo;\n" + "ns.B.prototype;\n" + "C[0];\n"; compileAndRunForward(source); assertFunctionAliased(false, "A"); assertFunctionAliased(false, "ns.B"); assertFunctionAliased(false, "C"); } public void testFunctionGetIsExposedToCallOrApply() { // Exposed to call String source = "function A(){};\n" + "function B(){};\n" + "function C(){};\n" + "var x;\n" + "A.call(x);\n" + "B.apply(x);\n" + "C();\n"; CallGraph callGraph = compileAndRunForward(source); Function functionA = callGraph.getUniqueFunctionWithName("A"); Function functionB = callGraph.getUniqueFunctionWithName("B"); Function functionC = callGraph.getUniqueFunctionWithName("C"); assertTrue(functionA.isExposedToCallOrApply()); assertTrue(functionB.isExposedToCallOrApply()); assertFalse(functionC.isExposedToCallOrApply()); } public void testCallsiteGetAstNode() { String source = "function A(){B()};\n" + "function B(){};\n"; CallGraph callgraph = compileAndRunForward(source); Function functionA = callgraph.getUniqueFunctionWithName("A"); Callsite callToB = functionA.getCallsitesInFunction().iterator().next(); assertTrue(callToB.getAstNode().isCall()); } public void testCallsiteGetContainingFunction() { String source = "function A(){B()};\n" + "function B(){};\n" + "A();\n"; CallGraph callgraph = compileAndRunForward(source); Function mainFunction = callgraph.getMainFunction(); Callsite callToA = mainFunction.getCallsitesInFunction().iterator().next(); assertEquals(mainFunction, callToA.getContainingFunction()); Function functionA = callgraph.getUniqueFunctionWithName("A"); Callsite callToB = functionA.getCallsitesInFunction().iterator().next(); assertEquals(functionA, callToB.getContainingFunction()); } public void testCallsiteGetKnownTargets() { String source = "function A(){B()};\n" + "function B(){};\n" + "A();\n"; CallGraph callgraph = compileAndRunForward(source); Function mainFunction = callgraph.getMainFunction(); Function functionA = callgraph.getUniqueFunctionWithName("A"); Function functionB = callgraph.getUniqueFunctionWithName("B"); Callsite callInMain = mainFunction.getCallsitesInFunction().iterator() .next(); Collection<Function> targetsOfCallInMain = callInMain.getPossibleTargets(); assertEquals(1, targetsOfCallInMain.size()); assertTrue(targetsOfCallInMain.contains(functionA)); Callsite callInA = functionA.getCallsitesInFunction().iterator().next(); Collection<Function> targetsOfCallInA = callInA.getPossibleTargets(); assertTrue(targetsOfCallInA.contains(functionB)); } public void testCallsiteHasUnknownTarget() { String source = "var A = externalnamespace.prop;\n" + "function B(){A();};\n" + "B();\n"; CallGraph callgraph = compileAndRunForward(source); Function mainFunction = callgraph.getMainFunction(); Function functionB = callgraph.getUniqueFunctionWithName("B"); Callsite callInMain = mainFunction.getCallsitesInFunction().iterator().next(); // B()'s target function is known, and it is functionB assertFalse(callInMain.hasUnknownTarget()); assertEquals("B", callInMain.getAstNode().getFirstChild().getString()); Callsite callInB = functionB.getCallsitesInFunction().iterator().next(); // A() has an unknown target and no known targets assertTrue(callInB.hasUnknownTarget()); assertEquals(0, callInB.getPossibleTargets().size()); } public void testCallsiteHasExternTarget() { String source = "var A = function(){}\n" + "function B(){ExternalFunction(6);};\n" + "A();\n"; CallGraph callgraph = compileAndRunForward(source); Function mainFunction = callgraph.getMainFunction(); Function functionB = callgraph.getUniqueFunctionWithName("B"); Callsite callInMain = mainFunction.getCallsitesInFunction().iterator().next(); // A()'s target function is not an extern assertFalse(callInMain.hasExternTarget()); Callsite callInB = functionB.getCallsitesInFunction().iterator().next(); assertEquals("ExternalFunction", callInB.getAstNode().getFirstChild().getString()); // ExternalFunction(6) is a call to an extern function assertTrue(callInB.hasExternTarget()); assertEquals(0, callInB.getPossibleTargets().size()); } public void testThrowForBackwardOpOnForwardGraph() { String source = "function A(){B()};\n" + "function B(){C();C();};\n" + "function C(){C()};\n" + "A();\n"; CallGraph callgraph = compileAndRunForward(source); Function functionA = callgraph.getUniqueFunctionWithName("A"); UnsupportedOperationException caughtException = null; try { functionA.getCallsitesPossiblyTargetingFunction(); } catch (UnsupportedOperationException e) { caughtException = e; } assertNotNull(caughtException); } public void testThrowForForwardOpOnBackwardGraph() { String source = "function A(){B()};\n" + "function B(){};\n" + "A();\n"; CallGraph callgraph = compileAndRunBackward(source); Function mainFunction = callgraph.getMainFunction(); Function functionA = callgraph.getUniqueFunctionWithName("A"); Callsite callInMain = mainFunction.getCallsitesInFunction().iterator() .next(); UnsupportedOperationException caughtException = null; try { callInMain.getPossibleTargets(); } catch (UnsupportedOperationException e) { return; } fail(); } /** * Helper function that, given a collection of callsites, returns a * collection of the names of the target expression nodes, e.g. * if the callsites are [A(), B.b()], the collection returned is * ["A", "B"]. * * This makes it easier to test methods that return collections of callsites. * * An exception is thrown if the callsite target is not a simple name * (e.g. "a.bar()"). */ private List<String> getCallsiteTargetNames(Collection<Callsite> callsites) { List<String> result = Lists.newArrayList(); for (Callsite callsite : callsites) { Node targetExpressionNode = callsite.getAstNode().getFirstChild(); if (targetExpressionNode.isName()) { result.add(targetExpressionNode.getString()); } else { throw new IllegalStateException("Called getCallsiteTargetNames() on " + "a complex callsite."); } } return result; } private void assertFunctionAliased(boolean aliased, String name) { Function function = currentProcessor.getUniqueFunctionWithName(name); assertEquals(aliased, function.isAliased()); } private CallGraph compileAndRunBackward(String js) { return compileAndRun(SHARED_EXTERNS, js, false, true); } private CallGraph compileAndRunForward(String js) { return compileAndRun(SHARED_EXTERNS, js, true, false); } private CallGraph compileAndRun(String externs, String js, boolean forward, boolean backward) { createBackwardCallGraph = backward; createForwardCallGraph = forward; testSame(externs, js, null); return currentProcessor; } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Tests for {@link ChainCalls} * */ public class ChainCallsTest extends CompilerTestCase { @Override protected CompilerPass getProcessor(final Compiler compiler) { return new ChainCalls(compiler); } @Override protected int getNumRepetitions() { return 1; } public void testUnchainedCalls() { test( "" + "/** @constructor */ function Foo() {}\n" + "Foo.prototype.bar = function() { return this; };\n" + "var f = new Foo();\n" + "f.bar();\n" + "f.bar();\n", "" + "/** @constructor */ function Foo() {}\n" + "Foo.prototype.bar = function() { return this; };\n" + "var f = new Foo();\n" + "f.bar().bar();\n"); } public void testSecondCallReturnNotThis() { test( "" + "/** @constructor */ function Foo() {}\n" + "Foo.prototype.bar = function() { return this; };\n" + "Foo.prototype.baz = function() {};\n" + "var f = new Foo();\n" + "f.bar();\n" + "f.baz();\n", "" + "/** @constructor */ function Foo() {}\n" + "Foo.prototype.bar = function() { return this; };\n" + "Foo.prototype.baz = function() {};\n" + "var f = new Foo();\n" + "f.bar().baz();\n"); } public void testDifferentInstance() { testSame( "" + "/** @constructor */ function Foo() {}\n" + "Foo.prototype.bar = function() { return this; };\n" + "new Foo().bar();\n" + "new Foo().bar();\n"); } public void testSubclass() { testSame( "" + "/** @constructor */ function Foo() {}\n" + "Foo.prototype.bar = function() { return this; };\n" + "/** @constructor\n@extends {Foo} */ function Baz() {}\n" + "Baz.prototype.bar = function() {};\n" + "(/** @type {Foo} */ new Baz()).bar();\n" + "(/** @type {Foo} */ new Baz()).bar();\n"); } public void testSimpleDefinitionFinder() { String defs = "/** @constructor */ function Foo() {}\n" + "Foo.prototype.a = function() { return this; };" + "/** @constructor */ function Bar() {}\n" + "Bar.prototype.a = function() {};"; testSame( defs + "var o = new Foo; o.a(); o.a();"); testSame( defs + "var o = new Bar; o.a(); o.a();"); } public void testSimpleDefinitionFinder2() { String defs = "/** @constructor */ function Foo() {}\n" + "Foo.prototype.a = function() { return this; };" + "/** @constructor */ function Bar() {}\n" + "Bar.prototype.a = function() { return this; };"; testSame( defs + "var o = new Foo; o.a().a();"); testSame( defs + "var o = new Bar; o.a().a();"); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import static com.google.javascript.jscomp.CheckAccessControls.BAD_PRIVATE_GLOBAL_ACCESS; import static com.google.javascript.jscomp.CheckAccessControls.BAD_PRIVATE_PROPERTY_ACCESS; import static com.google.javascript.jscomp.CheckAccessControls.BAD_PROTECTED_PROPERTY_ACCESS; import static com.google.javascript.jscomp.CheckAccessControls.CONST_PROPERTY_DELETED; import static com.google.javascript.jscomp.CheckAccessControls.CONST_PROPERTY_REASSIGNED_VALUE; import static com.google.javascript.jscomp.CheckAccessControls.DEPRECATED_CLASS; import static com.google.javascript.jscomp.CheckAccessControls.DEPRECATED_CLASS_REASON; import static com.google.javascript.jscomp.CheckAccessControls.DEPRECATED_NAME; import static com.google.javascript.jscomp.CheckAccessControls.DEPRECATED_NAME_REASON; import static com.google.javascript.jscomp.CheckAccessControls.DEPRECATED_PROP; import static com.google.javascript.jscomp.CheckAccessControls.DEPRECATED_PROP_REASON; import static com.google.javascript.jscomp.CheckAccessControls.EXTEND_FINAL_CLASS; import static com.google.javascript.jscomp.CheckAccessControls.PRIVATE_OVERRIDE; import static com.google.javascript.jscomp.CheckAccessControls.VISIBILITY_MISMATCH; /** * Tests for {@link CheckAccessControls}. * * @author nicksantos@google.com (Nick Santos) */ public class CheckAccessControlsTest extends CompilerTestCase { public CheckAccessControlsTest() { super(CompilerTypeTestCase.DEFAULT_EXTERNS); parseTypeInfo = true; enableTypeCheck(CheckLevel.WARNING); } @Override protected CompilerPass getProcessor(final Compiler compiler) { return new CheckAccessControls(compiler); } @Override protected CompilerOptions getOptions() { CompilerOptions options = super.getOptions(); options.setWarningLevel(DiagnosticGroups.ACCESS_CONTROLS, CheckLevel.ERROR); options.setWarningLevel(DiagnosticGroups.CONSTANT_PROPERTY, CheckLevel.ERROR); return options; } /** * Tests that the given JavaScript code has a @deprecated marker * somewhere in it which raises an error. Also tests that the * deprecated marker works with a message. The JavaScript should * have a JsDoc of the form "@deprecated %s\n". * * @param js The JavaScript code to parse and test. * @param reason A simple deprecation reason string, used for testing * the addition of a deprecation reason to the @deprecated tag. * @param error The deprecation error expected when no reason is given. * @param errorWithMessage The deprecation error expected when a reason * message is given. */ private void testDep(String js, String reason, DiagnosticType error, DiagnosticType errorWithMessage) { // Test without a reason. test(String.format(js, ""), null, error); // Test with a reason. test(String.format(js, reason), null, errorWithMessage, null, reason); } public void testDeprecatedFunction() { testDep("/** @deprecated %s */ function f() {} function g() { f(); }", "Some Reason", DEPRECATED_NAME, DEPRECATED_NAME_REASON); } public void testWarningOnDeprecatedConstVariable() { testDep("/** @deprecated %s */ var f = 4; function g() { alert(f); }", "Another reason", DEPRECATED_NAME, DEPRECATED_NAME_REASON); } public void testThatNumbersArentDeprecated() { testSame("/** @deprecated */ var f = 4; var h = 3; " + "function g() { alert(h); }"); } public void testDeprecatedFunctionVariable() { testDep("/** @deprecated %s */ var f = function() {}; " + "function g() { f(); }", "I like g...", DEPRECATED_NAME, DEPRECATED_NAME_REASON); } public void testNoWarningInGlobalScope() { testSame("var goog = {}; goog.makeSingleton = function(x) {};" + "/** @deprecated */ function f() {} goog.makeSingleton(f);"); } public void testNoWarningInGlobalScopeForCall() { testDep("/** @deprecated %s */ function f() {} f();", "Some global scope", DEPRECATED_NAME, DEPRECATED_NAME_REASON); } public void testNoWarningInDeprecatedFunction() { testSame("/** @deprecated */ function f() {} " + "/** @deprecated */ function g() { f(); }"); } public void testWarningInNormalClass() { testDep("/** @deprecated %s */ function f() {}" + "/** @constructor */ var Foo = function() {}; " + "Foo.prototype.bar = function() { f(); }", "FooBar", DEPRECATED_NAME, DEPRECATED_NAME_REASON); } public void testWarningForProperty1() { testDep("/** @constructor */ function Foo() {}" + "/** @deprecated %s */ Foo.prototype.bar = 3;" + "Foo.prototype.baz = function() { alert((new Foo()).bar); };", "A property is bad", DEPRECATED_PROP, DEPRECATED_PROP_REASON); } public void testWarningForProperty2() { testDep("/** @constructor */ function Foo() {}" + "/** @deprecated %s */ Foo.prototype.bar = 3;" + "Foo.prototype.baz = function() { alert(this.bar); };", "Zee prop, it is deprecated!", DEPRECATED_PROP, DEPRECATED_PROP_REASON); } public void testWarningForDeprecatedClass() { testDep("/** @constructor \n* @deprecated %s */ function Foo() {} " + "function f() { new Foo(); }", "Use the class 'Bar'", DEPRECATED_CLASS, DEPRECATED_CLASS_REASON); } public void testNoWarningForDeprecatedClassInstance() { testSame("/** @constructor \n * @deprecated */ function Foo() {} " + "/** @param {Foo} x */ function f(x) { return x; }"); } public void testWarningForDeprecatedSuperClass() { testDep("/** @constructor \n * @deprecated %s */ function Foo() {} " + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}" + "function f() { new SubFoo(); }", "Superclass to the rescue!", DEPRECATED_CLASS, DEPRECATED_CLASS_REASON); } public void testWarningForDeprecatedSuperClass2() { testDep("/** @constructor \n * @deprecated %s */ function Foo() {} " + "var namespace = {}; " + "/** @constructor \n * @extends {Foo} */ " + "namespace.SubFoo = function() {}; " + "function f() { new namespace.SubFoo(); }", "Its only weakness is Kryptoclass", DEPRECATED_CLASS, DEPRECATED_CLASS_REASON); } public void testWarningForPrototypeProperty() { testDep("/** @constructor */ function Foo() {}" + "/** @deprecated %s */ Foo.prototype.bar = 3;" + "Foo.prototype.baz = function() { alert(Foo.prototype.bar); };", "It is now in production, use that model...", DEPRECATED_PROP, DEPRECATED_PROP_REASON); } public void testNoWarningForNumbers() { testSame("/** @constructor */ function Foo() {}" + "/** @deprecated */ Foo.prototype.bar = 3;" + "Foo.prototype.baz = function() { alert(3); };"); } public void testWarningForMethod1() { testDep("/** @constructor */ function Foo() {}" + "/** @deprecated %s */ Foo.prototype.bar = function() {};" + "Foo.prototype.baz = function() { this.bar(); };", "There is a madness to this method", DEPRECATED_PROP, DEPRECATED_PROP_REASON); } public void testWarningForMethod2() { testDep("/** @constructor */ function Foo() {} " + "/** @deprecated %s */ Foo.prototype.bar; " + "Foo.prototype.baz = function() { this.bar(); };", "Stop the ringing!", DEPRECATED_PROP, DEPRECATED_PROP_REASON); } public void testNoWarningInDeprecatedClass() { testSame("/** @deprecated */ function f() {} " + "/** @constructor \n * @deprecated */ " + "var Foo = function() {}; " + "Foo.prototype.bar = function() { f(); }"); } public void testNoWarningInDeprecatedClass2() { testSame("/** @deprecated */ function f() {} " + "/** @constructor \n * @deprecated */ " + "var Foo = function() {}; " + "Foo.bar = function() { f(); }"); } public void testNoWarningInDeprecatedStaticMethod() { testSame("/** @deprecated */ function f() {} " + "/** @constructor */ " + "var Foo = function() {}; " + "/** @deprecated */ Foo.bar = function() { f(); }"); } public void testWarningInStaticMethod() { testDep("/** @deprecated %s */ function f() {} " + "/** @constructor */ " + "var Foo = function() {}; " + "Foo.bar = function() { f(); }", "crazy!", DEPRECATED_NAME, DEPRECATED_NAME_REASON); } public void testDeprecatedObjLitKey() { testDep("var f = {}; /** @deprecated %s */ f.foo = 3; " + "function g() { return f.foo; }", "It is literally not used anymore", DEPRECATED_PROP, DEPRECATED_PROP_REASON); } public void testWarningForSubclassMethod() { testDep("/** @constructor */ function Foo() {}" + "Foo.prototype.bar = function() {};" + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}" + "/** @deprecated %s */ SubFoo.prototype.bar = function() {};" + "function f() { (new SubFoo()).bar(); };", "I have a parent class!", DEPRECATED_PROP, DEPRECATED_PROP_REASON); } public void testWarningForSuperClassWithDeprecatedSubclassMethod() { testSame("/** @constructor */ function Foo() {}" + "Foo.prototype.bar = function() {};" + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}" + "/** @deprecated \n * @override */ SubFoo.prototype.bar = " + "function() {};" + "function f() { (new Foo()).bar(); };"); } public void testWarningForSuperclassMethod() { testDep("/** @constructor */ function Foo() {}" + "/** @deprecated %s */ Foo.prototype.bar = function() {};" + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}" + "SubFoo.prototype.bar = function() {};" + "function f() { (new SubFoo()).bar(); };", "I have a child class!", DEPRECATED_PROP, DEPRECATED_PROP_REASON); } public void testWarningForSuperclassMethod2() { testDep("/** @constructor */ function Foo() {}" + "/** @deprecated %s \n* @protected */" + "Foo.prototype.bar = function() {};" + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}" + "/** @protected */SubFoo.prototype.bar = function() {};" + "function f() { (new SubFoo()).bar(); };", "I have another child class...", DEPRECATED_PROP, DEPRECATED_PROP_REASON); } public void testWarningForBind() { testDep("/** @deprecated %s */ Function.prototype.bind = function() {};" + "(function() {}).bind();", "I'm bound to this method...", DEPRECATED_PROP, DEPRECATED_PROP_REASON); } public void testWarningForDeprecatedClassInGlobalScope() { testDep("/** @constructor \n * @deprecated %s */ var Foo = function() {};" + "new Foo();", "I'm a very worldly object!", DEPRECATED_CLASS, DEPRECATED_CLASS_REASON); } public void testNoWarningForPrototypeCopying() { testSame("/** @constructor */ var Foo = function() {};" + "Foo.prototype.bar = function() {};" + "/** @deprecated */ Foo.prototype.baz = Foo.prototype.bar;" + "(new Foo()).bar();"); } public void testNoWarningOnDeprecatedPrototype() { // This used to cause an NPE. testSame("/** @constructor */ var Foo = function() {};" + "/** @deprecated */ Foo.prototype = {};" + "Foo.prototype.bar = function() {};"); } public void testPrivateAccessForNames() { testSame("/** @private */ function foo_() {}; foo_();"); test(new String[] { "/** @private */ function foo_() {};", "foo_();" }, null, BAD_PRIVATE_GLOBAL_ACCESS); } public void testPrivateAccessForProperties1() { testSame("/** @constructor */ function Foo() {}" + "/** @private */ Foo.prototype.bar_ = function() {};" + "Foo.prototype.baz = function() { this.bar_(); }; (new Foo).bar_();"); } public void testPrivateAccessForProperties2() { testSame(new String[] { "/** @constructor */ function Foo() {}", "/** @private */ Foo.prototype.bar_ = function() {};" + "Foo.prototype.baz = function() { this.bar_(); }; (new Foo).bar_();" }); } public void testPrivateAccessForProperties3() { testSame(new String[] { "/** @constructor */ function Foo() {}" + "/** @private */ Foo.prototype.bar_ = function() {}; (new Foo).bar_();", "Foo.prototype.baz = function() { this.bar_(); };" }); } public void testPrivateAccessForProperties4() { testSame(new String[] { "/** @constructor */ function Foo() {}" + "/** @private */ Foo.prototype.bar_ = function() {};", "Foo.prototype['baz'] = function() { (new Foo()).bar_(); };" }); } public void testNoPrivateAccessForProperties1() { test(new String[] { "/** @constructor */ function Foo() {} (new Foo).bar_();", "/** @private */ Foo.prototype.bar_ = function() {};" + "Foo.prototype.baz = function() { this.bar_(); };" }, null, BAD_PRIVATE_PROPERTY_ACCESS); } public void testNoPrivateAccessForProperties2() { test(new String[] { "/** @constructor */ function Foo() {} " + "/** @private */ Foo.prototype.bar_ = function() {};" + "Foo.prototype.baz = function() { this.bar_(); };", "(new Foo).bar_();" }, null, BAD_PRIVATE_PROPERTY_ACCESS); } public void testNoPrivateAccessForProperties3() { test(new String[] { "/** @constructor */ function Foo() {} " + "/** @private */ Foo.prototype.bar_ = function() {};", "/** @constructor */ function OtherFoo() { (new Foo).bar_(); }" }, null, BAD_PRIVATE_PROPERTY_ACCESS); } public void testNoPrivateAccessForProperties4() { test(new String[] { "/** @constructor */ function Foo() {} " + "/** @private */ Foo.prototype.bar_ = function() {};", "/** @constructor \n * @extends {Foo} */ " + "function SubFoo() { this.bar_(); }" }, null, BAD_PRIVATE_PROPERTY_ACCESS); } public void testNoPrivateAccessForProperties5() { test(new String[] { "/** @constructor */ function Foo() {} " + "/** @private */ Foo.prototype.bar_ = function() {};", "/** @constructor \n * @extends {Foo} */ " + "function SubFoo() {};" + "SubFoo.prototype.baz = function() { this.bar_(); }" }, null, BAD_PRIVATE_PROPERTY_ACCESS); } public void testNoPrivateAccessForProperties6() { // Overriding a private property with a non-private property // in a different file causes problems. test(new String[] { "/** @constructor */ function Foo() {} " + "/** @private */ Foo.prototype.bar_ = function() {};", "/** @constructor \n * @extends {Foo} */ " + "function SubFoo() {};" + "SubFoo.prototype.bar_ = function() {};" }, null, BAD_PRIVATE_PROPERTY_ACCESS); } public void testNoPrivateAccessForProperties7() { // It's OK to override a private property with a non-private property // in the same file, but you'll get yelled at when you try to use it. test(new String[] { "/** @constructor */ function Foo() {} " + "/** @private */ Foo.prototype.bar_ = function() {};" + "/** @constructor \n * @extends {Foo} */ " + "function SubFoo() {};" + "SubFoo.prototype.bar_ = function() {};", "SubFoo.prototype.baz = function() { this.bar_(); }" }, null, BAD_PRIVATE_PROPERTY_ACCESS); } public void testNoPrivateAccessForProperties8() { test(new String[] { "/** @constructor */ function Foo() { /** @private */ this.bar_ = 3; }", "/** @constructor \n * @extends {Foo} */ " + "function SubFoo() { /** @private */ this.bar_ = 3; };" }, null, PRIVATE_OVERRIDE); } public void testProtectedAccessForProperties1() { testSame(new String[] { "/** @constructor */ function Foo() {}" + "/** @protected */ Foo.prototype.bar = function() {};" + "(new Foo).bar();", "Foo.prototype.baz = function() { this.bar(); };" }); } public void testProtectedAccessForProperties2() { testSame(new String[] { "/** @constructor */ function Foo() {}" + "/** @protected */ Foo.prototype.bar = function() {};" + "(new Foo).bar();", "/** @constructor \n * @extends {Foo} */" + "function SubFoo() { this.bar(); }" }); } public void testProtectedAccessForProperties3() { testSame(new String[] { "/** @constructor */ function Foo() {}" + "/** @protected */ Foo.prototype.bar = function() {};" + "(new Foo).bar();", "/** @constructor \n * @extends {Foo} */" + "function SubFoo() { }" + "SubFoo.baz = function() { (new Foo).bar(); }" }); } public void testProtectedAccessForProperties4() { testSame(new String[] { "/** @constructor */ function Foo() {}" + "/** @protected */ Foo.bar = function() {};", "/** @constructor \n * @extends {Foo} */" + "function SubFoo() { Foo.bar(); }" }); } public void testProtectedAccessForProperties5() { testSame(new String[] { "/** @constructor */ function Foo() {}" + "/** @protected */ Foo.prototype.bar = function() {};" + "(new Foo).bar();", "/** @constructor \n * @extends {Foo} */" + "var SubFoo = function() { this.bar(); }" }); } public void testProtectedAccessForProperties6() { testSame(new String[] { "var goog = {};" + "/** @constructor */ goog.Foo = function() {};" + "/** @protected */ goog.Foo.prototype.bar = function() {};", "/** @constructor \n * @extends {goog.Foo} */" + "goog.SubFoo = function() { this.bar(); };" }); } public void testNoProtectedAccessForProperties1() { test(new String[] { "/** @constructor */ function Foo() {} " + "/** @protected */ Foo.prototype.bar = function() {};", "(new Foo).bar();" }, null, BAD_PROTECTED_PROPERTY_ACCESS); } public void testNoProtectedAccessForProperties2() { test(new String[] { "/** @constructor */ function Foo() {} " + "/** @protected */ Foo.prototype.bar = function() {};", "/** @constructor */ function OtherFoo() { (new Foo).bar(); }" }, null, BAD_PROTECTED_PROPERTY_ACCESS); } public void testNoProtectedAccessForProperties3() { test(new String[] { "/** @constructor */ function Foo() {} " + "/** @constructor \n * @extends {Foo} */ " + "function SubFoo() {}" + "/** @protected */ SubFoo.prototype.bar = function() {};", "/** @constructor \n * @extends {Foo} */ " + "function SubberFoo() { (new SubFoo).bar(); }" }, null, BAD_PROTECTED_PROPERTY_ACCESS); } public void testNoProtectedAccessForProperties4() { test(new String[] { "/** @constructor */ function Foo() { (new SubFoo).bar(); } ", "/** @constructor \n * @extends {Foo} */ " + "function SubFoo() {}" + "/** @protected */ SubFoo.prototype.bar = function() {};", }, null, BAD_PROTECTED_PROPERTY_ACCESS); } public void testNoProtectedAccessForProperties5() { test(new String[] { "var goog = {};" + "/** @constructor */ goog.Foo = function() {};" + "/** @protected */ goog.Foo.prototype.bar = function() {};", "/** @constructor */" + "goog.NotASubFoo = function() { (new goog.Foo).bar(); };" }, null, BAD_PROTECTED_PROPERTY_ACCESS); } public void testNoExceptionsWithBadConstructors1() { testSame(new String[] { "function Foo() { (new SubFoo).bar(); } " + "/** @constructor */ function SubFoo() {}" + "/** @protected */ SubFoo.prototype.bar = function() {};" }); } public void testNoExceptionsWithBadConstructors2() { testSame(new String[] { "/** @constructor */ function Foo() {} " + "Foo.prototype.bar = function() {};" + "/** @constructor */" + "function SubFoo() {}" + "/** @protected */ " + "SubFoo.prototype.bar = function() { (new Foo).bar(); };" }); } public void testGoodOverrideOfProtectedProperty() { testSame(new String[] { "/** @constructor */ function Foo() { } " + "/** @protected */ Foo.prototype.bar = function() {};", "/** @constructor \n * @extends {Foo} */ " + "function SubFoo() {}" + "/** @inheritDoc */ SubFoo.prototype.bar = function() {};", }); } public void testBadOverrideOfProtectedProperty() { test(new String[] { "/** @constructor */ function Foo() { } " + "/** @protected */ Foo.prototype.bar = function() {};", "/** @constructor \n * @extends {Foo} */ " + "function SubFoo() {}" + "/** @private */ SubFoo.prototype.bar = function() {};", }, null, VISIBILITY_MISMATCH); } public void testBadOverrideOfPrivateProperty() { test(new String[] { "/** @constructor */ function Foo() { } " + "/** @private */ Foo.prototype.bar = function() {};", "/** @constructor \n * @extends {Foo} */ " + "function SubFoo() {}" + "/** @protected */ SubFoo.prototype.bar = function() {};", }, null, PRIVATE_OVERRIDE); testSame(new String[] { "/** @constructor */ function Foo() { } " + "/** @private */ Foo.prototype.bar = function() {};", "/** @constructor \n * @extends {Foo} */ " + "function SubFoo() {}" + "/** @override \n *@suppress{visibility} */\n" + " SubFoo.prototype.bar = function() {};", }); } public void testAccessOfStaticMethodOnPrivateConstructor() { testSame(new String[] { "/** @constructor \n * @private */ function Foo() { } " + "Foo.create = function() { return new Foo(); };", "Foo.create()", }); } public void testAccessOfStaticMethodOnPrivateQualifiedConstructor() { testSame(new String[] { "var goog = {};" + "/** @constructor \n * @private */ goog.Foo = function() { }; " + "goog.Foo.create = function() { return new goog.Foo(); };", "goog.Foo.create()", }); } public void testInstanceofOfPrivateConstructor() { testSame(new String[] { "var goog = {};" + "/** @constructor \n * @private */ goog.Foo = function() { }; " + "goog.Foo.create = function() { return new goog.Foo(); };", "goog instanceof goog.Foo", }); } public void testOkAssignmentOfDeprecatedProperty() { testSame( "/** @constructor */ function Foo() {" + " /** @deprecated */ this.bar = 3;" + "}"); } public void testBadReadOfDeprecatedProperty() { testDep( "/** @constructor */ function Foo() {" + " /** @deprecated %s */ this.bar = 3;" + " this.baz = this.bar;" + "}", "GRR", DEPRECATED_PROP, DEPRECATED_PROP_REASON); } public void testAutoboxedDeprecatedProperty() { test( "", // no externs "/** @constructor */ function String() {}" + "/** @deprecated %s */ String.prototype.length;" + "function f() { return 'x'.length; }", "GRR", DEPRECATED_PROP_REASON, null); } public void testAutoboxedPrivateProperty() { test( "/** @constructor */ function String() {}" + "/** @private */ String.prototype.length;", // externs "function f() { return 'x'.length; }", "", // output BAD_PRIVATE_PROPERTY_ACCESS, null); } public void testNullableDeprecatedProperty() { testDep( "/** @constructor */ function Foo() {}" + "/** @deprecated %s */ Foo.prototype.length;" + "/** @param {?Foo} x */ function f(x) { return x.length; }", "GRR", DEPRECATED_PROP, DEPRECATED_PROP_REASON); } public void testNullablePrivateProperty() { test(new String[] { "/** @constructor */ function Foo() {}" + "/** @private */ Foo.prototype.length;", "/** @param {?Foo} x */ function f(x) { return x.length; }" }, null, BAD_PRIVATE_PROPERTY_ACCESS); } public void testConstantProperty1() { test("/** @constructor */ function A() {" + "/** @const */ this.bar = 3;}" + "/** @constructor */ function B() {" + "/** @const */ this.bar = 3;this.bar += 4;}", null, CONST_PROPERTY_REASSIGNED_VALUE); } public void testConstantProperty2() { test("/** @constructor */ function Foo() {}" + "/** @const */ Foo.prototype.prop = 2;" + "var foo = new Foo();" + "foo.prop = 3;", null , CONST_PROPERTY_REASSIGNED_VALUE); } public void testConstantProperty3() { testSame("var o = { /** @const */ x: 1 };" + "o.x = 2;"); } public void testConstantProperty4() { test("/** @constructor */ function cat(name) {}" + "/** @const */ cat.test = 1;" + "cat.test *= 2;", null, CONST_PROPERTY_REASSIGNED_VALUE); } public void testConstantProperty5() { test("/** @constructor */ function Foo() { this.prop = 1;}" + "/** @const */ Foo.prototype.prop;" + "Foo.prototype.prop = 2", null , CONST_PROPERTY_REASSIGNED_VALUE); } public void testConstantProperty6() { test("/** @constructor */ function Foo() { this.prop = 1;}" + "/** @const */ Foo.prototype.prop = 2;", null , CONST_PROPERTY_REASSIGNED_VALUE); } public void testConstantProperty7() { testSame("/** @constructor */ function Foo() {} " + "Foo.prototype.bar_ = function() {};" + "/** @constructor \n * @extends {Foo} */ " + "function SubFoo() {};" + "/** @const */ /** @override */ SubFoo.prototype.bar_ = function() {};" + "SubFoo.prototype.baz = function() { this.bar_(); }"); } public void testConstantProperty8() { testSame("var o = { /** @const */ x: 1 };" + "var y = o.x;"); } public void testConstantProperty9() { testSame("/** @constructor */ function A() {" + "/** @const */ this.bar = 3;}" + "/** @constructor */ function B() {" + "this.bar = 4;}"); } public void testConstantProperty10() { testSame("/** @constructor */ function Foo() { this.prop = 1;}" + "/** @const */ Foo.prototype.prop;"); } public void testConstantProperty11() { test("/** @constructor */ function Foo() {}" + "/** @const */ Foo.prototype.bar;" + "/**\n" + " * @constructor\n" + " * @extends {Foo}\n" + " */ function SubFoo() { this.bar = 5; this.bar = 6; }", null , CONST_PROPERTY_REASSIGNED_VALUE); } public void testConstantProperty12() { testSame("/** @constructor */ function Foo() {}" + "/** @const */ Foo.prototype.bar;" + "/**\n" + " * @constructor\n" + " * @extends {Foo}\n" + " */ function SubFoo() { this.bar = 5; }" + "/**\n" + " * @constructor\n" + " * @extends {Foo}\n" + " */ function SubFoo2() { this.bar = 5; }"); } public void testConstantProperty13() { test("/** @constructor */ function Foo() {}" + "/** @const */ Foo.prototype.bar;" + "/**\n" + " * @constructor\n" + " * @extends {Foo}\n" + " */ function SubFoo() { this.bar = 5; }" + "/**\n" + " * @constructor\n" + " * @extends {SubFoo}\n" + " */ function SubSubFoo() { this.bar = 5; }", null , CONST_PROPERTY_REASSIGNED_VALUE); } public void testConstantProperty14() { test("/** @constructor */ function Foo() {" + "/** @const */ this.bar = 3; delete this.bar; }", null, CONST_PROPERTY_DELETED); } public void testSuppressConstantProperty() { testSame("/** @constructor */ function A() {" + "/** @const */ this.bar = 3;}" + "/**\n" + " * @suppress {constantProperty}\n" + " * @constructor\n" + " */ function B() {" + "/** @const */ this.bar = 3;this.bar += 4;}"); } public void testSuppressConstantProperty2() { testSame("/** @constructor */ function A() {" + "/** @const */ this.bar = 3;}" + "/**\n" + " * @suppress {const}\n" + " * @constructor\n" + " */ function B() {" + "/** @const */ this.bar = 3;this.bar += 4;}"); } public void testFinalClassCannotBeSubclassed() { test( "/**\n" + " * @constructor\n" + " * @const\n" + " */ Foo = function() {};\n" + "/**\n" + " * @constructor\n" + " * @extends {Foo}\n*" + " */ Bar = function() {};", null, EXTEND_FINAL_CLASS); test( "/**\n" + " * @constructor\n" + " * @const\n" + " */ function Foo() {};\n" + "/**\n" + " * @constructor\n" + " * @extends {Foo}\n*" + " */ function Bar() {};", null, EXTEND_FINAL_CLASS); } }
/* * Copyright 2011 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.jscomp.CheckLevel; import com.google.javascript.jscomp.CompilerOptions; import com.google.javascript.jscomp.DiagnosticGroups; /** * {@link CheckDebuggerStatementTest} is a unit test for * {@link CheckDebuggerStatement}. * * @author bolinfest@google.com (Michael Bolin) */ public class CheckDebuggerStatementTest extends CompilerTestCase { private CheckLevel checkLevel; @Override public void tearDown() { checkLevel = null; } @Override protected CompilerPass getProcessor(Compiler compiler) { return new CheckDebuggerStatement(compiler); } @Override protected CompilerOptions getOptions() { CompilerOptions options = super.getOptions(); if (checkLevel != null) { options.setWarningLevel( DiagnosticGroups.DEBUGGER_STATEMENT_PRESENT, checkLevel); } return options; } public void testCheckDebuggerStatement() { checkLevel = CheckLevel.WARNING; testSame("debugger;", CheckDebuggerStatement.DEBUGGER_STATEMENT_PRESENT); testSame("function foo() { debugger; }", CheckDebuggerStatement.DEBUGGER_STATEMENT_PRESENT); } public void testCheckIsDisabledByDefault() { checkLevel = null; testSame("debugger;"); testSame("function foo() { debugger; }"); } public void testNoWarningWhenExplicitlyDisabled() { checkLevel = CheckLevel.OFF; testSame("debugger;"); testSame("function foo() { debugger; }"); } public void testCheckDebuggerKeywordMayAppearInComments() { checkLevel = CheckLevel.WARNING; test("// I like the debugger; it is helpful.", ""); } public void testCheckDebuggerStatementInEval() { checkLevel = CheckLevel.WARNING; testSame("eval('debugger');"); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import static com.google.javascript.jscomp.CheckGlobalNames.NAME_DEFINED_LATE_WARNING; import static com.google.javascript.jscomp.CheckGlobalNames.UNDEFINED_NAME_WARNING; import static com.google.javascript.jscomp.CheckGlobalNames.STRICT_MODULE_DEP_QNAME; import com.google.javascript.rhino.Node; /** * Tests for {@code CheckGlobalNames.java}. * * @author nicksantos@google.com (Nick Santos) */ public class CheckGlobalNamesTest extends CompilerTestCase { private boolean injectNamespace = false; public CheckGlobalNamesTest() { super("function alert() {}" + "/** @constructor */ function Object(){}" + "Object.prototype.hasOwnProperty = function() {};" + "/** @constructor */ function Function(){}" + "Function.prototype.call = function() {};"); } @Override protected CompilerPass getProcessor(final Compiler compiler) { final CheckGlobalNames checkGlobalNames = new CheckGlobalNames( compiler, CheckLevel.WARNING); if (injectNamespace) { return new CompilerPass() { @Override public void process(Node externs, Node js) { checkGlobalNames.injectNamespace( new GlobalNamespace(compiler, externs, js)) .process(externs, js); } }; } else { return checkGlobalNames; } } @Override public void setUp() { injectNamespace = false; STRICT_MODULE_DEP_QNAME.level = CheckLevel.WARNING; } private static final String GET_NAMES = "var a = {get d() {return 1}}; a.b = 3; a.c = {get e() {return 5}};"; private static final String SET_NAMES = "var a = {set d(x) {}}; a.b = 3; a.c = {set e(y) {}};"; private static final String NAMES = "var a = {d: 1}; a.b = 3; a.c = {e: 5};"; public void testRefToDefinedProperties1() { testSame(NAMES + "alert(a.b); alert(a.c.e);"); testSame(GET_NAMES + "alert(a.b); alert(a.c.e);"); testSame(SET_NAMES + "alert(a.b); alert(a.c.e);"); } public void testRefToDefinedProperties2() { testSame(NAMES + "a.x={}; alert(a.c);"); testSame(GET_NAMES + "a.x={}; alert(a.c);"); testSame(SET_NAMES + "a.x={}; alert(a.c);"); } public void testRefToDefinedProperties3() { testSame(NAMES + "alert(a.d);"); testSame(GET_NAMES + "alert(a.d);"); testSame(SET_NAMES + "alert(a.d);"); } public void testRefToMethod1() { testSame("function foo() {}; foo.call();"); } public void testRefToMethod2() { testSame("function foo() {}; foo.call.call();"); } public void testCallUndefinedFunctionGivesNoWaring() { // We don't bother checking undeclared variables--there's another // pass that does this already. testSame("foo();"); } public void testRefToPropertyOfAliasedName() { // this is OK, because "a" was aliased testSame(NAMES + "alert(a); alert(a.x);"); } public void testRefToUndefinedProperty1() { testSame(NAMES + "alert(a.x);", UNDEFINED_NAME_WARNING); } public void testRefToUndefinedProperty2() { testSame(NAMES + "a.x();", UNDEFINED_NAME_WARNING); } public void testRefToUndefinedProperty3() { testSame(NAMES + "alert(a.c.x);", UNDEFINED_NAME_WARNING); testSame(GET_NAMES + "alert(a.c.x);", UNDEFINED_NAME_WARNING); testSame(SET_NAMES + "alert(a.c.x);", UNDEFINED_NAME_WARNING); } public void testRefToUndefinedProperty4() { testSame(NAMES + "alert(a.d.x);"); testSame(GET_NAMES + "alert(a.d.x);"); testSame(SET_NAMES + "alert(a.d.x);"); } public void testRefToDescendantOfUndefinedProperty1() { testSame(NAMES + "var c = a.x.b;", UNDEFINED_NAME_WARNING); } public void testRefToDescendantOfUndefinedProperty2() { testSame(NAMES + "a.x.b();", UNDEFINED_NAME_WARNING); } public void testRefToDescendantOfUndefinedProperty3() { testSame(NAMES + "a.x.b = 3;", UNDEFINED_NAME_WARNING); } public void testUndefinedPrototypeMethodRefGivesNoWarning() { testSame("function Foo() {} var a = new Foo(); a.bar();"); } public void testComplexPropAssignGivesNoWarning() { testSame("var a = {}; var b = a.b = 3;"); } public void testTypedefGivesNoWarning() { testSame("var a = {}; /** @typedef {number} */ a.b;"); } public void testRefToDescendantOfUndefinedPropertyGivesCorrectWarning() { testSame("", NAMES + "a.x.b = 3;", UNDEFINED_NAME_WARNING, UNDEFINED_NAME_WARNING.format("a.x")); } public void testNamespaceInjection() { injectNamespace = true; testSame(NAMES + "var c = a.x.b;", UNDEFINED_NAME_WARNING); } public void testSuppressionOfUndefinedNamesWarning() { testSame(new String[] { NAMES + "/** @constructor */ function Foo() { };" + "/** @suppress {undefinedNames} */" + "Foo.prototype.bar = function() {" + " alert(a.x);" + " alert(a.x.b());" + " a.x();" + " var c = a.x.b;" + " var c = a.x.b();" + " a.x.b();" + " a.x.b = 3;" + "};", }); } public void testNoWarningForSimpleVarModuleDep1() { testSame(createModuleChain( NAMES, "var c = a;" )); } public void testNoWarningForSimpleVarModuleDep2() { testSame(createModuleChain( "var c = a;", NAMES )); } public void testNoWarningForGoodModuleDep1() { testSame(createModuleChain( NAMES, "var c = a.b;" )); } public void testBadModuleDep1() { testSame(createModuleChain( "var c = a.b;", NAMES ), STRICT_MODULE_DEP_QNAME); } public void testBadModuleDep2() { testSame(createModuleStar( NAMES, "a.xxx = 3;", "var x = a.xxx;" ), STRICT_MODULE_DEP_QNAME); } public void testSelfModuleDep() { testSame(createModuleChain( NAMES + "var c = a.b;" )); } public void testUndefinedModuleDep1() { testSame(createModuleChain( "var c = a.xxx;", NAMES ), UNDEFINED_NAME_WARNING); } public void testLateDefinedName1() { testSame("x.y = {}; var x = {};", NAME_DEFINED_LATE_WARNING); } public void testLateDefinedName2() { testSame("var x = {}; x.y.z = {}; x.y = {};", NAME_DEFINED_LATE_WARNING); } public void testLateDefinedName3() { testSame("var x = {}; x.y.z = {}; x.y = {z: {}};", NAME_DEFINED_LATE_WARNING); } public void testLateDefinedName4() { testSame("var x = {}; x.y.z.bar = {}; x.y = {z: {}};", NAME_DEFINED_LATE_WARNING); } public void testLateDefinedName5() { testSame("var x = {}; /** @typedef {number} */ x.y.z; x.y = {};", NAME_DEFINED_LATE_WARNING); } public void testLateDefinedName6() { testSame( "var x = {}; x.y.prototype.z = 3;" + "/** @constructor */ x.y = function() {};", NAME_DEFINED_LATE_WARNING); } public void testOkLateDefinedName1() { testSame("function f() { x.y = {}; } var x = {};"); } public void testOkLateDefinedName2() { testSame("var x = {}; function f() { x.y.z = {}; } x.y = {};"); } public void testPathologicalCaseThatsOkAnyway() { testSame( "var x = {};" + "switch (x) { " + " default: x.y.z = {}; " + " case (x.y = {}): break;" + "}", NAME_DEFINED_LATE_WARNING); } public void testOkGlobalDeclExpr() { testSame("var x = {}; /** @type {string} */ x.foo;"); } public void testBadInterfacePropRef() { testSame( "/** @interface */ function F() {}" + "F.bar();", UNDEFINED_NAME_WARNING); } public void testInterfaceFunctionPropRef() { testSame( "/** @interface */ function F() {}" + "F.call(); F.hasOwnProperty('z');"); } public void testObjectPrototypeProperties() { testSame("var x = {}; var y = x.hasOwnProperty('z');"); } public void testCustomObjectPrototypeProperties() { testSame("Object.prototype.seal = function() {};" + "var x = {}; x.seal();"); } public void testFunctionPrototypeProperties() { testSame("var x = {}; var y = x.hasOwnProperty('z');"); } public void testIndirectlyDeclaredProperties() { testSame( "Function.prototype.inherits = function(ctor) {" + " this.superClass_ = ctor;" + "};" + "/** @constructor */ function Foo() {}" + "Foo.prototype.bar = function() {};" + "/** @constructor */ function SubFoo() {}" + "SubFoo.inherits(Foo);" + "SubFoo.superClass_.bar();"); } public void testGoogInheritsAlias() { testSame( "Function.prototype.inherits = function(ctor) {" + " this.superClass_ = ctor;" + "};" + "/** @constructor */ function Foo() {}" + "Foo.prototype.bar = function() {};" + "/** @constructor */ function SubFoo() {}" + "SubFoo.inherits(Foo);" + "SubFoo.superClass_.bar();"); } public void testGoogInheritsAlias2() { testSame( CompilerTypeTestCase.CLOSURE_DEFS + "/** @constructor */ function Foo() {}" + "Foo.prototype.bar = function() {};" + "/** @constructor */ function SubFoo() {}" + "goog.inherits(SubFoo, Foo);" + "SubFoo.superClazz();", UNDEFINED_NAME_WARNING); } }
/* * Copyright 2007 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Tests {@link CheckGlobalThis}. */ public class CheckGlobalThisTest extends CompilerTestCase { public CheckGlobalThisTest() { this.parseTypeInfo = true; } @Override protected CompilerPass getProcessor(Compiler compiler) { return new CombinedCompilerPass( compiler, new CheckGlobalThis(compiler)); } private void testFailure(String js) { testSame(js, CheckGlobalThis.GLOBAL_THIS); } public void testGlobalThis1() throws Exception { testSame("var a = this;"); } public void testGlobalThis2() { testFailure("this.foo = 5;"); } public void testGlobalThis3() { testFailure("this[foo] = 5;"); } public void testGlobalThis4() { testFailure("this['foo'] = 5;"); } public void testGlobalThis5() { testFailure("(a = this).foo = 4;"); } public void testGlobalThis6() { testSame("a = this;"); } public void testGlobalThis7() { testFailure("var a = this.foo;"); } public void testStaticFunction1() { testSame("function a() { return this; }"); } public void testStaticFunction2() { testFailure("function a() { this.complex = 5; }"); } public void testStaticFunction3() { testSame("var a = function() { return this; }"); } public void testStaticFunction4() { testFailure("var a = function() { this.foo.bar = 6; }"); } public void testStaticFunction5() { testSame("function a() { return function() { return this; } }"); } public void testStaticFunction6() { testSame("function a() { return function() { this.x = 8; } }"); } public void testStaticFunction7() { testSame("var a = function() { return function() { this.x = 8; } }"); } public void testStaticFunction8() { testFailure("var a = function() { return this.foo; };"); } public void testConstructor1() { testSame("/** @constructor */function A() { this.m2 = 5; }"); } public void testConstructor2() { testSame("/** @constructor */var A = function() { this.m2 = 5; }"); } public void testConstructor3() { testSame("/** @constructor */a.A = function() { this.m2 = 5; }"); } public void testInterface1() { testSame( "/** @interface */function A() { /** @type {string} */ this.m2; }"); } public void testOverride1() { testSame("/** @constructor */function A() { } var a = new A();" + "/** @override */ a.foo = function() { this.bar = 5; };"); } public void testThisJSDoc1() throws Exception { testSame("/** @this whatever */function h() { this.foo = 56; }"); } public void testThisJSDoc2() throws Exception { testSame("/** @this whatever */var h = function() { this.foo = 56; }"); } public void testThisJSDoc3() throws Exception { testSame("/** @this whatever */foo.bar = function() { this.foo = 56; }"); } public void testThisJSDoc4() throws Exception { testSame("/** @this whatever */function f() { this.foo = 56; }"); } public void testThisJSDoc5() throws Exception { testSame("function a() { /** @this x */function f() { this.foo = 56; } }"); } public void testMethod1() { testSame("A.prototype.m1 = function() { this.m2 = 5; }"); } public void testMethod2() { testSame("a.B.prototype.m1 = function() { this.m2 = 5; }"); } public void testMethod3() { testSame("a.b.c.D.prototype.m1 = function() { this.m2 = 5; }"); } public void testMethod4() { testSame("a.prototype['x' + 'y'] = function() { this.foo = 3; };"); } public void testPropertyOfMethod() { testFailure("a.protoype.b = {}; " + "a.prototype.b.c = function() { this.foo = 3; };"); } public void testStaticMethod1() { testFailure("a.b = function() { this.m2 = 5; }"); } public void testStaticMethod2() { testSame("a.b = function() { return function() { this.m2 = 5; } }"); } public void testStaticMethod3() { testSame("a.b.c = function() { return function() { this.m2 = 5; } }"); } public void testMethodInStaticFunction() { testSame("function f() { A.prototype.m1 = function() { this.m2 = 5; } }"); } public void testStaticFunctionInMethod1() { testSame("A.prototype.m1 = function() { function me() { this.m2 = 5; } }"); } public void testStaticFunctionInMethod2() { testSame("A.prototype.m1 = function() {" + " function me() {" + " function myself() {" + " function andI() { this.m2 = 5; } } } }"); } public void testInnerFunction1() { testFailure("function f() { function g() { return this.x; } }"); } public void testInnerFunction2() { testFailure("function f() { var g = function() { return this.x; } }"); } public void testInnerFunction3() { testFailure( "function f() { var x = {}; x.y = function() { return this.x; } }"); } public void testInnerFunction4() { testSame( "function f() { var x = {}; x.y(function() { return this.x; }); }"); } public void testIssue182a() { testFailure("var NS = {read: function() { return this.foo; }};"); } public void testIssue182b() { testFailure("var NS = {write: function() { this.foo = 3; }};"); } public void testIssue182c() { testFailure("var NS = {}; NS.write2 = function() { this.foo = 3; };"); } public void testIssue182d() { testSame("function Foo() {} " + "Foo.prototype = {write: function() { this.foo = 3; }};"); } public void testLendsAnnotation1() { testFailure("/** @constructor */ function F() {}" + "dojo.declare(F, {foo: function() { return this.foo; }});"); } public void testLendsAnnotation2() { testFailure("/** @constructor */ function F() {}" + "dojo.declare(F, /** @lends {F.bar} */ (" + " {foo: function() { return this.foo; }}));"); } public void testLendsAnnotation3() { testSame("/** @constructor */ function F() {}" + "dojo.declare(F, /** @lends {F.prototype} */ (" + " {foo: function() { return this.foo; }}));"); } public void testSuppressWarning() { testFailure("var x = function() { this.complex = 5; };"); testSame("/** @suppress {globalThis} */" + "var x = function() { this.complex = 5; };"); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * @author mkretzschmar@google.com (Martin Kretzschmar) */ public class CheckMissingGetCssNameTest extends CompilerTestCase { @Override protected CompilerPass getProcessor(final Compiler compiler) { return new CombinedCompilerPass( compiler, new CheckMissingGetCssName(compiler, CheckLevel.ERROR, "goog-[a-z-]*")); } public void testMissingGetCssName() { testMissing("var s = 'goog-inline-block'"); testMissing("var s = 'CSS_FOO goog-menu'"); testMissing("alert('goog-inline-block ' + goog.getClassName('CSS_FOO'))"); testMissing("html = '<div class=\"goog-special-thing\">Hello</div>'"); } public void testRecognizeGetCssName() { testNotMissing("var s = goog.getCssName('goog-inline-block')"); } public void testIgnoreGetUniqueIdArguments() { testNotMissing("var s = goog.events.getUniqueId('goog-some-event')"); testNotMissing("var s = joe.random.getUniqueId('joe-is-a-goob')"); } public void testIgnoreAssignmentsToIdConstant() { testNotMissing("SOME_ID = 'goog-some-id'"); testNotMissing("SOME_PRIVATE_ID_ = 'goog-some-id'"); testNotMissing("var SOME_ID_ = 'goog-some-id'"); } public void testNotMissingGetCssName() { testNotMissing("s = 'not-a-css-name'"); testNotMissing("s = 'notagoog-css-name'"); } public void testDontCrashIfTheresNoQualifiedName() { testMissing("things[2].DONT_CARE_ABOUT_THIS_KIND_OF_ID = " + "'goog-inline-block'"); testMissing("objects[3].doSomething('goog-inline-block')"); } private void testMissing(String js) { test(js, js, CheckMissingGetCssName.MISSING_GETCSSNAME); } private void testNotMissing(String js) { test(js, js); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.jscomp.CheckLevel; /** * Tests for {@link CheckMissingReturn}. * */ public class CheckMissingReturnTest extends CompilerTestCase { public CheckMissingReturnTest() { enableTypeCheck(CheckLevel.OFF); } @Override protected CompilerPass getProcessor(final Compiler compiler) { return new CombinedCompilerPass(compiler, new CheckMissingReturn(compiler, CheckLevel.ERROR)); } public void testMissingReturn() { // Requires control flow analysis. testMissing("if (a) { return 1; }"); // Switch statement. testMissing("switch(1) { case 12: return 5; }"); // Test try catch finally. testMissing("try { foo() } catch (e) { return 5; } finally { }"); // Nested scope. testMissing("/** @return {number} */ function f() { var x; }; return 1;"); testMissing("/** @return {number} */ function f() { return 1; };"); } public void testReturnNotMissing() { // Empty function body. Ignore this case. The remainder of the functions in // this test have non-empty bodies. testNotMissing(""); // Simple cases. testSame("function f() { var x; }"); testNotMissing("return 1;"); // Returning void and undefined. testNotMissing("void", "var x;"); testNotMissing("undefined", "var x;"); // Returning a union that includes void or undefined. testNotMissing("number|undefined", "var x;"); testNotMissing("number|void", "var x;"); testNotMissing("(number,void)", "var x;"); testNotMissing("(number,undefined)", "var x;"); testNotMissing("*", "var x;"); // Test try catch finally. testNotMissing("try { return foo() } catch (e) { } finally { }"); // Nested function. testNotMissing( "/** @return {number} */ function f() { return 1; }; return 1;"); // Strange tests that come up when reviewing closure code. testNotMissing("try { return 12; } finally { return 62; }"); testNotMissing("try { } finally { return 1; }"); testNotMissing("switch(1) { default: return 1; }"); testNotMissing("switch(g) { case 1: return 1; default: return 2; }"); } public void testFinallyStatements() { // The control flow analysis (CFA) treats finally blocks somewhat strangely. // The CFA might indicate that a finally block implicitly returns. However, // if entry into the finally block is normally caused by an explicit return // statement, then a return statement isn't missing: // // try { // return 1; // } finally { // // CFA determines implicit return. However, return not missing // // because of return statement in try block. // } // // Hence extra tests are warranted for various cases involving finally // blocks. // Simple finally case. testNotMissing("try { return 1; } finally { }"); testNotMissing("try { } finally { return 1; }"); testMissing("try { } finally { }"); // Cycles in the CFG within the finally block were causing problems before. testNotMissing("try { return 1; } finally { while (true) { } }"); testMissing("try { } finally { while (x) { } }"); testMissing("try { } finally { while (x) { if (x) { break; } } }"); testNotMissing( "try { return 2; } finally { while (x) { if (x) { break; } } }"); // Test various cases with nested try statements. testMissing("try { } finally { try { } finally { } }"); testNotMissing("try { } finally { try { return 1; } finally { } }"); testNotMissing("try { return 1; } finally { try { } finally { } }"); // Calling a function potentially causes control flow to transfer to finally // block. However, the function will not return in this case as the // exception will unwind the stack. Hence this function isn't missing a // return statement (i.e., the running program will not expect a return // value from the function if an exception is thrown). testNotMissing("try { g(); return 1; } finally { }"); // Closures within try ... finally affect missing return statement analysis // because of the nested scopes. The following tests check for missing // return statements in the three possible configurations: both scopes // return; enclosed doesn't return; enclosing doesn't return. testNotMissing( "try {" + " /** @return {number} */ function f() {" + " try { return 1; }" + " finally { }" + " };" + " return 1;" + "}" + "finally { }"); testMissing( "try {" + " /** @return {number} */ function f() {" + " try { }" + " finally { }" + " };" + " return 1;" + "}" + "finally { }"); testMissing( "try {" + " /** @return {number} */ function f() {" + " try { return 1; }" + " finally { }" + " };" + "}" + "finally { }"); } public void testKnownConditions() { testNotMissing("if (true) return 1"); testMissing("if (true) {} else {return 1}"); testMissing("if (false) return 1"); testNotMissing("if (false) {} else {return 1}"); testNotMissing("if (1) return 1"); testMissing("if (1) {} else {return 1}"); testMissing("if (0) return 1"); testNotMissing("if (0) {} else {return 1}"); testNotMissing("if (3) return 1"); testMissing("if (3) {} else {return 1}"); } public void testKnownWhileLoop() { testNotMissing("while (1) return 1"); testNotMissing("while (1) { if (x) {return 1} else {return 1}}"); testNotMissing("while (0) {} return 1"); // TODO(user): The current algorithm will not detect this case. It is // still computable in most cases. testNotMissing("while (1) {} return 0"); testMissing("while (false) return 1"); // Not known. testMissing("while(x) { return 1 }"); } public void testMultiConditions() { testMissing("if (a) { } else { while (1) {return 1} }"); testNotMissing("if (a) { return 1} else { while (1) {return 1} }"); } public void testIssue779() { testNotMissing( "var a = f(); try { alert(); if (a > 0) return 1; }" + "finally { a = 5; } return 2;"); } private static String createFunction(String returnType, String body) { return "/** @return {" + returnType + "} */ function foo() {" + body + "}"; } private void testMissing(String returnType, String body) { String js = createFunction(returnType, body); test(js, js, CheckMissingReturn.MISSING_RETURN_STATEMENT); } private void testNotMissing(String returnType, String body) { testSame(createFunction(returnType, body)); } /** Creates function with return type {number} */ private void testNotMissing(String body) { testNotMissing("number", body); } /** Creates function with return type {number} */ private void testMissing(String body) { testMissing("number", body); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.base.Predicate; import com.google.common.base.Predicates; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.DiGraph; import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge; import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode; import junit.framework.TestCase; /** * Tests for {@link CheckPathsBetweenNodes}. * */ public class CheckPathsBetweenNodesTest extends TestCase { /** * Predicate satisfied by strings with a given prefix. */ private static class PrefixPredicate implements Predicate<String> { String prefix; PrefixPredicate(String prefix) { this.prefix = prefix; } @Override public boolean apply(String input) { return input.startsWith(prefix); } } private static final Predicate<String> FALSE = Predicates.alwaysFalse(); private static final Predicate<DiGraphEdge<String, String>> ALL_EDGE = Predicates.alwaysTrue(); private static final Predicate<DiGraphEdge<String, String>> NO_EDGE = Predicates.alwaysFalse(); /** Tests straight-line graphs. */ public void testSimple() { DiGraph<String, String> g = LinkedDirectedGraph.create(); g.createDirectedGraphNode("a"); g.createDirectedGraphNode("b"); g.createDirectedGraphNode("c"); g.createDirectedGraphNode("d"); g.connect("a", "-", "b"); g.connect("b", "-", "c"); g.connect("c", "-", "d"); g.connect("a", "x", "d"); CheckPathsBetweenNodes<String, String> test = null; // Simple case: the sole path from a to d has a matching node. assertGood(createTest(g, "a", "d", Predicates.equalTo("b"), edgeIs("-"))); //Test two edge cases where satisfying node is the first and last node on // the path. assertGood(createTest(g, "a", "d", Predicates.equalTo("a"), edgeIs("-"))); assertGood(createTest(g, "a", "d", Predicates.equalTo("d"), edgeIs("-"))); // Traverse no edges, so no paths. assertGood(createTest(g, "a", "d", FALSE, NO_EDGE)); // No path with matching edges contains b. assertBad(createTest(g, "a", "d", Predicates.equalTo("b"), edgeIs("x"))); } /** * Tests a graph where some paths between the nodes are valid and others * are invalid. */ public void testSomeValidPaths() { DiGraph<String, String> g = LinkedDirectedGraph.create(); g.createDirectedGraphNode("a"); g.createDirectedGraphNode("b"); g.createDirectedGraphNode("c"); g.createDirectedGraphNode("d"); g.createDirectedGraphNode("e"); g.connect("a", "1", "b"); g.connect("b", "2", "c"); g.connect("b", "3", "e"); g.connect("e", "4", "d"); g.connect("c", "5", "d"); assertBad(createTest(g, "a", "d", Predicates.equalTo("c"), ALL_EDGE)); assertBad(createTest(g, "a", "d", Predicates.equalTo("z"), ALL_EDGE)); } /** Tests a graph with many valid paths. */ public void testManyValidPaths() { DiGraph<String, String> g = LinkedDirectedGraph.create(); g.createDirectedGraphNode("a"); g.createDirectedGraphNode("b"); g.createDirectedGraphNode("c1"); g.createDirectedGraphNode("c2"); g.createDirectedGraphNode("c3"); DiGraphNode<String, String> d = g.createDirectedGraphNode("d"); g.connect("a", "-", "b"); g.connect("b", "-", "c1"); g.connect("b", "-", "c2"); g.connect("c2", "-", "d"); g.connect("c1", "-", "d"); g.connect("a", "-", "c3"); g.connect("c3", "-", "d"); assertGood(createTest(g, "a", "d", new PrefixPredicate("c"), ALL_EDGE)); } /** Tests a graph with some cycles. */ public void testCycles1() { DiGraph<String, String> g = LinkedDirectedGraph.create(); g.createDirectedGraphNode("a"); g.createDirectedGraphNode("b"); g.createDirectedGraphNode("c"); g.createDirectedGraphNode("d"); g.createDirectedGraphNode("e"); g.createDirectedGraphNode("f"); g.connect("a", "-", "b"); g.connect("b", "-", "c"); g.connect("c", "-", "d"); g.connect("d", "-", "e"); g.connect("e", "-", "f"); g.connect("f", "-", "b"); assertGood(createTest(g, "a", "e", Predicates.equalTo("b"), ALL_EDGE)); assertGood(createTest(g, "a", "e", Predicates.equalTo("c"), ALL_EDGE)); assertGood(createTest(g, "a", "e", Predicates.equalTo("d"), ALL_EDGE)); assertGood(createTest(g, "a", "e", Predicates.equalTo("e"), ALL_EDGE)); assertBad(createTest(g, "a", "e", Predicates.equalTo("f"), ALL_EDGE)); } /** * Tests another graph with cycles. The topology of this graph was inspired * by a control flow graph that was being incorrectly analyzed by an early * version of CheckPathsBetweenNodes. */ public void testCycles2() { DiGraph<String, String> g = LinkedDirectedGraph.create(); g.createDirectedGraphNode("a"); g.createDirectedGraphNode("b"); g.createDirectedGraphNode("c"); g.createDirectedGraphNode("d"); g.connect("a", "-", "b"); g.connect("b", "-", "c"); g.connect("c", "-", "b"); g.connect("b", "-", "d"); assertGood(createTest(g, "a", "d", Predicates.equalTo("a"), ALL_EDGE)); assertBad(createTest(g, "a", "d", Predicates.equalTo("z"), ALL_EDGE)); } /** * Tests another graph with cycles. The topology of this graph was inspired * by a control flow graph that was being incorrectly analyzed by an early * version of CheckPathsBetweenNodes. */ public void testCycles3() { DiGraph<String, String> g = LinkedDirectedGraph.create(); g.createDirectedGraphNode("a"); g.createDirectedGraphNode("b"); g.createDirectedGraphNode("c"); g.createDirectedGraphNode("d"); g.connect("a", "-", "b"); g.connect("b", "-", "c"); g.connect("c", "-", "b"); g.connect("b", "-", "d"); g.connect("c", "-", "d"); assertGood(createTest(g, "a", "d", Predicates.equalTo("a"), ALL_EDGE)); assertBad(createTest(g, "a", "d", Predicates.equalTo("z"), ALL_EDGE)); } /** * Much of the tests are done by testing all paths. We quickly verified * that some paths are indeed correct for the some path case. */ public void testSomePath1() { DiGraph<String, String> g = LinkedDirectedGraph.create(); g.createDirectedGraphNode("a"); g.createDirectedGraphNode("b"); g.createDirectedGraphNode("c"); g.createDirectedGraphNode("d"); g.connect("a", "-", "b"); g.connect("a", "-", "c"); g.connect("b", "-", "d"); g.connect("c", "-", "d"); assertTrue(createTest(g, "a", "d", Predicates.equalTo("b"), ALL_EDGE) .somePathsSatisfyPredicate()); assertTrue(createTest(g, "a", "d", Predicates.equalTo("c"), ALL_EDGE) .somePathsSatisfyPredicate()); assertTrue(createTest(g, "a", "d", Predicates.equalTo("a"), ALL_EDGE) .somePathsSatisfyPredicate()); assertTrue(createTest(g, "a", "d", Predicates.equalTo("d"), ALL_EDGE) .somePathsSatisfyPredicate()); assertFalse(createTest(g, "a", "d", Predicates.equalTo("NONE"), ALL_EDGE) .somePathsSatisfyPredicate()); } public void testSomePath2() { // No Paths between nodes, by definition, always false. DiGraph<String, String> g = LinkedDirectedGraph.create(); g.createDirectedGraphNode("a"); g.createDirectedGraphNode("b"); assertFalse(createTest(g, "a", "b", Predicates.equalTo("b"), ALL_EDGE) .somePathsSatisfyPredicate()); assertFalse(createTest(g, "a", "b", Predicates.equalTo("d"), ALL_EDGE) .somePathsSatisfyPredicate()); assertTrue(createTest(g, "a", "b", Predicates.equalTo("a"), ALL_EDGE) .somePathsSatisfyPredicate()); } public void testSomePathRevisiting() { DiGraph<String, String> g = LinkedDirectedGraph.create(); g.createDirectedGraphNode("1"); g.createDirectedGraphNode("2a"); g.createDirectedGraphNode("2b"); g.createDirectedGraphNode("3"); g.createDirectedGraphNode("4a"); g.createDirectedGraphNode("4b"); g.createDirectedGraphNode("5"); g.connect("1", "-", "2a"); g.connect("1", "-", "2b"); g.connect("2a", "-", "3"); g.connect("2b", "-", "3"); g.connect("3", "-", "4a"); g.connect("3", "-", "4b"); g.connect("4a", "-", "5"); g.connect("4b", "-", "5"); CountingPredicate<String> p = new CountingPredicate<String>(Predicates.equalTo("4a")); assertTrue(createTest(g, "1", "5", p, ALL_EDGE) .somePathsSatisfyPredicate()); // Make sure we are not doing more traversals than we have to. assertEquals(4, p.count); } public void testNonInclusive() { // No Paths between nodes, by definition, always false. DiGraph<String, String> g = LinkedDirectedGraph.create(); g.createDirectedGraphNode("a"); g.createDirectedGraphNode("b"); g.createDirectedGraphNode("c"); g.connect("a", "-", "b"); g.connect("b", "-", "c"); assertFalse(createNonInclusiveTest(g, "a", "b", Predicates.equalTo("a"), ALL_EDGE).somePathsSatisfyPredicate()); assertFalse(createNonInclusiveTest(g, "a", "b", Predicates.equalTo("b"), ALL_EDGE).somePathsSatisfyPredicate()); assertTrue(createNonInclusiveTest(g, "a", "c", Predicates.equalTo("b"), ALL_EDGE).somePathsSatisfyPredicate()); } private static <N, E> void assertGood(CheckPathsBetweenNodes<N, E> test) { assertTrue(test.allPathsSatisfyPredicate()); } private static <N, E> void assertBad(CheckPathsBetweenNodes<N, E> test) { assertFalse(test.allPathsSatisfyPredicate()); } private static CheckPathsBetweenNodes<String, String> createTest( DiGraph<String, String> graph, String entry, String exit, Predicate<String> nodePredicate, Predicate<DiGraphEdge<String, String>> edgePredicate) { return new CheckPathsBetweenNodes<String, String>(graph, graph.getDirectedGraphNode(entry), graph.getDirectedGraphNode(exit), nodePredicate, edgePredicate); } private static CheckPathsBetweenNodes<String, String> createNonInclusiveTest( DiGraph<String, String> graph, String entry, String exit, Predicate<String> nodePredicate, Predicate<DiGraphEdge<String, String>> edgePredicate) { return new CheckPathsBetweenNodes<String, String>(graph, graph.getDirectedGraphNode(entry), graph.getDirectedGraphNode(exit), nodePredicate, edgePredicate, false); } private static Predicate<DiGraphEdge<String, String>> edgeIs(final Object val) { return new Predicate<DiGraphEdge<String, String>>() { @Override public boolean apply(DiGraphEdge<String, String> input) { return input.getValue().equals(val); } }; } private static class CountingPredicate<T> implements Predicate<T> { private int count = 0; private final Predicate<T> delegate; private CountingPredicate(Predicate<T> delegate) { this.delegate = delegate; } @Override public boolean apply(T input) { count ++; return delegate.apply(input); } } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import static com.google.javascript.jscomp.CheckProvides.MISSING_PROVIDE_WARNING; import com.google.javascript.jscomp.CheckLevel; /** * Tests for {@link CheckProvides}. * */ public class CheckProvidesTest extends CompilerTestCase { @Override protected CompilerPass getProcessor(Compiler compiler) { return new CheckProvides(compiler, CheckLevel.WARNING); } public void testIrrelevant() { testSame("var str = 'g4';"); } public void testHarmlessProcedural() { testSame("goog.provide('X'); /** @constructor */ function X(){};"); } public void testHarmless() { String js = "goog.provide('X'); /** @constructor */ X = function(){};"; testSame(js); } public void testNoProvideInnerClass() { testSame( "goog.provide('X');\n" + "/** @constructor */ function X(){};" + "/** @constructor */ X.Y = function(){};"); } public void testMissingGoogProvide(){ String[] js = new String[]{"/** @constructor */ X = function(){};"}; String warning = "missing goog.provide('X')"; test(js, js, null, MISSING_PROVIDE_WARNING, warning); } public void testMissingGoogProvideWithNamespace(){ String[] js = new String[]{"goog = {}; " + "/** @constructor */ goog.X = function(){};"}; String warning = "missing goog.provide('goog.X')"; test(js, js, null, MISSING_PROVIDE_WARNING, warning); } public void testGoogProvideInWrongFileShouldCreateWarning(){ String bad = "/** @constructor */ X = function(){};"; String good = "goog.provide('X'); goog.provide('Y');" + "/** @constructor */ X = function(){};" + "/** @constructor */ Y = function(){};"; String[] js = new String[] {good, bad}; String warning = "missing goog.provide('X')"; test(js, js, null, MISSING_PROVIDE_WARNING, warning); } public void testGoogProvideMissingConstructorIsOkForNow(){ // TODO(user) to prevent orphan goog.provide calls, the pass would have to // account for enums, static functions and constants testSame(new String[]{"goog.provide('Y'); X = function(){};"}); } public void testIgnorePrivateConstructor() { String js = "/** @constructor*/ X_ = function(){};"; testSame(js); } public void testIgnorePrivatelyAnnotatedConstructor() { testSame("/** @private\n@constructor */ X = function(){};"); testSame("/** @constructor\n@private */ X = function(){};"); } }
/* * Copyright 2010 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * @author johnlenz@google.com (John Lenz) */ public class CheckRegExpTest extends CompilerTestCase { CheckRegExp last = null; public CheckRegExpTest() { super("var RegExp;", true); } @Override protected CompilerPass getProcessor(Compiler compiler) { compiler.options.setWarningLevel( DiagnosticGroups.CHECK_REGEXP, CheckLevel.WARNING); last = new CheckRegExp(compiler); return last; } private void testReference(String code, boolean expected) { testSame(code, (expected) ? CheckRegExp.REGEXP_REFERENCE : null); assertEquals(expected, last.isGlobalRegExpPropertiesUsed()); } public void testRegExp() { // Creating regexp's is ok testReference("RegExp();", false); testReference("var x = RegExp();", false); testReference("new RegExp();", false); testReference("var x = new RegExp();", false); // Checking for RegExp instances is OK, as well. testReference("x instanceof RegExp;", false); // Any other reference isn't testReference("RegExp.test();", true); testReference("var x = RegExp.test();", true); testReference("RegExp.exec();", true); testReference("RegExp.$1;", true); testReference("RegExp.foobar;", true); testReference("delete RegExp;", true); // Aliases aren't allowed testReference("var x = RegExp;", true); testReference("f(RegExp);", true); testReference("new f(RegExp);", true); testReference("var x = RegExp; x.test()", true); // No RegExp reference is ok testReference("var x;", false); // Local RegExp is ok testReference("function f() {var RegExp; RegExp.test();}", false); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import static com.google.javascript.jscomp.CheckRequiresForConstructors.MISSING_REQUIRE_WARNING; import com.google.common.collect.ImmutableList; import com.google.javascript.jscomp.CheckLevel; import com.google.javascript.jscomp.Result; /** * Tests for {@link CheckRequiresForConstructors}. * */ public class CheckRequiresForConstructorsTest extends CompilerTestCase { @Override protected CompilerPass getProcessor(Compiler compiler) { return new CheckRequiresForConstructors(compiler, CheckLevel.WARNING); } public void testPassWithNoNewNodes() { String js = "var str = 'g4'; /* does not use new */"; testSame(js); } public void testPassWithOneNew() { String js = "var goog = {};" + "goog.require('foo.bar.goo'); var bar = new foo.bar.goo();"; testSame(js); } public void testPassWithOneNewOuterClass() { String js = "var goog = {};" + "goog.require('goog.foo.Bar'); var bar = new goog.foo.Bar.Baz();"; testSame(js); } public void testPassWithOneNewOuterClassWithUpperPrefix() { String js = "var goog = {};" + "goog.require('goog.foo.IDBar'); var bar = new goog.foo.IDBar.Baz();"; testSame(js); } public void testFailWithOneNew() { String[] js = new String[] {"var foo = {}; var bar = new foo.bar();"}; String warning = "'foo.bar' used but not goog.require'd"; test(js, js, null, MISSING_REQUIRE_WARNING, warning); } public void testPassWithTwoNewNodes() { String js = "var goog = {};" + "goog.require('goog.foo.Bar');goog.require('goog.foo.Baz');" + "var str = new goog.foo.Bar('g4'), num = new goog.foo.Baz(5); "; testSame(js); } public void testPassWithNestedNewNodes() { String js = "var goog = {}; goog.require('goog.foo.Bar'); " + "var str = new goog.foo.Bar(new goog.foo.Bar('5')); "; testSame(js); } public void testFailWithNestedNewNodes() { String[] js = new String[] {"var goog = {}; goog.require('goog.foo.Bar'); " + "var str = new goog.foo.Bar(new goog.foo.Baz('5')); "}; String warning = "'goog.foo.Baz' used but not goog.require'd"; test(js, js, null, MISSING_REQUIRE_WARNING, warning); } public void testPassWithLocalFunctions() { String js = "/** @constructor */ function tempCtor() {}; var foo = new tempCtor();"; testSame(js); } public void testPassWithLocalVariables() { String js = "/** @constructor */ var nodeCreator = function() {};" + "var newNode = new nodeCreator();"; testSame(js); } public void testFailWithLocalVariableInMoreThanOneFile() { // there should be a warning for the 2nd script because it is only declared // in the 1st script String localVar = "/** @constructor */ function tempCtor() {}" + "function baz(){" + " /** @constructor */ function tempCtor() {}; " + "var foo = new tempCtor();}"; String[] js = new String[] {localVar, " var foo = new tempCtor();"}; String warning = "'tempCtor' used but not goog.require'd"; test(js, js, null, MISSING_REQUIRE_WARNING, warning); } public void testNewNodesMetaTraditionalFunctionForm() { // the class in this script creates an instance of itself // there should be no warning because the class should not have to // goog.require itself . String js = "/** @constructor */ function Bar(){}; " + "Bar.prototype.bar = function(){ return new Bar();};"; testSame(js); } public void testNewNodesMeta() { String js = "var goog = {};" + "/** @constructor */goog.ui.Option = function(){};" + "goog.ui.Option.optionDecorator = function(){" + " return new goog.ui.Option(); };"; testSame(js); } public void testShouldWarnWhenInstantiatingObjectsDefinedInGlobalScope() { // there should be a warning for the 2nd script because // Bar was declared in the 1st file, not the 2nd String good = "/** @constructor */ function Bar(){}; " + "Bar.prototype.bar = function(){return new Bar();};"; String bad = "/** @constructor */ function Foo(){ var bar = new Bar();}"; String[] js = new String[] {good, bad}; String warning = "'Bar' used but not goog.require'd"; test(js, js, null, MISSING_REQUIRE_WARNING, warning); } public void testShouldWarnWhenInstantiatingGlobalClassesFromGlobalScope() { // there should be a warning for the 2nd script because Baz // was declared in the first file, not the 2nd String good = "/** @constructor */ function Baz(){}; " + "Baz.prototype.bar = function(){return new Baz();};"; String bad = "var baz = new Baz()"; String[] js = new String[] {good, bad}; String warning = "'Baz' used but not goog.require'd"; test(js, js, null, MISSING_REQUIRE_WARNING, warning); } public void testIgnoresNativeObject() { String externs = "/** @constructor */ function String(val) {}"; String js = "var str = new String('4');"; test(externs, js, js, null, null); } public void testNewNodesWithMoreThanOneFile() { // Bar is created, and goog.require()ed, but in different files. String[] js = new String[] { "var goog = {};" + "/** @constructor */ function Bar() {}" + "goog.require('Bar');", "var bar = new Bar();"}; String warning = "'Bar' used but not goog.require'd"; test(js, js, null, MISSING_REQUIRE_WARNING, warning); } public void testPassWithoutWarningsAndMultipleFiles() { String[] js = new String[] { "var goog = {};" + "goog.require('Foo'); var foo = new Foo();", "goog.require('Bar'); var bar = new Bar();"}; testSame(js); } public void testFailWithWarningsAndMultipleFiles() { /* goog.require is in the code base, but not in the correct file */ String[] js = new String[] { "var goog = {};" + "/** @constructor */ function Bar() {}" + "goog.require('Bar');", "var bar = new Bar();"}; String warning = "'Bar' used but not goog.require'd"; test(js, js, null, MISSING_REQUIRE_WARNING, warning); } public void testCanStillCallNumberWithoutNewOperator() { String externs = "/** @constructor */ function Number(opt_value) {}"; String js = "var n = Number('42');"; test(externs, js, js, null, null); js = "var n = Number();"; test(externs, js, js, null, null); } public void testRequiresAreCaughtBeforeProcessed() { String js = "var foo = {}; var bar = new foo.bar.goo();"; SourceFile input = SourceFile.fromCode("foo.js", js); Compiler compiler = new Compiler(); CompilerOptions opts = new CompilerOptions(); opts.checkRequires = CheckLevel.WARNING; opts.closurePass = true; Result result = compiler.compile(ImmutableList.<SourceFile>of(), ImmutableList.of(input), opts); JSError[] warnings = result.warnings; assertNotNull(warnings); assertTrue(warnings.length > 0); String expectation = "'foo.bar.goo' used but not goog.require'd"; for (JSError warning : warnings) { if (expectation.equals(warning.description)) { return; } } fail("Could not find the following warning:" + expectation); } public void testNoWarningsForThisConstructor() { String js = "var goog = {};" + "/** @constructor */goog.Foo = function() {};" + "goog.Foo.bar = function() {" + " return new this.constructor; " + "};"; testSame(js); } public void testBug2062487() { testSame( "var goog = {};" + "/** @constructor */goog.Foo = function() {" + " /** @constructor */ this.x_ = function() {};" + " this.y_ = new this.x_();" + "};"); } public void testIgnoreDuplicateWarningsForSingleClasses(){ // no use telling them the same thing twice String[] js = new String[]{ "var goog = {};" + "/** @constructor */goog.Foo = function() {};" + "goog.Foo.bar = function(){" + " var first = new goog.Forgot();" + " var second = new goog.Forgot();" + "};"}; String warning = "'goog.Forgot' used but not goog.require'd"; test(js, js, null, MISSING_REQUIRE_WARNING, warning); } }
/* * Copyright 2006 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.jscomp.CheckLevel; public class CheckSideEffectsTest extends CompilerTestCase { public CheckSideEffectsTest() { this.parseTypeInfo = true; allowExternsChanges(true); } @Override protected int getNumRepetitions() { return 1; } @Override protected CompilerPass getProcessor(Compiler compiler) { return new CheckSideEffects(compiler, CheckLevel.WARNING, true); } @Override public void test(String js, String expected, DiagnosticType warning) { test(js, expected, null, warning); } public void test(String js, DiagnosticType warning) { test(js, js, null, warning); } final DiagnosticType e = CheckSideEffects.USELESS_CODE_ERROR; final DiagnosticType ok = null; // no warning public void testUselessCode() { test("function f(x) { if(x) return; }", ok); test("function f(x) { if(x); }", "function f(x) { if(x); }", e); test("if(x) x = y;", ok); test("if(x) x == bar();", "if(x) JSCOMPILER_PRESERVE(x == bar());", e); test("x = 3;", ok); test("x == 3;", "JSCOMPILER_PRESERVE(x == 3);", e); test("var x = 'test'", ok); test("var x = 'test'\n'str'", "var x = 'test'\nJSCOMPILER_PRESERVE('str')", e); test("", ok); test("foo();;;;bar();;;;", ok); test("var a, b; a = 5, b = 6", ok); test("var a, b; a = 5, b == 6", "var a, b; a = 5, JSCOMPILER_PRESERVE(b == 6)", e); test("var a, b; a = (5, 6)", "var a, b; a = (JSCOMPILER_PRESERVE(5), 6)", e); test("var a, b; a = (bar(), 6, 7)", "var a, b; a = (bar(), JSCOMPILER_PRESERVE(6), 7)", e); test("var a, b; a = (bar(), bar(), 7, 8)", "var a, b; a = (bar(), bar(), JSCOMPILER_PRESERVE(7), 8)", e); test("var a, b; a = (b = 7, 6)", ok); test("function x(){}\nfunction f(a, b){}\nf(1,(x(), 2));", ok); test("function x(){}\nfunction f(a, b){}\nf(1,(2, 3));", "function x(){}\nfunction f(a, b){}\n" + "f(1,(JSCOMPILER_PRESERVE(2), 3));", e); } public void testUselessCodeInFor() { test("for(var x = 0; x < 100; x++) { foo(x) }", ok); test("for(; true; ) { bar() }", ok); test("for(foo(); true; foo()) { bar() }", ok); test("for(void 0; true; foo()) { bar() }", "for(JSCOMPILER_PRESERVE(void 0); true; foo()) { bar() }", e); test("for(foo(); true; void 0) { bar() }", "for(foo(); true; JSCOMPILER_PRESERVE(void 0)) { bar() }", e); test("for(foo(); true; (1, bar())) { bar() }", "for(foo(); true; (JSCOMPILER_PRESERVE(1), bar())) { bar() }", e); test("for(foo in bar) { foo() }", ok); test("for (i = 0; el = el.previousSibling; i++) {}", ok); test("for (i = 0; el = el.previousSibling; i++);", ok); } public void testTypeAnnotations() { test("x;", "JSCOMPILER_PRESERVE(x);", e); test("a.b.c.d;", "JSCOMPILER_PRESERVE(a.b.c.d);", e); test("/** @type Number */ a.b.c.d;", ok); test("if (true) { /** @type Number */ a.b.c.d; }", ok); test("function A() { this.foo; }", "function A() { JSCOMPILER_PRESERVE(this.foo); }", e); test("function A() { /** @type Number */ this.foo; }", ok); } public void testJSDocComments() { test("function A() { /** This is a JsDoc comment */ this.foo; }", ok); test("function A() { /* This is a normal comment */ this.foo; }", "function A() { " + " /* This is a normal comment */ JSCOMPILER_PRESERVE(this.foo); }", e); } public void testIssue80() { test("(0, eval)('alert');", ok); test("(0, foo)('alert');", "(JSCOMPILER_PRESERVE(0), foo)('alert');", e); } public void testIsue504() { test("void f();", "JSCOMPILER_PRESERVE(void f());", null, e, "Suspicious code. The result of the 'void' operator is not being used."); } }
/* * Copyright 2012 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Tests for CheckSuspiciousCode */ public class CheckSuspiciousCodeTest extends CompilerTestCase { public CheckSuspiciousCodeTest() { this.parseTypeInfo = true; } @Override protected CompilerPass getProcessor(Compiler compiler) { return new CombinedCompilerPass(compiler, new CheckSuspiciousCode()); } @Override protected int getNumRepetitions() { return 1; } public void test(String js, DiagnosticType error) { test(js, js, null, error); } public void testSuspiciousSemi() { final DiagnosticType e = CheckSuspiciousCode.SUSPICIOUS_SEMICOLON; final DiagnosticType ok = null; // code is 'ok', verify no warning test("if(x()) x = y;", ok); test("if(x()); x = y;", e); // I've had this bug, damned ; test("if(x()){} x = y;", ok); test("if(x()) x = y; else y=z;", ok); test("if(x()); else y=z;", e); test("if(x()){} else y=z;", ok); test("if(x()) x = y; else;", e); test("if(x()) x = y; else {}", ok); test("while(x()) x = y;", ok); test("while(x()); x = y;", e); test("while(x()){} x = y;", ok); test("while(x()); {x = y}", e); test("while(x()){} {x = y}", ok); test("for(;;) x = y;", ok); test("for(;;); x = y;", e); test("for(;;){} x = y;", ok); test("for(x in y) x = y;", ok); test("for(x in y); x = y;", e); test("for(x in y){} x = y;", ok); } private void testReportNaN(String js) { testSame(js, CheckSuspiciousCode.SUSPICIOUS_COMPARISON_WITH_NAN); } public void testComparison1() { testReportNaN("x == NaN"); testReportNaN("x != NaN"); testReportNaN("x === NaN"); testReportNaN("x !== NaN"); testReportNaN("x < NaN"); testReportNaN("x <= NaN"); testReportNaN("x > NaN"); testReportNaN("x >= NaN"); } public void testComparison2() { testReportNaN("NaN == x"); testReportNaN("NaN != x"); testReportNaN("NaN === x"); testReportNaN("NaN !== x"); testReportNaN("NaN < x"); testReportNaN("NaN <= x"); testReportNaN("NaN > x"); testReportNaN("NaN >= x"); } public void testComparison3() { testReportNaN("x == 0/0"); testReportNaN("x != 0/0"); testReportNaN("x === 0/0"); testReportNaN("x !== 0/0"); testReportNaN("x < 0/0"); testReportNaN("x <= 0/0"); testReportNaN("x > 0/0"); testReportNaN("x >= 0/0"); } public void testComparison4() { testReportNaN("0/0 == x"); testReportNaN("0/0 != x"); testReportNaN("0/0 === x"); testReportNaN("0/0 !== x"); testReportNaN("0/0 < x"); testReportNaN("0/0 <= x"); testReportNaN("0/0 > x"); testReportNaN("0/0 >= x"); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.jscomp.CheckLevel; /** * Tests for {@link CheckUnreachableCode}. * */ public class CheckUnreachableCodeTest extends CompilerTestCase { @Override protected CompilerPass getProcessor(Compiler compiler) { return new CombinedCompilerPass(compiler, new CheckUnreachableCode(compiler, CheckLevel.ERROR)); } public void testCorrectSimple() { testSame("var x"); testSame("var x = 1"); testSame("var x = 1; x = 2;"); testSame("if (x) { var x = 1 }"); testSame("if (x) { var x = 1 } else { var y = 2 }"); testSame("while(x) {}"); } public void testIncorrectSimple() { assertUnreachable("function f() { return; x=1; }"); assertUnreachable("function f() { return; x=1; x=1; }"); assertUnreachable("function f() { return; var x = 1; }"); } public void testCorrectIfReturns() { testSame("function f() { if (x) { return } }"); testSame("function f() { if (x) { return } return }"); testSame("function f() { if (x) { if (y) { return } } else { return }}"); testSame("function f()" + "{ if (x) { if (y) { return } return } else { return }}"); } public void testInCorrectIfReturns() { assertUnreachable( "function f() { if (x) { return } else { return } return }"); } public void testCorrectSwitchReturn() { testSame("function f() { switch(x) { default: return; case 1: x++; }}"); testSame("function f() {" + "switch(x) { default: return; case 1: x++; } return }"); testSame("function f() {" + "switch(x) { default: return; case 1: return; }}"); testSame("function f() {" + "switch(x) { case 1: return; } return }"); testSame("function f() {" + "switch(x) { case 1: case 2: return; } return }"); testSame("function f() {" + "switch(x) { case 1: return; case 2: return; } return }"); testSame("function f() {" + "switch(x) { case 1 : return; case 2: return; } return }"); } public void testInCorrectSwitchReturn() { assertUnreachable("function f() {" + "switch(x) { default: return; case 1: return; } return }"); assertUnreachable("function f() {" + "switch(x) { default: return; return; case 1: return; } }"); } public void testCorrectLoopBreaksAndContinues() { testSame("while(1) { foo(); break }"); testSame("while(1) { foo(); continue }"); testSame("for(;;) { foo(); break }"); testSame("for(;;) { foo(); continue }"); testSame("for(;;) { if (x) { break } }"); testSame("for(;;) { if (x) { continue } }"); testSame("do { foo(); continue} while(1)"); } public void testInCorrectLoopBreaksAndContinues() { assertUnreachable("while(1) { foo(); break; bar()}"); assertUnreachable("while(1) { foo(); continue; bar() }"); assertUnreachable("for(;;) { foo(); break; bar() }"); assertUnreachable("for(;;) { foo(); continue; bar() }"); assertUnreachable("for(;;) { if (x) { break; bar() } }"); assertUnreachable("for(;;) { if (x) { continue; bar() } }"); assertUnreachable("do { foo(); continue; bar()} while(1)"); } public void testUncheckedWhileInDo() { assertUnreachable("do { foo(); break} while(1)"); } public void testUncheckedConditionInFor() { assertUnreachable("for(var x = 0; x < 100; x++) { break };"); } public void testFunctionDeclaration() { // functions are not in our CFG. testSame("function f() { return; function ff() { }}"); } public void testVarDeclaration() { assertUnreachable("function f() { return; var x = 1 }"); // I think the user should fix this as well. assertUnreachable("function f() { return; var x }"); } public void testReachableTryCatchFinally() { testSame("try { } finally { }"); testSame("try { foo(); } finally bar(); "); testSame("try { foo() } finally { bar() }"); testSame("try { foo(); } catch (e) {e()} finally bar(); "); testSame("try { foo() } catch (e) {e()} finally { bar() }"); } public void testUnreachableCatch() { assertUnreachable("try { var x = 0 } catch (e) { }"); } public void testSpuriousBreak() { testSame("switch (x) { default: throw x; break; }"); } public void testInstanceOfThrowsException() { testSame("function f() {try { if (value instanceof type) return true; } " + "catch (e) { }}"); } public void testFalseCondition() { assertUnreachable("if(false) { }"); assertUnreachable("if(0) { }"); } public void testUnreachableLoop() { assertUnreachable("while(false) {}"); } public void testInfiniteLoop() { testSame("while (true) { foo(); break; }"); // TODO(user): Have a infinite loop warning instead. assertUnreachable("while(true) {} foo()"); } public void testSuppression() { assertUnreachable("if(false) { }"); testSame( "/** @fileoverview\n" + " * @suppress {uselessCode}\n" + " */\n" + "if(false) { }"); testSame( "/** @fileoverview\n" + " * @suppress {uselessCode}\n" + " */\n" + "function f() { if(false) { } }"); testSame( "/**\n" + " * @suppress {uselessCode}\n" + " */\n" + "function f() { if(false) { } }"); assertUnreachable( "/**\n" + " * @suppress {uselessCode}\n" + " */\n" + "function f() { if(false) { } }\n" + "function g() { if(false) { } }\n"); testSame( "/**\n" + " * @suppress {uselessCode}\n" + " */\n" + "function f() {\n" + " function g() { if(false) { } }\n" + " if(false) { } }\n"); assertUnreachable( "function f() {\n" + " /**\n" + " * @suppress {uselessCode}\n" + " */\n" + " function g() { if(false) { } }\n" + " if(false) { } }\n"); testSame( "function f() {\n" + " /**\n" + " * @suppress {uselessCode}\n" + " */\n" + " function g() { if(false) { } }\n" + "}\n"); } private void assertUnreachable(String js) { test(js, js, CheckUnreachableCode.UNREACHABLE_CODE); } }
/* * Copyright 2012 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import junit.framework.TestCase; import java.util.List; /** * @author tylerg@google.com (Tyler Goodwin) */ public class CleanupPassesTest extends TestCase { private final AbstractCompiler compiler = new Compiler(); private final CompilerOptions options = new CompilerOptions(); public void testCleanupPassOrder() { CleanupPasses config = new CleanupPasses(options); List<PassFactory> checks = config.getChecks(); assertTrue("Pass 0 should be a FieldCleanupPass", checks.get(0).create(compiler) instanceof FieldCleanupPass); } public void testNoOptimizations() { CompilerOptions options = new CompilerOptions(); CleanupPasses config = new CleanupPasses(options); assertTrue("Cleanup Passes unexpectedly contain optimization passes", config.getOptimizations().isEmpty()); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Tests for {@link ClosureCodeRemoval} * * @author robbyw@google.com (Robby Walker) */ public class ClosureCodeRemovalTest extends CompilerTestCase { private static String EXTERNS = "var window;"; public ClosureCodeRemovalTest() { super(EXTERNS); } public void testRemoveAbstract() { test("function Foo() {}; Foo.prototype.doSomething = goog.abstractMethod;", "function Foo() {};"); } public void testRemoveMultiplySetAbstract() { test("function Foo() {}; Foo.prototype.doSomething = " + "Foo.prototype.doSomethingElse = Foo.prototype.oneMore = " + "goog.abstractMethod;", "function Foo() {};"); } public void testDoNotRemoveNormal() { testSame("function Foo() {}; Foo.prototype.doSomething = function() {};"); } public void testDoNotRemoveOverride() { test("function Foo() {}; Foo.prototype.doSomething = goog.abstractMethod;" + "function Bar() {}; goog.inherits(Bar, Foo);" + "Bar.prototype.doSomething = function() {}", "function Foo() {}; function Bar() {}; goog.inherits(Bar, Foo);" + "Bar.prototype.doSomething = function() {}"); } public void testDoNotRemoveNonQualifiedName() { testSame("document.getElementById('x').y = goog.abstractMethod;"); } public void testStopRemovalAtNonQualifiedName() { test("function Foo() {}; function Bar() {};" + "Foo.prototype.x = document.getElementById('x').y = Bar.prototype.x" + " = goog.abstractMethod;", "function Foo() {}; function Bar() {};" + "Foo.prototype.x = document.getElementById('x').y = " + "goog.abstractMethod;"); } public void testAssertionRemoval1() { test("var x = goog.asserts.assert(y(), 'message');", "var x = y();"); } public void testAssertionRemoval2() { test("goog.asserts.assert(y(), 'message');", ""); } public void testAssertionRemoval3() { test("goog.asserts.assert();", ""); } public void testAssertionRemoval4() { test("var x = goog.asserts.assert();", "var x = void 0;"); } @Override protected ClosureCodeRemoval getProcessor(Compiler compiler) { return new ClosureCodeRemoval(compiler, true, true); } }
/* * Copyright 2007 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.jscomp.CodingConvention.SubclassRelationship; import com.google.javascript.jscomp.CodingConvention.SubclassType; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSTypeRegistry; import junit.framework.TestCase; /** * Test class for {@link GoogleCodingConvention}. */ public class ClosureCodingConventionTest extends TestCase { private ClosureCodingConvention conv = new ClosureCodingConvention(); public void testVarAndOptionalParams() { Node args = new Node(Token.PARAM_LIST, Node.newString(Token.NAME, "a"), Node.newString(Token.NAME, "b")); Node optArgs = new Node(Token.PARAM_LIST, Node.newString(Token.NAME, "opt_a"), Node.newString(Token.NAME, "opt_b")); assertFalse(conv.isVarArgsParameter(args.getFirstChild())); assertFalse(conv.isVarArgsParameter(args.getLastChild())); assertFalse(conv.isVarArgsParameter(optArgs.getFirstChild())); assertFalse(conv.isVarArgsParameter(optArgs.getLastChild())); assertFalse(conv.isOptionalParameter(args.getFirstChild())); assertFalse(conv.isOptionalParameter(args.getLastChild())); assertFalse(conv.isOptionalParameter(optArgs.getFirstChild())); assertFalse(conv.isOptionalParameter(optArgs.getLastChild())); } public void testInlineName() { assertFalse(conv.isConstant("a")); assertFalse(conv.isConstant("XYZ123_")); assertFalse(conv.isConstant("ABC")); assertFalse(conv.isConstant("ABCdef")); assertFalse(conv.isConstant("aBC")); assertFalse(conv.isConstant("A")); assertFalse(conv.isConstant("_XYZ123")); assertFalse(conv.isConstant("a$b$XYZ123_")); assertFalse(conv.isConstant("a$b$ABC_DEF")); assertFalse(conv.isConstant("a$b$A")); assertFalse(conv.isConstant("a$b$a")); assertFalse(conv.isConstant("a$b$ABCdef")); assertFalse(conv.isConstant("a$b$aBC")); assertFalse(conv.isConstant("a$b$")); assertFalse(conv.isConstant("$")); } public void testExportedName() { assertFalse(conv.isExported("_a")); assertFalse(conv.isExported("_a_")); assertFalse(conv.isExported("a")); assertFalse(conv.isExported("$super", false)); assertTrue(conv.isExported("$super", true)); assertTrue(conv.isExported("$super")); } public void testPrivateName() { assertFalse(conv.isPrivate("a_")); assertFalse(conv.isPrivate("a")); assertFalse(conv.isPrivate("_a_")); } public void testEnumKey() { assertTrue(conv.isValidEnumKey("A")); assertTrue(conv.isValidEnumKey("123")); assertTrue(conv.isValidEnumKey("FOO_BAR")); assertTrue(conv.isValidEnumKey("a")); assertTrue(conv.isValidEnumKey("someKeyInCamelCase")); assertTrue(conv.isValidEnumKey("_FOO_BAR")); } public void testInheritanceDetection1() { assertNotClassDefining("goog.foo(A, B);"); } public void testInheritanceDetection2() { assertDefinesClasses("goog.inherits(A, B);", "A", "B"); } public void testInheritanceDetection3() { assertDefinesClasses("A.inherits(B);", "A", "B"); } public void testInheritanceDetection4() { assertDefinesClasses("goog.inherits(goog.A, goog.B);", "goog.A", "goog.B"); } public void testInheritanceDetection5() { assertDefinesClasses("goog.A.inherits(goog.B);", "goog.A", "goog.B"); } public void testInheritanceDetection6() { assertNotClassDefining("A.inherits(this.B);"); } public void testInheritanceDetection7() { assertNotClassDefining("this.A.inherits(B);"); } public void testInheritanceDetection8() { assertNotClassDefining("goog.inherits(A, B, C);"); } public void testInheritanceDetection9() { assertDefinesClasses("A.mixin(B.prototype);", "A", "B"); } public void testInheritanceDetection10() { assertDefinesClasses("goog.mixin(A.prototype, B.prototype);", "A", "B"); } public void testInheritanceDetection11() { assertNotClassDefining("A.mixin(B)"); } public void testInheritanceDetection12() { assertNotClassDefining("goog.mixin(A.prototype, B)"); } public void testInheritanceDetection13() { assertNotClassDefining("goog.mixin(A, B)"); } public void testInheritanceDetection14() { assertNotClassDefining("goog$mixin((function(){}).prototype)"); } public void testInheritanceDetectionPostCollapseProperties() { assertDefinesClasses("goog$inherits(A, B);", "A", "B"); assertNotClassDefining("goog$inherits(A);"); } public void testObjectLiteralCast() { assertNotObjectLiteralCast("goog.reflect.object();"); assertNotObjectLiteralCast("goog.reflect.object(A);"); assertNotObjectLiteralCast("goog.reflect.object(1, {});"); assertObjectLiteralCast("goog.reflect.object(A, {});"); } public void testFunctionBind() { assertNotFunctionBind("goog.bind()"); // invalid bind assertFunctionBind("goog.bind(f)"); assertFunctionBind("goog.bind(f, obj)"); assertFunctionBind("goog.bind(f, obj, p1)"); assertNotFunctionBind("goog$bind()"); // invalid bind assertFunctionBind("goog$bind(f)"); assertFunctionBind("goog$bind(f, obj)"); assertFunctionBind("goog$bind(f, obj, p1)"); assertNotFunctionBind("goog.partial()"); // invalid bind assertFunctionBind("goog.partial(f)"); assertFunctionBind("goog.partial(f, obj)"); assertFunctionBind("goog.partial(f, obj, p1)"); assertNotFunctionBind("goog$partial()"); // invalid bind assertFunctionBind("goog$partial(f)"); assertFunctionBind("goog$partial(f, obj)"); assertFunctionBind("goog$partial(f, obj, p1)"); assertFunctionBind("(function(){}).bind()"); assertFunctionBind("(function(){}).bind(obj)"); assertFunctionBind("(function(){}).bind(obj, p1)"); assertNotFunctionBind("Function.prototype.bind.call()"); assertFunctionBind("Function.prototype.bind.call(obj)"); assertFunctionBind("Function.prototype.bind.call(obj, p1)"); } public void testRequire() { assertRequire("goog.require('foo')"); assertNotRequire("goog.require(foo)"); assertNotRequire("goog.require()"); assertNotRequire("foo()"); } public void testApplySubclassRelationship() { JSTypeRegistry registry = new JSTypeRegistry(null); Node nodeA = new Node(Token.FUNCTION); FunctionType ctorA = registry.createConstructorType("A", nodeA, new Node(Token.PARAM_LIST), null, null); Node nodeB = new Node(Token.FUNCTION); FunctionType ctorB = registry.createConstructorType("B", nodeB, new Node(Token.PARAM_LIST), null, null); conv.applySubclassRelationship(ctorA, ctorB, SubclassType.INHERITS); assertTrue(ctorB.getPrototype().hasOwnProperty("constructor")); assertEquals(nodeB, ctorB.getPrototype().getPropertyNode("constructor")); assertTrue(ctorB.hasOwnProperty("superClass_")); assertEquals(nodeB, ctorB.getPropertyNode("superClass_")); } private void assertFunctionBind(String code) { Node n = parseTestCode(code); assertNotNull(conv.describeFunctionBind(n.getFirstChild())); } private void assertNotFunctionBind(String code) { Node n = parseTestCode(code); assertNull(conv.describeFunctionBind(n.getFirstChild())); } private void assertRequire(String code) { Node n = parseTestCode(code); assertNotNull(conv.extractClassNameIfRequire(n.getFirstChild(), n)); } private void assertNotRequire(String code) { Node n = parseTestCode(code); assertNull(conv.extractClassNameIfRequire(n.getFirstChild(), n)); } private void assertNotObjectLiteralCast(String code) { Node n = parseTestCode(code); assertNull(conv.getObjectLiteralCast(n.getFirstChild())); } private void assertObjectLiteralCast(String code) { Node n = parseTestCode(code); assertNotNull(conv.getObjectLiteralCast(n.getFirstChild())); } private void assertNotClassDefining(String code) { Node n = parseTestCode(code); assertNull(conv.getClassesDefinedByCall(n.getFirstChild())); } private void assertDefinesClasses(String code, String subclassName, String superclassName) { Node n = parseTestCode(code); SubclassRelationship classes = conv.getClassesDefinedByCall(n.getFirstChild()); assertNotNull(classes); assertEquals(subclassName, classes.subclassName); assertEquals(superclassName, classes.superclassName); } private Node parseTestCode(String code) { Compiler compiler = new Compiler(); return compiler.parseTestCode(code).getFirstChild(); } }
/* * Copyright 2011 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Tests for {@link ClosureOptimizePrimitives}. * * @author agrieve@google.com (Andrew Grieve) */ public class ClosureOptimizePrimitivesTest extends CompilerTestCase { @Override public CompilerPass getProcessor(final Compiler compiler) { return new ClosureOptimizePrimitives(compiler); } public void testObjectCreateNonConstKey() { testSame("goog.object.create('a',1,2,3,foo,bar);"); } public void testObjectCreateOddParams() { testSame("goog.object.create('a',1,2);"); } public void testObjectCreate1() { test("var a = goog.object.create()", "var a = {}"); } public void testObjectCreate2() { test("var a = goog$object$create('b',goog$object$create('c','d'))", "var a = {'b':{'c':'d'}};"); } public void testObjectCreate3() { test("var a = goog.object.create(1,2)", "var a = {1:2}"); } public void testObjectCreate4() { test("alert(goog.object.create(1,2).toString())", "alert({1:2}.toString())"); } public void testObjectCreate5() { test("goog.object.create('a',2).toString()", "({'a':2}).toString()"); } }
/* * Copyright 2012 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import static com.google.javascript.jscomp.ClosureRewriteClass.GOOG_CLASS_CONSTRUCTOR_MISING; import static com.google.javascript.jscomp.ClosureRewriteClass.GOOG_CLASS_DESCRIPTOR_NOT_VALID; import static com.google.javascript.jscomp.ClosureRewriteClass.GOOG_CLASS_STATICS_NOT_VALID; import static com.google.javascript.jscomp.ClosureRewriteClass.GOOG_CLASS_SUPER_CLASS_NOT_VALID; import static com.google.javascript.jscomp.ClosureRewriteClass.GOOG_CLASS_TARGET_INVALID; import static com.google.javascript.jscomp.ClosureRewriteClass.GOOG_CLASS_UNEXPECTED_PARAMS; /** * Unit tests for ClosureRewriteGoogClass * @author johnlenz@google.com (John Lenz) */ public class ClosureRewriteClassTest extends CompilerTestCase { @Override protected CompilerPass getProcessor(Compiler compiler) { return new ClosureRewriteClass(compiler); } @Override protected void setUp() throws Exception { super.setUp(); this.enableEcmaScript5(false); } @Override protected int getNumRepetitions() { return 1; } public void testBasic1() { test( "var x = goog.defineClass(null, {\n" + " constructor: function(){}\n" + "});", "{var x = function() {};}"); } public void testBasic2() { test( "var x = {};\n" + "x.y = goog.defineClass(null, {\n" + " constructor: function(){}\n" + "});", "var x = {};" + "{x.y = function() {};}"); } public void testBasic3() { test( "var x = goog.labs.classdef.defineClass(null, {\n" + " constructor: function(){}\n" + "});", "{var x = function() {};}"); } public void testInnerClass1() { test( "var x = goog.defineClass(some.Super, {\n" + " constructor: function(){\n" + " this.foo = 1;\n" + " },\n" + " statics: {\n" + " inner: goog.defineClass(x,{\n" + " constructor: function(){\n" + " this.bar = 1;\n" + " }\n" + " })\n" + " }\n" + "});", "{" + "var x=function(){this.foo=1};" + "goog.inherits(x,some.Super);" + "{" + "x.inner=function(){this.bar=1};" + "goog.inherits(x.inner,x);" + "}" + "}"); } public void testComplete1() { test( "var x = goog.defineClass(some.Super, {\n" + " constructor: function(){\n" + " this.foo = 1;\n" + " },\n" + " statics: {\n" + " prop1: 1,\n" + " /** @const */\n" + " PROP2: 2\n" + " },\n" + " anotherProp: 1,\n" + " aMethod: function() {}\n" + "});", "{" + "var x=function(){this.foo=1};" + "goog.inherits(x,some.Super);" + "x.prop1=1;" + "x.PROP2=2;" + "x.prototype.anotherProp=1;" + "x.prototype.aMethod=function(){};" + "}"); } public void testComplete2() { test( "x.y = goog.defineClass(some.Super, {\n" + " constructor: function(){\n" + " this.foo = 1;\n" + " },\n" + " statics: {\n" + " prop1: 1,\n" + " /** @const */\n" + " PROP2: 2\n" + " },\n" + " anotherProp: 1,\n" + " aMethod: function() {}\n" + "});", "{\n" + "/** @constructor */\n" + "x.y=function(){this.foo=1};\n" + "goog.inherits(x.y,some.Super);" + "x.y.prop1=1;\n" + "/** @const */\n" + "x.y.PROP2=2;\n" + "x.y.prototype.anotherProp=1;" + "x.y.prototype.aMethod=function(){};" + "}"); } public void testClassWithStaticInitFn() { test( "x.y = goog.defineClass(some.Super, {\n" + " constructor: function(){\n" + " this.foo = 1;\n" + " },\n" + " statics: function(cls) {\n" + " cls.prop1 = 1;\n" + " /** @const */\n" + " cls.PROP2 = 2;\n" + " },\n" + " anotherProp: 1,\n" + " aMethod: function() {}\n" + "});", "{\n" + "/** @constructor */\n" + "x.y=function(){this.foo=1};\n" + "goog.inherits(x.y,some.Super);" + "x.y.prototype.anotherProp=1;" + "x.y.prototype.aMethod=function(){};" + "(function(cls) {" + " cls.prop1=1;\n" + " /** @const */\n" + " cls.PROP2=2;" + "})(x.y);\n" + "}"); } public void testInvalid1() { testSame( "var x = goog.defineClass();", GOOG_CLASS_SUPER_CLASS_NOT_VALID, true); testSame( "var x = goog.defineClass('foo');", GOOG_CLASS_SUPER_CLASS_NOT_VALID, true); testSame( "var x = goog.defineClass(foo());", GOOG_CLASS_SUPER_CLASS_NOT_VALID, true); testSame( "var x = goog.defineClass({'foo':1});", GOOG_CLASS_SUPER_CLASS_NOT_VALID, true); testSame( "var x = goog.defineClass({1:1});", GOOG_CLASS_SUPER_CLASS_NOT_VALID, true); this.enableEcmaScript5(true); testSame( "var x = goog.defineClass({get foo() {return 1}});", GOOG_CLASS_SUPER_CLASS_NOT_VALID, true); testSame( "var x = goog.defineClass({set foo(a) {}});", GOOG_CLASS_SUPER_CLASS_NOT_VALID, true); } public void testInvalid2() { testSame( "var x = goog.defineClass(null);", GOOG_CLASS_DESCRIPTOR_NOT_VALID, true); testSame( "var x = goog.defineClass(null, null);", GOOG_CLASS_DESCRIPTOR_NOT_VALID, true); testSame( "var x = goog.defineClass(null, foo());", GOOG_CLASS_DESCRIPTOR_NOT_VALID, true); } public void testInvalid3() { testSame( "var x = goog.defineClass(null, {});", GOOG_CLASS_CONSTRUCTOR_MISING, true); } public void testInvalid4() { testSame( "var x = goog.defineClass(null, {" + " constructor: function(){}," + " statics: null" + "});", GOOG_CLASS_STATICS_NOT_VALID, true); testSame( "var x = goog.defineClass(null, {" + " constructor: function(){}," + " statics: foo" + "});", GOOG_CLASS_STATICS_NOT_VALID, true); testSame( "var x = goog.defineClass(null, {" + " constructor: function(){}," + " statics: {'foo': 1}" + "});", GOOG_CLASS_STATICS_NOT_VALID, true); testSame( "var x = goog.defineClass(null, {" + " constructor: function(){}," + " statics: {1: 1}" + "});", GOOG_CLASS_STATICS_NOT_VALID, true); } public void testInvalid5() { testSame( "var x = goog.defineClass(null, {" + " constructor: function(){}" + "}, null);", GOOG_CLASS_UNEXPECTED_PARAMS, true); } public void testInvalid6() { testSame( "goog.defineClass();", GOOG_CLASS_TARGET_INVALID, true); testSame( "var x = goog.defineClass() || null;", GOOG_CLASS_TARGET_INVALID, true); testSame( "({foo: goog.defineClass()});", GOOG_CLASS_TARGET_INVALID, true); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.rhino.Node; /** * Unit tests for {@link CoalesceVariableNames} * */ public class CoalesceVariableNamesTest extends CompilerTestCase { // The spacing in this file is not exactly standard but it greatly helps // picking out which variable names are merged. private boolean usePseudoName = false; @Override protected int getNumRepetitions() { return 1; } @Override public void setUp() { super.enableLineNumberCheck(true); usePseudoName = false; } @Override public CompilerPass getProcessor(final Compiler compiler) { return new CompilerPass() { @Override public void process(Node externs, Node js) { NodeTraversal.traverse(compiler, js, new CoalesceVariableNames(compiler, usePseudoName)); } }; } public void testSimple() { inFunction("var x; var y; x=1; x; y=1; y; return y", "var x; x=1; x; x=1; x; return x"); inFunction("var x,y; x=1; x; y=1; y", "var x ; x=1; x; x=1; x"); inFunction("var x,y; x=1; y=2; y; x"); inFunction("y=0; var x, y; y; x=0; x", "y=0; var y ; y; y=0;y"); inFunction("var x,y; x=1; y=x; y", "var x ; x=1; x=x; x"); inFunction("var x,y; x=1; y=x+1; y", "var x ; x=1; x=x+1; x"); inFunction("x=1; x; y=2; y; var x; var y", "x=1; x; x=2; x; var x"); inFunction("var x=1; var y=x+1; return y", "var x=1; x=x+1; return x"); inFunction("var x=1; var y=0; x+=1; y"); inFunction("var x=1; x+=1; var y=0; y", "var x=1; x+=1; x=0; x"); inFunction("var x=1; foo(bar(x+=1)); var y=0; y", "var x=1; foo(bar(x+=1)); x=0; x"); inFunction("var y, x=1; f(x+=1, y)"); inFunction("var x; var y; y += 1, y, x = 1; x"); } public void testMergeThreeVarNames() { inFunction("var x,y,z; x=1; x; y=1; y; z=1; z", "var x ; x=1; x; x=1; x; x=1; x"); } public void testDifferentBlock() { inFunction("if(1) { var x = 0; x } else { var y = 0; y }", "if(1) { var x = 0; x } else { x = 0; x }"); } public void testLoops() { inFunction("var x; while(1) { x; x = 1; var y = 1; y }"); inFunction("var y = 1; y; while(1) { var x = 1; x }", "var y = 1; y; while(1) { y = 1; y }"); } public void testEscaped() { inFunction("var x = 1; x; function f() { x }; var y = 0; y; f()"); } public void testFor() { inFunction("var x = 1; x; for (;;) var y; y = 1; y", "var x = 1; x; for (;;) ; x = 1; x"); } public void testForIn() { // We lose some precision here, unless we have "branched-backward-dataflow". inFunction("var x = 1, k; x; ; for (var y in k) { y }", "var x = 1, k; x; ; for (var y in k) { y }"); inFunction("var x = 1, k; x; y = 1; for (var y in k) { y }", "var x = 1, k; x; x = 1; for ( x in k) { x }"); } public void testLoopInductionVar() { inFunction( "for(var x = 0; x < 10; x++){}" + "for(var y = 0; y < 10; y++){}" + "for(var z = 0; z < 10; z++){}", "for(var x = 0; x < 10; x++){}" + "for(x = 0; x < 10; x++){}" + "for(x = 0; x < 10; x++){}"); inFunction( "for(var x = 0; x < 10; x++){z}" + "for(var y = 0, z = 0; y < 10; y++){z}", "for(var x = 0; x < 10; x++){z}" + "for(var x = 0, z = 0; x < 10; x++){z}"); inFunction("var x = 1; x; for (var y; y=1; ) {y}", "var x = 1; x; for ( ; x=1; ) {x}"); inFunction("var x = 1; x; y = 1; while(y) var y; y", "var x = 1; x; x = 1; while(x); x"); inFunction("var x = 1; x; f:var y; y=1", "var x = 1; x; x=1"); } public void testSwitchCase() { inFunction("var x = 1; switch(x) { case 1: var y; case 2: } y = 1; y", "var x = 1; switch(x) { case 1: case 2: } x = 1; x"); } public void testDuplicatedVar() { // Is there a shorter version without multiple declarations? inFunction("z = 1; var x = 0; x; z; var y = 2, z = 1; y; z;", "z = 1; var x = 0; x; z; var x = 2, z = 1; x; z;"); } public void testTryCatch() { inFunction("try {} catch (e) { } var x = 4; x;", "try {} catch (e) { } var x = 4; x;"); inFunction("var x = 4; x; try {} catch (e) { }", "var x = 4; x; try {} catch (e) { }"); } public void testDeadAssignment() { inFunction("var x = 6; var y; y = 4 ; x"); inFunction("var y = 3; var y; y += 4; x"); inFunction("var y = 3; var y; y ++ ; x"); inFunction("y = 3; var x; var y = 1 ; x"); } public void testParameter() { test("function FUNC(param) {var x = 0; x}", "function FUNC(param) {param = 0; param}"); } public void testParameter2() { // Make sure two formal parameter name never merges. test("function FUNC(x,y) {x = 0; x; y = 0; y}"); test("function FUNC(x,y,z) {x = 0; x; y = 0; z = 0; z}"); } public void testParameter3() { // Make sure the formal parameter declaration is consider a def. test("function FUNC(x) {var y; y = 0; x; y}"); } public void testParameter4() { // Make sure that we do not merge two-arg functions because of the // IE sort bug (see comments in computeEscaped) test("function FUNC(x, y) {var a,b; y; a=0; a; x; b=0; b}", "function FUNC(x, y) {var a; y; a=0; a; x; a=0; a}"); } public void testParameter4b() { // Merge parameters test("function FUNC(x, y, z) {var a,b; y; a=0; a; x; b=0; b}", "function FUNC(x, y, z) { y; y=0; y; x; x=0; x}"); } public void testLiveRangeChangeWithinCfgNode() { inFunction("var x, y; x = 1, y = 2, y, x"); inFunction("var x, y; x = 1,x; y"); // We lose some precisions within the node itself. inFunction("var x; var y; y = 1, y, x = 1; x"); inFunction("var x; var y; y = 1; y, x = 1; x", "var x; x = 1; x, x = 1; x"); inFunction("var x, y; y = 1, x = 1, x, y += 1, y"); inFunction("var x, y; y = 1, x = 1, x, y ++, y"); } public void testLiveRangeChangeWithinCfgNode2() { inFunction("var x; var y; var a; var b;" + "y = 1, a = 1, y, a, x = 1, b = 1; x; b"); inFunction("var x; var y; var a; var b;" + "y = 1, a = 1, y, a, x = 1; x; b = 1; b", "var x; var y; var a; " + "y = 1, a = 1, y, a, x = 1; x; x = 1; x"); inFunction("var x; var y; var a; var b;" + "y = 1, a = 1, y, x = 1; a; x; b = 1; b", "var x; var y; var a; " + "y = 1, a = 1, y, x = 1; a; x; x = 1; x"); } public void testFunctionNameReuse() { // TODO(user): Figure out why this increase code size most of the time. // inFunction("function x() {}; x(); var y = 1; y", // "function x() {}; x(); x = 1; x"); // inFunction("x(); var y = 1; y; function x() {}", // "x(); x = 1; x; function x() {}"); // inFunction("x(); var y = 1; function x() {}; y", // "x(); x = 1; function x() {}; x"); // // Can't merge because of possible escape. // inFunction("function x() {return x}; x(); var y = 1; y", // "function x() {return x}; x(); var y = 1; y"); // // inFunction("var y = 1; y; x; function x() {}", // "var y = 1; y; x; function x() {}"); // inFunction("var y = 1; y; function x() {}; x", // "var y = 1; y; function x() {}; x"); // inFunction("var y = 1; y; function x() {}; x = 1; x", // "var y = 1; y; function x() {}; y = 1; y"); // inFunction("var y = 1; y; x = 1; function x() {}; x", // "var y = 1; y; y = 1; function x() {}; y"); } public void testBug1401831() { // Verify that we don't wrongly merge "opt_a2" and "i" without considering // arguments[0] aliasing it. String src = "function f(opt_a2) {" + " var buffer;" + " if (opt_a2) {" + " for(var i = 0; i < arguments.length; i++) {" + " buffer += arguments[i];" + " }" + " }" + " return buffer;" + "}"; test(src, src); } public void testDeterministic() { // Make the variable interference graph a pentagon. // a - b // / \ // e c // \ / // d // The coloring partitioning would be: // a = { a, c } // b = { b, d } // e = { e } inFunction("var a,b,c,d,e;" + " a=1; b=1; a; b;" + " b=1; c=1; b; c;" + " c=1; d=1; c; d;" + " d=1; e=1; d; e;" + " e=1; a=1; e; a;", "var a,b, e;" + " a=1; b=1; a; b;" + " b=1; a=1; b; a;" + " a=1; b=1; a; b;" + " b=1; e=1; b; e;" + " e=1; a=1; e; a;"); // If we favor "d" first by declaring "d" earlier, // the coloring partitioning would be: // b = { b, e } // d = { d, a } // c = { c } inFunction("var d,a,b,c,e;" + " a=1; b=1; a; b;" + " b=1; c=1; b; c;" + " c=1; d=1; c; d;" + " d=1; e=1; d; e;" + " e=1; a=1; e; a;", "var d, b,c ;" + " d=1; b=1; d; b;" + " b=1; c=1; b; c;" + " c=1; d=1; c; d;" + " d=1; b=1; d; b;" + " b=1; d=1; b; d;"); } // Sometimes live range can be cross even within a VAR declaration. public void testVarLiveRangeCross() { inFunction("var a={}; var b=a.S(); b", "var a={}; a=a.S(); a"); inFunction("var a={}; var b=a.S(), c=b.SS(); b; c", "var a={}; var b=a.S(), a=b.SS(); b; a"); inFunction("var a={}; var b=a.S(), c=a.SS(), d=a.SSS(); b; c; d", "var a={}; var b=a.S(), c=a.SS(), a=a.SSS(); b; c; a"); inFunction("var a={}; var b=a.S(), c=a.SS(), d=a.SSS(); b; c; d", "var a={}; var b=a.S(), c=a.SS(), a=a.SSS(); b; c; a"); inFunction("var a={}; d=1; d; var b=a.S(), c=a.SS(), d=a.SSS(); b; c; d"); } public void testBug1445366() { // An assignment might not be complete if the RHS throws an exception. inFunction( " var iframe = getFrame();" + " try {" + " var win = iframe.contentWindow;" + " } catch (e) {" + " } finally {" + " if (win)" + " this.setupWinUtil_();" + " else" + " this.load();" + " }"); // Verify that we can still coalesce it if there are no handlers. inFunction( " var iframe = getFrame();" + " var win = iframe.contentWindow;" + " if (win)" + " this.setupWinUtil_();" + " else" + " this.load();", " var iframe = getFrame();" + " iframe = iframe.contentWindow;" + " if (iframe)" + " this.setupWinUtil_();" + " else" + " this.load();"); } public void testCannotReuseAnyParamsBug() { testSame("function handleKeyboardShortcut(e, key, isModifierPressed) {\n" + " if (!isModifierPressed) {\n" + " return false;\n" + " }\n" + " var command;\n" + " switch (key) {\n" + " case 'b': // Ctrl+B\n" + " command = COMMAND.BOLD;\n" + " break;\n" + " case 'i': // Ctrl+I\n" + " command = COMMAND.ITALIC;\n" + " break;\n" + " case 'u': // Ctrl+U\n" + " command = COMMAND.UNDERLINE;\n" + " break;\n" + " case 's': // Ctrl+S\n" + " return true;\n" + " }\n" + "\n" + " if (command) {\n" + " this.fieldObject.execCommand(command);\n" + " return true;\n" + " }\n" + "\n" + " return false;\n" + "};"); } public void testForInWithAssignment() { inFunction( "var _f = function (commands) {" + " var k, v, ref;" + " for (k in ref = commands) {" + " v = ref[k];" + " alert(k + ':' + v);" + " }" + "}", "var _f = function (commands) {" + " var k,ref;" + " for (k in ref = commands) {" + " commands = ref[k];" + " alert(k + ':' + commands);" + " }" + "}" ); } public void testUsePseduoNames() { usePseudoName = true; inFunction("var x = 0; print(x ); var y = 1; print( y)", "var x_y = 0; print(x_y); x_y = 1; print(x_y)"); inFunction("var x_y = 1; var x = 0; print(x ); var y = 1;" + "print( y); print(x_y);", "var x_y = 1; var x_y$ = 0; print(x_y$); x_y$ = 1;" + "" + "print(x_y$); print(x_y);"); inFunction("var x_y = 1; function f() {" + "var x = 0; print(x ); var y = 1; print( y);" + "print(x_y);}", "var x_y = 1; function f() {" + "var x_y$ = 0; print(x_y$); x_y$ = 1; print(x_y$);" + "print(x_y);}"); inFunction("var x = 0; print(x ); var y = 1; print( y); " + "var closure_var; function bar() { print(closure_var); }", "var x_y = 0; print(x_y); x_y = 1; print(x_y); " + "var closure_var; function bar() { print(closure_var); }"); } public void testMaxVars() { String code = ""; for (int i = 0; i < LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE + 1; i++) { code += String.format("var x%d = 0; print(x%d);", i, i); } inFunction(code); } private void inFunction(String src) { inFunction(src, src); } private void inFunction(String src, String expected) { test("function FUNC(){" + src + "}", "function FUNC(){" + expected + "}"); } private void test(String src) { test(src, src); } }
/* * Copyright 2004 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.base.Joiner; import com.google.common.collect.Lists; import com.google.javascript.jscomp.CompilerOptions.LanguageMode; import com.google.javascript.rhino.InputId; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import junit.framework.TestCase; import java.util.List; public class CodePrinterTest extends TestCase { boolean trustedStrings = true; @Override public void setUp() { trustedStrings = true; } Node parse(String js) { return parse(js, false); } Node parse(String js, boolean checkTypes) { Compiler compiler = new Compiler(); CompilerOptions options = new CompilerOptions(); options.setTrustedStrings(trustedStrings); // Allow getters and setters. options.setLanguageIn(LanguageMode.ECMASCRIPT5); compiler.initOptions(options); Node n = compiler.parseTestCode(js); if (checkTypes) { DefaultPassConfig passConfig = new DefaultPassConfig(null); CompilerPass typeResolver = passConfig.resolveTypes.create(compiler); Node externs = new Node(Token.SCRIPT); externs.setInputId(new InputId("externs")); Node externAndJsRoot = new Node(Token.BLOCK, externs, n); externAndJsRoot.setIsSyntheticBlock(true); typeResolver.process(externs, n); CompilerPass inferTypes = passConfig.inferTypes.create(compiler); inferTypes.process(externs, n); } checkUnexpectedErrorsOrWarnings(compiler, 0); return n; } private static void checkUnexpectedErrorsOrWarnings( Compiler compiler, int expected) { int actual = compiler.getErrors().length + compiler.getWarnings().length; if (actual != expected) { String msg = ""; for (JSError err : compiler.getErrors()) { msg += "Error:" + err.toString() + "\n"; } for (JSError err : compiler.getWarnings()) { msg += "Warning:" + err.toString() + "\n"; } assertEquals("Unexpected warnings or errors.\n " + msg, expected, actual); } } String parsePrint(String js, boolean prettyprint, int lineThreshold) { CompilerOptions options = new CompilerOptions(); options.setTrustedStrings(trustedStrings); options.setPrettyPrint(prettyprint); options.setLineLengthThreshold(lineThreshold); return new CodePrinter.Builder(parse(js)).setCompilerOptions(options) .build(); } String parsePrint(String js, boolean prettyprint, boolean lineBreak, int lineThreshold) { CompilerOptions options = new CompilerOptions(); options.setTrustedStrings(trustedStrings); options.setPrettyPrint(prettyprint); options.setLineLengthThreshold(lineThreshold); options.setLineBreak(lineBreak); return new CodePrinter.Builder(parse(js)).setCompilerOptions(options) .build(); } String parsePrint(String js, boolean prettyprint, boolean lineBreak, boolean preferLineBreakAtEof, int lineThreshold) { CompilerOptions options = new CompilerOptions(); options.setTrustedStrings(trustedStrings); options.setPrettyPrint(prettyprint); options.setLineLengthThreshold(lineThreshold); options.setPreferLineBreakAtEndOfFile(preferLineBreakAtEof); options.setLineBreak(lineBreak); return new CodePrinter.Builder(parse(js)).setCompilerOptions(options) .build(); } String parsePrint(String js, boolean prettyprint, boolean lineBreak, int lineThreshold, boolean outputTypes) { CompilerOptions options = new CompilerOptions(); options.setTrustedStrings(trustedStrings); options.setPrettyPrint(prettyprint); options.setLineLengthThreshold(lineThreshold); options.setLineBreak(lineBreak); return new CodePrinter.Builder(parse(js, true)).setCompilerOptions(options) .setOutputTypes(outputTypes) .build(); } String parsePrint(String js, boolean prettyprint, boolean lineBreak, int lineThreshold, boolean outputTypes, boolean tagAsStrict) { CompilerOptions options = new CompilerOptions(); options.setTrustedStrings(trustedStrings); options.setPrettyPrint(prettyprint); options.setLineLengthThreshold(lineThreshold); options.setLineBreak(lineBreak); return new CodePrinter.Builder(parse(js, true)).setCompilerOptions(options) .setOutputTypes(outputTypes) .setTagAsStrict(tagAsStrict) .build(); } String printNode(Node n) { CompilerOptions options = new CompilerOptions(); options.setLineLengthThreshold(CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD); return new CodePrinter.Builder(n).setCompilerOptions(options).build(); } void assertPrintNode(String expectedJs, Node ast) { assertEquals(expectedJs, printNode(ast)); } public void testPrint() { assertPrint("10 + a + b", "10+a+b"); assertPrint("10 + (30*50)", "10+30*50"); assertPrint("with(x) { x + 3; }", "with(x)x+3"); assertPrint("\"aa'a\"", "\"aa'a\""); assertPrint("\"aa\\\"a\"", "'aa\"a'"); assertPrint("function foo()\n{return 10;}", "function foo(){return 10}"); assertPrint("a instanceof b", "a instanceof b"); assertPrint("typeof(a)", "typeof a"); assertPrint( "var foo = x ? { a : 1 } : {a: 3, b:4, \"default\": 5, \"foo-bar\": 6}", "var foo=x?{a:1}:{a:3,b:4,\"default\":5,\"foo-bar\":6}"); // Safari: needs ';' at the end of a throw statement assertPrint("function foo(){throw 'error';}", "function foo(){throw\"error\";}"); // Safari 3 needs a "{" around a single function assertPrint("if (true) function foo(){return}", "if(true){function foo(){return}}"); assertPrint("var x = 10; { var y = 20; }", "var x=10;var y=20"); assertPrint("while (x-- > 0);", "while(x-- >0);"); assertPrint("x-- >> 1", "x-- >>1"); assertPrint("(function () {})(); ", "(function(){})()"); // Associativity assertPrint("var a,b,c,d;a || (b&& c) && (a || d)", "var a,b,c,d;a||b&&c&&(a||d)"); assertPrint("var a,b,c; a || (b || c); a * (b * c); a | (b | c)", "var a,b,c;a||b||c;a*b*c;a|b|c"); assertPrint("var a,b,c; a / b / c;a / (b / c); a - (b - c);", "var a,b,c;a/b/c;a/(b/c);a-(b-c)"); assertPrint("var a,b; a = b = 3;", "var a,b;a=b=3"); assertPrint("var a,b,c,d; a = (b = c = (d = 3));", "var a,b,c,d;a=b=c=d=3"); assertPrint("var a,b,c; a += (b = c += 3);", "var a,b,c;a+=b=c+=3"); assertPrint("var a,b,c; a *= (b -= c);", "var a,b,c;a*=b-=c"); // Precedence assertPrint("a ? delete b[0] : 3", "a?delete b[0]:3"); assertPrint("(delete a[0])/10", "delete a[0]/10"); // optional '()' for new // simple new assertPrint("new A", "new A"); assertPrint("new A()", "new A"); assertPrint("new A('x')", "new A(\"x\")"); // calling instance method directly after new assertPrint("new A().a()", "(new A).a()"); assertPrint("(new A).a()", "(new A).a()"); // this case should be fixed assertPrint("new A('y').a()", "(new A(\"y\")).a()"); // internal class assertPrint("new A.B", "new A.B"); assertPrint("new A.B()", "new A.B"); assertPrint("new A.B('z')", "new A.B(\"z\")"); // calling instance method directly after new internal class assertPrint("(new A.B).a()", "(new A.B).a()"); assertPrint("new A.B().a()", "(new A.B).a()"); // this case should be fixed assertPrint("new A.B('w').a()", "(new A.B(\"w\")).a()"); // Operators: make sure we don't convert binary + and unary + into ++ assertPrint("x + +y", "x+ +y"); assertPrint("x - (-y)", "x- -y"); assertPrint("x++ +y", "x++ +y"); assertPrint("x-- -y", "x-- -y"); assertPrint("x++ -y", "x++-y"); // Label assertPrint("foo:for(;;){break foo;}", "foo:for(;;)break foo"); assertPrint("foo:while(1){continue foo;}", "foo:while(1)continue foo"); // Object literals. assertPrint("({})", "({})"); assertPrint("var x = {};", "var x={}"); assertPrint("({}).x", "({}).x"); assertPrint("({})['x']", "({})[\"x\"]"); assertPrint("({}) instanceof Object", "({})instanceof Object"); assertPrint("({}) || 1", "({})||1"); assertPrint("1 || ({})", "1||{}"); assertPrint("({}) ? 1 : 2", "({})?1:2"); assertPrint("0 ? ({}) : 2", "0?{}:2"); assertPrint("0 ? 1 : ({})", "0?1:{}"); assertPrint("typeof ({})", "typeof{}"); assertPrint("f({})", "f({})"); // Anonymous function expressions. assertPrint("(function(){})", "(function(){})"); assertPrint("(function(){})()", "(function(){})()"); assertPrint("(function(){})instanceof Object", "(function(){})instanceof Object"); assertPrint("(function(){}).bind().call()", "(function(){}).bind().call()"); assertPrint("var x = function() { };", "var x=function(){}"); assertPrint("var x = function() { }();", "var x=function(){}()"); assertPrint("(function() {}), 2", "(function(){}),2"); // Name functions expression. assertPrint("(function f(){})", "(function f(){})"); // Function declaration. assertPrint("function f(){}", "function f(){}"); // Make sure we don't treat non-Latin character escapes as raw strings. assertPrint("({ 'a': 4, '\\u0100': 4 })", "({\"a\":4,\"\\u0100\":4})"); assertPrint("({ a: 4, '\\u0100': 4 })", "({a:4,\"\\u0100\":4})"); // Test if statement and for statements with single statements in body. assertPrint("if (true) { alert();}", "if(true)alert()"); assertPrint("if (false) {} else {alert(\"a\");}", "if(false);else alert(\"a\")"); assertPrint("for(;;) { alert();};", "for(;;)alert()"); assertPrint("do { alert(); } while(true);", "do alert();while(true)"); assertPrint("myLabel: { alert();}", "myLabel:alert()"); assertPrint("myLabel: for(;;) continue myLabel;", "myLabel:for(;;)continue myLabel"); // Test nested var statement assertPrint("if (true) var x; x = 4;", "if(true)var x;x=4"); // Non-latin identifier. Make sure we keep them escaped. assertPrint("\\u00fb", "\\u00fb"); assertPrint("\\u00fa=1", "\\u00fa=1"); assertPrint("function \\u00f9(){}", "function \\u00f9(){}"); assertPrint("x.\\u00f8", "x.\\u00f8"); assertPrint("x.\\u00f8", "x.\\u00f8"); assertPrint("abc\\u4e00\\u4e01jkl", "abc\\u4e00\\u4e01jkl"); // Test the right-associative unary operators for spurious parens assertPrint("! ! true", "!!true"); assertPrint("!(!(true))", "!!true"); assertPrint("typeof(void(0))", "typeof void 0"); assertPrint("typeof(void(!0))", "typeof void!0"); assertPrint("+ - + + - + 3", "+-+ +-+3"); // chained unary plus/minus assertPrint("+(--x)", "+--x"); assertPrint("-(++x)", "-++x"); // needs a space to prevent an ambiguous parse assertPrint("-(--x)", "- --x"); assertPrint("!(~~5)", "!~~5"); assertPrint("~(a/b)", "~(a/b)"); // Preserve parens to overcome greedy binding of NEW assertPrint("new (foo.bar()).factory(baz)", "new (foo.bar().factory)(baz)"); assertPrint("new (bar()).factory(baz)", "new (bar().factory)(baz)"); assertPrint("new (new foobar(x)).factory(baz)", "new (new foobar(x)).factory(baz)"); // Make sure that HOOK is right associative assertPrint("a ? b : (c ? d : e)", "a?b:c?d:e"); assertPrint("a ? (b ? c : d) : e", "a?b?c:d:e"); assertPrint("(a ? b : c) ? d : e", "(a?b:c)?d:e"); // Test nested ifs assertPrint("if (x) if (y); else;", "if(x)if(y);else;"); // Test comma. assertPrint("a,b,c", "a,b,c"); assertPrint("(a,b),c", "a,b,c"); assertPrint("a,(b,c)", "a,b,c"); assertPrint("x=a,b,c", "x=a,b,c"); assertPrint("x=(a,b),c", "x=(a,b),c"); assertPrint("x=a,(b,c)", "x=a,b,c"); assertPrint("x=a,y=b,z=c", "x=a,y=b,z=c"); assertPrint("x=(a,y=b,z=c)", "x=(a,y=b,z=c)"); assertPrint("x=[a,b,c,d]", "x=[a,b,c,d]"); assertPrint("x=[(a,b,c),d]", "x=[(a,b,c),d]"); assertPrint("x=[(a,(b,c)),d]", "x=[(a,b,c),d]"); assertPrint("x=[a,(b,c,d)]", "x=[a,(b,c,d)]"); assertPrint("var x=(a,b)", "var x=(a,b)"); assertPrint("var x=a,b,c", "var x=a,b,c"); assertPrint("var x=(a,b),c", "var x=(a,b),c"); assertPrint("var x=a,b=(c,d)", "var x=a,b=(c,d)"); assertPrint("foo(a,b,c,d)", "foo(a,b,c,d)"); assertPrint("foo((a,b,c),d)", "foo((a,b,c),d)"); assertPrint("foo((a,(b,c)),d)", "foo((a,b,c),d)"); assertPrint("f(a+b,(c,d,(e,f,g)))", "f(a+b,(c,d,e,f,g))"); assertPrint("({}) , 1 , 2", "({}),1,2"); assertPrint("({}) , {} , {}", "({}),{},{}"); // EMPTY nodes assertPrint("if (x){}", "if(x);"); assertPrint("if(x);", "if(x);"); assertPrint("if(x)if(y);", "if(x)if(y);"); assertPrint("if(x){if(y);}", "if(x)if(y);"); assertPrint("if(x){if(y){};;;}", "if(x)if(y);"); assertPrint("if(x){;;function y(){};;}", "if(x){function y(){}}"); } public void testBreakTrustedStrings() { // Break scripts assertPrint("'<script>'", "\"<script>\""); assertPrint("'</script>'", "\"\\x3c/script>\""); assertPrint("\"</script> </SCRIPT>\"", "\"\\x3c/script> \\x3c/SCRIPT>\""); assertPrint("'-->'", "\"--\\x3e\""); assertPrint("']]>'", "\"]]\\x3e\""); assertPrint("' --></script>'", "\" --\\x3e\\x3c/script>\""); assertPrint("/--> <\\/script>/g", "/--\\x3e <\\/script>/g"); // Break HTML start comments. Certain versions of WebKit // begin an HTML comment when they see this. assertPrint("'<!-- I am a string -->'", "\"\\x3c!-- I am a string --\\x3e\""); assertPrint("'<=&>'", "\"<=&>\""); } public void testBreakUntrustedStrings() { trustedStrings = false; // Break scripts assertPrint("'<script>'", "\"\\x3cscript\\x3e\""); assertPrint("'</script>'", "\"\\x3c/script\\x3e\""); assertPrint("\"</script> </SCRIPT>\"", "\"\\x3c/script\\x3e \\x3c/SCRIPT\\x3e\""); assertPrint("'-->'", "\"--\\x3e\""); assertPrint("']]>'", "\"]]\\x3e\""); assertPrint("' --></script>'", "\" --\\x3e\\x3c/script\\x3e\""); assertPrint("/--> <\\/script>/g", "/--\\x3e <\\/script>/g"); // Break HTML start comments. Certain versions of WebKit // begin an HTML comment when they see this. assertPrint("'<!-- I am a string -->'", "\"\\x3c!-- I am a string --\\x3e\""); assertPrint("'<=&>'", "\"\\x3c\\x3d\\x26\\x3e\""); assertPrint("/(?=x)/", "/(?=x)/"); } public void testPrintArray() { assertPrint("[void 0, void 0]", "[void 0,void 0]"); assertPrint("[undefined, undefined]", "[undefined,undefined]"); assertPrint("[ , , , undefined]", "[,,,undefined]"); assertPrint("[ , , , 0]", "[,,,0]"); } public void testHook() { assertPrint("a ? b = 1 : c = 2", "a?b=1:c=2"); assertPrint("x = a ? b = 1 : c = 2", "x=a?b=1:c=2"); assertPrint("(x = a) ? b = 1 : c = 2", "(x=a)?b=1:c=2"); assertPrint("x, a ? b = 1 : c = 2", "x,a?b=1:c=2"); assertPrint("x, (a ? b = 1 : c = 2)", "x,a?b=1:c=2"); assertPrint("(x, a) ? b = 1 : c = 2", "(x,a)?b=1:c=2"); assertPrint("a ? (x, b) : c = 2", "a?(x,b):c=2"); assertPrint("a ? b = 1 : (x,c)", "a?b=1:(x,c)"); assertPrint("a ? b = 1 : c = 2 + x", "a?b=1:c=2+x"); assertPrint("(a ? b = 1 : c = 2) + x", "(a?b=1:c=2)+x"); assertPrint("a ? b = 1 : (c = 2) + x", "a?b=1:(c=2)+x"); assertPrint("a ? (b?1:2) : 3", "a?b?1:2:3"); } public void testPrintInOperatorInForLoop() { // Check for in expression in for's init expression. // Check alone, with + (higher precedence), with ?: (lower precedence), // and with conditional. assertPrint("var a={}; for (var i = (\"length\" in a); i;) {}", "var a={};for(var i=(\"length\"in a);i;);"); assertPrint("var a={}; for (var i = (\"length\" in a) ? 0 : 1; i;) {}", "var a={};for(var i=(\"length\"in a)?0:1;i;);"); assertPrint("var a={}; for (var i = (\"length\" in a) + 1; i;) {}", "var a={};for(var i=(\"length\"in a)+1;i;);"); assertPrint("var a={};for (var i = (\"length\" in a|| \"size\" in a);;);", "var a={};for(var i=(\"length\"in a)||(\"size\"in a);;);"); assertPrint("var a={};for (var i = a || a || (\"size\" in a);;);", "var a={};for(var i=a||a||(\"size\"in a);;);"); // Test works with unary operators and calls. assertPrint("var a={}; for (var i = -(\"length\" in a); i;) {}", "var a={};for(var i=-(\"length\"in a);i;);"); assertPrint("var a={};function b_(p){ return p;};" + "for(var i=1,j=b_(\"length\" in a);;) {}", "var a={};function b_(p){return p}" + "for(var i=1,j=b_(\"length\"in a);;);"); // Test we correctly handle an in operator in the test clause. assertPrint("var a={}; for (;(\"length\" in a);) {}", "var a={};for(;\"length\"in a;);"); } public void testLiteralProperty() { assertPrint("(64).toString()", "(64).toString()"); } private void assertPrint(String js, String expected) { parse(expected); // validate the expected string is valid JS assertEquals(expected, parsePrint(js, false, CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD)); } private void assertPrintSame(String js) { assertPrint(js, js); } // Make sure that the code generator doesn't associate an // else clause with the wrong if clause. public void testAmbiguousElseClauses() { assertPrintNode("if(x)if(y);else;", new Node(Token.IF, Node.newString(Token.NAME, "x"), new Node(Token.BLOCK, new Node(Token.IF, Node.newString(Token.NAME, "y"), new Node(Token.BLOCK), // ELSE clause for the inner if new Node(Token.BLOCK))))); assertPrintNode("if(x){if(y);}else;", new Node(Token.IF, Node.newString(Token.NAME, "x"), new Node(Token.BLOCK, new Node(Token.IF, Node.newString(Token.NAME, "y"), new Node(Token.BLOCK))), // ELSE clause for the outer if new Node(Token.BLOCK))); assertPrintNode("if(x)if(y);else{if(z);}else;", new Node(Token.IF, Node.newString(Token.NAME, "x"), new Node(Token.BLOCK, new Node(Token.IF, Node.newString(Token.NAME, "y"), new Node(Token.BLOCK), new Node(Token.BLOCK, new Node(Token.IF, Node.newString(Token.NAME, "z"), new Node(Token.BLOCK))))), // ELSE clause for the outermost if new Node(Token.BLOCK))); } public void testLineBreak() { // line break after function if in a statement context assertLineBreak("function a() {}\n" + "function b() {}", "function a(){}\n" + "function b(){}\n"); // line break after ; after a function assertLineBreak("var a = {};\n" + "a.foo = function () {}\n" + "function b() {}", "var a={};a.foo=function(){};\n" + "function b(){}\n"); // break after comma after a function assertLineBreak("var a = {\n" + " b: function() {},\n" + " c: function() {}\n" + "};\n" + "alert(a);", "var a={b:function(){},\n" + "c:function(){}};\n" + "alert(a)"); } private void assertLineBreak(String js, String expected) { assertEquals(expected, parsePrint(js, false, true, CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD)); } public void testPreferLineBreakAtEndOfFile() { // short final line, no previous break, do nothing assertLineBreakAtEndOfFile( "\"1234567890\";", "\"1234567890\"", "\"1234567890\""); // short final line, shift previous break to end assertLineBreakAtEndOfFile( "\"123456789012345678901234567890\";\"1234567890\"", "\"123456789012345678901234567890\";\n\"1234567890\"", "\"123456789012345678901234567890\"; \"1234567890\";\n"); assertLineBreakAtEndOfFile( "var12345678901234567890123456 instanceof Object;", "var12345678901234567890123456 instanceof\nObject", "var12345678901234567890123456 instanceof Object;\n"); // long final line, no previous break, add a break at end assertLineBreakAtEndOfFile( "\"1234567890\";\"12345678901234567890\";", "\"1234567890\";\"12345678901234567890\"", "\"1234567890\";\"12345678901234567890\";\n"); // long final line, previous break, add a break at end assertLineBreakAtEndOfFile( "\"123456789012345678901234567890\";\"12345678901234567890\";", "\"123456789012345678901234567890\";\n\"12345678901234567890\"", "\"123456789012345678901234567890\";\n\"12345678901234567890\";\n"); } private void assertLineBreakAtEndOfFile(String js, String expectedWithoutBreakAtEnd, String expectedWithBreakAtEnd) { assertEquals(expectedWithoutBreakAtEnd, parsePrint(js, false, false, false, 30)); assertEquals(expectedWithBreakAtEnd, parsePrint(js, false, false, true, 30)); } public void testPrettyPrinter() { // Ensure that the pretty printer inserts line breaks at appropriate // places. assertPrettyPrint("(function(){})();","(function() {\n})();\n"); assertPrettyPrint("var a = (function() {});alert(a);", "var a = function() {\n};\nalert(a);\n"); // Check we correctly handle putting brackets around all if clauses so // we can put breakpoints inside statements. assertPrettyPrint("if (1) {}", "if(1) {\n" + "}\n"); assertPrettyPrint("if (1) {alert(\"\");}", "if(1) {\n" + " alert(\"\")\n" + "}\n"); assertPrettyPrint("if (1)alert(\"\");", "if(1) {\n" + " alert(\"\")\n" + "}\n"); assertPrettyPrint("if (1) {alert();alert();}", "if(1) {\n" + " alert();\n" + " alert()\n" + "}\n"); // Don't add blocks if they weren't there already. assertPrettyPrint("label: alert();", "label:alert();\n"); // But if statements and loops get blocks automagically. assertPrettyPrint("if (1) alert();", "if(1) {\n" + " alert()\n" + "}\n"); assertPrettyPrint("for (;;) alert();", "for(;;) {\n" + " alert()\n" + "}\n"); assertPrettyPrint("while (1) alert();", "while(1) {\n" + " alert()\n" + "}\n"); // Do we put else clauses in blocks? assertPrettyPrint("if (1) {} else {alert(a);}", "if(1) {\n" + "}else {\n alert(a)\n}\n"); // Do we add blocks to else clauses? assertPrettyPrint("if (1) alert(a); else alert(b);", "if(1) {\n" + " alert(a)\n" + "}else {\n" + " alert(b)\n" + "}\n"); // Do we put for bodies in blocks? assertPrettyPrint("for(;;) { alert();}", "for(;;) {\n" + " alert()\n" + "}\n"); assertPrettyPrint("for(;;) {}", "for(;;) {\n" + "}\n"); assertPrettyPrint("for(;;) { alert(); alert(); }", "for(;;) {\n" + " alert();\n" + " alert()\n" + "}\n"); // How about do loops? assertPrettyPrint("do { alert(); } while(true);", "do {\n" + " alert()\n" + "}while(true);\n"); // label? assertPrettyPrint("myLabel: { alert();}", "myLabel: {\n" + " alert()\n" + "}\n"); // Don't move the label on a loop, because then break {label} and // continue {label} won't work. assertPrettyPrint("myLabel: for(;;) continue myLabel;", "myLabel:for(;;) {\n" + " continue myLabel\n" + "}\n"); assertPrettyPrint("var a;", "var a;\n"); } public void testPrettyPrinter2() { assertPrettyPrint( "if(true) f();", "if(true) {\n" + " f()\n" + "}\n"); assertPrettyPrint( "if (true) { f() } else { g() }", "if(true) {\n" + " f()\n" + "}else {\n" + " g()\n" + "}\n"); assertPrettyPrint( "if(true) f(); for(;;) g();", "if(true) {\n" + " f()\n" + "}\n" + "for(;;) {\n" + " g()\n" + "}\n"); } public void testPrettyPrinter3() { assertPrettyPrint( "try {} catch(e) {}if (1) {alert();alert();}", "try {\n" + "}catch(e) {\n" + "}\n" + "if(1) {\n" + " alert();\n" + " alert()\n" + "}\n"); assertPrettyPrint( "try {} finally {}if (1) {alert();alert();}", "try {\n" + "}finally {\n" + "}\n" + "if(1) {\n" + " alert();\n" + " alert()\n" + "}\n"); assertPrettyPrint( "try {} catch(e) {} finally {} if (1) {alert();alert();}", "try {\n" + "}catch(e) {\n" + "}finally {\n" + "}\n" + "if(1) {\n" + " alert();\n" + " alert()\n" + "}\n"); } public void testPrettyPrinter4() { assertPrettyPrint( "function f() {}if (1) {alert();}", "function f() {\n" + "}\n" + "if(1) {\n" + " alert()\n" + "}\n"); assertPrettyPrint( "var f = function() {};if (1) {alert();}", "var f = function() {\n" + "};\n" + "if(1) {\n" + " alert()\n" + "}\n"); assertPrettyPrint( "(function() {})();if (1) {alert();}", "(function() {\n" + "})();\n" + "if(1) {\n" + " alert()\n" + "}\n"); assertPrettyPrint( "(function() {alert();alert();})();if (1) {alert();}", "(function() {\n" + " alert();\n" + " alert()\n" + "})();\n" + "if(1) {\n" + " alert()\n" + "}\n"); } public void testTypeAnnotations() { assertTypeAnnotations( "/** @constructor */ function Foo(){}", "/**\n * @return {undefined}\n * @constructor\n */\n" + "function Foo() {\n}\n"); } public void testTypeAnnotationsTypeDef() { // TODO(johnlenz): It would be nice if there were some way to preserve // typedefs but currently they are resolved into the basic types in the // type registry. assertTypeAnnotations( "/** @typedef {Array.<number>} */ goog.java.Long;\n" + "/** @param {!goog.java.Long} a*/\n" + "function f(a){};\n", "goog.java.Long;\n" + "/**\n" + " * @param {(Array.<number>|null)} a\n" + " * @return {undefined}\n" + " */\n" + "function f(a) {\n}\n"); } public void testTypeAnnotationsAssign() { assertTypeAnnotations("/** @constructor */ var Foo = function(){}", "/**\n * @return {undefined}\n * @constructor\n */\n" + "var Foo = function() {\n};\n"); } public void testTypeAnnotationsNamespace() { assertTypeAnnotations("var a = {};" + "/** @constructor */ a.Foo = function(){}", "var a = {};\n" + "/**\n * @return {undefined}\n * @constructor\n */\n" + "a.Foo = function() {\n};\n"); } public void testTypeAnnotationsMemberSubclass() { assertTypeAnnotations("var a = {};" + "/** @constructor */ a.Foo = function(){};" + "/** @constructor \n @extends {a.Foo} */ a.Bar = function(){}", "var a = {};\n" + "/**\n * @return {undefined}\n * @constructor\n */\n" + "a.Foo = function() {\n};\n" + "/**\n * @return {undefined}\n * @extends {a.Foo}\n" + " * @constructor\n */\n" + "a.Bar = function() {\n};\n"); } public void testTypeAnnotationsInterface() { assertTypeAnnotations("var a = {};" + "/** @interface */ a.Foo = function(){};" + "/** @interface \n @extends {a.Foo} */ a.Bar = function(){}", "var a = {};\n" + "/**\n * @interface\n */\n" + "a.Foo = function() {\n};\n" + "/**\n * @extends {a.Foo}\n" + " * @interface\n */\n" + "a.Bar = function() {\n};\n"); } public void testTypeAnnotationsMultipleInterface() { assertTypeAnnotations("var a = {};" + "/** @interface */ a.Foo1 = function(){};" + "/** @interface */ a.Foo2 = function(){};" + "/** @interface \n @extends {a.Foo1} \n @extends {a.Foo2} */" + "a.Bar = function(){}", "var a = {};\n" + "/**\n * @interface\n */\n" + "a.Foo1 = function() {\n};\n" + "/**\n * @interface\n */\n" + "a.Foo2 = function() {\n};\n" + "/**\n * @extends {a.Foo1}\n" + " * @extends {a.Foo2}\n" + " * @interface\n */\n" + "a.Bar = function() {\n};\n"); } public void testTypeAnnotationsMember() { assertTypeAnnotations("var a = {};" + "/** @constructor */ a.Foo = function(){}" + "/** @param {string} foo\n" + " * @return {number} */\n" + "a.Foo.prototype.foo = function(foo) { return 3; };" + "/** @type {string|undefined} */" + "a.Foo.prototype.bar = '';", "var a = {};\n" + "/**\n * @return {undefined}\n * @constructor\n */\n" + "a.Foo = function() {\n};\n" + "/**\n" + " * @param {string} foo\n" + " * @return {number}\n" + " */\n" + "a.Foo.prototype.foo = function(foo) {\n return 3\n};\n" + "/** @type {string} */\n" + "a.Foo.prototype.bar = \"\";\n"); } public void testTypeAnnotationsImplements() { assertTypeAnnotations("var a = {};" + "/** @constructor */ a.Foo = function(){};\n" + "/** @interface */ a.I = function(){};\n" + "/** @interface */ a.I2 = function(){};\n" + "/** @constructor \n @extends {a.Foo}\n" + " * @implements {a.I} \n @implements {a.I2}\n" + "*/ a.Bar = function(){}", "var a = {};\n" + "/**\n * @return {undefined}\n * @constructor\n */\n" + "a.Foo = function() {\n};\n" + "/**\n * @interface\n */\n" + "a.I = function() {\n};\n" + "/**\n * @interface\n */\n" + "a.I2 = function() {\n};\n" + "/**\n * @return {undefined}\n * @extends {a.Foo}\n" + " * @implements {a.I}\n" + " * @implements {a.I2}\n * @constructor\n */\n" + "a.Bar = function() {\n};\n"); } public void testTypeAnnotationsDispatcher1() { assertTypeAnnotations( "var a = {};\n" + "/** \n" + " * @constructor \n" + " * @javadispatch \n" + " */\n" + "a.Foo = function(){}", "var a = {};\n" + "/**\n" + " * @return {undefined}\n" + " * @constructor\n" + " * @javadispatch\n" + " */\n" + "a.Foo = function() {\n" + "};\n"); } public void testTypeAnnotationsDispatcher2() { assertTypeAnnotations( "var a = {};\n" + "/** \n" + " * @constructor \n" + " */\n" + "a.Foo = function(){}\n" + "/**\n" + " * @javadispatch\n" + " */\n" + "a.Foo.prototype.foo = function() {};", "var a = {};\n" + "/**\n" + " * @return {undefined}\n" + " * @constructor\n" + " */\n" + "a.Foo = function() {\n" + "};\n" + "/**\n" + " * @return {undefined}\n" + " * @javadispatch\n" + " */\n" + "a.Foo.prototype.foo = function() {\n" + "};\n"); } public void testU2UFunctionTypeAnnotation() { assertTypeAnnotations( "/** @type {!Function} */ var x = function() {}", "/**\n * @constructor\n */\nvar x = function() {\n};\n"); } public void testEmitUnknownParamTypesAsAllType() { assertTypeAnnotations( "var a = function(x) {}", "/**\n" + " * @param {*} x\n" + " * @return {undefined}\n" + " */\n" + "var a = function(x) {\n};\n"); } public void testOptionalTypesAnnotation() { assertTypeAnnotations( "/**\n" + " * @param {string=} x \n" + " */\n" + "var a = function(x) {}", "/**\n" + " * @param {string=} x\n" + " * @return {undefined}\n" + " */\n" + "var a = function(x) {\n};\n"); } public void testVariableArgumentsTypesAnnotation() { assertTypeAnnotations( "/**\n" + " * @param {...string} x \n" + " */\n" + "var a = function(x) {}", "/**\n" + " * @param {...string} x\n" + " * @return {undefined}\n" + " */\n" + "var a = function(x) {\n};\n"); } public void testTempConstructor() { assertTypeAnnotations( "var x = function() {\n/**\n * @constructor\n */\nfunction t1() {}\n" + " /**\n * @constructor\n */\nfunction t2() {}\n" + " t1.prototype = t2.prototype}", "/**\n * @return {undefined}\n */\nvar x = function() {\n" + " /**\n * @return {undefined}\n * @constructor\n */\n" + "function t1() {\n }\n" + " /**\n * @return {undefined}\n * @constructor\n */\n" + "function t2() {\n }\n" + " t1.prototype = t2.prototype\n};\n" ); } public void testEnumAnnotation1() { assertTypeAnnotations( "/** @enum {string} */ var Enum = {FOO: 'x', BAR: 'y'};", "/** @enum {string} */\nvar Enum = {FOO:\"x\", BAR:\"y\"};\n"); } public void testEnumAnnotation2() { assertTypeAnnotations( "var goog = goog || {};" + "/** @enum {string} */ goog.Enum = {FOO: 'x', BAR: 'y'};" + "/** @const */ goog.Enum2 = goog.x ? {} : goog.Enum;", "var goog = goog || {};\n" + "/** @enum {string} */\ngoog.Enum = {FOO:\"x\", BAR:\"y\"};\n" + "/** @type {(Object|{})} */\ngoog.Enum2 = goog.x ? {} : goog.Enum;\n"); } private void assertPrettyPrint(String js, String expected) { assertEquals(expected, parsePrint(js, true, false, CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD)); } private void assertTypeAnnotations(String js, String expected) { assertEquals(expected, parsePrint(js, true, false, CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD, true)); } public void testSubtraction() { Compiler compiler = new Compiler(); Node n = compiler.parseTestCode("x - -4"); assertEquals(0, compiler.getErrorCount()); assertEquals( "x- -4", printNode(n)); } public void testFunctionWithCall() { assertPrint( "var user = new function() {" + "alert(\"foo\")}", "var user=new function(){" + "alert(\"foo\")}"); assertPrint( "var user = new function() {" + "this.name = \"foo\";" + "this.local = function(){alert(this.name)};}", "var user=new function(){" + "this.name=\"foo\";" + "this.local=function(){alert(this.name)}}"); } public void testLineLength() { // list assertLineLength("var aba,bcb,cdc", "var aba,bcb," + "\ncdc"); // operators, and two breaks assertLineLength( "\"foo\"+\"bar,baz,bomb\"+\"whee\"+\";long-string\"\n+\"aaa\"", "\"foo\"+\"bar,baz,bomb\"+" + "\n\"whee\"+\";long-string\"+" + "\n\"aaa\""); // assignment assertLineLength("var abazaba=1234", "var abazaba=" + "\n1234"); // statements assertLineLength("var abab=1;var bab=2", "var abab=1;" + "\nvar bab=2"); // don't break regexes assertLineLength("var a=/some[reg](ex),with.*we?rd|chars/i;var b=a", "var a=/some[reg](ex),with.*we?rd|chars/i;" + "\nvar b=a"); // don't break strings assertLineLength("var a=\"foo,{bar};baz\";var b=a", "var a=\"foo,{bar};baz\";" + "\nvar b=a"); // don't break before post inc/dec assertLineLength("var a=\"a\";a++;var b=\"bbb\";", "var a=\"a\";a++;\n" + "var b=\"bbb\""); } private void assertLineLength(String js, String expected) { assertEquals(expected, parsePrint(js, false, true, 10)); } public void testParsePrintParse() { testReparse("3;"); testReparse("var a = b;"); testReparse("var x, y, z;"); testReparse("try { foo() } catch(e) { bar() }"); testReparse("try { foo() } catch(e) { bar() } finally { stuff() }"); testReparse("try { foo() } finally { stuff() }"); testReparse("throw 'me'"); testReparse("function foo(a) { return a + 4; }"); testReparse("function foo() { return; }"); testReparse("var a = function(a, b) { foo(); return a + b; }"); testReparse("b = [3, 4, 'paul', \"Buchhe it\",,5];"); testReparse("v = (5, 6, 7, 8)"); testReparse("d = 34.0; x = 0; y = .3; z = -22"); testReparse("d = -x; t = !x + ~y;"); testReparse("'hi'; /* just a test */ stuff(a,b) \n" + " foo(); // and another \n" + " bar();"); testReparse("a = b++ + ++c; a = b++-++c; a = - --b; a = - ++b;"); testReparse("a++; b= a++; b = ++a; b = a--; b = --a; a+=2; b-=5"); testReparse("a = (2 + 3) * 4;"); testReparse("a = 1 + (2 + 3) + 4;"); testReparse("x = a ? b : c; x = a ? (b,3,5) : (foo(),bar());"); testReparse("a = b | c || d ^ e " + "&& f & !g != h << i <= j < k >>> l > m * n % !o"); testReparse("a == b; a != b; a === b; a == b == a;" + " (a == b) == a; a == (b == a);"); testReparse("if (a > b) a = b; if (b < 3) a = 3; else c = 4;"); testReparse("if (a == b) { a++; } if (a == 0) { a++; } else { a --; }"); testReparse("for (var i in a) b += i;"); testReparse("for (var i = 0; i < 10; i++){ b /= 2;" + " if (b == 2)break;else continue;}"); testReparse("for (x = 0; x < 10; x++) a /= 2;"); testReparse("for (;;) a++;"); testReparse("while(true) { blah(); }while(true) blah();"); testReparse("do stuff(); while(a>b);"); testReparse("[0, null, , true, false, this];"); testReparse("s.replace(/absc/, 'X').replace(/ab/gi, 'Y');"); testReparse("new Foo; new Bar(a, b,c);"); testReparse("with(foo()) { x = z; y = t; } with(bar()) a = z;"); testReparse("delete foo['bar']; delete foo;"); testReparse("var x = { 'a':'paul', 1:'3', 2:(3,4) };"); testReparse("switch(a) { case 2: case 3: stuff(); break;" + "case 4: morestuff(); break; default: done();}"); testReparse("x = foo['bar'] + foo['my stuff'] + foo[bar] + f.stuff;"); testReparse("a.v = b.v; x['foo'] = y['zoo'];"); testReparse("'test' in x; 3 in x; a in x;"); testReparse("'foo\"bar' + \"foo'c\" + 'stuff\\n and \\\\more'"); testReparse("x.__proto__;"); } private void testReparse(String code) { Compiler compiler = new Compiler(); Node parse1 = parse(code); Node parse2 = parse(new CodePrinter.Builder(parse1).build()); String explanation = parse1.checkTreeEquals(parse2); assertNull("\nExpected: " + compiler.toSource(parse1) + "\nResult: " + compiler.toSource(parse2) + "\n" + explanation, explanation); } public void testDoLoopIECompatiblity() { // Do loops within IFs cause syntax errors in IE6 and IE7. assertPrint("function f(){if(e1){do foo();while(e2)}else foo()}", "function f(){if(e1){do foo();while(e2)}else foo()}"); assertPrint("function f(){if(e1)do foo();while(e2)else foo()}", "function f(){if(e1){do foo();while(e2)}else foo()}"); assertPrint("if(x){do{foo()}while(y)}else bar()", "if(x){do foo();while(y)}else bar()"); assertPrint("if(x)do{foo()}while(y);else bar()", "if(x){do foo();while(y)}else bar()"); assertPrint("if(x){do{foo()}while(y)}", "if(x){do foo();while(y)}"); assertPrint("if(x)do{foo()}while(y);", "if(x){do foo();while(y)}"); assertPrint("if(x)A:do{foo()}while(y);", "if(x){A:do foo();while(y)}"); assertPrint("var i = 0;a: do{b: do{i++;break b;} while(0);} while(0);", "var i=0;a:do{b:do{i++;break b}while(0)}while(0)"); } public void testFunctionSafariCompatiblity() { // Functions within IFs cause syntax errors on Safari. assertPrint("function f(){if(e1){function goo(){return true}}else foo()}", "function f(){if(e1){function goo(){return true}}else foo()}"); assertPrint("function f(){if(e1)function goo(){return true}else foo()}", "function f(){if(e1){function goo(){return true}}else foo()}"); assertPrint("if(e1){function goo(){return true}}", "if(e1){function goo(){return true}}"); assertPrint("if(e1)function goo(){return true}", "if(e1){function goo(){return true}}"); assertPrint("if(e1)A:function goo(){return true}", "if(e1){A:function goo(){return true}}"); } public void testExponents() { assertPrintNumber("1", 1); assertPrintNumber("10", 10); assertPrintNumber("100", 100); assertPrintNumber("1E3", 1000); assertPrintNumber("1E4", 10000); assertPrintNumber("1E5", 100000); assertPrintNumber("-1", -1); assertPrintNumber("-10", -10); assertPrintNumber("-100", -100); assertPrintNumber("-1E3", -1000); assertPrintNumber("-12341234E4", -123412340000L); assertPrintNumber("1E18", 1000000000000000000L); assertPrintNumber("1E5", 100000.0); assertPrintNumber("100000.1", 100000.1); assertPrintNumber("1E-6", 0.000001); assertPrintNumber("-0x38d7ea4c68001", -0x38d7ea4c68001L); assertPrintNumber("0x38d7ea4c68001", 0x38d7ea4c68001L); } // Make sure to test as both a String and a Node, because // negative numbers do not parse consistently from strings. private void assertPrintNumber(String expected, double number) { assertPrint(String.valueOf(number), expected); assertPrintNode(expected, Node.newNumber(number)); } private void assertPrintNumber(String expected, int number) { assertPrint(String.valueOf(number), expected); assertPrintNode(expected, Node.newNumber(number)); } public void testDirectEval() { assertPrint("eval('1');", "eval(\"1\")"); } public void testIndirectEval() { Node n = parse("eval('1');"); assertPrintNode("eval(\"1\")", n); n.getFirstChild().getFirstChild().getFirstChild().putBooleanProp( Node.DIRECT_EVAL, false); assertPrintNode("(0,eval)(\"1\")", n); } public void testFreeCall1() { assertPrint("foo(a);", "foo(a)"); assertPrint("x.foo(a);", "x.foo(a)"); } public void testFreeCall2() { Node n = parse("foo(a);"); assertPrintNode("foo(a)", n); Node call = n.getFirstChild().getFirstChild(); assertTrue(call.isCall()); call.putBooleanProp(Node.FREE_CALL, true); assertPrintNode("foo(a)", n); } public void testFreeCall3() { Node n = parse("x.foo(a);"); assertPrintNode("x.foo(a)", n); Node call = n.getFirstChild().getFirstChild(); assertTrue(call.isCall()); call.putBooleanProp(Node.FREE_CALL, true); assertPrintNode("(0,x.foo)(a)", n); } public void testPrintScript() { // Verify that SCRIPT nodes not marked as synthetic are printed as // blocks. Node ast = new Node(Token.SCRIPT, new Node(Token.EXPR_RESULT, Node.newString("f")), new Node(Token.EXPR_RESULT, Node.newString("g"))); String result = new CodePrinter.Builder(ast).setPrettyPrint(true).build(); assertEquals("\"f\";\n\"g\";\n", result); } public void testObjectLit() { assertPrint("({x:1})", "({x:1})"); assertPrint("var x=({x:1})", "var x={x:1}"); assertPrint("var x={'x':1}", "var x={\"x\":1}"); assertPrint("var x={1:1}", "var x={1:1}"); assertPrint("({},42)+0", "({},42)+0"); } public void testObjectLit2() { assertPrint("var x={1:1}", "var x={1:1}"); assertPrint("var x={'1':1}", "var x={1:1}"); assertPrint("var x={'1.0':1}", "var x={\"1.0\":1}"); assertPrint("var x={1.5:1}", "var x={\"1.5\":1}"); } public void testObjectLit3() { assertPrint("var x={3E9:1}", "var x={3E9:1}"); assertPrint("var x={'3000000000':1}", // More than 31 bits "var x={3E9:1}"); assertPrint("var x={'3000000001':1}", "var x={3000000001:1}"); assertPrint("var x={'6000000001':1}", // More than 32 bits "var x={6000000001:1}"); assertPrint("var x={\"12345678901234567\":1}", // More than 53 bits "var x={\"12345678901234567\":1}"); } public void testObjectLit4() { // More than 128 bits. assertPrint( "var x={\"123456789012345671234567890123456712345678901234567\":1}", "var x={\"123456789012345671234567890123456712345678901234567\":1}"); } public void testGetter() { assertPrint("var x = {}", "var x={}"); assertPrint("var x = {get a() {return 1}}", "var x={get a(){return 1}}"); assertPrint( "var x = {get a() {}, get b(){}}", "var x={get a(){},get b(){}}"); assertPrint( "var x = {get 'a'() {return 1}}", "var x={get \"a\"(){return 1}}"); assertPrint( "var x = {get 1() {return 1}}", "var x={get 1(){return 1}}"); assertPrint( "var x = {get \"()\"() {return 1}}", "var x={get \"()\"(){return 1}}"); } public void testSetter() { assertPrint("var x = {}", "var x={}"); assertPrint( "var x = {set a(y) {return 1}}", "var x={set a(y){return 1}}"); assertPrint( "var x = {get 'a'() {return 1}}", "var x={get \"a\"(){return 1}}"); assertPrint( "var x = {set 1(y) {return 1}}", "var x={set 1(y){return 1}}"); assertPrint( "var x = {set \"(x)\"(y) {return 1}}", "var x={set \"(x)\"(y){return 1}}"); } public void testNegCollapse() { // Collapse the negative symbol on numbers at generation time, // to match the Rhino behavior. assertPrint("var x = - - 2;", "var x=2"); assertPrint("var x = - (2);", "var x=-2"); } public void testStrict() { String result = parsePrint("var x", false, false, 0, false, true); assertEquals("'use strict';var x", result); } public void testArrayLiteral() { assertPrint("var x = [,];","var x=[,]"); assertPrint("var x = [,,];","var x=[,,]"); assertPrint("var x = [,s,,];","var x=[,s,,]"); assertPrint("var x = [,s];","var x=[,s]"); assertPrint("var x = [s,];","var x=[s]"); } public void testZero() { assertPrint("var x ='\\0';", "var x=\"\\x00\""); assertPrint("var x ='\\x00';", "var x=\"\\x00\""); assertPrint("var x ='\\u0000';", "var x=\"\\x00\""); assertPrint("var x ='\\u00003';", "var x=\"\\x003\""); } public void testUnicode() { assertPrint("var x ='\\x0f';", "var x=\"\\u000f\""); assertPrint("var x ='\\x68';", "var x=\"h\""); assertPrint("var x ='\\x7f';", "var x=\"\\u007f\""); } public void testUnicodeKeyword() { // keyword "if" assertPrint("var \\u0069\\u0066 = 1;", "var i\\u0066=1"); // keyword "var" assertPrint("var v\\u0061\\u0072 = 1;", "var va\\u0072=1"); // all are keyword "while" assertPrint("var w\\u0068\\u0069\\u006C\\u0065 = 1;" + "\\u0077\\u0068il\\u0065 = 2;" + "\\u0077h\\u0069le = 3;", "var whil\\u0065=1;whil\\u0065=2;whil\\u0065=3"); } public void testNumericKeys() { assertPrint("var x = {010: 1};", "var x={8:1}"); assertPrint("var x = {'010': 1};", "var x={\"010\":1}"); assertPrint("var x = {0x10: 1};", "var x={16:1}"); assertPrint("var x = {'0x10': 1};", "var x={\"0x10\":1}"); // I was surprised at this result too. assertPrint("var x = {.2: 1};", "var x={\"0.2\":1}"); assertPrint("var x = {'.2': 1};", "var x={\".2\":1}"); assertPrint("var x = {0.2: 1};", "var x={\"0.2\":1}"); assertPrint("var x = {'0.2': 1};", "var x={\"0.2\":1}"); } public void testIssue582() { assertPrint("var x = -0.0;", "var x=-0"); } public void testIssue601() { assertPrint("'\\v' == 'v'", "\"\\v\"==\"v\""); assertPrint("'\\u000B' == '\\v'", "\"\\x0B\"==\"\\v\""); assertPrint("'\\x0B' == '\\v'", "\"\\x0B\"==\"\\v\""); } public void testIssue620() { assertPrint("alert(/ / / / /);", "alert(/ // / /)"); assertPrint("alert(/ // / /);", "alert(/ // / /)"); } public void testIssue5746867() { assertPrint("var a = { '$\\\\' : 5 };", "var a={\"$\\\\\":5}"); } public void testCommaSpacing() { assertPrint("var a = (b = 5, c = 5);", "var a=(b=5,c=5)"); assertPrettyPrint("var a = (b = 5, c = 5);", "var a = (b = 5, c = 5);\n"); } public void testManyCommas() { int numCommas = 10000; List<String> numbers = Lists.newArrayList("0", "1"); Node current = new Node(Token.COMMA, Node.newNumber(0), Node.newNumber(1)); for (int i = 2; i < numCommas; i++) { current = new Node(Token.COMMA, current); // 1000 is printed as 1E3, and screws up our test. int num = i % 1000; numbers.add(String.valueOf(num)); current.addChildToBack(Node.newNumber(num)); } String expected = Joiner.on(",").join(numbers); String actual = printNode(current).replace("\n", ""); assertEquals(expected, actual); } public void testManyAdds() { int numAdds = 10000; List<String> numbers = Lists.newArrayList("0", "1"); Node current = new Node(Token.ADD, Node.newNumber(0), Node.newNumber(1)); for (int i = 2; i < numAdds; i++) { current = new Node(Token.ADD, current); // 1000 is printed as 1E3, and screws up our test. int num = i % 1000; numbers.add(String.valueOf(num)); current.addChildToBack(Node.newNumber(num)); } String expected = Joiner.on("+").join(numbers); String actual = printNode(current).replace("\n", ""); assertEquals(expected, actual); } public void testMinusNegativeZero() { // Negative zero is weird, because we have to be able to distinguish // it from positive zero (there are some subtle differences in behavior). assertPrint("x- -0", "x- -0"); } public void testStringEscapeSequences() { // From the SingleEscapeCharacter grammar production. assertPrintSame("var x=\"\\b\""); assertPrintSame("var x=\"\\f\""); assertPrintSame("var x=\"\\n\""); assertPrintSame("var x=\"\\r\""); assertPrintSame("var x=\"\\t\""); assertPrintSame("var x=\"\\v\""); assertPrint("var x=\"\\\"\"", "var x='\"'"); assertPrint("var x=\"\\\'\"", "var x=\"'\""); // From the LineTerminator grammar assertPrint("var x=\"\\u000A\"", "var x=\"\\n\""); assertPrint("var x=\"\\u000D\"", "var x=\"\\r\""); assertPrintSame("var x=\"\\u2028\""); assertPrintSame("var x=\"\\u2029\""); // Now with regular expressions. assertPrintSame("var x=/\\b/"); assertPrintSame("var x=/\\f/"); assertPrintSame("var x=/\\n/"); assertPrintSame("var x=/\\r/"); assertPrintSame("var x=/\\t/"); assertPrintSame("var x=/\\v/"); assertPrintSame("var x=/\\u000A/"); assertPrintSame("var x=/\\u000D/"); assertPrintSame("var x=/\\u2028/"); assertPrintSame("var x=/\\u2029/"); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Tests for {@link CollapseAnonymousFunctions} * */ public class CollapseAnonymousFunctionsTest extends CompilerTestCase { public CollapseAnonymousFunctionsTest() { this.enableNormalize(); } @Override protected CompilerPass getProcessor(Compiler compiler) { return new CollapseAnonymousFunctions(compiler); } public void testGlobalScope() { test("var f = function(){}", "function f(){}"); } public void testLocalScope1() { test("function f(){ var x = function(){}; x() }", "function f(){ function x(){} x() }"); } public void testLocalScope2() { test("function f(){ var x = function(){}; return x }", "function f(){ function x(){} return x }"); } public void testVarNotImmediatelyBelowScriptOrBlock1() { testSame("if (x) var f = function(){}"); } public void testVarNotImmediatelyBelowScriptOrBlock2() { testSame("var x = 1;" + "if (x == 1) {" + " var f = function () { alert('b')}" + "} else {" + " f = function() { alert('c')}" + "}" + "f();"); } public void testVarNotImmediatelyBelowScriptOrBlock3() { testSame("var x = 1; if (x) {var f = function(){return x}; f(); x--;}"); } public void testMultipleVar() { test("var f = function(){}; var g = f", "function f(){} var g = f"); } public void testMultipleVar2() { test("var f = function(){}; var g = f; var h = function(){}", "function f(){}var g = f;function h(){}"); } public void testBothScopes() { test("var x = function() { var y = function(){} }", "function x() { function y(){} }"); } public void testLocalScopeOnly1() { test("if (x) var f = function(){ var g = function(){} }", "if (x) var f = function(){ function g(){} }"); } public void testLocalScopeOnly2() { test("if (x) var f = function(){ var g = function(){} };", "if (x) var f = function(){ function g(){} }"); } public void testReturn() { test("var f = function(x){return 2*x}; var g = f(2);", "function f(x){return 2*x} var g = f(2)"); } public void testAlert() { test("var x = 1; var f = function(){alert(x)};", "var x = 1; function f(){alert(x)}"); } public void testRecursiveInternal1() { testSame("var f = function foo() { foo() }"); } public void testRecursiveInternal2() { testSame("var f = function foo() { function g(){foo()} g() }"); } public void testRecursiveExternal1() { test("var f = function foo() { f() }", "function f() { f() }"); } public void testRecursiveExternal2() { test("var f = function foo() { function g(){f()} g() }", "function f() { function g(){f()} g() }"); } public void testConstantFunction1() { test("var FOO = function(){};FOO()", "function FOO(){}FOO()"); } public void testInnerFunction1() { test( "function f() { " + " var x = 3; var y = function() { return 4; }; return x + y();" + "}", "function f() { " + " function y() { return 4; } var x = 3; return x + y();" + "}"); } }
/* * Copyright 2006 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import static com.google.javascript.jscomp.CollapseProperties.UNSAFE_THIS; import com.google.javascript.rhino.Node; /** * Tests for {@link CollapseProperties}. * */ public class CollapsePropertiesTest extends CompilerTestCase { private static String EXTERNS = "var window; function alert(s) {} function parseInt(s) {}" + "/** @constructor */ function String() {}"; private boolean collapsePropertiesOnExternTypes = false; public CollapsePropertiesTest() { super(EXTERNS); } @Override public CompilerPass getProcessor(Compiler compiler) { return new CollapseProperties( compiler, collapsePropertiesOnExternTypes, true); } @Override public void setUp() { enableLineNumberCheck(true); enableNormalize(true); } @Override public int getNumRepetitions() { return 1; } public void testCollapse() { test("var a = {}; a.b = {}; var c = a.b;", "var a$b = {}; var c = a$b"); } public void testMultiLevelCollapse() { test("var a = {}; a.b = {}; a.b.c = {}; var d = a.b.c;", "var a$b$c = {}; var d = a$b$c;"); } public void testDecrement() { test("var a = {}; a.b = 5; a.b--; a.b = 5", "var a$b = 5; a$b--; a$b = 5"); } public void testIncrement() { test("var a = {}; a.b = 5; a.b++; a.b = 5", "var a$b = 5; a$b++; a$b = 5"); } public void testObjLitDeclaration() { test("var a = {b: {}, c: {}}; var d = a.b; var e = a.c", "var a$b = {}; var a$c = {}; var d = a$b; var e = a$c"); } public void testObjLitDeclarationWithGet1() { testSame("var a = {get b(){}};"); } public void testObjLitDeclarationWithGet2() { test("var a = {b: {}, get c(){}}; var d = a.b; var e = a.c", "var a$b = {};var a = {get c(){}};var d = a$b; var e = a.c"); } public void testObjLitDeclarationWithGet3() { test("var a = {b: {get c() { return 3; }}};", "var a$b = {get c() { return 3; }};"); } public void testObjLitDeclarationWithSet1() { testSame("var a = {set b(a){}};"); } public void testObjLitDeclarationWithSet2() { test("var a = {b: {}, set c(a){}}; var d = a.b; var e = a.c", "var a$b = {};var a = {set c(a){}};var d = a$b; var e = a.c"); } public void testObjLitDeclarationWithSet3() { test("var a = {b: {set c(d) {}}};", "var a$b = {set c(d) {}};"); } public void testObjLitDeclarationWithGetAndSet1() { test("var a = {b: {get c() { return 3; },set c(d) {}}};", "var a$b = {get c() { return 3; },set c(d) {}};"); } public void testObjLitDeclarationWithDuplicateKeys() { test("var a = {b: 0, b: 1}; var c = a.b;", "var a$b = 0; var a$b = 1; var c = a$b;", SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR); } public void testObjLitAssignmentDepth1() { test("var a = {b: {}, c: {}}; var d = a.b; var e = a.c", "var a$b = {}; var a$c = {}; var d = a$b; var e = a$c"); } public void testObjLitAssignmentDepth2() { test("var a = {}; a.b = {c: {}, d: {}}; var e = a.b.c; var f = a.b.d", "var a$b$c = {}; var a$b$d = {}; var e = a$b$c; var f = a$b$d"); } public void testObjLitAssignmentDepth3() { test("var a = {}; a.b = {}; a.b.c = {d: 1, e: 2}; var f = a.b.c.d", "var a$b$c$d = 1; var a$b$c$e = 2; var f = a$b$c$d"); } public void testObjLitAssignmentDepth4() { test("var a = {}; a.b = {}; a.b.c = {}; a.b.c.d = {e: 1, f: 2}; " + "var g = a.b.c.d.e", "var a$b$c$d$e = 1; var a$b$c$d$f = 2; var g = a$b$c$d$e"); } public void testGlobalObjectDeclaredToPreserveItsPreviousValue1() { test("var a = a ? a : {}; a.c = 1;", "var a = a ? a : {}; var a$c = 1;"); } public void testGlobalObjectDeclaredToPreserveItsPreviousValue2() { test("var a = a || {}; a.c = 1;", "var a = a || {}; var a$c = 1;"); } public void testGlobalObjectDeclaredToPreserveItsPreviousValue3() { test("var a = a || {get b() {}}; a.c = 1;", "var a = a || {get b() {}}; var a$c = 1;"); } public void testGlobalObjectNameInBooleanExpressionDepth1_1() { test("var a = {b: 0}; a.c = 1; if (a) x();", "var a$b = 0; var a = {}; var a$c = 1; if (a) x();"); } public void testGlobalObjectNameInBooleanExpressionDepth1_2() { test("var a = {b: 0}; a.c = 1; if (!(a && a.c)) x();", "var a$b = 0; var a = {}; var a$c = 1; if (!(a && a$c)) x();"); } public void testGlobalObjectNameInBooleanExpressionDepth1_3() { test("var a = {b: 0}; a.c = 1; while (a || a.c) x();", "var a$b = 0; var a = {}; var a$c = 1; while (a || a$c) x();"); } public void testGlobalObjectNameInBooleanExpressionDepth1_4() { testSame("var a = {}; a.c = 1; var d = a || {}; a.c;"); } public void testGlobalObjectNameInBooleanExpressionDepth1_5() { testSame("var a = {}; a.c = 1; var d = a.c || a; a.c;"); } public void testGlobalObjectNameInBooleanExpressionDepth1_6() { test("var a = {b: 0}; a.c = 1; var d = !(a.c || a); a.c;", "var a$b = 0; var a = {}; var a$c = 1; var d = !(a$c || a); a$c;"); } public void testGlobalObjectNameInBooleanExpressionDepth2() { test("var a = {b: {}}; a.b.c = 1; if (a.b) x(a.b.c);", "var a$b = {}; var a$b$c = 1; if (a$b) x(a$b$c);"); } public void testGlobalObjectNameInBooleanExpressionDepth3() { // TODO(user): Make CollapseProperties even more aggressive so that // a$b.z gets collapsed. Right now, it doesn't get collapsed because the // expression (a.b && a.b.c) could return a.b. But since it returns a.b iff // a.b *is* safely collapsible, the Boolean logic should be smart enough to // only consider the right side of the && as aliasing. test("var a = {}; a.b = {}; /** @constructor */ a.b.c = function(){};" + " a.b.z = 1; var d = a.b && a.b.c;", "var a$b = {}; var a$b$c = function(){};" + " a$b.z = 1; var d = a$b && a$b$c;", null, CollapseProperties.UNSAFE_NAMESPACE_WARNING); } public void testGlobalFunctionNameInBooleanExpressionDepth1() { test("function a() {} a.c = 1; if (a) x(a.c);", "function a() {} var a$c = 1; if (a) x(a$c);"); } public void testGlobalFunctionNameInBooleanExpressionDepth2() { test("var a = {b: function(){}}; a.b.c = 1; if (a.b) x(a.b.c);", "var a$b = function(){}; var a$b$c = 1; if (a$b) x(a$b$c);"); } public void testAliasCreatedForObjectDepth1_1() { // An object's properties are not collapsed if the object is referenced // in a such a way that an alias is created for it. testSame("var a = {b: 0}; var c = a; c.b = 1; a.b == c.b;"); } public void testAliasCreatedForObjectDepth1_2() { testSame("var a = {b: 0}; f(a); a.b;"); } public void testAliasCreatedForObjectDepth1_3() { testSame("var a = {b: 0}; new f(a); a.b;"); } public void testAliasCreatedForObjectDepth2_1() { test("var a = {}; a.b = {c: 0}; var d = a.b; a.b.c == d.c;", "var a$b = {c: 0}; var d = a$b; a$b.c == d.c;"); } public void testAliasCreatedForObjectDepth2_2() { test("var a = {}; a.b = {c: 0}; for (var p in a.b) { e(a.b[p]); }", "var a$b = {c: 0}; for (var p in a$b) { e(a$b[p]); }"); } public void testAliasCreatedForEnumDepth1_1() { // An enum's values are always collapsed, even if the enum object is // referenced in a such a way that an alias is created for it. test("/** @enum */ var a = {b: 0}; var c = a; c.b = 1; a.b != c.b;", "var a$b = 0; var a = {b: a$b}; var c = a; c.b = 1; a$b != c.b;"); } public void testAliasCreatedForEnumDepth1_2() { test("/** @enum */ var a = {b: 0}; f(a); a.b;", "var a$b = 0; var a = {b: a$b}; f(a); a$b;"); } public void testAliasCreatedForEnumDepth1_3() { test("/** @enum */ var a = {b: 0}; new f(a); a.b;", "var a$b = 0; var a = {b: a$b}; new f(a); a$b;"); } public void testAliasCreatedForEnumDepth1_4() { test("/** @enum */ var a = {b: 0}; for (var p in a) { f(a[p]); }", "var a$b = 0; var a = {b: a$b}; for (var p in a) { f(a[p]); }"); } public void testAliasCreatedForEnumDepth2_1() { test("var a = {}; /** @enum */ a.b = {c: 0};" + "var d = a.b; d.c = 1; a.b.c != d.c;", "var a$b$c = 0; var a$b = {c: a$b$c};" + "var d = a$b; d.c = 1; a$b$c != d.c;"); } public void testAliasCreatedForEnumDepth2_2() { test("var a = {}; /** @enum */ a.b = {c: 0};" + "for (var p in a.b) { f(a.b[p]); }", "var a$b$c = 0; var a$b = {c: a$b$c};" + "for (var p in a$b) { f(a$b[p]); }"); } public void testAliasCreatedForEnumDepth2_3() { test("var a = {}; var d = a; /** @enum */ a.b = {c: 0};" + "for (var p in a.b) { f(a.b[p]); }", "var a = {}; var d = a; var a$b$c = 0; var a$b = {c: a$b$c};" + "for (var p in a$b) { f(a$b[p]); }", null, CollapseProperties.UNSAFE_NAMESPACE_WARNING); } public void testAliasCreatedForEnumOfObjects() { test("var a = {}; " + "/** @enum {Object} */ a.b = {c: {d: 1}}; a.b.c;" + "searchEnum(a.b);", "var a$b$c = {d: 1};var a$b = {c: a$b$c}; a$b$c; " + "searchEnum(a$b)"); } public void testAliasCreatedForEnumOfObjects2() { test("var a = {}; " + "/** @enum {Object} */ a.b = {c: {d: 1}}; a.b.c.d;" + "searchEnum(a.b);", "var a$b$c = {d: 1};var a$b = {c: a$b$c}; a$b$c.d; " + "searchEnum(a$b)"); } public void testAliasCreatedForPropertyOfEnumOfObjects() { test("var a = {}; " + "/** @enum {Object} */ a.b = {c: {d: 1}}; a.b.c;" + "searchEnum(a.b.c);", "var a$b$c = {d: 1}; a$b$c; searchEnum(a$b$c);"); } public void testAliasCreatedForPropertyOfEnumOfObjects2() { test("var a = {}; " + "/** @enum {Object} */ a.b = {c: {d: 1}}; a.b.c.d;" + "searchEnum(a.b.c);", "var a$b$c = {d: 1}; a$b$c.d; searchEnum(a$b$c);"); } public void testMisusedEnumTag() { testSame("var a = {}; var d = a; a.b = function() {};" + "/** @enum */ a.b.c = 0; a.b.c;"); } public void testMisusedConstructorTag() { testSame("var a = {}; var d = a; a.b = function() {};" + "/** @constructor */ a.b.c = 0; a.b.c;"); } public void testAliasCreatedForFunctionDepth1_1() { testSame("var a = function(){}; a.b = 1; var c = a; c.b = 2; a.b != c.b;"); } public void testAliasCreatedForCtorDepth1_1() { // A constructor's properties *are* collapsed even if the function is // referenced in a such a way that an alias is created for it, // since a function with custom properties is considered a class and its // non-prototype properties are considered static methods and variables. // People don't typically iterate through static members of a class or // refer to them using an alias for the class name. test("/** @constructor */ var a = function(){}; a.b = 1; " + "var c = a; c.b = 2; a.b != c.b;", "var a = function(){}; var a$b = 1; var c = a; c.b = 2; a$b != c.b;"); } public void testAliasCreatedForFunctionDepth1_2() { testSame("var a = function(){}; a.b = 1; f(a); a.b;"); } public void testAliasCreatedForCtorDepth1_2() { test("/** @constructor */ var a = function(){}; a.b = 1; f(a); a.b;", "var a = function(){}; var a$b = 1; f(a); a$b;"); } public void testAliasCreatedForFunctionDepth1_3() { testSame("var a = function(){}; a.b = 1; new f(a); a.b;"); } public void testAliasCreatedForCtorDepth1_3() { test("/** @constructor */ var a = function(){}; a.b = 1; new f(a); a.b;", "var a = function(){}; var a$b = 1; new f(a); a$b;"); } public void testAliasCreatedForFunctionDepth2() { test( "var a = {}; a.b = function() {}; a.b.c = 1; var d = a.b;" + "a.b.c != d.c;", "var a$b = function() {}; a$b.c = 1; var d = a$b;" + "a$b.c != d.c;"); } public void testAliasCreatedForCtorDepth2() { test("var a = {}; /** @constructor */ a.b = function() {}; " + "a.b.c = 1; var d = a.b;" + "a.b.c != d.c;", "var a$b = function() {}; var a$b$c = 1; var d = a$b;" + "a$b$c != d.c;"); } public void testAliasCreatedForClassDepth1_1() { // A class's name is always collapsed, even if one of its prefixes is // referenced in a such a way that an alias is created for it. test("var a = {}; /** @constructor */ a.b = function(){};" + "var c = a; c.b = 0; a.b != c.b;", "var a = {}; var a$b = function(){};" + "var c = a; c.b = 0; a$b != c.b;", null, CollapseProperties.UNSAFE_NAMESPACE_WARNING); } public void testAliasCreatedForClassDepth1_2() { test("var a = {}; /** @constructor */ a.b = function(){}; f(a); a.b;", "var a = {}; var a$b = function(){}; f(a); a$b;", null, CollapseProperties.UNSAFE_NAMESPACE_WARNING); } public void testAliasCreatedForClassDepth1_3() { test("var a = {}; /** @constructor */ a.b = function(){}; new f(a); a.b;", "var a = {}; var a$b = function(){}; new f(a); a$b;", null, CollapseProperties.UNSAFE_NAMESPACE_WARNING); } public void testAliasCreatedForClassDepth2_1() { test("var a = {}; a.b = {}; /** @constructor */ a.b.c = function(){};" + "var d = a.b; a.b.c != d.c;", "var a$b = {}; var a$b$c = function(){};" + "var d = a$b; a$b$c != d.c;", null, CollapseProperties.UNSAFE_NAMESPACE_WARNING); } public void testAliasCreatedForClassDepth2_2() { test("var a = {}; a.b = {}; /** @constructor */ a.b.c = function(){};" + "f(a.b); a.b.c;", "var a$b = {}; var a$b$c = function(){}; f(a$b); a$b$c;", null, CollapseProperties.UNSAFE_NAMESPACE_WARNING); } public void testAliasCreatedForClassDepth2_3() { test("var a = {}; a.b = {}; /** @constructor */ a.b.c = function(){};" + "new f(a.b); a.b.c;", "var a$b = {}; var a$b$c = function(){}; new f(a$b); a$b$c;", null, CollapseProperties.UNSAFE_NAMESPACE_WARNING); } public void testAliasCreatedForClassProperty() { test("var a = {}; /** @constructor */ a.b = function(){};" + "a.b.c = {d: 3}; new f(a.b.c); a.b.c.d;", "var a$b = function(){}; var a$b$c = {d:3}; new f(a$b$c); a$b$c.d;"); } public void testNestedObjLit() { test("var a = {}; a.b = {f: 0, c: {d: 1}}; var e = a.b.c.d", "var a$b$f = 0; var a$b$c$d = 1; var e = a$b$c$d;"); } public void testObjLitDeclarationUsedInSameVarList() { // The collapsed properties must defined in the same place in the var list // where they were originally defined (and not, for example, at the end). test("var a = {b: {}, c: {}}; var d = a.b; var e = a.c;", "var a$b = {}; var a$c = {}; var d = a$b; var e = a$c;"); } public void testPropGetInsideAnObjLit() { test("var x = {}; x.y = 1; var a = {}; a.b = {c: x.y}", "var x$y = 1; var a$b$c = x$y;"); } public void testObjLitWithQuotedKeyThatDoesNotGetRead() { test("var a = {}; a.b = {c: 0, 'd': 1}; var e = a.b.c;", "var a$b$c = 0; var a$b$d = 1; var e = a$b$c;"); } public void testObjLitWithQuotedKeyThatGetsRead() { test("var a = {}; a.b = {c: 0, 'd': 1}; var e = a.b['d'];", "var a$b = {c: 0, 'd': 1}; var e = a$b['d'];"); } public void testFunctionWithQuotedPropertyThatDoesNotGetRead() { test("var a = {}; a.b = function() {}; a.b['d'] = 1;", "var a$b = function() {}; a$b['d'] = 1;"); } public void testFunctionWithQuotedPropertyThatGetsRead() { test("var a = {}; a.b = function() {}; a.b['d'] = 1; f(a.b['d']);", "var a$b = function() {}; a$b['d'] = 1; f(a$b['d']);"); } public void testObjLitAssignedToMultipleNames1() { // An object literal that's assigned to multiple names isn't collapsed. testSame("var a = b = {c: 0, d: 1}; var e = a.c; var f = b.d;"); } public void testObjLitAssignedToMultipleNames2() { testSame("a = b = {c: 0, d: 1}; var e = a.c; var f = b.d;"); } public void testObjLitRedefinedInGlobalScope() { testSame("a = {b: 0}; a = {c: 1}; var d = a.b; var e = a.c;"); } public void testObjLitRedefinedInLocalScope() { test("var a = {}; a.b = {c: 0}; function d() { a.b = {c: 1}; } e(a.b.c);", "var a$b = {c: 0}; function d() { a$b = {c: 1}; } e(a$b.c);"); } public void testObjLitAssignedInTernaryExpression1() { testSame("a = x ? {b: 0} : d; var c = a.b;"); } public void testObjLitAssignedInTernaryExpression2() { testSame("a = x ? {b: 0} : {b: 1}; var c = a.b;"); } public void testGlobalVarSetToObjLitConditionally1() { testSame("var a; if (x) a = {b: 0}; var c = x ? a.b : 0;"); } public void testGlobalVarSetToObjLitConditionally1b() { test("if (x) var a = {b: 0}; var c = x ? a.b : 0;", "if (x) var a$b = 0; var c = x ? a$b : 0;"); } public void testGlobalVarSetToObjLitConditionally2() { test("if (x) var a = {b: 0}; var c = a.b; var d = a.c;", "if (x){ var a$b = 0; var a = {}; }var c = a$b; var d = a.c;"); } public void testGlobalVarSetToObjLitConditionally3() { testSame("var a; if (x) a = {b: 0}; else a = {b: 1}; var c = a.b;"); } public void testObjectPropertySetToObjLitConditionally() { test("var a = {}; if (x) a.b = {c: 0}; var d = a.b ? a.b.c : 0;", "if (x){ var a$b$c = 0; var a$b = {} } var d = a$b ? a$b$c : 0;"); } public void testFunctionPropertySetToObjLitConditionally() { test("function a() {} if (x) a.b = {c: 0}; var d = a.b ? a.b.c : 0;", "function a() {} if (x){ var a$b$c = 0; var a$b = {} }" + "var d = a$b ? a$b$c : 0;"); } public void testPrototypePropertySetToAnObjectLiteral() { test("var a = {b: function(){}}; a.b.prototype.c = {d: 0};", "var a$b = function(){}; a$b.prototype.c = {d: 0};"); } public void testObjectPropertyResetInLocalScope() { test("var z = {}; z.a = 0; function f() {z.a = 5; return z.a}", "var z$a = 0; function f() {z$a = 5; return z$a}"); } public void testFunctionPropertyResetInLocalScope() { test("function z() {} z.a = 0; function f() {z.a = 5; return z.a}", "function z() {} var z$a = 0; function f() {z$a = 5; return z$a}"); } public void testNamespaceResetInGlobalScope1() { test("var a = {}; /** @constructor */a.b = function() {}; a = {};", "var a = {}; var a$b = function() {}; a = {};", null, CollapseProperties.NAMESPACE_REDEFINED_WARNING); } public void testNamespaceResetInGlobalScope2() { test("var a = {}; a = {}; /** @constructor */a.b = function() {};", "var a = {}; a = {}; var a$b = function() {};", null, CollapseProperties.NAMESPACE_REDEFINED_WARNING); } public void testNamespaceResetInLocalScope1() { test("var a = {}; /** @constructor */a.b = function() {};" + " function f() { a = {}; }", "var a = {};var a$b = function() {};" + " function f() { a = {}; }", null, CollapseProperties.NAMESPACE_REDEFINED_WARNING); } public void testNamespaceResetInLocalScope2() { test("var a = {}; function f() { a = {}; }" + " /** @constructor */a.b = function() {};", "var a = {}; function f() { a = {}; }" + " var a$b = function() {};", null, CollapseProperties.NAMESPACE_REDEFINED_WARNING); } public void testNamespaceDefinedInLocalScope() { test("var a = {}; (function() { a.b = {}; })();" + " /** @constructor */a.b.c = function() {};", "var a$b; (function() { a$b = {}; })(); var a$b$c = function() {};"); } public void testAddPropertyToObjectInLocalScopeDepth1() { test("var a = {b: 0}; function f() { a.c = 5; return a.c; }", "var a$b = 0; var a$c; function f() { a$c = 5; return a$c; }"); } public void testAddPropertyToObjectInLocalScopeDepth2() { test("var a = {}; a.b = {}; (function() {a.b.c = 0;})(); x = a.b.c;", "var a$b$c; (function() {a$b$c = 0;})(); x = a$b$c;"); } public void testAddPropertyToFunctionInLocalScopeDepth1() { test("function a() {} function f() { a.c = 5; return a.c; }", "function a() {} var a$c; function f() { a$c = 5; return a$c; }"); } public void testAddPropertyToFunctionInLocalScopeDepth2() { test("var a = {}; a.b = function() {}; function f() {a.b.c = 0;}", "var a$b = function() {}; var a$b$c; function f() {a$b$c = 0;}"); } public void testAddPropertyToUncollapsibleObjectInLocalScopeDepth1() { testSame("var a = {}; var c = a; (function() {a.b = 0;})(); a.b;"); } public void testAddPropertyToUncollapsibleFunctionInLocalScopeDepth1() { testSame("function a() {} var c = a; (function() {a.b = 0;})(); a.b;"); } public void testAddPropertyToUncollapsibleNamedCtorInLocalScopeDepth1() { testSame( "/** @constructor */ function a() {} var a$b; var c = a; " + "(function() {a$b = 0;})(); a$b;"); } public void testAddPropertyToUncollapsibleCtorInLocalScopeDepth1() { test("/** @constructor */ var a = function() {}; var c = a; " + "(function() {a.b = 0;})(); a.b;", "var a = function() {}; var a$b; " + "var c = a; (function() {a$b = 0;})(); a$b;"); } public void testAddPropertyToUncollapsibleObjectInLocalScopeDepth2() { test("var a = {}; a.b = {}; var d = a.b;" + "(function() {a.b.c = 0;})(); a.b.c;", "var a$b = {}; var d = a$b;" + "(function() {a$b.c = 0;})(); a$b.c;"); } public void testAddPropertyToUncollapsibleFunctionInLocalScopeDepth2() { test("var a = {}; a.b = function (){}; var d = a.b;" + "(function() {a.b.c = 0;})(); a.b.c;", "var a$b = function (){}; var d = a$b;" + "(function() {a$b.c = 0;})(); a$b.c;"); } public void testAddPropertyToUncollapsibleCtorInLocalScopeDepth2() { test("var a = {}; /** @constructor */ a.b = function (){}; var d = a.b;" + "(function() {a.b.c = 0;})(); a.b.c;", "var a$b = function (){}; var a$b$c; var d = a$b;" + "(function() {a$b$c = 0;})(); a$b$c;"); } public void testPropertyOfChildFuncOfUncollapsibleObjectDepth1() { testSame("var a = {}; var c = a; a.b = function (){}; a.b.x = 0; a.b.x;"); } public void testPropertyOfChildFuncOfUncollapsibleObjectDepth2() { test("var a = {}; a.b = {}; var c = a.b;" + "a.b.c = function (){}; a.b.c.x = 0; a.b.c.x;", "var a$b = {}; var c = a$b;" + "a$b.c = function (){}; a$b.c.x = 0; a$b.c.x;"); } public void testAddPropertyToChildFuncOfUncollapsibleObjectInLocalScope() { testSame("var a = {}; a.b = function (){}; a.b.x = 0;" + "var c = a; (function() {a.b.y = 1;})(); a.b.x; a.b.y;"); } public void testAddPropertyToChildTypeOfUncollapsibleObjectInLocalScope() { test("var a = {}; /** @constructor */ a.b = function (){}; a.b.x = 0;" + "var c = a; (function() {a.b.y = 1;})(); a.b.x; a.b.y;", "var a = {}; var a$b = function (){}; var a$b$y; var a$b$x = 0;" + "var c = a; (function() {a$b$y = 1;})(); a$b$x; a$b$y;", null, CollapseProperties.UNSAFE_NAMESPACE_WARNING); } public void testAddPropertyToChildOfUncollapsibleFunctionInLocalScope() { testSame( "function a() {} a.b = {x: 0}; var c = a;" + "(function() {a.b.y = 0;})(); a.b.y;"); } public void testAddPropertyToChildOfUncollapsibleCtorInLocalScope() { test("/** @constructor */ var a = function() {}; a.b = {x: 0}; var c = a;" + "(function() {a.b.y = 0;})(); a.b.y;", "var a = function() {}; var a$b$x = 0; var a$b$y; var c = a;" + "(function() {a$b$y = 0;})(); a$b$y;"); } public void testResetObjectPropertyInLocalScope() { test("var a = {b: 0}; a.c = 1; function f() { a.c = 5; }", "var a$b = 0; var a$c = 1; function f() { a$c = 5; }"); } public void testResetFunctionPropertyInLocalScope() { test("function a() {}; a.c = 1; function f() { a.c = 5; }", "function a() {}; var a$c = 1; function f() { a$c = 5; }"); } public void testGlobalNameReferencedInLocalScopeBeforeDefined1() { // Because referencing global names earlier in the source code than they're // defined is such a common practice, we collapse them even though a runtime // exception could result (in the off-chance that the function gets called // before the alias variable is defined). test("var a = {b: 0}; function f() { a.c = 5; } a.c = 1;", "var a$b = 0; function f() { a$c = 5; } var a$c = 1;"); } public void testGlobalNameReferencedInLocalScopeBeforeDefined2() { test("var a = {b: 0}; function f() { return a.c; } a.c = 1;", "var a$b = 0; function f() { return a$c; } var a$c = 1;"); } public void testTwiceDefinedGlobalNameDepth1_1() { testSame("var a = {}; function f() { a.b(); }" + "a = function() {}; a.b = function() {};"); } public void testTwiceDefinedGlobalNameDepth1_2() { testSame("var a = {}; /** @constructor */ a = function() {};" + "a.b = {}; a.b.c = 0; function f() { a.b.d = 1; }"); } public void testTwiceDefinedGlobalNameDepth2() { test("var a = {}; a.b = {}; function f() { a.b.c(); }" + "a.b = function() {}; a.b.c = function() {};", "var a$b = {}; function f() { a$b.c(); }" + "a$b = function() {}; a$b.c = function() {};"); } public void testFunctionCallDepth1() { test("var a = {}; a.b = function(){}; var c = a.b();", "var a$b = function(){}; var c = a$b()"); } public void testFunctionCallDepth2() { test("var a = {}; a.b = {}; a.b.c = function(){}; a.b.c();", "var a$b$c = function(){}; a$b$c();"); } public void testFunctionAlias() { test("var a = {}; a.b = {}; a.b.c = function(){}; a.b.d = a.b.c;", "var a$b$c = function(){}; var a$b$d = a$b$c;"); } public void testCallToRedefinedFunction() { test("var a = {}; a.b = function(){}; a.b = function(){}; a.b();", "var a$b = function(){}; a$b = function(){}; a$b();"); } public void testCollapsePrototypeName() { test("var a = {}; a.b = {}; a.b.c = function(){}; " + "a.b.c.prototype.d = function(){}; (new a.b.c()).d();", "var a$b$c = function(){}; a$b$c.prototype.d = function(){}; " + "new a$b$c().d();"); } public void testReferencedPrototypeProperty() { test("var a = {b: {}}; a.b.c = function(){}; a.b.c.prototype.d = {};" + "e = a.b.c.prototype.d;", "var a$b$c = function(){}; a$b$c.prototype.d = {};" + "e = a$b$c.prototype.d;"); } public void testSetStaticAndPrototypePropertiesOnFunction() { test("var a = {}; a.b = function(){}; a.b.prototype.d = 0; a.b.c = 1;", "var a$b = function(){}; a$b.prototype.d = 0; var a$b$c = 1;"); } public void testReadUndefinedPropertyDepth1() { test("var a = {b: 0}; var c = a.d;", "var a$b = 0; var a = {}; var c = a.d;"); } public void testReadUndefinedPropertyDepth2() { test("var a = {b: {c: 0}}; f(a.b.c); f(a.b.d);", "var a$b$c = 0; var a$b = {}; f(a$b$c); f(a$b.d);"); } public void testCallUndefinedMethodOnObjLitDepth1() { test("var a = {b: 0}; a.c();", "var a$b = 0; var a = {}; a.c();"); } public void testCallUndefinedMethodOnObjLitDepth2() { test("var a = {b: {}}; a.b.c = function() {}; a.b.c(); a.b.d();", "var a$b = {}; var a$b$c = function() {}; a$b$c(); a$b.d();"); } public void testPropertiesOfAnUndefinedVar() { testSame("a.document = d; f(a.document.innerHTML);"); } public void testPropertyOfAnObjectThatIsNeitherFunctionNorObjLit() { testSame("var a = window; a.document = d; f(a.document)"); } public void testStaticFunctionReferencingThis1() { // Note: Google's JavaScript Style Guide says to avoid using the 'this' // keyword in a static function. test("var a = {}; a.b = function() {this.c}; var d = a.b;", "var a$b = function() {this.c}; var d = a$b;", null, UNSAFE_THIS); } public void testStaticFunctionReferencingThis2() { // This gives no warning, because "this" is in a scope whose name is not // getting collapsed. test("var a = {}; " + "a.b = function() { return function(){ return this; }; };", "var a$b = function() { return function(){ return this; }; };"); } public void testStaticFunctionReferencingThis3() { test("var a = {b: function() {this.c}};", "var a$b = function() { this.c };", null, UNSAFE_THIS); } public void testStaticFunctionReferencingThis4() { test("var a = {/** @this {Element} */ b: function() {this.c}};", "var a$b = function() { this.c };"); } public void testPrototypeMethodReferencingThis() { testSame("var A = function(){}; A.prototype = {b: function() {this.c}};"); } public void testConstructorReferencingThis() { test("var a = {}; " + "/** @constructor */ a.b = function() { this.a = 3; };", "var a$b = function() { this.a = 3; };"); } public void testSafeReferenceOfThis() { test("var a = {}; " + "/** @this {Object} */ a.b = function() { this.a = 3; };", "var a$b = function() { this.a = 3; };"); } public void testGlobalFunctionReferenceOfThis() { testSame("var a = function() { this.a = 3; };"); } public void testFunctionGivenTwoNames() { // It's okay to collapse f's properties because g is not added to the // global scope as an alias for f. (Try it in your browser.) test("var f = function g() {}; f.a = 1; h(f.a);", "var f = function g() {}; var f$a = 1; h(f$a);"); } public void testObjLitWithUsedNumericKey() { testSame("a = {40: {}, c: {}}; var d = a[40]; var e = a.c;"); } public void testObjLitWithUnusedNumericKey() { test("var a = {40: {}, c: {}}; var e = a.c;", "var a$1 = {}; var a$c = {}; var e = a$c"); } public void testObjLitWithNonIdentifierKeys() { testSame("a = {' ': 0, ',': 1}; var c = a[' '];"); } public void testChainedAssignments1() { test("var x = {}; x.y = a = 0;", "var x$y = a = 0;"); } public void testChainedAssignments2() { test("var x = {}; x.y = a = b = c();", "var x$y = a = b = c();"); } public void testChainedAssignments3() { test("var x = {y: 1}; a = b = x.y;", "var x$y = 1; a = b = x$y;"); } public void testChainedAssignments4() { test("var x = {}; a = b = x.y;", "var x = {}; a = b = x.y;"); } public void testChainedAssignments5() { test("var x = {}; a = x.y = 0;", "var x$y; a = x$y = 0;"); } public void testChainedAssignments6() { test("var x = {}; a = x.y = b = c();", "var x$y; a = x$y = b = c();"); } public void testChainedAssignments7() { test("var x = {}; a = x.y = {}; /** @constructor */ x.y.z = function() {};", "var x$y; a = x$y = {}; var x$y$z = function() {};", null, CollapseProperties.UNSAFE_NAMESPACE_WARNING); } public void testChainedVarAssignments1() { test("var x = {y: 1}; var a = x.y = 0;", "var x$y = 1; var a = x$y = 0;"); } public void testChainedVarAssignments2() { test("var x = {y: 1}; var a = x.y = b = 0;", "var x$y = 1; var a = x$y = b = 0;"); } public void testChainedVarAssignments3() { test("var x = {y: {z: 1}}; var b = 0; var a = x.y.z = 1; var c = 2;", "var x$y$z = 1; var b = 0; var a = x$y$z = 1; var c = 2;"); } public void testChainedVarAssignments4() { test("var x = {}; var a = b = x.y = 0;", "var x$y; var a = b = x$y = 0;"); } public void testChainedVarAssignments5() { test("var x = {y: {}}; var a = b = x.y.z = 0;", "var x$y$z; var a = b = x$y$z = 0;"); } public void testPeerAndSubpropertyOfUncollapsibleProperty() { test("var x = {}; var a = x.y = 0; x.w = 1; x.y.z = 2;" + "b = x.w; c = x.y.z;", "var x$y; var a = x$y = 0; var x$w = 1; x$y.z = 2;" + "b = x$w; c = x$y.z;"); } public void testComplexAssignmentAfterInitialAssignment() { test("var d = {}; d.e = {}; d.e.f = 0; a = b = d.e.f = 1;", "var d$e$f = 0; a = b = d$e$f = 1;"); } public void testRenamePrefixOfUncollapsibleProperty() { test("var d = {}; d.e = {}; a = b = d.e.f = 0;", "var d$e$f; a = b = d$e$f = 0;"); } public void testNewOperator() { // Using the new operator on a name doesn't prevent its (static) properties // from getting collapsed. test("var a = {}; a.b = function() {}; a.b.c = 1; var d = new a.b();", "var a$b = function() {}; var a$b$c = 1; var d = new a$b();"); } public void testMethodCall() { test("var a = {}; a.b = function() {}; var d = a.b();", "var a$b = function() {}; var d = a$b();"); } public void testObjLitDefinedInLocalScopeIsLeftAlone() { test("var a = {}; a.b = function() {};" + "a.b.prototype.f_ = function() {" + " var x = { p: '', q: '', r: ''}; var y = x.q;" + "};", "var a$b = function() {};" + "a$b.prototype.f_ = function() {" + " var x = { p: '', q: '', r: ''}; var y = x.q;" + "};"); } public void testPropertiesOnBothSidesOfAssignment() { // This verifies that replacements are done in the right order. Collapsing // the l-value in an assignment affects the parse tree immediately above // the r-value, so we update all rvalues before any lvalues. test("var a = {b: 0}; a.c = a.b;", "var a$b = 0; var a$c = a$b;"); } public void testCallOnUndefinedProperty() { // The "inherits" property is not explicitly defined on a.b anywhere, but // it is accessed as though it certainly exists (it is called), so we infer // that it must be an uncollapsible property that has come into existence // some other way. test("var a = {}; a.b = function(){}; a.b.inherits(x);", "var a$b = function(){}; a$b.inherits(x);"); } public void testGetPropOnUndefinedProperty() { // The "superClass_" property is not explicitly defined on a.b anywhere, // but it is accessed as though it certainly exists (a subproperty of it // is accessed), so we infer that it must be an uncollapsible property that // has come into existence some other way. test("var a = {b: function(){}}; a.b.prototype.c =" + "function() { a.b.superClass_.c.call(this); }", "var a$b = function(){}; a$b.prototype.c =" + "function() { a$b.superClass_.c.call(this); }"); } public void testLocalAlias1() { test("var a = {b: 3}; function f() { var x = a; f(x.b); }", "var a$b = 3; function f() { var x = null; f(a$b); }"); } public void testLocalAlias2() { test("var a = {b: 3, c: 4}; function f() { var x = a; f(x.b); f(x.c);}", "var a$b = 3; var a$c = 4; " + "function f() { var x = null; f(a$b); f(a$c);}"); } public void testLocalAlias3() { test("var a = {b: 3, c: {d: 5}}; " + "function f() { var x = a; f(x.b); f(x.c); f(x.c.d); }", "var a$b = 3; var a$c = {d: 5}; " + "function f() { var x = null; f(a$b); f(a$c); f(a$c.d);}"); } public void testLocalAlias4() { test("var a = {b: 3}; var c = {d: 5}; " + "function f() { var x = a; var y = c; f(x.b); f(y.d); }", "var a$b = 3; var c$d = 5; " + "function f() { var x = null; var y = null; f(a$b); f(c$d);}"); } public void testLocalAlias5() { test("var a = {b: {c: 5}}; " + "function f() { var x = a; var y = x.b; f(a.b.c); f(y.c); }", "var a$b$c = 5; " + "function f() { var x = null; var y = null; f(a$b$c); f(a$b$c);}"); } public void testLocalAlias6() { test("var a = {b: 3}; function f() { var x = a; if (x.b) { f(x.b); } }", "var a$b = 3; function f() { var x = null; if (a$b) { f(a$b); } }"); } public void testLocalAlias7() { test("var a = {b: {c: 5}}; function f() { var x = a.b; f(x.c); }", "var a$b$c = 5; function f() { var x = null; f(a$b$c); }"); } public void testGlobalWriteToAncestor() { testSame("var a = {b: 3}; function f() { var x = a; f(a.b); } a = 5;"); } public void testGlobalWriteToNonAncestor() { test("var a = {b: 3}; function f() { var x = a; f(a.b); } a.b = 5;", "var a$b = 3; function f() { var x = null; f(a$b); } a$b = 5;"); } public void testLocalWriteToAncestor() { testSame("var a = {b: 3}; function f() { a = 5; var x = a; f(a.b); } "); } public void testLocalWriteToNonAncestor() { test("var a = {b: 3}; " + "function f() { a.b = 5; var x = a; f(a.b); }", "var a$b = 3; function f() { a$b = 5; var x = null; f(a$b); } "); } public void testNonWellformedAlias1() { testSame("var a = {b: 3}; function f() { f(x); var x = a; f(x.b); }"); } public void testNonWellformedAlias2() { testSame("var a = {b: 3}; " + "function f() { if (false) { var x = a; f(x.b); } f(x); }"); } public void testLocalAliasOfAncestor() { testSame("var a = {b: {c: 5}}; function g() { f(a); } " + "function f() { var x = a.b; f(x.c); }"); } public void testGlobalAliasOfAncestor() { testSame("var a = {b: {c: 5}}; var y = a; " + "function f() { var x = a.b; f(x.c); }"); } public void testLocalAliasOfOtherName() { testSame("var foo = function() { return {b: 3}; };" + "var a = foo(); a.b = 5; " + "function f() { var x = a.b; f(x); }"); } public void testLocalAliasOfFunction() { test("var a = function() {}; a.b = 5; " + "function f() { var x = a.b; f(x); }", "var a = function() {}; var a$b = 5; " + "function f() { var x = null; f(a$b); }"); } public void testNoInlineGetpropIntoCall() { test("var b = x; function f() { var a = b; a(); }", "var b = x; function f() { var a = null; b(); }"); test("var b = {}; b.c = x; function f() { var a = b.c; a(); }", "var b$c = x; function f() { var a = null; b$c(); }"); } public void testInlineAliasWithModifications() { testSame("var x = 10; function f() { var y = x; x++; alert(y)} "); testSame("var x = 10; function f() { var y = x; x+=1; alert(y)} "); test("var x = {}; x.x = 10; function f() {var y=x.x; x.x++; alert(y)}", "var x$x = 10; function f() {var y=x$x; x$x++; alert(y)}"); test("var x = {}; x.x = 10; function f() {var y=x.x; x.x+=1; alert(y)}", "var x$x = 10; function f() {var y=x$x; x$x+=1; alert(y)}"); } public void testCollapsePropertyOnExternType() { collapsePropertiesOnExternTypes = true; test("String.myFunc = function() {}; String.myFunc();", "var String$myFunc = function() {}; String$myFunc()"); } public void testCollapseForEachWithoutExterns() { collapsePropertiesOnExternTypes = true; test("/** @constructor */function Array(){};\n", "if (!Array.forEach) {\n" + " Array.forEach = function() {};\n" + "}", "if (!Array$forEach) {\n" + " var Array$forEach = function() {};\n" + "}", null, null); } public void testNoCollapseForEachInExterns() { collapsePropertiesOnExternTypes = true; test("/** @constructor */ function Array() {}" + "Array.forEach = function() {}", "if (!Array.forEach) {\n" + " Array.forEach = function() {};\n" + "}", "if (!Array.forEach) {\n" + " Array.forEach = function() {};\n" + "}", null, null); } public void testDoNotCollapsePropertyOnExternType() { collapsePropertiesOnExternTypes = false; test("String.myFunc = function() {}; String.myFunc()", "String.myFunc = function() {}; String.myFunc()"); } public void testBug1704733() { String prelude = "function protect(x) { return x; }" + "function O() {}" + "protect(O).m1 = function() {};" + "protect(O).m2 = function() {};" + "protect(O).m3 = function() {};"; testSame(prelude + "alert(O.m1); alert(O.m2()); alert(!O.m3);"); } public void testBug1956277() { test("var CONST = {}; CONST.URL = 3;", "var CONST$URL = 3;"); } public void testBug1974371() { test( "/** @enum {Object} */ var Foo = {A: {c: 2}, B: {c: 3}};" + "for (var key in Foo) {}", "var Foo$A = {c: 2}; var Foo$B = {c: 3};" + "var Foo = {A: Foo$A, B: Foo$B};" + "for (var key in Foo) {}"); } private final String COMMON_ENUM = "/** @enum {Object} */ var Foo = {A: {c: 2}, B: {c: 3}};"; public void testEnumOfObjects1() { test( COMMON_ENUM + "for (var key in Foo.A) {}", "var Foo$A = {c: 2}; var Foo$B$c = 3; for (var key in Foo$A) {}"); } public void testEnumOfObjects2() { test( COMMON_ENUM + "foo(Foo.A.c);", "var Foo$A$c = 2; var Foo$B$c = 3; foo(Foo$A$c);"); } public void testEnumOfObjects3() { test( "var x = {c: 2}; var y = {c: 3};" + "/** @enum {Object} */ var Foo = {A: x, B: y};" + "for (var key in Foo) {}", "var x = {c: 2}; var y = {c: 3};" + "var Foo$A = x; var Foo$B = y; var Foo = {A: Foo$A, B: Foo$B};" + "for (var key in Foo) {}"); } public void testEnumOfObjects4() { // Note that this produces bad code, but that's OK, because // checkConsts will yell at you for reassigning an enum value. // (enum values have to be constant). test( COMMON_ENUM + "for (var key in Foo) {} Foo.A = 3; alert(Foo.A);", "var Foo$A = {c: 2}; var Foo$B = {c: 3};" + "var Foo = {A: Foo$A, B: Foo$B};" + "for (var key in Foo) {} Foo$A = 3; alert(Foo$A);"); } public void testObjectOfObjects1() { // Basically the same as testEnumOfObjects4, but without the // constant enum values. testSame( "var Foo = {a: {c: 2}, b: {c: 3}};" + "for (var key in Foo) {} Foo.a = 3; alert(Foo.a);"); } public void testReferenceInAnonymousObject0() { test("var a = {};" + "a.b = function(){};" + "a.b.prototype.c = function(){};" + "var d = a.b.prototype.c;", "var a$b = function(){};" + "a$b.prototype.c = function(){};" + "var d = a$b.prototype.c;"); } public void testReferenceInAnonymousObject1() { test("var a = {};" + "a.b = function(){};" + "var d = a.b.prototype.c;", "var a$b = function(){};" + "var d = a$b.prototype.c;"); } public void testReferenceInAnonymousObject2() { test("var a = {};" + "a.b = function(){};" + "a.b.prototype.c = function(){};" + "var d = {c: a.b.prototype.c};", "var a$b = function(){};" + "a$b.prototype.c = function(){};" + "var d$c = a$b.prototype.c;"); } public void testReferenceInAnonymousObject3() { test("function CreateClass(a$$1) {}" + "var a = {};" + "a.b = function(){};" + "a.b.prototype.c = function(){};" + "a.d = CreateClass({c: a.b.prototype.c});", "function CreateClass(a$$1) {}" + "var a$b = function(){};" + "a$b.prototype.c = function(){};" + "var a$d = CreateClass({c: a$b.prototype.c});"); } public void testReferenceInAnonymousObject4() { test("function CreateClass(a) {}" + "var a = {};" + "a.b = CreateClass({c: function() {}});" + "a.d = CreateClass({c: a.b.c});", "function CreateClass(a$$1) {}" + "var a$b = CreateClass({c: function() {}});" + "var a$d = CreateClass({c: a$b.c});"); } public void testReferenceInAnonymousObject5() { test("function CreateClass(a) {}" + "var a = {};" + "a.b = CreateClass({c: function() {}});" + "a.d = CreateClass({c: a.b.prototype.c});", "function CreateClass(a$$1) {}" + "var a$b = CreateClass({c: function() {}});" + "var a$d = CreateClass({c: a$b.prototype.c});"); } public void testCrashInCommaOperator() { test("var a = {}; a.b = function() {},a.b();", "var a$b; a$b=function() {},a$b();"); } public void testCrashInNestedAssign() { test("var a = {}; if (a.b = function() {}) a.b();", "var a$b; if (a$b=function() {}) { a$b(); }"); } public void testTwinReferenceCancelsChildCollapsing() { test("var a = {}; if (a.b = function() {}) { a.b.c = 3; a.b(a.b.c); }", "var a$b; if (a$b = function() {}) { a$b.c = 3; a$b(a$b.c); }"); } public void testPropWithDollarSign() { test("var a = {$: 3}", "var a$$0 = 3;"); } public void testPropWithDollarSign2() { test("var a = {$: function(){}}", "var a$$0 = function(){};"); } public void testPropWithDollarSign3() { test("var a = {b: {c: 3}, b$c: function(){}}", "var a$b$c = 3; var a$b$0c = function(){};"); } public void testPropWithDollarSign4() { test("var a = {$$: {$$$: 3}};", "var a$$0$0$$0$0$0 = 3;"); } public void testPropWithDollarSign5() { test("var a = {b: {$0c: true}, b$0c: false};", "var a$b$$00c = true; var a$b$00c = false;"); } public void testConstKey() { test("var foo = {A: 3};", "var foo$A = 3;"); } public void testPropertyOnGlobalCtor() { test("/** @constructor */ function Map() {} Map.foo = 3; Map;", "function Map() {} var Map$foo = 3; Map;"); } public void testPropertyOnGlobalInterface() { test("/** @interface */ function Map() {} Map.foo = 3; Map;", "function Map() {} var Map$foo = 3; Map;"); } public void testPropertyOnGlobalFunction() { testSame("function Map() {} Map.foo = 3; Map;"); } public void testIssue389() { test( "function alias() {}" + "var dojo = {};" + "dojo.gfx = {};" + "dojo.declare = function() {};" + "/** @constructor */" + "dojo.gfx.Shape = function() {};" + "dojo.gfx.Shape = dojo.declare('dojo.gfx.Shape');" + "alias(dojo);", "function alias() {}" + "var dojo = {};" + "dojo.gfx = {};" + "dojo.declare = function() {};" + "/** @constructor */" + "var dojo$gfx$Shape = function() {};" + "dojo$gfx$Shape = dojo.declare('dojo.gfx.Shape');" + "alias(dojo);", null, CollapseProperties.UNSAFE_NAMESPACE_WARNING); } public void testAliasedTopLevelName() { testSame( "function alias() {}" + "var dojo = {};" + "dojo.gfx = {};" + "dojo.declare = function() {};" + "dojo.gfx.Shape = {SQUARE: 2};" + "dojo.gfx.Shape = dojo.declare('dojo.gfx.Shape');" + "alias(dojo);" + "alias(dojo$gfx$Shape$SQUARE);"); } public void testAliasedTopLevelEnum() { test( "function alias() {}" + "var dojo = {};" + "dojo.gfx = {};" + "dojo.declare = function() {};" + "/** @enum {number} */" + "dojo.gfx.Shape = {SQUARE: 2};" + "dojo.gfx.Shape = dojo.declare('dojo.gfx.Shape');" + "alias(dojo);" + "alias(dojo.gfx.Shape.SQUARE);", "function alias() {}" + "var dojo = {};" + "dojo.gfx = {};" + "dojo.declare = function() {};" + "/** @constructor */" + "var dojo$gfx$Shape = {SQUARE: 2};" + "dojo$gfx$Shape = dojo.declare('dojo.gfx.Shape');" + "alias(dojo);" + "alias(dojo$gfx$Shape.SQUARE);", null, CollapseProperties.UNSAFE_NAMESPACE_WARNING); } public void testAssignFunctionBeforeDefinition() { testSame( "f = function() {};" + "var f = null;"); } public void testObjectLitBeforeDefinition() { testSame( "a = {b: 3};" + "var a = null;" + "this.c = a.b;"); } public void testTypedef1() { test("var foo = {};" + "/** @typedef {number} */ foo.Baz;", "var foo = {}; var foo$Baz;"); } public void testTypedef2() { test("var foo = {};" + "/** @typedef {number} */ foo.Bar.Baz;" + "foo.Bar = function() {};", "var foo$Bar$Baz; var foo$Bar = function(){};"); } public void testDelete1() { testSame( "var foo = {};" + "foo.bar = 3;" + "delete foo.bar;"); } public void testDelete2() { test( "var foo = {};" + "foo.bar = 3;" + "foo.baz = 3;" + "delete foo.bar;", "var foo = {};" + "foo.bar = 3;" + "var foo$baz = 3;" + "delete foo.bar;"); } public void testDelete3() { testSame( "var foo = {bar: 3};" + "delete foo.bar;"); } public void testDelete4() { test( "var foo = {bar: 3, baz: 3};" + "delete foo.bar;", "var foo$baz=3;var foo={bar:3};delete foo.bar"); } public void testDelete5() { test( "var x = {};" + "x.foo = {};" + "x.foo.bar = 3;" + "delete x.foo.bar;", "var x$foo = {};" + "x$foo.bar = 3;" + "delete x$foo.bar;"); } public void testDelete6() { test( "var x = {};" + "x.foo = {};" + "x.foo.bar = 3;" + "x.foo.baz = 3;" + "delete x.foo.bar;", "var x$foo = {};" + "x$foo.bar = 3;" + "var x$foo$baz = 3;" + "delete x$foo.bar;"); } public void testDelete7() { test( "var x = {};" + "x.foo = {bar: 3};" + "delete x.foo.bar;", "var x$foo = {bar: 3};" + "delete x$foo.bar;"); } public void testDelete8() { test( "var x = {};" + "x.foo = {bar: 3, baz: 3};" + "delete x.foo.bar;", "var x$foo$baz = 3; var x$foo = {bar: 3};" + "delete x$foo.bar;"); } public void testDelete9() { testSame( "var x = {};" + "x.foo = {};" + "x.foo.bar = 3;" + "delete x.foo;"); } public void testDelete10() { testSame( "var x = {};" + "x.foo = {bar: 3};" + "delete x.foo;"); } public void testDelete11() { // Constructors are always collapsed. test( "var x = {};" + "x.foo = {};" + "/** @constructor */ x.foo.Bar = function() {};" + "delete x.foo;", "var x = {};" + "x.foo = {};" + "var x$foo$Bar = function() {};" + "delete x.foo;", null, CollapseProperties.NAMESPACE_REDEFINED_WARNING); } public void testPreserveConstructorDoc() { test("var foo = {};" + "/** @constructor */\n" + "foo.bar = function() {}", "var foo$bar = function() {}"); Node root = getLastCompiler().getRoot(); Node fooBarNode = findQualifiedNameNode("foo$bar", root); Node varNode = fooBarNode.getParent(); assertTrue(varNode.isVar()); assertTrue(varNode.getJSDocInfo().isConstructor()); } }
/* * Copyright 2006 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Tests for variable declaration collapsing. * */ public class CollapseVariableDeclarationsTest extends CompilerTestCase { public void testCollapsing() throws Exception { // Basic collapsing test("var a;var b;", "var a,b;"); // With initial values test("var a = 1;var b = 1;", "var a=1,b=1;"); // Already collapsed test("var a, b;", "var a,b;"); // Already collapsed with values test("var a = 1, b = 1;", "var a=1,b=1;"); // Some already collapsed test("var a;var b, c;var d;", "var a,b,c,d;"); // Some already collapsed with values test("var a = 1;var b = 2, c = 3;var d = 4;", "var a=1,b=2,c=3,d=4;"); } public void testIssue820() throws Exception { // Don't redeclare function parameters, this is incompatible with // strict mode. testSame("function f(a){ var b=1; a=2; var c; }"); } public void testIfElseVarDeclarations() throws Exception { testSame("if (x) var a = 1; else var b = 2;"); } public void testAggressiveRedeclaration() { test("var x = 2; foo(x); x = 3; var y = 2;", "var x = 2; foo(x); var x = 3, y = 2;"); test("var x = 2; foo(x); x = 3; x = 1; var y = 2;", "var x = 2; foo(x); var x = 3, x = 1, y = 2;"); test("var x = 2; foo(x); x = 3; x = 1; var y = 2; var z = 4", "var x = 2; foo(x); var x = 3, x = 1, y = 2, z = 4"); test("var x = 2; foo(x); x = 3; x = 1; var y = 2; var z = 4; x = 5", "var x = 2; foo(x); var x = 3, x = 1, y = 2, z = 4, x = 5"); } public void testAggressiveRedeclarationInFor() { testSame("for(var x = 1; x = 2; x = 3) {x = 4}"); testSame("for(var x = 1; y = 2; z = 3) {var a = 4}"); testSame("var x; for(x = 1; x = 2; z = 3) {x = 4}"); } public void testIssue397() { test("var x; var y = 3; x = 5;", "var x, y = 3; x = 5;"); testSame("var x; x = 5; var z = 7;"); test("var x; var y = 3; x = 5; var z = 7;", "var x, y = 3; x = 5; var z = 7;"); test("var a = 1; var x; var y = 3; x = 5;", "var a = 1, x, y = 3; x = 5;"); } @Override protected CompilerPass getProcessor(Compiler compiler) { return new CollapseVariableDeclarations(compiler); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.Callback; import com.google.javascript.jscomp.NodeTraversal.ScopedCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import junit.framework.TestCase; import java.util.Collection; import java.util.List; import java.util.Set; /** */ public class CombinedCompilerPassTest extends TestCase { private Compiler compiler; /** * Returns a Node tree with the post-order traversal a b c d e f g h i j k l m * and the in-order traversal m d a b c h e f g l i j k: * * m * ,---------|---------. * d h l * ,--|--. ,--|--. ,--|--. * a b c e f g i j k * */ private static Node createPostOrderAlphabet() { Node a = Node.newString("a"); Node b = Node.newString("b"); Node c = Node.newString("c"); Node d = Node.newString("d"); Node e = Node.newString("e"); Node f = Node.newString("f"); Node g = Node.newString("g"); Node h = Node.newString("h"); Node i = Node.newString("i"); Node j = Node.newString("j"); Node k = Node.newString("k"); Node l = Node.newString("l"); Node m = Node.newString("m"); d.addChildToBack(a); d.addChildToBack(b); d.addChildToBack(c); h.addChildrenToBack(e); h.addChildrenToBack(f); h.addChildrenToBack(g); l.addChildToBack(i); l.addChildToBack(j); l.addChildToBack(k); m.addChildToBack(d); m.addChildToBack(h); m.addChildToBack(l); return m; } @Override public void setUp() throws Exception { super.setUp(); compiler = new Compiler(); } /** * Concatenates contents of string nodes encountered in pre-order * and post-order traversals. Abbreviates traversals by ignoring subtrees * rooted with specified strings. */ private static class ConcatTraversal implements Callback { private StringBuilder visited = new StringBuilder(); private StringBuilder shouldTraversed = new StringBuilder(); private Set<String> ignoring = Sets.newHashSet(); ConcatTraversal ignore(String s) { ignoring.add(s); return this; } @Override public void visit(NodeTraversal t, Node n, Node parent) { assertEquals(Token.STRING, n.getType()); visited.append(n.getString()); } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { assertEquals(Token.STRING, n.getType()); shouldTraversed.append(n.getString()); return !ignoring.contains(n.getString()); } /** Returns strings concatenated during post-order traversal. */ String getVisited() { return visited.toString(); } /** Returns strings concatenated during pre-order traversal. */ String getShouldTraversed() { return shouldTraversed.toString(); } Collection<String> getIgnoring() { return ignoring; } } /** * Collection of data for a traversal test. Contains the traversal callback * and the expected pre- and post-order traversal results. */ private static class TestHelper { private ConcatTraversal traversal; private String expectedVisited; private String shouldTraverseExpected; TestHelper(ConcatTraversal traversal, String expectedVisited, String shouldTraverseExpected) { this.traversal = traversal; this.expectedVisited = expectedVisited; this.shouldTraverseExpected = shouldTraverseExpected; } ConcatTraversal getTraversal() { return traversal; } void checkResults() { assertEquals("ConcatTraversal ignoring " + traversal.getIgnoring().toString() + " has unexpected visiting order", expectedVisited, traversal.getVisited()); assertEquals("ConcatTraversal ignoring " + traversal.getIgnoring().toString() + " has unexpected traversal order", shouldTraverseExpected, traversal.getShouldTraversed()); } } private static List<TestHelper> createStringTests() { List<TestHelper> tests = Lists.newArrayList(); tests.add(new TestHelper( new ConcatTraversal(), "abcdefghijklm", "mdabchefglijk")); tests.add(new TestHelper( new ConcatTraversal().ignore("d"), "efghijklm", "mdhefglijk")); tests.add(new TestHelper( new ConcatTraversal().ignore("f"), "abcdeghijklm", "mdabchefglijk")); tests.add(new TestHelper(new ConcatTraversal().ignore("m"), "", "m")); return tests; } public void testIndividualPasses() { for (TestHelper test : createStringTests()) { CombinedCompilerPass pass = new CombinedCompilerPass(compiler, test.getTraversal()); pass.process(null, createPostOrderAlphabet()); test.checkResults(); } } public void testCombinedPasses() { List<TestHelper> tests = createStringTests(); Callback[] callbacks = new Callback[tests.size()]; int i = 0; for (TestHelper test : tests) { callbacks[i++] = test.getTraversal(); } CombinedCompilerPass pass = new CombinedCompilerPass(compiler, callbacks); pass.process(null, createPostOrderAlphabet()); for (TestHelper test : tests) { test.checkResults(); } } /** * Records the scopes visited during an AST traversal. Abbreviates traversals * by ignoring subtrees rooted with specified NAME nodes. */ private static class ScopeRecordingCallback implements ScopedCallback { Set<Node> visitedScopes = Sets.newHashSet(); Set<String> ignoring = Sets.newHashSet(); void ignore(String name) { ignoring.add(name); } @Override public void enterScope(NodeTraversal t) { visitedScopes.add(t.getScopeRoot()); } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { return !n.isName() || !ignoring.contains(n.getString()); } Set<Node> getVisitedScopes() { return visitedScopes; } @Override public void exitScope(NodeTraversal t) { } @Override public void visit(NodeTraversal t, Node n, Node parent) { } } public void testScopes() { Node root = compiler.parseTestCode("var y = function() { var x = function() { };}"); ScopeRecordingCallback c1 = new ScopeRecordingCallback(); c1.ignore("y"); ScopeRecordingCallback c2 = new ScopeRecordingCallback(); c2.ignore("x"); ScopeRecordingCallback c3 = new ScopeRecordingCallback(); CombinedCompilerPass pass = new CombinedCompilerPass(compiler, c1, c2, c3); pass.process(null, root); assertEquals(1, c1.getVisitedScopes().size()); assertEquals(2, c2.getVisitedScopes().size()); assertEquals(3, c3.getVisitedScopes().size()); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.base.Function; import com.google.common.base.Joiner; import com.google.common.base.Preconditions; import com.google.common.base.Supplier; import com.google.common.base.Suppliers; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.AbstractCommandLineRunner.FlagUsageException; import com.google.javascript.jscomp.CompilerOptions.LanguageMode; import com.google.javascript.rhino.Node; import junit.framework.TestCase; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.PrintStream; import java.util.List; import java.util.Map; /** * Tests for {@link CommandLineRunner}. * * @author nicksantos@google.com (Nick Santos) */ public class CommandLineRunnerTest extends TestCase { private Compiler lastCompiler = null; private CommandLineRunner lastCommandLineRunner = null; private List<Integer> exitCodes = null; private ByteArrayOutputStream outReader = null; private ByteArrayOutputStream errReader = null; private Map<Integer,String> filenames; // If set, this will be appended to the end of the args list. // For testing args parsing. private String lastArg = null; // If set to true, uses comparison by string instead of by AST. private boolean useStringComparison = false; private ModulePattern useModules = ModulePattern.NONE; private enum ModulePattern { NONE, CHAIN, STAR } private List<String> args = Lists.newArrayList(); /** Externs for the test */ private final List<SourceFile> DEFAULT_EXTERNS = ImmutableList.of( SourceFile.fromCode("externs", "var arguments;" + "/**\n" + " * @constructor\n" + " * @param {...*} var_args\n" + " * @nosideeffects\n" + " * @throws {Error}\n" + " */\n" + "function Function(var_args) {}\n" + "/**\n" + " * @param {...*} var_args\n" + " * @return {*}\n" + " */\n" + "Function.prototype.call = function(var_args) {};" + "/**\n" + " * @constructor\n" + " * @param {...*} var_args\n" + " * @return {!Array}\n" + " */\n" + "function Array(var_args) {}" + "/**\n" + " * @param {*=} opt_begin\n" + " * @param {*=} opt_end\n" + " * @return {!Array}\n" + " * @this {Object}\n" + " */\n" + "Array.prototype.slice = function(opt_begin, opt_end) {};" + "/** @constructor */ function Window() {}\n" + "/** @type {string} */ Window.prototype.name;\n" + "/** @type {Window} */ var window;" + "/** @constructor */ function Element() {}" + "Element.prototype.offsetWidth;" + "/** @nosideeffects */ function noSideEffects() {}\n" + "/** @param {...*} x */ function alert(x) {}\n") ); private List<SourceFile> externs; @Override public void setUp() throws Exception { super.setUp(); externs = DEFAULT_EXTERNS; filenames = Maps.newHashMap(); lastCompiler = null; lastArg = null; outReader = new ByteArrayOutputStream(); errReader = new ByteArrayOutputStream(); useStringComparison = false; useModules = ModulePattern.NONE; args.clear(); exitCodes = Lists.newArrayList(); } @Override public void tearDown() throws Exception { super.tearDown(); } public void testWarningGuardOrdering1() { args.add("--jscomp_error=globalThis"); args.add("--jscomp_off=globalThis"); testSame("function f() { this.a = 3; }"); } public void testWarningGuardOrdering2() { args.add("--jscomp_off=globalThis"); args.add("--jscomp_error=globalThis"); test("function f() { this.a = 3; }", CheckGlobalThis.GLOBAL_THIS); } public void testWarningGuardOrdering3() { args.add("--jscomp_warning=globalThis"); args.add("--jscomp_off=globalThis"); testSame("function f() { this.a = 3; }"); } public void testWarningGuardOrdering4() { args.add("--jscomp_off=globalThis"); args.add("--jscomp_warning=globalThis"); test("function f() { this.a = 3; }", CheckGlobalThis.GLOBAL_THIS); } public void testSimpleModeLeavesUnusedParams() { args.add("--compilation_level=SIMPLE_OPTIMIZATIONS"); testSame("window.f = function(a) {};"); } public void testAdvancedModeRemovesUnusedParams() { args.add("--compilation_level=ADVANCED_OPTIMIZATIONS"); test("window.f = function(a) {};", "window.a = function() {};"); } public void testCheckGlobalThisOffByDefault() { testSame("function f() { this.a = 3; }"); } public void testCheckGlobalThisOnWithAdvancedMode() { args.add("--compilation_level=ADVANCED_OPTIMIZATIONS"); test("function f() { this.a = 3; }", CheckGlobalThis.GLOBAL_THIS); } public void testCheckGlobalThisOnWithErrorFlag() { args.add("--jscomp_error=globalThis"); test("function f() { this.a = 3; }", CheckGlobalThis.GLOBAL_THIS); } public void testCheckGlobalThisOff() { args.add("--warning_level=VERBOSE"); args.add("--jscomp_off=globalThis"); testSame("function f() { this.a = 3; }"); } public void testTypeCheckingOffByDefault() { test("function f(x) { return x; } f();", "function f(a) { return a; } f();"); } public void testReflectedMethods() { args.add("--compilation_level=ADVANCED_OPTIMIZATIONS"); test( "/** @constructor */" + "function Foo() {}" + "Foo.prototype.handle = function(x, y) { alert(y); };" + "var x = goog.reflect.object(Foo, {handle: 1});" + "for (var i in x) { x[i].call(x); }" + "window['Foo'] = Foo;", "function a() {}" + "a.prototype.a = function(e, d) { alert(d); };" + "var b = goog.c.b(a, {a: 1}),c;" + "for (c in b) { b[c].call(b); }" + "window.Foo = a;"); } public void testInlineVariables() { args.add("--compilation_level=ADVANCED_OPTIMIZATIONS"); test( "/** @constructor */ function F() { this.a = 0; }" + "F.prototype.inc = function() { this.a++; return 10; };" + "F.prototype.bar = function() { " + " var c = 3; var val = inc(); this.a += val + c;" + "};" + "window['f'] = new F();" + "window['f']['bar'] = window['f'].bar;", "function a(){ this.a = 0; }" + "a.prototype.b = function(){ var b=inc(); this.a += b + 3; };" + "window.f = new a;" + "window.f.bar = window.f.b"); } public void testTypedAdvanced() { args.add("--compilation_level=ADVANCED_OPTIMIZATIONS"); args.add("--use_types_for_optimization"); test( "/** @constructor */\n" + "function Foo() {}\n" + "Foo.prototype.handle1 = function(x, y) { alert(y); };\n" + "/** @constructor */\n" + "function Bar() {}\n" + "Bar.prototype.handle1 = function(x, y) {};\n" + "new Foo().handle1(1, 2);\n" + "new Bar().handle1(1, 2);\n", "alert(2)"); } public void testTypeCheckingOnWithVerbose() { args.add("--warning_level=VERBOSE"); test("function f(x) { return x; } f();", TypeCheck.WRONG_ARGUMENT_COUNT); } public void testTypeParsingOffByDefault() { testSame("/** @return {number */ function f(a) { return a; }"); } public void testTypeParsingOnWithVerbose() { args.add("--warning_level=VERBOSE"); test("/** @return {number */ function f(a) { return a; }", RhinoErrorReporter.TYPE_PARSE_ERROR); test("/** @return {n} */ function f(a) { return a; }", RhinoErrorReporter.TYPE_PARSE_ERROR); } public void testTypeCheckOverride1() { args.add("--warning_level=VERBOSE"); args.add("--jscomp_off=checkTypes"); testSame("var x = x || {}; x.f = function() {}; x.f(3);"); } public void testTypeCheckOverride2() { args.add("--warning_level=DEFAULT"); testSame("var x = x || {}; x.f = function() {}; x.f(3);"); args.add("--jscomp_warning=checkTypes"); test("var x = x || {}; x.f = function() {}; x.f(3);", TypeCheck.WRONG_ARGUMENT_COUNT); } public void testCheckSymbolsOffForDefault() { args.add("--warning_level=DEFAULT"); test("x = 3; var y; var y;", "x=3; var y;"); } public void testCheckSymbolsOnForVerbose() { args.add("--warning_level=VERBOSE"); test("x = 3;", VarCheck.UNDEFINED_VAR_ERROR); test("var y; var y;", SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR); } public void testCheckSymbolsOverrideForVerbose() { args.add("--warning_level=VERBOSE"); args.add("--jscomp_off=undefinedVars"); testSame("x = 3;"); } public void testCheckSymbolsOverrideForQuiet() { args.add("--warning_level=QUIET"); args.add("--jscomp_error=undefinedVars"); test("x = 3;", VarCheck.UNDEFINED_VAR_ERROR); } public void testCheckUndefinedProperties1() { args.add("--warning_level=VERBOSE"); args.add("--jscomp_error=missingProperties"); test("var x = {}; var y = x.bar;", TypeCheck.INEXISTENT_PROPERTY); } public void testCheckUndefinedProperties2() { args.add("--warning_level=VERBOSE"); args.add("--jscomp_off=missingProperties"); test("var x = {}; var y = x.bar;", CheckGlobalNames.UNDEFINED_NAME_WARNING); } public void testCheckUndefinedProperties3() { args.add("--warning_level=VERBOSE"); test("function f() {var x = {}; var y = x.bar;}", TypeCheck.INEXISTENT_PROPERTY); } public void testDuplicateParams() { test("function f(a, a) {}", RhinoErrorReporter.DUPLICATE_PARAM); assertTrue(lastCompiler.hasHaltingErrors()); } public void testDefineFlag() { args.add("--define=FOO"); args.add("--define=\"BAR=5\""); args.add("--D"); args.add("CCC"); args.add("-D"); args.add("DDD"); test("/** @define {boolean} */ var FOO = false;" + "/** @define {number} */ var BAR = 3;" + "/** @define {boolean} */ var CCC = false;" + "/** @define {boolean} */ var DDD = false;", "var FOO = !0, BAR = 5, CCC = !0, DDD = !0;"); } public void testDefineFlag2() { args.add("--define=FOO='x\"'"); test("/** @define {string} */ var FOO = \"a\";", "var FOO = \"x\\\"\";"); } public void testDefineFlag3() { args.add("--define=FOO=\"x'\""); test("/** @define {string} */ var FOO = \"a\";", "var FOO = \"x'\";"); } public void testScriptStrictModeNoWarning() { test("'use strict';", ""); test("'no use strict';", CheckSideEffects.USELESS_CODE_ERROR); } public void testFunctionStrictModeNoWarning() { test("function f() {'use strict';}", "function f() {}"); test("function f() {'no use strict';}", CheckSideEffects.USELESS_CODE_ERROR); } public void testQuietMode() { args.add("--warning_level=DEFAULT"); test("/** @const \n * @const */ var x;", RhinoErrorReporter.PARSE_ERROR); args.add("--warning_level=QUIET"); testSame("/** @const \n * @const */ var x;"); } public void testProcessClosurePrimitives() { test("var goog = {}; goog.provide('goog.dom');", "var goog = {dom:{}};"); args.add("--process_closure_primitives=false"); testSame("var goog = {}; goog.provide('goog.dom');"); } public void testGetMsgWiring() throws Exception { test("var goog = {}; goog.getMsg = function(x) { return x; };" + "/** @desc A real foo. */ var MSG_FOO = goog.getMsg('foo');", "var goog={getMsg:function(a){return a}}, " + "MSG_FOO=goog.getMsg('foo');"); args.add("--compilation_level=ADVANCED_OPTIMIZATIONS"); test("var goog = {}; goog.getMsg = function(x) { return x; };" + "/** @desc A real foo. */ var MSG_FOO = goog.getMsg('foo');" + "window['foo'] = MSG_FOO;", "window.foo = 'foo';"); } public void testCssNameWiring() throws Exception { test("var goog = {}; goog.getCssName = function() {};" + "goog.setCssNameMapping = function() {};" + "goog.setCssNameMapping({'goog': 'a', 'button': 'b'});" + "var a = goog.getCssName('goog-button');" + "var b = goog.getCssName('css-button');" + "var c = goog.getCssName('goog-menu');" + "var d = goog.getCssName('css-menu');", "var goog = { getCssName: function() {}," + " setCssNameMapping: function() {} }," + " a = 'a-b'," + " b = 'css-b'," + " c = 'a-menu'," + " d = 'css-menu';"); } ////////////////////////////////////////////////////////////////////////////// // Integration tests public void testIssue70a() { test("function foo({}) {}", RhinoErrorReporter.PARSE_ERROR); } public void testIssue70b() { test("function foo([]) {}", RhinoErrorReporter.PARSE_ERROR); } public void testIssue81() { args.add("--compilation_level=ADVANCED_OPTIMIZATIONS"); useStringComparison = true; test("eval('1'); var x = eval; x('2');", "eval(\"1\");(0,eval)(\"2\");"); } public void testIssue115() { args.add("--compilation_level=SIMPLE_OPTIMIZATIONS"); args.add("--jscomp_off=es5Strict"); args.add("--warning_level=VERBOSE"); test("function f() { " + " var arguments = Array.prototype.slice.call(arguments, 0);" + " return arguments[0]; " + "}", "function f() { " + " arguments = Array.prototype.slice.call(arguments, 0);" + " return arguments[0]; " + "}"); } public void testIssue297() { args.add("--compilation_level=SIMPLE_OPTIMIZATIONS"); test("function f(p) {" + " var x;" + " return ((x=p.id) && (x=parseInt(x.substr(1))) && x>0);" + "}", "function f(b) {" + " var a;" + " return ((a=b.id) && (a=parseInt(a.substr(1))) && 0<a);" + "}"); } public void testHiddenSideEffect() { args.add("--compilation_level=ADVANCED_OPTIMIZATIONS"); test("element.offsetWidth;", "element.offsetWidth", CheckSideEffects.USELESS_CODE_ERROR); } public void testIssue504() { args.add("--compilation_level=ADVANCED_OPTIMIZATIONS"); test("void function() { alert('hi'); }();", "alert('hi');void 0", CheckSideEffects.USELESS_CODE_ERROR); } public void testIssue601() { args.add("--compilation_level=WHITESPACE_ONLY"); test("function f() { return '\\v' == 'v'; } window['f'] = f;", "function f(){return'\\v'=='v'}window['f']=f"); } public void testIssue601b() { args.add("--compilation_level=ADVANCED_OPTIMIZATIONS"); test("function f() { return '\\v' == 'v'; } window['f'] = f;", "window.f=function(){return'\\v'=='v'}"); } public void testIssue601c() { args.add("--compilation_level=ADVANCED_OPTIMIZATIONS"); test("function f() { return '\\u000B' == 'v'; } window['f'] = f;", "window.f=function(){return'\\u000B'=='v'}"); } public void testIssue846() { args.add("--compilation_level=ADVANCED_OPTIMIZATIONS"); testSame( "try { new Function('this is an error'); } catch(a) { alert('x'); }"); } public void testDebugFlag1() { args.add("--compilation_level=SIMPLE_OPTIMIZATIONS"); args.add("--debug=false"); test("function foo(a) {}", "function foo(a) {}"); } public void testDebugFlag2() { args.add("--compilation_level=SIMPLE_OPTIMIZATIONS"); args.add("--debug=true"); test("function foo(a) {alert(a)}", "function foo($a$$) {alert($a$$)}"); } public void testDebugFlag3() { args.add("--compilation_level=ADVANCED_OPTIMIZATIONS"); args.add("--warning_level=QUIET"); args.add("--debug=false"); test("function Foo() {}" + "Foo.x = 1;" + "function f() {throw new Foo().x;} f();", "throw (new function() {}).a;"); } public void testDebugFlag4() { args.add("--compilation_level=ADVANCED_OPTIMIZATIONS"); args.add("--warning_level=QUIET"); args.add("--debug=true"); test("function Foo() {}" + "Foo.x = 1;" + "function f() {throw new Foo().x;} f();", "throw (new function Foo() {}).$x$;"); } public void testBooleanFlag1() { args.add("--compilation_level=SIMPLE_OPTIMIZATIONS"); args.add("--debug"); test("function foo(a) {alert(a)}", "function foo($a$$) {alert($a$$)}"); } public void testBooleanFlag2() { args.add("--debug"); args.add("--compilation_level=SIMPLE_OPTIMIZATIONS"); test("function foo(a) {alert(a)}", "function foo($a$$) {alert($a$$)}"); } public void testHelpFlag() { args.add("--help"); assertFalse( createCommandLineRunner( new String[] {"function f() {}"}).shouldRunCompiler()); } public void testExternsLifting1() throws Exception{ String code = "/** @externs */ function f() {}"; test(new String[] {code}, new String[] {}); assertEquals(2, lastCompiler.getExternsForTesting().size()); CompilerInput extern = lastCompiler.getExternsForTesting().get(1); assertNull(extern.getModule()); assertTrue(extern.isExtern()); assertEquals(code, extern.getCode()); assertEquals(1, lastCompiler.getInputsForTesting().size()); CompilerInput input = lastCompiler.getInputsForTesting().get(0); assertNotNull(input.getModule()); assertFalse(input.isExtern()); assertEquals("", input.getCode()); } public void testExternsLifting2() { args.add("--warning_level=VERBOSE"); test(new String[] {"/** @externs */ function f() {}", "f(3);"}, new String[] {"f(3);"}, TypeCheck.WRONG_ARGUMENT_COUNT); } public void testSourceSortingOff() { args.add("--compilation_level=WHITESPACE_ONLY"); testSame( new String[] { "goog.require('beer');", "goog.provide('beer');" }); } public void testSourceSortingOn() { test(new String[] { "goog.require('beer');", "goog.provide('beer');" }, new String[] { "var beer = {};", "" }); } public void testSourceSortingOn2() { test(new String[] { "goog.provide('a');", "goog.require('a');\n" + "var COMPILED = false;", }, new String[] { "var a={};", "var COMPILED=!1" }); } public void testSourceSortingOn3() { args.add("--manage_closure_dependencies=true"); test(new String[] { "goog.addDependency('sym', [], []);\nvar x = 3;", "var COMPILED = false;", }, new String[] { "var COMPILED = !1;", "var x = 3;" }); } public void testSourceSortingCircularDeps1() { args.add("--manage_closure_dependencies=true"); test(new String[] { "goog.provide('gin'); goog.require('tonic'); var gin = {};", "goog.provide('tonic'); goog.require('gin'); var tonic = {};", "goog.require('gin'); goog.require('tonic');" }, JSModule.CIRCULAR_DEPENDENCY_ERROR); } public void testSourceSortingCircularDeps2() { args.add("--manage_closure_dependencies=true"); test(new String[] { "goog.provide('roses.lime.juice');", "goog.provide('gin'); goog.require('tonic'); var gin = {};", "goog.provide('tonic'); goog.require('gin'); var tonic = {};", "goog.require('gin'); goog.require('tonic');", "goog.provide('gimlet');" + " goog.require('gin'); goog.require('roses.lime.juice');" }, JSModule.CIRCULAR_DEPENDENCY_ERROR); } public void testSourcePruningOn1() { args.add("--manage_closure_dependencies=true"); test(new String[] { "goog.require('beer');", "goog.provide('beer');", "goog.provide('scotch'); var x = 3;" }, new String[] { "var beer = {};", "" }); } public void testSourcePruningOn2() { args.add("--closure_entry_point=guinness"); test(new String[] { "goog.provide('guinness');\ngoog.require('beer');", "goog.provide('beer');", "goog.provide('scotch'); var x = 3;" }, new String[] { "var beer = {};", "var guinness = {};" }); } public void testSourcePruningOn3() { args.add("--closure_entry_point=scotch"); test(new String[] { "goog.provide('guinness');\ngoog.require('beer');", "goog.provide('beer');", "goog.provide('scotch'); var x = 3;" }, new String[] { "var scotch = {}, x = 3;", }); } public void testSourcePruningOn4() { args.add("--closure_entry_point=scotch"); args.add("--closure_entry_point=beer"); test(new String[] { "goog.provide('guinness');\ngoog.require('beer');", "goog.provide('beer');", "goog.provide('scotch'); var x = 3;" }, new String[] { "var beer = {};", "var scotch = {}, x = 3;", }); } public void testSourcePruningOn5() { args.add("--closure_entry_point=shiraz"); test(new String[] { "goog.provide('guinness');\ngoog.require('beer');", "goog.provide('beer');", "goog.provide('scotch'); var x = 3;" }, Compiler.MISSING_ENTRY_ERROR); } public void testSourcePruningOn6() { args.add("--closure_entry_point=scotch"); test(new String[] { "goog.require('beer');", "goog.provide('beer');", "goog.provide('scotch'); var x = 3;" }, new String[] { "var beer = {};", "", "var scotch = {}, x = 3;", }); } public void testSourcePruningOn7() { args.add("--manage_closure_dependencies=true"); test(new String[] { "var COMPILED = false;", }, new String[] { "var COMPILED = !1;", }); } public void testSourcePruningOn8() { args.add("--only_closure_dependencies"); args.add("--closure_entry_point=scotch"); args.add("--warning_level=VERBOSE"); test(new String[] { "/** @externs */\n" + "var externVar;", "goog.provide('scotch'); var x = externVar;" }, new String[] { "var scotch = {}, x = externVar;", }); } public void testNoCompile() { args.add("--warning_level=VERBOSE"); test(new String[] { "/** @nocompile */\n" + "goog.provide('x');\n" + "var dupeVar;", "var dupeVar;" }, new String[] { "var dupeVar;" }); } public void testDependencySortingWhitespaceMode() { args.add("--manage_closure_dependencies"); args.add("--compilation_level=WHITESPACE_ONLY"); test(new String[] { "goog.require('beer');", "goog.provide('beer');\ngoog.require('hops');", "goog.provide('hops');", }, new String[] { "goog.provide('hops');", "goog.provide('beer');\ngoog.require('hops');", "goog.require('beer');" }); } public void testForwardDeclareDroppedTypes() { args.add("--manage_closure_dependencies=true"); args.add("--warning_level=VERBOSE"); test(new String[] { "goog.require('beer');", "goog.provide('beer'); /** @param {Scotch} x */ function f(x) {}", "goog.provide('Scotch'); var x = 3;" }, new String[] { "var beer = {}; function f(a) {}", "" }); test(new String[] { "goog.require('beer');", "goog.provide('beer'); /** @param {Scotch} x */ function f(x) {}" }, new String[] { "var beer = {}; function f(a) {}", "" }, RhinoErrorReporter.TYPE_PARSE_ERROR); } public void testOnlyClosureDependenciesEmptyEntryPoints() throws Exception { // Prevents this from trying to load externs.zip args.add("--use_only_custom_externs=true"); args.add("--only_closure_dependencies=true"); try { CommandLineRunner runner = createCommandLineRunner(new String[0]); runner.doRun(); fail("Expected FlagUsageException"); } catch (FlagUsageException e) { assertTrue(e.getMessage(), e.getMessage().contains("only_closure_dependencies")); } } public void testOnlyClosureDependenciesOneEntryPoint() throws Exception { args.add("--only_closure_dependencies=true"); args.add("--closure_entry_point=beer"); test(new String[] { "goog.require('beer'); var beerRequired = 1;", "goog.provide('beer');\ngoog.require('hops');\nvar beerProvided = 1;", "goog.provide('hops'); var hopsProvided = 1;", "goog.provide('scotch'); var scotchProvided = 1;", "goog.require('scotch');\nvar includeFileWithoutProvides = 1;", "/** This is base.js */\nvar COMPILED = false;", }, new String[] { "var COMPILED = !1;", "var hops = {}, hopsProvided = 1;", "var beer = {}, beerProvided = 1;" }); } public void testSourceMapExpansion1() { args.add("--js_output_file"); args.add("/path/to/out.js"); args.add("--create_source_map=%outname%.map"); testSame("var x = 3;"); assertEquals("/path/to/out.js.map", lastCommandLineRunner.expandSourceMapPath( lastCompiler.getOptions(), null)); } public void testSourceMapExpansion2() { useModules = ModulePattern.CHAIN; args.add("--create_source_map=%outname%.map"); args.add("--module_output_path_prefix=foo"); testSame(new String[] {"var x = 3;", "var y = 5;"}); assertEquals("foo.map", lastCommandLineRunner.expandSourceMapPath( lastCompiler.getOptions(), null)); } public void testSourceMapExpansion3() { useModules = ModulePattern.CHAIN; args.add("--create_source_map=%outname%.map"); args.add("--module_output_path_prefix=foo_"); testSame(new String[] {"var x = 3;", "var y = 5;"}); assertEquals("foo_m0.js.map", lastCommandLineRunner.expandSourceMapPath( lastCompiler.getOptions(), lastCompiler.getModuleGraph().getRootModule())); } public void testSourceMapFormat1() { args.add("--js_output_file"); args.add("/path/to/out.js"); testSame("var x = 3;"); assertEquals(SourceMap.Format.DEFAULT, lastCompiler.getOptions().sourceMapFormat); } public void testSourceMapFormat2() { args.add("--js_output_file"); args.add("/path/to/out.js"); args.add("--source_map_format=V3"); testSame("var x = 3;"); assertEquals(SourceMap.Format.V3, lastCompiler.getOptions().sourceMapFormat); } public void testModuleWrapperBaseNameExpansion() throws Exception { useModules = ModulePattern.CHAIN; args.add("--module_wrapper=m0:%s // %basename%"); testSame(new String[] { "var x = 3;", "var y = 4;" }); StringBuilder builder = new StringBuilder(); lastCommandLineRunner.writeModuleOutput( builder, lastCompiler.getModuleGraph().getRootModule()); assertEquals("var x=3; // m0.js\n", builder.toString()); } public void testCharSetExpansion() { testSame(""); assertEquals("US-ASCII", lastCompiler.getOptions().outputCharset); args.add("--charset=UTF-8"); testSame(""); assertEquals("UTF-8", lastCompiler.getOptions().outputCharset); } public void testChainModuleManifest() throws Exception { useModules = ModulePattern.CHAIN; testSame(new String[] { "var x = 3;", "var y = 5;", "var z = 7;", "var a = 9;"}); StringBuilder builder = new StringBuilder(); lastCommandLineRunner.printModuleGraphManifestOrBundleTo( lastCompiler.getModuleGraph(), builder, true); assertEquals( "{m0}\n" + "i0\n" + "\n" + "{m1:m0}\n" + "i1\n" + "\n" + "{m2:m1}\n" + "i2\n" + "\n" + "{m3:m2}\n" + "i3\n", builder.toString()); } public void testStarModuleManifest() throws Exception { useModules = ModulePattern.STAR; testSame(new String[] { "var x = 3;", "var y = 5;", "var z = 7;", "var a = 9;"}); StringBuilder builder = new StringBuilder(); lastCommandLineRunner.printModuleGraphManifestOrBundleTo( lastCompiler.getModuleGraph(), builder, true); assertEquals( "{m0}\n" + "i0\n" + "\n" + "{m1:m0}\n" + "i1\n" + "\n" + "{m2:m0}\n" + "i2\n" + "\n" + "{m3:m0}\n" + "i3\n", builder.toString()); } public void testOutputModuleGraphJson() throws Exception { useModules = ModulePattern.STAR; testSame(new String[] { "var x = 3;", "var y = 5;", "var z = 7;", "var a = 9;"}); StringBuilder builder = new StringBuilder(); lastCommandLineRunner.printModuleGraphJsonTo( lastCompiler.getModuleGraph(), builder); assertTrue(builder.toString().indexOf("transitive-dependencies") != -1); } public void testVersionFlag() { args.add("--version"); testSame(""); assertEquals( 0, new String(errReader.toByteArray()).indexOf( "Closure Compiler (http://code.google.com/closure/compiler)\n" + "Version: ")); } public void testVersionFlag2() { lastArg = "--version"; testSame(""); assertEquals( 0, new String(errReader.toByteArray()).indexOf( "Closure Compiler (http://code.google.com/closure/compiler)\n" + "Version: ")); } public void testPrintAstFlag() { args.add("--print_ast=true"); testSame(""); assertEquals( "digraph AST {\n" + " node [color=lightblue2, style=filled];\n" + " node0 [label=\"BLOCK\"];\n" + " node1 [label=\"SCRIPT\"];\n" + " node0 -> node1 [weight=1];\n" + " node1 -> RETURN [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node0 -> RETURN [label=\"SYN_BLOCK\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node0 -> node1 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "}\n\n", new String(outReader.toByteArray())); } public void testSyntheticExterns() { externs = ImmutableList.of( SourceFile.fromCode("externs", "myVar.property;")); test("var theirVar = {}; var myVar = {}; var yourVar = {};", VarCheck.UNDEFINED_EXTERN_VAR_ERROR); args.add("--jscomp_off=externsValidation"); args.add("--warning_level=VERBOSE"); test("var theirVar = {}; var myVar = {}; var yourVar = {};", "var theirVar={},myVar={},yourVar={};"); args.add("--jscomp_off=externsValidation"); args.add("--warning_level=VERBOSE"); test("var theirVar = {}; var myVar = {}; var myVar = {};", SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR); } public void testGoogAssertStripping() { args.add("--compilation_level=ADVANCED_OPTIMIZATIONS"); test("goog.asserts.assert(false)", ""); args.add("--debug"); test("goog.asserts.assert(false)", "goog.$asserts$.$assert$(!1)"); } public void testMissingReturnCheckOnWithVerbose() { args.add("--warning_level=VERBOSE"); test("/** @return {number} */ function f() {f()} f();", CheckMissingReturn.MISSING_RETURN_STATEMENT); } public void testGenerateExports() { args.add("--generate_exports=true"); test("/** @export */ foo.prototype.x = function() {};", "foo.prototype.x=function(){};"+ "goog.exportSymbol(\"foo.prototype.x\",foo.prototype.x);"); } public void testDepreciationWithVerbose() { args.add("--warning_level=VERBOSE"); test("/** @deprecated */ function f() {}; f()", CheckAccessControls.DEPRECATED_NAME); } public void testTwoParseErrors() { // If parse errors are reported in different files, make // sure all of them are reported. Compiler compiler = compile(new String[] { "var a b;", "var b c;" }); assertEquals(2, compiler.getErrors().length); } public void testES3ByDefault() { test("var x = f.function", RhinoErrorReporter.PARSE_ERROR); } public void testES5ChecksByDefault() { testSame("var x = 3; delete x;"); } public void testES5ChecksInVerbose() { args.add("--warning_level=VERBOSE"); test("function f(x) { delete x; }", StrictModeCheck.DELETE_VARIABLE); } public void testES5() { args.add("--language_in=ECMASCRIPT5"); test("var x = f.function", "var x = f.function"); test("var let", "var let"); } public void testES5Strict() { args.add("--language_in=ECMASCRIPT5_STRICT"); test("var x = f.function", "'use strict';var x = f.function"); test("var let", RhinoErrorReporter.PARSE_ERROR); test("function f(x) { delete x; }", StrictModeCheck.DELETE_VARIABLE); } public void testES5StrictUseStrict() { args.add("--language_in=ECMASCRIPT5_STRICT"); Compiler compiler = compile(new String[] {"var x = f.function"}); String outputSource = compiler.toSource(); assertEquals("'use strict'", outputSource.substring(0, 12)); } public void testES5StrictUseStrictMultipleInputs() { args.add("--language_in=ECMASCRIPT5_STRICT"); Compiler compiler = compile(new String[] {"var x = f.function", "var y = f.function", "var z = f.function"}); String outputSource = compiler.toSource(); assertEquals("'use strict'", outputSource.substring(0, 12)); assertEquals(outputSource.substring(13).indexOf("'use strict'"), -1); } public void testWithKeywordDefault() { test("var x = {}; with (x) {}", ControlStructureCheck.USE_OF_WITH); } public void testWithKeywordWithEs5ChecksOff() { args.add("--jscomp_off=es5Strict"); testSame("var x = {}; with (x) {}"); } public void testNoSrCFilesWithManifest() throws IOException { args.add("--use_only_custom_externs=true"); args.add("--output_manifest=test.MF"); CommandLineRunner runner = createCommandLineRunner(new String[0]); String expectedMessage = ""; try { runner.doRun(); } catch (FlagUsageException e) { expectedMessage = e.getMessage(); } assertEquals(expectedMessage, "Bad --js flag. " + "Manifest files cannot be generated when the input is from stdin."); } public void testTransformAMD() { args.add("--transform_amd_modules"); test("define({test: 1})", "exports = {test: 1}"); } public void testProcessCJS() { useStringComparison = true; args.add("--process_common_js_modules"); args.add("--common_js_entry_module=foo/bar"); setFilename(0, "foo/bar.js"); String expected = "var module$foo$bar={test:1};"; test("exports.test = 1", expected); assertEquals(expected + "\n", outReader.toString()); } public void testProcessCJSWithModuleOutput() { useStringComparison = true; args.add("--process_common_js_modules"); args.add("--common_js_entry_module=foo/bar"); args.add("--module=auto"); setFilename(0, "foo/bar.js"); test("exports.test = 1", "var module$foo$bar={test:1};"); // With modules=auto no direct output is created. assertEquals("", outReader.toString()); } public void testFormattingSingleQuote() { testSame("var x = '';"); assertEquals("var x=\"\";", lastCompiler.toSource()); args.add("--formatting=SINGLE_QUOTES"); testSame("var x = '';"); assertEquals("var x='';", lastCompiler.toSource()); } public void testTransformAMDAndProcessCJS() { useStringComparison = true; args.add("--transform_amd_modules"); args.add("--process_common_js_modules"); args.add("--common_js_entry_module=foo/bar"); setFilename(0, "foo/bar.js"); test("define({foo: 1})", "var module$foo$bar={},module$foo$bar={foo:1};"); } public void testModuleJSON() { useStringComparison = true; args.add("--transform_amd_modules"); args.add("--process_common_js_modules"); args.add("--common_js_entry_module=foo/bar"); args.add("--output_module_dependencies=test.json"); setFilename(0, "foo/bar.js"); test("define({foo: 1})", "var module$foo$bar={},module$foo$bar={foo:1};"); } public void testOutputSameAsInput() { args.add("--js_output_file=" + getFilename(0)); test("", AbstractCommandLineRunner.OUTPUT_SAME_AS_INPUT_ERROR); } /* Helper functions */ private void testSame(String original) { testSame(new String[] { original }); } private void testSame(String[] original) { test(original, original); } private void test(String original, String compiled) { test(new String[] { original }, new String[] { compiled }); } /** * Asserts that when compiling with the given compiler options, * {@code original} is transformed into {@code compiled}. */ private void test(String[] original, String[] compiled) { test(original, compiled, null); } /** * Asserts that when compiling with the given compiler options, * {@code original} is transformed into {@code compiled}. * If {@code warning} is non-null, we will also check if the given * warning type was emitted. */ private void test(String[] original, String[] compiled, DiagnosticType warning) { Compiler compiler = compile(original); if (warning == null) { assertEquals("Expected no warnings or errors\n" + "Errors: \n" + Joiner.on("\n").join(compiler.getErrors()) + "Warnings: \n" + Joiner.on("\n").join(compiler.getWarnings()), 0, compiler.getErrors().length + compiler.getWarnings().length); } else { assertEquals(1, compiler.getWarnings().length); assertEquals(warning, compiler.getWarnings()[0].getType()); } Node root = compiler.getRoot().getLastChild(); if (useStringComparison) { assertEquals(Joiner.on("").join(compiled), compiler.toSource()); } else { Node expectedRoot = parse(compiled); String explanation = expectedRoot.checkTreeEquals(root); assertNull("\nExpected: " + compiler.toSource(expectedRoot) + "\nResult: " + compiler.toSource(root) + "\n" + explanation, explanation); } } /** * Asserts that when compiling, there is an error or warning. */ private void test(String original, DiagnosticType warning) { test(new String[] { original }, warning); } private void test(String original, String expected, DiagnosticType warning) { test(new String[] { original }, new String[] { expected }, warning); } /** * Asserts that when compiling, there is an error or warning. */ private void test(String[] original, DiagnosticType warning) { Compiler compiler = compile(original); assertEquals("Expected exactly one warning or error " + "Errors: \n" + Joiner.on("\n").join(compiler.getErrors()) + "Warnings: \n" + Joiner.on("\n").join(compiler.getWarnings()), 1, compiler.getErrors().length + compiler.getWarnings().length); assertTrue(exitCodes.size() > 0); int lastExitCode = exitCodes.get(exitCodes.size() - 1); if (compiler.getErrors().length > 0) { assertEquals(1, compiler.getErrors().length); assertEquals(warning, compiler.getErrors()[0].getType()); assertEquals(1, lastExitCode); } else { assertEquals(1, compiler.getWarnings().length); assertEquals(warning, compiler.getWarnings()[0].getType()); assertEquals(0, lastExitCode); } } private CommandLineRunner createCommandLineRunner(String[] original) { for (int i = 0; i < original.length; i++) { args.add("--js"); args.add("/path/to/input" + i + ".js"); if (useModules == ModulePattern.CHAIN) { args.add("--module"); args.add("m" + i + ":1" + (i > 0 ? (":m" + (i - 1)) : "")); } else if (useModules == ModulePattern.STAR) { args.add("--module"); args.add("m" + i + ":1" + (i > 0 ? ":m0" : "")); } } if (lastArg != null) { args.add(lastArg); } String[] argStrings = args.toArray(new String[] {}); return new CommandLineRunner( argStrings, new PrintStream(outReader), new PrintStream(errReader)); } private Compiler compile(String[] original) { CommandLineRunner runner = createCommandLineRunner(original); assertTrue(new String(errReader.toByteArray()), runner.shouldRunCompiler()); Supplier<List<SourceFile>> inputsSupplier = null; Supplier<List<JSModule>> modulesSupplier = null; if (useModules == ModulePattern.NONE) { List<SourceFile> inputs = Lists.newArrayList(); for (int i = 0; i < original.length; i++) { inputs.add(SourceFile.fromCode(getFilename(i), original[i])); } inputsSupplier = Suppliers.ofInstance(inputs); } else if (useModules == ModulePattern.STAR) { modulesSupplier = Suppliers.<List<JSModule>>ofInstance( Lists.<JSModule>newArrayList( CompilerTestCase.createModuleStar(original))); } else if (useModules == ModulePattern.CHAIN) { modulesSupplier = Suppliers.<List<JSModule>>ofInstance( Lists.<JSModule>newArrayList( CompilerTestCase.createModuleChain(original))); } else { throw new IllegalArgumentException("Unknown module type: " + useModules); } runner.enableTestMode( Suppliers.<List<SourceFile>>ofInstance(externs), inputsSupplier, modulesSupplier, new Function<Integer, Boolean>() { @Override public Boolean apply(Integer code) { return exitCodes.add(code); } }); runner.run(); lastCompiler = runner.getCompiler(); lastCommandLineRunner = runner; return lastCompiler; } private Node parse(String[] original) { String[] argStrings = args.toArray(new String[] {}); CommandLineRunner runner = new CommandLineRunner(argStrings); Compiler compiler = runner.createCompiler(); List<SourceFile> inputs = Lists.newArrayList(); for (int i = 0; i < original.length; i++) { inputs.add(SourceFile.fromCode(getFilename(i), original[i])); } CompilerOptions options = new CompilerOptions(); // ECMASCRIPT5 is the most forgiving. options.setLanguageIn(LanguageMode.ECMASCRIPT5); compiler.init(externs, inputs, options); Node all = compiler.parseInputs(); Preconditions.checkState(compiler.getErrorCount() == 0); Preconditions.checkNotNull(all); Node n = all.getLastChild(); return n; } private void setFilename(int i, String filename) { this.filenames.put(i, filename); } private String getFilename(int i) { if (filenames.isEmpty()) { return "input" + i; } return filenames.get(i); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import junit.framework.TestCase; import java.util.Map; /** * Tests for {@link CompilerOptions}. * @author nicksantos@google.com (Nick Santos) */ public class CompilerOptionsTest extends TestCase { public void testDefines() throws Exception { CompilerOptions options = new CompilerOptions(); options.setDefineToBooleanLiteral("trueVar", true); options.setDefineToBooleanLiteral("falseVar", false); options.setDefineToNumberLiteral("threeVar", 3); options.setDefineToStringLiteral("strVar", "str"); Map<String, Node> actual = options.getDefineReplacements(); assertEquivalent(new Node(Token.TRUE), actual.get("trueVar")); assertEquivalent(new Node(Token.FALSE), actual.get("falseVar")); assertEquivalent(Node.newNumber(3), actual.get("threeVar")); assertEquivalent(Node.newString("str"), actual.get("strVar")); } public void assertEquivalent(Node a, Node b) { assertTrue(a.isEquivalentTo(b)); } }
/* * Copyright 2010 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import junit.framework.TestCase; import java.util.List; /** * @author johnlenz@google.com (John Lenz) */ public class CompilerTest extends TestCase { public void testCodeBuilderColumnAfterResetDummy() { Compiler compiler = new Compiler(); Node n = compiler.parseTestCode(""); Compiler.CodeBuilder cb = new Compiler.CodeBuilder(); } // Verify the line and column information is maintained after a reset public void testCodeBuilderColumnAfterReset() { Compiler.CodeBuilder cb = new Compiler.CodeBuilder(); String js = "foo();\ngoo();"; cb.append(js); assertEquals(js, cb.toString()); assertEquals(1, cb.getLineIndex()); assertEquals(6, cb.getColumnIndex()); cb.reset(); assertTrue(cb.toString().isEmpty()); assertEquals(1, cb.getLineIndex()); assertEquals(6, cb.getColumnIndex()); } public void testCodeBuilderAppend() { Compiler.CodeBuilder cb = new Compiler.CodeBuilder(); cb.append("foo();"); assertEquals(0, cb.getLineIndex()); assertEquals(6, cb.getColumnIndex()); cb.append("goo();"); assertEquals(0, cb.getLineIndex()); assertEquals(12, cb.getColumnIndex()); // newline reset the column index cb.append("blah();\ngoo();"); assertEquals(1, cb.getLineIndex()); assertEquals(6, cb.getColumnIndex()); } public void testCyclicalDependencyInInputs() { List<SourceFile> inputs = Lists.newArrayList( SourceFile.fromCode( "gin", "goog.provide('gin'); goog.require('tonic'); var gin = {};"), SourceFile.fromCode("tonic", "goog.provide('tonic'); goog.require('gin'); var tonic = {};"), SourceFile.fromCode( "mix", "goog.require('gin'); goog.require('tonic');")); CompilerOptions options = new CompilerOptions(); options.ideMode = true; options.setManageClosureDependencies(true); Compiler compiler = new Compiler(); compiler.init(ImmutableList.<SourceFile>of(), inputs, options); compiler.parseInputs(); assertEquals(compiler.externAndJsRoot, compiler.jsRoot.getParent()); assertEquals(compiler.externAndJsRoot, compiler.externsRoot.getParent()); assertNotNull(compiler.externAndJsRoot); Node jsRoot = compiler.jsRoot; assertEquals(3, jsRoot.getChildCount()); } public void testLocalUndefined() throws Exception { // Some JavaScript libraries like to create a local instance of "undefined", // to ensure that other libraries don't try to overwrite it. // // Most of the time, this is OK, because normalization will rename // that variable to undefined$$1. But this won't happen if they don't // include the default externs. // // This test is just to make sure that the compiler doesn't crash. CompilerOptions options = new CompilerOptions(); CompilationLevel.SIMPLE_OPTIMIZATIONS.setOptionsForCompilationLevel( options); Compiler compiler = new Compiler(); SourceFile externs = SourceFile.fromCode("externs.js", ""); SourceFile input = SourceFile.fromCode("input.js", "(function (undefined) { alert(undefined); })();"); compiler.compile(externs, input, options); } public void testCommonJSProvidesAndRequire() throws Exception { List<SourceFile> inputs = Lists.newArrayList( SourceFile.fromCode("gin.js", "require('tonic')"), SourceFile.fromCode("tonic.js", ""), SourceFile.fromCode("mix.js", "require('gin'); require('tonic');")); List<String> entryPoints = Lists.newArrayList("module$mix"); Compiler compiler = initCompilerForCommonJS(inputs, entryPoints); JSModuleGraph graph = compiler.getModuleGraph(); assertEquals(4, graph.getModuleCount()); List<CompilerInput> result = graph.manageDependencies(entryPoints, compiler.getInputsForTesting()); assertEquals("[root]", result.get(0).getName()); assertEquals("[module$tonic]", result.get(1).getName()); assertEquals("[module$gin]", result.get(2).getName()); assertEquals("tonic.js", result.get(3).getName()); assertEquals("gin.js", result.get(4).getName()); assertEquals("mix.js", result.get(5).getName()); } public void testCommonJSMissingRequire() throws Exception { List<SourceFile> inputs = Lists.newArrayList( SourceFile.fromCode("gin.js", "require('missing')")); Compiler compiler = initCompilerForCommonJS( inputs, ImmutableList.of("module$gin")); compiler.processAMDAndCommonJSModules(); assertEquals(1, compiler.getErrorManager().getErrorCount()); String error = compiler.getErrorManager().getErrors()[0].toString(); assertTrue( "Unexpected error: " + error, error.contains( "required entry point \"module$missing\" never provided")); } private Compiler initCompilerForCommonJS( List<SourceFile> inputs, List<String> entryPoints) throws Exception { CompilerOptions options = new CompilerOptions(); options.ideMode = true; options.setManageClosureDependencies(entryPoints); options.closurePass = true; options.processCommonJSModules = true; Compiler compiler = new Compiler(); compiler.init(Lists.<SourceFile>newArrayList(), inputs, options); compiler.parseInputs(); return compiler; } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import static com.google.javascript.jscomp.ConcreteType.ALL; import static com.google.javascript.jscomp.ConcreteType.NONE; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.common.collect.Sets; import com.google.javascript.jscomp.ConcreteType.ConcreteFunctionType; import com.google.javascript.jscomp.ConcreteType.ConcreteInstanceType; import com.google.javascript.jscomp.ConcreteType.ConcreteUnionType; import com.google.javascript.jscomp.ConcreteType.Factory; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.StaticReference; import com.google.javascript.rhino.jstype.StaticScope; import com.google.javascript.rhino.jstype.StaticSlot; import com.google.javascript.rhino.testing.AbstractStaticScope; import com.google.javascript.rhino.testing.TestErrorReporter; import junit.framework.TestCase; import java.util.Arrays; import java.util.Collection; import java.util.List; import java.util.Map; /** * Unit test for the the subclasses of ConcreteType. * */ public class ConcreteTypeTest extends TestCase { private JSTypeRegistry typeRegistry; private JSType unknownType; private Factory factory; @Override public void setUp() { typeRegistry = new JSTypeRegistry(new TestErrorReporter(null, null)); unknownType = typeRegistry.getNativeType(JSTypeNative.UNKNOWN_TYPE); factory = new FakeFactory(); } private void checkEquality(List<ConcreteType> types) { for (int i = 0; i < types.size(); ++i) { for (int j = 0; j < types.size(); ++j) { if (i == j) { assertEquals(types.get(i), types.get(j)); } else { assertFalse(types.get(i).equals(types.get(j))); } } } } public void testEquals() { ConcreteFunctionType fun1 = createFunction("fun1"); ConcreteFunctionType fun2 = createFunction("fun2"); ConcreteType obj1 = fun1.getInstanceType(); ConcreteType obj2 = fun2.getInstanceType(); ConcreteType union1 = new ConcreteUnionType(fun1, fun2); ConcreteType union2 = new ConcreteUnionType(fun1, obj1); ConcreteType union3 = new ConcreteUnionType(fun1, obj1); checkEquality(Lists.newArrayList(fun1, fun2, obj1, obj2, union1, union2)); assertEquals(union2, union3); } public void testUnionWith() { ConcreteFunctionType fun = createFunction("fun"); ConcreteType obj = fun.getInstanceType(); ConcreteType both = new ConcreteUnionType(fun, obj); assertTrue(fun.isSingleton()); assertTrue(obj.isSingleton()); assertFalse(both.isSingleton()); assertFalse(NONE.isSingleton()); assertFalse(ALL.isSingleton()); checkUnionWith(fun, NONE, fun); checkUnionWith(fun, ALL, ALL); checkUnionWith(fun, obj, both); checkUnionWith(both, NONE, both); checkUnionWith(both, ALL, ALL); } private void checkUnionWith(ConcreteType a, ConcreteType b, ConcreteType c) { assertEquals(a, a.unionWith(a)); assertEquals(b, b.unionWith(b)); assertEquals(c, a.unionWith(b)); assertEquals(c, b.unionWith(a)); } public void testIntersectionWith() { ConcreteFunctionType fun = createFunction("fun"); ConcreteFunctionType fun2 = createFunction("fun2"); ConcreteType obj = fun.getInstanceType(); ConcreteType both = new ConcreteUnionType(fun, obj); assertEquals(NONE, fun.intersectWith(obj)); assertEquals(NONE, obj.intersectWith(fun)); assertEquals(fun, both.intersectWith(fun)); assertEquals(fun, fun.intersectWith(both)); assertEquals(NONE, NONE.intersectWith(both)); assertEquals(NONE, both.intersectWith(NONE)); assertEquals(NONE, fun.intersectWith(NONE)); assertEquals(NONE, NONE.intersectWith(fun)); assertEquals(NONE, both.intersectWith(fun2)); assertEquals(both, ALL.intersectWith(both)); assertEquals(both, both.intersectWith(ALL)); assertEquals(fun, ALL.intersectWith(fun)); assertEquals(fun, fun.intersectWith(ALL)); assertEquals(NONE, ALL.intersectWith(NONE)); assertEquals(NONE, NONE.intersectWith(ALL)); } public void testFunction() { ConcreteFunctionType fun = createFunction("fun", "a", "b"); assertTrue(fun.isFunction()); assertNotNull(fun.getCallSlot()); assertNotNull(fun.getReturnSlot()); assertNotNull(fun.getParameterSlot(0)); assertNotNull(fun.getParameterSlot(1)); assertNull(fun.getParameterSlot(2)); assertTrue(fun.getInstanceType().isInstance()); } public void testInstance() { ConcreteInstanceType obj = createInstance("MyObj", "a", "b"); assertTrue(obj.isInstance()); assertNotNull(obj.getPropertySlot("a")); assertNotNull(obj.getPropertySlot("b")); assertNull(obj.getPropertySlot("c")); // The prototype chain should be: MyObj -> MyObj.prototype -> Object -> // Object.prototype -> null. for (int i = 0; i < 3; ++i) { assertNotNull(obj = obj.getImplicitPrototype()); assertTrue(obj.isInstance()); } assertNull(obj.getImplicitPrototype()); } public void testGetX() { ConcreteFunctionType fun1 = createFunction("fun1"); ConcreteFunctionType fun2 = createFunction("fun2"); ConcreteInstanceType obj1 = fun1.getInstanceType(); ConcreteInstanceType obj2 = fun2.getInstanceType(); ConcreteType union1 = fun1.unionWith(obj1); ConcreteType union2 = union1.unionWith(fun2).unionWith(obj2); assertEqualSets(Lists.newArrayList(), NONE.getFunctions()); assertEqualSets(Lists.newArrayList(), NONE.getInstances()); assertEqualSets(Lists.newArrayList(fun1), fun1.getFunctions()); assertEqualSets(Lists.newArrayList(), fun1.getInstances()); assertEqualSets(Lists.newArrayList(), obj1.getFunctions()); assertEqualSets(Lists.newArrayList(obj1), obj1.getInstances()); assertEqualSets(Lists.newArrayList(fun1), union1.getFunctions()); assertEqualSets(Lists.newArrayList(obj1), union1.getInstances()); assertEqualSets(Lists.newArrayList(fun1, fun2), union2.getFunctions()); assertEqualSets(Lists.newArrayList(obj1, obj2), union2.getInstances()); } /** Checks that the two collections are equal as sets. */ private void assertEqualSets(Collection<?> first, Collection<?> second) { assertEquals(Sets.newHashSet(first), Sets.newHashSet(second)); } /** Creates a fake function with the given description. */ private ConcreteFunctionType createFunction( String name, String... paramNames) { Node args = new Node(Token.PARAM_LIST); for (int i = 0; i < paramNames.length; ++i) { args.addChildToBack(Node.newString(Token.NAME, paramNames[i])); } Node decl = new Node(Token.FUNCTION, Node.newString(Token.NAME, name), args, new Node(Token.BLOCK)); JSType[] paramTypes = new JSType[paramNames.length]; Arrays.fill(paramTypes, unknownType); decl.setJSType(typeRegistry.createConstructorType( name, decl, args, unknownType, null)); return new ConcreteFunctionType(factory, decl, null); } /** Creates a fake instance with the given description. */ private ConcreteInstanceType createInstance( String name, String... propNames) { ObjectType objType = typeRegistry.createObjectType(name, null, typeRegistry.createObjectType(name + ".prototype", null, null)); for (int i = 0; i < propNames.length; ++i) { objType.defineDeclaredProperty(propNames[i], unknownType, null); } return new ConcreteInstanceType(factory, objType); } private class FakeFactory implements Factory { private final Map<Node, ConcreteFunctionType> functionByDeclaration = Maps.newHashMap(); private final Map<FunctionType, ConcreteFunctionType> functionByJSType = Maps.newHashMap(); private final Map<ObjectType, ConcreteInstanceType> instanceByJSType = Maps.newHashMap(); private final JSTypeRegistry registry = new JSTypeRegistry( new TestErrorReporter(null, null)); @Override public JSTypeRegistry getTypeRegistry() { return registry; } /** {@inheritDoc} */ @Override public ConcreteFunctionType createConcreteFunction( Node decl, StaticScope<ConcreteType> parent) { ConcreteFunctionType funcType = functionByDeclaration.get(decl); if (funcType == null) { functionByDeclaration.put(decl, funcType = new ConcreteFunctionType(this, decl, parent)); if (decl.getJSType() != null) { functionByJSType.put((FunctionType) decl.getJSType(), funcType); } } return funcType; } /** {@inheritDoc} */ @Override public ConcreteInstanceType createConcreteInstance( ObjectType instanceType) { ConcreteInstanceType instType = instanceByJSType.get(instanceType); if (instType == null) { instanceByJSType.put(instanceType, instType = new ConcreteInstanceType(this, instanceType)); } return instType; } /** {@inheritDoc} */ @Override public ConcreteFunctionType getConcreteFunction(FunctionType functionType) { return functionByJSType.get(functionType); } /** {@inheritDoc} */ @Override public ConcreteInstanceType getConcreteInstance(ObjectType instanceType) { return instanceByJSType.get(instanceType); } /** {@inheritDoc} */ @Override public StaticScope<ConcreteType> createFunctionScope( Node decl, StaticScope<ConcreteType> parent) { FakeScope scope = new FakeScope((FakeScope) parent); scope.addSlot(ConcreteFunctionType.CALL_SLOT_NAME); scope.addSlot(ConcreteFunctionType.THIS_SLOT_NAME); scope.addSlot(ConcreteFunctionType.RETURN_SLOT_NAME); for (Node n = decl.getFirstChild().getNext().getFirstChild(); n != null; n = n.getNext()) { scope.addSlot(n.getString()); } return scope; } /** {@inheritDoc} */ @Override public StaticScope<ConcreteType> createInstanceScope( ObjectType instanceType) { FakeScope parentScope = null; if (instanceType.getImplicitPrototype() != null) { ConcreteInstanceType prototype = createConcreteInstance(instanceType.getImplicitPrototype()); parentScope = (FakeScope) prototype.getScope(); } FakeScope scope = new FakeScope(parentScope); for (String propName : instanceType.getOwnPropertyNames()) { scope.addSlot(propName); } return scope; } } // TODO(user): move to a common place if it can be used elsewhere private class FakeScope extends AbstractStaticScope<ConcreteType> { private final FakeScope parent; private final Map<String, FakeSlot> slots = Maps.newHashMap(); FakeScope(FakeScope parent) { this.parent = parent; } /** {@inheritDoc} */ @Override public StaticScope<ConcreteType> getParentScope() { return parent; } /** {@inheritDoc} */ @Override public StaticSlot<ConcreteType> getOwnSlot(String name) { return slots.get(name); } /** {@inheritDoc} */ @Override public StaticSlot<ConcreteType> getSlot(String name) { if (slots.containsKey(name)) { return slots.get(name); } else if (parent != null) { return parent.getSlot(name); } else { return null; } } /** {@inheritDoc} */ @Override public ConcreteType getTypeOfThis() { return ConcreteType.ALL; } void addSlot(String name) { slots.put(name, new FakeSlot(name)); } } // TODO(user): move to a common place if it can be used elsewhere private class FakeSlot implements StaticSlot<ConcreteType> { private final String name; FakeSlot(String name) { this.name = name; } @Override public String getName() { return name; } @Override public ConcreteType getType() { return ConcreteType.ALL; } @Override public boolean isTypeInferred() { return true; } @Override public StaticReference<ConcreteType> getDeclaration() { return null; } @Override public JSDocInfo getJSDocInfo() { return null; } } }
/* * Copyright 2007 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Tests {@link ConstCheck}. * */ public class ConstCheckTest extends CompilerTestCase { public ConstCheckTest() { enableNormalize(); } @Override public CompilerPass getProcessor(Compiler compiler) { return new ConstCheck(compiler); } @Override public int getNumRepetitions() { return 1; } public void testConstantDefinition1() { testSame("var XYZ = 1;"); } public void testConstantDefinition2() { testSame("var a$b$XYZ = 1;"); } public void testConstantInitializedInAnonymousNamespace1() { testSame("var XYZ; (function(){ XYZ = 1; })();"); } public void testConstantInitializedInAnonymousNamespace2() { testSame("var a$b$XYZ; (function(){ a$b$XYZ = 1; })();"); } public void testObjectModified() { testSame("var IE = true, XYZ = {a:1,b:1}; if (IE) XYZ['c'] = 1;"); } public void testObjectPropertyInitializedLate() { testSame("var XYZ = {}; for (var i = 0; i < 10; i++) { XYZ[i] = i; }"); } public void testObjectRedefined1() { testError("var XYZ = {}; XYZ = 2;"); } public void testConstantRedefined1() { testError("var XYZ = 1; XYZ = 2;"); } public void testConstantRedefined2() { testError("var a$b$XYZ = 1; a$b$XYZ = 2;"); } public void testConstantRedefinedInLocalScope1() { testError("var XYZ = 1; (function(){ XYZ = 2; })();"); } public void testConstantRedefinedInLocalScope2() { testError("var a$b$XYZ = 1; (function(){ a$b$XYZ = 2; })();"); } public void testConstantRedefinedInLocalScopeOutOfOrder() { testError("function f() { XYZ = 2; } var XYZ = 1;"); } public void testConstantPostIncremented1() { testError("var XYZ = 1; XYZ++;"); } public void testConstantPostIncremented2() { testError("var a$b$XYZ = 1; a$b$XYZ++;"); } public void testConstantPreIncremented1() { testError("var XYZ = 1; XYZ++;"); } public void testConstantPreIncremented2() { testError("var a$b$XYZ = 1; a$b$XYZ++;"); } public void testConstantPostDecremented1() { testError("var XYZ = 1; XYZ--;"); } public void testConstantPostDecremented2() { testError("var a$b$XYZ = 1; a$b$XYZ--;"); } public void testConstantPreDecremented1() { testError("var XYZ = 1; XYZ--;"); } public void testConstantPreDecremented2() { testError("var a$b$XYZ = 1; a$b$XYZ--;"); } public void testAbbreviatedArithmeticAssignment1() { testError("var XYZ = 1; XYZ += 2;"); } public void testAbbreviatedArithmeticAssignment2() { testError("var a$b$XYZ = 1; a$b$XYZ %= 2;"); } public void testAbbreviatedBitAssignment1() { testError("var XYZ = 1; XYZ |= 2;"); } public void testAbbreviatedBitAssignment2() { testError("var a$b$XYZ = 1; a$b$XYZ &= 2;"); } public void testAbbreviatedShiftAssignment1() { testError("var XYZ = 1; XYZ >>= 2;"); } public void testAbbreviatedShiftAssignment2() { testError("var a$b$XYZ = 1; a$b$XYZ <<= 2;"); } public void testConstAnnotation() { testError("/** @const */ var xyz = 1; xyz = 3;"); } public void testConstSuppression() { testSame("/**\n" + " * @fileoverview\n" + " * @suppress {const}\n" + " */\n" + "/** @const */ var xyz = 1; xyz = 3;"); } private void testError(String js) { test(js, null, ConstCheck.CONST_REASSIGNED_VALUE_ERROR); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.Lists; import com.google.javascript.jscomp.ControlFlowGraph.Branch; import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge; import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import junit.framework.TestCase; import java.util.Collections; import java.util.Iterator; import java.util.List; /** * Tests {@link ControlFlowAnalysis}. * */ public class ControlFlowAnalysisTest extends TestCase { /** * Given an input in JavaScript, test if the control flow analysis * creates the proper control flow graph by comparing the expected * Dot file output. * * @param input Input JavaScript. * @param expected Expected Graphviz Dot file. */ private void testCfg(String input, String expected) { testCfg(input, expected, true); } /** * Gets all the edges of the graph. */ private static List<DiGraphEdge<Node, Branch>> getAllEdges( ControlFlowGraph<Node> cfg) { List<DiGraphEdge<Node, Branch>> edges = Lists.newArrayList(); for (DiGraphNode<Node, Branch> n : cfg.getDirectedGraphNodes()) { for (DiGraphEdge<Node, Branch> e : cfg.getOutEdges(n.getValue())) { edges.add(e); } } return edges; } /** * Gets all the control flow edges from some node with the first token to * some node with the second token. */ private static List<DiGraphEdge<Node, Branch>> getAllEdges( ControlFlowGraph<Node> cfg, int startToken, int endToken) { List<DiGraphEdge<Node, Branch>> edges = getAllEdges(cfg); Iterator<DiGraphEdge<Node, Branch>> it = edges.iterator(); while (it.hasNext()) { DiGraphEdge<Node, Branch> edge = it.next(); Node startNode = edge.getSource().getValue(); Node endNode = edge.getDestination().getValue(); if (startNode == null || endNode == null || startNode.getType() != startToken || endNode.getType() != endToken) { it.remove(); } } return edges; } /** * Gets all the control flow edges of the given type from some node with the * first token to some node with the second token. */ private static List<DiGraphEdge<Node, Branch>> getAllEdges( ControlFlowGraph<Node> cfg, int startToken, int endToken, Branch type) { List<DiGraphEdge<Node, Branch>> edges = getAllEdges(cfg, startToken, endToken); Iterator<DiGraphEdge<Node, Branch>> it = edges.iterator(); while (it.hasNext()) { if (type != it.next().getValue()) { it.remove(); } } return edges; } private static boolean isAncestor(Node n, Node maybeDescendent) { for (Node current = n.getFirstChild(); current != null; current = current.getNext()) { if (current == maybeDescendent || isAncestor(current, maybeDescendent)) { return true; } } return false; } /** * Gets all the control flow edges of the given type from some node with * the first token to some node with the second token. * This edge must flow from a parent to one of its descendants. */ private static List<DiGraphEdge<Node, Branch>> getAllDownEdges( ControlFlowGraph<Node> cfg, int startToken, int endToken, Branch type) { List<DiGraphEdge<Node, Branch>> edges = getAllEdges(cfg, startToken, endToken, type); Iterator<DiGraphEdge<Node, Branch>> it = edges.iterator(); while (it.hasNext()) { DiGraphEdge<Node, Branch> edge = it.next(); Node source = edge.getSource().getValue(); Node dest = edge.getDestination().getValue(); if (!isAncestor(source, dest)) { it.remove(); } } return edges; } /** * Assert that there exists a control flow edge of the given type * from some node with the first token to some node with the second token. */ private static void assertNoEdge(ControlFlowGraph<Node> cfg, int startToken, int endToken) { assertEquals(0, getAllEdges(cfg, startToken, endToken).size()); } /** * Assert that there exists a control flow edge of the given type * from some node with the first token to some node with the second token. * This edge must flow from a parent to one of its descendants. */ private static void assertDownEdge(ControlFlowGraph<Node> cfg, int startToken, int endToken, Branch type) { assertTrue("No down edge found", 0 != getAllDownEdges(cfg, startToken, endToken, type).size()); } /** * Assert that there exists a control flow edge of the given type * from some node with the first token to some node with the second token. * This edge must flow from a node to one of its ancestors. */ private static void assertUpEdge(ControlFlowGraph<Node> cfg, int startToken, int endToken, Branch type) { assertTrue("No up edge found", 0 != getAllDownEdges(cfg, endToken, startToken, type).size()); } /** * Assert that there exists a control flow edge of the given type * from some node with the first token to some node with the second token. * This edge must flow between two nodes that are not in the same subtree. */ private static void assertCrossEdge(ControlFlowGraph<Node> cfg, int startToken, int endToken, Branch type) { int numDownEdges = getAllDownEdges(cfg, startToken, endToken, type).size(); int numUpEdges = getAllDownEdges(cfg, endToken, startToken, type).size(); int numEdges = getAllEdges(cfg, startToken, endToken, type).size(); assertTrue("No cross edges found", numDownEdges + numUpEdges < numEdges); } /** * Assert that there exists a control flow edge of the given type * from some node with the first token to the return node. */ private static void assertReturnEdge(ControlFlowGraph<Node> cfg, int startToken) { List<DiGraphEdge<Node, Branch>> edges = getAllEdges(cfg); for (DiGraphEdge<Node, Branch> edge : edges) { Node source = edge.getSource().getValue(); DiGraphNode<Node, Branch> dest = edge.getDestination(); if (source.getType() == startToken && cfg.isImplicitReturn(dest)) { return; } } fail("No return edge found"); } /** * Assert that there exists no control flow edge of the given type * from some node with the first token to the return node. */ private static void assertNoReturnEdge(ControlFlowGraph<Node> cfg, int startToken) { List<DiGraphEdge<Node, Branch>> edges = getAllEdges(cfg); for (DiGraphEdge<Node, Branch> edge : edges) { Node source = edge.getSource().getValue(); DiGraphNode<Node, Branch> dest = edge.getDestination(); if (source.getType() == startToken) { assertTrue("Token " + startToken + " should not have an out going" + " edge to the implicit return", !cfg.isImplicitReturn(dest)); return; } } } /** * Given an input in JavaScript, get a control flow graph for it. * * @param input Input JavaScript. */ private ControlFlowGraph<Node> createCfg(String input, boolean runSynBlockPass) { Compiler compiler = new Compiler(); ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, true, true); Node root = compiler.parseSyntheticCode("cfgtest", input); if (runSynBlockPass) { CreateSyntheticBlocks pass = new CreateSyntheticBlocks( compiler, "START", "END"); pass.process(null, root); } cfa.process(null, root); return cfa.getCfg(); } private ControlFlowGraph<Node> createCfg(String input) { return createCfg(input, false); } /** * Given an input in JavaScript, test if the control flow analysis * creates the proper control flow graph by comparing the expected * Dot file output. * * @param input Input JavaScript. * @param expected Expected Graphviz Dot file. * @param shouldTraverseFunctions Whether to traverse functions when * constructing the CFG (true by default). Passed in to the * constructor of {@link ControlFlowAnalysis}. */ private void testCfg(String input, String expected, boolean shouldTraverseFunctions) { Compiler compiler = new Compiler(); ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, shouldTraverseFunctions, true); Node root = compiler.parseSyntheticCode("cfgtest", input); cfa.process(null, root); ControlFlowGraph<Node> cfg = cfa.getCfg(); try { assertEquals(expected, DotFormatter.toDot(root, cfg)); } catch (java.io.IOException e) { fail("Tests failed with IOExceptions"); } } public void testSimpleStatements() { String src = "var a; a = a; a = a"; ControlFlowGraph<Node> cfg = createCfg(src); assertDownEdge(cfg, Token.SCRIPT, Token.VAR, Branch.UNCOND); assertCrossEdge(cfg, Token.VAR, Token.EXPR_RESULT, Branch.UNCOND); assertCrossEdge(cfg, Token.EXPR_RESULT, Token.EXPR_RESULT, Branch.UNCOND); } // Test a simple IF control flow. public void testSimpleIf() { String src = "var x; if (x) { x() } else { x() };"; ControlFlowGraph<Node> cfg = createCfg(src); assertDownEdge(cfg, Token.SCRIPT, Token.VAR, Branch.UNCOND); assertCrossEdge(cfg, Token.VAR, Token.IF, Branch.UNCOND); assertDownEdge(cfg, Token.IF, Token.BLOCK, Branch.ON_TRUE); assertDownEdge(cfg, Token.BLOCK, Token.EXPR_RESULT, Branch.UNCOND); assertNoEdge(cfg, Token.EXPR_RESULT, Token.CALL); assertDownEdge(cfg, Token.IF, Token.BLOCK, Branch.ON_FALSE); assertReturnEdge(cfg, Token.EMPTY); } public void testBreakingBlock() { // BUG #1382217 String src = "X: { while(1) { break } }"; ControlFlowGraph<Node> cfg = createCfg(src); assertUpEdge(cfg, Token.BREAK, Token.BLOCK, Branch.UNCOND); } public void testBreakingTryBlock() { String src = "a: try { break a; } finally {} if(x) {}"; ControlFlowGraph<Node> cfg = createCfg(src); assertCrossEdge(cfg, Token.BREAK, Token.IF, Branch.UNCOND); src = "a: try {} finally {break a;} if(x) {}"; cfg = createCfg(src); assertCrossEdge(cfg, Token.BREAK, Token.IF, Branch.UNCOND); src = "a: try {} catch(e) {break a;} if(x) {}"; cfg = createCfg(src); assertCrossEdge(cfg, Token.BREAK, Token.IF, Branch.UNCOND); } public void testWithStatement() { String src = "var x, y; with(x) { y() }"; ControlFlowGraph<Node> cfg = createCfg(src); assertDownEdge(cfg, Token.WITH, Token.BLOCK, Branch.UNCOND); assertNoEdge(cfg, Token.WITH, Token.NAME); assertNoEdge(cfg, Token.NAME, Token.BLOCK); assertDownEdge(cfg, Token.BLOCK, Token.EXPR_RESULT, Branch.UNCOND); assertReturnEdge(cfg, Token.EXPR_RESULT); } // Test a simple WHILE control flow with BREAKs. public void testSimpleWhile() { String src = "var x; while (x) { x(); if (x) { break; } x() }"; ControlFlowGraph<Node> cfg = createCfg(src); assertDownEdge(cfg, Token.WHILE, Token.BLOCK, Branch.ON_TRUE); assertDownEdge(cfg, Token.BLOCK, Token.EXPR_RESULT, Branch.UNCOND); assertDownEdge(cfg, Token.IF, Token.BLOCK, Branch.ON_TRUE); assertReturnEdge(cfg, Token.BREAK); } public void testSimpleSwitch() { String src = "var x; switch(x){ case(1): x(); case('x'): x(); break" + "; default: x();}"; ControlFlowGraph<Node> cfg = createCfg(src); assertCrossEdge(cfg, Token.VAR, Token.SWITCH, Branch.UNCOND); assertNoEdge(cfg, Token.SWITCH, Token.NAME); // Transfer between cases and default. assertDownEdge(cfg, Token.SWITCH, Token.CASE, Branch.UNCOND); assertCrossEdge(cfg, Token.CASE, Token.CASE, Branch.ON_FALSE); assertCrossEdge(cfg, Token.CASE, Token.DEFAULT_CASE, Branch.ON_FALSE); // Within each case. assertDownEdge(cfg, Token.CASE, Token.BLOCK, Branch.ON_TRUE); assertDownEdge(cfg, Token.BLOCK, Token.EXPR_RESULT, Branch.UNCOND); assertNoEdge(cfg, Token.EXPR_RESULT, Token.CALL); assertNoEdge(cfg, Token.CALL, Token.NAME); } public void testSimpleNoDefault() { String src = "var x; switch(x){ case(1): break; } x();"; ControlFlowGraph<Node> cfg = createCfg(src); assertCrossEdge(cfg, Token.CASE, Token.EXPR_RESULT, Branch.ON_FALSE); } public void testSwitchDefaultFirst() { // DEFAULT appears first. But it is should evaluated last. String src = "var x; switch(x){ default: break; case 1: break; }"; ControlFlowGraph<Node> cfg = createCfg(src); assertDownEdge(cfg, Token.SWITCH, Token.CASE, Branch.UNCOND); assertCrossEdge(cfg, Token.CASE, Token.DEFAULT_CASE, Branch.ON_FALSE); } public void testSwitchDefaultInMiddle() { // DEFAULT appears in the middle. But it is should evaluated last. String src = "var x; switch(x){ case 1: break; default: break; " + "case 2: break; }"; ControlFlowGraph<Node> cfg = createCfg(src); assertDownEdge(cfg, Token.SWITCH, Token.CASE, Branch.UNCOND); assertCrossEdge(cfg, Token.CASE, Token.CASE, Branch.ON_FALSE); assertCrossEdge(cfg, Token.CASE, Token.DEFAULT_CASE, Branch.ON_FALSE); } public void testSwitchEmpty() { // DEFAULT appears first. But it is should evaluated last. String src = "var x; switch(x){}; x()"; ControlFlowGraph<Node> cfg = createCfg(src); assertCrossEdge(cfg, Token.SWITCH, Token.EMPTY, Branch.UNCOND); assertCrossEdge(cfg, Token.EMPTY, Token.EXPR_RESULT, Branch.UNCOND); } public void testReturnThrowingException() { String src = "function f() {try { return a(); } catch (e) {e()}}"; ControlFlowGraph<Node> cfg = createCfg(src); assertCrossEdge(cfg, Token.RETURN, Token.BLOCK, Branch.ON_EX); assertDownEdge(cfg, Token.BLOCK, Token.CATCH, Branch.UNCOND); } // Test a simple FOR loop. public void testSimpleFor() { String src = "var a; for (var x = 0; x < 100; x++) { a(); }"; String expected = "digraph AST {\n" + " node [color=lightblue2, style=filled];\n" + " node0 [label=\"SCRIPT\"];\n" + " node1 [label=\"VAR\"];\n" + " node0 -> node1 [weight=1];\n" + " node2 [label=\"NAME\"];\n" + " node1 -> node2 [weight=1];\n" + " node3 [label=\"VAR\"];\n" + " node1 -> node3 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node4 [label=\"FOR\"];\n" + " node0 -> node4 [weight=1];\n" + " node4 -> node3 [weight=1];\n" + " node5 [label=\"NAME\"];\n" + " node3 -> node5 [weight=1];\n" + " node6 [label=\"NUMBER\"];\n" + " node5 -> node6 [weight=1];\n" + " node3 -> node4 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node7 [label=\"LT\"];\n" + " node4 -> node7 [weight=1];\n" + " node8 [label=\"NAME\"];\n" + " node7 -> node8 [weight=1];\n" + " node9 [label=\"NUMBER\"];\n" + " node7 -> node9 [weight=1];\n" + " node10 [label=\"INC\"];\n" + " node4 -> node10 [weight=1];\n" + " node11 [label=\"NAME\"];\n" + " node10 -> node11 [weight=1];\n" + " node10 -> node4 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node12 [label=\"BLOCK\"];\n" + " node4 -> node12 [weight=1];\n" + " node13 [label=\"EXPR_RESULT\"];\n" + " node12 -> node13 [weight=1];\n" + " node14 [label=\"CALL\"];\n" + " node13 -> node14 [weight=1];\n" + " node15 [label=\"NAME\"];\n" + " node14 -> node15 [weight=1];\n" + " node13 -> node10 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node12 -> node13 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node4 -> RETURN " + "[label=\"ON_FALSE\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node4 -> node12 " + "[label=\"ON_TRUE\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node0 -> node1 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "}\n"; testCfg(src, expected); } public void testSimpleForWithContinue() { String src = "var a; for (var x = 0; x < 100; x++) {a();continue;a()}"; String expected = "digraph AST {\n" + " node [color=lightblue2, style=filled];\n" + " node0 [label=\"SCRIPT\"];\n" + " node1 [label=\"VAR\"];\n" + " node0 -> node1 [weight=1];\n" + " node2 [label=\"NAME\"];\n" + " node1 -> node2 [weight=1];\n" + " node3 [label=\"VAR\"];\n" + " node1 -> node3 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node4 [label=\"FOR\"];\n" + " node0 -> node4 [weight=1];\n" + " node4 -> node3 [weight=1];\n" + " node5 [label=\"NAME\"];\n" + " node3 -> node5 [weight=1];\n" + " node6 [label=\"NUMBER\"];\n" + " node5 -> node6 [weight=1];\n" + " node3 -> node4 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node7 [label=\"LT\"];\n" + " node4 -> node7 [weight=1];\n" + " node8 [label=\"NAME\"];\n" + " node7 -> node8 [weight=1];\n" + " node9 [label=\"NUMBER\"];\n" + " node7 -> node9 [weight=1];\n" + " node10 [label=\"INC\"];\n" + " node4 -> node10 [weight=1];\n" + " node11 [label=\"NAME\"];\n" + " node10 -> node11 [weight=1];\n" + " node10 -> node4 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node12 [label=\"BLOCK\"];\n" + " node4 -> node12 [weight=1];\n" + " node13 [label=\"EXPR_RESULT\"];\n" + " node12 -> node13 [weight=1];\n" + " node14 [label=\"CALL\"];\n" + " node13 -> node14 [weight=1];\n" + " node15 [label=\"NAME\"];\n" + " node14 -> node15 [weight=1];\n" + " node16 [label=\"CONTINUE\"];\n" + " node13 -> node16 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node12 -> node16 [weight=1];\n" + " node16 -> node10 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node17 [label=\"EXPR_RESULT\"];\n" + " node12 -> node17 [weight=1];\n" + " node18 [label=\"CALL\"];\n" + " node17 -> node18 [weight=1];\n" + " node19 [label=\"NAME\"];\n" + " node18 -> node19 [weight=1];\n" + " node17 -> node10 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node12 -> node13 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node4 -> RETURN " + "[label=\"ON_FALSE\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node4 -> node12 " + "[label=\"ON_TRUE\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node0 -> node1 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "}\n"; testCfg(src, expected); } public void testNestedFor() { // This is tricky as the inner FOR branches to "x++" ON_FALSE. String src = "var a,b;a();for(var x=0;x<100;x++){for(var y=0;y<100;y++){" + "continue;b();}}"; String expected = "digraph AST {\n" + " node [color=lightblue2, style=filled];\n" + " node0 [label=\"SCRIPT\"];\n" + " node1 [label=\"VAR\"];\n" + " node0 -> node1 [weight=1];\n" + " node2 [label=\"NAME\"];\n" + " node1 -> node2 [weight=1];\n" + " node3 [label=\"NAME\"];\n" + " node1 -> node3 [weight=1];\n" + " node4 [label=\"EXPR_RESULT\"];\n" + " node1 -> node4 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node0 -> node4 [weight=1];\n" + " node5 [label=\"CALL\"];\n" + " node4 -> node5 [weight=1];\n" + " node6 [label=\"NAME\"];\n" + " node5 -> node6 [weight=1];\n" + " node7 [label=\"VAR\"];\n" + " node4 -> node7 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node8 [label=\"FOR\"];\n" + " node0 -> node8 [weight=1];\n" + " node8 -> node7 [weight=1];\n" + " node9 [label=\"NAME\"];\n" + " node7 -> node9 [weight=1];\n" + " node10 [label=\"NUMBER\"];\n" + " node9 -> node10 [weight=1];\n" + " node7 -> node8 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node11 [label=\"LT\"];\n" + " node8 -> node11 [weight=1];\n" + " node12 [label=\"NAME\"];\n" + " node11 -> node12 [weight=1];\n" + " node13 [label=\"NUMBER\"];\n" + " node11 -> node13 [weight=1];\n" + " node14 [label=\"INC\"];\n" + " node8 -> node14 [weight=1];\n" + " node15 [label=\"NAME\"];\n" + " node14 -> node15 [weight=1];\n" + " node14 -> node8 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node16 [label=\"BLOCK\"];\n" + " node8 -> node16 [weight=1];\n" + " node17 [label=\"FOR\"];\n" + " node16 -> node17 [weight=1];\n" + " node18 [label=\"VAR\"];\n" + " node17 -> node18 [weight=1];\n" + " node19 [label=\"NAME\"];\n" + " node18 -> node19 [weight=1];\n" + " node20 [label=\"NUMBER\"];\n" + " node19 -> node20 [weight=1];\n" + " node18 -> node17 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node21 [label=\"LT\"];\n" + " node17 -> node21 [weight=1];\n" + " node22 [label=\"NAME\"];\n" + " node21 -> node22 [weight=1];\n" + " node23 [label=\"NUMBER\"];\n" + " node21 -> node23 [weight=1];\n" + " node24 [label=\"INC\"];\n" + " node17 -> node24 [weight=1];\n" + " node25 [label=\"NAME\"];\n" + " node24 -> node25 [weight=1];\n" + " node24 -> node17 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node26 [label=\"BLOCK\"];\n" + " node17 -> node26 [weight=1];\n" + " node27 [label=\"CONTINUE\"];\n" + " node26 -> node27 [weight=1];\n" + " node27 -> node24 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node28 [label=\"EXPR_RESULT\"];\n" + " node26 -> node28 [weight=1];\n" + " node29 [label=\"CALL\"];\n" + " node28 -> node29 [weight=1];\n" + " node30 [label=\"NAME\"];\n" + " node29 -> node30 [weight=1];\n" + " node28 -> node24 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node26 -> node27 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node17 -> node14 " + "[label=\"ON_FALSE\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node17 -> node26 " + "[label=\"ON_TRUE\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node16 -> node18 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node8 -> RETURN " + "[label=\"ON_FALSE\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node8 -> node16 " + "[label=\"ON_TRUE\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node0 -> node1 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "}\n"; testCfg(src, expected); } public void testNestedDoWithBreak() { // The BREAK branches to a() with UNCOND. String src = "var a;do{do{break}while(a);do{a()}while(a)}while(a);"; String expected = "digraph AST {\n" + " node [color=lightblue2, style=filled];\n" + " node0 [label=\"SCRIPT\"];\n" + " node1 [label=\"VAR\"];\n" + " node0 -> node1 [weight=1];\n" + " node2 [label=\"NAME\"];\n" + " node1 -> node2 [weight=1];\n" + " node3 [label=\"BLOCK\"];\n" + " node1 -> node3 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node4 [label=\"DO\"];\n" + " node0 -> node4 [weight=1];\n" + " node4 -> node3 [weight=1];\n" + " node5 [label=\"DO\"];\n" + " node3 -> node5 [weight=1];\n" + " node6 [label=\"BLOCK\"];\n" + " node5 -> node6 [weight=1];\n" + " node7 [label=\"BREAK\"];\n" + " node6 -> node7 [weight=1];\n" + " node8 [label=\"BLOCK\"];\n" + " node7 -> node8 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node6 -> node7 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node9 [label=\"NAME\"];\n" + " node5 -> node9 [weight=1];\n" + " node5 -> node6 " + "[label=\"ON_TRUE\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node5 -> node8 " + "[label=\"ON_FALSE\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node10 [label=\"DO\"];\n" + " node3 -> node10 [weight=1];\n" + " node10 -> node8 [weight=1];\n" + " node11 [label=\"EXPR_RESULT\"];\n" + " node8 -> node11 [weight=1];\n" + " node12 [label=\"CALL\"];\n" + " node11 -> node12 [weight=1];\n" + " node13 [label=\"NAME\"];\n" + " node12 -> node13 [weight=1];\n" + " node11 -> node10 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node8 -> node11 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node14 [label=\"NAME\"];\n" + " node10 -> node14 [weight=1];\n" + " node10 -> node4 " + "[label=\"ON_FALSE\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node10 -> node8 " + "[label=\"ON_TRUE\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node3 -> node6 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node15 [label=\"NAME\"];\n" + " node4 -> node15 [weight=1];\n" + " node4 -> RETURN " + "[label=\"ON_FALSE\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node4 -> node3 " + "[label=\"ON_TRUE\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node0 -> node1 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "}\n"; testCfg(src, expected); } public void testForIn() { String src = "var a,b;for(a in b){a()};"; String expected = "digraph AST {\n" + " node [color=lightblue2, style=filled];\n" + " node0 [label=\"SCRIPT\"];\n" + " node1 [label=\"VAR\"];\n" + " node0 -> node1 [weight=1];\n" + " node2 [label=\"NAME\"];\n" + " node1 -> node2 [weight=1];\n" + " node3 [label=\"NAME\"];\n" + " node1 -> node3 [weight=1];\n" + " node4 [label=\"NAME\"];\n" + " node1 -> node4 [label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node5 [label=\"FOR\"];\n" + " node0 -> node5 [weight=1];\n" + " node6 [label=\"NAME\"];\n" + " node5 -> node6 [weight=1];\n" + " node5 -> node4 [weight=1];\n" + " node4 -> node5 [label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node7 [label=\"BLOCK\"];\n" + " node5 -> node7 [weight=1];\n" + " node8 [label=\"EXPR_RESULT\"];\n" + " node7 -> node8 [weight=1];\n" + " node9 [label=\"CALL\"];\n" + " node8 -> node9 [weight=1];\n" + " node10 [label=\"NAME\"];\n" + " node9 -> node10 [weight=1];\n" + " node8 -> node5 [label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node7 -> node8 [label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node11 [label=\"EMPTY\"];\n" + " node5 -> node11 [label=\"ON_FALSE\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node5 -> node7 [label=\"ON_TRUE\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node0 -> node11 [weight=1];\n" + " node11 -> RETURN [label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node0 -> node1 [label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "}\n"; testCfg(src, expected); } public void testThrow() { String src = "function f() { throw 1; f() }"; String expected = "digraph AST {\n" + " node [color=lightblue2, style=filled];\n" + " node0 [label=\"SCRIPT\"];\n" + " node1 [label=\"FUNCTION\"];\n" + " node0 -> node1 [weight=1];\n" + " node2 [label=\"NAME\"];\n" + " node1 -> node2 [weight=1];\n" + " node3 [label=\"PARAM_LIST\"];\n" + " node1 -> node3 [weight=1];\n" + " node4 [label=\"BLOCK\"];\n" + " node1 -> node4 [weight=1];\n" + " node5 [label=\"THROW\"];\n" + " node4 -> node5 [weight=1];\n" + " node6 [label=\"NUMBER\"];\n" + " node5 -> node6 [weight=1];\n" + " node7 [label=\"EXPR_RESULT\"];\n" + " node4 -> node7 [weight=1];\n" + " node8 [label=\"CALL\"];\n" + " node7 -> node8 [weight=1];\n" + " node9 [label=\"NAME\"];\n" + " node8 -> node9 [weight=1];\n" + " node7 -> RETURN " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node4 -> node5 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node1 -> node4 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node0 -> RETURN " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "}\n"; testCfg(src, expected); } // Test a simple FUNCTION. public void testSimpleFunction() { String src = "function f() { f() } f()"; String expected = "digraph AST {\n" + " node [color=lightblue2, style=filled];\n" + " node0 [label=\"SCRIPT\"];\n" + " node1 [label=\"FUNCTION\"];\n" + " node0 -> node1 [weight=1];\n" + " node2 [label=\"NAME\"];\n" + " node1 -> node2 [weight=1];\n" + " node3 [label=\"PARAM_LIST\"];\n" + " node1 -> node3 [weight=1];\n" + " node4 [label=\"BLOCK\"];\n" + " node1 -> node4 [weight=1];\n" + " node5 [label=\"EXPR_RESULT\"];\n" + " node4 -> node5 [weight=1];\n" + " node6 [label=\"CALL\"];\n" + " node5 -> node6 [weight=1];\n" + " node7 [label=\"NAME\"];\n" + " node6 -> node7 [weight=1];\n" + " node5 -> RETURN " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node4 -> node5 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node1 -> node4 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node8 [label=\"EXPR_RESULT\"];\n" + " node0 -> node8 [weight=1];\n" + " node9 [label=\"CALL\"];\n" + " node8 -> node9 [weight=1];\n" + " node10 [label=\"NAME\"];\n" + " node9 -> node10 [weight=1];\n" + " node8 -> RETURN " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node0 -> node8 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "}\n"; testCfg(src, expected); } public void testSimpleCatch() { String src = "try{ throw x; x(); x['stuff']; x.x; x} catch (e) { e() }"; String expected = "digraph AST {\n" + " node [color=lightblue2, style=filled];\n" + " node0 [label=\"SCRIPT\"];\n" + " node1 [label=\"TRY\"];\n" + " node0 -> node1 [weight=1];\n" + " node2 [label=\"BLOCK\"];\n" + " node1 -> node2 [weight=1];\n" + " node3 [label=\"THROW\"];\n" + " node2 -> node3 [weight=1];\n" + " node4 [label=\"NAME\"];\n" + " node3 -> node4 [weight=1];\n" + " node5 [label=\"BLOCK\"];\n" + " node3 -> node5 [label=\"ON_EX\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node6 [label=\"EXPR_RESULT\"];\n" + " node2 -> node6 [weight=1];\n" + " node7 [label=\"CALL\"];\n" + " node6 -> node7 [weight=1];\n" + " node8 [label=\"NAME\"];\n" + " node7 -> node8 [weight=1];\n" + " node9 [label=\"EXPR_RESULT\"];\n" + " node6 -> node5 [label=\"ON_EX\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node6 -> node9 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node2 -> node9 [weight=1];\n" + " node10 [label=\"GETELEM\"];\n" + " node9 -> node10 [weight=1];\n" + " node11 [label=\"NAME\"];\n" + " node10 -> node11 [weight=1];\n" + " node12 [label=\"STRING\"];\n" + " node10 -> node12 [weight=1];\n" + " node13 [label=\"EXPR_RESULT\"];\n" + " node9 -> node13 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node9 -> node5 [label=\"ON_EX\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node2 -> node13 [weight=1];\n" + " node14 [label=\"GETPROP\"];\n" + " node13 -> node14 [weight=1];\n" + " node15 [label=\"NAME\"];\n" + " node14 -> node15 [weight=1];\n" + " node16 [label=\"STRING\"];\n" + " node14 -> node16 [weight=1];\n" + " node17 [label=\"EXPR_RESULT\"];\n" + " node13 -> node17 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node13 -> node5 [label=\"ON_EX\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node2 -> node17 [weight=1];\n" + " node18 [label=\"NAME\"];\n" + " node17 -> node18 [weight=1];\n" + " node17 -> RETURN [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node2 -> node3 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node1 -> node5 [weight=1];\n" + " node19 [label=\"CATCH\"];\n" + " node5 -> node19 [weight=1];\n" + " node20 [label=\"NAME\"];\n" + " node19 -> node20 [weight=1];\n" + " node21 [label=\"BLOCK\"];\n" + " node19 -> node21 [weight=1];\n" + " node22 [label=\"EXPR_RESULT\"];\n" + " node21 -> node22 [weight=1];\n" + " node23 [label=\"CALL\"];\n" + " node22 -> node23 [weight=1];\n" + " node24 [label=\"NAME\"];\n" + " node23 -> node24 [weight=1];\n" + " node22 -> RETURN [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node21 -> node22 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node19 -> node21 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node5 -> node19 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node1 -> node2 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node0 -> node1 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "}\n"; testCfg(src, expected); } public void testFunctionWithinTry() { // Make sure we don't search for the handler outside of the function. String src = "try { function f() {throw 1;} } catch (e) { }"; String expected = "digraph AST {\n" + " node [color=lightblue2, style=filled];\n" + " node0 [label=\"SCRIPT\"];\n" + " node1 [label=\"TRY\"];\n" + " node0 -> node1 [weight=1];\n" + " node2 [label=\"BLOCK\"];\n" + " node1 -> node2 [weight=1];\n" + " node3 [label=\"FUNCTION\"];\n" + " node2 -> node3 [weight=1];\n" + " node4 [label=\"NAME\"];\n" + " node3 -> node4 [weight=1];\n" + " node5 [label=\"PARAM_LIST\"];\n" + " node3 -> node5 [weight=1];\n" + " node6 [label=\"BLOCK\"];\n" + " node3 -> node6 [weight=1];\n" + " node7 [label=\"THROW\"];\n" + " node6 -> node7 [weight=1];\n" + " node8 [label=\"NUMBER\"];\n" + " node7 -> node8 [weight=1];\n" + " node6 -> node7 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node3 -> node6 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node2 -> RETURN [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node9 [label=\"BLOCK\"];\n" + " node1 -> node9 [weight=1];\n" + " node10 [label=\"CATCH\"];\n" + " node9 -> node10 [weight=1];\n" + " node11 [label=\"NAME\"];\n" + " node10 -> node11 [weight=1];\n" + " node12 [label=\"BLOCK\"];\n" + " node10 -> node12 [weight=1];\n" + " node12 -> RETURN [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node10 -> node12 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node9 -> node10 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node1 -> node2 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node0 -> node1 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "}\n"; testCfg(src, expected); } public void testNestedCatch() { // Make sure we are going to the right handler. String src = "try{try{throw 1;}catch(e){throw 2}}catch(f){}"; String expected = "digraph AST {\n" + " node [color=lightblue2, style=filled];\n" + " node0 [label=\"SCRIPT\"];\n" + " node1 [label=\"TRY\"];\n" + " node0 -> node1 [weight=1];\n" + " node2 [label=\"BLOCK\"];\n" + " node1 -> node2 [weight=1];\n" + " node3 [label=\"TRY\"];\n" + " node2 -> node3 [weight=1];\n" + " node4 [label=\"BLOCK\"];\n" + " node3 -> node4 [weight=1];\n" + " node5 [label=\"THROW\"];\n" + " node4 -> node5 [weight=1];\n" + " node6 [label=\"NUMBER\"];\n" + " node5 -> node6 [weight=1];\n" + " node7 [label=\"BLOCK\"];\n" + " node5 -> node7 [label=\"ON_EX\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node4 -> node5 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node3 -> node7 [weight=1];\n" + " node8 [label=\"CATCH\"];\n" + " node7 -> node8 [weight=1];\n" + " node9 [label=\"NAME\"];\n" + " node8 -> node9 [weight=1];\n" + " node10 [label=\"BLOCK\"];\n" + " node8 -> node10 [weight=1];\n" + " node11 [label=\"THROW\"];\n" + " node10 -> node11 [weight=1];\n" + " node12 [label=\"NUMBER\"];\n" + " node11 -> node12 [weight=1];\n" + " node13 [label=\"BLOCK\"];\n" + " node11 -> node13 [label=\"ON_EX\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node10 -> node11 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node8 -> node10 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node7 -> node8 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node3 -> node4 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node2 -> node3 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node1 -> node13 [weight=1];\n" + " node14 [label=\"CATCH\"];\n" + " node13 -> node14 [weight=1];\n" + " node15 [label=\"NAME\"];\n" + " node14 -> node15 [weight=1];\n" + " node16 [label=\"BLOCK\"];\n" + " node14 -> node16 [weight=1];\n" + " node16 -> RETURN [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node14 -> node16 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node13 -> node14 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node1 -> node2 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node0 -> node1 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "}\n"; testCfg(src, expected); } public void testSimpleFinally() { String src = "try{var x; foo()}finally{}"; ControlFlowGraph<Node> cfg = createCfg(src); assertDownEdge(cfg, Token.TRY, Token.BLOCK, Branch.UNCOND); assertDownEdge(cfg, Token.BLOCK, Token.VAR, Branch.UNCOND); // VAR to FINALLY. assertCrossEdge(cfg, Token.EXPR_RESULT, Token.BLOCK, Branch.UNCOND); // No CATCH to FINALLY. assertNoEdge(cfg, Token.BLOCK, Token.BLOCK); } public void testSimpleCatchFinally() { // Make sure we are going to the right handler. String src = "try{ if(a){throw 1}else{a} } catch(e){a}finally{a}"; String expected = "digraph AST {\n" + " node [color=lightblue2, style=filled];\n" + " node0 [label=\"SCRIPT\"];\n" + " node1 [label=\"TRY\"];\n" + " node0 -> node1 [weight=1];\n" + " node2 [label=\"BLOCK\"];\n" + " node1 -> node2 [weight=1];\n" + " node3 [label=\"IF\"];\n" + " node2 -> node3 [weight=1];\n" + " node4 [label=\"NAME\"];\n" + " node3 -> node4 [weight=1];\n" + " node5 [label=\"BLOCK\"];\n" + " node3 -> node5 [weight=1];\n" + " node6 [label=\"THROW\"];\n" + " node5 -> node6 [weight=1];\n" + " node7 [label=\"NUMBER\"];\n" + " node6 -> node7 [weight=1];\n" + " node8 [label=\"BLOCK\"];\n" + " node6 -> node8 [label=\"ON_EX\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node5 -> node6 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node9 [label=\"BLOCK\"];\n" + " node3 -> node9 [weight=1];\n" + " node10 [label=\"EXPR_RESULT\"];\n" + " node9 -> node10 [weight=1];\n" + " node11 [label=\"NAME\"];\n" + " node10 -> node11 [weight=1];\n" + " node12 [label=\"BLOCK\"];\n" + " node10 -> node12 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node9 -> node10 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node3 -> node5 [label=\"ON_TRUE\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node3 -> node9 [label=\"ON_FALSE\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node2 -> node3 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node1 -> node8 [weight=1];\n" + " node13 [label=\"CATCH\"];\n" + " node8 -> node13 [weight=1];\n" + " node14 [label=\"NAME\"];\n" + " node13 -> node14 [weight=1];\n" + " node15 [label=\"BLOCK\"];\n" + " node13 -> node15 [weight=1];\n" + " node16 [label=\"EXPR_RESULT\"];\n" + " node15 -> node16 [weight=1];\n" + " node17 [label=\"NAME\"];\n" + " node16 -> node17 [weight=1];\n" + " node16 -> node12 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node15 -> node16 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node13 -> node15 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node8 -> node13 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node1 -> node12 [weight=1];\n" + " node18 [label=\"EXPR_RESULT\"];\n" + " node12 -> node18 [weight=1];\n" + " node19 [label=\"NAME\"];\n" + " node18 -> node19 [weight=1];\n" + " node18 -> RETURN [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node12 -> node18 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node1 -> node2 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node0 -> node1 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "}\n"; testCfg(src, expected); } public void testComplicatedFinally2() { // Now the most nasty case..... String src = "while(1){try{" + "if(a){a;continue;}else if(b){b;break;} else if(c) throw 1; else a}" + "catch(e){}finally{c()}bar}foo"; ControlFlowGraph<Node> cfg = createCfg(src); // Focus only on the ON_EX edges. assertCrossEdge(cfg, Token.CONTINUE, Token.BLOCK, Branch.UNCOND); assertCrossEdge(cfg, Token.BREAK, Token.BLOCK, Branch.UNCOND); assertCrossEdge(cfg, Token.THROW, Token.BLOCK, Branch.ON_EX); } public void testDeepNestedBreakwithFinally() { String src = "X:while(1){try{while(2){try{var a;break X;}" + "finally{}}}finally{}}"; ControlFlowGraph<Node> cfg = createCfg(src); assertDownEdge(cfg, Token.WHILE, Token.BLOCK, Branch.ON_TRUE); assertDownEdge(cfg, Token.BLOCK, Token.TRY, Branch.UNCOND); assertDownEdge(cfg, Token.BLOCK, Token.VAR, Branch.UNCOND); // BREAK to FINALLY. assertCrossEdge(cfg, Token.BREAK, Token.BLOCK, Branch.UNCOND); // FINALLY to FINALLY. assertCrossEdge(cfg, Token.BLOCK, Token.BLOCK, Branch.ON_EX); assertCrossEdge(cfg, Token.WHILE, Token.BLOCK, Branch.ON_FALSE); assertReturnEdge(cfg, Token.BLOCK); } public void testDeepNestedFinally() { String src = "try{try{try{throw 1}" + "finally{1;var a}}finally{2;if(a);}}finally{3;a()}"; ControlFlowGraph<Node> cfg = createCfg(src); assertCrossEdge(cfg, Token.THROW, Token.BLOCK, Branch.ON_EX); assertCrossEdge(cfg, Token.VAR, Token.BLOCK, Branch.UNCOND); assertCrossEdge(cfg, Token.IF, Token.BLOCK, Branch.ON_EX); } public void testReturn() { String src = "function f() { return; }"; ControlFlowGraph<Node> cfg = createCfg(src); assertReturnEdge(cfg, Token.RETURN); } public void testReturnInFinally() { String src = "function f(x){ try{} finally {return x;} }"; ControlFlowGraph<Node> cfg = createCfg(src); assertReturnEdge(cfg, Token.RETURN); } public void testReturnInFinally2() { String src = "function f(x){" + " try{ try{}finally{var dummy; return x;} } finally {} }"; ControlFlowGraph<Node> cfg = createCfg(src); assertCrossEdge(cfg, Token.VAR, Token.RETURN, Branch.UNCOND); assertCrossEdge(cfg, Token.RETURN, Token.BLOCK, Branch.UNCOND); assertReturnEdge(cfg, Token.BLOCK); assertNoReturnEdge(cfg, Token.RETURN); } public void testReturnInTry() { String src = "function f(x){ try{x; return x()} finally {} var y;}"; ControlFlowGraph<Node> cfg = createCfg(src); assertCrossEdge(cfg, Token.EXPR_RESULT, Token.RETURN, Branch.UNCOND); assertCrossEdge(cfg, Token.RETURN, Token.BLOCK, Branch.UNCOND); assertCrossEdge(cfg, Token.BLOCK, Token.VAR, Branch.UNCOND); assertReturnEdge(cfg, Token.VAR); assertReturnEdge(cfg, Token.BLOCK); assertNoReturnEdge(cfg, Token.RETURN); } public void testOptionNotToTraverseFunctions() { String src = "var x = 1; function f() { x = null; }"; String expectedWhenNotTraversingFunctions = "digraph AST {\n" + " node [color=lightblue2, style=filled];\n" + " node0 [label=\"SCRIPT\"];\n" + " node1 [label=\"VAR\"];\n" + " node0 -> node1 [weight=1];\n" + " node2 [label=\"NAME\"];\n" + " node1 -> node2 [weight=1];\n" + " node3 [label=\"NUMBER\"];\n" + " node2 -> node3 [weight=1];\n" + " node1 -> RETURN " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node4 [label=\"FUNCTION\"];\n" + " node0 -> node4 [weight=1];\n" + " node5 [label=\"NAME\"];\n" + " node4 -> node5 [weight=1];\n" + " node6 [label=\"PARAM_LIST\"];\n" + " node4 -> node6 [weight=1];\n" + " node7 [label=\"BLOCK\"];\n" + " node4 -> node7 [weight=1];\n" + " node8 [label=\"EXPR_RESULT\"];\n" + " node7 -> node8 [weight=1];\n" + " node9 [label=\"ASSIGN\"];\n" + " node8 -> node9 [weight=1];\n" + " node10 [label=\"NAME\"];\n" + " node9 -> node10 [weight=1];\n" + " node11 [label=\"NULL\"];\n" + " node9 -> node11 [weight=1];\n" + " node0 -> node1 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "}\n"; String expected = "digraph AST {\n" + " node [color=lightblue2, style=filled];\n" + " node0 [label=\"SCRIPT\"];\n" + " node1 [label=\"VAR\"];\n" + " node0 -> node1 [weight=1];\n" + " node2 [label=\"NAME\"];\n" + " node1 -> node2 [weight=1];\n" + " node3 [label=\"NUMBER\"];\n" + " node2 -> node3 [weight=1];\n" + " node1 -> RETURN " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node4 [label=\"FUNCTION\"];\n" + " node0 -> node4 [weight=1];\n" + " node5 [label=\"NAME\"];\n" + " node4 -> node5 [weight=1];\n" + " node6 [label=\"PARAM_LIST\"];\n" + " node4 -> node6 [weight=1];\n" + " node7 [label=\"BLOCK\"];\n" + " node4 -> node7 [weight=1];\n" + " node8 [label=\"EXPR_RESULT\"];\n" + " node7 -> node8 [weight=1];\n" + " node9 [label=\"ASSIGN\"];\n" + " node8 -> node9 [weight=1];\n" + " node10 [label=\"NAME\"];\n" + " node9 -> node10 [weight=1];\n" + " node11 [label=\"NULL\"];\n" + " node9 -> node11 [weight=1];\n" + " node8 -> RETURN " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node7 -> node8 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node4 -> node7 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node0 -> node1 " + "[label=\"UNCOND\", fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "}\n"; testCfg(src, expected); testCfg(src, expectedWhenNotTraversingFunctions, false); } public void testInstanceOf() { String src = "try { x instanceof 'x' } catch (e) { }"; ControlFlowGraph<Node> cfg = createCfg(src, true); assertCrossEdge(cfg, Token.EXPR_RESULT, Token.BLOCK, Branch.ON_EX); } public void testSynBlock() { String src = "START(); var x; END(); var y;"; ControlFlowGraph<Node> cfg = createCfg(src, true); assertCrossEdge(cfg, Token.BLOCK, Token.EXPR_RESULT, Branch.SYN_BLOCK); } public void testPartialTraversalOfScope() { Compiler compiler = new Compiler(); ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, true, true); Node script1 = compiler.parseSyntheticCode("cfgtest", "var foo;"); Node script2 = compiler.parseSyntheticCode("cfgtest2", "var bar;"); Node root = new Node(Token.BLOCK, script1, script2); cfa.process(null, script1); ControlFlowGraph<Node> cfg = cfa.getCfg(); assertNotNull(cfg.getNode(script1)); assertNull(cfg.getNode(script2)); } public void testForLoopOrder() { assertNodeOrder( createCfg("for (var i = 0; i < 5; i++) { var x = 3; } if (true) {}"), Lists.newArrayList( Token.SCRIPT, Token.VAR, Token.FOR, Token.BLOCK, Token.VAR, Token.INC /* i++ */, Token.IF, Token.BLOCK)); } public void testLabelledForInLoopOrder() { assertNodeOrder( createCfg("var i = 0; var y = {}; " + "label: for (var x in y) { " + " if (x) { break label; } else { i++ } x(); }"), Lists.newArrayList( Token.SCRIPT, Token.VAR, Token.VAR, Token.NAME, Token.FOR, Token.BLOCK, Token.IF, Token.BLOCK, Token.BREAK, Token.BLOCK, Token.EXPR_RESULT, Token.EXPR_RESULT)); } public void testLocalFunctionOrder() { ControlFlowGraph<Node> cfg = createCfg("function f() { while (x) { x++; } } var x = 3;"); assertNodeOrder( cfg, Lists.newArrayList( Token.SCRIPT, Token.VAR, Token.FUNCTION, Token.BLOCK, Token.WHILE, Token.BLOCK, Token.EXPR_RESULT)); } public void testDoWhileOrder() { assertNodeOrder( createCfg("do { var x = 3; } while (true); void x;"), Lists.newArrayList( Token.SCRIPT, Token.BLOCK, Token.VAR, Token.DO, Token.EXPR_RESULT)); } public void testBreakInFinally1() { String src = "f = function() {\n" + " var action;\n" + " a: {\n" + " var proto = null;\n" + " try {\n" + " proto = new Proto\n" + " } finally {\n" + " action = proto;\n" + " break a\n" + // Remove this... " }\n" + " }\n" + " alert(action)\n" + // but not this. "};"; String expected = "digraph AST {\n" + " node [color=lightblue2, style=filled];\n" + " node0 [label=\"SCRIPT\"];\n" + " node1 [label=\"EXPR_RESULT\"];\n" + " node0 -> node1 [weight=1];\n" + " node2 [label=\"ASSIGN\"];\n" + " node1 -> node2 [weight=1];\n" + " node3 [label=\"NAME\"];\n" + " node2 -> node3 [weight=1];\n" + " node4 [label=\"FUNCTION\"];\n" + " node2 -> node4 [weight=1];\n" + " node5 [label=\"NAME\"];\n" + " node4 -> node5 [weight=1];\n" + " node6 [label=\"PARAM_LIST\"];\n" + " node4 -> node6 [weight=1];\n" + " node7 [label=\"BLOCK\"];\n" + " node4 -> node7 [weight=1];\n" + " node8 [label=\"VAR\"];\n" + " node7 -> node8 [weight=1];\n" + " node9 [label=\"NAME\"];\n" + " node8 -> node9 [weight=1];\n" + " node10 [label=\"LABEL\"];\n" + " node7 -> node10 [weight=1];\n" + " node11 [label=\"LABEL_NAME\"];\n" + " node10 -> node11 [weight=1];\n" + " node12 [label=\"BLOCK\"];\n" + " node10 -> node12 [weight=1];\n" + " node13 [label=\"VAR\"];\n" + " node12 -> node13 [weight=1];\n" + " node14 [label=\"NAME\"];\n" + " node13 -> node14 [weight=1];\n" + " node15 [label=\"NULL\"];\n" + " node14 -> node15 [weight=1];\n" + " node16 [label=\"TRY\"];\n" + " node12 -> node16 [weight=1];\n" + " node17 [label=\"BLOCK\"];\n" + " node16 -> node17 [weight=1];\n" + " node18 [label=\"EXPR_RESULT\"];\n" + " node17 -> node18 [weight=1];\n" + " node19 [label=\"ASSIGN\"];\n" + " node18 -> node19 [weight=1];\n" + " node20 [label=\"NAME\"];\n" + " node19 -> node20 [weight=1];\n" + " node21 [label=\"NEW\"];\n" + " node19 -> node21 [weight=1];\n" + " node22 [label=\"NAME\"];\n" + " node21 -> node22 [weight=1];\n" + " node23 [label=\"BLOCK\"];\n" + " node16 -> node23 [weight=1];\n" + " node24 [label=\"BLOCK\"];\n" + " node16 -> node24 [weight=1];\n" + " node25 [label=\"EXPR_RESULT\"];\n" + " node24 -> node25 [weight=1];\n" + " node26 [label=\"ASSIGN\"];\n" + " node25 -> node26 [weight=1];\n" + " node27 [label=\"NAME\"];\n" + " node26 -> node27 [weight=1];\n" + " node28 [label=\"NAME\"];\n" + " node26 -> node28 [weight=1];\n" + " node29 [label=\"BREAK\"];\n" + " node24 -> node29 [weight=1];\n" + " node30 [label=\"LABEL_NAME\"];\n" + " node29 -> node30 [weight=1];\n" + " node31 [label=\"EXPR_RESULT\"];\n" + " node7 -> node31 [weight=1];\n" + " node32 [label=\"CALL\"];\n" + " node31 -> node32 [weight=1];\n" + " node33 [label=\"NAME\"];\n" + " node32 -> node33 [weight=1];\n" + " node34 [label=\"NAME\"];\n" + " node32 -> node34 [weight=1];\n" + " node1 -> RETURN [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + " node0 -> node1 [label=\"UNCOND\", " + "fontcolor=\"red\", weight=0.01, color=\"red\"];\n" + "}\n"; testCfg(src, expected); } public void testBreakInFinally2() { String src = "var action;\n" + "a: {\n" + " var proto = null;\n" + " try {\n" + " proto = new Proto\n" + " } finally {\n" + " action = proto;\n" + " break a\n" + " }\n" + "}\n" + "alert(action)\n"; ControlFlowGraph<Node> cfg = createCfg(src); assertCrossEdge(cfg, Token.BREAK, Token.EXPR_RESULT, Branch.UNCOND); assertNoEdge(cfg, Token.BREAK, Token.BLOCK); } /** * Asserts the priority order of CFG nodes. * * Checks that the node type of the highest-priority node matches the * first element of the list, the type of the second node matches the * second element of the list, and so on. * * @param cfg The control flow graph. * @param nodeTypes The expected node types, in order. */ private void assertNodeOrder(ControlFlowGraph<Node> cfg, List<Integer> nodeTypes) { List<DiGraphNode<Node, Branch>> cfgNodes = Lists.newArrayList(cfg.getDirectedGraphNodes()); Collections.sort(cfgNodes, cfg.getOptionalNodeComparator(true)); // IMPLICIT RETURN must always be last. Node implicitReturn = cfgNodes.remove(cfgNodes.size() - 1).getValue(); assertNull(implicitReturn == null ? "null" : implicitReturn.toStringTree(), implicitReturn); assertEquals("Wrong number of CFG nodes", nodeTypes.size(), cfgNodes.size()); for (int i = 0; i < cfgNodes.size(); i++) { int expectedType = nodeTypes.get(i); int actualType = cfgNodes.get(i).getValue().getType(); assertEquals( "node type mismatch at " + i + ".\n" + "found : " + Token.name(actualType) + "\n" + "required: " + Token.name(expectedType) + "\n", expectedType, actualType); } } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Test for the control structure verification. * */ public class ControlStructureCheckTest extends CompilerTestCase { // Rhino parse error message text final String UNLABELED_BREAK = "unlabelled break must be inside loop or switch"; final String UNEXPECTED_CONTINUE = "continue must be inside loop"; final String UNEXPECTED_LABLED_CONTINUE = "continue can only use labeles of iteration statements"; final String UNDEFINED_LABEL = "undefined label"; @Override public CompilerPass getProcessor(Compiler compiler) { return new ControlStructureCheck(compiler); } public void testWhile() { assertNoError("while(1) { break; }"); } public void testNextedWhile() { assertNoError("while(1) { while(1) { break; } }"); } public void testBreak() { assertInvalidBreak("break;"); } public void testContinue() { assertInvalidContinue("continue;"); } public void testBreakCrossFunction() { assertInvalidBreak("while(1) { function f() { break; } }"); } public void testBreakCrossFunctionInFor() { assertInvalidBreak("while(1) {for(var f = function () { break; };;) {}}"); } public void testContinueToSwitch() { assertInvalidContinue("switch(1) {case(1): continue; }"); } public void testContinueToSwitchWithNoCases() { assertNoError("switch(1){}"); } public void testContinueToSwitchWithTwoCases() { assertInvalidContinue("switch(1){case(1):break;case(2):continue;}"); } public void testContinueToSwitchWithDefault() { assertInvalidContinue("switch(1){case(1):break;case(2):default:continue;}"); } public void testContinueToLabelSwitch() { assertInvalidLabeledContinue( "while(1) {a: switch(1) {case(1): continue a; }}"); } public void testContinueOutsideSwitch() { assertNoError("b: while(1) { a: switch(1) { case(1): continue b; } }"); } public void testContinueNotCrossFunction1() { assertNoError("a:switch(1){case(1):function f(){a:while(1){continue a;}}}"); } public void testContinueNotCrossFunction2() { assertUndefinedLabel( "a:switch(1){case(1):function f(){while(1){continue a;}}}"); } public void testUseOfWith1() { testSame("with(a){}", ControlStructureCheck.USE_OF_WITH); } public void testUseOfWith2() { testSame("/** @suppress {with} */" + "with(a){}"); } public void testUseOfWith3() { testSame( "function f(expr, context) {\n" + " try {\n" + " /** @suppress{with} */ with (context) {\n" + " return eval('[' + expr + '][0]');\n" + " }\n" + " } catch (e) {\n" + " return null;\n" + " }\n" + "};\n"); } private void assertNoError(String js) { testSame(js); } private void assertInvalidBreak(String js) { testParseError(js, UNLABELED_BREAK); } private void assertInvalidContinue(String js) { testParseError(js, UNEXPECTED_CONTINUE); } private void assertInvalidLabeledContinue(String js) { testParseError(js, UNEXPECTED_LABLED_CONTINUE); } private void assertUndefinedLabel(String js) { testParseError(js, UNDEFINED_LABEL); } private void testParseError(String js, String errorText) { Compiler compiler = new Compiler(); compiler.parseTestCode(js); assertTrue(compiler.getErrorCount() == 1); String msg = compiler.getErrors()[0].toString(); assertTrue(msg.contains(errorText)); } }
/* * Copyright 2007 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Tests for {@link ConvertToDottedProperties}. * */ public class ConvertToDottedPropertiesTest extends CompilerTestCase { @Override public CompilerPass getProcessor(Compiler compiler) { return new ConvertToDottedProperties(compiler); } public void testConvert() { test("a['p']", "a.p"); test("a['_p_']", "a._p_"); test("a['_']", "a._"); test("a['$']", "a.$"); test("a.b.c['p']", "a.b.c.p"); test("a.b['c'].p", "a.b.c.p"); test("a['p']();", "a.p();"); test("a()['p']", "a().p"); // ASCII in Unicode is safe. test("a['\u0041A']", "a.AA"); } public void testDoNotConvert() { testSame("a[0]"); testSame("a['']"); testSame("a[' ']"); testSame("a[',']"); testSame("a[';']"); testSame("a[':']"); testSame("a['.']"); testSame("a['0']"); testSame("a['p ']"); testSame("a['p' + '']"); testSame("a[p]"); testSame("a[P]"); testSame("a[$]"); testSame("a[p()]"); testSame("a['default']"); // upper case lower half of o from phonetic extensions set. // valid in Safari, not in Firefox, IE. test("a['\u1d17A']", "a['\u1d17A']"); // Latin capital N with tilde - nice if we handled it, but for now let's // only allow simple Latin (aka ASCII) to be converted. test("a['\u00d1StuffAfter']", "a['\u00d1StuffAfter']"); } public void testQuotedProps() { testSame("({'':0})"); testSame("({'1.0':0})"); testSame("({'\u1d17A':0})"); } public void test5746867() { testSame("var a = { '$\\\\' : 5 };"); testSame("var a = { 'x\\\\u0041$\\\\' : 5 };"); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.rhino.Node; /** * Tests for {@link CreateSyntheticBlocks} * */ public class CreateSyntheticBlocksTest extends CompilerTestCase { private static final String START_MARKER = "startMarker"; private static final String END_MARKER = "endMarker"; public CreateSyntheticBlocksTest() { // Can't use compare as a tree because of the added synthetic blocks. super("", false); } @Override public void setUp() { super.enableLineNumberCheck(false); } @Override protected CompilerPass getProcessor(final Compiler compiler) { return new CompilerPass() { @Override public void process(Node externs, Node js) { new CreateSyntheticBlocks(compiler, START_MARKER, END_MARKER).process( externs, js); NodeTraversal.traverse(compiler, js, new MinimizeExitPoints(compiler)); new PeepholeOptimizationsPass(compiler, new PeepholeRemoveDeadCode(), new PeepholeSubstituteAlternateSyntax(true), new PeepholeFoldConstants(true)) .process(externs, js); new MinimizeExitPoints(compiler).process(externs, js); new Denormalize(compiler).process(externs, js); } }; } @Override protected int getNumRepetitions() { return 1; } // TODO(johnlenz): Add tests to the IntegrationTest. public void testFold1() { test("function f() { if (x) return; y(); }", "function f(){x||y()}"); } public void testFoldWithMarkers1() { testSame("function f(){startMarker();if(x)return;endMarker();y()}"); } public void testFoldWithMarkers1a() { testSame("function f(){startMarker();if(x)return;endMarker()}"); } public void testFold2() { test("function f() { if (x) return; y(); if (a) return; b(); }", "function f(){if(!x){y();a||b()}}"); } public void testFoldWithMarkers2() { testSame("function f(){startMarker(\"FOO\");startMarker(\"BAR\");" + "if(x)return;endMarker(\"BAR\");y();if(a)return;" + "endMarker(\"FOO\");b()}"); } public void testUnmatchedStartMarker() { testSame("startMarker()", CreateSyntheticBlocks.UNMATCHED_START_MARKER); } public void testUnmatchedEndMarker1() { testSame("endMarker()", CreateSyntheticBlocks.UNMATCHED_END_MARKER); } public void testUnmatchedEndMarker2() { test("if(y){startMarker();x()}endMarker()", "if(y){startMarker();x()}endMarker()", null, CreateSyntheticBlocks.UNMATCHED_END_MARKER); } public void testInvalid1() { test("startMarker() && true", "startMarker()", null, CreateSyntheticBlocks.INVALID_MARKER_USAGE); } public void testInvalid2() { test("false && endMarker()", "", null, CreateSyntheticBlocks.INVALID_MARKER_USAGE); } public void testDenormalize() { testSame("startMarker();for(;;);endMarker()"); } public void testNonMarkingUse() { testSame("function foo(endMarker){}"); testSame("function foo(){startMarker:foo()}"); } public void testContainingBlockPreservation() { testSame("if(y){startMarker();x();endMarker()}"); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Tests for {@link CrossModuleCodeMotion}. * */ public class CrossModuleCodeMotionTest extends CompilerTestCase { private static final String EXTERNS = "alert"; public CrossModuleCodeMotionTest() { super(EXTERNS); } @Override public void setUp() { super.enableLineNumberCheck(true); } @Override public CompilerPass getProcessor(Compiler compiler) { return new CrossModuleCodeMotion(compiler, compiler.getModuleGraph()); } public void testFunctionMovement1() { // This tests lots of things: // 1) f1 is declared in m1, and used in m2. Move it to m2 // 2) f2 is declared in m1, and used in m3 twice. Move it to m3 // 3) f3 is declared in m1, and used in m2+m3. It stays put // 4) g declared in m1 and never used. It stays put // 5) h declared in m2 and never used. It stays put // 6) f4 declared in m1 and used in m2 as var. It moves to m2 JSModule[] modules = createModuleStar( // m1 "function f1(a) { alert(a); }" + "function f2(a) { alert(a); }" + "function f3(a) { alert(a); }" + "function f4() { alert(1); }" + "function g() { alert('ciao'); }", // m2 "f1('hi'); f3('bye'); var a = f4;" + "function h(a) { alert('h:' + a); }", // m3 "f2('hi'); f2('hi'); f3('bye');"); test(modules, new String[] { // m1 "function f3(a) { alert(a); }" + "function g() { alert('ciao'); }", // m2 "function f4() { alert(1); }" + "function f1(a) { alert(a); }" + "f1('hi'); f3('bye'); var a = f4;" + "function h(a) { alert('h:' + a); }", // m3 "function f2(a) { alert(a); }" + "f2('hi'); f2('hi'); f3('bye');", }); } public void testFunctionMovement2() { // having f declared as a local variable should block the migration to m2 JSModule[] modules = createModuleStar( // m1 "function f(a) { alert(a); }" + "function g() {var f = 1; f++}", // m2 "f(1);"); test(modules, new String[] { // m1 "function g() {var f = 1; f++}", // m2 "function f(a) { alert(a); }" + "f(1);", }); } public void testFunctionMovement3() { // having f declared as a arg should block the migration to m2 JSModule[] modules = createModuleStar( // m1 "function f(a) { alert(a); }" + "function g(f) {f++}", // m2 "f(1);"); test(modules, new String[] { // m1 "function g(f) {f++}", // m2 "function f(a) { alert(a); }" + "f(1);", }); } public void testFunctionMovement4() { // Try out moving a function which returns a closure JSModule[] modules = createModuleStar( // m1 "function f(){return function(a){}}", // m2 "var a = f();" ); test(modules, new String[] { // m1 "", // m2 "function f(){return function(a){}}" + "var a = f();", }); } public void testFunctionMovement5() { // Try moving a recursive function [using factorials for kicks] JSModule[] modules = createModuleStar( // m1 "function f(n){return (n<1)?1:f(n-1)}", // m2 "var a = f(4);" ); test(modules, new String[] { // m1 "", // m2 "function f(n){return (n<1)?1:f(n-1)}" + "var a = f(4);", }); } public void testFunctionMovement5b() { // Try moving a recursive function declared differently. JSModule[] modules = createModuleStar( // m1 "var f = function(n){return (n<1)?1:f(n-1)};", // m2 "var a = f(4);" ); test(modules, new String[] { // m1 "", // m2 "var f = function(n){return (n<1)?1:f(n-1)};" + "var a = f(4);", }); } public void testFunctionMovement6() { // Try out moving to the common ancestor JSModule[] modules = createModuleChain( // m1 "function f(){return 1}", // m2 "var a = f();", // m3 "var b = f();" ); test(modules, new String[] { // m1 "", // m2 "function f(){return 1}" + "var a = f();", // m3 "var b = f();", }); } public void testFunctionMovement7() { // Try out moving to the common ancestor with deeper ancestry chain JSModule[] modules = createModules( // m1 "function f(){return 1}", // m2 "", // m3 "var a = f();", // m4 "var b = f();", // m5 "var c = f();" ); modules[1].addDependency(modules[0]); modules[2].addDependency(modules[1]); modules[3].addDependency(modules[1]); modules[4].addDependency(modules[1]); test(modules, new String[] { // m1 "", // m2 "function f(){return 1}", // m3 "var a = f();", // m4 "var b = f();", // m5 "var c = f();", }); } public void testFunctionMovement8() { // Check what happens with named functions JSModule[] modules = createModuleChain( // m1 "var v = function f(){return 1}", // m2 "v();" ); test(modules, new String[] { // m1 "", // m2 "var v = function f(){return 1};" + "v();", }); } public void testFunctionNonMovement1() { // This tests lots of things: // 1) we can't move it if it is a class with non-const attributes accessed // 2) if it's in an if statement, we can't move it // 3) if it's in an while statement, we can't move it [with some extra // block elements] testSame(createModuleStar( // m1 "function f(){};f.prototype.bar=new f;" + "if(a)function f2(){}" + "{{while(a)function f3(){}}}", // m2 "var a = new f();f2();f3();")); } public void testFunctionNonMovement2() { // A generic case where 2 modules depend on the first one. But it's the // common ancestor, so we can't move. testSame(createModuleStar( // m1 "function f(){return 1}", // m2 "var a = f();", // m3 "var b = f();")); } public void testClassMovement1() { test(createModuleStar( // m1 "function f(){} f.prototype.bar=function (){};", // m2 "var a = new f();"), new String[] { "", "function f(){} f.prototype.bar=function (){};" + "var a = new f();" }); } public void testClassMovement2() { // NOTE: this is the result of two iterations test(createModuleChain( // m1 "function f(){} f.prototype.bar=3; f.prototype.baz=5;", // m2 "f.prototype.baq = 7;", // m3 "f.prototype.baz = 9;", // m4 "var a = new f();"), new String[] { // m1 "", // m2 "", // m3 "function f(){} f.prototype.bar=3; f.prototype.baz=5;" + "f.prototype.baq = 7;" + "f.prototype.baz = 9;", // m4 "var a = new f();" }); } public void testClassMovement3() { // NOTE: this is the result of two iterations test(createModuleChain( // m1 "var f = function() {}; f.prototype.bar=3; f.prototype.baz=5;", // m2 "f = 7;", // m3 "f = 9;", // m4 "f = 11;"), new String[] { // m1 "", // m2 "", // m3 "var f = function() {}; f.prototype.bar=3; f.prototype.baz=5;" + "f = 7;" + "f = 9;", // m4 "f = 11;" }); } public void testClassMovement4() { testSame(createModuleStar( // m1 "function f(){} f.prototype.bar=3; f.prototype.baz=5;", // m2 "f.prototype.baq = 7;", // m3 "var a = new f();")); } public void testClassMovement5() { JSModule[] modules = createModules( // m1 "function f(){} f.prototype.bar=3; f.prototype.baz=5;", // m2 "", // m3 "f.prototype.baq = 7;", // m4 "var a = new f();"); modules[1].addDependency(modules[0]); modules[2].addDependency(modules[1]); modules[3].addDependency(modules[1]); test(modules, new String[] { // m1 "", // m2 "function f(){} f.prototype.bar=3; f.prototype.baz=5;", // m3 "f.prototype.baq = 7;", // m4 + "var a = new f();" }); } public void testClassMovement6() { test(createModuleChain( // m1 "function Foo(){} function Bar(){} goog.inherits(Bar, Foo);" + "new Foo();", // m2 "new Bar();"), new String[] { // m1 "function Foo(){} new Foo();", // m2 "function Bar(){} goog.inherits(Bar, Foo); new Bar();" }); } public void testClassMovement7() { testSame(createModuleChain( // m1 "function Foo(){} function Bar(){} goog.inherits(Bar, Foo);" + "new Bar();", // m2 "new Foo();")); } public void testStubMethodMovement1() { test(createModuleChain( // m1 "function Foo(){} " + "Foo.prototype.bar = JSCompiler_stubMethod(x);", // m2 "new Foo();"), new String[] { // m1 "", "function Foo(){} " + "Foo.prototype.bar = JSCompiler_stubMethod(x);" + "new Foo();" }); } public void testStubMethodMovement2() { test(createModuleChain( // m1 "function Foo(){} " + "Foo.prototype.bar = JSCompiler_unstubMethod(x);", // m2 "new Foo();"), new String[] { // m1 "", "function Foo(){} " + "Foo.prototype.bar = JSCompiler_unstubMethod(x);" + "new Foo();" }); } public void testNoMoveSideEffectProperty() { testSame(createModuleChain( // m1 "function Foo(){} " + "Foo.prototype.bar = createSomething();", // m2 "new Foo();")); } public void testAssignMovement() { test(createModuleChain( // m1 "var f = 3;" + "f = 5;", // m2 "var h = f;"), new String[] { // m1 "", // m2 "var f = 3;" + "f = 5;" + "var h = f;" }); // don't move nested assigns testSame(createModuleChain( // m1 "var f = 3;" + "var g = f = 5;", // m2 "var h = f;")); } public void testNoClassMovement2() { test(createModuleChain( // m1 "var f = {};" + "f.h = 5;", // m2 "var h = f;"), new String[] { // m1 "", // m2 "var f = {};" + "f.h = 5;" + "var h = f;" }); // don't move nested getprop assigns testSame(createModuleChain( // m1 "var f = {};" + "var g = f.h = 5;", // m2 "var h = f;")); } public void testLiteralMovement1() { test(createModuleChain( // m1 "var f = {'hi': 'mom', 'bye': function() {}};", // m2 "var h = f;"), new String[] { // m1 "", // m2 "var f = {'hi': 'mom', 'bye': function() {}};" + "var h = f;" }); } public void testLiteralMovement2() { testSame(createModuleChain( // m1 "var f = {'hi': 'mom', 'bye': goog.nullFunction};", // m2 "var h = f;")); } public void testLiteralMovement3() { test(createModuleChain( // m1 "var f = ['hi', function() {}];", // m2 "var h = f;"), new String[] { // m1 "", // m2 "var f = ['hi', function() {}];" + "var h = f;" }); } public void testLiteralMovement4() { testSame(createModuleChain( // m1 "var f = ['hi', goog.nullFunction];", // m2 "var h = f;")); } public void testVarMovement1() { // test moving a variable JSModule[] modules = createModuleStar( // m1 "var a = 0;", // m2 "var x = a;" ); test(modules, new String[] { // m1 "", // m2 "var a = 0;" + "var x = a;", }); } public void testVarMovement2() { // Test moving 1 variable out of the block JSModule[] modules = createModuleStar( // m1 "var a = 0; var b = 1; var c = 2;", // m2 "var x = b;" ); test(modules, new String[] { // m1 "var a = 0; var c = 2;", // m2 "var b = 1;" + "var x = b;" }); } public void testVarMovement3() { // Test moving all variables out of the block JSModule[] modules = createModuleStar( // m1 "var a = 0; var b = 1;", // m2 "var x = a + b;" ); test(modules, new String[] { // m1 "", // m2 "var b = 1;" + "var a = 0;" + "var x = a + b;" }); } public void testVarMovement4() { // Test moving a function JSModule[] modules = createModuleStar( // m1 "var a = function(){alert(1)};", // m2 "var x = a;" ); test(modules, new String[] { // m1 "", // m2 "var a = function(){alert(1)};" + "var x = a;" }); } public void testVarMovement5() { // Don't move a function outside of scope testSame(createModuleStar( // m1 "var a = alert;", // m2 "var x = a;")); } public void testVarMovement6() { // Test moving a var with no assigned value JSModule[] modules = createModuleStar( // m1 "var a;", // m2 "var x = a;" ); test(modules, new String[] { // m1 "", // m2 "var a;" + "var x = a;" }); } public void testVarMovement7() { // Don't move a variable higher in the dependency tree testSame(createModuleStar( // m1 "function f() {g();}", // m2 "function g(){};")); } public void testVarMovement8() { JSModule[] modules = createModuleBush( // m1 "var a = 0;", // m2 -> m1 "", // m3 -> m2 "var x = a;", // m4 -> m2 "var y = a;" ); test(modules, new String[] { // m1 "", // m2 "var a = 0;", // m3 "var x = a;", // m4 "var y = a;" }); } public void testVarMovement9() { JSModule[] modules = createModuleTree( // m1 "var a = 0; var b = 1; var c = 3;", // m2 -> m1 "", // m3 -> m1 "", // m4 -> m2 "a;", // m5 -> m2 "a;c;", // m6 -> m3 "b;", // m7 -> m4 "b;c;" ); test(modules, new String[] { // m1 "var c = 3;", // m2 "var a = 0;", // m3 "var b = 1;", // m4 "a;", // m5 "a;c;", // m6 "b;", // m7 "b;c;" }); } public void testClone1() { test(createModuleChain( // m1 "function f(){} f.prototype.clone = function() { return new f };", // m2 "var a = (new f).clone();"), new String[] { // m1 "", "function f(){} f.prototype.clone = function() { return new f() };" + // m2 "var a = (new f).clone();" }); } public void testClone2() { test(createModuleChain( // m1 "function f(){}" + "f.prototype.cloneFun = function() {" + " return function() {new f}" + "};", // m2 "var a = (new f).cloneFun();"), new String[] { // m1 "", "function f(){}" + "f.prototype.cloneFun = function() {" + " return function() {new f}" + "};" + // m2 "var a = (new f).cloneFun();" }); } public void testBug4118005() { testSame(createModuleChain( // m1 "var m = 1;\n" + "(function () {\n" + " var x = 1;\n" + " m = function() { return x };\n" + "})();\n", // m2 "m();")); } public void testEmptyModule() { // When the dest module is empty, it might try to move the code to the // one of the modules that the empty module depends on. In some cases // this might ended up to be the same module as the definition of the code. // When that happens, CrossModuleCodeMotion might report a code change // while nothing is moved. This should not be a problem if we know all // modules are non-empty. JSModule m1 = new JSModule("m1"); m1.add(SourceFile.fromCode("m1", "function x() {}")); JSModule empty = new JSModule("empty"); empty.addDependency(m1); JSModule m2 = new JSModule("m2"); m2.add(SourceFile.fromCode("m2", "x()")); m2.addDependency(empty); JSModule m3 = new JSModule("m3"); m3.add(SourceFile.fromCode("m3", "x()")); m3.addDependency(empty); test(new JSModule[] {m1,empty,m2,m3}, new String[] { "", "function x() {}", "x()", "x()" }); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Tests for {@link CrossModuleMethodMotion}. * * @author nicksantos@google.com (Nick Santos) */ public class CrossModuleMethodMotionTest extends CompilerTestCase { private static final String EXTERNS = "IFoo.prototype.bar; var mExtern; mExtern.bExtern; mExtern['cExtern'];"; private boolean canMoveExterns = false; private final String STUB_DECLARATIONS = CrossModuleMethodMotion.STUB_DECLARATIONS; public CrossModuleMethodMotionTest() { super(EXTERNS); } @Override protected CompilerPass getProcessor(Compiler compiler) { return new CrossModuleMethodMotion( compiler, new CrossModuleMethodMotion.IdGenerator(), canMoveExterns); } @Override public void setUp() { super.enableLineNumberCheck(true); canMoveExterns = false; } public void testMovePrototypeMethod1() { testSame(createModuleChain( "function Foo() {}" + "Foo.prototype.bar = function() {};", // Module 2 "(new Foo).bar()")); canMoveExterns = true; test(createModuleChain( "function Foo() {}" + "Foo.prototype.bar = function() {};", // Module 2 "(new Foo).bar()"), new String[] { STUB_DECLARATIONS + "function Foo() {}" + "Foo.prototype.bar = JSCompiler_stubMethod(0);", // Module 2 "Foo.prototype.bar = JSCompiler_unstubMethod(0, function() {});" + "(new Foo).bar()" }); } public void testMovePrototypeMethod2() { test(createModuleChain( "function Foo() {}" + "Foo.prototype = { method: function() {} };", // Module 2 "(new Foo).method()"), new String[] { STUB_DECLARATIONS + "function Foo() {}" + "Foo.prototype = { method: JSCompiler_stubMethod(0) };", // Module 2 "Foo.prototype.method = " + " JSCompiler_unstubMethod(0, function() {});" + "(new Foo).method()" }); } public void testMovePrototypeMethod3() { testSame(createModuleChain( "function Foo() {}" + "Foo.prototype = { get method() {} };", // Module 2 "(new Foo).method()")); } public void testMovePrototypeRecursiveMethod() { test(createModuleChain( "function Foo() {}" + "Foo.prototype.baz = function() { this.baz(); };", // Module 2 "(new Foo).baz()"), new String[] { STUB_DECLARATIONS + "function Foo() {}" + "Foo.prototype.baz = JSCompiler_stubMethod(0);", // Module 2 "Foo.prototype.baz = JSCompiler_unstubMethod(0, " + " function() { this.baz(); });" + "(new Foo).baz()" }); } public void testCantMovePrototypeProp() { testSame(createModuleChain( "function Foo() {}" + "Foo.prototype.baz = goog.nullFunction;", // Module 2 "(new Foo).baz()")); } public void testMoveMethodsInRightOrder() { test(createModuleChain( "function Foo() {}" + "Foo.prototype.baz = function() { return 1; };" + "Foo.prototype.baz = function() { return 2; };", // Module 2 "(new Foo).baz()"), new String[] { STUB_DECLARATIONS + "function Foo() {}" + "Foo.prototype.baz = JSCompiler_stubMethod(1);" + "Foo.prototype.baz = JSCompiler_stubMethod(0);", // Module 2 "Foo.prototype.baz = " + "JSCompiler_unstubMethod(1, function() { return 1; });" + "Foo.prototype.baz = " + "JSCompiler_unstubMethod(0, function() { return 2; });" + "(new Foo).baz()" }); } public void testMoveMethodsInRightOrder2() { JSModule[] m = createModules( "function Foo() {}" + "Foo.prototype.baz = function() { return 1; };" + "function Goo() {}" + "Goo.prototype.baz = function() { return 2; };", // Module 2, depends on 1 "", // Module 3, depends on 2 "(new Foo).baz()", // Module 4, depends on 3 "", // Module 5, depends on 3 "(new Goo).baz()"); m[1].addDependency(m[0]); m[2].addDependency(m[1]); m[3].addDependency(m[2]); m[4].addDependency(m[2]); test(m, new String[] { STUB_DECLARATIONS + "function Foo() {}" + "Foo.prototype.baz = JSCompiler_stubMethod(1);" + "function Goo() {}" + "Goo.prototype.baz = JSCompiler_stubMethod(0);", // Module 2 "", // Module 3 "Foo.prototype.baz = " + "JSCompiler_unstubMethod(1, function() { return 1; });" + "Goo.prototype.baz = " + "JSCompiler_unstubMethod(0, function() { return 2; });" + "(new Foo).baz()", // Module 4 "", // Module 5 "(new Goo).baz()" }); } public void testMoveMethodsUsedInTwoModules() { testSame(createModuleStar( "function Foo() {}" + "Foo.prototype.baz = function() {};", // Module 2 "(new Foo).baz()", // Module 3 "(new Foo).baz()")); } public void testMoveMethodsUsedInTwoModules2() { JSModule[] modules = createModules( "function Foo() {}" + "Foo.prototype.baz = function() {};", // Module 2 "", // a blank module in the middle // Module 3 "(new Foo).baz() + 1", // Module 4 "(new Foo).baz() + 2"); modules[1].addDependency(modules[0]); modules[2].addDependency(modules[1]); modules[3].addDependency(modules[1]); test(modules, new String[] { STUB_DECLARATIONS + "function Foo() {}" + "Foo.prototype.baz = JSCompiler_stubMethod(0);", // Module 2 "Foo.prototype.baz = JSCompiler_unstubMethod(0, function() {});", // Module 3 "(new Foo).baz() + 1", // Module 4 "(new Foo).baz() + 2" }); } public void testTwoMethods() { test(createModuleChain( "function Foo() {}" + "Foo.prototype.baz = function() {};", // Module 2 "Foo.prototype.callBaz = function() { this.baz(); }", // Module 3 "(new Foo).callBaz()"), new String[] { STUB_DECLARATIONS + "function Foo() {}" + "Foo.prototype.baz = JSCompiler_stubMethod(1);", // Module 2 "Foo.prototype.callBaz = JSCompiler_stubMethod(0);", // Module 3 "Foo.prototype.baz = JSCompiler_unstubMethod(1, function() {});" + "Foo.prototype.callBaz = " + " JSCompiler_unstubMethod(0, function() { this.baz(); });" + "(new Foo).callBaz()" }); } public void testTwoMethods2() { // if the programmer screws up the module order, we don't try to correct // the mistake. test(createModuleChain( "function Foo() {}" + "Foo.prototype.baz = function() {};", // Module 2 "(new Foo).callBaz()", // Module 3 "Foo.prototype.callBaz = function() { this.baz(); }"), new String[] { STUB_DECLARATIONS + "function Foo() {}" + "Foo.prototype.baz = JSCompiler_stubMethod(0);", // Module 2 "(new Foo).callBaz()", // Module 3 "Foo.prototype.baz = JSCompiler_unstubMethod(0, function() {});" + "Foo.prototype.callBaz = function() { this.baz(); };" }); } public void testGlobalFunctionsInGraph() { test(createModuleChain( "function Foo() {}" + "Foo.prototype.baz = function() {};" + "function x() { return (new Foo).baz(); }", // Module 2 "x();"), new String[] { STUB_DECLARATIONS + "function Foo() {}" + "Foo.prototype.baz = JSCompiler_stubMethod(0);" + "function x() { return (new Foo).baz(); }", // Module 2 "Foo.prototype.baz = JSCompiler_unstubMethod(0, function() {});" + "x();" }); } // Read of closure variable disables method motions. public void testClosureVariableReads1() { testSame(createModuleChain( "function Foo() {}" + "(function() {" + "var x = 'x';" + "Foo.prototype.baz = function() {x};" + "})();", // Module 2 "var y = new Foo(); y.baz();")); } // Read of global variable is fine. public void testClosureVariableReads2() { test(createModuleChain( "function Foo() {}" + "Foo.prototype.b1 = function() {" + " var x = 1;" + " Foo.prototype.b2 = function() {" + " Foo.prototype.b3 = function() {" + " x;" + " }" + " }" + "};", // Module 2 "var y = new Foo(); y.b1();", // Module 3 "y = new Foo(); z.b2();", // Module 4 "y = new Foo(); z.b3();" ), new String[] { STUB_DECLARATIONS + "function Foo() {}" + "Foo.prototype.b1 = JSCompiler_stubMethod(0);", // Module 2 "Foo.prototype.b1 = JSCompiler_unstubMethod(0, function() {" + " var x = 1;" + " Foo.prototype.b2 = function() {" + " Foo.prototype.b3 = function() {" + " x;" + " }" + " }" + "});" + "var y = new Foo(); y.b1();", // Module 3 "y = new Foo(); z.b2();", // Module 4 "y = new Foo(); z.b3();" }); } public void testClosureVariableReads3() { test(createModuleChain( "function Foo() {}" + "Foo.prototype.b1 = function() {" + " Foo.prototype.b2 = function() {" + " var x = 1;" + " Foo.prototype.b3 = function() {" + " x;" + " }" + " }" + "};", // Module 2 "var y = new Foo(); y.b1();", // Module 3 "y = new Foo(); z.b2();", // Module 4 "y = new Foo(); z.b3();" ), new String[] { STUB_DECLARATIONS + "function Foo() {}" + "Foo.prototype.b1 = JSCompiler_stubMethod(0);", // Module 2 "Foo.prototype.b1 = JSCompiler_unstubMethod(0, function() {" + " Foo.prototype.b2 = JSCompiler_stubMethod(1);" + "});" + "var y = new Foo(); y.b1();", // Module 3 "Foo.prototype.b2 = JSCompiler_unstubMethod(1, function() {" + " var x = 1;" + " Foo.prototype.b3 = function() {" + " x;" + " }" + "});" + "y = new Foo(); z.b2();", // Module 4 "y = new Foo(); z.b3();" }); } // Read of global variable is fine. public void testNoClosureVariableReads1() { test(createModuleChain( "function Foo() {}" + "var x = 'x';" + "Foo.prototype.baz = function(){x};", // Module 2 "var y = new Foo(); y.baz();"), new String[] { STUB_DECLARATIONS + "function Foo() {}" + "var x = 'x';" + "Foo.prototype.baz = JSCompiler_stubMethod(0);", // Module 2 "Foo.prototype.baz = JSCompiler_unstubMethod(0, function(){x});" + "var y = new Foo(); y.baz();" }); } // Read of a local is fine. public void testNoClosureVariableReads2() { test(createModuleChain( "function Foo() {}" + "Foo.prototype.baz = function(){var x = 1;x};", // Module 2 "var y = new Foo(); y.baz();"), new String[] { STUB_DECLARATIONS + "function Foo() {}" + "Foo.prototype.baz = JSCompiler_stubMethod(0);", // Module 2 "Foo.prototype.baz = JSCompiler_unstubMethod(" + " 0, function(){var x = 1; x});" + "var y = new Foo(); y.baz();" }); } // An anonymous inner function reading a closure variable is fine. public void testInnerFunctionClosureVariableReads() { test(createModuleChain( "function Foo() {}" + "Foo.prototype.baz = function(){var x = 1;" + " return function(){x}};", // Module 2 "var y = new Foo(); y.baz();"), new String[] { STUB_DECLARATIONS + "function Foo() {}" + "Foo.prototype.baz = JSCompiler_stubMethod(0);", // Module 2 "Foo.prototype.baz = JSCompiler_unstubMethod(" + " 0, function(){var x = 1; return function(){x}});" + "var y = new Foo(); y.baz();" }); } public void testIssue600() { testSame( createModuleChain( "var jQuery1 = (function() {\n" + " var jQuery2 = function() {};\n" + " var theLoneliestNumber = 1;\n" + " jQuery2.prototype = {\n" + " size: function() {\n" + " return theLoneliestNumber;\n" + " }\n" + " };\n" + " return jQuery2;\n" + "})();\n", "(function() {" + " var div = jQuery1('div');" + " div.size();" + "})();")); } public void testIssue600b() { testSame( createModuleChain( "var jQuery1 = (function() {\n" + " var jQuery2 = function() {};\n" + " jQuery2.prototype = {\n" + " size: function() {\n" + " return 1;\n" + " }\n" + " };\n" + " return jQuery2;\n" + "})();\n", "(function() {" + " var div = jQuery1('div');" + " div.size();" + "})();")); } public void testIssue600c() { test( createModuleChain( "var jQuery2 = function() {};\n" + "jQuery2.prototype = {\n" + " size: function() {\n" + " return 1;\n" + " }\n" + "};\n", "(function() {" + " var div = jQuery2('div');" + " div.size();" + "})();"), new String[] { STUB_DECLARATIONS + "var jQuery2 = function() {};\n" + "jQuery2.prototype = {\n" + " size: JSCompiler_stubMethod(0)\n" + "};\n", "jQuery2.prototype.size=" + " JSCompiler_unstubMethod(0,function(){return 1});" + "(function() {" + " var div = jQuery2('div');" + " div.size();" + "})();" }); } public void testIssue600d() { test( createModuleChain( "var jQuery2 = function() {};\n" + "(function() {" + " jQuery2.prototype = {\n" + " size: function() {\n" + " return 1;\n" + " }\n" + " };\n" + "})();", "(function() {" + " var div = jQuery2('div');" + " div.size();" + "})();"), new String[] { STUB_DECLARATIONS + "var jQuery2 = function() {};\n" + "(function() {" + " jQuery2.prototype = {\n" + " size: JSCompiler_stubMethod(0)\n" + " };\n" + "})();", "jQuery2.prototype.size=" + " JSCompiler_unstubMethod(0,function(){return 1});" + "(function() {" + " var div = jQuery2('div');" + " div.size();" + "})();" }); } public void testIssue600e() { testSame( createModuleChain( "var jQuery2 = function() {};\n" + "(function() {" + " var theLoneliestNumber = 1;\n" + " jQuery2.prototype = {\n" + " size: function() {\n" + " return theLoneliestNumber;\n" + " }\n" + " };\n" + "})();", "(function() {" + " var div = jQuery2('div');" + " div.size();" + "})();")); } public void testPrototypeOfThisAssign() { testSame( createModuleChain( "/** @constructor */" + "function F() {}" + "this.prototype.foo = function() {};", "(new F()).foo();")); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.ControlFlowGraph.Branch; import com.google.javascript.jscomp.DataFlowAnalysis.BranchedFlowState; import com.google.javascript.jscomp.DataFlowAnalysis.BranchedForwardDataFlowAnalysis; import com.google.javascript.jscomp.DataFlowAnalysis.FlowState; import com.google.javascript.jscomp.DataFlowAnalysis.MaxIterationsExceededException; import com.google.javascript.jscomp.JoinOp.BinaryJoinOp; import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge; import com.google.javascript.jscomp.graph.GraphNode; import com.google.javascript.jscomp.graph.LatticeElement; import junit.framework.TestCase; import java.util.Comparator; import java.util.List; import java.util.Map; /** * A test suite with a very small programming language that has two types of * instructions: {@link BranchInstruction} and {@link ArithmeticInstruction}. * Test cases must construct a small program with these instructions and * manually put each instruction in a {@code ControlFlowGraph}. * */ public class DataFlowAnalysisTest extends TestCase { /** * Operations supported by ArithmeticInstruction. */ enum Operation { ADD("+"), SUB("-"), DIV("/"), MUL("*"); private final String stringRep; private Operation(String stringRep) { this.stringRep = stringRep; } @Override public String toString() { return stringRep; } } /** * A simple value. */ abstract static class Value { boolean isNumber() { return this instanceof Number; } boolean isVariable() { return this instanceof Variable; } } /** * A variable. */ static class Variable extends Value { private String name; /** * Constructor. * * @param n Name of the variable. */ Variable(String n) { name = n; } String getName() { return name; } @Override public boolean equals(Object other) { // Use the String's .equals() if (!(other instanceof Variable)) { return false; } return ((Variable) other).name.equals(name); } @Override public int hashCode() { return name.hashCode(); } @Override public String toString() { return this.name; } } /** * A number constant. */ static class Number extends Value { private int value; /** * Constructor * * @param v Value */ Number(int v) { value = v; } int getValue() { return value; } @Override public String toString() { return "" + value; } @Override public int hashCode() { return value; } } /** * An instruction of the dummy program. */ abstract static class Instruction { int order = 0; /** * Check whether this is an arithmetic instruction. * * @return {@code true} if it is an arithmetic instruction. */ boolean isArithmetic() { return this instanceof ArithmeticInstruction; } /** * Check whether this is a branch instruction. * * @return {@code true} if it is a branch instruction. */ boolean isBranch() { return this instanceof BranchInstruction; } } /** * Basic arithmetic instruction that only takes the form of: * * <pre> * Result = Operand1 operator Operand2 * </pre> */ static class ArithmeticInstruction extends Instruction { private Operation operation; private Value operand1; private Value operand2; private Variable result; /** * Constructor * * @param res Result. * @param op1 First Operand. * @param o Operator. * @param op2 Second Operand. */ ArithmeticInstruction(Variable res, int op1, Operation o, int op2) { this(res, new Number(op1), o, new Number(op2)); } /** * Constructor * * @param res Result. * @param op1 First Operand. * @param o Operator. * @param op2 Second Operand. */ ArithmeticInstruction(Variable res, Value op1, Operation o, int op2) { this(res, op1, o, new Number(op2)); } /** * Constructor * * @param res Result. * @param op1 First Operand. * @param o Operator. * @param op2 Second Operand. */ ArithmeticInstruction(Variable res, int op1, Operation o, Value op2) { this(res, new Number(op1), o, op2); } /** * Constructor * * @param res Result. * @param op1 First Operand. * @param o Operator. * @param op2 Second Operand. */ ArithmeticInstruction(Variable res, Value op1, Operation o, Value op2) { result = res; operand1 = op1; operand2 = op2; operation = o; } Operation getOperator() { return operation; } void setOperator(Operation op) { this.operation = op; } Value getOperand1() { return operand1; } void setOperand1(Value operand1) { this.operand1 = operand1; } Value getOperand2() { return operand2; } void setOperand2(Value operand2) { this.operand2 = operand2; } Variable getResult() { return result; } void setResult(Variable result) { this.result = result; } @Override public String toString() { StringBuilder out = new StringBuilder(); out.append(result); out.append(" = "); out.append(operand1); out.append(operation); out.append(operand2); return out.toString(); } @Override public int hashCode() { return toString().hashCode(); } } public static ArithmeticInstruction newAssignNumberToVariableInstruction(Variable res, int num) { return new ArithmeticInstruction(res, num, Operation.ADD, 0); } public static ArithmeticInstruction newAssignVariableToVariableInstruction(Variable lhs, Variable rhs) { return new ArithmeticInstruction(lhs, rhs, Operation.ADD, 0); } /** * Branch instruction based on a {@link Value} as a condition. */ static class BranchInstruction extends Instruction { private Value condition; BranchInstruction(Value cond) { condition = cond; } Value getCondition() { return condition; } void setCondition(Value condition) { this.condition = condition; } } /** * A lattice to represent constant states. Each variable of the program will * have a lattice defined as: * * <pre> * TOP * / / | \ * 0 1 2 3 ..... MAX_VALUE * \ \ | / * BOTTOM * </pre> * * Where BOTTOM represents the variable is not a constant. * <p> * This class will represent a product lattice of each variable's lattice. The * whole lattice is store in a {@code HashMap}. If variable {@code x} is * defined to be constant 10. The map will contain the value 10 with the * variable {@code x} as key. Otherwise, {@code x} is not a constant. */ private static class ConstPropLatticeElement implements LatticeElement { private final Map<Variable, Integer> constMap; private final boolean isTop; /** * Constructor. * * @param isTop To define if the lattice is top. */ ConstPropLatticeElement(boolean isTop) { this.isTop = isTop; this.constMap = Maps.newHashMap(); } /** * Create a lattice where every variable is defined to be not constant. */ ConstPropLatticeElement() { this(false); } ConstPropLatticeElement(ConstPropLatticeElement other) { this.isTop = other.isTop; this.constMap = Maps.newHashMap(other.constMap); } @Override public String toString() { if (isTop) { return "TOP"; } StringBuilder out = new StringBuilder(); out.append("{"); for (Variable var : constMap.keySet()) { out.append(var); out.append("="); out.append(constMap.get(var)); out.append(" "); } out.append("}"); return out.toString(); } @Override public boolean equals(Object other) { if (other instanceof ConstPropLatticeElement) { ConstPropLatticeElement otherLattice = (ConstPropLatticeElement) other; return (this.isTop == otherLattice.isTop) && this.constMap.equals(otherLattice.constMap); } return false; } } private static class ConstPropJoinOp extends BinaryJoinOp<ConstPropLatticeElement> { @Override public ConstPropLatticeElement apply(ConstPropLatticeElement a, ConstPropLatticeElement b) { ConstPropLatticeElement result = new ConstPropLatticeElement(); // By the definition of TOP of the lattice. if (a.isTop) { return new ConstPropLatticeElement(a); } if (b.isTop) { return new ConstPropLatticeElement(b); } // Do the join for each variable's lattice. for (Variable var : a.constMap.keySet()) { if (b.constMap.containsKey(var)) { Integer number = b.constMap.get(var); // The result will contain that variable as a known constant // if both lattice has that variable the same constant. if (a.constMap.get(var).equals(number)) { result.constMap.put(var, number); } } } return result; } } /** * A simple forward constant propagation. */ static class DummyConstPropagation extends DataFlowAnalysis<Instruction, ConstPropLatticeElement> { /** * Constructor. * * @param targetCfg Control Flow Graph. */ DummyConstPropagation(ControlFlowGraph<Instruction> targetCfg) { super(targetCfg, new ConstPropJoinOp()); } @Override boolean isForward() { return true; } @Override ConstPropLatticeElement flowThrough(Instruction node, ConstPropLatticeElement input) { if (node.isBranch()) { return new ConstPropLatticeElement(input); } else { return flowThroughArithmeticInstruction((ArithmeticInstruction) node, input); } } @Override ConstPropLatticeElement createEntryLattice() { return new ConstPropLatticeElement(); } @Override ConstPropLatticeElement createInitialEstimateLattice() { return new ConstPropLatticeElement(true); } } static ConstPropLatticeElement flowThroughArithmeticInstruction( ArithmeticInstruction aInst, ConstPropLatticeElement input) { ConstPropLatticeElement out = new ConstPropLatticeElement(input); // Try to see if left is a number. If it is a variable, it might already // be a constant coming in. Integer leftConst = null; if (aInst.operand1.isNumber()) { leftConst = ((Number) aInst.operand1).value; } else { if (input.constMap.containsKey(aInst.operand1)) { leftConst = input.constMap.get(aInst.operand1); } } // Do the same thing to the right. Integer rightConst = null; if (aInst.operand2.isNumber()) { rightConst = ((Number) aInst.operand2).value; } else { if (input.constMap.containsKey(aInst.operand2)) { rightConst = input.constMap.get(aInst.operand2); } } // If both are known constant we can perform the operation. if (leftConst != null && rightConst != null) { Integer constResult = null; if (aInst.operation == Operation.ADD) { constResult = leftConst.intValue() + rightConst.intValue(); } else if (aInst.operation == Operation.SUB) { constResult = leftConst.intValue() - rightConst.intValue(); } else if (aInst.operation == Operation.MUL) { constResult = leftConst.intValue() * rightConst.intValue(); } else if (aInst.operation == Operation.DIV) { constResult = leftConst.intValue() / rightConst.intValue(); } // Put it in the map. (Possibly replacing the existing constant value) out.constMap.put(aInst.result, constResult); } else { // If we cannot find a constant for it out.constMap.remove(aInst.result); } return out; } public void testSimpleIf() { // if (a) { b = 1; } else { b = 1; } c = b; Variable a = new Variable("a"); Variable b = new Variable("b"); Variable c = new Variable("c"); Instruction inst1 = new BranchInstruction(a); Instruction inst2 = newAssignNumberToVariableInstruction(b, 1); Instruction inst3 = newAssignNumberToVariableInstruction(b, 1); Instruction inst4 = newAssignVariableToVariableInstruction(c, b); ControlFlowGraph<Instruction> cfg = new ControlFlowGraph<Instruction>(inst1, true, true); GraphNode<Instruction, Branch> n1 = cfg.createNode(inst1); GraphNode<Instruction, Branch> n2 = cfg.createNode(inst2); GraphNode<Instruction, Branch> n3 = cfg.createNode(inst3); GraphNode<Instruction, Branch> n4 = cfg.createNode(inst4); cfg.connect(inst1, ControlFlowGraph.Branch.ON_FALSE, inst2); cfg.connect(inst1, ControlFlowGraph.Branch.ON_TRUE, inst3); cfg.connect(inst2, ControlFlowGraph.Branch.UNCOND, inst4); cfg.connect(inst3, ControlFlowGraph.Branch.UNCOND, inst4); DummyConstPropagation constProp = new DummyConstPropagation(cfg); constProp.analyze(); // We cannot conclude anything from if (a). verifyInHas(n1, a, null); verifyInHas(n1, b, null); verifyInHas(n1, c, null); verifyOutHas(n1, a, null); verifyOutHas(n1, b, null); verifyOutHas(n1, c, null); // We can conclude b = 1 after the instruction. verifyInHas(n2, a, null); verifyInHas(n2, b, null); verifyInHas(n2, c, null); verifyOutHas(n2, a, null); verifyOutHas(n2, b, 1); verifyOutHas(n2, c, null); // Same as above. verifyInHas(n3, a, null); verifyInHas(n3, b, null); verifyInHas(n3, c, null); verifyOutHas(n3, a, null); verifyOutHas(n3, b, 1); verifyOutHas(n3, c, null); // After the merge we should still have b = 1. verifyInHas(n4, a, null); verifyInHas(n4, b, 1); verifyInHas(n4, c, null); verifyOutHas(n4, a, null); // After the instruction both b and c are 1. verifyOutHas(n4, b, 1); verifyOutHas(n4, c, 1); } public void testSimpleLoop() { // a = 0; do { a = a + 1 } while (b); c = a; Variable a = new Variable("a"); Variable b = new Variable("b"); Variable c = new Variable("c"); Instruction inst1 = newAssignNumberToVariableInstruction(a, 0); Instruction inst2 = new ArithmeticInstruction(a, a, Operation.ADD, 1); Instruction inst3 = new BranchInstruction(b); Instruction inst4 = newAssignVariableToVariableInstruction(c, a); ControlFlowGraph<Instruction> cfg = new ControlFlowGraph<Instruction>(inst1, true, true); GraphNode<Instruction, Branch> n1 = cfg.createNode(inst1); GraphNode<Instruction, Branch> n2 = cfg.createNode(inst2); GraphNode<Instruction, Branch> n3 = cfg.createNode(inst3); GraphNode<Instruction, Branch> n4 = cfg.createNode(inst4); cfg.connect(inst1, ControlFlowGraph.Branch.UNCOND, inst2); cfg.connect(inst2, ControlFlowGraph.Branch.UNCOND, inst3); cfg.connect(inst3, ControlFlowGraph.Branch.ON_TRUE, inst2); cfg.connect(inst3, ControlFlowGraph.Branch.ON_FALSE, inst4); DummyConstPropagation constProp = new DummyConstPropagation(cfg); // This will also show that the framework terminates properly. constProp.analyze(); // a = 0 is the only thing we know. verifyInHas(n1, a, null); verifyInHas(n1, b, null); verifyInHas(n1, c, null); verifyOutHas(n1, a, 0); verifyOutHas(n1, b, null); verifyOutHas(n1, c, null); // Nothing is provable in this program, so confirm that we haven't // erroneously "proven" something. verifyInHas(n2, a, null); verifyInHas(n2, b, null); verifyInHas(n2, c, null); verifyOutHas(n2, a, null); verifyOutHas(n2, b, null); verifyOutHas(n2, c, null); verifyInHas(n3, a, null); verifyInHas(n3, b, null); verifyInHas(n3, c, null); verifyOutHas(n3, a, null); verifyOutHas(n3, b, null); verifyOutHas(n3, c, null); verifyInHas(n4, a, null); verifyInHas(n4, b, null); verifyInHas(n4, c, null); verifyOutHas(n4, a, null); verifyOutHas(n4, b, null); verifyOutHas(n4, c, null); } public void testLatticeArrayMinimizationWhenMidpointIsEven() { assertEquals(6, JoinOp.BinaryJoinOp.computeMidPoint(12)); } public void testLatticeArrayMinimizationWhenMidpointRoundsDown() { assertEquals(8, JoinOp.BinaryJoinOp.computeMidPoint(18)); } public void testLatticeArrayMinimizationWithTwoElements() { assertEquals(1, JoinOp.BinaryJoinOp.computeMidPoint(2)); } /** * A simple forward constant propagation. */ static class BranchedDummyConstPropagation extends BranchedForwardDataFlowAnalysis<Instruction, ConstPropLatticeElement> { BranchedDummyConstPropagation(ControlFlowGraph<Instruction> targetCfg) { super(targetCfg, new ConstPropJoinOp()); } @Override ConstPropLatticeElement flowThrough(Instruction node, ConstPropLatticeElement input) { if (node.isArithmetic()) { return flowThroughArithmeticInstruction( (ArithmeticInstruction) node, input); } else { return new ConstPropLatticeElement(input); } } @Override List<ConstPropLatticeElement> branchedFlowThrough(Instruction node, ConstPropLatticeElement input) { List<ConstPropLatticeElement> result = Lists.newArrayList(); List<DiGraphEdge<Instruction, Branch>> outEdges = getCfg().getOutEdges(node); if (node.isArithmetic()) { assertTrue(outEdges.size() < 2); ConstPropLatticeElement aResult = flowThroughArithmeticInstruction( (ArithmeticInstruction) node, input); for (DiGraphEdge<Instruction, Branch> _ : outEdges) { result.add(aResult); } } else { BranchInstruction branchInst = (BranchInstruction) node; for (DiGraphEdge<Instruction, Branch> branch : outEdges) { ConstPropLatticeElement edgeResult = new ConstPropLatticeElement(input); if (branch.getValue() == Branch.ON_FALSE && branchInst.getCondition().isVariable()) { edgeResult.constMap.put((Variable) branchInst.getCondition(), 0); } result.add(edgeResult); } } return result; } @Override ConstPropLatticeElement createEntryLattice() { return new ConstPropLatticeElement(); } @Override ConstPropLatticeElement createInitialEstimateLattice() { return new ConstPropLatticeElement(true); } } public void testBranchedSimpleIf() { // if (a) { a = 0; } else { b = 0; } c = b; Variable a = new Variable("a"); Variable b = new Variable("b"); Variable c = new Variable("c"); Instruction inst1 = new BranchInstruction(a); Instruction inst2 = newAssignNumberToVariableInstruction(a, 0); Instruction inst3 = newAssignNumberToVariableInstruction(b, 0); Instruction inst4 = newAssignVariableToVariableInstruction(c, b); ControlFlowGraph<Instruction> cfg = new ControlFlowGraph<Instruction>(inst1, true, true); GraphNode<Instruction, Branch> n1 = cfg.createNode(inst1); GraphNode<Instruction, Branch> n2 = cfg.createNode(inst2); GraphNode<Instruction, Branch> n3 = cfg.createNode(inst3); GraphNode<Instruction, Branch> n4 = cfg.createNode(inst4); cfg.connect(inst1, ControlFlowGraph.Branch.ON_TRUE, inst2); cfg.connect(inst1, ControlFlowGraph.Branch.ON_FALSE, inst3); cfg.connect(inst2, ControlFlowGraph.Branch.UNCOND, inst4); cfg.connect(inst3, ControlFlowGraph.Branch.UNCOND, inst4); BranchedDummyConstPropagation constProp = new BranchedDummyConstPropagation(cfg); constProp.analyze(); // We cannot conclude anything from if (a). verifyBranchedInHas(n1, a, null); verifyBranchedInHas(n1, b, null); verifyBranchedInHas(n1, c, null); // Nothing is known on the true branch. verifyBranchedInHas(n2, a, null); verifyBranchedInHas(n2, b, null); verifyBranchedInHas(n2, c, null); // Verify that we have a = 0 on the false branch. verifyBranchedInHas(n3, a, 0); verifyBranchedInHas(n3, b, null); verifyBranchedInHas(n3, c, null); // After the merge we should still have a = 0. verifyBranchedInHas(n4, a, 0); } public void testMaxIterationsExceededException() { final int MAX_STEP = 10; Variable a = new Variable("a"); Instruction inst1 = new ArithmeticInstruction(a, a, Operation.ADD, a); ControlFlowGraph<Instruction> cfg = new ControlFlowGraph<Instruction>(inst1, true, true) { @Override public Comparator<DiGraphNode<Instruction, Branch>> getOptionalNodeComparator(boolean isForward) { return new Comparator<DiGraphNode<Instruction, Branch>>() { @Override public int compare(DiGraphNode<Instruction, Branch> o1, DiGraphNode<Instruction, Branch> o2) { return o1.getValue().order - o2.getValue().order; } }; } }; cfg.createNode(inst1); // We have MAX_STEP + 1 nodes, it is impossible to finish the analysis with // MAX_STEP number of steps. for (int i = 0; i < MAX_STEP + 1; i++) { Instruction inst2 = new ArithmeticInstruction(a, a, Operation.ADD, a); cfg.createNode(inst2); inst2.order = i + 1; cfg.connect(inst1, ControlFlowGraph.Branch.UNCOND, inst2); inst1 = inst2; } DummyConstPropagation constProp = new DummyConstPropagation(cfg); try { constProp.analyze(MAX_STEP); fail("Expected MaxIterationsExceededException to be thrown."); } catch (MaxIterationsExceededException e) { assertEquals(e.getMessage(), "Analysis did not terminate after " + MAX_STEP + " iterations"); } } static void verifyInHas(GraphNode<Instruction, Branch> node, Variable var, Integer constant) { FlowState<ConstPropLatticeElement> fState = node.getAnnotation(); assertEquals(constant, fState.getIn().constMap.get(var)); } static void verifyOutHas(GraphNode<Instruction, Branch> node, Variable var, Integer constant) { FlowState<ConstPropLatticeElement> fState = node.getAnnotation(); assertEquals(constant, fState.getOut().constMap.get(var)); } static void verifyBranchedInHas(GraphNode<Instruction, Branch> node, Variable var, Integer constant) { BranchedFlowState<ConstPropLatticeElement> fState = node.getAnnotation(); assertEquals(constant, fState.getIn().constMap.get(var)); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.rhino.Node; /** * Tests for {@link DeadAssignmentsElimination}. * */ public class DeadAssignmentsEliminationTest extends CompilerTestCase { public DeadAssignmentsEliminationTest() { super("var extern;"); } @Override public void setUp() { super.enableLineNumberCheck(true); } @Override public CompilerPass getProcessor(final Compiler compiler) { return new CompilerPass() { @Override public void process(Node externs, Node js) { NodeTraversal.traverse( compiler, js, new DeadAssignmentsElimination(compiler)); } }; } @Override protected int getNumRepetitions() { return 1; } public void testSimple() { inFunction("var a; a=1", "var a; 1"); inFunction("var a; a=1+1", "var a; 1+1"); inFunction("var a; a=foo();", "var a; foo()"); inFunction("a=1; var a; a=foo();", "1; var a; foo();"); // This should be: "var a; (function f(){})", but we don't mess with // functions with inner functions. inFunction("var a; a=function f(){}"); } public void testLoops() { inFunction("for(var a=0; a<10; a++) {}"); inFunction("var x; for(var a=0; a<10; a++) {x=a}; a(x)"); inFunction("var x; for(var a=0; x=a<10; a++) {}", "var x; for(var a=0; a<10; a++) {}"); inFunction("var x; for(var a=0; a<10; x=a) {}", "var x; for(var a=0; a<10; a) {}"); inFunction("var x; for(var a=0; a<10; x=a,a++) {}", "var x; for(var a=0; a<10; a,a++) {}"); inFunction("var x; for(var a=0; a<10; a++,x=a) {}", "var x; for(var a=0; a<10; a++,a) {}"); inFunction("var x;for(var a=0; a<10; a++) {x=1}", "var x;for(var a=0; a<10; a++) {1}"); inFunction("var x; x=1; do{x=2}while(0); x", "var x; 1; do{x=2}while(0); x"); inFunction("var x; x=1; while(1){x=2}; x"); } public void testMultiPaths() { inFunction("var x,y; if(x)y=1;", "var x,y; if(x)1;"); inFunction("var x,y; if(x)y=1; y=2; x(y)", "var x,y; if(x)1; y=2; x(y)"); inFunction("var x; switch(x) { case(1): x=1; break; } x"); inFunction("var x; switch(x) { case(1): x=1; break; }", "var x; switch(x) { case(1): 1; break; }"); } public void testUsedAsConditions() { inFunction("var x; while(x=1){}", "var x; while(1){}"); inFunction("var x; if(x=1){}", "var x; if(1){}"); inFunction("var x; do{}while(x=1)", "var x; do{}while(1)"); inFunction("var x; if(x=1==4&&1){}", "var x; if(1==4&&1) {}"); inFunction("var x; if(0&&(x=1)){}", "var x; if(0&&1){}"); inFunction("var x; if((x=2)&&(x=1)){}", "var x; if(2&&1){}"); inFunction("var x; x=2; if(0&&(x=1)){}; x"); inFunction("var x,y; if( (x=1)+(y=2) > 3){}", "var x,y; if( 1+2 > 3){}"); } public void testUsedAsConditionsInSwitchStatements() { inFunction("var x; switch(x=1){}","var x; switch(1){}"); inFunction("var x; switch(x){case(x=1):break;}", "var x; switch(x){case(1):break;}"); inFunction("var x,y; switch(y) { case (x += 1): break; case (x): break;}"); inFunction("var x,y; switch(y) { case (x = 1): break; case (2): break;}", "var x,y; switch(y) { case (1): break; case (2): break;}"); inFunction("var x,y; switch(y) { case (x+=1): break; case (x=2): break;}", "var x,y; switch(y) { case (x+1): break; case (2): break;}"); } public void testAssignmentInReturn() { inFunction("var x; return x = 1;", "var x; return 1"); inFunction("var x; return"); } public void testAssignmentSamples() { // We want this to be "var x" in these cases. inFunction("var x = 2;"); inFunction("var x = 2; x++;", "var x=2; void 0"); inFunction("var x; x=x++;", "var x;x++"); inFunction("var x; x+=1;", "var x;x+1"); } public void testAssignmentInArgs() { inFunction("var x; foo(x = 1);", "var x; foo(1);"); inFunction("var x; return foo(x = 1);", "var x; return foo(1);"); } /** * BUG #1358904 */ public void testAssignAndReadInCondition() { inFunction("var a, b; if ((a = 1) && (b = a)) {b}"); inFunction("var a, b; if ((b = a) && (a = 1)) {b}", "var a, b; if ((b = a) && (1)) {b}"); } public void testParameters() { inFunction("param1=1; param1=2; param2(param1)", "1; param1=2; param2(param1)"); inFunction("param1=param2()", "param2()"); } public void testErrorHandling() { inFunction("var x; try{ x=1 } catch(e){ x=2 }; x"); inFunction("var x; try{ x=1 } catch(e){ x=2 }", "var x;try{ 1 } catch(e) { 2 }"); inFunction("var x; try{ x=1 } finally { x=2 }; x", "var x;try{ 1 } finally{ x=2 }; x"); inFunction("var x; while(1) { try{x=1;break}finally{x} }"); inFunction("var x; try{throw 1} catch(e){x=2} finally{x}"); inFunction("var x; try{x=1;throw 1;x} finally{x=2}; x", "var x; try{1;throw 1;x} finally{x=2}; x"); } public void testDeadVarDeclarations() { // Dead assignments in VAR is _NOT_ supported yet. inFunction("var x=1;"); inFunction("var x=1; x=2; x"); } public void testGlobal() { // Doesn't do any work on global scope yet. test("var x; x=1; x=2; x=3;", "var x; x=1; x=2; x=3;"); } public void testInnerFunctions() { inFunction("var x = function() { var x; x=1; }", "var x = function() { var x; 1; }"); } public void testInnerFunctions2() { // Give up DCE if there is a inner function. inFunction("var x = 0; print(x); x = 1; var y = function(){}; y()"); } public void testSelfReAssignment() { inFunction("var x; x = x;", "var x; x"); } public void testSelfIncrement() { inFunction("var x; x = x + 1;", "var x; x + 1"); } public void testAssignmentOp() { // We have remove constant expressions that cleans this one up. inFunction("var x; x += foo()", "var x; x + foo()"); } public void testAssignmentOpUsedAsLhs() { inFunction("var x,y; y = x += foo(); print(y)", "var x,y; y = x + foo(); print(y)"); } public void testAssignmentOpUsedAsCondition() { inFunction("var x; if(x += foo()) {}", "var x; if(x + foo()) {}"); inFunction("var x; if((x += foo()) > 1) {}", "var x; if((x + foo()) > 1) {}"); // Not in a while because this happens every loop. inFunction("var x; while((x += foo()) > 1) {}"); inFunction("var x; for(;--x;){}"); inFunction("var x; for(;x--;){}"); inFunction("var x; for(;x -= 1;){}"); inFunction("var x; for(;x = 0;){}", "var x; for(;0;){}"); inFunction("var x; for(;;--x){}"); inFunction("var x; for(;;x--){}"); inFunction("var x; for(;;x -= 1){}"); inFunction("var x; for(;;x = 0){}", "var x; for(;;0){}"); inFunction("var x; for(--x;;){}", "var x; for(;;){}"); inFunction("var x; for(x--;;){}", "var x; for(;;){}"); inFunction("var x; for(x -= 1;;){}", "var x; for(x - 1;;){}"); inFunction("var x; for(x = 0;;){}", "var x; for(0;;){}"); } public void testDeadIncrement() { // TODO(user): Optimize this. inFunction("var x; x ++", "var x; void 0"); inFunction("var x; x --", "var x; void 0"); } public void testDeadButAlivePartiallyWithinTheExpression() { inFunction("var x; x = 100, print(x), x = 101;", "var x; x = 100, print(x), 101;"); inFunction("var x; x = 100, print(x), print(x), x = 101;", "var x; x = 100, print(x), print(x), 101;"); inFunction("var x; x = 100, print(x), x = 0, print(x), x = 101;", "var x; x = 100, print(x), x = 0, print(x), 101;"); } public void testMutipleDeadAssignmentsButAlivePartiallyWithinTheExpression() { inFunction("var x; x = 1, x = 2, x = 3, x = 4, x = 5," + " print(x), x = 0, print(x), x = 101;", "var x; 1, 2, 3, 4, x = 5, print(x), x = 0, print(x), 101;"); } public void testDeadPartiallyWithinTheExpression() { // Sadly, this is not covered. We don't suspect this would happen too // often. inFunction("var x; x = 100, x = 101; print(x);"); } public void testAssignmentChain() { inFunction("var a,b,c,d,e; a = b = c = d = e = 1", "var a,b,c,d,e; 1"); inFunction("var a,b,c,d,e; a = b = c = d = e = 1; print(c)", "var a,b,c,d,e; c = 1 ; print(c)"); inFunction("var a,b,c,d,e; a = b = c = d = e = 1; print(a + e)", "var a,b,c,d,e; a = e = 1; print(a + e)"); inFunction("var a,b,c,d,e; a = b = c = d = e = 1; print(b + d)", "var a,b,c,d,e; b = d = 1; print(b + d)"); inFunction("var a,b,c,d,e; a = b = c = d = e = 1; print(a + b + d + e)", "var a,b,c,d,e; a = b = d = e = 1; print(a + b + d + e)"); inFunction("var a,b,c,d,e; a = b = c = d = e = 1; print(a+b+c+d+e)"); } public void testAssignmentOpChain() { inFunction("var a,b,c,d,e; a = b = c += d = e = 1", "var a,b,c,d,e; c + 1"); inFunction("var a,b,c,d,e; a = b = c += d = e = 1; print(e)", "var a,b,c,d,e; c + (e = 1); print(e)"); inFunction("var a,b,c,d,e; a = b = c += d = e = 1; print(d)", "var a,b,c,d,e; c + (d = 1) ; print(d)"); inFunction("var a,b,c,d,e; a = b = c += d = e = 1; print(a)", "var a,b,c,d,e; a = c + 1; print(a)"); } public void testIncDecInSubExpressions() { inFunction("var a; a = 1, a++; a"); inFunction("var a; a = 1, ++a; a"); inFunction("var a; a = 1, a--; a"); inFunction("var a; a = 1, --a; a"); inFunction("var a; a = 1, a++, print(a)"); inFunction("var a; a = 1, ++a, print(a)"); inFunction("var a; a = 1, a--, print(a)"); inFunction("var a; a = 1, --a, print(a)"); inFunction("var a; a = 1, print(a++)"); inFunction("var a; a = 1, print(++a)"); inFunction("var a; a = 1, print(a++)"); inFunction("var a; a = 1, print(++a)"); inFunction("var a; a = 1, print(a--)"); inFunction("var a; a = 1, print(--a)"); } public void testNestedReassignments() { inFunction("var a; a = (a = 1)", "var a; 1"); inFunction("var a; a = (a *= 2)", "var a; a*2"); // Note a = (a++) is not same as a++. Only if 'a' is dead. inFunction("var a; a = (a++)", "var a; a++"); // Preferred: "var a" inFunction("var a; a = (++a)", "var a; ++a"); // Preferred: "var a" inFunction("var a; a = (b = (a = 1))", "var a; b = 1"); inFunction("var a; a = (b = (a *= 2))", "var a; b = a * 2"); inFunction("var a; a = (b = (a++))", "var a; b=a++"); inFunction("var a; a = (b = (++a))", "var a; b=++a"); // Include b as local. inFunction("var a,b; a = (b = (a = 1))", "var a,b; 1"); inFunction("var a,b; a = (b = (a *= 2))", "var a,b; a * 2"); inFunction("var a,b; a = (b = (a++))", "var a,b; a++"); // Preferred: "var a,b" inFunction("var a,b; a = (b = (++a))", "var a,b; ++a"); // Preferred: "var a,b" inFunction("var a; a += (a++)", "var a; a + a++"); inFunction("var a; a += (++a)", "var a; a+ (++a)"); // Include b as local. inFunction("var a,b; a += (b = (a = 1))", "var a,b; a + 1"); inFunction("var a,b; a += (b = (a *= 2))", "var a,b; a + (a * 2)"); inFunction("var a,b; a += (b = (a++))", "var a,b; a + a++"); inFunction("var a,b; a += (b = (++a))", "var a,b; a+(++a)"); } public void testIncrementalReassignmentInForLoops() { inFunction("for(;x+=1;x+=1) {}"); inFunction("for(;x;x+=1){}"); inFunction("for(;x+=1;){foo(x)}"); inFunction("for(;1;x+=1){foo(x)}"); } public void testIdentityAssignments() { inFunction("var x; x=x", "var x; x"); } private void inFunction(String src) { inFunction(src, src); } private void inFunction(String src, String expected) { test("function FUNC(param1, param2){" + src + "}", "function FUNC(param1, param2){" + expected + "}"); } public void testBug8730257() { inFunction( " try {" + " var sortIndices = {};" + " sortIndices = bar();" + " for (var i = 0; i < 100; i++) {" + " var sortIndex = sortIndices[i];" + " bar(sortIndex);" + " }" + " } finally {" + " bar();" + " }" ); } public void testAssignToExtern() { inFunction("extern = true;"); } public void testIssue297a() { testSame("function f(p) {" + " var x;" + " return ((x=p.id) && (x=parseInt(x.substr(1))) && x>0);" + "}; f('');"); } public void testIssue297b() { test("function f() {" + " var x;" + " return (x='') && (x = x.substr(1));" + "};", "function f() {" + " var x;" + " return (x='') && (x.substr(1));" + "};"); } public void testIssue297c() { test("function f() {" + " var x;" + " return (x=1) && (x = f(x));" + "};", "function f() {" + " var x;" + " return (x=1) && f(x);" + "};"); } public void testIssue297d() { test("function f(a) {" + " return (a=1) && (a = f(a));" + "};", "function f(a) {" + " return (a=1) && (f(a));" + "};"); } public void testIssue297e() { test("function f(a) {" + " return (a=1) - (a = g(a));" + "};", "function f(a) {" + " return (a=1) - (g(a));" + "};"); } public void testIssue297f() { test("function f(a) {" + " h((a=1) - (a = g(a)));" + "};", "function f(a) {" + " h((a=1) - (g(a)));" + "};"); } public void testIssue297g() { test("function f(a) {" + " var b = h((b=1) - (b = g(b)));" + " return b;" + "};", // The last assignment in the initializer should be eliminated "function f(a) {" + " var b = h((b=1) - (b = g(b)));" + " return b;" + "};"); } public void testIssue297h() { test("function f(a) {" + " var b = b=1;" + " return b;" + "};", // The assignment in the initializer should be eliminated "function f(a) {" + " var b = b = 1;" + " return b;" + "};"); } public void testInExpression1() { inFunction("var a; return a=(a=(a=3));", "var a; return 3;"); inFunction("var a; return a=(a=(a=a));", "var a; return a;"); inFunction("var a; return a=(a=(a=a+1)+1);", "var a; return a+1+1;"); inFunction("var a; return a=(a=(a=f(a)+1)+1);", "var a; return f(a)+1+1;"); inFunction("var a; return a=f(a=f(a=f(a)));", "var a; return f(f(f(a)));"); } public void testInExpression2() { // This can be improved. "a = 1" is dead but "a" is read in the following // expression. inFunction( "var a; a = 1; if ((a = 2) || (a = 3) || (a)) {}", "var a; a = 1; if (( 2) || (a = 3) || (a)) {}"); inFunction( "var a; (a = 1) || (a = 2)", "var a; 1 || 2"); inFunction("var a; (a = 1) || (a = 2); return a"); inFunction( "var a; a = 1; a ? a = 2 : a;", "var a; a = 1; a ? 2 : a;"); inFunction("var a; a = 1; a ? a = 2 : a; return a"); inFunction( "var a; a = 1; a ? a : a = 2;", "var a; a = 1; a ? a : 2;"); inFunction("var a; a = 1; a ? a : a =2; return a"); inFunction( "var a; (a = 1) ? a = 2 : a = 3;", "var a; 1 ? 2 : 3;"); // This can be improved. "a = 1" is dead but "a" is read in the following // expression. inFunction("var a; (a = 1) ? a = 2 : a = 3; return a"); } public void testIssue384a() { inFunction( " var a, b;\n" + " if (f(b = true) || f(b = false))\n" + " a = b;\n" + " else\n" + " a = null;\n" + " return a;"); } public void testIssue384b() { inFunction( " var a, b;\n" + " (f(b = true) || f(b = false)) ? (a = b) : (a = null);\n" + " return a;"); } public void testIssue384c() { inFunction( " var a, b;\n" + " (a ? f(b = true) : f(b = false)) && (a = b);\n" + " return a;"); } public void testIssue384d() { inFunction( " var a, b;\n" + " (f(b = true) || f(b = false)) && (a = b);\n" + " return a;"); } public void testForIn() { inFunction("var x = {}; for (var y in x) { y() }"); inFunction("var x, y, z; x = {}; z = {}; for (y in x = z) { y() }", "var x, y, z; ({}); z = {}; for (y in z) { y() }"); inFunction("var x, y, z; x = {}; z = {}; for (y[z=1] in z) { y() }", "var x, y, z; ({}); z = {}; for (y[z=1] in z) { y() }"); // "x in z" doesn't overwrite x if z is empty. // TODO(user): If you look outside of just liveness, x = {} is dead. // That probably requires value numbering or SSA to detect that case. inFunction("var x, y, z; x = {}; z = {}; for (x in z) { x() }"); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import junit.framework.TestCase; /** * Test class for the default {@link CodingConvention}. */ public class DefaultCodingConventionTest extends TestCase { private CodingConvention conv = CodingConventions.getDefault(); public void testVarAndOptionalParams() { Node args = new Node(Token.PARAM_LIST, Node.newString(Token.NAME, "a"), Node.newString(Token.NAME, "b")); Node optArgs = new Node(Token.PARAM_LIST, Node.newString(Token.NAME, "opt_a"), Node.newString(Token.NAME, "opt_b")); assertFalse(conv.isVarArgsParameter(args.getFirstChild())); assertTrue(conv.isVarArgsParameter(args.getLastChild())); assertFalse(conv.isVarArgsParameter(optArgs.getFirstChild())); assertTrue(conv.isVarArgsParameter(optArgs.getLastChild())); assertTrue(conv.isOptionalParameter(args.getFirstChild())); assertFalse(conv.isOptionalParameter(args.getLastChild())); assertTrue(conv.isOptionalParameter(optArgs.getFirstChild())); assertFalse(conv.isOptionalParameter(optArgs.getLastChild())); } public void testInlineName() { assertFalse(conv.isConstant("a")); assertFalse(conv.isConstant("XYZ123_")); assertFalse(conv.isConstant("ABC")); assertFalse(conv.isConstant("ABCdef")); assertFalse(conv.isConstant("aBC")); assertFalse(conv.isConstant("A")); assertFalse(conv.isConstant("_XYZ123")); assertFalse(conv.isConstant("a$b$XYZ123_")); assertFalse(conv.isConstant("a$b$ABC_DEF")); assertFalse(conv.isConstant("a$b$A")); assertFalse(conv.isConstant("a$b$a")); assertFalse(conv.isConstant("a$b$ABCdef")); assertFalse(conv.isConstant("a$b$aBC")); assertFalse(conv.isConstant("a$b$")); assertFalse(conv.isConstant("$")); } public void testExportedName() { assertFalse(conv.isExported("_a")); assertFalse(conv.isExported("_a_")); assertFalse(conv.isExported("a")); assertFalse(conv.isExported("$super", false)); assertTrue(conv.isExported("$super", true)); assertTrue(conv.isExported("$super")); } public void testPrivateName() { assertFalse(conv.isPrivate("a_")); assertFalse(conv.isPrivate("a")); assertFalse(conv.isPrivate("_a_")); } public void testEnumKey() { assertTrue(conv.isValidEnumKey("A")); assertTrue(conv.isValidEnumKey("123")); assertTrue(conv.isValidEnumKey("FOO_BAR")); assertTrue(conv.isValidEnumKey("a")); assertTrue(conv.isValidEnumKey("someKeyInCamelCase")); assertTrue(conv.isValidEnumKey("_FOO_BAR")); } public void testInheritanceDetection1() { assertNotClassDefining("goog.foo(A, B);"); } public void testInheritanceDetection2() { assertNotClassDefining("goog.inherits(A, B);"); } public void testInheritanceDetection3() { assertNotClassDefining("A.inherits(B);"); } public void testInheritanceDetection4() { assertNotClassDefining("goog.inherits(goog.A, goog.B);"); } public void testInheritanceDetection5() { assertNotClassDefining("goog.A.inherits(goog.B);"); } public void testInheritanceDetection6() { assertNotClassDefining("A.inherits(this.B);"); } public void testInheritanceDetection7() { assertNotClassDefining("this.A.inherits(B);"); } public void testInheritanceDetection8() { assertNotClassDefining("goog.inherits(A, B, C);"); } public void testInheritanceDetection9() { assertNotClassDefining("A.mixin(B.prototype);"); } public void testInheritanceDetection10() { assertNotClassDefining("goog.mixin(A.prototype, B.prototype);"); } public void testInheritanceDetectionPostCollapseProperties() { assertNotClassDefining("goog$inherits(A, B);"); assertNotClassDefining("goog$inherits(A);"); } public void testFunctionBind() { assertNotFunctionBind("goog.bind(f)"); assertNotFunctionBind("goog$bind(f)"); assertNotFunctionBind("goog.partial(f)"); assertNotFunctionBind("goog$partial(f)"); assertFunctionBind("(function(){}).bind()"); assertFunctionBind("(function(){}).bind(obj)"); assertFunctionBind("(function(){}).bind(obj, p1)"); assertNotFunctionBind("Function.prototype.bind.call()"); assertFunctionBind("Function.prototype.bind.call(obj)"); assertFunctionBind("Function.prototype.bind.call(obj, p1)"); } private void assertFunctionBind(String code) { Node n = parseTestCode(code); assertNotNull(conv.describeFunctionBind(n.getFirstChild())); } private void assertNotFunctionBind(String code) { Node n = parseTestCode(code); assertNull(conv.describeFunctionBind(n.getFirstChild())); } private void assertNotClassDefining(String code) { Node n = parseTestCode(code); assertNull(conv.getClassesDefinedByCall(n.getFirstChild())); } private Node parseTestCode(String code) { Compiler compiler = new Compiler(); return compiler.parseTestCode(code).getFirstChild(); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.Lists; import com.google.javascript.jscomp.DefinitionsRemover.Definition; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.rhino.Node; import java.util.List; /** * Test for {@link DefinitionsRemover}. Basically test for the simple removal * cases. More complicated cases will be tested by the clients of * {@link DefinitionsRemover}. * */ public class DefinitionsRemoverTest extends CompilerTestCase { public void testRemoveFunction() { testSame("{(function (){bar()})}"); test("{function a(){bar()}}", "{}"); test("foo(); function a(){} bar()", "foo(); bar();"); test("foo(); function a(){} function b(){} bar()", "foo(); bar();"); } public void testRemoveAssignment() { test("x = 0;", "0"); test("{x = 0}", "{0}"); test("x = 0; y = 0;", "0; 0;"); test("for (x = 0;x;x) {};", "for(0;x;x) {};"); } public void testRemoveVarAssignment() { test("var x = 0;", "0"); test("{var x = 0}", "{0}"); test("var x = 0; var y = 0;", "0;0"); test("var x = 0; var y = 0;", "0;0"); } public void testRemoveLiteral() { test("foo({ 'one' : 1 })", "foo({ })"); test("foo({ 'one' : 1 , 'two' : 2 })", "foo({ })"); } public void testRemoveFunctionExpressionName() { test("foo(function f(){})", "foo(function (){})"); } @Override protected CompilerPass getProcessor(final Compiler compiler) { // Create a pass that removes all the definitions. return new CompilerPass() { @Override public void process(Node externs, Node root) { DefinitionsGatherer g = new DefinitionsGatherer(); (new NodeTraversal(compiler, g)).traverse(root); for (Definition def : g.definitions) { def.remove(); compiler.reportCodeChange(); } } }; } /** * Gather all possible definition objects. */ private static class DefinitionsGatherer extends AbstractPostOrderCallback { final List<Definition> definitions = Lists.newArrayList(); @Override public void visit(NodeTraversal t, Node n, Node parent) { Definition def = DefinitionsRemover.getDefinition(n, false); if (def != null) { definitions.add(def); } } } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.jscomp.Normalize.NormalizeStatements; import com.google.javascript.rhino.Node; /** * @author johnlenz@google.com (John Lenz) * */ public class DenormalizeTest extends CompilerTestCase { @Override public CompilerPass getProcessor(final Compiler compiler) { return new NormalizeAndDenormalizePass(compiler); } @Override protected int getNumRepetitions() { // The normalize pass is only run once. return 1; } public void testFor() { // Verify assignments are moved into the FOR init node. test("a = 0; for(; a < 2 ; a++) foo()", "for(a = 0; a < 2 ; a++) foo();"); // Verify vars are are moved into the FOR init node. test("var a = 0; for(; c < b ; c++) foo()", "for(var a = 0; c < b ; c++) foo()"); // We don't handle labels yet. testSame("var a = 0; a:for(; c < b ; c++) foo()"); testSame("var a = 0; a:b:for(; c < b ; c++) foo()"); // Verify FOR inside IFs. test("if(x){var a = 0; for(; c < b; c++) foo()}", "if(x){for(var a = 0; c < b; c++) foo()}"); // Any other expression. test("init(); for(; a < 2 ; a++) foo()", "for(init(); a < 2 ; a++) foo();"); // Other statements are left as is. test("function f(){ var a; for(; a < 2 ; a++) foo() }", "function f(){ for(var a; a < 2 ; a++) foo() }"); testSame("function f(){ return; for(; a < 2 ; a++) foo() }"); } public void testForIn() { test("var a; for(a in b) foo()", "for (var a in b) foo()"); testSame("a = 0; for(a in b) foo()"); testSame("var a = 0; for(a in b) foo()"); // We don't handle labels yet. testSame("var a; a:for(a in b) foo()"); testSame("var a; a:b:for(a in b) foo()"); // Verify FOR inside IFs. test("if(x){var a; for(a in b) foo()}", "if(x){for(var a in b) foo()}"); // Any other expression. testSame("init(); for(a in b) foo()"); // Other statements are left as is. testSame("function f(){ return; for(a in b) foo() }"); } public void testInOperatorNotInsideFor() { // in operators shouldn't be moved into for loops. // Some JavaScript interpreters (such as the NetFront Access browser // embedded in the PlayStation 3) will not parse an in operator in // a for loop, even if it's protected by parentheses. // Make sure the in operator doesn't get moved into the for loop. testSame("function f(){ var a; var i=\"length\" in a;" + "for(; a < 2 ; a++) foo() }"); // Same, but with parens around the operator. testSame("function f(){ var a; var i=(\"length\" in a);" + "for(; a < 2 ; a++) foo() }"); // Make sure Normalize yanks the variable initializer out, and // Denormalize doesn't put it back. test("function f(){" + "var b,a=0; for (var i=(\"length\" in b);a<2; a++) foo()}", "function f(){var b; var a=0;var i=(\"length\" in b);" + "for (;a<2;a++) foo()}"); } /** * Create a class to combine the Normalize and Denormalize passes. * This is needed because the enableNormalize() call on CompilerTestCase * causes normalization of the result *and* the expected string, and * we really don't want the compiler twisting the expected code around. */ public class NormalizeAndDenormalizePass implements CompilerPass { Denormalize denormalizePass; NormalizeStatements normalizePass; AbstractCompiler compiler; public NormalizeAndDenormalizePass(AbstractCompiler compiler) { this.compiler = compiler; denormalizePass = new Denormalize(compiler); normalizePass = new NormalizeStatements(compiler, false); } @Override public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root, normalizePass); NodeTraversal.traverse(compiler, root, denormalizePass); } } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.base.Joiner; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.javascript.jscomp.CheckLevel; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.JSType; import java.util.List; /** * Tests for {@link DevirtualizePrototypeMethods} * */ public class DevirtualizePrototypeMethodsTest extends CompilerTestCase { private static final String EXTERNAL_SYMBOLS = "var extern;extern.externalMethod"; private final List<String> typeInformation; public DevirtualizePrototypeMethodsTest() { super(EXTERNAL_SYMBOLS); typeInformation = Lists.newArrayList(); } @Override protected int getNumRepetitions() { // run pass once. return 1; } @Override protected void setUp() throws Exception { super.setUp(); super.enableLineNumberCheck(true); disableTypeCheck(); } /** * Combine source strings using '\n' as the separator. */ private static String newlineJoin(String ... parts) { return Joiner.on("\n").join(parts); } /** * Combine source strings using ';' as the separator. */ private static String semicolonJoin(String ... parts) { return Joiner.on(";").join(parts); } /** * Inputs for prototype method tests. */ private static class RewritePrototypeMethodTestInput { static final String INPUT = newlineJoin( "/** @constructor */", "function a(){ this.x = 3; }", "/** @return {number} */", "a.prototype.foo = function() {return this.x};", "/** @param {number} p\n@return {number} */", "a.prototype.bar = function(p) {return this.x};", "a.prototype.baz = function() {};", "var o = new a;", "o.foo();", "o.bar(2);", "o.baz()"); static final String EXPECTED = newlineJoin( "function a(){ this.x = 3; }", "var JSCompiler_StaticMethods_foo = ", "function(JSCompiler_StaticMethods_foo$self) {", " return JSCompiler_StaticMethods_foo$self.x", "};", "var JSCompiler_StaticMethods_bar = ", "function(JSCompiler_StaticMethods_bar$self, p) {", " return JSCompiler_StaticMethods_bar$self.x", "};", "var JSCompiler_StaticMethods_baz = ", "function(JSCompiler_StaticMethods_baz$self) {", "};", "var o = new a;", "JSCompiler_StaticMethods_foo(o);", "JSCompiler_StaticMethods_bar(o, 2);", "JSCompiler_StaticMethods_baz(o)"); static final List<String> EXPECTED_TYPE_CHECKING_OFF = ImmutableList.of( "FUNCTION a = null", "NAME JSCompiler_StaticMethods_foo$self = null", "FUNCTION JSCompiler_StaticMethods_foo = null", "NAME JSCompiler_StaticMethods_bar$self = null", "FUNCTION JSCompiler_StaticMethods_bar = null", "FUNCTION JSCompiler_StaticMethods_baz = null", "NEW a = null", "CALL JSCompiler_StaticMethods_foo = null", "CALL JSCompiler_StaticMethods_bar = null", "CALL JSCompiler_StaticMethods_baz = null"); static final List<String> EXPECTED_TYPE_CHECKING_ON = ImmutableList.of( "FUNCTION a = function (new:a): undefined", "NAME JSCompiler_StaticMethods_foo$self = a", "FUNCTION JSCompiler_StaticMethods_foo = function (a): number", "NAME JSCompiler_StaticMethods_bar$self = a", "FUNCTION JSCompiler_StaticMethods_bar = function (a, number): number", "FUNCTION JSCompiler_StaticMethods_baz = function (a): undefined", "NEW a = a", "CALL JSCompiler_StaticMethods_foo = number", "CALL JSCompiler_StaticMethods_bar = number", "CALL JSCompiler_StaticMethods_baz = undefined"); private RewritePrototypeMethodTestInput() {} } public void testRewritePrototypeMethods1() throws Exception { // type checking off disableTypeCheck(); checkTypes(RewritePrototypeMethodTestInput.INPUT, RewritePrototypeMethodTestInput.EXPECTED, RewritePrototypeMethodTestInput.EXPECTED_TYPE_CHECKING_OFF); } public void testRewritePrototypeMethods2() throws Exception { // type checking on enableTypeCheck(CheckLevel.ERROR); checkTypes(RewritePrototypeMethodTestInput.INPUT, RewritePrototypeMethodTestInput.EXPECTED, RewritePrototypeMethodTestInput.EXPECTED_TYPE_CHECKING_ON); } public void testRewriteChained() throws Exception { String source = newlineJoin( "A.prototype.foo = function(){return this.b};", "B.prototype.bar = function(){};", "o.foo().bar()"); String expected = newlineJoin( "var JSCompiler_StaticMethods_foo = ", "function(JSCompiler_StaticMethods_foo$self) {", " return JSCompiler_StaticMethods_foo$self.b", "};", "var JSCompiler_StaticMethods_bar = ", "function(JSCompiler_StaticMethods_bar$self) {", "};", "JSCompiler_StaticMethods_bar(JSCompiler_StaticMethods_foo(o))"); test(source, expected); } /** * Inputs for declaration used as an r-value tests. */ private static class NoRewriteDeclarationUsedAsRValue { static final String DECL = "a.prototype.foo = function() {}"; static final String CALL = "o.foo()"; private NoRewriteDeclarationUsedAsRValue() {} } public void testRewriteDeclIsExpressionStatement() throws Exception { test(semicolonJoin(NoRewriteDeclarationUsedAsRValue.DECL, NoRewriteDeclarationUsedAsRValue.CALL), "var JSCompiler_StaticMethods_foo =" + "function(JSCompiler_StaticMethods_foo$self) {};" + "JSCompiler_StaticMethods_foo(o)"); } public void testNoRewriteDeclUsedAsAssignmentRhs() throws Exception { testSame(semicolonJoin("var c = " + NoRewriteDeclarationUsedAsRValue.DECL, NoRewriteDeclarationUsedAsRValue.CALL)); } public void testNoRewriteDeclUsedAsCallArgument() throws Exception { testSame(semicolonJoin("f(" + NoRewriteDeclarationUsedAsRValue.DECL + ")", NoRewriteDeclarationUsedAsRValue.CALL)); } /** * Inputs for restrict-to-global-scope tests. */ private static class NoRewriteIfNotInGlobalScopeTestInput { static final String INPUT = newlineJoin( "function a(){}", "a.prototype.foo = function() {return this.x};", "var o = new a;", "o.foo()"); private NoRewriteIfNotInGlobalScopeTestInput() {} } public void testRewriteInGlobalScope() throws Exception { String expected = newlineJoin( "function a(){}", "var JSCompiler_StaticMethods_foo = ", "function(JSCompiler_StaticMethods_foo$self) {", " return JSCompiler_StaticMethods_foo$self.x", "};", "var o = new a;", "JSCompiler_StaticMethods_foo(o);"); test(NoRewriteIfNotInGlobalScopeTestInput.INPUT, expected); } public void testNoRewriteIfNotInGlobalScope1() throws Exception { testSame("if(true){" + NoRewriteIfNotInGlobalScopeTestInput.INPUT + "}"); } public void testNoRewriteIfNotInGlobalScope2() throws Exception { testSame("function enclosingFunction() {" + NoRewriteIfNotInGlobalScopeTestInput.INPUT + "}"); } public void testNoRewriteNamespaceFunctions() throws Exception { String source = newlineJoin( "function a(){}", "a.foo = function() {return this.x};", "a.foo()"); testSame(source); } /** * Inputs for multiple definition tests. */ private static class NoRewriteMultipleDefinitionTestInput { static final String TEMPLATE = ".prototype.foo = function() {}"; static final String SOURCE_A = "a" + TEMPLATE; static final String SOURCE_B = "b" + TEMPLATE; static final String CALL = "o.foo()"; static final String SINGLE_DEFINITION_EXPECTED = "var JSCompiler_StaticMethods_foo = " + " function(JSCompiler_StaticMethods_foo$self) {};" + "JSCompiler_StaticMethods_foo(o)"; private NoRewriteMultipleDefinitionTestInput() {} } public void testRewriteSingleDefinition1() throws Exception { test(semicolonJoin(NoRewriteMultipleDefinitionTestInput.SOURCE_A, NoRewriteMultipleDefinitionTestInput.CALL), NoRewriteMultipleDefinitionTestInput.SINGLE_DEFINITION_EXPECTED); } public void testRewriteSingleDefinition2() throws Exception { test(semicolonJoin(NoRewriteMultipleDefinitionTestInput.SOURCE_B, NoRewriteMultipleDefinitionTestInput.CALL), NoRewriteMultipleDefinitionTestInput.SINGLE_DEFINITION_EXPECTED); } public void testNoRewriteMultipleDefinition1() throws Exception { testSame(semicolonJoin(NoRewriteMultipleDefinitionTestInput.SOURCE_A, NoRewriteMultipleDefinitionTestInput.SOURCE_A, NoRewriteMultipleDefinitionTestInput.CALL)); } public void testNoRewriteMultipleDefinition2() throws Exception { testSame(semicolonJoin(NoRewriteMultipleDefinitionTestInput.SOURCE_B, NoRewriteMultipleDefinitionTestInput.SOURCE_B, NoRewriteMultipleDefinitionTestInput.CALL)); } public void testNoRewriteMultipleDefinition3() throws Exception { testSame(semicolonJoin(NoRewriteMultipleDefinitionTestInput.SOURCE_A, NoRewriteMultipleDefinitionTestInput.SOURCE_B, NoRewriteMultipleDefinitionTestInput.CALL)); } /** * Inputs for object literal tests. */ private static class NoRewritePrototypeObjectLiteralsTestInput { static final String REGULAR = "b.prototype.foo = function() {}"; static final String OBJ_LIT = "a.prototype = {foo : function() {}}"; static final String CALL = "o.foo()"; private NoRewritePrototypeObjectLiteralsTestInput() {} } public void testRewritePrototypeNoObjectLiterals() throws Exception { test(semicolonJoin(NoRewritePrototypeObjectLiteralsTestInput.REGULAR, NoRewritePrototypeObjectLiteralsTestInput.CALL), "var JSCompiler_StaticMethods_foo = " + "function(JSCompiler_StaticMethods_foo$self) {};" + "JSCompiler_StaticMethods_foo(o)"); } public void testRewritePrototypeObjectLiterals1() throws Exception { test(semicolonJoin(NoRewritePrototypeObjectLiteralsTestInput.OBJ_LIT, NoRewritePrototypeObjectLiteralsTestInput.CALL), "a.prototype={};" + "var JSCompiler_StaticMethods_foo=" + "function(JSCompiler_StaticMethods_foo$self){};" + "JSCompiler_StaticMethods_foo(o)"); } public void testNoRewritePrototypeObjectLiterals2() throws Exception { testSame(semicolonJoin(NoRewritePrototypeObjectLiteralsTestInput.OBJ_LIT, NoRewritePrototypeObjectLiteralsTestInput.REGULAR, NoRewritePrototypeObjectLiteralsTestInput.CALL)); } public void testNoRewriteExternalMethods1() throws Exception { testSame("a.externalMethod()"); } public void testNoRewriteExternalMethods2() throws Exception { testSame("A.prototype.externalMethod = function(){}; o.externalMethod()"); } public void testNoRewriteCodingConvention() throws Exception { // no rename, leading _ indicates exported symbol testSame("a.prototype._foo = function() {};"); } public void testRewriteNoVarArgs() throws Exception { String source = newlineJoin( "function a(){}", "a.prototype.foo = function(args) {return args};", "var o = new a;", "o.foo()"); String expected = newlineJoin( "function a(){}", "var JSCompiler_StaticMethods_foo = ", " function(JSCompiler_StaticMethods_foo$self, args) {return args};", "var o = new a;", "JSCompiler_StaticMethods_foo(o)"); test(source, expected); } public void testNoRewriteVarArgs() throws Exception { String source = newlineJoin( "function a(){}", "a.prototype.foo = function(var_args) {return arguments};", "var o = new a;", "o.foo()"); testSame(source); } /** * Inputs for invalidating reference tests. */ private static class NoRewriteNonCallReferenceTestInput { static final String BASE = newlineJoin( "function a(){}", "a.prototype.foo = function() {return this.x};", "var o = new a;"); private NoRewriteNonCallReferenceTestInput() {} } public void testRewriteCallReference() throws Exception { String expected = newlineJoin( "function a(){}", "var JSCompiler_StaticMethods_foo = ", "function(JSCompiler_StaticMethods_foo$self) {", " return JSCompiler_StaticMethods_foo$self.x", "};", "var o = new a;", "JSCompiler_StaticMethods_foo(o);"); test(NoRewriteNonCallReferenceTestInput.BASE + "o.foo()", expected); } public void testNoRewriteNoReferences() throws Exception { testSame(NoRewriteNonCallReferenceTestInput.BASE); } public void testNoRewriteNonCallReference() throws Exception { testSame(NoRewriteNonCallReferenceTestInput.BASE + "o.foo && o.foo()"); } /** * Inputs for nested definition tests. */ private static class NoRewriteNestedFunctionTestInput { static final String PREFIX = "a.prototype.foo = function() {"; static final String SUFFIX = "o.foo()"; static final String INNER = "a.prototype.bar = function() {}; o.bar()"; static final String EXPECTED_PREFIX = "var JSCompiler_StaticMethods_foo=" + "function(JSCompiler_StaticMethods_foo$self){"; static final String EXPECTED_SUFFIX = "JSCompiler_StaticMethods_foo(o)"; private NoRewriteNestedFunctionTestInput() {} } public void testRewriteNoNestedFunction() throws Exception { test(semicolonJoin( NoRewriteNestedFunctionTestInput.PREFIX + "}", NoRewriteNestedFunctionTestInput.SUFFIX, NoRewriteNestedFunctionTestInput.INNER), semicolonJoin( NoRewriteNestedFunctionTestInput.EXPECTED_PREFIX + "}", NoRewriteNestedFunctionTestInput.EXPECTED_SUFFIX, "var JSCompiler_StaticMethods_bar=" + "function(JSCompiler_StaticMethods_bar$self){}", "JSCompiler_StaticMethods_bar(o)")); } public void testNoRewriteNestedFunction() throws Exception { test(NoRewriteNestedFunctionTestInput.PREFIX + NoRewriteNestedFunctionTestInput.INNER + "};" + NoRewriteNestedFunctionTestInput.SUFFIX, NoRewriteNestedFunctionTestInput.EXPECTED_PREFIX + NoRewriteNestedFunctionTestInput.INNER + "};" + NoRewriteNestedFunctionTestInput.EXPECTED_SUFFIX); } public void testRewriteImplementedMethod() throws Exception { String source = newlineJoin( "function a(){}", "a.prototype.foo = function(args) {return args};", "var o = new a;", "o.foo()"); String expected = newlineJoin( "function a(){}", "var JSCompiler_StaticMethods_foo = ", " function(JSCompiler_StaticMethods_foo$self, args) {return args};", "var o = new a;", "JSCompiler_StaticMethods_foo(o)"); test(source, expected); } public void testRewriteImplementedMethod2() throws Exception { String source = newlineJoin( "function a(){}", "a.prototype['foo'] = function(args) {return args};", "var o = new a;", "o.foo()"); testSame(source); } public void testRewriteImplementedMethod3() throws Exception { String source = newlineJoin( "function a(){}", "a.prototype.foo = function(args) {return args};", "var o = new a;", "o['foo']"); testSame(source); } public void testRewriteImplementedMethod4() throws Exception { String source = newlineJoin( "function a(){}", "a.prototype['foo'] = function(args) {return args};", "var o = new a;", "o['foo']"); testSame(source); } public void testRewriteImplementedMethodInObj() throws Exception { String source = newlineJoin( "function a(){}", "a.prototype = {foo: function(args) {return args}};", "var o = new a;", "o.foo()"); test(source, "function a(){}" + "a.prototype={};" + "var JSCompiler_StaticMethods_foo=" + "function(JSCompiler_StaticMethods_foo$self,args){return args};" + "var o=new a;" + "JSCompiler_StaticMethods_foo(o)"); } public void testNoRewriteGet1() throws Exception { // Getters and setter require special handling. String source = newlineJoin( "function a(){}", "a.prototype = {get foo(){return f}};", "var o = new a;", "o.foo()"); testSame(source); } public void testNoRewriteGet2() throws Exception { // Getters and setter require special handling. String source = newlineJoin( "function a(){}", "a.prototype = {get foo(){return 1}};", "var o = new a;", "o.foo"); testSame(source); } public void testNoRewriteSet1() throws Exception { // Getters and setter require special handling. String source = newlineJoin( "function a(){}", "a.prototype = {set foo(a){}};", "var o = new a;", "o.foo()"); testSame(source); } public void testNoRewriteSet2() throws Exception { // Getters and setter require special handling. String source = newlineJoin( "function a(){}", "a.prototype = {set foo(a){}};", "var o = new a;", "o.foo = 1"); testSame(source); } public void testNoRewriteNotImplementedMethod() throws Exception { testSame(newlineJoin("function a(){}", "var o = new a;", "o.foo()")); } public void testWrapper() { testSame("(function() {})()"); } private static class ModuleTestInput { static final String DEFINITION = "a.prototype.foo = function() {}"; static final String USE = "x.foo()"; static final String REWRITTEN_DEFINITION = "var JSCompiler_StaticMethods_foo=" + "function(JSCompiler_StaticMethods_foo$self){}"; static final String REWRITTEN_USE = "JSCompiler_StaticMethods_foo(x)"; private ModuleTestInput() {} } public void testRewriteSameModule1() throws Exception { JSModule[] modules = createModuleStar( // m1 semicolonJoin(ModuleTestInput.DEFINITION, ModuleTestInput.USE), // m2 ""); test(modules, new String[] { // m1 semicolonJoin(ModuleTestInput.REWRITTEN_DEFINITION, ModuleTestInput.REWRITTEN_USE), // m2 "", }); } public void testRewriteSameModule2() throws Exception { JSModule[] modules = createModuleStar( // m1 "", // m2 semicolonJoin(ModuleTestInput.DEFINITION, ModuleTestInput.USE)); test(modules, new String[] { // m1 "", // m2 semicolonJoin(ModuleTestInput.REWRITTEN_DEFINITION, ModuleTestInput.REWRITTEN_USE) }); } public void testRewriteSameModule3() throws Exception { JSModule[] modules = createModuleStar( // m1 semicolonJoin(ModuleTestInput.USE, ModuleTestInput.DEFINITION), // m2 ""); test(modules, new String[] { // m1 semicolonJoin(ModuleTestInput.REWRITTEN_USE, ModuleTestInput.REWRITTEN_DEFINITION), // m2 "" }); } public void testRewriteDefinitionBeforeUse() throws Exception { JSModule[] modules = createModuleStar( // m1 ModuleTestInput.DEFINITION, // m2 ModuleTestInput.USE); test(modules, new String[] { // m1 ModuleTestInput.REWRITTEN_DEFINITION, // m2 ModuleTestInput.REWRITTEN_USE }); } public void testNoRewriteUseBeforeDefinition() throws Exception { JSModule[] modules = createModuleStar( // m1 ModuleTestInput.USE, // m2 ModuleTestInput.DEFINITION); testSame(modules); } /** * Verifies that the compiler pass's output matches the expected * output, and that nodes are annotated with the expected jstype * information. */ private void checkTypes(String source, String expected, List<String> expectedTypes) { typeInformation.clear(); test(source, expected); assertEquals(expectedTypes, typeInformation); } @Override protected CompilerPass getProcessor(Compiler compiler) { return new TypeInformationGatherer( compiler, new DevirtualizePrototypeMethods(compiler), typeInformation); } /** * Wrapper that gathers function, call, and self variable type strings after * the pass under test runs. For use to test passes that modify JSType * annotations. */ private static class TypeInformationGatherer implements CompilerPass { private final Compiler compiler; private final CompilerPass passUnderTest; private final List<String> typeInformation; TypeInformationGatherer(Compiler compiler, CompilerPass passUnderTest, List<String> typeInformation) { this.compiler = compiler; this.passUnderTest = passUnderTest; this.typeInformation = typeInformation; } @Override public void process(Node externs, Node root) { passUnderTest.process(externs, root); NodeTraversal.traverse(compiler, externs, new GatherCallback()); NodeTraversal.traverse(compiler, root, new GatherCallback()); } public String getNameString(Node n) { int type = n.getType(); if (type == Token.NAME) { return n.getString(); } else if (type == Token.GETPROP) { String left = getNameString(n.getFirstChild()); if (left == null) { return null; } return left + "." + n.getLastChild().getString(); } else if (type == Token.GETELEM) { String left = getNameString(n.getFirstChild()); if (left == null) { return null; } return left + "[" + n.getLastChild().getString() + "]"; } else if (type == Token.THIS) { return "this"; } else if (type == Token.FUNCTION){ return "{ANON FUNCTION}"; } else { // I wonder if we should just die on this. return null; } } private class GatherCallback extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal traversal, Node node, Node parent) { Node nameNode = null; if (node.isFunction()) { if (parent.isName()) { nameNode = parent; } else if (parent.isAssign()) { nameNode = parent.getFirstChild(); } else { nameNode = node.getFirstChild(); } } else if (node.isCall() || node.isNew()) { nameNode = node.getFirstChild(); } if (nameNode != null) { JSType type = node.getJSType(); typeInformation.add( Joiner.on("").join( Token.name(node.getType()), " ", getNameString(nameNode), " = ", (type != null) ? type.toString() : "null")); } if (node.isGetProp()) { Node child = node.getFirstChild(); if (child.isName() && child.getString().endsWith("$self")) { JSType type = child.getJSType(); typeInformation.add( Joiner.on("").join( Token.name(child.getType()), " ", child.getString(), " = ", (type != null) ? type.toString() : "null")); } } } } } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import junit.framework.TestCase; /** * Tests for DiagnosticGroup. * @author nicksantos@google.com (Nick Santos) */ public class DiagnosticGroupTest extends TestCase { public void testRegistration() throws Exception { DiagnosticGroups dg = new DiagnosticGroups(); assertEquals(DiagnosticGroups.DEPRECATED, dg.forName("deprecated")); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.Maps; import com.google.common.collect.Multimap; import com.google.common.collect.Sets; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.testing.BaseJSTypeTestCase; import com.google.javascript.rhino.testing.TestErrorReporter; import java.util.Collection; import java.util.Map; import java.util.Set; import java.util.TreeMap; import java.util.TreeSet; /** * Unit test for the Compiler DisambiguateProperties pass. * */ public class DisambiguatePropertiesTest extends CompilerTestCase { private DisambiguateProperties<?> lastPass; private boolean runTightenTypes; public DisambiguatePropertiesTest() { parseTypeInfo = true; } @Override protected void setUp() throws Exception { super.setUp(); super.enableNormalize(true); super.enableTypeCheck(CheckLevel.WARNING); } @Override public CompilerPass getProcessor(final Compiler compiler) { return new CompilerPass() { @Override public void process(Node externs, Node root) { Map<String, CheckLevel> propertiesToErrorFor = Maps.<String, CheckLevel>newHashMap(); propertiesToErrorFor.put("foobar", CheckLevel.ERROR); if (runTightenTypes) { TightenTypes tightener = new TightenTypes(compiler); tightener.process(externs, root); lastPass = DisambiguateProperties.forConcreteTypeSystem(compiler, tightener, propertiesToErrorFor); } else { // This must be created after type checking is run as it depends on // any mismatches found during checking. lastPass = DisambiguateProperties.forJSTypeSystem( compiler, propertiesToErrorFor); } lastPass.process(externs, root); } }; } @Override protected int getNumRepetitions() { return 1; } public void testOneType1() { String js = "" + "/** @constructor */ function Foo() {}\n" + "Foo.prototype.a = 0;\n" + "/** @type Foo */\n" + "var F = new Foo;\n" + "F.a = 0;"; testSets(false, js, js, "{a=[[Foo.prototype]]}"); testSets(true, js, js, "{a=[[Foo.prototype]]}"); } public void testOneType2() { String js = "" + "/** @constructor */ function Foo() {}\n" + "Foo.prototype = {a: 0};\n" + "/** @type Foo */\n" + "var F = new Foo;\n" + "F.a = 0;"; String expected = "{a=[[Foo.prototype]]}"; testSets(false, js, js, expected); testSets(true, js, js, expected); } public void testOneType3() { String js = "" + "/** @constructor */ function Foo() {}\n" + "Foo.prototype = { get a() {return 0}," + " set a(b) {} };\n" + "/** @type Foo */\n" + "var F = new Foo;\n" + "F.a = 0;"; String expected = "{a=[[Foo.prototype]]}"; testSets(false, js, js, expected); testSets(true, js, js, expected); } public void testPrototypeAndInstance() { String js = "" + "/** @constructor */ function Foo() {}\n" + "Foo.prototype.a = 0;\n" + "/** @type Foo */\n" + "var F = new Foo;\n" + "F.a = 0;"; testSets(false, js, js, "{a=[[Foo.prototype]]}"); testSets(true, js, js, "{a=[[Foo.prototype]]}"); } public void testPrototypeAndInstance2() { String js = "" + "/** @constructor */ function Foo() {}\n" + "Foo.prototype.a = 0;\n" + "new Foo().a = 0;"; testSets(false, js, js, "{a=[[Foo.prototype]]}"); testSets(true, js, js, "{a=[[Foo.prototype]]}"); } public void testTwoTypes1() { String js = "" + "/** @constructor */ function Foo() {}\n" + "Foo.prototype.a = 0;" + "/** @type Foo */\n" + "var F = new Foo;\n" + "F.a = 0;" + "/** @constructor */ function Bar() {}\n" + "Bar.prototype.a = 0;" + "/** @type Bar */\n" + "var B = new Bar;\n" + "B.a = 0;"; String output = "" + "function Foo(){}" + "Foo.prototype.Foo_prototype$a=0;" + "var F=new Foo;" + "F.Foo_prototype$a=0;" + "function Bar(){}" + "Bar.prototype.Bar_prototype$a=0;" + "var B=new Bar;" + "B.Bar_prototype$a=0"; testSets(false, js, output, "{a=[[Bar.prototype], [Foo.prototype]]}"); testSets(true, js, output, "{a=[[Bar.prototype], [Foo.prototype]]}"); } public void testTwoTypes2() { String js = "" + "/** @constructor */ function Foo() {}\n" + "Foo.prototype = {a: 0};" + "/** @type Foo */\n" + "var F = new Foo;\n" + "F.a = 0;" + "/** @constructor */ function Bar() {}\n" + "Bar.prototype = {a: 0};" + "/** @type Bar */\n" + "var B = new Bar;\n" + "B.a = 0;"; String output = "" + "function Foo(){}" + "Foo.prototype = {Foo_prototype$a: 0};" + "var F=new Foo;" + "F.Foo_prototype$a=0;" + "function Bar(){}" + "Bar.prototype = {Bar_prototype$a: 0};" + "var B=new Bar;" + "B.Bar_prototype$a=0"; testSets(false, js, output, "{a=[[Bar.prototype], [Foo.prototype]]}"); testSets(true, js, output, "{a=[[Bar.prototype], [Foo.prototype]]}"); } public void testTwoTypes3() { String js = "" + "/** @constructor */ function Foo() {}\n" + "Foo.prototype = { get a() {return 0}," + " set a(b) {} };\n" + "/** @type Foo */\n" + "var F = new Foo;\n" + "F.a = 0;" + "/** @constructor */ function Bar() {}\n" + "Bar.prototype = { get a() {return 0}," + " set a(b) {} };\n" + "/** @type Bar */\n" + "var B = new Bar;\n" + "B.a = 0;"; String output = "" + "function Foo(){}" + "Foo.prototype = { get Foo_prototype$a() {return 0}," + " set Foo_prototype$a(b) {} };\n" + "var F=new Foo;" + "F.Foo_prototype$a=0;" + "function Bar(){}" + "Bar.prototype = { get Bar_prototype$a() {return 0}," + " set Bar_prototype$a(b) {} };\n" + "var B=new Bar;" + "B.Bar_prototype$a=0"; testSets(false, js, output, "{a=[[Bar.prototype], [Foo.prototype]]}"); testSets(true, js, output, "{a=[[Bar.prototype], [Foo.prototype]]}"); } public void testTwoFields() { String js = "" + "/** @constructor */ function Foo() {}\n" + "Foo.prototype.a = 0;" + "Foo.prototype.b = 0;" + "/** @type Foo */\n" + "var F = new Foo;\n" + "F.a = 0;" + "F.b = 0;"; String output = "function Foo(){}Foo.prototype.a=0;Foo.prototype.b=0;" + "var F=new Foo;F.a=0;F.b=0"; testSets(false, js, output, "{a=[[Foo.prototype]], b=[[Foo.prototype]]}"); testSets(true, js, output, "{a=[[Foo.prototype]], b=[[Foo.prototype]]}"); } public void testTwoSeparateFieldsTwoTypes() { String js = "" + "/** @constructor */ function Foo() {}\n" + "Foo.prototype.a = 0;" + "Foo.prototype.b = 0;" + "/** @type Foo */\n" + "var F = new Foo;\n" + "F.a = 0;" + "F.b = 0;" + "/** @constructor */ function Bar() {}\n" + "Bar.prototype.a = 0;" + "Bar.prototype.b = 0;" + "/** @type Bar */\n" + "var B = new Bar;\n" + "B.a = 0;" + "B.b = 0;"; String output = "" + "function Foo(){}" + "Foo.prototype.Foo_prototype$a=0;" + "Foo.prototype.Foo_prototype$b=0;" + "var F=new Foo;" + "F.Foo_prototype$a=0;" + "F.Foo_prototype$b=0;" + "function Bar(){}" + "Bar.prototype.Bar_prototype$a=0;" + "Bar.prototype.Bar_prototype$b=0;" + "var B=new Bar;" + "B.Bar_prototype$a=0;" + "B.Bar_prototype$b=0"; testSets(false, js, output, "{a=[[Bar.prototype], [Foo.prototype]]," + " b=[[Bar.prototype], [Foo.prototype]]}"); testSets(true, js, output, "{a=[[Bar.prototype], [Foo.prototype]]," + " b=[[Bar.prototype], [Foo.prototype]]}"); } public void testUnionType() { String js = "" + "/** @constructor */ function Foo() {}\n" + "Foo.prototype.a = 0;" + "/** @constructor */ function Bar() {}\n" + "Bar.prototype.a = 0;" + "/** @type {Bar|Foo} */\n" + "var B = new Bar;\n" + "B.a = 0;\n" + "B = new Foo;\n" + "B.a = 0;\n" + "/** @constructor */ function Baz() {}\n" + "Baz.prototype.a = 0;\n"; testSets(false, js, "{a=[[Bar.prototype, Foo.prototype], [Baz.prototype]]}"); testSets(true, js, "{a=[[Bar.prototype, Foo.prototype], [Baz.prototype]]}"); } public void testIgnoreUnknownType() { String js = "" + "/** @constructor */\n" + "function Foo() {}\n" + "Foo.prototype.blah = 3;\n" + "/** @type {Foo} */\n" + "var F = new Foo;\n" + "F.blah = 0;\n" + "var U = function() { return {} };\n" + "U().blah();"; String expected = "" + "function Foo(){}Foo.prototype.blah=3;var F = new Foo;F.blah=0;" + "var U=function(){return{}};U().blah()"; testSets(false, js, expected, "{}"); testSets(true, BaseJSTypeTestCase.ALL_NATIVE_EXTERN_TYPES, js, expected, "{}"); } public void testIgnoreUnknownType1() { String js = "" + "/** @constructor */\n" + "function Foo() {}\n" + "Foo.prototype.blah = 3;\n" + "/** @type {Foo} */\n" + "var F = new Foo;\n" + "F.blah = 0;\n" + "/** @return {Object} */\n" + "var U = function() { return {} };\n" + "U().blah();"; String expected = "" + "function Foo(){}Foo.prototype.blah=3;var F = new Foo;F.blah=0;" + "var U=function(){return{}};U().blah()"; testSets(false, js, expected, "{blah=[[Foo.prototype]]}"); testSets(true, BaseJSTypeTestCase.ALL_NATIVE_EXTERN_TYPES, js, expected, "{}"); } public void testIgnoreUnknownType2() { String js = "" + "/** @constructor */\n" + "function Foo() {}\n" + "Foo.prototype.blah = 3;\n" + "/** @type {Foo} */\n" + "var F = new Foo;\n" + "F.blah = 0;\n" + "/** @constructor */\n" + "function Bar() {}\n" + "Bar.prototype.blah = 3;\n" + "/** @return {Object} */\n" + "var U = function() { return {} };\n" + "U().blah();"; String expected = "" + "function Foo(){}Foo.prototype.blah=3;var F = new Foo;F.blah=0;" + "function Bar(){}Bar.prototype.blah=3;" + "var U=function(){return{}};U().blah()"; testSets(false, js, expected, "{}"); testSets(true, BaseJSTypeTestCase.ALL_NATIVE_EXTERN_TYPES, js, expected, "{}"); } public void testUnionTypeTwoFields() { String js = "" + "/** @constructor */ function Foo() {}\n" + "Foo.prototype.a = 0;\n" + "Foo.prototype.b = 0;\n" + "/** @constructor */ function Bar() {}\n" + "Bar.prototype.a = 0;\n" + "Bar.prototype.b = 0;\n" + "/** @type {Foo|Bar} */\n" + "var B = new Bar;\n" + "B.a = 0;\n" + "B.b = 0;\n" + "B = new Foo;\n" + "/** @constructor */ function Baz() {}\n" + "Baz.prototype.a = 0;\n" + "Baz.prototype.b = 0;\n"; String output = "" + "function Foo(){}" + "Foo.prototype.Bar_prototype$a=0;" + "Foo.prototype.Bar_prototype$b=0;" + "function Bar(){}" + "Bar.prototype.Bar_prototype$a=0;" + "Bar.prototype.Bar_prototype$b=0;" + "var B=new Bar;" + "B.Bar_prototype$a=0;" + "B.Bar_prototype$b=0;" + "function Baz(){}" + "Baz.prototype.a$Baz_prototype=0;" + "Baz.prototype.b$Baz_prototype=0;"; testSets(false, js, "{a=[[Bar.prototype, Foo.prototype], [Baz.prototype]]," + " b=[[Bar.prototype, Foo.prototype], [Baz.prototype]]}"); testSets(true, js, "{a=[[Bar.prototype, Foo.prototype], [Baz.prototype]]," + " b=[[Bar.prototype, Foo.prototype], [Baz.prototype]]}"); } public void testCast() { String js = "" + "/** @constructor */ function Foo() {}\n" + "Foo.prototype.a = 0;" + "/** @constructor */ function Bar() {}\n" + "Bar.prototype.a = 0;" + "/** @type {Foo|Bar} */\n" + "var F = new Foo;\n" + "(/** @type {Bar} */(F)).a = 0;"; String output = "" + "function Foo(){}Foo.prototype.Foo_prototype$a=0;" + "function Bar(){}Bar.prototype.Bar_prototype$a=0;" + "var F=new Foo;F.Bar_prototype$a=0;"; String ttOutput = "" + "function Foo(){}Foo.prototype.Foo_prototype$a=0;" + "function Bar(){}Bar.prototype.Bar_prototype$a=0;" + "var F=new Foo;F.Unique$1$a=0;"; testSets(false, js, output, "{a=[[Bar.prototype], [Foo.prototype]]}"); testSets(true, js, ttOutput, "{a=[[Bar.prototype], [Foo.prototype], [Unique$1]]}"); } public void testConstructorFields() { String js = "" + "/** @constructor */\n" + "var Foo = function() { this.a = 0; };\n" + "/** @constructor */ function Bar() {}\n" + "Bar.prototype.a = 0;" + "new Foo"; String output = "" + "var Foo=function(){this.Foo$a=0};" + "function Bar(){}" + "Bar.prototype.Bar_prototype$a=0;" + "new Foo"; String ttOutput = "" + "var Foo=function(){this.Foo_prototype$a=0};" + "function Bar(){}" + "Bar.prototype.Bar_prototype$a=0;" + "new Foo"; testSets(false, js, output, "{a=[[Bar.prototype], [Foo]]}"); testSets(true, js, ttOutput, "{a=[[Bar.prototype], [Foo.prototype]]}"); } public void testStaticProperty() { String js = "" + "/** @constructor */ function Foo() {} \n" + "/** @constructor */ function Bar() {}\n" + "Foo.a = 0;" + "Bar.a = 0;"; String output = "" + "function Foo(){}" + "function Bar(){}" + "Foo.function__new_Foo___undefined$a = 0;" + "Bar.function__new_Bar___undefined$a = 0;"; testSets(false, js, output, "{a=[[function (new:Bar): undefined]," + " [function (new:Foo): undefined]]}"); } public void testSupertypeWithSameField() { String js = "" + "/** @constructor */ function Foo() {}\n" + "Foo.prototype.a = 0;\n" + "/** @constructor\n* @extends Foo */ function Bar() {}\n" + "/** @override */\n" + "Bar.prototype.a = 0;\n" + "/** @type Bar */ var B = new Bar;\n" + "B.a = 0;" + "/** @constructor */ function Baz() {}\n" + "Baz.prototype.a = function(){};\n"; String output = "" + "function Foo(){}Foo.prototype.Foo_prototype$a=0;" + "function Bar(){}Bar.prototype.Foo_prototype$a=0;" + "var B = new Bar;B.Foo_prototype$a=0;" + "function Baz(){}Baz.prototype.Baz_prototype$a=function(){};"; String ttOutput = "" + "function Foo(){}Foo.prototype.Foo_prototype$a=0;" + "function Bar(){}Bar.prototype.Bar_prototype$a=0;" + "var B = new Bar;B.Bar_prototype$a=0;" + "function Baz(){}Baz.prototype.Baz_prototype$a=function(){};"; testSets(false, js, output, "{a=[[Baz.prototype], [Foo.prototype]]}"); testSets(true, js, ttOutput, "{a=[[Bar.prototype], [Baz.prototype], [Foo.prototype]]}"); } public void testScopedType() { String js = "" + "var g = {};\n" + "/** @constructor */ g.Foo = function() {}\n" + "g.Foo.prototype.a = 0;" + "/** @constructor */ g.Bar = function() {}\n" + "g.Bar.prototype.a = 0;"; String output = "" + "var g={};" + "g.Foo=function(){};" + "g.Foo.prototype.g_Foo_prototype$a=0;" + "g.Bar=function(){};" + "g.Bar.prototype.g_Bar_prototype$a=0;"; testSets(false, js, output, "{a=[[g.Bar.prototype], [g.Foo.prototype]]}"); testSets(true, js, output, "{a=[[g.Bar.prototype], [g.Foo.prototype]]}"); } public void testUnresolvedType() { // NOTE(nicksantos): This behavior seems very wrong to me. String js = "" + "var g = {};" + "/** @constructor \n @extends {?} */ " + "var Foo = function() {};\n" + "Foo.prototype.a = 0;" + "/** @constructor */ var Bar = function() {};\n" + "Bar.prototype.a = 0;"; String output = "" + "var g={};" + "var Foo=function(){};" + "Foo.prototype.Foo_prototype$a=0;" + "var Bar=function(){};" + "Bar.prototype.Bar_prototype$a=0;"; testSets(false, BaseJSTypeTestCase.ALL_NATIVE_EXTERN_TYPES, js, output, "{a=[[Bar.prototype], [Foo.prototype]]}"); testSets(true, BaseJSTypeTestCase.ALL_NATIVE_EXTERN_TYPES, js, output, "{a=[[Bar.prototype], [Foo.prototype]]}"); } public void testNamedType() { String js = "" + "var g = {};" + "/** @constructor \n @extends g.Late */ var Foo = function() {}\n" + "Foo.prototype.a = 0;" + "/** @constructor */ var Bar = function() {}\n" + "Bar.prototype.a = 0;" + "/** @constructor */ g.Late = function() {}"; String output = "" + "var g={};" + "var Foo=function(){};" + "Foo.prototype.Foo_prototype$a=0;" + "var Bar=function(){};" + "Bar.prototype.Bar_prototype$a=0;" + "g.Late = function(){}"; testSets(false, js, output, "{a=[[Bar.prototype], [Foo.prototype]]}"); testSets(true, js, output, "{a=[[Bar.prototype], [Foo.prototype]]}"); } public void testUnknownType() { String js = "" + "/** @constructor */ var Foo = function() {};\n" + "/** @constructor */ var Bar = function() {};\n" + "/** @return {?} */ function fun() {}\n" + "Foo.prototype.a = fun();\n" + "fun().a;\n" + "Bar.prototype.a = 0;"; String ttOutput = "" + "var Foo=function(){};\n" + "var Bar=function(){};\n" + "function fun(){}\n" + "Foo.prototype.Foo_prototype$a=fun();\n" + "fun().Unique$1$a;\n" + "Bar.prototype.Bar_prototype$a=0;"; testSets(false, js, js, "{}"); testSets(true, BaseJSTypeTestCase.ALL_NATIVE_EXTERN_TYPES, js, ttOutput, "{a=[[Bar.prototype], [Foo.prototype], [Unique$1]]}"); } public void testEnum() { String js = "" + "/** @enum {string} */ var En = {\n" + " A: 'first',\n" + " B: 'second'\n" + "};\n" + "var EA = En.A;\n" + "var EB = En.B;\n" + "/** @constructor */ function Foo(){};\n" + "Foo.prototype.A = 0;\n" + "Foo.prototype.B = 0;\n"; String output = "" + "var En={A:'first',B:'second'};" + "var EA=En.A;" + "var EB=En.B;" + "function Foo(){};" + "Foo.prototype.Foo_prototype$A=0;" + "Foo.prototype.Foo_prototype$B=0"; String ttOutput = "" + "var En={A:'first',B:'second'};" + "var EA=En.A;" + "var EB=En.B;" + "function Foo(){};" + "Foo.prototype.Foo_prototype$A=0;" + "Foo.prototype.Foo_prototype$B=0"; testSets(false, js, output, "{A=[[Foo.prototype]], B=[[Foo.prototype]]}"); testSets(true, js, ttOutput, "{A=[[Foo.prototype]], B=[[Foo.prototype]]}"); } public void testEnumOfObjects() { String js = "" + "/** @constructor */ function Formatter() {}" + "Formatter.prototype.format = function() {};" + "/** @constructor */ function Unrelated() {}" + "Unrelated.prototype.format = function() {};" + "/** @enum {!Formatter} */ var Enum = {\n" + " A: new Formatter()\n" + "};\n" + "Enum.A.format();\n"; String output = "" + "/** @constructor */ function Formatter() {}" + "Formatter.prototype.Formatter_prototype$format = function() {};" + "/** @constructor */ function Unrelated() {}" + "Unrelated.prototype.Unrelated_prototype$format = function() {};" + "/** @enum {!Formatter} */ var Enum = {\n" + " A: new Formatter()\n" + "};\n" + "Enum.A.Formatter_prototype$format();\n"; testSets(false, js, output, "{format=[[Formatter.prototype], [Unrelated.prototype]]}"); // TODO(nicksantos): Fix the type tightener to handle this case. // It currently doesn't work, because getSubTypes is broken for enums. } public void testEnumOfObjects2() { String js = "" + "/** @constructor */ function Formatter() {}" + "Formatter.prototype.format = function() {};" + "/** @constructor */ function Unrelated() {}" + "Unrelated.prototype.format = function() {};" + "/** @enum {?Formatter} */ var Enum = {\n" + " A: new Formatter(),\n" + " B: new Formatter()\n" + "};\n" + "function f() {\n" + " var formatter = window.toString() ? Enum.A : Enum.B;\n" + " formatter.format();\n" + "}"; String output = "" + "/** @constructor */ function Formatter() {}" + "Formatter.prototype.format = function() {};" + "/** @constructor */ function Unrelated() {}" + "Unrelated.prototype.format = function() {};" + "/** @enum {?Formatter} */ var Enum = {\n" + " A: new Formatter(),\n" + " B: new Formatter()\n" + "};\n" + "function f() {\n" + " var formatter = window.toString() ? Enum.A : Enum.B;\n" + " formatter.format();\n" + "}"; testSets(false, js, output, "{}"); } public void testEnumOfObjects3() { String js = "" + "/** @constructor */ function Formatter() {}" + "Formatter.prototype.format = function() {};" + "/** @constructor */ function Unrelated() {}" + "Unrelated.prototype.format = function() {};" + "/** @enum {!Formatter} */ var Enum = {\n" + " A: new Formatter(),\n" + " B: new Formatter()\n" + "};\n" + "/** @enum {!Enum} */ var SubEnum = {\n" + " C: Enum.A\n" + "};\n" + "function f() {\n" + " var formatter = SubEnum.C\n" + " formatter.format();\n" + "}"; String output = "" + "/** @constructor */ function Formatter() {}" + "Formatter.prototype.Formatter_prototype$format = function() {};" + "/** @constructor */ function Unrelated() {}" + "Unrelated.prototype.Unrelated_prototype$format = function() {};" + "/** @enum {!Formatter} */ var Enum = {\n" + " A: new Formatter(),\n" + " B: new Formatter()\n" + "};\n" + "/** @enum {!Enum} */ var SubEnum = {\n" + " C: Enum.A\n" + "};\n" + "function f() {\n" + " var formatter = SubEnum.C\n" + " formatter.Formatter_prototype$format();\n" + "}"; testSets(false, js, output, "{format=[[Formatter.prototype], [Unrelated.prototype]]}"); } public void testUntypedExterns() { String externs = BaseJSTypeTestCase.ALL_NATIVE_EXTERN_TYPES + "var window;" + "window.alert = function() {x};"; String js = "" + "/** @constructor */ function Foo() {}\n" + "Foo.prototype.a = 0;\n" + "Foo.prototype.alert = 0;\n" + "Foo.prototype.window = 0;\n" + "/** @constructor */ function Bar() {}\n" + "Bar.prototype.a = 0;\n" + "Bar.prototype.alert = 0;\n" + "Bar.prototype.window = 0;\n" + "window.alert();"; String output = "" + "function Foo(){}" + "Foo.prototype.Foo_prototype$a=0;" + "Foo.prototype.alert=0;" + "Foo.prototype.Foo_prototype$window=0;" + "function Bar(){}" + "Bar.prototype.Bar_prototype$a=0;" + "Bar.prototype.alert=0;" + "Bar.prototype.Bar_prototype$window=0;" + "window.alert();"; testSets(false, externs, js, output, "{a=[[Bar.prototype], [Foo.prototype]]" + ", window=[[Bar.prototype], [Foo.prototype]]}"); testSets(true, externs, js, output, "{a=[[Bar.prototype], [Foo.prototype]]," + " window=[[Bar.prototype], [Foo.prototype]]}"); } public void testUnionTypeInvalidation() { String externs = "" + "/** @constructor */ function Baz() {}" + "Baz.prototype.a"; String js = "" + "/** @constructor */ function Ind() {this.a=0}\n" + "/** @constructor */ function Foo() {}\n" + "Foo.prototype.a = 0;\n" + "/** @constructor */ function Bar() {}\n" + "Bar.prototype.a = 0;\n" + "/** @type {Foo|Bar} */\n" + "var F = new Foo;\n" + "F.a = 1\n;" + "F = new Bar;\n" + "/** @type {Baz} */\n" + "var Z = new Baz;\n" + "Z.a = 1\n;" + "/** @type {Bar|Baz} */\n" + "var B = new Baz;\n" + "B.a = 1;\n" + "B = new Bar;\n"; // Only the constructor field a of Ind is renamed, as Foo is related to Baz // through Bar in the unions Bar|Baz and Foo|Bar. String output = "" + "function Ind() { this.Ind$a = 0; }" + "function Foo() {}" + "Foo.prototype.a = 0;" + "function Bar() {}" + "Bar.prototype.a = 0;" + "var F = new Foo;" + "F.a = 1;" + "F = new Bar;" + "var Z = new Baz;" + "Z.a = 1;" + "var B = new Baz;" + "B.a = 1;" + "B = new Bar;"; String ttOutput = "" + "function Ind() { this.Unique$1$a = 0; }" + "function Foo() {}" + "Foo.prototype.a = 0;" + "function Bar() {}" + "Bar.prototype.a = 0;" + "var F = new Foo;" + "F.a = 1;" + "F = new Bar;" + "var Z = new Baz;" + "Z.a = 1;" + "var B = new Baz;" + "B.a = 1;" + "B = new Bar;"; testSets(false, externs, js, output, "{a=[[Ind]]}"); testSets(true, externs, js, ttOutput, "{a=[[Unique$1]]}"); } public void testUnionAndExternTypes() { String externs = "" + "/** @constructor */ function Foo() { }" + "Foo.prototype.a = 4;\n"; String js = "" + "/** @constructor */ function Bar() { this.a = 2; }\n" + "/** @constructor */ function Baz() { this.a = 3; }\n" + "/** @constructor */ function Buz() { this.a = 4; }\n" + "/** @constructor */ function T1() { this.a = 3; }\n" + "/** @constructor */ function T2() { this.a = 3; }\n" + "/** @type {Bar|Baz} */ var b;\n" + "/** @type {Baz|Buz} */ var c;\n" + "/** @type {Buz|Foo} */ var d;\n" + "b.a = 5; c.a = 6; d.a = 7;"; String output = "" + "/** @constructor */ function Bar() { this.a = 2; }\n" + "/** @constructor */ function Baz() { this.a = 3; }\n" + "/** @constructor */ function Buz() { this.a = 4; }\n" + "/** @constructor */ function T1() { this.T1$a = 3; }\n" + "/** @constructor */ function T2() { this.T2$a = 3; }\n" + "/** @type {Bar|Baz} */ var b;\n" + "/** @type {Baz|Buz} */ var c;\n" + "/** @type {Buz|Foo} */ var d;\n" + "b.a = 5; c.a = 6; d.a = 7;"; // We are testing the skipping of multiple types caused by unionizing with // extern types. testSets(false, externs, js, output, "{a=[[T1], [T2]]}"); } public void testTypedExterns() { String externs = "" + "/** @constructor */ function Window() {};\n" + "Window.prototype.alert;" + "/** @type {Window} */" + "var window;"; String js = "" + "/** @constructor */ function Foo() {}\n" + "Foo.prototype.alert = 0;\n" + "window.alert('blarg');"; String output = "" + "function Foo(){}" + "Foo.prototype.Foo_prototype$alert=0;" + "window.alert('blarg');"; testSets(false, externs, js, output, "{alert=[[Foo.prototype]]}"); testSets(true, externs, js, output, "{alert=[[Foo.prototype]]}"); } public void testSubtypesWithSameField() { String js = "" + "/** @constructor */ function Top() {}\n" + "/** @constructor \n@extends Top*/ function Foo() {}\n" + "Foo.prototype.a;\n" + "/** @constructor \n@extends Top*/ function Bar() {}\n" + "Bar.prototype.a;\n" + "/** @param {Top} top */" + "function foo(top) {\n" + " var x = top.a;\n" + "}\n" + "foo(new Foo);\n" + "foo(new Bar);\n"; testSets(false, js, "{}"); testSets(true, js, "{a=[[Bar.prototype, Foo.prototype]]}"); } public void testSupertypeReferenceOfSubtypeProperty() { String externs = "" + "/** @constructor */ function Ext() {}" + "Ext.prototype.a;"; String js = "" + "/** @constructor */ function Foo() {}\n" + "/** @constructor \n@extends Foo*/ function Bar() {}\n" + "Bar.prototype.a;\n" + "/** @param {Foo} foo */" + "function foo(foo) {\n" + " var x = foo.a;\n" + "}\n"; String result = "" + "function Foo() {}\n" + "function Bar() {}\n" + "Bar.prototype.Bar_prototype$a;\n" + "function foo(foo$$1) {\n" + " var x = foo$$1.Bar_prototype$a;\n" + "}\n"; testSets(false, externs, js, result, "{a=[[Bar.prototype]]}"); } public void testObjectLiteralNotRenamed() { String js = "" + "var F = {a:'a', b:'b'};" + "F.a = 'z';"; testSets(false, js, js, "{}"); testSets(true, js, js, "{}"); } public void testObjectLiteralReflected() { String js = "" + "var goog = {};" + "goog.reflect = {};" + "goog.reflect.object = function(x, y) { return y; };" + "/** @constructor */ function F() {}" + "/** @type {number} */ F.prototype.foo = 3;" + "/** @constructor */ function G() {}" + "/** @type {number} */ G.prototype.foo = 3;" + "goog.reflect.object(F, {foo: 5});"; String result = "" + "var goog = {};" + "goog.reflect = {};" + "goog.reflect.object = function(x, y) { return y; };" + "function F() {}" + "F.prototype.F_prototype$foo = 3;" + "function G() {}" + "G.prototype.G_prototype$foo = 3;" + "goog.reflect.object(F, {F_prototype$foo: 5});"; testSets(false, js, result, "{foo=[[F.prototype], [G.prototype]]}"); testSets(true, js, result, "{foo=[[F.prototype], [G.prototype]]}"); } public void testObjectLiteralLends() { String js = "" + "var mixin = function(x) { return x; };" + "/** @constructor */ function F() {}" + "/** @type {number} */ F.prototype.foo = 3;" + "/** @constructor */ function G() {}" + "/** @type {number} */ G.prototype.foo = 3;" + "mixin(/** @lends {F.prototype} */ ({foo: 5}));"; String result = "" + "var mixin = function(x) { return x; };" + "function F() {}" + "F.prototype.F_prototype$foo = 3;" + "function G() {}" + "G.prototype.G_prototype$foo = 3;" + "mixin(/** @lends {F.prototype} */ ({F_prototype$foo: 5}));"; testSets(false, js, result, "{foo=[[F.prototype], [G.prototype]]}"); testSets(true, js, result, "{foo=[[F.prototype], [G.prototype]]}"); } public void testClosureInherits() { String js = "" + "var goog = {};" + "/* @param {Function} childCtor Child class.\n" + " * @param {Function} parentCtor Parent class. */\n" + "goog.inherits = function(childCtor, parentCtor) {\n" + " /** @constructor */\n" + " function tempCtor() {};\n" + " tempCtor.prototype = parentCtor.prototype;\n" + " childCtor.superClass_ = parentCtor.prototype;\n" + " childCtor.prototype = new tempCtor();\n" + " childCtor.prototype.constructor = childCtor;\n" + "};" + "/** @constructor */ function Top() {}\n" + "Top.prototype.f = function() {};" + "/** @constructor \n@extends Top*/ function Foo() {}\n" + "goog.inherits(Foo, Top);\n" + "/** @override */\n" + "Foo.prototype.f = function() {" + " Foo.superClass_.f();" + "};\n" + "/** @constructor \n* @extends Foo */ function Bar() {}\n" + "goog.inherits(Bar, Foo);\n" + "/** @override */\n" + "Bar.prototype.f = function() {" + " Bar.superClass_.f();" + "};\n" + "(new Bar).f();\n"; testSets(false, js, "{f=[[Top.prototype]]}"); testSets(true, js, "{constructor=[[Bar.prototype, Foo.prototype]], " + "f=[[Bar.prototype], [Foo.prototype], [Top.prototype]]}"); } public void testSkipNativeFunctionMethod() { String externs = "" + "/** @constructor \n @param {*} var_args */" + "function Function(var_args) {}" + "Function.prototype.call = function() {};"; String js = "" + "/** @constructor */ function Foo(){};" + "/** @constructor\n @extends Foo */" + "function Bar() { Foo.call(this); };"; // call should not be renamed testSame(externs, js, null); } public void testSkipNativeObjectMethod() { String externs = "" + "/** @constructor \n @param {*} opt_v */ function Object(opt_v) {}" + "Object.prototype.hasOwnProperty;"; String js = "" + "/** @constructor */ function Foo(){};" + "(new Foo).hasOwnProperty('x');"; testSets(false, externs, js, js, "{}"); testSets(true, externs, js, js, "{}"); } public void testExtendNativeType() { String externs = "" + "/** @constructor \n @return {string} */" + "function Date(opt_1, opt_2, opt_3, opt_4, opt_5, opt_6, opt_7) {}" + "/** @override */ Date.prototype.toString = function() {}"; String js = "" + "/** @constructor\n @extends {Date} */ function SuperDate() {};\n" + "(new SuperDate).toString();"; testSets(true, externs, js, js, "{}"); testSets(false, externs, js, js, "{}"); } public void testStringFunction() { // Extern functions are not renamed, but user functions on a native // prototype object are. String externs = "/**@constructor\n@param {*} opt_str \n @return {string}*/" + "function String(opt_str) {};\n" + "/** @override \n @return {string} */\n" + "String.prototype.toString = function() { };\n"; String js = "" + "/** @constructor */ function Foo() {};\n" + "Foo.prototype.foo = function() {};\n" + "String.prototype.foo = function() {};\n" + "var a = 'str'.toString().foo();\n"; String output = "" + "function Foo() {};\n" + "Foo.prototype.Foo_prototype$foo = function() {};\n" + "String.prototype.String_prototype$foo = function() {};\n" + "var a = 'str'.toString().String_prototype$foo();\n"; testSets(false, externs, js, output, "{foo=[[Foo.prototype], [String.prototype]]}"); testSets(true, externs, js, output, "{foo=[[Foo.prototype], [String.prototype]]}"); } public void testUnusedTypeInExterns() { String externs = "" + "/** @constructor */ function Foo() {};\n" + "Foo.prototype.a"; String js = "" + "/** @constructor */ function Bar() {};\n" + "Bar.prototype.a;" + "/** @constructor */ function Baz() {};\n" + "Baz.prototype.a;"; String output = "" + "/** @constructor */ function Bar() {};\n" + "Bar.prototype.Bar_prototype$a;" + "/** @constructor */ function Baz() {};\n" + "Baz.prototype.Baz_prototype$a"; testSets(false, externs, js, output, "{a=[[Bar.prototype], [Baz.prototype]]}"); testSets(true, externs, js, output, "{a=[[Bar.prototype], [Baz.prototype]]}"); } public void testInterface() { String js = "" + "/** @interface */ function I() {};\n" + "I.prototype.a;\n" + "/** @constructor \n @implements I */ function Foo() {};\n" + "Foo.prototype.a;\n" + "/** @type I */\n" + "var F = new Foo;" + "var x = F.a;"; testSets(false, js, "{a=[[Foo.prototype, I.prototype]]}"); testSets(true, js, "{a=[[Foo.prototype], [I.prototype]]}"); } public void testInterfaceOfSuperclass() { String js = "" + "/** @interface */ function I() {};\n" + "I.prototype.a;\n" + "/** @constructor \n @implements I */ function Foo() {};\n" + "Foo.prototype.a;\n" + "/** @constructor \n @extends Foo */ function Bar() {};\n" + "Bar.prototype.a;\n" + "/** @type Bar */\n" + "var B = new Bar;" + "B.a = 0"; testSets(false, js, "{a=[[Foo.prototype, I.prototype]]}"); testSets(true, js, "{a=[[Bar.prototype], [Foo.prototype], [I.prototype]]}"); } public void testTwoInterfacesWithSomeInheritance() { String js = "" + "/** @interface */ function I() {};\n" + "I.prototype.a;\n" + "/** @interface */ function I2() {};\n" + "I2.prototype.a;\n" + "/** @constructor \n @implements I */ function Foo() {};\n" + "Foo.prototype.a;\n" + "/** @constructor \n @extends Foo \n @implements I2*/\n" + "function Bar() {};\n" + "Bar.prototype.a;\n" + "/** @type Bar */\n" + "var B = new Bar;" + "B.a = 0"; testSets(false, js, "{a=[[Foo.prototype, I.prototype, I2.prototype]]}"); testSets(true, js, "{a=[[Bar.prototype], [Foo.prototype], " + "[I.prototype], [I2.prototype]]}"); } public void testInvalidatingInterface() { String js = "" + "/** @interface */ function I2() {};\n" + "I2.prototype.a;\n" + "/** @constructor */ function Bar() {}\n" + "/** @type I */\n" + "var i = new Bar;\n" // Make I invalidating + "/** @constructor \n @implements I \n @implements I2 */" + "function Foo() {};\n" + "/** @override */\n" + "Foo.prototype.a = 0;\n" + "(new Foo).a = 0;" + "/** @interface */ function I() {};\n" + "I.prototype.a;\n"; testSets(false, js, "{}", TypeValidator.TYPE_MISMATCH_WARNING); testSets(true, js, "{}", TypeValidator.TYPE_MISMATCH_WARNING); } public void testMultipleInterfaces() { String js = "" + "/** @interface */ function I() {};\n" + "/** @interface */ function I2() {};\n" + "I2.prototype.a;\n" + "/** @constructor \n @implements I \n @implements I2 */" + "function Foo() {};\n" + "/** @override */" + "Foo.prototype.a = 0;\n" + "(new Foo).a = 0"; testSets(false, js, "{a=[[Foo.prototype, I2.prototype]]}"); testSets(true, js, "{a=[[Foo.prototype], [I2.prototype]]}"); } public void testInterfaceWithSupertypeImplementor() { String js = "" + "/** @interface */ function C() {}\n" + "C.prototype.foo = function() {};\n" + "/** @constructor */ function A (){}\n" + "A.prototype.foo = function() {};\n" + "/** @constructor \n @implements {C} \n @extends {A} */\n" + "function B() {}\n" + "/** @type {C} */ var b = new B();\n" + "b.foo();\n"; testSets(false, js, "{foo=[[A.prototype, C.prototype]]}"); testSets(true, js, "{foo=[[A.prototype], [C.prototype]]}"); } public void testSuperInterface() { String js = "" + "/** @interface */ function I() {};\n" + "I.prototype.a;\n" + "/** @interface \n @extends I */ function I2() {};\n" + "/** @constructor \n @implements I2 */" + "function Foo() {};\n" + "/** @override */\n" + "Foo.prototype.a = 0;\n" + "(new Foo).a = 0"; testSets(false, js, "{a=[[Foo.prototype, I.prototype]]}"); testSets(true, js, "{a=[[Foo.prototype], [I.prototype]]}"); } public void testInterfaceUnionWithCtor() { String js = "" + "/** @interface */ function I() {};\n" + "/** @type {!Function} */ I.prototype.addEventListener;\n" + "/** @constructor \n * @implements {I} */ function Impl() {};\n" + "/** @type {!Function} */ Impl.prototype.addEventListener;" + "/** @constructor */ function C() {};\n" + "/** @type {!Function} */ C.prototype.addEventListener;" + "/** @param {C|I} x */" + "function f(x) { x.addEventListener(); };\n" + "f(new C()); f(new Impl());"; testSets(false, js, js, "{addEventListener=[[C.prototype, I.prototype, Impl.prototype]]}"); // In the tightened case, the disambiguator is smart enough to // disambiguate Impl's method from the interface method. String tightenedOutput = "" + "function I() {};\n" + "I.prototype.I_prototype$addEventListener;\n" + "function Impl() {};\n" + "Impl.prototype.C_prototype$addEventListener;" + "function C() {};\n" + "C.prototype.C_prototype$addEventListener;" + "/** @param {C|I} x */" + "function f(x) { x.C_prototype$addEventListener(); };\n" + "f(new C()); f(new Impl());"; testSets(true, js, tightenedOutput, "{addEventListener=[[C.prototype, Impl.prototype], [I.prototype]]}"); } public void testExternInterfaceUnionWithCtor() { String externs = "" + "/** @interface */ function I() {};\n" + "/** @type {!Function} */ I.prototype.addEventListener;\n" + "/** @constructor \n * @implements {I} */ function Impl() {};\n" + "/** @type {!Function} */ Impl.prototype.addEventListener;"; String js = "" + "/** @constructor */ function C() {};\n" + "/** @type {!Function} */ C.prototype.addEventListener;" + "/** @param {C|I} x */" + "function f(x) { x.addEventListener(); };\n" + "f(new C()); f(new Impl());"; testSets(false, externs, js, js, "{}"); testSets(true, externs, js, js, "{}"); } /** * Tests that the type based version skips renaming on types that have a * mismatch, and the type tightened version continues to work as normal. */ public void testMismatchInvalidation() { String js = "" + "/** @constructor */ function Foo() {}\n" + "Foo.prototype.a = 0;\n" + "/** @constructor */ function Bar() {}\n" + "Bar.prototype.a = 0;\n" + "/** @type Foo */\n" + "var F = new Bar;\n" + "F.a = 0;"; testSets(false, "", js, js, "{}", TypeValidator.TYPE_MISMATCH_WARNING, "initializing variable\n" + "found : Bar\n" + "required: (Foo|null)"); testSets(true, "", js, js, "{}", TypeValidator.TYPE_MISMATCH_WARNING, "initializing variable\n" + "found : Bar\n" + "required: (Foo|null)"); } public void testBadCast() { String js = "/** @constructor */ function Foo() {};\n" + "Foo.prototype.a = 0;\n" + "/** @constructor */ function Bar() {};\n" + "Bar.prototype.a = 0;\n" + "var a = /** @type {!Foo} */ (new Bar);\n" + "a.a = 4;"; testSets(false, "", js, js, "{}", TypeValidator.INVALID_CAST, "invalid cast - must be a subtype or supertype\n" + "from: Bar\n" + "to : Foo"); } public void testDeterministicNaming() { String js = "/** @constructor */function A() {}\n" + "/** @return {string} */A.prototype.f = function() {return 'a';};\n" + "/** @constructor */function B() {}\n" + "/** @return {string} */B.prototype.f = function() {return 'b';};\n" + "/** @constructor */function C() {}\n" + "/** @return {string} */C.prototype.f = function() {return 'c';};\n" + "/** @type {A|B} */var ab = 1 ? new B : new A;\n" + "/** @type {string} */var n = ab.f();\n"; String output = "function A() {}\n" + "A.prototype.A_prototype$f = function() { return'a'; };\n" + "function B() {}\n" + "B.prototype.A_prototype$f = function() { return'b'; };\n" + "function C() {}\n" + "C.prototype.C_prototype$f = function() { return'c'; };\n" + "var ab = 1 ? new B : new A; var n = ab.A_prototype$f();\n"; for (int i = 0; i < 5; i++) { testSets(false, js, output, "{f=[[A.prototype, B.prototype], [C.prototype]]}"); testSets(true, js, output, "{f=[[A.prototype, B.prototype], [C.prototype]]}"); } } public void testObjectLiteral() { String js = "/** @constructor */ function Foo() {}\n" + "Foo.prototype.a;\n" + "/** @constructor */ function Bar() {}\n" + "Bar.prototype.a;\n" + "var F = /** @type {Foo} */({ a: 'a' });\n"; String output = "function Foo() {}\n" + "Foo.prototype.Foo_prototype$a;\n" + "function Bar() {}\n" + "Bar.prototype.Bar_prototype$a;\n" + "var F = { Foo_prototype$a: 'a' };\n"; testSets(false, js, output, "{a=[[Bar.prototype], [Foo.prototype]]}"); testSets(true, js, output, "{a=[[Bar.prototype], [Foo.prototype]]}"); } public void testCustomInherits() { String js = "Object.prototype.inheritsFrom = function(shuper) {\n" + " /** @constructor */\n" + " function Inheriter() { }\n" + " Inheriter.prototype = shuper.prototype;\n" + " this.prototype = new Inheriter();\n" + " this.superConstructor = shuper;\n" + "};\n" + "function Foo(var1, var2, strength) {\n" + " Foo.superConstructor.call(this, strength);\n" + "}" + "Foo.inheritsFrom(Object);"; String externs = "" + "function Function(var_args) {}" + "/** @return {*} */Function.prototype.call = function(var_args) {};"; testSets(false, externs, js, js, "{}"); } public void testSkipNativeFunctionStaticProperty() { String js = "" + "/** @param {!Function} ctor */\n" + "function addSingletonGetter(ctor) { ctor.a; }\n" + "/** @constructor */ function Foo() {}\n" + "Foo.a = 0;" + "/** @constructor */ function Bar() {}\n" + "Bar.a = 0;"; String output = "" + "function addSingletonGetter(ctor){ctor.a}" + "function Foo(){}" + "Foo.a=0;" + "function Bar(){}" + "Bar.a=0"; testSets(false, js, output, "{}"); } public void testErrorOnProtectedProperty() { test("function addSingletonGetter(foo) { foo.foobar = 'a'; };", null, DisambiguateProperties.Warnings.INVALIDATION); assertTrue(getLastCompiler().getErrors()[0].toString().contains("foobar")); } public void testMismatchForbiddenInvalidation() { test("/** @constructor */ function F() {}" + "/** @type {number} */ F.prototype.foobar = 3;" + "/** @return {number} */ function g() { return new F(); }", null, DisambiguateProperties.Warnings.INVALIDATION); assertTrue(getLastCompiler().getErrors()[0].toString() .contains("Consider fixing errors")); } public void runFindHighestTypeInChain() { // Check that this doesn't go into an infinite loop. DisambiguateProperties.forJSTypeSystem(new Compiler(), Maps.<String, CheckLevel>newHashMap()) .getTypeWithProperty("no", new JSTypeRegistry(new TestErrorReporter(null, null)) .getNativeType(JSTypeNative.OBJECT_PROTOTYPE)); } @SuppressWarnings("unchecked") private void testSets(boolean runTightenTypes, String js, String expected, String fieldTypes) { this.runTightenTypes = runTightenTypes; test(js, expected); assertEquals( fieldTypes, mapToString(lastPass.getRenamedTypesForTesting())); } @SuppressWarnings("unchecked") private void testSets(boolean runTightenTypes, String externs, String js, String expected, String fieldTypes) { testSets(runTightenTypes, externs, js, expected, fieldTypes, null, null); } @SuppressWarnings("unchecked") private void testSets(boolean runTightenTypes, String externs, String js, String expected, String fieldTypes, DiagnosticType warning, String description) { this.runTightenTypes = runTightenTypes; test(externs, js, expected, null, warning, description); assertEquals( fieldTypes, mapToString(lastPass.getRenamedTypesForTesting())); } /** * Compiles the code and checks that the set of types for each field matches * the expected value. * * <p>The format for the set of types for fields is: * {field=[[Type1, Type2]]} */ private void testSets(boolean runTightenTypes, String js, String fieldTypes) { this.runTightenTypes = runTightenTypes; test(js, null, null, null); assertEquals(fieldTypes, mapToString(lastPass.getRenamedTypesForTesting())); } /** * Compiles the code and checks that the set of types for each field matches * the expected value. * * <p>The format for the set of types for fields is: * {field=[[Type1, Type2]]} */ private void testSets(boolean runTightenTypes, String js, String fieldTypes, DiagnosticType warning) { this.runTightenTypes = runTightenTypes; test(js, null, null, warning); assertEquals(fieldTypes, mapToString(lastPass.getRenamedTypesForTesting())); } /** Sorts the map and converts to a string for comparison purposes. */ private <T> String mapToString(Multimap<String, Collection<T>> map) { TreeMap<String, String> retMap = Maps.newTreeMap(); for (String key : map.keySet()) { TreeSet<String> treeSet = Sets.newTreeSet(); for (Collection<T> collection : map.get(key)) { Set<String> subSet = Sets.newTreeSet(); for (T type : collection) { subSet.add(type.toString()); } treeSet.add(subSet.toString()); } retMap.put(key, treeSet.toString()); } return retMap.toString(); } }
/* * Copyright 2007 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import junit.framework.TestCase; public class DotFormatterTest extends TestCase { /** * Tests that keys are assigned sequentially. */ public void testKeyAssignementSequential() throws Exception { DotFormatter dot = DotFormatter.newInstanceForTesting(); assertEquals(0, dot.key(new Node(Token.BLOCK))); assertEquals(1, dot.key(new Node(Token.BLOCK))); assertEquals(2, dot.key(new Node(Token.BLOCK))); assertEquals(3, dot.key(new Node(Token.BLOCK))); assertEquals(4, dot.key(new Node(Token.BLOCK))); } /** * Tests that keys are assigned once per node. */ public void testKeyAssignementOncePerNode() throws Exception { DotFormatter dot = DotFormatter.newInstanceForTesting(); Node node0 = new Node(Token.BLOCK); Node node1 = new Node(Token.BLOCK); Node node2 = new Node(Token.BLOCK); assertEquals(0, dot.key(node0)); assertEquals(1, dot.key(node1)); assertEquals(2, dot.key(node2)); assertEquals(0, dot.key(node0)); assertEquals(1, dot.key(node1)); assertEquals(2, dot.key(node2)); } /** * Tests the formatting (simple tree). */ public void testToDotSimple() throws Exception { Node ast = new Node(Token.BITOR); String expected = "digraph AST {\n" + " node [color=lightblue2, style=filled];\n" + " node0 [label=\"BITOR\"];\n" + "}\n"; test(expected, ast); } /** * Tests the formatting (3 element tree). */ public void testToDot3Elements() throws Exception { Node ast = new Node(Token.BLOCK); ast.addChildToBack(new Node(Token.NAME)); ast.addChildToBack(new Node(Token.STRING)); String expected = "digraph AST {\n" + " node [color=lightblue2, style=filled];\n" + " node0 [label=\"BLOCK\"];\n" + " node1 [label=\"NAME\"];\n" + " node0 -> node1 [weight=1];\n" + " node2 [label=\"STRING\"];\n" + " node0 -> node2 [weight=1];\n" + "}\n"; test(expected, ast); } private void test(String expected, Node ast) { try { assertEquals(expected, DotFormatter.toDot(ast)); } catch (java.io.IOException e) { fail("Tests failed with IOExceptions"); } } }
/* * Copyright 2011 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Tests for {@link ExpandJqueryAliases} */ public class ExpandJqueryAliasesTest extends CompilerTestCase { private JqueryCodingConvention conv = new JqueryCodingConvention(); final DiagnosticType NAME_ERROR = ExpandJqueryAliases.JQUERY_UNABLE_TO_EXPAND_INVALID_NAME_ERROR; final DiagnosticType INVALID_LIT_ERROR = ExpandJqueryAliases.JQUERY_UNABLE_TO_EXPAND_INVALID_LIT_ERROR; final DiagnosticType USELESS_EACH_ERROR = ExpandJqueryAliases.JQUERY_USELESS_EACH_EXPANSION; public ExpandJqueryAliasesTest() {} @Override protected CompilerPass getProcessor(Compiler compiler) { compiler.options.setCodingConvention(conv); return new ExpandJqueryAliases(compiler); } public void testJqueryFnAliasExpansion() { String setupCode = "var jQuery={};jQuery.fn=jQuery.prototype;"; testSame(setupCode); test(setupCode + "jQuery.fn.foo='bar';", setupCode + "jQuery.prototype.foo='bar';"); test(setupCode + "jQuerySub.fn.foo='bar';", setupCode + "jQuerySub.prototype.foo='bar';"); } public void testJqueryExtendExpansion() { String setupCode = "var jQuery={},obj2={};"; // test for extend call that should not be expanded - no arguments testSame(setupCode + "jQuery.extend()"); // test for extend call that should not be expanded - empty argument // this statement has no effect in actual code testSame(setupCode + "jQuery.extend({})"); // test single argument call - should assign to the jQuery namespace test(setupCode + "jQuery.extend({a:'test'})", setupCode + "{jQuery.a = 'test';}"); // test expansion when extending the jQuery prototype test(setupCode + "jQuery.fn=jQuery.prototype;" + "jQuery.fn.extend({a:'test', b:'test2'});", setupCode + "jQuery.fn=jQuery.prototype;" + "{jQuery.prototype.a = 'test'; jQuery.prototype.b = 'test2';}"); // Expand the extension of obj2 test(setupCode + "jQuery.extend(obj2, {a:'test', b:'test2'});", setupCode + "{obj2=obj2||{}; obj2.a='test'; obj2.b='test2';}"); // Expand the jQuery namespace - 2 argument call // Must ensure that the first argument is defined test(setupCode + "jQuery.extend(jQuery,{a:'test', b:'test2'});", setupCode + "{jQuery = jQuery || {}; jQuery.a = 'test';" + "jQuery.b = 'test2';}"); // Test extend call where first argument includes a method call testSame(setupCode+"obj2.meth=function() { return { a:{} }; };" + "jQuery.extend(obj2.meth().a, {a: 'test'});"); } public void testJqueryExpandedEachExpansion() { String setupCode = "var jQuery={};" + "jQuery.expandedEach=function(vals, callback){};"; testSame(setupCode); // Test expansion with object literal test(setupCode + "jQuery.expandedEach({'a': 1, 'b': 2, 'c': 8}," + "function(key, val) { var a = key; jQuery[key] = val; });", setupCode + "(function(){ var a = 'a'; jQuery.a = 1 })();" + "(function(){ var a = 'b'; jQuery.b = 2 })();" + "(function(){ var a = 'c'; jQuery.c = 8 })();"); // Test expansion with array literal // For array literals, the key parameter will be the element index number // and the value parameter will be the string literal. In this case, the // string literal value should become a property name. test(setupCode + "jQuery.expandedEach(['a', 'b', 'c']," + "function(key, val){ jQuery[val] = key; });", setupCode + "(function(){ jQuery.a = 0; })();" + "(function(){ jQuery.b = 1; })();" + "(function(){ jQuery.c = 2 })();"); // Test expansion with object literal using 'this' keyword test(setupCode + "jQuery.expandedEach({'a': 1, 'b': 2, 'c': 8}," + "function(key, val) { var a = key; jQuery[key] = this; });", setupCode + "(function(){ var a = 'a'; jQuery.a = 1 })();" + "(function(){ var a = 'b'; jQuery.b = 2 })();" + "(function(){ var a = 'c'; jQuery.c = 8 })();"); // Test expansion with array literal using 'this' keyword test(setupCode + "jQuery.expandedEach(['a', 'b', 'c']," + "function(key, val){ jQuery[this] = key; });", setupCode + "(function(){ jQuery.a = 0; })();" + "(function(){ jQuery.b = 1; })();" + "(function(){ jQuery.c = 2 })();"); // test nested function using argument name to shadow callback name test(setupCode + "jQuery.expandedEach(['a'], function(key,val) {" + "jQuery[val] = key; (function(key) { jQuery[key] = 1;})('test'); })", setupCode + "(function(){ jQuery.a = 0;" + "(function(key){ jQuery[key] = 1})('test') })()"); // test nested function using var name to shadow callback name test(setupCode + "jQuery.expandedEach(['a'], function(key,val) {" + "jQuery[val] = key; (function(key) { var val = 2;" + "jQuery[key] = val;})('test');})", setupCode + "(function(){" + "jQuery.a=0;" + "(function(key){var val = 2; jQuery[key] = val;})('test')})()"); // test nested function using function name to shadow callback name test(setupCode + "jQuery.expandedEach(['a'], function(key,val) {" + "jQuery[val] = key; (function(key1) {" + "function key() {}; key();" + "})('test');})", setupCode + "(function(){" + "jQuery.a=0;(function(key1) {" + "function key() {}; key(); })('test')})()"); // test using return val test(setupCode + "alert(jQuery.expandedEach(['a']," + "function(key,val) { jQuery[val] = key;})[0])", setupCode + "alert((function(){" + "(function(){ jQuery.a = 0;})(); return ['a']})()[0]);"); // Loop object is a variable. Test that warning is raised. testSame(setupCode + "var a = ['a'];" + "jQuery.expandedEach(a, function(key,val){ jQuery[key]=val; })", INVALID_LIT_ERROR); // Invalid property name. Test that warning is raised. testSame(setupCode + "var obj2={};" + "jQuery.expandedEach(['foo','bar'], function(i, name) {" + "obj2[ '[object ' + name + ']' ] = 'a';});", NAME_ERROR, true); // Useless expansion (key not used). Test that warning is raised. testSame(setupCode + "var obj2={};" + "jQuery.expandedEach(['foo','bar'], function(i, name) {" + "obj2[i] = 1;});", USELESS_EACH_ERROR, false); } }
/* * Copyright 2006 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Unit tests for {@link ExploitAssigns} * * @author nicksantos@google.com (Nick Santos) * @author acleung@google.com (Alan Leung) */ public class ExploitAssignsTest extends CompilerTestCase { public void testExprExploitationTypes() { test("a = true; b = true", "b = a = true"); test("a = !0; b = !0", "b = a = !0"); test("a = !1; b = !1", "b = a = !1"); test("a = void 0; b = void 0", "b = a = void 0"); test("a = -Infinity; b = -Infinity", "b = a = -Infinity"); } public void testExprExploitationTypes2() { test("a = !0; b = !0", "b = a = !0"); } public void testExprExploitation() { test("a = null; b = null; var c = b", "var c = b = a = null"); test("a = null; b = null", "b = a = null"); test("a = undefined; b = undefined", "b = a = undefined"); test("a = 0; b = 0", "b=a=0"); test("a = 'foo'; b = 'foo'", "b = a = \"foo\""); test("a = c; b = c", "b=a=c"); testSame("a = 0; b = 1"); testSame("a = \"foo\"; b = \"foox\""); test("a = null; a && b;", "(a = null)&&b"); test("a = null; a || b;", "(a = null)||b"); test("a = null; a ? b : c;", "(a = null) ? b : c"); test("a = null; this.foo = null;", "this.foo = a = null"); test("function f(){ a = null; return null; }", "function f(){return a = null}"); test("a = true; if (a) { foo(); }", "if (a = true) { foo() }"); test("a = true; if (a && a) { foo(); }", "if ((a = true) && a) { foo() }"); test("a = false; if (a) { foo(); }", "if (a = false) { foo() }"); test("a = !0; if (a) { foo(); }", "if (a = !0) { foo() }"); test("a = !0; if (a && a) { foo(); }", "if ((a = !0) && a) { foo() }"); test("a = !1; if (a) { foo(); }", "if (a = !1) { foo() }"); testSame("a = this.foo; a();"); test("a = b; b = a;", "b = a = b"); testSame("a = b; a.c = a"); test("this.foo = null; this.bar = null;", "this.bar = this.foo = null"); test("this.foo = null; this.bar = null; this.baz = this.bar", "this.baz = this.bar = this.foo = null"); test("this.foo = null; a = null;", "a = this.foo = null"); test("this.foo = null; a = this.foo;", "a = this.foo = null"); test("a.b.c=null; a=null;", "a = a.b.c = null"); testSame("a = null; a.b.c = null"); test("(a=b).c = null; this.b = null;", "this.b = (a=b).c = null"); testSame("if(x) a = null; else b = a"); } public void testNestedExprExploitation() { test("this.foo = null; this.bar = null; this.baz = null;", "this.baz = this.bar = this.foo = null"); test("a = 3; this.foo = a; this.bar = a; this.baz = 3;", "this.baz = this.bar = this.foo = a = 3"); test("a = 3; this.foo = a; this.bar = this.foo; this.baz = a;", "this.baz = this.bar = this.foo = a = 3"); test("a = 3; this.foo = a; this.bar = 3; this.baz = this.foo;", "this.baz = this.bar = this.foo = a = 3"); test("a = 3; this.foo = a; a = 3; this.bar = 3; " + "a = 3; this.baz = this.foo;", "this.baz = a = this.bar = a = this.foo = a = 3"); test("a = 4; this.foo = a; a = 3; this.bar = 3; " + "a = 3; this.baz = this.foo;", "this.foo = a = 4; a = this.bar = a = 3; this.baz = this.foo"); test("a = 3; this.foo = a; a = 4; this.bar = 3; " + "a = 3; this.baz = this.foo;", "this.foo = a = 3; a = 4; a = this.bar = 3; this.baz = this.foo"); test("a = 3; this.foo = a; a = 3; this.bar = 3; " + "a = 4; this.baz = this.foo;", "this.bar = a = this.foo = a = 3; a = 4; this.baz = this.foo"); } public void testBug1840071() { // Some external properties are implemented as setters. Let's // make sure that we don't collapse them inappropriately. test("a.b = a.x; if (a.x) {}", "if (a.b = a.x) {}"); testSame("a.b = a.x; if (a.b) {}"); test("a.b = a.c = a.x; if (a.x) {}", "if (a.b = a.c = a.x) {}"); testSame("a.b = a.c = a.x; if (a.c) {}"); testSame("a.b = a.c = a.x; if (a.b) {}"); } public void testBug2072343() { testSame("a = a.x;a = a.x"); testSame("a = a.x;b = a.x"); test("b = a.x;a = a.x", "a = b = a.x"); testSame("a.x = a;a = a.x"); testSame("a.b = a.b.x;a.b = a.b.x"); testSame("a.y = a.y.x;b = a.y;c = a.y.x"); test("a = a.x;b = a;c = a.x", "b = a = a.x;c = a.x"); test("b = a.x;a = b;c = a.x", "a = b = a.x;c = a.x"); } public void testBadCollapseIntoCall() { // Can't collapse this, because if we did, 'foo' would be called // in the wrong 'this' context. testSame("this.foo = function() {}; this.foo();"); } public void testBadCollapse() { testSame("this.$e$ = []; this.$b$ = null;"); } @Override protected CompilerPass getProcessor(Compiler compiler) { return new PeepholeOptimizationsPass(compiler,new ExploitAssigns()); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Tests for ExportTestFunctions. * */ public class ExportTestFunctionsTest extends CompilerTestCase { private static final String EXTERNS = "function google_exportSymbol(a, b) {}; " + "function google_exportProperty(a, b, c) {};"; private static final String TEST_FUNCTIONS_WITH_NAMES = "function Foo(arg) {}; " + "function setUp(arg3) {}; " + "function tearDown(arg, arg2) {}; " + "function testBar(arg) {}"; public ExportTestFunctionsTest() { super(EXTERNS); } @Override public void setUp() { super.enableLineNumberCheck(false); } @Override protected CompilerPass getProcessor(Compiler compiler) { return new ExportTestFunctions(compiler, "google_exportSymbol", "google_exportProperty"); } @Override protected int getNumRepetitions() { // This pass only runs once. return 1; } public void testFunctionsAreExported() { test(TEST_FUNCTIONS_WITH_NAMES, "function Foo(arg){}; " + "function setUp(arg3){} google_exportSymbol(\"setUp\",setUp);; " + "function tearDown(arg,arg2) {} " + "google_exportSymbol(\"tearDown\",tearDown);; " + "function testBar(arg){} google_exportSymbol(\"testBar\",testBar)" ); } // Helper functions public void testBasicTestFunctionsAreExported() { test("function Foo() {function testA() {}}", "function Foo() {function testA(){}}"); test("function setUp() {}", "function setUp(){} google_exportSymbol('setUp',setUp)"); test("function setUpPage() {}", "function setUpPage(){} google_exportSymbol('setUpPage',setUpPage)"); test("function tearDown() {}", "function tearDown(){} google_exportSymbol('tearDown',tearDown)"); test("function tearDownPage() {}", "function tearDownPage(){} google_exportSymbol('tearDownPage'," + "tearDownPage)"); test("function testBar() { function testB() {}}", "function testBar(){function testB(){}}" + "google_exportSymbol('testBar',testBar)"); testSame("var testCase = {}; testCase.setUpPage = function() {}"); } /** * Make sure this works for global functions declared as function expressions: * <pre> * var testFunctionName = function() { * // Implementation * }; * </pre> * This format should be supported in addition to function statements. */ public void testFunctionExpressionsAreExported() { test("var Foo = function() {var testA = function() {}}", "var Foo = function() {var testA = function() {}}"); test("var setUp = function() {}", "var setUp = function() {}; " + "google_exportSymbol('setUp',setUp)"); test("var setUpPage = function() {}", "var setUpPage = function() {}; " + "google_exportSymbol('setUpPage',setUpPage)"); test("var tearDown = function() {}", "var tearDown = function() {}; " + "google_exportSymbol('tearDown',tearDown)"); test("var tearDownPage = function() {}", "var tearDownPage = function() {}; " + "google_exportSymbol('tearDownPage', tearDownPage)"); test("var testBar = function() { var testB = function() {}}", "var testBar = function(){ var testB = function() {}}; " + "google_exportSymbol('testBar',testBar)"); } public void testFunctionAssignmentsAreExported() { test("Foo = {}; Foo.prototype.bar = function() {};", "Foo = {}; Foo.prototype.bar = function() {};"); test("Foo = {}; Foo.prototype.setUpPage = function() {};", "Foo = {}; Foo.prototype.setUpPage = function() {};" + "google_exportProperty(Foo.prototype, 'setUpPage', " + "Foo.prototype.setUpPage);"); test("Foo = {}; Foo.prototype.testBar = function() {};", "Foo = {}; Foo.prototype.testBar = function() {};" + "google_exportProperty(Foo.prototype, 'testBar', " + "Foo.prototype.testBar);"); test("Foo = {}; Foo.prototype.testBar = function() " + "{ var testBaz = function() {}};", "Foo = {}; Foo.prototype.testBar = function() " + "{ var testBaz = function() {}};" + "google_exportProperty(Foo.prototype, 'testBar', " + "Foo.prototype.testBar);"); test("Foo = {}; Foo.baz.prototype.testBar = function() " + "{ var testBaz = function() {}};", "Foo = {}; Foo.baz.prototype.testBar = function() " + "{ var testBaz = function() {}};" + "google_exportProperty(Foo.baz.prototype, 'testBar', " + "Foo.baz.prototype.testBar);"); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.Sets; import com.google.javascript.jscomp.CompilerOptions.LanguageMode; import com.google.javascript.jscomp.ExpressionDecomposer.DecompositionType; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import junit.framework.TestCase; import java.util.Set; import javax.annotation.Nullable; /** * Unit tests for ExpressionDecomposer * @author johnlenz@google.com (John Lenz) */ public class ExpressionDecomposerTest extends TestCase { // Note: functions "foo" and "goo" are external functions // in the helper. public void testCanExposeExpression1() { // Can't move or decompose some classes of expressions. helperCanExposeExpression( DecompositionType.UNDECOMPOSABLE, "while(foo());", "foo"); helperCanExposeExpression( DecompositionType.UNDECOMPOSABLE, "while(x = goo()&&foo()){}", "foo"); helperCanExposeExpression( DecompositionType.UNDECOMPOSABLE, "while(x += goo()&&foo()){}", "foo"); helperCanExposeExpression( DecompositionType.UNDECOMPOSABLE, "do{}while(foo());", "foo"); helperCanExposeExpression( DecompositionType.UNDECOMPOSABLE, "for(;foo(););", "foo"); // This case could be supported for loops without conditional continues // by moving the increment into the loop body. helperCanExposeExpression( DecompositionType.UNDECOMPOSABLE, "for(;;foo());", "foo"); // FOR initializer could be supported but they never occur // as they are normalized away. // This is potentially doable but a bit too complex currently. helperCanExposeExpression( DecompositionType.UNDECOMPOSABLE, "switch(1){case foo():;}", "foo"); } public void testCanExposeExpression2() { helperCanExposeExpression( DecompositionType.MOVABLE, "foo()", "foo"); helperCanExposeExpression( DecompositionType.MOVABLE, "x = foo()", "foo"); helperCanExposeExpression( DecompositionType.MOVABLE, "var x = foo()", "foo"); helperCanExposeExpression( DecompositionType.MOVABLE, "if(foo()){}", "foo"); helperCanExposeExpression( DecompositionType.MOVABLE, "switch(foo()){}", "foo"); helperCanExposeExpression( DecompositionType.MOVABLE, "switch(foo()){}", "foo"); helperCanExposeExpression( DecompositionType.MOVABLE, "function f(){ return foo();}", "foo"); helperCanExposeExpression( DecompositionType.MOVABLE, "x = foo() && 1", "foo"); helperCanExposeExpression( DecompositionType.MOVABLE, "x = foo() || 1", "foo"); helperCanExposeExpression( DecompositionType.MOVABLE, "x = foo() ? 0 : 1", "foo"); helperCanExposeExpression( DecompositionType.MOVABLE, "(function(a){b = a})(foo())", "foo"); } public void testCanExposeExpression3() { helperCanExposeExpression( DecompositionType.DECOMPOSABLE, "x = 0 && foo()", "foo"); helperCanExposeExpression( DecompositionType.DECOMPOSABLE, "x = 1 || foo()", "foo"); helperCanExposeExpression( DecompositionType.DECOMPOSABLE, "var x = 1 ? foo() : 0", "foo"); helperCanExposeExpression( DecompositionType.DECOMPOSABLE, "goo() && foo()", "foo"); helperCanExposeExpression( DecompositionType.DECOMPOSABLE, "x = goo() && foo()", "foo"); helperCanExposeExpression( DecompositionType.DECOMPOSABLE, "x += goo() && foo()", "foo"); helperCanExposeExpression( DecompositionType.DECOMPOSABLE, "var x = goo() && foo()", "foo"); helperCanExposeExpression( DecompositionType.DECOMPOSABLE, "if(goo() && foo()){}", "foo"); helperCanExposeExpression( DecompositionType.DECOMPOSABLE, "switch(goo() && foo()){}", "foo"); helperCanExposeExpression( DecompositionType.DECOMPOSABLE, "switch(goo() && foo()){}", "foo"); helperCanExposeExpression( DecompositionType.DECOMPOSABLE, "switch(x = goo() && foo()){}", "foo"); helperCanExposeExpression( DecompositionType.DECOMPOSABLE, "function f(){ return goo() && foo();}", "foo"); } public void testCanExposeExpression4() { // 'this' must be preserved in call. helperCanExposeExpression( DecompositionType.UNDECOMPOSABLE, "if (goo.a(1, foo()));", "foo"); } public void testCanExposeExpression5() { // 'this' must be preserved in call. helperCanExposeExpression( DecompositionType.UNDECOMPOSABLE, "if (goo['a'](foo()));", "foo"); } public void testCanExposeExpression6() { // 'this' must be preserved in call. helperCanExposeExpression( DecompositionType.UNDECOMPOSABLE, "z:if (goo.a(1, foo()));", "foo"); } public void testCanExposeExpression7() { // Verify calls to function expressions are movable. helperCanExposeFunctionExpression( DecompositionType.MOVABLE, "(function(map){descriptions_=map})(\n" + "function(){\n" + "var ret={};\n" + "ret[INIT]='a';\n" + "ret[MIGRATION_BANNER_DISMISS]='b';\n" + "return ret\n" + "}()\n" + ");", 2); } public void testCanExposeExpression8() { // Can it be decompose? helperCanExposeExpression( DecompositionType.DECOMPOSABLE, "HangoutStarter.prototype.launchHangout = function() {\n" + " var self = a.b;\n" + " var myUrl = new goog.Uri(getDomServices_(self).getDomHelper()." + "getWindow().location.href);\n" + "};", "getDomServices_"); // Verify it is properly expose the target expression. helperExposeExpression( "HangoutStarter.prototype.launchHangout = function() {\n" + " var self = a.b;\n" + " var myUrl = new goog.Uri(getDomServices_(self).getDomHelper()." + "getWindow().location.href);\n" + "};", "getDomServices_", "HangoutStarter.prototype.launchHangout = function() {" + " var self = a.b;" + " var temp_const$$0 = goog.Uri;" + " var myUrl = new temp_const$$0(getDomServices_(self)." + " getDomHelper().getWindow().location.href)}"); // Verify the results can be properly moved. helperMoveExpression( "HangoutStarter.prototype.launchHangout = function() {" + " var self = a.b;" + " var temp_const$$0 = goog.Uri;" + " var myUrl = new temp_const$$0(getDomServices_(self)." + " getDomHelper().getWindow().location.href)}", "getDomServices_", "HangoutStarter.prototype.launchHangout = function() {" + " var self=a.b;" + " var temp_const$$0=goog.Uri;" + " var result$$0=getDomServices_(self);" + " var myUrl=new temp_const$$0(result$$0.getDomHelper()." + " getWindow().location.href)}"); } public void testMoveExpression1() { // There isn't a reason to do this, but it works. helperMoveExpression("foo()", "foo", "var result$$0 = foo(); result$$0;"); } public void testMoveExpression2() { helperMoveExpression( "x = foo()", "foo", "var result$$0 = foo(); x = result$$0;"); } public void testMoveExpression3() { helperMoveExpression( "var x = foo()", "foo", "var result$$0 = foo(); var x = result$$0;"); } public void testMoveExpression4() { helperMoveExpression( "if(foo()){}", "foo", "var result$$0 = foo(); if (result$$0);"); } public void testMoveExpression5() { helperMoveExpression( "switch(foo()){}", "foo", "var result$$0 = foo(); switch(result$$0){}"); } public void testMoveExpression6() { helperMoveExpression( "switch(1 + foo()){}", "foo", "var result$$0 = foo(); switch(1 + result$$0){}"); } public void testMoveExpression7() { helperMoveExpression( "function f(){ return foo();}", "foo", "function f(){ var result$$0 = foo(); return result$$0;}"); } public void testMoveExpression8() { helperMoveExpression( "x = foo() && 1", "foo", "var result$$0 = foo(); x = result$$0 && 1"); } public void testMoveExpression9() { helperMoveExpression( "x = foo() || 1", "foo", "var result$$0 = foo(); x = result$$0 || 1"); } public void testMoveExpression10() { helperMoveExpression( "x = foo() ? 0 : 1", "foo", "var result$$0 = foo(); x = result$$0 ? 0 : 1"); } /* Decomposition tests. */ public void testExposeExpression1() { helperExposeExpression( "x = 0 && foo()", "foo", "var temp$$0; if (temp$$0 = 0) temp$$0 = foo(); x = temp$$0;"); } public void testExposeExpression2() { helperExposeExpression( "x = 1 || foo()", "foo", "var temp$$0; if (temp$$0 = 1); else temp$$0 = foo(); x = temp$$0;"); } public void testExposeExpression3() { helperExposeExpression( "var x = 1 ? foo() : 0", "foo", "var temp$$0;" + " if (1) temp$$0 = foo(); else temp$$0 = 0;var x = temp$$0;"); } public void testExposeExpression4() { helperExposeExpression( "goo() && foo()", "foo", "if (goo()) foo();"); } public void testExposeExpression5() { helperExposeExpression( "x = goo() && foo()", "foo", "var temp$$0; if (temp$$0 = goo()) temp$$0 = foo(); x = temp$$0;"); } public void testExposeExpression6() { helperExposeExpression( "var x = 1 + (goo() && foo())", "foo", "var temp$$0; if (temp$$0 = goo()) temp$$0 = foo();" + "var x = 1 + temp$$0;"); } public void testExposeExpression7() { helperExposeExpression( "if(goo() && foo());", "foo", "var temp$$0;" + "if (temp$$0 = goo()) temp$$0 = foo();" + "if(temp$$0);"); } public void testExposeExpression8() { helperExposeExpression( "switch(goo() && foo()){}", "foo", "var temp$$0;" + "if (temp$$0 = goo()) temp$$0 = foo();" + "switch(temp$$0){}"); } public void testExposeExpression9() { helperExposeExpression( "switch(1 + goo() + foo()){}", "foo", "var temp_const$$0 = 1 + goo();" + "switch(temp_const$$0 + foo()){}"); } public void testExposeExpression10() { helperExposeExpression( "function f(){ return goo() && foo();}", "foo", "function f(){" + "var temp$$0; if (temp$$0 = goo()) temp$$0 = foo();" + "return temp$$0;" + "}"); } public void testExposeExpression11() { // TODO(johnlenz): We really want a constant marking pass. // The value "goo" should be constant, but it isn't known to be so. helperExposeExpression( "if (goo(1, goo(2), (1 ? foo() : 0)));", "foo", "var temp_const$$1 = goo;" + "var temp_const$$0 = goo(2);" + "var temp$$2;" + "if (1) temp$$2 = foo(); else temp$$2 = 0;" + "if (temp_const$$1(1, temp_const$$0, temp$$2));"); } // Simple name on LHS of assignment-op. public void testExposePlusEquals1() { helperExposeExpression( "var x = 0; x += foo() + 1", "foo", "var x = 0; var temp_const$$0 = x;" + "x = temp_const$$0 + (foo() + 1);"); helperExposeExpression( "var x = 0; y = (x += foo()) + x", "foo", "var x = 0; var temp_const$$0 = x;" + "y = (x = temp_const$$0 + foo()) + x"); } // Structure on LHS of assignment-op. public void testExposePlusEquals2() { helperExposeExpression( "var x = {}; x.a += foo() + 1", "foo", "var x = {}; var temp_const$$0 = x;" + "var temp_const$$1 = temp_const$$0.a;" + "temp_const$$0.a = temp_const$$1 + (foo() + 1);"); helperExposeExpression( "var x = {}; y = (x.a += foo()) + x.a", "foo", "var x = {}; var temp_const$$0 = x;" + "var temp_const$$1 = temp_const$$0.a;" + "y = (temp_const$$0.a = temp_const$$1 + foo()) + x.a"); } // Constant object on LHS of assignment-op. public void testExposePlusEquals3() { helperExposeExpression( "/** @const */ var XX = {};\n" + "XX.a += foo() + 1", "foo", "var XX = {}; var temp_const$$0 = XX.a;" + "XX.a = temp_const$$0 + (foo() + 1);"); helperExposeExpression( "var XX = {}; y = (XX.a += foo()) + XX.a", "foo", "var XX = {}; var temp_const$$0 = XX.a;" + "y = (XX.a = temp_const$$0 + foo()) + XX.a"); } // Function all on LHS of assignment-op. public void testExposePlusEquals4() { helperExposeExpression( "var x = {}; goo().a += foo() + 1", "foo", "var x = {};" + "var temp_const$$0 = goo();" + "var temp_const$$1 = temp_const$$0.a;" + "temp_const$$0.a = temp_const$$1 + (foo() + 1);"); helperExposeExpression( "var x = {}; y = (goo().a += foo()) + goo().a", "foo", "var x = {};" + "var temp_const$$0 = goo();" + "var temp_const$$1 = temp_const$$0.a;" + "y = (temp_const$$0.a = temp_const$$1 + foo()) + goo().a"); } // Test multiple levels public void testExposePlusEquals5() { helperExposeExpression( "var x = {}; goo().a.b += foo() + 1", "foo", "var x = {};" + "var temp_const$$0 = goo().a;" + "var temp_const$$1 = temp_const$$0.b;" + "temp_const$$0.b = temp_const$$1 + (foo() + 1);"); helperExposeExpression( "var x = {}; y = (goo().a.b += foo()) + goo().a", "foo", "var x = {};" + "var temp_const$$0 = goo().a;" + "var temp_const$$1 = temp_const$$0.b;" + "y = (temp_const$$0.b = temp_const$$1 + foo()) + goo().a"); } public void testExposeObjectLit1() { // Validate that getter and setters methods are see as side-effect // free and that values can move past them. We don't need to be // concerned with exposing the getter or setter here but the // decomposer does not have a method of exposing properties only variables. helperMoveExpression( "var x = {get a() {}, b: foo()};", "foo", "var result$$0=foo();var x = {get a() {}, b: result$$0};"); helperMoveExpression( "var x = {set a(p) {}, b: foo()};", "foo", "var result$$0=foo();var x = {set a(p) {}, b: result$$0};"); } /** Test case helpers. */ private void helperCanExposeExpression( DecompositionType expectedResult, String code, String fnName ) { helperCanExposeExpression(expectedResult, code, fnName, null); } private void helperCanExposeFunctionExpression( DecompositionType expectedResult, String code, int call) { Compiler compiler = getCompiler(); Set<String> knownConstants = Sets.newHashSet(); ExpressionDecomposer decomposer = new ExpressionDecomposer( compiler, compiler.getUniqueNameIdSupplier(), knownConstants); Node tree = parse(compiler, code); assertNotNull(tree); Node externsRoot = parse(compiler, "function goo() {}" + "function foo() {}"); assertNotNull(externsRoot); Node mainRoot = tree; Node callSite = findCall(tree, null, 2); assertNotNull("Call " + call + " was not found.", callSite); compiler.resetUniqueNameId(); DecompositionType result = decomposer.canExposeExpression( callSite); assertEquals(expectedResult, result); } private void helperCanExposeExpression( DecompositionType expectedResult, String code, String fnName, Set<String> knownConstants ) { Compiler compiler = getCompiler(); if (knownConstants == null) { knownConstants = Sets.newHashSet(); } ExpressionDecomposer decomposer = new ExpressionDecomposer( compiler, compiler.getUniqueNameIdSupplier(), knownConstants); Node tree = parse(compiler, code); assertNotNull(tree); Node externsRoot = parse(compiler, "function goo() {}" + "function foo() {}"); assertNotNull(externsRoot); Node mainRoot = tree; Node callSite = findCall(tree, fnName); assertNotNull("Call to " + fnName + " was not found.", callSite); compiler.resetUniqueNameId(); DecompositionType result = decomposer.canExposeExpression( callSite); assertEquals(expectedResult, result); } private void helperExposeExpression( String code, String fnName, String expectedResult ) { helperExposeExpression( code, fnName, expectedResult, null); } private void validateSourceInfo(Compiler compiler, Node subtree) { (new LineNumberCheck(compiler)).setCheckSubTree(subtree); // Source information problems are reported as compiler errors. if (compiler.getErrorCount() != 0) { String msg = "Error encountered: "; for (JSError err : compiler.getErrors()) { msg += err.toString() + "\n"; } assertTrue(msg, compiler.getErrorCount() == 0); } } private void helperExposeExpression( String code, String fnName, String expectedResult, Set<String> knownConstants ) { Compiler compiler = getCompiler(); if (knownConstants == null) { knownConstants = Sets.newHashSet(); } ExpressionDecomposer decomposer = new ExpressionDecomposer( compiler, compiler.getUniqueNameIdSupplier(), knownConstants); decomposer.setTempNamePrefix("temp"); decomposer.setResultNamePrefix("result"); Node expectedRoot = parse(compiler, expectedResult); Node tree = parse(compiler, code); assertNotNull(tree); Node externsRoot = new Node(Token.EMPTY); Node mainRoot = tree; Node callSite = findCall(tree, fnName); assertNotNull("Call to " + fnName + " was not found.", callSite); DecompositionType result = decomposer.canExposeExpression(callSite); assertTrue(result == DecompositionType.DECOMPOSABLE); compiler.resetUniqueNameId(); decomposer.exposeExpression(callSite); validateSourceInfo(compiler, tree); String explanation = expectedRoot.checkTreeEquals(tree); assertNull("\nExpected: " + compiler.toSource(expectedRoot) + "\nResult: " + compiler.toSource(tree) + "\n" + explanation, explanation); } private void helperMoveExpression( String code, String fnName, String expectedResult ) { helperMoveExpression( code, fnName, expectedResult, null); } private void helperMoveExpression( String code, String fnName, String expectedResult, Set<String> knownConstants ) { Compiler compiler = getCompiler(); if (knownConstants == null) { knownConstants = Sets.newHashSet(); } ExpressionDecomposer decomposer = new ExpressionDecomposer( compiler, compiler.getUniqueNameIdSupplier(), knownConstants); decomposer.setTempNamePrefix("temp"); decomposer.setResultNamePrefix("result"); Node expectedRoot = parse(compiler, expectedResult); Node tree = parse(compiler, code); assertNotNull(tree); Node externsRoot = new Node(Token.EMPTY); Node mainRoot = tree; Node callSite = findCall(tree, fnName); assertNotNull("Call to " + fnName + " was not found.", callSite); compiler.resetUniqueNameId(); decomposer.moveExpression(callSite); validateSourceInfo(compiler, tree); String explanation = expectedRoot.checkTreeEquals(tree); assertNull("\nExpected: " + compiler.toSource(expectedRoot) + "\nResult: " + compiler.toSource(tree) + "\n" + explanation, explanation); } private static Compiler getCompiler() { Compiler compiler = new Compiler(); CompilerOptions options = new CompilerOptions(); options.setLanguageIn(LanguageMode.ECMASCRIPT5); options.setCodingConvention(new GoogleCodingConvention()); compiler.initOptions(options); return compiler; } private static Node findCall(Node n, String name) { return findCall(n, name, 1); } /** * @param name The name to look for. * @param call The call to look for. * @return The return the Nth CALL node to name found in a pre-order * traversal. */ private static Node findCall( Node root, @Nullable final String name, final int call) { class Find { int found = 0; Node find(Node n) { if (n.isCall()) { Node callee = n.getFirstChild(); if (name == null || (callee.isName() && callee.getString().equals(name))) { found++; if (found == call) { return n; } } } for (Node c : n.children()) { Node result = find(c); if (result != null) { return result; } } return null; } } return (new Find()).find(root); } private static Node parse(Compiler compiler, String js) { Node n = Normalize.parseAndNormalizeTestCode(compiler, js, ""); assertEquals(0, compiler.getErrorCount()); return n; } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.base.Joiner; import com.google.common.collect.Lists; import junit.framework.TestCase; import java.util.List; /** * Tests for {@link ExternExportsPass}. * */ public class ExternExportsPassTest extends TestCase { private boolean runCheckTypes = true; /** * ExternExportsPass relies on type information to emit JSDoc annotations for * exported externs. However, the user can disable type checking and still * ask for externs to be exported. Set this flag to enable or disable checking * of types during a test. */ private void setRunCheckTypes(boolean shouldRunCheckTypes) { runCheckTypes = shouldRunCheckTypes; } @Override public void setUp() throws Exception { super.setUp(); setRunCheckTypes(true); } public void testExportSymbol() throws Exception { compileAndCheck("var a = {}; a.b = {}; a.b.c = function(d, e, f) {};" + "goog.exportSymbol('foobar', a.b.c)", "/**\n" + " * @param {*} d\n" + " * @param {*} e\n" + " * @param {*} f\n" + " * @return {undefined}\n" + " */\n" + "var foobar = function(d, e, f) {\n};\n"); } public void testExportSymbolDefinedInVar() throws Exception { compileAndCheck("var a = function(d, e, f) {};" + "goog.exportSymbol('foobar', a)", "/**\n" + " * @param {*} d\n" + " * @param {*} e\n" + " * @param {*} f\n" + " * @return {undefined}\n" + " */\n" + "var foobar = function(d, e, f) {\n};\n"); } public void testExportProperty() throws Exception { compileAndCheck("var a = {}; a.b = {}; a.b.c = function(d, e, f) {};" + "goog.exportProperty(a.b, 'cprop', a.b.c)", "var a;\n" + "a.b;\n" + "/**\n" + " * @param {*} d\n" + " * @param {*} e\n" + " * @param {*} f\n" + " * @return {undefined}\n" + " */\n" + "a.b.cprop = function(d, e, f) {\n};\n"); } public void testExportMultiple() throws Exception { compileAndCheck("var a = {}; a.b = function(p1) {}; " + "a.b.c = function(d, e, f) {};" + "a.b.prototype.c = function(g, h, i) {};" + "goog.exportSymbol('a.b', a.b);" + "goog.exportProperty(a.b, 'c', a.b.c);" + "goog.exportProperty(a.b.prototype, 'c', a.b.prototype.c);", "var a;\n" + "/**\n" + " * @param {*} p1\n" + " * @return {undefined}\n" + " */\n" + "a.b = function(p1) {\n};\n" + "/**\n" + " * @param {*} d\n" + " * @param {*} e\n" + " * @param {*} f\n" + " * @return {undefined}\n" + " */\n" + "a.b.c = function(d, e, f) {\n};\n" + "/**\n" + " * @param {*} g\n" + " * @param {*} h\n" + " * @param {*} i\n" + " * @return {undefined}\n" + " */\n" + "a.b.prototype.c = function(g, h, i) {\n};\n"); } public void testExportMultiple2() throws Exception { compileAndCheck("var a = {}; a.b = function(p1) {}; " + "a.b.c = function(d, e, f) {};" + "a.b.prototype.c = function(g, h, i) {};" + "goog.exportSymbol('hello', a);" + "goog.exportProperty(a.b, 'c', a.b.c);" + "goog.exportProperty(a.b.prototype, 'c', a.b.prototype.c);", "/** @type {{b: function (?): undefined}} */\n" + "var hello = {};\n" + "hello.b;\n" + "/**\n" + " * @param {*} d\n" + " * @param {*} e\n" + " * @param {*} f\n" + " * @return {undefined}\n" + " */\n" + "hello.b.c = function(d, e, f) {\n};\n" + "/**\n" + " * @param {*} g\n" + " * @param {*} h\n" + " * @param {*} i\n" + " * @return {undefined}\n" + " */\n" + "hello.b.prototype.c = function(g, h, i) {\n};\n"); } public void testExportMultiple3() throws Exception { compileAndCheck("var a = {}; a.b = function(p1) {}; " + "a.b.c = function(d, e, f) {};" + "a.b.prototype.c = function(g, h, i) {};" + "goog.exportSymbol('prefix', a.b);" + "goog.exportProperty(a.b, 'c', a.b.c);", "/**\n" + " * @param {*} p1\n" + " * @return {undefined}\n" + " */\n" + "var prefix = function(p1) {\n};\n" + "/**\n" + " * @param {*} d\n" + " * @param {*} e\n" + " * @param {*} f\n" + " * @return {undefined}\n" + " */\n" + "prefix.c = function(d, e, f) {\n};\n"); } public void testExportNonStaticSymbol() throws Exception { compileAndCheck("var a = {}; a.b = {}; var d = {}; a.b.c = d;" + "goog.exportSymbol('foobar', a.b.c)", "var foobar;\n"); } public void testExportNonStaticSymbol2() throws Exception { compileAndCheck("var a = {}; a.b = {}; var d = null; a.b.c = d;" + "goog.exportSymbol('foobar', a.b.c())", "var foobar;\n"); } public void testExportNonexistentProperty() throws Exception { compileAndCheck("var a = {}; a.b = {}; a.b.c = function(d, e, f) {};" + "goog.exportProperty(a.b, 'none', a.b.none)", "var a;\n" + "a.b;\n" + "a.b.none;\n"); } public void testExportSymbolWithTypeAnnotation() { compileAndCheck("var internalName;\n" + "/**\n" + " * @param {string} param1\n" + " * @param {number} param2\n" + " * @return {string}\n" + " */\n" + "internalName = function(param1, param2) {" + "return param1 + param2;" + "};" + "goog.exportSymbol('externalName', internalName)", "/**\n" + " * @param {string} param1\n" + " * @param {number} param2\n" + " * @return {string}\n" + " */\n" + "var externalName = function(param1, param2) {\n};\n"); } public void testExportSymbolWithoutTypeCheck() { // ExternExportsPass should not emit annotations // if there is no type information available. setRunCheckTypes(false); compileAndCheck("var internalName;\n" + "/**\n" + " * @param {string} param1\n" + " * @param {number} param2\n" + " * @return {string}\n" + " */\n" + "internalName = function(param1, param2) {" + "return param1 + param2;" + "};" + "goog.exportSymbol('externalName', internalName)", "var externalName = function(param1, param2) {\n};\n"); } public void testExportSymbolWithConstructor() { compileAndCheck("var internalName;\n" + "/**\n" + " * @constructor\n" + " */\n" + "internalName = function() {" + "};" + "goog.exportSymbol('externalName', internalName)", "/**\n" + " * @return {undefined}\n" + " * @constructor\n" + " */\n" + "var externalName = function() {\n};\n"); } public void testExportSymbolWithConstructorWithoutTypeCheck() { // For now, skipping type checking should prevent generating // annotations of any kind, so, e.g., @constructor is not preserved. // This is probably not ideal, but since JSDocInfo for functions is attached // to JSTypes and not Nodes (and no JSTypes are created when checkTypes // is false), we don't really have a choice. setRunCheckTypes(false); compileAndCheck("var internalName;\n" + "/**\n" + " * @constructor\n" + " */\n" + "internalName = function() {" + "};" + "goog.exportSymbol('externalName', internalName)", "var externalName = function() {\n};\n"); } public void testExportFunctionWithOptionalArguments() { compileAndCheck("var internalName;\n" + "/**\n" + " * @param {number=} a\n" + " */\n" + "internalName = function(a) {" + " return 6;\n" + "};" + "goog.exportSymbol('externalName', internalName)", "/**\n" + " * @param {number=} a\n" + " */\n" + "var externalName = function(a) {\n};\n"); } public void testExportFunctionWithVariableArguments() { compileAndCheck("var internalName;\n" + "/**\n" + " * @param {...number} a\n" + " * @return {number}\n" + " */\n" + "internalName = function(a) {" + " return 6;\n" + "};" + "goog.exportSymbol('externalName', internalName)", "/**\n" + " * @param {...number} a\n" + " * @return {number}\n" + " */\n" + "var externalName = function(a) {\n};\n"); } /** * Enums are not currently handled. */ public void testExportEnum() { // We don't care what the values of the object properties are. // They're ignored by the type checker, and even if they weren't, it'd // be incomputable to get them correct in all cases // (think complex objects). compileAndCheck( "/** @enum {string}\n @export */ var E = {A:8, B:9};" + "goog.exportSymbol('E', E);", "/** @enum {string} */\n" + "var E = {A:1, B:2};\n"); } /** If we export a property with "prototype" as a path component, there * is no need to emit the initializer for prototype because every namespace * has one automatically. */ public void testExportDontEmitPrototypePathPrefix() { compileAndCheck( "/**\n" + " * @constructor\n" + " */\n" + "var Foo = function() {};" + "/**\n" + " * @return {number}\n" + " */\n" + "Foo.prototype.m = function() {return 6;};\n" + "goog.exportSymbol('Foo', Foo);\n" + "goog.exportProperty(Foo.prototype, 'm', Foo.prototype.m);", "/**\n" + " * @return {undefined}\n" + " * @constructor\n" + " */\n" + "var Foo = function() {\n};\n" + "/**\n" + " * @return {number}\n" + " */\n" + "Foo.prototype.m = function() {\n};\n" ); } /** * Test the workflow of creating an externs file for a library * via the export pass and then using that externs file in a client. * * There should be no warnings in the client if the library includes * type information for the exported functions and the client uses them * correctly. */ public void testUseExportsAsExterns() { String librarySource = "/**\n" + " * @param {number} a\n" + " * @constructor\n" + " */\n" + "var InternalName = function(a) {" + "};" + "goog.exportSymbol('ExternalName', InternalName)"; String clientSource = "var a = new ExternalName(6);\n" + "/**\n" + " * @param {ExternalName} x\n" + " */\n" + "var b = function(x) {};"; Result libraryCompileResult = compileAndExportExterns(librarySource); assertEquals(0, libraryCompileResult.warnings.length); assertEquals(0, libraryCompileResult.errors.length); String generatedExterns = libraryCompileResult.externExport; Result clientCompileResult = compileAndExportExterns(clientSource, generatedExterns); assertEquals(0, clientCompileResult.warnings.length); assertEquals(0, clientCompileResult.errors.length); } public void testWarnOnExportFunctionWithUnknownReturnType() { String librarySource = "var InternalName = function() {" + " return 6;" + "};" + "goog.exportSymbol('ExternalName', InternalName)"; Result libraryCompileResult = compileAndExportExterns(librarySource); assertEquals(1, libraryCompileResult.warnings.length); assertEquals(0, libraryCompileResult.errors.length); } public void testDontWarnOnExportConstructorWithUnknownReturnType() { String librarySource = "/**\n" + " * @constructor\n" + " */\n " + "var InternalName = function() {" + "};" + "goog.exportSymbol('ExternalName', InternalName)"; Result libraryCompileResult = compileAndExportExterns(librarySource); assertEquals(0, libraryCompileResult.warnings.length); assertEquals(0, libraryCompileResult.errors.length); } public void testTypedef() { compileAndCheck( "/** @typedef {{x: number, y: number}} */ var Coord;\n" + "/**\n" + " * @param {Coord} a\n" + " * @export\n" + " */\n" + "var fn = function(a) {};" + "goog.exportSymbol('fn', fn);", "/**\n" + " * @param {{x: number, y: number}} a\n" + " * @return {undefined}\n" + " */\n" + "var fn = function(a) {\n};\n"); } private void compileAndCheck(String js, String expected) { Result result = compileAndExportExterns(js); assertEquals(expected, result.externExport); } public void testWarnOnExportFunctionWithUnknownParameterTypes() { /* This source is missing types for the b and c parameters */ String librarySource = "/**\n" + " * @param {number} a\n" + " * @return {number}" + " */\n " + "var InternalName = function(a,b,c) {" + " return 6;" + "};" + "goog.exportSymbol('ExternalName', InternalName)"; Result libraryCompileResult = compileAndExportExterns(librarySource); assertEquals(2, libraryCompileResult.warnings.length); assertEquals(0, libraryCompileResult.errors.length); } private Result compileAndExportExterns(String js) { return compileAndExportExterns(js, ""); } /** * Compiles the passed in JavaScript with the passed in externs and returns * the new externs exported by the this pass. * * @param js the source to be compiled * @param externs the externs the {@code js} source needs * @return the externs generated from {@code js} */ private Result compileAndExportExterns(String js, String externs) { Compiler compiler = new Compiler(); CompilerOptions options = new CompilerOptions(); options.externExportsPath = "externs.js"; // Turn on IDE mode to get rid of optimizations. options.ideMode = true; /* Check types so we can make sure our exported externs have * type information. */ options.checkSymbols = true; options.checkTypes = runCheckTypes; List<SourceFile> inputs = Lists.newArrayList( SourceFile.fromCode("testcode", "var goog = {};" + "goog.exportSymbol = function(a, b) {}; " + "goog.exportProperty = function(a, b, c) {}; " + js)); List<SourceFile> externFiles = Lists.newArrayList( SourceFile.fromCode("externs", externs)); Result result = compiler.compile(externFiles, inputs, options); if (!result.success) { String msg = "Errors:"; msg += Joiner.on("\n").join(result.errors); assertTrue(msg, result.success); } return result; } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.jscomp.ExtractPrototypeMemberDeclarations.Pattern; /** * Tests for {@link ExtractPrototypeMemberDeclarations}. * */ public class ExtractPrototypeMemberDeclarationsTest extends CompilerTestCase { private static final String TMP = "JSCompiler_prototypeAlias"; private Pattern pattern = Pattern.USE_GLOBAL_TEMP; @Override protected void setUp() { super.enableLineNumberCheck(true); enableNormalize(); pattern = Pattern.USE_GLOBAL_TEMP; } @Override protected CompilerPass getProcessor(Compiler compiler) { return new ExtractPrototypeMemberDeclarations(compiler, pattern); } public void testNotEnoughPrototypeToExtract() { // switch statement with stuff after "return" for (int i = 0; i < 7; i++) { testSame(generatePrototypeDeclarations("x", i)); } } public void testExtractingSingleClassPrototype() { extract(generatePrototypeDeclarations("x", 7), loadPrototype("x") + generateExtractedDeclarations(7)); } public void testExtractingTwoClassPrototype() { extract( generatePrototypeDeclarations("x", 6) + generatePrototypeDeclarations("y", 6), loadPrototype("x") + generateExtractedDeclarations(6) + loadPrototype("y") + generateExtractedDeclarations(6)); } public void testExtractingTwoClassPrototypeInDifferentBlocks() { extract( generatePrototypeDeclarations("x", 6) + "if (foo()) {" + generatePrototypeDeclarations("y", 6) + "}", loadPrototype("x") + generateExtractedDeclarations(6) + "if (foo()) {" + loadPrototype("y") + generateExtractedDeclarations(6) + "}"); } public void testNoMemberDeclarations() { testSame( "x.prototype = {}; x.prototype = {}; x.prototype = {};" + "x.prototype = {}; x.prototype = {}; x.prototype = {};" + "x.prototype = {}; x.prototype = {}; x.prototype = {};"); } public void testExtractingPrototypeWithQName() { extract( generatePrototypeDeclarations("com.google.javascript.jscomp.x", 7), loadPrototype("com.google.javascript.jscomp.x") + generateExtractedDeclarations(7)); } public void testInterweaved() { testSame( "x.prototype.a=1; y.prototype.a=1;" + "x.prototype.b=1; y.prototype.b=1;" + "x.prototype.c=1; y.prototype.c=1;" + "x.prototype.d=1; y.prototype.d=1;" + "x.prototype.e=1; y.prototype.e=1;" + "x.prototype.f=1; y.prototype.f=1;"); } public void testExtractingPrototypeWithNestedMembers() { extract( "x.prototype.y.a = 1;" + "x.prototype.y.b = 1;" + "x.prototype.y.c = 1;" + "x.prototype.y.d = 1;" + "x.prototype.y.e = 1;" + "x.prototype.y.f = 1;" + "x.prototype.y.g = 1;", loadPrototype("x") + TMP + ".y.a = 1;" + TMP + ".y.b = 1;" + TMP + ".y.c = 1;" + TMP + ".y.d = 1;" + TMP + ".y.e = 1;" + TMP + ".y.f = 1;" + TMP + ".y.g = 1;"); } public void testWithDevirtualization() { extract( "x.prototype.a = 1;" + "x.prototype.b = 1;" + "function devirtualize1() { }" + "x.prototype.c = 1;" + "x.prototype.d = 1;" + "x.prototype.e = 1;" + "x.prototype.f = 1;" + "x.prototype.g = 1;", loadPrototype("x") + TMP + ".a = 1;" + TMP + ".b = 1;" + "function devirtualize1() { }" + TMP + ".c = 1;" + TMP + ".d = 1;" + TMP + ".e = 1;" + TMP + ".f = 1;" + TMP + ".g = 1;"); extract( "x.prototype.a = 1;" + "x.prototype.b = 1;" + "function devirtualize1() { }" + "x.prototype.c = 1;" + "x.prototype.d = 1;" + "function devirtualize2() { }" + "x.prototype.e = 1;" + "x.prototype.f = 1;" + "function devirtualize3() { }" + "x.prototype.g = 1;", loadPrototype("x") + TMP + ".a = 1;" + TMP + ".b = 1;" + "function devirtualize1() { }" + TMP + ".c = 1;" + TMP + ".d = 1;" + "function devirtualize2() { }" + TMP + ".e = 1;" + TMP + ".f = 1;" + "function devirtualize3() { }" + TMP + ".g = 1;"); } public void testAnonSimple() { pattern = Pattern.USE_ANON_FUNCTION; extract( generatePrototypeDeclarations("x", 3), generateExtractedDeclarations(3) + loadPrototype("x")); testSame(generatePrototypeDeclarations("x", 1)); testSame(generatePrototypeDeclarations("x", 2)); extract( generatePrototypeDeclarations("x", 7), generateExtractedDeclarations(7) + loadPrototype("x")); } public void testAnonWithDevirtualization() { pattern = Pattern.USE_ANON_FUNCTION; extract( "x.prototype.a = 1;" + "x.prototype.b = 1;" + "function devirtualize() { }" + "x.prototype.c = 1;", "(function(" + TMP + "){" + TMP + ".a = 1;" + TMP + ".b = 1;" + TMP + ".c = 1;" + loadPrototype("x") + "function devirtualize() { }"); extract( "x.prototype.a = 1;" + "function devirtualize1() { }" + "x.prototype.b = 1;" + "function devirtualize2() { }" + "x.prototype.c = 1;" + "function devirtualize3() { }", "(function(" + TMP + "){" + TMP + ".a = 1;" + TMP + ".b = 1;" + TMP + ".c = 1;" + loadPrototype("x") + "function devirtualize1() { }" + "function devirtualize2() { }" + "function devirtualize3() { }"); } public void testAnonWithSideFx() { pattern = Pattern.USE_ANON_FUNCTION; testSame( "function foo() {};" + "foo.prototype.a1 = 1;" + "bar();;" + "foo.prototype.a2 = 2;" + "bar();;" + "foo.prototype.a3 = 3;" + "bar();;" + "foo.prototype.a4 = 4;" + "bar();;" + "foo.prototype.a5 = 5;" + "bar();;" + "foo.prototype.a6 = 6;" + "bar();;" + "foo.prototype.a7 = 7;" + "bar();"); } public String loadPrototype(String qName) { if (pattern == Pattern.USE_GLOBAL_TEMP) { return TMP + " = " + qName + ".prototype;"; } else { return "})(" + qName + ".prototype);"; } } public void extract(String src, String expected) { if (pattern == Pattern.USE_GLOBAL_TEMP) { test(src, "var " + TMP + ";" + expected); } else { test(src, expected); } } public String generatePrototypeDeclarations(String className, int num) { StringBuilder builder = new StringBuilder(); for (int i = 0; i < num; i++) { char member = (char) ('a' + i); builder.append(generatePrototypeDeclaration( className, "" + member, "" + member)); } return builder.toString(); } public String generatePrototypeDeclaration(String className, String member, String value) { return className + ".prototype." + member + " = " + value + ";"; } public String generateExtractedDeclarations(int num) { StringBuilder builder = new StringBuilder(); if (pattern == Pattern.USE_ANON_FUNCTION) { builder.append("(function(" + TMP + "){"); } for (int i = 0; i < num; i++) { char member = (char) ('a' + i); builder.append(generateExtractedDeclaration("" + member, "" + member)); } return builder.toString(); } public String generateExtractedDeclaration(String member, String value) { return TMP + "." + member + " = " + value + ";"; } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback; import com.google.javascript.jscomp.graph.DiGraph; import junit.framework.TestCase; /** * Test for FixedPointGraphTraversal. * @author nicksantos@google.com (Nick Santos) */ public class FixedPointGraphTraversalTest extends TestCase { // The maximum value of a counter that counts as a "change" // to the state of the graph, for the purposes of fixed-point // computation. private int maxChange = 0; private class Counter { int value = 0; } private class CounterIncrementer implements EdgeCallback<Counter, String> { @Override public boolean traverseEdge(Counter source, String e, Counter dest) { dest.value++; return dest.value <= maxChange; } } private DiGraph<Counter, String> graph; private Counter A, B, C, D, E; private CounterIncrementer callback = new CounterIncrementer(); private FixedPointGraphTraversal<Counter, String> traversal = new FixedPointGraphTraversal<Counter, String>(callback); // Create a new graph of the following form: // // A // / \ // | B // / \ / // C D // \ / // E // // with all edges pointing downwards, and an "up-edge" from E to D. @Override public void setUp() { A = new Counter(); B = new Counter(); C = new Counter(); D = new Counter(); E = new Counter(); graph = LinkedDirectedGraph.create(); graph.createDirectedGraphNode(A); graph.createDirectedGraphNode(B); graph.createDirectedGraphNode(C); graph.createDirectedGraphNode(D); graph.createDirectedGraphNode(E); graph.connect(A, "->", B); graph.connect(A, "->", C); graph.connect(A, "->", D); graph.connect(B, "->", D); graph.connect(C, "->", E); graph.connect(D, "->", E); graph.connect(E, "->", D); } public void testGraph1() { maxChange = 0; traversal.computeFixedPoint(graph, A); assertEquals(0, A.value); assertEquals(1, B.value); assertEquals(1, C.value); assertEquals(1, D.value); assertEquals(0, E.value); } public void testGraph2() { maxChange = 0; traversal.computeFixedPoint(graph, D); assertEquals(0, A.value); assertEquals(0, B.value); assertEquals(0, C.value); assertEquals(0, D.value); assertEquals(1, E.value); } public void testGraph3() { maxChange = 1; traversal.computeFixedPoint(graph, A); assertEquals(0, A.value); assertEquals(1, B.value); assertEquals(1, C.value); assertEquals(3, D.value); assertEquals(2, E.value); } public void testGraph4() { maxChange = 1; traversal.computeFixedPoint(graph, D); assertEquals(0, A.value); assertEquals(0, B.value); assertEquals(0, C.value); assertEquals(1, D.value); assertEquals(2, E.value); } public void testGraph5() { maxChange = 5; traversal.computeFixedPoint(graph, A); assertEquals(0, A.value); assertEquals(1, B.value); assertEquals(1, C.value); assertEquals(6, D.value); assertEquals(5, E.value); } public void testGraph6() { maxChange = 5; traversal.computeFixedPoint(graph, B); assertEquals(0, A.value); assertEquals(0, B.value); assertEquals(0, C.value); assertEquals(6, D.value); assertEquals(5, E.value); } public void testGraph8() { maxChange = 2; traversal.computeFixedPoint(graph, A); try { traversal = new FixedPointGraphTraversal<Counter, String>( new EdgeCallback<Counter, String>() { @Override public boolean traverseEdge(Counter source, String e, Counter dest) { return true; } }); traversal.computeFixedPoint(graph, A); fail("Expecting Error: " + FixedPointGraphTraversal.NON_HALTING_ERROR_MSG); } catch (IllegalStateException e) { assertEquals(e.getMessage(), FixedPointGraphTraversal.NON_HALTING_ERROR_MSG); } } public void testGraph9() { maxChange = 0; // when the graph traversal is done for the whole graph, we're actually // counting the number of "in" edges for each node. traversal.computeFixedPoint(graph); assertEquals(0, A.value); assertEquals(1, B.value); assertEquals(1, C.value); assertEquals(3, D.value); assertEquals(2, E.value); } public void testGraph10() { // Test a graph with self-edges. maxChange = 5; A = new Counter(); B = new Counter(); graph = LinkedDirectedGraph.create(); graph.createDirectedGraphNode(A); graph.createDirectedGraphNode(B); graph.connect(A, "->", A); graph.connect(A, "->", B); traversal.computeFixedPoint(graph); assertEquals(6, A.value); assertEquals(6, B.value); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.rhino.Node; /** * Unit tests for {@link FlowSensitiveInlineVariables}. * */ public class FlowSensitiveInlineVariablesTest extends CompilerTestCase { public static final String EXTERN_FUNCTIONS = "" + "var print;\n" + "/** @nosideeffects */ function noSFX() {} \n" + " function hasSFX() {} \n"; public FlowSensitiveInlineVariablesTest() { enableNormalize(true); } @Override public int getNumRepetitions() { // Test repeatedly inline. return 3; } @Override protected CompilerPass getProcessor(final Compiler compiler) { //return new FlowSensitiveInlineVariables(compiler); return new CompilerPass() { @Override public void process(Node externs, Node root) { (new MarkNoSideEffectCalls(compiler)).process(externs, root); (new FlowSensitiveInlineVariables(compiler)).process(externs, root); } }; } public void testSimpleAssign() { inline("var x; x = 1; print(x)", "var x; print(1)"); inline("var x; x = 1; x", "var x; 1"); inline("var x; x = 1; var a = x", "var x; var a = 1"); inline("var x; x = 1; x = x + 1", "var x; x = 1 + 1"); } public void testSimpleVar() { inline("var x = 1; print(x)", "var x; print(1)"); inline("var x = 1; x", "var x; 1"); inline("var x = 1; var a = x", "var x; var a = 1"); inline("var x = 1; x = x + 1", "var x; x = 1 + 1"); } public void testSimpleForIn() { inline("var a,b,x = a in b; x", "var a,b,x; a in b"); noInline("var a, b; var x = a in b; print(1); x"); noInline("var a,b,x = a in b; delete a[b]; x"); } public void testExported() { noInline("var _x = 1; print(_x)"); } public void testDoNotInlineIncrement() { noInline("var x = 1; x++;"); noInline("var x = 1; x--;"); } public void testDoNotInlineAssignmentOp() { noInline("var x = 1; x += 1;"); noInline("var x = 1; x -= 1;"); } public void testDoNotInlineIntoLhsOfAssign() { noInline("var x = 1; x += 3;"); } public void testMultiUse() { noInline("var x; x = 1; print(x); print (x);"); } public void testMultiUseInSameCfgNode() { noInline("var x; x = 1; print(x) || print (x);"); } public void testMultiUseInTwoDifferentPath() { noInline("var x = 1; if (print) { print(x) } else { alert(x) }"); } public void testAssignmentBeforeDefinition() { inline("x = 1; var x = 0; print(x)","x = 1; var x; print(0)" ); } public void testVarInConditionPath() { noInline("if (foo) { var x = 0 } print(x)"); } public void testMultiDefinitionsBeforeUse() { inline("var x = 0; x = 1; print(x)", "var x = 0; print(1)"); } public void testMultiDefinitionsInSameCfgNode() { noInline("var x; (x = 1) || (x = 2); print(x)"); noInline("var x; x = (1 || (x = 2)); print(x)"); noInline("var x;(x = 1) && (x = 2); print(x)"); noInline("var x;x = (1 && (x = 2)); print(x)"); noInline("var x; x = 1 , x = 2; print(x)"); } public void testNotReachingDefinitions() { noInline("var x; if (foo) { x = 0 } print (x)"); } public void testNoInlineLoopCarriedDefinition() { // First print is undefined instead. noInline("var x; while(true) { print(x); x = 1; }"); // Prints 0 1 1 1 1.... noInline("var x = 0; while(true) { print(x); x = 1; }"); } public void testDoNotExitLoop() { noInline("while (z) { var x = 3; } var y = x;"); } public void testDoNotInlineWithinLoop() { noInline("var y = noSFX(); do { var z = y.foo(); } while (true);"); } public void testDoNotInlineCatchExpression1() { noInline( "var a;\n" + "try {\n" + " throw Error(\"\");\n" + "}catch(err) {" + " a = err;\n" + "}\n" + "return a.stack\n"); } public void testDoNotInlineCatchExpression1a() { noInline( "var a;\n" + "try {\n" + " throw Error(\"\");\n" + "}catch(err) {" + " a = err + 1;\n" + "}\n" + "return a.stack\n"); } public void testDoNotInlineCatchExpression2() { noInline( "var a;\n" + "try {\n" + " if (x) {throw Error(\"\");}\n" + "}catch(err) {" + " a = err;\n" + "}\n" + "return a.stack\n"); } public void testDoNotInlineCatchExpression3() { noInline( "var a;\n" + "try {\n" + " throw Error(\"\");\n" + "} catch(err) {" + " err = x;\n" + " a = err;\n" + "}\n" + "return a.stack\n"); } public void testDoNotInlineCatchExpression4() { // Note: it is valid to inline "x" here but we currently don't. noInline( "try {\n" + " stuff();\n" + "} catch (e) {\n" + " x = e;\n" + " print(x);\n" + "}"); } public void testDefinitionAfterUse() { inline("var x = 0; print(x); x = 1", "var x; print(0); x = 1"); } public void testInlineSameVariableInStraightLine() { inline("var x; x = 1; print(x); x = 2; print(x)", "var x; print(1); print(2)"); } public void testInlineInDifferentPaths() { inline("var x; if (print) {x = 1; print(x)} else {x = 2; print(x)}", "var x; if (print) {print(1)} else {print(2)}"); } public void testNoInlineInMergedPath() { noInline( "var x,y;x = 1;while(y) { if(y){ print(x) } else { x = 1 } } print(x)"); } public void testInlineIntoExpressions() { inline("var x = 1; print(x + 1);", "var x; print(1 + 1)"); } public void testInlineExpressions1() { inline("var a, b; var x = a+b; print(x)", "var a, b; var x; print(a+b)"); } public void testInlineExpressions2() { // We can't inline because of the redefinition of "a". noInline("var a, b; var x = a + b; a = 1; print(x)"); } public void testInlineExpressions3() { inline("var a,b,x; x=a+b; x=a-b ; print(x)", "var a,b,x; x=a+b; print(a-b)"); } public void testInlineExpressions4() { // Precision is lost due to comma's. noInline("var a,b,x; x=a+b, x=a-b; print(x)"); } public void testInlineExpressions5() { noInline("var a; var x = a = 1; print(x)"); } public void testInlineExpressions6() { noInline("var a, x; a = 1 + (x = 1); print(x)"); } public void testInlineExpression7() { // Possible side effects in foo() that might conflict with bar(); noInline("var x = foo() + 1; bar(); print(x)"); // This is a possible case but we don't have analysis to prove this yet. // TODO(user): It is possible to cover this case with the same algorithm // as the missing return check. noInline("var x = foo() + 1; print(x)"); } public void testInlineExpression8() { // The same variable inlined twice. inline( "var a,b;" + "var x = a + b; print(x); x = a - b; print(x)", "var a,b;" + "var x; print(a + b); print(a - b)"); } public void testInlineExpression9() { // Check for actual control flow sensitivity. inline( "var a,b;" + "var x; if (g) { x= a + b; print(x) } x = a - b; print(x)", "var a,b;" + "var x; if (g) { print(a + b)} print(a - b)"); } public void testInlineExpression10() { // The DFA is not fine grain enough for this. noInline("var x, y; x = ((y = 1), print(y))"); } public void testInlineExpressions11() { inline("var x; x = x + 1; print(x)", "var x; print(x + 1)"); noInline("var x; x = x + 1; print(x); print(x)"); } public void testInlineExpressions12() { // ++ is an assignment and considered to modify state so it will not be // inlined. noInline("var x = 10; x = c++; print(x)"); } public void testInlineExpressions13() { inline("var a = 1, b = 2;" + "var x = a;" + "var y = b;" + "var z = x + y;" + "var i = z;" + "var j = z + y;" + "var k = i;", "var a, b;" + "var x;" + "var y = 2;" + "var z = 1 + y;" + "var i;" + "var j = z + y;" + "var k = z;"); } public void testNoInlineIfDefinitionMayNotReach() { noInline("var x; if (x=1) {} x;"); } public void testNoInlineEscapedToInnerFunction() { noInline("var x = 1; function foo() { x = 2 }; print(x)"); } public void testNoInlineLValue() { noInline("var x; if (x = 1) { print(x) }"); } public void testSwitchCase() { inline("var x = 1; switch(x) { }", "var x; switch(1) { }"); } public void testShadowedVariableInnerFunction() { inline("var x = 1; print(x) || (function() { var x; x = 1; print(x)})()", "var x; print(1) || (function() { var x; print(1)})()"); } public void testCatch() { noInline("var x = 0; try { } catch (x) { }"); noInline("try { } catch (x) { print(x) }"); } public void testNoInlineGetProp() { // We don't know if j alias a.b noInline("var x = a.b.c; j.c = 1; print(x);"); } public void testNoInlineGetProp2() { noInline("var x = 1 * a.b.c; j.c = 1; print(x);"); } public void testNoInlineGetProp3() { // Anything inside a function is fine. inline("var x = function(){1 * a.b.c}; print(x);", "var x; print(function(){1 * a.b.c});"); } public void testNoInlineGetEle() { // Again we don't know if i = j noInline("var x = a[i]; a[j] = 2; print(x); "); } // TODO(user): These should be inlinable. public void testNoInlineConstructors() { noInline("var x = new Iterator(); x.next();"); } // TODO(user): These should be inlinable. public void testNoInlineArrayLits() { noInline("var x = []; print(x)"); } // TODO(user): These should be inlinable. public void testNoInlineObjectLits() { noInline("var x = {}; print(x)"); } // TODO(user): These should be inlinable after the REGEX checks. public void testNoInlineRegExpLits() { noInline("var x = /y/; print(x)"); } public void testInlineConstructorCallsIntoLoop() { // Don't inline construction into loops. noInline("var x = new Iterator();" + "for(i = 0; i < 10; i++) {j = x.next()}"); } public void testRemoveWithLabels() { inline("var x = 1; L: x = 2; print(x)", "var x = 1; L:{} print(2)"); inline("var x = 1; L: M: x = 2; print(x)", "var x = 1; L:M:{} print(2)"); inline("var x = 1; L: M: N: x = 2; print(x)", "var x = 1; L:M:N:{} print(2)"); } public void testInlineAcrossSideEffect1() { // This can't be inlined because print() has side-effects and might change // the definition of noSFX. // // noSFX must be both const and pure in order to inline it. noInline("var y; var x = noSFX(y); print(x)"); //inline("var y; var x = noSFX(y); print(x)", "var y;var x;print(noSFX(y))"); } public void testInlineAcrossSideEffect2() { // Think noSFX() as a function that reads y.foo and return it // and SFX() write some new value of y.foo. If that's the case, // inlining across hasSFX() is not valid. // This is a case where hasSFX is right of the source of the inlining. noInline("var y; var x = noSFX(y), z = hasSFX(y); print(x)"); noInline("var y; var x = noSFX(y), z = new hasSFX(y); print(x)"); noInline("var y; var x = new noSFX(y), z = new hasSFX(y); print(x)"); } public void testInlineAcrossSideEffect3() { // This is a case where hasSFX is left of the destination of the inlining. noInline("var y; var x = noSFX(y); hasSFX(y), print(x)"); noInline("var y; var x = noSFX(y); new hasSFX(y), print(x)"); noInline("var y; var x = new noSFX(y); new hasSFX(y), print(x)"); } public void testInlineAcrossSideEffect4() { // This is a case where hasSFX is some control flow path between the // source and its destination. noInline("var y; var x = noSFX(y); hasSFX(y); print(x)"); noInline("var y; var x = noSFX(y); new hasSFX(y); print(x)"); noInline("var y; var x = new noSFX(y); new hasSFX(y); print(x)"); } public void testCanInlineAcrossNoSideEffect() { // This can't be inlined because print() has side-effects and might change // the definition of noSFX. We should be able to mark noSFX as const // in some way. noInline( "var y; var x = noSFX(y), z = noSFX(); noSFX(); noSFX(), print(x)"); //inline( // "var y; var x = noSFX(y), z = noSFX(); noSFX(); noSFX(), print(x)", // "var y; var x, z = noSFX(); noSFX(); noSFX(), print(noSFX(y))"); } public void testDependOnOuterScopeVariables() { noInline("var x; function foo() { var y = x; x = 0; print(y) }"); noInline("var x; function foo() { var y = x; x++; print(y) }"); // Sadly, we don't understand the data flow of outer scoped variables as // it can be modified by code outside of this scope. We can't inline // at all if the definition has dependence on such variable. noInline("var x; function foo() { var y = x; print(y) }"); } public void testInlineIfNameIsLeftSideOfAssign() { inline("var x = 1; x = print(x) + 1", "var x; x = print(1) + 1"); inline("var x = 1; L: x = x + 2", "var x; L: x = 1 + 2"); inline("var x = 1; x = (x = x + 1)", "var x; x = (x = 1 + 1)"); noInline("var x = 1; x = (x = (x = 10) + x)"); noInline("var x = 1; x = (f(x) + (x = 10) + x);"); noInline("var x = 1; x=-1,foo(x)"); noInline("var x = 1; x-=1,foo(x)"); } public void testInlineArguments() { testSame("function _func(x) { print(x) }"); testSame("function _func(x,y) { if(y) { x = 1 }; print(x) }"); test("function f(x, y) { x = 1; print(x) }", "function f(x, y) { print(1) }"); test("function f(x, y) { if (y) { x = 1; print(x) }}", "function f(x, y) { if (y) { print(1) }}"); } public void testInvalidInlineArguments1() { testSame("function f(x, y) { x = 1; arguments[0] = 2; print(x) }"); testSame("function f(x, y) { x = 1; var z = arguments;" + "z[0] = 2; z[1] = 3; print(x)}"); testSame("function g(a){a[0]=2} function f(x){x=1;g(arguments);print(x)}"); } public void testInvalidInlineArguments2() { testSame("function f(c) {var f = c; arguments[0] = this;" + "f.apply(this, arguments); return this;}"); } public void testForIn() { noInline("var x; var y = {}; for(x in y){}"); noInline("var x; var y = {}; var z; for(x in z = y){print(z)}"); noInline("var x; var y = {}; var z; for(x in y){print(z)}"); } public void testNotOkToSkipCheckPathBetweenNodes() { noInline("var x; for(x = 1; foo(x);) {}"); noInline("var x; for(; x = 1;foo(x)) {}"); } public void testIssue698() { // Most of the flow algorithms operate on Vars. We want to make // sure the algorithm bails out appropriately if it sees // a var that it doesn't know about. inline( "var x = ''; " + "unknown.length < 2 && (unknown='0' + unknown);" + "x = x + unknown; " + "unknown.length < 3 && (unknown='0' + unknown);" + "x = x + unknown; " + "return x;", "var x; " + "unknown.length < 2 && (unknown='0' + unknown);" + "x = '' + unknown; " + "unknown.length < 3 && (unknown='0' + unknown);" + "x = x + unknown; " + "return x;"); } public void testIssue777() { test( "function f(cmd, ta) {" + " var temp = cmd;" + " var temp2 = temp >> 2;" + " cmd = STACKTOP;" + " for (var src = temp2, dest = cmd >> 2, stop = src + 37;" + " src < stop;" + " src++, dest++) {" + " HEAP32[dest] = HEAP32[src];" + " }" + " temp = ta;" + " temp2 = temp >> 2;" + " ta = STACKTOP;" + " STACKTOP += 8;" + " HEAP32[ta >> 2] = HEAP32[temp2];" + " HEAP32[ta + 4 >> 2] = HEAP32[temp2 + 1];" + "}", "function f(cmd, ta){" + " var temp;" + " var temp2 = cmd >> 2;" + " cmd = STACKTOP;" + " var src = temp2;" + " var dest = cmd >> 2;" + " var stop = src + 37;" + " for(;src<stop;src++,dest++)HEAP32[dest]=HEAP32[src];" + " temp2 = ta >> 2;" + " ta = STACKTOP;" + " STACKTOP += 8;" + " HEAP32[ta>>2] = HEAP32[temp2];" + " HEAP32[ta+4>>2] = HEAP32[temp2+1];" + "}"); } public void testTransitiveDependencies1() { test( "function f(x) { var a = x; var b = a; x = 3; return b; }", "function f(x) { var a; var b = x; x = 3; return b; }"); } public void testTransitiveDependencies2() { test( "function f(x) { var a = x; var b = a; var c = b; x = 3; return c; }", "function f(x) { var a ; var b = x; var c ; x = 3; return b; }"); } public void testIssue794a() { noInline( "var x = 1; " + "try { x += someFunction(); } catch (e) {}" + "x += 1;" + "try { x += someFunction(); } catch (e) {}" + "return x;"); } public void testIssue794b() { noInline( "var x = 1; " + "try { x = x + someFunction(); } catch (e) {}" + "x = x + 1;" + "try { x = x + someFunction(); } catch (e) {}" + "return x;"); } private void noInline(String input) { inline(input, input); } private void inline(String input, String expected) { test(EXTERN_FUNCTIONS, "function _func() {" + input + "}", "function _func() {" + expected + "}", null, null); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Supplier; import com.google.common.collect.Sets; import com.google.javascript.rhino.Node; import junit.framework.TestCase; import java.util.Collections; import java.util.Map; import java.util.Set; /** * Inline function tests. * @author johnlenz@google.com (John Lenz) */ public class FunctionArgumentInjectorTest extends TestCase { // TODO(johnlenz): Add unit tests for: // inject // getFunctionCallParameterMap private static final Set<String> EMPTY_STRING_SET = Collections.emptySet(); public void testFindModifiedParameters1() { assertEquals(Sets.newHashSet(), FunctionArgumentInjector.findModifiedParameters( parseFunction("function f(a){ return a==0; }"))); } public void testFindModifiedParameters2() { assertEquals(Sets.newHashSet(), FunctionArgumentInjector.findModifiedParameters( parseFunction("function f(a){ b=a }"))); } public void testFindModifiedParameters3() { assertEquals(Sets.newHashSet("a"), FunctionArgumentInjector.findModifiedParameters( parseFunction("function f(a){ a=0 }"))); } public void testFindModifiedParameters4() { assertEquals(Sets.newHashSet("a", "b"), FunctionArgumentInjector.findModifiedParameters( parseFunction("function f(a,b){ a=0;b=0 }"))); } public void testFindModifiedParameters5() { assertEquals(Sets.newHashSet("b"), FunctionArgumentInjector.findModifiedParameters( parseFunction("function f(a,b){ a; if (a) b=0 }"))); } public void testFindModifiedParameters6() { assertEquals(Sets.newHashSet("a", "b"), FunctionArgumentInjector.findModifiedParameters( parseFunction("function f(a,b){ function f(){ a;b; } }"))); } public void testFindModifiedParameters7() { assertEquals(Sets.newHashSet("b"), FunctionArgumentInjector.findModifiedParameters( parseFunction("function f(a,b){ a; function f(){ b; } }"))); } public void testFindModifiedParameters8() { assertEquals(Sets.newHashSet("b"), FunctionArgumentInjector.findModifiedParameters( parseFunction( "function f(a,b){ "+ "a; function f(){ function g() { b; } } }"))); } public void testFindModifiedParameters9() { assertEquals(Sets.newHashSet("a", "b"), FunctionArgumentInjector.findModifiedParameters( parseFunction("function f(a,b){ (function(){ a;b; }) }"))); } public void testFindModifiedParameters10() { assertEquals(Sets.newHashSet("b"), FunctionArgumentInjector.findModifiedParameters( parseFunction("function f(a,b){ a; (function (){ b; }) }"))); } public void testFindModifiedParameters11() { assertEquals(Sets.newHashSet("b"), FunctionArgumentInjector.findModifiedParameters( parseFunction( "function f(a,b){ "+ "a; (function(){ (function () { b; }) }) }"))); } public void testMaybeAddTempsForCallArguments1() { // Parameters with side-effects must be executed // even if they aren't referenced. testNeededTemps( "function foo(a,b){}; foo(goo(),goo());", "foo", Sets.newHashSet("a", "b")); } public void testMaybeAddTempsForCallArguments2() { // Unreferenced parameters without side-effects // can be ignored. testNeededTemps( "function foo(a,b){}; foo(1,2);", "foo", EMPTY_STRING_SET); } public void testMaybeAddTempsForCallArguments3() { // Referenced parameters without side-effects // don't need temps. testNeededTemps( "function foo(a,b){a;b;}; foo(x,y);", "foo", EMPTY_STRING_SET); } public void testMaybeAddTempsForCallArguments4() { // Parameters referenced after side-effect must // be assigned to temps. testNeededTemps( "function foo(a,b){a;goo();b;}; foo(x,y);", "foo", Sets.newHashSet("b")); } public void testMaybeAddTempsForCallArguments5() { // Parameters referenced after out-of-scope side-effect must // be assigned to temps. testNeededTemps( "function foo(a,b){x = b; y = a;}; foo(x,y);", "foo", Sets.newHashSet("a")); } public void testMaybeAddTempsForCallArguments6() { // Parameter referenced after a out-of-scope side-effect must // be assigned to a temp. testNeededTemps( "function foo(a){x++;a;}; foo(x);", "foo", Sets.newHashSet("a")); } public void testMaybeAddTempsForCallArguments7() { // No temp needed after local side-effects. testNeededTemps( "function foo(a){var c; c=0; a;}; foo(x);", "foo", EMPTY_STRING_SET); } public void testMaybeAddTempsForCallArguments8() { // Temp needed for side-effects to object using local name. testNeededTemps( "function foo(a){var c = {}; c.goo=0; a;}; foo(x);", "foo", Sets.newHashSet("a")); } public void testMaybeAddTempsForCallArguments9() { // Parameters referenced in a loop with side-effects must // be assigned to temps. testNeededTemps( "function foo(a,b){while(true){a;goo();b;}}; foo(x,y);", "foo", Sets.newHashSet("a", "b")); } public void testMaybeAddTempsForCallArguments10() { // No temps for parameters referenced in a loop with no side-effects. testNeededTemps( "function foo(a,b){while(true){a;true;b;}}; foo(x,y);", "foo", EMPTY_STRING_SET); } public void testMaybeAddTempsForCallArguments11() { // Parameters referenced in a loop with side-effects must // be assigned to temps. testNeededTemps( "function foo(a,b){do{a;b;}while(goo());}; foo(x,y);", "foo", Sets.newHashSet("a", "b")); } public void testMaybeAddTempsForCallArguments12() { // Parameters referenced in a loop with side-effects must // be assigned to temps. testNeededTemps( "function foo(a,b){for(;;){a;b;goo();}}; foo(x,y);", "foo", Sets.newHashSet("a", "b")); } public void testMaybeAddTempsForCallArguments13() { // Parameters referenced in a inner loop without side-effects must // be assigned to temps if the outer loop has side-effects. testNeededTemps( "function foo(a,b){for(;;){for(;;){a;b;}goo();}}; foo(x,y);", "foo", Sets.newHashSet("a", "b")); } public void testMaybeAddTempsForCallArguments14() { // Parameters referenced in a loop must // be assigned to temps. testNeededTemps( "function foo(a,b){goo();for(;;){a;b;}}; foo(x,y);", "foo", Sets.newHashSet("a", "b")); } public void testMaybeAddTempsForCallArguments20() { // A long string referenced more than once should have a temp. testNeededTemps( "function foo(a){a;a;}; foo(\"blah blah\");", "foo", Sets.newHashSet("a")); } public void testMaybeAddTempsForCallArguments21() { // A short string referenced once should not have a temp. testNeededTemps( "function foo(a){a;a;}; foo(\"\");", "foo", EMPTY_STRING_SET); } public void testMaybeAddTempsForCallArguments22() { // A object literal not referenced. testNeededTemps( "function foo(a){}; foo({x:1});", "foo", EMPTY_STRING_SET); // A object literal referenced, should have a temp. testNeededTemps( "function foo(a){a;}; foo({x:1});", "foo", Sets.newHashSet("a")); // A object literal, referenced more than once, should have a temp. testNeededTemps( "function foo(a){a;a;}; foo({x:1});", "foo", Sets.newHashSet("a")); } public void testMaybeAddTempsForCallArguments23() { // A array literal, not referenced. testNeededTemps( "function foo(a){}; foo([1,2]);", "foo", EMPTY_STRING_SET); // A array literal, referenced once, should have a temp. testNeededTemps( "function foo(a){a;}; foo([1,2]);", "foo", Sets.newHashSet("a")); // A array literal, referenced more than once, should have a temp. testNeededTemps( "function foo(a){a;a;}; foo([1,2]);", "foo", Sets.newHashSet("a")); } public void testMaybeAddTempsForCallArguments24() { // A regex literal, not referenced. testNeededTemps( "function foo(a){}; foo(/mac/);", "foo", EMPTY_STRING_SET); // A regex literal, referenced once, should have a temp. testNeededTemps( "function foo(a){a;}; foo(/mac/);", "foo", Sets.newHashSet("a")); // A regex literal, referenced more than once, should have a temp. testNeededTemps( "function foo(a){a;a;}; foo(/mac/);", "foo", Sets.newHashSet("a")); } public void testMaybeAddTempsForCallArguments25() { // A side-effect-less constructor, not referenced. testNeededTemps( "function foo(a){}; foo(new Date());", "foo", EMPTY_STRING_SET); // A side-effect-less constructor, referenced once, should have a temp. testNeededTemps( "function foo(a){a;}; foo(new Date());", "foo", Sets.newHashSet("a")); // A side-effect-less constructor, referenced more than once, should have // a temp. testNeededTemps( "function foo(a){a;a;}; foo(new Date());", "foo", Sets.newHashSet("a")); } public void testMaybeAddTempsForCallArguments26() { // A constructor, not referenced. testNeededTemps( "function foo(a){}; foo(new Bar());", "foo", Sets.newHashSet("a")); // A constructor, referenced once, should have a temp. testNeededTemps( "function foo(a){a;}; foo(new Bar());", "foo", Sets.newHashSet("a")); // A constructor, referenced more than once, should have a temp. testNeededTemps( "function foo(a){a;a;}; foo(new Bar());", "foo", Sets.newHashSet("a")); } public void testMaybeAddTempsForCallArguments27() { // Ensure the correct parameter is given a temp, when there is // a this value in the call. testNeededTemps( "function foo(a,b,c){}; foo.call(this,1,goo(),2);", "foo", Sets.newHashSet("b")); } public void testMaybeAddTempsForCallArguments28() { // true/false are don't need temps testNeededTemps( "function foo(a){a;a;}; foo(true);", "foo", EMPTY_STRING_SET); } public void testMaybeAddTempsForCallArguments29() { // true/false are don't need temps testNeededTemps( "function foo(a){a;a;}; foo(false);", "foo", EMPTY_STRING_SET); } public void testMaybeAddTempsForCallArguments30() { // true/false are don't need temps testNeededTemps( "function foo(a){a;a;}; foo(!0);", "foo", EMPTY_STRING_SET); } public void testMaybeAddTempsForCallArguments31() { // true/false are don't need temps testNeededTemps( "function foo(a){a;a;}; foo(!1);", "foo", EMPTY_STRING_SET); } public void testMaybeAddTempsForCallArguments32() { // void 0 doesn't need a temp testNeededTemps( "function foo(a){a;a;}; foo(void 0);", "foo", EMPTY_STRING_SET); } public void testMaybeAddTempsForCallArgumentsInLoops() { // A mutable parameter referenced in loop needs a // temporary. testNeededTemps( "function foo(a){for(;;)a;}; foo(new Bar());", "foo", Sets.newHashSet("a")); testNeededTemps( "function foo(a){while(true)a;}; foo(new Bar());", "foo", Sets.newHashSet("a")); testNeededTemps( "function foo(a){do{a;}while(true)}; foo(new Bar());", "foo", Sets.newHashSet("a")); } private void testNeededTemps( String code, String fnName, Set<String> expectedTemps) { Node n = parse(code); Node fn = findFunction(n, fnName); assertNotNull(fn); Node call = findCall(n, fnName); assertNotNull(call); Map<String, Node> args = FunctionArgumentInjector.getFunctionCallParameterMap( fn, call, getNameSupplier()); Set<String> actualTemps = Sets.newHashSet(); FunctionArgumentInjector.maybeAddTempsForCallArguments( fn, args, actualTemps, new ClosureCodingConvention()); assertEquals(expectedTemps, actualTemps); } private static Supplier<String> getNameSupplier() { return new Supplier<String>() { int i = 0; @Override public String get() { return String.valueOf(i++); } }; } private static Node findCall(Node n, String name) { if (n.isCall()) { Node callee; if (NodeUtil.isGet(n.getFirstChild())) { callee = n.getFirstChild().getFirstChild(); Node prop = callee.getNext(); // Only "call" is support at this point. Preconditions.checkArgument(prop.isString() && prop.getString().equals("call")); } else { callee = n.getFirstChild(); } if (callee.isName() && callee.getString().equals(name)) { return n; } } for (Node c : n.children()) { Node result = findCall(c, name); if (result != null) { return result; } } return null; } private static Node findFunction(Node n, String name) { if (n.isFunction()) { if (n.getFirstChild().getString().equals(name)) { return n; } } for (Node c : n.children()) { Node result = findFunction(c, name); if (result != null) { return result; } } return null; } private static Node parseFunction(String js) { return parse(js).getFirstChild(); } private static Node parse(String js) { Compiler compiler = new Compiler(); Node n = compiler.parseTestCode(js); assertEquals(0, compiler.getErrorCount()); return n; } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.jscomp.AbstractCompiler.LifeCycleStage; import com.google.javascript.jscomp.FunctionInjector.CanInlineResult; import com.google.javascript.jscomp.FunctionInjector.InliningMode; import com.google.javascript.jscomp.NodeTraversal.Callback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import junit.framework.TestCase; import java.util.List; import java.util.Set; /** * Inline function tests. * @author johnlenz@google.com (John Lenz) */ public class FunctionInjectorTest extends TestCase { static final InliningMode INLINE_DIRECT = InliningMode.DIRECT; static final InliningMode INLINE_BLOCK = InliningMode.BLOCK; private boolean assumeStrictThis = false; private boolean assumeMinimumCapture = false; @Override protected void setUp() throws Exception { super.setUp(); assumeStrictThis = false; } private FunctionInjector getInjector() { Compiler compiler = new Compiler(); return new FunctionInjector( compiler, compiler.getUniqueNameIdSupplier(), true, assumeStrictThis, assumeMinimumCapture); } public void testIsSimpleFunction1() { assertTrue(getInjector().isDirectCallNodeReplacementPossible( prep("function f(){}"))); } public void testIsSimpleFunction2() { assertTrue(getInjector().isDirectCallNodeReplacementPossible( prep("function f(){return 0;}"))); } public void testIsSimpleFunction3() { assertTrue(getInjector().isDirectCallNodeReplacementPossible( prep("function f(){return x ? 0 : 1}"))); } public void testIsSimpleFunction4() { assertFalse(getInjector().isDirectCallNodeReplacementPossible( prep("function f(){return;}"))); } public void testIsSimpleFunction5() { assertFalse(getInjector().isDirectCallNodeReplacementPossible( prep("function f(){return 0; return 0;}"))); } public void testIsSimpleFunction6() { assertFalse(getInjector().isDirectCallNodeReplacementPossible( prep("function f(){var x=true;return x ? 0 : 1}"))); } public void testIsSimpleFunction7() { assertFalse(getInjector().isDirectCallNodeReplacementPossible( prep("function f(){if (x) return 0; else return 1}"))); } public void testCanInlineReferenceToFunction1() { helperCanInlineReferenceToFunction(CanInlineResult.YES, "function foo(){}; foo();", "foo", INLINE_DIRECT); } public void testCanInlineReferenceToFunction2() { helperCanInlineReferenceToFunction(CanInlineResult.YES, "function foo(){}; foo();", "foo", INLINE_BLOCK); } public void testCanInlineReferenceToFunction3() { // NOTE: FoldConstants will convert this to a empty function, // so there is no need to explicitly support it. helperCanInlineReferenceToFunction(CanInlineResult.NO, "function foo(){return;}; foo();", "foo", INLINE_DIRECT); } public void testCanInlineReferenceToFunction4() { helperCanInlineReferenceToFunction(CanInlineResult.YES, "function foo(){return;}; foo();", "foo", INLINE_BLOCK); } public void testCanInlineReferenceToFunction5() { helperCanInlineReferenceToFunction(CanInlineResult.YES, "function foo(){return true;}; foo();", "foo", INLINE_DIRECT); } public void testCanInlineReferenceToFunction6() { helperCanInlineReferenceToFunction(CanInlineResult.YES, "function foo(){return true;}; foo();", "foo", INLINE_BLOCK); } public void testCanInlineReferenceToFunction7() { // In var initialization. helperCanInlineReferenceToFunction(CanInlineResult.YES, "function foo(){return true;}; var x=foo();", "foo", INLINE_DIRECT); } public void testCanInlineReferenceToFunction8() { helperCanInlineReferenceToFunction(CanInlineResult.YES, "function foo(){return true;}; var x=foo();", "foo", INLINE_BLOCK); } public void testCanInlineReferenceToFunction9() { // In assignment. helperCanInlineReferenceToFunction(CanInlineResult.YES, "function foo(){return true;}; var x; x=foo();", "foo", INLINE_DIRECT); } public void testCanInlineReferenceToFunction10() { helperCanInlineReferenceToFunction(CanInlineResult.YES, "function foo(){return true;}; var x; x=foo();", "foo", INLINE_BLOCK); } public void testCanInlineReferenceToFunction11() { // In expression. helperCanInlineReferenceToFunction(CanInlineResult.YES, "function foo(){return true;}; var x; x=x+foo();", "foo", INLINE_DIRECT); } public void testCanInlineReferenceToFunction12() { // "foo" is not known to be side-effect free, it might change the value // of "x", so it can't be inlined. helperCanInlineReferenceToFunction(CanInlineResult.NO, "function foo(){return true;}; var x; x=x+foo();", "foo", INLINE_BLOCK); } public void testCanInlineReferenceToFunction12b() { // "foo" is not known to be side-effect free, it might change the value // of "x", so it can't be inlined. helperCanInlineReferenceToFunction( CanInlineResult.AFTER_PREPARATION, "function foo(){return true;}; var x; x=x+foo();", "foo", INLINE_BLOCK, true); } // TODO(nicksantos): Re-enable with side-effect detection. // public void testCanInlineReferenceToFunction13() { // // ... if foo is side-effect free we can inline here. // helperCanInlineReferenceToFunction(true, // "/** @nosideeffects */ function foo(){return true;};" + // "var x; x=x+foo();", "foo", INLINE_BLOCK); // } public void testCanInlineReferenceToFunction14() { // Simple call with parameters helperCanInlineReferenceToFunction(CanInlineResult.YES, "function foo(a){return true;}; foo(x);", "foo", INLINE_DIRECT); } public void testCanInlineReferenceToFunction15() { helperCanInlineReferenceToFunction(CanInlineResult.YES, "function foo(a){return true;}; foo(x);", "foo", INLINE_BLOCK); } // TODO(johnlenz): remove this constant once this has been proven in // production code. static final CanInlineResult NEW_VARS_IN_GLOBAL_SCOPE = CanInlineResult.YES; public void testCanInlineReferenceToFunction16() { // Function "foo" as it contains "var b" which // must be brought into the global scope. helperCanInlineReferenceToFunction(NEW_VARS_IN_GLOBAL_SCOPE, "function foo(a){var b;return a;}; foo(goo());", "foo", INLINE_BLOCK); } public void testCanInlineReferenceToFunction17() { // This doesn't bring names into the global name space. helperCanInlineReferenceToFunction(CanInlineResult.YES, "function foo(a){return a;}; " + "function x() { foo(goo()); }", "foo", INLINE_BLOCK); } public void testCanInlineReferenceToFunction18() { // Parameter has side-effects. helperCanInlineReferenceToFunction(CanInlineResult.NO, "function foo(a){return a;} foo(x++);", "foo", INLINE_DIRECT); } public void testCanInlineReferenceToFunction19() { // Parameter has mutable parameter referenced more than once. helperCanInlineReferenceToFunction(CanInlineResult.NO, "function foo(a){return a+a} foo([]);", "foo", INLINE_DIRECT); } public void testCanInlineReferenceToFunction20() { helperCanInlineReferenceToFunction(CanInlineResult.NO, "function foo(a){return a+a} foo({});", "foo", INLINE_DIRECT); } public void testCanInlineReferenceToFunction21() { helperCanInlineReferenceToFunction(CanInlineResult.NO, "function foo(a){return a+a} foo(new Date);", "foo", INLINE_DIRECT); } public void testCanInlineReferenceToFunction22() { helperCanInlineReferenceToFunction(CanInlineResult.NO, "function foo(a){return a+a} foo(true && new Date);", "foo", INLINE_DIRECT); } public void testCanInlineReferenceToFunction23() { // variables to global scope. helperCanInlineReferenceToFunction(NEW_VARS_IN_GLOBAL_SCOPE, "function foo(a){return a;}; foo(x++);", "foo", INLINE_BLOCK); } public void testCanInlineReferenceToFunction24() { // ... this is OK, because it doesn't introduce a new global name. helperCanInlineReferenceToFunction(CanInlineResult.YES, "function foo(a){return a;}; " + "function x() { foo(x++); }", "foo", INLINE_BLOCK); } public void testCanInlineReferenceToFunction25() { // Parameter has side-effects. helperCanInlineReferenceToFunction(CanInlineResult.NO, "function foo(a){return a+a;}; foo(x++);", "foo", INLINE_DIRECT); } public void testCanInlineReferenceToFunction26() { helperCanInlineReferenceToFunction(NEW_VARS_IN_GLOBAL_SCOPE, "function foo(a){return a+a;}; foo(x++);", "foo", INLINE_BLOCK); } public void testCanInlineReferenceToFunction27() { helperCanInlineReferenceToFunction(CanInlineResult.YES, "function foo(a){return a+a;}; " + "function x() { foo(x++); }", "foo", INLINE_BLOCK); } public void testCanInlineReferenceToFunction28() { // Parameter has side-effects. helperCanInlineReferenceToFunction(CanInlineResult.NO, "function foo(a){return true;}; foo(goo());", "foo", INLINE_DIRECT); } public void testCanInlineReferenceToFunction29() { helperCanInlineReferenceToFunction(NEW_VARS_IN_GLOBAL_SCOPE, "function foo(a){return true;}; foo(goo());", "foo", INLINE_BLOCK); } public void testCanInlineReferenceToFunction30() { helperCanInlineReferenceToFunction(CanInlineResult.YES, "function foo(a){return true;}; " + "function x() { foo(goo()); }", "foo", INLINE_BLOCK); } public void testCanInlineReferenceToFunction31() { helperCanInlineReferenceToFunction(CanInlineResult.YES, "function foo(a) {return true;}; " + "function x() {foo.call(this, 1);}", "foo", INLINE_DIRECT); } public void testCanInlineReferenceToFunction32() { helperCanInlineReferenceToFunction(CanInlineResult.NO, "function foo(a){return true;}; " + "function x() { foo.apply(this, [1]); }", "foo", INLINE_DIRECT); } public void testCanInlineReferenceToFunction33() { // No special handling is required for method calls passing this. helperCanInlineReferenceToFunction(CanInlineResult.YES, "function foo(a){return true;}; " + "function x() { foo.bar(this, 1); }", "foo", INLINE_DIRECT); } public void testCanInlineReferenceToFunction34() { helperCanInlineReferenceToFunction(CanInlineResult.YES, "function foo(a){return true;}; " + "function x() { foo.call(this, goo()); }", "foo", INLINE_BLOCK); } public void testCanInlineReferenceToFunction35() { helperCanInlineReferenceToFunction(CanInlineResult.NO, "function foo(a){return true;}; " + "function x() { foo.apply(this, goo()); }", "foo", INLINE_BLOCK); } public void testCanInlineReferenceToFunction36() { helperCanInlineReferenceToFunction(CanInlineResult.YES, "function foo(a){return true;}; " + "function x() { foo.bar(this, goo()); }", "foo", INLINE_BLOCK); } public void testCanInlineReferenceToFunction37() { helperCanInlineReferenceToFunction(CanInlineResult.NO, "function foo(a){return true;}; " + "function x() { foo.call(null, 1); }", "foo", INLINE_DIRECT); } public void testCanInlineReferenceToFunction38() { assumeStrictThis = false; helperCanInlineReferenceToFunction(CanInlineResult.NO, "function foo(a){return true;}; " + "function x() { foo.call(null, goo()); }", "foo", INLINE_BLOCK); assumeStrictThis = true; helperCanInlineReferenceToFunction(CanInlineResult.YES, "function foo(a){return true;}; " + "function x() { foo.call(null, goo()); }", "foo", INLINE_BLOCK); } public void testCanInlineReferenceToFunction39() { helperCanInlineReferenceToFunction(CanInlineResult.NO, "function foo(a){return true;}; " + "function x() { foo.call(bar, 1); }", "foo", INLINE_DIRECT); } public void testCanInlineReferenceToFunction40() { assumeStrictThis = false; helperCanInlineReferenceToFunction(CanInlineResult.NO, "function foo(a){return true;}; " + "function x() { foo.call(bar, goo()); }", "foo", INLINE_BLOCK); assumeStrictThis = true; helperCanInlineReferenceToFunction(CanInlineResult.YES, "function foo(a){return true;}; " + "function x() { foo.call(bar, goo()); }", "foo", INLINE_BLOCK); } public void testCanInlineReferenceToFunction41() { helperCanInlineReferenceToFunction(CanInlineResult.NO, "function foo(a){return true;}; " + "function x() { foo.call(new bar(), 1); }", "foo", INLINE_DIRECT); } public void testCanInlineReferenceToFunction42() { assumeStrictThis = false; helperCanInlineReferenceToFunction(CanInlineResult.NO, "function foo(a){return true;}; " + "function x() { foo.call(new bar(), goo()); }", "foo", INLINE_BLOCK); assumeStrictThis = true; helperCanInlineReferenceToFunction(CanInlineResult.YES, "function foo(a){return true;}; " + "function x() { foo.call(new bar(), goo()); }", "foo", INLINE_BLOCK); } public void testCanInlineReferenceToFunction43() { // Handle the case of a missing 'this' value in a call. helperCanInlineReferenceToFunction(CanInlineResult.NO, "function foo(){return true;}; " + "function x() { foo.call(); }", "foo", INLINE_DIRECT); } public void testCanInlineReferenceToFunction44() { assumeStrictThis = false; // Handle the case of a missing 'this' value in a call. helperCanInlineReferenceToFunction(CanInlineResult.NO, "function foo(){return true;}; " + "function x() { foo.call(); }", "foo", INLINE_BLOCK); assumeStrictThis = true; // Handle the case of a missing 'this' value in a call. helperCanInlineReferenceToFunction(CanInlineResult.YES, "function foo(){return true;}; " + "function x() { foo.call(); }", "foo", INLINE_BLOCK); } public void testCanInlineReferenceToFunction45() { // Call with inner function expression. helperCanInlineReferenceToFunction(CanInlineResult.YES, "function foo(){return function() {return true;}}; foo();", "foo", INLINE_DIRECT); } public void testCanInlineReferenceToFunction46() { // Call with inner function expression. helperCanInlineReferenceToFunction(CanInlineResult.YES, "function foo(){return function() {return true;}}; foo();", "foo", INLINE_BLOCK); } public void testCanInlineReferenceToFunction47() { // Call with inner function expression and variable decl. helperCanInlineReferenceToFunction(CanInlineResult.NO, "function foo(){var a; return function() {return true;}}; foo();", "foo", INLINE_DIRECT); } public void testCanInlineReferenceToFunction48() { // Call with inner function expression and variable decl. // TODO(johnlenz): should we validate no values in scope? helperCanInlineReferenceToFunction(CanInlineResult.YES, "function foo(){var a; return function() {return true;}}; foo();", "foo", INLINE_BLOCK); } public void testCanInlineReferenceToFunction49() { // Call with inner function expression. helperCanInlineReferenceToFunction(CanInlineResult.YES, "function foo(){return function() {var a; return true;}}; foo();", "foo", INLINE_DIRECT); } public void testCanInlineReferenceToFunction50() { // Call with inner function expression. helperCanInlineReferenceToFunction(CanInlineResult.YES, "function foo(){return function() {var a; return true;}}; foo();", "foo", INLINE_BLOCK); } public void testCanInlineReferenceToFunction51() { // Call with inner function statement. helperCanInlineReferenceToFunction(CanInlineResult.YES, "function foo(){function x() {var a; return true;} return x}; foo();", "foo", INLINE_BLOCK); } public void testCanInlineReferenceToFunctionInExpression1() { // Call in if condition helperCanInlineReferenceToFunction(CanInlineResult.AFTER_PREPARATION, "function foo(a){return true;}; " + "function x() { if (foo(1)) throw 'test'; }", "foo", INLINE_BLOCK, true); } public void testCanInlineReferenceToFunctionInExpression2() { // Call in return expression helperCanInlineReferenceToFunction(CanInlineResult.AFTER_PREPARATION, "function foo(a){return true;}; " + "function x() { return foo(1); }", "foo", INLINE_BLOCK, true); } public void testCanInlineReferenceToFunctionInExpression3() { // Call in switch expression helperCanInlineReferenceToFunction(CanInlineResult.AFTER_PREPARATION, "function foo(a){return true;}; " + "function x() { switch(foo(1)) { default:break; } }", "foo", INLINE_BLOCK, true); } public void testCanInlineReferenceToFunctionInExpression4() { // Call in hook condition helperCanInlineReferenceToFunction(CanInlineResult.AFTER_PREPARATION, "function foo(a){return true;}; " + "function x() {foo(1)?0:1 }", "foo", INLINE_BLOCK, true); } public void testCanInlineReferenceToFunctionInExpression5() { // Call in hook side-effect free condition helperCanInlineReferenceToFunction(CanInlineResult.NO, "function foo(a){return true;}; " + "function x() {true?foo(1):1 }", "foo", INLINE_BLOCK); } public void testCanInlineReferenceToFunctionInExpression5a() { // Call in hook side-effect free condition helperCanInlineReferenceToFunction( CanInlineResult.AFTER_PREPARATION, "function foo(a){return true;}; " + "function x() {true?foo(1):1 }", "foo", INLINE_BLOCK, true); } public void testCanInlineReferenceToFunctionInExpression6() { // Call in expression statement "condition" helperCanInlineReferenceToFunction(CanInlineResult.AFTER_PREPARATION, "function foo(a){return true;}; " + "function x() {foo(1) && 1 }", "foo", INLINE_BLOCK, true); } public void testCanInlineReferenceToFunctionInExpression7() { // Call in expression statement after side-effect free "condition" helperCanInlineReferenceToFunction(CanInlineResult.NO, "function foo(a){return true;}; " + "function x() {1 && foo(1) }", "foo", INLINE_BLOCK); } public void testCanInlineReferenceToFunctionInExpression7a() { // Call in expression statement after side-effect free "condition" helperCanInlineReferenceToFunction( CanInlineResult.AFTER_PREPARATION, "function foo(a){return true;}; " + "function x() {1 && foo(1) }", "foo", INLINE_BLOCK, true); } public void testCanInlineReferenceToFunctionInExpression8() { // Call in expression statement after side-effect free operator helperCanInlineReferenceToFunction(CanInlineResult.AFTER_PREPARATION, "function foo(a){return true;}; " + "function x() {1 + foo(1) }", "foo", INLINE_BLOCK, true); } public void testCanInlineReferenceToFunctionInExpression9() { // Call in VAR expression. helperCanInlineReferenceToFunction(CanInlineResult.AFTER_PREPARATION, "function foo(a){return true;}; " + "function x() {var b = 1 + foo(1)}", "foo", INLINE_BLOCK, true); } public void testCanInlineReferenceToFunctionInExpression10() { // Call in assignment expression. helperCanInlineReferenceToFunction(CanInlineResult.NO, "function foo(a){return true;}; " + "function x() {var b; b += 1 + foo(1) }", "foo", INLINE_BLOCK); } public void testCanInlineReferenceToFunctionInExpression10a() { // Call in assignment expression. helperCanInlineReferenceToFunction( CanInlineResult.AFTER_PREPARATION, "function foo(a){return true;}; " + "function x() {var b; b += 1 + foo(1) }", "foo", INLINE_BLOCK, true); } // TODO(nicksantos): Re-enable with side-effect detection. // public void testCanInlineReferenceToFunctionInExpression11() { // helperCanInlineReferenceToFunction(true, // "/** @nosideeffects */ function foo(a){return true;}; " + // "function x() {var b; b += 1 + foo(1) }", // "foo", INLINE_BLOCK); // } public void testCanInlineReferenceToFunctionInExpression12() { helperCanInlineReferenceToFunction(CanInlineResult.AFTER_PREPARATION, "function foo(a){return true;}; " + "function x() {var a,b,c; a = b = c = foo(1) }", "foo", INLINE_BLOCK, true); } public void testCanInlineReferenceToFunctionInExpression13() { helperCanInlineReferenceToFunction(CanInlineResult.AFTER_PREPARATION, "function foo(a){return true;}; " + "function x() {var a,b,c; a = b = c = 1 + foo(1) }", "foo", INLINE_BLOCK, true); } public void testCanInlineReferenceToFunctionInExpression14() { // ... foo can not be inlined because of possible changes to "c". helperCanInlineReferenceToFunction(CanInlineResult.NO, "var a = {}, b = {}, c;" + "a.test = 'a';" + "b.test = 'b';" + "c = a;" + "function foo(){c = b; return 'foo'};" + "c.test=foo();", "foo", INLINE_BLOCK); } public void testCanInlineReferenceToFunctionInExpression14a() { // ... foo can be inlined despite possible changes to "c". helperCanInlineReferenceToFunction( CanInlineResult.AFTER_PREPARATION, "var a = {}, b = {}, c;" + "a.test = 'a';" + "b.test = 'b';" + "c = a;" + "function foo(){c = b; return 'foo'};" + "c.test=foo();", "foo", INLINE_BLOCK, true); } // TODO(nicksantos): Re-enable with side-effect detection. // public void testCanInlineReferenceToFunctionInExpression15() { // // ... foo can be inlined as it is side-effect free. // helperCanInlineReferenceToFunction(true, // "var a = {}, b = {}, c;" + // "a.test = 'a';" + // "b.test = 'b';" + // "c = a;" + // "/** @nosideeffects */ function foo(){return 'foo'};" + // "c.test=foo();", // "foo", INLINE_BLOCK); // } // public void testCanInlineReferenceToFunctionInExpression16() { // // ... foo can not be inlined because of possible side-effects of x() // helperCanInlineReferenceToFunction(false, // "var a = {}, b = {}, c;" + // "a.test = 'a';" + // "b.test = 'b';" + // "c = a;" + // "function x(){return c};" + // "/** @nosideeffects */ function foo(){return 'foo'};" + // "x().test=foo();", // "foo", INLINE_BLOCK); // } // public void testCanInlineReferenceToFunctionInExpression17() { // // ... foo can be inlined because of x() is side-effect free. // helperCanInlineReferenceToFunction(true, // "var a = {}, b = {}, c;" + // "a.test = 'a';" + // "b.test = 'b';" + // "c = a;" + // "/** @nosideeffects */ function x(){return c};" + // "/** @nosideeffects */ function foo(){return 'foo'};" + // "x().test=foo();", // "foo", INLINE_BLOCK); // } public void testCanInlineReferenceToFunctionInExpression18() { // Call in within a call helperCanInlineReferenceToFunction(CanInlineResult.AFTER_PREPARATION, "function foo(){return _g();}; " + "function x() {1 + foo()() }", "foo", INLINE_BLOCK, true); } public void testCanInlineReferenceToFunctionInExpression19() { // ... unless foo is known to be side-effect free, it might actually // change the value of "_g" which would unfortunately change the behavior, // so we can't inline here. helperCanInlineReferenceToFunction(CanInlineResult.NO, "function foo(){return a;}; " + "function x() {1 + _g(foo()) }", "foo", INLINE_BLOCK); } public void testCanInlineReferenceToFunctionInExpression19a() { // ... unless foo is known to be side-effect free, it might actually // change the value of "_g" which would unfortunately change the behavior, // so we can't inline here. helperCanInlineReferenceToFunction( CanInlineResult.AFTER_PREPARATION, "function foo(){return a;}; " + "function x() {1 + _g(foo()) }", "foo", INLINE_BLOCK, true); } // TODO(nicksantos): Re-enable with side-effect detection. // public void testCanInlineReferenceToFunctionInExpression20() { // helperCanInlineReferenceToFunction(true, // "/** @nosideeffects */ function foo(){return a;}; " + // "function x() {1 + _g(foo()) }", // "foo", INLINE_BLOCK); // } public void testCanInlineReferenceToFunctionInExpression21() { // Assignments to object are problematic if the call has side-effects, // as the object that is being referred to can change. // Note: This could be changed be inlined if we in some way make "z" // as not escaping from the local scope. helperCanInlineReferenceToFunction(CanInlineResult.NO, "var z = {};" + "function foo(a){z = {};return true;}; " + "function x() { z.gack = foo(1) }", "foo", INLINE_BLOCK); } public void testCanInlineReferenceToFunctionInExpression21a() { // Assignments to object are problematic if the call has side-effects, // as the object that is being referred to can change. // Note: This could be changed be inlined if we in some way make "z" // as not escaping from the local scope. helperCanInlineReferenceToFunction( CanInlineResult.AFTER_PREPARATION, "var z = {};" + "function foo(a){z = {};return true;}; " + "function x() { z.gack = foo(1) }", "foo", INLINE_BLOCK, true); } public void testCanInlineReferenceToFunctionInExpression22() { // ... foo() is after a side-effect helperCanInlineReferenceToFunction(CanInlineResult.NO, "function foo(){return a;}; " + "function x() {1 + _g(_a(), foo()) }", "foo", INLINE_BLOCK); } public void testCanInlineReferenceToFunctionInExpression22a() { // ... foo() is after a side-effect helperCanInlineReferenceToFunction( CanInlineResult.AFTER_PREPARATION, "function foo(){return a;}; " + "function x() {1 + _g(_a(), foo()) }", "foo", INLINE_BLOCK, true); } public void testCanInlineReferenceToFunctionInExpression23() { // ... foo() is after a side-effect helperCanInlineReferenceToFunction(CanInlineResult.NO, "function foo(){return a;}; " + "function x() {1 + _g(_a(), foo.call(this)) }", "foo", INLINE_BLOCK); } public void testCanInlineReferenceToFunctionInExpression23a() { // ... foo() is after a side-effect helperCanInlineReferenceToFunction( CanInlineResult.AFTER_PREPARATION, "function foo(){return a;}; " + "function x() {1 + _g(_a(), foo.call(this)) }", "foo", INLINE_BLOCK, true); } public void testCanInlineReferenceToFunctionInLoop1() { helperCanInlineReferenceToFunction( CanInlineResult.YES, "function foo(){return a;}; " + "while(1) { foo(); }", "foo", INLINE_BLOCK, true); } public void testCanInlineReferenceToFunctionInLoop2() { // If function contains function, don't inline it into a loop. // TODO(johnlenz): this can be improved by looking to see // if the inner function contains any references to values defined // in the outer function. helperCanInlineReferenceToFunction( CanInlineResult.NO, "function foo(){return function() {};}; " + "while(1) { foo(); }", "foo", INLINE_BLOCK, true); } public void testInline1() { helperInlineReferenceToFunction( "function foo(){}; foo();", "function foo(){}; void 0", "foo", INLINE_DIRECT); } public void testInline2() { helperInlineReferenceToFunction( "function foo(){}; foo();", "function foo(){}; {}", "foo", INLINE_BLOCK); } public void testInline3() { helperInlineReferenceToFunction( "function foo(){return;}; foo();", "function foo(){return;}; {}", "foo", INLINE_BLOCK); } public void testInline4() { helperInlineReferenceToFunction( "function foo(){return true;}; foo();", "function foo(){return true;}; true;", "foo", INLINE_DIRECT); } public void testInline5() { helperInlineReferenceToFunction( "function foo(){return true;}; foo();", "function foo(){return true;}; {true;}", "foo", INLINE_BLOCK); } public void testInline6() { // In var initialization. helperInlineReferenceToFunction( "function foo(){return true;}; var x=foo();", "function foo(){return true;}; var x=true;", "foo", INLINE_DIRECT); } public void testInline7() { helperInlineReferenceToFunction( "function foo(){return true;}; var x=foo();", "function foo(){return true;}; var x;" + "{x=true}", "foo", INLINE_BLOCK); } public void testInline8() { // In assignment. helperInlineReferenceToFunction( "function foo(){return true;}; var x; x=foo();", "function foo(){return true;}; var x; x=true;", "foo", INLINE_DIRECT); } public void testInline9() { helperInlineReferenceToFunction( "function foo(){return true;}; var x; x=foo();", "function foo(){return true;}; var x;{x=true}", "foo", INLINE_BLOCK); } public void testInline10() { // In expression. helperInlineReferenceToFunction( "function foo(){return true;}; var x; x=x+foo();", "function foo(){return true;}; var x; x=x+true;", "foo", INLINE_DIRECT); } public void testInline11() { // Simple call with parameters helperInlineReferenceToFunction( "function foo(a){return true;}; foo(x);", "function foo(a){return true;}; true;", "foo", INLINE_DIRECT); } public void testInline12() { helperInlineReferenceToFunction( "function foo(a){return true;}; foo(x);", "function foo(a){return true;}; {true}", "foo", INLINE_BLOCK); } public void testInline13() { // Parameter has side-effects. helperInlineReferenceToFunction( "function foo(a){return a;}; " + "function x() { foo(x++); }", "function foo(a){return a;}; " + "function x() {{var a$$inline_0=x++;" + "a$$inline_0}}", "foo", INLINE_BLOCK); } public void testInline14() { // Parameter has side-effects. helperInlineReferenceToFunction( "function foo(a){return a+a;}; foo(x++);", "function foo(a){return a+a;}; " + "{var a$$inline_0=x++;" + " a$$inline_0+" + "a$$inline_0;}", "foo", INLINE_BLOCK); } public void testInline15() { // Parameter has mutable, references more than once. helperInlineReferenceToFunction( "function foo(a){return a+a;}; foo(new Date());", "function foo(a){return a+a;}; " + "{var a$$inline_0=new Date();" + " a$$inline_0+" + "a$$inline_0;}", "foo", INLINE_BLOCK); } public void testInline16() { // Parameter is large, references more than once. helperInlineReferenceToFunction( "function foo(a){return a+a;}; foo(function(){});", "function foo(a){return a+a;}; " + "{var a$$inline_0=function(){};" + " a$$inline_0+" + "a$$inline_0;}", "foo", INLINE_BLOCK); } public void testInline17() { // Parameter has side-effects. helperInlineReferenceToFunction( "function foo(a){return true;}; foo(goo());", "function foo(a){return true;};" + "{var a$$inline_0=goo();true}", "foo", INLINE_BLOCK); } public void testInline18() { // This doesn't bring names into the global name space. helperInlineReferenceToFunction( "function foo(a){var b;return a;}; " + "function x() { foo(goo()); }", "function foo(a){var b;return a;}; " + "function x() {{var a$$inline_0=goo();" + "var b$$inline_1;a$$inline_0}}", "foo", INLINE_BLOCK); } public void testInline19() { // Properly alias. helperInlineReferenceToFunction( "var x = 1; var y = 2;" + "function foo(a,b){x = b; y = a;}; " + "function bar() { foo(x,y); }", "var x = 1; var y = 2;" + "function foo(a,b){x = b; y = a;}; " + "function bar() {" + "{var a$$inline_0=x;" + "x = y;" + "y = a$$inline_0;}" + "}", "foo", INLINE_BLOCK); } public void testInline19b() { helperInlineReferenceToFunction( "var x = 1; var y = 2;" + "function foo(a,b){y = a; x = b;}; " + "function bar() { foo(x,y); }", "var x = 1; var y = 2;" + "function foo(a,b){y = a; x = b;}; " + "function bar() {" + "{var b$$inline_1=y;" + "y = x;" + "x = b$$inline_1;}" + "}", "foo", INLINE_BLOCK); } public void testInlineIntoLoop() { helperInlineReferenceToFunction( "function foo(a){var b;return a;}; " + "for(;1;){ foo(1); }", "function foo(a){var b;return a;}; " + "for(;1;){ {" + "var b$$inline_1=void 0;1}}", "foo", INLINE_BLOCK); helperInlineReferenceToFunction( "function foo(a){var b;return a;}; " + "do{ foo(1); } while(1)", "function foo(a){var b;return a;}; " + "do{ {" + "var b$$inline_1=void 0;1}}while(1)", "foo", INLINE_BLOCK); helperInlineReferenceToFunction( "function foo(a){for(var b in c)return a;}; " + "for(;1;){ foo(1); }", "function foo(a){var b;for(b in c)return a;}; " + "for(;1;){ {JSCompiler_inline_label_foo_2:{" + "var b$$inline_1=void 0;for(b$$inline_1 in c){" + "1;break JSCompiler_inline_label_foo_2" + "}}}}", "foo", INLINE_BLOCK); } public void testInlineFunctionWithInnerFunction1() { // Call with inner function expression. helperInlineReferenceToFunction( "function foo(){return function() {return true;}}; foo();", "function foo(){return function() {return true;}};" + "(function() {return true;})", "foo", INLINE_DIRECT); } public void testInlineFunctionWithInnerFunction2() { // Call with inner function expression. helperInlineReferenceToFunction( "function foo(){return function() {return true;}}; foo();", "function foo(){return function() {return true;}};" + "{(function() {return true;})}", "foo", INLINE_BLOCK); } public void testInlineFunctionWithInnerFunction3() { // Call with inner function expression. helperInlineReferenceToFunction( "function foo(){return function() {var a; return true;}}; foo();", "function foo(){return function() {var a; return true;}};" + "(function() {var a; return true;});", "foo", INLINE_DIRECT); } public void testInlineFunctionWithInnerFunction4() { // Call with inner function expression. helperInlineReferenceToFunction( "function foo(){return function() {var a; return true;}}; foo();", "function foo(){return function() {var a; return true;}};" + "{(function() {var a$$inline_0; return true;});}", "foo", INLINE_BLOCK); } public void testInlineFunctionWithInnerFunction5() { // Call with inner function statement. helperInlineReferenceToFunction( "function foo(){function x() {var a; return true;} return x}; foo();", "function foo(){function x(){var a;return true}return x};" + "{var x$$inline_0 = function(){" + "var a$$inline_1;return true};x$$inline_0}", "foo", INLINE_BLOCK); } public void testInlineReferenceInExpression1() { // Call in if condition helperInlineReferenceToFunction( "function foo(a){return true;}; " + "function x() { if (foo(1)) throw 'test'; }", "function foo(a){return true;}; " + "function x() { var JSCompiler_inline_result$$0; " + "{JSCompiler_inline_result$$0=true;}" + "if (JSCompiler_inline_result$$0) throw 'test'; }", "foo", INLINE_BLOCK, true); } public void testInlineReferenceInExpression2() { // Call in return expression helperInlineReferenceToFunction( "function foo(a){return true;}; " + "function x() { return foo(1); }", "function foo(a){return true;}; " + "function x() { var JSCompiler_inline_result$$0; " + "{JSCompiler_inline_result$$0=true;}" + "return JSCompiler_inline_result$$0; }", "foo", INLINE_BLOCK, true); } public void testInlineReferenceInExpression3() { // Call in switch expression helperInlineReferenceToFunction( "function foo(a){return true;}; " + "function x() { switch(foo(1)) { default:break; } }", "function foo(a){return true;}; " + "function x() { var JSCompiler_inline_result$$0; " + "{JSCompiler_inline_result$$0=true;}" + "switch(JSCompiler_inline_result$$0) { default:break; } }", "foo", INLINE_BLOCK, true); } public void testInlineReferenceInExpression4() { // Call in hook condition helperInlineReferenceToFunction( "function foo(a){return true;}; " + "function x() {foo(1)?0:1 }", "function foo(a){return true;}; " + "function x() { var JSCompiler_inline_result$$0; " + "{JSCompiler_inline_result$$0=true;}" + "JSCompiler_inline_result$$0?0:1 }", "foo", INLINE_BLOCK, true); } public void testInlineReferenceInExpression5() { // Call in expression statement "condition" helperInlineReferenceToFunction( "function foo(a){return true;}; " + "function x() {foo(1)&&1 }", "function foo(a){return true;}; " + "function x() { var JSCompiler_inline_result$$0; " + "{JSCompiler_inline_result$$0=true;}" + "JSCompiler_inline_result$$0&&1 }", "foo", INLINE_BLOCK, true); } public void testInlineReferenceInExpression6() { // Call in expression statement after side-effect free "condition" helperInlineReferenceToFunction( "function foo(a){return true;}; " + "function x() {1 + foo(1) }", "function foo(a){return true;}; " + "function x() { var JSCompiler_inline_result$$0; " + "{JSCompiler_inline_result$$0=true;}" + "1 + JSCompiler_inline_result$$0 }", "foo", INLINE_BLOCK, true); } public void testInlineReferenceInExpression7() { // Call in expression statement "condition" helperInlineReferenceToFunction( "function foo(a){return true;}; " + "function x() {foo(1) && 1 }", "function foo(a){return true;}; " + "function x() { var JSCompiler_inline_result$$0; " + "{JSCompiler_inline_result$$0=true;}" + "JSCompiler_inline_result$$0&&1 }", "foo", INLINE_BLOCK, true); } public void testInlineReferenceInExpression8() { // Call in expression statement after side-effect free operator helperInlineReferenceToFunction( "function foo(a){return true;}; " + "function x() {1 + foo(1) }", "function foo(a){return true;}; " + "function x() { var JSCompiler_inline_result$$0;" + "{JSCompiler_inline_result$$0=true;}" + "1 + JSCompiler_inline_result$$0 }", "foo", INLINE_BLOCK, true); } public void testInlineReferenceInExpression9() { // Call in VAR expression. helperInlineReferenceToFunction( "function foo(a){return true;}; " + "function x() {var b = 1 + foo(1)}", "function foo(a){return true;}; " + "function x() { " + "var JSCompiler_inline_result$$0;" + "{JSCompiler_inline_result$$0=true;}" + "var b = 1 + JSCompiler_inline_result$$0 " + "}", "foo", INLINE_BLOCK, true); } // TODO(nicksantos): Re-enable with side-effect detection. // public void testInlineReferenceInExpression10() { // // Call in assignment expression. // helperInlineReferenceToFunction( // "/** @nosideeffects */ function foo(a){return true;}; " + // "function x() {var b; b += 1 + foo(1) }", // "function foo(a){return true;}; " + // "function x() {var b;" + // "{var JSCompiler_inline_result$$0; " + // "JSCompiler_inline_result$$0=true;}" + // "b += 1 + JSCompiler_inline_result$$0 }", // "foo", INLINE_BLOCK); // } public void testInlineReferenceInExpression11() { // Call under label helperInlineReferenceToFunction( "function foo(a){return true;}; " + "function x() {a:foo(1)?0:1 }", "function foo(a){return true;}; " + "function x() {" + " a:{" + " var JSCompiler_inline_result$$0; " + " {JSCompiler_inline_result$$0=true;}" + " JSCompiler_inline_result$$0?0:1 " + " }" + "}", "foo", INLINE_BLOCK, true); } public void testInlineReferenceInExpression12() { helperInlineReferenceToFunction( "function foo(a){return true;}" + "function x() { 1?foo(1):1; }", "function foo(a){return true}" + "function x() {" + " if(1) {" + " {true;}" + " } else {" + " 1;" + " }" + "}", "foo", INLINE_BLOCK, true); } public void testInlineReferenceInExpression13() { helperInlineReferenceToFunction( "function foo(a){return true;}; " + "function x() { goo() + (1?foo(1):1) }", "function foo(a){return true;}; " + "function x() { var JSCompiler_temp_const$$0=goo();" + "var JSCompiler_temp$$1;" + "if(1) {" + " {JSCompiler_temp$$1=true;} " + "} else {" + " JSCompiler_temp$$1=1;" + "}" + "JSCompiler_temp_const$$0 + JSCompiler_temp$$1" + "}", "foo", INLINE_BLOCK, true); } public void testInlineReferenceInExpression14() { helperInlineReferenceToFunction( "var z = {};" + "function foo(a){z = {};return true;}; " + "function x() { z.gack = foo(1) }", "var z = {};" + "function foo(a){z = {};return true;}; " + "function x() {" + "var JSCompiler_temp_const$$0=z;" + "var JSCompiler_inline_result$$1;" + "{" + "z= {};" + "JSCompiler_inline_result$$1 = true;" + "}" + "JSCompiler_temp_const$$0.gack = JSCompiler_inline_result$$1;" + "}", "foo", INLINE_BLOCK, true); } public void testInlineReferenceInExpression15() { helperInlineReferenceToFunction( "var z = {};" + "function foo(a){z = {};return true;}; " + "function x() { z.gack = foo.call(this,1) }", "var z = {};" + "function foo(a){z = {};return true;}; " + "function x() {" + "var JSCompiler_temp_const$$0=z;" + "var JSCompiler_inline_result$$1;" + "{" + "z= {};" + "JSCompiler_inline_result$$1 = true;" + "}" + "JSCompiler_temp_const$$0.gack = JSCompiler_inline_result$$1;" + "}", "foo", INLINE_BLOCK, true); } public void testInlineReferenceInExpression16() { helperInlineReferenceToFunction( "var z = {};" + "function foo(a){z = {};return true;}; " + "function x() { z[bar()] = foo(1) }", "var z = {};" + "function foo(a){z = {};return true;}; " + "function x() {" + "var JSCompiler_temp_const$$1=z;" + "var JSCompiler_temp_const$$0=bar();" + "var JSCompiler_inline_result$$2;" + "{" + "z= {};" + "JSCompiler_inline_result$$2 = true;" + "}" + "JSCompiler_temp_const$$1[JSCompiler_temp_const$$0] = " + "JSCompiler_inline_result$$2;" + "}", "foo", INLINE_BLOCK, true); } public void testInlineReferenceInExpression17() { helperInlineReferenceToFunction( "var z = {};" + "function foo(a){z = {};return true;}; " + "function x() { z.y.x.gack = foo(1) }", "var z = {};" + "function foo(a){z = {};return true;}; " + "function x() {" + "var JSCompiler_temp_const$$0=z.y.x;" + "var JSCompiler_inline_result$$1;" + "{" + "z= {};" + "JSCompiler_inline_result$$1 = true;" + "}" + "JSCompiler_temp_const$$0.gack = JSCompiler_inline_result$$1;" + "}", "foo", INLINE_BLOCK, true); } public void testInlineWithinCalls1() { // Call in within a call helperInlineReferenceToFunction( "function foo(){return _g;}; " + "function x() {1 + foo()() }", "function foo(){return _g;}; " + "function x() { var JSCompiler_inline_result$$0;" + "{JSCompiler_inline_result$$0=_g;}" + "1 + JSCompiler_inline_result$$0() }", "foo", INLINE_BLOCK, true); } // TODO(nicksantos): Re-enable with side-effect detection. // public void testInlineWithinCalls2() { // helperInlineReferenceToFunction( // "/** @nosideeffects */ function foo(){return true;}; " + // "function x() {1 + _g(foo()) }", // "function foo(){return true;}; " + // "function x() { {var JSCompiler_inline_result$$0; " + // "JSCompiler_inline_result$$0=true;}" + // "1 + _g(JSCompiler_inline_result$$0) }", // "foo", INLINE_BLOCK, true); // } public void testInlineAssignmentToConstant() { // Call in within a call helperInlineReferenceToFunction( "function foo(){return _g;}; " + "function x(){var CONSTANT_RESULT = foo(); }", "function foo(){return _g;}; " + "function x() {" + " var JSCompiler_inline_result$$0;" + " {JSCompiler_inline_result$$0=_g;}" + " var CONSTANT_RESULT = JSCompiler_inline_result$$0;" + "}", "foo", INLINE_BLOCK, true); } public void testBug1897706() { helperInlineReferenceToFunction( "function foo(a){}; foo(x())", "function foo(a){}; {var a$$inline_0=x()}", "foo", INLINE_BLOCK); helperInlineReferenceToFunction( "function foo(a){bar()}; foo(x())", "function foo(a){bar()}; {var a$$inline_0=x();bar()}", "foo", INLINE_BLOCK); helperInlineReferenceToFunction( "function foo(a,b){bar()}; foo(x(),y())", "function foo(a,b){bar()};" + "{var a$$inline_0=x();var b$$inline_1=y();bar()}", "foo", INLINE_BLOCK); } /** * Test case * * var a = {}, b = {} * a.test = "a", b.test = "b" * c = a; * foo() { c=b; return "a" } * c.teste * */ public void helperCanInlineReferenceToFunction( final CanInlineResult expectedResult, final String code, final String fnName, final InliningMode mode) { helperCanInlineReferenceToFunction( expectedResult, code, fnName, mode, false); } public void helperCanInlineReferenceToFunction( final CanInlineResult expectedResult, final String code, final String fnName, final InliningMode mode, boolean allowDecomposition) { final Compiler compiler = new Compiler(); final FunctionInjector injector = new FunctionInjector( compiler, compiler.getUniqueNameIdSupplier(), allowDecomposition, assumeStrictThis, assumeMinimumCapture); final Node tree = parse(compiler, code); Node externsRoot = new Node(Token.EMPTY); Node mainRoot = tree; final Node fnNode = findFunction(tree, fnName); final Set<String> unsafe = FunctionArgumentInjector.findModifiedParameters(fnNode); // can-inline tester Method tester = new Method() { @Override public boolean call(NodeTraversal t, Node n, Node parent) { CanInlineResult result = injector.canInlineReferenceToFunction( t, n, fnNode, unsafe, mode, NodeUtil.referencesThis(fnNode), NodeUtil.containsFunction(NodeUtil.getFunctionBody(fnNode))); assertEquals(expectedResult, result); return true; } }; compiler.resetUniqueNameId(); TestCallback test = new TestCallback(fnName, tester); NodeTraversal.traverse(compiler, tree, test); } public void helperInlineReferenceToFunction( String code, final String expectedResult, final String fnName, final InliningMode mode) { helperInlineReferenceToFunction( code, expectedResult, fnName, mode, false); } private void validateSourceInfo(Compiler compiler, Node subtree) { (new LineNumberCheck(compiler)).setCheckSubTree(subtree); // Source information problems are reported as compiler errors. if (compiler.getErrorCount() != 0) { String msg = "Error encountered: "; for (JSError err : compiler.getErrors()) { msg += err.toString() + "\n"; } assertTrue(msg, compiler.getErrorCount() == 0); } } public void helperInlineReferenceToFunction( String code, final String expectedResult, final String fnName, final InliningMode mode, final boolean decompose) { final Compiler compiler = new Compiler(); final FunctionInjector injector = new FunctionInjector( compiler, compiler.getUniqueNameIdSupplier(), decompose, assumeStrictThis, assumeMinimumCapture); List<SourceFile> externsInputs = Lists.newArrayList( SourceFile.fromCode("externs", "")); CompilerOptions options = new CompilerOptions(); options.setCodingConvention(new GoogleCodingConvention()); compiler.init(externsInputs, Lists.newArrayList( SourceFile.fromCode("code", code)), options); Node parseRoot = compiler.parseInputs(); Node externsRoot = parseRoot.getFirstChild(); final Node tree = parseRoot.getLastChild(); assertNotNull(tree); assertTrue(tree != externsRoot); final Node expectedRoot = parseExpected(new Compiler(), expectedResult); Node mainRoot = tree; MarkNoSideEffectCalls mark = new MarkNoSideEffectCalls(compiler); mark.process(externsRoot, mainRoot); Normalize normalize = new Normalize(compiler, false); normalize.process(externsRoot, mainRoot); compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED); final Node fnNode = findFunction(tree, fnName); assertNotNull(fnNode); final Set<String> unsafe = FunctionArgumentInjector.findModifiedParameters(fnNode); assertNotNull(fnNode); // inline tester Method tester = new Method() { @Override public boolean call(NodeTraversal t, Node n, Node parent) { CanInlineResult canInline = injector.canInlineReferenceToFunction( t, n, fnNode, unsafe, mode, NodeUtil.referencesThis(fnNode), NodeUtil.containsFunction(NodeUtil.getFunctionBody(fnNode))); assertTrue("canInlineReferenceToFunction should not be CAN_NOT_INLINE", CanInlineResult.NO != canInline); if (decompose) { assertTrue("canInlineReferenceToFunction " + "should be CAN_INLINE_AFTER_DECOMPOSITION", CanInlineResult.AFTER_PREPARATION == canInline); Set<String> knownConstants = Sets.newHashSet(); ExpressionDecomposer decomposer = new ExpressionDecomposer( compiler, compiler.getUniqueNameIdSupplier(), knownConstants); injector.setKnownConstants(knownConstants); injector.maybePrepareCall(n); assertTrue("canInlineReferenceToFunction " + "should be CAN_INLINE", CanInlineResult.YES != canInline); } Node result = injector.inline( t, n, fnName, fnNode, mode); validateSourceInfo(compiler, result); String explanation = expectedRoot.checkTreeEquals(tree.getFirstChild()); assertNull("\nExpected: " + toSource(expectedRoot) + "\nResult: " + toSource(tree.getFirstChild()) + "\n" + explanation, explanation); return true; } }; compiler.resetUniqueNameId(); TestCallback test = new TestCallback(fnName, tester); NodeTraversal.traverse(compiler, tree, test); } interface Method { boolean call(NodeTraversal t, Node n, Node parent); } class TestCallback implements Callback { private final String callname; private final Method method; private boolean complete = false; TestCallback(String callname, Method method) { this.callname = callname; this.method = method; } @Override public boolean shouldTraverse( NodeTraversal nodeTraversal, Node n, Node parent) { return !complete; } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isCall()) { Node callee; if (NodeUtil.isGet(n.getFirstChild())) { callee = n.getFirstChild().getFirstChild(); } else { callee = n.getFirstChild(); } if (callee.isName() && callee.getString().equals(callname)) { complete = method.call(t, n, parent); } } if (parent == null) { assertTrue(complete); } } } private static Node findFunction(Node n, String name) { if (n.isFunction()) { if (n.getFirstChild().getString().equals(name)) { return n; } } for (Node c : n.children()) { Node result = findFunction(c, name); if (result != null) { return result; } } return null; } private static Node prep(String js) { Compiler compiler = new Compiler(); Node n = compiler.parseTestCode(js); assertEquals(0, compiler.getErrorCount()); return n.getFirstChild(); } private static Node parse(Compiler compiler, String js) { Node n = compiler.parseTestCode(js); assertEquals(0, compiler.getErrorCount()); return n; } private static Node parseExpected(Compiler compiler, String js) { Node n = compiler.parseTestCode(js); String message = "Unexpected errors: "; JSError[] errs = compiler.getErrors(); for (int i = 0; i < errs.length; i++){ message += "\n" + errs[i].toString(); } assertEquals(message, 0, compiler.getErrorCount()); return n; } private static String toSource(Node n) { return new CodePrinter.Builder(n) .setPrettyPrint(false) .setLineBreak(false) .setSourceMap(null) .build(); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.Maps; import com.google.javascript.rhino.Node; import java.util.Map; /** * Tests for {@link FunctionNames} * */ public class FunctionNamesTest extends CompilerTestCase { private FunctionNames functionNames; public FunctionNamesTest() { this.functionNames = null; } @Override protected CompilerPass getProcessor(Compiler compiler) { functionNames = new FunctionNames(compiler); return functionNames; } public void testFunctionsNamesAndIds() { final String jsSource = "goog.widget = function(str) {\n" + " this.member_fn = function() {};\n" + " local_fn = function() {};\n" + " (function(a){})(1);\n" + "}\n" + "function foo() {\n" + " function bar() {}\n" + "}\n" + "literal = {f1 : function(){}, f2 : function(){}};\n" + "goog.array.map(arr, function named(){});\n" + "goog.array.map(arr, function(){});\n" + "named_twice = function quax(){};\n" + "recliteral = {l1 : {l2 : function(){}}};\n" + "namedliteral = {n1 : function litnamed(){}};\n" + "namedrecliteral = {n1 : {n2 : function reclitnamed(){}}};\n" + "numliteral = {1 : function(){}};\n" + "recnumliteral = {1 : {a : function(){}}};\n"; testSame(jsSource); final Map<Integer, String> idNameMap = Maps.newLinkedHashMap(); int count = 0; for (Node f : functionNames.getFunctionNodeList()) { int id = functionNames.getFunctionId(f); String name = functionNames.getFunctionName(f); idNameMap.put(id, name); count++; } assertEquals("Unexpected number of functions", 16, count); final Map<Integer, String> expectedMap = Maps.newLinkedHashMap(); expectedMap.put(0, "goog.widget.member_fn"); expectedMap.put(1, "goog.widget::local_fn"); expectedMap.put(2, "goog.widget::<anonymous>"); expectedMap.put(3, "goog.widget"); expectedMap.put(4, "foo::bar"); expectedMap.put(5, "foo"); expectedMap.put(6, "literal.f1"); expectedMap.put(7, "literal.f2"); expectedMap.put(8, "named"); expectedMap.put(9, "<anonymous>"); expectedMap.put(10, "quax"); expectedMap.put(11, "recliteral.l1.l2"); expectedMap.put(12, "litnamed"); expectedMap.put(13, "reclitnamed"); expectedMap.put(14, "numliteral.__2"); expectedMap.put(15, "recnumliteral.__3.a"); assertEquals("Function id/name mismatch", expectedMap, idNameMap); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Tests for {@link FunctionRewriter} * */ public class FunctionRewriterTest extends CompilerTestCase { private static final String RETURNARG_HELPER = "function JSCompiler_returnArg(JSCompiler_returnArg_value){" + " return function() { return JSCompiler_returnArg_value }" + "}"; private static final String GET_HELPER = "function JSCompiler_get(JSCompiler_get_name){" + " return function() { return this[JSCompiler_get_name] }" + "}"; private static final String SET_HELPER = "function JSCompiler_set(JSCompiler_set_name) {" + " return function(JSCompiler_set_value){" + " this[JSCompiler_set_name]=JSCompiler_set_value" + " }" + "}"; private static final String EMPTY_HELPER = "function JSCompiler_emptyFn() {" + " return function(){}" + "}"; private static final String IDENTITY_HELPER = "function JSCompiler_identityFn() {" + " return function(JSCompiler_identityFn_value) {" + " return JSCompiler_identityFn_value" + " }" + "}"; @Override protected void setUp() { super.enableLineNumberCheck(false); } @Override protected FunctionRewriter getProcessor(Compiler compiler) { return new FunctionRewriter(compiler); } @Override protected int getNumRepetitions() { // Pass reaches steady state after just 1 iteration return 1; } public void testReplaceReturnConst1() { String source = "a.prototype.foo = function() {return \"foobar\"}"; checkCompilesToSame(source, 3); checkCompilesTo(source, RETURNARG_HELPER, "a.prototype.foo = JSCompiler_returnArg(\"foobar\")", 4); } public void testReplaceReturnConst2() { checkCompilesToSame("a.prototype.foo = function() {return foobar}", 10); } public void testReplaceReturnConst3() { String source = "a.prototype.foo = function() {return void 0;}"; checkCompilesToSame(source, 3); checkCompilesTo(source, RETURNARG_HELPER, "a.prototype.foo = JSCompiler_returnArg(void 0)", 4); } public void testReplaceGetter1() { String source = "a.prototype.foo = function() {return this.foo_}"; checkCompilesToSame(source, 3); checkCompilesTo(source, GET_HELPER, "a.prototype.foo = JSCompiler_get(\"foo_\")", 4); } public void testReplaceGetter2() { checkCompilesToSame("a.prototype.foo = function() {return}", 10); } public void testReplaceSetter1() { String source = "a.prototype.foo = function(v) {this.foo_ = v}"; checkCompilesToSame(source, 4); checkCompilesTo(source, SET_HELPER, "a.prototype.foo = JSCompiler_set(\"foo_\")", 5); } public void testReplaceSetter2() { String source = "a.prototype.foo = function(v, v2) {this.foo_ = v}"; checkCompilesToSame(source, 3); checkCompilesTo(source, SET_HELPER, "a.prototype.foo = JSCompiler_set(\"foo_\")", 4); } public void testReplaceSetter3() { checkCompilesToSame("a.prototype.foo = function() {this.foo_ = v}", 10); } public void testReplaceSetter4() { checkCompilesToSame( "a.prototype.foo = function(v, v2) {this.foo_ = v2}", 10); } public void testReplaceEmptyFunction1() { String source = "a.prototype.foo = function() {}"; checkCompilesToSame(source, 4); checkCompilesTo(source, EMPTY_HELPER, "a.prototype.foo = JSCompiler_emptyFn()", 5); } public void testReplaceEmptyFunction2() { checkCompilesToSame("function foo() {}", 10); } public void testReplaceEmptyFunction3() { String source = "var foo = function() {}"; checkCompilesToSame(source, 4); checkCompilesTo(source, EMPTY_HELPER, "var foo = JSCompiler_emptyFn()", 5); } public void testReplaceIdentityFunction1() { String source = "a.prototype.foo = function(a) {return a}"; checkCompilesToSame(source, 2); checkCompilesTo(source, IDENTITY_HELPER, "a.prototype.foo = JSCompiler_identityFn()", 3); } public void testReplaceIdentityFunction2() { checkCompilesToSame("a.prototype.foo = function(a) {return a + 1}", 10); } public void testIssue538() { checkCompilesToSame( "/** @constructor */\n" + "WebInspector.Setting = function() {}\n" + "WebInspector.Setting.prototype = {\n" + " get name0(){return this._name;},\n" + " get name1(){return this._name;},\n" + " get name2(){return this._name;},\n" + " get name3(){return this._name;},\n" + " get name4(){return this._name;},\n" + " get name5(){return this._name;},\n" + " get name6(){return this._name;},\n" + " get name7(){return this._name;},\n" + " get name8(){return this._name;},\n" + " get name9(){return this._name;},\n" + "}", 1); } private void checkCompilesTo(String src, String expectedHdr, String expectedBody, int repetitions) { StringBuilder srcBuffer = new StringBuilder(); StringBuilder expectedBuffer = new StringBuilder(); expectedBuffer.append(expectedHdr); for (int idx = 0; idx < repetitions; idx++) { if (idx != 0) { srcBuffer.append(";"); expectedBuffer.append(";"); } srcBuffer.append(src); expectedBuffer.append(expectedBody); } test(srcBuffer.toString(), expectedBuffer.toString()); } private void checkCompilesToSame(String src, int repetitions) { checkCompilesTo(src, "", src, repetitions); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.javascript.jscomp.AbstractCompiler.LifeCycleStage; import com.google.javascript.jscomp.NodeTraversal.Callback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import junit.framework.TestCase; import java.util.Set; /** * @author johnlenz@google.com (John Lenz) */ public class FunctionToBlockMutatorTest extends TestCase { public void testMutateNoReturnWithoutResultAssignment() { helperMutate( "function foo(){}; foo();", "{}", "foo"); } public void testMutateNoReturnWithResultAssignment() { helperMutate( "function foo(){}; var result = foo();", "{result = void 0}", "foo", true, false); } public void testMutateNoValueReturnWithoutResultAssignment() { helperMutate( "function foo(){return;}; foo();", "{}", "foo", null); } public void testMutateNoValueReturnWithResultAssignment() { helperMutate( "function foo(){return;}; var result = foo();", "{result = void 0}", "foo"); } public void testMutateValueReturnWithoutResultAssignment() { helperMutate( "function foo(){return true;}; foo();", "{true;}", "foo", null); } public void testMutateValueReturnWithResultAssignment() { helperMutate( "function foo(){return true;}; var x=foo();", "{x=true}", "foo", "x", true, false); } public void testMutateWithMultipleReturns() { helperMutate( "function foo(){ if (0) {return 0} else {return 1} };" + "var result=foo();", "{" + "JSCompiler_inline_label_foo_0:{" + "if(0) {" + "result=0; break JSCompiler_inline_label_foo_0" + "} else {" + "result=1; break JSCompiler_inline_label_foo_0" + "} result=void 0" + "}" + "}", "foo", true, false); } public void testMutateWithParameters1() { // Simple call with useless parameter helperMutate( "function foo(a){return true;}; foo(x);", "{true}", "foo", null); } public void testMutateWithParameters2() { // Simple call with parameter helperMutate( "function foo(a){return x;}; foo(x);", "{x}", "foo", null); } public void testMutateWithParameters3() { // Parameter has side-effects. helperMutate( "function foo(a){return a;}; " + "function x() { foo(x++); }", "{var a$$inline_0 = x++; a$$inline_0}", "foo", null); } public void testMutate8() { // Parameter has side-effects. helperMutate( "function foo(a){return a+a;}; foo(x++);", "{var a$$inline_0 = x++;" + "a$$inline_0 + a$$inline_0;}", "foo", null); } public void testMutateInitializeUninitializedVars1() { helperMutate( "function foo(a){var b;return a;}; foo(1);", "{var b$$inline_1=void 0;1}", "foo", null, false, true); } public void testMutateInitializeUninitializedVars2() { helperMutate( "function foo(a){for(var b in c)return a;}; foo(1);", "{JSCompiler_inline_label_foo_2:" + "{" + "for(var b$$inline_1 in c){" + "1;break JSCompiler_inline_label_foo_2" + "}" + "}" + "}", "foo", null); } public void testMutateCallInLoopVars1() { // baseline: outside a loop, the constant remains constant. boolean callInLoop = false; helperMutate( "function foo(a){var B = bar(); a;}; foo(1);", "{var B$$inline_1=bar(); 1;}", "foo", null, false, callInLoop); // ... in a loop, the constant-ness is removed. // TODO(johnlenz): update this test to look for the const annotation. callInLoop = true; helperMutate( "function foo(a){var B = bar(); a;}; foo(1);", "{var B$$inline_1 = bar(); 1;}", "foo", null, false, callInLoop); } public void testMutateFunctionDefinition() { // function declarations are rewritten as function // expressions helperMutate( "function foo(a){function g(){}}; foo(1);", "{var g$$inline_1=function(){};}", "foo", null); } public void helperMutate( String code, final String expectedResult, final String fnName) { helperMutate(code, expectedResult, fnName, false, false); } public void helperMutate( String code, final String expectedResult, final String fnName, final boolean needsDefaultResult, final boolean isCallInLoop) { helperMutate(code, expectedResult, fnName, "result", needsDefaultResult, isCallInLoop); } public void helperMutate( String code, final String expectedResult, final String fnName, final String resultName) { helperMutate(code, expectedResult, fnName, resultName, false, false); } private void validateSourceInfo(Compiler compiler, Node subtree) { (new LineNumberCheck(compiler)).setCheckSubTree(subtree); // Source information problems are reported as compiler errors. if (compiler.getErrorCount() != 0) { String msg = "Error encountered: "; for (JSError err : compiler.getErrors()) { msg += err.toString() + "\n"; } assertTrue(msg, compiler.getErrorCount() == 0); } } public void helperMutate( String code, final String expectedResult, final String fnName, final String resultName, final boolean needsDefaultResult, final boolean isCallInLoop) { final Compiler compiler = new Compiler(); final FunctionToBlockMutator mutator = new FunctionToBlockMutator( compiler, compiler.getUniqueNameIdSupplier()); Node expectedRoot = parse(compiler, expectedResult); Preconditions.checkState(compiler.getErrorCount() == 0); final Node expected = expectedRoot.getFirstChild(); final Node tree = parse(compiler, code); Preconditions.checkState(compiler.getErrorCount() == 0); Node externsRoot = new Node(Token.EMPTY); Node mainRoot = tree; MarkNoSideEffectCalls mark = new MarkNoSideEffectCalls(compiler); mark.process(externsRoot, mainRoot); final Node fnNode = findFunction(tree, fnName); final Set<String> unsafe = FunctionArgumentInjector.findModifiedParameters(fnNode); // Fake precondition. compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED); // inline tester Method tester = new Method() { @Override public boolean call(NodeTraversal t, Node n, Node parent) { Node result = mutator.mutate( fnName, fnNode, n, resultName, needsDefaultResult, isCallInLoop); validateSourceInfo(compiler, result); String explanation = expected.checkTreeEquals(result); assertNull("\nExpected: " + compiler.toSource(expected) + "\nResult: " + compiler.toSource(result) + "\n" + explanation, explanation); return true; } }; compiler.resetUniqueNameId(); TestCallback test = new TestCallback(fnName, tester); NodeTraversal.traverse(compiler, tree, test); } interface Method { boolean call(NodeTraversal t, Node n, Node parent); } class TestCallback implements Callback { private final String callname; private final Method method; private boolean complete = false; TestCallback(String callname, Method method) { this.callname = callname; this.method = method; } @Override public boolean shouldTraverse( NodeTraversal nodeTraversal, Node n, Node parent) { return !complete; } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isCall()) { Node first = n.getFirstChild(); if (first.isName() && first.getString().equals(callname)) { complete = method.call(t, n, parent); } } if (parent == null) { assertTrue(complete); } } } private static Node findFunction(Node n, String name) { if (n.isFunction()) { if (n.getFirstChild().getString().equals(name)) { return n; } } for (Node c : n.children()) { Node result = findFunction(c, name); if (result != null) { return result; } } return null; } private static Node parse(Compiler compiler, String js) { Node n = compiler.parseTestCode(js); assertEquals(0, compiler.getErrorCount()); return n; } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import static com.google.javascript.rhino.testing.BaseJSTypeTestCase.ALL_NATIVE_EXTERN_TYPES; import com.google.javascript.jscomp.CheckLevel; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.ObjectType; import java.util.List; /** * Unit tests for {@link FunctionTypeBuilder}. * */ public class FunctionTypeBuilderTest extends CompilerTestCase { public FunctionTypeBuilderTest() { parseTypeInfo = true; enableTypeCheck(CheckLevel.WARNING); } @Override public CompilerPass getProcessor(Compiler compiler) { // By turning on type checking, the FunctionTypeBuilder will be invoked. return new CompilerPass() { @Override public void process(Node externs, Node js) {} }; } @Override public int getNumRepetitions() { return 1; } public void testValidBuiltInTypeRedefinition() throws Exception { testSame(ALL_NATIVE_EXTERN_TYPES, "", null); } public void testBuiltInTypeDifferentReturnType() throws Exception { testSame( "/**\n" + " * @constructor\n" + " * @param {*} opt_str\n" + " * @return {number}\n" + " */\n" + "function String(opt_str) {}\n", "", FunctionTypeBuilder.TYPE_REDEFINITION, "attempted re-definition of type String\n" + "found : function (new:String, *=): number\n" + "expected: function (new:String, *=): string"); } public void testBuiltInTypeDifferentNumParams() throws Exception { testSame( "/**\n" + " * @constructor\n" + " * @return {string}\n" + " */\n" + "function String() {}\n", "", FunctionTypeBuilder.TYPE_REDEFINITION, "attempted re-definition of type String\n" + "found : function (new:String): string\n" + "expected: function (new:String, *=): string"); } public void testBuiltInTypeDifferentNumParams2() throws Exception { testSame( "/**\n" + " * @constructor\n" + " * @return {string}\n" + " */\n" + "function String(opt_str, opt_nothing) {}\n", "", FunctionTypeBuilder.TYPE_REDEFINITION, "attempted re-definition of type String\n" + "found : function (new:String, ?=, ?=): string\n" + "expected: function (new:String, *=): string"); } public void testBuiltInTypeDifferentParamType() throws Exception { testSame( "/**\n" + " * @constructor\n" + " * @return {string}\n" + " */\n" + "function String(opt_str) {}\n", "", FunctionTypeBuilder.TYPE_REDEFINITION, "attempted re-definition of type String\n" + "found : function (new:String, ?=): string\n" + "expected: function (new:String, *=): string"); } public void testBadFunctionTypeDefinition() throws Exception { testSame( "/** @constructor */function Function(opt_str) {}\n", "", FunctionTypeBuilder.TYPE_REDEFINITION, "attempted re-definition of type Function\n" + "found : function (new:Function, ?=): ?\n" + "expected: function (new:Function, ...[*]): ?"); } public void testExternSubTypes() throws Exception { testSame(ALL_NATIVE_EXTERN_TYPES, "", null); List<FunctionType> subtypes = ((ObjectType) getLastCompiler() .getTypeRegistry().getType("Error")).getConstructor().getSubTypes(); for (FunctionType type : subtypes) { String typeName = type.getInstanceType().toString(); FunctionType typeInRegistry = ((ObjectType) getLastCompiler() .getTypeRegistry().getType(typeName)).getConstructor(); assertTrue(typeInRegistry == type); } } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.Sets; import java.util.Set; /** * Tests for {@link GatherRawExports}. * * @author johnlenz@google.com (John Lenz) */ public class GatherRawExportsTest extends CompilerTestCase { private static final String EXTERNS = "var window;"; private GatherRawExports last; public GatherRawExportsTest() { super(EXTERNS); super.enableNormalize(); } @Override protected CompilerPass getProcessor(Compiler compiler) { last = new GatherRawExports(compiler); return last; } public void testExportsFound1() { assertExported("var a"); } public void testExportsFound2() { assertExported("window['a']", "a"); } public void testExportsFound3() { assertExported("window.a", "a"); } public void testExportsFound4() { assertExported("this['a']", "a"); } public void testExportsFound5() { assertExported("this.a", "a"); } public void testExportsFound6() { assertExported("function f() { this['a'] }"); } public void testExportsFound7() { assertExported("function f() { this.a }"); } public void testExportsFound8() { assertExported("window['foo']", "foo"); } public void testExportsFound9() { assertExported("window['a'] = 1;", "a"); } public void testExportsFound10() { assertExported("window['a']['b']['c'] = 1;", "a"); } public void testExportsFound11() { assertExported("if (window['a'] = 1) alert(x);", "a"); } public void testExportsFound12() { assertExported("function foo() { window['a'] = 1; }", "a"); } public void testExportsFound13() { assertExported("function foo() {var window; window['a'] = 1; }"); } public void testExportsFound14() { assertExported("var a={window:{}}; a.window['b']"); } public void testExportsFound15() { assertExported("window.window['b']", "window"); } public void testExportsFound16() { // It would be nice to handle this case, hopefully inlining will take care // of it for us. assertExported("var a = window; a['b']"); } public void testExportOnTopFound1() { assertExported("top['a']", "a"); } public void testExportOntopFound2() { assertExported("top.a", "a"); } private void assertExported(String js, String ... names) { Set<String> setNames = Sets.newHashSet(names); testSame(js); assertTrue(last.getExportedVariableNames().equals(setNames)); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.javascript.jscomp.GatherSideEffectSubexpressionsCallback.GetReplacementSideEffectSubexpressions; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import junit.framework.TestCase; import java.util.List; /** * Tests for {@link GatherSideEffectSubexpressionsCallback} * */ public class GatherSideEffectSubexpressionsCallbackTest extends TestCase { public void testAndOr() throws Exception { Node andNode = getSideEffectsAndNode(); checkKeepSimplifiedShortCircuitExpr(andNode, ImmutableList.of("foo&&(bar=0)")); } public void testIllegalArgumentIfNotAndOr() throws Exception { Node nameNode = Node.newString(Token.NAME, "foo"); try { checkKeepSimplifiedShortCircuitExpr(nameNode, ImmutableList.<String>of()); fail("Expected exception"); } catch (IllegalArgumentException e) { // ignore } } public void testIllegalArgumentIfNoSideEffectAndOr() throws Exception { Node andNode = getNoSideEffectsAndNode(); try { checkKeepSimplifiedShortCircuitExpr(andNode, ImmutableList.<String>of()); fail("Expected exception"); } catch (IllegalArgumentException e) { // ignore } } public void testHook() throws Exception { Node hook = getSideEffectsHookNode(); checkKeepSimplifiedHookExpr(hook, true, true, ImmutableList.of("foo?bar=0:baz=0")); } public void testIllegalArgumentIfNotHook() throws Exception { Node nameNode = Node.newString(Token.NAME, "foo"); try { checkKeepSimplifiedHookExpr(nameNode, true, true, ImmutableList.<String>of()); fail("Expected exception"); } catch (IllegalArgumentException e) { // ignore } } public void testIllegalArgumentIfNoSideEffectHook() throws Exception { Node hookNode = getNoSideEffectsHookNode(); try { checkKeepSimplifiedHookExpr(hookNode, true, true, ImmutableList.<String>of()); fail("Expected exception"); } catch (IllegalArgumentException e) { // ignore } } public void testIllegalArgumentIfHookKeepNeitherBranch() throws Exception { Node hookNode = getSideEffectsHookNode(); try { checkKeepSimplifiedHookExpr(hookNode, false, false, ImmutableList.<String>of()); fail("Expected exception"); } catch (IllegalArgumentException e) { // ignore } } private Node getNoSideEffectsAndNode() { Node andNode = new Node(Token.AND); andNode.addChildToBack(Node.newString(Token.NAME, "foo")); andNode.addChildToBack(Node.newString(Token.NAME, "bar")); return andNode; } private Node getSideEffectsAndNode() { Node andNode = new Node(Token.AND); Node assign = new Node(Token.ASSIGN); assign.addChildToBack(Node.newString(Token.NAME, "bar")); assign.addChildToBack(Node.newNumber(0)); andNode.addChildToBack(Node.newString(Token.NAME, "foo")); andNode.addChildToBack(assign); return andNode; } private Node getNoSideEffectsHookNode() { Node hookNode = new Node(Token.HOOK); hookNode.addChildToBack(Node.newString(Token.NAME, "foo")); hookNode.addChildToBack(Node.newString(Token.NAME, "bar")); hookNode.addChildToBack(Node.newString(Token.NAME, "baz")); return hookNode; } private Node getSideEffectsHookNode() { Node hookNode = new Node(Token.HOOK); Node assign1 = new Node(Token.ASSIGN); assign1.addChildToBack(Node.newString(Token.NAME, "bar")); assign1.addChildToBack(Node.newNumber(0)); Node assign2 = new Node(Token.ASSIGN); assign2.addChildToBack(Node.newString(Token.NAME, "baz")); assign2.addChildToBack(Node.newNumber(0)); hookNode.addChildToBack(Node.newString(Token.NAME, "foo")); hookNode.addChildToBack(assign1); hookNode.addChildToBack(assign2); return hookNode; } private void checkKeepSimplifiedShortCircuitExpr(Node root, List<String> expected) { Compiler compiler = new Compiler(); List<Node> replacements = Lists.newArrayList(); GetReplacementSideEffectSubexpressions accumulator = new GetReplacementSideEffectSubexpressions(compiler, replacements); accumulator.keepSimplifiedShortCircuitExpression(root); List<String> actual = Lists.newArrayList(); for (Node replacement : replacements) { actual.add(compiler.toSource(replacement)); } assertEquals(expected, actual); } private void checkKeepSimplifiedHookExpr(Node root, boolean thenHasSideEffects, boolean elseHasSideEffects, List<String> expected) { Compiler compiler = new Compiler(); List<Node> replacements = Lists.newArrayList(); GetReplacementSideEffectSubexpressions accumulator = new GetReplacementSideEffectSubexpressions(compiler, replacements); accumulator.keepSimplifiedHookExpression(root, thenHasSideEffects, elseHasSideEffects); List<String> actual = Lists.newArrayList(); for (Node replacement : replacements) { actual.add(compiler.toSource(replacement)); } assertEquals(expected, actual); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Generate exports unit test. * */ public class GenerateExportsTest extends CompilerTestCase { private static final String EXTERNS = "function google_exportSymbol(a, b) {}; " + "goog.exportProperty = function(a, b, c) {}; "; public GenerateExportsTest() { super(EXTERNS); } @Override protected CompilerPass getProcessor(Compiler compiler) { return new GenerateExports(compiler, "google_exportSymbol", "goog.exportProperty"); } @Override protected int getNumRepetitions() { // This pass only runs once. return 1; } @Override public void setUp() throws Exception { super.setUp(); super.enableLineNumberCheck(false); } public void testExportSymbol() { test("/** @export */function foo() {}", "function foo(){}google_exportSymbol(\"foo\",foo)"); } public void testExportSymbolAndProperties() { test("/** @export */function foo() {}" + "/** @export */foo.prototype.bar = function() {}", "function foo(){}" + "google_exportSymbol(\"foo\",foo);" + "foo.prototype.bar=function(){};" + "goog.exportProperty(foo.prototype,\"bar\",foo.prototype.bar)"); } public void testExportSymbolAndConstantProperties() { test("/** @export */function foo() {}" + "/** @export */foo.BAR = 5;", "function foo(){}" + "google_exportSymbol(\"foo\",foo);" + "foo.BAR=5;" + "goog.exportProperty(foo,\"BAR\",foo.BAR)"); } public void testExportVars() { test("/** @export */var FOO = 5", "var FOO=5;" + "google_exportSymbol(\"FOO\",FOO)"); } public void testNoExport() { test("var FOO = 5", "var FOO=5"); } /** * Nested assignments are ambiguous and therefore not supported. * @see FindExportableNodes */ public void testNestedVarAssign() { test("var BAR;\n/** @export */var FOO = BAR = 5", null, FindExportableNodes.NON_GLOBAL_ERROR); } /** * Nested assignments are ambiguous and therefore not supported. * @see FindExportableNodes */ public void testNestedAssign() { test("var BAR;var FOO = {};\n/** @export */FOO.test = BAR = 5", null, FindExportableNodes.NON_GLOBAL_ERROR); } public void testNonGlobalScopeExport() { test("(function() { /** @export */var FOO = 5 })()", null, FindExportableNodes.NON_GLOBAL_ERROR); } public void testExportClass() { test("/** @export */ function G() {} foo();", "function G() {} google_exportSymbol('G', G); foo();"); } public void testExportSubclass() { test("var goog = {}; function F() {}" + "/** @export */ function G() {} goog.inherits(G, F);", "var goog = {}; function F() {}" + "function G() {} goog.inherits(G, F); google_exportSymbol('G', G);"); } public void testExportEnum() { // TODO(johnlenz): Issue 310, should the values also be externed? test("/** @enum {string}\n @export */ var E = {A:1, B:2};", "/** @enum {string}\n @export */ var E = {A:1, B:2};" + "google_exportSymbol('E', E);"); } }
/* * Copyright 2011 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import static com.google.javascript.jscomp.ReferenceCollectingCallback.Reference.createRefForTest; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.ReferenceCollectingCallback.Reference; import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import junit.framework.TestCase; import java.util.Map; /** * Unit-tests for the GlobalVarReferenceMap class. * * @author bashir@google.com (Bashir Sadjad) */ public class GlobalVarReferenceMapTest extends TestCase { private final CompilerInput INPUT1 = new CompilerInput(SourceFile.fromCode("input1", ""), false); private final CompilerInput INPUT2 = new CompilerInput(SourceFile.fromCode("input2", ""), false); private final CompilerInput INPUT3 = new CompilerInput(SourceFile.fromCode("input3", ""), false); private final CompilerInput EXTERN1 = new CompilerInput(SourceFile.fromCode("extern1", ""), true); private final GlobalVarReferenceMap map = new GlobalVarReferenceMap( Lists.newArrayList(INPUT1, INPUT2, INPUT3), Lists.newArrayList(EXTERN1)); private final Map<Var, ReferenceCollection> globalMap = Maps.newHashMap(); private final Node root = new Node(Token.BLOCK); private final Scope globalScope = Scope.createGlobalScope(root); private Node scriptRoot = new Node(Token.SCRIPT); // In the initial setUp we have 3 references to var1 (one in each input) and // 2 references to var2 (in first and third inputs), and 2 references to var3 // (in second input and first extern) private static final String VAR1 = "var1"; private static final String VAR2 = "var2"; private static final String VAR3 = "var3"; private final ReferenceCollection var1Refs = new ReferenceCollection(); private final ReferenceCollection var2Refs = new ReferenceCollection(); private final ReferenceCollection var3Refs = new ReferenceCollection(); private final Reference var1In1Ref = createRefForTest(INPUT1); private final Reference var1In2Ref = createRefForTest(INPUT2); private final Reference var1In3Ref = createRefForTest(INPUT3); private final Reference var2In1Ref = createRefForTest(INPUT1); private final Reference var2In3Ref = createRefForTest(INPUT3); private final Reference var3In2Ref = createRefForTest(INPUT2); private final Reference var3In1Ext = createRefForTest(EXTERN1); @Override protected void setUp() throws Exception { super.setUp(); globalScope.declare(VAR1, new Node(Token.NAME), null, INPUT1); var1Refs.references = Lists.newArrayList(var1In1Ref, var1In2Ref, var1In3Ref); globalScope.declare(VAR2, new Node(Token.NAME), null, INPUT1); var2Refs.references = Lists.newArrayList(var2In1Ref, var2In3Ref); globalScope.declare(VAR3, new Node(Token.NAME), null, EXTERN1); var3Refs.references = Lists.newArrayList(var3In1Ext, var3In2Ref); // We recreate these two ReferenceCollection to keep var1Refs and // var2Refs intact in update operations for comparison in the tests. ReferenceCollection var1TempRefs = new ReferenceCollection(); var1TempRefs.references = Lists.newArrayList(var1Refs.references); ReferenceCollection var2TempRefs = new ReferenceCollection(); var2TempRefs.references = Lists.newArrayList(var2Refs.references); ReferenceCollection var3TempRefs = new ReferenceCollection(); var3TempRefs.references = Lists.newArrayList(var3Refs.references); globalMap.put(globalScope.getVar(VAR1), var1TempRefs); globalMap.put(globalScope.getVar(VAR2), var2TempRefs); globalMap.put(globalScope.getVar(VAR3), var3TempRefs); map.updateGlobalVarReferences(globalMap, root); scriptRoot.setInputId(INPUT2.getInputId()); scriptRoot.setSourceFileForTesting(INPUT2.getName()); } /** Tests whether the global variable references are set/reset properly. */ public void testUpdateGlobalVarReferences_ResetReferences() { // First we check the original setup then reset again. for (int i = 0; i < 2; i++) { assertEquals(var1Refs.references, map.getReferences(globalScope.getVar(VAR1)).references); assertEquals(var2Refs.references, map.getReferences(globalScope.getVar(VAR2)).references); assertEquals(var3Refs.references, map.getReferences(globalScope.getVar(VAR3)).references); map.updateGlobalVarReferences(globalMap, root); } } /** Removes all variable references in second script. */ public void testUpdateGlobalVarReferences_UpdateScriptNoRef() { Map<Var, ReferenceCollection> scriptMap = Maps.newHashMap(); map.updateGlobalVarReferences(scriptMap, scriptRoot); ReferenceCollection refs = map.getReferences(globalScope.getVar(VAR2)); assertEquals(var2Refs.references, refs.references); refs = map.getReferences(globalScope.getVar(VAR1)); assertEquals(2, refs.references.size()); assertEquals(var1Refs.references.get(0), refs.references.get(0)); assertEquals(var1Refs.references.get(2), refs.references.get(1)); refs = map.getReferences(globalScope.getVar(VAR3)); assertEquals(1, refs.references.size()); assertEquals(var3Refs.references.get(0), refs.references.get(0)); } /** Changes variable references in second script. */ public void testUpdateGlobalVarReferences_UpdateScriptNewRefs() { Map<Var, ReferenceCollection> scriptMap = Maps.newHashMap(); ReferenceCollection newVar1Refs = new ReferenceCollection(); Reference newVar1In2Ref = createRefForTest(INPUT2); newVar1Refs.references = Lists.newArrayList(newVar1In2Ref); ReferenceCollection newVar2Refs = new ReferenceCollection(); Reference newVar2In2Ref = createRefForTest(INPUT2); newVar2Refs.references = Lists.newArrayList(newVar2In2Ref); ReferenceCollection newVar3Refs = new ReferenceCollection(); Reference newVar3In2Ref = createRefForTest(INPUT2); newVar3Refs.references = Lists.newArrayList(newVar3In2Ref); scriptMap.put(globalScope.getVar(VAR1), newVar1Refs); scriptMap.put(globalScope.getVar(VAR2), newVar2Refs); scriptMap.put(globalScope.getVar(VAR3), newVar3Refs); map.updateGlobalVarReferences(scriptMap, scriptRoot); ReferenceCollection refs = map.getReferences(globalScope.getVar(VAR1)); assertEquals(3, refs.references.size()); assertEquals(var1Refs.references.get(0), refs.references.get(0)); assertEquals(newVar1In2Ref, refs.references.get(1)); assertEquals(var1Refs.references.get(2), refs.references.get(2)); refs = map.getReferences(globalScope.getVar(VAR2)); assertEquals(3, refs.references.size()); assertEquals(var2Refs.references.get(0), refs.references.get(0)); assertEquals(newVar2In2Ref, refs.references.get(1)); assertEquals(var2Refs.references.get(1), refs.references.get(2)); refs = map.getReferences(globalScope.getVar(VAR3)); assertEquals(2, refs.references.size()); assertEquals(var3Refs.references.get(0), refs.references.get(0)); assertEquals(newVar3In2Ref, refs.references.get(1)); } /** Changes variable references in second script. */ public void testUpdateGlobalVarReferences_UpdateScriptNewVar() { Map<Var, ReferenceCollection> scriptMap = Maps.newHashMap(); final String var4 = "var4"; globalScope.declare(var4, new Node(Token.NAME), null, INPUT2); ReferenceCollection newVar3Refs = new ReferenceCollection(); Reference newVar3In2Ref = createRefForTest(INPUT2); newVar3Refs.references = Lists.newArrayList(newVar3In2Ref); scriptMap.put(globalScope.getVar(var4), newVar3Refs); map.updateGlobalVarReferences(scriptMap, scriptRoot); ReferenceCollection refs = map.getReferences(globalScope.getVar(var4)); assertEquals(1, refs.references.size()); assertEquals(newVar3In2Ref, refs.references.get(0)); } public void testUpdateReferencesWithGlobalScope() { Scope newGlobalScope = Scope.createGlobalScope(root); map.updateReferencesWithGlobalScope(newGlobalScope); ReferenceCollection references = map.getReferences(globalScope.getVar(VAR1)); for (Reference ref : references) { assertEquals(newGlobalScope, ref.getScope()); } references = map.getReferences(globalScope.getVar(VAR2)); for (Reference ref : references) { assertEquals(newGlobalScope, ref.getScope()); } references = map.getReferences(globalScope.getVar(VAR3)); for (Reference ref : references) { assertEquals(newGlobalScope, ref.getScope()); } } }
/* * Copyright 2007 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.jscomp.CodingConvention.SubclassRelationship; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import junit.framework.TestCase; /** * Test class for {@link GoogleCodingConvention}. */ public class GoogleCodingConventionTest extends TestCase { private GoogleCodingConvention conv = new GoogleCodingConvention(); public void testVarAndOptionalParams() { Node args = new Node(Token.PARAM_LIST, Node.newString(Token.NAME, "a"), Node.newString(Token.NAME, "b")); Node optArgs = new Node(Token.PARAM_LIST, Node.newString(Token.NAME, "opt_a"), Node.newString(Token.NAME, "opt_b")); assertFalse(conv.isVarArgsParameter(args.getFirstChild())); assertFalse(conv.isVarArgsParameter(args.getLastChild())); assertFalse(conv.isVarArgsParameter(optArgs.getFirstChild())); assertFalse(conv.isVarArgsParameter(optArgs.getLastChild())); assertFalse(conv.isOptionalParameter(args.getFirstChild())); assertFalse(conv.isOptionalParameter(args.getLastChild())); assertTrue(conv.isOptionalParameter(optArgs.getFirstChild())); assertTrue(conv.isOptionalParameter(optArgs.getLastChild())); } public void testInlineName() { assertFalse(conv.isConstant("a")); assertTrue(conv.isConstant("XYZ123_")); assertTrue(conv.isConstant("ABC")); assertFalse(conv.isConstant("ABCdef")); assertFalse(conv.isConstant("aBC")); assertFalse(conv.isConstant("A")); assertFalse(conv.isConstant("_XYZ123")); assertTrue(conv.isConstant("a$b$XYZ123_")); assertTrue(conv.isConstant("a$b$ABC_DEF")); assertTrue(conv.isConstant("a$b$A")); assertFalse(conv.isConstant("a$b$a")); assertFalse(conv.isConstant("a$b$ABCdef")); assertFalse(conv.isConstant("a$b$aBC")); assertFalse(conv.isConstant("a$b$")); assertFalse(conv.isConstant("$")); } public void testExportedName() { assertTrue(conv.isExported("_a")); assertTrue(conv.isExported("_a_")); assertFalse(conv.isExported("a")); assertFalse(conv.isExported("$super", false)); assertTrue(conv.isExported("$super", true)); assertTrue(conv.isExported("$super")); } public void testPrivateName() { assertTrue(conv.isPrivate("a_")); assertFalse(conv.isPrivate("a")); assertFalse(conv.isPrivate("_a_")); } public void testEnumKey() { assertTrue(conv.isValidEnumKey("A")); assertTrue(conv.isValidEnumKey("123")); assertTrue(conv.isValidEnumKey("FOO_BAR")); assertFalse(conv.isValidEnumKey("a")); assertFalse(conv.isValidEnumKey("someKeyInCamelCase")); assertFalse(conv.isValidEnumKey("_FOO_BAR")); } public void testInheritanceDetection1() { assertNotClassDefining("goog.foo(A, B);"); } public void testInheritanceDetection2() { assertDefinesClasses("goog.inherits(A, B);", "A", "B"); } public void testInheritanceDetection3() { assertDefinesClasses("A.inherits(B);", "A", "B"); } public void testInheritanceDetection4() { assertDefinesClasses("goog.inherits(goog.A, goog.B);", "goog.A", "goog.B"); } public void testInheritanceDetection5() { assertDefinesClasses("goog.A.inherits(goog.B);", "goog.A", "goog.B"); } public void testInheritanceDetection6() { assertNotClassDefining("A.inherits(this.B);"); } public void testInheritanceDetection7() { assertNotClassDefining("this.A.inherits(B);"); } public void testInheritanceDetection8() { assertNotClassDefining("goog.inherits(A, B, C);"); } public void testInheritanceDetection9() { assertDefinesClasses("A.mixin(B.prototype);", "A", "B"); } public void testInheritanceDetection10() { assertDefinesClasses("goog.mixin(A.prototype, B.prototype);", "A", "B"); } public void testInheritanceDetectionPostCollapseProperties() { assertDefinesClasses("goog$inherits(A, B);", "A", "B"); assertNotClassDefining("goog$inherits(A);"); } private void assertNotClassDefining(String code) { Node n = parseTestCode(code); assertNull(conv.getClassesDefinedByCall(n.getFirstChild())); } private void assertDefinesClasses(String code, String subclassName, String superclassName) { Node n = parseTestCode(code); SubclassRelationship classes = conv.getClassesDefinedByCall(n.getFirstChild()); assertNotNull(classes); assertEquals(subclassName, classes.subclassName); assertEquals(superclassName, classes.superclassName); } private Node parseTestCode(String code) { Compiler compiler = new Compiler(); return compiler.parseTestCode(code).getFirstChild(); } }
/* * Copyright 2010 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; public class GroupVariableDeclarationsTest extends CompilerTestCase { @Override protected void setUp() { super.enableLineNumberCheck(false); } public void testGroupingUninitializedVarsInScope() { // basic with just one fn call in between test("var a = 1; f1(); var b;", "var a = 1, b; f1();"); // > 1 line of code in between test("var a = \"mangoes\"; f1(); alert(a); var b;", "var a = \"mangoes\", b; f1(); alert(a);"); // nested block in between that also contains a declaration + initialization // of the variable that needs to be collapsed test("var a = 1; {var c; alert(c);} var b;", "var a = 1, c, b; {alert(c);}"); // multiple variables test("var a = 1; var b = 1; f1(); f2(); var c; var d;", "var a = 1, b, c, d; b = 1; f1(); f2();"); test("var a = 1; var b = 2; var c; f1(); f2(); var d, e;", "var a = 1, b, c, d, e; b = 2; f1(); f2();"); test("var a = 1, b = 2, c; f1(); f2(); var d; var e; " + "f3(); f4(); var f = 10; var g; var h = a + b;", "var a = 1, b = 2, c, d, e, f, g, h; f1(); f2(); f3(); f4(); " + "f = 10; h = a + b;"); } public void testGroupingInitializedVarsInScope() { // basic with just one fn call in between test("var a = 1; f1(); var b = 2;", "var a = 1, b; f1(); b = 2;"); // > 1 line of code in between test("var a = \"mangoes\"; f1(); alert(a); var b = 2;", "var a = \"mangoes\", b; f1(); alert(a); b = 2;"); // nested block in between that also contains a declaration + initialization // of the variable that needs to be collapsed test("var a = 1; {var c = 34; alert(c);} var b = 2;", "var a = 1, c, b; {c = 34; alert(c);} b = 2;"); // multiple variables test("var a = 1; var b = 1; f1(); f2(); var c = 3; var d = 4;", "var a = 1, b, c, d; b = 1; f1(); f2(); c = 3; d = 4;"); test("var a = 1; var b = 2; var c; f1(); f2(); var d = 4, e;", "var a = 1, b, c, d, e; b = 2; f1(); f2(); d = 4;"); test("var a = 1, b = 2, c; f1(); f2(); var d; var e = 6; " + "f3(); f4(); var f; var g; var h = a + b;", "var a = 1, b = 2, c, d, e, f, g, h; f1(); f2(); e = 6; " + "f3(); f4(); h = a + b;"); } public void testGroupingVarsInForAndForInLoops() { // test for loop test("var a = 1; for (var x = 0; x < 10; ++x) {a++;} var y;", "var a = 1, x, y; for (x = 0; x < 10; ++x) {a++;}"); test("var a = 1, x; for (x = 0; x < 10; ++x) {a++;} var y;", "var a = 1, x, y; for (x = 0; x < 10; ++x) {a++;}"); test("var a = 1, x; for (x; x < 10; ++x) {a++;} var y;", "var a = 1, x, y; for (x; x < 10; ++x) {a++;}"); test("var a = 1; for (; a < 10; ++a) {alert(a);} var y;", "var a = 1, y; for (; a < 10; ++a) {alert(a);}"); test("var a = 1; for (var x; x < 10; ++x) {a += 2;} var y = 5;", "var a = 1, x, y; for (; x < 10; ++x) {a += 2;} y = 5;"); // multiple loop-control variables in for loop test("var a = 1; " + "for (var a1 = 0, a2 = 10; a1 < 10 && a2 > 0; ++a1, --a2) {}" + "var x = 5;", "var a = 1, x;" + "for (var a1 = 0, a2 = 10; a1 < 10 && a2 > 0; ++a1, --a2) {} " + "x = 5;"); test("var a = 1; " + "for (var a1 = 0, a2; a1 < 10 && a2 > 0; ++a1, --a2) {}" + "var x = 5;", "var a = 1, a1, a2, x;" + "for (a1 = 0; a1 < 10 && a2 > 0; ++a1, --a2) {}" + "x = 5;"); test("var a = 1; " + "for (var a1, a2; a1 < 10 && a2 > 0; ++a1, --a2) {}" + "var x = 5;", "var a = 1, a1, a2, x;" + "for (; a1 < 10 && a2 > 0; ++a1, --a2) {}" + "x = 5;"); // test for-in loop test("var a = [1, 2, 3, 4]; for (var z in a) {alert(z);} var y;", "var a = [1, 2, 3, 4], z, y; for (z in a) {alert(z);}"); test("var a = [1, 2, 3, 4]; for (var z in a) {alert(z);} var y = 5;", "var a = [1, 2, 3, 4], z, y; for (z in a) {alert(z);} y = 5;"); test("var a; for (var z in a = [1, 2, 3, 4]) {alert(z);} var y, x = 5;", "var a, z, y, x; for (z in a = [1, 2, 3, 4]) {alert(z);} x = 5;"); test("var a; for (var z = 1 in a = [1, 2, 3, 4]) {alert(z);} var y, x = 5;", "var a, y, x; for (var z = 1 in a = [1, 2, 3, 4]) {alert(z);} x = 5;"); test("var a, z; for (z in a = [1, 2, 3, 4]) {alert(z);} var y, x = 5;", "var a, z, y, x; for (z in a = [1, 2, 3, 4]) {alert(z);} x = 5;"); } public void testGroupingVarsNestedFunction() { test("function f(b) {var x; function g() {var x; a = x; var y;} var a;}", "function f(b) {var x, a; function g() {var x, y; a = x;}}"); } public void testGroupingVarsInnerFunction() { test("function f(b) {var x; h = x * x; var myfn = function() " + "{var x; a = x; var y;}; var a;}", "function f(b) {var x, myfn, a; h = x * x; myfn = function() " + "{var x, y; a = x;};}"); } public void testGroupingVarsFirstStatementNotVar() { test("f(); var a; g(); var b;", "f(); var a, b; g();"); } public void testGroupingVarsInScopeRegtest() { // regtest with lots of different scopes test("var x = 0, y = 1, z;" + "function f1(aa, bb) {" + " if (y) {" + " if (x === 0) {" + " var h, r = 999;" + " }" + " } else {" + " r = 1000;" + " }" + " var mylist = [1, 2, 3, 4];" + " var k1 = 200, k2 = 400;" + " for (var i1 = 0; i1 < 10; ++i1) {" + " for (var i2 in mylist) {" + " alert(i1);" + " }" + " }" + " var jam, q = 100;" + " var myfn = function() {" + " var x = 1;" + " f5();" + " var z = 5;" + " };" + " function f5() {" + " var aa = 5;" + " if (y === 1) {" + " var x = 100;" + " }" + " }" + "}" + "var h = x + y;" + "function g() {" + " y = 0;" + " { var x = 200;}" + " var h = y + x;" + "}" + "var ggg = 0;", // End of input "var x = 0, y = 1, z, h, ggg;" + "function f1(aa, bb) {" + " if (y) {" + " if (x === 0) {" + " var h, r = 999, mylist, i1, i2, jam, q, myfn;" + " }" + " } else {" + " r = 1000;" + " }" + " mylist = [1, 2, 3, 4];" + " var k1 = 200, k2 = 400;" + " for (i1 = 0; i1 < 10; ++i1) {" + " for (i2 in mylist) {" + " alert(i1);" + " }" + " }" + " q = 100; " + " myfn = function() {" + " var x = 1, z;" + " f5();" + " z = 5;" + " };" + " function f5() {" + " var aa = 5, x;" + " if (y === 1) {" + " x = 100;" + " }" + " }" + "}" + "h = x + y;" + "function g() {" + " y = 0;" + " { var x = 200, h;}" + " h = y + x;" + "}" + "ggg = 0;"); } @Override protected CompilerPass getProcessor(Compiler compiler) { return new GroupVariableDeclarations(compiler); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * {@link IgnoreCajaProperties} tests. * */ public class IgnoreCajaPropertiesTest extends CompilerTestCase { private static final String EXTERNS = "var z = {}, " + "f = function(y) { z[y] = z[y] ? (z[y]+1) : 1; }, " + "x, i;"; public IgnoreCajaPropertiesTest() { super(EXTERNS); } @Override public void setUp() { super.enableLineNumberCheck(false); } @Override public int getNumRepetitions() { return 1; } public void testSimpleKey() { // Test a one-statement body. test("for (i in x) f(i);", "for (var JSCompiler_IgnoreCajaProperties_0 in x)" + " if (!JSCompiler_IgnoreCajaProperties_0.match(/___$/)) {" + " i = JSCompiler_IgnoreCajaProperties_0;" + " { f(i); }" + " }"); // Test a two-statement body. test("for (i in x) { f(i); f(i); }", "for (var JSCompiler_IgnoreCajaProperties_0 in x)" + " if (!JSCompiler_IgnoreCajaProperties_0.match(/___$/)) {" + " i = JSCompiler_IgnoreCajaProperties_0;" + " { f(i); f(i); }" + " }"); // Check that the counter's incrementing properly and // that nested loops work. test("for (i in x) for (j in y) f(i,j);", "for (var JSCompiler_IgnoreCajaProperties_1 in x)" + " if (!JSCompiler_IgnoreCajaProperties_1.match(/___$/)) {" + " i = JSCompiler_IgnoreCajaProperties_1;" + " {" + " for (var JSCompiler_IgnoreCajaProperties_0 in y)" + " if (!JSCompiler_IgnoreCajaProperties_0.match(/___$/)) {" + " j = JSCompiler_IgnoreCajaProperties_0;" + " { f(i,j); }" + " }" + " }" + " }"); } public void testPropertyKey() { test("for (z.i in x) { f(z.i); f(z.i); }", "for (var JSCompiler_IgnoreCajaProperties_0 in x) {" + " if (!JSCompiler_IgnoreCajaProperties_0.match(/___$/)) {" + " z.i = JSCompiler_IgnoreCajaProperties_0;" + " { f(z.i); f(z.i); }" + " }" + "}"); } public void testFunctionPropertyKey() { // Note that both in the original code and the // rewritten code, z.j() is invoked on every // iteration of the loop. test("for (z.j().i in x) { f(z.j().i); f(z.j().i); }", "for (var JSCompiler_IgnoreCajaProperties_0 in x) {" + " if (!JSCompiler_IgnoreCajaProperties_0.match(/___$/)) {" + " z.j().i = JSCompiler_IgnoreCajaProperties_0;" + " { f(z.j().i); f(z.j().i); }" + " }" + "}"); } public void testVarKey() { // Test a one-statement body. test("for (var j in x) { f(j); }", "for (var JSCompiler_IgnoreCajaProperties_0 in x) {" + " if (!JSCompiler_IgnoreCajaProperties_0.match(/___$/)) {" + " var j;" + " j = JSCompiler_IgnoreCajaProperties_0;" + " { f(j); }" + " }" + "}"); // Test a two-statement body. test("for (var j in x) { f(j); f(j); }", "for (var JSCompiler_IgnoreCajaProperties_0 in x) {" + " if (!JSCompiler_IgnoreCajaProperties_0.match(/___$/)) {" + " var j;" + " j = JSCompiler_IgnoreCajaProperties_0;" + " { f(j); f(j); }" + " }" + "}"); // Test two loops. test("for (var i in x) for (var j in y) f(i,j);", "for (var JSCompiler_IgnoreCajaProperties_1 in x)" + " if (!JSCompiler_IgnoreCajaProperties_1.match(/___$/)) {" + " var i;" + " i = JSCompiler_IgnoreCajaProperties_1;" + " {" + " for (var JSCompiler_IgnoreCajaProperties_0 in y)" + " if (!JSCompiler_IgnoreCajaProperties_0.match(/___$/)) {" + " var j;" + " j = JSCompiler_IgnoreCajaProperties_0;" + " { f(i,j); }" + " }" + " }" + " }"); } public void testFourChildFor() { test("for (i = 0; i < 10; ++i) { f(i); }", "for (i = 0; i < 10; ++i) { f(i); }"); } @Override public CompilerPass getProcessor(Compiler compiler) { return new IgnoreCajaProperties(compiler); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.Lists; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.NodeTraversal.Callback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.ObjectType; import java.util.Deque; /** * Tests for {@link InferJSDocInfo}. * @author nicksantos@google.com (Nick Santos) */ // TODO(nicksantos): A lot of this code is duplicated from // TypedScopeCreatorTest. We should create a common test harness for // assertions about type information. public class InferJSDocInfoTest extends CompilerTestCase { private Scope globalScope; @Override public int getNumRepetitions() { return 1; } @Override protected CompilerOptions getOptions() { CompilerOptions options = super.getOptions(); options.ideMode = true; return options; } private final Callback callback = new AbstractPostOrderCallback() { @Override public void visit(NodeTraversal t, Node n, Node parent) { Scope s = t.getScope(); if (s.isGlobal()) { globalScope = s; } } }; @Override public CompilerPass getProcessor(final Compiler compiler) { return new CompilerPass() { @Override public void process(Node externs, Node root) { MemoizedScopeCreator scopeCreator = new MemoizedScopeCreator(new TypedScopeCreator(compiler)); Scope topScope = scopeCreator.createScope(root.getParent(), null); (new TypeInferencePass( compiler, compiler.getReverseAbstractInterpreter(), topScope, scopeCreator)).process(externs, root); NodeTraversal t = new NodeTraversal( compiler, callback, scopeCreator); t.traverseRoots(Lists.newArrayList(externs, root)); (new InferJSDocInfo(compiler)).process(externs, root); } }; } public void testNativeCtor() { testSame( "/** Object. \n * @param {*=} x \n * @constructor */ " + "function Object(x) {};", "var x = new Object();" + "/** Another object. */ var y = new Object();", null); assertEquals( "Object.", findGlobalNameType("x").getJSDocInfo().getBlockDescription()); assertEquals( "Object.", findGlobalNameType("y").getJSDocInfo().getBlockDescription()); assertEquals( "Object.", globalScope.getVar("y").getType().getJSDocInfo().getBlockDescription()); } public void testStructuralFunctions() { testSame( "/** Object. \n * @param {*=} x \n * @constructor */ " + "function Object(x) {};", "/** Function. \n * @param {*} x */ " + "function fn(x) {};" + "var goog = {};" + "/** Another object. \n * @type {Object} */ goog.x = new Object();" + "/** Another function. \n * @param {number} x */ goog.y = fn;", null); assertEquals( "(Object|null)", globalScope.getVar("goog.x").getType().toString()); assertEquals( "Object.", globalScope.getVar("goog.x").getType().restrictByNotNullOrUndefined() .getJSDocInfo().getBlockDescription()); assertEquals( "Another function.", globalScope.getVar("goog.y").getType() .getJSDocInfo().getBlockDescription()); } public void testInstanceObject() { // Asserts that no property gets attached to the instance object. testSame( "/** @constructor */ function Foo() {}" + "var f = new Foo();" + "/** @type {number} */ f.bar = 4;"); ObjectType type = (ObjectType) globalScope.getVar("f").getType(); assertEquals("Foo", type.toString()); assertFalse(type.hasProperty("bar")); assertNull(type.getOwnPropertyJSDocInfo("bar")); } public void testInterface() { testSame( "/** An interface. \n * @interface */ function Foo() {}" + "var f = new Foo();" + "/** @type {number} */ f.bar = 4;"); ObjectType type = (ObjectType) globalScope.getVar("Foo").getType(); assertEquals( "An interface.", type.getJSDocInfo().getBlockDescription()); } public void testNamespacedCtor() { testSame( "var goog = {};" + "/** Hello! \n * @constructor */ goog.Foo = function() {};" + "goog.Foo.bar = goog.Foo;" + "/** Bye! \n * @param {string=} opt_x */" + "goog.Foo.prototype.baz = goog.Foo;" + "/** Blargh */ var x = new goog.Foo();"); assertEquals( "Hello!", findGlobalNameType("x").getJSDocInfo().getBlockDescription()); assertEquals( "Hello!", findGlobalNameType("goog.Foo").getJSDocInfo().getBlockDescription()); assertEquals( "Hello!", findGlobalNameType( "goog.Foo.bar").getJSDocInfo().getBlockDescription()); assertEquals( "Hello!", findGlobalNameType( "goog.Foo.prototype.baz").getJSDocInfo().getBlockDescription()); ObjectType proto = (ObjectType) findGlobalNameType("goog.Foo.prototype"); assertEquals( "Bye!", proto.getPropertyType("baz").getJSDocInfo().getBlockDescription()); } public void testAbstractMethod() { testSame( "/** Abstract method. \n * @type {!Function} */ var abstractMethod;" + "/** @constructor */ function Foo() {}" + "/** Block description. \n * @param {number} x */" + "Foo.prototype.bar = abstractMethod;"); FunctionType abstractMethod = (FunctionType) findGlobalNameType("abstractMethod"); assertNull(abstractMethod.getJSDocInfo()); FunctionType ctor = (FunctionType) findGlobalNameType("Foo"); ObjectType proto = ctor.getInstanceType().getImplicitPrototype(); FunctionType method = (FunctionType) proto.getPropertyType("bar"); assertEquals( "Block description.", method.getJSDocInfo().getBlockDescription()); assertEquals( "Block description.", proto.getOwnPropertyJSDocInfo("bar").getBlockDescription()); } private JSType findGlobalNameType(String name) { return findNameType(name, globalScope); } private JSType findNameType(String name, Scope scope) { Node root = scope.getRootNode(); Deque<Node> queue = Lists.newLinkedList(); queue.push(root); while (!queue.isEmpty()) { Node current = queue.pop(); if (name.equals(current.getQualifiedName()) && current.getJSType() != null) { return current.getJSType(); } for (Node child : current.children()) { queue.push(child); } } return null; } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.rhino.Node; import junit.framework.TestCase; /** * Unit test for {@link InlineCostEstimator}. * @author johnlenz@google.com (John Lenz) */ public class InlineCostEstimatorTest extends TestCase { static Node parse(String js) { Compiler compiler = new Compiler(); Node n = compiler.parseTestCode(js); assertEquals(0, compiler.getErrorCount()); return n; } static String minimize(String js) { CompilerOptions options = new CompilerOptions(); options.setLineLengthThreshold(Integer.MAX_VALUE); return new CodePrinter.Builder(parse(js)). setCompilerOptions(options). build(); } static long cost(String js) { return InlineCostEstimator.getCost(parse(js)); } public void testCost() { checkCost("1", "1"); checkCost("true", "1"); checkCost("false", "1"); checkCost("a", "xx"); checkCost("a + b", "xx+xx"); checkCost("foo()", "xx()"); checkCost("foo(a,b)", "xx(xx,xx)"); checkCost("10 + foo(a,b)", "0+xx(xx,xx)"); checkCost("1 + foo(a,b)", "1+xx(xx,xx)"); checkCost("a ? 1 : 0", "xx?1:0"); checkCost("a.b", "xx.xx"); checkCost("new Obj()", "new xx"); checkCost("function a() {return \"monkey\"}", "function xx(){return\"monkey\"}"); } private void checkCost(String source, String example) { // The example string should have been minified already. assertEquals(minimize(example), example); // cost estimate should be the same as the length of the example string. assertEquals(example.length(), cost(source)); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Inline function tests. * @author johnlenz@google.com (john lenz) */ public class InlineFunctionsTest extends CompilerTestCase { boolean allowGlobalFunctionInlining = true; boolean allowBlockInlining = true; final boolean allowExpressionDecomposition = true; final boolean allowFunctionExpressionInlining = true; final boolean allowLocalFunctionInlining = true; boolean assumeStrictThis = false; boolean assumeMinimumCapture = false; public InlineFunctionsTest() { this.enableNormalize(); this.enableMarkNoSideEffects(); } @Override protected void setUp() throws Exception { super.setUp(); super.enableLineNumberCheck(true); allowGlobalFunctionInlining = true; allowBlockInlining = true; assumeStrictThis = false; assumeMinimumCapture = false; } @Override protected CompilerPass getProcessor(Compiler compiler) { compiler.resetUniqueNameId(); return new InlineFunctions( compiler, compiler.getUniqueNameIdSupplier(), allowGlobalFunctionInlining, allowLocalFunctionInlining, allowBlockInlining, assumeStrictThis, assumeMinimumCapture); } /** * Returns the number of times the pass should be run before results are * verified. */ @Override protected int getNumRepetitions() { // Some inlining can only be done in multiple passes. return 3; } public void testInlineEmptyFunction1() { // Empty function, no params. test("function foo(){}" + "foo();", "void 0;"); } public void testInlineEmptyFunction2() { // Empty function, params with no side-effects. test("function foo(){}" + "foo(1, new Date, function(){});", "void 0;"); } public void testInlineEmptyFunction3() { // Empty function, multiple references. test("function foo(){}" + "foo();foo();foo();", "void 0;void 0;void 0"); } public void testInlineEmptyFunction4() { // Empty function, params with side-effects forces block inlining. test("function foo(){}" + "foo(x());", "{var JSCompiler_inline_anon_param_0=x();}"); } public void testInlineEmptyFunction5() { // Empty function, call params with side-effects in expression can not // be inlined. allowBlockInlining = false; testSame("function foo(){}" + "foo(x());"); } public void testInlineFunctions1() { // As simple a test as we can get. test("function foo(){ return 4 }" + "foo();", "4"); } public void testInlineFunctions2() { // inline simple constants // NOTE: CD is not inlined. test("var t;var AB=function(){return 4};" + "function BC(){return 6;}" + "CD=function(x){return x + 5};x=CD(3);y=AB();z=BC();", "var t;CD=function(x){return x+5};x=CD(3);y=4;z=6" ); } public void testInlineFunctions3() { // inline simple constants test("var t;var AB=function(){return 4};" + "function BC(){return 6;}" + "var CD=function(x){return x + 5};x=CD(3);y=AB();z=BC();", "var t;x=3+5;y=4;z=6"); } public void testInlineFunctions4() { // don't inline if there are multiple definitions (need DFA for that). test("var t; var AB = function() { return 4 }; " + "function BC() { return 6; }" + "CD = 0;" + "CD = function(x) { return x + 5 }; x = CD(3); y = AB(); z = BC();", "var t;CD=0;CD=function(x){return x+5};x=CD(3);y=4;z=6"); } public void testInlineFunctions5() { // inline additions test("var FOO_FN=function(x,y) { return \"de\" + x + \"nu\" + y };" + "var a = FOO_FN(\"ez\", \"ts\")", "var a=\"de\"+\"ez\"+\"nu\"+\"ts\""); } public void testInlineFunctions6() { // more complex inlines test("function BAR_FN(x, y, z) { return z(foo(x + y)) }" + "alert(BAR_FN(1, 2, baz))", "alert(baz(foo(1+2)))"); } public void testInlineFunctions7() { // inlines appearing multiple times test("function FN(x,y,z){return x+x+y}" + "var b=FN(1,2,3)", "var b=1+1+2"); } public void testInlineFunctions8() { // check correct parenthesization test("function MUL(x,y){return x*y}function ADD(x,y){return x+y}" + "var a=1+MUL(2,3);var b=2*ADD(3,4)", "var a=1+2*3;var b=2*(3+4)"); } public void testInlineFunctions9() { // don't inline if the input parameter is modified. test("function INC(x){return x++}" + "var y=INC(i)", "var y;{var x$$inline_0=i;" + "y=x$$inline_0++}"); } public void testInlineFunctions10() { test("function INC(x){return x++}" + "var y=INC(i);y=INC(i)", "var y;" + "{var x$$inline_0=i;" + "y=x$$inline_0++}" + "{var x$$inline_2=i;" + "y=x$$inline_2++}"); } public void testInlineFunctions11() { test("function f(x){return x}" + "var y=f(i)", "var y=i"); } public void testInlineFunctions12() { // don't inline if the input parameter has side-effects. allowBlockInlining = false; test("function f(x){return x}" + "var y=f(i)", "var y=i"); testSame("function f(x){return x}" + "var y=f(i++)"); } public void testInlineFunctions13() { // inline as block if the input parameter has side-effects. test("function f(x){return x}" + "var y=f(i++)", "var y;{var x$$inline_0=i++;y=x$$inline_0}"); } public void testInlineFunctions14() { // don't remove functions that are referenced on other ways test("function FOO(x){return x}var BAR=function(y){return y}" + ";b=FOO;a(BAR);x=FOO(1);y=BAR(2)", "function FOO(x){return x}var BAR=function(y){return y}" + ";b=FOO;a(BAR);x=1;y=2"); } public void testInlineFunctions15a() { // closure factories: do inline into global scope. test("function foo(){return function(a){return a+1}}" + "var b=function(){return c};" + "var d=b()+foo()", "var d=c+function(a){return a+1}"); } public void testInlineFunctions15b() { assumeMinimumCapture = false; // closure factories: don't inline closure with locals into global scope. test("function foo(){var x;return function(a){return a+1}}" + "var b=function(){return c};" + "var d=b()+foo()", "function foo(){var x;return function(a){return a+1}}" + "var d=c+foo()"); assumeMinimumCapture = true; test("function foo(){var x;return function(a){return a+1}}" + "var b=function(){return c};" + "var d=b()+foo()", "var JSCompiler_temp_const$$0 = c;\n" + "var JSCompiler_inline_result$$1;\n" + "{\n" + "var x$$inline_2;\n" + "JSCompiler_inline_result$$1 = " + " function(a$$inline_3){ return a$$inline_3+1 };\n" + "}" + "var d=JSCompiler_temp_const$$0 + JSCompiler_inline_result$$1"); } public void testInlineFunctions15c() { assumeMinimumCapture = false; // closure factories: don't inline into non-global scope. test("function foo(){return function(a){return a+1}}" + "var b=function(){return c};" + "function _x(){ var d=b()+foo() }", "function foo(){return function(a){return a+1}}" + "function _x(){ var d=c+foo() }"); assumeMinimumCapture = true; // closure factories: don't inline into non-global scope. test("function foo(){return function(a){return a+1}}" + "var b=function(){return c};" + "function _x(){ var d=b()+foo() }", "function _x(){var d=c+function(a){return a+1}}"); } public void testInlineFunctions15d() { assumeMinimumCapture = false; // closure factories: don't inline functions with vars. test("function foo(){var x; return function(a){return a+1}}" + "var b=function(){return c};" + "function _x(){ var d=b()+foo() }", "function foo(){var x; return function(a){return a+1}}" + "function _x(){ var d=c+foo() }"); assumeMinimumCapture = true; // closure factories: don't inline functions with vars. test("function foo(){var x; return function(a){return a+1}}" + "var b=function(){return c};" + "function _x(){ var d=b()+foo() }", "function _x() { \n" + " var JSCompiler_temp_const$$0 = c;\n" + " var JSCompiler_inline_result$$1;\n" + " {\n" + " var x$$inline_2;\n" + " JSCompiler_inline_result$$1 = " + " function(a$$inline_3) {return a$$inline_3+1};\n" + " }\n" + " var d = JSCompiler_temp_const$$0+JSCompiler_inline_result$$1\n" + "}"); } public void testInlineFunctions16a() { assumeMinimumCapture = false; testSame("function foo(b){return window.bar(function(){c(b)})}" + "var d=foo(e)"); assumeMinimumCapture = true; test( "function foo(b){return window.bar(function(){c(b)})}" + "var d=foo(e)", "var d;{var b$$inline_0=e;" + "d=window.bar(function(){c(b$$inline_0)})}"); } public void testInlineFunctions16b() { test("function foo(){return window.bar(function(){c()})}" + "var d=foo(e)", "var d=window.bar(function(){c()})"); } public void testInlineFunctions17() { // don't inline recursive functions testSame("function foo(x){return x*x+foo(3)}var bar=foo(4)"); } public void testInlineFunctions18() { // TRICKY ... test nested inlines allowBlockInlining = false; test("function foo(a, b){return a+b}" + "function bar(d){return c}" + "var d=foo(bar(1),e)", "var d=c+e"); } public void testInlineFunctions19() { // TRICKY ... test nested inlines // with block inlining possible test("function foo(a, b){return a+b}" + "function bar(d){return c}" + "var d=foo(bar(1),e)", "var d;{d=c+e}"); } public void testInlineFunctions20() { // Make sure both orderings work allowBlockInlining = false; test("function foo(a, b){return a+b}" + "function bar(d){return c}" + "var d=bar(foo(1,e));", "var d=c"); } public void testInlineFunctions21() { // with block inlining possible test("function foo(a, b){return a+b}" + "function bar(d){return c}" + "var d=bar(foo(1,e))", "var d;{d=c}"); } public void testInlineFunctions22() { // Another tricky case ... test nested compiler inlines test("function plex(a){if(a) return 0;else return 1;}" + "function foo(a, b){return bar(a+b)}" + "function bar(d){return plex(d)}" + "var d=foo(1,2)", "var d;{JSCompiler_inline_label_plex_1:{" + "if(1+2){" + "d=0;break JSCompiler_inline_label_plex_1}" + "else{" + "d=1;break JSCompiler_inline_label_plex_1}d=void 0}}"); } public void testInlineFunctions23() { // Test both orderings again test("function complex(a){if(a) return 0;else return 1;}" + "function bar(d){return complex(d)}" + "function foo(a, b){return bar(a+b)}" + "var d=foo(1,2)", "var d;{JSCompiler_inline_label_complex_1:{" + "if(1+2){" + "d=0;break JSCompiler_inline_label_complex_1" + "}else{" + "d=1;break JSCompiler_inline_label_complex_1" + "}d=void 0}}"); } public void testInlineFunctions24() { // Don't inline functions with 'arguments' or 'this' testSame("function foo(x){return this}foo(1)"); } public void testInlineFunctions25() { testSame("function foo(){return arguments[0]}foo()"); } public void testInlineFunctions26() { // Don't inline external functions testSame("function _foo(x){return x}_foo(1)"); } public void testInlineFunctions27() { test("var window = {}; function foo(){window.bar++; return 3;}" + "var x = {y: 1, z: foo(2)};", "var window={};" + "var JSCompiler_inline_result$$0;" + "{" + " window.bar++;" + " JSCompiler_inline_result$$0 = 3;" + "}" + "var x = {y: 1, z: JSCompiler_inline_result$$0};"); } public void testInlineFunctions28() { test("var window = {}; function foo(){window.bar++; return 3;}" + "var x = {y: alert(), z: foo(2)};", "var window = {};" + "var JSCompiler_temp_const$$0 = alert();" + "var JSCompiler_inline_result$$1;" + "{" + " window.bar++;" + " JSCompiler_inline_result$$1 = 3;}" + "var x = {" + " y: JSCompiler_temp_const$$0," + " z: JSCompiler_inline_result$$1" + "};"); } public void testInlineFunctions29() { test("var window = {}; function foo(){window.bar++; return 3;}" + "var x = {a: alert(), b: alert2(), c: foo(2)};", "var window = {};" + "var JSCompiler_temp_const$$1 = alert();" + "var JSCompiler_temp_const$$0 = alert2();" + "var JSCompiler_inline_result$$2;" + "{" + " window.bar++;" + " JSCompiler_inline_result$$2 = 3;}" + "var x = {" + " a: JSCompiler_temp_const$$1," + " b: JSCompiler_temp_const$$0," + " c: JSCompiler_inline_result$$2" + "};"); } public void testInlineFunctions30() { // As simple a test as we can get. testSame("function foo(){ return eval() }" + "foo();"); } public void testInlineFunctions31() { // Don't introduce a duplicate label in the same scope test("function foo(){ lab:{4;} }" + "lab:{foo();}", "lab:{{JSCompiler_inline_label_0:{4}}}"); } public void testMixedModeInlining1() { // Base line tests, direct inlining test("function foo(){return 1}" + "foo();", "1;"); } public void testMixedModeInlining2() { // Base line tests, block inlining. Block inlining is needed by // possible-side-effect parameter. test("function foo(){return 1}" + "foo(x());", "{var JSCompiler_inline_anon_param_0=x();1}"); } public void testMixedModeInlining3() { // Inline using both modes. test("function foo(){return 1}" + "foo();foo(x());", "1;{var JSCompiler_inline_anon_param_0=x();1}"); } public void testMixedModeInlining4() { // Inline using both modes. Alternating. Second call of each type has // side-effect-less parameter, this is thrown away. test("function foo(){return 1}" + "foo();foo(x());" + "foo(1);foo(1,x());", "1;{var JSCompiler_inline_anon_param_0=x();1}" + "1;{var JSCompiler_inline_anon_param_4=x();1}"); } public void testMixedModeInliningCosting1() { // Inline using both modes. Costing estimates. // Base line. test( "function foo(a,b){return a+b+a+b+4+5+6+7+8+9+1+2+3+4+5}" + "foo(1,2);" + "foo(2,3)", "1+2+1+2+4+5+6+7+8+9+1+2+3+4+5;" + "2+3+2+3+4+5+6+7+8+9+1+2+3+4+5"); } public void testMixedModeInliningCosting2() { // Don't inline here because the function definition can not be eliminated. // TODO(johnlenz): Should we add constant removing to the unit test? testSame( "function foo(a,b){return a+b+a+b+4+5+6+7+8+9+1+2+3+4+5}" + "foo(1,2);" + "foo(2,3,x())"); } public void testMixedModeInliningCosting3() { // Do inline here because the function definition can be eliminated. test( "function foo(a,b){return a+b+a+b+4+5+6+7+8+9+1+2+3+10}" + "foo(1,2);" + "foo(2,3,x())", "1+2+1+2+4+5+6+7+8+9+1+2+3+10;" + "{var JSCompiler_inline_anon_param_2=x();" + "2+3+2+3+4+5+6+7+8+9+1+2+3+10}"); } public void testMixedModeInliningCosting4() { // Threshold test. testSame( "function foo(a,b){return a+b+a+b+4+5+6+7+8+9+1+2+3+4+101}" + "foo(1,2);" + "foo(2,3,x())"); } public void testNoInlineIfParametersModified1() { // Assignment test("function f(x){return x=1}f(undefined)", "{var x$$inline_0=undefined;" + "x$$inline_0=1}"); } public void testNoInlineIfParametersModified2() { test("function f(x){return (x)=1;}f(2)", "{var x$$inline_0=2;" + "x$$inline_0=1}"); } public void testNoInlineIfParametersModified3() { // Assignment variant. test("function f(x){return x*=2}f(2)", "{var x$$inline_0=2;" + "x$$inline_0*=2}"); } public void testNoInlineIfParametersModified4() { // Assignment in if. test("function f(x){return x?(x=2):0}f(2)", "{var x$$inline_0=2;" + "x$$inline_0?(" + "x$$inline_0=2):0}"); } public void testNoInlineIfParametersModified5() { // Assignment in if, multiple params test("function f(x,y){return x?(y=2):0}f(2,undefined)", "{var y$$inline_1=undefined;2?(" + "y$$inline_1=2):0}"); } public void testNoInlineIfParametersModified6() { test("function f(x,y){return x?(y=2):0}f(2)", "{var y$$inline_1=void 0;2?(" + "y$$inline_1=2):0}"); } public void testNoInlineIfParametersModified7() { // Increment test("function f(a){return++a<++a}f(1)", "{var a$$inline_0=1;" + "++a$$inline_0<" + "++a$$inline_0}"); } public void testNoInlineIfParametersModified8() { // OK, object parameter modified. test("function f(a){return a.x=2}f(o)", "o.x=2"); } public void testNoInlineIfParametersModified9() { // OK, array parameter modified. test("function f(a){return a[2]=2}f(o)", "o[2]=2"); } public void testInlineNeverPartialSubtitution1() { test("function f(z){return x.y.z;}f(1)", "x.y.z"); } public void testInlineNeverPartialSubtitution2() { test("function f(z){return x.y[z];}f(a)", "x.y[a]"); } public void testInlineNeverMutateConstants() { test("function f(x){return x=1}f(undefined)", "{var x$$inline_0=undefined;" + "x$$inline_0=1}"); } public void testInlineNeverOverrideNewValues() { test("function f(a){return++a<++a}f(1)", "{var a$$inline_0=1;" + "++a$$inline_0<++a$$inline_0}"); } public void testInlineMutableArgsReferencedOnce() { test("function foo(x){return x;}foo([])", "[]"); } public void testNoInlineMutableArgs1() { allowBlockInlining = false; testSame("function foo(x){return x+x} foo([])"); } public void testNoInlineMutableArgs2() { allowBlockInlining = false; testSame("function foo(x){return x+x} foo(new Date)"); } public void testNoInlineMutableArgs3() { allowBlockInlining = false; testSame("function foo(x){return x+x} foo(true&&new Date)"); } public void testNoInlineMutableArgs4() { allowBlockInlining = false; testSame("function foo(x){return x+x} foo({})"); } public void testInlineBlockMutableArgs1() { test("function foo(x){x+x}foo([])", "{var x$$inline_0=[];" + "x$$inline_0+x$$inline_0}"); } public void testInlineBlockMutableArgs2() { test("function foo(x){x+x}foo(new Date)", "{var x$$inline_0=new Date;" + "x$$inline_0+x$$inline_0}"); } public void testInlineBlockMutableArgs3() { test("function foo(x){x+x}foo(true&&new Date)", "{var x$$inline_0=true&&new Date;" + "x$$inline_0+x$$inline_0}"); } public void testInlineBlockMutableArgs4() { test("function foo(x){x+x}foo({})", "{var x$$inline_0={};" + "x$$inline_0+x$$inline_0}"); } public void testShadowVariables1() { // The Normalize pass now guarantees that that globals are never shadowed // by locals. // "foo" is inlined here as its parameter "a" doesn't conflict. // "bar" is assigned a new name. test("var a=0;" + "function foo(a){return 3+a}" + "function bar(){var a=foo(4)}" + "bar();", "var a=0;" + "{var a$$inline_0=3+4}"); } public void testShadowVariables2() { // "foo" is inlined here as its parameter "a" doesn't conflict. // "bar" is inlined as its uses global "a", and does introduce any new // globals. test("var a=0;" + "function foo(a){return 3+a}" + "function bar(){a=foo(4)}" + "bar()", "var a=0;" + "{a=3+4}"); } public void testShadowVariables3() { // "foo" is inlined into exported "_bar", aliasing foo's "a". test("var a=0;" + "function foo(){var a=2;return 3+a}" + "function _bar(){a=foo()}", "var a=0;" + "function _bar(){{var a$$inline_0=2;" + "a=3+a$$inline_0}}"); } public void testShadowVariables4() { // "foo" is inlined. // block access to global "a". test("var a=0;" + "function foo(){return 3+a}" + "function _bar(a){a=foo(4)+a}", "var a=0;function _bar(a$$1){" + "a$$1=" + "3+a+a$$1}"); } public void testShadowVariables5() { // Can't yet inline multiple statements functions into expressions // (though some are possible using the COMMA operator). allowBlockInlining = false; testSame("var a=0;" + "function foo(){var a=4;return 3+a}" + "function _bar(a){a=foo(4)+a}"); } public void testShadowVariables6() { test("var a=0;" + "function foo(){var a=4;return 3+a}" + "function _bar(a){a=foo(4)}", "var a=0;function _bar(a$$2){{" + "var a$$inline_0=4;" + "a$$2=3+a$$inline_0}}"); } public void testShadowVariables7() { assumeMinimumCapture = false; test("var a=3;" + "function foo(){return a}" + "(function(){var a=5;(function(){foo()})()})()", "var a=3;" + "{var a$$inline_0=5;{a}}" ); assumeMinimumCapture = true; test("var a=3;" + "function foo(){return a}" + "(function(){var a=5;(function(){foo()})()})()", "var a=3;" + "{var a$$inline_1=5;{a}}" ); } public void testShadowVariables8() { // this should be inlined test("var a=0;" + "function foo(){return 3}" + "function _bar(){var a=foo()}", "var a=0;" + "function _bar(){var a=3}"); } public void testShadowVariables9() { // this should be inlined too [even if the global is not declared] test("function foo(){return 3}" + "function _bar(){var a=foo()}", "function _bar(){var a=3}"); } public void testShadowVariables10() { // callee var must be renamed. test("var a;function foo(){return a}" + "function _bar(){var a=foo()}", "var a;function _bar(){var a$$1=a}"); } public void testShadowVariables11() { // The call has a local variable // which collides with the function being inlined test("var a=0;var b=1;" + "function foo(){return a+a}" + "function _bar(){var a=foo();alert(a)}", "var a=0;var b=1;" + "function _bar(){var a$$1=a+a;" + "alert(a$$1)}" ); } public void testShadowVariables12() { // 2 globals colliding test("var a=0;var b=1;" + "function foo(){return a+b}" + "function _bar(){var a=foo(),b;alert(a)}", "var a=0;var b=1;" + "function _bar(){var a$$1=a+b," + "b$$1;" + "alert(a$$1)}"); } public void testShadowVariables13() { // The only change is to remove the collision test("var a=0;var b=1;" + "function foo(){return a+a}" + "function _bar(){var c=foo();alert(c)}", "var a=0;var b=1;" + "function _bar(){var c=a+a;alert(c)}"); } public void testShadowVariables14() { // There is a collision even though it is not read. test("var a=0;var b=1;" + "function foo(){return a+b}" + "function _bar(){var c=foo(),b;alert(c)}", "var a=0;var b=1;" + "function _bar(){var c=a+b," + "b$$1;alert(c)}"); } public void testShadowVariables15() { // Both parent and child reference a global test("var a=0;var b=1;" + "function foo(){return a+a}" + "function _bar(){var c=foo();alert(c+a)}", "var a=0;var b=1;" + "function _bar(){var c=a+a;alert(c+a)}"); } public void testShadowVariables16() { assumeMinimumCapture = false; // Inline functions defined as a child of the CALL node. test("var a=3;" + "function foo(){return a}" + "(function(){var a=5;(function(){foo()})()})()", "var a=3;" + "{var a$$inline_0=5;{a}}" ); assumeMinimumCapture = true; // Inline functions defined as a child of the CALL node. test("var a=3;" + "function foo(){return a}" + "(function(){var a=5;(function(){foo()})()})()", "var a=3;" + "{var a$$inline_1=5;{a}}" ); } public void testShadowVariables17() { test("var a=0;" + "function bar(){return a+a}" + "function foo(){return bar()}" + "function _goo(){var a=2;var x=foo();}", "var a=0;" + "function _goo(){var a$$1=2;var x=a+a}"); } public void testShadowVariables18() { test("var a=0;" + "function bar(){return a+a}" + "function foo(){var a=3;return bar()}" + "function _goo(){var a=2;var x=foo();}", "var a=0;" + "function _goo(){var a$$2=2;var x;" + "{var a$$inline_0=3;x=a+a}}"); } public void testCostBasedInlining1() { testSame( "function foo(a){return a}" + "foo=new Function(\"return 1\");" + "foo(1)"); } public void testCostBasedInlining2() { // Baseline complexity tests. // Single call, function not removed. test( "function foo(a){return a}" + "var b=foo;" + "function _t1(){return foo(1)}", "function foo(a){return a}" + "var b=foo;" + "function _t1(){return 1}"); } public void testCostBasedInlining3() { // Two calls, function not removed. test( "function foo(a,b){return a+b}" + "var b=foo;" + "function _t1(){return foo(1,2)}" + "function _t2(){return foo(2,3)}", "function foo(a,b){return a+b}" + "var b=foo;" + "function _t1(){return 1+2}" + "function _t2(){return 2+3}"); } public void testCostBasedInlining4() { // Two calls, function not removed. // Here there isn't enough savings to justify inlining. testSame( "function foo(a,b){return a+b+a+b}" + "var b=foo;" + "function _t1(){return foo(1,2)}" + "function _t2(){return foo(2,3)}"); } public void testCostBasedInlining5() { // Here there is enough savings to justify inlining. test( "function foo(a,b){return a+b+a+b}" + "function _t1(){return foo(1,2)}" + "function _t2(){return foo(2,3)}", "function _t1(){return 1+2+1+2}" + "function _t2(){return 2+3+2+3}"); } public void testCostBasedInlining6() { // Here we have a threshold test. // Do inline here: test( "function foo(a,b){return a+b+a+b+a+b+a+b+4+5+6+7+8+9+1+2+3+4+5}" + "function _t1(){return foo(1,2)}" + "function _t2(){return foo(2,3)}", "function _t1(){return 1+2+1+2+1+2+1+2+4+5+6+7+8+9+1+2+3+4+5}" + "function _t2(){return 2+3+2+3+2+3+2+3+4+5+6+7+8+9+1+2+3+4+5}"); } public void testCostBasedInlining7() { // Don't inline here (not enough savings): testSame( "function foo(a,b){" + " return a+b+a+b+a+b+a+b+4+5+6+7+8+9+1+2+3+4+5+6}" + "function _t1(){return foo(1,2)}" + "function _t2(){return foo(2,3)}"); } public void testCostBasedInlining8() { // Verify multiple references in the same statement: // Here "f" is not known to be removable, as it is a used as parameter // and is not known to be side-effect free. The first call to f() can // not be inlined on the first pass (as the call to f() as a parameter // prevents this). However, the call to f() would be inlinable, if it // is small enough to be inlined without removing the function declaration. // but it is not in this first test. allowBlockInlining = false; testSame("function f(a){return 1 + a + a;}" + "var a = f(f(1));"); } public void testCostBasedInlining9() { // Here both direct and block inlining is used. The call to f as a // parameter is inlined directly, which the call to f with f as a parameter // is inlined using block inlining. test("function f(a){return 1 + a + a;}" + "var a = f(f(1));", "var a;" + "{var a$$inline_0=1+1+1;" + "a=1+a$$inline_0+a$$inline_0}"); } public void testCostBasedInlining10() { // But it is small enough here, and on the second iteration, the remaining // call to f() is inlined, as there is no longer a possible side-effect-ing // parameter. allowBlockInlining = false; test("function f(a){return a + a;}" + "var a = f(f(1));", "var a= 1+1+(1+1);"); } public void testCostBasedInlining11() { // With block inlining test("function f(a){return a + a;}" + "var a = f(f(1))", "var a;" + "{var a$$inline_0=1+1;" + "a=a$$inline_0+a$$inline_0}"); } public void testCostBasedInlining12() { test("function f(a){return 1 + a + a;}" + "var a = f(1) + f(2);", "var a=1+1+1+(1+2+2)"); } public void testCostBasedInliningComplex1() { testSame( "function foo(a){a()}" + "foo=new Function(\"return 1\");" + "foo(1)"); } public void testCostBasedInliningComplex2() { // Baseline complexity tests. // Single call, function not removed. test( "function foo(a){a()}" + "var b=foo;" + "function _t1(){foo(x)}", "function foo(a){a()}" + "var b=foo;" + "function _t1(){{x()}}"); } public void testCostBasedInliningComplex3() { // Two calls, function not removed. test( "function foo(a,b){a+b}" + "var b=foo;" + "function _t1(){foo(1,2)}" + "function _t2(){foo(2,3)}", "function foo(a,b){a+b}" + "var b=foo;" + "function _t1(){{1+2}}" + "function _t2(){{2+3}}"); } public void testCostBasedInliningComplex4() { // Two calls, function not removed. // Here there isn't enough savings to justify inlining. testSame( "function foo(a,b){a+b+a+b}" + "var b=foo;" + "function _t1(){foo(1,2)}" + "function _t2(){foo(2,3)}"); } public void testCostBasedInliningComplex5() { // Here there is enough savings to justify inlining. test( "function foo(a,b){a+b+a+b}" + "function _t1(){foo(1,2)}" + "function _t2(){foo(2,3)}", "function _t1(){{1+2+1+2}}" + "function _t2(){{2+3+2+3}}"); } public void testCostBasedInliningComplex6() { // Here we have a threshold test. // Do inline here: test( "function foo(a,b){a+b+a+b+a+b+a+b+4+5+6+7+8+9+1}" + "function _t1(){foo(1,2)}" + "function _t2(){foo(2,3)}", "function _t1(){{1+2+1+2+1+2+1+2+4+5+6+7+8+9+1}}" + "function _t2(){{2+3+2+3+2+3+2+3+4+5+6+7+8+9+1}}"); } public void testCostBasedInliningComplex7() { // Don't inline here (not enough savings): testSame( "function foo(a,b){a+b+a+b+a+b+a+b+4+5+6+7+8+9+1+2}" + "function _t1(){foo(1,2)}" + "function _t2(){foo(2,3)}"); } public void testCostBasedInliningComplex8() { // Verify multiple references in the same statement. testSame("function _f(a){1+a+a}" + "a=_f(1)+_f(1)"); } public void testCostBasedInliningComplex9() { test("function f(a){1 + a + a;}" + "f(1);f(2);", "{1+1+1}{1+2+2}"); } public void testDoubleInlining1() { allowBlockInlining = false; test("var foo = function(a) { return getWindow(a); };" + "var bar = function(b) { return b; };" + "foo(bar(x));", "getWindow(x)"); } public void testDoubleInlining2() { test("var foo = function(a) { return getWindow(a); };" + "var bar = function(b) { return b; };" + "foo(bar(x));", "{getWindow(x)}"); } public void testNoInlineOfNonGlobalFunction1() { test("var g;function _f(){function g(){return 0}}" + "function _h(){return g()}", "var g;function _f(){}" + "function _h(){return g()}"); } public void testNoInlineOfNonGlobalFunction2() { test("var g;function _f(){var g=function(){return 0}}" + "function _h(){return g()}", "var g;function _f(){}" + "function _h(){return g()}"); } public void testNoInlineOfNonGlobalFunction3() { test("var g;function _f(){var g=function(){return 0}}" + "function _h(){return g()}", "var g;function _f(){}" + "function _h(){return g()}"); } public void testNoInlineOfNonGlobalFunction4() { test("var g;function _f(){function g(){return 0}}" + "function _h(){return g()}", "var g;function _f(){}" + "function _h(){return g()}"); } public void testNoInlineMaskedFunction() { // Normalization makes this test of marginal value. // The unreferenced function is removed. test("var g=function(){return 0};" + "function _f(g){return g()}", "function _f(g$$1){return g$$1()}"); } public void testNoInlineNonFunction() { testSame("var g=3;function _f(){return g()}"); } public void testInlineCall() { test("function f(g) { return g.h(); } f('x');", "\"x\".h()"); } public void testInlineFunctionWithArgsMismatch1() { test("function f(g) { return g; } f();", "void 0"); } public void testInlineFunctionWithArgsMismatch2() { test("function f() { return 0; } f(1);", "0"); } public void testInlineFunctionWithArgsMismatch3() { test("function f(one, two, three) { return one + two + three; } f(1);", "1+void 0+void 0"); } public void testInlineFunctionWithArgsMismatch4() { test("function f(one, two, three) { return one + two + three; }" + "f(1,2,3,4,5);", "1+2+3"); } public void testArgumentsWithSideEffectsNeverInlined1() { allowBlockInlining = false; testSame("function f(){return 0} f(new goo());"); } public void testArgumentsWithSideEffectsNeverInlined2() { allowBlockInlining = false; testSame("function f(g,h){return h+g}f(g(),h());"); } public void testOneSideEffectCallDoesNotRuinOthers() { allowBlockInlining = false; test("function f(){return 0}f(new goo());f()", "function f(){return 0}f(new goo());0"); } public void testComplexInlineNoResultNoParamCall1() { test("function f(){a()}f()", "{a()}"); } public void testComplexInlineNoResultNoParamCall2() { test("function f(){if (true){return;}else;} f();", "{JSCompiler_inline_label_f_0:{" + "if(true)break JSCompiler_inline_label_f_0;else;}}"); } public void testComplexInlineNoResultNoParamCall3() { // We now allow vars in the global space. // Don't inline into vars into global scope. // testSame("function f(){a();b();var z=1+1}f()"); // But do inline into functions test("function f(){a();b();var z=1+1}function _foo(){f()}", "function _foo(){{a();b();var z$$inline_0=1+1}}"); } public void testComplexInlineNoResultWithParamCall1() { test("function f(x){a(x)}f(1)", "{a(1)}"); } public void testComplexInlineNoResultWithParamCall2() { test("function f(x,y){a(x)}var b=1;f(1,b)", "var b=1;{a(1)}"); } public void testComplexInlineNoResultWithParamCall3() { test("function f(x,y){if (x) y(); return true;}var b=1;f(1,b)", "var b=1;{if(1)b();true}"); } public void testComplexInline1() { test("function f(){if (true){return;}else;} z=f();", "{JSCompiler_inline_label_f_0:" + "{if(true){z=void 0;" + "break JSCompiler_inline_label_f_0}else;z=void 0}}"); } public void testComplexInline2() { test("function f(){if (true){return;}else return;} z=f();", "{JSCompiler_inline_label_f_0:{if(true){z=void 0;" + "break JSCompiler_inline_label_f_0}else{z=void 0;" + "break JSCompiler_inline_label_f_0}z=void 0}}"); } public void testComplexInline3() { test("function f(){if (true){return 1;}else return 0;} z=f();", "{JSCompiler_inline_label_f_0:{if(true){z=1;" + "break JSCompiler_inline_label_f_0}else{z=0;" + "break JSCompiler_inline_label_f_0}z=void 0}}"); } public void testComplexInline4() { test("function f(x){a(x)} z = f(1)", "{a(1);z=void 0}"); } public void testComplexInline5() { test("function f(x,y){a(x)}var b=1;z=f(1,b)", "var b=1;{a(1);z=void 0}"); } public void testComplexInline6() { test("function f(x,y){if (x) y(); return true;}var b=1;z=f(1,b)", "var b=1;{if(1)b();z=true}"); } public void testComplexInline7() { test("function f(x,y){if (x) return y(); else return true;}" + "var b=1;z=f(1,b)", "var b=1;{JSCompiler_inline_label_f_2:{if(1){z=b();" + "break JSCompiler_inline_label_f_2}else{z=true;" + "break JSCompiler_inline_label_f_2}z=void 0}}"); } public void testComplexInline8() { test("function f(x){a(x)}var z=f(1)", "var z;{a(1);z=void 0}"); } public void testComplexInlineVars1() { test("function f(){if (true){return;}else;}var z=f();", "var z;{JSCompiler_inline_label_f_0:{" + "if(true){z=void 0;break JSCompiler_inline_label_f_0}else;z=void 0}}"); } public void testComplexInlineVars2() { test("function f(){if (true){return;}else return;}var z=f();", "var z;{JSCompiler_inline_label_f_0:{" + "if(true){z=void 0;break JSCompiler_inline_label_f_0" + "}else{" + "z=void 0;break JSCompiler_inline_label_f_0}z=void 0}}"); } public void testComplexInlineVars3() { test("function f(){if (true){return 1;}else return 0;}var z=f();", "var z;{JSCompiler_inline_label_f_0:{if(true){" + "z=1;break JSCompiler_inline_label_f_0" + "}else{" + "z=0;break JSCompiler_inline_label_f_0}z=void 0}}"); } public void testComplexInlineVars4() { test("function f(x){a(x)}var z = f(1)", "var z;{a(1);z=void 0}"); } public void testComplexInlineVars5() { test("function f(x,y){a(x)}var b=1;var z=f(1,b)", "var b=1;var z;{a(1);z=void 0}"); } public void testComplexInlineVars6() { test("function f(x,y){if (x) y(); return true;}var b=1;var z=f(1,b)", "var b=1;var z;{if(1)b();z=true}"); } public void testComplexInlineVars7() { test("function f(x,y){if (x) return y(); else return true;}" + "var b=1;var z=f(1,b)", "var b=1;var z;" + "{JSCompiler_inline_label_f_2:{if(1){z=b();" + "break JSCompiler_inline_label_f_2" + "}else{" + "z=true;break JSCompiler_inline_label_f_2}z=void 0}}"); } public void testComplexInlineVars8() { test("function f(x){a(x)}var x;var z=f(1)", "var x;var z;{a(1);z=void 0}"); } public void testComplexInlineVars9() { test("function f(x){a(x)}var x;var z=f(1);var y", "var x;var z;{a(1);z=void 0}var y"); } public void testComplexInlineVars10() { test("function f(x){a(x)}var x=blah();var z=f(1);var y=blah();", "var x=blah();var z;{a(1);z=void 0}var y=blah()"); } public void testComplexInlineVars11() { test("function f(x){a(x)}var x=blah();var z=f(1);var y;", "var x=blah();var z;{a(1);z=void 0}var y"); } public void testComplexInlineVars12() { test("function f(x){a(x)}var x;var z=f(1);var y=blah();", "var x;var z;{a(1);z=void 0}var y=blah()"); } public void testComplexInlineInExpresssions1() { test("function f(){a()}var z=f()", "var z;{a();z=void 0}"); } public void testComplexInlineInExpresssions2() { test("function f(){a()}c=z=f()", "var JSCompiler_inline_result$$0;" + "{a();JSCompiler_inline_result$$0=void 0;}" + "c=z=JSCompiler_inline_result$$0"); } public void testComplexInlineInExpresssions3() { test("function f(){a()}c=z=f()", "var JSCompiler_inline_result$$0;" + "{a();JSCompiler_inline_result$$0=void 0;}" + "c=z=JSCompiler_inline_result$$0"); } public void testComplexInlineInExpresssions4() { test("function f(){a()}if(z=f());", "var JSCompiler_inline_result$$0;" + "{a();JSCompiler_inline_result$$0=void 0;}" + "if(z=JSCompiler_inline_result$$0);"); } public void testComplexInlineInExpresssions5() { test("function f(){a()}if(z.y=f());", "var JSCompiler_temp_const$$0=z;" + "var JSCompiler_inline_result$$1;" + "{a();JSCompiler_inline_result$$1=void 0;}" + "if(JSCompiler_temp_const$$0.y=JSCompiler_inline_result$$1);"); } public void testComplexNoInline1() { testSame("function f(){a()}while(z=f())continue"); } public void testComplexNoInline2() { testSame("function f(){a()}do;while(z=f())"); } public void testComplexSample() { String result = "" + "{{" + "var styleSheet$$inline_2=null;" + "if(goog$userAgent$IE)" + "styleSheet$$inline_2=0;" + "else " + "var head$$inline_3=0;" + "{" + "var element$$inline_4=" + "styleSheet$$inline_2;" + "var stylesString$$inline_5=a;" + "if(goog$userAgent$IE)" + "element$$inline_4.cssText=" + "stylesString$$inline_5;" + "else " + "{" + "var propToSet$$inline_6=" + "\"innerText\";" + "element$$inline_4[" + "propToSet$$inline_6]=" + "stylesString$$inline_5" + "}" + "}" + "styleSheet$$inline_2" + "}}"; test("var foo = function(stylesString, opt_element) { " + "var styleSheet = null;" + "if (goog$userAgent$IE)" + "styleSheet = 0;" + "else " + "var head = 0;" + "" + "goo$zoo(styleSheet, stylesString);" + "return styleSheet;" + " };\n " + "var goo$zoo = function(element, stylesString) {" + "if (goog$userAgent$IE)" + "element.cssText = stylesString;" + "else {" + "var propToSet = 'innerText';" + "element[propToSet] = stylesString;" + "}" + "};" + "(function(){foo(a,b);})();", result); } public void testComplexSampleNoInline() { // This is the result we would expect if we could handle "foo = function" String result = "foo=function(stylesString,opt_element){" + "var styleSheet=null;" + "if(goog$userAgent$IE){" + "styleSheet=0" + "}else{" + "var head=0" + "}" + "{var JSCompiler_inline_element_0=styleSheet;" + "var JSCompiler_inline_stylesString_1=stylesString;" + "if(goog$userAgent$IE){" + "JSCompiler_inline_element_0.cssText=" + "JSCompiler_inline_stylesString_1" + "}else{" + "var propToSet=goog$userAgent$WEBKIT?\"innerText\":\"innerHTML\";" + "JSCompiler_inline_element_0[propToSet]=" + "JSCompiler_inline_stylesString_1" + "}}" + "return styleSheet" + "}"; testSame( "foo=function(stylesString,opt_element){" + "var styleSheet=null;" + "if(goog$userAgent$IE)" + "styleSheet=0;" + "else " + "var head=0;" + "" + "goo$zoo(styleSheet,stylesString);" + "return styleSheet" + "};" + "goo$zoo=function(element,stylesString){" + "if(goog$userAgent$IE)" + "element.cssText=stylesString;" + "else{" + "var propToSet=goog$userAgent$WEBKIT?\"innerText\":\"innerHTML\";" + "element[propToSet]=stylesString" + "}" + "}"); } // Test redefinition of parameter name. public void testComplexNoVarSub() { test( "function foo(x){" + "var x;" + "y=x" + "}" + "foo(1)", "{y=1}" ); } public void testComplexFunctionWithFunctionDefinition1() { test("function f(){call(function(){return})}f()", "{call(function(){return})}"); } public void testComplexFunctionWithFunctionDefinition2() { assumeMinimumCapture = false; // Don't inline if local names might be captured. testSame("function f(a){call(function(){return})}f()"); assumeMinimumCapture = true; test("(function(){" + "var f = function(a){call(function(){return a})};f()})()", "{{var a$$inline_0=void 0;call(function(){return a$$inline_0})}}"); } public void testComplexFunctionWithFunctionDefinition2a() { assumeMinimumCapture = false; // Don't inline if local names might be captured. testSame("(function(){" + "var f = function(a){call(function(){return a})};f()})()"); assumeMinimumCapture = true; test("(function(){" + "var f = function(a){call(function(){return a})};f()})()", "{{var a$$inline_0=void 0;call(function(){return a$$inline_0})}}"); } public void testComplexFunctionWithFunctionDefinition3() { assumeMinimumCapture = false; // Don't inline if local names might need to be captured. testSame("function f(){var a; call(function(){return a})}f()"); assumeMinimumCapture = true; test("function f(){var a; call(function(){return a})}f()", "{var a$$inline_0;call(function(){return a$$inline_0})}"); } public void testDecomposePlusEquals() { test("function f(){a=1;return 1} var x = 1; x += f()", "var x = 1;" + "var JSCompiler_temp_const$$0 = x;" + "var JSCompiler_inline_result$$1;" + "{a=1;" + " JSCompiler_inline_result$$1=1}" + "x = JSCompiler_temp_const$$0 + JSCompiler_inline_result$$1;"); } public void testDecomposeFunctionExpressionInCall() { test( "(function(map){descriptions_=map})(\n" + "function(){\n" + "var ret={};\n" + "ret[ONE]='a';\n" + "ret[TWO]='b';\n" + "return ret\n" + "}()\n" + ");", "var JSCompiler_inline_result$$0;" + "{" + "var ret$$inline_1={};\n" + "ret$$inline_1[ONE]='a';\n" + "ret$$inline_1[TWO]='b';\n" + "JSCompiler_inline_result$$0 = ret$$inline_1;\n" + "}" + "{" + "descriptions_=JSCompiler_inline_result$$0;" + "}" ); } public void testInlineConstructor1() { test("function f() {} function _g() {f.call(this)}", "function _g() {void 0}"); } public void testInlineConstructor2() { test("function f() {} f.prototype.a = 0; function _g() {f.call(this)}", "function f() {} f.prototype.a = 0; function _g() {void 0}"); } public void testInlineConstructor3() { test("function f() {x.call(this)} f.prototype.a = 0;" + "function _g() {f.call(this)}", "function f() {x.call(this)} f.prototype.a = 0;" + "function _g() {{x.call(this)}}"); } public void testInlineConstructor4() { test("function f() {x.call(this)} f.prototype.a = 0;" + "function _g() {var t = f.call(this)}", "function f() {x.call(this)} f.prototype.a = 0;" + "function _g() {var t; {x.call(this); t = void 0}}"); } public void testFunctionExpressionInlining1() { test("(function(){})()", "void 0"); } public void testFunctionExpressionInlining2() { test("(function(){foo()})()", "{foo()}"); } public void testFunctionExpressionInlining3() { test("var a = (function(){return foo()})()", "var a = foo()"); } public void testFunctionExpressionInlining4() { test("var a; a = 1 + (function(){return foo()})()", "var a; a = 1 + foo()"); } public void testFunctionExpressionCallInlining1() { test("(function(){}).call(this)", "void 0"); } public void testFunctionExpressionCallInlining2() { test("(function(){foo(this)}).call(this)", "{foo(this)}"); } public void testFunctionExpressionCallInlining3() { test("var a = (function(){return foo(this)}).call(this)", "var a = foo(this)"); } public void testFunctionExpressionCallInlining4() { test("var a; a = 1 + (function(){return foo(this)}).call(this)", "var a; a = 1 + foo(this)"); } public void testFunctionExpressionCallInlining5() { test("a:(function(){return foo()})()", "a:foo()"); } public void testFunctionExpressionCallInlining6() { test("a:(function(){return foo()}).call(this)", "a:foo()"); } public void testFunctionExpressionCallInlining7() { test("a:(function(){})()", "a:void 0"); } public void testFunctionExpressionCallInlining8() { test("a:(function(){}).call(this)", "a:void 0"); } public void testFunctionExpressionCallInlining9() { // ... with unused recursive name. test("(function foo(){})()", "void 0"); } public void testFunctionExpressionCallInlining10() { // ... with unused recursive name. test("(function foo(){}).call(this)", "void 0"); } public void testFunctionExpressionCallInlining11a() { // Inline functions that return inner functions. test("((function(){return function(){foo()}})())();", "{foo()}"); } public void testFunctionExpressionCallInlining11b() { assumeMinimumCapture = false; // Can't inline functions that return inner functions and have local names. testSame("((function(){var a; return function(){foo()}})())();"); assumeMinimumCapture = true; test( "((function(){var a; return function(){foo()}})())();", "var JSCompiler_inline_result$$0;" + "{var a$$inline_1;" + "JSCompiler_inline_result$$0=function(){foo()};}" + "JSCompiler_inline_result$$0()"); } public void testFunctionExpressionCallInlining11c() { // TODO(johnlenz): Can inline, not temps needed. assumeMinimumCapture = false; testSame("function _x() {" + " ((function(){return function(){foo()}})())();" + "}"); assumeMinimumCapture = true; test( "function _x() {" + " ((function(){return function(){foo()}})())();" + "}", "function _x() {" + " {foo()}" + "}"); } public void testFunctionExpressionCallInlining11d() { // TODO(johnlenz): Can inline into a function containing eval, if // no names are introduced. assumeMinimumCapture = false; testSame("function _x() {" + " eval();" + " ((function(){return function(){foo()}})())();" + "}"); assumeMinimumCapture = true; test( "function _x() {" + " eval();" + " ((function(){return function(){foo()}})())();" + "}", "function _x() {" + " eval();" + " {foo()}" + "}"); } public void testFunctionExpressionCallInlining11e() { // No, don't inline into a function containing eval, // if temps are introduced. assumeMinimumCapture = false; testSame("function _x() {" + " eval();" + " ((function(a){return function(){foo()}})())();" + "}"); assumeMinimumCapture = true; test("function _x() {" + " eval();" + " ((function(a){return function(){foo()}})())();" + "}", "function _x() {" + " eval();" + " {foo();}" + "}"); } public void testFunctionExpressionCallInlining12() { // Can't inline functions that recurse. testSame("(function foo(){foo()})()"); } public void testFunctionExpressionOmega() { // ... with unused recursive name. test("(function (f){f(f)})(function(f){f(f)})", "{var f$$inline_0=function(f$$1){f$$1(f$$1)};" + "{{f$$inline_0(f$$inline_0)}}}"); } public void testLocalFunctionInlining1() { test("function _f(){ function g() {} g() }", "function _f(){ void 0 }"); } public void testLocalFunctionInlining2() { test("function _f(){ function g() {foo(); bar();} g() }", "function _f(){ {foo(); bar();} }"); } public void testLocalFunctionInlining3() { test("function _f(){ function g() {foo(); bar();} g() }", "function _f(){ {foo(); bar();} }"); } public void testLocalFunctionInlining4() { test("function _f(){ function g() {return 1} return g() }", "function _f(){ return 1 }"); } public void testLocalFunctionInlining5() { testSame("function _f(){ function g() {this;} g() }"); } public void testLocalFunctionInlining6() { testSame("function _f(){ function g() {this;} return g; }"); } public void testLocalFunctionInliningOnly1() { this.allowGlobalFunctionInlining = true; test("function f(){} f()", "void 0;"); this.allowGlobalFunctionInlining = false; testSame("function f(){} f()"); } public void testLocalFunctionInliningOnly2() { this.allowGlobalFunctionInlining = false; testSame("function f(){} f()"); test("function f(){ function g() {return 1} return g() }; f();", "function f(){ return 1 }; f();"); } public void testLocalFunctionInliningOnly3() { this.allowGlobalFunctionInlining = false; testSame("function f(){} f()"); test("(function(){ function g() {return 1} return g() })();", "(function(){ return 1 })();"); } public void testLocalFunctionInliningOnly4() { this.allowGlobalFunctionInlining = false; testSame("function f(){} f()"); test("(function(){ return (function() {return 1})() })();", "(function(){ return 1 })();"); } public void testInlineWithThis1() { assumeStrictThis = false; // If no "this" is provided it might need to be coerced to the global // "this". testSame("function f(){} f.call();"); testSame("function f(){this} f.call();"); assumeStrictThis = true; // In strict mode, "this" is never coerced so we can use the provided value. test("function f(){} f.call();", "{}"); test("function f(){this} f.call();", "{void 0;}"); } public void testInlineWithThis2() { // "this" can always be replaced with "this" assumeStrictThis = false; test("function f(){} f.call(this);", "void 0"); assumeStrictThis = true; test("function f(){} f.call(this);", "void 0"); } public void testInlineWithThis3() { assumeStrictThis = false; // If no "this" is provided it might need to be coerced to the global // "this". testSame("function f(){} f.call([]);"); assumeStrictThis = true; // In strict mode, "this" is never coerced so we can use the provided value. test("function f(){} f.call([]);", "{}"); } public void testInlineWithThis4() { assumeStrictThis = false; // If no "this" is provided it might need to be coerced to the global // "this". testSame("function f(){} f.call(new g);"); assumeStrictThis = true; // In strict mode, "this" is never coerced so we can use the provided value. test("function f(){} f.call(new g);", "{var JSCompiler_inline_this_0=new g}"); } public void testInlineWithThis5() { assumeStrictThis = false; // If no "this" is provided it might need to be coerced to the global // "this". testSame("function f(){} f.call(g());"); assumeStrictThis = true; // In strict mode, "this" is never coerced so we can use the provided value. test("function f(){} f.call(g());", "{var JSCompiler_inline_this_0=g()}"); } public void testInlineWithThis6() { assumeStrictThis = false; // If no "this" is provided it might need to be coerced to the global // "this". testSame("function f(){this} f.call(new g);"); assumeStrictThis = true; // In strict mode, "this" is never coerced so we can use the provided value. test("function f(){this} f.call(new g);", "{var JSCompiler_inline_this_0=new g;JSCompiler_inline_this_0}"); } public void testInlineWithThis7() { assumeStrictThis = true; // In strict mode, "this" is never coerced so we can use the provided value. test("function f(a){a=1;this} f.call();", "{var a$$inline_0=void 0; a$$inline_0=1; void 0;}"); test("function f(a){a=1;this} f.call(x, x);", "{var a$$inline_0=x; a$$inline_0=1; x;}"); } // http://en.wikipedia.org/wiki/Fixed_point_combinator#Y_combinator public void testFunctionExpressionYCombinator() { assumeMinimumCapture = false; testSame( "var factorial = ((function(M) {\n" + " return ((function(f) {\n" + " return M(function(arg) {\n" + " return (f(f))(arg);\n" + " })\n" + " })\n" + " (function(f) {\n" + " return M(function(arg) {\n" + " return (f(f))(arg);\n" + " })\n" + " }));\n" + " })\n" + " (function(f) {\n" + " return function(n) {\n" + " if (n === 0)\n" + " return 1;\n" + " else\n" + " return n * f(n - 1);\n" + " };\n" + " }));\n" + "\n" + "factorial(5)\n"); assumeMinimumCapture = true; test( "var factorial = ((function(M) {\n" + " return ((function(f) {\n" + " return M(function(arg) {\n" + " return (f(f))(arg);\n" + " })\n" + " })\n" + " (function(f) {\n" + " return M(function(arg) {\n" + " return (f(f))(arg);\n" + " })\n" + " }));\n" + " })\n" + " (function(f) {\n" + " return function(n) {\n" + " if (n === 0)\n" + " return 1;\n" + " else\n" + " return n * f(n - 1);\n" + " };\n" + " }));\n" + "\n" + "factorial(5)\n", "var factorial;\n" + "{\n" + "var M$$inline_4 = function(f$$2) {\n" + " return function(n){if(n===0)return 1;else return n*f$$2(n-1)}\n" + "};\n" + "{\n" + "var f$$inline_0=function(f$$inline_7){\n" + " return M$$inline_4(\n" + " function(arg$$inline_8){\n" + " return f$$inline_7(f$$inline_7)(arg$$inline_8)\n" + " })\n" + "};\n" + "factorial=M$$inline_4(\n" + " function(arg$$inline_1){\n" + " return f$$inline_0(f$$inline_0)(arg$$inline_1)\n" + "});\n" + "}\n" + "}" + "factorial(5)"); } public void testRenamePropertyFunction() { testSame("function JSCompiler_renameProperty(x) {return x} " + "JSCompiler_renameProperty('foo')"); } public void testReplacePropertyFunction() { // baseline: an alias doesn't prevents declaration removal, but not // inlining. test("function f(x) {return x} " + "foo(window, f); f(1)", "function f(x) {return x} " + "foo(window, f); 1"); // a reference passed to JSCompiler_ObjectPropertyString prevents inlining // as well. testSame("function f(x) {return x} " + "new JSCompiler_ObjectPropertyString(window, f); f(1)"); } public void testInlineWithClosureContainingThis() { test("(function (){return f(function(){return this})})();", "f(function(){return this})"); } public void testIssue5159924a() { test("function f() { if (x()) return y() }\n" + "while(1){ var m = f() || z() }", "for(;1;) {" + " var JSCompiler_inline_result$$0;" + " {" + " JSCompiler_inline_label_f_1: {" + " if(x()) {" + " JSCompiler_inline_result$$0 = y();" + " break JSCompiler_inline_label_f_1" + " }" + " JSCompiler_inline_result$$0 = void 0;" + " }" + " }" + " var m=JSCompiler_inline_result$$0 || z()" + "}"); } public void testIssue5159924b() { test("function f() { if (x()) return y() }\n" + "while(1){ var m = f() }", "for(;1;){" + " var m;" + " {" + " JSCompiler_inline_label_f_0: { " + " if(x()) {" + " m = y();" + " break JSCompiler_inline_label_f_0" + " }" + " m = void 0" + " }" + " }" + "}"); } public void testInlineObject() { new StringCompare().testInlineObject(); } private static class StringCompare extends CompilerTestCase { private boolean allowGlobalFunctionInlining = true; StringCompare() { super("", false); this.enableNormalize(); this.enableMarkNoSideEffects(); } @Override public void setUp() throws Exception { super.setUp(); super.enableLineNumberCheck(true); allowGlobalFunctionInlining = true; } @Override protected CompilerPass getProcessor(Compiler compiler) { compiler.resetUniqueNameId(); return new InlineFunctions( compiler, compiler.getUniqueNameIdSupplier(), allowGlobalFunctionInlining, true, // allowLocalFunctionInlining true, // allowBlockInlining true, // assumeStrictThis true); // assumeMinimumCapture } public void testInlineObject() { allowGlobalFunctionInlining = false; // TODO(johnlenz): normalize the AST so an AST comparison can be done. // As is, the expected AST does not match the actual correct result: // The AST matches "g.a()" with a FREE_CALL annotation, but this as // expected string would fail as it won't be mark as a free call. // "(0,g.a)()" matches the output, but not the resulting AST. test("function inner(){function f(){return g.a}(f())()}", "function inner(){(0,g.a)()}"); } } public void testBug4944818() { test( "var getDomServices_ = function(self) {\n" + " if (!self.domServices_) {\n" + " self.domServices_ = goog$component$DomServices.get(" + " self.appContext_);\n" + " }\n" + "\n" + " return self.domServices_;\n" + "};\n" + "\n" + "var getOwnerWin_ = function(self) {\n" + " return getDomServices_(self).getDomHelper().getWindow();\n" + "};\n" + "\n" + "HangoutStarter.prototype.launchHangout = function() {\n" + " var self = a.b;\n" + " var myUrl = new goog.Uri(getOwnerWin_(self).location.href);\n" + "};", "HangoutStarter.prototype.launchHangout = function() { " + " var self$$2 = a.b;" + " var JSCompiler_temp_const$$0 = goog.Uri;" + " var JSCompiler_inline_result$$1;" + " {" + " var self$$inline_2 = self$$2;" + " if (!self$$inline_2.domServices_) {" + " self$$inline_2.domServices_ = goog$component$DomServices.get(" + " self$$inline_2.appContext_);" + " }" + " JSCompiler_inline_result$$1=self$$inline_2.domServices_;" + " }" + " var myUrl = new JSCompiler_temp_const$$0(" + " JSCompiler_inline_result$$1.getDomHelper()." + " getWindow().location.href)" + "}"); } public void testIssue423() { assumeMinimumCapture = false; test( "(function($) {\n" + " $.fn.multicheck = function(options) {\n" + " initialize.call(this, options);\n" + " };\n" + "\n" + " function initialize(options) {\n" + " options.checkboxes = $(this).siblings(':checkbox');\n" + " preload_check_all.call(this);\n" + " }\n" + "\n" + " function preload_check_all() {\n" + " $(this).data('checkboxes');\n" + " }\n" + "})(jQuery)", "(function($){" + " $.fn.multicheck=function(options$$1){" + " {" + " options$$1.checkboxes=$(this).siblings(\":checkbox\");" + " {" + " $(this).data(\"checkboxes\")" + " }" + " }" + " }" + "})(jQuery)"); assumeMinimumCapture = true; test( "(function($) {\n" + " $.fn.multicheck = function(options) {\n" + " initialize.call(this, options);\n" + " };\n" + "\n" + " function initialize(options) {\n" + " options.checkboxes = $(this).siblings(':checkbox');\n" + " preload_check_all.call(this);\n" + " }\n" + "\n" + " function preload_check_all() {\n" + " $(this).data('checkboxes');\n" + " }\n" + "})(jQuery)", "{var $$$inline_0=jQuery;\n" + "$$$inline_0.fn.multicheck=function(options$$inline_4){\n" + " {options$$inline_4.checkboxes=" + "$$$inline_0(this).siblings(\":checkbox\");\n" + " {$$$inline_0(this).data(\"checkboxes\")}" + " }\n" + "}\n" + "}"); } public void testIssue728() { String f = "var f = function() { return false; };"; StringBuilder calls = new StringBuilder(); StringBuilder folded = new StringBuilder(); for (int i = 0; i < 30; i++) { calls.append("if (!f()) alert('x');"); folded.append("if (!false) alert('x');"); } test(f + calls, folded.toString()); } public void testAnonymous1() { assumeMinimumCapture = false; test("(function(){var a=10;(function(){var b=a;a++;alert(b)})()})();", "{var a$$inline_0=10;" + "{var b$$inline_1=a$$inline_0;" + "a$$inline_0++;alert(b$$inline_1)}}"); assumeMinimumCapture = true; test("(function(){var a=10;(function(){var b=a;a++;alert(b)})()})();", "{var a$$inline_2=10;" + "{var b$$inline_0=a$$inline_2;" + "a$$inline_2++;alert(b$$inline_0)}}"); } public void testAnonymous2() { testSame("(function(){eval();(function(){var b=a;a++;alert(b)})()})();"); } public void testAnonymous3() { // Introducing a new value into is tricky assumeMinimumCapture = false; testSame("(function(){var a=10;(function(){arguments;})()})();"); assumeMinimumCapture = true; test("(function(){var a=10;(function(){arguments;})()})();", "{var a$$inline_0=10;(function(){arguments;})();}"); test("(function(){(function(){arguments;})()})();", "{(function(){arguments;})()}"); } public void testLoopWithFunctionWithFunction() { assumeMinimumCapture = true; test("function _testLocalVariableInLoop_() {\n" + " var result = 0;\n" + " function foo() {\n" + " var arr = [1, 2, 3, 4, 5];\n" + " for (var i = 0, l = arr.length; i < l; i++) {\n" + " var j = arr[i];\n" + // don't inline this function, because the correct behavior depends // captured values. " (function() {\n" + " var k = j;\n" + " setTimeout(function() { result += k; }, 5 * i);\n" + " })();\n" + " }\n" + " }\n" + " foo();\n" + "}", "function _testLocalVariableInLoop_(){\n" + " var result=0;\n" + " {" + " var arr$$inline_0=[1,2,3,4,5];\n" + " var i$$inline_1=0;\n" + " var l$$inline_2=arr$$inline_0.length;\n" + " for(;i$$inline_1<l$$inline_2;i$$inline_1++){\n" + " var j$$inline_3=arr$$inline_0[i$$inline_1];\n" + " (function(){\n" + " var k$$inline_4=j$$inline_3;\n" + " setTimeout(function(){result+=k$$inline_4},5*i$$inline_1)\n" + " })()\n" + " }\n" + " }\n" + "}"); } public void testMethodWithFunctionWithFunction() { assumeMinimumCapture = true; test("function _testLocalVariable_() {\n" + " var result = 0;\n" + " function foo() {\n" + " var j = [i];\n" + " (function(j) {\n" + " setTimeout(function() { result += j; }, 5 * i);\n" + " })(j);\n" + " j = null;" + " }\n" + " foo();\n" + "}", "function _testLocalVariable_(){\n" + " var result=0;\n" + " {\n" + " var j$$inline_2=[i];\n" + " {\n" + " var j$$inline_0=j$$inline_2;\n" + // this temp is needed. " setTimeout(function(){result+=j$$inline_0},5*i);\n" + " }\n" + " j$$inline_2=null\n" + // because this value can be modified later. " }\n" + "}"); } // Inline a single reference function into deeper modules public void testCrossModuleInlining1() { test(createModuleChain( // m1 "function foo(){return f(1)+g(2)+h(3);}", // m2 "foo()" ), new String[] { // m1 "", // m2 "f(1)+g(2)+h(3);" } ); } // Inline a single reference function into shallow modules, only if it // is cheaper than the call itself. public void testCrossModuleInlining2() { testSame(createModuleChain( // m1 "foo()", // m2 "function foo(){return f(1)+g(2)+h(3);}" ) ); test(createModuleChain( // m1 "foo()", // m2 "function foo(){return f();}" ), new String[] { // m1 "f();", // m2 "" } ); } // Inline a multi-reference functions into shallow modules, only if it // is cheaper than the call itself. public void testCrossModuleInlining3() { testSame(createModuleChain( // m1 "foo()", // m2 "function foo(){return f(1)+g(2)+h(3);}", // m3 "foo()" ) ); test(createModuleChain( // m1 "foo()", // m2 "function foo(){return f();}", // m3 "foo()" ), new String[] { // m1 "f();", // m2 "", // m3 "f();" } ); } public void test6671158() { test( "function f() {return g()}" + "function Y(a){a.loader_()}" + "function _Z(){}" + "function _X() { new _Z(a,b, Y(singleton), f()) }", "function _Z(){}" + "function _X(){" + " var JSCompiler_temp_const$$2=_Z;" + " var JSCompiler_temp_const$$1=a;" + " var JSCompiler_temp_const$$0=b;" + " var JSCompiler_inline_result$$3;" + " {" + " singleton.loader_();" + " JSCompiler_inline_result$$3=void 0;" + " }" + " new JSCompiler_temp_const$$2(" + " JSCompiler_temp_const$$1," + " JSCompiler_temp_const$$0," + " JSCompiler_inline_result$$3," + " g())}"); } }
/* * Copyright 2011 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Verifies that valid candidates for object literals are inlined as * expected, and invalid candidates are not touched. * */ public class InlineObjectLiteralsTest extends CompilerTestCase { public InlineObjectLiteralsTest() { enableNormalize(); } @Override public void setUp() { super.enableLineNumberCheck(true); } @Override protected CompilerPass getProcessor(final Compiler compiler) { return new InlineObjectLiterals( compiler, compiler.getUniqueNameIdSupplier()); } // Test object literal -> variable inlining public void testObject0() { // Don't mess with global variables, that is the job of CollapseProperties. testSame("var a = {x:1}; f(a.x);"); } public void testObject1() { testLocal("var a = {x:x(), y:y()}; f(a.x, a.y);", "var JSCompiler_object_inline_x_0=x();" + "var JSCompiler_object_inline_y_1=y();" + "f(JSCompiler_object_inline_x_0, JSCompiler_object_inline_y_1);"); } public void testObject1a() { testLocal("var a; a = {x:x, y:y}; f(a.x, a.y);", "var JSCompiler_object_inline_x_0;" + "var JSCompiler_object_inline_y_1;" + "(JSCompiler_object_inline_x_0=x," + "JSCompiler_object_inline_y_1=y, true);" + "f(JSCompiler_object_inline_x_0, JSCompiler_object_inline_y_1);"); } public void testObject2() { testLocal("var a = {y:y}; a.x = z; f(a.x, a.y);", "var JSCompiler_object_inline_y_0 = y;" + "var JSCompiler_object_inline_x_1;" + "JSCompiler_object_inline_x_1=z;" + "f(JSCompiler_object_inline_x_1, JSCompiler_object_inline_y_0);"); } public void testObject3() { // Inlining the 'y' would cause the 'this' to be different in the // target function. testSameLocal("var a = {y:y,x:x}; a.y(); f(a.x);"); testSameLocal("var a; a = {y:y,x:x}; a.y(); f(a.x);"); } public void testObject4() { // Object literal is escaped. testSameLocal("var a = {y:y}; a.x = z; f(a.x, a.y); g(a);"); testSameLocal("var a; a = {y:y}; a.x = z; f(a.x, a.y); g(a);"); } public void testObject5() { testLocal("var a = {x:x, y:y}; var b = {a:a}; f(b.a.x, b.a.y);", "var a = {x:x, y:y};" + "var JSCompiler_object_inline_a_0=a;" + "f(JSCompiler_object_inline_a_0.x, JSCompiler_object_inline_a_0.y);"); } public void testObject6() { testLocal("for (var i = 0; i < 5; i++) { var a = {i:i,x:x}; f(a.i, a.x); }", "for (var i = 0; i < 5; i++) {" + " var JSCompiler_object_inline_i_0=i;" + " var JSCompiler_object_inline_x_1=x;" + " f(JSCompiler_object_inline_i_0,JSCompiler_object_inline_x_1)" + "}"); testLocal("if (c) { var a = {i:i,x:x}; f(a.i, a.x); }", "if (c) {" + " var JSCompiler_object_inline_i_0=i;" + " var JSCompiler_object_inline_x_1=x;" + " f(JSCompiler_object_inline_i_0,JSCompiler_object_inline_x_1)" + "}"); } public void testObject7() { testLocal("var a = {x:x, y:f()}; g(a.x);", "var JSCompiler_object_inline_x_0=x;" + "var JSCompiler_object_inline_y_1=f();" + "g(JSCompiler_object_inline_x_0)"); } public void testObject8() { testSameLocal("var a = {x:x,y:y}; var b = {x:y}; f((c?a:b).x);"); testLocal("var a; if(c) { a={x:x, y:y}; } else { a={x:y}; } f(a.x);", "var JSCompiler_object_inline_x_0;" + "var JSCompiler_object_inline_y_1;" + "if(c) JSCompiler_object_inline_x_0=x," + " JSCompiler_object_inline_y_1=y," + " true;" + "else JSCompiler_object_inline_x_0=y," + " JSCompiler_object_inline_y_1=void 0," + " true;" + "f(JSCompiler_object_inline_x_0)"); testLocal("var a = {x:x,y:y}; var b = {x:y}; c ? f(a.x) : f(b.x);", "var JSCompiler_object_inline_x_0 = x; " + "var JSCompiler_object_inline_y_1 = y; " + "var JSCompiler_object_inline_x_2 = y; " + "c ? f(JSCompiler_object_inline_x_0):f(JSCompiler_object_inline_x_2)"); } public void testObject9() { // There is a call, so no inlining testSameLocal("function f(a,b) {" + " var x = {a:a,b:b}; x.a(); return x.b;" + "}"); testLocal("function f(a,b) {" + " var x = {a:a,b:b}; g(x.a); x = {a:a,b:2}; return x.b;" + "}", "function f(a,b) {" + " var JSCompiler_object_inline_a_0 = a;" + " var JSCompiler_object_inline_b_1 = b;" + " g(JSCompiler_object_inline_a_0);" + " JSCompiler_object_inline_a_0 = a," + " JSCompiler_object_inline_b_1=2," + " true;" + " return JSCompiler_object_inline_b_1" + "}"); testLocal("function f(a,b) { " + " var x = {a:a,b:b}; g(x.a); x.b = x.c = 2; return x.b; " + "}", "function f(a,b) { " + " var JSCompiler_object_inline_a_0=a;" + " var JSCompiler_object_inline_b_1=b; " + " var JSCompiler_object_inline_c_2;" + " g(JSCompiler_object_inline_a_0);" + " JSCompiler_object_inline_b_1=JSCompiler_object_inline_c_2=2;" + " return JSCompiler_object_inline_b_1" + "}"); } public void testObject10() { testLocal("var x; var b = f(); x = {a:a, b:b}; if(x.a) g(x.b);", "var JSCompiler_object_inline_a_0;" + "var JSCompiler_object_inline_b_1;" + "var b = f();" + "JSCompiler_object_inline_a_0=a,JSCompiler_object_inline_b_1=b,true;" + "if(JSCompiler_object_inline_a_0) g(JSCompiler_object_inline_b_1)"); testLocal("var x = {}; var b = f(); x = {a:a, b:b}; if(x.a) g(x.b) + x.c", "var x = {}; var b = f(); x = {a:a, b:b}; if(x.a) g(x.b) + x.c"); testLocal("var x; var b = f(); x = {a:a, b:b}; x.c = c; if(x.a) g(x.b) + x.c", "var JSCompiler_object_inline_a_0;" + "var JSCompiler_object_inline_b_1;" + "var JSCompiler_object_inline_c_2;" + "var b = f();" + "JSCompiler_object_inline_a_0 = a,JSCompiler_object_inline_b_1 = b, " + " JSCompiler_object_inline_c_2=void 0,true;" + "JSCompiler_object_inline_c_2 = c;" + "if (JSCompiler_object_inline_a_0)" + " g(JSCompiler_object_inline_b_1) + JSCompiler_object_inline_c_2;"); testLocal("var x = {a:a}; if (b) x={b:b}; f(x.a||x.b);", "var JSCompiler_object_inline_a_0 = a;" + "var JSCompiler_object_inline_b_1;" + "if(b) JSCompiler_object_inline_b_1 = b," + " JSCompiler_object_inline_a_0 = void 0," + " true;" + "f(JSCompiler_object_inline_a_0 || JSCompiler_object_inline_b_1)"); testLocal("var x; var y = 5; x = {a:a, b:b, c:c}; if (b) x={b:b}; f(x.a||x.b);", "var JSCompiler_object_inline_a_0;" + "var JSCompiler_object_inline_b_1;" + "var JSCompiler_object_inline_c_2;" + "var y=5;" + "JSCompiler_object_inline_a_0=a," + "JSCompiler_object_inline_b_1=b," + "JSCompiler_object_inline_c_2=c," + "true;" + "if (b) JSCompiler_object_inline_b_1=b," + " JSCompiler_object_inline_a_0=void 0," + " JSCompiler_object_inline_c_2=void 0," + " true;" + "f(JSCompiler_object_inline_a_0||JSCompiler_object_inline_b_1)"); } public void testObject11() { testSameLocal("var x = {a:b}; (x = {a:a}).c = 5; f(x.a);"); testSameLocal("var x = {a:a}; f(x[a]); g(x[a]);"); } public void testObject12() { testLocal("var a; a = {x:1, y:2}; f(a.x, a.y2);", "var a; a = {x:1, y:2}; f(a.x, a.y2);"); } public void testObject13() { testSameLocal("var x = {a:1, b:2}; x = {a:3, b:x.a};"); } public void testObject14() { testSameLocal("var x = {a:1}; if ('a' in x) { f(); }"); testSameLocal("var x = {a:1}; for (var y in x) { f(y); }"); } public void testObject15() { testSameLocal("x = x || {}; f(x.a);"); } public void testObject16() { testLocal("function f(e) { bar(); x = {a: foo()}; var x; print(x.a); }", "function f(e) { " + " var JSCompiler_object_inline_a_0;" + " bar();" + " JSCompiler_object_inline_a_0 = foo(), true;" + " print(JSCompiler_object_inline_a_0);" + "}"); } public void testObject17() { // Note: Some day, with careful analysis, these two uses could be // disambiguated, and the second assignment could be inlined. testSameLocal( "var a = {a: function(){}};" + "a.a();" + "a = {a1: 100};" + "print(a.a1);"); } public void testObject18() { testSameLocal("var a,b; b=a={x:x, y:y}; f(b.x);"); } public void testObject19() { testSameLocal("var a,b; if(c) { b=a={x:x, y:y}; } else { b=a={x:y}; } f(b.x);"); } public void testObject20() { testSameLocal("var a,b; if(c) { b=a={x:x, y:y}; } else { b=a={x:y}; } f(a.x);"); } public void testObject21() { testSameLocal("var a,b; b=a={x:x, y:y};"); testSameLocal("var a,b; if(c) { b=a={x:x, y:y}; }" + "else { b=a={x:y}; } f(a.x); f(b.x)"); testSameLocal("var a, b; if(c) { if (a={x:x, y:y}) f(); } " + "else { b=a={x:y}; } f(a.x);"); testSameLocal("var a,b; b = (a = {x:x, y:x});"); testSameLocal("var a,b; a = {x:x, y:x}; b = a"); testSameLocal("var a,b; a = {x:x, y:x}; b = x || a"); testSameLocal("var a,b; a = {x:x, y:x}; b = y && a"); testSameLocal("var a,b; a = {x:x, y:x}; b = y ? a : a"); testSameLocal("var a,b; a = {x:x, y:x}; b = y , a"); testSameLocal("b = x || (a = {x:1, y:2});"); } public void testObject22() { testLocal("while(1) { var a = {y:1}; if (b) a.x = 2; f(a.y, a.x);}", "for(;1;){" + " var JSCompiler_object_inline_y_0=1;" + " var JSCompiler_object_inline_x_1;" + " if(b) JSCompiler_object_inline_x_1=2;" + " f(JSCompiler_object_inline_y_0,JSCompiler_object_inline_x_1)" + "}"); testLocal("var a; while (1) { f(a.x, a.y); a = {x:1, y:1};}", "var a; while (1) { f(a.x, a.y); a = {x:1, y:1};}"); } public void testObject23() { testLocal("function f() {\n" + " var templateData = {\n" + " linkIds: {\n" + " CHROME: 'cl',\n" + " DISMISS: 'd'\n" + " }\n" + " };\n" + " var html = templateData.linkIds.CHROME \n" + " + \":\" + templateData.linkIds.DISMISS;\n" + "}", "function f(){" + "var JSCompiler_object_inline_CHROME_1='cl';" + "var JSCompiler_object_inline_DISMISS_2='d';" + "var html=JSCompiler_object_inline_CHROME_1 +" + " ':' +JSCompiler_object_inline_DISMISS_2}"); } public void testObject24() { testLocal("function f() {\n" + " var linkIds = {\n" + " CHROME: 1,\n" + " };\n" + " var g = function () {var o = {a: linkIds};}\n" + "}", "function f(){var linkIds={CHROME:1};" + "var g=function(){var JSCompiler_object_inline_a_0=linkIds}}"); } public void testObject25() { testLocal("var a = {x:f(), y:g()}; a = {y:g(), x:f()}; f(a.x, a.y);", "var JSCompiler_object_inline_x_0=f();" + "var JSCompiler_object_inline_y_1=g();" + "JSCompiler_object_inline_y_1=g()," + " JSCompiler_object_inline_x_0=f()," + " true;" + "f(JSCompiler_object_inline_x_0,JSCompiler_object_inline_y_1)"); } public void testObject26() { testLocal("var a = {}; a.b = function() {}; new a.b.c", "var JSCompiler_object_inline_b_0;" + "JSCompiler_object_inline_b_0=function(){};" + "new JSCompiler_object_inline_b_0.c"); } public void testBug545() { testLocal("var a = {}", ""); testLocal("var a; a = {}", "true"); } public void testIssue724() { testSameLocal( "var getType; getType = {};" + "return functionToCheck && " + " getType.toString.apply(functionToCheck) === " + " '[object Function]';"); } public void testNoInlineDeletedProperties() { testSameLocal( "var foo = {bar:1};" + "delete foo.bar;" + "return foo.bar;"); } private final String LOCAL_PREFIX = "function local(){"; private final String LOCAL_POSTFIX = "}"; private void testLocal(String code, String result) { test(LOCAL_PREFIX + code + LOCAL_POSTFIX, LOCAL_PREFIX + result + LOCAL_POSTFIX); } private void testSameLocal(String code) { testLocal(code, code); } }
/* * Copyright 2012 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * @author johnlenz@google.com (John Lenz) */ public class InlinePropertiesTest extends CompilerTestCase { private static final String EXTERNS = "Function.prototype.call=function(){};" + "Function.prototype.inherits=function(){};" + "prop.toString;" + "var google = { gears: { factory: {}, workerPool: {} } };"; public InlinePropertiesTest() { super(EXTERNS); enableNormalize(); enableTypeCheck(CheckLevel.WARNING); enableClosurePass(); } @Override protected CompilerPass getProcessor(Compiler compiler) { return new InlineProperties(compiler); } public void testConstInstanceProp1() { // Replace a reference to known constant property. test( "/** @constructor */\n" + "function C() {\n" + " this.foo = 1;\n" + "}\n" + "new C().foo;", "function C() {\n" + " this.foo = 1;\n" + "}\n" + "new C(), 1;"); } public void testConstInstanceProp2() { // Replace a constant reference test( "/** @constructor */\n" + "function C() {\n" + " this.foo = 1;\n" + "}\n" + "var x = new C();\n" + "x.foo;", "function C() {\n" + " this.foo = 1\n" + "}\n" + "var x = new C();\n" + "1;\n"); } public void testConstInstanceProp3() { // Replace a constant reference test( "/** @constructor */\n" + "function C() {\n" + " this.foo = 1;\n" + "}\n" + "/** @type {C} */\n" + "var x = new C();\n" + "x.foo;", "function C() {\n" + " this.foo = 1\n" + "}\n" + "var x = new C();\n" + "1;\n"); } public void testConstInstanceProp4() { // This pass replies on DisambiguateProperties to distinguish like named // properties so it doesn't handle this case. testSame( "/** @constructor */\n" + "function C() {\n" + " this.foo = 1;\n" + "}\n" + "/** @constructor */\n" + "function B() {\n" + " this.foo = 1;\n" + "}\n" + "new C().foo;\n"); } public void testConstClassProps1() { // For now, don't inline constant class properties, // CollapseProperties should handle this in most cases. testSame( "/** @constructor */\n" + "function C() {\n" + "}\n" + "C.foo = 1;\n" + "C.foo;"); } public void testConstClassProps2() { // Don't confuse, class properties with instance properties testSame( "/** @constructor */\n" + "function C() {\n" + " this.foo = 1;\n" + "}\n" + "C.foo;"); } public void testConstClassProps3() { // Don't confuse, class properties with prototype properties testSame( "/** @constructor */\n" + "function C() {}\n" + "C.prototype.foo = 1;\n" + "c.foo;\n"); } public void testNonConstClassProp1() { testSame( "/** @constructor */\n" + "function C() {\n" + " this.foo = 1;\n" + "}\n" + "var x = new C();\n" + "alert(x.foo);\n" + "delete x.foo;"); } public void testNonConstClassProp2() { testSame( "/** @constructor */\n" + "function C() {\n" + " this.foo = 1;\n" + "}\n" + "var x = new C();\n" + "alert(x.foo);\n" + "x.foo = 2;"); } public void testNonConstructorClassProp1() { testSame( "function C() {\n" + " this.foo = 1;\n" + " return this;\n" + "}\n" + "C().foo;"); } public void testConditionalClassProp1() { testSame( "/** @constructor */\n" + "function C() {\n" + " if (false) this.foo = 1;\n" + "}\n" + "new C().foo;"); } public void testConstPrototypeProp1() { test( "/** @constructor */\n" + "function C() {}\n" + "C.prototype.foo = 1;\n" + "new C().foo;\n", "function C() {}\n" + "C.prototype.foo = 1;\n" + "new C(), 1;\n"); } public void testConstPrototypeProp2() { test( "/** @constructor */\n" + "function C() {}\n" + "C.prototype.foo = 1;\n" + "var x = new C();\n" + "x.foo;\n", "function C() {}\n" + "C.prototype.foo = 1;\n" + "var x = new C();\n" + "1;\n"); } }
/* * Copyright 2007 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; public class InlineSimpleMethodsTest extends CompilerTestCase { public InlineSimpleMethodsTest() { super("", false); } @Override protected void setUp() throws Exception { super.setUp(); super.enableLineNumberCheck(true); } @Override protected CompilerPass getProcessor(Compiler compiler) { return new InlineSimpleMethods(compiler); } /** * Helper for tests that expects definitions to remain unchanged, such * that {@code definitions+js} is converted to {@code definitions+expected}. */ private void testWithPrefix(String definitions, String js, String expected) { test(definitions + js, definitions + expected); } public void testSimpleInline1() { testWithPrefix("function Foo(){}" + "Foo.prototype.bar=function(){return this.baz};", "var x=(new Foo).bar();var y=(new Foo).bar();", "var x=(new Foo).baz;var y=(new Foo).baz"); } public void testSimpleInline2() { testWithPrefix("function Foo(){}" + "Foo.prototype={bar:function(){return this.baz}};", "var x=(new Foo).bar();var y=(new Foo).bar();", "var x=(new Foo).baz;var y=(new Foo).baz"); } public void testSimpleGetterInline1() { // TODO(johnlenz): Support this case. testSame("function Foo(){}" + "Foo.prototype={get bar(){return this.baz}};" + "var x=(new Foo).bar;var y=(new Foo).bar"); // Verify we are not confusing calling the result of an ES5 getter // with call the getter. testSame("function Foo(){}" + "Foo.prototype={get bar(){return this.baz}};" + "var x=(new Foo).bar();var y=(new Foo).bar()"); } public void testSimpleSetterInline1() { // Verify 'get' and 'set' are not confused. testSame("function Foo(){}" + "Foo.prototype={set bar(a){return this.baz}};" + "var x=(new Foo).bar;var y=(new Foo).bar"); testSame("function Foo(){}" + "Foo.prototype={set bar(a){return this.baz}};" + "var x=(new Foo).bar();var y=(new Foo).bar()"); } public void testSelfInline() { testWithPrefix("function Foo(){}" + "Foo.prototype.bar=function(){return this.baz};", "Foo.prototype.meth=function(){this.bar();}", "Foo.prototype.meth=function(){this.baz}"); } public void testCallWithArgs() { testWithPrefix("function Foo(){}" + "Foo.prototype.bar=function(){return this.baz};", "var x=(new Foo).bar(3,new Foo)", "var x=(new Foo).bar(3,new Foo)"); } public void testCallWithConstArgs() { testWithPrefix("function Foo(){}" + "Foo.prototype.bar=function(a){return this.baz};", "var x=(new Foo).bar(3, 4)", "var x=(new Foo).baz"); } public void testNestedProperties() { testWithPrefix("function Foo(){}" + "Foo.prototype.bar=function(){return this.baz.ooka};", "(new Foo).bar()", "(new Foo).baz.ooka"); } public void testSkipComplexMethods() { testWithPrefix("function Foo(){}" + "Foo.prototype.bar=function(){return this.baz};" + "Foo.prototype.condy=function(){return this.baz?this.baz:1};", "var x=(new Foo).argy()", "var x=(new Foo).argy()"); } public void testSkipConflictingMethods() { testWithPrefix("function Foo(){}" + "Foo.prototype.bar=function(){return this.baz};" + "Foo.prototype.bar=function(){return this.bazz};", "var x=(new Foo).bar()", "var x=(new Foo).bar()"); } public void testSameNamesDifferentDefinitions() { testWithPrefix("function A(){}" + "A.prototype.g=function(){return this.a};" + "function B(){}" + "B.prototype.g=function(){return this.b};", "var x=(new A).g();" + "var y=(new B).g();" + "var a=new A;" + "var ag=a.g();", "var x=(new A).g();" + "var y=(new B).g();" + "var a=new A;" + "var ag=a.g()"); } public void testSameNamesSameDefinitions() { testWithPrefix("function A(){}" + "A.prototype.g=function(){return this.a};" + "function B(){}" + "B.prototype.g=function(){return this.a};", "var x=(new A).g();" + "var y=(new B).g();" + "var a=new A;" + "var ag=a.g();", "var x=(new A).a;" + "var y=(new B).a;" + "var a=new A;" + "var ag=a.a"); } public void testConfusingNames() { testWithPrefix("function Foo(){}" + "Foo.prototype.bar=function(){return this.baz};", "function bar(){var bar=function(){};bar()}", "function bar(){var bar=function(){};bar()}"); } public void testConstantInline() { testWithPrefix("function Foo(){}" + "Foo.prototype.bar=function(){return 3};", "var f=new Foo;var x=f.bar()", "var f=new Foo;var x=3"); } public void testConstantArrayInline() { testWithPrefix("function Foo(){}" + "Foo.prototype.bar=function(){return[3,4]};", "var f=new Foo;var x=f.bar()", "var f=new Foo;var x=[3,4]"); } public void testConstantInlineWithSideEffects() { testWithPrefix("function Foo(){}" + "Foo.prototype.bar=function(){return 3};", "var x=(new Foo).bar()", "var x=(new Foo).bar()"); } public void testEmptyMethodInline() { testWithPrefix("function Foo(){}" + "Foo.prototype.bar=function(a){};", "var x=new Foo; x.bar();", "var x=new Foo"); } public void testEmptyMethodInlineWithSideEffects() { testWithPrefix("function Foo(){}" + "Foo.prototype.bar=function(){};", "(new Foo).bar();var y=new Foo;y.bar(new Foo)", "(new Foo).bar();var y=new Foo;y.bar(new Foo)"); } public void testEmptyMethodInlineInAssign1() { testWithPrefix("function Foo(){}" + "Foo.prototype.bar=function(){};", "var x=new Foo;var y=x.bar()", "var x=new Foo;var y=void 0"); } public void testEmptyMethodInlineInAssign2() { testWithPrefix("function Foo(){}" + "Foo.prototype.bar=function(){};", "var x=new Foo;var y=x.bar().toString()", "var x=new Foo;var y=(void 0).toString()"); } public void testNormalMethod() { testWithPrefix("function Foo(){}" + "Foo.prototype.bar=function(){var x=1};", "var x=new Foo;x.bar()", "var x=new Foo;x.bar()"); } public void testNoInlineOfExternMethods1() { testSame("var external={};external.charAt;", "external.charAt()", (DiagnosticType) null); } public void testNoInlineOfExternMethods2() { testSame("var external={};external.charAt=function(){};", "external.charAt()", (DiagnosticType) null); } public void testNoInlineOfExternMethods3() { testSame("var external={};external.bar=function(){};", "function Foo(){}Foo.prototype.bar=function(){};(new Foo).bar()", (DiagnosticType) null); } public void testNoInlineOfDangerousProperty() { testSame("function Foo(){this.bar=3}" + "Foo.prototype.bar=function(){};" + "var x=new Foo;var y=x.bar()"); } // Don't warn about argument naming conventions (this is done in another pass) // opt_ parameters must not be followed by non-optional parameters. // var_args must be last public void testNoWarn() { testSame("function Foo(){}" + "Foo.prototype.bar=function(opt_a,b){var x=1};" + "var x=new Foo;x.bar()"); testSame("function Foo(){}" + "Foo.prototype.bar=function(var_args,b){var x=1};" + "var x=new Foo;x.bar()"); } public void testObjectLit() { testSame("Foo.prototype.bar=function(){return this.baz_};" + "var blah={bar:function(){}};" + "(new Foo).bar()"); } public void testObjectLit2() { testSame("var blah={bar:function(){}};" + "(new Foo).bar()"); } public void testObjectLitExtern() { String externs = "window.bridge={_sip:function(){}};"; testSame(externs, "window.bridge._sip()", null); } public void testExternFunction() { String externs = "function emptyFunction() {}"; testSame(externs, "function Foo(){this.empty=emptyFunction}" + "(new Foo).empty()", null); } public void testIssue2508576_1() { // Method defined by an extern should be left alone. String externs = "function alert(a) {}"; testSame(externs, "({a:alert,b:alert}).a(\"a\")", null); } public void testIssue2508576_2() { // Anonymous object definition with a side-effect should be left alone. testSame("({a:function(){},b:x()}).a(\"a\")"); } public void testIssue2508576_3() { // Anonymous object definition without side-effect should be removed. test("({a:function(){},b:alert}).a(\"a\")", ""); } public void testAnonymousGet() { // Anonymous object definition without side-effect should be removed. testSame("({get a(){return function(){}},b:alert}).a(\"a\")"); testSame("({get a(){},b:alert}).a(\"a\")"); testSame("({get a(){},b:alert}).a"); } public void testAnonymousSet() { // Anonymous object definition without side-effect should be removed. testSame("({set a(b){return function(){}},b:alert}).a(\"a\")"); testSame("({set a(b){},b:alert}).a(\"a\")"); testSame("({set a(b){},b:alert}).a"); } }
/* * Copyright 2004 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Ensures that the InlineVariables pass in constants-only mode * is functionally equivalent to the old InlineVariablesConstants pass. */ public class InlineVariablesConstantsTest extends CompilerTestCase { private boolean inlineAllStrings = false; public InlineVariablesConstantsTest() { enableNormalize(); } @Override protected CompilerPass getProcessor(final Compiler compiler) { return new InlineVariables( compiler, InlineVariables.Mode.CONSTANTS_ONLY, inlineAllStrings); } @Override public void tearDown() { inlineAllStrings = false; } public void testInlineVariablesConstants() { test("var ABC=2; var x = ABC;", "var x=2"); test("var AA = 'aa'; AA;", "'aa'"); test("var A_A=10; A_A + A_A;", "10+10"); test("var AA=1", ""); test("var AA; AA=1", "1"); test("var AA; if (false) AA=1; AA;", "if (false) 1; 1;"); testSame("var AA; if (false) AA=1; else AA=2; AA;"); test("var AA;(function () {AA=1})()", "(function () {1})()"); // Make sure that nothing explodes if there are undeclared variables. testSame("var x = AA;"); // Don't inline if it will make the output larger. testSame("var AA = '1234567890'; foo(AA); foo(AA); foo(AA);"); test("var AA = '123456789012345';AA;", "'123456789012345'"); } public void testNoInlineArraysOrRegexps() { testSame("var AA = [10,20]; AA[0]"); testSame("var AA = [10,20]; AA.push(1); AA[0]"); testSame("var AA = /x/; AA.test('1')"); testSame("/** @const */ var aa = /x/; aa.test('1')"); } public void testInlineVariablesConstantsJsDocStyle() { test("/** @const */var abc=2; var x = abc;", "var x=2"); test("/** @const */var aa = 'aa'; aa;", "'aa'"); test("/** @const */var a_a=10; a_a + a_a;", "10+10"); test("/** @const */var aa=1;", ""); test("/** @const */var aa; aa=1;", "1"); test("/** @const */var aa;(function () {aa=1})()", "(function () {1})()"); test("/** @const */var aa;(function () {aa=1})(); var z=aa", "(function () {1})(); var z=1"); testSame("/** @const */var aa;(function () {var y; aa=y})(); var z=aa"); // Don't inline if it will make the output larger. testSame("/** @const */var aa = '1234567890'; foo(aa); foo(aa); foo(aa);"); test("/** @const */var aa = '123456789012345';aa;", "'123456789012345'"); } public void testInlineConditionallyDefinedConstant1() { // Note that inlining conditionally defined constants can change the // run-time behavior of code (e.g. when y is true and x is false in the // example below). We inline them anyway because if the code author didn't // want one inlined, he/she could define it as a non-const variable instead. test("if (x) var ABC = 2; if (y) f(ABC);", "if (x); if (y) f(2);"); } public void testInlineConditionallyDefinedConstant2() { test("if (x); else var ABC = 2; if (y) f(ABC);", "if (x); else; if (y) f(2);"); } public void testInlineConditionallyDefinedConstant3() { test("if (x) { var ABC = 2; } if (y) { f(ABC); }", "if (x) {} if (y) { f(2); }"); } public void testInlineDefinedConstant() { test( "/**\n" + " * @define {string}\n" + " */\n" + "var aa = '1234567890';\n" + "foo(aa); foo(aa); foo(aa);", "foo('1234567890');foo('1234567890');foo('1234567890')"); test( "/**\n" + " * @define {string}\n" + " */\n" + "var ABC = '1234567890';\n" + "foo(ABC); foo(ABC); foo(ABC);", "foo('1234567890');foo('1234567890');foo('1234567890')"); } public void testInlineVariablesConstantsWithInlineAllStringsOn() { inlineAllStrings = true; test("var AA = '1234567890'; foo(AA); foo(AA); foo(AA);", "foo('1234567890'); foo('1234567890'); foo('1234567890')"); } public void testNoInlineWithoutConstDeclaration() { testSame("var abc = 2; var x = abc;"); } // TODO(nicksantos): enable this again once we allow constant aliasing. // public void testInlineConstantAlias() { // test("var XXX = new Foo(); var YYY = XXX; bar(YYY)", // "var XXX = new Foo(); bar(XXX)"); // } public void testNoInlineAliases() { testSame("var XXX = new Foo(); var yyy = XXX; bar(yyy)"); testSame("var xxx = new Foo(); var YYY = xxx; bar(YYY)"); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Verifies that valid candidates for inlining are inlined, but * that no dangerous inlining occurs. * * @author kushal@google.com (Kushal Dave) */ public class InlineVariablesTest extends CompilerTestCase { private boolean inlineAllStrings = false; private boolean inlineLocalsOnly = false; public InlineVariablesTest() { enableNormalize(); } @Override public void setUp() { super.enableLineNumberCheck(true); } @Override protected CompilerPass getProcessor(final Compiler compiler) { return new InlineVariables( compiler, (inlineLocalsOnly) ? InlineVariables.Mode.LOCALS_ONLY : InlineVariables.Mode.ALL, inlineAllStrings); } @Override public void tearDown() { inlineAllStrings = false; inlineLocalsOnly = false; } // Test respect for scopes and blocks public void testInlineGlobal() { test("var x = 1; var z = x;", "var z = 1;"); } public void testNoInlineExportedName() { testSame("var _x = 1; var z = _x;"); } public void testNoInlineExportedName2() { testSame("var f = function() {}; var _x = f;" + "var y = function() { _x(); }; var _y = f;"); } public void testDoNotInlineIncrement() { testSame("var x = 1; x++;"); } public void testDoNotInlineDecrement() { testSame("var x = 1; x--;"); } public void testDoNotInlineIntoLhsOfAssign() { testSame("var x = 1; x += 3;"); } public void testInlineIntoRhsOfAssign() { test("var x = 1; var y = x;", "var y = 1;"); } public void testInlineInFunction() { test("function baz() { var x = 1; var z = x; }", "function baz() { var z = 1; }"); } public void testInlineInFunction2() { test("function baz() { " + "var a = new obj();"+ "result = a;" + "}", "function baz() { " + "result = new obj()" + "}"); } public void testInlineInFunction3() { testSame( "function baz() { " + "var a = new obj();" + "(function(){a;})();" + "result = a;" + "}"); } public void testInlineInFunction4() { testSame( "function baz() { " + "var a = new obj();" + "foo.result = a;" + "}"); } public void testInlineInFunction5() { testSame( "function baz() { " + "var a = (foo = new obj());" + "foo.x();" + "result = a;" + "}"); } public void testInlineAcrossModules() { // TODO(kushal): Make decision about overlap with CrossModuleCodeMotion test(createModules("var a = 2;", "var b = a;"), new String[] { "", "var b = 2;" }); } public void testDoNotExitConditional1() { testSame("if (true) { var x = 1; } var z = x;"); } public void testDoNotExitConditional2() { testSame("if (true) var x = 1; var z = x;"); } public void testDoNotExitConditional3() { testSame("var x; if (true) x=1; var z = x;"); } public void testDoNotExitLoop() { testSame("while (z) { var x = 3; } var y = x;"); } public void testDoNotExitForLoop() { test("for (var i = 1; false; false) var z = i;", "for (;false;false) var z = 1;"); testSame("for (; false; false) var i = 1; var z = i;"); testSame("for (var i in {}); var z = i;"); } public void testDoNotEnterSubscope() { testSame( "var x = function() {" + " var self = this; " + " return function() { var y = self; };" + "}"); testSame( "var x = function() {" + " var y = [1]; " + " return function() { var z = y; };" + "}"); } public void testDoNotExitTry() { testSame("try { var x = y; } catch (e) {} var z = y; "); testSame("try { throw e; var x = 1; } catch (e) {} var z = x; "); } public void testDoNotEnterCatch() { testSame("try { } catch (e) { var z = e; } "); } public void testDoNotEnterFinally() { testSame("try { throw e; var x = 1; } catch (e) {} " + "finally { var z = x; } "); } public void testInsideIfConditional() { test("var a = foo(); if (a) { alert(3); }", "if (foo()) { alert(3); }"); test("var a; a = foo(); if (a) { alert(3); }", "if (foo()) { alert(3); }"); } public void testOnlyReadAtInitialization() { test("var a; a = foo();", "foo();"); test("var a; if (a = foo()) { alert(3); }", "if (foo()) { alert(3); }"); test("var a; switch (a = foo()) {}", "switch(foo()) {}"); test("var a; function f(){ return a = foo(); }", "function f(){ return foo(); }"); test("function f(){ var a; return a = foo(); }", "function f(){ return foo(); }"); test("var a; with (a = foo()) { alert(3); }", "with (foo()) { alert(3); }"); test("var a; b = (a = foo());", "b = foo();"); test("var a; while(a = foo()) { alert(3); }", "while(foo()) { alert(3); }"); test("var a; for(;a = foo();) { alert(3); }", "for(;foo();) { alert(3); }"); test("var a; do {} while(a = foo()) { alert(3); }", "do {} while(foo()) { alert(3); }"); } public void testImmutableWithSingleReferenceAfterInitialzation() { test("var a; a = 1;", "1;"); test("var a; if (a = 1) { alert(3); }", "if (1) { alert(3); }"); test("var a; switch (a = 1) {}", "switch(1) {}"); test("var a; function f(){ return a = 1; }", "function f(){ return 1; }"); test("function f(){ var a; return a = 1; }", "function f(){ return 1; }"); test("var a; with (a = 1) { alert(3); }", "with (1) { alert(3); }"); test("var a; b = (a = 1);", "b = 1;"); test("var a; while(a = 1) { alert(3); }", "while(1) { alert(3); }"); test("var a; for(;a = 1;) { alert(3); }", "for(;1;) { alert(3); }"); test("var a; do {} while(a = 1) { alert(3); }", "do {} while(1) { alert(3); }"); } public void testSingleReferenceAfterInitialzation() { test("var a; a = foo();a;", "foo();"); testSame("var a; if (a = foo()) { alert(3); } a;"); testSame("var a; switch (a = foo()) {} a;"); testSame("var a; function f(){ return a = foo(); } a;"); testSame("function f(){ var a; return a = foo(); a;}"); testSame("var a; with (a = foo()) { alert(3); } a;"); testSame("var a; b = (a = foo()); a;"); testSame("var a; while(a = foo()) { alert(3); } a;"); testSame("var a; for(;a = foo();) { alert(3); } a;"); testSame("var a; do {} while(a = foo()) { alert(3); } a;"); } public void testInsideIfBranch() { testSame("var a = foo(); if (1) { alert(a); }"); } public void testInsideAndConditional() { test("var a = foo(); a && alert(3);", "foo() && alert(3);"); } public void testInsideAndBranch() { testSame("var a = foo(); 1 && alert(a);"); } public void testInsideOrBranch() { testSame("var a = foo(); 1 || alert(a);"); } public void testInsideHookBranch() { testSame("var a = foo(); 1 ? alert(a) : alert(3)"); } public void testInsideHookConditional() { test("var a = foo(); a ? alert(1) : alert(3)", "foo() ? alert(1) : alert(3)"); } public void testInsideOrBranchInsideIfConditional() { testSame("var a = foo(); if (x || a) {}"); } public void testInsideOrBranchInsideIfConditionalWithConstant() { // We don't inline non-immutable constants into branches. testSame("var a = [false]; if (x || a) {}"); } public void testCrossFunctionsAsLeftLeaves() { // Ensures getNext() understands how to walk past a function leaf test( new String[] { "var x = function() {};", "", "function cow() {} var z = x;"}, new String[] { "", "", "function cow() {} var z = function() {};" }); test( new String[] { "var x = function() {};", "", "var cow = function() {}; var z = x;"}, new String[] { "", "", "var cow = function() {}; var z = function() {};" }); testSame( new String[] { "var x = a;", "", "(function() { a++; })(); var z = x;"}); test( new String[] { "var x = a;", "", "function cow() { a++; }; cow(); var z = x;"}, new String[] { "var x = a;", "", ";(function cow(){ a++; })(); var z = x;"}); testSame( new String[] { "var x = a;", "", "cow(); var z = x; function cow() { a++; };"}); } // Test movement of constant values public void testDoCrossFunction() { // We know foo() does not affect x because we require that x is only // referenced twice. test("var x = 1; foo(); var z = x;", "foo(); var z = 1;"); } public void testDoNotCrossReferencingFunction() { testSame( "var f = function() { var z = x; };" + "var x = 1;" + "f();" + "var z = x;" + "f();"); } // Test tricky declarations and references public void testChainedAssignment() { test("var a = 2, b = 2; var c = b;", "var a = 2; var c = 2;"); test("var a = 2, b = 2; var c = a;", "var b = 2; var c = 2;"); test("var a = b = 2; var f = 3; var c = a;", "var f = 3; var c = b = 2;"); testSame("var a = b = 2; var c = b;"); } public void testForIn() { testSame("for (var i in j) { var c = i; }"); testSame("var i = 0; for (i in j) ;"); testSame("var i = 0; for (i in j) { var c = i; }"); testSame("i = 0; for (var i in j) { var c = i; }"); testSame("var j = {'key':'value'}; for (var i in j) {print(i)};"); } // Test movement of values that have (may) side effects public void testDoCrossNewVariables() { test("var x = foo(); var z = x;", "var z = foo();"); } public void testDoNotCrossFunctionCalls() { testSame("var x = foo(); bar(); var z = x;"); } // Test movement of values that are complex but lack side effects public void testDoNotCrossAssignment() { testSame("var x = {}; var y = x.a; x.a = 1; var z = y;"); testSame("var a = this.id; foo(this.id = 3, a);"); } public void testDoNotCrossDelete() { testSame("var x = {}; var y = x.a; delete x.a; var z = y;"); } public void testDoNotCrossAssignmentPlus() { testSame("var a = b; b += 2; var c = a;"); } public void testDoNotCrossIncrement() { testSame("var a = b.c; b.c++; var d = a;"); } public void testDoNotCrossConstructor() { testSame("var a = b; new Foo(); var c = a;"); } public void testDoCrossVar() { // Assumes we do not rely on undefined variables (not technically correct!) test("var a = b; var b = 3; alert(a)", "alert(3);"); } public void testOverlappingInlines() { String source = "a = function(el, x, opt_y) { " + " var cur = bar(el); " + " opt_y = x.y; " + " x = x.x; " + " var dx = x - cur.x; " + " var dy = opt_y - cur.y;" + " foo(el, el.offsetLeft + dx, el.offsetTop + dy); " + "};"; String expected = "a = function(el, x, opt_y) { " + " var cur = bar(el); " + " opt_y = x.y; " + " x = x.x; " + " foo(el, el.offsetLeft + (x - cur.x)," + " el.offsetTop + (opt_y - cur.y)); " + "};"; test(source, expected); } public void testOverlappingInlineFunctions() { String source = "a = function() { " + " var b = function(args) {var n;}; " + " var c = function(args) {}; " + " d(b,c); " + "};"; String expected = "a = function() { " + " d(function(args){var n;}, function(args){}); " + "};"; test(source, expected); } public void testInlineIntoLoops() { test("var x = true; while (true) alert(x);", "while (true) alert(true);"); test("var x = true; while (true) for (var i in {}) alert(x);", "while (true) for (var i in {}) alert(true);"); testSame("var x = [true]; while (true) alert(x);"); } public void testInlineIntoFunction() { test("var x = false; var f = function() { alert(x); };", "var f = function() { alert(false); };"); testSame("var x = [false]; var f = function() { alert(x); };"); } public void testNoInlineIntoNamedFunction() { testSame("f(); var x = false; function f() { alert(x); };"); } public void testInlineIntoNestedNonHoistedNamedFunctions() { test("f(); var x = false; if (false) function f() { alert(x); };", "f(); if (false) function f() { alert(false); };"); } public void testNoInlineIntoNestedNamedFunctions() { testSame("f(); var x = false; function f() { if (false) { alert(x); } };"); } public void testNoInlineMutatedVariable() { testSame("var x = false; if (true) { var y = x; x = true; }"); } public void testInlineImmutableMultipleTimes() { test("var x = null; var y = x, z = x;", "var y = null, z = null;"); test("var x = 3; var y = x, z = x;", "var y = 3, z = 3;"); } public void testNoInlineStringMultipleTimesIfNotWorthwhile() { testSame("var x = 'abcdefghijklmnopqrstuvwxyz'; var y = x, z = x;"); } public void testInlineStringMultipleTimesWhenAliasingAllStrings() { inlineAllStrings = true; test("var x = 'abcdefghijklmnopqrstuvwxyz'; var y = x, z = x;", "var y = 'abcdefghijklmnopqrstuvwxyz', " + " z = 'abcdefghijklmnopqrstuvwxyz';"); } public void testNoInlineBackwards() { testSame("var y = x; var x = null;"); } public void testNoInlineOutOfBranch() { testSame("if (true) var x = null; var y = x;"); } public void testInterferingInlines() { test("var a = 3; var f = function() { var x = a; alert(x); };", "var f = function() { alert(3); };"); } public void testInlineIntoTryCatch() { test("var a = true; " + "try { var b = a; } " + "catch (e) { var c = a + b; var d = true; } " + "finally { var f = a + b + c + d; }", "try { var b = true; } " + "catch (e) { var c = true + b; var d = true; } " + "finally { var f = true + b + c + d; }"); } // Make sure that we still inline constants that are not provably // written before they're read. public void testInlineConstants() { test("function foo() { return XXX; } var XXX = true;", "function foo() { return true; }"); } public void testInlineStringWhenWorthwhile() { test("var x = 'a'; foo(x, x, x);", "foo('a', 'a', 'a');"); } public void testInlineConstantAlias() { test("var XXX = new Foo(); q(XXX); var YYY = XXX; bar(YYY)", "var XXX = new Foo(); q(XXX); bar(XXX)"); } public void testInlineConstantAliasWithAnnotation() { test("/** @const */ var xxx = new Foo(); q(xxx); var YYY = xxx; bar(YYY)", "/** @const */ var xxx = new Foo(); q(xxx); bar(xxx)"); } public void testInlineConstantAliasWithNonConstant() { test("var XXX = new Foo(); q(XXX); var y = XXX; bar(y); baz(y)", "var XXX = new Foo(); q(XXX); bar(XXX); baz(XXX)"); } public void testCascadingInlines() { test("var XXX = 4; " + "function f() { var YYY = XXX; bar(YYY); baz(YYY); }", "function f() { bar(4); baz(4); }"); } public void testNoInlineGetpropIntoCall() { test("var a = b; a();", "b();"); test("var a = b.c; f(a);", "f(b.c);"); testSame("var a = b.c; a();"); } public void testInlineFunctionDeclaration() { test("var f = function () {}; var a = f;", "var a = function () {};"); test("var f = function () {}; foo(); var a = f;", "foo(); var a = function () {};"); test("var f = function () {}; foo(f);", "foo(function () {});"); testSame("var f = function () {}; function g() {var a = f;}"); testSame("var f = function () {}; function g() {h(f);}"); } public void test2388531() { testSame("var f = function () {};" + "var g = function () {};" + "goog.inherits(f, g);"); testSame("var f = function () {};" + "var g = function () {};" + "goog$inherits(f, g);"); } public void testRecursiveFunction1() { testSame("var x = 0; (function x() { return x ? x() : 3; })();"); } public void testRecursiveFunction2() { testSame("function y() { return y(); }"); } public void testUnreferencedBleedingFunction() { testSame("var x = function y() {}"); } public void testReferencedBleedingFunction() { testSame("var x = function y() { return y(); }"); } public void testInlineAliases1() { test("var x = this.foo(); this.bar(); var y = x; this.baz(y);", "var x = this.foo(); this.bar(); this.baz(x);"); } public void testInlineAliases1b() { test("var x = this.foo(); this.bar(); var y; y = x; this.baz(y);", "var x = this.foo(); this.bar(); x; this.baz(x);"); } public void testInlineAliases1c() { test("var x; x = this.foo(); this.bar(); var y = x; this.baz(y);", "var x; x = this.foo(); this.bar(); this.baz(x);"); } public void testInlineAliases1d() { test("var x; x = this.foo(); this.bar(); var y; y = x; this.baz(y);", "var x; x = this.foo(); this.bar(); x; this.baz(x);"); } public void testInlineAliases2() { test("var x = this.foo(); this.bar(); " + "function f() { var y = x; this.baz(y); }", "var x = this.foo(); this.bar(); function f() { this.baz(x); }"); } public void testInlineAliases2b() { test("var x = this.foo(); this.bar(); " + "function f() { var y; y = x; this.baz(y); }", "var x = this.foo(); this.bar(); function f() { this.baz(x); }"); } public void testInlineAliases2c() { test("var x; x = this.foo(); this.bar(); " + "function f() { var y = x; this.baz(y); }", "var x; x = this.foo(); this.bar(); function f() { this.baz(x); }"); } public void testInlineAliases2d() { test("var x; x = this.foo(); this.bar(); " + "function f() { var y; y = x; this.baz(y); }", "var x; x = this.foo(); this.bar(); function f() { this.baz(x); }"); } public void testInlineAliasesInLoop() { test( "function f() { " + " var x = extern();" + " for (var i = 0; i < 5; i++) {" + " (function() {" + " var y = x; window.setTimeout(function() { extern(y); }, 0);" + " })();" + " }" + "}", "function f() { " + " var x = extern();" + " for (var i = 0; i < 5; i++) {" + " (function() {" + " window.setTimeout(function() { extern(x); }, 0);" + " })();" + " }" + "}"); } public void testNoInlineAliasesInLoop() { testSame( "function f() { " + " for (var i = 0; i < 5; i++) {" + " var x = extern();" + " (function() {" + " var y = x; window.setTimeout(function() { extern(y); }, 0);" + " })();" + " }" + "}"); } public void testNoInlineAliases1() { testSame( "var x = this.foo(); this.bar(); var y = x; x = 3; this.baz(y);"); } public void testNoInlineAliases1b() { testSame( "var x = this.foo(); this.bar(); var y; y = x; x = 3; this.baz(y);"); } public void testNoInlineAliases2() { testSame( "var x = this.foo(); this.bar(); var y = x; y = 3; this.baz(y); "); } public void testNoInlineAliases2b() { testSame( "var x = this.foo(); this.bar(); var y; y = x; y = 3; this.baz(y); "); } public void testNoInlineAliases3() { testSame( "var x = this.foo(); this.bar(); " + "function f() { var y = x; g(); this.baz(y); } " + "function g() { x = 3; }"); } public void testNoInlineAliases3b() { testSame( "var x = this.foo(); this.bar(); " + "function f() { var y; y = x; g(); this.baz(y); } " + "function g() { x = 3; }"); } public void testNoInlineAliases4() { testSame( "var x = this.foo(); this.bar(); " + "function f() { var y = x; y = 3; this.baz(y); }"); } public void testNoInlineAliases4b() { testSame( "var x = this.foo(); this.bar(); " + "function f() { var y; y = x; y = 3; this.baz(y); }"); } public void testNoInlineAliases5() { testSame( "var x = this.foo(); this.bar(); var y = x; this.bing();" + "this.baz(y); x = 3;"); } public void testNoInlineAliases5b() { testSame( "var x = this.foo(); this.bar(); var y; y = x; this.bing();" + "this.baz(y); x = 3;"); } public void testNoInlineAliases6() { testSame( "var x = this.foo(); this.bar(); var y = x; this.bing();" + "this.baz(y); y = 3;"); } public void testNoInlineAliases6b() { testSame( "var x = this.foo(); this.bar(); var y; y = x; this.bing();" + "this.baz(y); y = 3;"); } public void testNoInlineAliases7() { testSame( "var x = this.foo(); this.bar(); " + "function f() { var y = x; this.bing(); this.baz(y); x = 3; }"); } public void testNoInlineAliases7b() { testSame( "var x = this.foo(); this.bar(); " + "function f() { var y; y = x; this.bing(); this.baz(y); x = 3; }"); } public void testNoInlineAliases8() { testSame( "var x = this.foo(); this.bar(); " + "function f() { var y = x; this.baz(y); y = 3; }"); } public void testNoInlineAliases8b() { testSame( "var x = this.foo(); this.bar(); " + "function f() { var y; y = x; this.baz(y); y = 3; }"); } public void testSideEffectOrder() { // z can not be changed by the call to y, so x can be inlined. String EXTERNS = "var z; function f(){}"; test(EXTERNS, "var x = f(y.a, y); z = x;", "z = f(y.a, y);", null, null); // z.b can be changed by the call to y, so x can not be inlined. testSame(EXTERNS, "var x = f(y.a, y); z.b = x;", null, null); } public void testInlineParameterAlias1() { test( "function f(x) {" + " var y = x;" + " g();" + " y;y;" + "}", "function f(x) {" + " g();" + " x;x;" + "}" ); } public void testInlineParameterAlias2() { test( "function f(x) {" + " var y; y = x;" + " g();" + " y;y;" + "}", "function f(x) {" + " x;" + " g();" + " x;x;" + "}" ); } public void testInlineFunctionAlias1a() { test( "function f(x) {}" + "var y = f;" + "g();" + "y();y();", "var y = function f(x) {};" + "g();" + "y();y();" ); } public void testInlineFunctionAlias1b() { test( "function f(x) {};" + "f;var y = f;" + "g();" + "y();y();", "function f(x) {};" + "f;g();" + "f();f();" ); } public void testInlineFunctionAlias2a() { test( "function f(x) {}" + "var y; y = f;" + "g();" + "y();y();", "var y; y = function f(x) {};" + "g();" + "y();y();" ); } public void testInlineFunctionAlias2b() { test( "function f(x) {};" + "f; var y; y = f;" + "g();" + "y();y();", "function f(x) {};" + "f; f;" + "g();" + "f();f();" ); } public void testInlineCatchAlias1() { test( "try {" + "} catch (e) {" + " var y = e;" + " g();" + " y;y;" + "}", "try {" + "} catch (e) {" + " g();" + " e;e;" + "}" ); } public void testInlineCatchAlias2() { test( "try {" + "} catch (e) {" + " var y; y = e;" + " g();" + " y;y;" + "}", "try {" + "} catch (e) {" + " e;" + " g();" + " e;e;" + "}" ); } public void testLocalsOnly1() { inlineLocalsOnly = true; test( "var x=1; x; function f() {var x = 1; x;}", "var x=1; x; function f() {1;}"); } public void testLocalsOnly2() { inlineLocalsOnly = true; test( "/** @const */\n" + "var X=1; X;\n" + "function f() {\n" + " /** @const */\n" + " var X = 1; X;\n" + "}", "var X=1; X; function f() {1;}"); } public void testInlineUndefined1() { test("var x; x;", "void 0;"); } public void testInlineUndefined2() { testSame("var x; x++;"); } public void testInlineUndefined3() { testSame("var x; var x;"); } public void testInlineUndefined4() { test("var x; x; x;", "void 0; void 0;"); } public void testInlineUndefined5() { test("var x; for(x in a) {}", "var x; for(x in a) {}"); } public void testIssue90() { test("var x; x && alert(1)", "void 0 && alert(1)"); } public void testRenamePropertyFunction() { testSame("var JSCompiler_renameProperty; " + "JSCompiler_renameProperty('foo')"); } public void testThisAlias() { test("function f() { var a = this; a.y(); a.z(); }", "function f() { this.y(); this.z(); }"); } public void testThisEscapedAlias() { testSame( "function f() { var a = this; var g = function() { a.y(); }; a.z(); }"); } public void testInlineNamedFunction() { test("function f() {} f();", "(function f(){})()"); } public void testIssue378ModifiedArguments1() { testSame( "function g(callback) {\n" + " var f = callback;\n" + " arguments[0] = this;\n" + " f.apply(this, arguments);\n" + "}"); } public void testIssue378ModifiedArguments2() { testSame( "function g(callback) {\n" + " /** @const */\n" + " var f = callback;\n" + " arguments[0] = this;\n" + " f.apply(this, arguments);\n" + "}"); } public void testIssue378EscapedArguments1() { testSame( "function g(callback) {\n" + " var f = callback;\n" + " h(arguments,this);\n" + " f.apply(this, arguments);\n" + "}\n" + "function h(a,b) {\n" + " a[0] = b;" + "}"); } public void testIssue378EscapedArguments2() { testSame( "function g(callback) {\n" + " /** @const */\n" + " var f = callback;\n" + " h(arguments,this);\n" + " f.apply(this);\n" + "}\n" + "function h(a,b) {\n" + " a[0] = b;" + "}"); } public void testIssue378EscapedArguments3() { test( "function g(callback) {\n" + " var f = callback;\n" + " f.apply(this, arguments);\n" + "}\n", "function g(callback) {\n" + " callback.apply(this, arguments);\n" + "}\n"); } public void testIssue378EscapedArguments4() { testSame( "function g(callback) {\n" + " var f = callback;\n" + " h(arguments[0],this);\n" + " f.apply(this, arguments);\n" + "}\n" + "function h(a,b) {\n" + " a[0] = b;" + "}"); } public void testIssue378ArgumentsRead1() { test( "function g(callback) {\n" + " var f = callback;\n" + " var g = arguments[0];\n" + " f.apply(this, arguments);\n" + "}", "function g(callback) {\n" + " var g = arguments[0];\n" + " callback.apply(this, arguments);\n" + "}"); } public void testIssue378ArgumentsRead2() { test( "function g(callback) {\n" + " var f = callback;\n" + " h(arguments[0],this);\n" + " f.apply(this, arguments[0]);\n" + "}\n" + "function h(a,b) {\n" + " a[0] = b;" + "}", "function g(callback) {\n" + " h(arguments[0],this);\n" + " callback.apply(this, arguments[0]);\n" + "}\n" + "function h(a,b) {\n" + " a[0] = b;" + "}"); } public void testArgumentsModifiedInOuterFunction() { test( "function g(callback) {\n" + " var f = callback;\n" + " arguments[0] = this;\n" + " f.apply(this, arguments);\n" + " function inner(callback) {" + " var x = callback;\n" + " x.apply(this);\n" + " }" + "}", "function g(callback) {\n" + " var f = callback;\n" + " arguments[0] = this;\n" + " f.apply(this, arguments);\n" + " function inner(callback) {" + " callback.apply(this);\n" + " }" + "}"); } public void testArgumentsModifiedInInnerFunction() { test( "function g(callback) {\n" + " var f = callback;\n" + " f.apply(this, arguments);\n" + " function inner(callback) {" + " var x = callback;\n" + " arguments[0] = this;\n" + " x.apply(this);\n" + " }" + "}", "function g(callback) {\n" + " callback.apply(this, arguments);\n" + " function inner(callback) {" + " var x = callback;\n" + " arguments[0] = this;\n" + " x.apply(this);\n" + " }" + "}"); } public void testNoInlineRedeclaredExterns() { String externs = "var test = 1;"; String code = "/** @suppress {duplicate} */ var test = 2;alert(test);"; test(externs, code, code, null, null); } public void testBug6598844() { testSame( "function F() { this.a = 0; }" + "F.prototype.inc = function() { this.a++; return 10; };" + "F.prototype.bar = function() { var val = inc(); this.a += val; };"); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.ImmutableList; import com.google.javascript.rhino.Node; import java.io.StringReader; import java.util.List; /** * Tests for {@link InstrumentFunctions} * */ public class InstrumentFunctionsTest extends CompilerTestCase { private String instrumentationPb; public InstrumentFunctionsTest() { this.instrumentationPb = null; } @Override protected void setUp() { super.enableLineNumberCheck(false); this.instrumentationPb = null; } @Override protected CompilerPass getProcessor(Compiler compiler) { return new NameAndInstrumentFunctions(compiler); } @Override protected int getNumRepetitions() { // This pass is not idempotent. return 1; } public void testInstrument() { final String kPreamble = "var $$toRemoveDefinition1, $$notToRemove;\n" + "var $$toRemoveDefinition2, $$toRemoveDefinition3;\n"; // build instrumentation template and init code strings for use in // tests below. List<String> initCodeList = ImmutableList.of( "var $$Table = [];", "function $$TestDefine(id) {", " $$Table[id] = 0;", "};", "function $$TestInstrument(id) {", " $$Table[id]++;", "};"); StringBuilder initCodeBuilder = new StringBuilder(); StringBuilder pbBuilder = new StringBuilder(); for (String line : initCodeList) { initCodeBuilder.append(line).append("\n"); pbBuilder.append("init: \"").append(line).append("\"\n"); } pbBuilder.append("report_call: \"$$testInstrument\"") .append("report_defined: \"$$testDefine\"") .append("declaration_to_remove: \"$$toRemoveDefinition1\"") .append("declaration_to_remove: \"$$toRemoveDefinition2\"") .append("declaration_to_remove: \"$$toRemoveDefinition3\""); final String initCode = initCodeBuilder.toString(); this.instrumentationPb = pbBuilder.toString(); // Test basic instrumentation test("function a(){b}", initCode + "$$testDefine(0);" + "function a(){$$testInstrument(0);b}"); // Test declaration_to_remove test(kPreamble + "function a(){b}", initCode + "$$testDefine(0);" + "var $$notToRemove;" + "function a(){$$testInstrument(0);b}"); // Test object literal declarations test(kPreamble + "var a = { b: function(){c} }", initCode + "var $$notToRemove;" + "$$testDefine(0);" + "var a = { b: function(){$$testInstrument(0);c} }"); // Test multiple object literal declarations test(kPreamble + "var a = { b: function(){c}, d: function(){e} }", initCode + "var $$notToRemove;" + "$$testDefine(0);" + "$$testDefine(1);" + "var a={b:function(){$$testInstrument(0);c}," + "d:function(){$$testInstrument(1);e}}"); // Test recursive object literal declarations test(kPreamble + "var a = { b: { f: function(){c} }, d: function(){e} }", initCode + "var $$notToRemove;" + "$$testDefine(0);" + "$$testDefine(1);" + "var a={b:{f:function(){$$testInstrument(0);c}}," + "d:function(){$$testInstrument(1);e}}"); } public void testEmpty() { this.instrumentationPb = ""; test("function a(){b}", "function a(){b}"); } public void testAppNameSetter() { this.instrumentationPb = "app_name_setter: \"setAppName\""; test("function a(){b}", "setAppName(\"testfile.js\");function a(){b}"); } public void testInit() { this.instrumentationPb = "init: \"var foo = 0;\"\n" + "init: \"function f(){g();}\"\n"; test("function a(){b}", "var foo = 0;function f(){g()}function a(){b}"); } public void testDeclare() { this.instrumentationPb = "report_defined: \"$$testDefine\""; test("function a(){b}", "$$testDefine(0);function a(){b}"); } public void testCall() { this.instrumentationPb = "report_call: \"$$testCall\""; test("function a(){b}", "function a(){$$testCall(0);b}"); } public void testNested() { this.instrumentationPb = "report_call: \"$$testCall\"\n" + "report_defined: \"$$testDefine\""; test("function a(){ function b(){}}", "$$testDefine(1);$$testDefine(0);" + "function a(){$$testCall(1);function b(){$$testCall(0)}}"); } public void testExitPaths() { this.instrumentationPb = "report_exit: \"$$testExit\""; test("function a(){return}", "function a(){return $$testExit(0)}"); test("function b(){return 5}", "function b(){return $$testExit(0, 5)}"); test("function a(){if(2 != 3){return}else{return 5}}", "function a(){if(2!=3){return $$testExit(0)}" + "else{return $$testExit(0,5)}}"); test("function a(){if(2 != 3){return}else{return 5}}b()", "function a(){if(2!=3){return $$testExit(0)}" + "else{return $$testExit(0,5)}}b()"); test("function a(){if(2 != 3){return}else{return 5}}", "function a(){if(2!=3){return $$testExit(0)}" + "else{return $$testExit(0,5)}}"); } public void testExitNoReturn() { this.instrumentationPb = "report_exit: \"$$testExit\""; test("function a(){}", "function a(){$$testExit(0);}"); test("function a(){b()}", "function a(){b();$$testExit(0);}"); } public void testPartialExitPaths() { this.instrumentationPb = "report_exit: \"$$testExit\""; test("function a(){if (2 != 3) {return}}", "function a(){if (2 != 3){return $$testExit(0)}$$testExit(0)}"); } public void testExitTry() { this.instrumentationPb = "report_exit: \"$$testExit\""; test("function a(){try{return}catch(err){}}", "function a(){try{return $$testExit(0)}catch(err){}$$testExit(0)}"); test("function a(){try{}catch(err){return}}", "function a(){try{}catch(err){return $$testExit(0)}$$testExit(0)}"); test("function a(){try{return}finally{}}", "function a(){try{return $$testExit(0)}finally{}$$testExit(0)}"); test("function a(){try{return}catch(err){}finally{}}", "function a(){try{return $$testExit(0)}catch(err){}finally{}" + "$$testExit(0)}"); test("function a(){try{return 1}catch(err){return 2}}", "function a(){try{return $$testExit(0, 1)}" + "catch(err){return $$testExit(0,2)}}"); test("function a(){try{return 1}catch(err){return 2}finally{}}", "function a(){try{return $$testExit(0, 1)}" + "catch(err){return $$testExit(0,2)}" + "finally{}$$testExit(0)}"); test("function a(){try{return 1}catch(err){return 2}finally{return}}", "function a(){try{return $$testExit(0, 1)}" + "catch(err){return $$testExit(0,2)}finally{return $$testExit(0)}}"); test("function a(){try{}catch(err){}finally{return}}", "function a(){try{}catch(err){}finally{return $$testExit(0)}}"); } public void testNestedExit() { this.instrumentationPb = "report_exit: \"$$testExit\"\n" + "report_defined: \"$$testDefine\""; test("function a(){ return function(){ return c;}}", "$$testDefine(1);function a(){$$testDefine(0);" + "return $$testExit(1, function(){return $$testExit(0, c);});}"); } public void testProtobuffParseFail() { this.instrumentationPb = "not an ascii pb\n"; test("function a(){b}", "", RhinoErrorReporter.PARSE_ERROR); } public void testInitJsParseFail() { this.instrumentationPb = "init: \"= assignWithNoLhs();\""; test("function a(){b}", "", RhinoErrorReporter.PARSE_ERROR); } private class NameAndInstrumentFunctions implements CompilerPass { private final Compiler compiler; NameAndInstrumentFunctions(Compiler compiler) { this.compiler = compiler; } @Override public void process(Node externs, Node root) { FunctionNames functionNames = new FunctionNames(compiler); functionNames.process(externs, root); InstrumentFunctions instrumentation = new InstrumentFunctions(compiler, functionNames, "test init code", "testfile.js", new StringReader(instrumentationPb)); instrumentation.process(externs, root); } } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.ArrayListMultimap; import com.google.common.collect.ImmutableList; import com.google.common.collect.ImmutableMap; import com.google.common.collect.Sets; import com.google.javascript.jscomp.CompilerOptions.LanguageMode; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; /** * Tests for {@link PassFactory}. * * @author nicksantos@google.com (Nick Santos) */ public class IntegrationTest extends IntegrationTestCase { private static final String CLOSURE_BOILERPLATE = "/** @define {boolean} */ var COMPILED = false; var goog = {};" + "goog.exportSymbol = function() {};"; private static final String CLOSURE_COMPILED = "var COMPILED = true; var goog$exportSymbol = function() {};"; public void testConstructorCycle() { CompilerOptions options = createCompilerOptions(); options.checkTypes = true; test(options, "/** @return {function()} */ var AsyncTestCase = function() {};\n" + "/**\n" + " * @constructor\n" + " */ Foo = /** @type {function(new:Foo)} */ (AyncTestCase());", RhinoErrorReporter.PARSE_ERROR); } public void testBug1949424() { CompilerOptions options = createCompilerOptions(); options.collapseProperties = true; options.closurePass = true; test(options, CLOSURE_BOILERPLATE + "goog.provide('FOO'); FOO.bar = 3;", CLOSURE_COMPILED + "var FOO$bar = 3;"); } public void testBug1949424_v2() { CompilerOptions options = createCompilerOptions(); options.collapseProperties = true; options.closurePass = true; test(options, CLOSURE_BOILERPLATE + "goog.provide('FOO.BAR'); FOO.BAR = 3;", CLOSURE_COMPILED + "var FOO$BAR = 3;"); } public void testBug1956277() { CompilerOptions options = createCompilerOptions(); options.collapseProperties = true; options.inlineVariables = true; test(options, "var CONST = {}; CONST.bar = null;" + "function f(url) { CONST.bar = url; }", "var CONST$bar = null; function f(url) { CONST$bar = url; }"); } public void testBug1962380() { CompilerOptions options = createCompilerOptions(); options.collapseProperties = true; options.inlineVariables = true; options.generateExports = true; test(options, CLOSURE_BOILERPLATE + "/** @export */ goog.CONSTANT = 1;" + "var x = goog.CONSTANT;", "(function() {})('goog.CONSTANT', 1);" + "var x = 1;"); } public void testBug2410122() { CompilerOptions options = createCompilerOptions(); options.generateExports = true; options.closurePass = true; test(options, "var goog = {};" + "function F() {}" + "/** @export */ function G() { goog.base(this); } " + "goog.inherits(G, F);", "var goog = {};" + "function F() {}" + "function G() { F.call(this); } " + "goog.inherits(G, F); goog.exportSymbol('G', G);"); } public void testIssue90() { CompilerOptions options = createCompilerOptions(); options.foldConstants = true; options.inlineVariables = true; options.removeDeadCode = true; test(options, "var x; x && alert(1);", ""); } public void testClosurePassOff() { CompilerOptions options = createCompilerOptions(); options.closurePass = false; testSame( options, "var goog = {}; goog.require = function(x) {}; goog.require('foo');"); testSame( options, "var goog = {}; goog.getCssName = function(x) {};" + "goog.getCssName('foo');"); } public void testClosurePassOn() { CompilerOptions options = createCompilerOptions(); options.closurePass = true; test( options, "var goog = {}; goog.require = function(x) {}; goog.require('foo');", ProcessClosurePrimitives.MISSING_PROVIDE_ERROR); test( options, "/** @define {boolean} */ var COMPILED = false;" + "var goog = {}; goog.getCssName = function(x) {};" + "goog.getCssName('foo');", "var COMPILED = true;" + "var goog = {}; goog.getCssName = function(x) {};" + "'foo';"); } public void testCssNameCheck() { CompilerOptions options = createCompilerOptions(); options.closurePass = true; options.checkMissingGetCssNameLevel = CheckLevel.ERROR; options.checkMissingGetCssNameBlacklist = "foo"; test(options, "var x = 'foo';", CheckMissingGetCssName.MISSING_GETCSSNAME); } public void testBug2592659() { CompilerOptions options = createCompilerOptions(); options.closurePass = true; options.checkTypes = true; options.checkMissingGetCssNameLevel = CheckLevel.WARNING; options.checkMissingGetCssNameBlacklist = "foo"; test(options, "var goog = {};\n" + "/**\n" + " * @param {string} className\n" + " * @param {string=} opt_modifier\n" + " * @return {string}\n" + "*/\n" + "goog.getCssName = function(className, opt_modifier) {}\n" + "var x = goog.getCssName(123, 'a');", TypeValidator.TYPE_MISMATCH_WARNING); } public void testTypedefBeforeOwner1() { CompilerOptions options = createCompilerOptions(); options.closurePass = true; test(options, "goog.provide('foo.Bar.Type');\n" + "goog.provide('foo.Bar');\n" + "/** @typedef {number} */ foo.Bar.Type;\n" + "foo.Bar = function() {};", "var foo = {}; foo.Bar.Type; foo.Bar = function() {};"); } public void testTypedefBeforeOwner2() { CompilerOptions options = createCompilerOptions(); options.closurePass = true; options.collapseProperties = true; test(options, "goog.provide('foo.Bar.Type');\n" + "goog.provide('foo.Bar');\n" + "/** @typedef {number} */ foo.Bar.Type;\n" + "foo.Bar = function() {};", "var foo$Bar$Type; var foo$Bar = function() {};"); } public void testExportedNames() { CompilerOptions options = createCompilerOptions(); options.closurePass = true; options.variableRenaming = VariableRenamingPolicy.ALL; test(options, "/** @define {boolean} */ var COMPILED = false;" + "var goog = {}; goog.exportSymbol('b', goog);", "var a = true; var c = {}; c.exportSymbol('b', c);"); test(options, "/** @define {boolean} */ var COMPILED = false;" + "var goog = {}; goog.exportSymbol('a', goog);", "var b = true; var c = {}; c.exportSymbol('a', c);"); } public void testCheckGlobalThisOn() { CompilerOptions options = createCompilerOptions(); options.checkSuspiciousCode = true; options.checkGlobalThisLevel = CheckLevel.ERROR; test(options, "function f() { this.y = 3; }", CheckGlobalThis.GLOBAL_THIS); } public void testSusiciousCodeOff() { CompilerOptions options = createCompilerOptions(); options.checkSuspiciousCode = false; options.checkGlobalThisLevel = CheckLevel.ERROR; test(options, "function f() { this.y = 3; }", CheckGlobalThis.GLOBAL_THIS); } public void testCheckGlobalThisOff() { CompilerOptions options = createCompilerOptions(); options.checkSuspiciousCode = true; options.checkGlobalThisLevel = CheckLevel.OFF; testSame(options, "function f() { this.y = 3; }"); } public void testCheckRequiresAndCheckProvidesOff() { testSame(createCompilerOptions(), new String[] { "/** @constructor */ function Foo() {}", "new Foo();" }); } public void testCheckRequiresOn() { CompilerOptions options = createCompilerOptions(); options.checkRequires = CheckLevel.ERROR; test(options, new String[] { "/** @constructor */ function Foo() {}", "new Foo();" }, CheckRequiresForConstructors.MISSING_REQUIRE_WARNING); } public void testCheckProvidesOn() { CompilerOptions options = createCompilerOptions(); options.checkProvides = CheckLevel.ERROR; test(options, new String[] { "/** @constructor */ function Foo() {}", "new Foo();" }, CheckProvides.MISSING_PROVIDE_WARNING); } public void testGenerateExportsOff() { testSame(createCompilerOptions(), "/** @export */ function f() {}"); } public void testGenerateExportsOn() { CompilerOptions options = createCompilerOptions(); options.generateExports = true; test(options, "/** @export */ function f() {}", "/** @export */ function f() {} goog.exportSymbol('f', f);"); } public void testExportTestFunctionsOff() { testSame(createCompilerOptions(), "function testFoo() {}"); } public void testExportTestFunctionsOn() { CompilerOptions options = createCompilerOptions(); options.exportTestFunctions = true; test(options, "function testFoo() {}", "/** @export */ function testFoo() {}" + "goog.exportSymbol('testFoo', testFoo);"); } public void testExpose() { CompilerOptions options = createCompilerOptions(); CompilationLevel.ADVANCED_OPTIMIZATIONS .setOptionsForCompilationLevel(options); test(options, "var x = {eeny: 1, /** @expose */ meeny: 2};" + "/** @constructor */ var Foo = function() {};" + "/** @expose */ Foo.prototype.miny = 3;" + "Foo.prototype.moe = 4;" + "function moe(a, b) { return a.meeny + b.miny; }" + "window['x'] = x;" + "window['Foo'] = Foo;" + "window['moe'] = moe;", "function a(){}" + "a.prototype.miny=3;" + "window.x={a:1,meeny:2};" + "window.Foo=a;" + "window.moe=function(b,c){" + " return b.meeny+c.miny" + "}"); } public void testCheckSymbolsOff() { CompilerOptions options = createCompilerOptions(); testSame(options, "x = 3;"); } public void testCheckSymbolsOn() { CompilerOptions options = createCompilerOptions(); options.checkSymbols = true; test(options, "x = 3;", VarCheck.UNDEFINED_VAR_ERROR); } public void testCheckReferencesOff() { CompilerOptions options = createCompilerOptions(); testSame(options, "x = 3; var x = 5;"); } public void testCheckReferencesOn() { CompilerOptions options = createCompilerOptions(); options.aggressiveVarCheck = CheckLevel.ERROR; test(options, "x = 3; var x = 5;", VariableReferenceCheck.UNDECLARED_REFERENCE); } public void testInferTypes() { CompilerOptions options = createCompilerOptions(); options.inferTypes = true; options.checkTypes = false; options.closurePass = true; test(options, CLOSURE_BOILERPLATE + "goog.provide('Foo'); /** @enum */ Foo = {a: 3};", TypeCheck.ENUM_NOT_CONSTANT); assertTrue(lastCompiler.getErrorManager().getTypedPercent() == 0); // This does not generate a warning. test(options, "/** @type {number} */ var n = window.name;", "var n = window.name;"); assertTrue(lastCompiler.getErrorManager().getTypedPercent() == 0); } public void testTypeCheckAndInference() { CompilerOptions options = createCompilerOptions(); options.checkTypes = true; test(options, "/** @type {number} */ var n = window.name;", TypeValidator.TYPE_MISMATCH_WARNING); assertTrue(lastCompiler.getErrorManager().getTypedPercent() > 0); } public void testTypeNameParser() { CompilerOptions options = createCompilerOptions(); options.checkTypes = true; test(options, "/** @type {n} */ var n = window.name;", RhinoErrorReporter.TYPE_PARSE_ERROR); } // This tests that the TypedScopeCreator is memoized so that it only creates a // Scope object once for each scope. If, when type inference requests a scope, // it creates a new one, then multiple JSType objects end up getting created // for the same local type, and ambiguate will rename the last statement to // o.a(o.a, o.a), which is bad. public void testMemoizedTypedScopeCreator() { CompilerOptions options = createCompilerOptions(); options.checkTypes = true; options.ambiguateProperties = true; options.propertyRenaming = PropertyRenamingPolicy.ALL_UNQUOTED; test(options, "function someTest() {\n" + " /** @constructor */\n" + " function Foo() { this.instProp = 3; }\n" + " Foo.prototype.protoProp = function(a, b) {};\n" + " /** @constructor\n @extends Foo */\n" + " function Bar() {}\n" + " goog.inherits(Bar, Foo);\n" + " var o = new Bar();\n" + " o.protoProp(o.protoProp, o.instProp);\n" + "}", "function someTest() {\n" + " function Foo() { this.b = 3; }\n" + " function Bar() {}\n" + " Foo.prototype.a = function(a, b) {};\n" + " goog.c(Bar, Foo);\n" + " var o = new Bar();\n" + " o.a(o.a, o.b);\n" + "}"); } public void testCheckTypes() { CompilerOptions options = createCompilerOptions(); options.checkTypes = true; test(options, "var x = x || {}; x.f = function() {}; x.f(3);", TypeCheck.WRONG_ARGUMENT_COUNT); } public void testReplaceCssNames() { CompilerOptions options = createCompilerOptions(); options.closurePass = true; options.gatherCssNames = true; test(options, "/** @define {boolean} */\n" + "var COMPILED = false;\n" + "goog.setCssNameMapping({'foo':'bar'});\n" + "function getCss() {\n" + " return goog.getCssName('foo');\n" + "}", "var COMPILED = true;\n" + "function getCss() {\n" + " return \"bar\";" + "}"); assertEquals( ImmutableMap.of("foo", new Integer(1)), lastCompiler.getPassConfig().getIntermediateState().cssNames); } public void testRemoveClosureAsserts() { CompilerOptions options = createCompilerOptions(); options.closurePass = true; testSame(options, "var goog = {};" + "goog.asserts.assert(goog);"); options.removeClosureAsserts = true; test(options, "var goog = {};" + "goog.asserts.assert(goog);", "var goog = {};"); } public void testDeprecation() { String code = "/** @deprecated */ function f() { } function g() { f(); }"; CompilerOptions options = createCompilerOptions(); testSame(options, code); options.setWarningLevel(DiagnosticGroups.DEPRECATED, CheckLevel.ERROR); testSame(options, code); options.checkTypes = true; test(options, code, CheckAccessControls.DEPRECATED_NAME); } public void testVisibility() { String[] code = { "/** @private */ function f() { }", "function g() { f(); }" }; CompilerOptions options = createCompilerOptions(); testSame(options, code); options.setWarningLevel(DiagnosticGroups.VISIBILITY, CheckLevel.ERROR); testSame(options, code); options.checkTypes = true; test(options, code, CheckAccessControls.BAD_PRIVATE_GLOBAL_ACCESS); } public void testUnreachableCode() { String code = "function f() { return \n 3; }"; CompilerOptions options = createCompilerOptions(); testSame(options, code); options.checkUnreachableCode = CheckLevel.ERROR; test(options, code, CheckUnreachableCode.UNREACHABLE_CODE); } public void testMissingReturn() { String code = "/** @return {number} */ function f() { if (f) { return 3; } }"; CompilerOptions options = createCompilerOptions(); testSame(options, code); options.checkMissingReturn = CheckLevel.ERROR; testSame(options, code); options.checkTypes = true; test(options, code, CheckMissingReturn.MISSING_RETURN_STATEMENT); } public void testIdGenerators() { String code = "function f() {} f('id');"; CompilerOptions options = createCompilerOptions(); testSame(options, code); options.idGenerators = Sets.newHashSet("f"); test(options, code, "function f() {} 'a';"); } public void testOptimizeArgumentsArray() { String code = "function f() { return arguments[0]; }"; CompilerOptions options = createCompilerOptions(); testSame(options, code); options.optimizeArgumentsArray = true; String argName = "JSCompiler_OptimizeArgumentsArray_p0"; test(options, code, "function f(" + argName + ") { return " + argName + "; }"); } public void testOptimizeParameters() { String code = "function f(a) { return a; } f(true);"; CompilerOptions options = createCompilerOptions(); testSame(options, code); options.optimizeParameters = true; test(options, code, "function f() { var a = true; return a;} f();"); } public void testOptimizeReturns() { String code = "function f(a) { return a; } f(true);"; CompilerOptions options = createCompilerOptions(); testSame(options, code); options.optimizeReturns = true; test(options, code, "function f(a) {return;} f(true);"); } public void testRemoveAbstractMethods() { String code = CLOSURE_BOILERPLATE + "var x = {}; x.foo = goog.abstractMethod; x.bar = 3;"; CompilerOptions options = createCompilerOptions(); testSame(options, code); options.closurePass = true; options.collapseProperties = true; test(options, code, CLOSURE_COMPILED + " var x$bar = 3;"); } public void testCollapseProperties1() { String code = "var x = {}; x.FOO = 5; x.bar = 3;"; CompilerOptions options = createCompilerOptions(); testSame(options, code); options.collapseProperties = true; test(options, code, "var x$FOO = 5; var x$bar = 3;"); } public void testCollapseProperties2() { String code = "var x = {}; x.FOO = 5; x.bar = 3;"; CompilerOptions options = createCompilerOptions(); testSame(options, code); options.collapseProperties = true; options.collapseObjectLiterals = true; test(options, code, "var x$FOO = 5; var x$bar = 3;"); } public void testCollapseObjectLiteral1() { // Verify collapseObjectLiterals does nothing in global scope String code = "var x = {}; x.FOO = 5; x.bar = 3;"; CompilerOptions options = createCompilerOptions(); testSame(options, code); options.collapseObjectLiterals = true; testSame(options, code); } public void testCollapseObjectLiteral2() { String code = "function f() {var x = {}; x.FOO = 5; x.bar = 3;}"; CompilerOptions options = createCompilerOptions(); testSame(options, code); options.collapseObjectLiterals = true; test(options, code, "function f(){" + "var JSCompiler_object_inline_FOO_0;" + "var JSCompiler_object_inline_bar_1;" + "JSCompiler_object_inline_FOO_0=5;" + "JSCompiler_object_inline_bar_1=3}"); } public void testTightenTypesWithoutTypeCheck() { CompilerOptions options = createCompilerOptions(); options.tightenTypes = true; test(options, "", DefaultPassConfig.TIGHTEN_TYPES_WITHOUT_TYPE_CHECK); } public void testDisambiguateProperties() { String code = "/** @constructor */ function Foo(){} Foo.prototype.bar = 3;" + "/** @constructor */ function Baz(){} Baz.prototype.bar = 3;"; CompilerOptions options = createCompilerOptions(); testSame(options, code); options.disambiguateProperties = true; options.checkTypes = true; test(options, code, "function Foo(){} Foo.prototype.Foo_prototype$bar = 3;" + "function Baz(){} Baz.prototype.Baz_prototype$bar = 3;"); } public void testMarkPureCalls() { String testCode = "function foo() {} foo();"; CompilerOptions options = createCompilerOptions(); options.removeDeadCode = true; testSame(options, testCode); options.computeFunctionSideEffects = true; test(options, testCode, "function foo() {}"); } public void testMarkNoSideEffects() { String testCode = "noSideEffects();"; CompilerOptions options = createCompilerOptions(); options.removeDeadCode = true; testSame(options, testCode); options.markNoSideEffectCalls = true; test(options, testCode, ""); } public void testChainedCalls() { CompilerOptions options = createCompilerOptions(); options.chainCalls = true; test( options, "/** @constructor */ function Foo() {} " + "Foo.prototype.bar = function() { return this; }; " + "var f = new Foo();" + "f.bar(); " + "f.bar(); ", "function Foo() {} " + "Foo.prototype.bar = function() { return this; }; " + "var f = new Foo();" + "f.bar().bar();"); } public void testExtraAnnotationNames() { CompilerOptions options = createCompilerOptions(); options.setExtraAnnotationNames(Sets.newHashSet("TagA", "TagB")); test( options, "/** @TagA */ var f = new Foo(); /** @TagB */ f.bar();", "var f = new Foo(); f.bar();"); } public void testDevirtualizePrototypeMethods() { CompilerOptions options = createCompilerOptions(); options.devirtualizePrototypeMethods = true; test( options, "/** @constructor */ var Foo = function() {}; " + "Foo.prototype.bar = function() {};" + "(new Foo()).bar();", "var Foo = function() {};" + "var JSCompiler_StaticMethods_bar = " + " function(JSCompiler_StaticMethods_bar$self) {};" + "JSCompiler_StaticMethods_bar(new Foo());"); } public void testCheckConsts() { CompilerOptions options = createCompilerOptions(); options.inlineConstantVars = true; test(options, "var FOO = true; FOO = false", ConstCheck.CONST_REASSIGNED_VALUE_ERROR); } public void testAllChecksOn() { CompilerOptions options = createCompilerOptions(); options.checkSuspiciousCode = true; options.checkControlStructures = true; options.checkRequires = CheckLevel.ERROR; options.checkProvides = CheckLevel.ERROR; options.generateExports = true; options.exportTestFunctions = true; options.closurePass = true; options.checkMissingGetCssNameLevel = CheckLevel.ERROR; options.checkMissingGetCssNameBlacklist = "goog"; options.syntheticBlockStartMarker = "synStart"; options.syntheticBlockEndMarker = "synEnd"; options.checkSymbols = true; options.aggressiveVarCheck = CheckLevel.ERROR; options.processObjectPropertyString = true; options.collapseProperties = true; test(options, CLOSURE_BOILERPLATE, CLOSURE_COMPILED); } public void testTypeCheckingWithSyntheticBlocks() { CompilerOptions options = createCompilerOptions(); options.syntheticBlockStartMarker = "synStart"; options.syntheticBlockEndMarker = "synEnd"; options.checkTypes = true; // We used to have a bug where the CFG drew an // edge straight from synStart to f(progress). // If that happens, then progress will get type {number|undefined}. testSame( options, "/** @param {number} x */ function f(x) {}" + "function g() {" + " synStart('foo');" + " var progress = 1;" + " f(progress);" + " synEnd('foo');" + "}"); } public void testCompilerDoesNotBlowUpIfUndefinedSymbols() { CompilerOptions options = createCompilerOptions(); options.checkSymbols = true; // Disable the undefined variable check. options.setWarningLevel( DiagnosticGroup.forType(VarCheck.UNDEFINED_VAR_ERROR), CheckLevel.OFF); // The compiler used to throw an IllegalStateException on this. testSame(options, "var x = {foo: y};"); } // Make sure that if we change variables which are constant to have // $$constant appended to their names, we remove that tag before // we finish. public void testConstantTagsMustAlwaysBeRemoved() { CompilerOptions options = createCompilerOptions(); options.variableRenaming = VariableRenamingPolicy.LOCAL; String originalText = "var G_GEO_UNKNOWN_ADDRESS=1;\n" + "function foo() {" + " var localVar = 2;\n" + " if (G_GEO_UNKNOWN_ADDRESS == localVar) {\n" + " alert(\"A\"); }}"; String expectedText = "var G_GEO_UNKNOWN_ADDRESS=1;" + "function foo(){var a=2;if(G_GEO_UNKNOWN_ADDRESS==a){alert(\"A\")}}"; test(options, originalText, expectedText); } public void testClosurePassPreservesJsDoc() { CompilerOptions options = createCompilerOptions(); options.checkTypes = true; options.closurePass = true; test(options, CLOSURE_BOILERPLATE + "goog.provide('Foo'); /** @constructor */ Foo = function() {};" + "var x = new Foo();", "var COMPILED=true;var goog={};goog.exportSymbol=function(){};" + "var Foo=function(){};var x=new Foo"); test(options, CLOSURE_BOILERPLATE + "goog.provide('Foo'); /** @enum */ Foo = {a: 3};", TypeCheck.ENUM_NOT_CONSTANT); } public void testProvidedNamespaceIsConst() { CompilerOptions options = createCompilerOptions(); options.closurePass = true; options.inlineConstantVars = true; options.collapseProperties = true; test(options, "var goog = {}; goog.provide('foo'); " + "function f() { foo = {};}", "var foo = {}; function f() { foo = {}; }", ConstCheck.CONST_REASSIGNED_VALUE_ERROR); } public void testProvidedNamespaceIsConst2() { CompilerOptions options = createCompilerOptions(); options.closurePass = true; options.inlineConstantVars = true; options.collapseProperties = true; test(options, "var goog = {}; goog.provide('foo.bar'); " + "function f() { foo.bar = {};}", "var foo$bar = {};" + "function f() { foo$bar = {}; }", ConstCheck.CONST_REASSIGNED_VALUE_ERROR); } public void testProvidedNamespaceIsConst3() { CompilerOptions options = createCompilerOptions(); options.closurePass = true; options.inlineConstantVars = true; options.collapseProperties = true; test(options, "var goog = {}; " + "goog.provide('foo.bar'); goog.provide('foo.bar.baz'); " + "/** @constructor */ foo.bar = function() {};" + "/** @constructor */ foo.bar.baz = function() {};", "var foo$bar = function(){};" + "var foo$bar$baz = function(){};"); } public void testProvidedNamespaceIsConst4() { CompilerOptions options = createCompilerOptions(); options.closurePass = true; options.inlineConstantVars = true; options.collapseProperties = true; test(options, "var goog = {}; goog.provide('foo.Bar'); " + "var foo = {}; foo.Bar = {};", "var foo = {}; foo = {}; foo.Bar = {};"); } public void testProvidedNamespaceIsConst5() { CompilerOptions options = createCompilerOptions(); options.closurePass = true; options.inlineConstantVars = true; options.collapseProperties = true; test(options, "var goog = {}; goog.provide('foo.Bar'); " + "foo = {}; foo.Bar = {};", "var foo = {}; foo = {}; foo.Bar = {};"); } public void testProcessDefinesAlwaysOn() { test(createCompilerOptions(), "/** @define {boolean} */ var HI = true; HI = false;", "var HI = false;false;"); } public void testProcessDefinesAdditionalReplacements() { CompilerOptions options = createCompilerOptions(); options.setDefineToBooleanLiteral("HI", false); test(options, "/** @define {boolean} */ var HI = true;", "var HI = false;"); } public void testReplaceMessages() { CompilerOptions options = createCompilerOptions(); String prefix = "var goog = {}; goog.getMsg = function() {};"; testSame(options, prefix + "var MSG_HI = goog.getMsg('hi');"); options.messageBundle = new EmptyMessageBundle(); test(options, prefix + "/** @desc xyz */ var MSG_HI = goog.getMsg('hi');", prefix + "var MSG_HI = 'hi';"); } public void testCheckGlobalNames() { CompilerOptions options = createCompilerOptions(); options.checkGlobalNamesLevel = CheckLevel.ERROR; test(options, "var x = {}; var y = x.z;", CheckGlobalNames.UNDEFINED_NAME_WARNING); } public void testInlineGetters() { CompilerOptions options = createCompilerOptions(); String code = "function Foo() {} Foo.prototype.bar = function() { return 3; };" + "var x = new Foo(); x.bar();"; testSame(options, code); options.inlineGetters = true; test(options, code, "function Foo() {} Foo.prototype.bar = function() { return 3 };" + "var x = new Foo(); 3;"); } public void testInlineGettersWithAmbiguate() { CompilerOptions options = createCompilerOptions(); String code = "/** @constructor */" + "function Foo() {}" + "/** @type {number} */ Foo.prototype.field;" + "Foo.prototype.getField = function() { return this.field; };" + "/** @constructor */" + "function Bar() {}" + "/** @type {string} */ Bar.prototype.field;" + "Bar.prototype.getField = function() { return this.field; };" + "new Foo().getField();" + "new Bar().getField();"; testSame(options, code); options.inlineGetters = true; test(options, code, "function Foo() {}" + "Foo.prototype.field;" + "Foo.prototype.getField = function() { return this.field; };" + "function Bar() {}" + "Bar.prototype.field;" + "Bar.prototype.getField = function() { return this.field; };" + "new Foo().field;" + "new Bar().field;"); options.checkTypes = true; options.ambiguateProperties = true; // Propagating the wrong type information may cause ambiguate properties // to generate bad code. testSame(options, code); } public void testInlineVariables() { CompilerOptions options = createCompilerOptions(); String code = "function foo() {} var x = 3; foo(x);"; testSame(options, code); options.inlineVariables = true; test(options, code, "(function foo() {})(3);"); options.propertyRenaming = PropertyRenamingPolicy.HEURISTIC; test(options, code, DefaultPassConfig.CANNOT_USE_PROTOTYPE_AND_VAR); } public void testInlineConstants() { CompilerOptions options = createCompilerOptions(); String code = "function foo() {} var x = 3; foo(x); var YYY = 4; foo(YYY);"; testSame(options, code); options.inlineConstantVars = true; test(options, code, "function foo() {} var x = 3; foo(x); foo(4);"); } public void testMinimizeExits() { CompilerOptions options = createCompilerOptions(); String code = "function f() {" + " if (window.foo) return; window.h(); " + "}"; testSame(options, code); options.foldConstants = true; test( options, code, "function f() {" + " window.foo || window.h(); " + "}"); } public void testFoldConstants() { CompilerOptions options = createCompilerOptions(); String code = "if (true) { window.foo(); }"; testSame(options, code); options.foldConstants = true; test(options, code, "window.foo();"); } public void testRemoveUnreachableCode() { CompilerOptions options = createCompilerOptions(); String code = "function f() { return; f(); }"; testSame(options, code); options.removeDeadCode = true; test(options, code, "function f() {}"); } public void testRemoveUnusedPrototypeProperties1() { CompilerOptions options = createCompilerOptions(); String code = "function Foo() {} " + "Foo.prototype.bar = function() { return new Foo(); };"; testSame(options, code); options.removeUnusedPrototypeProperties = true; test(options, code, "function Foo() {}"); } public void testRemoveUnusedPrototypeProperties2() { CompilerOptions options = createCompilerOptions(); String code = "function Foo() {} " + "Foo.prototype.bar = function() { return new Foo(); };" + "function f(x) { x.bar(); }"; testSame(options, code); options.removeUnusedPrototypeProperties = true; testSame(options, code); options.removeUnusedVars = true; test(options, code, ""); } public void testSmartNamePass() { CompilerOptions options = createCompilerOptions(); String code = "function Foo() { this.bar(); } " + "Foo.prototype.bar = function() { return Foo(); };"; testSame(options, code); options.smartNameRemoval = true; test(options, code, ""); } public void testDeadAssignmentsElimination() { CompilerOptions options = createCompilerOptions(); String code = "function f() { var x = 3; 4; x = 5; return x; } f(); "; testSame(options, code); options.deadAssignmentElimination = true; testSame(options, code); options.removeUnusedVars = true; test(options, code, "function f() { var x = 3; 4; x = 5; return x; } f();"); } public void testInlineFunctions() { CompilerOptions options = createCompilerOptions(); String code = "function f() { return 3; } f(); "; testSame(options, code); options.inlineFunctions = true; test(options, code, "3;"); } public void testRemoveUnusedVars1() { CompilerOptions options = createCompilerOptions(); String code = "function f(x) {} f();"; testSame(options, code); options.removeUnusedVars = true; test(options, code, "function f() {} f();"); } public void testRemoveUnusedVars2() { CompilerOptions options = createCompilerOptions(); String code = "(function f(x) {})();var g = function() {}; g();"; testSame(options, code); options.removeUnusedVars = true; test(options, code, "(function() {})();var g = function() {}; g();"); options.anonymousFunctionNaming = AnonymousFunctionNamingPolicy.UNMAPPED; test(options, code, "(function f() {})();var g = function $g$() {}; g();"); } public void testCrossModuleCodeMotion() { CompilerOptions options = createCompilerOptions(); String[] code = new String[] { "var x = 1;", "x;", }; testSame(options, code); options.crossModuleCodeMotion = true; test(options, code, new String[] { "", "var x = 1; x;", }); } public void testCrossModuleMethodMotion() { CompilerOptions options = createCompilerOptions(); String[] code = new String[] { "var Foo = function() {}; Foo.prototype.bar = function() {};" + "var x = new Foo();", "x.bar();", }; testSame(options, code); options.crossModuleMethodMotion = true; test(options, code, new String[] { CrossModuleMethodMotion.STUB_DECLARATIONS + "var Foo = function() {};" + "Foo.prototype.bar=JSCompiler_stubMethod(0); var x=new Foo;", "Foo.prototype.bar=JSCompiler_unstubMethod(0,function(){}); x.bar()", }); } public void testFlowSensitiveInlineVariables1() { CompilerOptions options = createCompilerOptions(); String code = "function f() { var x = 3; x = 5; return x; }"; testSame(options, code); options.flowSensitiveInlineVariables = true; test(options, code, "function f() { var x = 3; return 5; }"); String unusedVar = "function f() { var x; x = 5; return x; } f()"; test(options, unusedVar, "function f() { var x; return 5; } f()"); options.removeUnusedVars = true; test(options, unusedVar, "function f() { return 5; } f()"); } public void testFlowSensitiveInlineVariables2() { CompilerOptions options = createCompilerOptions(); CompilationLevel.SIMPLE_OPTIMIZATIONS .setOptionsForCompilationLevel(options); test(options, "function f () {\n" + " var ab = 0;\n" + " ab += '-';\n" + " alert(ab);\n" + "}", "function f () {\n" + " alert('0-');\n" + "}"); } public void testCollapseAnonymousFunctions() { CompilerOptions options = createCompilerOptions(); String code = "var f = function() {};"; testSame(options, code); options.collapseAnonymousFunctions = true; test(options, code, "function f() {}"); } public void testMoveFunctionDeclarations() { CompilerOptions options = createCompilerOptions(); String code = "var x = f(); function f() { return 3; }"; testSame(options, code); options.moveFunctionDeclarations = true; test(options, code, "function f() { return 3; } var x = f();"); } public void testNameAnonymousFunctions() { CompilerOptions options = createCompilerOptions(); String code = "var f = function() {};"; testSame(options, code); options.anonymousFunctionNaming = AnonymousFunctionNamingPolicy.MAPPED; test(options, code, "var f = function $() {}"); assertNotNull(lastCompiler.getResult().namedAnonFunctionMap); options.anonymousFunctionNaming = AnonymousFunctionNamingPolicy.UNMAPPED; test(options, code, "var f = function $f$() {}"); assertNull(lastCompiler.getResult().namedAnonFunctionMap); } public void testNameAnonymousFunctionsWithVarRemoval() { CompilerOptions options = createCompilerOptions(); options.setRemoveUnusedVariables(CompilerOptions.Reach.LOCAL_ONLY); options.setInlineVariables(true); String code = "var f = function longName() {}; var g = function() {};" + "function longerName() {} var i = longerName;"; test(options, code, "var f = function() {}; var g = function() {}; " + "var i = function() {};"); options.anonymousFunctionNaming = AnonymousFunctionNamingPolicy.MAPPED; test(options, code, "var f = function longName() {}; var g = function $() {};" + "var i = function longerName(){};"); assertNotNull(lastCompiler.getResult().namedAnonFunctionMap); options.anonymousFunctionNaming = AnonymousFunctionNamingPolicy.UNMAPPED; test(options, code, "var f = function longName() {}; var g = function $g$() {};" + "var i = function longerName(){};"); assertNull(lastCompiler.getResult().namedAnonFunctionMap); } public void testExtractPrototypeMemberDeclarations() { CompilerOptions options = createCompilerOptions(); String code = "var f = function() {};"; String expected = "var a; var b = function() {}; a = b.prototype;"; for (int i = 0; i < 10; i++) { code += "f.prototype.a = " + i + ";"; expected += "a.a = " + i + ";"; } testSame(options, code); options.extractPrototypeMemberDeclarations = true; options.variableRenaming = VariableRenamingPolicy.ALL; test(options, code, expected); options.propertyRenaming = PropertyRenamingPolicy.HEURISTIC; options.variableRenaming = VariableRenamingPolicy.OFF; testSame(options, code); } public void testDevirtualizationAndExtractPrototypeMemberDeclarations() { CompilerOptions options = createCompilerOptions(); options.devirtualizePrototypeMethods = true; options.collapseAnonymousFunctions = true; options.extractPrototypeMemberDeclarations = true; options.variableRenaming = VariableRenamingPolicy.ALL; String code = "var f = function() {};"; String expected = "var a; function b() {} a = b.prototype;"; for (int i = 0; i < 10; i++) { code += "f.prototype.argz = function() {arguments};"; code += "f.prototype.devir" + i + " = function() {};"; char letter = (char) ('d' + i); expected += "a.argz = function() {arguments};"; expected += "function " + letter + "(c){}"; } code += "var F = new f(); F.argz();"; expected += "var n = new b(); n.argz();"; for (int i = 0; i < 10; i++) { code += "F.devir" + i + "();"; char letter = (char) ('d' + i); expected += letter + "(n);"; } test(options, code, expected); } public void testCoalesceVariableNames() { CompilerOptions options = createCompilerOptions(); String code = "function f() {var x = 3; var y = x; var z = y; return z;}"; testSame(options, code); options.coalesceVariableNames = true; test(options, code, "function f() {var x = 3; x = x; x = x; return x;}"); } public void testPropertyRenaming() { CompilerOptions options = createCompilerOptions(); options.propertyAffinity = true; String code = "function f() { return this.foo + this['bar'] + this.Baz; }" + "f.prototype.bar = 3; f.prototype.Baz = 3;"; String heuristic = "function f() { return this.foo + this['bar'] + this.a; }" + "f.prototype.bar = 3; f.prototype.a = 3;"; String aggHeuristic = "function f() { return this.foo + this['b'] + this.a; } " + "f.prototype.b = 3; f.prototype.a = 3;"; String all = "function f() { return this.b + this['bar'] + this.a; }" + "f.prototype.c = 3; f.prototype.a = 3;"; testSame(options, code); options.propertyRenaming = PropertyRenamingPolicy.HEURISTIC; test(options, code, heuristic); options.propertyRenaming = PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC; test(options, code, aggHeuristic); options.propertyRenaming = PropertyRenamingPolicy.ALL_UNQUOTED; test(options, code, all); } public void testConvertToDottedProperties() { CompilerOptions options = createCompilerOptions(); String code = "function f() { return this['bar']; } f.prototype.bar = 3;"; String expected = "function f() { return this.bar; } f.prototype.a = 3;"; testSame(options, code); options.convertToDottedProperties = true; options.propertyRenaming = PropertyRenamingPolicy.ALL_UNQUOTED; test(options, code, expected); } public void testRewriteFunctionExpressions() { CompilerOptions options = createCompilerOptions(); String code = "var a = function() {};"; String expected = "function JSCompiler_emptyFn(){return function(){}} " + "var a = JSCompiler_emptyFn();"; for (int i = 0; i < 10; i++) { code += "a = function() {};"; expected += "a = JSCompiler_emptyFn();"; } testSame(options, code); options.rewriteFunctionExpressions = true; test(options, code, expected); } public void testAliasAllStrings() { CompilerOptions options = createCompilerOptions(); String code = "function f() { return 'a'; }"; String expected = "var $$S_a = 'a'; function f() { return $$S_a; }"; testSame(options, code); options.aliasAllStrings = true; test(options, code, expected); } public void testAliasExterns() { CompilerOptions options = createCompilerOptions(); String code = "function f() { return window + window + window + window; }"; String expected = "var GLOBAL_window = window;" + "function f() { return GLOBAL_window + GLOBAL_window + " + " GLOBAL_window + GLOBAL_window; }"; testSame(options, code); options.aliasExternals = true; test(options, code, expected); } public void testAliasKeywords() { CompilerOptions options = createCompilerOptions(); String code = "function f() { return true + true + true + true + true + true; }"; String expected = "var JSCompiler_alias_TRUE = true;" + "function f() { return JSCompiler_alias_TRUE + " + " JSCompiler_alias_TRUE + JSCompiler_alias_TRUE + " + " JSCompiler_alias_TRUE + JSCompiler_alias_TRUE + " + " JSCompiler_alias_TRUE; }"; testSame(options, code); options.aliasKeywords = true; test(options, code, expected); } public void testRenameVars1() { CompilerOptions options = createCompilerOptions(); String code = "var abc = 3; function f() { var xyz = 5; return abc + xyz; }"; String local = "var abc = 3; function f() { var a = 5; return abc + a; }"; String all = "var a = 3; function c() { var b = 5; return a + b; }"; testSame(options, code); options.variableRenaming = VariableRenamingPolicy.LOCAL; test(options, code, local); options.variableRenaming = VariableRenamingPolicy.ALL; test(options, code, all); options.reserveRawExports = true; } public void testRenameVars2() { CompilerOptions options = createCompilerOptions(); options.variableRenaming = VariableRenamingPolicy.ALL; String code = "var abc = 3; function f() { window['a'] = 5; }"; String noexport = "var a = 3; function b() { window['a'] = 5; }"; String export = "var b = 3; function c() { window['a'] = 5; }"; options.reserveRawExports = false; test(options, code, noexport); options.reserveRawExports = true; test(options, code, export); } public void testShadowVaribles() { CompilerOptions options = createCompilerOptions(); options.variableRenaming = VariableRenamingPolicy.LOCAL; options.shadowVariables = true; String code = "var f = function(x) { return function(y) {}}"; String expected = "var f = function(a) { return function(a) {}}"; test(options, code, expected); } public void testRenameLabels() { CompilerOptions options = createCompilerOptions(); String code = "longLabel: for(;true;) { break longLabel; }"; String expected = "a: for(;true;) { break a; }"; testSame(options, code); options.labelRenaming = true; test(options, code, expected); } public void testBadBreakStatementInIdeMode() { // Ensure that type-checking doesn't crash, even if the CFG is malformed. // This can happen in IDE mode. CompilerOptions options = createCompilerOptions(); options.ideMode = true; options.checkTypes = true; test(options, "function f() { try { } catch(e) { break; } }", RhinoErrorReporter.PARSE_ERROR); } public void testIssue63SourceMap() { CompilerOptions options = createCompilerOptions(); String code = "var a;"; options.skipAllPasses = true; options.sourceMapOutputPath = "./src.map"; Compiler compiler = compile(options, code); compiler.toSource(); } public void testRegExp1() { CompilerOptions options = createCompilerOptions(); options.foldConstants = true; String code = "/(a)/.test(\"a\");"; testSame(options, code); options.computeFunctionSideEffects = true; String expected = ""; test(options, code, expected); } public void testRegExp2() { CompilerOptions options = createCompilerOptions(); options.foldConstants = true; String code = "/(a)/.test(\"a\");var a = RegExp.$1"; testSame(options, code); options.computeFunctionSideEffects = true; test(options, code, CheckRegExp.REGEXP_REFERENCE); options.setWarningLevel(DiagnosticGroups.CHECK_REGEXP, CheckLevel.OFF); testSame(options, code); } public void testFoldLocals1() { CompilerOptions options = createCompilerOptions(); options.foldConstants = true; // An external object, whose constructor has no side-effects, // and whose method "go" only modifies the object. String code = "new Widget().go();"; testSame(options, code); options.computeFunctionSideEffects = true; test(options, code, ""); } public void testFoldLocals2() { CompilerOptions options = createCompilerOptions(); options.foldConstants = true; options.checkTypes = true; // An external function that returns a local object that the // method "go" that only modifies the object. String code = "widgetToken().go();"; testSame(options, code); options.computeFunctionSideEffects = true; test(options, code, "widgetToken()"); } public void testFoldLocals3() { CompilerOptions options = createCompilerOptions(); options.foldConstants = true; // A function "f" who returns a known local object, and a method that // modifies only modifies that. String definition = "function f(){return new Widget()}"; String call = "f().go();"; String code = definition + call; testSame(options, code); options.computeFunctionSideEffects = true; // BROKEN //test(options, code, definition); testSame(options, code); } public void testFoldLocals4() { CompilerOptions options = createCompilerOptions(); options.foldConstants = true; String code = "/** @constructor */\n" + "function InternalWidget(){this.x = 1;}" + "InternalWidget.prototype.internalGo = function (){this.x = 2};" + "new InternalWidget().internalGo();"; testSame(options, code); options.computeFunctionSideEffects = true; String optimized = "" + "function InternalWidget(){this.x = 1;}" + "InternalWidget.prototype.internalGo = function (){this.x = 2};"; test(options, code, optimized); } public void testFoldLocals5() { CompilerOptions options = createCompilerOptions(); options.foldConstants = true; String code = "" + "function fn(){var a={};a.x={};return a}" + "fn().x.y = 1;"; // "fn" returns a unescaped local object, we should be able to fold it, // but we don't currently. String result = "" + "function fn(){var a={x:{}};return a}" + "fn().x.y = 1;"; test(options, code, result); options.computeFunctionSideEffects = true; test(options, code, result); } public void testFoldLocals6() { CompilerOptions options = createCompilerOptions(); options.foldConstants = true; String code = "" + "function fn(){return {}}" + "fn().x.y = 1;"; testSame(options, code); options.computeFunctionSideEffects = true; testSame(options, code); } public void testFoldLocals7() { CompilerOptions options = createCompilerOptions(); options.foldConstants = true; String code = "" + "function InternalWidget(){return [];}" + "Array.prototype.internalGo = function (){this.x = 2};" + "InternalWidget().internalGo();"; testSame(options, code); options.computeFunctionSideEffects = true; String optimized = "" + "function InternalWidget(){return [];}" + "Array.prototype.internalGo = function (){this.x = 2};"; test(options, code, optimized); } public void testVarDeclarationsIntoFor() { CompilerOptions options = createCompilerOptions(); options.collapseVariableDeclarations = false; String code = "var a = 1; for (var b = 2; ;) {}"; testSame(options, code); options.collapseVariableDeclarations = true; test(options, code, "for (var a = 1, b = 2; ;) {}"); } public void testExploitAssigns() { CompilerOptions options = createCompilerOptions(); options.collapseVariableDeclarations = false; String code = "a = 1; b = a; c = b"; testSame(options, code); options.collapseVariableDeclarations = true; test(options, code, "c=b=a=1"); } public void testRecoverOnBadExterns() throws Exception { // This test is for a bug in a very narrow set of circumstances: // 1) externs validation has to be off. // 2) aliasExternals has to be on. // 3) The user has to reference a "normal" variable in externs. // This case is handled at checking time by injecting a // synthetic extern variable, and adding a "@suppress {duplicate}" to // the normal code at compile time. But optimizations may remove that // annotation, so we need to make sure that the variable declarations // are de-duped before that happens. CompilerOptions options = createCompilerOptions(); options.aliasExternals = true; externs = ImmutableList.of( SourceFile.fromCode("externs", "extern.foo")); test(options, "var extern; " + "function f() { return extern + extern + extern + extern; }", "var extern; " + "function f() { return extern + extern + extern + extern; }", VarCheck.UNDEFINED_EXTERN_VAR_ERROR); } public void testDuplicateVariablesInExterns() { CompilerOptions options = createCompilerOptions(); options.checkSymbols = true; externs = ImmutableList.of( SourceFile.fromCode("externs", "var externs = {}; /** @suppress {duplicate} */ var externs = {};")); testSame(options, ""); } public void testLanguageMode() { CompilerOptions options = createCompilerOptions(); options.setLanguageIn(LanguageMode.ECMASCRIPT3); String code = "var a = {get f(){}}"; Compiler compiler = compile(options, code); checkUnexpectedErrorsOrWarnings(compiler, 1); assertEquals( "JSC_PARSE_ERROR. Parse error. " + "getters are not supported in older versions of JS. " + "If you are targeting newer versions of JS, " + "set the appropriate language_in option. " + "at i0 line 1 : 0", compiler.getErrors()[0].toString()); options.setLanguageIn(LanguageMode.ECMASCRIPT5); testSame(options, code); options.setLanguageIn(LanguageMode.ECMASCRIPT5_STRICT); testSame(options, code); } public void testLanguageMode2() { CompilerOptions options = createCompilerOptions(); options.setLanguageIn(LanguageMode.ECMASCRIPT3); options.setWarningLevel(DiagnosticGroups.ES5_STRICT, CheckLevel.OFF); String code = "var a = 2; delete a;"; testSame(options, code); options.setLanguageIn(LanguageMode.ECMASCRIPT5); testSame(options, code); options.setLanguageIn(LanguageMode.ECMASCRIPT5_STRICT); test(options, code, code, StrictModeCheck.DELETE_VARIABLE); } public void testIssue598() { CompilerOptions options = createCompilerOptions(); options.setLanguageIn(LanguageMode.ECMASCRIPT5_STRICT); WarningLevel.VERBOSE.setOptionsForWarningLevel(options); options.setLanguageIn(LanguageMode.ECMASCRIPT5); String code = "'use strict';\n" + "function App() {}\n" + "App.prototype = {\n" + " get appData() { return this.appData_; },\n" + " set appData(data) { this.appData_ = data; }\n" + "};"; Compiler compiler = compile(options, code); testSame(options, code); } public void testIssue701() { // Check ASCII art in license comments. String ascii = "/**\n" + " * @preserve\n" + " This\n" + " is\n" + " ASCII ART\n" + "*/"; String result = "/*\n\n" + " This\n" + " is\n" + " ASCII ART\n" + "*/\n"; testSame(createCompilerOptions(), ascii); assertEquals(result, lastCompiler.toSource()); } public void testIssue724() { CompilerOptions options = createCompilerOptions(); CompilationLevel.ADVANCED_OPTIMIZATIONS .setOptionsForCompilationLevel(options); String code = "isFunction = function(functionToCheck) {" + " var getType = {};" + " return functionToCheck && " + " getType.toString.apply(functionToCheck) === " + " '[object Function]';" + "};"; String result = "isFunction=function(a){var b={};" + "return a&&\"[object Function]\"===b.b.a(a)}"; test(options, code, result); } public void testIssue730() { CompilerOptions options = createCompilerOptions(); CompilationLevel.ADVANCED_OPTIMIZATIONS .setOptionsForCompilationLevel(options); String code = "/** @constructor */function A() {this.foo = 0; Object.seal(this);}\n" + "/** @constructor */function B() {this.a = new A();}\n" + "B.prototype.dostuff = function() {this.a.foo++;alert('hi');}\n" + "new B().dostuff();\n"; test(options, code, "function a(){this.b=0;Object.seal(this)}" + "(new function(){this.a=new a}).a.b++;" + "alert(\"hi\")"); options.removeUnusedClassProperties = true; // This is still a problem when removeUnusedClassProperties are enabled. test(options, code, "function a(){Object.seal(this)}" + "(new function(){this.a=new a}).a.b++;" + "alert(\"hi\")"); } public void testCoaleseVariables() { CompilerOptions options = createCompilerOptions(); options.foldConstants = false; options.coalesceVariableNames = true; String code = "function f(a) {" + " if (a) {" + " return a;" + " } else {" + " var b = a;" + " return b;" + " }" + " return a;" + "}"; String expected = "function f(a) {" + " if (a) {" + " return a;" + " } else {" + " a = a;" + " return a;" + " }" + " return a;" + "}"; test(options, code, expected); options.foldConstants = true; options.coalesceVariableNames = false; code = "function f(a) {" + " if (a) {" + " return a;" + " } else {" + " var b = a;" + " return b;" + " }" + " return a;" + "}"; expected = "function f(a) {" + " if (!a) {" + " var b = a;" + " return b;" + " }" + " return a;" + "}"; test(options, code, expected); options.foldConstants = true; options.coalesceVariableNames = true; expected = "function f(a) {" + " return a;" + "}"; test(options, code, expected); } public void testLateStatementFusion() { CompilerOptions options = createCompilerOptions(); options.foldConstants = true; test(options, "while(a){a();if(b){b();b()}}", "for(;a;)a(),b&&(b(),b())"); } public void testLateConstantReordering() { CompilerOptions options = createCompilerOptions(); options.foldConstants = true; test(options, "if (x < 1 || x > 1 || 1 < x || 1 > x) { alert(x) }", " (1 > x || 1 < x || 1 < x || 1 > x) && alert(x) "); } public void testsyntheticBlockOnDeadAssignments() { CompilerOptions options = createCompilerOptions(); options.deadAssignmentElimination = true; options.removeUnusedVars = true; options.syntheticBlockStartMarker = "START"; options.syntheticBlockEndMarker = "END"; test(options, "var x; x = 1; START(); x = 1;END();x()", "var x; x = 1;{START();{x = 1}END()}x()"); } public void testBug4152835() { CompilerOptions options = createCompilerOptions(); options.foldConstants = true; options.syntheticBlockStartMarker = "START"; options.syntheticBlockEndMarker = "END"; test(options, "START();END()", "{START();{}END()}"); } public void testBug5786871() { CompilerOptions options = createCompilerOptions(); options.ideMode = true; test(options, "function () {}", RhinoErrorReporter.PARSE_ERROR); } public void testIssue378() { CompilerOptions options = createCompilerOptions(); options.inlineVariables = true; options.flowSensitiveInlineVariables = true; testSame(options, "function f(c) {var f = c; arguments[0] = this;" + " f.apply(this, arguments); return this;}"); } public void testIssue550() { CompilerOptions options = createCompilerOptions(); CompilationLevel.SIMPLE_OPTIMIZATIONS .setOptionsForCompilationLevel(options); options.foldConstants = true; options.inlineVariables = true; options.flowSensitiveInlineVariables = true; test(options, "function f(h) {\n" + " var a = h;\n" + " a = a + 'x';\n" + " a = a + 'y';\n" + " return a;\n" + "}", // This should eventually get inlined completely. "function f(a) { a += 'x'; return a += 'y'; }"); } public void testIssue284() { CompilerOptions options = createCompilerOptions(); options.smartNameRemoval = true; test(options, "var goog = {};" + "goog.inherits = function(x, y) {};" + "var ns = {};" + "/** @constructor */" + "ns.PageSelectionModel = function() {};" + "/** @constructor */" + "ns.PageSelectionModel.FooEvent = function() {};" + "/** @constructor */" + "ns.PageSelectionModel.SelectEvent = function() {};" + "goog.inherits(ns.PageSelectionModel.ChangeEvent," + " ns.PageSelectionModel.FooEvent);", ""); } public void testIssue772() throws Exception { CompilerOptions options = createCompilerOptions(); options.closurePass = true; options.checkTypes = true; test( options, "/** @const */ var a = {};" + "/** @const */ a.b = {};" + "/** @const */ a.b.c = {};" + "goog.scope(function() {" + " var b = a.b;" + " var c = b.c;" + " /** @typedef {string} */" + " c.MyType;" + " /** @param {c.MyType} x The variable. */" + " c.myFunc = function(x) {};" + "});", "/** @const */ var a = {};" + "/** @const */ a.b = {};" + "/** @const */ a.b.c = {};" + "a.b.c.MyType;" + "a.b.c.myFunc = function(x) {};"); } public void testCodingConvention() { Compiler compiler = new Compiler(); compiler.initOptions(new CompilerOptions()); assertEquals( compiler.getCodingConvention().getClass().toString(), ClosureCodingConvention.class.toString()); } public void testJQueryStringSplitLoops() { CompilerOptions options = createCompilerOptions(); options.foldConstants = true; test(options, "var x=['1','2','3','4','5','6','7']", "var x='1234567'.split('')"); options = createCompilerOptions(); options.foldConstants = true; options.computeFunctionSideEffects = false; options.removeUnusedVars = true; // If we do splits too early, it would add a side-effect to x. test(options, "var x=['1','2','3','4','5','6','7']", ""); } public void testAlwaysRunSafetyCheck() { CompilerOptions options = createCompilerOptions(); options.checkSymbols = false; options.customPasses = ArrayListMultimap.create(); options.customPasses.put( CustomPassExecutionTime.BEFORE_OPTIMIZATIONS, new CompilerPass() { @Override public void process(Node externs, Node root) { Node var = root.getLastChild().getFirstChild(); assertEquals(Token.VAR, var.getType()); var.detachFromParent(); } }); try { test(options, "var x = 3; function f() { return x + z; }", "function f() { return x + z; }"); fail("Expected run-time exception"); } catch (RuntimeException e) { assertTrue(e.getMessage().indexOf("Unexpected variable x") != -1); } } public void testSuppressEs5StrictWarning() { CompilerOptions options = createCompilerOptions(); options.setWarningLevel(DiagnosticGroups.ES5_STRICT, CheckLevel.WARNING); test(options, "/** @suppress{es5Strict} */\n" + "function f() { var arguments; }", "function f() {}"); } public void testCheckProvidesWarning() { CompilerOptions options = createCompilerOptions(); options.setWarningLevel(DiagnosticGroups.CHECK_PROVIDES, CheckLevel.WARNING); options.setCheckProvides(CheckLevel.WARNING); test(options, "/** @constructor */\n" + "function f() { var arguments; }", DiagnosticType.warning("JSC_MISSING_PROVIDE", "missing goog.provide(''{0}'')")); } public void testSuppressCheckProvidesWarning() { CompilerOptions options = createCompilerOptions(); options.setWarningLevel(DiagnosticGroups.CHECK_PROVIDES, CheckLevel.WARNING); options.setCheckProvides(CheckLevel.WARNING); testSame(options, "/** @constructor\n" + " * @suppress{checkProvides} */\n" + "function f() {}"); } public void testSuppressCastWarning() { CompilerOptions options = createCompilerOptions(); options.setWarningLevel(DiagnosticGroups.CHECK_TYPES, CheckLevel.WARNING); normalizeResults = true; test(options, "function f() { var xyz = /** @type {string} */ (0); }", DiagnosticType.warning( "JSC_INVALID_CAST", "invalid cast")); testSame(options, "/** @suppress{cast} */\n" + "function f() { var xyz = /** @type {string} */ (0); }"); } public void testRenamePrefix() { String code = "var x = {}; function f(y) {}"; CompilerOptions options = createCompilerOptions(); options.renamePrefix = "G_"; options.variableRenaming = VariableRenamingPolicy.ALL; test(options, code, "var G_={}; function G_a(a) {}"); } public void testRenamePrefixNamespace() { String code = "var x = {}; x.FOO = 5; x.bar = 3;"; CompilerOptions options = createCompilerOptions(); testSame(options, code); options.collapseProperties = true; options.renamePrefixNamespace = "_"; test(options, code, "_.x$FOO = 5; _.x$bar = 3;"); } public void testRenamePrefixNamespaceProtectSideEffects() { String code = "var x = null; try { +x.FOO; } catch (e) {}"; CompilerOptions options = createCompilerOptions(); testSame(options, code); CompilationLevel.SIMPLE_OPTIMIZATIONS.setOptionsForCompilationLevel( options); options.renamePrefixNamespace = "_"; test(options, code, "_.x = null; try { +_.x.FOO; } catch (e) {}"); } public void testRenamePrefixNamespaceActivatesMoveFunctionDeclarations() { CompilerOptions options = createCompilerOptions(); String code = "var x = f; function f() { return 3; }"; testSame(options, code); assertFalse(options.moveFunctionDeclarations); options.renamePrefixNamespace = "_"; test(options, code, "_.f = function() { return 3; }; _.x = _.f;"); } public void testBrokenNameSpace() { CompilerOptions options = createCompilerOptions(); String code = "var goog; goog.provide('i.am.on.a.Horse');" + "i.am.on.a.Horse = function() {};" + "i.am.on.a.Horse.prototype.x = function() {};" + "i.am.on.a.Boat.prototype.y = function() {}"; options.closurePass = true; options.collapseProperties = true; options.smartNameRemoval = true; test(options, code, ""); } public void testNamelessParameter() { CompilerOptions options = createCompilerOptions(); CompilationLevel.ADVANCED_OPTIMIZATIONS .setOptionsForCompilationLevel(options); String code = "var impl_0;" + "$load($init());" + "function $load(){" + " window['f'] = impl_0;" + "}" + "function $init() {" + " impl_0 = {};" + "}"; String result = "window.f = {};"; test(options, code, result); } public void testHiddenSideEffect() { CompilerOptions options = createCompilerOptions(); CompilationLevel.ADVANCED_OPTIMIZATIONS .setOptionsForCompilationLevel(options); options.setAliasExternals(true); String code = "window.offsetWidth;"; String result = "window.offsetWidth;"; test(options, code, result); } public void testNegativeZero() { CompilerOptions options = createCompilerOptions(); CompilationLevel.ADVANCED_OPTIMIZATIONS .setOptionsForCompilationLevel(options); test(options, "function bar(x) { return x; }\n" + "function foo(x) { print(x / bar(0));\n" + " print(x / bar(-0)); }\n" + "foo(3);", "print(3/0);print(3/-0);"); } public void testSingletonGetter1() { CompilerOptions options = createCompilerOptions(); CompilationLevel.ADVANCED_OPTIMIZATIONS .setOptionsForCompilationLevel(options); options.setCodingConvention(new ClosureCodingConvention()); test(options, "/** @const */\n" + "var goog = goog || {};\n" + "goog.addSingletonGetter = function(ctor) {\n" + " ctor.getInstance = function() {\n" + " return ctor.instance_ || (ctor.instance_ = new ctor());\n" + " };\n" + "};" + "function Foo() {}\n" + "goog.addSingletonGetter(Foo);" + "Foo.prototype.bar = 1;" + "function Bar() {}\n" + "goog.addSingletonGetter(Bar);" + "Bar.prototype.bar = 1;", ""); } public void testIncompleteFunction1() { CompilerOptions options = createCompilerOptions(); options.ideMode = true; DiagnosticType[] warnings = new DiagnosticType[]{ RhinoErrorReporter.PARSE_ERROR, RhinoErrorReporter.PARSE_ERROR}; test(options, new String[] { "var foo = {bar: function(e) }" }, new String[] { "var foo = {bar: function(e){}};" }, warnings ); } public void testIncompleteFunction2() { CompilerOptions options = createCompilerOptions(); options.ideMode = true; DiagnosticType[] warnings = new DiagnosticType[]{ RhinoErrorReporter.PARSE_ERROR, RhinoErrorReporter.PARSE_ERROR, RhinoErrorReporter.PARSE_ERROR, RhinoErrorReporter.PARSE_ERROR, RhinoErrorReporter.PARSE_ERROR, RhinoErrorReporter.PARSE_ERROR}; test(options, new String[] { "function hi" }, new String[] { "function hi() {}" }, warnings ); } public void testSortingOff() { CompilerOptions options = new CompilerOptions(); options.closurePass = true; options.setCodingConvention(new ClosureCodingConvention()); test(options, new String[] { "goog.require('goog.beer');", "goog.provide('goog.beer');" }, ProcessClosurePrimitives.LATE_PROVIDE_ERROR); } public void testUnboundedArrayLiteralInfiniteLoop() { CompilerOptions options = createCompilerOptions(); options.ideMode = true; test(options, "var x = [1, 2", "var x = [1, 2]", RhinoErrorReporter.PARSE_ERROR); } public void testProvideRequireSameFile() throws Exception { CompilerOptions options = createCompilerOptions(); options.setDependencyOptions( new DependencyOptions() .setDependencySorting(true)); options.closurePass = true; test( options, "goog.provide('x');\ngoog.require('x');", "var x = {};"); } public void testDependencySorting() throws Exception { CompilerOptions options = createCompilerOptions(); options.setDependencyOptions( new DependencyOptions() .setDependencySorting(true)); test( options, new String[] { "goog.require('x');", "goog.provide('x');", }, new String[] { "goog.provide('x');", "goog.require('x');", // For complicated reasons involving modules, // the compiler creates a synthetic source file. "", }); } public void testStrictWarningsGuard() throws Exception { CompilerOptions options = createCompilerOptions(); options.checkTypes = true; options.addWarningsGuard(new StrictWarningsGuard()); Compiler compiler = compile(options, "/** @return {number} */ function f() { return true; }"); assertEquals(1, compiler.getErrors().length); assertEquals(0, compiler.getWarnings().length); } public void testStrictWarningsGuardEmergencyMode() throws Exception { CompilerOptions options = createCompilerOptions(); options.checkTypes = true; options.addWarningsGuard(new StrictWarningsGuard()); options.useEmergencyFailSafe(); Compiler compiler = compile(options, "/** @return {number} */ function f() { return true; }"); assertEquals(0, compiler.getErrors().length); assertEquals(1, compiler.getWarnings().length); } public void testInlineProperties() { CompilerOptions options = createCompilerOptions(); CompilationLevel level = CompilationLevel.ADVANCED_OPTIMIZATIONS; level.setOptionsForCompilationLevel(options); level.setTypeBasedOptimizationOptions(options); String code = "" + "var ns = {};\n" + "/** @constructor */\n" + "ns.C = function () {this.someProperty = 1}\n" + "alert(new ns.C().someProperty + new ns.C().someProperty);\n"; assertTrue(options.inlineProperties); assertTrue(options.collapseProperties); // CollapseProperties used to prevent inlining this property. test(options, code, "alert(2);"); } public void testGoogDefineClass1() { CompilerOptions options = createCompilerOptions(); CompilationLevel level = CompilationLevel.ADVANCED_OPTIMIZATIONS; level.setOptionsForCompilationLevel(options); level.setTypeBasedOptimizationOptions(options); String code = "" + "var ns = {};\n" + "ns.C = goog.defineClass(null, {\n" + " /** @constructor */\n" + " constructor: function () {this.someProperty = 1}\n" + "});\n" + "alert(new ns.C().someProperty + new ns.C().someProperty);\n"; assertTrue(options.inlineProperties); assertTrue(options.collapseProperties); // CollapseProperties used to prevent inlining this property. test(options, code, "alert(2);"); } public void testGoogDefineClass2() { CompilerOptions options = createCompilerOptions(); CompilationLevel level = CompilationLevel.ADVANCED_OPTIMIZATIONS; level.setOptionsForCompilationLevel(options); level.setTypeBasedOptimizationOptions(options); String code = "" + "var C = goog.defineClass(null, {\n" + " /** @constructor */\n" + " constructor: function () {this.someProperty = 1}\n" + "});\n" + "alert(new C().someProperty + new C().someProperty);\n"; assertTrue(options.inlineProperties); assertTrue(options.collapseProperties); // CollapseProperties used to prevent inlining this property. test(options, code, "alert(2);"); } public void testGoogDefineClass3() { CompilerOptions options = createCompilerOptions(); CompilationLevel level = CompilationLevel.ADVANCED_OPTIMIZATIONS; level.setOptionsForCompilationLevel(options); level.setTypeBasedOptimizationOptions(options); WarningLevel warnings = WarningLevel.VERBOSE; warnings.setOptionsForWarningLevel(options); String code = "" + "var C = goog.defineClass(null, {\n" + " /** @constructor */\n" + " constructor: function () {\n" + " /** @type {number} */\n" + " this.someProperty = 1},\n" + " /** @param {string} a */\n" + " someMethod: function (a) {}\n" + "});" + "var x = new C();\n" + "x.someMethod(x.someProperty);\n"; assertTrue(options.inlineProperties); assertTrue(options.collapseProperties); // CollapseProperties used to prevent inlining this property. test(options, code, TypeValidator.TYPE_MISMATCH_WARNING); } public void testCheckConstants1() { CompilerOptions options = createCompilerOptions(); CompilationLevel level = CompilationLevel.SIMPLE_OPTIMIZATIONS; level.setOptionsForCompilationLevel(options); WarningLevel warnings = WarningLevel.QUIET; warnings.setOptionsForWarningLevel(options); String code = "" + "var foo; foo();\n" + "/** @const */\n" + "var x = 1; foo(); x = 2;\n"; test(options, code, code); } public void testCheckConstants2() { CompilerOptions options = createCompilerOptions(); CompilationLevel level = CompilationLevel.SIMPLE_OPTIMIZATIONS; level.setOptionsForCompilationLevel(options); WarningLevel warnings = WarningLevel.DEFAULT; warnings.setOptionsForWarningLevel(options); String code = "" + "var foo;\n" + "/** @const */\n" + "var x = 1; foo(); x = 2;\n"; test(options, code, ConstCheck.CONST_REASSIGNED_VALUE_ERROR); } public void testIssue787() { CompilerOptions options = createCompilerOptions(); CompilationLevel level = CompilationLevel.SIMPLE_OPTIMIZATIONS; level.setOptionsForCompilationLevel(options); WarningLevel warnings = WarningLevel.DEFAULT; warnings.setOptionsForWarningLevel(options); String code = "" + "function some_function() {\n" + " var fn1;\n" + " var fn2;\n" + "\n" + " if (any_expression) {\n" + " fn2 = external_ref;\n" + " fn1 = function (content) {\n" + " return fn2();\n" + " }\n" + " }\n" + "\n" + " return {\n" + " method1: function () {\n" + " if (fn1) fn1();\n" + " return true;\n" + " },\n" + " method2: function () {\n" + " return false;\n" + " }\n" + " }\n" + "}"; String result = "" + "function some_function() {\n" + " var a, b;\n" + " any_expression && (b = external_ref, a = function(a) {\n" + " return b()\n" + " });\n" + " return{method1:function() {\n" + " a && a();\n" + " return !0\n" + " }, method2:function() {\n" + " return !1\n" + " }}\n" + "}\n" + ""; test(options, code, result); } public void testManyAdds() {} // Defects4J: flaky method // public void testManyAdds() { // CompilerOptions options = createCompilerOptions(); // CompilationLevel level = CompilationLevel.SIMPLE_OPTIMIZATIONS; // level.setOptionsForCompilationLevel(options); // WarningLevel warnings = WarningLevel.VERBOSE; // warnings.setOptionsForWarningLevel(options); // // int numAdds = 4750; // StringBuilder original = new StringBuilder("var x = 0"); // for (int i = 0; i < numAdds; i++) { // original.append(" + 1"); // } // original.append(";"); // test(options, original.toString(), "var x = " + numAdds + ";"); // } /** Creates a CompilerOptions object with google coding conventions. */ @Override protected CompilerOptions createCompilerOptions() { CompilerOptions options = new CompilerOptions(); options.setCodingConvention(new GoogleCodingConvention()); return options; } }
/* * Copyright 2007 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.ImmutableList; import junit.framework.TestCase; /** */ public class JSCompilerSourceExcerptProviderTest extends TestCase { private SourceExcerptProvider provider; @Override protected void setUp() throws Exception { SourceFile foo = SourceFile.fromCode("foo", "foo:first line\nfoo:second line\nfoo:third line\n"); SourceFile bar = SourceFile.fromCode("bar", "bar:first line\nbar:second line\nbar:third line\nbar:fourth line\n"); SourceFile foo2 = SourceFile.fromCode("foo2", "foo2:first line\nfoo2:second line\nfoo2:third line"); Compiler compiler = new Compiler(); CompilerOptions options = new CompilerOptions(); compiler.init( ImmutableList.<SourceFile>of(), ImmutableList.of(foo, bar, foo2), options); this.provider = compiler; } public void testExcerptOneLine() throws Exception { assertEquals("foo:first line", provider.getSourceLine("foo", 1)); assertEquals("foo:second line", provider.getSourceLine("foo", 2)); assertEquals("foo:third line", provider.getSourceLine("foo", 3)); assertEquals("bar:first line", provider.getSourceLine("bar", 1)); assertEquals("bar:second line", provider.getSourceLine("bar", 2)); assertEquals("bar:third line", provider.getSourceLine("bar", 3)); assertEquals("bar:fourth line", provider.getSourceLine("bar", 4)); } public void testExcerptLineFromInexistantSource() throws Exception { assertEquals(null, provider.getSourceLine("inexistant", 1)); assertEquals(null, provider.getSourceLine("inexistant", 7)); assertEquals(null, provider.getSourceLine("inexistant", 90)); } public void testExcerptInexistantLine() throws Exception { assertEquals(null, provider.getSourceLine("foo", 0)); assertEquals(null, provider.getSourceLine("foo", 4)); assertEquals(null, provider.getSourceLine("bar", 0)); assertEquals(null, provider.getSourceLine("bar", 5)); } public void testExceptNoNewLine() throws Exception { assertEquals("foo2:first line", provider.getSourceLine("foo2", 1)); assertEquals("foo2:second line", provider.getSourceLine("foo2", 2)); assertEquals("foo2:third line", provider.getSourceLine("foo2", 3)); assertEquals(null, provider.getSourceLine("foo2", 4)); } public void testExcerptRegion() throws Exception { assertRegionWellFormed("foo", 1); assertRegionWellFormed("foo", 2); assertRegionWellFormed("foo", 3); assertRegionWellFormed("bar", 1); assertRegionWellFormed("bar", 2); assertRegionWellFormed("bar", 3); assertRegionWellFormed("bar", 4); } public void testExcerptRegionFromInexistantSource() throws Exception { assertEquals(null, provider.getSourceRegion("inexistant", 0)); assertEquals(null, provider.getSourceRegion("inexistant", 6)); assertEquals(null, provider.getSourceRegion("inexistant", 90)); } public void testExcerptInexistantRegion() throws Exception { assertEquals(null, provider.getSourceRegion("foo", 0)); assertEquals(null, provider.getSourceRegion("foo", 4)); assertEquals(null, provider.getSourceRegion("bar", 0)); assertEquals(null, provider.getSourceRegion("bar", 5)); } /** * Asserts that a region is 'well formed': it must not be an empty and * cannot start or finish by a carriage return. In addition, it must * contain the line whose region we are taking. */ private void assertRegionWellFormed(String sourceName, int lineNumber) { Region region = provider.getSourceRegion(sourceName, lineNumber); assertNotNull(region); String sourceRegion = region.getSourceExcerpt(); assertNotNull(sourceRegion); if (lineNumber == 1) { assertEquals(1, region.getBeginningLineNumber()); } else { assertTrue(region.getBeginningLineNumber() <= lineNumber); } assertTrue(lineNumber <= region.getEndingLineNumber()); assertNotSame(sourceRegion, 0, sourceRegion.length()); assertNotSame(sourceRegion, '\n', sourceRegion.charAt(0)); assertNotSame(sourceRegion, '\n', sourceRegion.charAt(sourceRegion.length() - 1)); String line = provider.getSourceLine(sourceName, lineNumber); assertTrue(sourceRegion, sourceRegion.contains(line)); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.ImmutableList; import com.google.common.collect.Iterables; import com.google.common.collect.Lists; import junit.framework.*; import java.util.*; import org.json.JSONArray; import org.json.JSONException; import org.json.JSONObject; /** * Tests for {@link JSModuleGraph} * */ public class JSModuleGraphTest extends TestCase { private final JSModule A = new JSModule("A"); private final JSModule B = new JSModule("B"); private final JSModule C = new JSModule("C"); private final JSModule D = new JSModule("D"); private final JSModule E = new JSModule("E"); private final JSModule F = new JSModule("F"); private JSModuleGraph graph = null; // For resolving dependencies only. private Compiler compiler; @Override public void setUp() throws Exception { super.setUp(); B.addDependency(A); // __A__ C.addDependency(A); // / | \ D.addDependency(B); // B C | E.addDependency(B); // / \ /| | E.addDependency(C); // D E | / F.addDependency(A); // \|/ F.addDependency(C); // F F.addDependency(E); graph = new JSModuleGraph(new JSModule[] {A, B, C, D, E, F}); compiler = new Compiler(); } public void testModuleDepth() { assertEquals("A should have depth 0", 0, A.getDepth()); assertEquals("B should have depth 1", 1, B.getDepth()); assertEquals("C should have depth 1", 1, C.getDepth()); assertEquals("D should have depth 2", 2, D.getDepth()); assertEquals("E should have depth 2", 2, E.getDepth()); assertEquals("F should have depth 3", 3, F.getDepth()); } public void testDeepestCommonDep() { assertDeepestCommonDep(null, A, A); assertDeepestCommonDep(null, A, B); assertDeepestCommonDep(null, A, C); assertDeepestCommonDep(null, A, D); assertDeepestCommonDep(null, A, E); assertDeepestCommonDep(null, A, F); assertDeepestCommonDep(A, B, B); assertDeepestCommonDep(A, B, C); assertDeepestCommonDep(A, B, D); assertDeepestCommonDep(A, B, E); assertDeepestCommonDep(A, B, F); assertDeepestCommonDep(A, C, C); assertDeepestCommonDep(A, C, D); assertDeepestCommonDep(A, C, E); assertDeepestCommonDep(A, C, F); assertDeepestCommonDep(B, D, D); assertDeepestCommonDep(B, D, E); assertDeepestCommonDep(B, D, F); assertDeepestCommonDep(C, E, E); assertDeepestCommonDep(C, E, F); assertDeepestCommonDep(E, F, F); } public void testDeepestCommonDepInclusive() { assertDeepestCommonDepInclusive(A, A, A); assertDeepestCommonDepInclusive(A, A, B); assertDeepestCommonDepInclusive(A, A, C); assertDeepestCommonDepInclusive(A, A, D); assertDeepestCommonDepInclusive(A, A, E); assertDeepestCommonDepInclusive(A, A, F); assertDeepestCommonDepInclusive(B, B, B); assertDeepestCommonDepInclusive(A, B, C); assertDeepestCommonDepInclusive(B, B, D); assertDeepestCommonDepInclusive(B, B, E); assertDeepestCommonDepInclusive(B, B, F); assertDeepestCommonDepInclusive(C, C, C); assertDeepestCommonDepInclusive(A, C, D); assertDeepestCommonDepInclusive(C, C, E); assertDeepestCommonDepInclusive(C, C, F); assertDeepestCommonDepInclusive(D, D, D); assertDeepestCommonDepInclusive(B, D, E); assertDeepestCommonDepInclusive(B, D, F); assertDeepestCommonDepInclusive(E, E, E); assertDeepestCommonDepInclusive(E, E, F); assertDeepestCommonDepInclusive(F, F, F); } public void testGetTransitiveDepsDeepestFirst() { assertTransitiveDepsDeepestFirst(A); assertTransitiveDepsDeepestFirst(B, A); assertTransitiveDepsDeepestFirst(C, A); assertTransitiveDepsDeepestFirst(D, B, A); assertTransitiveDepsDeepestFirst(E, C, B, A); assertTransitiveDepsDeepestFirst(F, E, C, B, A); } public void testCoalesceDuplicateFiles() { A.add(SourceFile.fromCode("a.js", "")); B.add(SourceFile.fromCode("a.js", "")); B.add(SourceFile.fromCode("b.js", "")); C.add(SourceFile.fromCode("b.js", "")); C.add(SourceFile.fromCode("c.js", "")); E.add(SourceFile.fromCode("c.js", "")); E.add(SourceFile.fromCode("d.js", "")); graph.coalesceDuplicateFiles(); assertEquals(2, A.getInputs().size()); assertEquals("a.js", A.getInputs().get(0).getName()); assertEquals("b.js", A.getInputs().get(1).getName()); assertEquals(0, B.getInputs().size()); assertEquals(1, C.getInputs().size()); assertEquals("c.js", C.getInputs().get(0).getName()); assertEquals(1, E.getInputs().size()); assertEquals("d.js", E.getInputs().get(0).getName()); } public void testManageDependencies1() throws Exception { List<CompilerInput> inputs = setUpManageDependenciesTest(); List<CompilerInput> results = graph.manageDependencies( ImmutableList.<String>of(), inputs); assertInputs(A, "a1", "a3"); assertInputs(B, "a2", "b2"); assertInputs(C); // no inputs assertInputs(E, "c1", "e1", "e2"); assertEquals( Lists.newArrayList("a1", "a3", "a2", "b2", "c1", "e1", "e2"), sourceNames(results)); } public void testManageDependencies2() throws Exception { List<CompilerInput> inputs = setUpManageDependenciesTest(); List<CompilerInput> results = graph.manageDependencies( ImmutableList.<String>of("c2"), inputs); assertInputs(A, "a1", "a3"); assertInputs(B, "a2", "b2"); assertInputs(C, "c1", "c2"); assertInputs(E, "e1", "e2"); assertEquals( Lists.newArrayList("a1", "a3", "a2", "b2", "c1", "c2", "e1", "e2"), sourceNames(results)); } public void testManageDependencies3() throws Exception { List<CompilerInput> inputs = setUpManageDependenciesTest(); DependencyOptions depOptions = new DependencyOptions(); depOptions.setDependencySorting(true); depOptions.setDependencyPruning(true); depOptions.setMoocherDropping(true); depOptions.setEntryPoints(ImmutableList.<String>of("c2")); List<CompilerInput> results = graph.manageDependencies( depOptions, inputs); // Everything gets pushed up into module c, because that's // the only one that has entry points. assertInputs(A); assertInputs(B); assertInputs(C, "a1", "c1", "c2"); assertInputs(E); assertEquals( Lists.newArrayList("a1", "c1", "c2"), sourceNames(results)); } public void testManageDependencies4() throws Exception { setUpManageDependenciesTest(); DependencyOptions depOptions = new DependencyOptions(); depOptions.setDependencySorting(true); List<CompilerInput> inputs = Lists.newArrayList(); // Add the inputs in a random order. inputs.addAll(E.getInputs()); inputs.addAll(B.getInputs()); inputs.addAll(A.getInputs()); inputs.addAll(C.getInputs()); List<CompilerInput> results = graph.manageDependencies( depOptions, inputs); assertInputs(A, "a1", "a2", "a3"); assertInputs(B, "b1", "b2"); assertInputs(C, "c1", "c2"); assertInputs(E, "e1", "e2"); assertEquals( Lists.newArrayList( "a1", "a2", "a3", "b1", "b2", "c1", "c2", "e1", "e2"), sourceNames(results)); } public void testNoFiles() throws Exception { DependencyOptions depOptions = new DependencyOptions(); depOptions.setDependencySorting(true); List<CompilerInput> inputs = Lists.newArrayList(); List<CompilerInput> results = graph.manageDependencies( depOptions, inputs); assertTrue(results.isEmpty()); } public void testToJson() throws JSONException { JSONArray modules = graph.toJson(); assertEquals(6, modules.length()); for (int i = 0; i < modules.length(); i++) { JSONObject m = modules.getJSONObject(i); assertNotNull(m.getString("name")); assertNotNull(m.getJSONArray("dependencies")); assertNotNull(m.getJSONArray("transitive-dependencies")); assertNotNull(m.getJSONArray("inputs")); } JSONObject m = modules.getJSONObject(3); assertEquals("D", m.getString("name")); assertEquals("[\"B\"]", m.getJSONArray("dependencies").toString()); assertEquals(2, m.getJSONArray("transitive-dependencies").length()); assertEquals("[]", m.getJSONArray("inputs").toString()); } private List<CompilerInput> setUpManageDependenciesTest() { List<CompilerInput> inputs = Lists.newArrayList(); A.add(code("a1", provides("a1"), requires())); A.add(code("a2", provides("a2"), requires("a1"))); A.add(code("a3", provides(), requires("a1"))); B.add(code("b1", provides("b1"), requires("a2"))); B.add(code("b2", provides(), requires("a1", "a2"))); C.add(code("c1", provides("c1"), requires("a1"))); C.add(code("c2", provides("c2"), requires("c1"))); E.add(code("e1", provides(), requires("c1"))); E.add(code("e2", provides(), requires("c1"))); inputs.addAll(A.getInputs()); inputs.addAll(B.getInputs()); inputs.addAll(C.getInputs()); inputs.addAll(E.getInputs()); for (CompilerInput input : inputs) { input.setCompiler(compiler); } return inputs; } private void assertInputs(JSModule module, String ... sourceNames) { List<CompilerInput> actualInputs = module.getInputs(); assertEquals( Lists.newArrayList(sourceNames), sourceNames(module.getInputs())); } private List<String> sourceNames(List<CompilerInput> inputs) { List<String> inputNames = Lists.newArrayList(); for (CompilerInput input : inputs) { inputNames.add(input.getName()); } return inputNames; } private SourceFile code( String sourceName, List<String> provides, List<String> requires) { String text = ""; for (String p : provides) { text += "goog.provide('" + p + "');\n"; } for (String r : requires) { text += "goog.require('" + r + "');\n"; } return SourceFile.fromCode(sourceName, text); } private List<String> provides(String ... strings) { return Lists.newArrayList(strings); } private List<String> requires(String ... strings) { return Lists.newArrayList(strings); } private void assertDeepestCommonDepInclusive( JSModule expected, JSModule m1, JSModule m2) { assertDeepestCommonDepOneWay(expected, m1, m2, true); assertDeepestCommonDepOneWay(expected, m2, m1, true); } private void assertDeepestCommonDep( JSModule expected, JSModule m1, JSModule m2) { assertDeepestCommonDepOneWay(expected, m1, m2, false); assertDeepestCommonDepOneWay(expected, m2, m1, false); } private void assertDeepestCommonDepOneWay( JSModule expected, JSModule m1, JSModule m2, boolean inclusive) { JSModule actual = inclusive ? graph.getDeepestCommonDependencyInclusive(m1, m2) : graph.getDeepestCommonDependency(m1, m2); if (actual != expected) { fail(String.format( "Deepest common dep of %s and %s should be %s but was %s", m1.getName(), m2.getName(), expected == null ? "null" : expected.getName(), actual == null ? "null" : actual.getName())); } } private void assertTransitiveDepsDeepestFirst(JSModule m, JSModule... deps) { Iterable<JSModule> actual = graph.getTransitiveDepsDeepestFirst(m); assertEquals(Arrays.toString(deps), Arrays.toString(Iterables.toArray(actual, JSModule.class))); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.ImmutableList; import com.google.common.collect.ImmutableSet; import junit.framework.TestCase; import java.util.Arrays; import java.util.List; import java.util.ArrayList; /** * Tests for {@link JSModule} * */ public class JSModuleTest extends TestCase { private JSModule mod1; private JSModule mod2; // depends on mod1 private JSModule mod3; // depends on mod1 private JSModule mod4; // depends on mod2, mod3 private JSModule mod5; // depends on mod1 @Override protected void setUp() { List<JSModule> modulesInDepOrder = new ArrayList<JSModule>(); mod1 = new JSModule("mod1"); modulesInDepOrder.add(mod1); mod2 = new JSModule("mod2"); mod2.addDependency(mod1); modulesInDepOrder.add(mod2); mod3 = new JSModule("mod3"); mod3.addDependency(mod1); modulesInDepOrder.add(mod3); mod4 = new JSModule("mod4"); mod4.addDependency(mod2); mod4.addDependency(mod3); modulesInDepOrder.add(mod4); mod5 = new JSModule("mod5"); mod5.addDependency(mod1); modulesInDepOrder.add(mod5); } public void testDependencies() { assertEquals(ImmutableSet.of(), mod1.getAllDependencies()); assertEquals(ImmutableSet.of(mod1), mod2.getAllDependencies()); assertEquals(ImmutableSet.of(mod1), mod3.getAllDependencies()); assertEquals(ImmutableSet.of(mod1, mod2, mod3), mod4.getAllDependencies()); assertEquals(ImmutableSet.of(mod1), mod1.getThisAndAllDependencies()); assertEquals(ImmutableSet.of(mod1, mod2), mod2.getThisAndAllDependencies()); assertEquals(ImmutableSet.of(mod1, mod3), mod3.getThisAndAllDependencies()); assertEquals(ImmutableSet.of(mod1, mod2, mod3, mod4), mod4.getThisAndAllDependencies()); } public void testSortInputs() throws Exception { CompilerInput a = new CompilerInput( SourceFile.fromCode("a.js", "goog.require('b');goog.require('c')")); CompilerInput b = new CompilerInput( SourceFile.fromCode("b.js", "goog.provide('b');goog.require('d')")); CompilerInput c = new CompilerInput( SourceFile.fromCode("c.js", "goog.provide('c');goog.require('d')")); CompilerInput d = new CompilerInput( SourceFile.fromCode("d.js", "goog.provide('d')")); // Independent modules. CompilerInput e = new CompilerInput( SourceFile.fromCode("e.js", "goog.provide('e')")); CompilerInput f = new CompilerInput( SourceFile.fromCode("f.js", "goog.provide('f')")); assertSortedInputs( ImmutableList.of(d, b, c, a), ImmutableList.of(a, b, c, d)); assertSortedInputs( ImmutableList.of(d, b, c, a), ImmutableList.of(d, b, c, a)); assertSortedInputs( ImmutableList.of(d, c, b, a), ImmutableList.of(d, c, b, a)); assertSortedInputs( ImmutableList.of(d, b, c, a), ImmutableList.of(d, a, b, c)); } private void assertSortedInputs( List<CompilerInput> expected, List<CompilerInput> shuffled) throws Exception { JSModule mod = new JSModule("mod"); for (CompilerInput input : shuffled) { input.setModule(null); mod.add(input); } Compiler compiler = new Compiler(System.err); compiler.initCompilerOptionsIfTesting(); mod.sortInputsByDeps(compiler); assertEquals(expected, mod.getInputs()); } public void testSortJsModules() throws Exception { // already in order: assertEquals(ImmutableList.of(mod1, mod2, mod3, mod4), Arrays.asList(JSModule.sortJsModules( ImmutableList.of(mod1, mod2, mod3, mod4)))); assertEquals(ImmutableList.of(mod1, mod3, mod2, mod4), Arrays.asList(JSModule.sortJsModules( ImmutableList.of(mod1, mod3, mod2, mod4)))); // one out of order: assertEquals(ImmutableList.of(mod1, mod3, mod2, mod4), Arrays.asList(JSModule.sortJsModules( ImmutableList.of(mod4, mod3, mod2, mod1)))); assertEquals(ImmutableList.of(mod1, mod3, mod2, mod4), Arrays.asList(JSModule.sortJsModules( ImmutableList.of(mod3, mod1, mod2, mod4)))); // more out of order: assertEquals(ImmutableList.of(mod1, mod3, mod2, mod4), Arrays.asList(JSModule.sortJsModules( ImmutableList.of(mod4, mod3, mod1, mod2)))); } }
/* * Copyright 2004 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import static com.google.javascript.jscomp.JsMessage.Style.RELAX; import com.google.common.base.Joiner; import com.google.common.collect.Lists; import junit.framework.TestCase; import java.io.IOException; import java.util.Collection; import java.util.Iterator; import java.util.List; /** * Unit test for {@link JsMessageExtractor}. * */ public class JsMessageExtractorTest extends TestCase { private Collection<JsMessage> extractMessages(String... js) { try { String sourceCode = Joiner.on("\n").join(js); return new JsMessageExtractor(null, RELAX) .extractMessages(SourceFile.fromCode("testcode", sourceCode)); } catch (IOException e) { fail(e.getMessage()); return null; } } private JsMessage extractMessage(String... js) { Collection<JsMessage> messages = extractMessages(js); assertEquals(1, messages.size()); return messages.iterator().next(); } public void testSyntaxError1() { try { extractMessage("if (true) {}}"); fail("Expected exception"); } catch (RuntimeException e) { assertTrue(e.getMessage().contains("JSCompiler errors\n")); assertTrue(e.getMessage().contains( "testcode:1: ERROR - Parse error. syntax error\n")); assertTrue(e.getMessage().contains("if (true) {}}\n")); } } public void testSyntaxError2() { try { extractMessage("", "if (true) {}}"); fail("Expected exception"); } catch (RuntimeException e) { assertTrue( e.getMessage(), e.getMessage().contains("JSCompiler errors\n")); assertTrue( e.getMessage(), e.getMessage().contains( "testcode:2: ERROR - Parse error. syntax error\n")); assertTrue( e.getMessage(), e.getMessage().contains("if (true) {}}\n")); } } public void testExtractNewStyleMessage1() { // A simple message with no description. assertEquals( new JsMessage.Builder("MSG_SILLY") .appendStringPart("silly test message") .build(), extractMessage("var MSG_SILLY = goog.getMsg('silly test message');")); } public void testExtractNewStyleMessage2() { // A message with placeholders and meta data. assertEquals( new JsMessage.Builder("MSG_WELCOME") .appendStringPart("Hi ") .appendPlaceholderReference("userName") .appendStringPart("! Welcome to ") .appendPlaceholderReference("product") .appendStringPart(".") .setDesc("The welcome message.") .setIsHidden(true) .build(), extractMessage( "/**", " * @desc The welcome", " * message.", " *", " * @hidden", " */", "var MSG_WELCOME = goog.getMsg(", " 'Hi {$userName}! Welcome to {$product}.',", " {userName: someUserName, product: getProductName()});")); } public void testExtractOldStyleMessage1() { // Description before the message. assertEquals( new JsMessage.Builder("MSG_SILLY") .appendStringPart("silly test message") .setDesc("Description.") .build(), extractMessage( "var MSG_SILLY_HELP = 'Description.';", "var MSG_SILLY = 'silly test message';")); } public void testExtractOldStyleMessage2() { // Description after the message, broken into parts. assertEquals( new JsMessage.Builder("MSG_SILLY") .appendStringPart("silly test message") .setDesc("Description.") .build(), extractMessage( "var MSG_SILLY = 'silly test message';", "var MSG_SILLY_HELP = 'Descrip' + 'tion.';")); } public void testExtractOldStyleMessage3() { // Function-style message with two placeholders and no description. assertEquals( new JsMessage.Builder("MSG_SILLY") .appendPlaceholderReference("one") .appendStringPart(", ") .appendPlaceholderReference("two") .appendStringPart(", buckle my shoe") .build(), extractMessage( "var MSG_SILLY = function(one, two) {", " return one + ', ' + two + ', buckle my shoe';", "};")); } public void testExtractMixedMessages() { // Several mixed-style messages in succession, one containing newlines. Iterator<JsMessage> msgs = extractMessages( "var MSG_MONEY = function(amount) {", " return 'You owe $' + amount +", " ' to the credit card company.';", "};", "var MSG_TIME = goog.getMsg('You need to finish your work in ' +", " '{$duration} hours.', {'duration': d});", "var MSG_NAG = 'Clean your room.\\n\\nWash your clothes.';", "var MSG_NAG_HELP = 'Just some ' +", " 'nags.';").iterator(); assertEquals( new JsMessage.Builder("MSG_MONEY") .appendStringPart("You owe $") .appendPlaceholderReference("amount") .appendStringPart(" to the credit card company.") .build(), msgs.next()); assertEquals( new JsMessage.Builder("MSG_TIME") .appendStringPart("You need to finish your work in ") .appendPlaceholderReference("duration") .appendStringPart(" hours.") .build(), msgs.next()); assertEquals( new JsMessage.Builder("MSG_NAG") .appendStringPart("Clean your room.\n\nWash your clothes.") .setDesc("Just some nags.") .build(), msgs.next()); } public void testDuplicateUnnamedVariables() { // Make sure that duplicate unnamed variables don't get swallowed when using // a Google-specific ID generator. Collection<JsMessage> msgs = extractMessages( "function a() {", " var MSG_UNNAMED_2 = goog.getMsg('foo');", "}", "function b() {", " var MSG_UNNAMED_2 = goog.getMsg('bar');", "}"); assertEquals(2, msgs.size()); final Iterator<JsMessage> iter = msgs.iterator(); assertEquals("foo", iter.next().toString()); assertEquals("bar", iter.next().toString()); } public void testMeaningAnnotation() { List<JsMessage> msgs = Lists.newArrayList( extractMessages( "var MSG_UNNAMED_1 = goog.getMsg('foo');", "var MSG_UNNAMED_2 = goog.getMsg('foo');")); assertEquals(2, msgs.size()); assertTrue(msgs.get(0).getId().equals(msgs.get(1).getId())); assertEquals(msgs.get(0), msgs.get(1)); msgs = Lists.newArrayList( extractMessages( "var MSG_UNNAMED_1 = goog.getMsg('foo');", "/** @meaning bar */ var MSG_UNNAMED_2 = goog.getMsg('foo');")); assertEquals(2, msgs.size()); assertFalse(msgs.get(0).getId().equals(msgs.get(1).getId())); } private void assertEquals(JsMessage expected, JsMessage actual) { assertEquals(expected.getId(), actual.getId()); assertEquals(expected.getKey(), actual.getKey()); assertEquals(expected.parts(), actual.parts()); assertEquals(expected.placeholders(), actual.placeholders()); assertEquals(expected.getDesc(), actual.getDesc()); assertEquals(expected.isHidden(), actual.isHidden()); assertEquals(expected.getMeaning(), actual.getMeaning()); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import junit.framework.*; /** * @author anatol@google.com (Anatol Pomazau) */ public class JsMessageTest extends TestCase { public void testIsEmpty() { assertTrue(new JsMessage.Builder().build().isEmpty()); assertTrue(new JsMessage.Builder().appendStringPart("").build().isEmpty()); assertTrue(new JsMessage.Builder().appendStringPart("") .appendStringPart("").build().isEmpty()); assertFalse(new JsMessage.Builder().appendStringPart("s") .appendStringPart("").build().isEmpty()); assertFalse(new JsMessage.Builder().appendPlaceholderReference("3") .build().isEmpty()); } public void testMeaningChangesId() { String id1 = new JsMessage.Builder() .appendStringPart("foo").build().getId(); String id2 = new JsMessage.Builder() .appendStringPart("foo").setMeaning("bar").build().getId(); assertFalse(id1.equals(id2)); } public void testHashValues() { final String EMPTY = ""; final String VAL = "Hello, world"; final long ANSWER_STRING_64 = 0x43ec5d9731515874L; final long ANSWER_EMPTY_64 = 0x468d9ea2c42361aaL; assertEquals(ANSWER_STRING_64, JsMessage.Hash.hash64(VAL)); assertEquals(ANSWER_EMPTY_64, JsMessage.Hash.hash64(EMPTY)); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.base.Joiner; import com.google.common.collect.Lists; import static com.google.javascript.jscomp.JsMessage.Style; import static com.google.javascript.jscomp.JsMessage.Style.CLOSURE; import static com.google.javascript.jscomp.JsMessage.Style.LEGACY; import static com.google.javascript.jscomp.JsMessage.Style.RELAX; import static com.google.javascript.jscomp.JsMessageVisitor.isLowerCamelCaseWithNumericSuffixes; import static com.google.javascript.jscomp.JsMessageVisitor.toLowerCamelCaseWithNumericSuffixes; import com.google.javascript.rhino.Node; import junit.framework.TestCase; import java.util.List; /** * Test for {@link JsMessageVisitor}. * * @author anatol@google.com (Anatol Pomazau) */ public class JsMessageVisitorTest extends TestCase { private Compiler compiler; private List<JsMessage> messages; private boolean allowLegacyMessages; @Override protected void setUp() throws Exception { messages = Lists.newLinkedList(); allowLegacyMessages = true; } public void testJsMessageOnVar() { extractMessagesSafely( "/** @desc Hello */ var MSG_HELLO = goog.getMsg('a')"); assertEquals(0, compiler.getWarningCount()); assertEquals(1, messages.size()); JsMessage msg = messages.get(0); assertEquals("MSG_HELLO", msg.getKey()); assertEquals("Hello", msg.getDesc()); } public void testJsMessageOnProperty() { extractMessagesSafely("/** @desc a */ " + "pint.sub.MSG_MENU_MARK_AS_UNREAD = goog.getMsg('a')"); assertEquals(0, compiler.getWarningCount()); assertEquals(1, messages.size()); JsMessage msg = messages.get(0); assertEquals("MSG_MENU_MARK_AS_UNREAD", msg.getKey()); assertEquals("a", msg.getDesc()); } public void testOrphanedJsMessage() { extractMessagesSafely("goog.getMsg('a')"); assertEquals(1, compiler.getWarningCount()); assertEquals(0, messages.size()); JSError warn = compiler.getWarnings()[0]; assertEquals(JsMessageVisitor.MESSAGE_NODE_IS_ORPHANED, warn.getType()); } public void testMessageWithoutDescription() { extractMessagesSafely("var MSG_HELLO = goog.getMsg('a')"); assertEquals(1, compiler.getWarningCount()); assertEquals(1, messages.size()); JsMessage msg = messages.get(0); assertEquals("MSG_HELLO", msg.getKey()); assertEquals(JsMessageVisitor.MESSAGE_HAS_NO_DESCRIPTION, compiler.getWarnings()[0].getType()); } public void testIncorrectMessageReporting() { extractMessages("var MSG_HELLO = goog.getMsg('a' + + 'b')"); assertEquals(1, compiler.getErrorCount()); assertEquals(0, compiler.getWarningCount()); assertEquals(0, messages.size()); JSError mailformedTreeError = compiler.getErrors()[0]; assertEquals(JsMessageVisitor.MESSAGE_TREE_MALFORMED, mailformedTreeError.getType()); assertEquals("Message parse tree malformed. " + "STRING or ADD node expected; found: POS", mailformedTreeError.description); } public void testEmptyMessage() { // This is an edge case. Empty messages are useless, but shouldn't fail extractMessagesSafely("var MSG_EMPTY = '';"); assertEquals(1, messages.size()); JsMessage msg = messages.get(0); assertEquals("MSG_EMPTY", msg.getKey()); assertEquals("", msg.toString()); } public void testConcatOfStrings() { extractMessagesSafely("var MSG_NOTEMPTY = 'aa' + 'bbb' \n + ' ccc';"); assertEquals(1, messages.size()); JsMessage msg = messages.get(0); assertEquals("MSG_NOTEMPTY", msg.getKey()); assertEquals("aabbb ccc", msg.toString()); } public void testLegacyFormatDescription() { extractMessagesSafely("var MSG_SILLY = 'silly test message';\n" + "var MSG_SILLY_HELP = 'help text';"); assertEquals(1, messages.size()); JsMessage msg = messages.get(0); assertEquals("MSG_SILLY", msg.getKey()); assertEquals("help text", msg.getDesc()); assertEquals("silly test message", msg.toString()); } public void testLegacyFormatParametizedFunction() { extractMessagesSafely("var MSG_SILLY = function(one, two) {" + " return one + ', ' + two + ', buckle my shoe';" + "};"); assertEquals(1, messages.size()); JsMessage msg = messages.get(0); assertEquals("MSG_SILLY", msg.getKey()); assertEquals(null, msg.getDesc()); assertEquals("{$one}, {$two}, buckle my shoe", msg.toString()); } public void testLegacyMessageWithDescAnnotation() { // Well, is was better do not allow legacy messages with @desc annotations, // but people love to mix styles so we need to check @desc also. extractMessagesSafely( "/** @desc The description */ var MSG_A = 'The Message';"); assertEquals(1, messages.size()); assertEquals(1, compiler.getWarningCount()); JsMessage msg = messages.get(0); assertEquals("MSG_A", msg.getKey()); assertEquals("The Message", msg.toString()); assertEquals("The description", msg.getDesc()); } public void testLegacyMessageWithDescAnnotationAndHelpVar() { // Well, is was better do not allow legacy messages with @desc annotations, // but people love to mix styles so we need to check @desc also. extractMessagesSafely( "var MSG_A_HELP = 'This is a help var';\n" + "/** @desc The description in @desc*/ var MSG_A = 'The Message';"); assertEquals(1, messages.size()); assertEquals(1, compiler.getWarningCount()); JsMessage msg = messages.get(0); assertEquals("MSG_A", msg.getKey()); assertEquals("The Message", msg.toString()); assertEquals("The description in @desc", msg.getDesc()); } public void testClosureMessageWithHelpPostfix() { extractMessagesSafely("/** @desc help text */\n" + "var MSG_FOO_HELP = goog.getMsg('Help!');"); assertEquals(1, messages.size()); JsMessage msg = messages.get(0); assertEquals("MSG_FOO_HELP", msg.getKey()); assertEquals("help text", msg.getDesc()); assertEquals("Help!", msg.toString()); } public void testClosureMessageWithoutGoogGetmsg() { allowLegacyMessages = false; extractMessages("var MSG_FOO_HELP = 'I am a bad message';"); assertEquals(1, messages.size()); assertEquals(1, compiler.getErrors().length); JSError error = compiler.getErrors()[0]; assertEquals(JsMessageVisitor.MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX, error.getType()); } public void testClosureFormatParametizedFunction() { extractMessagesSafely("/** @desc help text */" + "var MSG_SILLY = goog.getMsg('{$adjective} ' + 'message', " + "{'adjective': 'silly'});"); assertEquals(1, messages.size()); JsMessage msg = messages.get(0); assertEquals("MSG_SILLY", msg.getKey()); assertEquals("help text", msg.getDesc()); assertEquals("{$adjective} message", msg.toString()); } public void testHugeMessage() { extractMessagesSafely("/**" + " * @desc A message with lots of stuff.\n" + " * @hidden\n" + " */" + "var MSG_HUGE = goog.getMsg(" + " '{$startLink_1}Google{$endLink}' +" + " '{$startLink_2}blah{$endLink}{$boo}{$foo_001}{$boo}' +" + " '{$foo_002}{$xxx_001}{$image}{$image_001}{$xxx_002}'," + " {'startLink_1': '<a href=http://www.google.com/>'," + " 'endLink': '</a>'," + " 'startLink_2': '<a href=\"' + opt_data.url + '\">'," + " 'boo': opt_data.boo," + " 'foo_001': opt_data.foo," + " 'foo_002': opt_data.boo.foo," + " 'xxx_001': opt_data.boo + opt_data.foo," + " 'image': htmlTag7," + " 'image_001': opt_data.image," + " 'xxx_002': foo.callWithOnlyTopLevelKeys(" + " bogusFn, opt_data, null, 'bogusKey1'," + " opt_data.moo, 'bogusKey2', param10)});"); assertEquals(1, messages.size()); JsMessage msg = messages.get(0); assertEquals("MSG_HUGE", msg.getKey()); assertEquals("A message with lots of stuff.", msg.getDesc()); assertTrue(msg.isHidden()); assertEquals("{$startLink_1}Google{$endLink}{$startLink_2}blah{$endLink}" + "{$boo}{$foo_001}{$boo}{$foo_002}{$xxx_001}{$image}" + "{$image_001}{$xxx_002}", msg.toString()); } public void testUnnamedGoogleMessage() { extractMessagesSafely("var MSG_UNNAMED_2 = goog.getMsg('Hullo');"); assertEquals(1, messages.size()); JsMessage msg = messages.get(0); assertEquals(null, msg.getDesc()); assertEquals("MSG_16LJMYKCXT84X", msg.getKey()); assertEquals("MSG_16LJMYKCXT84X", msg.getId()); } public void testEmptyTextMessage() { extractMessagesSafely("/** @desc text */ var MSG_FOO = goog.getMsg('');"); assertEquals(1, messages.size()); assertEquals(1, compiler.getWarningCount()); assertEquals("Message value of MSG_FOO is just an empty string. " + "Empty messages are forbidden.", compiler.getWarnings()[0].description); } public void testEmptyTextComplexMessage() { extractMessagesSafely("/** @desc text */ var MSG_BAR = goog.getMsg(" + "'' + '' + '' + ''\n+'');"); assertEquals(1, messages.size()); assertEquals(1, compiler.getWarningCount()); assertEquals("Message value of MSG_BAR is just an empty string. " + "Empty messages are forbidden.", compiler.getWarnings()[0].description); } public void testMessageIsNoUnnamed() { extractMessagesSafely("var MSG_UNNAMED_ITEM = goog.getMsg('Hullo');"); assertEquals(1, messages.size()); JsMessage msg = messages.get(0); assertEquals("MSG_UNNAMED_ITEM", msg.getKey()); assertFalse(msg.isHidden()); } public void testMsgVarWithoutAssignment() { extractMessages("var MSG_SILLY;"); assertEquals(1, compiler.getErrors().length); JSError error = compiler.getErrors()[0]; assertEquals(JsMessageVisitor.MESSAGE_HAS_NO_VALUE, error.getType()); } public void testRegularVarWithoutAssignment() { extractMessagesSafely("var SILLY;"); assertTrue(messages.isEmpty()); } public void itIsNotImplementedYet_testMsgPropertyWithoutAssignment() { extractMessages("goog.message.MSG_SILLY_PROP;"); assertEquals(1, compiler.getErrors().length); JSError error = compiler.getErrors()[0]; assertEquals("Message MSG_SILLY_PROP has no value", error.description); } public void testMsgVarWithIncorrectRightSide() { extractMessages("var MSG_SILLY = 0;"); assertEquals(1, compiler.getErrors().length); JSError error = compiler.getErrors()[0]; assertEquals("Message parse tree malformed. Cannot parse value of " + "message MSG_SILLY", error.description); } public void testIncorrectMessage() { extractMessages("DP_DatePicker.MSG_DATE_SELECTION = {};"); assertEquals(0, messages.size()); assertEquals(1, compiler.getErrors().length); JSError error = compiler.getErrors()[0]; assertEquals("Message parse tree malformed. "+ "Message must be initialized using goog.getMsg function.", error.description); } public void testUnrecognizedFunction() { allowLegacyMessages = false; extractMessages("DP_DatePicker.MSG_DATE_SELECTION = somefunc('a')"); assertEquals(0, messages.size()); assertEquals(1, compiler.getErrors().length); JSError error = compiler.getErrors()[0]; assertEquals("Message parse tree malformed. "+ "Message initialized using unrecognized function. " + "Please use goog.getMsg() instead.", error.description); } public void testExtractPropertyMessage() { extractMessagesSafely("/**" + " * @desc A message that demonstrates placeholders\n" + " * @hidden\n" + " */" + "a.b.MSG_SILLY = goog.getMsg(\n" + " '{$adjective} ' + '{$someNoun}',\n" + " {'adjective': adj, 'someNoun': noun});"); assertEquals(1, messages.size()); JsMessage msg = messages.get(0); assertEquals("MSG_SILLY", msg.getKey()); assertEquals("{$adjective} {$someNoun}", msg.toString()); assertEquals("A message that demonstrates placeholders", msg.getDesc()); assertTrue(msg.isHidden()); } public void testAlmostButNotExternalMessage() { extractMessagesSafely( "/** @desc External */ var MSG_EXTERNAL = goog.getMsg('External');"); assertEquals(0, compiler.getWarningCount()); assertEquals(1, messages.size()); assertFalse(messages.get(0).isExternal()); assertEquals("MSG_EXTERNAL", messages.get(0).getKey()); } public void testExternalMessage() { extractMessagesSafely("var MSG_EXTERNAL_111 = goog.getMsg('Hello World');"); assertEquals(0, compiler.getWarningCount()); assertEquals(1, messages.size()); assertTrue(messages.get(0).isExternal()); assertEquals("111", messages.get(0).getId()); } public void testIsValidMessageNameStrict() { JsMessageVisitor visitor = new DummyJsVisitor(CLOSURE); assertTrue(visitor.isMessageName("MSG_HELLO", true)); assertTrue(visitor.isMessageName("MSG_", true)); assertTrue(visitor.isMessageName("MSG_HELP", true)); assertTrue(visitor.isMessageName("MSG_FOO_HELP", true)); assertFalse(visitor.isMessageName("_FOO_HELP", true)); assertFalse(visitor.isMessageName("MSGFOOP", true)); } public void testIsValidMessageNameRelax() { JsMessageVisitor visitor = new DummyJsVisitor(RELAX); assertFalse(visitor.isMessageName("MSG_HELP", false)); assertFalse(visitor.isMessageName("MSG_FOO_HELP", false)); } public void testIsValidMessageNameLegacy() { theseAreLegacyMessageNames(new DummyJsVisitor(RELAX)); theseAreLegacyMessageNames(new DummyJsVisitor(LEGACY)); } private void theseAreLegacyMessageNames(JsMessageVisitor visitor) { assertTrue(visitor.isMessageName("MSG_HELLO", false)); assertTrue(visitor.isMessageName("MSG_", false)); assertFalse(visitor.isMessageName("MSG_HELP", false)); assertFalse(visitor.isMessageName("MSG_FOO_HELP", false)); assertFalse(visitor.isMessageName("_FOO_HELP", false)); assertFalse(visitor.isMessageName("MSGFOOP", false)); } public void testUnexistedPlaceholders() { extractMessages("var MSG_FOO = goog.getMsg('{$foo}:', {});"); assertEquals(0, messages.size()); JSError[] errors = compiler.getErrors(); assertEquals(1, errors.length); JSError error = errors[0]; assertEquals(JsMessageVisitor.MESSAGE_TREE_MALFORMED, error.getType()); assertEquals("Message parse tree malformed. Unrecognized message " + "placeholder referenced: foo", error.description); } public void testUnusedReferenesAreNotOK() { extractMessages("/** @desc AA */ " + "var MSG_FOO = goog.getMsg('lalala:', {foo:1});"); assertEquals(0, messages.size()); JSError[] errors = compiler.getErrors(); assertEquals(1, errors.length); JSError error = errors[0]; assertEquals(JsMessageVisitor.MESSAGE_TREE_MALFORMED, error.getType()); assertEquals("Message parse tree malformed. Unused message placeholder: " + "foo", error.description); } public void testDuplicatePlaceHoldersAreBad() { extractMessages("var MSG_FOO = goog.getMsg(" + "'{$foo}:', {'foo': 1, 'foo' : 2});"); assertEquals(0, messages.size()); JSError[] errors = compiler.getErrors(); assertEquals(1, errors.length); JSError error = errors[0]; assertEquals(JsMessageVisitor.MESSAGE_TREE_MALFORMED, error.getType()); assertEquals("Message parse tree malformed. Duplicate placeholder " + "name: foo", error.description); } public void testDuplicatePlaceholderReferencesAreOk() { extractMessagesSafely("var MSG_FOO = goog.getMsg(" + "'{$foo}:, {$foo}', {'foo': 1});"); assertEquals(1, messages.size()); JsMessage msg = messages.get(0); assertEquals("{$foo}:, {$foo}", msg.toString()); } public void testCamelcasePlaceholderNamesAreOk() { extractMessagesSafely("var MSG_WITH_CAMELCASE = goog.getMsg(" + "'Slide {$slideNumber}:', {'slideNumber': opt_index + 1});"); assertEquals(1, messages.size()); JsMessage msg = messages.get(0); assertEquals("MSG_WITH_CAMELCASE", msg.getKey()); assertEquals("Slide {$slideNumber}:", msg.toString()); List<CharSequence> parts = msg.parts(); assertEquals(3, parts.size()); assertEquals("slideNumber", ((JsMessage.PlaceholderReference)parts.get(1)).getName()); } public void testWithNonCamelcasePlaceholderNamesAreNotOk() { extractMessages("var MSG_WITH_CAMELCASE = goog.getMsg(" + "'Slide {$slide_number}:', {'slide_number': opt_index + 1});"); assertEquals(0, messages.size()); JSError[] errors = compiler.getErrors(); assertEquals(1, errors.length); JSError error = errors[0]; assertEquals(JsMessageVisitor.MESSAGE_TREE_MALFORMED, error.getType()); assertEquals("Message parse tree malformed. Placeholder name not in " + "lowerCamelCase: slide_number", error.description); } public void testUnquotedPlaceholdersAreOk() { extractMessagesSafely("/** @desc Hello */ " + "var MSG_FOO = goog.getMsg('foo {$unquoted}:', {unquoted: 12});"); assertEquals(1, messages.size()); assertEquals(0, compiler.getWarningCount()); } public void testIsLowerCamelCaseWithNumericSuffixes() { assertTrue(isLowerCamelCaseWithNumericSuffixes("name")); assertFalse(isLowerCamelCaseWithNumericSuffixes("NAME")); assertFalse(isLowerCamelCaseWithNumericSuffixes("Name")); assertTrue(isLowerCamelCaseWithNumericSuffixes("a4Letter")); assertFalse(isLowerCamelCaseWithNumericSuffixes("A4_LETTER")); assertTrue(isLowerCamelCaseWithNumericSuffixes("startSpan_1_23")); assertFalse(isLowerCamelCaseWithNumericSuffixes("startSpan_1_23b")); assertFalse(isLowerCamelCaseWithNumericSuffixes("START_SPAN_1_23")); assertFalse(isLowerCamelCaseWithNumericSuffixes("")); } public void testToLowerCamelCaseWithNumericSuffixes() { assertEquals("name", toLowerCamelCaseWithNumericSuffixes("NAME")); assertEquals("a4Letter", toLowerCamelCaseWithNumericSuffixes("A4_LETTER")); assertEquals("startSpan_1_23", toLowerCamelCaseWithNumericSuffixes("START_SPAN_1_23")); } public void testDuplicateMessageError() { extractMessages( "(function () {/** @desc Hello */ var MSG_HELLO = goog.getMsg('a')})" + "(function () {/** @desc Hello2 */ var MSG_HELLO = goog.getMsg('a')})"); assertEquals(0, compiler.getWarningCount()); assertOneError(JsMessageVisitor.MESSAGE_DUPLICATE_KEY); } public void testNoDuplicateErrorOnExternMessage() { extractMessagesSafely( "(function () {/** @desc Hello */ " + "var MSG_EXTERNAL_2 = goog.getMsg('a')})" + "(function () {/** @desc Hello2 */ " + "var MSG_EXTERNAL_2 = goog.getMsg('a')})"); } public void testErrorWhenUsingMsgPrefixWithFallback() { extractMessages( "/** @desc Hello */ var MSG_HELLO_1 = goog.getMsg('hello');\n" + "/** @desc Hello */ var MSG_HELLO_2 = goog.getMsg('hello');\n" + "/** @desc Hello */ " + "var MSG_HELLO_3 = goog.getMsgWithFallback(MSG_HELLO_1, MSG_HELLO_2);"); assertOneError(JsMessageVisitor.MESSAGE_TREE_MALFORMED); } private void assertOneError(DiagnosticType type) { String errors = Joiner.on("\n").join(compiler.getErrors()); assertEquals("There should be one error. " + errors, 1, compiler.getErrorCount()); JSError error = compiler.getErrors()[0]; assertEquals(type, error.getType()); } private void extractMessagesSafely(String input) { extractMessages(input); JSError[] errors = compiler.getErrors(); assertEquals( "Unexpected error(s): " + Joiner.on("\n").join(compiler.getErrors()), 0, compiler.getErrorCount()); } private void extractMessages(String input) { compiler = new Compiler(); Node root = compiler.parseTestCode(input); JsMessageVisitor visitor = new CollectMessages(compiler); visitor.process(null, root); } private class CollectMessages extends JsMessageVisitor { private CollectMessages(Compiler compiler) { super(compiler, true, Style.getFromParams(true, allowLegacyMessages), null); } @Override protected void processJsMessage(JsMessage message, JsMessageDefinition definition) { messages.add(message); } } private class DummyJsVisitor extends JsMessageVisitor { private DummyJsVisitor(Style style) { super(null, true, style, null); } @Override protected void processJsMessage(JsMessage message, JsMessageDefinition definition) { // no-op } } }
/* * Copyright 2007 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import static com.google.javascript.jscomp.LightweightMessageFormatter.LineNumberingFormatter; import com.google.javascript.rhino.Node; import junit.framework.TestCase; public class LightweightMessageFormatterTest extends TestCase { private static final DiagnosticType FOO_TYPE = DiagnosticType.error("TEST_FOO", "error description here"); public void testNull() throws Exception { assertNull(format(null)); } public void testOneLineRegion() throws Exception { assertEquals(" 5| hello world", format(region(5, 5, "hello world"))); } public void testTwoLineRegion() throws Exception { assertEquals(" 5| hello world\n" + " 6| foo bar", format(region(5, 6, "hello world\nfoo bar"))); } public void testThreeLineRegionAcrossNumberRange() throws Exception { String region = format(region(9, 11, "hello world\nfoo bar\nanother one")); assertEquals(" 9| hello world\n" + " 10| foo bar\n" + " 11| another one", region); } public void testThreeLineRegionEmptyLine() throws Exception { String region = format(region(7, 9, "hello world\n\nanother one")); assertEquals(" 7| hello world\n" + " 8| \n" + " 9| another one", region); } public void testOnlyOneEmptyLine() throws Exception { assertNull(format(region(7, 7, ""))); } public void testTwoEmptyLines() throws Exception { assertEquals(" 7| ", format(region(7, 8, "\n"))); } public void testThreeLineRemoveLastEmptyLine() throws Exception { String region = format(region(7, 9, "hello world\nfoobar\n")); assertEquals(" 7| hello world\n" + " 8| foobar", region); } public void testFormatErrorSpaces() throws Exception { JSError error = JSError.make("javascript/complex.js", Node.newString("foobar", 5, 8), FOO_TYPE); LightweightMessageFormatter formatter = formatter(" if (foobar) {"); assertEquals("javascript/complex.js:5: ERROR - error description here\n" + " if (foobar) {\n" + " ^\n", formatter.formatError(error)); } public void testFormatErrorTabs() throws Exception { JSError error = JSError.make("javascript/complex.js", Node.newString("foobar", 5, 6), FOO_TYPE); LightweightMessageFormatter formatter = formatter("\t\tif (foobar) {"); assertEquals("javascript/complex.js:5: ERROR - error description here\n" + "\t\tif (foobar) {\n" + "\t\t ^\n", formatter.formatError(error)); } public void testFormatErrorSpaceEndOfLine1() throws Exception { JSError error = JSError.make("javascript/complex.js", 1, 10, FOO_TYPE); LightweightMessageFormatter formatter = formatter("assert (1;"); assertEquals("javascript/complex.js:1: ERROR - error description here\n" + "assert (1;\n" + " ^\n", formatter.formatError(error)); } public void testFormatErrorSpaceEndOfLine2() throws Exception { JSError error = JSError.make("javascript/complex.js", 6, 7, FOO_TYPE); LightweightMessageFormatter formatter = formatter("if (foo"); assertEquals("javascript/complex.js:6: ERROR - error description here\n" + "if (foo\n" + " ^\n", formatter.formatError(error)); } private LightweightMessageFormatter formatter(String string) { return new LightweightMessageFormatter(source(string)); } private SourceExcerptProvider source(final String source) { return new SourceExcerptProvider() { @Override public String getSourceLine(String sourceName, int lineNumber) { return source; } @Override public Region getSourceRegion(String sourceName, int lineNumber) { throw new UnsupportedOperationException(); } }; } private String format(Region region) { return new LineNumberingFormatter().formatRegion(region); } private Region region(final int startLine, final int endLine, final String source) { return new SimpleRegion(startLine, endLine, source); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.Lists; import com.google.javascript.jscomp.type.FlowScope; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.JSType; /** * Tests for LinkedFlowScope. * @author nicksantos@google.com (Nick Santos) */ public class LinkedFlowScopeTest extends CompilerTypeTestCase { private final Node blockNode = new Node(Token.BLOCK); private final Node functionNode = new Node(Token.FUNCTION); private final int LONG_CHAIN_LENGTH = 1050; private Scope globalScope; private Scope localScope; @SuppressWarnings("unused") private FlowScope globalEntry; private FlowScope localEntry; @Override public void setUp() throws Exception { super.setUp(); globalScope = Scope.createGlobalScope(blockNode); globalScope.declare("globalA", null, null, null); globalScope.declare("globalB", null, null, null); localScope = new Scope(globalScope, functionNode); localScope.declare("localA", null, null, null); localScope.declare("localB", null, null, null); globalEntry = LinkedFlowScope.createEntryLattice(globalScope); localEntry = LinkedFlowScope.createEntryLattice(localScope); } public void testOptimize() { assertEquals(localEntry, localEntry.optimize()); FlowScope child = localEntry.createChildFlowScope(); assertEquals(localEntry, child.optimize()); child.inferSlotType("localB", NUMBER_TYPE); assertEquals(child, child.optimize()); } public void testJoin1() { FlowScope childA = localEntry.createChildFlowScope(); childA.inferSlotType("localB", NUMBER_TYPE); FlowScope childAB = childA.createChildFlowScope(); childAB.inferSlotType("localB", STRING_TYPE); FlowScope childB = localEntry.createChildFlowScope(); childB.inferSlotType("localB", BOOLEAN_TYPE); assertTypeEquals(STRING_TYPE, childAB.getSlot("localB").getType()); assertTypeEquals(BOOLEAN_TYPE, childB.getSlot("localB").getType()); assertNull(childB.getSlot("localA").getType()); FlowScope joined = join(childB, childAB); assertTypeEquals(createUnionType(STRING_TYPE, BOOLEAN_TYPE), joined.getSlot("localB").getType()); assertNull(joined.getSlot("localA").getType()); joined = join(childAB, childB); assertTypeEquals(createUnionType(STRING_TYPE, BOOLEAN_TYPE), joined.getSlot("localB").getType()); assertNull(joined.getSlot("localA").getType()); assertEquals("Join should be symmetric", join(childB, childAB), join(childAB, childB)); } public void testJoin2() { FlowScope childA = localEntry.createChildFlowScope(); childA.inferSlotType("localA", STRING_TYPE); FlowScope childB = localEntry.createChildFlowScope(); childB.inferSlotType("globalB", BOOLEAN_TYPE); assertTypeEquals(STRING_TYPE, childA.getSlot("localA").getType()); assertTypeEquals(BOOLEAN_TYPE, childB.getSlot("globalB").getType()); assertNull(childB.getSlot("localB").getType()); FlowScope joined = join(childB, childA); assertTypeEquals(STRING_TYPE, joined.getSlot("localA").getType()); assertTypeEquals(BOOLEAN_TYPE, joined.getSlot("globalB").getType()); joined = join(childA, childB); assertTypeEquals(STRING_TYPE, joined.getSlot("localA").getType()); assertTypeEquals(BOOLEAN_TYPE, joined.getSlot("globalB").getType()); assertEquals("Join should be symmetric", join(childB, childA), join(childA, childB)); } public void testJoin3() { localScope.declare("localC", null, STRING_TYPE, null); localScope.declare("localD", null, STRING_TYPE, null); FlowScope childA = localEntry.createChildFlowScope(); childA.inferSlotType("localC", NUMBER_TYPE); FlowScope childB = localEntry.createChildFlowScope(); childA.inferSlotType("localD", BOOLEAN_TYPE); FlowScope joined = join(childB, childA); assertTypeEquals(createUnionType(STRING_TYPE, NUMBER_TYPE), joined.getSlot("localC").getType()); assertTypeEquals(createUnionType(STRING_TYPE, BOOLEAN_TYPE), joined.getSlot("localD").getType()); joined = join(childA, childB); assertTypeEquals(createUnionType(STRING_TYPE, NUMBER_TYPE), joined.getSlot("localC").getType()); assertTypeEquals(createUnionType(STRING_TYPE, BOOLEAN_TYPE), joined.getSlot("localD").getType()); assertEquals("Join should be symmetric", join(childB, childA), join(childA, childB)); } /** * Create a long chain of flow scopes where each link in the chain * contains one slot. */ public void testLongChain1() { FlowScope chainA = localEntry.createChildFlowScope(); FlowScope chainB = localEntry.createChildFlowScope(); for (int i = 0; i < LONG_CHAIN_LENGTH; i++) { localScope.declare("local" + i, null, null, null); chainA.inferSlotType("local" + i, i % 2 == 0 ? NUMBER_TYPE : BOOLEAN_TYPE); chainB.inferSlotType("local" + i, i % 3 == 0 ? STRING_TYPE : BOOLEAN_TYPE); chainA = chainA.createChildFlowScope(); chainB = chainB.createChildFlowScope(); } verifyLongChains(chainA, chainB); } /** * Create a long chain of flow scopes where each link in the chain * contains 7 slots. */ public void testLongChain2() { FlowScope chainA = localEntry.createChildFlowScope(); FlowScope chainB = localEntry.createChildFlowScope(); for (int i = 0; i < LONG_CHAIN_LENGTH * 7; i++) { localScope.declare("local" + i, null, null, null); chainA.inferSlotType("local" + i, i % 2 == 0 ? NUMBER_TYPE : BOOLEAN_TYPE); chainB.inferSlotType("local" + i, i % 3 == 0 ? STRING_TYPE : BOOLEAN_TYPE); if (i % 7 == 0) { chainA = chainA.createChildFlowScope(); chainB = chainB.createChildFlowScope(); } } verifyLongChains(chainA, chainB); } /** * Create a long chain of flow scopes where every 4 links in the chain * contain a slot. */ public void testLongChain3() { FlowScope chainA = localEntry.createChildFlowScope(); FlowScope chainB = localEntry.createChildFlowScope(); for (int i = 0; i < LONG_CHAIN_LENGTH * 7; i++) { if (i % 7 == 0) { int j = i / 7; localScope.declare("local" + j, null, null, null); chainA.inferSlotType("local" + j, j % 2 == 0 ? NUMBER_TYPE : BOOLEAN_TYPE); chainB.inferSlotType("local" + j, j % 3 == 0 ? STRING_TYPE : BOOLEAN_TYPE); } chainA = chainA.createChildFlowScope(); chainB = chainB.createChildFlowScope(); } verifyLongChains(chainA, chainB); } // Common chain verification for testLongChainN for all N. private void verifyLongChains(FlowScope chainA, FlowScope chainB) { FlowScope joined = join(chainA, chainB); for (int i = 0; i < LONG_CHAIN_LENGTH; i++) { assertTypeEquals( i % 2 == 0 ? NUMBER_TYPE : BOOLEAN_TYPE, chainA.getSlot("local" + i).getType()); assertTypeEquals( i % 3 == 0 ? STRING_TYPE : BOOLEAN_TYPE, chainB.getSlot("local" + i).getType()); JSType joinedSlotType = joined.getSlot("local" + i).getType(); if (i % 6 == 0) { assertTypeEquals(createUnionType(STRING_TYPE, NUMBER_TYPE), joinedSlotType); } else if (i % 2 == 0) { assertTypeEquals(createUnionType(NUMBER_TYPE, BOOLEAN_TYPE), joinedSlotType); } else if (i % 3 == 0) { assertTypeEquals(createUnionType(STRING_TYPE, BOOLEAN_TYPE), joinedSlotType); } else { assertTypeEquals(BOOLEAN_TYPE, joinedSlotType); } } assertScopesDiffer(chainA, chainB); assertScopesDiffer(chainA, joined); assertScopesDiffer(chainB, joined); } public void testFindUniqueSlot() { FlowScope childA = localEntry.createChildFlowScope(); childA.inferSlotType("localB", NUMBER_TYPE); FlowScope childAB = childA.createChildFlowScope(); childAB.inferSlotType("localB", STRING_TYPE); FlowScope childABC = childAB.createChildFlowScope(); childABC.inferSlotType("localA", BOOLEAN_TYPE); assertNull(childABC.findUniqueRefinedSlot(childABC)); assertTypeEquals(BOOLEAN_TYPE, childABC.findUniqueRefinedSlot(childAB).getType()); assertNull(childABC.findUniqueRefinedSlot(childA)); assertNull(childABC.findUniqueRefinedSlot(localEntry)); assertTypeEquals(STRING_TYPE, childAB.findUniqueRefinedSlot(childA).getType()); assertTypeEquals(STRING_TYPE, childAB.findUniqueRefinedSlot(localEntry).getType()); assertTypeEquals(NUMBER_TYPE, childA.findUniqueRefinedSlot(localEntry).getType()); } public void testDiffer1() { FlowScope childA = localEntry.createChildFlowScope(); childA.inferSlotType("localB", NUMBER_TYPE); FlowScope childAB = childA.createChildFlowScope(); childAB.inferSlotType("localB", STRING_TYPE); FlowScope childABC = childAB.createChildFlowScope(); childABC.inferSlotType("localA", BOOLEAN_TYPE); FlowScope childB = childAB.createChildFlowScope(); childB.inferSlotType("localB", STRING_TYPE); FlowScope childBC = childB.createChildFlowScope(); childBC.inferSlotType("localA", NO_TYPE); assertScopesSame(childAB, childB); assertScopesDiffer(childABC, childBC); assertScopesDiffer(childABC, childB); assertScopesDiffer(childAB, childBC); assertScopesDiffer(childA, childAB); assertScopesDiffer(childA, childABC); assertScopesDiffer(childA, childB); assertScopesDiffer(childA, childBC); } public void testDiffer2() { FlowScope childA = localEntry.createChildFlowScope(); childA.inferSlotType("localA", NUMBER_TYPE); FlowScope childB = localEntry.createChildFlowScope(); childB.inferSlotType("localA", NO_TYPE); assertScopesDiffer(childA, childB); } private void assertScopesDiffer(FlowScope a, FlowScope b) { assertFalse(a.equals(b)); assertFalse(b.equals(a)); assertEquals(a, a); assertEquals(b, b); } private void assertScopesSame(FlowScope a, FlowScope b) { assertEquals(a, b); assertEquals(b, a); assertEquals(a, a); assertEquals(b, b); } @SuppressWarnings("unchecked") private FlowScope join(FlowScope a, FlowScope b) { return (new LinkedFlowScope.FlowScopeJoinOp()).apply( Lists.newArrayList(a, b)); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.jscomp.DataFlowAnalysis.FlowState; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.InputId; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import junit.framework.TestCase; /** * Tests for {@link LiveVariablesAnalysis}. Test cases are snippets of a * function and assertions are made at the instruction labeled with {@code X}. * */ public class LiveVariableAnalysisTest extends TestCase { private LiveVariablesAnalysis liveness = null; public void testStraightLine() { // A sample of simple straight line of code with different liveness changes. assertNotLiveBeforeX("X:var a;", "a"); assertNotLiveAfterX("X:var a;", "a"); assertNotLiveAfterX("X:var a=1;", "a"); assertLiveAfterX("X:var a=1; a()", "a"); assertNotLiveBeforeX("X:var a=1; a()", "a"); assertLiveBeforeX("var a;X:a;", "a"); assertLiveBeforeX("var a;X:a=a+1;", "a"); assertLiveBeforeX("var a;X:a+=1;", "a"); assertLiveBeforeX("var a;X:a++;", "a"); assertNotLiveAfterX("var a,b;X:b();", "a"); assertNotLiveBeforeX("var a,b;X:b();", "a"); assertLiveBeforeX("var a,b;X:b(a);", "a"); assertLiveBeforeX("var a,b;X:b(1,2,3,b(a + 1));", "a"); assertNotLiveBeforeX("var a,b;X:a=1;b(a)", "a"); assertNotLiveAfterX("var a,b;X:b(a);b()", "a"); assertLiveBeforeX("var a,b;X:b();b=1;a()", "b"); assertLiveAfterX("X:a();var a;a()", "a"); assertNotLiveAfterX("X:a();var a=1;a()", "a"); assertLiveBeforeX("var a,b;X:a,b=1", "a"); } public void testProperties() { // Reading property of a local variable makes that variable live. assertLiveBeforeX("var a,b;X:a.P;", "a"); // Assigning to a property doesn't kill "a". It makes it live instead. assertLiveBeforeX("var a,b;X:a.P=1;b()", "a"); assertLiveBeforeX("var a,b;X:a.P.Q=1;b()", "a"); // An "a" in a different context. assertNotLiveAfterX("var a,b;X:b.P.Q.a=1;", "a"); assertLiveBeforeX("var a,b;X:b.P.Q=a;", "a"); } public void testConditions() { // Reading the condition makes the variable live. assertLiveBeforeX("var a,b;X:if(a){}", "a"); assertLiveBeforeX("var a,b;X:if(a||b) {}", "a"); assertLiveBeforeX("var a,b;X:if(b||a) {}", "a"); assertLiveBeforeX("var a,b;X:if(b||b(a)) {}", "a"); assertNotLiveAfterX("var a,b;X:b();if(a) {}", "b"); // We can kill within a condition as well. assertNotLiveAfterX("var a,b;X:a();if(a=b){}a()", "a"); assertNotLiveAfterX("var a,b;X:a();while(a=b){}a()", "a"); // The kill can be "conditional" due to short circuit. assertNotLiveAfterX("var a,b;X:a();if((a=b)&&b){}a()", "a"); assertNotLiveAfterX("var a,b;X:a();while((a=b)&&b){}a()", "a"); assertLiveBeforeX("var a,b;a();X:if(b&&(a=b)){}a()", "a"); // Assumed live. assertLiveBeforeX("var a,b;a();X:if(a&&(a=b)){}a()", "a"); assertLiveBeforeX("var a,b;a();X:while(b&&(a=b)){}a()", "a"); assertLiveBeforeX("var a,b;a();X:while(a&&(a=b)){}a()", "a"); } public void testArrays() { assertLiveBeforeX("var a;X:a[1]", "a"); assertLiveBeforeX("var a,b;X:b[a]", "a"); assertLiveBeforeX("var a,b;X:b[1,2,3,4,b(a)]", "a"); assertLiveBeforeX("var a,b;X:b=[a,'a']", "a"); assertNotLiveBeforeX("var a,b;X:a=[];b(a)", "a"); // Element assignment doesn't kill the array. assertLiveBeforeX("var a;X:a[1]=1", "a"); } public void testTwoPaths() { // Both Paths. assertLiveBeforeX("var a,b;X:if(b){b(a)}else{b(a)};", "a"); // Only one path. assertLiveBeforeX("var a,b;X:if(b){b(b)}else{b(a)};", "a"); assertLiveBeforeX("var a,b;X:if(b){b(a)}else{b(b)};", "a"); // None of the paths. assertNotLiveAfterX("var a,b;X:if(b){b(b)}else{b(b)};", "a"); // At the very end. assertLiveBeforeX("var a,b;X:if(b){b(b)}else{b(b)}a();", "a"); // The loop might or might not be executed. assertLiveBeforeX("var a;X:while(param1){a()};", "a"); assertLiveBeforeX("var a;X:while(param1){a=1};a()", "a"); // Same idea with if. assertLiveBeforeX("var a;X:if(param1){a()};", "a"); assertLiveBeforeX("var a;X:if(param1){a=1};a()", "a"); // This is different in DO. We know for sure at least one iteration is // executed. assertNotLiveAfterX("X:var a;do{a=1}while(param1);a()", "a"); } public void testThreePaths() { assertLiveBeforeX("var a;X:if(1){}else if(2){}else{a()};", "a"); assertLiveBeforeX("var a;X:if(1){}else if(2){a()}else{};", "a"); assertLiveBeforeX("var a;X:if(1){a()}else if(2){}else{};", "a"); assertLiveBeforeX("var a;X:if(1){}else if(2){}else{};a()", "a"); } public void testHooks() { assertLiveBeforeX("var a;X:1?a=1:1;a()", "a"); // Unfortunately, we cannot prove the following because we assume there is // no control flow within a hook (i.e. no joins / set unions). // assertNotLiveAfterX("var a;X:1?a=1:a=2;a", "a"); assertLiveBeforeX("var a,b;X:b=1?a:2", "a"); } public void testForLoops() { // Induction variable should not be live after the loop. assertNotLiveBeforeX("var a,b;for(a=0;a<9;a++){b(a)};X:b", "a"); assertNotLiveBeforeX("var a,b;for(a in b){a()};X:b", "a"); assertNotLiveBeforeX("var a,b;for(a in b){a()};X:a", "b"); assertLiveBeforeX("var b;for(var a in b){X:a()};", "a"); // It should be live within the loop even if it is not used. assertLiveBeforeX("var a,b;for(a=0;a<9;a++){X:1}", "a"); assertLiveAfterX("var a,b;for(a in b){X:b};", "a"); // For-In should serve as a gen as well. assertLiveBeforeX("var a,b; X:for(a in b){ }", "a"); // "a in b" should kill "a" before it. // Can't prove this unless we have branched backward DFA. //assertNotLiveAfterX("var a,b;X:b;for(a in b){a()};", "a"); // Unless it is used before. assertLiveBeforeX("var a,b;X:a();b();for(a in b){a()};", "a"); // Initializer assertLiveBeforeX("var a,b;X:b;for(b=a;;){};", "a"); assertNotLiveBeforeX("var a,b;X:a;for(b=a;;){b()};b();", "b"); } public void testNestedLoops() { assertLiveBeforeX("var a;X:while(1){while(1){a()}}", "a"); assertLiveBeforeX("var a;X:while(1){while(1){while(1){a()}}}", "a"); assertLiveBeforeX("var a;X:while(1){while(1){a()};a=1}", "a"); assertLiveAfterX("var a;while(1){while(1){a()};X:a=1;}", "a"); assertLiveAfterX("var a;while(1){X:a=1;while(1){a()}}", "a"); assertNotLiveBeforeX( "var a;X:1;do{do{do{a=1;}while(1)}while(1)}while(1);a()", "a"); } public void testSwitches() { assertLiveBeforeX("var a,b;X:switch(a){}", "a"); assertLiveBeforeX("var a,b;X:switch(b){case(a):break;}", "a"); assertLiveBeforeX("var a,b;X:switch(b){case(b):case(a):break;}", "a"); assertNotLiveBeforeX( "var a,b;X:switch(b){case 1:a=1;break;default:a=2;break};a()", "a"); assertLiveBeforeX("var a,b;X:switch(b){default:a();break;}", "a"); } public void testAssignAndReadInCondition() { // BUG #1358904 // Technically, this isn't exactly true....but we haven't model control flow // within an instruction. assertLiveBeforeX("var a, b; X: if ((a = this) && (b = a)) {}", "a"); assertNotLiveBeforeX("var a, b; X: a = 1, b = 1;", "a"); assertNotLiveBeforeX("var a; X: a = 1, a = 1;", "a"); } public void testParam() { // Unused parameter should not be live. assertNotLiveAfterX("var a;X:a()", "param1"); assertLiveBeforeX("var a;X:a(param1)", "param1"); assertNotLiveAfterX("var a;X:a();a(param2)", "param1"); } public void testExpressionInForIn() { assertLiveBeforeX("var a = [0]; X:for (a[1] in foo) { }", "a"); } public void testArgumentsArray() { // Check that use of arguments forces the parameters into the // escaped set. assertEscaped("arguments[0]", "param1"); assertEscaped("arguments[0]", "param2"); assertEscaped("var args = arguments", "param1"); assertEscaped("var args = arguments", "param2"); assertNotEscaped("arguments = []", "param1"); assertNotEscaped("arguments = []", "param2"); assertEscaped("arguments[0] = 1", "param1"); assertEscaped("arguments[0] = 1", "param2"); assertEscaped("arguments[arguments[0]] = 1", "param1"); assertEscaped("arguments[arguments[0]] = 1", "param2"); } public void testTryCatchFinally() { assertLiveAfterX("var a; try {X:a=1} finally {a}", "a"); assertLiveAfterX("var a; try {a()} catch(e) {X:a=1} finally {a}", "a"); // Because the outer catch doesn't catch any exceptions at all, the read of // "a" within the catch block should not make "a" live. assertNotLiveAfterX("var a = 1; try {" + "try {a()} catch(e) {X:1} } catch(E) {a}", "a"); assertLiveAfterX("var a; while(1) { try {X:a=1;break} finally {a}}", "a"); } public void testForInAssignment() { assertLiveBeforeX("var a,b; for (var y in a = b) { X:a[y] }", "a"); // No one refers to b after the first iteration. assertNotLiveBeforeX("var a,b; for (var y in a = b) { X:a[y] }", "b"); assertLiveBeforeX("var a,b; for (var y in a = b) { X:a[y] }", "y"); assertLiveAfterX("var a,b; for (var y in a = b) { a[y]; X: y();}", "a"); } public void testExceptionThrowingAssignments() { assertLiveBeforeX("try{var a; X:a=foo();a} catch(e) {e()}", "a"); assertLiveBeforeX("try{X:var a=foo();a} catch(e) {e()}", "a"); assertLiveBeforeX("try{X:var a=foo()} catch(e) {e(a)}", "a"); } public void testInnerFunctions() { assertLiveBeforeX("function a() {}; X: a()", "a"); assertNotLiveBeforeX("X: function a() {}", "a"); assertLiveBeforeX("a = function(){}; function a() {}; X: a()", "a"); // NOTE: function a() {} has no CFG node representation since it is not // part of the control execution. assertLiveAfterX("X: a = function(){}; function a() {}; a()", "a"); assertNotLiveBeforeX("X: a = function(){}; function a() {}; a()", "a"); } public void testEscaped() { assertEscaped("var a;function b(){a()}", "a"); assertEscaped("var a;function b(){param1()}", "param1"); assertEscaped("var a;function b(){function c(){a()}}", "a"); assertEscaped("var a;function b(){param1.x = function() {a()}}", "a"); assertEscaped("try{} catch(e){}", "e"); assertNotEscaped("var a;function b(){var c; c()}", "c"); assertNotEscaped("var a;function f(){function b(){var c;c()}}", "c"); assertNotEscaped("var a;function b(){};a()", "a"); assertNotEscaped("var a;function f(){function b(){}}a()", "a"); assertNotEscaped("var a;function b(){var a;a()};a()", "a"); // Escaped by exporting. assertEscaped("var _x", "_x"); } public void testEscapedLiveness() { assertNotLiveBeforeX("var a;X:a();function b(){a()}", "a"); } public void testBug1449316() { assertLiveBeforeX("try {var x=[]; X:var y=x[0]} finally {foo()}", "x"); } private void assertLiveBeforeX(String src, String var) { FlowState<LiveVariablesAnalysis.LiveVariableLattice> state = getFlowStateAtX(src); assertNotNull(src + " should contain a label 'X:'", state); assertTrue("Variable" + var + " should be live before X", state.getIn() .isLive(liveness.getVarIndex(var))); } private void assertLiveAfterX(String src, String var) { FlowState<LiveVariablesAnalysis.LiveVariableLattice> state = getFlowStateAtX(src); assertTrue("Label X should be in the input program.", state != null); assertTrue("Variable" + var + " should be live after X", state.getOut() .isLive(liveness.getVarIndex(var))); } private void assertNotLiveAfterX(String src, String var) { FlowState<LiveVariablesAnalysis.LiveVariableLattice> state = getFlowStateAtX(src); assertTrue("Label X should be in the input program.", state != null); assertTrue("Variable" + var + " should not be live after X", !state .getOut().isLive(liveness.getVarIndex(var))); } private void assertNotLiveBeforeX(String src, String var) { FlowState<LiveVariablesAnalysis.LiveVariableLattice> state = getFlowStateAtX(src); assertTrue("Label X should be in the input program.", state != null); assertTrue("Variable" + var + " should not be live before X", !state .getIn().isLive(liveness.getVarIndex(var))); } private FlowState<LiveVariablesAnalysis.LiveVariableLattice> getFlowStateAtX( String src) { liveness = computeLiveness(src); return getFlowStateAtX(liveness.getCfg().getEntry().getValue(), liveness .getCfg()); } private FlowState<LiveVariablesAnalysis.LiveVariableLattice> getFlowStateAtX( Node node, ControlFlowGraph<Node> cfg) { if (node.isLabel()) { if (node.getFirstChild().getString().equals("X")) { return cfg.getNode(node.getLastChild()).getAnnotation(); } } for (Node c = node.getFirstChild(); c != null; c = c.getNext()) { FlowState<LiveVariablesAnalysis.LiveVariableLattice> state = getFlowStateAtX(c, cfg); if (state != null) { return state; } } return null; } private static void assertEscaped(String src, String name) { for (Var var : computeLiveness(src).getEscapedLocals()) { if (var.name.equals(name)) { return; } } fail("Variable " + name + " should be in the escaped local list."); } private static void assertNotEscaped(String src, String name) { for (Var var : computeLiveness(src).getEscapedLocals()) { assertFalse(var.name.equals(name)); } } private static LiveVariablesAnalysis computeLiveness(String src) { Compiler compiler = new Compiler(); CompilerOptions options = new CompilerOptions(); options.setCodingConvention(new GoogleCodingConvention()); compiler.initOptions(options); src = "function _FUNCTION(param1, param2){" + src + "}"; Node n = compiler.parseTestCode(src).removeFirstChild(); Node script = new Node(Token.SCRIPT, n); script.setInputId(new InputId("test")); assertEquals(0, compiler.getErrorCount()); Scope scope = new SyntacticScopeCreator(compiler).createScope( n, Scope.createGlobalScope(script)); ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true); cfa.process(null, n); ControlFlowGraph<Node> cfg = cfa.getCfg(); LiveVariablesAnalysis analysis = new LiveVariablesAnalysis(cfg, scope, compiler); analysis.analyze(); return analysis; } }
/* * Copyright 2006 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.base.Joiner; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.jscomp.CheckLevel; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter; import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter; import com.google.javascript.rhino.InputId; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.testing.Asserts; import java.util.Arrays; import java.util.List; import java.util.Set; /** * Tests {@link TypeCheck}. * * This is a temporary fork of the TypeCheckTest for the experimental * "looseTypes" option. These tests should be be folded into TypeCheckTest * or removed along with the looseTypes option. * */ public class LooseTypeCheckTest extends CompilerTypeTestCase { @Override public CompilerOptions getOptions() { CompilerOptions options = super.getOptions(); options.looseTypes = true; return options; } public void testInitialTypingScope() { Scope s = new TypedScopeCreator(compiler, CodingConventions.getDefault()).createInitialScope( new Node(Token.BLOCK)); assertTypeEquals(ARRAY_FUNCTION_TYPE, s.getVar("Array").getType()); assertTypeEquals(BOOLEAN_OBJECT_FUNCTION_TYPE, s.getVar("Boolean").getType()); assertTypeEquals(DATE_FUNCTION_TYPE, s.getVar("Date").getType()); assertTypeEquals(ERROR_FUNCTION_TYPE, s.getVar("Error").getType()); assertTypeEquals(EVAL_ERROR_FUNCTION_TYPE, s.getVar("EvalError").getType()); assertTypeEquals(NUMBER_OBJECT_FUNCTION_TYPE, s.getVar("Number").getType()); assertTypeEquals(OBJECT_FUNCTION_TYPE, s.getVar("Object").getType()); assertTypeEquals(RANGE_ERROR_FUNCTION_TYPE, s.getVar("RangeError").getType()); assertTypeEquals(REFERENCE_ERROR_FUNCTION_TYPE, s.getVar("ReferenceError").getType()); assertTypeEquals(REGEXP_FUNCTION_TYPE, s.getVar("RegExp").getType()); assertTypeEquals(STRING_OBJECT_FUNCTION_TYPE, s.getVar("String").getType()); assertTypeEquals(SYNTAX_ERROR_FUNCTION_TYPE, s.getVar("SyntaxError").getType()); assertTypeEquals(TYPE_ERROR_FUNCTION_TYPE, s.getVar("TypeError").getType()); assertTypeEquals(URI_ERROR_FUNCTION_TYPE, s.getVar("URIError").getType()); } public void testTypeCheck1() throws Exception { testTypes("/**@return {void}*/function foo(){ if (foo()) return; }"); } public void testTypeCheck2() throws Exception { testTypes("/**@return {void}*/function foo(){ var x=foo(); x--; }", "increment/decrement\n" + "found : undefined\n" + "required: number"); } public void testTypeCheck4() throws Exception { testTypes("/**@return {void}*/function foo(){ !foo(); }"); } public void testTypeCheck5() throws Exception { testTypes("/**@return {void}*/function foo(){ var a = +foo(); }", "sign operator\n" + "found : undefined\n" + "required: number"); } public void testTypeCheck6() throws Exception { testTypes( "/**@return {void}*/function foo(){" + "/** @type {undefined|number} */var a;if (a == foo())return;}"); } public void testTypeCheck8() throws Exception { testTypes("/**@return {void}*/function foo(){do {} while (foo());}"); } public void testTypeCheck9() throws Exception { testTypes("/**@return {void}*/function foo(){while (foo());}"); } public void testTypeCheck10() throws Exception { testTypes("/**@return {void}*/function foo(){for (;foo(););}"); } public void testTypeCheck11() throws Exception { testTypes("/**@type !Number */var a;" + "/**@type !String */var b;" + "a = b;", "assignment\n" + "found : String\n" + "required: Number"); } public void testTypeCheck12() throws Exception { testTypes("/**@return {!Object}*/function foo(){var a = 3^foo();}", "bad right operand to bitwise operator\n" + "found : Object\n" + "required: (boolean|null|number|string|undefined)"); } public void testTypeCheck13() throws Exception { testTypes("/**@type {!Number|!String}*/var i; i=/xx/;", "assignment\n" + "found : RegExp\n" + "required: (Number|String)"); } public void testTypeCheck14() throws Exception { testTypes("/**@param opt_a*/function foo(opt_a){}"); } public void testTypeCheck15() throws Exception { testTypes("/**@type {Number} */var x;x=null;x=10;", "assignment\n" + "found : number\n" + "required: (Number|null|undefined)"); } public void testTypeCheck16a() throws Exception { testTypes("/**@type {Number|null} */var x='';", "initializing variable\n" + "found : string\n" + "required: (Number|null|undefined)"); } public void testTypeCheck16b() throws Exception { testTypes("/**@type {!Number|null} */var x='';", "initializing variable\n" + "found : string\n" + "required: (Number|null)"); } public void testTypeCheck17() throws Exception { testTypes("/**@return {Number}\n@param {Number} opt_foo */\n" + "function a(opt_foo){\nreturn /**@type {Number}*/(opt_foo);\n}"); } public void testTypeCheck18() throws Exception { testTypes("/**@return {RegExp}\n*/\n function a(){return new RegExp();}"); } public void testTypeCheck19() throws Exception { testTypes("/**@return {Array}\n*/\n function a(){return new Array();}"); } public void testTypeCheck20() throws Exception { testTypes("/**@return {Date}\n*/\n function a(){return new Date();}"); } public void testTypeCheckBasicDowncast() throws Exception { testTypes("/** @constructor */function foo() {}\n" + "/** @type {Object} */ var bar = new foo();\n"); } public void testTypeCheckNoDowncastToNumber() throws Exception { testTypes("/** @constructor */function foo() {}\n" + "/** @type {!Number} */ var bar = new foo();\n", "initializing variable\n" + "found : foo\n" + "required: Number"); } public void testTypeCheck21() throws Exception { testTypes("/** @type Array.<String> */var foo;"); } public void testTypeCheck22() throws Exception { testTypes("/** @param {Element|Object} p */\nfunction foo(p){}\n" + "/** @constructor */function Element(){}\n" + "/** @type {Element|Object} */var v;\n" + "foo(v);\n"); } public void testTypeCheck23() throws Exception { testTypes("/** @type {(Object,Null)} */var foo; foo = null;"); } public void testTypeCheck24() throws Exception { testTypes("/** @constructor */function MyType(){}\n" + "/** @type {(MyType,Null)} */var foo; foo = null;"); } public void testTypeCheckDefaultExterns() throws Exception { testTypes("/** @param {string} x */ function f(x) {}" + "f([].length);" , "actual parameter 1 of f does not match formal parameter\n" + "found : number\n" + "required: string"); } public void testTypeCheckCustomExterns() throws Exception { testTypes( DEFAULT_EXTERNS + "/** @type {boolean} */ Array.prototype.oogabooga;", "/** @param {string} x */ function f(x) {}" + "f([].oogabooga);" , "actual parameter 1 of f does not match formal parameter\n" + "found : boolean\n" + "required: string", false); } public void testParameterizedArray1() throws Exception { testTypes("/** @param {!Array.<number>} a\n" + "* @return {string}\n" + "*/ var f = function(a) { return a[0]; };", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testParameterizedArray2() throws Exception { testTypes("/** @param {!Array.<!Array.<number>>} a\n" + "* @return {number}\n" + "*/ var f = function(a) { return a[0]; };", "inconsistent return type\n" + "found : Array.<number>\n" + "required: number"); } public void testParameterizedArray3() throws Exception { testTypes("/** @param {!Array.<number>} a\n" + "* @return {number}\n" + "*/ var f = function(a) { a[1] = 0; return a[0]; };"); } public void testParameterizedArray4() throws Exception { testTypes("/** @param {!Array.<number>} a\n" + "*/ var f = function(a) { a[0] = 'a'; };", "assignment\n" + "found : string\n" + "required: number"); } public void testParameterizedArray5() throws Exception { testTypes("/** @param {!Array.<*>} a\n" + "*/ var f = function(a) { a[0] = 'a'; };"); } public void testParameterizedArray6() throws Exception { testTypes("/** @param {!Array.<*>} a\n" + "* @return {string}\n" + "*/ var f = function(a) { return a[0]; };", "inconsistent return type\n" + "found : *\n" + "required: string"); } public void testParameterizedArray7() throws Exception { testTypes("/** @param {?Array.<number>} a\n" + "* @return {string}\n" + "*/ var f = function(a) { return a[0]; };", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testParameterizedObject1() throws Exception { testTypes("/** @param {!Object.<number>} a\n" + "* @return {string}\n" + "*/ var f = function(a) { return a[0]; };", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testParameterizedObject2() throws Exception { testTypes("/** @param {!Object.<string,number>} a\n" + "* @return {string}\n" + "*/ var f = function(a) { return a['x']; };", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testParameterizedObject3() throws Exception { testTypes("/** @param {!Object.<number,string>} a\n" + "* @return {string}\n" + "*/ var f = function(a) { return a['x']; };", "restricted index type\n" + "found : string\n" + "required: number"); } public void testParameterizedObject4() throws Exception { testTypes("/** @enum {string} */ var E = {A: 'a', B: 'b'};\n" + "/** @param {!Object.<E,string>} a\n" + "* @return {string}\n" + "*/ var f = function(a) { return a['x']; };", "restricted index type\n" + "found : string\n" + "required: E.<string>"); } public void testUnionOfFunctionAndType() throws Exception { testTypes("/** @type {null|(function(Number):void)} */ var a;" + "/** @type {(function(Number):void)|null} */ var b = null; a = b;"); } public void testOptionalParameterComparedToUndefined() throws Exception { testTypes("/**@param opt_a {Number}*/function foo(opt_a)" + "{if (opt_a==undefined) var b = 3;}"); } public void testOptionalAllType() throws Exception { testTypes("/** @param {*} opt_x */function f(opt_x) { return opt_x }\n" + "/** @type {*} */var y;\n" + "f(y);"); } public void testOptionalUnknownNamedType() throws Exception { testTypes("/** @param {!T} opt_x\n@return {undefined} */\n" + "function f(opt_x) { return opt_x; }\n" + "/** @constructor */var T = function() {};", "inconsistent return type\n" + "found : (T|undefined)\n" + "required: undefined"); } public void testOptionalArgFunctionParam() throws Exception { testTypes("/** @param {function(number=)} a */" + "function f(a) {a()};"); } public void testOptionalArgFunctionParam2() throws Exception { testTypes("/** @param {function(number=)} a */" + "function f(a) {a(3)};"); } public void testOptionalArgFunctionParam3() throws Exception { testTypes("/** @param {function(number=)} a */" + "function f(a) {a(undefined)};"); } public void testOptionalArgFunctionParam4() throws Exception { String expectedWarning = "Function a: called with 2 argument(s). " + "Function requires at least 0 argument(s) and no more than 1 " + "argument(s)."; testTypes("/** @param {function(number=)} a */function f(a) {a(3,4)};", expectedWarning, false); } public void testOptionalArgFunctionParamError() throws Exception { String expectedWarning = "Bad type annotation. variable length argument must be last"; testTypes("/** @param {function(...[number], number=)} a */" + "function f(a) {};", expectedWarning, false); } public void testOptionalNullableArgFunctionParam() throws Exception { testTypes("/** @param {function(?number=)} a */" + "function f(a) {a()};"); } public void testOptionalNullableArgFunctionParam2() throws Exception { testTypes("/** @param {function(?number=)} a */" + "function f(a) {a(null)};"); } public void testOptionalNullableArgFunctionParam3() throws Exception { testTypes("/** @param {function(?number=)} a */" + "function f(a) {a(3)};"); } public void testOptionalArgFunctionReturn() throws Exception { testTypes("/** @return {function(number=)} */" + "function f() { return function(opt_x) { }; };" + "f()()"); } public void testOptionalArgFunctionReturn2() throws Exception { testTypes("/** @return {function(Object=)} */" + "function f() { return function(opt_x) { }; };" + "f()({})"); } public void testBooleanType() throws Exception { testTypes("/**@type {boolean} */var x = 1 < 2;"); } public void testBooleanReduction1() throws Exception { testTypes("/**@type {string} */var x; x = null || \"a\";"); } public void testBooleanReduction2() throws Exception { // It's important for the type system to recognize that in no case // can the boolean expression evaluate to a boolean value. testTypes("/** @param {string} s\n @return {string} */" + "(function(s) { return ((s == 'a') && s) || 'b'; })"); } public void testBooleanReduction3() throws Exception { testTypes("/** @param {string} s\n @return {string?} */" + "(function(s) { return s && null && 3; })"); } public void testBooleanReduction4() throws Exception { testTypes("/** @param {Object} x\n @return {Object} */" + "(function(x) { return null || x || null ; })"); } public void testBooleanReduction5() throws Exception { testTypes("/**\n" + "* @param {Array|string} x\n" + "* @return {string?}\n" + "*/\n" + "var f = function(x) {\n" + "if (!x || typeof x == 'string') {\n" + "return x;\n" + "}\n" + "return null;\n" + "};"); } public void testBooleanReduction6() throws Exception { testTypes("/**\n" + "* @param {Array|string|null} x\n" + "* @return {string?}\n" + "*/\n" + "var f = function(x) {\n" + "if (!(x && typeof x != 'string')) {\n" + "return x;\n" + "}\n" + "return null;\n" + "};"); } public void testBooleanReduction7() throws Exception { testTypes("/** @constructor */var T = function() {};\n" + "/**\n" + "* @param {Array|T} x\n" + "* @return {null|undefined}\n" + "*/\n" + "var f = function(x) {\n" + "if (!x) {\n" + "return x;\n" + "}\n" + "return null;\n" + "};"); } public void testNullAnd() throws Exception { testTypes("/** @type null */var x;\n" + "/** @type number */var r = x && x;", "initializing variable\n" + "found : null\n" + "required: number"); } public void testNullOr() throws Exception { testTypes("/** @type null */var x;\n" + "/** @type number */var r = x || x;", "initializing variable\n" + "found : null\n" + "required: number"); } public void testBooleanPreservation1() throws Exception { testTypes("/**@type {string} */var x = \"a\";" + "x = ((x == \"a\") && x) || x == \"b\";", "assignment\n" + "found : (boolean|string)\n" + "required: string"); } public void testBooleanPreservation2() throws Exception { testTypes("/**@type {string} */var x = \"a\"; x = (x == \"a\") || x;", "assignment\n" + "found : (boolean|string)\n" + "required: string"); } public void testBooleanPreservation3() throws Exception { testTypes("/** @param {Function?} x\n @return {boolean?} */" + "function f(x) { return x && x == \"a\"; }", "condition always evaluates to false\n" + "left : Function\n" + "right: string"); } public void testBooleanPreservation4() throws Exception { testTypes("/** @param {Function?|boolean} x\n @return {boolean} */" + "function f(x) { return x && x == \"a\"; }", "inconsistent return type\n" + "found : (boolean|null|undefined)\n" + "required: boolean"); } public void testTypeOfReduction1() throws Exception { testTypes("/** @param {string|number} x\n @return {string} */ " + "function f(x) { return typeof x == 'number' ? String(x) : x; }"); } public void testTypeOfReduction2() throws Exception { testTypes("/** @param {string|number} x\n @return {string} */ " + "function f(x) { return typeof x != 'string' ? String(x) : x; }"); } public void testTypeOfReduction3() throws Exception { testTypes("/** @param {number|null} x\n @return {number} */ " + "function f(x) { return typeof x == 'object' ? 1 : x; }"); } public void testTypeOfReduction4() throws Exception { testTypes("/** @param {Object|undefined} x\n @return {Object} */ " + "function f(x) { return typeof x == 'undefined' ? {} : x; }"); } public void testTypeOfReduction5() throws Exception { testTypes("/** @enum {string} */ var E = {A: 'a', B: 'b'};\n" + "/** @param {!E|number} x\n @return {string} */ " + "function f(x) { return typeof x != 'number' ? x : 'a'; }"); } public void testTypeOfReduction6() throws Exception { testTypes("/** @param {number|string} x\n@return {string} */\n" + "function f(x) {\n" + "return typeof x == 'string' && x.length == 3 ? x : 'a';\n" + "}"); } public void testTypeOfReduction7() throws Exception { testTypes("/** @return {string} */var f = function(x) { " + "return typeof x == 'number' ? x : 'a'; }", "inconsistent return type\n" + "found : (number|string)\n" + "required: string"); } public void testTypeOfReduction8() throws Exception { testClosureTypes( CLOSURE_DEFS + "/** @param {number|string} x\n@return {string} */\n" + "function f(x) {\n" + "return goog.isString(x) && x.length == 3 ? x : 'a';\n" + "}", null); } public void testTypeOfReduction9() throws Exception { testClosureTypes( CLOSURE_DEFS + "/** @param {!Array|string} x\n@return {string} */\n" + "function f(x) {\n" + "return goog.isArray(x) ? 'a' : x;\n" + "}", null); } public void testTypeOfReduction10() throws Exception { testClosureTypes( CLOSURE_DEFS + "/** @param {Array|string} x\n@return {Array} */\n" + "function f(x) {\n" + "return goog.isArray(x) ? x : [];\n" + "}", null); } public void testTypeOfReduction11() throws Exception { testClosureTypes( CLOSURE_DEFS + "/** @param {Array|string} x\n@return {Array} */\n" + "function f(x) {\n" + "return goog.isObject(x) ? x : [];\n" + "}", null); } public void testTypeOfReduction12() throws Exception { testTypes("/** @enum {string} */ var E = {A: 'a', B: 'b'};\n" + "/** @param {E|Array} x\n @return {Array} */ " + "function f(x) { return typeof x == 'object' ? x : []; }"); } public void testTypeOfReduction13() throws Exception { testClosureTypes( CLOSURE_DEFS + "/** @enum {string} */ var E = {A: 'a', B: 'b'};\n" + "/** @param {E|Array} x\n@return {Array} */ " + "function f(x) { return goog.isObject(x) ? x : []; }", null); } public void testTypeOfReduction14() throws Exception { // Don't do type inference on GETELEMs. testClosureTypes( CLOSURE_DEFS + "function f(x) { " + " return goog.isString(arguments[0]) ? arguments[0] : 0;" + "}", null); } public void testTypeOfReduction15() throws Exception { // Don't do type inference on GETELEMs. testClosureTypes( CLOSURE_DEFS + "function f(x) { " + " return typeof arguments[0] == 'string' ? arguments[0] : 0;" + "}", null); } public void testQualifiedNameReduction1() throws Exception { testTypes("var x = {}; /** @type {string?} */ x.a = 'a';\n" + "/** @return {string} */ var f = function() {\n" + "return x.a ? x.a : 'a'; }"); } public void testQualifiedNameReduction2() throws Exception { testTypes("/** @param {string?} a\n@constructor */ var T = " + "function(a) {this.a = a};\n" + "/** @return {string} */ T.prototype.f = function() {\n" + "return this.a ? this.a : 'a'; }"); } public void testQualifiedNameReduction3() throws Exception { testTypes("/** @param {string|Array} a\n@constructor */ var T = " + "function(a) {this.a = a};\n" + "/** @return {string} */ T.prototype.f = function() {\n" + "return typeof this.a == 'string' ? this.a : 'a'; }"); } public void testQualifiedNameReduction4() throws Exception { testClosureTypes( CLOSURE_DEFS + "/** @param {string|Array} a\n@constructor */ var T = " + "function(a) {this.a = a};\n" + "/** @return {string} */ T.prototype.f = function() {\n" + "return goog.isString(this.a) ? this.a : 'a'; }", null); } public void testInstanceOfReduction1() throws Exception { testTypes("/** @constructor */ var T = function() {};\n" + "/** @param {T|string} x\n@return {T} */\n" + "var f = function(x) {\n" + "if (x instanceof T) { return x; } else { return new T(); }\n" + "};"); } public void testInstanceOfReduction2() throws Exception { testTypes("/** @constructor */ var T = function() {};\n" + "/** @param {!T|string} x\n@return {string} */\n" + "var f = function(x) {\n" + "if (x instanceof T) { return ''; } else { return x; }\n" + "};"); } public void testPropertyInferredPropagation() throws Exception { testTypes("/** @return {Object} */function f() { return {}; }\n" + "function g() { var x = f(); if (x.p) x.a = 'a'; else x.a = 'b'; }\n" + "function h() { var x = f(); x.a = false; }"); } public void testPropertyInference1() throws Exception { testTypes( "/** @constructor */ function F() { this.x_ = true; }" + "/** @return {string} */" + "F.prototype.bar = function() { if (this.x_) return this.x_; };", "inconsistent return type\n" + "found : boolean\n" + "required: string"); } public void testPropertyInference2() throws Exception { testTypes( "/** @constructor */ function F() { this.x_ = true; }" + "F.prototype.baz = function() { this.x_ = null; };" + "/** @return {string} */" + "F.prototype.bar = function() { if (this.x_) return this.x_; };", "inconsistent return type\n" + "found : boolean\n" + "required: string"); } public void testPropertyInference3() throws Exception { testTypes( "/** @constructor */ function F() { this.x_ = true; }" + "F.prototype.baz = function() { this.x_ = 3; };" + "/** @return {string} */" + "F.prototype.bar = function() { if (this.x_) return this.x_; };", "inconsistent return type\n" + "found : (boolean|number)\n" + "required: string"); } public void testPropertyInference4() throws Exception { testTypes( "/** @constructor */ function F() { }" + "F.prototype.x_ = 3;" + "/** @return {string} */" + "F.prototype.bar = function() { if (this.x_) return this.x_; };", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testPropertyInference5() throws Exception { testTypes( "/** @constructor */ function F() { }" + "F.prototype.baz = function() { this.x_ = 3; };" + "/** @return {string} */" + "F.prototype.bar = function() { if (this.x_) return this.x_; };"); } public void testPropertyInference6() throws Exception { testTypes( "/** @constructor */ function F() { }" + "(new F).x_ = 3;" + "/** @return {string} */" + "F.prototype.bar = function() { return this.x_; };"); } public void testPropertyInference7() throws Exception { testTypes( "/** @constructor */ function F() { this.x_ = true; }" + "(new F).x_ = 3;" + "/** @return {string} */" + "F.prototype.bar = function() { return this.x_; };", "inconsistent return type\n" + "found : boolean\n" + "required: string"); } public void testPropertyInference8() throws Exception { testTypes( "/** @constructor */ function F() { " + " /** @type {string} */ this.x_ = 'x';" + "}" + "(new F).x_ = 3;" + "/** @return {string} */" + "F.prototype.bar = function() { return this.x_; };", "assignment to property x_ of F\n" + "found : number\n" + "required: string"); } public void testNoPersistentTypeInferenceForObjectProperties() throws Exception { testTypes("/** @param {Object} o\n@param {string} x */\n" + "function s1(o,x) { o.x = x; }\n" + "/** @param {Object} o\n@return {string} */\n" + "function g1(o) { return typeof o.x == 'undefined' ? '' : o.x; }\n" + "/** @param {Object} o\n@param {number} x */\n" + "function s2(o,x) { o.x = x; }\n" + "/** @param {Object} o\n@return {number} */\n" + "function g2(o) { return typeof o.x == 'undefined' ? 0 : o.x; }"); } public void testNoPersistentTypeInferenceForFunctionProperties() throws Exception { testTypes("/** @param {Function} o\n@param {string} x */\n" + "function s1(o,x) { o.x = x; }\n" + "/** @param {Function} o\n@return {string} */\n" + "function g1(o) { return typeof o.x == 'undefined' ? '' : o.x; }\n" + "/** @param {Function} o\n@param {number} x */\n" + "function s2(o,x) { o.x = x; }\n" + "/** @param {Function} o\n@return {number} */\n" + "function g2(o) { return typeof o.x == 'undefined' ? 0 : o.x; }"); } public void testObjectPropertyTypeInferredInLocalScope1() throws Exception { testTypes("/** @param {!Object} o\n@return {string} */\n" + "function f(o) { o.x = 1; return o.x; }", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testObjectPropertyTypeInferredInLocalScope2() throws Exception { testTypes("/**@param {!Object} o\n@param {number?} x\n@return {string}*/" + "function f(o, x) { o.x = 'a';\nif (x) {o.x = x;}\nreturn o.x; }", "inconsistent return type\n" + "found : (number|string)\n" + "required: string"); } public void testObjectPropertyTypeInferredInLocalScope3() throws Exception { testTypes("/**@param {!Object} o\n@param {number?} x\n@return {string}*/" + "function f(o, x) { if (x) {o.x = x;} else {o.x = 'a';}\nreturn o.x; }", "inconsistent return type\n" + "found : (number|string)\n" + "required: string"); } public void testMismatchingOverridingInferredPropertyBeforeDeclaredProperty1() throws Exception { testTypes("/** @constructor */var T = function() { this.x = ''; };\n" + "/** @type {number} */ T.prototype.x = 0;", "assignment to property x of T\n" + "found : string\n" + "required: number"); } public void testMismatchingOverridingInferredPropertyBeforeDeclaredProperty2() throws Exception { testTypes("/** @constructor */var T = function() { this.x = ''; };\n" + "/** @type {number} */ T.prototype.x;", "assignment to property x of T\n" + "found : string\n" + "required: number"); } public void testMismatchingOverridingInferredPropertyBeforeDeclaredProperty3() throws Exception { testTypes("/** @type {Object} */ var n = {};\n" + "/** @constructor */ n.T = function() { this.x = ''; };\n" + "/** @type {number} */ n.T.prototype.x = 0;", "assignment to property x of n.T\n" + "found : string\n" + "required: number"); } public void testMismatchingOverridingInferredPropertyBeforeDeclaredProperty4() throws Exception { testTypes("var n = {};\n" + "/** @constructor */ n.T = function() { this.x = ''; };\n" + "/** @type {number} */ n.T.prototype.x = 0;", "assignment to property x of n.T\n" + "found : string\n" + "required: number"); } public void testPropertyUsedBeforeDefinition1() throws Exception { testTypes("/** @constructor */ var T = function() {};\n" + "/** @return {string} */" + "T.prototype.f = function() { return this.g(); };\n" + "/** @return {number} */ T.prototype.g = function() { return 1; };\n", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testPropertyUsedBeforeDefinition2() throws Exception { testTypes("var n = {};\n" + "/** @constructor */ n.T = function() {};\n" + "/** @return {string} */" + "n.T.prototype.f = function() { return this.g(); };\n" + "/** @return {number} */ n.T.prototype.g = function() { return 1; };\n", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testAdd1() throws Exception { testTypes("/**@return {void}*/function foo(){var a = 'abc'+foo();}"); } public void testAdd2() throws Exception { testTypes("/**@return {void}*/function foo(){var a = foo()+4;}"); } public void testAdd3() throws Exception { testTypes("/** @type {string} */ var a = 'a';" + "/** @type {string} */ var b = 'b';" + "/** @type {string} */ var c = a + b;"); } public void testAdd4() throws Exception { testTypes("/** @type {number} */ var a = 5;" + "/** @type {string} */ var b = 'b';" + "/** @type {string} */ var c = a + b;"); } public void testAdd5() throws Exception { testTypes("/** @type {string} */ var a = 'a';" + "/** @type {number} */ var b = 5;" + "/** @type {string} */ var c = a + b;"); } public void testAdd6() throws Exception { testTypes("/** @type {number} */ var a = 5;" + "/** @type {number} */ var b = 5;" + "/** @type {number} */ var c = a + b;"); } public void testAdd7() throws Exception { testTypes("/** @type {number} */ var a = 5;" + "/** @type {string} */ var b = 'b';" + "/** @type {number} */ var c = a + b;", "initializing variable\n" + "found : string\n" + "required: number"); } public void testAdd8() throws Exception { testTypes("/** @type {string} */ var a = 'a';" + "/** @type {number} */ var b = 5;" + "/** @type {number} */ var c = a + b;", "initializing variable\n" + "found : string\n" + "required: number"); } public void testAdd9() throws Exception { testTypes("/** @type {number} */ var a = 5;" + "/** @type {number} */ var b = 5;" + "/** @type {string} */ var c = a + b;", "initializing variable\n" + "found : number\n" + "required: string"); } public void testAdd10() throws Exception { // d.e.f will have unknown type. testTypes( suppressMissingProperty("e", "f") + "/** @type {number} */ var a = 5;" + "/** @type {string} */ var c = a + d.e.f;"); } public void testAdd11() throws Exception { // d.e.f will have unknown type. testTypes( suppressMissingProperty("e", "f") + "/** @type {number} */ var a = 5;" + "/** @type {number} */ var c = a + d.e.f;"); } public void testAdd12() throws Exception { testTypes("/** @return {(number,string)} */ function a() { return 5; }" + "/** @type {number} */ var b = 5;" + "/** @type {boolean} */ var c = a() + b;", "initializing variable\n" + "found : (number|string)\n" + "required: boolean"); } public void testAdd13() throws Exception { testTypes("/** @type {number} */ var a = 5;" + "/** @return {(number,string)} */ function b() { return 5; }" + "/** @type {boolean} */ var c = a + b();", "initializing variable\n" + "found : (number|string)\n" + "required: boolean"); } public void testAdd14() throws Exception { testTypes("/** @type {(null,string)} */ var a = null;" + "/** @type {number} */ var b = 5;" + "/** @type {boolean} */ var c = a + b;", "initializing variable\n" + "found : (number|string)\n" + "required: boolean"); } public void testAdd15() throws Exception { testTypes("/** @type {number} */ var a = 5;" + "/** @return {(number,string)} */ function b() { return 5; }" + "/** @type {boolean} */ var c = a + b();", "initializing variable\n" + "found : (number|string)\n" + "required: boolean"); } public void testAdd16() throws Exception { testTypes("/** @type {(undefined,string)} */ var a = undefined;" + "/** @type {number} */ var b = 5;" + "/** @type {boolean} */ var c = a + b;", "initializing variable\n" + "found : (number|string)\n" + "required: boolean"); } public void testAdd17() throws Exception { testTypes("/** @type {number} */ var a = 5;" + "/** @type {(undefined,string)} */ var b = undefined;" + "/** @type {boolean} */ var c = a + b;", "initializing variable\n" + "found : (number|string)\n" + "required: boolean"); } public void testAdd18() throws Exception { testTypes("function f() {};" + "/** @type {string} */ var a = 'a';" + "/** @type {number} */ var c = a + f();", "initializing variable\n" + "found : string\n" + "required: number"); } public void testAdd19() throws Exception { testTypes("/** @param {number} opt_x\n@param {number} opt_y\n" + "@return {number} */ function f(opt_x, opt_y) {" + "return opt_x + opt_y;}"); } public void testAdd20() throws Exception { testTypes("/** @param {!Number} opt_x\n@param {!Number} opt_y\n" + "@return {number} */ function f(opt_x, opt_y) {" + "return opt_x + opt_y;}"); } public void testAdd21() throws Exception { testTypes("/** @param {Number|Boolean} opt_x\n" + "@param {number|boolean} opt_y\n" + "@return {number} */ function f(opt_x, opt_y) {" + "return opt_x + opt_y;}"); } public void testNumericComparison1() throws Exception { testTypes("/**@param {number} a*/ function f(a) {return a < 3;}"); } public void testNumericComparison2() throws Exception { testTypes("/**@param {!Object} a*/ function f(a) {return a < 3;}", "left side of numeric comparison\n" + "found : Object\n" + "required: number"); } public void testNumericComparison3() throws Exception { testTypes("/**@param {string} a*/ function f(a) {return a < 3;}"); } public void testNumericComparison4() throws Exception { testTypes("/**@param {(number,undefined)} a*/ " + "function f(a) {return a < 3;}"); } public void testNumericComparison5() throws Exception { testTypes("/**@param {*} a*/ function f(a) {return a < 3;}", "left side of numeric comparison\n" + "found : *\n" + "required: number"); } public void testNumericComparison6() throws Exception { testTypes("/**@return {void}*/ function foo() { if (3 >= foo()) return; }", "right side of numeric comparison\n" + "found : undefined\n" + "required: number"); } public void testStringComparison1() throws Exception { testTypes("/**@param {string} a*/ function f(a) {return a < 'x';}"); } public void testStringComparison2() throws Exception { testTypes("/**@param {Object} a*/ function f(a) {return a < 'x';}"); } public void testStringComparison3() throws Exception { testTypes("/**@param {number} a*/ function f(a) {return a < 'x';}"); } public void testStringComparison4() throws Exception { testTypes("/**@param {string|undefined} a*/ " + "function f(a) {return a < 'x';}"); } public void testStringComparison5() throws Exception { testTypes("/**@param {*} a*/ " + "function f(a) {return a < 'x';}"); } public void testStringComparison6() throws Exception { testTypes("/**@return {void} */ " + "function foo() { if ('a' >= foo()) return; }", "right side of comparison\n" + "found : undefined\n" + "required: string"); } public void testValueOfComparison1() throws Exception { testTypes("/** @constructor */function O() {};" + "/**@override*/O.prototype.valueOf = function() { return 1; };" + "/**@param {!O} a\n@param {!O} b*/ function f(a,b) { return a < b; }"); } public void testValueOfComparison2() throws Exception { testTypes("/** @constructor */function O() {};" + "/**@override*/O.prototype.valueOf = function() { return 1; };" + "/**@param {!O} a\n@param {number} b*/" + "function f(a,b) { return a < b; }"); } public void testValueOfComparison3() throws Exception { testTypes("/** @constructor */function O() {};" + "/**@override*/O.prototype.toString = function() { return 'o'; };" + "/**@param {!O} a\n@param {string} b*/" + "function f(a,b) { return a < b; }"); } public void testGenericRelationalExpression() throws Exception { testTypes("/**@param {*} a\n@param {*} b*/ " + "function f(a,b) {return a < b;}"); } public void testInstanceof1() throws Exception { testTypes("function foo(){" + "if (bar instanceof 3)return;}", "instanceof requires an object\n" + "found : number\n" + "required: Object"); } public void testInstanceof2() throws Exception { testTypes("/**@return {void}*/function foo(){" + "if (foo() instanceof Object)return;}", "deterministic instanceof yields false\n" + "found : undefined\n" + "required: NoObject"); } public void testInstanceof3() throws Exception { testTypes("/**@return {*} */function foo(){" + "if (foo() instanceof Object)return;}"); } public void testInstanceof4() throws Exception { testTypes("/**@return {(Object|number)} */function foo(){" + "if (foo() instanceof Object)return 3;}"); } public void testInstanceof5() throws Exception { // No warning for unknown types. testTypes("/** @return {?} */ function foo(){" + "if (foo() instanceof Object)return;}"); } public void testInstanceof6() throws Exception { testTypes("/**@return {(Array|number)} */function foo(){" + "if (foo() instanceof Object)return 3;}"); } public void testInstanceOfReduction3() throws Exception { testTypes( "/** \n" + " * @param {Object} x \n" + " * @param {Function} y \n" + " * @return {boolean} \n" + " */\n" + "var f = function(x, y) {\n" + " return x instanceof y;\n" + "};"); } public void testScoping1() throws Exception { testTypes( "/**@param {string} a*/function foo(a){" + " /**@param {Array|string} a*/function bar(a){" + " if (a instanceof Array)return;" + " }" + "}"); } public void testScoping2() throws Exception { testTypes( "/** @type number */ var a;" + "function Foo() {" + " /** @type string */ var a;" + "}"); } public void testScoping3() throws Exception { testTypes("\n\n/** @type{Number}*/var b;\n/** @type{!String} */var b;", "variable b redefined with type String, original " + "definition at [testcode]:3 with type (Number|null|undefined)"); } public void testScoping4() throws Exception { testTypes("/** @type{Number}*/var b; if (true) /** @type{!String} */var b;", "variable b redefined with type String, original " + "definition at [testcode]:1 with type (Number|null|undefined)"); } public void testScoping5() throws Exception { // multiple definitions are not checked by the type checker but by a // subsequent pass testTypes("if (true) var b; var b;"); } public void testScoping6() throws Exception { // multiple definitions are not checked by the type checker but by a // subsequent pass testTypes("if (true) var b; if (true) var b;"); } public void testScoping7() throws Exception { testTypes("/** @constructor */function A() {" + " /** @type !A */this.a = null;" + "}", "assignment to property a of A\n" + "found : null\n" + "required: A"); } public void testScoping8() throws Exception { testTypes("/** @constructor */function A() {}" + "/** @constructor */function B() {" + " /** @type !A */this.a = null;" + "}", "assignment to property a of B\n" + "found : null\n" + "required: A"); } public void testScoping9() throws Exception { testTypes("/** @constructor */function B() {" + " /** @type !A */this.a = null;" + "}" + "/** @constructor */function A() {}", "assignment to property a of B\n" + "found : null\n" + "required: A"); } public void testScoping10() throws Exception { TypeCheckResult p = parseAndTypeCheckWithScope("var a = function b(){};"); // a declared, b is not assertTrue(p.scope.isDeclared("a", false)); assertFalse(p.scope.isDeclared("b", false)); // checking that a has the correct assigned type assertEquals("function (): undefined", p.scope.getVar("a").getType().toString()); } public void testScoping11() throws Exception { // named anonymous functions create a binding in their body only // the return is wrong but the assignment is OK since the type of b is ? testTypes( "/** @return {number} */var a = function b(){ return b };", "inconsistent return type\n" + "found : function (): number\n" + "required: number"); } public void testFunctionArguments1() throws Exception { testFunctionType( "/** @param {number} a\n@return {string} */" + "function f(a) {}", "function (number): string"); } public void testFunctionArguments2() throws Exception { testFunctionType( "/** @param {number} opt_a\n@return {string} */" + "function f(opt_a) {}", "function (number=): string"); } public void testFunctionArguments3() throws Exception { testFunctionType( "/** @param {number} b\n@return {string} */" + "function f(a,b) {}", "function (?, number): string"); } public void testFunctionArguments4() throws Exception { testFunctionType( "/** @param {number} opt_a\n@return {string} */" + "function f(a,opt_a) {}", "function (?, number=): string"); } public void testFunctionArguments5() throws Exception { testTypes( "function a(opt_a,a) {}", "optional arguments must be at the end"); } public void testFunctionArguments6() throws Exception { testTypes( "function a(var_args,a) {}", "variable length argument must be last"); } public void testFunctionArguments7() throws Exception { testTypes( "/** @param {number} opt_a\n@return {string} */" + "function a(a,opt_a,var_args) {}"); } public void testFunctionArguments8() throws Exception { testTypes( "function a(a,opt_a,var_args,b) {}", "variable length argument must be last"); } public void testFunctionArguments9() throws Exception { // testing that only one error is reported testTypes( "function a(a,opt_a,var_args,b,c) {}", "variable length argument must be last"); } public void testFunctionArguments10() throws Exception { // testing that only one error is reported testTypes( "function a(a,opt_a,b,c) {}", "optional arguments must be at the end"); } public void testFunctionArguments11() throws Exception { testTypes( "function a(a,opt_a,b,c,var_args,d) {}", "optional arguments must be at the end"); } public void testFunctionArguments12() throws Exception { testTypes("/** @param foo {String} */function bar(baz){}", "parameter foo does not appear in bar's parameter list"); } public void testFunctionArguments13() throws Exception { // verifying that the argument type have non-inferable types testTypes( "/** @return {boolean} */ function u() { return true; }" + "/** @param {boolean} b\n@return {?boolean} */" + "function f(b) { if (u()) { b = null; } return b; }", "assignment\n" + "found : null\n" + "required: boolean"); } public void testFunctionArguments14() throws Exception { testTypes( "/**\n" + " * @param {string} x\n" + " * @param {number} opt_y\n" + " * @param {boolean} var_args\n" + " */ function f(x, opt_y, var_args) {}" + "f('3'); f('3', 2); f('3', 2, true); f('3', 2, true, false);"); } public void testFunctionArguments15() throws Exception { testTypes( "/** @param {?function(*)} f */" + "function g(f) { f(1, 2); }", "Function f: called with 2 argument(s). " + "Function requires at least 1 argument(s) " + "and no more than 1 argument(s)."); } public void testPrintFunctionName1() throws Exception { // Ensures that the function name is pretty. testTypes( "var goog = {}; goog.run = function(f) {};" + "goog.run();", "Function goog.run: called with 0 argument(s). " + "Function requires at least 1 argument(s) " + "and no more than 1 argument(s)."); } public void testPrintFunctionName2() throws Exception { testTypes( "/** @constructor */ var Foo = function() {}; " + "Foo.prototype.run = function(f) {};" + "(new Foo).run();", "Function Foo.prototype.run: called with 0 argument(s). " + "Function requires at least 1 argument(s) " + "and no more than 1 argument(s)."); } public void testFunctionInference1() throws Exception { testFunctionType( "function f(a) {}", "function (?): undefined"); } public void testFunctionInference2() throws Exception { testFunctionType( "function f(a,b) {}", "function (?, ?): undefined"); } public void testFunctionInference3() throws Exception { testFunctionType( "function f(var_args) {}", "function (...[?]): undefined"); } public void testFunctionInference4() throws Exception { testFunctionType( "function f(a,b,c,var_args) {}", "function (?, ?, ?, ...[?]): undefined"); } public void testFunctionInference5() throws Exception { testFunctionType( "/** @this Date\n@return {string} */function f(a) {}", "function (this:Date, ?): string"); } public void testFunctionInference6() throws Exception { testFunctionType( "/** @this Date\n@return {string} */function f(opt_a) {}", "function (this:Date, ?=): string"); } public void testFunctionInference7() throws Exception { testFunctionType( "/** @this Date */function f(a,b,c,var_args) {}", "function (this:Date, ?, ?, ?, ...[?]): undefined"); } public void testFunctionInference8() throws Exception { testFunctionType( "function f() {}", "function (): undefined"); } public void testFunctionInference9() throws Exception { testFunctionType( "var f = function() {};", "function (): undefined"); } public void testFunctionInference10() throws Exception { testFunctionType( "/** @this Date\n@param {boolean} b\n@return {string} */" + "var f = function(a,b) {};", "function (this:Date, ?, boolean): string"); } public void testFunctionInference11() throws Exception { testFunctionType( "var goog = {};" + "/** @return {number}*/goog.f = function(){};", "goog.f", "function (): number"); } public void testFunctionInference12() throws Exception { testFunctionType( "var goog = {};" + "goog.f = function(){};", "goog.f", "function (): undefined"); } public void testFunctionInference13() throws Exception { testFunctionType( "var goog = {};" + "/** @constructor */ goog.Foo = function(){};" + "/** @param {!goog.Foo} f */function eatFoo(f){};", "eatFoo", "function (goog.Foo): undefined"); } public void testFunctionInference14() throws Exception { testFunctionType( "var goog = {};" + "/** @constructor */ goog.Foo = function(){};" + "/** @return {!goog.Foo} */function eatFoo(){ return new goog.Foo; };", "eatFoo", "function (): goog.Foo"); } public void testFunctionInference15() throws Exception { testFunctionType( "/** @constructor */ function f() {};" + "f.prototype.foo = function(){};", "f.prototype.foo", "function (this:f): undefined"); } public void testFunctionInference16() throws Exception { testFunctionType( "/** @constructor */ function f() {};" + "f.prototype.foo = function(){};", "(new f).foo", "function (this:f): undefined"); } public void testFunctionInference17() throws Exception { testFunctionType( "/** @constructor */ function f() {}" + "function abstractMethod() {}" + "/** @param {number} x */ f.prototype.foo = abstractMethod;", "(new f).foo", "function (this:f, number): ?"); } public void testFunctionInference18() throws Exception { testFunctionType( "var goog = {};" + "/** @this {Date} */ goog.eatWithDate;", "goog.eatWithDate", "function (this:Date): ?"); } public void testFunctionInference19() throws Exception { testFunctionType( "/** @param {string} x */ var f;", "f", "function (string): ?"); } public void testFunctionInference20() throws Exception { testFunctionType( "/** @this {Date} */ var f;", "f", "function (this:Date): ?"); } public void testInnerFunction1() throws Exception { testTypes( "function f() {" + " /** @type {number} */ var x = 3;\n" + " function g() { x = null; }" + " return x;" + "}", "assignment\n" + "found : null\n" + "required: number"); } public void testInnerFunction2() throws Exception { testTypes( "/** @return {number} */\n" + "function f() {" + " var x = null;\n" + " function g() { x = 3; }" + " g();" + " return x;" + "}", "inconsistent return type\n" + "found : (null|number)\n" + "required: number"); } public void testInnerFunction3() throws Exception { testTypes( "var x = null;" + "/** @return {number} */\n" + "function f() {" + " x = 3;\n" + " /** @return {number} */\n" + " function g() { x = true; return x; }" + " return x;" + "}", "inconsistent return type\n" + "found : boolean\n" + "required: number"); } public void testInnerFunction4() throws Exception { testTypes( "var x = null;" + "/** @return {number} */\n" + "function f() {" + " x = '3';\n" + " /** @return {number} */\n" + " function g() { x = 3; return x; }" + " return x;" + "}", "inconsistent return type\n" + "found : string\n" + "required: number"); } public void testInnerFunction5() throws Exception { testTypes( "/** @return {number} */\n" + "function f() {" + " var x = 3;\n" + " /** @return {number} */" + " function g() { var x = 3;x = true; return x; }" + " return x;" + "}", "inconsistent return type\n" + "found : boolean\n" + "required: number"); } public void testInnerFunction6() throws Exception { testClosureTypes( CLOSURE_DEFS + "function f() {" + " var x = 0 || function() {};\n" + " function g() { if (goog.isFunction(x)) { x(1); } }" + " g();" + "}", "Function x: called with 1 argument(s). " + "Function requires at least 0 argument(s) " + "and no more than 0 argument(s)."); } public void testInnerFunction7() throws Exception { testClosureTypes( CLOSURE_DEFS + "function f() {" + " /** @type {number|function()} */" + " var x = 0 || function() {};\n" + " function g() { if (goog.isFunction(x)) { x(1); } }" + " g();" + "}", "Function x: called with 1 argument(s). " + "Function requires at least 0 argument(s) " + "and no more than 0 argument(s)."); } public void testInnerFunction8() throws Exception { testClosureTypes( CLOSURE_DEFS + "function f() {" + " function x() {};\n" + " function g() { if (goog.isFunction(x)) { x(1); } }" + " g();" + "}", "Function x: called with 1 argument(s). " + "Function requires at least 0 argument(s) " + "and no more than 0 argument(s)."); } public void testInnerFunction9() throws Exception { testTypes( "function f() {" + " var x = 3;\n" + " function g() { x = null; };\n" + " function h() { return x == null; }" + " return h();" + "}"); } public void testAbstractMethodHandling1() throws Exception { testTypes( "/** @type {Function} */ var abstractFn = function() {};" + "abstractFn(1);"); } public void testAbstractMethodHandling2() throws Exception { testTypes( "var abstractFn = function() {};" + "abstractFn(1);", "Function abstractFn: called with 1 argument(s). " + "Function requires at least 0 argument(s) " + "and no more than 0 argument(s)."); } public void testAbstractMethodHandling3() throws Exception { testTypes( "var goog = {};" + "/** @type {Function} */ goog.abstractFn = function() {};" + "goog.abstractFn(1);"); } public void testAbstractMethodHandling4() throws Exception { testTypes( "var goog = {};" + "goog.abstractFn = function() {};" + "goog.abstractFn(1);", "Function goog.abstractFn: called with 1 argument(s). " + "Function requires at least 0 argument(s) " + "and no more than 0 argument(s)."); } public void testAbstractMethodHandling5() throws Exception { testTypes( "/** @type {!Function} */ var abstractFn = function() {};" + "/** @param {number} x */ var f = abstractFn;" + "f('x');", "actual parameter 1 of f does not match formal parameter\n" + "found : string\n" + "required: number"); } public void testAbstractMethodHandling6() throws Exception { testTypes( "var goog = {};" + "/** @type {Function} */ goog.abstractFn = function() {};" + "/** @param {number} x */ goog.f = abstractFn;" + "goog.f('x');", "actual parameter 1 of goog.f does not match formal parameter\n" + "found : string\n" + "required: number"); } public void testMethodInference1() throws Exception { testTypes( "/** @constructor */ function F() {}" + "/** @return {number} */ F.prototype.foo = function() { return 3; };" + "/** @constructor \n * @extends {F} */ " + "function G() {}" + "/** @override */ G.prototype.foo = function() { return true; };", "inconsistent return type\n" + "found : boolean\n" + "required: number"); } public void testMethodInference2() throws Exception { testTypes( "var goog = {};" + "/** @constructor */ goog.F = function() {};" + "/** @return {number} */ goog.F.prototype.foo = " + " function() { return 3; };" + "/** @constructor \n * @extends {goog.F} */ " + "goog.G = function() {};" + "/** @override */ goog.G.prototype.foo = function() { return true; };", "inconsistent return type\n" + "found : boolean\n" + "required: number"); } public void testMethodInference3() throws Exception { testTypes( "/** @constructor */ function F() {}" + "/** @param {boolean} x \n * @return {number} */ " + "F.prototype.foo = function(x) { return 3; };" + "/** @constructor \n * @extends {F} */ " + "function G() {}" + "/** @override */ " + "G.prototype.foo = function(x) { return x; };", "inconsistent return type\n" + "found : boolean\n" + "required: number"); } public void testMethodInference4() throws Exception { testTypes( "/** @constructor */ function F() {}" + "/** @param {boolean} x \n * @return {number} */ " + "F.prototype.foo = function(x) { return 3; };" + "/** @constructor \n * @extends {F} */ " + "function G() {}" + "/** @override */ " + "G.prototype.foo = function(y) { return y; };", "inconsistent return type\n" + "found : boolean\n" + "required: number"); } public void testMethodInference5() throws Exception { testTypes( "/** @constructor */ function F() {}" + "/** @param {number} x \n * @return {string} */ " + "F.prototype.foo = function(x) { return 'x'; };" + "/** @constructor \n * @extends {F} */ " + "function G() {}" + "/** @type {number} */ G.prototype.num = 3;" + "/** @override */ " + "G.prototype.foo = function(y) { return this.num + y; };", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testMethodInference6() throws Exception { testTypes( "/** @constructor */ function F() {}" + "/** @param {number} x */ F.prototype.foo = function(x) { };" + "/** @constructor \n * @extends {F} */ " + "function G() {}" + "/** @override */ G.prototype.foo = function() { };" + "(new G()).foo(1);"); } public void testMethodInference7() throws Exception { testTypes( "/** @constructor */ function F() {}" + "F.prototype.foo = function() { };" + "/** @constructor \n * @extends {F} */ " + "function G() {}" + "/** @override */ G.prototype.foo = function(x, y) { };", "mismatch of the foo property type and the type of the property " + "it overrides from superclass F\n" + "original: function (this:F): undefined\n" + "override: function (this:G, ?, ?): undefined"); } public void testMethodInference8() throws Exception { testTypes( "/** @constructor */ function F() {}" + "F.prototype.foo = function() { };" + "/** @constructor \n * @extends {F} */ " + "function G() {}" + "/** @override */ " + "G.prototype.foo = function(opt_b, var_args) { };" + "(new G()).foo(1, 2, 3);"); } public void testMethodInference9() throws Exception { testTypes( "/** @constructor */ function F() {}" + "F.prototype.foo = function() { };" + "/** @constructor \n * @extends {F} */ " + "function G() {}" + "/** @override */ " + "G.prototype.foo = function(var_args, opt_b) { };", "variable length argument must be last"); } public void testStaticMethodDeclaration1() throws Exception { testTypes( "/** @constructor */ function F() { F.foo(true); }" + "/** @param {number} x */ F.foo = function(x) {};", "actual parameter 1 of F.foo does not match formal parameter\n" + "found : boolean\n" + "required: number"); } public void testStaticMethodDeclaration2() throws Exception { testTypes( "var goog = goog || {}; function f() { goog.foo(true); }" + "/** @param {number} x */ goog.foo = function(x) {};", "actual parameter 1 of goog.foo does not match formal parameter\n" + "found : boolean\n" + "required: number"); } public void testStaticMethodDeclaration3() throws Exception { testTypes( "var goog = goog || {}; function f() { goog.foo(true); }" + "goog.foo = function() {};", "Function goog.foo: called with 1 argument(s). Function requires " + "at least 0 argument(s) and no more than 0 argument(s)."); } public void testDuplicateStaticMethodDecl1() throws Exception { testTypes( "var goog = goog || {};" + "/** @param {number} x */ goog.foo = function(x) {};" + "/** @param {number} x */ goog.foo = function(x) {};", "variable goog.foo redefined with type function (number): undefined, " + "original definition at [testcode]:1 " + "with type function (number): undefined"); } public void testDuplicateStaticMethodDecl2() throws Exception { testTypes( "var goog = goog || {};" + "/** @param {number} x */ goog.foo = function(x) {};" + "/** @param {number} x \n * @suppress {duplicate} */ " + "goog.foo = function(x) {};"); } public void testDuplicateStaticMethodDecl3() throws Exception { testTypes( "var goog = goog || {};" + "goog.foo = function(x) {};" + "goog.foo = function(x) {};"); } public void testDuplicateStaticMethodDecl4() throws Exception { testTypes( "var goog = goog || {};" + "/** @type {Function} */ goog.foo = function(x) {};" + "goog.foo = function(x) {};"); } public void testDuplicateStaticMethodDecl5() throws Exception { testTypes( "var goog = goog || {};" + "goog.foo = function(x) {};" + "/** @return {undefined} */ goog.foo = function(x) {};", "variable goog.foo redefined with type function (?): undefined, " + "original definition at [testcode]:1 with type " + "function (?): undefined"); } public void testDuplicateStaticPropertyDecl1() throws Exception { testTypes( "var goog = goog || {};" + "/** @type {Foo} */ goog.foo;" + "/** @type {Foo} */ goog.foo;" + "/** @constructor */ function Foo() {}"); } public void testDuplicateStaticPropertyDecl2() throws Exception { testTypes( "var goog = goog || {};" + "/** @type {Foo} */ goog.foo;" + "/** @type {Foo} \n * @suppress {duplicate} */ goog.foo;" + "/** @constructor */ function Foo() {}"); } public void testDuplicateStaticPropertyDecl3() throws Exception { testTypes( "var goog = goog || {};" + "/** @type {!Foo} */ goog.foo;" + "/** @type {string} */ goog.foo;" + "/** @constructor */ function Foo() {}", "variable goog.foo redefined with type string, " + "original definition at [testcode]:1 with type Foo"); } public void testDuplicateStaticPropertyDecl4() throws Exception { testClosureTypesMultipleWarnings( "var goog = goog || {};" + "/** @type {!Foo} */ goog.foo;" + "/** @type {string} */ goog.foo = 'x';" + "/** @constructor */ function Foo() {}", Lists.newArrayList( "assignment to property foo of goog\n" + "found : string\n" + "required: Foo", "variable goog.foo redefined with type string, " + "original definition at [testcode]:1 with type Foo")); } public void testDuplicateStaticPropertyDecl5() throws Exception { testClosureTypesMultipleWarnings( "var goog = goog || {};" + "/** @type {!Foo} */ goog.foo;" + "/** @type {string}\n * @suppress {duplicate} */ goog.foo = 'x';" + "/** @constructor */ function Foo() {}", Lists.newArrayList( "assignment to property foo of goog\n" + "found : string\n" + "required: Foo", "variable goog.foo redefined with type string, " + "original definition at [testcode]:1 with type Foo")); } public void testDuplicateStaticPropertyDecl6() throws Exception { testTypes( "var goog = goog || {};" + "/** @type {string} */ goog.foo = 'y';" + "/** @type {string}\n * @suppress {duplicate} */ goog.foo = 'x';"); } public void testDuplicateStaticPropertyDecl7() throws Exception { testTypes( "var goog = goog || {};" + "/** @param {string} x */ goog.foo;" + "/** @type {function(string)} */ goog.foo;"); } public void testDuplicateStaticPropertyDecl8() throws Exception { testTypes( "var goog = goog || {};" + "/** @return {EventCopy} */ goog.foo;" + "/** @constructor */ function EventCopy() {}" + "/** @return {EventCopy} */ goog.foo;"); } public void testDuplicateStaticPropertyDecl9() throws Exception { testTypes( "var goog = goog || {};" + "/** @return {EventCopy} */ goog.foo;" + "/** @return {EventCopy} */ goog.foo;" + "/** @constructor */ function EventCopy() {}"); } public void testDuplicateLocalVarDecl() throws Exception { testClosureTypesMultipleWarnings( "/** @param {number} x */\n" + "function f(x) { /** @type {string} */ var x = ''; }", Lists.newArrayList( "variable x redefined with type string, original definition" + " at [testcode]:2 with type number", "initializing variable\n" + "found : string\n" + "required: number")); } public void testStubFunctionDeclaration1() throws Exception { testFunctionType( "/** @constructor */ function f() {};" + "/** @param {number} x \n * @param {string} y \n" + " * @return {number} */ f.prototype.foo;", "(new f).foo", "function (this:f, number, string): number"); } public void testStubFunctionDeclaration2() throws Exception { testExternFunctionType( // externs "/** @constructor */ function f() {};" + "/** @constructor \n * @extends {f} */ f.subclass;", "f.subclass", "function (new:f.subclass): ?"); } public void testStubFunctionDeclaration3() throws Exception { testFunctionType( "/** @constructor */ function f() {};" + "/** @return {undefined} */ f.foo;", "f.foo", "function (): undefined"); } public void testStubFunctionDeclaration4() throws Exception { testFunctionType( "/** @constructor */ function f() { " + " /** @return {number} */ this.foo;" + "}", "(new f).foo", "function (this:f): number"); } public void testStubFunctionDeclaration5() throws Exception { testFunctionType( "/** @constructor */ function f() { " + " /** @type {Function} */ this.foo;" + "}", "(new f).foo", createOptionalType(createNullableType(U2U_CONSTRUCTOR_TYPE)) .toString()); } public void testStubFunctionDeclaration6() throws Exception { testFunctionType( "/** @constructor */ function f() {} " + "/** @type {Function} */ f.prototype.foo;", "(new f).foo", createOptionalType(createNullableType(U2U_CONSTRUCTOR_TYPE)) .toString()); } public void testStubFunctionDeclaration7() throws Exception { testFunctionType( "/** @constructor */ function f() {} " + "/** @type {Function} */ f.prototype.foo = function() {};", "(new f).foo", createOptionalType(createNullableType(U2U_CONSTRUCTOR_TYPE)) .toString()); } public void testStubFunctionDeclaration8() throws Exception { testFunctionType( "/** @type {Function} */ var f = function() {}; ", "f", createOptionalType(createNullableType(U2U_CONSTRUCTOR_TYPE)) .toString()); } public void testStubFunctionDeclaration9() throws Exception { testFunctionType( "/** @type {function():number} */ var f; ", "f", "function (): number"); } public void testStubFunctionDeclaration10() throws Exception { testFunctionType( "/** @type {function(number):number} */ var f = function(x) {};", "f", "function (number): number"); } public void testNestedFunctionInference1() throws Exception { String nestedAssignOfFooAndBar = "/** @constructor */ function f() {};" + "f.prototype.foo = f.prototype.bar = function(){};"; testFunctionType(nestedAssignOfFooAndBar, "(new f).bar", "function (this:f): undefined"); } /** * Tests the type of a function definition. The function defined by * {@code functionDef} should be named {@code "f"}. */ private void testFunctionType(String functionDef, String functionType) throws Exception { testFunctionType(functionDef, "f", functionType); } /** * Tests the type of a function definition. The function defined by * {@code functionDef} should be named {@code functionName}. */ private void testFunctionType(String functionDef, String functionName, String functionType) throws Exception { // using the variable initialization check to verify the function's type testTypes( functionDef + "/** @type number */var a=" + functionName + ";", "initializing variable\n" + "found : " + functionType + "\n" + "required: number"); } /** * Tests the type of a function definition in externs. * The function defined by {@code functionDef} should be * named {@code functionName}. */ private void testExternFunctionType(String functionDef, String functionName, String functionType) throws Exception { testTypes( functionDef, "/** @type number */var a=" + functionName + ";", "initializing variable\n" + "found : " + functionType + "\n" + "required: number", false); } public void testTypeRedefinition() throws Exception { testClosureTypesMultipleWarnings( "a={};/**@enum {string}*/ a.A = {ZOR:'b'};" + "/** @constructor */ a.A = function() {}", Lists.newArrayList( "variable a.A redefined with type function (new:a.A): undefined, " + "original definition at [testcode]:1 with type enum{a.A}", "assignment to property A of a\n" + "found : function (new:a.A): undefined\n" + "required: enum{a.A}")); } public void testIn1() throws Exception { testTypes("'foo' in Object"); } public void testIn2() throws Exception { testTypes("3 in Object"); } public void testIn3() throws Exception { testTypes("undefined in Object"); } public void testIn4() throws Exception { testTypes("Date in Object", "left side of 'in'\n" + "found : function (new:Date, ?=, ?=, ?=, ?=, ?=, ?=, ?=): string\n" + "required: string"); } public void testIn5() throws Exception { testTypes("'x' in null", "'in' requires an object\n" + "found : null\n" + "required: Object"); } public void testIn6() throws Exception { testTypes( "/** @param {number} x */" + "function g(x) {}" + "g(1 in {});", "actual parameter 1 of g does not match formal parameter\n" + "found : boolean\n" + "required: number"); } public void testIn7() throws Exception { // Make sure we do inference in the 'in' expression. testTypes( "/**\n" + " * @param {number} x\n" + " * @return {number}\n" + " */\n" + "function g(x) { return 5; }" + "function f() {" + " var x = {};" + " x.foo = '3';" + " return g(x.foo) in {};" + "}", "actual parameter 1 of g does not match formal parameter\n" + "found : string\n" + "required: number"); } // TODO(nicksantos): change this to something that makes sense. // public void testComparison1() throws Exception { // testTypes("/**@type null */var a;" + // "/**@type !Date */var b;" + // "if (a==b) {}", // "condition always evaluates to false\n" + // "left : null\n" + // "right: Date"); // } public void testComparison2() throws Exception { testTypes("/**@type number*/var a;" + "/**@type !Date */var b;" + "if (a!==b) {}", "condition always evaluates to true\n" + "left : number\n" + "right: Date"); } public void testComparison3() throws Exception { // Since null == undefined in JavaScript, this code is reasonable. testTypes("/** @type {(Object,undefined)} */var a;" + "var b = a == null"); } public void testComparison4() throws Exception { testTypes("/** @type {(!Object,undefined)} */var a;" + "/** @type {!Object} */var b;" + "var c = a == b"); } public void testComparison5() throws Exception { testTypes("/** @type null */var a;" + "/** @type null */var b;" + "a == b", "condition always evaluates to true\n" + "left : null\n" + "right: null"); } public void testComparison6() throws Exception { testTypes("/** @type null */var a;" + "/** @type null */var b;" + "a != b", "condition always evaluates to false\n" + "left : null\n" + "right: null"); } public void testComparison7() throws Exception { testTypes("var a;" + "var b;" + "a == b", "condition always evaluates to true\n" + "left : undefined\n" + "right: undefined"); } public void testComparison8() throws Exception { testTypes("/** @type {Array.<string>} */ var a = [];" + "a[0] == null || a[1] == undefined"); } public void testComparison9() throws Exception { testTypes("/** @type {Array.<undefined>} */ var a = [];" + "a[0] == null", "condition always evaluates to true\n" + "left : undefined\n" + "right: null"); } public void testComparison10() throws Exception { testTypes("/** @type {Array.<undefined>} */ var a = [];" + "a[0] === null"); } public void testEnumStaticMethod1() throws Exception { testTypes( "/** @enum */ var Foo = {AAA: 1};" + "/** @param {number} x */ Foo.method = function(x) {};" + "Foo.method(true);", "actual parameter 1 of Foo.method does not match formal parameter\n" + "found : boolean\n" + "required: number"); } public void testEnumStaticMethod2() throws Exception { testTypes( "/** @enum */ var Foo = {AAA: 1};" + "/** @param {number} x */ Foo.method = function(x) {};" + "function f() { Foo.method(true); }", "actual parameter 1 of Foo.method does not match formal parameter\n" + "found : boolean\n" + "required: number"); } public void testEnum1() throws Exception { testTypes("/**@enum*/var a={BB:1,CC:2};\n" + "/**@type {a}*/var d;d=a.BB;"); } public void testEnum2() throws Exception { testTypes("/**@enum*/var a={b:1}", "enum key b must be a syntactic constant"); } public void testEnum3() throws Exception { testTypes("/**@enum*/var a={BB:1,BB:2}", "variable a.BB redefined with type a.<number>, " + "original definition at [testcode]:1 with type a.<number>"); } public void testEnum4() throws Exception { testTypes("/**@enum*/var a={BB:'string'}", "assignment to property BB of enum{a}\n" + "found : string\n" + "required: number"); } public void testEnum5() throws Exception { testTypes("/**@enum {String}*/var a={BB:'string'}", "assignment to property BB of enum{a}\n" + "found : string\n" + "required: (String|null|undefined)"); } public void testEnum6() throws Exception { testTypes("/**@enum*/var a={BB:1,CC:2};\n/**@type {!Array}*/var d;d=a.BB;", "assignment\n" + "found : a.<number>\n" + "required: Array"); } public void testEnum7() throws Exception { testTypes("/** @enum */var a={AA:1,BB:2,CC:3};" + "/** @type a */var b=a.D;", "element D does not exist on this enum"); } public void testEnum8() throws Exception { testClosureTypesMultipleWarnings("/** @enum */var a=8;", Lists.newArrayList( "enum initializer must be an object literal or an enum", "initializing variable\n" + "found : number\n" + "required: enum{a}")); } public void testEnum9() throws Exception { testClosureTypesMultipleWarnings( "var goog = {};" + "/** @enum */goog.a=8;", Lists.newArrayList( "assignment to property a of goog\n" + "found : number\n" + "required: enum{goog.a}", "enum initializer must be an object literal or an enum")); } public void testEnum10() throws Exception { testTypes( "/** @enum {number} */" + "goog.K = { A : 3 };"); } public void testEnum11() throws Exception { testTypes( "/** @enum {number} */" + "goog.K = { 502 : 3 };"); } public void testEnum12() throws Exception { testTypes( "/** @enum {number} */ var a = {};" + "/** @enum */ var b = a;"); } public void testEnum13() throws Exception { testTypes( "/** @enum {number} */ var a = {};" + "/** @enum {string} */ var b = a;", "incompatible enum element types\n" + "found : number\n" + "required: string"); } public void testEnum14() throws Exception { testTypes( "/** @enum {number} */ var a = {FOO:5};" + "/** @enum */ var b = a;" + "var c = b.FOO;"); } public void testEnum15() throws Exception { testTypes( "/** @enum {number} */ var a = {FOO:5};" + "/** @enum */ var b = a;" + "var c = b.BAR;", "element BAR does not exist on this enum"); } public void testEnum16() throws Exception { testTypes("var goog = {};" + "/**@enum*/goog .a={BB:1,BB:2}", "variable goog.a.BB redefined with type goog.a.<number>, " + "original definition at [testcode]:1 with type goog.a.<number>"); } public void testEnum17() throws Exception { testTypes("var goog = {};" + "/**@enum*/goog.a={BB:'string'}", "assignment to property BB of enum{goog.a}\n" + "found : string\n" + "required: number"); } public void testEnum18() throws Exception { testTypes("/**@enum*/ var E = {A: 1, B: 2};" + "/** @param {!E} x\n@return {number} */\n" + "var f = function(x) { return x; };"); } public void testEnum19() throws Exception { testTypes("/**@enum*/ var E = {A: 1, B: 2};" + "/** @param {number} x\n@return {!E} */\n" + "var f = function(x) { return x; };", "inconsistent return type\n" + "found : number\n" + "required: E.<number>"); } public void testEnum20() throws Exception { testTypes("/**@enum*/ var E = {A: 1, B: 2}; var x = []; x[E.A] = 0;"); } public void testEnum21() throws Exception { Node n = parseAndTypeCheck( "/** @enum {string} */ var E = {A : 'a', B : 'b'};\n" + "/** @param {!E} x\n@return {!E} */ function f(x) { return x; }"); Node nodeX = n.getLastChild().getLastChild().getLastChild().getLastChild(); JSType typeE = nodeX.getJSType(); assertFalse(typeE.isObject()); assertFalse(typeE.isNullable()); } public void testEnum22() throws Exception { testTypes("/**@enum*/ var E = {A: 1, B: 2};" + "/** @param {E} x \n* @return {number} */ function f(x) {return x}"); } public void testEnum23() throws Exception { testTypes("/**@enum*/ var E = {A: 1, B: 2};" + "/** @param {E} x \n* @return {string} */ function f(x) {return x}", "inconsistent return type\n" + "found : E.<number>\n" + "required: string"); } public void testEnum24() throws Exception { testTypes("/**@enum {Object} */ var E = {A: {}};" + "/** @param {E} x \n* @return {!Object} */ function f(x) {return x}", "inconsistent return type\n" + "found : E.<(Object|null|undefined)>\n" + "required: Object"); } public void testEnum25() throws Exception { testTypes("/**@enum {!Object} */ var E = {A: {}};" + "/** @param {E} x \n* @return {!Object} */ function f(x) {return x}"); } public void testEnum26() throws Exception { testTypes("var a = {}; /**@enum*/ a.B = {A: 1, B: 2};" + "/** @param {a.B} x \n* @return {number} */ function f(x) {return x}"); } public void testEnum27() throws Exception { // x is unknown testTypes("/** @enum */ var A = {B: 1, C: 2}; " + "function f(x) { return A == x; }"); } public void testEnum28() throws Exception { // x is unknown testTypes("/** @enum */ var A = {B: 1, C: 2}; " + "function f(x) { return A.B == x; }"); } public void testEnum29() throws Exception { testTypes("/** @enum */ var A = {B: 1, C: 2}; " + "/** @return {number} */ function f() { return A; }", "inconsistent return type\n" + "found : enum{A}\n" + "required: number"); } public void testEnum30() throws Exception { testTypes("/** @enum */ var A = {B: 1, C: 2}; " + "/** @return {number} */ function f() { return A.B; }"); } public void testEnum31() throws Exception { testTypes("/** @enum */ var A = {B: 1, C: 2}; " + "/** @return {A} */ function f() { return A; }", "inconsistent return type\n" + "found : enum{A}\n" + "required: A.<number>"); } public void testEnum32() throws Exception { testTypes("/** @enum */ var A = {B: 1, C: 2}; " + "/** @return {A} */ function f() { return A.B; }"); } public void testEnum34() throws Exception { testTypes("/** @enum */ var A = {B: 1, C: 2}; " + "/** @param {number} x */ function f(x) { return x == A.B; }"); } public void testEnum35() throws Exception { testTypes("var a = a || {}; /** @enum */ a.b = {C: 1, D: 2};" + "/** @return {a.b} */ function f() { return a.b.C; }"); } public void testEnum36() throws Exception { testTypes("var a = a || {}; /** @enum */ a.b = {C: 1, D: 2};" + "/** @return {!a.b} */ function f() { return 1; }", "inconsistent return type\n" + "found : number\n" + "required: a.b.<number>"); } public void testEnum37() throws Exception { testTypes( "var goog = goog || {};" + "/** @enum {number} */ goog.a = {};" + "/** @enum */ var b = goog.a;"); } public void testEnum38() throws Exception { testTypes( "/** @enum {MyEnum} */ var MyEnum = {};" + "/** @param {MyEnum} x */ function f(x) {}", "Parse error. Cycle detected in inheritance chain " + "of type MyEnum"); } public void testEnum39() throws Exception { testTypes( "/** @enum {Number} */ var MyEnum = {FOO: new Number(1)};" + "/** @param {MyEnum} x \n * @return {number} */" + "function f(x) { return x == MyEnum.FOO && MyEnum.FOO == x; }", "inconsistent return type\n" + "found : boolean\n" + "required: number"); } public void testEnum40() throws Exception { testTypes( "/** @enum {Number} */ var MyEnum = {FOO: new Number(1)};" + "/** @param {number} x \n * @return {number} */" + "function f(x) { return x == MyEnum.FOO && MyEnum.FOO == x; }", "inconsistent return type\n" + "found : boolean\n" + "required: number"); } public void testAliasedEnum1() throws Exception { testTypes( "/** @enum */ var YourEnum = {FOO: 3};" + "/** @enum */ var MyEnum = YourEnum;" + "/** @param {MyEnum} x */ function f(x) {} f(MyEnum.FOO);"); } public void testAliasedEnum2() throws Exception { testTypes( "/** @enum */ var YourEnum = {FOO: 3};" + "/** @enum */ var MyEnum = YourEnum;" + "/** @param {YourEnum} x */ function f(x) {} f(MyEnum.FOO);"); } public void testAliasedEnum3() throws Exception { testTypes( "/** @enum */ var YourEnum = {FOO: 3};" + "/** @enum */ var MyEnum = YourEnum;" + "/** @param {MyEnum} x */ function f(x) {} f(YourEnum.FOO);"); } public void testAliasedEnum4() throws Exception { testTypes( "/** @enum */ var YourEnum = {FOO: 3};" + "/** @enum */ var MyEnum = YourEnum;" + "/** @param {YourEnum} x */ function f(x) {} f(YourEnum.FOO);"); } public void testAliasedEnum5() throws Exception { testTypes( "/** @enum */ var YourEnum = {FOO: 3};" + "/** @enum */ var MyEnum = YourEnum;" + "/** @param {string} x */ function f(x) {} f(MyEnum.FOO);", "actual parameter 1 of f does not match formal parameter\n" + "found : YourEnum.<number>\n" + "required: string"); } public void testBackwardsEnumUse1() throws Exception { testTypes( "/** @return {string} */ function f() { return MyEnum.FOO; }" + "/** @enum {string} */ var MyEnum = {FOO: 'x'};"); } public void testBackwardsEnumUse2() throws Exception { testTypes( "/** @return {number} */ function f() { return MyEnum.FOO; }" + "/** @enum {string} */ var MyEnum = {FOO: 'x'};", "inconsistent return type\n" + "found : MyEnum.<string>\n" + "required: number"); } public void testBackwardsEnumUse3() throws Exception { testTypes( "/** @return {string} */ function f() { return MyEnum.FOO; }" + "/** @enum {string} */ var YourEnum = {FOO: 'x'};" + "/** @enum {string} */ var MyEnum = YourEnum;"); } public void testBackwardsEnumUse4() throws Exception { testTypes( "/** @return {number} */ function f() { return MyEnum.FOO; }" + "/** @enum {string} */ var YourEnum = {FOO: 'x'};" + "/** @enum {string} */ var MyEnum = YourEnum;", "inconsistent return type\n" + "found : YourEnum.<string>\n" + "required: number"); } public void testBackwardsEnumUse5() throws Exception { testTypes( "/** @return {string} */ function f() { return MyEnum.BAR; }" + "/** @enum {string} */ var YourEnum = {FOO: 'x'};" + "/** @enum {string} */ var MyEnum = YourEnum;", "element BAR does not exist on this enum"); } public void testBackwardsConstructor1() throws Exception { testTypes( "function f() { (new Foo(true)); }" + "/** \n * @constructor \n * @param {number} x */" + "var Foo = function(x) {};", "actual parameter 1 of Foo does not match formal parameter\n" + "found : boolean\n" + "required: number"); } public void testBackwardsConstructor2() throws Exception { testTypes( "function f() { (new Foo(true)); }" + "/** \n * @constructor \n * @param {number} x */" + "var YourFoo = function(x) {};" + "/** \n * @constructor \n * @param {number} x */" + "var Foo = YourFoo;", "actual parameter 1 of Foo does not match formal parameter\n" + "found : boolean\n" + "required: number"); } public void testMinimalConstructorAnnotation() throws Exception { testTypes("/** @constructor */function Foo(){}"); } public void testGoodExtends1() throws Exception { // A minimal @extends example testTypes("/** @constructor */function base() {}\n" + "/** @constructor\n * @extends {base} */function derived() {}\n"); } public void testGoodExtends2() throws Exception { testTypes("/** @constructor\n * @extends base */function derived() {}\n" + "/** @constructor */function base() {}\n"); } public void testGoodExtends3() throws Exception { testTypes("/** @constructor\n * @extends {Object} */function base() {}\n" + "/** @constructor\n * @extends {base} */function derived() {}\n"); } public void testGoodExtends4() throws Exception { // Ensure that @extends actually sets the base type of a constructor // correctly. Because this isn't part of the human-readable Function // definition, we need to crawl the prototype chain (eww). Node n = parseAndTypeCheck( "var goog = {};\n" + "/** @constructor */goog.Base = function(){};\n" + "/** @constructor\n" + " * @extends {goog.Base} */goog.Derived = function(){};\n"); Node subTypeName = n.getLastChild().getLastChild().getFirstChild(); assertEquals("goog.Derived", subTypeName.getQualifiedName()); FunctionType subCtorType = (FunctionType) subTypeName.getNext().getJSType(); assertEquals("goog.Derived", subCtorType.getInstanceType().toString()); JSType superType = subCtorType.getPrototype().getImplicitPrototype(); assertEquals("goog.Base", superType.toString()); } public void testGoodExtends5() throws Exception { // we allow for the extends annotation to be placed first testTypes("/** @constructor */function base() {}\n" + "/** @extends {base}\n * @constructor */function derived() {}\n"); } public void testGoodExtends6() throws Exception { testFunctionType( CLOSURE_DEFS + "/** @constructor */function base() {}\n" + "/** @return {number} */ " + " base.prototype.foo = function() { return 1; };\n" + "/** @extends {base}\n * @constructor */function derived() {}\n" + "goog.inherits(derived, base);", "derived.superClass_.foo", "function (this:base): number"); } public void testGoodExtends7() throws Exception { testFunctionType( "Function.prototype.inherits = function(x) {};" + "/** @constructor */function base() {}\n" + "/** @extends {base}\n * @constructor */function derived() {}\n" + "derived.inherits(base);", "(new derived).constructor", "function (new:derived, ...[?]): ?"); } public void testGoodExtends8() throws Exception { testTypes("/** @constructor \n @extends {Base} */ function Sub() {}" + "/** @return {number} */ function f() { return (new Sub()).foo; }" + "/** @constructor */ function Base() {}" + "/** @type {boolean} */ Base.prototype.foo = true;", "inconsistent return type\n" + "found : boolean\n" + "required: number"); } public void testGoodExtends9() throws Exception { testTypes( "/** @constructor */ function Super() {}" + "Super.prototype.foo = function() {};" + "/** @constructor \n * @extends {Super} */ function Sub() {}" + "Sub.prototype = new Super();" + "/** @override */ Sub.prototype.foo = function() {};"); } public void testGoodExtends10() throws Exception { testTypes( "/** @constructor */ function Super() {}" + "/** @constructor \n * @extends {Super} */ function Sub() {}" + "Sub.prototype = new Super();" + "/** @return {Super} */ function foo() { return new Sub(); }"); } public void testGoodExtends11() throws Exception { testTypes( "/** @constructor */ function Super() {}" + "/** @param {boolean} x */ Super.prototype.foo = function(x) {};" + "/** @constructor \n * @extends {Super} */ function Sub() {}" + "Sub.prototype = new Super();" + "(new Sub()).foo(0);", "actual parameter 1 of Super.prototype.foo " + "does not match formal parameter\n" + "found : number\n" + "required: boolean"); } public void testBadExtends1() throws Exception { testTypes("/** @constructor */function base() {}\n" + "/** @constructor\n * @extends {not_base} */function derived() {}\n", "Bad type annotation. Unknown type not_base"); } public void testBadExtends2() throws Exception { testTypes("/** @constructor */function base() {\n" + "/** @type {!Number}*/\n" + "this.baseMember = new Number(4);\n" + "}\n" + "/** @constructor\n" + " * @extends {base} */function derived() {}\n" + "/** @param {!String} x*/\n" + "function foo(x){ }\n" + "/** @type {!derived}*/var y;\n" + "foo(y.baseMember);\n", "actual parameter 1 of foo does not match formal parameter\n" + "found : Number\n" + "required: String"); } public void testBadExtends3() throws Exception { testTypes("/** @extends {Object} */function base() {}", "@extends used without @constructor or @interface for base"); } public void testLateExtends() throws Exception { testTypes( CLOSURE_DEFS + "/** @constructor */ function Foo() {}\n" + "Foo.prototype.foo = function() {};\n" + "/** @constructor */function Bar() {}\n" + "goog.inherits(Foo, Bar);\n", "Missing @extends tag on type Foo"); } public void testSuperclassMatch() throws Exception { compiler.getOptions().setCodingConvention(new GoogleCodingConvention()); testTypes("/** @constructor */ var Foo = function() {};\n" + "/** @constructor \n @extends Foo */ var Bar = function() {};\n" + "Bar.inherits = function(x){};" + "Bar.inherits(Foo);\n"); } public void testSuperclassMatchWithMixin() throws Exception { compiler.getOptions().setCodingConvention(new GoogleCodingConvention()); testTypes("/** @constructor */ var Foo = function() {};\n" + "/** @constructor */ var Baz = function() {};\n" + "/** @constructor \n @extends Foo */ var Bar = function() {};\n" + "Bar.inherits = function(x){};" + "Bar.mixin = function(y){};" + "Bar.inherits(Foo);\n" + "Bar.mixin(Baz);\n"); } public void testSuperclassMismatch1() throws Exception { compiler.getOptions().setCodingConvention(new GoogleCodingConvention()); testTypes("/** @constructor */ var Foo = function() {};\n" + "/** @constructor \n @extends Object */ var Bar = function() {};\n" + "Bar.inherits = function(x){};" + "Bar.inherits(Foo);\n", "Missing @extends tag on type Bar"); } public void testSuperclassMismatch2() throws Exception { compiler.getOptions().setCodingConvention(new GoogleCodingConvention()); testTypes("/** @constructor */ var Foo = function(){};\n" + "/** @constructor */ var Bar = function(){};\n" + "Bar.inherits = function(x){};" + "Bar.inherits(Foo);", "Missing @extends tag on type Bar"); } public void testSuperClassDefinedAfterSubClass1() throws Exception { testTypes( "/** @constructor \n * @extends {Base} */ function A() {}" + "/** @constructor \n * @extends {Base} */ function B() {}" + "/** @constructor */ function Base() {}" + "/** @param {A|B} x \n * @return {B|A} */ " + "function foo(x) { return x; }"); } public void testSuperClassDefinedAfterSubClass2() throws Exception { testTypes( "/** @constructor \n * @extends {Base} */ function A() {}" + "/** @constructor \n * @extends {Base} */ function B() {}" + "/** @param {A|B} x \n * @return {B|A} */ " + "function foo(x) { return x; }" + "/** @constructor */ function Base() {}"); } public void testDirectPrototypeAssignment1() throws Exception { testTypes( "/** @constructor */ function Base() {}" + "Base.prototype.foo = 3;" + "/** @constructor \n * @extends {Base} */ function A() {}" + "A.prototype = new Base();" + "/** @return {string} */ function foo() { return (new A).foo; }", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testDirectPrototypeAssignment2() throws Exception { // This ensures that we don't attach property 'foo' onto the Base // instance object. testTypes( "/** @constructor */ function Base() {}" + "/** @constructor \n * @extends {Base} */ function A() {}" + "A.prototype = new Base();" + "A.prototype.foo = 3;" + "/** @return {string} */ function foo() { return (new Base).foo; }"); } public void testGoodImplements1() throws Exception { testTypes("/** @interface */function Disposable() {}\n" + "/** @implements {Disposable}\n * @constructor */function f() {}"); } public void testGoodImplements2() throws Exception { testTypes("/** @interface */function Base1() {}\n" + "/** @interface */function Base2() {}\n" + "/** @constructor\n" + " * @implements {Base1}\n" + " * @implements {Base2}\n" + " */ function derived() {}"); } public void testBadImplements1() throws Exception { testTypes("/** @interface */function Base1() {}\n" + "/** @interface */function Base2() {}\n" + "/** @constructor\n" + " * @implements {nonExistent}\n" + " * @implements {Base2}\n" + " */ function derived() {}", "Bad type annotation. Unknown type nonExistent"); } public void testBadImplements2() throws Exception { testTypes("/** @interface */function Disposable() {}\n" + "/** @implements {Disposable}\n */function f() {}", "@implements used without @constructor for f"); } public void testBadImplements3() throws Exception { testTypes("/** @interface */function Disposable() {}\n" + "/** @implements {Disposable}\n * @interface */function f() {}", "f cannot implement this type; an interface can only extend, " + "but not implement interfaces"); } public void testInterfaceExtends() throws Exception { testTypes("/** @interface */function A() {}\n" + "/** @interface \n * @extends {A} */function B() {}\n" + "/** @constructor\n" + " * @implements {B}\n" + " */ function derived() {}"); } public void testBadInterfaceExtends1() throws Exception { testTypes("/** @interface \n * @extends {nonExistent} */function A() {}", "Bad type annotation. Unknown type nonExistent"); } public void testBadInterfaceExtends2() throws Exception { testTypes("/** @constructor */function A() {}\n" + "/** @interface \n * @extends {A} */function B() {}", "B cannot extend this type; interfaces can only extend interfaces"); } public void testBadInterfaceExtends3() throws Exception { testTypes("/** @interface */function A() {}\n" + "/** @constructor \n * @extends {A} */function B() {}", "B cannot extend this type; constructors can only extend constructors"); } public void testBadInterfaceExtends4() throws Exception { // TODO(user): This should be detected as an error. Even if we enforce // that A cannot be used in the assignment, we should still detect the // inheritance chain as invalid. testTypes("/** @interface */function A() {}\n" + "/** @constructor */function B() {}\n" + "B.prototype = A;"); } public void testBadInterfaceExtends5() throws Exception { // TODO(user): This should be detected as an error. Even if we enforce // that A cannot be used in the assignment, we should still detect the // inheritance chain as invalid. testTypes("/** @constructor */function A() {}\n" + "/** @interface */function B() {}\n" + "B.prototype = A;"); } public void testBadImplementsAConstructor() throws Exception { testTypes("/** @constructor */function A() {}\n" + "/** @constructor \n * @implements {A} */function B() {}", "can only implement interfaces"); } public void testBadImplementsNonInterfaceType() throws Exception { testTypes("/** @constructor \n * @implements {Boolean} */function B() {}", "can only implement interfaces"); } public void testBadImplementsNonObjectType() throws Exception { testTypes("/** @constructor \n * @implements {string} */function S() {}", "can only implement interfaces"); } public void testInterfaceAssignment1() throws Exception { testTypes("/** @interface */var I = function() {};\n" + "/** @constructor\n@implements {I} */var T = function() {};\n" + "var t = new T();\n" + "/** @type {!I} */var i = t;"); } public void testInterfaceAssignment2() throws Exception { testTypes("/** @interface */var I = function() {};\n" + "/** @constructor */var T = function() {};\n" + "var t = new T();\n" + "/** @type {!I} */var i = t;", "initializing variable\n" + "found : T\n" + "required: I"); } public void testInterfaceAssignment3() throws Exception { testTypes("/** @interface */var I = function() {};\n" + "/** @constructor\n@implements {I} */var T = function() {};\n" + "var t = new T();\n" + "/** @type {I|number} */var i = t;"); } public void testInterfaceAssignment4() throws Exception { testTypes("/** @interface */var I1 = function() {};\n" + "/** @interface */var I2 = function() {};\n" + "/** @constructor\n@implements {I1} */var T = function() {};\n" + "var t = new T();\n" + "/** @type {I1|I2} */var i = t;"); } public void testInterfaceAssignment5() throws Exception { testTypes("/** @interface */var I1 = function() {};\n" + "/** @interface */var I2 = function() {};\n" + "/** @constructor\n@implements {I1}\n@implements {I2}*/" + "var T = function() {};\n" + "var t = new T();\n" + "/** @type {I1} */var i1 = t;\n" + "/** @type {I2} */var i2 = t;\n"); } public void testInterfaceAssignment6() throws Exception { testTypes("/** @interface */var I1 = function() {};\n" + "/** @interface */var I2 = function() {};\n" + "/** @constructor\n@implements {I1} */var T = function() {};\n" + "/** @type {!I1} */var i1 = new T();\n" + "/** @type {!I2} */var i2 = i1;\n", "initializing variable\n" + "found : I1\n" + "required: I2"); } public void testInterfaceAssignment7() throws Exception { testTypes("/** @interface */var I1 = function() {};\n" + "/** @interface\n@extends {I1}*/var I2 = function() {};\n" + "/** @constructor\n@implements {I2}*/var T = function() {};\n" + "var t = new T();\n" + "/** @type {I1} */var i1 = t;\n" + "/** @type {I2} */var i2 = t;\n" + "i1 = i2;\n"); } public void testInterfaceAssignment8() throws Exception { testTypes("/** @interface */var I = function() {};\n" + "/** @type {I} */var i;\n" + "/** @type {Object} */var o = i;"); } public void testInterfaceAssignment9() throws Exception { testTypes("/** @interface */var I = function() {};\n" + "/** @return {I?} */function f() { return null; }\n" + "/** @type {!I} */var i = f();\n", "initializing variable\n" + "found : (I|null|undefined)\n" + "required: I"); } public void testInterfaceAssignment10() throws Exception { testTypes("/** @interface */var I1 = function() {};\n" + "/** @interface */var I2 = function() {};\n" + "/** @constructor\n@implements {I2} */var T = function() {};\n" + "/** @return {!I1|!I2} */function f() { return new T(); }\n" + "/** @type {!I1} */var i1 = f();\n", "initializing variable\n" + "found : (I1|I2)\n" + "required: I1"); } public void testInterfaceAssignment11() throws Exception { testTypes("/** @interface */var I1 = function() {};\n" + "/** @interface */var I2 = function() {};\n" + "/** @constructor */var T = function() {};\n" + "/** @return {!I1|!I2|!T} */function f() { return new T(); }\n" + "/** @type {!I1} */var i1 = f();\n", "initializing variable\n" + "found : (I1|I2|T)\n" + "required: I1"); } public void testInterfaceAssignment12() throws Exception { testTypes("/** @interface */var I = function() {};\n" + "/** @constructor\n@implements{I}*/var T1 = function() {};\n" + "/** @constructor\n@extends {T1}*/var T2 = function() {};\n" + "/** @return {I} */function f() { return new T2(); }"); } public void testInterfaceAssignment13() throws Exception { testTypes("/** @interface */var I = function() {};\n" + "/** @constructor\n@implements {I}*/var T = function() {};\n" + "/** @constructor */function Super() {};\n" + "/** @return {I} */Super.prototype.foo = " + "function() { return new T(); };\n" + "/** @constructor\n@extends {Super} */function Sub() {}\n" + "/** @override\n@return {T} */Sub.prototype.foo = " + "function() { return new T(); };\n"); } public void testGetprop1() throws Exception { testTypes("/** @return {void}*/function foo(){foo().bar;}", "No properties on this expression\n" + "found : undefined\n" + "required: Object"); } public void testArrayAccess1() throws Exception { testTypes("var a = []; var b = a['hi'];"); } public void testArrayAccess2() throws Exception { testTypes("var a = []; var b = a[[1,2]];", "array access\n" + "found : Array\n" + "required: number"); } public void testArrayAccess3() throws Exception { testTypes("var bar = [];" + "/** @return {void} */function baz(){};" + "var foo = bar[baz()];", "array access\n" + "found : undefined\n" + "required: number"); } public void testArrayAccess4() throws Exception { testTypes("/**@return {!Array}*/function foo(){};var bar = foo()[foo()];", "array access\n" + "found : Array\n" + "required: number"); } public void testArrayAccess6() throws Exception { testTypes("var bar = null[1];", "only arrays or objects can be accessed\n" + "found : null\n" + "required: Object"); } public void testArrayAccess7() throws Exception { testTypes("var bar = void 0; bar[0];", "only arrays or objects can be accessed\n" + "found : undefined\n" + "required: Object"); } public void testArrayAccess8() throws Exception { // Verifies that we don't emit two warnings, because // the var has been dereferenced after the first one. testTypes("var bar = void 0; bar[0]; bar[1];", "only arrays or objects can be accessed\n" + "found : undefined\n" + "required: Object"); } public void testPropAccess() throws Exception { testTypes("/** @param {*} x */var f = function(x) {\n" + "var o = String(x);\n" + "if (typeof o['a'] != 'undefined') { return o['a']; }\n" + "return null;\n" + "};"); } public void testPropAccess2() throws Exception { testTypes("var bar = void 0; bar.baz;", "No properties on this expression\n" + "found : undefined\n" + "required: Object"); } public void testPropAccess3() throws Exception { // Verifies that we don't emit two warnings, because // the var has been dereferenced after the first one. testTypes("var bar = void 0; bar.baz; bar.bax;", "No properties on this expression\n" + "found : undefined\n" + "required: Object"); } public void testPropAccess4() throws Exception { testTypes("/** @param {*} x */ function f(x) { return x['hi']; }"); } public void testSwitchCase1() throws Exception { testTypes("/**@type number*/var a;" + "/**@type string*/var b;" + "switch(a){case b:;}", "case expression doesn't match switch\n" + "found : string\n" + "required: number"); } public void testSwitchCase2() throws Exception { testTypes("var a = null; switch (typeof a) { case 'foo': }"); } public void testVar1() throws Exception { TypeCheckResult p = parseAndTypeCheckWithScope("/** @type {(string,null)} */var a = null"); assertTypeEquals(createUnionType(STRING_TYPE, NULL_TYPE), p.scope.getVar("a").getType()); } public void testVar2() throws Exception { testTypes("/** @type {Function} */ var a = function(){}"); } public void testVar3() throws Exception { TypeCheckResult p = parseAndTypeCheckWithScope("var a = 3;"); assertTypeEquals(NUMBER_TYPE, p.scope.getVar("a").getType()); } public void testVar4() throws Exception { TypeCheckResult p = parseAndTypeCheckWithScope( "var a = 3; a = 'string';"); assertTypeEquals(createUnionType(STRING_TYPE, NUMBER_TYPE), p.scope.getVar("a").getType()); } public void testVar5() throws Exception { testTypes("var goog = {};" + "/** @type string */goog.foo = 'hello';" + "/** @type number */var a = goog.foo;", "initializing variable\n" + "found : string\n" + "required: number"); } public void testVar6() throws Exception { testTypes( "function f() {" + " return function() {" + " /** @type {!Date} */" + " var a = 7;" + " };" + "}", "initializing variable\n" + "found : number\n" + "required: Date"); } public void testVar7() throws Exception { testTypes("/** @type number */var a, b;", "declaration of multiple variables with shared type information"); } public void testVar8() throws Exception { testTypes("var a, b;"); } public void testVar9() throws Exception { testTypes("/** @enum */var a;", "enum initializer must be an object literal or an enum"); } public void testVar10() throws Exception { testTypes("/** @type !Number */var foo = 'abc';", "initializing variable\n" + "found : string\n" + "required: Number"); } public void testVar11() throws Exception { testTypes("var /** @type !Date */foo = 'abc';", "initializing variable\n" + "found : string\n" + "required: Date"); } public void testVar12() throws Exception { testTypes("var /** @type !Date */foo = 'abc', " + "/** @type !RegExp */bar = 5;", new String[] { "initializing variable\n" + "found : string\n" + "required: Date", "initializing variable\n" + "found : number\n" + "required: RegExp"}); } public void testVar13() throws Exception { // this caused an NPE testTypes("var /** @type number */a,a;"); } public void testVar14() throws Exception { testTypes("/** @return {number} */ function f() { var x; return x; }", "inconsistent return type\n" + "found : undefined\n" + "required: number"); } public void testVar15() throws Exception { testTypes("/** @return {number} */" + "function f() { var x = x || {}; return x; }", "inconsistent return type\n" + "found : {}\n" + "required: number"); } public void testAssign1() throws Exception { testTypes("var goog = {};" + "/** @type number */goog.foo = 'hello';", "assignment to property foo of goog\n" + "found : string\n" + "required: number"); } public void testAssign2() throws Exception { testTypes("var goog = {};" + "/** @type number */goog.foo = 3;" + "goog.foo = 'hello';", "assignment to property foo of goog\n" + "found : string\n" + "required: number"); } public void testAssign3() throws Exception { testTypes("var goog = {};" + "/** @type number */goog.foo = 3;" + "goog.foo = 4;"); } public void testAssign4() throws Exception { testTypes("var goog = {};" + "goog.foo = 3;" + "goog.foo = 'hello';"); } public void testAssignInference() throws Exception { testTypes( "/**" + " * @param {Array} x" + " * @return {number}" + " */" + "function f(x) {" + " var y = null;" + " y = x[0];" + " if (y == null) { return 4; } else { return 6; }" + "}"); } public void testOr1() throws Exception { testTypes("/** @type number */var a;" + "/** @type number */var b;" + "a + b || undefined;"); } public void testOr2() throws Exception { testTypes("/** @type number */var a;" + "/** @type number */var b;" + "/** @type number */var c = a + b || undefined;", "initializing variable\n" + "found : (number|undefined)\n" + "required: number"); } public void testOr3() throws Exception { testTypes("/** @type {(number, undefined)} */var a;" + "/** @type number */var c = a || 3;"); } /** * Test that type inference continues with the right side, * when no short-circuiting is possible. * See bugid 1205387 for more details. */ public void testOr4() throws Exception { testTypes("/**@type {number} */var x;x=null || \"a\";", "assignment\n" + "found : string\n" + "required: number"); } /** * @see #testOr4() */ public void testOr5() throws Exception { testTypes("/**@type {number} */var x;x=undefined || \"a\";", "assignment\n" + "found : string\n" + "required: number"); } public void testAnd1() throws Exception { testTypes("/** @type number */var a;" + "/** @type number */var b;" + "a + b && undefined;"); } public void testAnd2() throws Exception { testTypes("/** @type number */var a;" + "/** @type number */var b;" + "/** @type number */var c = a + b && undefined;", "initializing variable\n" + "found : (number|undefined)\n" + "required: number"); } public void testAnd3() throws Exception { testTypes("/** @type {(!Array, undefined)} */var a;" + "/** @type number */var c = a && undefined;", "initializing variable\n" + "found : undefined\n" + "required: number"); } public void testAnd4() throws Exception { testTypes("/** @param {number} x */function f(x){};\n" + "/** @type null */var x; /** @type {number?} */var y;\n" + "if (x && y) { f(y) }"); } public void testAnd5() throws Exception { testTypes("/** @param {number} x\n@param {string} y*/function f(x,y){};\n" + "/** @type {number?} */var x; /** @type {string?} */var y;\n" + "if (x && y) { f(x, y) }"); } public void testAnd6() throws Exception { testTypes("/** @param {number} x */function f(x){};\n" + "/** @type {number|undefined} */var x;\n" + "if (x && f(x)) { f(x) }"); } public void testAnd7() throws Exception { // TODO(user): a deterministic warning should be generated for this // case since x && x is always false. The implementation of this requires // a more precise handling of a null value within a variable's type. // Currently, a null value defaults to ? which passes every check. testTypes("/** @type null */var x; if (x && x) {}"); } public void testHook() throws Exception { testTypes("/**@return {void}*/function foo(){ var x=foo()?a:b; }"); } public void testHookRestrictsType1() throws Exception { testTypes("/** @return {(string,null)} */" + "function f() { return null;}" + "/** @type {(string,null)} */ var a = f();" + "/** @type string */" + "var b = a ? a : 'default';"); } public void testHookRestrictsType2() throws Exception { testTypes("/** @type {String} */" + "var a = null;" + "/** @type (null|undefined) */" + "var b = a ? null : a;"); } public void testHookRestrictsType3() throws Exception { testTypes("/** @type {String} */" + "var a;" + "/** @type (null|undefined) */" + "var b = (!a) ? a : null;"); } public void testHookRestrictsType4() throws Exception { testTypes("/** @type {(boolean,undefined)} */" + "var a;" + "/** @type boolean */" + "var b = a != null ? a : true;"); } public void testHookRestrictsType5() throws Exception { testTypes("/** @type {(boolean,undefined)} */" + "var a;" + "/** @type {(undefined)} */" + "var b = a == null ? a : undefined;"); } public void testHookRestrictsType6() throws Exception { testTypes("/** @type {(number,null,undefined)} */" + "var a;" + "/** @type {number} */" + "var b = a == null ? 5 : a;"); } public void testHookRestrictsType7() throws Exception { testTypes("/** @type {(number,null,undefined)} */" + "var a;" + "/** @type {number} */" + "var b = a == undefined ? 5 : a;"); } public void testWhileRestrictsType1() throws Exception { testTypes("/** @param {null} x */ function g(x) {}" + "/** @param {number?} x */\n" + "function f(x) {\n" + "while (x) {\n" + "if (g(x)) { x = 1; }\n" + "x = x-1;\n}\n}", "actual parameter 1 of g does not match formal parameter\n" + "found : number\n" + "required: null"); } public void testWhileRestrictsType2() throws Exception { testTypes("/** @param {number?} x\n@return {number}*/\n" + "function f(x) {\n/** @type {number} */var y = 0;" + "while (x) {\n" + "y = x;\n" + "x = x-1;\n}\n" + "return y;}"); } public void testHigherOrderFunctions1() throws Exception { testTypes( "/** @type {function(number)} */var f;" + "f(true);", "actual parameter 1 of f does not match formal parameter\n" + "found : boolean\n" + "required: number"); } public void testHigherOrderFunctions2() throws Exception { testTypes( "/** @type {function():!Date} */var f;" + "/** @type boolean */var a = f();", "initializing variable\n" + "found : Date\n" + "required: boolean"); } public void testHigherOrderFunctions3() throws Exception { testTypes( "/** @type {function(this:Error):Date} */var f; new f", "cannot instantiate non-constructor"); } public void testHigherOrderFunctions4() throws Exception { testTypes( "/** @type {function(this:Error,...[number]):Date} */var f; new f", "cannot instantiate non-constructor"); } public void testConstructorAlias1() throws Exception { testTypes( "/** @constructor */ var Foo = function() {};" + "/** @type {number} */ Foo.prototype.bar = 3;" + "/** @constructor */ var FooAlias = Foo;" + "/** @return {string} */ function foo() { " + " return (new FooAlias()).bar; }", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testConstructorAlias2() throws Exception { testTypes( "/** @constructor */ var Foo = function() {};" + "/** @constructor */ var FooAlias = Foo;" + "/** @type {number} */ FooAlias.prototype.bar = 3;" + "/** @return {string} */ function foo() { " + " return (new Foo()).bar; }", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testConstructorAlias3() throws Exception { testTypes( "/** @constructor */ var Foo = function() {};" + "/** @type {number} */ Foo.prototype.bar = 3;" + "/** @constructor */ var FooAlias = Foo;" + "/** @return {string} */ function foo() { " + " return (new FooAlias()).bar; }", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testConstructorAlias4() throws Exception { testTypes( "/** @constructor */ var Foo = function() {};" + "var FooAlias = Foo;" + "/** @type {number} */ FooAlias.prototype.bar = 3;" + "/** @return {string} */ function foo() { " + " return (new Foo()).bar; }", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testConstructorAlias5() throws Exception { testTypes( "/** @constructor */ var Foo = function() {};" + "/** @constructor */ var FooAlias = Foo;" + "/** @return {FooAlias} */ function foo() { " + " return new Foo(); }"); } public void testConstructorAlias6() throws Exception { testTypes( "/** @constructor */ var Foo = function() {};" + "/** @constructor */ var FooAlias = Foo;" + "/** @return {Foo} */ function foo() { " + " return new FooAlias(); }"); } public void testConstructorAlias7() throws Exception { testTypes( "var goog = {};" + "/** @constructor */ goog.Foo = function() {};" + "/** @constructor */ goog.FooAlias = goog.Foo;" + "/** @return {number} */ function foo() { " + " return new goog.FooAlias(); }", "inconsistent return type\n" + "found : goog.Foo\n" + "required: number"); } public void testConstructorAlias8() throws Exception { testTypes( "var goog = {};" + "/**\n * @param {number} x \n * @constructor */ " + "goog.Foo = function(x) {};" + "/**\n * @param {number} x \n * @constructor */ " + "goog.FooAlias = goog.Foo;" + "/** @return {number} */ function foo() { " + " return new goog.FooAlias(1); }", "inconsistent return type\n" + "found : goog.Foo\n" + "required: number"); } public void testConstructorAlias9() throws Exception { testTypes( "var goog = {};" + "/**\n * @param {number} x \n * @constructor */ " + "goog.Foo = function(x) {};" + "/** @constructor */ goog.FooAlias = goog.Foo;" + "/** @return {number} */ function foo() { " + " return new goog.FooAlias(1); }", "inconsistent return type\n" + "found : goog.Foo\n" + "required: number"); } public void testConstructorAlias10() throws Exception { testTypes( "/**\n * @param {number} x \n * @constructor */ " + "var Foo = function(x) {};" + "/** @constructor */ var FooAlias = Foo;" + "/** @return {number} */ function foo() { " + " return new FooAlias(1); }", "inconsistent return type\n" + "found : Foo\n" + "required: number"); } public void testClosure1() throws Exception { testClosureTypes( CLOSURE_DEFS + "/** @type {string|undefined} */var a;" + "/** @type string */" + "var b = goog.isDef(a) ? a : 'default';", null); } public void testClosure2() throws Exception { testClosureTypes( CLOSURE_DEFS + "/** @type {string|null} */var a;" + "/** @type string */" + "var b = goog.isNull(a) ? 'default' : a;", null); } public void testClosure3() throws Exception { testClosureTypes( CLOSURE_DEFS + "/** @type {string|null|undefined} */var a;" + "/** @type string */" + "var b = goog.isDefAndNotNull(a) ? a : 'default';", null); } public void testClosure4() throws Exception { testClosureTypes( CLOSURE_DEFS + "/** @type {string|undefined} */var a;" + "/** @type string */" + "var b = !goog.isDef(a) ? 'default' : a;", null); } public void testClosure5() throws Exception { testClosureTypes( CLOSURE_DEFS + "/** @type {string|null} */var a;" + "/** @type string */" + "var b = !goog.isNull(a) ? a : 'default';", null); } public void testClosure6() throws Exception { testClosureTypes( CLOSURE_DEFS + "/** @type {string|null|undefined} */var a;" + "/** @type string */" + "var b = !goog.isDefAndNotNull(a) ? 'default' : a;", null); } public void testReturn1() throws Exception { testTypes("/**@return {void}*/function foo(){ return 3; }", "inconsistent return type\n" + "found : number\n" + "required: undefined"); } public void testReturn2() throws Exception { testTypes("/**@return {!Number}*/function foo(){ return; }", "inconsistent return type\n" + "found : undefined\n" + "required: Number"); } public void testReturn3() throws Exception { testTypes("/**@return {!Number}*/function foo(){ return 'abc'; }", "inconsistent return type\n" + "found : string\n" + "required: Number"); } public void testReturn4() throws Exception { testTypes("/**@return {!Number}\n*/\n function a(){return new Array();}", "inconsistent return type\n" + "found : Array\n" + "required: Number"); } public void testReturn5() throws Exception { testTypes("/** @param {number} n\n" + "@constructor */function n(n){return};"); } public void testReturn6() throws Exception { testTypes( "/** @param {number} opt_a\n@return {string} */" + "function a(opt_a) { return opt_a }", "inconsistent return type\n" + "found : (number|undefined)\n" + "required: string"); } public void testReturn7() throws Exception { testTypes("/** @constructor */var A = function() {};\n" + "/** @constructor */var B = function() {};\n" + "/** @return {!B} */A.f = function() { return 1; };", "inconsistent return type\n" + "found : number\n" + "required: B"); } public void testReturn8() throws Exception { testTypes("/** @constructor */var A = function() {};\n" + "/** @constructor */var B = function() {};\n" + "/** @return {!B} */A.prototype.f = function() { return 1; };", "inconsistent return type\n" + "found : number\n" + "required: B"); } public void testThis1() throws Exception { testTypes("var goog = {};" + "/** @constructor */goog.A = function(){};" + "/** @return {number} */goog.A.prototype.n = " + " function() { return this };", "inconsistent return type\n" + "found : goog.A\n" + "required: number"); } public void testThis2() throws Exception { testTypes("var goog = {};" + "/** @constructor */goog.A = function(){" + " this.foo = null;" + "};" + "/** @return {number} */" + "goog.A.prototype.n = function() { return this.foo };", "inconsistent return type\n" + "found : null\n" + "required: number"); } public void testThis3() throws Exception { testTypes("var goog = {};" + "/** @constructor */goog.A = function(){" + " this.foo = null;" + " this.foo = 5;" + "};"); } public void testThis4() throws Exception { testTypes("var goog = {};" + "/** @constructor */goog.A = function(){" + " /** @type {string?} */this.foo = null;" + "};" + "/** @return {number} */goog.A.prototype.n = function() {" + " return this.foo };", "inconsistent return type\n" + "found : (null|string|undefined)\n" + "required: number"); } public void testThis5() throws Exception { testTypes("/** @this Date\n@return {number}*/function h() { return this }", "inconsistent return type\n" + "found : Date\n" + "required: number"); } public void testThis6() throws Exception { testTypes("var goog = {};" + "/** @constructor\n@return {!Date} */" + "goog.A = function(){ return this };", "inconsistent return type\n" + "found : goog.A\n" + "required: Date"); } public void testThis7() throws Exception { testTypes("/** @constructor */function A(){};" + "/** @return {number} */A.prototype.n = function() { return this };", "inconsistent return type\n" + "found : A\n" + "required: number"); } public void testThis8() throws Exception { testTypes("/** @constructor */function A(){" + " /** @type {string?} */this.foo = null;" + "};" + "/** @return {number} */A.prototype.n = function() {" + " return this.foo };", "inconsistent return type\n" + "found : (null|string|undefined)\n" + "required: number"); } public void testThis9() throws Exception { // In A.bar, the type of {@code this} is unknown. testTypes("/** @constructor */function A(){};" + "A.prototype.foo = 3;" + "/** @return {string} */ A.bar = function() { return this.foo; };"); } public void testThis10() throws Exception { // In A.bar, the type of {@code this} is inferred from the @this tag. testTypes("/** @constructor */function A(){};" + "A.prototype.foo = 3;" + "/** @this {A}\n@return {string} */" + "A.bar = function() { return this.foo; };", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testGlobalThis1() throws Exception { testTypes("/** @constructor */ function Window() {}" + "/** @param {string} msg */ " + "Window.prototype.alert = function(msg) {};" + "this.alert(3);", "actual parameter 1 of Window.prototype.alert " + "does not match formal parameter\n" + "found : number\n" + "required: string"); } public void testGlobalThis2() throws Exception { testTypes("/** @constructor */ function Bindow() {}" + "/** @param {string} msg */ " + "Bindow.prototype.alert = function(msg) {};" + "this.alert = 3;" + "(new Bindow()).alert(this.alert)"); } public void testGlobalThis3() throws Exception { testTypes( "/** @param {string} msg */ " + "function alert(msg) {};" + "this.alert(3);", "actual parameter 1 of global this.alert " + "does not match formal parameter\n" + "found : number\n" + "required: string"); } public void testGlobalThis4() throws Exception { testTypes( "/** @param {string} msg */ " + "var alert = function(msg) {};" + "this.alert(3);", "actual parameter 1 of global this.alert " + "does not match formal parameter\n" + "found : number\n" + "required: string"); } public void testGlobalThis5() throws Exception { testTypes( "function f() {" + " /** @param {string} msg */ " + " var alert = function(msg) {};" + "}" + "this.alert(3);", "Property alert never defined on global this"); } public void testGlobalThis6() throws Exception { testTypes( "/** @param {string} msg */ " + "var alert = function(msg) {};" + "var x = 3;" + "x = 'msg';" + "this.alert(this.x);"); } public void testControlFlowRestrictsType1a() throws Exception { testTypes("/** @return {String?} */ function f() { return null; }\n" + "/** @type {String?} */ var a = f();\n" + "/** @type String */ var b = new String('foo');\n" + "/** @type (null|undefined) */ var c = null;\n" + "if (a) {\n" + " b = a;\n" + "} else {\n" + " c = a;\n" + "}"); } public void testControlFlowRestrictsType1b() throws Exception { testTypes("/** @return {!String|null} */ function f() { return null; }\n" + "/** @type {!String|null} */ var a = f();\n" + "/** @type String */ var b = new String('foo');\n" + "/** @type (null) */ var c = null;\n" + "if (a) {\n" + " b = a;\n" + "} else {\n" + " c = a;\n" + "}"); } public void testControlFlowRestrictsType1c() throws Exception { testTypes("/** @return {!String|undefined} */\n" + "function f() { return undefined; }\n" + "/** @type {!String|undefined} */ var a = f();\n" + "/** @type String */ var b = new String('foo');\n" + "/** @type undefined */ var c = undefined;\n" + "if (a) {\n" + " b = a;\n" + "} else {\n" + " c = a;\n" + "}"); } public void testControlFlowRestrictsType2() throws Exception { testTypes("/** @return {(string,null)} */ function f() { return null; }" + "/** @type {(string,null)} */ var a = f();" + "/** @type string */ var b = 'foo';" + "/** @type null */ var c = null;" + "if (a) {" + " b = a;" + "} else {" + " c = a;" + "}", "assignment\n" + "found : (null|string)\n" + "required: null"); } public void testControlFlowRestrictsType3() throws Exception { testTypes("/** @type {(string,void)} */" + "var a;" + "/** @type string */" + "var b = 'foo';" + "if (a) {" + " b = a;" + "}"); } public void testControlFlowRestrictsType4() throws Exception { testTypes("/** @param {string} a */ function f(a){}" + "/** @type {(string,undefined)} */ var a;" + "a && f(a);"); } public void testControlFlowRestrictsType5() throws Exception { testTypes("/** @param {undefined} a */ function f(a){}" + "/** @type {(!Array,undefined)} */ var a;" + "a || f(a);"); } public void testControlFlowRestrictsType6() throws Exception { testTypes("/** @param {undefined} x */ function f(x) {}" + "/** @type {(string,undefined)} */ var a;" + "a && f(a);", "actual parameter 1 of f does not match formal parameter\n" + "found : string\n" + "required: undefined"); } public void testControlFlowRestrictsType7() throws Exception { testTypes("/** @param {undefined} x */ function f(x) {}" + "/** @type {(string,undefined)} */ var a;" + "a && f(a);", "actual parameter 1 of f does not match formal parameter\n" + "found : string\n" + "required: undefined"); } public void testControlFlowRestrictsType8() throws Exception { testTypes("/** @param {undefined} a */ function f(a){}" + "/** @type {(!Array,undefined)} */ var a;" + "if (a || f(a)) {}"); } public void testControlFlowRestrictsType9() throws Exception { testTypes("/** @param {number?} x\n * @return {number}*/\n" + "var f = function(x) {\n" + "if (!x || x == 1) { return 1; } else { return x; }\n" + "};"); } public void testSwitchCase3() throws Exception { testTypes("/** @type String */" + "var a = new String('foo');" + "switch (a) { case 'A': }"); } public void testSwitchCase4() throws Exception { testTypes("/** @type {(string,Null)} */" + "var a = 'foo';" + "switch (a) { case 'A':break; case null:break; }"); } public void testSwitchCase5() throws Exception { testTypes("/** @type {(String,Null)} */" + "var a = new String('foo');" + "switch (a) { case 'A':break; case null:break; }"); } public void testSwitchCase6() throws Exception { testTypes("/** @type {(Number,Null)} */" + "var a = new Number(5);" + "switch (a) { case 5:break; case null:break; }"); } public void testSwitchCase7() throws Exception { // This really tests the inference inside the case. testTypes( "/**\n" + " * @param {number} x\n" + " * @return {number}\n" + " */\n" + "function g(x) { return 5; }" + "function f() {" + " var x = {};" + " x.foo = '3';" + " switch (3) { case g(x.foo): return 3; }" + "}", "actual parameter 1 of g does not match formal parameter\n" + "found : string\n" + "required: number"); } public void testSwitchCase8() throws Exception { // This really tests the inference inside the switch clause. testTypes( "/**\n" + " * @param {number} x\n" + " * @return {number}\n" + " */\n" + "function g(x) { return 5; }" + "function f() {" + " var x = {};" + " x.foo = '3';" + " switch (g(x.foo)) { case 3: return 3; }" + "}", "actual parameter 1 of g does not match formal parameter\n" + "found : string\n" + "required: number"); } public void testNoTypeCheck1() throws Exception { testTypes("/** @notypecheck */function foo() { new 4 }"); } public void testNoTypeCheck2() throws Exception { testTypes("/** @notypecheck */var foo = function() { new 4 }"); } public void testNoTypeCheck3() throws Exception { testTypes("/** @notypecheck */var foo = function bar() { new 4 }"); } public void testNoTypeCheck4() throws Exception { testTypes("var foo;" + "/** @notypecheck */foo = function() { new 4 }"); } public void testNoTypeCheck5() throws Exception { testTypes("var foo;" + "foo = /** @notypecheck */function() { new 4 }"); } public void testNoTypeCheck6() throws Exception { testTypes("var foo;" + "/** @notypecheck */foo = function bar() { new 4 }"); } public void testNoTypeCheck7() throws Exception { testTypes("var foo;" + "foo = /** @notypecheck */function bar() { new 4 }"); } public void testNoTypeCheck8() throws Exception { testTypes("/** @fileoverview \n * @notypecheck */ var foo;" + "var bar = 3; /** @param {string} x */ function f(x) {} f(bar);"); } public void testImplicitCast() throws Exception { testTypes("/** @constructor */ function Element() {};\n" + "/** @type {string}\n" + " * @implicitCast */" + "Element.prototype.innerHTML;", "(new Element).innerHTML = new Array();", null, false); } public void testImplicitCastSubclassAccess() throws Exception { testTypes("/** @constructor */ function Element() {};\n" + "/** @type {string}\n" + " * @implicitCast */" + "Element.prototype.innerHTML;" + "/** @constructor \n @extends Element */" + "function DIVElement() {};", "(new DIVElement).innerHTML = new Array();", null, false); } public void testImplicitCastNotInExterns() throws Exception { testTypes("/** @constructor */ function Element() {};\n" + "/** @type {string}\n" + " * @implicitCast */" + "Element.prototype.innerHTML;" + "(new Element).innerHTML = new Array();", new String[] { "Illegal annotation on innerHTML. @implicitCast may only be " + "used in externs.", "assignment to property innerHTML of Element\n" + "found : Array\n" + "required: string" }); } public void testNumberNode() throws Exception { Node n = typeCheck(Node.newNumber(0)); assertTypeEquals(NUMBER_TYPE, n.getJSType()); } public void testStringNode() throws Exception { Node n = typeCheck(Node.newString("hello")); assertTypeEquals(STRING_TYPE, n.getJSType()); } public void testBooleanNodeTrue() throws Exception { Node trueNode = typeCheck(new Node(Token.TRUE)); assertTypeEquals(BOOLEAN_TYPE, trueNode.getJSType()); } public void testBooleanNodeFalse() throws Exception { Node falseNode = typeCheck(new Node(Token.FALSE)); assertTypeEquals(BOOLEAN_TYPE, falseNode.getJSType()); } public void testUndefinedNode() throws Exception { Node p = new Node(Token.ADD); Node n = Node.newString(Token.NAME, "undefined"); p.addChildToBack(n); p.addChildToBack(Node.newNumber(5)); typeCheck(p); assertTypeEquals(VOID_TYPE, n.getJSType()); } public void testNumberAutoboxing() throws Exception { testTypes("/** @type Number */var a = 4;", "initializing variable\n" + "found : number\n" + "required: (Number|null|undefined)"); } public void testNumberUnboxing() throws Exception { testTypes("/** @type number */var a = new Number(4);", "initializing variable\n" + "found : Number\n" + "required: number"); } public void testStringAutoboxing() throws Exception { testTypes("/** @type String */var a = 'hello';", "initializing variable\n" + "found : string\n" + "required: (String|null|undefined)"); } public void testStringUnboxing() throws Exception { testTypes("/** @type string */var a = new String('hello');", "initializing variable\n" + "found : String\n" + "required: string"); } public void testBooleanAutoboxing() throws Exception { testTypes("/** @type Boolean */var a = true;", "initializing variable\n" + "found : boolean\n" + "required: (Boolean|null|undefined)"); } public void testBooleanUnboxing() throws Exception { testTypes("/** @type boolean */var a = new Boolean(false);", "initializing variable\n" + "found : Boolean\n" + "required: boolean"); } public void testIssue86() throws Exception { testTypes( "/** @interface */ function I() {}" + "/** @return {number} */ I.prototype.get = function(){};" + "/** @constructor \n * @implements {I} */ function F() {}" + "/** @override */ F.prototype.get = function() { return true; };", "inconsistent return type\n" + "found : boolean\n" + "required: number"); } public void testIssue124() throws Exception { testTypes( "var t = null;" + "function test() {" + " if (t != null) { t = null; }" + " t = 1;" + "}"); } public void testIssue124b() throws Exception { testTypes( "var t = null;" + "function test() {" + " if (t != null) { t = null; }" + " t = undefined;" + "}", "condition always evaluates to false\n" + "left : (null|undefined)\n" + "right: null"); } /** * Tests that the || operator is type checked correctly, that is of * the type of the first argument or of the second argument. See * bugid 592170 for more details. */ public void testBug592170() throws Exception { testTypes( "/** @param {Function} opt_f ... */" + "function foo(opt_f) {" + " /** @type {Function} */" + " return opt_f || function () {};" + "}", "Type annotations are not allowed here. Are you missing parentheses?"); } /** * Tests that undefined can be compared shallowly to a value of type * (number,undefined) regardless of the side on which the undefined * value is. */ public void testBug901455() throws Exception { testTypes("/** @return {(number,undefined)} */ function a() { return 3; }" + "var b = undefined === a()"); testTypes("/** @return {(number,undefined)} */ function a() { return 3; }" + "var b = a() === undefined"); } /** * Tests that the match method of strings returns nullable arrays. */ public void testBug908701() throws Exception { testTypes("/** @type {String} */var s = new String('foo');" + "var b = s.match(/a/) != null;"); } /** * Tests that named types play nicely with subtyping. */ public void testBug908625() throws Exception { testTypes("/** @constructor */function A(){}" + "/** @constructor\n * @extends A */function B(){}" + "/** @param {B} b" + "\n @return {(A,undefined)} */function foo(b){return b}"); } /** * Tests that assigning two untyped functions to a variable whose type is * inferred and calling this variable is legal. */ public void testBug911118() throws Exception { // verifying the type assigned to anonymous functions assigned variables Scope s = parseAndTypeCheckWithScope("var a = function(){};").scope; JSType type = s.getVar("a").getType(); assertEquals("function (): undefined", type.toString()); // verifying the bug example testTypes("function nullFunction() {};" + "var foo = nullFunction;" + "foo = function() {};" + "foo();"); } public void testBug909000() throws Exception { testTypes("/** @constructor */function A(){}\n" + "/** @param {!A} a\n" + "@return {boolean}*/\n" + "function y(a) { return a }", "inconsistent return type\n" + "found : A\n" + "required: boolean"); } public void testBug930117() throws Exception { testTypes( "/** @param {boolean} x */function f(x){}" + "f(null);", "actual parameter 1 of f does not match formal parameter\n" + "found : null\n" + "required: boolean"); } public void testBug1484445() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "/** @type {number?} */ Foo.prototype.bar = null;" + "/** @type {number?} */ Foo.prototype.baz = null;" + "/** @param {Foo} foo */" + "function f(foo) {" + " while (true) {" + " if (foo.bar == null && foo.baz == null) {" + " foo.bar;" + " }" + " }" + "}"); } public void testBug1859535() throws Exception { testTypes( "/**\n" + " * @param {Function} childCtor Child class.\n" + " * @param {Function} parentCtor Parent class.\n" + " */" + "var inherits = function(childCtor, parentCtor) {" + " /** @constructor */" + " function tempCtor() {};" + " tempCtor.prototype = parentCtor.prototype;" + " childCtor.superClass_ = parentCtor.prototype;" + " childCtor.prototype = new tempCtor();" + " /** @override */ childCtor.prototype.constructor = childCtor;" + "};" + "/**" + " * @param {Function} constructor\n" + " * @param {Object} var_args\n" + " * @return {Object}\n" + " */" + "var factory = function(constructor, var_args) {" + " /** @constructor */" + " var tempCtor = function() {};" + " tempCtor.prototype = constructor.prototype;" + " var obj = new tempCtor();" + " constructor.apply(obj, arguments);" + " return obj;" + "};"); } public void testBug1940591() throws Exception { testTypes( "/** @type {Object} */" + "var a = {};\n" + "/** @type {number} */\n" + "a.name = 0;\n" + "/**\n" + " * @param {Function} x anything.\n" + " */\n" + "a.g = function(x) { x.name = 'a'; }"); } public void testBug1942972() throws Exception { testTypes( "var google = {\n"+ " gears: {\n" + " factory: {},\n" + " workerPool: {}\n" + " }\n" + "};\n" + "\n" + "google.gears = {factory: {}};\n"); } public void testBug1943776() throws Exception { testTypes( "/** @return {{foo: Array}} */" + "function bar() {" + " return {foo: []};" + "}"); } public void testBug1987544() throws Exception { testTypes( "/** @param {string} x */ function foo(x) {}" + "var duration;" + "if (true && !(duration = 3)) {" + " foo(duration);" + "}", "actual parameter 1 of foo does not match formal parameter\n" + "found : number\n" + "required: string"); } public void testBug1940769() throws Exception { testTypes( "/** @return {!Object} */ " + "function proto(obj) { return obj.prototype; }" + "/** @constructor */ function Map() {}" + "/**\n" + " * @constructor\n" + " * @extends {Map}\n" + " */" + "function Map2() { Map.call(this); };" + "Map2.prototype = proto(Map);"); } public void testBug2335992() throws Exception { testTypes( "/** @return {*} */ function f() { return 3; }" + "var x = f();" + "/** @type {string} */" + "x.y = 3;", "assignment\n" + "found : number\n" + "required: string"); } public void testBug2341812() throws Exception { testTypes( "/** @interface */" + "function EventTarget() {}" + "/** @constructor \n * @implements {EventTarget} */" + "function Node() {}" + "/** @type {number} */ Node.prototype.index;" + "/** @param {EventTarget} x \n * @return {string} */" + "function foo(x) { return x.index; }"); } public void testScopedConstructors() throws Exception { testTypes( "function foo1() { " + " /** @constructor */ function Bar() { " + " /** @type {number} */ this.x = 3;" + " }" + "}" + "function foo2() { " + " /** @constructor */ function Bar() { " + " /** @type {string} */ this.x = 'y';" + " }" + " /** " + " * @param {Bar} b\n" + " * @return {number}\n" + " */" + " function baz(b) { return b.x; }" + "}", "inconsistent return type\n" + "found : string\n" + "required: number"); } public void testQualifiedNameInference1() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "/** @type {number?} */ Foo.prototype.bar = null;" + "/** @type {number?} */ Foo.prototype.baz = null;" + "/** @param {Foo} foo */" + "function f(foo) {" + " while (true) {" + " if (!foo.baz) break; " + " foo.bar = null;" + " }" + // Tests a bug where this condition always evaluated to true. " return foo.bar == null;" + "}"); } public void testQualifiedNameInference2() throws Exception { testTypes( "var x = {};" + "x.y = c;" + "function f(a, b) {" + " if (a) {" + " if (b) " + " x.y = 2;" + " else " + " x.y = 1;" + " }" + " return x.y == null;" + "}"); } public void testQualifiedNameInference3() throws Exception { testTypes( "var x = {};" + "x.y = c;" + "function f(a, b) {" + " if (a) {" + " if (b) " + " x.y = 2;" + " else " + " x.y = 1;" + " }" + " return x.y == null;" + "} function g() { x.y = null; }"); } public void testQualifiedNameInference4() throws Exception { testTypes( "/** @param {string} x */ function f(x) {}\n" + "/**\n" + " * @param {?string} x \n" + " * @constructor\n" + " */" + "function Foo(x) { this.x_ = x; }\n" + "Foo.prototype.bar = function() {" + " if (this.x_) { f(this.x_); }" + "};"); } public void testSheqRefinedScope() throws Exception { Node n = parseAndTypeCheck( "/** @constructor */function A() {}\n" + "/** @constructor \n @extends A */ function B() {}\n" + "/** @return {number} */\n" + "B.prototype.p = function() { return 1; }\n" + "/** @param {A} a\n @param {B} b */\n" + "function f(a, b) {\n" + " b.p();\n" + " if (a === b) {\n" + " b.p();\n" + " }\n" + "}"); Node nodeC = n.getLastChild().getLastChild().getLastChild().getLastChild() .getLastChild().getLastChild(); JSType typeC = nodeC.getJSType(); assertTrue(typeC.isNumber()); Node nodeB = nodeC.getFirstChild().getFirstChild(); JSType typeB = nodeB.getJSType(); assertEquals("B", typeB.toString()); } public void testAssignToUntypedVariable() throws Exception { Node n = parseAndTypeCheck("var z; z = 1;"); Node assign = n.getLastChild().getFirstChild(); Node node = assign.getFirstChild(); assertFalse(node.getJSType().isUnknownType()); assertEquals("number", node.getJSType().toString()); } public void testAssignToUntypedProperty() throws Exception { Node n = parseAndTypeCheck( "/** @constructor */ function Foo() {}\n" + "Foo.prototype.a = 1;" + "(new Foo).a;"); Node node = n.getLastChild().getFirstChild(); assertFalse(node.getJSType().isUnknownType()); assertTrue(node.getJSType().isNumber()); } public void testNew1() throws Exception { testTypes("new 4", TypeCheck.NOT_A_CONSTRUCTOR); } public void testNew2() throws Exception { testTypes("var Math = {}; new Math()", TypeCheck.NOT_A_CONSTRUCTOR); } public void testNew3() throws Exception { testTypes("new Date()"); } public void testNew4() throws Exception { testTypes("/** @constructor */function A(){}; new A();"); } public void testNew5() throws Exception { testTypes("function A(){}; new A();", TypeCheck.NOT_A_CONSTRUCTOR); } public void testNew6() throws Exception { TypeCheckResult p = parseAndTypeCheckWithScope("/** @constructor */function A(){};" + "var a = new A();"); JSType aType = p.scope.getVar("a").getType(); assertTrue(aType instanceof ObjectType); ObjectType aObjectType = (ObjectType) aType; assertEquals("A", aObjectType.getConstructor().getReferenceName()); } public void testNew7() throws Exception { testTypes("/** @param {Function} opt_constructor */" + "function foo(opt_constructor) {" + "if (opt_constructor) { new opt_constructor; }" + "}"); } public void testNew8() throws Exception { testTypes("/** @param {Function} opt_constructor */" + "function foo(opt_constructor) {" + "new opt_constructor;" + "}"); } public void testNew9() throws Exception { testTypes("/** @param {Function} opt_constructor */" + "function foo(opt_constructor) {" + "new (opt_constructor || Array);" + "}"); } public void testNew10() throws Exception { testTypes("var goog = {};" + "/** @param {Function} opt_constructor */" + "goog.Foo = function (opt_constructor) {" + "new (opt_constructor || Array);" + "}"); } public void testNew11() throws Exception { testTypes("/** @param {Function} c1 */" + "function f(c1) {" + " var c2 = function(){};" + " c1.prototype = new c2;" + "}", TypeCheck.NOT_A_CONSTRUCTOR); } public void testNew12() throws Exception { TypeCheckResult p = parseAndTypeCheckWithScope("var a = new Array();"); Var a = p.scope.getVar("a"); assertTypeEquals(ARRAY_TYPE, a.getType()); } public void testNew13() throws Exception { TypeCheckResult p = parseAndTypeCheckWithScope( "/** @constructor */function FooBar(){};" + "var a = new FooBar();"); Var a = p.scope.getVar("a"); assertTrue(a.getType() instanceof ObjectType); assertEquals("FooBar", a.getType().toString()); } public void testNew14() throws Exception { TypeCheckResult p = parseAndTypeCheckWithScope( "/** @constructor */var FooBar = function(){};" + "var a = new FooBar();"); Var a = p.scope.getVar("a"); assertTrue(a.getType() instanceof ObjectType); assertEquals("FooBar", a.getType().toString()); } public void testNew15() throws Exception { TypeCheckResult p = parseAndTypeCheckWithScope( "var goog = {};" + "/** @constructor */goog.A = function(){};" + "var a = new goog.A();"); Var a = p.scope.getVar("a"); assertTrue(a.getType() instanceof ObjectType); assertEquals("goog.A", a.getType().toString()); } public void testNew16() throws Exception { testTypes( "/** \n" + " * @param {string} x \n" + " * @constructor \n" + " */" + "function Foo(x) {}" + "function g() { new Foo(1); }", "actual parameter 1 of Foo does not match formal parameter\n" + "found : number\n" + "required: string"); } public void testName1() throws Exception { assertTypeEquals(VOID_TYPE, testNameNode("undefined")); } public void testName2() throws Exception { assertTypeEquals(OBJECT_FUNCTION_TYPE, testNameNode("Object")); } public void testName3() throws Exception { assertTypeEquals(ARRAY_FUNCTION_TYPE, testNameNode("Array")); } public void testName4() throws Exception { assertTypeEquals(DATE_FUNCTION_TYPE, testNameNode("Date")); } public void testName5() throws Exception { assertTypeEquals(REGEXP_FUNCTION_TYPE, testNameNode("RegExp")); } /** * Type checks a NAME node and retrieve its type. */ private JSType testNameNode(String name) { Node node = Node.newString(Token.NAME, name); Node parent = new Node(Token.SCRIPT, node); parent.setInputId(new InputId("code")); Node externs = new Node(Token.SCRIPT); externs.setInputId(new InputId("externs")); Node externAndJsRoot = new Node(Token.BLOCK, externs, parent); externAndJsRoot.setIsSyntheticBlock(true); makeTypeCheck().processForTesting(null, parent); return node.getJSType(); } public void testBitOperation1() throws Exception { testTypes("/**@return {void}*/function foo(){ ~foo(); }", "operator ~ cannot be applied to undefined"); } public void testBitOperation2() throws Exception { testTypes("/**@return {void}*/function foo(){var a = foo()<<3;}", "operator << cannot be applied to undefined"); } public void testBitOperation3() throws Exception { testTypes("/**@return {void}*/function foo(){var a = 3<<foo();}", "operator << cannot be applied to undefined"); } public void testBitOperation4() throws Exception { testTypes("/**@return {void}*/function foo(){var a = foo()>>>3;}", "operator >>> cannot be applied to undefined"); } public void testBitOperation5() throws Exception { testTypes("/**@return {void}*/function foo(){var a = 3>>>foo();}", "operator >>> cannot be applied to undefined"); } public void testBitOperation6() throws Exception { testTypes("/**@return {!Object}*/function foo(){var a = foo()&3;}", "bad left operand to bitwise operator\n" + "found : Object\n" + "required: (boolean|null|number|string|undefined)"); } public void testBitOperation7() throws Exception { testTypes("var x = null; x |= undefined; x &= 3; x ^= '3'; x |= true;"); } public void testBitOperation8() throws Exception { testTypes("var x = void 0; x |= new Number(3);"); } public void testBitOperation9() throws Exception { testTypes("var x = void 0; x |= {};", "bad right operand to bitwise operator\n" + "found : {}\n" + "required: (boolean|null|number|string|undefined)"); } public void testCall1() throws Exception { testTypes("3();", "number expressions are not callable"); } public void testCall2() throws Exception { testTypes("/** @param {!Number} foo*/function bar(foo){ bar('abc'); }", "actual parameter 1 of bar does not match formal parameter\n" + "found : string\n" + "required: Number"); } public void testCall3() throws Exception { // We are checking that an unresolved named type can successfully // meet with a functional type to produce a callable type. testTypes("/** @type {Function|undefined} */var opt_f;" + "/** @type {some.unknown.type} */var f1;" + "var f2 = opt_f || f1;" + "f2();", "Bad type annotation. Unknown type some.unknown.type"); } public void testCall4() throws Exception { testTypes("/**@param {!RegExp} a*/var foo = function bar(a){ bar('abc'); }", "actual parameter 1 of bar does not match formal parameter\n" + "found : string\n" + "required: RegExp"); } public void testCall5() throws Exception { testTypes("/**@param {!RegExp} a*/var foo = function bar(a){ foo('abc'); }", "actual parameter 1 of foo does not match formal parameter\n" + "found : string\n" + "required: RegExp"); } public void testCall6() throws Exception { testTypes("/** @param {!Number} foo*/function bar(foo){}" + "bar('abc');", "actual parameter 1 of bar does not match formal parameter\n" + "found : string\n" + "required: Number"); } public void testCall7() throws Exception { testTypes("/** @param {!RegExp} a*/var foo = function bar(a){};" + "foo('abc');", "actual parameter 1 of foo does not match formal parameter\n" + "found : string\n" + "required: RegExp"); } public void testCall8() throws Exception { testTypes("/** @type {Function|number} */var f;f();", "(Function|number) expressions are " + "not callable"); } public void testCall9() throws Exception { testTypes( "var goog = {};" + "/** @constructor */ goog.Foo = function() {};" + "/** @param {!goog.Foo} a */ var bar = function(a){};" + "bar('abc');", "actual parameter 1 of bar does not match formal parameter\n" + "found : string\n" + "required: goog.Foo"); } public void testCall10() throws Exception { testTypes("/** @type {Function} */var f;f();"); } public void testCall11() throws Exception { testTypes("var f = new Function(); f();"); } public void testFunctionCall1() throws Exception { testTypes( "/** @param {number} x */ var foo = function(x) {};" + "foo.call(null, 3);"); } public void testFunctionCall2() throws Exception { testTypes( "/** @param {number} x */ var foo = function(x) {};" + "foo.call(null, 'bar');", "actual parameter 2 of foo.call does not match formal parameter\n" + "found : string\n" + "required: number"); } public void testFunctionCall3() throws Exception { testTypes( "/** @param {number} x \n * @constructor */ " + "var Foo = function(x) { this.bar.call(null, x); };" + "/** @type {function(number)} */ Foo.prototype.bar;"); } public void testFunctionCall4() throws Exception { testTypes( "/** @param {string} x \n * @constructor */ " + "var Foo = function(x) { this.bar.call(null, x); };" + "/** @type {function(number)} */ Foo.prototype.bar;", "actual parameter 2 of this.bar.call " + "does not match formal parameter\n" + "found : string\n" + "required: number"); } public void testFunctionCall5() throws Exception { testTypes( "/** @param {Function} handler \n * @constructor */ " + "var Foo = function(handler) { handler.call(this, x); };"); } public void testFunctionCall6() throws Exception { testTypes( "/** @param {Function} handler \n * @constructor */ " + "var Foo = function(handler) { handler.apply(this, x); };"); } public void testFunctionCall7() throws Exception { testTypes( "/** @param {Function} handler \n * @param {Object} opt_context */ " + "var Foo = function(handler, opt_context) { " + " handler.call(opt_context, x);" + "};"); } public void testFunctionCall8() throws Exception { testTypes( "/** @param {Function} handler \n * @param {Object} opt_context */ " + "var Foo = function(handler, opt_context) { " + " handler.apply(opt_context, x);" + "};"); } public void testCast2() throws Exception { // can upcast to a base type. testTypes("/** @constructor */function base() {}\n" + "/** @constructor\n @extends {base} */function derived() {}\n" + "/** @type {base} */ var baz = new derived();\n"); } public void testCast3() throws Exception { // cannot downcast testTypes("/** @constructor */function base() {}\n" + "/** @constructor @extends {base} */function derived() {}\n" + "/** @type {!derived} */ var baz = new base();\n", "initializing variable\n" + "found : base\n" + "required: derived"); } public void testCast4() throws Exception { // downcast must be explicit testTypes("/** @constructor */function base() {}\n" + "/** @constructor\n * @extends {base} */function derived() {}\n" + "/** @type {!derived} */ var baz = " + "/** @type {!derived} */(new base());\n"); } public void testCast5() throws Exception { // cannot explicitly cast to an unrelated type testTypes("/** @constructor */function foo() {}\n" + "/** @constructor */function bar() {}\n" + "var baz = /** @type {!foo} */(new bar);\n", "invalid cast - must be a subtype or supertype\n" + "from: bar\n" + "to : foo"); } public void testCast6() throws Exception { // can explicitly cast to a subtype or supertype testTypes("/** @constructor */function foo() {}\n" + "/** @constructor \n @extends foo */function bar() {}\n" + "var baz = /** @type {!bar} */(new bar);\n" + "var baz = /** @type {!foo} */(new foo);\n" + "var baz = /** @type {bar} */(new bar);\n" + "var baz = /** @type {foo} */(new foo);\n" + "var baz = /** @type {!foo} */(new bar);\n" + "var baz = /** @type {!bar} */(new foo);\n" + "var baz = /** @type {foo} */(new bar);\n" + "var baz = /** @type {bar} */(new foo);\n"); } public void testCast7() throws Exception { testTypes("var x = /** @type {foo} */ (new Object());", "Bad type annotation. Unknown type foo"); } public void testCast8() throws Exception { testTypes("function f() { return /** @type {foo} */ (new Object()); }", "Bad type annotation. Unknown type foo"); } public void testCast9() throws Exception { testTypes("var foo = {};" + "function f() { return /** @type {foo} */ (new Object()); }", "Bad type annotation. Unknown type foo"); } public void testCast10() throws Exception { testTypes("var foo = function() {};" + "function f() { return /** @type {foo} */ (new Object()); }", "Bad type annotation. Unknown type foo"); } public void testCast11() throws Exception { testTypes("var goog = {}; goog.foo = {};" + "function f() { return /** @type {goog.foo} */ (new Object()); }", "Bad type annotation. Unknown type goog.foo"); } public void testCast12() throws Exception { testTypes("var goog = {}; goog.foo = function() {};" + "function f() { return /** @type {goog.foo} */ (new Object()); }", "Bad type annotation. Unknown type goog.foo"); } public void testCast13() throws Exception { // Test to make sure that the forward-declaration still allows for // a warning. testClosureTypes("var goog = {}; " + "goog.addDependency('zzz.js', ['goog.foo'], []);" + "goog.foo = function() {};" + "function f() { return /** @type {goog.foo} */ (new Object()); }", "Bad type annotation. Unknown type goog.foo"); } public void testCast14() throws Exception { // Test to make sure that the forward-declaration still prevents // some warnings. testClosureTypes("var goog = {}; " + "goog.addDependency('zzz.js', ['goog.bar'], []);" + "function f() { return /** @type {goog.bar} */ (new Object()); }", null); } public void testCast15() throws Exception { // This fixes a bug where a type cast on an object literal // would cause a run-time cast exception if the node was visited // more than once. // // Some code assumes that an object literal must have a object type, // while because of the cast, it could have any type (including // a union). testTypes( "for (var i = 0; i < 10; i++) {" + "var x = /** @type {Object|number} */ ({foo: 3});" + "/** @param {number} x */ function f(x) {}" + "f(x.foo);" + "f([].foo);" + "}", "Property foo never defined on Array"); } public void testCast16() throws Exception { // Mostly verifying that rhino actually understands these JsDocs. testTypes("/** @constructor */ function Foo() {} \n" + "/** @type {Foo} */ var x = /** @type {Foo} */ ({})"); testTypes("/** @constructor */ function Foo() {} \n" + "/** @type {Foo} */ var x = (/** @type {Foo} */ y)"); } public void testNestedCasts() throws Exception { testTypes("/** @constructor */var T = function() {};\n" + "/** @constructor */var V = function() {};\n" + "/**\n" + "* @param {boolean} b\n" + "* @return {T|V}\n" + "*/\n" + "function f(b) { return b ? new T() : new V(); }\n" + "/**\n" + "* @param {boolean} b\n" + "* @return {boolean|undefined}\n" + "*/\n" + "function g(b) { return b ? true : undefined; }\n" + "/** @return {T} */\n" + "function h() {\n" + "return /** @type {T} */ (f(/** @type {boolean} */ (g(true))));\n" + "}"); } public void testNativeCast1() throws Exception { testTypes( "/** @param {number} x */ function f(x) {}" + "f(String(true));", "actual parameter 1 of f does not match formal parameter\n" + "found : string\n" + "required: number"); } public void testNativeCast2() throws Exception { testTypes( "/** @param {string} x */ function f(x) {}" + "f(Number(true));", "actual parameter 1 of f does not match formal parameter\n" + "found : number\n" + "required: string"); } public void testNativeCast3() throws Exception { testTypes( "/** @param {number} x */ function f(x) {}" + "f(Boolean(''));", "actual parameter 1 of f does not match formal parameter\n" + "found : boolean\n" + "required: number"); } public void testNativeCast4() throws Exception { testTypes( "/** @param {number} x */ function f(x) {}" + "f(Error(''));", "actual parameter 1 of f does not match formal parameter\n" + "found : Error\n" + "required: number"); } public void testBadConstructorCall() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "Foo();", "Constructor function (new:Foo): undefined should be called " + "with the \"new\" keyword"); } public void testTypeof() throws Exception { testTypes("/**@return {void}*/function foo(){ var a = typeof foo(); }"); } public void testConstructorType1() throws Exception { testTypes("/**@constructor*/function Foo(){}" + "/**@type{!Foo}*/var f = new Date();", "initializing variable\n" + "found : Date\n" + "required: Foo"); } public void testConstructorType2() throws Exception { testTypes("/**@constructor*/function Foo(){\n" + "/**@type{Number}*/this.bar = new Number(5);\n" + "}\n" + "/**@type{Foo}*/var f = new Foo();\n" + "/**@type{Number}*/var n = f.bar;"); } public void testConstructorType3() throws Exception { // Reverse the declaration order so that we know that Foo is getting set // even on an out-of-order declaration sequence. testTypes("/**@type{Foo}*/var f = new Foo();\n" + "/**@type{Number}*/var n = f.bar;" + "/**@constructor*/function Foo(){\n" + "/**@type{Number}*/this.bar = new Number(5);\n" + "}\n"); } public void testConstructorType4() throws Exception { testTypes("/**@constructor*/function Foo(){\n" + "/**@type{!Number}*/this.bar = new Number(5);\n" + "}\n" + "/**@type{!Foo}*/var f = new Foo();\n" + "/**@type{!String}*/var n = f.bar;", "initializing variable\n" + "found : Number\n" + "required: String"); } public void testConstructorType5() throws Exception { testTypes("/**@constructor*/function Foo(){}\n" + "if (Foo){}\n"); } public void testConstructorType6() throws Exception { testTypes("/** @constructor */\n" + "function bar() {}\n" + "function _foo() {\n" + " /** @param {bar} x */\n" + " function f(x) {}\n" + "}"); } public void testConstructorType7() throws Exception { TypeCheckResult p = parseAndTypeCheckWithScope("/** @constructor */function A(){};"); JSType type = p.scope.getVar("A").getType(); assertTrue(type instanceof FunctionType); FunctionType fType = (FunctionType) type; assertEquals("A", fType.getReferenceName()); } public void testAnonymousType1() throws Exception { testTypes("function f() { return {}; }" + "/** @constructor */\n" + "f().bar = function() {};"); } public void testAnonymousType2() throws Exception { testTypes("function f() { return {}; }" + "/** @interface */\n" + "f().bar = function() {};"); } public void testAnonymousType3() throws Exception { testTypes("function f() { return {}; }" + "/** @enum */\n" + "f().bar = {FOO: 1};"); } public void testBang1() throws Exception { testTypes("/** @param {Object} x\n@return {!Object} */\n" + "function f(x) { return x; }", "inconsistent return type\n" + "found : (Object|null|undefined)\n" + "required: Object"); } public void testBang2() throws Exception { testTypes("/** @param {Object} x\n@return {!Object} */\n" + "function f(x) { return x ? x : new Object(); }"); } public void testBang3() throws Exception { testTypes("/** @param {Object} x\n@return {!Object} */\n" + "function f(x) { return /** @type {!Object} */ (x); }"); } public void testBang4() throws Exception { testTypes("/**@param {Object} x\n@param {Object} y\n@return {boolean}*/\n" + "function f(x, y) {\n" + "if (typeof x != 'undefined') { return x == y; }\n" + "else { return x != y; }\n}"); } public void testBang5() throws Exception { testTypes("/**@param {Object} x\n@param {Object} y\n@return {boolean}*/\n" + "function f(x, y) { return !!x && x == y; }"); } public void testBang6() throws Exception { testTypes("/** @param {Object?} x\n@return {Object} */\n" + "function f(x) { return x; }"); } public void testBang7() throws Exception { testTypes("/**@param {(Object,string,null)} x\n" + "@return {(Object,string)}*/function f(x) { return x; }"); } public void testDefinePropertyOnNullableObject1() throws Exception { testTypes("/** @type {Object} */ var n = {};\n" + "/** @type {number} */ n.x = 1;\n" + "/** @return {boolean} */function f() { return n.x; }", "inconsistent return type\n" + "found : number\n" + "required: boolean"); } public void testDefinePropertyOnNullableObject2() throws Exception { testTypes("/** @constructor */ var T = function() {};\n" + "/** @param {T} t\n@return {boolean} */function f(t) {\n" + "t.x = 1; return t.x; }", "inconsistent return type\n" + "found : number\n" + "required: boolean"); } public void testUnknownConstructorInstanceType1() throws Exception { testTypes("/** @return {Array} */ function g(f) { return new f(); }"); } public void testUnknownConstructorInstanceType2() throws Exception { testTypes("function g(f) { return /** @type Array */ (new f()); }"); } public void testUnknownConstructorInstanceType3() throws Exception { testTypes("function g(f) { var x = new f(); x.a = 1; return x; }"); } public void testUnknownPrototypeChain() throws Exception { testTypes("/**\n" + "* @param {Object} co\n" + " * @return {Object}\n" + " */\n" + "function inst(co) {\n" + " /** @constructor */\n" + " var c = function() {};\n" + " c.prototype = co.prototype;\n" + " return new c;\n" + "}"); } public void testNamespacedConstructor() throws Exception { Node root = parseAndTypeCheck( "var goog = {};" + "/** @constructor */ goog.MyClass = function() {};" + "/** @return {!goog.MyClass} */ " + "function foo() { return new goog.MyClass(); }"); JSType typeOfFoo = root.getLastChild().getJSType(); assert(typeOfFoo instanceof FunctionType); JSType retType = ((FunctionType) typeOfFoo).getReturnType(); assert(retType instanceof ObjectType); assertEquals("goog.MyClass", ((ObjectType) retType).getReferenceName()); } public void testComplexNamespace() throws Exception { String js = "var goog = {};" + "goog.foo = {};" + "goog.foo.bar = 5;"; TypeCheckResult p = parseAndTypeCheckWithScope(js); // goog type in the scope JSType googScopeType = p.scope.getVar("goog").getType(); assertTrue(googScopeType instanceof ObjectType); assertTrue("foo property not present on goog type", ((ObjectType) googScopeType).hasProperty("foo")); assertFalse("bar property present on goog type", ((ObjectType) googScopeType).hasProperty("bar")); // goog type on the VAR node Node varNode = p.root.getFirstChild(); assertEquals(Token.VAR, varNode.getType()); JSType googNodeType = varNode.getFirstChild().getJSType(); assertTrue(googNodeType instanceof ObjectType); // goog scope type and goog type on VAR node must be the same assertTrue(googScopeType == googNodeType); // goog type on the left of the GETPROP node (under fist ASSIGN) Node getpropFoo1 = varNode.getNext().getFirstChild().getFirstChild(); assertEquals(Token.GETPROP, getpropFoo1.getType()); assertEquals("goog", getpropFoo1.getFirstChild().getString()); JSType googGetpropFoo1Type = getpropFoo1.getFirstChild().getJSType(); assertTrue(googGetpropFoo1Type instanceof ObjectType); // still the same type as the one on the variable assertTrue(googGetpropFoo1Type == googScopeType); // the foo property should be defined on goog JSType googFooType = ((ObjectType) googScopeType).getPropertyType("foo"); assertTrue(googFooType instanceof ObjectType); // goog type on the left of the GETPROP lower level node // (under second ASSIGN) Node getpropFoo2 = varNode.getNext().getNext() .getFirstChild().getFirstChild().getFirstChild(); assertEquals(Token.GETPROP, getpropFoo2.getType()); assertEquals("goog", getpropFoo2.getFirstChild().getString()); JSType googGetpropFoo2Type = getpropFoo2.getFirstChild().getJSType(); assertTrue(googGetpropFoo2Type instanceof ObjectType); // still the same type as the one on the variable assertTrue(googGetpropFoo2Type == googScopeType); // goog.foo type on the left of the top-level GETPROP node // (under second ASSIGN) JSType googFooGetprop2Type = getpropFoo2.getJSType(); assertTrue("goog.foo incorrectly annotated in goog.foo.bar selection", googFooGetprop2Type instanceof ObjectType); ObjectType googFooGetprop2ObjectType = (ObjectType) googFooGetprop2Type; assertFalse("foo property present on goog.foo type", googFooGetprop2ObjectType.hasProperty("foo")); assertTrue("bar property not present on goog.foo type", googFooGetprop2ObjectType.hasProperty("bar")); assertTypeEquals("bar property on goog.foo type incorrectly inferred", NUMBER_TYPE, googFooGetprop2ObjectType.getPropertyType("bar")); } public void testAddingMethodsUsingPrototypeIdiomSimpleNamespace() throws Exception { Node js1Node = parseAndTypeCheck( "/** @constructor */function A() {}" + "A.prototype.m1 = 5"); ObjectType instanceType = getInstanceType(js1Node); assertEquals(NATIVE_PROPERTIES_COUNT + 1, instanceType.getPropertiesCount()); checkObjectType(instanceType, "m1", NUMBER_TYPE); } public void testAddingMethodsUsingPrototypeIdiomComplexNamespace1() throws Exception { TypeCheckResult p = parseAndTypeCheckWithScope( "var goog = {};" + "goog.A = /** @constructor */function() {};" + "/** @type number */goog.A.prototype.m1 = 5"); testAddingMethodsUsingPrototypeIdiomComplexNamespace(p); } public void testAddingMethodsUsingPrototypeIdiomComplexNamespace2() throws Exception { TypeCheckResult p = parseAndTypeCheckWithScope( "var goog = {};" + "/** @constructor */goog.A = function() {};" + "/** @type number */goog.A.prototype.m1 = 5"); testAddingMethodsUsingPrototypeIdiomComplexNamespace(p); } private void testAddingMethodsUsingPrototypeIdiomComplexNamespace( TypeCheckResult p) { ObjectType goog = (ObjectType) p.scope.getVar("goog").getType(); assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount()); JSType googA = goog.getPropertyType("A"); assertNotNull(googA); assertTrue(googA instanceof FunctionType); FunctionType googAFunction = (FunctionType) googA; ObjectType classA = googAFunction.getInstanceType(); assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount()); checkObjectType(classA, "m1", NUMBER_TYPE); } public void testAddingMethodsPrototypeIdiomAndObjectLiteralSimpleNamespace() throws Exception { Node js1Node = parseAndTypeCheck( "/** @constructor */function A() {}" + "A.prototype = {m1: 5, m2: true}"); ObjectType instanceType = getInstanceType(js1Node); assertEquals(NATIVE_PROPERTIES_COUNT + 2, instanceType.getPropertiesCount()); checkObjectType(instanceType, "m1", NUMBER_TYPE); checkObjectType(instanceType, "m2", BOOLEAN_TYPE); } public void testDontAddMethodsIfNoConstructor() throws Exception { Node js1Node = parseAndTypeCheck( "function A() {}" + "A.prototype = {m1: 5, m2: true}"); JSType functionAType = js1Node.getFirstChild().getJSType(); assertEquals("function (): undefined", functionAType.toString()); assertTypeEquals(UNKNOWN_TYPE, U2U_FUNCTION_TYPE.getPropertyType("m1")); assertTypeEquals(UNKNOWN_TYPE, U2U_FUNCTION_TYPE.getPropertyType("m2")); } public void testFunctionAssignement() throws Exception { testTypes("/**" + "* @param {string} ph0" + "* @param {string} ph1" + "* @return {string}" + "*/" + "function MSG_CALENDAR_ACCESS_ERROR(ph0, ph1) {return ''}" + "/** @type {Function} */" + "var MSG_CALENDAR_ADD_ERROR = MSG_CALENDAR_ACCESS_ERROR;"); } public void testAddMethodsPrototypeTwoWays() throws Exception { Node js1Node = parseAndTypeCheck( "/** @constructor */function A() {}" + "A.prototype = {m1: 5, m2: true};" + "A.prototype.m3 = 'third property!';"); ObjectType instanceType = getInstanceType(js1Node); assertEquals("A", instanceType.toString()); assertEquals(NATIVE_PROPERTIES_COUNT + 3, instanceType.getPropertiesCount()); checkObjectType(instanceType, "m1", NUMBER_TYPE); checkObjectType(instanceType, "m2", BOOLEAN_TYPE); checkObjectType(instanceType, "m3", STRING_TYPE); } public void testPrototypePropertyTypes() throws Exception { Node js1Node = parseAndTypeCheck( "/** @constructor */function A() {\n" + " /** @type string */ this.m1;\n" + " /** @type Object? */ this.m2 = {};\n" + " /** @type boolean */ this.m3;\n" + "}\n" + "/** @type string */ A.prototype.m4;\n" + "/** @type number */ A.prototype.m5 = 0;\n" + "/** @type boolean */ A.prototype.m6;\n"); ObjectType instanceType = getInstanceType(js1Node); assertEquals(NATIVE_PROPERTIES_COUNT + 6, instanceType.getPropertiesCount()); checkObjectType(instanceType, "m1", STRING_TYPE); checkObjectType(instanceType, "m2", createUnionType(createUnionType(OBJECT_TYPE, NULL_TYPE), VOID_TYPE)); checkObjectType(instanceType, "m3", BOOLEAN_TYPE); checkObjectType(instanceType, "m4", STRING_TYPE); checkObjectType(instanceType, "m5", NUMBER_TYPE); checkObjectType(instanceType, "m6", BOOLEAN_TYPE); } public void testValueTypeBuiltInPrototypePropertyType() throws Exception { Node node = parseAndTypeCheck("\"x\".charAt(0)"); assertTypeEquals(STRING_TYPE, node.getFirstChild().getFirstChild().getJSType()); } public void testDeclareBuiltInConstructor() throws Exception { // Built-in prototype properties should be accessible // even if the built-in constructor is declared. Node node = parseAndTypeCheck( "/** @constructor */ var String = function(opt_str) {};\n" + "(new String(\"x\")).charAt(0)"); assertTypeEquals(STRING_TYPE, node.getLastChild().getFirstChild().getJSType()); } public void testExtendBuiltInType1() throws Exception { String externs = "/** @constructor */ var String = function(opt_str) {};\n" + "/**\n" + "* @param {number} start\n" + "* @param {number} opt_length\n" + "* @return {string}\n" + "*/\n" + "String.prototype.substr = function(start, opt_length) {};\n"; Node n1 = parseAndTypeCheck(externs + "(new String(\"x\")).substr(0,1);"); assertTypeEquals(STRING_TYPE, n1.getLastChild().getFirstChild().getJSType()); } public void testExtendBuiltInType2() throws Exception { String externs = "/** @constructor */ var String = function(opt_str) {};\n" + "/**\n" + "* @param {number} start\n" + "* @param {number} opt_length\n" + "* @return {string}\n" + "*/\n" + "String.prototype.substr = function(start, opt_length) {};\n"; Node n2 = parseAndTypeCheck(externs + "\"x\".substr(0,1);"); assertTypeEquals(STRING_TYPE, n2.getLastChild().getFirstChild().getJSType()); } public void testExtendFunction1() throws Exception { Node n = parseAndTypeCheck("/**@return {number}*/Function.prototype.f = " + "function() { return 1; };\n" + "(new Function()).f();"); JSType type = n.getLastChild().getLastChild().getJSType(); assertTypeEquals(NUMBER_TYPE, type); } public void testExtendFunction2() throws Exception { Node n = parseAndTypeCheck("/**@return {number}*/Function.prototype.f = " + "function() { return 1; };\n" + "(function() {}).f();"); JSType type = n.getLastChild().getLastChild().getJSType(); assertTypeEquals(NUMBER_TYPE, type); } public void testInheritanceCheck1() throws Exception { testTypes( "/** @constructor */function Super() {};" + "/** @constructor\n @extends {Super} */function Sub() {};" + "Sub.prototype.foo = function() {};"); } public void testInheritanceCheck2() throws Exception { testTypes( "/** @constructor */function Super() {};" + "/** @constructor\n @extends {Super} */function Sub() {};" + "/** @override */Sub.prototype.foo = function() {};", "property foo not defined on any superclass of Sub"); } public void testInheritanceCheck3() throws Exception { testTypes( "/** @constructor */function Super() {};" + "Super.prototype.foo = function() {};" + "/** @constructor\n @extends {Super} */function Sub() {};" + "Sub.prototype.foo = function() {};", "property foo already defined on superclass Super; " + "use @override to override it"); } public void testInheritanceCheck4() throws Exception { testTypes( "/** @constructor */function Super() {};" + "Super.prototype.foo = function() {};" + "/** @constructor\n @extends {Super} */function Sub() {};" + "/** @override */Sub.prototype.foo = function() {};"); } public void testInheritanceCheck5() throws Exception { testTypes( "/** @constructor */function Root() {};" + "Root.prototype.foo = function() {};" + "/** @constructor\n @extends {Root} */function Super() {};" + "/** @constructor\n @extends {Super} */function Sub() {};" + "Sub.prototype.foo = function() {};", "property foo already defined on superclass Root; " + "use @override to override it"); } public void testInheritanceCheck6() throws Exception { testTypes( "/** @constructor */function Root() {};" + "Root.prototype.foo = function() {};" + "/** @constructor\n @extends {Root} */function Super() {};" + "/** @constructor\n @extends {Super} */function Sub() {};" + "/** @override */Sub.prototype.foo = function() {};"); } public void testInheritanceCheck7() throws Exception { testTypes( "var goog = {};" + "/** @constructor */goog.Super = function() {};" + "goog.Super.prototype.foo = 3;" + "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};" + "goog.Sub.prototype.foo = 5;"); } public void testInheritanceCheck8() throws Exception { testTypes( "var goog = {};" + "/** @constructor */goog.Super = function() {};" + "goog.Super.prototype.foo = 3;" + "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};" + "/** @override */goog.Sub.prototype.foo = 5;"); } public void testInheritanceCheck9_1() throws Exception { testTypes( "/** @constructor */function Super() {};" + "Super.prototype.foo = function() { return 3; };" + "/** @constructor\n @extends {Super} */function Sub() {};" + "/** @override\n @return {number} */Sub.prototype.foo =\n" + "function() { return 1; };"); } public void testInheritanceCheck9_2() throws Exception { testTypes( "/** @constructor */function Super() {};" + "/** @return {number} */" + "Super.prototype.foo = function() { return 1; };" + "/** @constructor\n @extends {Super} */function Sub() {};" + "/** @override */Sub.prototype.foo =\n" + "function() {};"); } public void testInheritanceCheck9_3() throws Exception { testTypes( "/** @constructor */function Super() {};" + "/** @return {number} */" + "Super.prototype.foo = function() { return 1; };" + "/** @constructor\n @extends {Super} */function Sub() {};" + "/** @override\n @return {string} */Sub.prototype.foo =\n" + "function() { return \"some string\" };", "mismatch of the foo property type and the type of the property it " + "overrides from superclass Super\n" + "original: function (this:Super): number\n" + "override: function (this:Sub): string"); } public void testInheritanceCheck10_1() throws Exception { testTypes( "/** @constructor */function Root() {};" + "Root.prototype.foo = function() { return 4; };" + "/** @constructor\n @extends {Root} */function Super() {};" + "/** @constructor\n @extends {Super} */function Sub() {};" + "/** @override\n @return {number} */Sub.prototype.foo =\n" + "function() { return 1; };"); } public void testInheritanceCheck10_2() throws Exception { testTypes( "/** @constructor */function Root() {};" + "/** @return {number} */" + "Root.prototype.foo = function() { return 1; };" + "/** @constructor\n @extends {Root} */function Super() {};" + "/** @constructor\n @extends {Super} */function Sub() {};" + "/** @override */Sub.prototype.foo =\n" + "function() {};"); } public void testInheritanceCheck10_3() throws Exception { testTypes( "/** @constructor */function Root() {};" + "/** @return {number} */" + "Root.prototype.foo = function() { return 1; };" + "/** @constructor\n @extends {Root} */function Super() {};" + "/** @constructor\n @extends {Super} */function Sub() {};" + "/** @override\n @return {string} */Sub.prototype.foo =\n" + "function() { return \"some string\" };", "mismatch of the foo property type and the type of the property it " + "overrides from superclass Root\n" + "original: function (this:Root): number\n" + "override: function (this:Sub): string"); } public void testInterfaceInheritanceCheck11() throws Exception { testTypes( "/** @constructor */function Super() {};" + "/** @param {number} bar */Super.prototype.foo = function(bar) {};" + "/** @constructor\n @extends {Super} */function Sub() {};" + "/** @override\n @param {string} bar */Sub.prototype.foo =\n" + "function(bar) {};", "mismatch of the foo property type and the type of the property it " + "overrides from superclass Super\n" + "original: function (this:Super, number): undefined\n" + "override: function (this:Sub, string): undefined"); } public void testInheritanceCheck12() throws Exception { testTypes( "var goog = {};" + "/** @constructor */goog.Super = function() {};" + "goog.Super.prototype.foo = 3;" + "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};" + "/** @override */goog.Sub.prototype.foo = \"some string\";"); } public void testInheritanceCheck13() throws Exception { testTypes( "var goog = {};\n" + "/** @constructor\n @extends {goog.Missing} */function Sub() {};" + "/** @override */Sub.prototype.foo = function() {};", "Bad type annotation. Unknown type goog.Missing"); } public void testInheritanceCheck14() throws Exception { testTypes( "var goog = {};\n" + "/** @constructor\n @extends {goog.Missing} */\n" + "goog.Super = function() {};\n" + "/** @constructor\n @extends {goog.Super} */function Sub() {};" + "/** @override */Sub.prototype.foo = function() {};", "Bad type annotation. Unknown type goog.Missing"); } // TODO(user): We should support this way of declaring properties as it is // widely used. //public void testInheritanceCheck15() throws Exception { // testTypes( // "/** @constructor */function Super() {};" + // "/** @param {number} bar */Super.prototype.foo;" + // "/** @constructor\n @extends {Super} */function Sub() {};" + // "/** @override\n @param {number} bar */Sub.prototype.foo =\n" + // "function(bar) {};"); //} // public void testInterfacePropertyOverride1() throws Exception { // testTypes( // "/** @interface */function Super() {};" + // "/** @desc description */Super.prototype.foo = function() {};" + // "/** @interface\n @extends {Super} */function Sub() {};" + // "/** @desc description */Sub.prototype.foo = function() {};", // "property foo is already defined by the Super extended interface"); // } // public void testInterfacePropertyOverride2() throws Exception { // testTypes( // "/** @interface */function Root() {};" + // "/** @desc description */Root.prototype.foo = function() {};" + // "/** @interface\n @extends {Root} */function Super() {};" + // "/** @interface\n @extends {Super} */function Sub() {};" + // "/** @desc description */Sub.prototype.foo = function() {};", // "property foo is already defined by the Root extended interface"); // } public void testInterfaceInheritanceCheck1() throws Exception { testTypes( "/** @interface */function Super() {};" + "/** @desc description */Super.prototype.foo = function() {};" + "/** @constructor\n @implements {Super} */function Sub() {};" + "Sub.prototype.foo = function() {};", "property foo already defined on interface Super; use @override to " + "override it"); } public void testInterfaceInheritanceCheck2() throws Exception { testTypes( "/** @interface */function Super() {};" + "/** @desc description */Super.prototype.foo = function() {};" + "/** @constructor\n @implements {Super} */function Sub() {};" + "/** @override */Sub.prototype.foo = function() {};"); } public void testInterfaceInheritanceCheck3() throws Exception { testTypes( "/** @interface */function Root() {};" + "/** @return {number} */Root.prototype.foo = function() {};" + "/** @interface\n @extends {Root} */function Super() {};" + "/** @constructor\n @implements {Super} */function Sub() {};" + "/** @return {number} */Sub.prototype.foo = function() { return 1;};", "property foo already defined on interface Root; use @override to " + "override it"); } public void testInterfaceInheritanceCheck4() throws Exception { testTypes( "/** @interface */function Root() {};" + "/** @return {number} */Root.prototype.foo = function() {};" + "/** @interface\n @extends {Root} */function Super() {};" + "/** @constructor\n @implements {Super} */function Sub() {};" + "/** @override\n * @return {number} */Sub.prototype.foo =\n" + "function() { return 1;};"); } public void testInterfaceInheritanceCheck5() throws Exception { testTypes( "/** @interface */function Super() {};" + "/** @return {string} */Super.prototype.foo = function() {};" + "/** @constructor\n @implements {Super} */function Sub() {};" + "/** @override\n @return {number} */Sub.prototype.foo =\n" + "function() { return 1; };", "mismatch of the foo property type and the type of the property it " + "overrides from interface Super\n" + "original: function (this:Super): string\n" + "override: function (this:Sub): number"); } public void testInterfaceInheritanceCheck6() throws Exception { testTypes( "/** @interface */function Root() {};" + "/** @return {string} */Root.prototype.foo = function() {};" + "/** @interface\n @extends {Root} */function Super() {};" + "/** @constructor\n @implements {Super} */function Sub() {};" + "/** @override\n @return {number} */Sub.prototype.foo =\n" + "function() { return 1; };", "mismatch of the foo property type and the type of the property it " + "overrides from interface Root\n" + "original: function (this:Root): string\n" + "override: function (this:Sub): number"); } public void testInterfaceInheritanceCheck7() throws Exception { testTypes( "/** @interface */function Super() {};" + "/** @param {number} bar */Super.prototype.foo = function(bar) {};" + "/** @constructor\n @implements {Super} */function Sub() {};" + "/** @override\n @param {string} bar */Sub.prototype.foo =\n" + "function(bar) {};", "mismatch of the foo property type and the type of the property it " + "overrides from interface Super\n" + "original: function (this:Super, number): undefined\n" + "override: function (this:Sub, string): undefined"); } public void testInterfaceInheritanceCheck8() throws Exception { testTypes( "/** @constructor\n @implements {Super} */function Sub() {};" + "/** @override */Sub.prototype.foo = function() {};", new String[] { "Bad type annotation. Unknown type Super", "property foo not defined on any superclass of Sub" }); } public void testInterfacePropertyNotImplemented() throws Exception { testTypes( "/** @interface */function Int() {};" + "/** @desc description */Int.prototype.foo = function() {};" + "/** @constructor\n @implements {Int} */function Foo() {};", "property foo on interface Int is not implemented by type Foo"); } public void testInterfacePropertyNotImplemented2() throws Exception { testTypes( "/** @interface */function Int() {};" + "/** @desc description */Int.prototype.foo = function() {};" + "/** @interface \n @extends {Int} */function Int2() {};" + "/** @constructor\n @implements {Int2} */function Foo() {};", "property foo on interface Int is not implemented by type Foo"); } public void testStubConstructorImplementingInterface() throws Exception { // This does not throw a warning for unimplemented property because Foo is // just a stub. testTypes( // externs "/** @interface */ function Int() {}\n" + "/** @desc description */Int.prototype.foo = function() {};" + "/** @constructor \n @implements {Int} */ var Foo;\n", "", null, false); } public void testObjectLiteral() throws Exception { Node n = parseAndTypeCheck("var a = {m1: 7, m2: 'hello'}"); Node nameNode = n.getFirstChild().getFirstChild(); Node objectNode = nameNode.getFirstChild(); // node extraction assertEquals(Token.NAME, nameNode.getType()); assertEquals(Token.OBJECTLIT, objectNode.getType()); // value's type ObjectType objectType = (ObjectType) objectNode.getJSType(); assertTypeEquals(NUMBER_TYPE, objectType.getPropertyType("m1")); assertTypeEquals(STRING_TYPE, objectType.getPropertyType("m2")); // variable's type assertTypeEquals(objectType, nameNode.getJSType()); } public void testObjectLiteralDeclaration1() throws Exception { testTypes( "var x = {" + "/** @type {boolean} */ abc: true," + "/** @type {number} */ 'def': 0," + "/** @type {string} */ 3: 'fgh'" + "};"); } public void testCallDateConstructorAsFunction() throws Exception { // ECMA-262 15.9.2: When Date is called as a function rather than as a // constructor, it returns a string. Node n = parseAndTypeCheck("Date()"); assertTypeEquals(STRING_TYPE, n.getFirstChild().getFirstChild().getJSType()); } // According to ECMA-262, Error & Array function calls are equivalent to // constructor calls. public void testCallErrorConstructorAsFunction() throws Exception { Node n = parseAndTypeCheck("Error('x')"); assertTypeEquals(ERROR_TYPE, n.getFirstChild().getFirstChild().getJSType()); } public void testCallArrayConstructorAsFunction() throws Exception { Node n = parseAndTypeCheck("Array()"); assertTypeEquals(ARRAY_TYPE, n.getFirstChild().getFirstChild().getJSType()); } public void testPropertyTypeOfUnionType() throws Exception { testTypes("var a = {};" + "/** @constructor */ a.N = function() {};\n" + "a.N.prototype.p = 1;\n" + "/** @constructor */ a.S = function() {};\n" + "a.S.prototype.p = 'a';\n" + "/** @param {!a.N|!a.S} x\n@return {string} */\n" + "var f = function(x) { return x.p; };", "inconsistent return type\n" + "found : (number|string)\n" + "required: string"); } // TODO(user): We should flag these as invalid. This will probably happen // when we make sure the interface is never referenced outside of its // definition. We might want more specific and helpful error messages. //public void testWarningOnInterfacePrototype() throws Exception { // testTypes("/** @interface */ u.T = function() {};\n" + // "/** @return {number} */ u.T.prototype = function() { };", // "cannot reference an interface outside of its definition"); //} // //public void testBadPropertyOnInterface1() throws Exception { // testTypes("/** @interface */ u.T = function() {};\n" + // "/** @return {number} */ u.T.f = function() { return 1;};", // "cannot reference an interface outside of its definition"); //} // //public void testBadPropertyOnInterface2() throws Exception { // testTypes("/** @interface */ function T() {};\n" + // "/** @return {number} */ T.f = function() { return 1;};", // "cannot reference an interface outside of its definition"); //} // //public void testBadPropertyOnInterface3() throws Exception { // testTypes("/** @interface */ u.T = function() {}; u.T.x", // "cannot reference an interface outside of its definition"); //} // //public void testBadPropertyOnInterface4() throws Exception { // testTypes("/** @interface */ function T() {}; T.x;", // "cannot reference an interface outside of its definition"); //} public void testAnnotatedPropertyOnInterface1() throws Exception { // For interfaces we must allow function definitions that don't have a // return statement, even though they declare a returned type. testTypes("/** @interface */ u.T = function() {};\n" + "/** @return {number} */ u.T.prototype.f = function() {};"); } public void testAnnotatedPropertyOnInterface2() throws Exception { testTypes("/** @interface */ u.T = function() {};\n" + "/** @return {number} */ u.T.prototype.f = function() { };"); } public void testAnnotatedPropertyOnInterface3() throws Exception { testTypes("/** @interface */ function T() {};\n" + "/** @return {number} */ T.prototype.f = function() { };"); } public void testAnnotatedPropertyOnInterface4() throws Exception { testTypes( CLOSURE_DEFS + "/** @interface */ function T() {};\n" + "/** @return {number} */ T.prototype.f = goog.abstractMethod;"); } // TODO(user): If we want to support this syntax we have to warn about // missing annotations. //public void testWarnUnannotatedPropertyOnInterface1() throws Exception { // testTypes("/** @interface */ u.T = function () {}; u.T.prototype.x;", // "interface property x is not annotated"); //} // //public void testWarnUnannotatedPropertyOnInterface2() throws Exception { // testTypes("/** @interface */ function T() {}; T.prototype.x;", // "interface property x is not annotated"); //} public void testWarnUnannotatedPropertyOnInterface5() throws Exception { testTypes("/** @interface */ u.T = function () {};\n" + "/** @desc x does something */u.T.prototype.x = function() {};"); } public void testWarnUnannotatedPropertyOnInterface6() throws Exception { testTypes("/** @interface */ function T() {};\n" + "/** @desc x does something */T.prototype.x = function() {};"); } // TODO(user): If we want to support this syntax we have to warn about // the invalid type of the interface member. //public void testWarnDataPropertyOnInterface1() throws Exception { // testTypes("/** @interface */ u.T = function () {};\n" + // "/** @type {number} */u.T.prototype.x;", // "interface members can only be plain functions"); //} // //public void testWarnDataPropertyOnInterface2() throws Exception { // testTypes("/** @interface */ function T() {};\n" + // "/** @type {number} */T.prototype.x;", // "interface members can only be plain functions"); //} public void testWarnDataPropertyOnInterface3() throws Exception { testTypes("/** @interface */ u.T = function () {};\n" + "/** @type {number} */u.T.prototype.x = 1;", "interface members can only be empty property declarations, " + "empty functions, or goog.abstractMethod"); } public void testWarnDataPropertyOnInterface4() throws Exception { testTypes("/** @interface */ function T() {};\n" + "/** @type {number} */T.prototype.x = 1;", "interface members can only be empty property declarations, " + "empty functions, or goog.abstractMethod"); } // TODO(user): If we want to support this syntax we should warn about the // mismatching types in the two tests below. //public void testErrorMismatchingPropertyOnInterface1() throws Exception { // testTypes("/** @interface */ u.T = function () {};\n" + // "/** @param {Number} foo */u.T.prototype.x =\n" + // "/** @param {String} foo */function(foo) {};", // "found : \n" + // "required: "); //} // //public void testErrorMismatchingPropertyOnInterface2() throws Exception { // testTypes("/** @interface */ function T() {};\n" + // "/** @return {number} */T.prototype.x =\n" + // "/** @return {string} */function() {};", // "found : \n" + // "required: "); //} // TODO(user): We should warn about this (bar is missing an annotation). We // probably don't want to warn about all missing parameter annotations, but // we should be as strict as possible regarding interfaces. //public void testErrorMismatchingPropertyOnInterface3() throws Exception { // testTypes("/** @interface */ u.T = function () {};\n" + // "/** @param {Number} foo */u.T.prototype.x =\n" + // "function(foo, bar) {};", // "found : \n" + // "required: "); //} public void testErrorMismatchingPropertyOnInterface4() throws Exception { testTypes("/** @interface */ u.T = function () {};\n" + "/** @param {Number} foo */u.T.prototype.x =\n" + "function() {};", "parameter foo does not appear in u.T.prototype.x's parameter list"); } public void testErrorMismatchingPropertyOnInterface5() throws Exception { testTypes("/** @interface */ function T() {};\n" + "/** @type {number} */T.prototype.x = function() { };", "assignment to property x of T.prototype\n" + "found : function (): undefined\n" + "required: number"); } public void testErrorMismatchingPropertyOnInterface6() throws Exception { testClosureTypesMultipleWarnings( "/** @interface */ function T() {};\n" + "/** @return {number} */T.prototype.x = 1", Lists.newArrayList( "assignment to property x of T.prototype\n" + "found : number\n" + "required: function (this:T): number", "interface members can only be empty property declarations, " + "empty functions, or goog.abstractMethod")); } public void testInterfaceNonEmptyFunction() throws Exception { testTypes("/** @interface */ function T() {};\n" + "T.prototype.x = function() { return 'foo'; }", "interface member functions must have an empty body" ); } public void testDoubleNestedInterface() throws Exception { testTypes("/** @interface */ var I1 = function() {};\n" + "/** @interface */ I1.I2 = function() {};\n" + "/** @interface */ I1.I2.I3 = function() {};\n"); } public void testStaticDataPropertyOnNestedInterface() throws Exception { testTypes("/** @interface */ var I1 = function() {};\n" + "/** @interface */ I1.I2 = function() {};\n" + "/** @type {number} */ I1.I2.x = 1;\n"); } public void testInterfaceInstantiation() throws Exception { testTypes("/** @interface */var f = function(){}; new f", "cannot instantiate non-constructor"); } public void testPrototypeLoop() throws Exception { testClosureTypesMultipleWarnings( suppressMissingProperty("foo") + "/** @constructor \n * @extends {T} */var T = function() {};" + "alert((new T).foo);", Lists.newArrayList( "Parse error. Cycle detected in inheritance chain of type T", "Could not resolve type in @extends tag of T")); } public void testDirectPrototypeAssign() throws Exception { // For now, we just ignore @type annotations on the prototype. testTypes( "/** @constructor */ function Foo() {}" + "/** @constructor */ function Bar() {}" + "/** @type {Array} */ Bar.prototype = new Foo()"); } // In all testResolutionViaRegistry* tests, since u is unknown, u.T can only // be resolved via the registry and not via properties. public void testResolutionViaRegistry1() throws Exception { testTypes("/** @constructor */ u.T = function() {};\n" + "/** @type {(number|string)} */ u.T.prototype.a;\n" + "/**\n" + "* @param {u.T} t\n" + "* @return {string}\n" + "*/\n" + "var f = function(t) { return t.a; };", "inconsistent return type\n" + "found : (number|string)\n" + "required: string"); } public void testResolutionViaRegistry2() throws Exception { testTypes( "/** @constructor */ u.T = function() {" + " this.a = 0; };\n" + "/**\n" + "* @param {u.T} t\n" + "* @return {string}\n" + "*/\n" + "var f = function(t) { return t.a; };", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testResolutionViaRegistry3() throws Exception { testTypes("/** @constructor */ u.T = function() {};\n" + "/** @type {(number|string)} */ u.T.prototype.a = 0;\n" + "/**\n" + "* @param {u.T} t\n" + "* @return {string}\n" + "*/\n" + "var f = function(t) { return t.a; };", "inconsistent return type\n" + "found : (number|string)\n" + "required: string"); } public void testResolutionViaRegistry4() throws Exception { testTypes("/** @constructor */ u.A = function() {};\n" + "/**\n* @constructor\n* @extends {u.A}\n*/\nu.A.A = function() {}\n;" + "/**\n* @constructor\n* @extends {u.A}\n*/\nu.A.B = function() {};\n" + "var ab = new u.A.B();\n" + "/** @type {!u.A} */ var a = ab;\n" + "/** @type {!u.A.A} */ var aa = ab;\n", "initializing variable\n" + "found : u.A.B\n" + "required: u.A.A"); } public void testResolutionViaRegistry5() throws Exception { Node n = parseAndTypeCheck("/** @constructor */ u.T = function() {}; u.T"); JSType type = n.getLastChild().getLastChild().getJSType(); assertFalse(type.isUnknownType()); assertTrue(type instanceof FunctionType); assertEquals("u.T", ((FunctionType) type).getInstanceType().getReferenceName()); } public void testGatherProperyWithoutAnnotation1() throws Exception { Node n = parseAndTypeCheck("/** @constructor */ var T = function() {};" + "/** @type {!T} */var t; t.x; t;"); JSType type = n.getLastChild().getLastChild().getJSType(); assertFalse(type.isUnknownType()); assertTrue(type instanceof ObjectType); ObjectType objectType = (ObjectType) type; assertFalse(objectType.hasProperty("x")); Asserts.assertTypeCollectionEquals( Lists.newArrayList(objectType), registry.getTypesWithProperty("x")); } public void testGatherProperyWithoutAnnotation2() throws Exception { TypeCheckResult ns = parseAndTypeCheckWithScope("/** @type {!Object} */var t; t.x; t;"); Node n = ns.root; Scope s = ns.scope; JSType type = n.getLastChild().getLastChild().getJSType(); assertFalse(type.isUnknownType()); assertTypeEquals(type, OBJECT_TYPE); assertTrue(type instanceof ObjectType); ObjectType objectType = (ObjectType) type; assertFalse(objectType.hasProperty("x")); Asserts.assertTypeCollectionEquals( Lists.newArrayList(OBJECT_TYPE), registry.getTypesWithProperty("x")); } public void testFunctionMasksVariableBug() throws Exception { testTypes("var x = 4; var f = function x(b) { return b ? 1 : x(true); };", "function x masks variable (IE bug)"); } public void testDfa1() throws Exception { testTypes("var x = null;\n x = 1;\n /** @type number */ var y = x;"); } public void testDfa2() throws Exception { testTypes("function u() {}\n" + "/** @return {number} */ function f() {\nvar x = 'todo';\n" + "if (u()) { x = 1; } else { x = 2; } return x;\n}"); } public void testDfa3() throws Exception { testTypes("function u() {}\n" + "/** @return {number} */ function f() {\n" + "/** @type {number|string} */ var x = 'todo';\n" + "if (u()) { x = 1; } else { x = 2; } return x;\n}"); } public void testDfa4() throws Exception { testTypes("/** @param {Date?} d */ function f(d) {\n" + "if (!d) { return; }\n" + "/** @type {!Date} */ var e = d;\n}"); } public void testDfa5() throws Exception { testTypes("/** @return {string?} */ function u() {return 'a';}\n" + "/** @param {string?} x\n@return {string} */ function f(x) {\n" + "while (!x) { x = u(); }\nreturn x;\n}"); } public void testDfa6() throws Exception { testTypes("/** @return {Object?} */ function u() {return {};}\n" + "/** @param {Object?} x */ function f(x) {\n" + "while (x) { x = u(); if (!x) { x = u(); } }\n}"); } public void testDfa7() throws Exception { testTypes("/** @constructor */ var T = function() {};\n" + "/** @type {Date?} */ T.prototype.x = null;\n" + "/** @param {!T} t */ function f(t) {\n" + "if (!t.x) { return; }\n" + "/** @type {!Date} */ var e = t.x;\n}"); } public void testDfa8() throws Exception { testTypes("/** @constructor */ var T = function() {};\n" + "/** @type {number|string} */ T.prototype.x = '';\n" + "function u() {}\n" + "/** @param {!T} t\n@return {number} */ function f(t) {\n" + "if (u()) { t.x = 1; } else { t.x = 2; } return t.x;\n}"); } public void testDfa9() throws Exception { testTypes("function f() {\n/** @type {string?} */var x;\nx = null;\n" + "if (x == null) { return 0; } else { return 1; } }", "condition always evaluates to true\n" + "left : null\n" + "right: null"); } public void testDfa10() throws Exception { testTypes("/** @param {null} x */ function g(x) {}" + "/** @param {string?} x */function f(x) {\n" + "if (!x) { x = ''; }\n" + "if (g(x)) { return 0; } else { return 1; } }", "actual parameter 1 of g does not match formal parameter\n" + "found : string\n" + "required: null"); } public void testDfa11() throws Exception { testTypes("/** @param {string} opt_x\n@return {string} */\n" + "function f(opt_x) { if (!opt_x) { " + "throw new Error('x cannot be empty'); } return opt_x; }"); } public void testDfa12() throws Exception { testTypes("/** @param {string} x \n * @constructor \n */" + "var Bar = function(x) {};" + "/** @param {string} x */ function g(x) { return true; }" + "/** @param {string|number} opt_x */ " + "function f(opt_x) { " + " if (opt_x) { new Bar(g(opt_x) && 'x'); }" + "}", "actual parameter 1 of g does not match formal parameter\n" + "found : (number|string)\n" + "required: string"); } public void testDfa13() throws Exception { testTypes( "/**\n" + " * @param {string} x \n" + " * @param {number} y \n" + " * @param {number} z \n" + " */" + "function g(x, y, z) {}" + "function f() { " + " var x = 'a'; g(x, x = 3, x);" + "}"); } public void testTypeInferenceWithCast1() throws Exception { testTypes( "/**@return {(number,null,undefined)}*/function u(x) {return null;}" + "/**@param {number?} x\n@return {number?}*/function f(x) {return x;}" + "/**@return {number?}*/function g(x) {" + "var y = /**@type {number?}*/(u(x)); return f(y);}"); } public void testTypeInferenceWithCast2() throws Exception { testTypes( "/**@return {(number,null,undefined)}*/function u(x) {return null;}" + "/**@param {number?} x\n@return {number?}*/function f(x) {return x;}" + "/**@return {number?}*/function g(x) {" + "var y; y = /**@type {number?}*/(u(x)); return f(y);}"); } public void testTypeInferenceWithCast3() throws Exception { testTypes( "/**@return {(number,null,undefined)}*/function u(x) {return 1;}" + "/**@return {number}*/function g(x) {" + "return /**@type {number}*/(u(x));}"); } public void testTypeInferenceWithCast4() throws Exception { testTypes( "/**@return {(number,null,undefined)}*/function u(x) {return 1;}" + "/**@return {number}*/function g(x) {" + "return /**@type {number}*/(u(x)) && 1;}"); } public void testTypeInferenceWithCast5() throws Exception { testTypes( "/** @param {number} x */ function foo(x) {}" + "/** @param {{length:*}} y */ function bar(y) {" + " /** @type {string} */ y.length;" + " foo(y.length);" + "}", "actual parameter 1 of foo does not match formal parameter\n" + "found : string\n" + "required: number"); } public void testTypeInferenceWithClosure1() throws Exception { testTypes( "/** @return {boolean} */" + "function f() {" + " /** @type {?string} */ var x = null;" + " function g() { x = 'y'; } g(); " + " return x == null;" + "}"); } public void testTypeInferenceWithClosure2() throws Exception { testTypes( "/** @return {boolean} */" + "function f() {" + " /** @type {?string} */ var x = null;" + " function g() { x = 'y'; } g(); " + " return x === 3;" + "}", "condition always evaluates to false\n" + "left : (null|string|undefined)\n" + "right: number"); } public void testForwardPropertyReference() throws Exception { testTypes("/** @constructor */ var Foo = function() { this.init(); };" + "/** @return {string} */" + "Foo.prototype.getString = function() {" + " return this.number_;" + "};" + "Foo.prototype.init = function() {" + " /** @type {number} */" + " this.number_ = 3;" + "};", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testNoForwardTypeDeclaration() throws Exception { testTypes( "/** @param {MyType} x */ function f(x) {}", "Bad type annotation. Unknown type MyType"); } public void testNoForwardTypeDeclarationAndNoBraces() throws Exception { testTypes("/** @return The result. */ function f() {}"); } public void testForwardTypeDeclaration1() throws Exception { testClosureTypes( // malformed addDependency calls shouldn't cause a crash "goog.addDependency();" + "goog.addDependency('y', [goog]);" + "goog.addDependency('zzz.js', ['MyType'], []);" + "/** @param {MyType} x \n * @return {number} */" + "function f(x) { return 3; }", null); } public void testForwardTypeDeclaration2() throws Exception { String f = "goog.addDependency('zzz.js', ['MyType'], []);" + "/** @param {MyType} x */ function f(x) { }"; testClosureTypes(f, null); testClosureTypes(f + "f(3);", "actual parameter 1 of f does not match formal parameter\n" + "found : number\n" + "required: (MyType|null|undefined)"); } public void testForwardTypeDeclaration3() throws Exception { testClosureTypes( "goog.addDependency('zzz.js', ['MyType'], []);" + "/** @param {MyType} x */ function f(x) { return x; }" + "/** @constructor */ var MyType = function() {};" + "f(3);", "actual parameter 1 of f does not match formal parameter\n" + "found : number\n" + "required: (MyType|null|undefined)"); } public void testDuplicateTypeDef() throws Exception { testTypes( "var goog = {};" + "/** @constructor */ goog.Bar = function() {};" + "/** @typedef {number} */ goog.Bar;", "variable goog.Bar redefined with type None, " + "original definition at [testcode]:1 " + "with type function (new:goog.Bar): undefined"); } public void testTypeDef1() throws Exception { testTypes( "var goog = {};" + "/** @typedef {number} */ goog.Bar;" + "/** @param {goog.Bar} x */ function f(x) {}" + "f(3);"); } public void testTypeDef2() throws Exception { testTypes( "var goog = {};" + "/** @typedef {number} */ goog.Bar;" + "/** @param {goog.Bar} x */ function f(x) {}" + "f('3');", "actual parameter 1 of f does not match formal parameter\n" + "found : string\n" + "required: number"); } public void testTypeDef3() throws Exception { testTypes( "var goog = {};" + "/** @typedef {number} */ var Bar;" + "/** @param {Bar} x */ function f(x) {}" + "f('3');", "actual parameter 1 of f does not match formal parameter\n" + "found : string\n" + "required: number"); } public void testCircularTypeDef() throws Exception { testTypes( "var goog = {};" + "/** @typedef {number|Array.<goog.Bar>} */ goog.Bar;" + "/** @param {goog.Bar} x */ function f(x) {}" + "f(3); f([3]); f([[3]]);"); } public void testGetTypedPercent1() throws Exception { String js = "var id = function(x) { return x; }\n" + "var id2 = function(x) { return id(x); }"; assertEquals(50.0, getTypedPercent(js), 0.1); } public void testGetTypedPercent2() throws Exception { String js = "var x = {}; x.y = 1;"; assertEquals(100.0, getTypedPercent(js), 0.1); } public void testGetTypedPercent3() throws Exception { String js = "var f = function(x) { x.a = x.b; }"; assertEquals(50.0, getTypedPercent(js), 0.1); } public void testGetTypedPercent4() throws Exception { String js = "var n = {};\n /** @constructor */ n.T = function() {};\n" + "/** @type n.T */ var x = new n.T();"; assertEquals(100.0, getTypedPercent(js), 0.1); } private double getTypedPercent(String js) throws Exception { Node n = compiler.parseTestCode(js); Node externs = new Node(Token.BLOCK); Node externAndJsRoot = new Node(Token.BLOCK, externs, n); externAndJsRoot.setIsSyntheticBlock(true); TypeCheck t = makeTypeCheck(); t.processForTesting(null, n); return t.getTypedPercent(); } private ObjectType getInstanceType(Node js1Node) { JSType type = js1Node.getFirstChild().getJSType(); assertNotNull(type); assertTrue(type instanceof FunctionType); FunctionType functionType = (FunctionType) type; assertTrue(functionType.isConstructor()); return functionType.getInstanceType(); } public void testPrototypePropertyReference() throws Exception { TypeCheckResult p = parseAndTypeCheckWithScope("" + "/** @constructor */\n" + "function Foo() {}\n" + "/** @param {number} a */\n" + "Foo.prototype.bar = function(a){};\n" + "/** @param {Foo} f */\n" + "function baz(f) {\n" + " Foo.prototype.bar.call(f, 3);\n" + "}"); assertEquals(0, compiler.getErrorCount()); assertEquals(0, compiler.getWarningCount()); assertTrue(p.scope.getVar("Foo").getType() instanceof FunctionType); FunctionType fooType = (FunctionType) p.scope.getVar("Foo").getType(); assertEquals("function (this:Foo, number): undefined", fooType.getPrototype().getPropertyType("bar").toString()); } public void testResolvingNamedTypes() throws Exception { String js = "" + "/** @constructor */\n" + "var Foo = function() {}\n" + "/** @param {number} a */\n" + "Foo.prototype.foo = function(a) {\n" + " return this.baz().toString();\n" + "};\n" + "/** @return {Baz} */\n" + "Foo.prototype.baz = function() { return new Baz(); };\n" + "/** @constructor\n" + " * @extends Foo */\n" + "var Bar = function() {};" + "/** @constructor */\n" + "var Baz = function() {};"; assertEquals(100.0, getTypedPercent(js), 0.1); } public void testMissingProperty1() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "Foo.prototype.bar = function() { return this.a; };" + "Foo.prototype.baz = function() { this.a = 3; };"); } public void testMissingProperty2() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "Foo.prototype.bar = function() { return this.a; };" + "Foo.prototype.baz = function() { this.b = 3; };", "Property a never defined on Foo"); } public void testMissingProperty3() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "Foo.prototype.bar = function() { return this.a; };" + "(new Foo).a = 3;"); } public void testMissingProperty4() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "Foo.prototype.bar = function() { return this.a; };" + "(new Foo).b = 3;", "Property a never defined on Foo"); } public void testMissingProperty5() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "Foo.prototype.bar = function() { return this.a; };" + "/** @constructor */ function Bar() { this.a = 3; };", "Property a never defined on Foo"); } public void testMissingProperty6() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "Foo.prototype.bar = function() { return this.a; };" + "/** @constructor \n * @extends {Foo} */ " + "function Bar() { this.a = 3; };"); } public void testMissingProperty7() throws Exception { testTypes( "/** @param {Object} obj */" + "function foo(obj) { return obj.impossible; }", "Property impossible never defined on Object"); } public void testMissingProperty8() throws Exception { testTypes( "/** @param {Object} obj */" + "function foo(obj) { return typeof obj.impossible; }"); } public void testMissingProperty9() throws Exception { testTypes( "/** @param {Object} obj */" + "function foo(obj) { if (obj.impossible) { return true; } }"); } public void testMissingProperty10() throws Exception { testTypes( "/** @param {Object} obj */" + "function foo(obj) { while (obj.impossible) { return true; } }"); } public void testMissingProperty11() throws Exception { testTypes( "/** @param {Object} obj */" + "function foo(obj) { for (;obj.impossible;) { return true; } }"); } public void testMissingProperty12() throws Exception { testTypes( "/** @param {Object} obj */" + "function foo(obj) { do { } while (obj.impossible); }"); } public void testMissingProperty13() throws Exception { testTypes( "var goog = {}; goog.isDef = function(x) { return false; };" + "/** @param {Object} obj */" + "function foo(obj) { return goog.isDef(obj.impossible); }"); } public void testMissingProperty14() throws Exception { testTypes( "var goog = {}; goog.isDef = function(x) { return false; };" + "/** @param {Object} obj */" + "function foo(obj) { return goog.isNull(obj.impossible); }", "Property isNull never defined on goog"); } public void testMissingProperty15() throws Exception { testTypes( "/** @param {Object} x */" + "function f(x) { if (x.foo) { x.foo(); } }"); } public void testMissingProperty16() throws Exception { testTypes( "/** @param {Object} x */" + "function f(x) { x.foo(); if (x.foo) {} }", "Property foo never defined on Object"); } public void testMissingProperty17() throws Exception { testTypes( "/** @param {Object} x */" + "function f(x) { if (typeof x.foo == 'function') { x.foo(); } }"); } public void testMissingProperty18() throws Exception { testTypes( "/** @param {Object} x */" + "function f(x) { if (x.foo instanceof Function) { x.foo(); } }"); } public void testMissingProperty19() throws Exception { testTypes( "/** @param {Object} x */" + "function f(x) { if (x.bar) { if (x.foo) {} } else { x.foo(); } }", "Property foo never defined on Object"); } public void testMissingProperty21() throws Exception { testTypes( "/** @param {Object} x */" + "function f(x) { x.foo && x.foo(); }"); } public void testMissingProperty22() throws Exception { testTypes( "/** @param {Object} x \n * @return {boolean} */" + "function f(x) { return x.foo ? x.foo() : true; }"); } public void testMissingProperty23() throws Exception { testTypes( "function f(x) { x.impossible(); }", "Property impossible never defined on x"); } public void testMissingProperty24() throws Exception { testClosureTypes( "goog.addDependency('zzz.js', ['MissingType'], []);" + "/** @param {MissingType} x */" + "function f(x) { x.impossible(); }", null); } public void testMissingProperty25() throws Exception { testTypes( "/** @constructor */ var Foo = function() {};" + "Foo.prototype.bar = function() {};" + "/** @constructor */ var FooAlias = Foo;" + "(new FooAlias()).bar();"); } public void testMissingProperty26() throws Exception { testTypes( "/** @constructor */ var Foo = function() {};" + "/** @constructor */ var FooAlias = Foo;" + "FooAlias.prototype.bar = function() {};" + "(new Foo()).bar();"); } public void testMissingProperty27() throws Exception { testClosureTypes( "goog.addDependency('zzz.js', ['MissingType'], []);" + "/** @param {?MissingType} x */" + "function f(x) {" + " for (var parent = x; parent; parent = parent.getParent()) {}" + "}", null); } public void testMissingProperty28() throws Exception { testTypes( "function f(obj) {" + " /** @type {*} */ obj.foo;" + " return obj.foo;" + "}"); testTypes( "function f(obj) {" + " /** @type {*} */ obj.foo;" + " return obj.foox;" + "}", "Property foox never defined on obj"); } public void testMissingProperty29() throws Exception { // This used to emit a warning. testTypes( // externs "/** @constructor */ var Foo;" + "Foo.prototype.opera;" + "Foo.prototype.opera.postError;", "", null, false); } public void testDeclaredNativeTypeEquality() throws Exception { Node n = parseAndTypeCheck("/** @constructor */ function Object() {};"); assertEquals(registry.getNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE), n.getFirstChild().getJSType()); } public void testUndefinedVar() throws Exception { Node n = parseAndTypeCheck("var undefined;"); assertEquals(registry.getNativeType(JSTypeNative.VOID_TYPE), n.getFirstChild().getFirstChild().getJSType()); } public void testFlowScopeBug1() throws Exception { Node n = parseAndTypeCheck("/** @param {number} a \n" + "* @param {number} b */\n" + "function f(a, b) {\n" + "/** @type number */" + "var i = 0;" + "for (; (i + a) < b; ++i) {}}"); // check the type of the add node for i + f assertEquals(registry.getNativeType(JSTypeNative.NUMBER_TYPE), n.getFirstChild().getLastChild().getLastChild().getFirstChild() .getNext().getFirstChild().getJSType()); } public void testFlowScopeBug2() throws Exception { Node n = parseAndTypeCheck("/** @constructor */ function Foo() {};\n" + "Foo.prototype.hi = false;" + "function foo(a, b) {\n" + " /** @type Array */" + " var arr;" + " /** @type number */" + " var iter;" + " for (iter = 0; iter < arr.length; ++ iter) {" + " /** @type Foo */" + " var afoo = arr[iter];" + " afoo;" + " }" + "}"); // check the type of afoo when referenced assertTypeEquals(registry.createOptionalType( registry.createNullableType(registry.getType("Foo"))), n.getLastChild().getLastChild().getLastChild().getLastChild() .getLastChild().getLastChild().getJSType()); } public void testAddSingletonGetter() { Node n = parseAndTypeCheck( "/** @constructor */ function Foo() {};\n" + "goog.addSingletonGetter(Foo);"); ObjectType o = (ObjectType) n.getFirstChild().getJSType(); assertEquals("function (): Foo", o.getPropertyType("getInstance").toString()); assertEquals("Foo", o.getPropertyType("instance_").toString()); } public void testTypeCheckStandaloneAST() throws Exception { Node n = compiler.parseTestCode("function Foo() { }"); typeCheck(n); MemoizedScopeCreator scopeCreator = new MemoizedScopeCreator(new TypedScopeCreator(compiler)); Scope topScope = scopeCreator.createScope(n, null); Node second = compiler.parseTestCode("new Foo"); Node externs = new Node(Token.BLOCK); Node externAndJsRoot = new Node(Token.BLOCK, externs, second); externAndJsRoot.setIsSyntheticBlock(true); new TypeCheck( compiler, new SemanticReverseAbstractInterpreter( compiler.getCodingConvention(), registry), registry, topScope, scopeCreator, CheckLevel.WARNING, CheckLevel.OFF) .process(null, second); assertEquals(1, compiler.getWarningCount()); assertEquals("cannot instantiate non-constructor", compiler.getWarnings()[0].description); } private void checkObjectType(ObjectType objectType, String propertyName, JSType expectedType) { assertTrue("Expected " + objectType.getReferenceName() + " to have property " + propertyName, objectType.hasProperty(propertyName)); assertTypeEquals("Expected " + objectType.getReferenceName() + "'s property " + propertyName + " to have type " + expectedType, expectedType, objectType.getPropertyType(propertyName)); } private void testTypes(String js) throws Exception { testTypes(js, (String) null); } private void testTypes(String js, String description) throws Exception { testTypes(js, description, false); } private void testTypes(String js, DiagnosticType type) throws Exception { testTypes(js, type.format(), false); } private void testClosureTypes(String js, String description) throws Exception { testClosureTypesMultipleWarnings(js, description == null ? null : Lists.newArrayList(description)); } private void testClosureTypesMultipleWarnings( String js, List<String> descriptions) throws Exception { Node n = compiler.parseTestCode(js); Node externs = new Node(Token.BLOCK); Node externAndJsRoot = new Node(Token.BLOCK, externs, n); externAndJsRoot.setIsSyntheticBlock(true); assertEquals("parsing error: " + Joiner.on(", ").join(compiler.getErrors()), 0, compiler.getErrorCount()); // For processing goog.addDependency for forward typedefs. new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR) .process(null, n); CodingConvention convention = compiler.getCodingConvention(); new TypeCheck(compiler, new ClosureReverseAbstractInterpreter( convention, registry).append( new SemanticReverseAbstractInterpreter( convention, registry)) .getFirst(), registry) .processForTesting(null, n); assertEquals(0, compiler.getErrorCount()); if (descriptions == null) { assertEquals( "unexpected warning(s) : " + Joiner.on(", ").join(compiler.getWarnings()), 0, compiler.getWarningCount()); } else { assertEquals(descriptions.size(), compiler.getWarningCount()); Set<String> actualWarningDescriptions = Sets.newHashSet(); for (int i = 0; i < descriptions.size(); i++) { actualWarningDescriptions.add(compiler.getWarnings()[i].description); } assertEquals( Sets.newHashSet(descriptions), actualWarningDescriptions); } } void testTypes(String js, String description, boolean isError) throws Exception { testTypes(DEFAULT_EXTERNS, js, description, isError); } void testTypes(String externs, String js, String description, boolean isError) throws Exception { Node n = parseAndTypeCheck(externs, js); JSError[] errors = compiler.getErrors(); if (description != null && isError) { assertTrue("expected an error", errors.length > 0); assertEquals(description, errors[0].description); errors = Arrays.asList(errors).subList(1, errors.length).toArray( new JSError[errors.length - 1]); } if (errors.length > 0) { fail("unexpected error(s):\n" + Joiner.on("\n").join(errors)); } JSError[] warnings = compiler.getWarnings(); if (description != null && !isError) { assertTrue("expected a warning", warnings.length > 0); assertEquals(description, warnings[0].description); warnings = Arrays.asList(warnings).subList(1, warnings.length).toArray( new JSError[warnings.length - 1]); } if (warnings.length > 0) { fail("unexpected warnings(s):\n" + Joiner.on("\n").join(warnings)); } } /** * Parses and type checks the JavaScript code. */ private Node parseAndTypeCheck(String js) { return parseAndTypeCheck(DEFAULT_EXTERNS, js); } private Node parseAndTypeCheck(String externs, String js) { return parseAndTypeCheckWithScope(externs, js).root; } /** * Parses and type checks the JavaScript code and returns the Scope used * whilst type checking. */ private TypeCheckResult parseAndTypeCheckWithScope(String js) { return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js); } private TypeCheckResult parseAndTypeCheckWithScope( String externs, String js) { compiler.init( Lists.newArrayList(SourceFile.fromCode("[externs]", externs)), Lists.newArrayList(SourceFile.fromCode("[testcode]", js)), compiler.getOptions()); Node n = compiler.getInput(new InputId("[testcode]")).getAstRoot(compiler); Node externsNode = compiler.getInput(new InputId("[externs]")) .getAstRoot(compiler); Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n); externAndJsRoot.setIsSyntheticBlock(true); assertEquals("parsing error: " + Joiner.on(", ").join(compiler.getErrors()), 0, compiler.getErrorCount()); Scope s = makeTypeCheck().processForTesting(externsNode, n); return new TypeCheckResult(n, s); } private Node typeCheck(Node n) { Node externsNode = new Node(Token.BLOCK); Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n); externAndJsRoot.setIsSyntheticBlock(true); makeTypeCheck().processForTesting(null, n); return n; } private TypeCheck makeTypeCheck() { return new TypeCheck( compiler, new SemanticReverseAbstractInterpreter( compiler.getCodingConvention(), registry), registry); } void testTypes(String js, String[] warnings) throws Exception { Node n = compiler.parseTestCode(js); assertEquals(0, compiler.getErrorCount()); Node externsNode = new Node(Token.BLOCK); Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n); makeTypeCheck().processForTesting(null, n); assertEquals(0, compiler.getErrorCount()); if (warnings != null) { assertEquals(warnings.length, compiler.getWarningCount()); JSError[] messages = compiler.getWarnings(); for (int i = 0; i < warnings.length && i < compiler.getWarningCount(); i++) { assertEquals(warnings[i], messages[i].description); } } else { assertEquals(0, compiler.getWarningCount()); } } String suppressMissingProperty(String ... props) { String result = "function dummy(x) { "; for (String prop : props) { result += "x." + prop + " = 3;"; } return result + "}"; } private static class TypeCheckResult { private final Node root; private final Scope scope; private TypeCheckResult(Node root, Scope scope) { this.root = root; this.scope = scope; } } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.Lists; import com.google.javascript.jscomp.MakeDeclaredNamesUnique.InlineRenamer; import com.google.javascript.rhino.Node; /** * @author johnlenz@google.com (John Lenz) */ public class MakeDeclaredNamesUniqueTest extends CompilerTestCase { private boolean useDefaultRenamer = false; private boolean invert = false; private boolean removeConst = false; private final String localNamePrefix = "unique_"; @Override public CompilerPass getProcessor(final Compiler compiler) { if (!invert) { return new CompilerPass() { @Override public void process(Node externs, Node root) { compiler.resetUniqueNameId(); MakeDeclaredNamesUnique renamer = null; if (useDefaultRenamer) { renamer = new MakeDeclaredNamesUnique(); } else { renamer = new MakeDeclaredNamesUnique( new InlineRenamer( compiler.getUniqueNameIdSupplier(), localNamePrefix, removeConst)); } NodeTraversal.traverseRoots( compiler, Lists.newArrayList(externs, root), renamer); } }; } else { return MakeDeclaredNamesUnique.getContextualRenameInverter(compiler); } } @Override protected int getNumRepetitions() { // The normalize pass is only run once. return 1; } @Override public void setUp() { removeConst = false; invert = false; useDefaultRenamer = false; } private void testWithInversion(String original, String expected) { invert = false; test(original, expected); invert = true; test(expected, original); invert = false; } private void testSameWithInversion(String externs, String original) { invert = false; testSame(externs, original, null); invert = true; testSame(externs, original, null); invert = false; } private void testSameWithInversion(String original) { testSameWithInversion("", original); } private String wrapInFunction(String s) { return "function f(){" + s + "}"; } private void testInFunction(String original, String expected) { test(wrapInFunction(original), wrapInFunction(expected)); } public void testMakeLocalNamesUniqueWithContext1() { // Set the test type this.useDefaultRenamer = true; invert = true; test( "var a;function foo(){var a$$inline_1; a = 1}", "var a;function foo(){var a$$0; a = 1}"); test( "var a;function foo(){var a$$inline_1;}", "var a;function foo(){var a;}"); } public void testMakeLocalNamesUniqueWithContext2() { // Set the test type this.useDefaultRenamer = true; // Verify global names are untouched. testSameWithInversion("var a;"); // Verify global names are untouched. testSameWithInversion("a;"); // Local names are made unique. testWithInversion( "var a;function foo(a){var b;a}", "var a;function foo(a$$1){var b;a$$1}"); testWithInversion( "var a;function foo(){var b;a}function boo(){var b;a}", "var a;function foo(){var b;a}function boo(){var b$$1;a}"); testWithInversion( "function foo(a){var b}" + "function boo(a){var b}", "function foo(a){var b}" + "function boo(a$$1){var b$$1}"); // Verify functions expressions are renamed. testWithInversion( "var a = function foo(){foo()};var b = function foo(){foo()};", "var a = function foo(){foo()};var b = function foo$$1(){foo$$1()};"); // Verify catch exceptions names are made unique testWithInversion( "try { } catch(e) {e;}", "try { } catch(e) {e;}"); // Inversion does not handle exceptions correctly. test( "try { } catch(e) {e;}; try { } catch(e) {e;}", "try { } catch(e) {e;}; try { } catch(e$$1) {e$$1;}"); test( "try { } catch(e) {e; try { } catch(e) {e;}};", "try { } catch(e) {e; try { } catch(e$$1) {e$$1;} }; "); } public void testMakeLocalNamesUniqueWithContext3() { // Set the test type this.useDefaultRenamer = true; String externs = "var extern1 = {};"; // Verify global names are untouched. testSameWithInversion(externs, "var extern1 = extern1 || {};"); // Verify global names are untouched. testSame(externs, "var extern1 = extern1 || {};", null); } public void testMakeLocalNamesUniqueWithContext4() { // Set the test type this.useDefaultRenamer = true; // Inversion does not handle exceptions correctly. testInFunction( "var e; try { } catch(e) {e;}; try { } catch(e) {e;}", "var e; try { } catch(e$$1) {e$$1;}; try { } catch(e$$2) {e$$2;}"); testInFunction( "var e; try { } catch(e) {e; try { } catch(e) {e;}}", "var e; try { } catch(e$$1) {e$$1; try { } catch(e$$2) {e$$2;} }"); testInFunction( "try { } catch(e) {e;}; try { } catch(e) {e;} var e;", "try { } catch(e$$1) {e$$1;}; try { } catch(e$$2) {e$$2;} var e;"); testInFunction( "try { } catch(e) {e; try { } catch(e) {e;}} var e;", "try { } catch(e$$1) {e$$1; try { } catch(e$$2) {e$$2;} } var e;"); invert = true; testInFunction( "var e; try { } catch(e$$0) {e$$0;}; try { } catch(e$$1) {e$$1;}", "var e; try { } catch(e$$2) {e$$2;}; try { } catch(e$$0) {e$$0;}"); testInFunction( "var e; try { } catch(e$$1) {e$$1; try { } catch(e$$2) {e$$2;} };", "var e; try { } catch(e$$0) {e$$0; try { } catch(e$$1) {e$$1;} };"); testInFunction( "try { } catch(e) {e;}; try { } catch(e$$1) {e$$1;};var e$$2;", "try { } catch(e) {e;}; try { } catch(e$$0) {e$$0;};var e$$1;"); testInFunction( "try { } catch(e) {e; try { } catch(e$$1) {e$$1;} };var e$$2", "try { } catch(e) {e; try { } catch(e$$0) {e$$0;} };var e$$1"); } public void testMakeLocalNamesUniqueWithContext5() { // Set the test type this.useDefaultRenamer = true; testWithInversion( "function f(){var f; f = 1}", "function f(){var f$$1; f$$1 = 1}"); testWithInversion( "function f(f){f = 1}", "function f(f$$1){f$$1 = 1}"); testWithInversion( "function f(f){var f; f = 1}", "function f(f$$1){var f$$1; f$$1 = 1}"); test( "var fn = function f(){var f; f = 1}", "var fn = function f(){var f$$1; f$$1 = 1}"); test( "var fn = function f(f){f = 1}", "var fn = function f(f$$1){f$$1 = 1}"); test( "var fn = function f(f){var f; f = 1}", "var fn = function f(f$$1){var f$$1; f$$1 = 1}"); } public void testArguments() { // Set the test type this.useDefaultRenamer = true; // Don't distinguish between "arguments", it can't be made unique. testSameWithInversion( "function foo(){var arguments;function bar(){var arguments;}}"); invert = true; // Don't introduce new references to arguments, it is special. test( "function foo(){var arguments$$1;}", "function foo(){var arguments$$0;}"); } public void testMakeLocalNamesUniqueWithoutContext() { // Set the test type this.useDefaultRenamer = false; test("var a;", "var a$$unique_0"); // Verify undeclared names are untouched. testSame("a;"); // Local names are made unique. test("var a;" + "function foo(a){var b;a}", "var a$$unique_0;" + "function foo$$unique_1(a$$unique_2){var b$$unique_3;a$$unique_2}"); test("var a;" + "function foo(){var b;a}" + "function boo(){var b;a}", "var a$$unique_0;" + "function foo$$unique_1(){var b$$unique_3;a$$unique_0}" + "function boo$$unique_2(){var b$$unique_4;a$$unique_0}"); // Verify function expressions are renamed. test("var a = function foo(){foo()};", "var a$$unique_0 = function foo$$unique_1(){foo$$unique_1()};"); // Verify catch exceptions names are made unique test("try { } catch(e) {e;}", "try { } catch(e$$unique_0) {e$$unique_0;}"); test("try { } catch(e) {e;};" + "try { } catch(e) {e;}", "try { } catch(e$$unique_0) {e$$unique_0;};" + "try { } catch(e$$unique_1) {e$$unique_1;}"); test("try { } catch(e) {e; " + "try { } catch(e) {e;}};", "try { } catch(e$$unique_0) {e$$unique_0; " + "try { } catch(e$$unique_1) {e$$unique_1;} }; "); } public void testOnlyInversion() { invert = true; test("function f(a, a$$1) {}", "function f(a, a$$0) {}"); test("function f(a$$1, b$$2) {}", "function f(a, b) {}"); test("function f(a$$1, a$$2) {}", "function f(a, a$$0) {}"); testSame("try { } catch(e) {e;}; try { } catch(e$$1) {e$$1;}"); testSame("try { } catch(e) {e; try { } catch(e$$1) {e$$1;} }; "); testSame("var a$$1;"); testSame("function f() { var $$; }"); test("var CONST = 3; var b = CONST;", "var CONST = 3; var b = CONST;"); test("function f() {var CONST = 3; var ACONST$$1 = 2;}", "function f() {var CONST = 3; var ACONST = 2;}"); } public void testOnlyInversion2() { invert = true; test("function f() {try { } catch(e) {e;}; try { } catch(e$$0) {e$$0;}}", "function f() {try { } catch(e) {e;}; try { } catch(e$$1) {e$$1;}}"); } public void testOnlyInversion3() { invert = true; test( "function x1() {" + " var a$$1;" + " function x2() {" + " var a$$2;" + " }" + " function x3() {" + " var a$$3;" + " }" + "}", "function x1() {" + " var a$$0;" + " function x2() {" + " var a;" + " }" + " function x3() {" + " var a;" + " }" + "}"); } public void testOnlyInversion4() { invert = true; test( "function x1() {" + " var a$$0;" + " function x2() {" + " var a;a$$0++" + " }" + "}", "function x1() {" + " var a$$1;" + " function x2() {" + " var a;a$$1++" + " }" + "}"); } public void testConstRemovingRename1() { removeConst = true; test("(function () {var CONST = 3; var ACONST$$1 = 2;})", "(function () {var CONST$$unique_0 = 3; var ACONST$$unique_1 = 2;})"); } public void testConstRemovingRename2() { removeConst = true; test("var CONST = 3; var b = CONST;", "var CONST$$unique_0 = 3; var b$$unique_1 = CONST$$unique_0;"); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import static com.google.javascript.jscomp.MarkNoSideEffectCalls.INVALID_NO_SIDE_EFFECT_ANNOTATION; import com.google.javascript.rhino.Node; import java.util.Collections; import java.util.List; /** * Tests for {@link MarkNoSideEffectCalls} * */ public class MarkNoSideEffectCallsTest extends CompilerTestCase { List<String> noSideEffectCalls = Lists.newArrayList(); private static String kExterns = "function externSef1(){}" + "/**@nosideeffects*/function externNsef1(){}" + "var externSef2 = function(){};" + "/**@nosideeffects*/var externNsef2 = function(){};" + "var externNsef3 = /**@nosideeffects*/function(){};" + "var externObj;" + "externObj.sef1 = function(){};" + "/**@nosideeffects*/externObj.nsef1 = function(){};" + "externObj.nsef2 = /**@nosideeffects*/function(){};" + "externObj.sef2;" + "/**@nosideeffects*/externObj.nsef3;"; public MarkNoSideEffectCallsTest() { super(kExterns); } @Override protected int getNumRepetitions() { // run pass once. return 1; } @Override protected void tearDown() throws Exception { super.tearDown(); noSideEffectCalls.clear(); } public void testFunctionAnnotation() throws Exception { testMarkCalls("/**@nosideeffects*/function f(){}", "f()", ImmutableList.of("f")); testMarkCalls("/**@nosideeffects*/var f = function(){};", "f()", ImmutableList.of("f")); testMarkCalls("var f = /**@nosideeffects*/function(){};", "f()", ImmutableList.of("f")); testMarkCalls("var f; f = /**@nosideeffects*/function(){};", "f()", ImmutableList.of("f")); testMarkCalls("var f; /**@nosideeffects*/ f = function(){};", "f()", ImmutableList.of("f")); // no annotation testMarkCalls("function f(){}", Collections.<String>emptyList()); testMarkCalls("function f(){} f()", Collections.<String>emptyList()); // 2 annotations testMarkCalls("/**@nosideeffects*/var f = " + "/**@nosideeffects*/function(){};", "f()", ImmutableList.of("f")); } public void testNamespaceAnnotation() throws Exception { testMarkCalls("var o = {}; o.f = /**@nosideeffects*/function(){};", "o.f()", ImmutableList.of("o.f")); testMarkCalls("var o = {}; o.f = /**@nosideeffects*/function(){};", "o.f()", ImmutableList.of("o.f")); testMarkCalls("var o = {}; o.f = function(){}; o.f()", Collections.<String>emptyList()); } public void testConstructorAnnotation() throws Exception { testMarkCalls("/**@nosideeffects*/function c(){};", "new c", ImmutableList.of("c")); testMarkCalls("var c = /**@nosideeffects*/function(){};", "new c", ImmutableList.of("c")); testMarkCalls("/**@nosideeffects*/var c = function(){};", "new c", ImmutableList.of("c")); testMarkCalls("function c(){}; new c", Collections.<String>emptyList()); } public void testMultipleDefinition() throws Exception { testMarkCalls("/**@nosideeffects*/function f(){}" + "/**@nosideeffects*/f = function(){};", "f()", ImmutableList.of("f")); testMarkCalls("function f(){}" + "/**@nosideeffects*/f = function(){};", "f()", Collections.<String>emptyList()); testMarkCalls("/**@nosideeffects*/function f(){}", "f = function(){};" + "f()", Collections.<String>emptyList()); } public void testAssignNoFunction() throws Exception { testMarkCalls("/**@nosideeffects*/function f(){}", "f = 1; f()", ImmutableList.of("f")); testMarkCalls("/**@nosideeffects*/function f(){}", "f = 1 || 2; f()", Collections.<String>emptyList()); } public void testPrototype() throws Exception { testMarkCalls("function c(){};" + "/**@nosideeffects*/c.prototype.g = function(){};", "var o = new c; o.g()", ImmutableList.of("o.g")); testMarkCalls("function c(){};" + "/**@nosideeffects*/c.prototype.g = function(){};", "function f(){}" + "var o = new c; o.g(); f()", ImmutableList.of("o.g")); // replace o.f with a function that has side effects testMarkCalls("function c(){};" + "/**@nosideeffects*/c.prototype.g = function(){};", "var o = new c;" + "o.g = function(){};" + "o.g()", ImmutableList.<String>of()); // two classes with same property; neither has side effects testMarkCalls("function c1(){};" + "/**@nosideeffects*/c1.prototype.f = function(){};" + "function c2(){};" + "/**@nosideeffects*/c2.prototype.f = function(){};", "var o = new c1;" + "o.f()", ImmutableList.of("o.f")); // two classes with same property; one has side effects testMarkCalls("function c1(){};" + "/**@nosideeffects*/c1.prototype.f = function(){};", "function c2(){};" + "c2.prototype.f = function(){};" + "var o = new c1;" + "o.f()", Collections.<String>emptyList()); } public void testAnnotationInExterns() throws Exception { testMarkCalls("externSef1()", Collections.<String>emptyList()); testMarkCalls("externSef2()", Collections.<String>emptyList()); testMarkCalls("externNsef1()", ImmutableList.of("externNsef1")); testMarkCalls("externNsef2()", ImmutableList.of("externNsef2")); testMarkCalls("externNsef3()", ImmutableList.of("externNsef3")); } public void testNamespaceAnnotationInExterns() throws Exception { testMarkCalls("externObj.sef1()", Collections.<String>emptyList()); testMarkCalls("externObj.sef2()", Collections.<String>emptyList()); testMarkCalls("externObj.nsef1()", ImmutableList.of("externObj.nsef1")); testMarkCalls("externObj.nsef2()", ImmutableList.of("externObj.nsef2")); testMarkCalls("externObj.nsef3()", ImmutableList.of("externObj.nsef3")); } public void testOverrideDefinitionInSource() throws Exception { // both have side effects. testMarkCalls("var obj = {}; obj.sef1 = function(){}; obj.sef1()", Collections.<String>emptyList()); // extern has side effects. testMarkCalls("var obj = {};" + "/**@nosideeffects*/obj.sef1 = function(){};", "obj.sef1()", Collections.<String>emptyList()); // override in source also has side effects. testMarkCalls("var obj = {}; obj.nsef1 = function(){}; obj.nsef1()", Collections.<String>emptyList()); // override in source also has no side effects. testMarkCalls("var obj = {};" + "/**@nosideeffects*/obj.nsef1 = function(){};", "obj.nsef1()", ImmutableList.of("obj.nsef1")); } public void testApply1() throws Exception { testMarkCalls("/**@nosideeffects*/ var f = function() {}", "f.apply()", ImmutableList.of("f.apply")); } public void testApply2() throws Exception { testMarkCalls("var f = function() {}", "f.apply()", ImmutableList.<String>of()); } public void testCall1() throws Exception { testMarkCalls("/**@nosideeffects*/ var f = function() {}", "f.call()", ImmutableList.of("f.call")); } public void testCall2() throws Exception { testMarkCalls("var f = function() {}", "f.call()", ImmutableList.<String>of()); } public void testInvalidAnnotation1() throws Exception { test("/** @nosideeffects */ function foo() {}", null, INVALID_NO_SIDE_EFFECT_ANNOTATION); } public void testInvalidAnnotation2() throws Exception { test("var f = /** @nosideeffects */ function() {}", null, INVALID_NO_SIDE_EFFECT_ANNOTATION); } public void testInvalidAnnotation3() throws Exception { test("/** @nosideeffects */ var f = function() {}", null, INVALID_NO_SIDE_EFFECT_ANNOTATION); } public void testInvalidAnnotation4() throws Exception { test("var f = function() {};" + "/** @nosideeffects */ f.x = function() {}", null, INVALID_NO_SIDE_EFFECT_ANNOTATION); } public void testInvalidAnnotation5() throws Exception { test("var f = function() {};" + "f.x = /** @nosideeffects */ function() {}", null, INVALID_NO_SIDE_EFFECT_ANNOTATION); } void testMarkCalls(String source, List<String> expected) { testMarkCalls("", source, expected); } void testMarkCalls( String extraExterns, String source, List<String> expected) { testSame(kExterns + extraExterns, source, null); assertEquals(expected, noSideEffectCalls); noSideEffectCalls.clear(); } @Override protected CompilerPass getProcessor(Compiler compiler) { return new NoSideEffectCallEnumerator(compiler); } /** * Run MarkNoSideEffectCalls, then gather a list of calls that are * marked as having no side effects. */ private class NoSideEffectCallEnumerator extends AbstractPostOrderCallback implements CompilerPass { private final MarkNoSideEffectCalls passUnderTest; private final Compiler compiler; NoSideEffectCallEnumerator(Compiler compiler) { this.passUnderTest = new MarkNoSideEffectCalls(compiler); this.compiler = compiler; } @Override public void process(Node externs, Node root) { passUnderTest.process(externs, root); NodeTraversal.traverse(compiler, externs, this); NodeTraversal.traverse(compiler, root, this); } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isNew()) { if (!NodeUtil.constructorCallHasSideEffects(n)) { noSideEffectCalls.add(n.getFirstChild().getQualifiedName()); } } else if (n.isCall()) { if (!NodeUtil.functionCallHasSideEffects(n)) { noSideEffectCalls.add(n.getFirstChild().getQualifiedName()); } } } } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.Lists; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.rhino.Node; import junit.framework.TestCase; import java.util.Collection; import java.util.List; /** * Tests for {@link MaybeReachingVariableUse}. * */ public class MaybeReachingVariableUseTest extends TestCase { private MaybeReachingVariableUse useDef = null; private Node def = null; private List<Node> uses = null; /* * The test cases consist of a short code snippet that has an instruction * labeled with D and one or more with label starting with U. When assertMatch * is called, the test suite verifies that all the uses with label starting * with U is reachable to the definition label at D. */ public void testStraightLine() { assertMatch("D:var x=1; U: x"); assertMatch("var x; D:x=1; U: x"); assertNotMatch("D:var x=1; x = 2; U: x"); assertMatch("var x=1; D:x=2; U: x"); assertNotMatch("U:x; D:var x = 1"); assertMatch("D: var x = 1; var y = 2; y; U:x"); } public void testIf() { assertMatch("var x; if(a){ D:x=1 }else { x=2 }; U:x"); assertMatch("var x; if(a){ x=1 }else { D:x=2 }; U:x"); assertMatch("D:var x=1; if(a){ U1: x }else { U2: x };"); } public void testLoops() { assertMatch("var x=0; while(a){ D:x=1 }; U:x"); assertMatch("var x=0; for(;;) { D:x=1 }; U:x"); assertMatch("D:var x=1; while(a) { U:x }"); assertMatch("D:var x=1; for(;;) { U:x }"); } public void testConditional() { assertMatch("var x=0; var y; D:(x=1)&&y; U:x"); assertMatch("var x=0; var y; D:y&&(x=1); U:x"); assertMatch("var x=0; var y=0; D:(x=1)&&(y=0); U:x"); assertMatch("var x=0; var y=0; D:(y=0)&&(x=1); U:x"); assertNotMatch("D: var x=0; var y=0; (x=1)&&(y=0); U:x"); assertMatch("D: var x=0; var y=0; (y=1)&&((y=2)||(x=1)); U:x"); assertMatch("D: var x=0; var y=0; (y=0)&&(x=1); U:x"); } public void testUseAndDefInSameInstruction() { assertNotMatch("D:var x=0; U:x=1,x"); assertMatch("D:var x=0; U:x,x=1"); } public void testAssignmentInExpressions() { assertMatch("var x=0; D:foo(bar(x=1)); U:x"); assertMatch("var x=0; D:foo(bar + (x = 1)); U:x"); } public void testHook() { assertMatch("var x=0; D:foo() ? x=1 : bar(); U:x"); assertMatch("var x=0; D:foo() ? x=1 : x=2; U:x"); } public void testAssignmentOps() { assertNotMatch("D: var x = 0; U: x = 100"); assertMatch("D: var x = 0; U: x += 100"); assertMatch("D: var x = 0; U: x -= 100"); } public void testInc() { assertMatch("D: var x = 0; U:x++"); assertMatch("var x = 0; D:x++; U:x"); } public void testForIn() { // Uses within FOR-IN header are hard to test. They are covered // by the tests in the flow sensitive inliner. assertNotMatch("D: var x = [], foo; U: for (x in foo) { }"); assertNotMatch("D: var x = [], foo; for (x in foo) { U:x }"); assertMatch("var x = [], foo; D: for (x in foo) { U:x }"); } public void testTryCatch() { assertMatch( "D: var x = 1; " + "try { U: var y = foo() + x; } catch (e) {} " + "U: var z = x;"); } /** * The def of x at D: may be used by the read of x at U:. */ private void assertMatch(String src) { computeUseDef(src); Collection<Node> result = useDef.getUses("x", def); assertTrue(result.size() == uses.size()); assertTrue(result.containsAll(uses)); } /** * The def of x at D: is not used by the read of x at U:. */ private void assertNotMatch(String src) { computeUseDef(src); assertFalse(useDef.getUses("x", def).contains(uses)); } /** * Computes reaching use on given source. */ private void computeUseDef(String src) { Compiler compiler = new Compiler(); src = "function _FUNCTION(param1, param2){" + src + "}"; Node n = compiler.parseTestCode(src).getFirstChild(); assertEquals(0, compiler.getErrorCount()); Scope scope = new SyntacticScopeCreator(compiler).createScope(n, null); ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true); cfa.process(null, n); ControlFlowGraph<Node> cfg = cfa.getCfg(); useDef = new MaybeReachingVariableUse(cfg, scope, compiler); useDef.analyze(); def = null; uses = Lists.newArrayList(); new NodeTraversal(compiler,new LabelFinder()).traverse(n); assertNotNull("Code should have an instruction labeled D", def); assertFalse("Code should have an instruction labeled starting withing U", uses.isEmpty()); } /** * Finds the D: and U: label and store which node they point to. */ private class LabelFinder extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isLabel()) { if (n.getFirstChild().getString().equals("D")) { def = n.getLastChild(); } else if (n.getFirstChild().getString().startsWith("U")) { uses.add(n.getLastChild()); } } } } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import junit.framework.TestCase; /** * A dopey test for {@link MemoizedScopeCreator}. This is mostly here * just so it's easy to write more tests if this becomes more complicated. * * @author nicksantos@google.com (Nick Santos) */ public class MemoizedScopeCreatorTest extends TestCase { public void testMemoization() throws Exception { Node trueNode = new Node(Token.TRUE); Node falseNode = new Node(Token.FALSE); // Wow, is there really a circular dependency between JSCompiler and // SyntacticScopeCreator? Compiler compiler = new Compiler(); compiler.initOptions(new CompilerOptions()); ScopeCreator creator = new MemoizedScopeCreator( new SyntacticScopeCreator(compiler)); Scope scopeA = creator.createScope(trueNode, null); assertSame(scopeA, creator.createScope(trueNode, null)); assertNotSame(scopeA, creator.createScope(falseNode, null)); } public void testPreconditionCheck() throws Exception { Compiler compiler = new Compiler(); compiler.initOptions(new CompilerOptions()); Node trueNode = new Node(Token.TRUE); ScopeCreator creator = new MemoizedScopeCreator( new SyntacticScopeCreator(compiler)); Scope scopeA = creator.createScope(trueNode, null); boolean handled = false; try { creator.createScope(trueNode, scopeA); } catch (IllegalStateException e) { handled = true; } assertTrue(handled); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.rhino.Node; /** * @author johnlenz@google.com (John Lenz) */ public class MinimizeExitPointsTest extends CompilerTestCase { @Override public void setUp() { super.enableLineNumberCheck(true); } @Override protected CompilerPass getProcessor(final Compiler compiler) { return new CompilerPass() { @Override public void process(Node externs, Node js) { NodeTraversal.traverse(compiler, js, new MinimizeExitPoints(compiler)); } }; } @Override protected int getNumRepetitions() { return 1; } void foldSame(String js) { testSame(js); } void fold(String js, String expected) { test(js, expected); } void fold(String js, String expected, DiagnosticType warning) { test(js, expected, warning); } public void testBreakOptimization() throws Exception { fold("f:{if(true){a();break f;}else;b();}", "f:{if(true){a()}else{b()}}"); fold("f:{if(false){a();break f;}else;b();break f;}", "f:{if(false){a()}else{b()}}"); fold("f:{if(a()){b();break f;}else;c();}", "f:{if(a()){b();}else{c();}}"); fold("f:{if(a()){b()}else{c();break f;}}", "f:{if(a()){b()}else{c();}}"); fold("f:{if(a()){b();break f;}else;}", "f:{if(a()){b();}else;}"); fold("f:{if(a()){break f;}else;}", "f:{if(a()){}else;}"); fold("f:while(a())break f;", "f:while(a())break f"); foldSame("f:for(x in a())break f"); fold("f:{while(a())break;}", "f:{while(a())break;}"); foldSame("f:{for(x in a())break}"); fold("f:try{break f;}catch(e){break f;}", "f:try{}catch(e){}"); fold("f:try{if(a()){break f;}else{break f;} break f;}catch(e){}", "f:try{if(a()){}else{}}catch(e){}"); fold("f:g:break f", ""); fold("f:g:{if(a()){break f;}else{break f;} break f;}", "f:g:{if(a()){}else{}}"); } public void testFunctionReturnOptimization() throws Exception { fold("function f(){if(a()){b();if(c())return;}}", "function f(){if(a()){b();if(c());}}"); fold("function f(){if(x)return; x=3; return; }", "function f(){if(x); else x=3}"); fold("function f(){if(true){a();return;}else;b();}", "function f(){if(true){a();}else{b();}}"); fold("function f(){if(false){a();return;}else;b();return;}", "function f(){if(false){a();}else{b();}}"); fold("function f(){if(a()){b();return;}else;c();}", "function f(){if(a()){b();}else{c();}}"); fold("function f(){if(a()){b()}else{c();return;}}", "function f(){if(a()){b()}else{c();}}"); fold("function f(){if(a()){b();return;}else;}", "function f(){if(a()){b();}else;}"); fold("function f(){if(a()){return;}else{return;} return;}", "function f(){if(a()){}else{}}"); fold("function f(){if(a()){return;}else{return;} b();}", "function f(){if(a()){}else{return;b()}}"); fold("function f(){while(a())return;}", "function f(){while(a())return}"); foldSame("function f(){for(x in a())return}"); fold("function f(){while(a())break;}", "function f(){while(a())break}"); foldSame("function f(){for(x in a())break}"); fold("function f(){try{return;}catch(e){return;}finally{return}}", "function f(){try{}catch(e){}finally{}}"); fold("function f(){try{return;}catch(e){return;}}", "function f(){try{}catch(e){}}"); fold("function f(){try{return;}finally{return;}}", "function f(){try{}finally{}}"); fold("function f(){try{if(a()){return;}else{return;} return;}catch(e){}}", "function f(){try{if(a()){}else{}}catch(e){}}"); fold("function f(){g:return}", "function f(){}"); fold("function f(){g:if(a()){return;}else{return;} return;}", "function f(){g:if(a()){}else{}}"); fold("function f(){try{g:if(a()){} return;}finally{return}}", "function f(){try{g:if(a()){}}finally{}}"); } public void testWhileContinueOptimization() throws Exception { fold("while(true){if(x)continue; x=3; continue; }", "while(true)if(x);else x=3"); foldSame("while(true){a();continue;b();}"); fold("while(true){if(true){a();continue;}else;b();}", "while(true){if(true){a();}else{b()}}"); fold("while(true){if(false){a();continue;}else;b();continue;}", "while(true){if(false){a()}else{b();}}"); fold("while(true){if(a()){b();continue;}else;c();}", "while(true){if(a()){b();}else{c();}}"); fold("while(true){if(a()){b();}else{c();continue;}}", "while(true){if(a()){b();}else{c();}}"); fold("while(true){if(a()){b();continue;}else;}", "while(true){if(a()){b();}else;}"); fold("while(true){if(a()){continue;}else{continue;} continue;}", "while(true){if(a()){}else{}}"); fold("while(true){if(a()){continue;}else{continue;} b();}", "while(true){if(a()){}else{continue;b();}}"); fold("while(true)while(a())continue;", "while(true)while(a());"); fold("while(true)for(x in a())continue", "while(true)for(x in a());"); fold("while(true)while(a())break;", "while(true)while(a())break"); fold("while(true)for(x in a())break", "while(true)for(x in a())break"); fold("while(true){try{continue;}catch(e){continue;}}", "while(true){try{}catch(e){}}"); fold("while(true){try{if(a()){continue;}else{continue;}" + "continue;}catch(e){}}", "while(true){try{if(a()){}else{}}catch(e){}}"); fold("while(true){g:continue}", "while(true){}"); // This case could be improved. fold("while(true){g:if(a()){continue;}else{continue;} continue;}", "while(true){g:if(a());else;}"); } public void testDoContinueOptimization() throws Exception { fold("do{if(x)continue; x=3; continue; }while(true)", "do if(x); else x=3; while(true)"); foldSame("do{a();continue;b()}while(true)"); fold("do{if(true){a();continue;}else;b();}while(true)", "do{if(true){a();}else{b();}}while(true)"); fold("do{if(false){a();continue;}else;b();continue;}while(true)", "do{if(false){a();}else{b();}}while(true)"); fold("do{if(a()){b();continue;}else;c();}while(true)", "do{if(a()){b();}else{c()}}while(true)"); fold("do{if(a()){b();}else{c();continue;}}while(true)", "do{if(a()){b();}else{c();}}while(true)"); fold("do{if(a()){b();continue;}else;}while(true)", "do{if(a()){b();}else;}while(true)"); fold("do{if(a()){continue;}else{continue;} continue;}while(true)", "do{if(a()){}else{}}while(true)"); fold("do{if(a()){continue;}else{continue;} b();}while(true)", "do{if(a()){}else{continue; b();}}while(true)"); fold("do{while(a())continue;}while(true)", "do while(a());while(true)"); fold("do{for(x in a())continue}while(true)", "do for(x in a());while(true)"); fold("do{while(a())break;}while(true)", "do while(a())break;while(true)"); fold("do for(x in a())break;while(true)", "do for(x in a())break;while(true)"); fold("do{try{continue;}catch(e){continue;}}while(true)", "do{try{}catch(e){}}while(true)"); fold("do{try{if(a()){continue;}else{continue;}" + "continue;}catch(e){}}while(true)", "do{try{if(a()){}else{}}catch(e){}}while(true)"); fold("do{g:continue}while(true)", "do{}while(true)"); // This case could be improved. fold("do{g:if(a()){continue;}else{continue;} continue;}while(true)", "do{g:if(a());else;}while(true)"); fold("do { foo(); continue; } while(false)", "do { foo(); } while(false)"); fold("do { foo(); break; } while(false)", "do { foo(); } while(false)"); } public void testForContinueOptimization() throws Exception { fold("for(x in y){if(x)continue; x=3; continue; }", "for(x in y)if(x);else x=3"); foldSame("for(x in y){a();continue;b()}"); fold("for(x in y){if(true){a();continue;}else;b();}", "for(x in y){if(true)a();else b();}"); fold("for(x in y){if(false){a();continue;}else;b();continue;}", "for(x in y){if(false){a();}else{b()}}"); fold("for(x in y){if(a()){b();continue;}else;c();}", "for(x in y){if(a()){b();}else{c();}}"); fold("for(x in y){if(a()){b();}else{c();continue;}}", "for(x in y){if(a()){b();}else{c();}}"); fold("for(x=0;x<y;x++){if(a()){b();continue;}else;}", "for(x=0;x<y;x++){if(a()){b();}else;}"); fold("for(x=0;x<y;x++){if(a()){continue;}else{continue;} continue;}", "for(x=0;x<y;x++){if(a()){}else{}}"); fold("for(x=0;x<y;x++){if(a()){continue;}else{continue;} b();}", "for(x=0;x<y;x++){if(a()){}else{continue; b();}}"); fold("for(x=0;x<y;x++)while(a())continue;", "for(x=0;x<y;x++)while(a());"); fold("for(x=0;x<y;x++)for(x in a())continue", "for(x=0;x<y;x++)for(x in a());"); fold("for(x=0;x<y;x++)while(a())break;", "for(x=0;x<y;x++)while(a())break"); foldSame("for(x=0;x<y;x++)for(x in a())break"); fold("for(x=0;x<y;x++){try{continue;}catch(e){continue;}}", "for(x=0;x<y;x++){try{}catch(e){}}"); fold("for(x=0;x<y;x++){try{if(a()){continue;}else{continue;}" + "continue;}catch(e){}}", "for(x=0;x<y;x++){try{if(a()){}else{}}catch(e){}}"); fold("for(x=0;x<y;x++){g:continue}", "for(x=0;x<y;x++){}"); // This case could be improved. fold("for(x=0;x<y;x++){g:if(a()){continue;}else{continue;} continue;}", "for(x=0;x<y;x++){g:if(a());else;}"); } public void testCodeMotionDoesntBreakFunctionHoisting() throws Exception { fold("function f() { if (x) return; foo(); function foo() {} }", "function f() { if (x); else { function foo() {} foo(); } }"); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Tests for {@link MoveFunctionDeclarations} * */ public class MoveFunctionDeclarationsTest extends CompilerTestCase { @Override protected CompilerPass getProcessor(Compiler compiler) { return new MoveFunctionDeclarations(compiler); } public void testFunctionDeclarations() { test("a; function f(){} function g(){}", "function f(){} function g(){} a"); } public void testFunctionDeclarationsInModule() { test(createModules("a; function f(){} function g(){}"), new String[] { "function f(){} function g(){} a" }); } public void testFunctionsExpression() { testSame("a; f = function(){}"); } public void testNoMoveDeepFunctionDeclarations() { testSame("a; if (a) function f(){};"); testSame("a; if (a) { function f(){} }"); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.rhino.Node; import junit.framework.TestCase; /** * Tests for {@link MustBeReachingVariableDef}. * */ public class MustBeReachingVariableDefTest extends TestCase { private MustBeReachingVariableDef defUse = null; private Node def = null; private Node use = null; public static final String EXTERNS = "var goog = {}"; public void testStraightLine() { assertMatch("D:var x=1; U: x"); assertMatch("var x; D:x=1; U: x"); assertNotMatch("D:var x=1; x = 2; U: x"); assertMatch("var x=1; D:x=2; U: x"); assertNotMatch("U:x; D:var x = 1"); assertNotMatch("D:var x; U:x; x=1"); assertNotMatch("D:var x; U:x; x=1; x"); assertMatch("D: var x = 1; var y = 2; y; U:x"); } public void testIf() { assertNotMatch("var x; if(a){ D:x=1 } else { x=2 }; U:x"); assertNotMatch("var x; if(a){ x=1 } else { D:x=2 }; U:x"); assertMatch("D:var x=1; if(a){ U:x } else { x };"); assertMatch("D:var x=1; if(a){ x } else { U:x };"); assertNotMatch("var x; if(a) { D: x = 1 }; U:x;"); } public void testLoops() { assertNotMatch("var x=0; while(a){ D:x=1 }; U:x"); assertNotMatch("var x=0; for(;;) { D:x=1 }; U:x"); assertMatch("D:var x=1; while(a) { U:x }"); assertMatch("D:var x=1; for(;;) { U:x }"); } public void testConditional() { assertMatch("var x=0,y; D:(x=1)&&y; U:x"); assertNotMatch("var x=0,y; D:y&&(x=1); U:x"); } public void testUseAndDefInSameInstruction() { assertMatch("D:var x=0; U:x=1,x"); assertMatch("D:var x=0; U:x,x=1"); } public void testAssignmentInExpressions() { assertMatch("var x=0; D:foo(bar(x=1)); U:x"); assertMatch("var x=0; D:foo(bar + (x = 1)); U:x"); } public void testHook() { assertNotMatch("var x=0; D:foo() ? x=1 : bar(); U:x"); assertNotMatch("var x=0; D:foo() ? x=1 : x=2; U:x"); } public void testExpressionVariableReassignment() { assertMatch("var a,b; D: var x = a + b; U:x"); assertNotMatch("var a,b,c; D: var x = a + b; a = 1; U:x"); assertNotMatch("var a,b,c; D: var x = a + b; f(b = 1); U:x"); assertMatch("var a,b,c; D: var x = a + b; c = 1; U:x"); // Even if the sub-expression is change conditionally assertNotMatch("var a,b,c; D: var x = a + b; c ? a = 1 : 0; U:x"); } public void testMergeDefinitions() { assertNotMatch("var x,y; D: y = x + x; if(x) { x = 1 }; U:y"); } public void testMergesWithOneDefinition() { assertNotMatch( "var x,y; while(y) { if (y) { print(x) } else { D: x = 1 } } U:x"); } public void testRedefinitionUsingItself() { assertMatch("var x = 1; D: x = x + 1; U:x;"); assertNotMatch("var x = 1; D: x = x + 1; x = 1; U:x;"); } public void testMultipleDefinitionsWithDependence() { assertMatch("var x, a, b; D: x = a, x = b; U: x"); assertMatch("var x, a, b; D: x = a, x = b; a = 1; U: x"); assertNotMatch("var x, a, b; D: x = a, x = b; b = 1; U: x"); } public void testExterns() { assertNotMatch("D: goog = {}; U: goog"); } public void testAssignmentOp() { assertMatch("var x = 0; D: x += 1; U: x"); assertMatch("var x = 0; D: x *= 1; U: x"); assertNotMatch("D: var x = 0; x += 1; U: x"); } public void testIncAndDec() { assertMatch("var x; D: x++; U: x"); assertMatch("var x; D: x--; U: x"); } public void testFunctionParams1() { computeDefUse("if (param2) { D: param1 = 1; U: param1 }"); assertSame(def, defUse.getDefNode("param1", use)); } public void testFunctionParams2() { computeDefUse("if (param2) { D: param1 = 1} U: param1"); assertNotSame(def, defUse.getDefNode("param1", use)); } public void testArgumentsObjectModifications() { computeDefUse("D: param1 = 1; arguments[0] = 2; U: param1"); assertNotSame(def, defUse.getDefNode("param1", use)); } public void testArgumentsObjectEscaped() { computeDefUse("D: param1 = 1; var x = arguments; x[0] = 2; U: param1"); assertNotSame(def, defUse.getDefNode("param1", use)); } public void testArgumentsObjectEscapedDependents() { assertNotMatch("param1=1; var x; D:x=param1; var y=arguments; U:x"); } /** * The use of x at U: is the definition of x at D:. */ private void assertMatch(String src) { computeDefUse(src); assertSame(def, defUse.getDefNode("x", use)); } /** * The use of x at U: is not the definition of x at D:. */ private void assertNotMatch(String src) { computeDefUse(src); assertNotSame(def, defUse.getDefNode("x", use)); } /** * Computes reaching definition on given source. */ private void computeDefUse(String src) { Compiler compiler = new Compiler(); src = "function _FUNCTION(param1, param2){" + src + "}"; Node externs = compiler.parseTestCode(EXTERNS); Node root = compiler.parseTestCode(src).getFirstChild(); assertEquals(0, compiler.getErrorCount()); Scope scope = new SyntacticScopeCreator(compiler).createScope(root, null); ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true); cfa.process(null, root); ControlFlowGraph<Node> cfg = cfa.getCfg(); defUse = new MustBeReachingVariableDef(cfg, scope, compiler); defUse.analyze(); def = null; use = null; new NodeTraversal(compiler,new LabelFinder()).traverse(root); assertNotNull("Code should have an instruction labeled D", def); assertNotNull("Code should have an instruction labeled U", use); } /** * Finds the D: and U: label and store which node they point to. */ private class LabelFinder extends AbstractPostOrderCallback { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isLabel()) { if (n.getFirstChild().getString().equals("D")) { def = n.getLastChild(); } else if (n.getFirstChild().getString().equals("U")) { use = n.getLastChild(); } } } } }
/* * Copyright 2006 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.rhino.Node; /** * Tests for {@link NameAnalyzer} * */ public class NameAnalyzerTest extends CompilerTestCase { private static String kExterns = "var window, top;" + "var document;" + "var Function;" + "var Array;" + "var externfoo; methods.externfoo;"; public NameAnalyzerTest() { super(kExterns); } @Override protected void setUp() { super.enableNormalize(); super.enableLineNumberCheck(true); } @Override protected int getNumRepetitions() { // pass reaches steady state after 1 iteration. return 1; } public void testRemoveVarDeclaration1() { test("var foo = 3;", ""); } public void testRemoveVarDeclaration2() { test("var foo = 3, bar = 4; externfoo = foo;", "var foo = 3; externfoo = foo;"); } public void testRemoveVarDeclaration3() { test("var a = f(), b = 1, c = 2; b; c", "f();var b = 1, c = 2; b; c"); } public void testRemoveVarDeclaration4() { test("var a = 0, b = f(), c = 2; a; c", "var a = 0;f();var c = 2; a; c"); } public void testRemoveVarDeclaration5() { test("var a = 0, b = 1, c = f(); a; b", "var a = 0, b = 1; f(); a; b"); } public void testRemoveVarDeclaration6() { test("var a = 0, b = a = 1; a", "var a = 0; a = 1; a"); } public void testRemoveVarDeclaration7() { test("var a = 0, b = a = 1", ""); } public void testRemoveVarDeclaration8() { test("var a;var b = 0, c = a = b = 1", ""); } public void testRemoveDeclaration1() { test("var a;var b = 0, c = a = b = 1", ""); } public void testRemoveDeclaration2() { test("var a,b,c; c = a = b = 1", ""); } public void testRemoveDeclaration3() { test("var a,b,c; c = a = b = {}; a.x = 1;", ""); } public void testRemoveDeclaration4() { testSame("var a,b,c; c = a = b = {}; a.x = 1;alert(c.x);"); } public void testRemoveDeclaration5() { test("var a,b,c; c = a = b = null; use(b)", "var b;b=null;use(b)"); } public void testRemoveDeclaration6() { test("var a,b,c; c = a = b = 'str';use(b)", "var b;b='str';use(b)"); } public void testRemoveDeclaration7() { test("var a,b,c; c = a = b = true;use(b)", "var b;b=true;use(b)"); } public void testRemoveFunction1() { test("var foo = function(){};", ""); } public void testRemoveFunction2() { test("var foo; foo = function(){};", ""); } public void testRemoveFunction3() { test("var foo = {}; foo.bar = function() {};", ""); } public void testRemoveFunction4() { test("var a = {}; a.b = {}; a.b.c = function() {};", ""); } public void testReferredToByWindow() { testSame("var foo = {}; foo.bar = function() {}; window['fooz'] = foo.bar"); } public void testExtern() { testSame("externfoo = 5"); } public void testRemoveNamedFunction() { test("function foo(){}", ""); } public void testRemoveRecursiveFunction1() { test("function f(){f()}", ""); } public void testRemoveRecursiveFunction2() { test("var f = function (){f()}", ""); } public void testRemoveRecursiveFunction2a() { test("var f = function g(){g()}", ""); } public void testRemoveRecursiveFunction3() { test("var f;f = function (){f()}", ""); } public void testRemoveRecursiveFunction4() { // don't removed if name definition doesn't exist. testSame("f = function (){f()}"); } public void testRemoveRecursiveFunction5() { test("function g(){f()}function f(){g()}", ""); } public void testRemoveRecursiveFunction6() { test("var f=function(){g()};function g(){f()}", ""); } public void testRemoveRecursiveFunction7() { test("var g = function(){f()};var f = function(){g()}", ""); } public void testRemoveRecursiveFunction8() { test("var o = {};o.f = function(){o.f()}", ""); } public void testRemoveRecursiveFunction9() { testSame("var o = {};o.f = function(){o.f()};o.f()"); } public void testSideEffectClassification1() { test("foo();", "foo();"); } public void testSideEffectClassification2() { test("var a = foo();", "foo();"); } public void testSideEffectClassification3() { testSame("var a = foo();window['b']=a;"); } public void testSideEffectClassification4() { testSame("function sef(){} sef();"); } public void testSideEffectClassification5() { testSame("function nsef(){} var a = nsef();window['b']=a;"); } public void testSideEffectClassification6() { test("function sef(){} sef();", "function sef(){} sef();"); } public void testSideEffectClassification7() { testSame("function sef(){} var a = sef();window['b']=a;"); } public void testNoSideEffectAnnotation1() { test("function f(){} var a = f();", "function f(){} f()"); } public void testNoSideEffectAnnotation2() { test("/**@nosideeffects*/function f(){}", "var a = f();", "", null, null); } public void testNoSideEffectAnnotation3() { test("var f = function(){}; var a = f();", "var f = function(){}; f();"); } public void testNoSideEffectAnnotation4() { test("var f = /**@nosideeffects*/function(){};", "var a = f();", "", null, null); } public void testNoSideEffectAnnotation5() { test("var f; f = function(){}; var a = f();", "var f; f = function(){}; f();"); } public void testNoSideEffectAnnotation6() { test("var f; f = /**@nosideeffects*/function(){};", "var a = f();", "", null, null); } public void testNoSideEffectAnnotation7() { test("var f;" + "f = /**@nosideeffects*/function(){};", "f = function(){};" + "var a = f();", "f = function(){}; f();", null, null); } public void testNoSideEffectAnnotation8() { test("var f;" + "f = function(){};" + "f = /**@nosideeffects*/function(){};", "var a = f();", "f();", null, null); } public void testNoSideEffectAnnotation9() { test("var f;" + "f = /**@nosideeffects*/function(){};" + "f = /**@nosideeffects*/function(){};", "var a = f();", "", null, null); test("var f; f = /**@nosideeffects*/function(){};", "var a = f();", "", null, null); } public void testNoSideEffectAnnotation10() { test("var o = {}; o.f = function(){}; var a = o.f();", "var o = {}; o.f = function(){}; o.f();"); } public void testNoSideEffectAnnotation11() { test("var o = {}; o.f = /**@nosideeffects*/function(){};", "var a = o.f();", "", null, null); } public void testNoSideEffectAnnotation12() { test("function c(){} var a = new c", "function c(){} new c"); } public void testNoSideEffectAnnotation13() { test("/**@nosideeffects*/function c(){}", "var a = new c", "", null, null); } public void testNoSideEffectAnnotation14() { String common = "function c(){};" + "c.prototype.f = /**@nosideeffects*/function(){};"; test(common, "var o = new c; var a = o.f()", "new c", null, null); } public void testNoSideEffectAnnotation15() { test("function c(){}; c.prototype.f = function(){}; var a = (new c).f()", "function c(){}; c.prototype.f = function(){}; (new c).f()"); } public void testNoSideEffectAnnotation16() { test("/**@nosideeffects*/function c(){}" + "c.prototype.f = /**@nosideeffects*/function(){};", "var a = (new c).f()", "", null, null); } public void testFunctionPrototype() { testSame("var a = 5; Function.prototype.foo = function() {return a;}"); } public void testTopLevelClass1() { test("var Point = function() {}; Point.prototype.foo = function() {}", ""); } public void testTopLevelClass2() { testSame("var Point = {}; Point.prototype.foo = function() {};" + "externfoo = new Point()"); } public void testTopLevelClass3() { test("function Point() {this.me_ = Point}", ""); } public void testTopLevelClass4() { test("function f(){} function A(){} A.prototype = {x: function() {}}; f();", "function f(){} f();"); } public void testTopLevelClass5() { testSame("function f(){} function A(){}" + "A.prototype = {x: function() { f(); }}; new A();"); } public void testTopLevelClass6() { testSame("function f(){} function A(){}" + "A.prototype = {x: function() { f(); }}; new A().x();"); } public void testTopLevelClass7() { test("A.prototype.foo = function(){}; function A() {}", ""); } public void testNamespacedClass1() { test("var foo = {};foo.bar = {};foo.bar.prototype.baz = {}", ""); } public void testNamespacedClass2() { testSame("var foo = {};foo.bar = {};foo.bar.prototype.baz = {};" + "window.z = new foo.bar()"); } public void testNamespacedClass3() { test("var a = {}; a.b = function() {}; a.b.prototype = {x: function() {}};", ""); } public void testNamespacedClass4() { testSame("function f(){} var a = {}; a.b = function() {};" + "a.b.prototype = {x: function() { f(); }}; new a.b();"); } public void testNamespacedClass5() { testSame("function f(){} var a = {}; a.b = function() {};" + "a.b.prototype = {x: function() { f(); }}; new a.b().x();"); } public void testAssignmentToThisPrototype() { testSame("Function.prototype.inherits = function(parentCtor) {" + " function tempCtor() {};" + " tempCtor.prototype = parentCtor.prototype;" + " this.superClass_ = parentCtor.prototype;" + " this.prototype = new tempCtor();" + " this.prototype.constructor = this;" + "};"); } public void testAssignmentToCallResultPrototype() { testSame("function f() { return function(){}; } f().prototype = {};"); } public void testAssignmentToExternPrototype() { testSame("externfoo.prototype = {};"); } public void testAssignmentToUnknownPrototype() { testSame( "/** @suppress {duplicate} */ var window;" + "window['a'].prototype = {};"); } public void testBug2099540() { testSame( "/** @suppress {duplicate} */ var document;\n" + "/** @suppress {duplicate} */ var window;\n" + "var klass;\n" + "window[klass].prototype = " + "document.createElement(tagName)['__proto__'];"); } public void testOtherGlobal() { testSame("goog.global.foo = bar(); function bar(){}"); } public void testExternName1() { testSame("top.z = bar(); function bar(){}"); } public void testExternName2() { testSame("top['z'] = bar(); function bar(){}"); } public void testInherits1() { test("var a = {}; var b = {}; b.inherits(a)", ""); } public void testInherits2() { test("var a = {}; var b = {}; var goog = {}; goog.inherits(b, a)", ""); } public void testInherits3() { testSame("var a = {}; this.b = {}; b.inherits(a);"); } public void testInherits4() { testSame("var a = {}; this.b = {}; var goog = {}; goog.inherits(b, a);"); } public void testInherits5() { test("this.a = {}; var b = {}; b.inherits(a);", "this.a = {}"); } public void testInherits6() { test("this.a = {}; var b = {}; var goog = {}; goog.inherits(b, a);", "this.a = {}"); } public void testInherits7() { testSame("var a = {}; this.b = {}; var goog = {};" + " goog.inherits = function() {}; goog.inherits(b, a);"); } public void testInherits8() { // Make sure that exceptions aren't thrown if inherits() is used as // an R-value test("this.a = {}; var b = {}; var c = b.inherits(a);", "this.a = {};"); } public void testMixin1() { testSame("var goog = {}; goog.mixin = function() {};" + "Function.prototype.mixin = function(base) {" + " goog.mixin(this.prototype, base); " + "};"); } public void testMixin2() { testSame("var a = {}; this.b = {}; var goog = {};" + " goog.mixin = function() {}; goog.mixin(b.prototype, a.prototype);"); } public void testMixin3() { test("this.a = {}; var b = {}; var goog = {};" + " goog.mixin = function() {}; goog.mixin(b.prototype, a.prototype);", "this.a = {};"); } public void testMixin4() { testSame("this.a = {}; var b = {}; var goog = {};" + "goog.mixin = function() {};" + "goog.mixin(b.prototype, a.prototype);" + "new b()"); } public void testMixin5() { test("this.a = {}; var b = {}; var c = {}; var goog = {};" + "goog.mixin = function() {};" + "goog.mixin(b.prototype, a.prototype);" + "goog.mixin(c.prototype, a.prototype);" + "new b()", "this.a = {}; var b = {}; var goog = {};" + "goog.mixin = function() {};" + "goog.mixin(b.prototype, a.prototype);" + "new b()"); } public void testMixin6() { testSame("this.a = {}; var b = {}; var c = {}; var goog = {};" + "goog.mixin = function() {};" + "goog.mixin(c.prototype, a.prototype) + " + "goog.mixin(b.prototype, a.prototype);" + "new b()"); } public void testMixin7() { test("this.a = {}; var b = {}; var c = {}; var goog = {};" + "goog.mixin = function() {};" + "var d = goog.mixin(c.prototype, a.prototype) + " + "goog.mixin(b.prototype, a.prototype);" + "new b()", "this.a = {}; var b = {}; var goog = {};" + "goog.mixin = function() {};" + "goog.mixin(b.prototype, a.prototype);" + "new b()"); } public void testConstants1() { testSame("var bar = function(){}; var EXP_FOO = true; if (EXP_FOO) bar();"); } public void testConstants2() { test("var bar = function(){}; var EXP_FOO = true; var EXP_BAR = true;" + "if (EXP_FOO) bar();", "var bar = function(){}; var EXP_FOO = true; if (EXP_FOO) bar();"); } public void testExpressions1() { test("var foo={}; foo.A='A'; foo.AB=foo.A+'B'; foo.ABC=foo.AB+'C'", ""); } public void testExpressions2() { testSame("var foo={}; foo.A='A'; foo.AB=foo.A+'B'; this.ABC=foo.AB+'C'"); } public void testExpressions3() { testSame("var foo = 2; window.bar(foo + 3)"); } public void testSetCreatingReference() { testSame("var foo; var bar = function(){foo=6;}; bar();"); } public void testAnonymous1() { testSame("function foo() {}; function bar() {}; foo(function() {bar()})"); } public void testAnonymous2() { test("var foo;(function(){foo=6;})()", "(function(){})()"); } public void testAnonymous3() { testSame("var foo; (function(){ if(!foo)foo=6; })()"); } public void testAnonymous4() { testSame("var foo; (function(){ foo=6; })(); externfoo=foo;"); } public void testAnonymous5() { testSame("var foo;" + "(function(){ foo=function(){ bar() }; function bar(){} })();" + "foo();"); } public void testAnonymous6() { testSame("function foo(){}" + "function bar(){}" + "foo(function(){externfoo = bar});"); } public void testAnonymous7() { testSame("var foo;" + "(function (){ function bar(){ externfoo = foo; } bar(); })();"); } public void testAnonymous8() { testSame("var foo;" + "(function (){ var g=function(){ externfoo = foo; }; g(); })();"); } public void testAnonymous9() { testSame("function foo(){}" + "function bar(){}" + "foo(function(){ function baz(){ externfoo = bar; } baz(); });"); } public void testFunctions1() { testSame("var foo = null; function baz() {}" + "function bar() {foo=baz();} bar();"); } public void testFunctions2() { testSame("var foo; foo = function() {var a = bar()};" + "var bar = function(){}; foo();"); } public void testGetElem1() { testSame("var foo = {}; foo.bar = {}; foo.bar.baz = {a: 5, b: 10};" + "var fn = function() {window[foo.bar.baz.a] = 5;}; fn()"); } public void testGetElem2() { testSame("var foo = {}; foo.bar = {}; foo.bar.baz = {a: 5, b: 10};" + "var fn = function() {this[foo.bar.baz.a] = 5;}; fn()"); } public void testGetElem3() { testSame("var foo = {'i': 0, 'j': 1}; foo['k'] = 2; top.foo = foo;"); } public void testIf1() { test("var foo = {};if(e)foo.bar=function(){};", "if(e);"); } public void testIf2() { test("var e = false;var foo = {};if(e)foo.bar=function(){};", "var e = false;if(e);"); } public void testIf3() { test("var e = false;var foo = {};if(e + 1)foo.bar=function(){};", "var e = false;if(e + 1);"); } public void testIf4() { test("var e = false, f;var foo = {};if(f=e)foo.bar=function(){};", "var e = false;if(e);"); } public void testIf4a() { // TODO(johnlenz): fix this. testSame("var e = [], f;if(f=e);f[0] = 1;"); } public void testIf4b() { // TODO(johnlenz): fix this. test("var e = [], f;if(e=f);f[0] = 1;", "var f;if(f);f[0] = 1;"); } public void testIf4c() { test("var e = [], f;if(f=e);e[0] = 1;", "var e = [];if(e);e[0] = 1;"); } public void testIf5() { test("var e = false, f;var foo = {};if(f = e + 1)foo.bar=function(){};", "var e = false;if(e + 1);"); } public void testIfElse() { test("var foo = {};if(e)foo.bar=function(){};else foo.bar=function(){};", "if(e);else;"); } public void testWhile() { test("var foo = {};while(e)foo.bar=function(){};", "while(e);"); } public void testFor() { test("var foo = {};for(e in x)foo.bar=function(){};", "for(e in x);"); } public void testDo() { test("var cond = false;do {var a = 1} while (cond)", "var cond = false;do {} while (cond)"); } public void testSetterInForStruct1() { test("var j = 0; for (var i = 1; i = 0; j++);", "var j = 0; for (; 0; j++);"); } public void testSetterInForStruct2() { test("var Class = function() {}; " + "for (var i = 1; Class.prototype.property_ = 0; i++);", "for (var i = 1; 0; i++);"); } public void testSetterInForStruct3() { test("var j = 0; for (var i = 1 + f() + g() + h(); i = 0; j++);", "var j = 0; f(); g(); h(); for (; 0; j++);"); } public void testSetterInForStruct4() { test("var i = 0;var j = 0; for (i = 1 + f() + g() + h(); i = 0; j++);", "var j = 0; f(); g(); h(); for (; 0; j++);"); } public void testSetterInForStruct5() { test("var i = 0, j = 0; for (i = f(), j = g(); 0;);", "for (f(), g(); 0;);"); } public void testSetterInForStruct6() { test("var i = 0, j = 0, k = 0; for (i = f(), j = g(), k = h(); i = 0;);", "for (f(), g(), h(); 0;);"); } public void testSetterInForStruct7() { test("var i = 0, j = 0, k = 0; for (i = 1, j = 2, k = 3; i = 0;);", "for (1, 2, 3; 0;);"); } public void testSetterInForStruct8() { test("var i = 0, j = 0, k = 0; for (i = 1, j = i, k = 2; i = 0;);", "var i = 0; for(i = 1, i , 2; i = 0;);"); } public void testSetterInForStruct9() { test("var Class = function() {}; " + "for (var i = 1; Class.property_ = 0; i++);", "for (var i = 1; 0; i++);"); } public void testSetterInForStruct10() { test("var Class = function() {}; " + "for (var i = 1; Class.property_ = 0; i = 2);", "for (; 0;);"); } public void testSetterInForStruct11() { test("var Class = function() {}; " + "for (;Class.property_ = 0;);", "for (;0;);"); } public void testSetterInForStruct12() { test("var a = 1; var Class = function() {}; " + "for (;Class.property_ = a;);", "var a = 1; for (; a;);"); } public void testSetterInForStruct13() { test("var a = 1; var Class = function() {}; " + "for (Class.property_ = a; 0 ;);", "for (; 0;);"); } public void testSetterInForStruct14() { test("var a = 1; var Class = function() {}; " + "for (; 0; Class.property_ = a);", "for (; 0;);"); } public void testSetterInForStruct15() { test("var Class = function() {}; " + "for (var i = 1; 0; Class.prototype.property_ = 0);", "for (; 0; 0);"); } public void testSetterInForStruct16() { test("var Class = function() {}; " + "for (var i = 1; i = 0; Class.prototype.property_ = 0);", "for (; 0; 0);"); } public void testSetterInForIn1() { test("var foo = {}; var bar; for(e in bar = foo.a);", "var foo = {}; for(e in foo.a);"); } public void testSetterInForIn2() { testSame("var foo = {}; var bar; for(e in bar = foo.a); bar"); } public void testSetterInForIn3() { testSame("var foo = {}; var bar; for(e in bar = foo.a); bar.b = 3"); } public void testSetterInForIn4() { testSame("var foo = {}; var bar; for (e in bar = foo.a); bar.b = 3; foo.a"); } public void testSetterInForIn5() { // TODO(user) Fix issue similar to b/2316773: bar should be preserved // but isn't due to missing references between e and foo.a test("var foo = {}; var bar; for (e in foo.a) { bar = e } bar.b = 3; foo.a", "var foo={};for(e in foo.a);foo.a"); } public void testSetterInForIn6() { testSame("var foo = {};for(e in foo);"); } public void testSetterInIfPredicate() { // TODO(user) Make NameAnalyzer smarter so it can remove "Class". testSame("var a = 1;" + "var Class = function() {}; " + "if (Class.property_ = a);"); } public void testSetterInWhilePredicate() { test("var a = 1;" + "var Class = function() {}; " + "while (Class.property_ = a);", "var a = 1; for (;a;) {}"); } public void testSetterInDoWhilePredicate() { // TODO(user) Make NameAnalyzer smarter so it can remove "Class". testSame("var a = 1;" + "var Class = function() {}; " + "do {} while(Class.property_ = a);"); } public void testSetterInSwitchInput() { // TODO(user) Make NameAnalyzer smarter so it can remove "Class". testSame("var a = 1;" + "var Class = function() {}; " + "switch (Class.property_ = a) {" + " default:" + "}"); } public void testComplexAssigns() { // Complex assigns are not removed by the current pass. testSame("var x = 0; x += 3; x *= 5;"); } public void testNestedAssigns1() { test("var x = 0; var y = x = 3; window.alert(y);", "var y = 3; window.alert(y);"); } public void testNestedAssigns2() { testSame("var x = 0; var y = x = {}; x.b = 3; window.alert(y);"); } public void testComplexNestedAssigns1() { // TODO(nicksantos): Make NameAnalyzer smarter, so that we can eliminate y. testSame("var x = 0; var y = 2; y += x = 3; window.alert(x);"); } public void testComplexNestedAssigns2() { test("var x = 0; var y = 2; y += x = 3; window.alert(y);", "var y = 2; y += 3; window.alert(y);"); } public void testComplexNestedAssigns3() { test("var x = 0; var y = x += 3; window.alert(x);", "var x = 0; x += 3; window.alert(x);"); } public void testComplexNestedAssigns4() { testSame("var x = 0; var y = x += 3; window.alert(y);"); } public void testUnintendedUseOfInheritsInLocalScope1() { testSame("goog.mixin = function() {}; " + "(function() { var x = {}; var y = {}; goog.mixin(x, y); })();"); } public void testUnintendedUseOfInheritsInLocalScope2() { testSame("goog.mixin = function() {}; " + "var x = {}; var y = {}; (function() { goog.mixin(x, y); })();"); } public void testUnintendedUseOfInheritsInLocalScope3() { testSame("goog.mixin = function() {}; " + "var x = {}; var y = {}; (function() { goog.mixin(x, y); })(); " + "window.alert(x);"); } public void testUnintendedUseOfInheritsInLocalScope4() { // Ensures that the "goog$mixin" variable doesn't get stripped out, // even when it's only used in a local scope. testSame("var goog$mixin = function() {}; " + "(function() { var x = {}; var y = {}; goog$mixin(x, y); })();"); } public void testPrototypePropertySetInLocalScope1() { testSame("(function() { var x = function(){}; x.prototype.bar = 3; })();"); } public void testPrototypePropertySetInLocalScope2() { testSame("var x = function(){}; (function() { x.prototype.bar = 3; })();"); } public void testPrototypePropertySetInLocalScope3() { test("var x = function(){ x.prototype.bar = 3; };", ""); } public void testPrototypePropertySetInLocalScope4() { test("var x = {}; x.foo = function(){ x.foo.prototype.bar = 3; };", ""); } public void testPrototypePropertySetInLocalScope5() { test("var x = {}; x.prototype.foo = 3;", ""); } public void testPrototypePropertySetInLocalScope6() { testSame("var x = {}; x.prototype.foo = 3; bar(x.prototype.foo)"); } public void testPrototypePropertySetInLocalScope7() { testSame("var x = {}; x.foo = 3; bar(x.foo)"); } public void testRValueReference1() { testSame("var a = 1; a"); } public void testRValueReference2() { testSame("var a = 1; 1+a"); } public void testRValueReference3() { testSame("var x = {}; x.prototype.foo = 3; var a = x.prototype.foo; 1+a"); } public void testRValueReference4() { testSame("var x = {}; x.prototype.foo = 3; x.prototype.foo"); } public void testRValueReference5() { testSame("var x = {}; x.prototype.foo = 3; 1+x.prototype.foo"); } public void testRValueReference6() { testSame("var x = {}; var idx = 2; x[idx]"); } public void testUnhandledTopNode() { testSame("function Foo() {}; Foo.prototype.isBar = function() {};" + "function Bar() {}; Bar.prototype.isFoo = function() {};" + "var foo = new Foo(); var bar = new Bar();" + // The boolean AND here is currently unhandled by this pass, but // it should not cause it to blow up. "var cond = foo.isBar() && bar.isFoo();" + "if (cond) {window.alert('hello');}"); } public void testPropertyDefinedInGlobalScope() { testSame("function Foo() {}; var x = new Foo(); x.cssClass = 'bar';" + "window.alert(x);"); } public void testConditionallyDefinedFunction1() { testSame("var g; externfoo.x || (externfoo.x = function() { g; })"); } public void testConditionallyDefinedFunction2() { testSame("var g; 1 || (externfoo.x = function() { g; })"); } public void testConditionallyDefinedFunction3() { testSame("var a = {};" + "rand() % 2 || (a.f = function() { externfoo = 1; } || alert());"); } public void testGetElemOnThis() { testSame("var a = 3; this['foo'] = a;"); testSame("this['foo'] = 3;"); } public void testRemoveInstanceOfOnly() { test("function Foo() {}; Foo.prototype.isBar = function() {};" + "var x; if (x instanceof Foo) { window.alert(x); }", ";var x; if (false) { window.alert(x); }"); } public void testRemoveLocalScopedInstanceOfOnly() { test("function Foo() {}; function Bar(x) { this.z = x instanceof Foo; };" + "externfoo.x = new Bar({});", ";function Bar(x) { this.z = false }; externfoo.x = new Bar({});"); } public void testRemoveInstanceOfWithReferencedMethod() { test("function Foo() {}; Foo.prototype.isBar = function() {};" + "var x; if (x instanceof Foo) { window.alert(x.isBar()); }", ";var x; if (false) { window.alert(x.isBar()); }"); } public void testDoNotChangeReferencedInstanceOf() { testSame("function Foo() {}; Foo.prototype.isBar = function() {};" + "var x = new Foo(); if (x instanceof Foo) { window.alert(x); }"); } public void testDoNotChangeReferencedLocalScopedInstanceOf() { testSame("function Foo() {}; externfoo.x = new Foo();" + "function Bar() { if (x instanceof Foo) { window.alert(x); } };" + "externfoo.y = new Bar();"); } public void testDoNotChangeLocalScopeReferencedInstanceOf() { testSame("function Foo() {}; Foo.prototype.isBar = function() {};" + "function Bar() { this.z = new Foo(); }; externfoo.x = new Bar();" + "if (x instanceof Foo) { window.alert(x); }"); } public void testDoNotChangeLocalScopeReferencedLocalScopedInstanceOf() { testSame("function Foo() {}; Foo.prototype.isBar = function() {};" + "function Bar() { this.z = new Foo(); };" + "Bar.prototype.func = function(x) {" + "if (x instanceof Foo) { window.alert(x); }" + "}; new Bar().func();"); } public void testDoNotChangeLocalScopeReferencedLocalScopedInstanceOf2() { test( "function Foo() {}" + "var createAxis = function(f) { return window.passThru(f); };" + "var axis = createAxis(function(test) {" + " return test instanceof Foo;" + "});", "var createAxis = function(f) { return window.passThru(f); };" + "createAxis(function(test) {" + " return false;" + "});"); } public void testDoNotChangeInstanceOfGetElem() { testSame("var goog = {};" + "function f(obj, name) {" + " if (obj instanceof goog[name]) {" + " return name;" + " }" + "}" + "window['f'] = f;"); } public void testWeirdnessOnLeftSideOfPrototype() { // This checks a bug where 'x' was removed, but the function referencing // it was not, causing problems. testSame("var x = 3; " + "(function() { this.bar = 3; }).z = function() {" + " return x;" + "};"); } public void testShortCircuit1() { test("var a = b() || 1", "b()"); } public void testShortCircuit2() { test("var a = 1 || c()", "1 || c()"); } public void testShortCircuit3() { test("var a = b() || c()", "b() || c()"); } public void testShortCircuit4() { test("var a = b() || 3 || c()", "b() || 3 || c()"); } public void testShortCircuit5() { test("var a = b() && 1", "b()"); } public void testShortCircuit6() { test("var a = 1 && c()", "1 && c()"); } public void testShortCircuit7() { test("var a = b() && c()", "b() && c()"); } public void testShortCircuit8() { test("var a = b() && 3 && c()", "b() && 3 && c()"); } public void testRhsReference1() { testSame("var a = 1; a"); } public void testRhsReference2() { testSame("var a = 1; a || b()"); } public void testRhsReference3() { testSame("var a = 1; 1 || a"); } public void testRhsReference4() { test("var a = 1; var b = a || foo()", "var a = 1; a || foo()"); } public void testRhsReference5() { test("var a = 1, b = 5; a; foo(b)", "var a = 1, b = 5; a; foo(b)"); } public void testRhsAssign1() { test("var foo, bar; foo || (bar = 1)", "var foo; foo || 1"); } public void testRhsAssign2() { test("var foo, bar, baz; foo || (baz = bar = 1)", "var foo; foo || 1"); } public void testRhsAssign3() { testSame("var foo = null; foo || (foo = 1)"); } public void testRhsAssign4() { test("var foo = null; foo = (foo || 1)", ""); } public void testRhsAssign5() { test("var a = 3, foo, bar; foo || (bar = a)", "var a = 3, foo; foo || a"); } public void testRhsAssign6() { test("function Foo(){} var foo = null;" + "var f = function () {foo || (foo = new Foo()); return foo}", ""); } public void testRhsAssign7() { testSame("function Foo(){} var foo = null;" + "var f = function () {foo || (foo = new Foo())}; f()"); } public void testRhsAssign8() { testSame("function Foo(){} var foo = null;" + "var f = function () {(foo = new Foo()) || g()}; f()"); } public void testRhsAssign9() { test("function Foo(){} var foo = null;" + "var f = function () {1 + (foo = new Foo()); return foo}", ""); } public void testAssignWithOr1() { testSame("var foo = null;" + "var f = window.a || function () {return foo}; f()"); } public void testAssignWithOr2() { test("var foo = null;" + "var f = window.a || function () {return foo};", "var foo = null"); // why is this left? } public void testAssignWithAnd1() { testSame("var foo = null;" + "var f = window.a && function () {return foo}; f()"); } public void testAssignWithAnd2() { test("var foo = null;" + "var f = window.a && function () {return foo};", "var foo = null;"); // why is this left? } public void testAssignWithHook1() { testSame("function Foo(){} var foo = null;" + "var f = window.a ? " + " function () {return new Foo()} : function () {return foo}; f()"); } public void testAssignWithHook2() { test("function Foo(){} var foo = null;" + "var f = window.a ? " + " function () {return new Foo()} : function () {return foo};", ""); } public void testAssignWithHook2a() { test("function Foo(){} var foo = null;" + "var f; f = window.a ? " + " function () {return new Foo()} : function () {return foo};", ""); } public void testAssignWithHook3() { testSame("function Foo(){} var foo = null; var f = {};" + "f.b = window.a ? " + " function () {return new Foo()} : function () {return foo}; f.b()"); } public void testAssignWithHook4() { test("function Foo(){} var foo = null; var f = {};" + "f.b = window.a ? " + " function () {return new Foo()} : function () {return foo};", ""); } public void testAssignWithHook5() { testSame("function Foo(){} var foo = null; var f = {};" + "f.b = window.a ? function () {return new Foo()} :" + " window.b ? function () {return foo} :" + " function() { return Foo }; f.b()"); } public void testAssignWithHook6() { test("function Foo(){} var foo = null; var f = {};" + "f.b = window.a ? function () {return new Foo()} :" + " window.b ? function () {return foo} :" + " function() { return Foo };", ""); } public void testAssignWithHook7() { testSame("function Foo(){} var foo = null;" + "var f = window.a ? new Foo() : foo;" + "f()"); } public void testAssignWithHook8() { test("function Foo(){} var foo = null;" + "var f = window.a ? new Foo() : foo;", "function Foo(){}" + "window.a && new Foo()"); } public void testAssignWithHook9() { test("function Foo(){} var foo = null; var f = {};" + "f.b = window.a ? new Foo() : foo;", "function Foo(){} window.a && new Foo()"); } public void testAssign1() { test("function Foo(){} var foo = null; var f = {};" + "f.b = window.a;", ""); } public void testAssign2() { test("function Foo(){} var foo = null; var f = {};" + "f.b = window;", ""); } public void testAssign3() { test("var f = {};" + "f.b = window;", ""); } public void testAssign4() { test("function Foo(){} var foo = null; var f = {};" + "f.b = new Foo();", "function Foo(){} new Foo()"); } public void testAssign5() { test("function Foo(){} var foo = null; var f = {};" + "f.b = foo;", ""); } public void testNestedAssign1() { test("var a, b = a = 1, c = 2", ""); } public void testNestedAssign2() { test("var a, b = a = 1; foo(b)", "var b = 1; foo(b)"); } public void testNestedAssign3() { test("var a, b = a = 1; a = b = 2; foo(b)", "var b = 1; b = 2; foo(b)"); } public void testNestedAssign4() { test("var a, b = a = 1; b = a = 2; foo(b)", "var b = 1; b = 2; foo(b)"); } public void testNestedAssign5() { test("var a, b = a = 1; b = a = 2", ""); } public void testNestedAssign15() { test("var a, b, c; c = b = a = 2", ""); } public void testNestedAssign6() { testSame("var a, b, c; a = b = c = 1; foo(a, b, c)"); } public void testNestedAssign7() { testSame("var a = 0; a = i[j] = 1; b(a, i[j])"); } public void testNestedAssign8() { testSame("function f(){" + "this.lockedToken_ = this.lastToken_ = " + "SETPROP_value(this.hiddenInput_, a)}f()"); } public void testRefChain1() { test("var a = 1; var b = a; var c = b; var d = c", ""); } public void testRefChain2() { test("var a = 1; var b = a; var c = b; var d = c || f()", "var a = 1; var b = a; var c = b; c || f()"); } public void testRefChain3() { test("var a = 1; var b = a; var c = b; var d = c + f()", "f()"); } public void testRefChain4() { test("var a = 1; var b = a; var c = b; var d = f() || c", "f()"); } public void testRefChain5() { test("var a = 1; var b = a; var c = b; var d = f() ? g() : c", "f() && g()"); } public void testRefChain6() { test("var a = 1; var b = a; var c = b; var d = c ? f() : g()", "var a = 1; var b = a; var c = b; c ? f() : g()"); } public void testRefChain7() { test("var a = 1; var b = a; var c = b; var d = (b + f()) ? g() : c", "var a = 1; var b = a; (b+f()) && g()"); } public void testRefChain8() { test("var a = 1; var b = a; var c = b; var d = f()[b] ? g() : 0", "var a = 1; var b = a; f()[b] && g()"); } public void testRefChain9() { test("var a = 1; var b = a; var c = 5; var d = f()[b+c] ? g() : 0", "var a = 1; var b = a; var c = 5; f()[b+c] && g()"); } public void testRefChain10() { test("var a = 1; var b = a; var c = b; var d = f()[b] ? g() : 0", "var a = 1; var b = a; f()[b] && g()"); } public void testRefChain11() { test("var a = 1; var b = a; var d = f()[b] ? g() : 0", "var a = 1; var b = a; f()[b] && g()"); } public void testRefChain12() { testSame("var a = 1; var b = a; f()[b] ? g() : 0"); } public void testRefChain13() { test("function f(){}var a = 1; var b = a; var d = f()[b] ? g() : 0", "function f(){}var a = 1; var b = a; f()[b] && g()"); } public void testRefChain14() { testSame("function f(){}var a = 1; var b = a; f()[b] ? g() : 0"); } public void testRefChain15() { test("function f(){}var a = 1, b = a; var c = f(); var d = c[b] ? g() : 0", "function f(){}var a = 1, b = a; var c = f(); c[b] && g()"); } public void testRefChain16() { testSame("function f(){}var a = 1; var b = a; var c = f(); c[b] ? g() : 0"); } public void testRefChain17() { test("function f(){}var a = 1; var b = a; var c = f(); var d = c[b]", "function f(){} f()"); } public void testRefChain18() { testSame("var a = 1; f()[a] && g()"); } public void testRefChain19() { test("var a = 1; var b = [a]; var c = b; b[f()] ? g() : 0", "var a=1; var b=[a]; b[f()] ? g() : 0"); } public void testRefChain20() { test("var a = 1; var b = [a]; var c = b; var d = b[f()] ? g() : 0", "var a=1; var b=[a]; b[f()]&&g()"); } public void testRefChain21() { testSame("var a = 1; var b = 2; var c = a + b; f(c)"); } public void testRefChain22() { test("var a = 2; var b = a = 4; f(a)", "var a = 2; a = 4; f(a)"); } public void testRefChain23() { test("var a = {}; var b = a[1] || f()", "var a = {}; a[1] || f()"); } /** * Expressions that cannot be attributed to any enclosing dependency * scope should be treated as global references. * @bug 1739062 */ public void testAssignmentWithComplexLhs() { testSame("function f() { return this; }" + "var o = {'key': 'val'};" + "f().x_ = o['key'];"); } public void testAssignmentWithComplexLhs2() { testSame("function f() { return this; }" + "var o = {'key': 'val'};" + "f().foo = function() {" + " o" + "};"); } public void testAssignmentWithComplexLhs3() { String source = "var o = {'key': 'val'};" + "function init_() {" + " this.x = o['key']" + "}"; test(source, ""); testSame(source + ";init_()"); } public void testAssignmentWithComplexLhs4() { testSame("function f() { return this; }" + "var o = {'key': 'val'};" + "f().foo = function() {" + " this.x = o['key']" + "};"); } /** * Do not "prototype" property of variables that are not being * tracked (because they are local). * @bug 1809442 */ public void testNoRemovePrototypeDefinitionsOutsideGlobalScope1() { testSame("function f(arg){}" + "" + "(function(){" + " var O = {};" + " O.prototype = 'foo';" + " f(O);" + "})()"); } public void testNoRemovePrototypeDefinitionsOutsideGlobalScope2() { testSame("function f(arg){}" + "(function h(){" + " var L = {};" + " L.prototype = 'foo';" + " f(L);" + "})()"); } public void testNoRemovePrototypeDefinitionsOutsideGlobalScope4() { testSame("function f(arg){}" + "function g(){" + " var N = {};" + " N.prototype = 'foo';" + " f(N);" + "}" + "g()"); } public void testNoRemovePrototypeDefinitionsOutsideGlobalScope5() { // function body not removed due to @bug 1898561 testSame("function g(){ var R = {}; R.prototype = 'foo' } g()"); } public void testRemovePrototypeDefinitionsInGlobalScope1() { testSame("function f(arg){}" + "var M = {};" + "M.prototype = 'foo';" + "f(M);"); } public void testRemovePrototypeDefinitionsInGlobalScope2() { test("var Q = {}; Q.prototype = 'foo'", ""); } public void testRemoveLabeledStatment() { test("LBL: var x = 1;", "LBL: {}"); } public void testRemoveLabeledStatment2() { test("var x; LBL: x = f() + g()", "LBL: { f() ; g()}"); } public void testRemoveLabeledStatment3() { test("var x; LBL: x = 1;", "LBL: {}"); } public void testRemoveLabeledStatment4() { test("var a; LBL: a = f()", "LBL: f()"); } public void testPreservePropertyMutationsToAlias1() { // Test for issue b/2316773 - property get case // Since a is referenced, property mutations via a's alias b must // be preserved. testSame("var a = {}; var b = a; b.x = 1; a"); } public void testPreservePropertyMutationsToAlias2() { // Test for issue b/2316773 - property get case, don't keep 'c' test("var a = {}; var b = a; var c = a; b.x = 1; a", "var a = {}; var b = a; b.x = 1; a"); } public void testPreservePropertyMutationsToAlias3() { // Test for issue b/2316773 - property get case, chain testSame("var a = {}; var b = a; var c = b; c.x = 1; a"); } public void testPreservePropertyMutationsToAlias4() { // Test for issue b/2316773 - element get case testSame("var a = {}; var b = a; b['x'] = 1; a"); } public void testPreservePropertyMutationsToAlias5() { // From issue b/2316773 description testSame("function testCall(o){}" + "var DATA = {'prop': 'foo','attr': {}};" + "var SUBDATA = DATA['attr'];" + "SUBDATA['subprop'] = 'bar';" + "testCall(DATA);"); } public void testPreservePropertyMutationsToAlias6() { // Longer GETELEM chain testSame("function testCall(o){}" + "var DATA = {'prop': 'foo','attr': {}};" + "var SUBDATA = DATA['attr'];" + "var SUBSUBDATA = SUBDATA['subprop'];" + "SUBSUBDATA['subsubprop'] = 'bar';" + "testCall(DATA);"); } public void testPreservePropertyMutationsToAlias7() { // Make sure that the base class does not depend on the derived class. test("var a = {}; var b = {}; b.x = 0;" + "var goog = {}; goog.inherits(b, a); a", "var a = {}; a"); } public void testPreservePropertyMutationsToAlias8() { // Make sure that the derived classes don't end up depending on each other. test("var a = {};" + "var b = {}; b.x = 0;" + "var c = {}; c.y = 0;" + "var goog = {}; goog.inherits(b, a); goog.inherits(c, a); c", "var a = {}; var c = {}; c.y = 0;" + "var goog = {}; goog.inherits(c, a); c"); } public void testPreservePropertyMutationsToAlias9() { testSame("var a = {b: {}};" + "var c = a.b; c.d = 3;" + "a.d = 3; a.d;"); } public void testRemoveAlias() { test("var a = {b: {}};" + "var c = a.b;" + "a.d = 3; a.d;", "var a = {b: {}}; a.d = 3; a.d;"); } public void testSingletonGetter1() { test("function Foo() {} goog.addSingletonGetter(Foo);", ""); } public void testSingletonGetter2() { test("function Foo() {} goog$addSingletonGetter(Foo);", ""); } public void testSingletonGetter3() { // addSingletonGetter adds a getInstance method to a class. testSame("function Foo() {} goog$addSingletonGetter(Foo);" + "this.x = Foo.getInstance();"); } public void testNoRemoveWindowPropertyAlias1() { testSame( "var self_ = window.gbar;\n" + "self_.qs = function() {};"); } public void testNoRemoveWindowPropertyAlias2() { testSame( "var self_ = window;\n" + "self_.qs = function() {};"); } public void testNoRemoveWindowPropertyAlias3() { testSame( "var self_ = window;\n" + "self_['qs'] = function() {};"); } public void testNoRemoveWindowPropertyAlias4() { // TODO(johnlenz): fix this. "self_" should remain. test( "var self_ = window['gbar'] || {};\n" + "self_.qs = function() {};", ""); } public void testNoRemoveWindowPropertyAlias4a() { // TODO(johnlenz): fix this. "self_" should remain. test( "var self_; self_ = window.gbar || {};\n" + "self_.qs = function() {};", ""); } public void testNoRemoveWindowPropertyAlias5() { // TODO(johnlenz): fix this. "self_" should remain. test( "var self_ = window || {};\n" + "self_['qs'] = function() {};", ""); } public void testNoRemoveWindowPropertyAlias5a() { // TODO(johnlenz): fix this. test( "var self_; self_ = window || {};\n" + "self_['qs'] = function() {};", ""); } public void testNoRemoveWindowPropertyAlias6() { testSame( "var self_ = (window.gbar = window.gbar || {});\n" + "self_.qs = function() {};"); } public void testNoRemoveWindowPropertyAlias6a() { testSame( "var self_; self_ = (window.gbar = window.gbar || {});\n" + "self_.qs = function() {};"); } public void testNoRemoveWindowPropertyAlias7() { testSame( "var self_ = (window = window || {});\n" + "self_['qs'] = function() {};"); } public void testNoRemoveWindowPropertyAlias7a() { testSame( "var self_; self_ = (window = window || {});\n" + "self_['qs'] = function() {};"); } public void testNoRemoveAlias0() { testSame( "var x = {}; function f() { return x; }; " + "f().style.display = 'block';" + "alert(x.style)"); } public void testNoRemoveAlias1() { testSame( "var x = {}; function f() { return x; };" + "var map = f();\n" + "map.style.display = 'block';" + "alert(x.style)"); } public void testNoRemoveAlias2() { testSame( "var x = {};" + "var map = (function () { return x; })();\n" + "map.style = 'block';" + "alert(x.style)"); } public void testNoRemoveAlias3() { testSame( "var x = {}; function f() { return x; };" + "var map = {}\n" + "map[1] = f();\n" + "map[1].style.display = 'block';"); } public void testNoRemoveAliasOfExternal0() { testSame( "document.getElementById('foo').style.display = 'block';"); } public void testNoRemoveAliasOfExternal1() { testSame( "var map = document.getElementById('foo');\n" + "map.style.display = 'block';"); } public void testNoRemoveAliasOfExternal2() { testSame( "var map = {}\n" + "map[1] = document.getElementById('foo');\n" + "map[1].style.display = 'block';"); } public void testNoRemoveThrowReference1() { testSame( "var e = {}\n" + "throw e;"); } public void testNoRemoveThrowReference2() { testSame( "function e() {}\n" + "throw new e();"); } public void testClassDefinedInObjectLit1() { test( "var data = {Foo: function() {}};" + "data.Foo.prototype.toString = function() {};", ""); } public void testClassDefinedInObjectLit2() { test( "var data = {}; data.bar = {Foo: function() {}};" + "data.bar.Foo.prototype.toString = function() {};", ""); } public void testClassDefinedInObjectLit3() { test( "var data = {bar: {Foo: function() {}}};" + "data.bar.Foo.prototype.toString = function() {};", ""); } public void testClassDefinedInObjectLit4() { test( "var data = {};" + "data.baz = {bar: {Foo: function() {}}};" + "data.baz.bar.Foo.prototype.toString = function() {};", ""); } public void testVarReferencedInClassDefinedInObjectLit1() { testSame( "var ref = 3;" + "var data = {Foo: function() { this.x = ref; }};" + "window.Foo = data.Foo;"); } public void testVarReferencedInClassDefinedInObjectLit2() { testSame( "var ref = 3;" + "var data = {Foo: function() { this.x = ref; }," + " Bar: function() {}};" + "window.Bar = data.Bar;"); } public void testArrayExt() { testSame( "Array.prototype.foo = function() { return 1 };" + "var y = [];" + "switch (y.foo()) {" + "}"); } public void testArrayAliasExt() { testSame( "Array$X = Array;" + "Array$X.prototype.foo = function() { return 1 };" + "function Array$X() {}" + "var y = [];" + "switch (y.foo()) {" + "}"); } public void testExternalAliasInstanceof1() { test( "Array$X = Array;" + "function Array$X() {}" + "var y = [];" + "if (y instanceof Array) {}", "var y = [];" + "if (y instanceof Array) {}" ); } public void testExternalAliasInstanceof2() { testSame( "Array$X = Array;" + "function Array$X() {}" + "var y = [];" + "if (y instanceof Array$X) {}"); } public void testExternalAliasInstanceof3() { testSame( "var b = Array;" + "var y = [];" + "if (y instanceof b) {}"); } public void testAliasInstanceof4() { testSame( "function Foo() {};" + "var b = Foo;" + "var y = new Foo();" + "if (y instanceof b) {}"); } public void testAliasInstanceof5() { // TODO(johnlenz): fix this. "b" should remain. test( "function Foo() {}" + "function Bar() {}" + "var b = x ? Foo : Bar;" + "var y = new Foo();" + "if (y instanceof b) {}", "function Foo() {}" + "var y = new Foo;" + "if (false){}"); } // We cannot leave x.a.prototype there because it will // fail sanity var check. public void testBrokenNamespaceWithPrototypeAssignment() { test("var x = {}; x.a.prototype = 1", ""); } public void testRemovePrototypeAliases() { test( "function g() {}" + "function F() {} F.prototype.bar = g;" + "window.g = g;", "function g() {}" + "window.g = g;"); } public void testIssue284() { test( "var goog = {};" + "goog.inherits = function(x, y) {};" + "var ns = {};" + "/** @constructor */" + "ns.PageSelectionModel = function() {};" + "/** @constructor */" + "ns.PageSelectionModel.FooEvent = function() {};" + "/** @constructor */" + "ns.PageSelectionModel.SelectEvent = function() {};" + "goog.inherits(ns.PageSelectionModel.ChangeEvent," + " ns.PageSelectionModel.FooEvent);", ""); } public void testIssue838a() { testSame("var z = window['z'] || (window['z'] = {});\n" + "z['hello'] = 'Hello';\n" + "z['world'] = 'World';"); } public void testIssue838b() { testSame( "var z;" + "window['z'] = z || (z = {});\n" + "z['hello'] = 'Hello';\n" + "z['world'] = 'World';"); } public void testIssue874a() { testSame( "var a = a || {};\n" + "var b = a;\n" + "b.View = b.View || {}\n" + "var c = b.View;\n" + "c.Editor = function f(d, e) {\n" + " return d + e\n" + "};\n" + "window.ImageEditor.View.Editor = a.View.Editor;"); } public void testIssue874b() { testSame( "var b;\n" + "var c = b = {};\n" + "c.Editor = function f(d, e) {\n" + " return d + e\n" + "};\n" + "window['Editor'] = b.Editor;"); } public void testIssue874c() { testSame( "var b, c;\n" + "c = b = {};\n" + "c.Editor = function f(d, e) {\n" + " return d + e\n" + "};\n" + "window['Editor'] = b.Editor;"); } public void testIssue874d() { testSame( "var b = {}, c;\n" + "c = b;\n" + "c.Editor = function f(d, e) {\n" + " return d + e\n" + "};\n" + "window['Editor'] = b.Editor;"); } public void testIssue874e() { testSame( "var a;\n" + "var b = a || (a = {});\n" + "var c = b.View || (b.View = {});\n" + "c.Editor = function f(d, e) {\n" + " return d + e\n" + "};\n" + "window.ImageEditor.View.Editor = a.View.Editor;"); } public void testBug6575051() { testSame( "var hackhack = window['__o_o_o__'] = window['__o_o_o__'] || {};\n" + "window['__o_o_o__']['va'] = 1;\n" + "hackhack['Vb'] = 1;"); } @Override protected CompilerPass getProcessor(Compiler compiler) { return new MarkNoSideEffectCallsAndNameAnalyzerRunner(compiler); } private class MarkNoSideEffectCallsAndNameAnalyzerRunner implements CompilerPass { MarkNoSideEffectCalls markNoSideEffectCalls; NameAnalyzer analyzer; MarkNoSideEffectCallsAndNameAnalyzerRunner(Compiler compiler) { this.markNoSideEffectCalls = new MarkNoSideEffectCalls(compiler); this.analyzer = new NameAnalyzer(compiler, true); } @Override public void process(Node externs, Node root) { markNoSideEffectCalls.process(externs, root); analyzer.process(externs, root); } } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.ImmutableMap; /** * Test cases for {@link NameAnonymousFunctionsMapped}. * */ public class NameAnonymousFunctionsMappedTest extends CompilerTestCase { private static final String EXTERNS = "var document;"; private NameAnonymousFunctionsMapped pass; private VariableMap previous; public NameAnonymousFunctionsMappedTest() { super(EXTERNS); } @Override protected int getNumRepetitions() { return 1; } @Override protected void setUp() throws Exception { super.setUp(); previous = null; } @Override public CompilerPass getProcessor(Compiler compiler) { return pass = new NameAnonymousFunctionsMapped(compiler, previous); } private void assertMapping(String... pairs) { VariableMap functionMap = pass.getFunctionMap(); assertTrue(pairs.length % 2 == 0); for (int i = 0; i < pairs.length; i += 2) { String s = functionMap.lookupSourceName(pairs[i]); assertEquals(pairs[i + 1], s); } assertEquals(pairs.length / 2, functionMap.getNewNameToOriginalNameMap().size()); } public void testSimpleVarAssignment1() { test("var a = function() { return 1; }", "var a = function $() { return 1; }"); assertMapping("$", "a"); } public void testSimpleVarAssignment2() { previous = VariableMap.fromMap(ImmutableMap.<String,String>of( "a", "previous")); test("var a = function() { return 1; }", "var a = function previous() { return 1; }"); assertMapping("previous", "a"); } public void testSimpleVarAssignment3() { previous = VariableMap.fromMap(ImmutableMap.<String,String>of( "unused", "$")); test("var fn = function() { return 1; }", "var fn = function $a() { return 1; }"); assertMapping("$a", "fn"); } public void testAssignmentToProperty() { test("var a = {}; a.b = function() { return 1; }", "var a = {}; a.b = function $() { return 1; }"); assertMapping("$", "a.b"); } public void testAssignmentToPrototype() { test("function a() {} a.prototype.b = function() { return 1; };", "function a() {} " + "a.prototype.b = function $() { return 1; };"); assertMapping("$", "a.prototype.b"); } public void testAssignmentToPrototype2() { test("var a = {}; " + "a.b = function() {}; " + "a.b.prototype.c = function() { return 1; };", "var a = {}; " + "a.b = function $() {}; " + "a.b.prototype.c = function $a() { return 1; };"); assertMapping("$", "a.b", "$a", "a.b.prototype.c"); } public void testAssignmentToPrototype3() { test("function a() {} a.prototype['XXX'] = function() { return 1; };", "function a() {} " + "a.prototype['XXX'] = function $() { return 1; };"); assertMapping("$", "a.prototype[\"XXX\"]"); test("function a() {} a.prototype['\\n'] = function() { return 1; };", "function a() {} " + "a.prototype['\\n'] = function $() { return 1; };"); assertMapping("$", "a.prototype[\"\\n\"]"); } public void testAssignmentToPrototype4() { test("var Y = 1; function a() {} " + "a.prototype[Y] = function() { return 1; };", "var Y = 1; function a() {} " + "a.prototype[Y] = function $() { return 1; };"); assertMapping("$", "a.prototype[Y]"); } public void testAssignmentToPrototype5() { test("function a() {} a['prototype'].b = function() { return 1; };", "function a() {} " + "a['prototype'].b = function $() { return 1; };"); assertMapping("$", "a[\"prototype\"].b"); } public void testPrototypeInitializer() { test("function a(){} a.prototype = {b: function() { return 1; }};", "function a(){} " + "a.prototype = {b: function $() { return 1; }};"); assertMapping("$", "a.prototype.b"); } public void testAssignmentToPropertyOfCallReturnValue() { test("document.getElementById('x').onClick = function() {};", "document.getElementById('x').onClick = " + "function $() {};"); assertMapping("$", "document.getElementById(\"x\").onClick"); } public void testAssignmentToPropertyOfArrayElement() { test("var a = {}; a.b = [{}]; a.b[0].c = function() {};", "var a = {}; a.b = [{}]; a.b[0].c = function $() {};"); assertMapping("$", "a.b[0].c"); test("var a = {b: {'c': {}}}; a.b['c'].d = function() {};", "var a = {b: {'c': {}}}; a.b['c'].d = function $() {};"); assertMapping("$", "a.b[\"c\"].d"); test("var a = {b: {'c': {}}}; a.b[x()].d = function() {};", "var a = {b: {'c': {}}}; a.b[x()].d = function $() {};"); assertMapping("$", "a.b[x()].d"); } public void testAssignmentToGetElem() { test("function f() { win['x' + this.id] = function(a){}; }", "function f() { win['x' + this.id] = function $(a){}; }"); // TODO - could probably do a better job encoding these assertMapping("$", "win[\"x\"+this.id]"); } public void testGetElemWithDashes() { test("var foo = {}; foo['-'] = function() {};", "var foo = {}; foo['-'] = function $() {};"); assertMapping("$", "foo[\"-\"]"); } public void testDuplicateNames() { test("var a = function() { return 1; };a = function() { return 2; }", "var a = function $() { return 1; };a = function $() { return 2; }"); assertMapping("$", "a"); } }
/* * Copyright 2006 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Unit test for {@link NameAnonymousFunctionsTest}. * */ public class NameAnonymousFunctionsTest extends CompilerTestCase { private static final String EXTERNS = "var document;"; public NameAnonymousFunctionsTest() { super(EXTERNS); } @Override public CompilerPass getProcessor(Compiler compiler) { return new NameAnonymousFunctions(compiler); } public void testSimpleVarAssignment() { test("var a = function() { return 1; }", "var a = function $a$() { return 1; }"); } public void testAssignmentToProperty() { test("var a = {}; a.b = function() { return 1; }", "var a = {}; a.b = function $a$b$() { return 1; }"); } public void testAssignmentToPrototype() { test("function a() {} a.prototype.b = function() { return 1; };", "function a() {} " + "a.prototype.b = function $a$$b$() { return 1; };"); } public void testAssignmentToPrototype2() { test("var a = {}; " + "a.b = function() {}; " + "a.b.prototype.c = function() { return 1; };", "var a = {}; " + "a.b = function $a$b$() {}; " + "a.b.prototype.c = function $a$b$$c$() { return 1; };"); } public void testAssignmentToPrototype3() { test("function a() {} a.prototype['b'] = function() { return 1; };", "function a() {} " + "a.prototype['b'] = function $a$$b$() { return 1; };"); } public void testAssignmentToPrototype4() { test("function a() {} a['prototype']['b'] = function() { return 1; };", "function a() {} " + "a['prototype']['b'] = function $a$$b$() { return 1; };"); } public void testPrototypeInitializer() { test("function a(){} a.prototype = {b: function() { return 1; }};", "function a(){} " + "a.prototype = {b: function $a$$b$() { return 1; }};"); } public void testMultiplePrototypeInitializer() { test("function a(){} a.prototype = {b: function() { return 1; }, " + "c: function() { return 2; }};", "function a(){} " + "a.prototype = {b: function $a$$b$() { return 1; }," + "c: function $a$$c$() { return 2; }};"); } public void testRecursiveObjectLiteral() { test("function a(){} a.prototype = {b: {c: function() { return 1; }}}", "function a(){}a.prototype={b:{c:function $a$$b$c$(){return 1}}}"); } public void testAssignmentToPropertyOfCallReturnValue() { test("document.getElementById('x').onClick = function() {};", "document.getElementById('x').onClick = " + "function $document$getElementById$onClick$() {};"); } public void testAssignmentToPropertyOfArrayElement() { test("var a = {}; a.b = [{}]; a.b[0].c = function() {};", "var a = {}; a.b = [{}]; a.b[0].c = function $a$b$0$c$() {};"); test("var a = {b: {'c': {}}}; a.b['c'].d = function() {};", "var a = {b: {'c': {}}}; a.b['c'].d = function $a$b$c$d$() {};"); test("var a = {b: {'c': {}}}; a.b[x()].d = function() {};", "var a = {b: {'c': {}}}; a.b[x()].d = function $a$b$x$d$() {};"); } public void testAssignmentToGetElem() { test("function f() {win['x' + this.id] = function(a){};}", "function f() {win['x' + this.id] = function $win$x$this$id$(a){};}"); } public void testGetElemWithDashes() { test("var foo = {}; foo['-'] = function() {};", "var foo = {}; foo['-'] = function $foo$__0$() {};"); } public void testWhatCausedIeToFail() { // If the function was given the name main, for some reason IE failed to // handle this case properly. That's why we give it the name $main$. FF // handled the case fine. test("var main;" + "(function() {" + " main = function() {" + " return 5;" + " };" + "})();" + "" + "main();", "var main;(function(){main=function $main$(){return 5}})();main()"); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.jscomp.NodeIterators.FunctionlessLocalScope; import com.google.javascript.jscomp.NodeIterators.LocalVarMotion; import java.util.Iterator; import java.util.List; import junit.framework.TestCase; /** * Tests for NodeIterators. * @author nicksantos@google.com (Nick Santos) */ public class NodeIteratorsTest extends TestCase { // In each test, we find the declaration of "X" in the local scope, // construct a list of all nodes where X is guaranteed to retain its // original value, and compare those nodes against an expected list of // tokens. public void testBasic() { testVarMotionWithCode("var X = 3;", Token.VAR, Token.SCRIPT); } public void testNamedFunction() { testVarMotionWithCode("var X = 3; function f() {}", Token.VAR, Token.SCRIPT); } public void testNamedFunction2() { testVarMotionWithCode("var X = 3; function f() {} var Y;", Token.VAR, Token.NAME, Token.VAR, Token.SCRIPT); } public void testFunctionExpression() { testVarMotionWithCode("var X = 3, Y = function() {}; 3;", Token.NAME, Token.VAR, Token.NUMBER, Token.EXPR_RESULT, Token.SCRIPT); } public void testFunctionExpression2() { testVarMotionWithCode("var X = 3; var Y = function() {}; 3;", Token.VAR, Token.NAME, Token.VAR, Token.NUMBER, Token.EXPR_RESULT, Token.SCRIPT); } public void testHaltAtVarRef() { testVarMotionWithCode("var X, Y = 3; var Z = X;", Token.NUMBER, Token.NAME, Token.VAR, Token.NAME); } public void testHaltAtVarRef2() { testVarMotionWithCode("var X, Y = 3; (function() {})(3, X);", Token.NUMBER, Token.NAME, Token.VAR, Token.NUMBER, Token.NAME); } public void testHaltAtVarRef3() { testVarMotionWithCode("var X, Y = 3; X;", Token.NUMBER, Token.NAME, Token.VAR, Token.NAME); } public void testHaltAtSideEffects() { testVarMotionWithCode("var X, Y = 3; var Z = B(3);", Token.NUMBER, Token.NAME, Token.VAR, Token.NAME, Token.NUMBER); } public void testHaltAtSideEffects2() { testVarMotionWithCode("var A = 1, X = A, Y = 3; delete A;", Token.NUMBER, Token.NAME, Token.VAR, Token.NAME); } public void testHaltAtSideEffects3() { testVarMotionWithCode("var A = 1, X = A, Y = 3; A++;", Token.NUMBER, Token.NAME, Token.VAR, Token.NAME); } public void testHaltAtSideEffects4() { testVarMotionWithCode("var A = 1, X = A, Y = 3; A--;", Token.NUMBER, Token.NAME, Token.VAR, Token.NAME); } public void testHaltAtSideEffects5() { testVarMotionWithCode("var A = 1, X = A, Y = 3; A = 'a';", Token.NUMBER, Token.NAME, Token.VAR, Token.NAME, Token.STRING); } public void testNoHaltReadWhenValueIsImmutable() { testVarMotionWithCode("var X = 1, Y = 3; alert();", Token.NUMBER, Token.NAME, Token.VAR, Token.NAME); } public void testHaltReadWhenValueHasSideEffects() { testVarMotionWithCode("var X = f(), Y = 3; alert();", Token.NUMBER, Token.NAME, Token.VAR); } public void testCatchBlock() { testVarMotionWithCode("var X = 1; try { 4; } catch (X) {}", Token.VAR, Token.NUMBER, Token.EXPR_RESULT, Token.BLOCK); } public void testIfBranch() { testVarMotionWithCode("var X = foo(); if (X) {}", Token.VAR, Token.NAME); } /** * Parses the given code, finds the variable X in the global scope, and runs * the VarMotion iterator. Asserts that the iteration order matches the * tokens given. */ private void testVarMotionWithCode(String code, int ... expectedTokens) { List<Integer> expectedList = Lists.newArrayList(); for (int token : expectedTokens) { expectedList.add(token); } testVarMotionWithCode(code, expectedList); } /** * @see #testVarMotionWithCode(String, int ...) */ private void testVarMotionWithCode(String code, List<Integer> expectedTokens) { List<Node> ancestors = Lists.newArrayList(); // Add an empty node to the beginning of the code and start there. Node root = (new Compiler()).parseTestCode(";" + code); for (Node n = root; n != null; n = n.getFirstChild()) { ancestors.add(0, n); } FunctionlessLocalScope searchIt = new FunctionlessLocalScope( ancestors.toArray(new Node[ancestors.size()])); boolean found = false; while (searchIt.hasNext()) { Node n = searchIt.next(); if (n.isName() && searchIt.currentParent().isVar() && n.getString().equals("X")) { found = true; break; } } assertTrue("Variable X not found! " + root.toStringTree(), found); List<Node> currentAncestors = searchIt.currentAncestors(); assert(currentAncestors.size() >= 3); Iterator<Node> moveIt = LocalVarMotion.forVar( currentAncestors.get(0), currentAncestors.get(1), currentAncestors.get(2)); List<Integer> actualTokens = Lists.newArrayList(); while (moveIt.hasNext()) { actualTokens.add(moveIt.next().getType()); } assertEquals(expectedTokens, actualTokens); } }
/* * Copyright 2007 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.ImmutableSet; import com.google.javascript.jscomp.NodeTraversal.AbstractNodeTypePruningCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import junit.framework.TestCase; import java.util.ArrayList; import java.util.List; import java.util.Set; /** * Tests for {@link NodeTraversal}. */ public class NodeTraversalTest extends TestCase { public void testPruningCallbackShouldTraverse1() { PruningCallback include = new PruningCallback(ImmutableSet.of(Token.SCRIPT, Token.VAR), true); Node script = new Node(Token.SCRIPT); assertTrue(include.shouldTraverse(null, script, null)); assertTrue(include.shouldTraverse(null, new Node(Token.VAR), null)); assertFalse(include.shouldTraverse(null, new Node(Token.NAME), null)); assertFalse(include.shouldTraverse(null, new Node(Token.ADD), null)); } public void testPruningCallbackShouldTraverse2() { PruningCallback include = new PruningCallback(ImmutableSet.of(Token.SCRIPT, Token.VAR), false); Node script = new Node(Token.SCRIPT); assertFalse(include.shouldTraverse(null, script, null)); assertFalse(include.shouldTraverse(null, new Node(Token.VAR), null)); assertTrue(include.shouldTraverse(null, new Node(Token.NAME), null)); assertTrue(include.shouldTraverse(null, new Node(Token.ADD), null)); } /** * Concrete implementation of AbstractPrunedCallback to test the * AbstractNodeTypePruningCallback shouldTraverse method. */ static class PruningCallback extends AbstractNodeTypePruningCallback { public PruningCallback(Set<Integer> nodeTypes, boolean include) { super(nodeTypes, include); } @Override public void visit(NodeTraversal t, Node n, Node parent) { throw new UnsupportedOperationException(); } } public void testReport() { final List<JSError> errors = new ArrayList<JSError>(); Compiler compiler = new Compiler(new BasicErrorManager() { @Override public void report(CheckLevel level, JSError error) { errors.add(error); } @Override public void println(CheckLevel level, JSError error) { } @Override protected void printSummary() { } }); compiler.initCompilerOptionsIfTesting(); NodeTraversal t = new NodeTraversal(compiler, null); DiagnosticType dt = DiagnosticType.warning("FOO", "{0}, {1} - {2}"); t.report(null, dt, "Foo", "Bar", "Hello"); assertEquals(1, errors.size()); assertEquals("Foo, Bar - Hello", errors.get(0).description); } public void testUnexpectedException() { final String TEST_EXCEPTION = "test me"; NodeTraversal.Callback cb = new NodeTraversal.AbstractPostOrderCallback() { @Override public void visit(NodeTraversal t, Node n, Node parent) { throw new RuntimeException(TEST_EXCEPTION); } }; Compiler compiler = new Compiler(); NodeTraversal t = new NodeTraversal(compiler, cb); String code = "function foo() {}"; Node tree = parse(compiler, code); try { t.traverse(tree); fail("Expected RuntimeException"); } catch (RuntimeException e) { assertTrue(e.getMessage().startsWith( "INTERNAL COMPILER ERROR.\n" + "Please report this problem.\n" + "test me")); } } public void testGetScopeRoot() { Compiler compiler = new Compiler(); NodeTraversal t = new NodeTraversal(compiler, new NodeTraversal.ScopedCallback() { @Override public void enterScope(NodeTraversal t) { Node root1 = t.getScopeRoot(); Node root2 = t.getScope().getRootNode(); assertEquals(root1, root2); } @Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { } } ); String code = "" + "var a; " + "function foo() {" + " var b" + "}"; Node tree = parse(compiler, code); t.traverse(tree); } public void testGetCurrentNode() { Compiler compiler = new Compiler(); ScopeCreator creator = new SyntacticScopeCreator(compiler); ExpectNodeOnEnterScope callback = new ExpectNodeOnEnterScope(); NodeTraversal t = new NodeTraversal(compiler, callback, creator); String code = "" + "var a; " + "function foo() {" + " var b;" + "}"; Node tree = parse(compiler, code); Scope topScope = creator.createScope(tree, null); // Calling #traverseWithScope uses the given scope but starts traversal at // the given node. callback.expect(tree.getFirstChild(), tree); t.traverseWithScope(tree.getFirstChild(), topScope); callback.assertEntered(); // Calling #traverse creates a new scope with the given node as the root. callback.expect(tree.getFirstChild(), tree.getFirstChild()); t.traverse(tree.getFirstChild()); callback.assertEntered(); // Calling #traverseAtScope starts traversal from the scope's root. Node fn = tree.getFirstChild().getNext(); Scope fnScope = creator.createScope(fn, topScope); callback.expect(fn, fn); t.traverseAtScope(fnScope); callback.assertEntered(); } // Helper class used to test getCurrentNode private static class ExpectNodeOnEnterScope implements NodeTraversal.ScopedCallback { private Node node; private Node scopeRoot; private boolean entered = false; private void expect(Node node, Node scopeRoot) { this.node = node; this.scopeRoot = scopeRoot; entered = false; } private void assertEntered() { assertTrue(entered); } @Override public void enterScope(NodeTraversal t) { assertEquals(node, t.getCurrentNode()); assertEquals(scopeRoot, t.getScopeRoot()); entered = true; } @Override public void exitScope(NodeTraversal t) { } @Override public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { } } private static Node parse(Compiler compiler, String js) { Node n = compiler.parseTestCode(js); assertEquals(0, compiler.getErrorCount()); return n; } }
/* * Copyright 2004 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.base.Predicates; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Sets; import com.google.javascript.jscomp.CompilerOptions.LanguageMode; import com.google.javascript.rhino.IR; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.TernaryValue; import junit.framework.TestCase; import java.util.Collection; import java.util.Set; /** * Tests for NodeUtil */ public class NodeUtilTest extends TestCase { private static Node parse(String js) { Compiler compiler = new Compiler(); compiler.initCompilerOptionsIfTesting(); compiler.getOptions().setLanguageIn(LanguageMode.ECMASCRIPT5); Node n = compiler.parseTestCode(js); assertEquals(0, compiler.getErrorCount()); return n; } static Node getNode(String js) { Node root = parse("var a=(" + js + ");"); Node expr = root.getFirstChild(); Node var = expr.getFirstChild(); return var.getFirstChild(); } public void testIsLiteralOrConstValue() { assertLiteralAndImmutable(getNode("10")); assertLiteralAndImmutable(getNode("-10")); assertLiteralButNotImmutable(getNode("[10, 20]")); assertLiteralButNotImmutable(getNode("{'a': 20}")); assertLiteralButNotImmutable(getNode("[10, , 1.0, [undefined], 'a']")); assertLiteralButNotImmutable(getNode("/abc/")); assertLiteralAndImmutable(getNode("\"string\"")); assertLiteralAndImmutable(getNode("'aaa'")); assertLiteralAndImmutable(getNode("null")); assertLiteralAndImmutable(getNode("undefined")); assertLiteralAndImmutable(getNode("void 0")); assertNotLiteral(getNode("abc")); assertNotLiteral(getNode("[10, foo(), 20]")); assertNotLiteral(getNode("foo()")); assertNotLiteral(getNode("c + d")); assertNotLiteral(getNode("{'a': foo()}")); assertNotLiteral(getNode("void foo()")); } public void assertLiteralAndImmutable(Node n) { assertTrue(NodeUtil.isLiteralValue(n, true)); assertTrue(NodeUtil.isLiteralValue(n, false)); assertTrue(NodeUtil.isImmutableValue(n)); } public void assertLiteralButNotImmutable(Node n) { assertTrue(NodeUtil.isLiteralValue(n, true)); assertTrue(NodeUtil.isLiteralValue(n, false)); assertFalse(NodeUtil.isImmutableValue(n)); } public void assertNotLiteral(Node n) { assertFalse(NodeUtil.isLiteralValue(n, true)); assertFalse(NodeUtil.isLiteralValue(n, false)); assertFalse(NodeUtil.isImmutableValue(n)); } public void testGetBooleanValue() { assertPureBooleanTrue("true"); assertPureBooleanTrue("10"); assertPureBooleanTrue("'0'"); assertPureBooleanTrue("/a/"); assertPureBooleanTrue("{}"); assertPureBooleanTrue("[]"); assertPureBooleanFalse("false"); assertPureBooleanFalse("null"); assertPureBooleanFalse("0"); assertPureBooleanFalse("''"); assertPureBooleanFalse("undefined"); assertPureBooleanFalse("void 0"); assertPureBooleanUnknown("void foo()"); assertPureBooleanUnknown("b"); assertPureBooleanUnknown("-'0.0'"); // Known but getBooleanValue return false for expressions with side-effects assertPureBooleanUnknown("{a:foo()}"); assertPureBooleanUnknown("[foo()]"); } private void assertPureBooleanTrue(String val) { assertEquals(TernaryValue.TRUE, NodeUtil.getPureBooleanValue(getNode(val))); } private void assertPureBooleanFalse(String val) { assertEquals( TernaryValue.FALSE, NodeUtil.getPureBooleanValue(getNode(val))); } private void assertPureBooleanUnknown(String val) { assertEquals( TernaryValue.UNKNOWN, NodeUtil.getPureBooleanValue(getNode(val))); } public void testGetExpressionBooleanValue() { assertImpureBooleanTrue("a=true"); assertImpureBooleanFalse("a=false"); assertImpureBooleanTrue("a=(false,true)"); assertImpureBooleanFalse("a=(true,false)"); assertImpureBooleanTrue("a=(false || true)"); assertImpureBooleanFalse("a=(true && false)"); assertImpureBooleanTrue("a=!(true && false)"); assertImpureBooleanTrue("a,true"); assertImpureBooleanFalse("a,false"); assertImpureBooleanTrue("true||false"); assertImpureBooleanFalse("false||false"); assertImpureBooleanTrue("true&&true"); assertImpureBooleanFalse("true&&false"); assertImpureBooleanFalse("!true"); assertImpureBooleanTrue("!false"); assertImpureBooleanTrue("!''"); // Assignment ops other than ASSIGN are unknown. assertImpureBooleanUnknown("a *= 2"); // Complex expressions that contain anything other then "=", ",", or "!" are // unknown. assertImpureBooleanUnknown("2 + 2"); assertImpureBooleanTrue("a=1"); assertImpureBooleanTrue("a=/a/"); assertImpureBooleanTrue("a={}"); assertImpureBooleanTrue("true"); assertImpureBooleanTrue("10"); assertImpureBooleanTrue("'0'"); assertImpureBooleanTrue("/a/"); assertImpureBooleanTrue("{}"); assertImpureBooleanTrue("[]"); assertImpureBooleanFalse("false"); assertImpureBooleanFalse("null"); assertImpureBooleanFalse("0"); assertImpureBooleanFalse("''"); assertImpureBooleanFalse("undefined"); assertImpureBooleanFalse("void 0"); assertImpureBooleanFalse("void foo()"); assertImpureBooleanTrue("a?true:true"); assertImpureBooleanFalse("a?false:false"); assertImpureBooleanUnknown("a?true:false"); assertImpureBooleanUnknown("a?true:foo()"); assertImpureBooleanUnknown("b"); assertImpureBooleanUnknown("-'0.0'"); assertImpureBooleanTrue("{a:foo()}"); assertImpureBooleanTrue("[foo()]"); } private void assertImpureBooleanTrue(String val) { assertEquals(TernaryValue.TRUE, NodeUtil.getImpureBooleanValue(getNode(val))); } private void assertImpureBooleanFalse(String val) { assertEquals(TernaryValue.FALSE, NodeUtil.getImpureBooleanValue(getNode(val))); } private void assertImpureBooleanUnknown(String val) { assertEquals(TernaryValue.UNKNOWN, NodeUtil.getImpureBooleanValue(getNode(val))); } public void testGetStringValue() { assertEquals("true", NodeUtil.getStringValue(getNode("true"))); assertEquals("10", NodeUtil.getStringValue(getNode("10"))); assertEquals("1", NodeUtil.getStringValue(getNode("1.0"))); assertEquals("0", NodeUtil.getStringValue(getNode("'0'"))); assertEquals(null, NodeUtil.getStringValue(getNode("/a/"))); assertEquals("[object Object]", NodeUtil.getStringValue(getNode("{}"))); assertEquals("", NodeUtil.getStringValue(getNode("[]"))); assertEquals("false", NodeUtil.getStringValue(getNode("false"))); assertEquals("null", NodeUtil.getStringValue(getNode("null"))); assertEquals("0", NodeUtil.getStringValue(getNode("0"))); assertEquals("", NodeUtil.getStringValue(getNode("''"))); assertEquals("undefined", NodeUtil.getStringValue(getNode("undefined"))); assertEquals("undefined", NodeUtil.getStringValue(getNode("void 0"))); assertEquals("undefined", NodeUtil.getStringValue(getNode("void foo()"))); assertEquals("NaN", NodeUtil.getStringValue(getNode("NaN"))); assertEquals("Infinity", NodeUtil.getStringValue(getNode("Infinity"))); assertEquals(null, NodeUtil.getStringValue(getNode("x"))); } public void testGetArrayStringValue() { assertEquals("", NodeUtil.getStringValue(getNode("[]"))); assertEquals("", NodeUtil.getStringValue(getNode("['']"))); assertEquals("", NodeUtil.getStringValue(getNode("[null]"))); assertEquals("", NodeUtil.getStringValue(getNode("[undefined]"))); assertEquals("", NodeUtil.getStringValue(getNode("[void 0]"))); assertEquals("NaN", NodeUtil.getStringValue(getNode("[NaN]"))); assertEquals(",", NodeUtil.getStringValue(getNode("[,'']"))); assertEquals(",,", NodeUtil.getStringValue(getNode("[[''],[''],['']]"))); assertEquals("1,2", NodeUtil.getStringValue(getNode("[[1.0],[2.0]]"))); assertEquals(null, NodeUtil.getStringValue(getNode("[a]"))); assertEquals(null, NodeUtil.getStringValue(getNode("[1,a]"))); } public void testIsObjectLiteralKey1() throws Exception { testIsObjectLiteralKey( parseExpr("({})"), false); testIsObjectLiteralKey( parseExpr("a"), false); testIsObjectLiteralKey( parseExpr("'a'"), false); testIsObjectLiteralKey( parseExpr("1"), false); testIsObjectLiteralKey( parseExpr("({a: 1})").getFirstChild(), true); testIsObjectLiteralKey( parseExpr("({1: 1})").getFirstChild(), true); testIsObjectLiteralKey( parseExpr("({get a(){}})").getFirstChild(), true); testIsObjectLiteralKey( parseExpr("({set a(b){}})").getFirstChild(), true); } private Node parseExpr(String js) { Compiler compiler = new Compiler(); CompilerOptions options = new CompilerOptions(); options.setLanguageIn(LanguageMode.ECMASCRIPT5); compiler.initOptions(options); Node root = compiler.parseTestCode(js); return root.getFirstChild().getFirstChild(); } private void testIsObjectLiteralKey(Node node, boolean expected) { assertEquals(expected, NodeUtil.isObjectLitKey(node, node.getParent())); } public void testGetFunctionName1() throws Exception { Compiler compiler = new Compiler(); Node parent = compiler.parseTestCode("function name(){}"); testGetFunctionName(parent.getFirstChild(), "name"); } public void testGetFunctionName2() throws Exception { Compiler compiler = new Compiler(); Node parent = compiler.parseTestCode("var name = function(){}") .getFirstChild().getFirstChild(); testGetFunctionName(parent.getFirstChild(), "name"); } public void testGetFunctionName3() throws Exception { Compiler compiler = new Compiler(); Node parent = compiler.parseTestCode("qualified.name = function(){}") .getFirstChild().getFirstChild(); testGetFunctionName(parent.getLastChild(), "qualified.name"); } public void testGetFunctionName4() throws Exception { Compiler compiler = new Compiler(); Node parent = compiler.parseTestCode("var name2 = function name1(){}") .getFirstChild().getFirstChild(); testGetFunctionName(parent.getFirstChild(), "name2"); } public void testGetFunctionName5() throws Exception { Compiler compiler = new Compiler(); Node n = compiler.parseTestCode("qualified.name2 = function name1(){}"); Node parent = n.getFirstChild().getFirstChild(); testGetFunctionName(parent.getLastChild(), "qualified.name2"); } private void testGetFunctionName(Node function, String name) { assertEquals(Token.FUNCTION, function.getType()); assertEquals(name, NodeUtil.getFunctionName(function)); } public void testContainsFunctionDeclaration() { assertTrue(NodeUtil.containsFunction( getNode("function foo(){}"))); assertTrue(NodeUtil.containsFunction( getNode("(b?function(){}:null)"))); assertFalse(NodeUtil.containsFunction( getNode("(b?foo():null)"))); assertFalse(NodeUtil.containsFunction( getNode("foo()"))); } private void assertSideEffect(boolean se, String js) { Node n = parse(js); assertEquals(se, NodeUtil.mayHaveSideEffects(n.getFirstChild())); } private void assertSideEffect(boolean se, String js, boolean globalRegExp) { Node n = parse(js); Compiler compiler = new Compiler(); compiler.setHasRegExpGlobalReferences(globalRegExp); assertEquals(se, NodeUtil.mayHaveSideEffects(n.getFirstChild(), compiler)); } public void testMayHaveSideEffects() { assertSideEffect(true, "i++"); assertSideEffect(true, "[b, [a, i++]]"); assertSideEffect(true, "i=3"); assertSideEffect(true, "[0, i=3]"); assertSideEffect(true, "b()"); assertSideEffect(true, "[1, b()]"); assertSideEffect(true, "b.b=4"); assertSideEffect(true, "b.b--"); assertSideEffect(true, "i--"); assertSideEffect(true, "a[0][i=4]"); assertSideEffect(true, "a += 3"); assertSideEffect(true, "a, b, z += 4"); assertSideEffect(true, "a ? c : d++"); assertSideEffect(true, "a + c++"); assertSideEffect(true, "a + c - d()"); assertSideEffect(true, "a + c - d()"); assertSideEffect(true, "function foo() {}"); assertSideEffect(true, "while(true);"); assertSideEffect(true, "if(true){a()}"); assertSideEffect(false, "if(true){a}"); assertSideEffect(false, "(function() { })"); assertSideEffect(false, "(function() { i++ })"); assertSideEffect(false, "[function a(){}]"); assertSideEffect(false, "a"); assertSideEffect(false, "[b, c [d, [e]]]"); assertSideEffect(false, "({a: x, b: y, c: z})"); assertSideEffect(false, "/abc/gi"); assertSideEffect(false, "'a'"); assertSideEffect(false, "0"); assertSideEffect(false, "a + c"); assertSideEffect(false, "'c' + a[0]"); assertSideEffect(false, "a[0][1]"); assertSideEffect(false, "'a' + c"); assertSideEffect(false, "'a' + a.name"); assertSideEffect(false, "1, 2, 3"); assertSideEffect(false, "a, b, 3"); assertSideEffect(false, "(function(a, b) { })"); assertSideEffect(false, "a ? c : d"); assertSideEffect(false, "'1' + navigator.userAgent"); assertSideEffect(false, "new RegExp('foobar', 'i')"); assertSideEffect(true, "new RegExp(SomethingWacky(), 'i')"); assertSideEffect(false, "new Array()"); assertSideEffect(false, "new Array"); assertSideEffect(false, "new Array(4)"); assertSideEffect(false, "new Array('a', 'b', 'c')"); assertSideEffect(true, "new SomeClassINeverHeardOf()"); assertSideEffect(true, "new SomeClassINeverHeardOf()"); assertSideEffect(false, "({}).foo = 4"); assertSideEffect(false, "([]).foo = 4"); assertSideEffect(false, "(function() {}).foo = 4"); assertSideEffect(true, "this.foo = 4"); assertSideEffect(true, "a.foo = 4"); assertSideEffect(true, "(function() { return n; })().foo = 4"); assertSideEffect(true, "([]).foo = bar()"); assertSideEffect(false, "undefined"); assertSideEffect(false, "void 0"); assertSideEffect(true, "void foo()"); assertSideEffect(false, "-Infinity"); assertSideEffect(false, "Infinity"); assertSideEffect(false, "NaN"); assertSideEffect(false, "({}||[]).foo = 2;"); assertSideEffect(false, "(true ? {} : []).foo = 2;"); assertSideEffect(false, "({},[]).foo = 2;"); assertSideEffect(true, "delete a.b"); } public void testObjectMethodSideEffects() { // "toString" and "valueOf" are assumed to be side-effect free assertSideEffect(false, "o.toString()"); assertSideEffect(false, "o.valueOf()"); // other methods depend on the extern definitions assertSideEffect(true, "o.watch()"); } public void testRegExpSideEffect() { // A RegExp Object by itself doesn't have any side-effects assertSideEffect(false, "/abc/gi", true); assertSideEffect(false, "/abc/gi", false); // RegExp instance methods have global side-effects, so whether they are // considered side-effect free depends on whether the global properties // are referenced. assertSideEffect(true, "(/abc/gi).test('')", true); assertSideEffect(false, "(/abc/gi).test('')", false); assertSideEffect(true, "(/abc/gi).test(a)", true); assertSideEffect(false, "(/abc/gi).test(b)", false); assertSideEffect(true, "(/abc/gi).exec('')", true); assertSideEffect(false, "(/abc/gi).exec('')", false); // Some RegExp object method that may have side-effects. assertSideEffect(true, "(/abc/gi).foo('')", true); assertSideEffect(true, "(/abc/gi).foo('')", false); // Try the string RegExp ops. assertSideEffect(true, "''.match('a')", true); assertSideEffect(false, "''.match('a')", false); assertSideEffect(true, "''.match(/(a)/)", true); assertSideEffect(false, "''.match(/(a)/)", false); assertSideEffect(true, "''.replace('a')", true); assertSideEffect(false, "''.replace('a')", false); assertSideEffect(true, "''.search('a')", true); assertSideEffect(false, "''.search('a')", false); assertSideEffect(true, "''.split('a')", true); assertSideEffect(false, "''.split('a')", false); // Some non-RegExp string op that may have side-effects. assertSideEffect(true, "''.foo('a')", true); assertSideEffect(true, "''.foo('a')", false); // 'a' might be a RegExp object with the 'g' flag, in which case // the state might change by running any of the string ops. // Specifically, using these methods resets the "lastIndex" if used // in combination with a RegExp instance "exec" method. assertSideEffect(true, "''.match(a)", true); assertSideEffect(true, "''.match(a)", false); } private void assertMutableState(boolean se, String js) { Node n = parse(js); assertEquals(se, NodeUtil.mayEffectMutableState(n.getFirstChild())); } public void testMayEffectMutableState() { assertMutableState(true, "i++"); assertMutableState(true, "[b, [a, i++]]"); assertMutableState(true, "i=3"); assertMutableState(true, "[0, i=3]"); assertMutableState(true, "b()"); assertMutableState(true, "void b()"); assertMutableState(true, "[1, b()]"); assertMutableState(true, "b.b=4"); assertMutableState(true, "b.b--"); assertMutableState(true, "i--"); assertMutableState(true, "a[0][i=4]"); assertMutableState(true, "a += 3"); assertMutableState(true, "a, b, z += 4"); assertMutableState(true, "a ? c : d++"); assertMutableState(true, "a + c++"); assertMutableState(true, "a + c - d()"); assertMutableState(true, "a + c - d()"); assertMutableState(true, "function foo() {}"); assertMutableState(true, "while(true);"); assertMutableState(true, "if(true){a()}"); assertMutableState(false, "if(true){a}"); assertMutableState(true, "(function() { })"); assertMutableState(true, "(function() { i++ })"); assertMutableState(true, "[function a(){}]"); assertMutableState(false, "a"); assertMutableState(true, "[b, c [d, [e]]]"); assertMutableState(true, "({a: x, b: y, c: z})"); // Note: RegExp objects are not immutable, for instance, the exec // method maintains state for "global" searches. assertMutableState(true, "/abc/gi"); assertMutableState(false, "'a'"); assertMutableState(false, "0"); assertMutableState(false, "a + c"); assertMutableState(false, "'c' + a[0]"); assertMutableState(false, "a[0][1]"); assertMutableState(false, "'a' + c"); assertMutableState(false, "'a' + a.name"); assertMutableState(false, "1, 2, 3"); assertMutableState(false, "a, b, 3"); assertMutableState(true, "(function(a, b) { })"); assertMutableState(false, "a ? c : d"); assertMutableState(false, "'1' + navigator.userAgent"); assertMutableState(true, "new RegExp('foobar', 'i')"); assertMutableState(true, "new RegExp(SomethingWacky(), 'i')"); assertMutableState(true, "new Array()"); assertMutableState(true, "new Array"); assertMutableState(true, "new Array(4)"); assertMutableState(true, "new Array('a', 'b', 'c')"); assertMutableState(true, "new SomeClassINeverHeardOf()"); } public void testIsFunctionExpression() { assertContainsAnonFunc(true, "(function(){})"); assertContainsAnonFunc(true, "[function a(){}]"); assertContainsAnonFunc(false, "{x: function a(){}}"); assertContainsAnonFunc(true, "(function a(){})()"); assertContainsAnonFunc(true, "x = function a(){};"); assertContainsAnonFunc(true, "var x = function a(){};"); assertContainsAnonFunc(true, "if (function a(){});"); assertContainsAnonFunc(true, "while (function a(){});"); assertContainsAnonFunc(true, "do; while (function a(){});"); assertContainsAnonFunc(true, "for (function a(){};;);"); assertContainsAnonFunc(true, "for (;function a(){};);"); assertContainsAnonFunc(true, "for (;;function a(){});"); assertContainsAnonFunc(true, "for (p in function a(){});"); assertContainsAnonFunc(true, "with (function a(){}) {}"); assertContainsAnonFunc(false, "function a(){}"); assertContainsAnonFunc(false, "if (x) function a(){};"); assertContainsAnonFunc(false, "if (x) { function a(){} }"); assertContainsAnonFunc(false, "if (x); else function a(){};"); assertContainsAnonFunc(false, "while (x) function a(){};"); assertContainsAnonFunc(false, "do function a(){} while (0);"); assertContainsAnonFunc(false, "for (;;) function a(){}"); assertContainsAnonFunc(false, "for (p in o) function a(){};"); assertContainsAnonFunc(false, "with (x) function a(){}"); } private void assertContainsAnonFunc(boolean expected, String js) { Node funcParent = findParentOfFuncDescendant(parse(js)); assertNotNull("Expected function node in parse tree of: " + js, funcParent); Node funcNode = getFuncChild(funcParent); assertEquals(expected, NodeUtil.isFunctionExpression(funcNode)); } private Node findParentOfFuncDescendant(Node n) { for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (c.isFunction()) { return n; } Node result = findParentOfFuncDescendant(c); if (result != null) { return result; } } return null; } private Node getFuncChild(Node n) { for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (c.isFunction()) { return c; } } return null; } public void testContainsType() { assertTrue(NodeUtil.containsType( parse("this"), Token.THIS)); assertTrue(NodeUtil.containsType( parse("function foo(){}(this)"), Token.THIS)); assertTrue(NodeUtil.containsType( parse("b?this:null"), Token.THIS)); assertFalse(NodeUtil.containsType( parse("a"), Token.THIS)); assertFalse(NodeUtil.containsType( parse("function foo(){}"), Token.THIS)); assertFalse(NodeUtil.containsType( parse("(b?foo():null)"), Token.THIS)); } public void testReferencesThis() { assertTrue(NodeUtil.referencesThis( parse("this"))); // Don't descend into functions (starts at the script node) assertFalse(NodeUtil.referencesThis( parse("function foo(){this}"))); // But starting with a function properly check for 'this' Node n = parse("function foo(){this}").getFirstChild(); assertEquals(n.getType(), Token.FUNCTION); assertTrue(NodeUtil.referencesThis(n)); assertTrue(NodeUtil.referencesThis( parse("b?this:null"))); assertFalse(NodeUtil.referencesThis( parse("a"))); n = parse("function foo(){}").getFirstChild(); assertEquals(n.getType(), Token.FUNCTION); assertFalse(NodeUtil.referencesThis(n)); assertFalse(NodeUtil.referencesThis( parse("(b?foo():null)"))); } public void testGetNodeTypeReferenceCount() { assertEquals(0, NodeUtil.getNodeTypeReferenceCount( parse("function foo(){}"), Token.THIS, Predicates.<Node>alwaysTrue())); assertEquals(1, NodeUtil.getNodeTypeReferenceCount( parse("this"), Token.THIS, Predicates.<Node>alwaysTrue())); assertEquals(2, NodeUtil.getNodeTypeReferenceCount( parse("this;function foo(){}(this)"), Token.THIS, Predicates.<Node>alwaysTrue())); } public void testIsNameReferenceCount() { assertTrue(NodeUtil.isNameReferenced( parse("function foo(){}"), "foo")); assertTrue(NodeUtil.isNameReferenced( parse("var foo = function(){}"), "foo")); assertFalse(NodeUtil.isNameReferenced( parse("function foo(){}"), "undefined")); assertTrue(NodeUtil.isNameReferenced( parse("undefined"), "undefined")); assertTrue(NodeUtil.isNameReferenced( parse("undefined;function foo(){}(undefined)"), "undefined")); assertTrue(NodeUtil.isNameReferenced( parse("goo.foo"), "goo")); assertFalse(NodeUtil.isNameReferenced( parse("goo.foo"), "foo")); } public void testGetNameReferenceCount() { assertEquals(0, NodeUtil.getNameReferenceCount( parse("function foo(){}"), "undefined")); assertEquals(1, NodeUtil.getNameReferenceCount( parse("undefined"), "undefined")); assertEquals(2, NodeUtil.getNameReferenceCount( parse("undefined;function foo(){}(undefined)"), "undefined")); assertEquals(1, NodeUtil.getNameReferenceCount( parse("goo.foo"), "goo")); assertEquals(0, NodeUtil.getNameReferenceCount( parse("goo.foo"), "foo")); assertEquals(1, NodeUtil.getNameReferenceCount( parse("function foo(){}"), "foo")); assertEquals(1, NodeUtil.getNameReferenceCount( parse("var foo = function(){}"), "foo")); } public void testGetVarsDeclaredInBranch() { Compiler compiler = new Compiler(); assertNodeNames(Sets.newHashSet("foo"), NodeUtil.getVarsDeclaredInBranch( parse("var foo;"))); assertNodeNames(Sets.newHashSet("foo", "goo"), NodeUtil.getVarsDeclaredInBranch( parse("var foo,goo;"))); assertNodeNames(Sets.<String>newHashSet(), NodeUtil.getVarsDeclaredInBranch( parse("foo();"))); assertNodeNames(Sets.<String>newHashSet(), NodeUtil.getVarsDeclaredInBranch( parse("function f(){var foo;}"))); assertNodeNames(Sets.newHashSet("goo"), NodeUtil.getVarsDeclaredInBranch( parse("var goo;function f(){var foo;}"))); } private void assertNodeNames(Set<String> nodeNames, Collection<Node> nodes) { Set<String> actualNames = Sets.newHashSet(); for (Node node : nodes) { actualNames.add(node.getString()); } assertEquals(nodeNames, actualNames); } public void testIsControlStructureCodeBlock() { Node root = parse("if (x) foo(); else boo();"); Node ifNode = root.getFirstChild(); Node ifCondition = ifNode.getFirstChild(); Node ifCase = ifNode.getFirstChild().getNext(); Node elseCase = ifNode.getLastChild(); assertFalse(NodeUtil.isControlStructureCodeBlock(ifNode, ifCondition)); assertTrue(NodeUtil.isControlStructureCodeBlock(ifNode, ifCase)); assertTrue(NodeUtil.isControlStructureCodeBlock(ifNode, elseCase)); } public void testIsFunctionExpression1() { Node root = parse("(function foo() {})"); Node statementNode = root.getFirstChild(); assertTrue(statementNode.isExprResult()); Node functionNode = statementNode.getFirstChild(); assertTrue(functionNode.isFunction()); assertTrue(NodeUtil.isFunctionExpression(functionNode)); } public void testIsFunctionExpression2() { Node root = parse("function foo() {}"); Node functionNode = root.getFirstChild(); assertTrue(functionNode.isFunction()); assertFalse(NodeUtil.isFunctionExpression(functionNode)); } public void testRemoveChildBlock() { // Test removing the inner block. Node actual = parse("{{x()}}"); Node outerBlockNode = actual.getFirstChild(); Node innerBlockNode = outerBlockNode.getFirstChild(); innerBlockNode.setIsSyntheticBlock(true); NodeUtil.removeChild(outerBlockNode, innerBlockNode); String expected = "{{}}"; String difference = parse(expected).checkTreeEquals(actual); if (difference != null) { assertTrue("Nodes do not match:\n" + difference, false); } } public void testRemoveTryChild1() { // Test removing the finally clause. Node actual = parse("try {foo()} catch(e) {} finally {}"); Node tryNode = actual.getFirstChild(); Node tryBlock = tryNode.getFirstChild(); Node catchBlocks = tryNode.getFirstChild().getNext(); Node finallyBlock = tryNode.getLastChild(); NodeUtil.removeChild(tryNode, finallyBlock); String expected = "try {foo()} catch(e) {}"; String difference = parse(expected).checkTreeEquals(actual); if (difference != null) { assertTrue("Nodes do not match:\n" + difference, false); } } public void testRemoveTryChild2() { // Test removing the try clause. Node actual = parse("try {foo()} catch(e) {} finally {}"); Node tryNode = actual.getFirstChild(); Node tryBlock = tryNode.getFirstChild(); Node catchBlocks = tryNode.getFirstChild().getNext(); NodeUtil.removeChild(tryNode, tryBlock); String expected = "try {} catch(e) {} finally {}"; String difference = parse(expected).checkTreeEquals(actual); if (difference != null) { assertTrue("Nodes do not match:\n" + difference, false); } } public void testRemoveTryChild3() { // Test removing the catch clause. Node actual = parse("try {foo()} catch(e) {} finally {}"); Node tryNode = actual.getFirstChild(); Node tryBlock = tryNode.getFirstChild(); Node catchBlocks = tryNode.getFirstChild().getNext(); Node catchBlock = catchBlocks.getFirstChild(); Node finallyBlock = tryNode.getLastChild(); NodeUtil.removeChild(catchBlocks, catchBlock); String expected = "try {foo()} finally {}"; String difference = parse(expected).checkTreeEquals(actual); if (difference != null) { assertTrue("Nodes do not match:\n" + difference, false); } } public void testRemoveTryChild4() { // Test removing the catch clause without a finally. Node actual = parse("try {foo()} catch(e) {} finally {}"); Node tryNode = actual.getFirstChild(); Node tryBlock = tryNode.getFirstChild(); Node catchBlocks = tryNode.getFirstChild().getNext(); Node catchBlock = catchBlocks.getFirstChild(); Node finallyBlock = tryNode.getLastChild(); NodeUtil.removeChild(tryNode, catchBlocks); String expected = "try {foo()} finally {}"; String difference = parse(expected).checkTreeEquals(actual); if (difference != null) { assertTrue("Nodes do not match:\n" + difference, false); } } public void testRemoveTryChild5() { Node actual = parse("try {foo()} catch(e) {} finally {}"); Node tryNode = actual.getFirstChild(); Node tryBlock = tryNode.getFirstChild(); Node catchBlocks = tryNode.getFirstChild().getNext(); Node catchBlock = catchBlocks.getFirstChild(); Node finallyBlock = tryNode.getLastChild(); NodeUtil.removeChild(catchBlocks, catchBlock); String expected = "try {foo()} finally {}"; String difference = parse(expected).checkTreeEquals(actual); if (difference != null) { assertTrue("Nodes do not match:\n" + difference, false); } } public void testRemoveVarChild() { Compiler compiler = new Compiler(); // Test removing the first child. Node actual = parse("var foo, goo, hoo"); Node varNode = actual.getFirstChild(); Node nameNode = varNode.getFirstChild(); NodeUtil.removeChild(varNode, nameNode); String expected = "var goo, hoo"; String difference = parse(expected).checkTreeEquals(actual); if (difference != null) { assertTrue("Nodes do not match:\n" + difference, false); } // Test removing the second child. actual = parse("var foo, goo, hoo"); varNode = actual.getFirstChild(); nameNode = varNode.getFirstChild().getNext(); NodeUtil.removeChild(varNode, nameNode); expected = "var foo, hoo"; difference = parse(expected).checkTreeEquals(actual); if (difference != null) { assertTrue("Nodes do not match:\n" + difference, false); } // Test removing the last child of several children. actual = parse("var foo, hoo"); varNode = actual.getFirstChild(); nameNode = varNode.getFirstChild().getNext(); NodeUtil.removeChild(varNode, nameNode); expected = "var foo"; difference = parse(expected).checkTreeEquals(actual); if (difference != null) { assertTrue("Nodes do not match:\n" + difference, false); } // Test removing the last. actual = parse("var hoo"); varNode = actual.getFirstChild(); nameNode = varNode.getFirstChild(); NodeUtil.removeChild(varNode, nameNode); expected = ""; difference = parse(expected).checkTreeEquals(actual); if (difference != null) { assertTrue("Nodes do not match:\n" + difference, false); } } public void testRemoveLabelChild1() { Compiler compiler = new Compiler(); // Test removing the first child. Node actual = parse("foo: goo()"); Node labelNode = actual.getFirstChild(); Node callExpressNode = labelNode.getLastChild(); NodeUtil.removeChild(labelNode, callExpressNode); String expected = ""; String difference = parse(expected).checkTreeEquals(actual); if (difference != null) { assertTrue("Nodes do not match:\n" + difference, false); } } public void testRemoveLabelChild2() { // Test removing the first child. Node actual = parse("achoo: foo: goo()"); Node labelNode = actual.getFirstChild(); Node callExpressNode = labelNode.getLastChild(); NodeUtil.removeChild(labelNode, callExpressNode); String expected = ""; String difference = parse(expected).checkTreeEquals(actual); if (difference != null) { assertTrue("Nodes do not match:\n" + difference, false); } } public void testRemoveForChild() { Compiler compiler = new Compiler(); // Test removing the initializer. Node actual = parse("for(var a=0;a<0;a++)foo()"); Node forNode = actual.getFirstChild(); Node child = forNode.getFirstChild(); NodeUtil.removeChild(forNode, child); String expected = "for(;a<0;a++)foo()"; String difference = parse(expected).checkTreeEquals(actual); assertNull("Nodes do not match:\n" + difference, difference); // Test removing the condition. actual = parse("for(var a=0;a<0;a++)foo()"); forNode = actual.getFirstChild(); child = forNode.getFirstChild().getNext(); NodeUtil.removeChild(forNode, child); expected = "for(var a=0;;a++)foo()"; difference = parse(expected).checkTreeEquals(actual); assertNull("Nodes do not match:\n" + difference, difference); // Test removing the increment. actual = parse("for(var a=0;a<0;a++)foo()"); forNode = actual.getFirstChild(); child = forNode.getFirstChild().getNext().getNext(); NodeUtil.removeChild(forNode, child); expected = "for(var a=0;a<0;)foo()"; difference = parse(expected).checkTreeEquals(actual); assertNull("Nodes do not match:\n" + difference, difference); // Test removing the body. actual = parse("for(var a=0;a<0;a++)foo()"); forNode = actual.getFirstChild(); child = forNode.getLastChild(); NodeUtil.removeChild(forNode, child); expected = "for(var a=0;a<0;a++);"; difference = parse(expected).checkTreeEquals(actual); assertNull("Nodes do not match:\n" + difference, difference); // Test removing the body. actual = parse("for(a in ack)foo();"); forNode = actual.getFirstChild(); child = forNode.getLastChild(); NodeUtil.removeChild(forNode, child); expected = "for(a in ack);"; difference = parse(expected).checkTreeEquals(actual); assertNull("Nodes do not match:\n" + difference, difference); } public void testMergeBlock1() { Compiler compiler = new Compiler(); // Test removing the initializer. Node actual = parse("{{a();b();}}"); Node parentBlock = actual.getFirstChild(); Node childBlock = parentBlock.getFirstChild(); assertTrue(NodeUtil.tryMergeBlock(childBlock)); String expected = "{a();b();}"; String difference = parse(expected).checkTreeEquals(actual); assertNull("Nodes do not match:\n" + difference, difference); } public void testMergeBlock2() { Compiler compiler = new Compiler(); // Test removing the initializer. Node actual = parse("foo:{a();}"); Node parentLabel = actual.getFirstChild(); Node childBlock = parentLabel.getLastChild(); assertFalse(NodeUtil.tryMergeBlock(childBlock)); } public void testMergeBlock3() { Compiler compiler = new Compiler(); // Test removing the initializer. String code = "foo:{a();boo()}"; Node actual = parse("foo:{a();boo()}"); Node parentLabel = actual.getFirstChild(); Node childBlock = parentLabel.getLastChild(); assertFalse(NodeUtil.tryMergeBlock(childBlock)); String expected = code; String difference = parse(expected).checkTreeEquals(actual); assertNull("Nodes do not match:\n" + difference, difference); } public void testGetSourceName() { Node n = new Node(Token.BLOCK); Node parent = new Node(Token.BLOCK, n); parent.setSourceFileForTesting("foo"); assertEquals("foo", NodeUtil.getSourceName(n)); } public void testLocalValue1() throws Exception { // Names are not known to be local. assertFalse(testLocalValue("x")); assertFalse(testLocalValue("x()")); assertFalse(testLocalValue("this")); assertFalse(testLocalValue("arguments")); // We can't know if new objects are local unless we know // that they don't alias themselves. assertFalse(testLocalValue("new x()")); // property references are assume to be non-local assertFalse(testLocalValue("(new x()).y")); assertFalse(testLocalValue("(new x())['y']")); // Primitive values are local assertTrue(testLocalValue("null")); assertTrue(testLocalValue("undefined")); assertTrue(testLocalValue("Infinity")); assertTrue(testLocalValue("NaN")); assertTrue(testLocalValue("1")); assertTrue(testLocalValue("'a'")); assertTrue(testLocalValue("true")); assertTrue(testLocalValue("false")); assertTrue(testLocalValue("[]")); assertTrue(testLocalValue("{}")); // The contents of arrays and objects don't matter assertTrue(testLocalValue("[x]")); assertTrue(testLocalValue("{'a':x}")); // Pre-increment results in primitive number assertTrue(testLocalValue("++x")); assertTrue(testLocalValue("--x")); // Post-increment, the previous value matters. assertFalse(testLocalValue("x++")); assertFalse(testLocalValue("x--")); // The left side of an only assign matters if it is an alias or mutable. assertTrue(testLocalValue("x=1")); assertFalse(testLocalValue("x=[]")); assertFalse(testLocalValue("x=y")); // The right hand side of assignment opts don't matter, as they force // a local result. assertTrue(testLocalValue("x+=y")); assertTrue(testLocalValue("x*=y")); // Comparisons always result in locals, as they force a local boolean // result. assertTrue(testLocalValue("x==y")); assertTrue(testLocalValue("x!=y")); assertTrue(testLocalValue("x>y")); // Only the right side of a comma matters assertTrue(testLocalValue("(1,2)")); assertTrue(testLocalValue("(x,1)")); assertFalse(testLocalValue("(x,y)")); // Both the operands of OR matter assertTrue(testLocalValue("1||2")); assertFalse(testLocalValue("x||1")); assertFalse(testLocalValue("x||y")); assertFalse(testLocalValue("1||y")); // Both the operands of AND matter assertTrue(testLocalValue("1&&2")); assertFalse(testLocalValue("x&&1")); assertFalse(testLocalValue("x&&y")); assertFalse(testLocalValue("1&&y")); // Only the results of HOOK matter assertTrue(testLocalValue("x?1:2")); assertFalse(testLocalValue("x?x:2")); assertFalse(testLocalValue("x?1:x")); assertFalse(testLocalValue("x?x:y")); // Results of ops are local values assertTrue(testLocalValue("!y")); assertTrue(testLocalValue("~y")); assertTrue(testLocalValue("y + 1")); assertTrue(testLocalValue("y + z")); assertTrue(testLocalValue("y * z")); assertTrue(testLocalValue("'a' in x")); assertTrue(testLocalValue("typeof x")); assertTrue(testLocalValue("x instanceof y")); assertTrue(testLocalValue("void x")); assertTrue(testLocalValue("void 0")); assertFalse(testLocalValue("{}.x")); assertTrue(testLocalValue("{}.toString()")); assertTrue(testLocalValue("o.toString()")); assertFalse(testLocalValue("o.valueOf()")); assertTrue(testLocalValue("delete a.b")); } public void testLocalValue2() { Node newExpr = getNode("new x()"); assertFalse(NodeUtil.evaluatesToLocalValue(newExpr)); Preconditions.checkState(newExpr.isNew()); Node.SideEffectFlags flags = new Node.SideEffectFlags(); flags.clearAllFlags(); newExpr.setSideEffectFlags(flags.valueOf()); assertTrue(NodeUtil.evaluatesToLocalValue(newExpr)); flags.clearAllFlags(); flags.setMutatesThis(); newExpr.setSideEffectFlags(flags.valueOf()); assertTrue(NodeUtil.evaluatesToLocalValue(newExpr)); flags.clearAllFlags(); flags.setReturnsTainted(); newExpr.setSideEffectFlags(flags.valueOf()); assertTrue(NodeUtil.evaluatesToLocalValue(newExpr)); flags.clearAllFlags(); flags.setThrows(); newExpr.setSideEffectFlags(flags.valueOf()); assertFalse(NodeUtil.evaluatesToLocalValue(newExpr)); flags.clearAllFlags(); flags.setMutatesArguments(); newExpr.setSideEffectFlags(flags.valueOf()); assertFalse(NodeUtil.evaluatesToLocalValue(newExpr)); flags.clearAllFlags(); flags.setMutatesGlobalState(); newExpr.setSideEffectFlags(flags.valueOf()); assertFalse(NodeUtil.evaluatesToLocalValue(newExpr)); } public void testCallSideEffects() { Node callExpr = getNode("new x().method()"); assertTrue(NodeUtil.functionCallHasSideEffects(callExpr)); Node newExpr = callExpr.getFirstChild().getFirstChild(); Preconditions.checkState(newExpr.isNew()); Node.SideEffectFlags flags = new Node.SideEffectFlags(); // No side effects, local result flags.clearAllFlags(); newExpr.setSideEffectFlags(flags.valueOf()); flags.clearAllFlags(); callExpr.setSideEffectFlags(flags.valueOf()); assertTrue(NodeUtil.evaluatesToLocalValue(callExpr)); assertFalse(NodeUtil.functionCallHasSideEffects(callExpr)); assertFalse(NodeUtil.mayHaveSideEffects(callExpr)); // Modifies this, local result flags.clearAllFlags(); newExpr.setSideEffectFlags(flags.valueOf()); flags.clearAllFlags(); flags.setMutatesThis(); callExpr.setSideEffectFlags(flags.valueOf()); assertTrue(NodeUtil.evaluatesToLocalValue(callExpr)); assertFalse(NodeUtil.functionCallHasSideEffects(callExpr)); assertFalse(NodeUtil.mayHaveSideEffects(callExpr)); // Modifies this, non-local result flags.clearAllFlags(); newExpr.setSideEffectFlags(flags.valueOf()); flags.clearAllFlags(); flags.setMutatesThis(); flags.setReturnsTainted(); callExpr.setSideEffectFlags(flags.valueOf()); assertFalse(NodeUtil.evaluatesToLocalValue(callExpr)); assertFalse(NodeUtil.functionCallHasSideEffects(callExpr)); assertFalse(NodeUtil.mayHaveSideEffects(callExpr)); // No modifications, non-local result flags.clearAllFlags(); newExpr.setSideEffectFlags(flags.valueOf()); flags.clearAllFlags(); flags.setReturnsTainted(); callExpr.setSideEffectFlags(flags.valueOf()); assertFalse(NodeUtil.evaluatesToLocalValue(callExpr)); assertFalse(NodeUtil.functionCallHasSideEffects(callExpr)); assertFalse(NodeUtil.mayHaveSideEffects(callExpr)); // The new modifies global state, no side-effect call, non-local result // This call could be removed, but not the new. flags.clearAllFlags(); flags.setMutatesGlobalState(); newExpr.setSideEffectFlags(flags.valueOf()); flags.clearAllFlags(); callExpr.setSideEffectFlags(flags.valueOf()); assertTrue(NodeUtil.evaluatesToLocalValue(callExpr)); assertFalse(NodeUtil.functionCallHasSideEffects(callExpr)); assertTrue(NodeUtil.mayHaveSideEffects(callExpr)); } private boolean testLocalValue(String js) { return NodeUtil.evaluatesToLocalValue(getNode(js)); } public void testValidDefine() { assertTrue(testValidDefineValue("1")); assertTrue(testValidDefineValue("-3")); assertTrue(testValidDefineValue("true")); assertTrue(testValidDefineValue("false")); assertTrue(testValidDefineValue("'foo'")); assertFalse(testValidDefineValue("x")); assertFalse(testValidDefineValue("null")); assertFalse(testValidDefineValue("undefined")); assertFalse(testValidDefineValue("NaN")); assertTrue(testValidDefineValue("!true")); assertTrue(testValidDefineValue("-true")); assertTrue(testValidDefineValue("1 & 8")); assertTrue(testValidDefineValue("1 + 8")); assertTrue(testValidDefineValue("'a' + 'b'")); assertFalse(testValidDefineValue("1 & foo")); } private boolean testValidDefineValue(String js) { Node script = parse("var test = " + js + ";"); Node var = script.getFirstChild(); Node name = var.getFirstChild(); Node value = name.getFirstChild(); ImmutableSet<String> defines = ImmutableSet.of(); return NodeUtil.isValidDefineValue(value, defines); } public void testGetNumberValue() { // Strings assertEquals(1.0, NodeUtil.getNumberValue(getNode("'\\uFEFF1'"))); assertEquals(0.0, NodeUtil.getNumberValue(getNode("''"))); assertEquals(0.0, NodeUtil.getNumberValue(getNode("' '"))); assertEquals(0.0, NodeUtil.getNumberValue(getNode("' \\t'"))); assertEquals(0.0, NodeUtil.getNumberValue(getNode("'+0'"))); assertEquals(-0.0, NodeUtil.getNumberValue(getNode("'-0'"))); assertEquals(2.0, NodeUtil.getNumberValue(getNode("'+2'"))); assertEquals(-1.6, NodeUtil.getNumberValue(getNode("'-1.6'"))); assertEquals(16.0, NodeUtil.getNumberValue(getNode("'16'"))); assertEquals(16.0, NodeUtil.getNumberValue(getNode("' 16 '"))); assertEquals(16.0, NodeUtil.getNumberValue(getNode("' 16 '"))); assertEquals(12300.0, NodeUtil.getNumberValue(getNode("'123e2'"))); assertEquals(12300.0, NodeUtil.getNumberValue(getNode("'123E2'"))); assertEquals(1.23, NodeUtil.getNumberValue(getNode("'123e-2'"))); assertEquals(1.23, NodeUtil.getNumberValue(getNode("'123E-2'"))); assertEquals(-1.23, NodeUtil.getNumberValue(getNode("'-123e-2'"))); assertEquals(-1.23, NodeUtil.getNumberValue(getNode("'-123E-2'"))); assertEquals(1.23, NodeUtil.getNumberValue(getNode("'+123e-2'"))); assertEquals(1.23, NodeUtil.getNumberValue(getNode("'+123E-2'"))); assertEquals(12300.0, NodeUtil.getNumberValue(getNode("'+123e+2'"))); assertEquals(12300.0, NodeUtil.getNumberValue(getNode("'+123E+2'"))); assertEquals(15.0, NodeUtil.getNumberValue(getNode("'0xf'"))); assertEquals(15.0, NodeUtil.getNumberValue(getNode("'0xF'"))); // Chrome and rhino behavior differently from FF and IE. FF and IE // consider a negative hex number to be invalid assertEquals(null, NodeUtil.getNumberValue(getNode("'-0xf'"))); assertEquals(null, NodeUtil.getNumberValue(getNode("'-0xF'"))); assertEquals(null, NodeUtil.getNumberValue(getNode("'+0xf'"))); assertEquals(null, NodeUtil.getNumberValue(getNode("'+0xF'"))); assertEquals(16.0, NodeUtil.getNumberValue(getNode("'0X10'"))); assertEquals(Double.NaN, NodeUtil.getNumberValue(getNode("'0X10.8'"))); assertEquals(77.0, NodeUtil.getNumberValue(getNode("'077'"))); assertEquals(-77.0, NodeUtil.getNumberValue(getNode("'-077'"))); assertEquals(-77.5, NodeUtil.getNumberValue(getNode("'-077.5'"))); assertEquals( Double.NEGATIVE_INFINITY, NodeUtil.getNumberValue(getNode("'-Infinity'"))); assertEquals( Double.POSITIVE_INFINITY, NodeUtil.getNumberValue(getNode("'Infinity'"))); assertEquals( Double.POSITIVE_INFINITY, NodeUtil.getNumberValue(getNode("'+Infinity'"))); // Firefox treats "infinity" as "Infinity", IE treats it as NaN assertEquals(null, NodeUtil.getNumberValue(getNode("'-infinity'"))); assertEquals(null, NodeUtil.getNumberValue(getNode("'infinity'"))); assertEquals(null, NodeUtil.getNumberValue(getNode("'+infinity'"))); assertEquals(Double.NaN, NodeUtil.getNumberValue(getNode("'NaN'"))); assertEquals( Double.NaN, NodeUtil.getNumberValue(getNode("'some unknown string'"))); assertEquals(Double.NaN, NodeUtil.getNumberValue(getNode("'123 blah'"))); // Literals assertEquals(1.0, NodeUtil.getNumberValue(getNode("1"))); // "-1" is parsed as a literal assertEquals(-1.0, NodeUtil.getNumberValue(getNode("-1"))); // "+1" is parse as an op + literal assertEquals(null, NodeUtil.getNumberValue(getNode("+1"))); assertEquals(22.0, NodeUtil.getNumberValue(getNode("22"))); assertEquals(18.0, NodeUtil.getNumberValue(getNode("022"))); assertEquals(34.0, NodeUtil.getNumberValue(getNode("0x22"))); assertEquals( 1.0, NodeUtil.getNumberValue(getNode("true"))); assertEquals( 0.0, NodeUtil.getNumberValue(getNode("false"))); assertEquals( 0.0, NodeUtil.getNumberValue(getNode("null"))); assertEquals( Double.NaN, NodeUtil.getNumberValue(getNode("void 0"))); assertEquals( Double.NaN, NodeUtil.getNumberValue(getNode("void f"))); // values with side-effects are ignored. assertEquals( null, NodeUtil.getNumberValue(getNode("void f()"))); assertEquals( Double.NaN, NodeUtil.getNumberValue(getNode("NaN"))); assertEquals( Double.POSITIVE_INFINITY, NodeUtil.getNumberValue(getNode("Infinity"))); assertEquals( Double.NEGATIVE_INFINITY, NodeUtil.getNumberValue(getNode("-Infinity"))); // "infinity" is not a known name. assertEquals(null, NodeUtil.getNumberValue(getNode("infinity"))); assertEquals(null, NodeUtil.getNumberValue(getNode("-infinity"))); // getNumberValue only converts literals assertEquals(null, NodeUtil.getNumberValue(getNode("x"))); assertEquals(null, NodeUtil.getNumberValue(getNode("x.y"))); assertEquals(null, NodeUtil.getNumberValue(getNode("1/2"))); assertEquals(null, NodeUtil.getNumberValue(getNode("1-2"))); assertEquals(null, NodeUtil.getNumberValue(getNode("+1"))); } public void testIsNumbericResult() { assertTrue(NodeUtil.isNumericResult(getNode("1"))); assertFalse(NodeUtil.isNumericResult(getNode("true"))); assertTrue(NodeUtil.isNumericResult(getNode("+true"))); assertTrue(NodeUtil.isNumericResult(getNode("+1"))); assertTrue(NodeUtil.isNumericResult(getNode("-1"))); assertTrue(NodeUtil.isNumericResult(getNode("-Infinity"))); assertTrue(NodeUtil.isNumericResult(getNode("Infinity"))); assertTrue(NodeUtil.isNumericResult(getNode("NaN"))); assertFalse(NodeUtil.isNumericResult(getNode("undefined"))); assertFalse(NodeUtil.isNumericResult(getNode("void 0"))); assertTrue(NodeUtil.isNumericResult(getNode("a << b"))); assertTrue(NodeUtil.isNumericResult(getNode("a >> b"))); assertTrue(NodeUtil.isNumericResult(getNode("a >>> b"))); assertFalse(NodeUtil.isNumericResult(getNode("a == b"))); assertFalse(NodeUtil.isNumericResult(getNode("a != b"))); assertFalse(NodeUtil.isNumericResult(getNode("a === b"))); assertFalse(NodeUtil.isNumericResult(getNode("a !== b"))); assertFalse(NodeUtil.isNumericResult(getNode("a < b"))); assertFalse(NodeUtil.isNumericResult(getNode("a > b"))); assertFalse(NodeUtil.isNumericResult(getNode("a <= b"))); assertFalse(NodeUtil.isNumericResult(getNode("a >= b"))); assertFalse(NodeUtil.isNumericResult(getNode("a in b"))); assertFalse(NodeUtil.isNumericResult(getNode("a instanceof b"))); assertFalse(NodeUtil.isNumericResult(getNode("'a'"))); assertFalse(NodeUtil.isNumericResult(getNode("'a'+b"))); assertFalse(NodeUtil.isNumericResult(getNode("a+'b'"))); assertFalse(NodeUtil.isNumericResult(getNode("a+b"))); assertFalse(NodeUtil.isNumericResult(getNode("a()"))); assertFalse(NodeUtil.isNumericResult(getNode("''.a"))); assertFalse(NodeUtil.isNumericResult(getNode("a.b"))); assertFalse(NodeUtil.isNumericResult(getNode("a.b()"))); assertFalse(NodeUtil.isNumericResult(getNode("a().b()"))); assertFalse(NodeUtil.isNumericResult(getNode("new a()"))); // Definitely not numeric assertFalse(NodeUtil.isNumericResult(getNode("([1,2])"))); assertFalse(NodeUtil.isNumericResult(getNode("({a:1})"))); // Recurse into the expression when necessary. assertTrue(NodeUtil.isNumericResult(getNode("1 && 2"))); assertTrue(NodeUtil.isNumericResult(getNode("1 || 2"))); assertTrue(NodeUtil.isNumericResult(getNode("a ? 2 : 3"))); assertTrue(NodeUtil.isNumericResult(getNode("a,1"))); assertTrue(NodeUtil.isNumericResult(getNode("a=1"))); } public void testIsBooleanResult() { assertFalse(NodeUtil.isBooleanResult(getNode("1"))); assertTrue(NodeUtil.isBooleanResult(getNode("true"))); assertFalse(NodeUtil.isBooleanResult(getNode("+true"))); assertFalse(NodeUtil.isBooleanResult(getNode("+1"))); assertFalse(NodeUtil.isBooleanResult(getNode("-1"))); assertFalse(NodeUtil.isBooleanResult(getNode("-Infinity"))); assertFalse(NodeUtil.isBooleanResult(getNode("Infinity"))); assertFalse(NodeUtil.isBooleanResult(getNode("NaN"))); assertFalse(NodeUtil.isBooleanResult(getNode("undefined"))); assertFalse(NodeUtil.isBooleanResult(getNode("void 0"))); assertFalse(NodeUtil.isBooleanResult(getNode("a << b"))); assertFalse(NodeUtil.isBooleanResult(getNode("a >> b"))); assertFalse(NodeUtil.isBooleanResult(getNode("a >>> b"))); assertTrue(NodeUtil.isBooleanResult(getNode("a == b"))); assertTrue(NodeUtil.isBooleanResult(getNode("a != b"))); assertTrue(NodeUtil.isBooleanResult(getNode("a === b"))); assertTrue(NodeUtil.isBooleanResult(getNode("a !== b"))); assertTrue(NodeUtil.isBooleanResult(getNode("a < b"))); assertTrue(NodeUtil.isBooleanResult(getNode("a > b"))); assertTrue(NodeUtil.isBooleanResult(getNode("a <= b"))); assertTrue(NodeUtil.isBooleanResult(getNode("a >= b"))); assertTrue(NodeUtil.isBooleanResult(getNode("a in b"))); assertTrue(NodeUtil.isBooleanResult(getNode("a instanceof b"))); assertFalse(NodeUtil.isBooleanResult(getNode("'a'"))); assertFalse(NodeUtil.isBooleanResult(getNode("'a'+b"))); assertFalse(NodeUtil.isBooleanResult(getNode("a+'b'"))); assertFalse(NodeUtil.isBooleanResult(getNode("a+b"))); assertFalse(NodeUtil.isBooleanResult(getNode("a()"))); assertFalse(NodeUtil.isBooleanResult(getNode("''.a"))); assertFalse(NodeUtil.isBooleanResult(getNode("a.b"))); assertFalse(NodeUtil.isBooleanResult(getNode("a.b()"))); assertFalse(NodeUtil.isBooleanResult(getNode("a().b()"))); assertFalse(NodeUtil.isBooleanResult(getNode("new a()"))); assertTrue(NodeUtil.isBooleanResult(getNode("delete a"))); // Definitely not boolean assertFalse(NodeUtil.isBooleanResult(getNode("([true,false])"))); assertFalse(NodeUtil.isBooleanResult(getNode("({a:true})"))); // These are boolean but aren't handled yet, "false" here means "unknown". assertTrue(NodeUtil.isBooleanResult(getNode("true && false"))); assertTrue(NodeUtil.isBooleanResult(getNode("true || false"))); assertTrue(NodeUtil.isBooleanResult(getNode("a ? true : false"))); assertTrue(NodeUtil.isBooleanResult(getNode("a,true"))); assertTrue(NodeUtil.isBooleanResult(getNode("a=true"))); assertFalse(NodeUtil.isBooleanResult(getNode("a=1"))); } public void testMayBeString() { assertFalse(NodeUtil.mayBeString(getNode("1"))); assertFalse(NodeUtil.mayBeString(getNode("true"))); assertFalse(NodeUtil.mayBeString(getNode("+true"))); assertFalse(NodeUtil.mayBeString(getNode("+1"))); assertFalse(NodeUtil.mayBeString(getNode("-1"))); assertFalse(NodeUtil.mayBeString(getNode("-Infinity"))); assertFalse(NodeUtil.mayBeString(getNode("Infinity"))); assertFalse(NodeUtil.mayBeString(getNode("NaN"))); assertFalse(NodeUtil.mayBeString(getNode("undefined"))); assertFalse(NodeUtil.mayBeString(getNode("void 0"))); assertFalse(NodeUtil.mayBeString(getNode("null"))); assertFalse(NodeUtil.mayBeString(getNode("a << b"))); assertFalse(NodeUtil.mayBeString(getNode("a >> b"))); assertFalse(NodeUtil.mayBeString(getNode("a >>> b"))); assertFalse(NodeUtil.mayBeString(getNode("a == b"))); assertFalse(NodeUtil.mayBeString(getNode("a != b"))); assertFalse(NodeUtil.mayBeString(getNode("a === b"))); assertFalse(NodeUtil.mayBeString(getNode("a !== b"))); assertFalse(NodeUtil.mayBeString(getNode("a < b"))); assertFalse(NodeUtil.mayBeString(getNode("a > b"))); assertFalse(NodeUtil.mayBeString(getNode("a <= b"))); assertFalse(NodeUtil.mayBeString(getNode("a >= b"))); assertFalse(NodeUtil.mayBeString(getNode("a in b"))); assertFalse(NodeUtil.mayBeString(getNode("a instanceof b"))); assertTrue(NodeUtil.mayBeString(getNode("'a'"))); assertTrue(NodeUtil.mayBeString(getNode("'a'+b"))); assertTrue(NodeUtil.mayBeString(getNode("a+'b'"))); assertTrue(NodeUtil.mayBeString(getNode("a+b"))); assertTrue(NodeUtil.mayBeString(getNode("a()"))); assertTrue(NodeUtil.mayBeString(getNode("''.a"))); assertTrue(NodeUtil.mayBeString(getNode("a.b"))); assertTrue(NodeUtil.mayBeString(getNode("a.b()"))); assertTrue(NodeUtil.mayBeString(getNode("a().b()"))); assertTrue(NodeUtil.mayBeString(getNode("new a()"))); // These can't be strings but they aren't handled yet. assertFalse(NodeUtil.mayBeString(getNode("1 && 2"))); assertFalse(NodeUtil.mayBeString(getNode("1 || 2"))); assertFalse(NodeUtil.mayBeString(getNode("1 ? 2 : 3"))); assertFalse(NodeUtil.mayBeString(getNode("1,2"))); assertFalse(NodeUtil.mayBeString(getNode("a=1"))); assertFalse(NodeUtil.mayBeString(getNode("1+1"))); assertFalse(NodeUtil.mayBeString(getNode("true+true"))); assertFalse(NodeUtil.mayBeString(getNode("null+null"))); assertFalse(NodeUtil.mayBeString(getNode("NaN+NaN"))); // These are not strings but they aren't primitives either assertTrue(NodeUtil.mayBeString(getNode("([1,2])"))); assertTrue(NodeUtil.mayBeString(getNode("({a:1})"))); assertTrue(NodeUtil.mayBeString(getNode("({}+1)"))); assertTrue(NodeUtil.mayBeString(getNode("(1+{})"))); assertTrue(NodeUtil.mayBeString(getNode("([]+1)"))); assertTrue(NodeUtil.mayBeString(getNode("(1+[])"))); } public void testValidNames() { assertTrue(NodeUtil.isValidPropertyName("a")); assertTrue(NodeUtil.isValidPropertyName("a3")); assertFalse(NodeUtil.isValidPropertyName("3a")); assertFalse(NodeUtil.isValidPropertyName("a.")); assertFalse(NodeUtil.isValidPropertyName(".a")); assertFalse(NodeUtil.isValidPropertyName("a.b")); assertFalse(NodeUtil.isValidPropertyName("true")); assertFalse(NodeUtil.isValidPropertyName("a.true")); assertFalse(NodeUtil.isValidPropertyName("a..b")); assertTrue(NodeUtil.isValidSimpleName("a")); assertTrue(NodeUtil.isValidSimpleName("a3")); assertFalse(NodeUtil.isValidSimpleName("3a")); assertFalse(NodeUtil.isValidSimpleName("a.")); assertFalse(NodeUtil.isValidSimpleName(".a")); assertFalse(NodeUtil.isValidSimpleName("a.b")); assertFalse(NodeUtil.isValidSimpleName("true")); assertFalse(NodeUtil.isValidSimpleName("a.true")); assertFalse(NodeUtil.isValidSimpleName("a..b")); assertTrue(NodeUtil.isValidQualifiedName("a")); assertTrue(NodeUtil.isValidQualifiedName("a3")); assertFalse(NodeUtil.isValidQualifiedName("3a")); assertFalse(NodeUtil.isValidQualifiedName("a.")); assertFalse(NodeUtil.isValidQualifiedName(".a")); assertTrue(NodeUtil.isValidQualifiedName("a.b")); assertFalse(NodeUtil.isValidQualifiedName("true")); assertFalse(NodeUtil.isValidQualifiedName("a.true")); assertFalse(NodeUtil.isValidQualifiedName("a..b")); } public void testGetNearestFunctionName() { testFunctionName("(function() {})()", null); testFunctionName("function a() {}", "a"); testFunctionName("(function a() {})", "a"); testFunctionName("({a:function () {}})", "a"); testFunctionName("({get a() {}})", "a"); testFunctionName("({set a(b) {}})", "a"); testFunctionName("({set a(b) {}})", "a"); testFunctionName("({1:function () {}})", "1"); testFunctionName("var a = function a() {}", "a"); testFunctionName("var a;a = function a() {}", "a"); testFunctionName("var o;o.a = function a() {}", "o.a"); testFunctionName("this.a = function a() {}", "this.a"); } public void testGetBestLValue() { assertEquals("x", getFunctionLValue("var x = function() {};")); assertEquals("x", getFunctionLValue("x = function() {};")); assertEquals("x", getFunctionLValue("function x() {};")); assertEquals("x", getFunctionLValue("var x = y ? z : function() {};")); assertEquals("x", getFunctionLValue("var x = y ? function() {} : z;")); assertEquals("x", getFunctionLValue("var x = y && function() {};")); assertEquals("x", getFunctionLValue("var x = y || function() {};")); assertEquals("x", getFunctionLValue("var x = (y, function() {});")); } public void testIsNaN() { assertEquals(true, NodeUtil.isNaN(getNode("NaN"))); assertEquals(false, NodeUtil.isNaN(getNode("Infinity"))); assertEquals(false, NodeUtil.isNaN(getNode("x"))); assertEquals(true, NodeUtil.isNaN(getNode("0/0"))); assertEquals(false, NodeUtil.isNaN(getNode("1/0"))); assertEquals(false, NodeUtil.isNaN(getNode("0/1"))); assertEquals(false, NodeUtil.isNaN(IR.number(0.0))); } public void testIsExecutedExactlyOnce() { assertEquals(true, executedOnceTestCase("x;")); assertEquals(true, executedOnceTestCase("x && 1;")); assertEquals(false, executedOnceTestCase("1 && x;")); assertEquals(false, executedOnceTestCase("1 && (x && 1);")); assertEquals(true, executedOnceTestCase("x || 1;")); assertEquals(false, executedOnceTestCase("1 || x;")); assertEquals(false, executedOnceTestCase("1 && (x || 1);")); assertEquals(true, executedOnceTestCase("x ? 1 : 2;")); assertEquals(false, executedOnceTestCase("1 ? 1 : x;")); assertEquals(false, executedOnceTestCase("1 ? x : 2;")); assertEquals(false, executedOnceTestCase("1 && (x ? 1 : 2);")); assertEquals(true, executedOnceTestCase("if (x) {}")); assertEquals(false, executedOnceTestCase("if (true) {x;}")); assertEquals(false, executedOnceTestCase("if (true) {} else {x;}")); assertEquals(false, executedOnceTestCase("if (1) { if (x) {} }")); assertEquals(true, executedOnceTestCase("for(x;;){}")); assertEquals(false, executedOnceTestCase("for(;x;){}")); assertEquals(false, executedOnceTestCase("for(;;x){}")); assertEquals(false, executedOnceTestCase("for(;;){x;}")); assertEquals(false, executedOnceTestCase("if (1) { for(x;;){} }")); assertEquals(false, executedOnceTestCase("for(x in {}){}")); assertEquals(true, executedOnceTestCase("for({}.a in x){}")); assertEquals(false, executedOnceTestCase("for({}.a in {}){x}")); assertEquals(false, executedOnceTestCase("if (1) { for(x in {}){} }")); assertEquals(true, executedOnceTestCase("switch (x) {}")); assertEquals(false, executedOnceTestCase("switch (1) {case x:}")); assertEquals(false, executedOnceTestCase("switch (1) {case 1: x}")); assertEquals(false, executedOnceTestCase("switch (1) {default: x}")); assertEquals(false, executedOnceTestCase("if (1) { switch (x) {} }")); assertEquals(false, executedOnceTestCase("while (x) {}")); assertEquals(false, executedOnceTestCase("while (1) {x}")); assertEquals(false, executedOnceTestCase("do {} while (x)")); assertEquals(false, executedOnceTestCase("do {x} while (1)")); assertEquals(false, executedOnceTestCase("try {x} catch (e) {}")); assertEquals(false, executedOnceTestCase("try {} catch (e) {x}")); assertEquals(true, executedOnceTestCase("try {} finally {x}")); assertEquals(false, executedOnceTestCase("if (1) { try {} finally {x} }")); } private boolean executedOnceTestCase(String code) { Node ast = parse(code); Node nameNode = getNameNode(ast, "x"); return NodeUtil.isExecutedExactlyOnce(nameNode); } private String getFunctionLValue(String js) { Node lVal = NodeUtil.getBestLValue(getFunctionNode(js)); return lVal == null ? null : lVal.getString(); } static void testFunctionName(String js, String expected) { assertEquals( expected, NodeUtil.getNearestFunctionName(getFunctionNode(js))); } static Node getFunctionNode(String js) { Node root = parse(js); return getFunctionNode(root); } static Node getFunctionNode(Node n) { if (n.isFunction()) { return n; } for (Node c : n.children()) { Node result = getFunctionNode(c); if (result != null) { return result; } } return null; } static Node getNameNode(Node n, String name) { if (n.isName() && n.getString().equals(name)) { return n; } for (Node c : n.children()) { Node result = getNameNode(c, name); if (result != null) { return result; } } return null; } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.rhino.Node; import java.util.Set; /** * @author johnlenz@google.com (John Lenz) * */ public class NormalizeTest extends CompilerTestCase { private static final String EXTERNS = "var window;"; public NormalizeTest() { super(EXTERNS); super.enableLineNumberCheck(true); } @Override public CompilerPass getProcessor(final Compiler compiler) { return new Normalize(compiler, false); } @Override protected int getNumRepetitions() { // The normalize pass is only run once. return 1; } public void testSplitVar() { testSame("var a"); test("var a, b", "var a; var b"); test("var a, b, c", "var a; var b; var c"); testSame("var a = 0 "); test("var a = 0 , b = foo()", "var a = 0; var b = foo()"); test("var a = 0, b = 1, c = 2", "var a = 0; var b = 1; var c = 2"); test("var a = foo(1), b = foo(2), c = foo(3)", "var a = foo(1); var b = foo(2); var c = foo(3)"); // Verify vars extracted from FOR nodes are split. test("for(var a = 0, b = foo(1), c = 1; c < b; c++) foo(2)", "var a = 0; var b = foo(1); var c = 1; for(; c < b; c++) foo(2)"); // Verify split vars properly introduce blocks when needed. test("for(;;) var b = foo(1), c = foo(2);", "for(;;){var b = foo(1); var c = foo(2)}"); test("for(;;){var b = foo(1), c = foo(2);}", "for(;;){var b = foo(1); var c = foo(2)}"); test("try{var b = foo(1), c = foo(2);} finally foo(3);", "try{var b = foo(1); var c = foo(2)} finally foo(3);"); test("try{var b = foo(1),c = foo(2);} finally;", "try{var b = foo(1); var c = foo(2)} finally;"); test("try{foo(0);} finally var b = foo(1), c = foo(2);", "try{foo(0);} finally {var b = foo(1); var c = foo(2)}"); test("switch(a) {default: var b = foo(1), c = foo(2); break;}", "switch(a) {default: var b = foo(1); var c = foo(2); break;}"); test("do var a = foo(1), b; while(false);", "do{var a = foo(1); var b} while(false);"); test("a:var a,b,c;", "a:{ var a;var b; var c; }"); test("a:for(var a,b,c;;);", "var a;var b; var c;a:for(;;);"); test("if (true) a:var a,b;", "if (true)a:{ var a; var b; }"); } public void testDuplicateVarInExterns() { test("var extern;", "/** @suppress {duplicate} */ var extern = 3;", "var extern = 3;", null, null); } public void testUnhandled() { testSame("var x = y = 1"); } public void testFor() { // Verify assignments are extracted from the FOR init node. test("for(a = 0; a < 2 ; a++) foo();", "a = 0; for(; a < 2 ; a++) foo()"); // Verify vars are extracted from the FOR init node. test("for(var a = 0; c < b ; c++) foo()", "var a = 0; for(; c < b ; c++) foo()"); // Verify vars are extracted from the FOR init before the label node. test("a:for(var a = 0; c < b ; c++) foo()", "var a = 0; a:for(; c < b ; c++) foo()"); // Verify vars are extracted from the FOR init before the labels node. test("a:b:for(var a = 0; c < b ; c++) foo()", "var a = 0; a:b:for(; c < b ; c++) foo()"); // Verify block are properly introduced for ifs. test("if(x) for(var a = 0; c < b ; c++) foo()", "if(x){var a = 0; for(; c < b ; c++) foo()}"); // Any other expression. test("for(init(); a < 2 ; a++) foo();", "init(); for(; a < 2 ; a++) foo()"); } public void testForIn1() { // Verify nothing happens with simple for-in testSame("for(a in b) foo();"); // Verify vars are extracted from the FOR-IN node. test("for(var a in b) foo()", "var a; for(a in b) foo()"); // Verify vars are extracted from the FOR init before the label node. test("a:for(var a in b) foo()", "var a; a:for(a in b) foo()"); // Verify vars are extracted from the FOR init before the labels node. test("a:b:for(var a in b) foo()", "var a; a:b:for(a in b) foo()"); // Verify block are properly introduced for ifs. test("if (x) for(var a in b) foo()", "if (x) { var a; for(a in b) foo() }"); } public void testForIn2() { // Verify vars are extracted from the FOR-IN node. test("for(var a = foo() in b) foo()", "var a = foo(); for(a in b) foo()"); } public void testWhile() { // Verify while loops are converted to FOR loops. test("while(c < b) foo()", "for(; c < b;) foo()"); } public void testMoveFunctions1() throws Exception { test("function f() { if (x) return; foo(); function foo() {} }", "function f() {function foo() {} if (x) return; foo(); }"); test("function f() { " + "function foo() {} " + "if (x) return;" + "foo(); " + "function bar() {} " + "}", "function f() {" + "function foo() {}" + "function bar() {}" + "if (x) return;" + "foo();" + "}"); } public void testMoveFunctions2() throws Exception { testSame("function f() { function foo() {} }"); test("function f() { f(); a:function bar() {} }", "function f() { f(); a:{ var bar = function () {} }}"); test("function f() { f(); {function bar() {}}}", "function f() { f(); {var bar = function () {}}}"); test("function f() { f(); if (true) {function bar() {}}}", "function f() { f(); if (true) {var bar = function () {}}}"); } private String inFunction(String code) { return "(function(){" + code + "})"; } private void testSameInFunction(String code) { testSame(inFunction(code)); } private void testInFunction(String code, String expected) { test(inFunction(code), inFunction(expected)); } public void testNormalizeFunctionDeclarations() throws Exception { testSame("function f() {}"); testSame("var f = function () {}"); test("var f = function f() {}", "var f = function f$$1() {}"); testSame("var f = function g() {}"); test("a:function g() {}", "a:{ var g = function () {} }"); test("{function g() {}}", "{var g = function () {}}"); testSame("if (function g() {}) {}"); test("if (true) {function g() {}}", "if (true) {var g = function () {}}"); test("if (true) {} else {function g() {}}", "if (true) {} else {var g = function () {}}"); testSame("switch (function g() {}) {}"); test("switch (1) { case 1: function g() {}}", "switch (1) { case 1: var g = function () {}}"); testSameInFunction("function f() {}"); testInFunction("f(); a:function g() {}", "f(); a:{ var g = function () {} }"); testInFunction("f(); {function g() {}}", "f(); {var g = function () {}}"); testInFunction("f(); if (true) {function g() {}}", "f(); if (true) {var g = function () {}}"); testInFunction("if (true) {} else {function g() {}}", "if (true) {} else {var g = function () {}}"); } public void testMakeLocalNamesUnique() { if (!Normalize.MAKE_LOCAL_NAMES_UNIQUE) { return; } // Verify global names are untouched. testSame("var a;"); // Verify global names are untouched. testSame("a;"); // Local names are made unique. test("var a;function foo(a){var b;a}", "var a;function foo(a$$1){var b;a$$1}"); test("var a;function foo(){var b;a}function boo(){var b;a}", "var a;function foo(){var b;a}function boo(){var b$$1;a}"); test("function foo(a){var b}" + "function boo(a){var b}", "function foo(a){var b}" + "function boo(a$$1){var b$$1}"); // Verify function expressions are renamed. test("var a = function foo(){foo()};var b = function foo(){foo()};", "var a = function foo(){foo()};var b = function foo$$1(){foo$$1()};"); // Verify catch exceptions names are made unique test("try { } catch(e) {e;}", "try { } catch(e) {e;}"); test("try { } catch(e) {e;}; try { } catch(e) {e;}", "try { } catch(e) {e;}; try { } catch(e$$1) {e$$1;}"); test("try { } catch(e) {e; try { } catch(e) {e;}};", "try { } catch(e) {e; try { } catch(e$$1) {e$$1;} }; "); // Verify the 1st global redefinition of extern definition is not removed. test("/** @suppress {duplicate} */\nvar window;", "var window;"); // Verify the 2nd global redefinition of extern definition is removed. test("/** @suppress {duplicate} */\nvar window;" + "/** @suppress {duplicate} */\nvar window;", "var window;"); // Verify local masking extern made unique. test("function f() {var window}", "function f() {var window$$1}"); } public void testRemoveDuplicateVarDeclarations1() { test("function f() { var a; var a }", "function f() { var a; }"); test("function f() { var a = 1; var a = 2 }", "function f() { var a = 1; a = 2 }"); test("var a = 1; function f(){ var a = 2 }", "var a = 1; function f(){ var a$$1 = 2 }"); test("function f() { var a = 1; lable1:var a = 2 }", "function f() { var a = 1; lable1:{a = 2}}"); test("function f() { var a = 1; lable1:var a }", "function f() { var a = 1; lable1:{} }"); test("function f() { var a = 1; for(var a in b); }", "function f() { var a = 1; for(a in b); }"); } public void testRemoveDuplicateVarDeclarations2() { test("var e = 1; function f(){ try {} catch (e) {} var e = 2 }", "var e = 1; function f(){ try {} catch (e$$2) {} var e$$1 = 2 }"); } public void testRemoveDuplicateVarDeclarations3() { test("var f = 1; function f(){}", "f = 1; function f(){}"); test("var f; function f(){}", "function f(){}"); test("if (a) { var f = 1; } else { function f(){} }", "if (a) { var f = 1; } else { f = function (){} }"); test("function f(){} var f = 1;", "function f(){} f = 1;"); test("function f(){} var f;", "function f(){}"); test("if (a) { function f(){} } else { var f = 1; }", "if (a) { var f = function (){} } else { f = 1; }"); // TODO(johnlenz): Do we need to handle this differently for "third_party" // mode? Remove the previous function definitions? test("function f(){} function f(){}", "function f(){} function f(){}", SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR); test("if (a) { function f(){} } else { function f(){} }", "if (a) { var f = function (){} } else { f = function (){} }"); } public void testRenamingConstants() { test("var ACONST = 4;var b = ACONST;", "var ACONST = 4; var b = ACONST;"); test("var a, ACONST = 4;var b = ACONST;", "var a; var ACONST = 4; var b = ACONST;"); test("var ACONST; ACONST = 4; var b = ACONST;", "var ACONST; ACONST = 4;" + "var b = ACONST;"); test("var ACONST = new Foo(); var b = ACONST;", "var ACONST = new Foo(); var b = ACONST;"); test("/** @const */var aa; aa=1;", "var aa;aa=1"); } public void testSkipRenamingExterns() { test("var EXTERN; var ext; ext.FOO;", "var b = EXTERN; var c = ext.FOO", "var b = EXTERN; var c = ext.FOO", null, null); } public void testIssue166a() { test("try { throw 1 } catch(e) { /** @suppress {duplicate} */ var e=2 }", "try { throw 1 } catch(e) { var e=2 }", Normalize.CATCH_BLOCK_VAR_ERROR); } public void testIssue166b() { test("function a() {" + "try { throw 1 } catch(e) { /** @suppress {duplicate} */ var e=2 }" + "};", "function a() {" + "try { throw 1 } catch(e) { var e=2 }" + "}", Normalize.CATCH_BLOCK_VAR_ERROR); } public void testIssue166c() { test("var e = 0; try { throw 1 } catch(e) {" + "/** @suppress {duplicate} */ var e=2 }", "var e = 0; try { throw 1 } catch(e) { var e=2 }", Normalize.CATCH_BLOCK_VAR_ERROR); } public void testIssue166d() { test("function a() {" + "var e = 0; try { throw 1 } catch(e) {" + "/** @suppress {duplicate} */ var e=2 }" + "};", "function a() {" + "var e = 0; try { throw 1 } catch(e) { var e=2 }" + "}", Normalize.CATCH_BLOCK_VAR_ERROR); } public void testIssue166e() { test("var e = 2; try { throw 1 } catch(e) {}", "var e = 2; try { throw 1 } catch(e$$1) {}"); } public void testIssue166f() { test("function a() {" + "var e = 2; try { throw 1 } catch(e) {}" + "}", "function a() {" + "var e = 2; try { throw 1 } catch(e$$1) {}" + "}"); } public void testIssue() { super.allowExternsChanges(true); test("var a,b,c; var a,b", "a(), b()", "a(), b()", null, null); } public void testNormalizeSyntheticCode() { Compiler compiler = new Compiler(); compiler.init( Lists.<SourceFile>newArrayList(), Lists.<SourceFile>newArrayList(), new CompilerOptions()); Node code = Normalize.parseAndNormalizeSyntheticCode( compiler, "function f(x) {} function g(x) {}", "prefix_"); assertEquals( "function f(x$$prefix_0){}function g(x$$prefix_1){}", compiler.toSource(code)); } public void testIsConstant() throws Exception { testSame("var CONST = 3; var b = CONST;"); Node n = getLastCompiler().getRoot(); Set<Node> constantNodes = findNodesWithProperty(n, Node.IS_CONSTANT_NAME); assertEquals(2, constantNodes.size()); for (Node hasProp : constantNodes) { assertEquals("CONST", hasProp.getString()); } } public void testPropertyIsConstant1() throws Exception { testSame("var a = {};a.CONST = 3; var b = a.CONST;"); Node n = getLastCompiler().getRoot(); Set<Node> constantNodes = findNodesWithProperty(n, Node.IS_CONSTANT_NAME); assertEquals(2, constantNodes.size()); for (Node hasProp : constantNodes) { assertEquals("CONST", hasProp.getString()); } } public void testPropertyIsConstant2() throws Exception { testSame("var a = {CONST: 3}; var b = a.CONST;"); Node n = getLastCompiler().getRoot(); Set<Node> constantNodes = findNodesWithProperty(n, Node.IS_CONSTANT_NAME); assertEquals(2, constantNodes.size()); for (Node hasProp : constantNodes) { assertEquals("CONST", hasProp.getString()); } } public void testGetterPropertyIsConstant() throws Exception { testSame("var a = { get CONST() {return 3} }; " + "var b = a.CONST;"); Node n = getLastCompiler().getRoot(); Set<Node> constantNodes = findNodesWithProperty(n, Node.IS_CONSTANT_NAME); assertEquals(2, constantNodes.size()); for (Node hasProp : constantNodes) { assertEquals("CONST", hasProp.getString()); } } public void testSetterPropertyIsConstant() throws Exception { // Verifying that a SET is properly annotated. testSame("var a = { set CONST(b) {throw 'invalid'} }; " + "var c = a.CONST;"); Node n = getLastCompiler().getRoot(); Set<Node> constantNodes = findNodesWithProperty(n, Node.IS_CONSTANT_NAME); assertEquals(2, constantNodes.size()); for (Node hasProp : constantNodes) { assertEquals("CONST", hasProp.getString()); } } public void testExposeSimple() { test("var x = {}; /** @expose */ x.y = 3; x.y = 5;", "var x = {}; x['y'] = 3; x['y'] = 5;"); } public void testExposeComplex() { test( "var x = {/** @expose */ a: 1, b: 2};" + "x.a = 3; /** @expose */ x.b = 5;", "var x = {'a': 1, 'b': 2};" + "x['a'] = 3; x['b'] = 5;"); } private Set<Node> findNodesWithProperty(Node root, final int prop) { final Set<Node> set = Sets.newHashSet(); NodeTraversal.traverse( getLastCompiler(), root, new AbstractPostOrderCallback() { @Override public void visit(NodeTraversal t, Node node, Node parent) { if (node.getBooleanProp(prop)) { set.add(node); } } }); return set; } public void testRenamingConstantProperties() { // In order to detect that foo.BAR is a constant, we need collapse // properties to run first so that we can tell if the initial value is // non-null and immutable. new WithCollapse().testConstantProperties(); } private class WithCollapse extends CompilerTestCase { WithCollapse() { enableNormalize(); } private void testConstantProperties() { test("var a={}; a.ACONST = 4;var b = a.ACONST;", "var a$ACONST = 4; var b = a$ACONST;"); test("var a={b:{}}; a.b.ACONST = 4;var b = a.b.ACONST;", "var a$b$ACONST = 4;var b = a$b$ACONST;"); test("var a = {FOO: 1};var b = a.FOO;", "var a$FOO = 1; var b = a$FOO;"); test("var EXTERN; var ext; ext.FOO;", "var b = EXTERN; var c = ext.FOO", "var b = EXTERN; var c = ext.FOO", null, null); test("var a={}; a.ACONST = 4; var b = a.ACONST;", "var a$ACONST = 4; var b = a$ACONST;"); test("var a = {}; function foo() { var d = a.CONST; };" + "(function(){a.CONST=4})();", "var a$CONST;function foo(){var d = a$CONST;};" + "(function(){a$CONST = 4})();"); test("var a = {}; a.ACONST = new Foo(); var b = a.ACONST;", "var a$ACONST = new Foo(); var b = a$ACONST;"); } @Override protected int getNumRepetitions() { // The normalize pass is only run once. return 1; } @Override public CompilerPass getProcessor(final Compiler compiler) { return new CompilerPass() { @Override public void process(Node externs, Node root) { new CollapseProperties(compiler, false, true).process(externs, root); } }; } } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Tests for {@link ObjectPropertyStringPostprocess}. * */ public class ObjectPropertyStringPostprocessTest extends CompilerTestCase { @Override protected CompilerPass getProcessor(final Compiler compiler) { return new ObjectPropertyStringPostprocess(compiler); } @Override protected int getNumRepetitions() { return 1; } public void testFooDotBar() { testPass("goog.global, foo.bar", "foo, 'bar'"); } public void testFooGetElemBar() { testPass("goog.global, foo[bar]", "foo, bar"); } public void testFooBar() { testPass("goog.global, foo$bar", "goog.global, 'foo$bar'"); } private void testPass(String input, String expected) { test("new JSCompiler_ObjectPropertyString(" + input + ")", "new JSCompiler_ObjectPropertyString(" + expected + ")"); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Tests for {@link ObjectPropertyStringPreprocess} * */ public class ObjectPropertyStringPreprocessTest extends CompilerTestCase { @Override protected CompilerPass getProcessor(final Compiler compiler) { return new ObjectPropertyStringPreprocess(compiler); } @Override protected int getNumRepetitions() { return 1; } @Override protected void setUp() { super.allowExternsChanges(true); } public void testDeclaration() { test("goog.testing.ObjectPropertyString = function() {}", "JSCompiler_ObjectPropertyString = function() {}"); } public void testFooBar() { test("new goog.testing.ObjectPropertyString(foo, 'bar')", "new JSCompiler_ObjectPropertyString(goog.global, foo.bar)"); } public void testFooPrototypeBar() { test("new goog.testing.ObjectPropertyString(foo.prototype, 'bar')", "new JSCompiler_ObjectPropertyString(goog.global, " + "foo.prototype.bar)"); } public void testInvalidNumArgumentsError() { testSame(new String[] {"new goog.testing.ObjectPropertyString()"}, ObjectPropertyStringPreprocess.INVALID_NUM_ARGUMENTS_ERROR); } public void testQualifedNameExpectedError() { testSame( new String[] { "new goog.testing.ObjectPropertyString(foo[a], 'bar')" }, ObjectPropertyStringPreprocess.QUALIFIED_NAME_EXPECTED_ERROR); } public void testStringLiteralExpectedError() { testSame(new String[] {"new goog.testing.ObjectPropertyString(foo, bar)"}, ObjectPropertyStringPreprocess.STRING_LITERAL_EXPECTED_ERROR); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Unit tests for {@link OptimizeArgumentsArray}. * */ public class OptimizeArgumentsArrayTest extends CompilerTestCase { public OptimizeArgumentsArrayTest() { /* * arguments is a builtin variable of the javascript language and * OptimizeArgumentsArray does not make any attempt to resolve it. However, * I am leaving "var arguments" in the externs to emulate the current * behavior we have for JS compilation where var arguments in defined in * externs/es3.js as extern. */ super("var arguments, alert" /* Externs */); } @Override public void setUp() { super.enableLineNumberCheck(false); } @Override protected CompilerPass getProcessor(Compiler compiler) { return new OptimizeArgumentsArray(compiler, "p"); } public void testSimple() { test("function foo() { alert(arguments[0]); }", "function foo(p0) { alert(p0); }"); } public void testNoVarArgs() { testSame("function f(a,b,c) { alert(a + b + c) }"); test("function f(a,b,c) { alert(arguments[0]) }", "function f(a,b,c) { alert(a) }"); } public void testMissingVarArgs() { testSame("function f() { alert(arguments[x]) }"); } public void testArgumentRefOnNamedParameter() { test("function f(a,b) { alert(arguments[0]) }", "function f(a,b) { alert(a) }"); } public void testTwoVarArgs() { test("function foo(a) { alert(arguments[1] + arguments[2]); }", "function foo(a, p0, p1) { alert(p0 + p1); }"); } public void testTwoFourArgsTwoUsed() { test("function foo() { alert(arguments[0] + arguments[3]); }", "function foo(p0, p1, p2, p3) { alert(p0 + p3); }"); } public void testOneRequired() { test("function foo(req0, var_args) { alert(req0 + arguments[1]); }", "function foo(req0, var_args) { alert(req0 + var_args); }"); } public void testTwoRequiredSixthVarArgReferenced() { test("function foo(r0, r1, var_args) {alert(r0 + r1 + arguments[5]);}", "function foo(r0, r1, var_args, p0, p1, p2) { alert(r0 + r1 + p2); }"); } public void testTwoRequiredOneOptionalFifthVarArgReferenced() { test("function foo(r0, r1, opt_1)" + " {alert(r0 + r1 + opt_1 + arguments[4]);}", "function foo(r0, r1, opt_1, p0, p1)" + " {alert(r0 + r1 + opt_1 + p1); }"); } public void testTwoRequiredTwoOptionalSixthVarArgReferenced() { test("function foo(r0, r1, opt_1, opt_2)" + " {alert(r0 + r1 + opt_1 + opt_2 + arguments[5]);}", "function foo(r0, r1, opt_1, opt_2, p0, p1)" + " {alert(r0 + r1 + opt_1 + opt_2 + p1); }"); } public void testInnerFunctions() { test("function f() { function b( ) { arguments[0] }}", "function f() { function b(p0) { p0 }}"); test("function f( ) { function b() { } arguments[0] }", "function f(p0) { function b() { } p0 }"); test("function f( ) { arguments[0]; function b( ) { arguments[0] }}", "function f(p1) { p1; function b(p0) { p0 }}"); } public void testInnerFunctionsWithNamedArgumentInInnerFunction() { test("function f() { function b(x ) { arguments[1] }}", "function f() { function b(x,p0) { p0 }}"); test("function f( ) { function b(x) { } arguments[0] }", "function f(p0) { function b(x) { } p0 }"); test("function f( ) { arguments[0]; function b(x ) { arguments[1] }}", "function f(p1) { p1; function b(x,p0) { p0 }}"); } public void testInnerFunctionsWithNamedArgumentInOutterFunction() { test("function f(x) { function b( ) { arguments[0] }}", "function f(x) { function b(p0) { p0 }}"); test("function f(x ) { function b() { } arguments[1] }", "function f(x,p0) { function b() { } p0 }"); test("function f(x ) { arguments[1]; function b( ) { arguments[0] }}", "function f(x,p1) { p1; function b(p0) { p0 }}"); } public void testInnerFunctionsWithNamedArgumentInInnerAndOutterFunction() { test("function f(x) { function b(x ) { arguments[1] }}", "function f(x) { function b(x,p0) { p0 }}"); test("function f(x ) { function b(x) { } arguments[1] }", "function f(x,p0) { function b(x) { } p0 }"); test("function f(x ) { arguments[1]; function b(x ) { arguments[1] }}", "function f(x,p1) { p1; function b(x,p0) { p0 }}"); } public void testInnerFunctionsAfterArguments() { // This caused a bug earlier due to incorrect push and pop of the arguments // access stack. test("function f( ) { arguments[0]; function b() { function c() { }} }", "function f(p0) { p0; function b() { function c() { }} }"); } public void testNoOptimizationWhenGetProp() { testSame("function f() { arguments[0]; arguments.size }"); } public void testNoOptimizationWhenIndexIsNotNumberConstant() { testSame("function f() { arguments[0]; arguments['callee'].length}"); testSame("function f() { arguments[0]; arguments.callee.length}"); testSame( "function f() { arguments[0]; var x = 'callee'; arguments[x].length}"); } public void testNoOptimizationWhenArgumentIsUsedAsFunctionCall() { testSame("function f() {arguments[0]()}"); } }
/* * Copyright 2011 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.rhino.Node; /** * Unit tests for {#link {@link OptimizeCalls} * */ public class OptimizeCallsTest extends CompilerTestCase { @Override protected CompilerPass getProcessor(final Compiler compiler) { final OptimizeCalls passes = new OptimizeCalls(compiler); passes.addPass(new OptimizeReturns(compiler)); passes.addPass(new OptimizeParameters(compiler)); passes.addPass(new RemoveUnusedVars(compiler, true, false, true)); return new CompilerPass() { @Override public void process(Node externs, Node root) { new PureFunctionIdentifier(compiler, new SimpleDefinitionFinder(compiler)).process(externs, root); passes.process(externs, root); } }; } public void testRemovingReturnCallToFunctionWithUnusedParams() { test("function foo() {var x; return x = bar(1)} foo(); function bar(x) {}", "function foo() { bar(); return;} foo(); function bar() {}"); } public void testNestingFunctionCallWithUnsedParams() { test("function f1(x) { } function f2(x) { }" + "function f3(x) { } function f4(x) { }" + "f3(f1(f2()));", "function f1() {f2()} function f2() { }" + "function f3() {f1()} " + "f3();" ); } public void testUnusedAssignOnFunctionWithUnusedParams() { test("var foo = function(a){}; function bar(){var x;x = foo} bar(); foo(1)", "var foo = function( ){}; function bar(){ } bar(); foo()"); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Tests for {@link OptimizeParameters} * */ public class OptimizeParametersTest extends CompilerTestCase { @Override public CompilerPass getProcessor(Compiler compiler) { return new OptimizeParameters(compiler); } @Override public void setUp() { super.enableNormalize(); super.enableLineNumberCheck(false); } public void testNoRemoval() { testSame("function foo(p1) { } foo(1); foo(2)"); testSame("function foo(p1) { } foo(1,2); foo(3,4)"); } public void testSimpleRemoval() { test("function foo(p1) { } foo(); foo()", "function foo() {var p1;} foo(); foo()"); test("function foo(p1) { } foo(1); foo(1)", "function foo() {var p1 = 1;} foo(); foo()"); test("function foo(p1) { } foo(1,2); foo(1,4)", "function foo() {var p1 = 1;} foo(2); foo(4)"); } public void testNotAFunction() { testSame("var x = 1; x; x = 2"); } public void testRemoveOneOptionalNamedFunction() { test("function foo(p1) { } foo()", "function foo() {var p1} foo()"); } public void testDifferentScopes() { test("function f(a, b) {} f(1, 2); f(1, 3); " + "function h() {function g(a) {} g(4); g(5);} f(1, 2);", "function f(b) {var a = 1} f(2); f(3); " + "function h() {function g(a) {} g(4); g(5);} f(2);"); } public void testOptimizeOnlyImmutableValues() { test("function foo(a) {}; foo(undefined);", "function foo() {var a = undefined}; foo()"); test("function foo(a) {}; foo(null);", "function foo() {var a = null}; foo()"); test("function foo(a) {}; foo(1);", "function foo() {var a = 1}; foo()"); test("function foo(a) {}; foo('abc');", "function foo() {var a = 'abc'}; foo()"); test("var foo = function(a) {}; foo(undefined);", "var foo = function() {var a = undefined}; foo()"); test("var foo = function(a) {}; foo(null);", "var foo = function() {var a = null}; foo()"); test("var foo = function(a) {}; foo(1);", "var foo = function() {var a = 1}; foo()"); test("var foo = function(a) {}; foo('abc');", "var foo = function() {var a = 'abc'}; foo()"); } public void testRemoveOneOptionalVarAssignment() { test("var foo = function (p1) { }; foo()", "var foo = function () {var p1}; foo()"); } public void testDoOptimizeCall() { testSame("var foo = function () {}; foo(); foo.call();"); // TODO(johnlenz): support foo.call testSame("var foo = function () {}; foo(); foo.call(this);"); testSame("var foo = function (a, b) {}; foo(1); foo.call(this, 1);"); testSame("var foo = function () {}; foo(); foo.call(null);"); testSame("var foo = function (a, b) {}; foo(1); foo.call(null, 1);"); testSame("var foo = function () {}; foo.call();"); // TODO(johnlenz): support foo.call testSame("var foo = function () {}; foo.call(this);"); testSame("var foo = function (a, b) {}; foo.call(this, 1);"); testSame("var foo = function () {}; foo.call(null);"); testSame("var foo = function (a, b) {}; foo.call(null, 1);"); } public void testDoOptimizeApply() { testSame("var foo = function () {}; foo(); foo.apply();"); testSame("var foo = function () {}; foo(); foo.apply(this);"); testSame("var foo = function (a, b) {}; foo(1); foo.apply(this, 1);"); testSame("var foo = function () {}; foo(); foo.apply(null);"); testSame("var foo = function (a, b) {}; foo(1); foo.apply(null, []);"); testSame("var foo = function () {}; foo.apply();"); testSame("var foo = function () {}; foo.apply(this);"); testSame("var foo = function (a, b) {}; foo.apply(this, 1);"); testSame("var foo = function () {}; foo.apply(null);"); testSame("var foo = function (a, b) {}; foo.apply(null, []);"); } public void testRemoveOneOptionalExpressionAssign() { // TODO(johnlenz): There are two definitions of "foo" here, ignore the // one that can't be called. testSame("var foo; foo = function (p1) { }; foo()"); } public void testRemoveOneOptionalOneRequired() { test("function foo(p1, p2) { } foo(1); foo(2)", "function foo(p1) {var p2} foo(1); foo(2)"); } public void testRemoveOneOptionalMultipleCalls() { test( "function foo(p1, p2) { } foo(1); foo(2); foo()", "function foo(p1) {var p2} foo(1); foo(2); foo()"); } public void testRemoveOneOptionalMultiplePossibleDefinition() { String src = "var goog = {};" + "goog.foo = function (p1, p2) { };" + "goog.foo = function (q1, q2) { };" + "goog.foo = function (r1, r2) { };" + "goog.foo(1); goog.foo(2); goog.foo()"; String expected = "var goog = {};" + "goog.foo = function (p1) { var p2 };" + "goog.foo = function (q1) { var q2 };" + "goog.foo = function (r1) { var r2 };" + "goog.foo(1); goog.foo(2); goog.foo()"; // TODO(johnlenz): Support multiple valid definitions. testSame(src); } public void testRemoveTwoOptionalMultiplePossibleDefinition() { String src = "var goog = {};" + "goog.foo = function (p1, p2, p3, p4) { };" + "goog.foo = function (q1, q2, q3, q4) { };" + "goog.foo = function (r1, r2, r3, r4) { };" + "goog.foo(1,0); goog.foo(2,1); goog.foo()"; String expected = "var goog = {};" + "goog.foo = function(p1, p2) { var p4; var p3};" + "goog.foo = function(q1, q2) { var q4; var q3};" + "goog.foo = function(r1, r2) { var r4; var r3};" + "goog.foo(1,0); goog.foo(2,1); goog.foo()"; // TODO(johnlenz): Support multiple valid definitions. testSame(src); } public void testConstructorOptArgsNotRemoved() { String src = "/** @constructor */" + "var goog = function(){};" + "goog.prototype.foo = function(a,b) {};" + "goog.prototype.bar = function(a) {};" + "goog.bar.inherits(goog.foo);" + "new goog.foo(2,3);" + "new goog.foo(1,2);"; testSame(src); } public void testMultipleUnknown() { String src = "var goog1 = {};" + "goog1.foo = function () { };" + "var goog2 = {};" + "goog2.foo = function (p1) { };" + "var x = getGoog();" + "x.foo()"; String expected = "var goog1 = {};" + "goog1.foo = function () { };" + "var goog2 = {};" + "goog2.foo = function () { var p1 };" + "var x = getGoog();" + "x.foo()"; // TODO(johnlenz): Support multiple definitions. testSame(src); } public void testSingleUnknown() { String src = "var goog2 = {};" + "goog2.foo = function (p1) { };" + "var x = getGoog();" + "x.foo()"; String expected = "var goog2 = {};" + "goog2.foo = function () { var p1 };" + "var x = getGoog();" + "x.foo()"; test(src, expected); } public void testRemoveVarArg() { test("function foo(p1, var_args) { } foo(1); foo(2)", "function foo(p1) { var var_args } foo(1); foo(2)"); } public void testAliasMethodsDontGetOptimize() { String src = "var foo = function(a, b) {};" + "var goog = {};" + "goog.foo = foo;" + "goog.prototype.bar = goog.foo;" + "new goog().bar(1,2);" + "foo(2);"; testSame(src); } public void testAliasMethodsDontGetOptimize2() { String src = "var foo = function(a, b) {};" + "var bar = foo;" + "foo(1);" + "bar(2,3);"; testSame(src); } public void testAliasMethodsDontGetOptimize3() { String src = "var array = {};" + "array[0] = function(a, b) {};" + "var foo = array[0];" + // foo should be marked as aliased. "foo(1);"; testSame(src); } public void testAliasMethodsDontGetOptimize4() { // Don't change the call to baz as it has been aliased. test( "function foo(bar) {};" + "baz = function(a) {};" + "baz(1);" + "foo(baz);", "function foo() {var bar = baz};" + "baz = function(a) {};" + "baz(1);" + "foo();"); } public void testMethodsDefinedInArraysDontGetOptimized() { String src = "var array = [true, function (a) {}];" + "array[1](1)"; testSame(src); } public void testMethodsDefinedInObjectDontGetOptimized() { String src = "var object = { foo: function bar() {} };" + "object.foo(1)"; testSame(src); src = "var object = { foo: function bar() {} };" + "object['foo'](1)"; testSame(src); } public void testRemoveConstantArgument() { // Remove only one parameter test("function foo(p1, p2) {}; foo(1,2); foo(2,2);", "function foo(p1) {var p2 = 2}; foo(1); foo(2)"); // Remove nothing testSame("function foo(p1, p2) {}; foo(1); foo(2,3);"); // Remove middle parameter test("function foo(a,b,c){}; foo(1, 2, 3); foo(1, 2, 4); foo(2, 2, 3)", "function foo(a,c){var b=2}; foo(1, 3); foo(1, 4); foo(2, 3)"); // Number are equals test("function foo(a) {}; foo(1); foo(1.0);", "function foo() {var a = 1;}; foo(); foo();"); // A more OO test String src = "/** @constructor */" + "function Person(){}; Person.prototype.run = function(a, b) {};" + "Person.run(1, 'a'); Person.run(2, 'a')"; String expected = "function Person(){}; Person.prototype.run = " + "function(a) {var b = 'a'};" + "Person.run(1); Person.run(2)"; test(src, expected); } public void testCanDeleteArgumentsAtAnyPosition() { // Argument removed in middle and end String src = "function foo(a,b,c,d,e) {};" + "foo(1,2,3,4,5);" + "foo(2,2,4,4,5);"; String expected = "function foo(a,c) {var b=2; var d=4; var e=5;};" + "foo(1,3);" + "foo(2,4);"; test(src, expected); } public void testNoOptimizationForExternsFunctions() { testSame("function _foo(x, y, z){}; _foo(1);"); } public void testNoOptimizationForGoogExportSymbol() { testSame("goog.exportSymbol('foo', foo);" + "function foo(x, y, z){}; foo(1);"); } public void testNoArgumentRemovalNonEqualNodes() { testSame("function foo(a){}; foo('bar'); foo('baz');"); testSame("function foo(a){}; foo(1.0); foo(2.0);"); testSame("function foo(a){}; foo(true); foo(false);"); testSame("var a = 1, b = 2; function foo(a){}; foo(a); foo(b);"); testSame("function foo(a){}; foo(/&/g); foo(/</g);"); } public void testFunctionPassedAsParam() { String src = "/** @constructor */ function person(){}; " + "person.prototype.run = function(a, b) {};" + "person.prototype.walk = function() {};" + "person.prototype.foo = function() { this.run(this.walk, 0.1)};" + "person.foo();"; String expected = "function person(){}; person.prototype.run = function(a) {" + " var b = 0.1;};" + "person.prototype.walk = function() {};" + "person.prototype.foo = function() { this.run(this.walk)};" + "person.foo();"; test(src, expected); } public void testCallIsIgnore() { testSame("var goog;" + "goog.foo = function(a, opt) {};" + "var bar = function(){goog.foo.call(this, 1)};" + "goog.foo(1);"); } public void testApplyIsIgnore() { testSame("var goog;" + "goog.foo = function(a, opt) {};" + "var bar = function(){goog.foo.apply(this, 1)};" + "goog.foo(1);"); } public void testFunctionWithReferenceToArgumentsShouldNotBeOptimize() { testSame("function foo(a,b,c) { return arguments.size; };" + "foo(1);"); testSame("var foo = function(a,b,c) { return arguments.size }; foo(1);"); testSame("var foo = function bar(a,b,c) { return arguments.size }; " + "foo(2); bar(2);"); } public void testFunctionWithTwoNames() { testSame("var foo = function bar(a,b) {};"); testSame("var foo = function bar(a,b) {}; foo(1)"); testSame("var foo = function bar(a,b) {}; bar(1);"); testSame("var foo = function bar(a,b) {}; foo(1); foo(2)"); testSame("var foo = function bar(a,b) {}; foo(1); bar(1)"); testSame("var foo = function bar(a,b) {}; foo(1); bar(2)"); testSame("var foo = function bar(a,b) {}; foo(1,2); bar(2,1)"); } public void testRecursion() { test("var foo = function (a,b) {foo(1, b)}; foo(1, 2)", "var foo = function (b) {var a=1; foo(b)}; foo(2)"); } public void testConstantArgumentsToConstructorCanBeOptimized() { String src = "function foo(a) {};" + "var bar = new foo(1);"; String expected = "function foo() {var a=1;};" + "var bar = new foo();"; test(src, expected); } public void testOptionalArgumentsToConstructorCanBeOptimized() { String src = "function foo(a) {};" + "var bar = new foo();"; String expected = "function foo() {var a;};" + "var bar = new foo();"; test(src, expected); } public void testRegexesCanBeInlined() { test("function foo(a) {}; foo(/abc/);", "function foo() {var a = /abc/}; foo();"); } public void testConstructorUsedAsFunctionCanBeOptimized() { String src = "function foo(a) {};" + "var bar = new foo(1);" + "foo(1);"; String expected = "function foo() {var a=1;};" + "var bar = new foo();" + "foo();"; test(src, expected); } public void testDoNotOptimizeConstructorWhenArgumentsAreNotEqual() { testSame("function Foo(a) {};" + "var bar = new Foo(1);" + "var baz = new Foo(2);"); } public void testDoNotOptimizeArrayElements() { testSame("var array = [function (a, b) {}];"); testSame("var array = [function f(a, b) {}]"); testSame("var array = [function (a, b) {}];" + "array[0](1, 2);" + "array[0](1);"); testSame("var array = [];" + "function foo(a, b) {};" + "array[0] = foo;"); } public void testOptimizeThis() { String src = "function foo() {" + "var bar = function (a, b) {};" + "this.bar = function (a, b) {};" + "this.bar(3);" + "bar(2);}"; String expected = "function foo() {" + "var bar = function () {var b; var a = 2;};" + "this.bar = function () {var b; var a = 3;};" + "this.bar();" + "bar();}"; test(src, expected); } public void testDoNotOptimizeWhenArgumentsPassedAsParameter() { testSame("function foo(a) {}; foo(arguments)"); testSame("function foo(a) {}; foo(arguments[0])"); test("function foo(a, b) {}; foo(arguments, 1)", "function foo(a) {var b = 1}; foo(arguments)"); test("function foo(a, b) {}; foo(arguments)", "function foo(a) {var b}; foo(arguments)"); } public void testDoNotOptimizeGoogExportFunctions() { testSame("function foo(a, b) {}; foo(); goog.export_function(foo);"); } public void testDoNotOptimizeJSCompiler_renameProperty() { testSame("function JSCompiler_renameProperty(a) {return a};" + "JSCompiler_renameProperty('a');"); } public void testDoNotOptimizeJSCompiler_ObjectPropertyString() { testSame("function JSCompiler_ObjectPropertyString(a, b) {return a[b]};" + "JSCompiler_renameProperty(window,'b');"); } public void testMutableValues1() { test("function foo(p1) {} foo()", "function foo() {var p1} foo()"); test("function foo(p1) {} foo(1)", "function foo() {var p1=1} foo()"); test("function foo(p1) {} foo([])", "function foo() {var p1=[]} foo()"); test("function foo(p1) {} foo({})", "function foo() {var p1={}} foo()"); test("var x;function foo(p1) {} foo(x)", "var x;function foo() {var p1=x} foo()"); test("var x;function foo(p1) {} foo(x())", "var x;function foo() {var p1=x()} foo()"); test("var x;function foo(p1) {} foo(new x())", "var x;function foo() {var p1=new x()} foo()"); test("var x;function foo(p1) {} foo('' + x)", "var x;function foo() {var p1='' + x} foo()"); testSame("function foo(p1) {} foo(this)"); testSame("function foo(p1) {} foo(arguments)"); testSame("function foo(p1) {} foo(function(){})"); testSame("function foo(p1) {} (function () {var x;foo(x)})()"); } public void testMutableValues2() { test("function foo(p1, p2) {} foo(1, 2)", "function foo() {var p1=1; var p2 = 2} foo()"); test("var x; var y; function foo(p1, p2) {} foo(x(), y())", "var x; var y; function foo() {var p1=x(); var p2 = y()} foo()"); } public void testMutableValues3() { test( "var x; var y; var z;" + "function foo(p1, p2) {}" + "foo(x(), y()); foo(x(),y())", "var x; var y; var z;" + "function foo() {var p1=x(); var p2=y()}" + "foo(); foo()"); } public void testMutableValues4() { // Preserve the ordering of side-effects. // If z(), can't be moved into the function then z() may change the value // of x and y. testSame( "var x; var y; var z;" + "function foo(p1, p2, p3) {}" + "foo(x(), y(), z()); foo(x(),y(),3)"); // If z(), can't be moved into the function then z() may change the value // of x and y. testSame( "var x; var y; var z;" + "function foo(p1, p2, p3) {}" + "foo(x, y(), z()); foo(x,y(),3)"); // Mutable object that can not be effect by side-effects are movable, // however. test( "var x; var y; var z;" + "function foo(p1, p2, p3) {}" + "foo([], y(), z()); foo([],y(),3)", "var x; var y; var z;" + "function foo(p2, p3) {var p1=[]}" + "foo(y(), z()); foo(y(),3)"); } public void testMutableValues5() { test( "var x; var y; var z;" + "function foo(p1, p2) {}" + "new foo(new x(), y()); new foo(new x(),y())", "var x; var y; var z;" + "function foo() {var p1=new x(); var p2=y()}" + "new foo(); new foo()"); test( "var x; var y; var z;" + "function foo(p1, p2) {}" + "new foo(x(), y()); new foo(x(),y())", "var x; var y; var z;" + "function foo() {var p1=x(); var p2=y()}" + "new foo(); new foo()"); testSame( "var x; var y; var z;" + "function foo(p1, p2, p3) {}" + "new foo(x(), y(), z()); new foo(x(),y(),3)"); testSame( "var x; var y; var z;" + "function foo(p1, p2, p3) {}" + "new foo(x, y(), z()); new foo(x,y(),3)"); test( "var x; var y; var z;" + "function foo(p1, p2, p3) {}" + "new foo([], y(), z()); new foo([],y(),3)", "var x; var y; var z;" + "function foo(p2, p3) {var p1=[]}" + "new foo(y(), z()); new foo(y(),3)"); } public void testShadows() { testSame("function foo(a) {}" + "var x;" + "function f() {" + " var x;" + " function g() {" + " foo(x());" + " }" + "};" + "foo(x())"); } public void testCrash() { test( "function foo(a) {}" + "foo({o:1});" + "foo({o:1})", "function foo() {var a = {o:1}}" + "foo();" + "foo()"); } public void testGlobalCatch() { testSame("function foo(a) {} try {} catch (e) {foo(e)}"); } public void testNamelessParameter1() { test("f(g()); function f(){}", "f(); function f(){g()}"); } public void testNamelessParameter2() { test("f(g(),h()); function f(){}", "f(); function f(){g();h()}"); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.base.Joiner; /** * Tests OptimizeReturns * @author johnlenz@google.com (John Lenz) */ public class OptimizeReturnsTest extends CompilerTestCase { @Override protected CompilerPass getProcessor(Compiler compiler) { return new OptimizeReturns(compiler); } private static final String EXTERNAL_SYMBOLS = "var extern;extern.externalMethod"; public OptimizeReturnsTest() { super(EXTERNAL_SYMBOLS); } @Override protected int getNumRepetitions() { // run pass once. return 1; } @Override protected void setUp() throws Exception { super.setUp(); super.enableLineNumberCheck(true); disableTypeCheck(); } /** * Combine source strings using '\n' as the separator. */ private static String newlineJoin(String ... parts) { return Joiner.on("\n").join(parts); } public void testNoRewriteUsedResult1() throws Exception { String source = newlineJoin( "function a(){return 1}", "var x = a()"); testSame(source); } public void testNoRewriteUsedResult2() throws Exception { String source = newlineJoin( "var a = function(){return 1}", "a(); var b = a()"); testSame(source); } public void testRewriteUnusedResult1() throws Exception { String source = newlineJoin( "function a(){return 1}", "a()"); String expected = newlineJoin( "function a(){return}", "a()"); test(source, expected); } public void testRewriteUnusedResult2() throws Exception { String source = newlineJoin( "var a; a = function(){return 1}", "a()"); String expected = newlineJoin( "var a; a = function(){return}", "a()"); test(source, expected); } public void testRewriteUnusedResult3() throws Exception { String source = newlineJoin( "var a = function(){return 1}", "a()"); String expected = newlineJoin( "var a = function(){return}", "a()"); test(source, expected); } public void testRewriteUnusedResult4a() throws Exception { String source = newlineJoin( "var a = function(){return a()}", "a()"); testSame(source); } public void testRewriteUnusedResult4b() throws Exception { String source = newlineJoin( "var a = function b(){return b()}", "a()"); testSame(source); } public void testRewriteUnusedResult4c() throws Exception { String source = newlineJoin( "function a(){return a()}", "a()"); testSame(source); } public void testRewriteUnusedResult5() throws Exception { String source = newlineJoin( "function a(){}", "a.prototype.foo = function(args) {return args};", "var o = new a;", "o.foo()"); String expected = newlineJoin( "function a(){}", "a.prototype.foo = function(args) {return};", "var o = new a;", "o.foo()"); test(source, expected); } public void testRewriteUnusedResult6() throws Exception { String source = newlineJoin( "function a(){return (g = 1)}", "a()"); String expected = newlineJoin( "function a(){g = 1;return}", "a()"); test(source, expected); } public void testRewriteUnusedResult7a() throws Exception { String source = newlineJoin( "function a() { return 1 }", "function b() { return a() }", "function c() { return b() }", "c();"); String expected = newlineJoin( "function a() { return 1 }", "function b() { return a() }", "function c() { b(); return }", "c();"); test(source, expected); } public void testRewriteUnusedResult7b() throws Exception { String source = newlineJoin( "c();", "function c() { return b() }", "function b() { return a() }", "function a() { return 1 }"); // Iteration 1. String expected = newlineJoin( "c();", "function c() { b(); return }", "function b() { return a() }", "function a() { return 1 }"); test(source, expected); // Iteration 2. source = expected; expected = newlineJoin( "c();", "function c() { b(); return }", "function b() { a(); return }", "function a() { return 1 }"); test(source, expected); // Iteration 3. source = expected; expected = newlineJoin( "c();", "function c() { b(); return }", "function b() { a(); return }", "function a() { return }"); test(source, expected); } public void testRewriteUnusedResult8() throws Exception { String source = newlineJoin( "function a() { return c() }", "function b() { return a() }", "function c() { return b() }", "c();"); testSame(source); } public void testNoRewriteObjLit1() throws Exception { String source = newlineJoin( "var a = {b:function(){return 1;}}", "for(c in a) (a[c])();", "a.b()"); testSame(source); } public void testNoRewriteObjLit2() throws Exception { String source = newlineJoin( "var a = {b:function fn(){return 1;}}", "for(c in a) (a[c])();", "a.b()"); testSame(source); } public void testNoRewriteArrLit() throws Exception { String source = newlineJoin( "var a = [function(){return 1;}]", "(a[0])();"); testSame(source); } public void testPrototypeMethod1() throws Exception { String source = newlineJoin( "function c(){}", "c.prototype.a = function(){return 1}", "var x = new c;", "x.a()"); String result = newlineJoin( "function c(){}", "c.prototype.a = function(){return}", "var x = new c;", "x.a()"); test(source, result); } public void testPrototypeMethod2() throws Exception { String source = newlineJoin( "function c(){}", "c.prototype.a = function(){return 1}", "goog.reflect.object({a: 'v'})", "var x = new c;", "x.a()"); testSame(source); } public void testPrototypeMethod3() throws Exception { String source = newlineJoin( "function c(){}", "c.prototype.a = function(){return 1}", "var x = new c;", "for(var key in goog.reflect.object({a: 'v'})){ x[key](); }", "x.a()"); testSame(source); } public void testPrototypeMethod4() throws Exception { String source = newlineJoin( "function c(){}", "c.prototype.a = function(){return 1}", "var x = new c;", "for(var key in goog.reflect.object({a: 'v'})){ x[key](); }"); testSame(source); } public void testCallOrApply() throws Exception { // TODO(johnlenz): Add support for .call and .apply testSame("function a() {return 1}; a.call(new foo);"); testSame("function a() {return 1}; a.apply(new foo);"); } public void testRewriteUseSiteRemoval() throws Exception { String source = newlineJoin( "function a() { return {\"_id\" : 1} }", "a();"); String expected = newlineJoin( "function a() { return }", "a();"); test(source, expected); } }
/* * Copyright 2010 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; public class PeepholeCollectPropertyAssignmentsTest extends CompilerTestCase { @Override protected CompilerPass getProcessor(final Compiler compiler) { return new PeepholeOptimizationsPass( compiler, new PeepholeCollectPropertyAssignments()); } public final void testArrayOptimization1() { test("var a = []; a[0] = 1; a[1] = 2; a[2] = 3;", "var a = [1, 2, 3];"); } public final void testArrayOptimization2() { test("var a; a = []; a[0] = 1; a[1] = 2; a[2] = 3;", "var a; a = [1, 2, 3];"); } public final void testArrayOptimization3() { testSame("var a; a.b = []; a.b[0] = 1; a.b[1] = 2; a.b[2] = 3;"); } public final void testCompoundAssignment() { testSame("var x, a; a = []; a[0] *= x;"); } public final void testNegativeArrayIndex1() { testSame("var a = []; a[-1] = 1;"); } public final void testNegativeArrayIndex2() { testSame("var a; a = []; a[-1] = 1;"); } public final void testFractionalArrayIndex1() { testSame("var a = []; a[0.5] = 1;"); } public final void testFractionalArrayIndex2() { testSame("var a; a = []; a[0.5] = 1;"); } public final void testArrayOptimizationOfPartiallyBuiltArray1() { test("var a = [1, 2]; a[2] = 3;", "var a = [1, 2, 3];"); } public final void testArrayOptimizationOfPartiallyBuiltArray2() { test("var a; a = [1, 2]; a[2] = 3;", "var a; a = [1, 2, 3];"); } public final void testArrayOptimizationWithAHole1() { test("var a = []; a[0] = 1; a[1] = 2; a[3] = 4;", "var a = [1, 2, , 4];"); } public final void testArrayOptimizationWithAHole2() { test("var a; a = []; a[0] = 1; a[1] = 2; a[3] = 4;", "var a; a = [1, 2, , 4];"); } public final void testEarlyUsage1() { testSame( "function c() {return sum(a)};" + "var a = [1,2,3];" + "a[4] = c();"); } public final void testEarlyUsage2() { testSame( "function c() {return sum(a)};" + "var a; a = [1,2,3];" + "a[4] = c();"); } public final void testArrayTooSparseOptimization1() { test("var a = []; a[0] = 1; a[1] = 2; a[100] = 4;", "var a = [1, 2]; a[100] = 4;"); } public final void testArrayTooSparseOptimization2() { test("var a; a = []; a[0] = 1; a[1] = 2; a[100] = 4;", "var a; a = [1, 2]; a[100] = 4;"); } public final void testArrayOutOfOrder() { test("var a = []; a[1] = 1; a[0] = 0;", "var a = [0, 1];"); test("var a; a = []; a[1] = 1; a[0] = 0;", "var a; a = [0, 1];"); // We cannot change the order of side-effects. // The below should not be // var x = 0; var a = [x++, x++] // since that would produce // var a = [0, 1], x = 2; // instead of // var a = [1, 0], x = 2; testSame("var x = 0; var a = []; a[1] = x++; a[0] = x++;"); testSame("var x; x = 0; var a = []; a[1] = x++; a[0] = x++;"); } public final void testMultipleNames1() { test("var b = []; b[0] = 2; var a = []; a[0] = 1;", "var b = [2]; var a = [1];"); } public final void testMultipleNames2() { test("var b; b = []; b[0] = 2; var a = []; a[0] = 1;", "var b; b = [2]; var a = [1];"); } public final void testArrayReassignedInValue1() { test("var a = []; a[0] = 1; a[1] = (a = []); a[3] = 4;", "var a = [1]; a[1] = (a = []); a[3] = 4;"); } public final void testArrayReassignedInValue2() { test("var a; a = []; a[0] = 1; a[1] = (a = []); a[3] = 4;", "var a; a = [1]; a[1] = (a = []); a[3] = 4;"); } public final void testArrayReassignedInSubsequentVar1() { testSame("var a = []; a[0] = a = []; a[1] = 2;"); } public final void testArrayReassignedInSubsequentVar2() { testSame("var a; a = []; a[0] = a = []; a[1] = 2;"); } public final void testForwardReference1() { test("var a; a = []; a[0] = 1; a[1] = a;", "var a; a = [1]; a[1] = a;"); } public final void testForwardReference2() { test("var a; a = []; a[0] = 1; a[1] = a;", "var a; a = [1]; a[1] = a;"); } public final void testObjectOptimization1() { test("var o = {}; o.x = 0; o['y'] = 1; o[2] = 2;", "var o = { x: 0, \"y\": 1, \"2\": 2 };"); } public final void testObjectOptimization2() { test("var o; o = {}; o.x = 0; o['y'] = 1; o[2] = 2;", "var o; o = { x: 0, \"y\": 1, \"2\": 2 };"); } public final void testObjectReassignedInValue1() { test("var o = {}; o.x = 1; o.y = (o = {}); o.z = 4;", "var o = {x:1}; o.y = (o = {}); o.z = 4;"); } public final void testObjectReassignedInValue2() { test("var o; o = {}; o.x = 1; o.y = (o = {}); o.z = 4;", "var o; o = {x:1}; o.y = (o = {}); o.z = 4;"); } public final void testObjectFunctionRollup1() { test("var o; o = {};" + "o.x = function() {};", "var o; o = {x:function () {}};"); } public final void testObjectFunctionRollup2() { testSame( "var o; o = {};" + "o.x = (function() {return o})();"); } public final void testObjectFunctionRollup3() { test("var o; o = {};" + "o.x = function() {return o};", "var o; o = {x:function () {return o}};"); } public final void testObjectFunctionRollup4() { testSame( "function f() {return o};" + "var o; o = {};" + "o.x = f();"); } public final void testObjectFunctionRollup5() { test("var o; o = {};" + "o.x = function() {return o};" + "o.y = [function() {return o}];" + "o.z = {a:function() {return o}};", "var o; o = {" + "x:function () {return o}, " + "y:[function () {return o}], " + "z:{a:function () {return o}}};"); } }
/* * Copyright 2004 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.base.Joiner; import com.google.common.collect.ImmutableList; import com.google.common.collect.ImmutableMap; import com.google.common.collect.ImmutableSet; import com.google.javascript.rhino.Node; import java.util.List; import java.util.Map; import java.util.Set; /** * Tests for {@link PeepholeFoldConstants} in isolation. Tests for * the interaction of multiple peephole passes are in * {@link PeepholeIntegrationTest}. */ public class PeepholeFoldConstantsTest extends CompilerTestCase { private boolean late; // TODO(user): Remove this when we no longer need to do string comparison. private PeepholeFoldConstantsTest(boolean compareAsTree) { super("", compareAsTree); } public PeepholeFoldConstantsTest() { super(""); } @Override public void setUp() { late = false; enableLineNumberCheck(true); } @Override public CompilerPass getProcessor(final Compiler compiler) { CompilerPass peepholePass = new PeepholeOptimizationsPass(compiler, new PeepholeFoldConstants(late)); return peepholePass; } @Override protected int getNumRepetitions() { // Reduce this to 1 if we get better expression evaluators. return 2; } private void foldSame(String js) { testSame(js); } private void fold(String js, String expected) { test(js, expected); } private void fold(String js, String expected, DiagnosticType warning) { test(js, expected, null, warning); } // TODO(user): This is same as fold() except it uses string comparison. Any // test that needs tell us where a folding is constructing an invalid AST. private void assertResultString(String js, String expected) { PeepholeFoldConstantsTest scTest = new PeepholeFoldConstantsTest(false); scTest.test(js, expected); } public void testUndefinedComparison1() { fold("undefined == undefined", "true"); fold("undefined == null", "true"); fold("undefined == void 0", "true"); fold("undefined == 0", "false"); fold("undefined == 1", "false"); fold("undefined == 'hi'", "false"); fold("undefined == true", "false"); fold("undefined == false", "false"); fold("undefined === undefined", "true"); fold("undefined === null", "false"); fold("undefined === void 0", "true"); foldSame("undefined == this"); foldSame("undefined == x"); fold("undefined != undefined", "false"); fold("undefined != null", "false"); fold("undefined != void 0", "false"); fold("undefined != 0", "true"); fold("undefined != 1", "true"); fold("undefined != 'hi'", "true"); fold("undefined != true", "true"); fold("undefined != false", "true"); fold("undefined !== undefined", "false"); fold("undefined !== void 0", "false"); fold("undefined !== null", "true"); foldSame("undefined != this"); foldSame("undefined != x"); fold("undefined < undefined", "false"); fold("undefined > undefined", "false"); fold("undefined >= undefined", "false"); fold("undefined <= undefined", "false"); fold("0 < undefined", "false"); fold("true > undefined", "false"); fold("'hi' >= undefined", "false"); fold("null <= undefined", "false"); fold("undefined < 0", "false"); fold("undefined > true", "false"); fold("undefined >= 'hi'", "false"); fold("undefined <= null", "false"); fold("null == undefined", "true"); fold("0 == undefined", "false"); fold("1 == undefined", "false"); fold("'hi' == undefined", "false"); fold("true == undefined", "false"); fold("false == undefined", "false"); fold("null === undefined", "false"); fold("void 0 === undefined", "true"); fold("undefined == NaN", "false"); fold("NaN == undefined", "false"); fold("undefined == Infinity", "false"); fold("Infinity == undefined", "false"); fold("undefined == -Infinity", "false"); fold("-Infinity == undefined", "false"); fold("({}) == undefined", "false"); fold("undefined == ({})", "false"); fold("([]) == undefined", "false"); fold("undefined == ([])", "false"); fold("(/a/g) == undefined", "false"); fold("undefined == (/a/g)", "false"); fold("(function(){}) == undefined", "false"); fold("undefined == (function(){})", "false"); fold("undefined != NaN", "true"); fold("NaN != undefined", "true"); fold("undefined != Infinity", "true"); fold("Infinity != undefined", "true"); fold("undefined != -Infinity", "true"); fold("-Infinity != undefined", "true"); fold("({}) != undefined", "true"); fold("undefined != ({})", "true"); fold("([]) != undefined", "true"); fold("undefined != ([])", "true"); fold("(/a/g) != undefined", "true"); fold("undefined != (/a/g)", "true"); fold("(function(){}) != undefined", "true"); fold("undefined != (function(){})", "true"); foldSame("this == undefined"); foldSame("x == undefined"); } public void testUndefinedComparison2() { fold("\"123\" !== void 0", "true"); fold("\"123\" === void 0", "false"); fold("void 0 !== \"123\"", "true"); fold("void 0 === \"123\"", "false"); } public void testUndefinedComparison3() { fold("\"123\" !== undefined", "true"); fold("\"123\" === undefined", "false"); fold("undefined !== \"123\"", "true"); fold("undefined === \"123\"", "false"); } public void testUndefinedComparison4() { fold("1 !== void 0", "true"); fold("1 === void 0", "false"); fold("null !== void 0", "true"); fold("null === void 0", "false"); fold("undefined !== void 0", "false"); fold("undefined === void 0", "true"); } public void testNullComparison1() { fold("null == undefined", "true"); fold("null == null", "true"); fold("null == void 0", "true"); fold("null == 0", "false"); fold("null == 1", "false"); fold("null == 'hi'", "false"); fold("null == true", "false"); fold("null == false", "false"); fold("null === undefined", "false"); fold("null === null", "true"); fold("null === void 0", "false"); foldSame("null == this"); foldSame("null == x"); fold("null != undefined", "false"); fold("null != null", "false"); fold("null != void 0", "false"); fold("null != 0", "true"); fold("null != 1", "true"); fold("null != 'hi'", "true"); fold("null != true", "true"); fold("null != false", "true"); fold("null !== undefined", "true"); fold("null !== void 0", "true"); fold("null !== null", "false"); foldSame("null != this"); foldSame("null != x"); fold("null < null", "false"); fold("null > null", "false"); fold("null >= null", "true"); fold("null <= null", "true"); foldSame("0 < null"); // foldable fold("true > null", "true"); foldSame("'hi' >= null"); // foldable fold("null <= null", "true"); foldSame("null < 0"); // foldable fold("null > true", "false"); foldSame("null >= 'hi'"); // foldable fold("null <= null", "true"); fold("null == null", "true"); fold("0 == null", "false"); fold("1 == null", "false"); fold("'hi' == null", "false"); fold("true == null", "false"); fold("false == null", "false"); fold("null === null", "true"); fold("void 0 === null", "false"); fold("null == NaN", "false"); fold("NaN == null", "false"); fold("null == Infinity", "false"); fold("Infinity == null", "false"); fold("null == -Infinity", "false"); fold("-Infinity == null", "false"); fold("({}) == null", "false"); fold("null == ({})", "false"); fold("([]) == null", "false"); fold("null == ([])", "false"); fold("(/a/g) == null", "false"); fold("null == (/a/g)", "false"); fold("(function(){}) == null", "false"); fold("null == (function(){})", "false"); fold("null != NaN", "true"); fold("NaN != null", "true"); fold("null != Infinity", "true"); fold("Infinity != null", "true"); fold("null != -Infinity", "true"); fold("-Infinity != null", "true"); fold("({}) != null", "true"); fold("null != ({})", "true"); fold("([]) != null", "true"); fold("null != ([])", "true"); fold("(/a/g) != null", "true"); fold("null != (/a/g)", "true"); fold("(function(){}) != null", "true"); fold("null != (function(){})", "true"); foldSame("({a:f()}) == null"); foldSame("null == ({a:f()})"); foldSame("([f()]) == null"); foldSame("null == ([f()])"); foldSame("this == null"); foldSame("x == null"); } public void testUnaryOps() { // These cases are handled by PeepholeRemoveDeadCode. foldSame("!foo()"); foldSame("~foo()"); foldSame("-foo()"); // These cases are handled here. fold("a=!true", "a=false"); fold("a=!10", "a=false"); fold("a=!false", "a=true"); fold("a=!foo()", "a=!foo()"); fold("a=-0", "a=-0.0"); fold("a=-(0)", "a=-0.0"); fold("a=-Infinity", "a=-Infinity"); fold("a=-NaN", "a=NaN"); fold("a=-foo()", "a=-foo()"); fold("a=~~0", "a=0"); fold("a=~~10", "a=10"); fold("a=~-7", "a=6"); fold("a=+true", "a=1"); fold("a=+10", "a=10"); fold("a=+false", "a=0"); foldSame("a=+foo()"); foldSame("a=+f"); fold("a=+(f?true:false)", "a=+(f?1:0)"); // TODO(johnlenz): foldable fold("a=+0", "a=0"); fold("a=+Infinity", "a=Infinity"); fold("a=+NaN", "a=NaN"); fold("a=+-7", "a=-7"); fold("a=+.5", "a=.5"); fold("a=~0x100000000", "a=~0x100000000", PeepholeFoldConstants.BITWISE_OPERAND_OUT_OF_RANGE); fold("a=~-0x100000000", "a=~-0x100000000", PeepholeFoldConstants.BITWISE_OPERAND_OUT_OF_RANGE); testSame("a=~.5", PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND); } public void testUnaryOpsStringCompare() { // Negatives are folded into a single number node. assertResultString("a=-1", "a=-1"); assertResultString("a=~0", "a=-1"); assertResultString("a=~1", "a=-2"); assertResultString("a=~101", "a=-102"); } public void testFoldLogicalOp() { fold("x = true && x", "x = x"); foldSame("x = [foo()] && x"); fold("x = false && x", "x = false"); fold("x = true || x", "x = true"); fold("x = false || x", "x = x"); fold("x = 0 && x", "x = 0"); fold("x = 3 || x", "x = 3"); fold("x = false || 0", "x = 0"); // unfoldable, because the right-side may be the result fold("a = x && true", "a=x&&true"); fold("a = x && false", "a=x&&false"); fold("a = x || 3", "a=x||3"); fold("a = x || false", "a=x||false"); fold("a = b ? c : x || false", "a=b?c:x||false"); fold("a = b ? x || false : c", "a=b?x||false:c"); fold("a = b ? c : x && true", "a=b?c:x&&true"); fold("a = b ? x && true : c", "a=b?x&&true:c"); // folded, but not here. foldSame("a = x || false ? b : c"); foldSame("a = x && true ? b : c"); fold("x = foo() || true || bar()", "x = foo()||true"); fold("x = foo() || false || bar()", "x = foo()||bar()"); fold("x = foo() || true && bar()", "x = foo()||bar()"); fold("x = foo() || false && bar()", "x = foo()||false"); fold("x = foo() && false && bar()", "x = foo()&&false"); fold("x = foo() && true && bar()", "x = foo()&&bar()"); fold("x = foo() && false || bar()", "x = foo()&&false||bar()"); fold("1 && b()", "b()"); fold("a() && (1 && b())", "a() && b()"); // TODO(johnlenz): Consider folding the following to: // "(a(),1) && b(); fold("(a() && 1) && b()", "(a() && 1) && b()"); // Really not foldable, because it would change the type of the // expression if foo() returns something equivalent, but not // identical, to true. Cf. FoldConstants.tryFoldAndOr(). foldSame("x = foo() && true || bar()"); foldSame("foo() && true || bar()"); } public void testFoldBitwiseOp() { fold("x = 1 & 1", "x = 1"); fold("x = 1 & 2", "x = 0"); fold("x = 3 & 1", "x = 1"); fold("x = 3 & 3", "x = 3"); fold("x = 1 | 1", "x = 1"); fold("x = 1 | 2", "x = 3"); fold("x = 3 | 1", "x = 3"); fold("x = 3 | 3", "x = 3"); fold("x = 1 ^ 1", "x = 0"); fold("x = 1 ^ 2", "x = 3"); fold("x = 3 ^ 1", "x = 2"); fold("x = 3 ^ 3", "x = 0"); fold("x = -1 & 0", "x = 0"); fold("x = 0 & -1", "x = 0"); fold("x = 1 & 4", "x = 0"); fold("x = 2 & 3", "x = 2"); // make sure we fold only when we are supposed to -- not when doing so would // lose information or when it is performed on nonsensical arguments. fold("x = 1 & 1.1", "x = 1"); fold("x = 1.1 & 1", "x = 1"); fold("x = 1 & 3000000000", "x = 0"); fold("x = 3000000000 & 1", "x = 0"); // Try some cases with | as well fold("x = 1 | 4", "x = 5"); fold("x = 1 | 3", "x = 3"); fold("x = 1 | 1.1", "x = 1"); foldSame("x = 1 | 3E9"); fold("x = 1 | 3000000001", "x = -1294967295"); } public void testFoldBitwiseOp2() { fold("x = y & 1 & 1", "x = y & 1"); fold("x = y & 1 & 2", "x = y & 0"); fold("x = y & 3 & 1", "x = y & 1"); fold("x = 3 & y & 1", "x = y & 1"); fold("x = y & 3 & 3", "x = y & 3"); fold("x = 3 & y & 3", "x = y & 3"); fold("x = y | 1 | 1", "x = y | 1"); fold("x = y | 1 | 2", "x = y | 3"); fold("x = y | 3 | 1", "x = y | 3"); fold("x = 3 | y | 1", "x = y | 3"); fold("x = y | 3 | 3", "x = y | 3"); fold("x = 3 | y | 3", "x = y | 3"); fold("x = y ^ 1 ^ 1", "x = y ^ 0"); fold("x = y ^ 1 ^ 2", "x = y ^ 3"); fold("x = y ^ 3 ^ 1", "x = y ^ 2"); fold("x = 3 ^ y ^ 1", "x = y ^ 2"); fold("x = y ^ 3 ^ 3", "x = y ^ 0"); fold("x = 3 ^ y ^ 3", "x = y ^ 0"); fold("x = Infinity | NaN", "x=0"); fold("x = 12 | NaN", "x=12"); } public void testFoldingMixTypesLate() { late = true; fold("x = x + '2'", "x+='2'"); fold("x = +x + +'2'", "x = +x + 2"); fold("x = x - '2'", "x-=2"); fold("x = x ^ '2'", "x^=2"); fold("x = '2' ^ x", "x^=2"); fold("x = '2' & x", "x&=2"); fold("x = '2' | x", "x|=2"); fold("x = '2' | y", "x=2|y"); fold("x = y | '2'", "x=y|2"); fold("x = y | (a && '2')", "x=y|(a&&2)"); fold("x = y | (a,'2')", "x=y|(a,2)"); fold("x = y | (a?'1':'2')", "x=y|(a?1:2)"); fold("x = y | ('x'?'1':'2')", "x=y|('x'?1:2)"); } public void testFoldingMixTypesEarly() { late = false; foldSame("x = x + '2'"); fold("x = +x + +'2'", "x = +x + 2"); fold("x = x - '2'", "x = x - 2"); fold("x = x ^ '2'", "x = x ^ 2"); fold("x = '2' ^ x", "x = 2 ^ x"); fold("x = '2' & x", "x = 2 & x"); fold("x = '2' | x", "x = 2 | x"); fold("x = '2' | y", "x=2|y"); fold("x = y | '2'", "x=y|2"); fold("x = y | (a && '2')", "x=y|(a&&2)"); fold("x = y | (a,'2')", "x=y|(a,2)"); fold("x = y | (a?'1':'2')", "x=y|(a?1:2)"); fold("x = y | ('x'?'1':'2')", "x=y|('x'?1:2)"); } public void testFoldingAdd() { fold("x = null + true", "x=1"); foldSame("x = a + true"); } public void testFoldBitwiseOpStringCompare() { assertResultString("x = -1 | 0", "x=-1"); // EXPR_RESULT case is in in PeepholeIntegrationTest } public void testFoldBitShifts() { fold("x = 1 << 0", "x = 1"); fold("x = -1 << 0", "x = -1"); fold("x = 1 << 1", "x = 2"); fold("x = 3 << 1", "x = 6"); fold("x = 1 << 8", "x = 256"); fold("x = 1 >> 0", "x = 1"); fold("x = -1 >> 0", "x = -1"); fold("x = 1 >> 1", "x = 0"); fold("x = 2 >> 1", "x = 1"); fold("x = 5 >> 1", "x = 2"); fold("x = 127 >> 3", "x = 15"); fold("x = 3 >> 1", "x = 1"); fold("x = 3 >> 2", "x = 0"); fold("x = 10 >> 1", "x = 5"); fold("x = 10 >> 2", "x = 2"); fold("x = 10 >> 5", "x = 0"); fold("x = 10 >>> 1", "x = 5"); fold("x = 10 >>> 2", "x = 2"); fold("x = 10 >>> 5", "x = 0"); fold("x = -1 >>> 1", "x = 2147483647"); // 0x7fffffff fold("x = -1 >>> 0", "x = 4294967295"); // 0xffffffff fold("x = -2 >>> 0", "x = 4294967294"); // 0xfffffffe testSame("3000000000 << 1", PeepholeFoldConstants.BITWISE_OPERAND_OUT_OF_RANGE); testSame("1 << 32", PeepholeFoldConstants.SHIFT_AMOUNT_OUT_OF_BOUNDS); testSame("1 << -1", PeepholeFoldConstants.SHIFT_AMOUNT_OUT_OF_BOUNDS); testSame("3000000000 >> 1", PeepholeFoldConstants.BITWISE_OPERAND_OUT_OF_RANGE); testSame("1 >> 32", PeepholeFoldConstants.SHIFT_AMOUNT_OUT_OF_BOUNDS); testSame("1.5 << 0", PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND); testSame("1 << .5", PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND); testSame("1.5 >>> 0", PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND); testSame("1 >>> .5", PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND); testSame("1.5 >> 0", PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND); testSame("1 >> .5", PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND); } public void testFoldBitShiftsStringCompare() { // Negative numbers. assertResultString("x = -1 << 1", "x=-2"); assertResultString("x = -1 << 8", "x=-256"); assertResultString("x = -1 >> 1", "x=-1"); assertResultString("x = -2 >> 1", "x=-1"); assertResultString("x = -1 >> 0", "x=-1"); } public void testStringAdd() { fold("x = 'a' + \"bc\"", "x = \"abc\""); fold("x = 'a' + 5", "x = \"a5\""); fold("x = 5 + 'a'", "x = \"5a\""); fold("x = 'a' + ''", "x = \"a\""); fold("x = \"a\" + foo()", "x = \"a\"+foo()"); fold("x = foo() + 'a' + 'b'", "x = foo()+\"ab\""); fold("x = (foo() + 'a') + 'b'", "x = foo()+\"ab\""); // believe it! fold("x = foo() + 'a' + 'b' + 'cd' + bar()", "x = foo()+\"abcd\"+bar()"); fold("x = foo() + 2 + 'b'", "x = foo()+2+\"b\""); // don't fold! fold("x = foo() + 'a' + 2", "x = foo()+\"a2\""); fold("x = '' + null", "x = \"null\""); fold("x = true + '' + false", "x = \"truefalse\""); fold("x = '' + []", "x = ''"); // cannot fold (but nice if we can) } public void testIssue821() { foldSame("var a =(Math.random()>0.5? '1' : 2 ) + 3 + 4;"); foldSame("var a = ((Math.random() ? 0 : 1) ||" + "(Math.random()>0.5? '1' : 2 )) + 3 + 4;"); } public void testFoldConstructor() { fold("x = this[new String('a')]", "x = this['a']"); fold("x = ob[new String(12)]", "x = ob['12']"); fold("x = ob[new String(false)]", "x = ob['false']"); fold("x = ob[new String(null)]", "x = ob['null']"); fold("x = 'a' + new String('b')", "x = 'ab'"); fold("x = 'a' + new String(23)", "x = 'a23'"); fold("x = 2 + new String(1)", "x = '21'"); foldSame("x = ob[new String(a)]"); foldSame("x = new String('a')"); foldSame("x = (new String('a'))[3]"); } public void testFoldArithmetic() { fold("x = 10 + 20", "x = 30"); fold("x = 2 / 4", "x = 0.5"); fold("x = 2.25 * 3", "x = 6.75"); fold("z = x * y", "z = x * y"); fold("x = y * 5", "x = y * 5"); fold("x = 1 / 0", "x = 1 / 0"); fold("x = 3 % 2", "x = 1"); fold("x = 3 % -2", "x = 1"); fold("x = -1 % 3", "x = -1"); fold("x = 1 % 0", "x = 1 % 0"); } public void testFoldArithmetic2() { foldSame("x = y + 10 + 20"); foldSame("x = y / 2 / 4"); fold("x = y * 2.25 * 3", "x = y * 6.75"); fold("z = x * y", "z = x * y"); fold("x = y * 5", "x = y * 5"); fold("x = y + (z * 24 * 60 * 60 * 1000)", "x = y + z * 864E5"); } public void testFoldArithmetic3() { fold("x = null * undefined", "x = NaN"); fold("x = null * 1", "x = 0"); fold("x = (null - 1) * 2", "x = -2"); fold("x = (null + 1) * 2", "x = 2"); } public void testFoldArithmeticInfinity() { fold("x=-Infinity-2", "x=-Infinity"); fold("x=Infinity-2", "x=Infinity"); fold("x=Infinity*5", "x=Infinity"); } public void testFoldArithmeticStringComp() { // Negative Numbers. assertResultString("x = 10 - 20", "x=-10"); } public void testFoldComparison() { fold("x = 0 == 0", "x = true"); fold("x = 1 == 2", "x = false"); fold("x = 'abc' == 'def'", "x = false"); fold("x = 'abc' == 'abc'", "x = true"); fold("x = \"\" == ''", "x = true"); fold("x = foo() == bar()", "x = foo()==bar()"); fold("x = 1 != 0", "x = true"); fold("x = 'abc' != 'def'", "x = true"); fold("x = 'a' != 'a'", "x = false"); fold("x = 1 < 20", "x = true"); fold("x = 3 < 3", "x = false"); fold("x = 10 > 1.0", "x = true"); fold("x = 10 > 10.25", "x = false"); fold("x = y == y", "x = y==y"); fold("x = y < y", "x = false"); fold("x = y > y", "x = false"); fold("x = 1 <= 1", "x = true"); fold("x = 1 <= 0", "x = false"); fold("x = 0 >= 0", "x = true"); fold("x = -1 >= 9", "x = false"); fold("x = true == true", "x = true"); fold("x = false == false", "x = true"); fold("x = false == null", "x = false"); fold("x = false == true", "x = false"); fold("x = true == null", "x = false"); fold("0 == 0", "true"); fold("1 == 2", "false"); fold("'abc' == 'def'", "false"); fold("'abc' == 'abc'", "true"); fold("\"\" == ''", "true"); foldSame("foo() == bar()"); fold("1 != 0", "true"); fold("'abc' != 'def'", "true"); fold("'a' != 'a'", "false"); fold("1 < 20", "true"); fold("3 < 3", "false"); fold("10 > 1.0", "true"); fold("10 > 10.25", "false"); foldSame("x == x"); fold("x < x", "false"); fold("x > x", "false"); fold("1 <= 1", "true"); fold("1 <= 0", "false"); fold("0 >= 0", "true"); fold("-1 >= 9", "false"); fold("true == true", "true"); fold("false == null", "false"); fold("false == true", "false"); fold("true == null", "false"); } // ===, !== comparison tests public void testFoldComparison2() { fold("x = 0 === 0", "x = true"); fold("x = 1 === 2", "x = false"); fold("x = 'abc' === 'def'", "x = false"); fold("x = 'abc' === 'abc'", "x = true"); fold("x = \"\" === ''", "x = true"); fold("x = foo() === bar()", "x = foo()===bar()"); fold("x = 1 !== 0", "x = true"); fold("x = 'abc' !== 'def'", "x = true"); fold("x = 'a' !== 'a'", "x = false"); fold("x = y === y", "x = y===y"); fold("x = true === true", "x = true"); fold("x = false === false", "x = true"); fold("x = false === null", "x = false"); fold("x = false === true", "x = false"); fold("x = true === null", "x = false"); fold("0 === 0", "true"); fold("1 === 2", "false"); fold("'abc' === 'def'", "false"); fold("'abc' === 'abc'", "true"); fold("\"\" === ''", "true"); foldSame("foo() === bar()"); // TODO(johnlenz): It would be nice to handle these cases as well. foldSame("1 === '1'"); foldSame("1 === true"); foldSame("1 !== '1'"); foldSame("1 !== true"); fold("1 !== 0", "true"); fold("'abc' !== 'def'", "true"); fold("'a' !== 'a'", "false"); foldSame("x === x"); fold("true === true", "true"); fold("false === null", "false"); fold("false === true", "false"); fold("true === null", "false"); } public void testFoldComparison3() { fold("x = !1 == !0", "x = false"); fold("x = !0 == !0", "x = true"); fold("x = !1 == !1", "x = true"); fold("x = !1 == null", "x = false"); fold("x = !1 == !0", "x = false"); fold("x = !0 == null", "x = false"); fold("!0 == !0", "true"); fold("!1 == null", "false"); fold("!1 == !0", "false"); fold("!0 == null", "false"); fold("x = !0 === !0", "x = true"); fold("x = !1 === !1", "x = true"); fold("x = !1 === null", "x = false"); fold("x = !1 === !0", "x = false"); fold("x = !0 === null", "x = false"); fold("!0 === !0", "true"); fold("!1 === null", "false"); fold("!1 === !0", "false"); fold("!0 === null", "false"); } public void testFoldGetElem() { fold("x = [,10][0]", "x = void 0"); fold("x = [10, 20][0]", "x = 10"); fold("x = [10, 20][1]", "x = 20"); testSame("x = [10, 20][0.5]", PeepholeFoldConstants.INVALID_GETELEM_INDEX_ERROR); testSame("x = [10, 20][-1]", PeepholeFoldConstants.INDEX_OUT_OF_BOUNDS_ERROR); testSame("x = [10, 20][2]", PeepholeFoldConstants.INDEX_OUT_OF_BOUNDS_ERROR); foldSame("x = [foo(), 0][1]"); fold("x = [0, foo()][1]", "x = foo()"); foldSame("x = [0, foo()][0]"); } public void testFoldComplex() { fold("x = (3 / 1.0) + (1 * 2)", "x = 5"); fold("x = (1 == 1.0) && foo() && true", "x = foo()&&true"); fold("x = 'abc' + 5 + 10", "x = \"abc510\""); } public void testFoldLeft() { foldSame("(+x - 1) + 2"); // not yet fold("(+x + 1) + 2", "+x + 3"); } public void testFoldArrayLength() { // Can fold fold("x = [].length", "x = 0"); fold("x = [1,2,3].length", "x = 3"); fold("x = [a,b].length", "x = 2"); // Not handled yet fold("x = [,,1].length", "x = 3"); // Cannot fold fold("x = [foo(), 0].length", "x = [foo(),0].length"); fold("x = y.length", "x = y.length"); } public void testFoldStringLength() { // Can fold basic strings. fold("x = ''.length", "x = 0"); fold("x = '123'.length", "x = 3"); // Test Unicode escapes are accounted for. fold("x = '123\u01dc'.length", "x = 4"); } public void testFoldTypeof() { fold("x = typeof 1", "x = \"number\""); fold("x = typeof 'foo'", "x = \"string\""); fold("x = typeof true", "x = \"boolean\""); fold("x = typeof false", "x = \"boolean\""); fold("x = typeof null", "x = \"object\""); fold("x = typeof undefined", "x = \"undefined\""); fold("x = typeof void 0", "x = \"undefined\""); fold("x = typeof []", "x = \"object\""); fold("x = typeof [1]", "x = \"object\""); fold("x = typeof [1,[]]", "x = \"object\""); fold("x = typeof {}", "x = \"object\""); fold("x = typeof function() {}", "x = 'function'"); foldSame("x = typeof[1,[foo()]]"); foldSame("x = typeof{bathwater:baby()}"); } public void testFoldInstanceOf() { // Non object types are never instances of anything. fold("64 instanceof Object", "false"); fold("64 instanceof Number", "false"); fold("'' instanceof Object", "false"); fold("'' instanceof String", "false"); fold("true instanceof Object", "false"); fold("true instanceof Boolean", "false"); fold("!0 instanceof Object", "false"); fold("!0 instanceof Boolean", "false"); fold("false instanceof Object", "false"); fold("null instanceof Object", "false"); fold("undefined instanceof Object", "false"); fold("NaN instanceof Object", "false"); fold("Infinity instanceof Object", "false"); // Array and object literals are known to be objects. fold("[] instanceof Object", "true"); fold("({}) instanceof Object", "true"); // These cases is foldable, but no handled currently. foldSame("new Foo() instanceof Object"); // These would require type information to fold. foldSame("[] instanceof Foo"); foldSame("({}) instanceof Foo"); fold("(function() {}) instanceof Object", "true"); // An unknown value should never be folded. foldSame("x instanceof Foo"); } public void testDivision() { // Make sure the 1/3 does not expand to 0.333333 fold("print(1/3)", "print(1/3)"); // Decimal form is preferable to fraction form when strings are the // same length. fold("print(1/2)", "print(0.5)"); } public void testAssignOpsLate() { late = true; fold("x=x+y", "x+=y"); foldSame("x=y+x"); fold("x=x*y", "x*=y"); fold("x=y*x", "x*=y"); fold("x.y=x.y+z", "x.y+=z"); foldSame("next().x = next().x + 1"); fold("x=x-y", "x-=y"); foldSame("x=y-x"); fold("x=x|y", "x|=y"); fold("x=y|x", "x|=y"); fold("x=x*y", "x*=y"); fold("x=y*x", "x*=y"); fold("x.y=x.y+z", "x.y+=z"); foldSame("next().x = next().x + 1"); // This is OK, really. fold("({a:1}).a = ({a:1}).a + 1", "({a:1}).a = 2"); } public void testAssignOpsEarly() { late = false; foldSame("x=x+y"); foldSame("x=y+x"); foldSame("x=x*y"); foldSame("x=y*x"); foldSame("x.y=x.y+z"); foldSame("next().x = next().x + 1"); foldSame("x=x-y"); foldSame("x=y-x"); foldSame("x=x|y"); foldSame("x=y|x"); foldSame("x=x*y"); foldSame("x=y*x"); foldSame("x.y=x.y+z"); foldSame("next().x = next().x + 1"); // This is OK, really. fold("({a:1}).a = ({a:1}).a + 1", "({a:1}).a = 2"); } public void testFoldAdd1() { fold("x=false+1","x=1"); fold("x=true+1","x=2"); fold("x=1+false","x=1"); fold("x=1+true","x=2"); } public void testFoldLiteralNames() { foldSame("NaN == NaN"); foldSame("Infinity == Infinity"); foldSame("Infinity == NaN"); fold("undefined == NaN", "false"); fold("undefined == Infinity", "false"); foldSame("Infinity >= Infinity"); foldSame("NaN >= NaN"); } public void testFoldLiteralsTypeMismatches() { fold("true == true", "true"); fold("true == false", "false"); fold("true == null", "false"); fold("false == null", "false"); // relational operators convert its operands fold("null <= null", "true"); // 0 = 0 fold("null >= null", "true"); fold("null > null", "false"); fold("null < null", "false"); fold("false >= null", "true"); // 0 = 0 fold("false <= null", "true"); fold("false > null", "false"); fold("false < null", "false"); fold("true >= null", "true"); // 1 > 0 fold("true <= null", "false"); fold("true > null", "true"); fold("true < null", "false"); fold("true >= false", "true"); // 1 > 0 fold("true <= false", "false"); fold("true > false", "true"); fold("true < false", "false"); } public void testFoldLeftChildConcat() { foldSame("x +5 + \"1\""); fold("x+\"5\" + \"1\"", "x + \"51\""); // fold("\"a\"+(c+\"b\")","\"a\"+c+\"b\""); fold("\"a\"+(\"b\"+c)","\"ab\"+c"); } public void testFoldLeftChildOp() { fold("x * Infinity * 2", "x * Infinity"); foldSame("x - Infinity - 2"); // want "x-Infinity" foldSame("x - 1 + Infinity"); foldSame("x - 2 + 1"); foldSame("x - 2 + 3"); foldSame("1 + x - 2 + 1"); foldSame("1 + x - 2 + 3"); foldSame("1 + x - 2 + 3 - 1"); foldSame("f(x)-0"); foldSame("x-0-0"); foldSame("x+2-2+2"); foldSame("x+2-2+2-2"); foldSame("x-2+2"); foldSame("x-2+2-2"); foldSame("x-2+2-2+2"); foldSame("1+x-0-NaN"); foldSame("1+f(x)-0-NaN"); foldSame("1+x-0+NaN"); foldSame("1+f(x)-0+NaN"); foldSame("1+x+NaN"); // unfoldable foldSame("x+2-2"); // unfoldable foldSame("x+2"); // nothing to do foldSame("x-2"); // nothing to do } public void testFoldSimpleArithmeticOp() { foldSame("x*NaN"); foldSame("NaN/y"); foldSame("f(x)-0"); foldSame("f(x)*1"); foldSame("1*f(x)"); foldSame("0+a+b"); foldSame("0-a-b"); foldSame("a+b-0"); foldSame("(1+x)*NaN"); foldSame("(1+f(x))*NaN"); // don't fold side-effects } public void testFoldLiteralsAsNumbers() { fold("x/'12'","x/12"); fold("x/('12'+'6')", "x/126"); fold("true*x", "1*x"); fold("x/false", "x/0"); // should we add an error check? :) } public void testNotFoldBackToTrueFalse() { late = false; fold("!0", "true"); fold("!1", "false"); fold("!3", "false"); late = true; foldSame("!0"); foldSame("!1"); fold("!3", "false"); foldSame("false"); foldSame("true"); } public void testFoldBangConstants() { fold("1 + !0", "2"); fold("1 + !1", "1"); fold("'a ' + !1", "'a false'"); fold("'a ' + !0", "'a true'"); } public void testFoldMixed() { fold("''+[1]", "'1'"); foldSame("false+[]"); // would like: "\"false\"" } public void testFoldVoid() { foldSame("void 0"); fold("void 1", "void 0"); fold("void x", "void 0"); fold("void x()", "void x()"); } public void testObjectLiteral() { test("(!{})", "false"); test("(!{a:1})", "false"); testSame("(!{a:foo()})"); testSame("(!{'a':foo()})"); } public void testArrayLiteral() { test("(![])", "false"); test("(![1])", "false"); test("(![a])", "false"); testSame("(![foo()])"); } public void testIssue601() { testSame("'\\v' == 'v'"); testSame("'v' == '\\v'"); testSame("'\\u000B' == '\\v'"); } public void testFoldObjectLiteralRef1() { // Leave extra side-effects in place testSame("var x = ({a:foo(),b:bar()}).a"); testSame("var x = ({a:1,b:bar()}).a"); testSame("function f() { return {b:foo(), a:2}.a; }"); // on the LHS the object act as a temporary leave it in place. testSame("({a:x}).a = 1"); test("({a:x}).a += 1", "({a:x}).a = x + 1"); testSame("({a:x}).a ++"); testSame("({a:x}).a --"); // functions can't reference the object through 'this'. testSame("({a:function(){return this}}).a"); testSame("({get a() {return this}}).a"); testSame("({set a(b) {return this}}).a"); // Leave unknown props alone, the might be on the prototype testSame("({}).a"); // setters by themselves don't provide a definition testSame("({}).a"); testSame("({set a(b) {}}).a"); // sets don't hide other definitions. test("({a:1,set a(b) {}}).a", "1"); // get is transformed to a call (gets don't have self referential names) test("({get a() {}}).a", "(function (){})()"); // sets don't hide other definitions. test("({get a() {},set a(b) {}}).a", "(function (){})()"); // a function remains a function not a call. test("var x = ({a:function(){return 1}}).a", "var x = function(){return 1}"); test("var x = ({a:1}).a", "var x = 1"); test("var x = ({a:1, a:2}).a", "var x = 2"); test("var x = ({a:1, a:foo()}).a", "var x = foo()"); test("var x = ({a:foo()}).a", "var x = foo()"); test("function f() { return {a:1, b:2}.a; }", "function f() { return 1; }"); // GETELEM is handled the same way. test("var x = ({'a':1})['a']", "var x = 1"); } public void testFoldObjectLiteralRef2() { late = false; test("({a:x}).a += 1", "({a:x}).a = x + 1"); late = true; testSame("({a:x}).a += 1"); } public void testIEString() { testSame("!+'\\v1'"); } public void testIssue522() { testSame("[][1] = 1;"); } private static final List<String> LITERAL_OPERANDS = ImmutableList.of( "null", "undefined", "void 0", "true", "false", "!0", "!1", "0", "1", "''", "'123'", "'abc'", "'def'", "NaN", "Infinity", // TODO(nicksantos): Add more literals "-Infinity" //"({})", // "[]" //"[0]", //"Object", //"(function() {})" ); public void testInvertibleOperators() { Map<String, String> inverses = ImmutableMap.<String, String>builder() .put("==", "!=") .put("===", "!==") .put("<=", ">") .put("<", ">=") .put(">=", "<") .put(">", "<=") .put("!=", "==") .put("!==", "===") .build(); Set<String> comparators = ImmutableSet.of("<=", "<", ">=", ">"); Set<String> equalitors = ImmutableSet.of("==", "==="); Set<String> uncomparables = ImmutableSet.of("undefined", "void 0"); List<String> operators = ImmutableList.copyOf(inverses.values()); for (int iOperandA = 0; iOperandA < LITERAL_OPERANDS.size(); iOperandA++) { for (int iOperandB = 0; iOperandB < LITERAL_OPERANDS.size(); iOperandB++) { for (int iOp = 0; iOp < operators.size(); iOp++) { String a = LITERAL_OPERANDS.get(iOperandA); String b = LITERAL_OPERANDS.get(iOperandB); String op = operators.get(iOp); String inverse = inverses.get(op); // Test invertability. if (comparators.contains(op) && (uncomparables.contains(a) || uncomparables.contains(b))) { assertSameResults(join(a, op, b), "false"); assertSameResults(join(a, inverse, b), "false"); } else if (a.equals(b) && equalitors.contains(op)) { if (a.equals("NaN") || a.equals("Infinity") || a.equals("-Infinity")) { foldSame(join(a, op, b)); foldSame(join(a, inverse, b)); } else { assertSameResults(join(a, op, b), "true"); assertSameResults(join(a, inverse, b), "false"); } } else { assertNotSameResults(join(a, op, b), join(a, inverse, b)); } } } } } public void testCommutativeOperators() { late = true; List<String> operators = ImmutableList.of( "==", "!=", "===", "!==", "*", "|", "&", "^"); for (int iOperandA = 0; iOperandA < LITERAL_OPERANDS.size(); iOperandA++) { for (int iOperandB = iOperandA; iOperandB < LITERAL_OPERANDS.size(); iOperandB++) { for (int iOp = 0; iOp < operators.size(); iOp++) { String a = LITERAL_OPERANDS.get(iOperandA); String b = LITERAL_OPERANDS.get(iOperandB); String op = operators.get(iOp); // Test commutativity. // TODO(nicksantos): Eventually, all cases should be collapsed. assertSameResultsOrUncollapsed(join(a, op, b), join(b, op, a)); } } } } public void testConvertToNumberNegativeInf() { foldSame("var x = 3 * (r ? Infinity : -Infinity);"); } private String join(String operandA, String op, String operandB) { return operandA + " " + op + " " + operandB; } private void assertSameResultsOrUncollapsed(String exprA, String exprB) { String resultA = process(exprA); String resultB = process(exprB); // TODO: why is nothing done with this? if (resultA.equals(print(exprA))) { foldSame(exprA); foldSame(exprB); } else { assertSameResults(exprA, exprB); } } private void assertSameResults(String exprA, String exprB) { assertEquals( "Expressions did not fold the same\nexprA: " + exprA + "\nexprB: " + exprB, process(exprA), process(exprB)); } private void assertNotSameResults(String exprA, String exprB) { assertFalse( "Expressions folded the same\nexprA: " + exprA + "\nexprB: " + exprB, process(exprA).equals(process(exprB))); } private String process(String js) { return printHelper(js, true); } private String print(String js) { return printHelper(js, false); } private String printHelper(String js, boolean runProcessor) { Compiler compiler = createCompiler(); CompilerOptions options = getOptions(); compiler.init( ImmutableList.<SourceFile>of(), ImmutableList.of(SourceFile.fromCode("testcode", js)), options); Node root = compiler.parseInputs(); assertTrue("Unexpected parse error(s): " + Joiner.on("\n").join(compiler.getErrors()) + "\nEXPR: " + js, root != null); Node externsRoot = root.getFirstChild(); Node mainRoot = externsRoot.getNext(); if (runProcessor) { getProcessor(compiler).process(externsRoot, mainRoot); } return compiler.toSource(mainRoot); } }
/* * Copyright 2010 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Tests for {@link ExternExportsPass}. * * @author dcc@google.com (Devin Coughlin) */ public class PeepholeFoldWithTypesTest extends CompilerTestCase { @Override protected CompilerPass getProcessor(Compiler compiler) { return new PeepholeOptimizationsPass(compiler, new PeepholeFoldWithTypes()); } @Override public void setUp() { enableTypeCheck(CheckLevel.WARNING); } public void testFoldTypeofObject() { test("var x = {};typeof x", "var x = {};\"object\""); test("var x = [];typeof x", "var x = [];\"object\""); // typeof null is "object" in JavaScript test("var x = null;typeof x", "var x = null;\"object\""); } public void testFoldTypeofString() { test("var x = \"foo\";typeof x", "var x = \"foo\";\"string\""); test("var x = new String(\"foo\");typeof x", "var x = new String(\"foo\");\"object\""); } public void testFoldTypeofNumber() { test("var x = 10;typeof x", "var x = 10;\"number\""); test("var x = new Number(6);typeof x", "var x = new Number(6);\"object\""); } public void testFoldTypeofBoolean() { test("var x = false;typeof x", "var x = false;\"boolean\""); test("var x = new Boolean(true);typeof x", "var x = new Boolean(true);\"object\""); } public void testFoldTypeofUndefined() { test("var x = undefined;typeof x", "var x = undefined;\"undefined\""); } public void testDontFoldTypeofUnionTypes() { // For now we don't do anything with union types testSame("var x = (unknown ? {} : null);typeof x"); } public void testDontFoldTypeofSideEffects() { // Shouldn't fold if argument to typeof has side effects testSame("var x = 6 ;typeof (x++)"); } public void testDontFoldTypeofWithTypeCheckDisabled() { disableTypeCheck(); testSame("var x = {};typeof x"); } }
/* * Copyright 2004 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Tests for the interaction between multiple peephole passes. */ public class PeepholeIntegrationTest extends CompilerTestCase { private boolean late = true; // TODO(user): Remove this when we no longer need to do string comparison. private PeepholeIntegrationTest(boolean compareAsTree) { super("", compareAsTree); } public PeepholeIntegrationTest() { super(""); } @Override public void setUp() throws Exception { super.setUp(); this.late = false; enableLineNumberCheck(true); // TODO(nicksantos): Turn this on. There are some normalizations // that cause weirdness here. disableNormalize(); } @Override public CompilerPass getProcessor(final Compiler compiler) { PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass(compiler, new PeepholeSubstituteAlternateSyntax(late), new PeepholeRemoveDeadCode(), new PeepholeFoldConstants(late) ); return peepholePass; } @Override protected int getNumRepetitions() { // Reduce this to 2 if we get better expression evaluators. return 4; } private void foldSame(String js) { testSame(js); } private void fold(String js, String expected) { test(js, expected); } // TODO(user): This is same as fold() except it uses string comparison. Any // test that needs tell us where a folding is constructing an invalid AST. private void assertResultString(String js, String expected) { PeepholeIntegrationTest scTest = new PeepholeIntegrationTest(false); scTest.disableNormalize(); scTest.test(js, expected); } public void testTrueFalse() { late = false; foldSame("x = true"); foldSame("x = false"); fold("x = !1", "x = false"); fold("x = !0", "x = true"); late = true; fold("x = true", "x = !0"); fold("x = false", "x = !1"); foldSame("x = !1"); foldSame("x = !0"); } /** Check that removing blocks with 1 child works */ public void testFoldOneChildBlocksIntegration() { fold("function f(){switch(foo()){default:{break}}}", "function f(){foo()}"); fold("function f(){switch(x){default:{break}}}", "function f(){}"); fold("function f(){switch(x){default:x;case 1:return 2}}", "function f(){switch(x){default:case 1:return 2}}"); // ensure that block folding does not break hook ifs fold("if(x){if(true){foo();foo()}else{bar();bar()}}", "if(x){foo();foo()}"); fold("if(x){if(false){foo();foo()}else{bar();bar()}}", "if(x){bar();bar()}"); // Cases where the then clause has no side effects. fold("if(x()){}", "x()"); fold("if(x()){} else {x()}", "x()||x()"); fold("if(x){}", ""); // Even the condition has no side effect. fold("if(a()){A()} else if (b()) {} else {C()}", "a()?A():b()||C()"); fold("if(a()){} else if (b()) {} else {C()}", "a()||b()||C()"); fold("if(a()){A()} else if (b()) {} else if (c()) {} else{D()}", "a()?A():b()||c()||D()"); fold("if(a()){} else if (b()) {} else if (c()) {} else{D()}", "a()||b()||c()||D()"); fold("if(a()){A()} else if (b()) {} else if (c()) {} else{}", "a()?A():b()||c()"); // Verify that non-global scope works. fold("function foo(){if(x()){}}", "function foo(){x()}"); } public void testFoldOneChildBlocksStringCompare() { // The expected parse tree has a BLOCK structure around the true branch. assertResultString("if(x){if(y){var x;}}else{var z;}", "if(x){if(y)var x}else var z"); } /** Test a particularly hairy edge case. */ public void testNecessaryDanglingElse() { // The extra block is added by CodeGenerator. The logic to avoid ambiguous // else clauses used to be in FoldConstants, so the test is here for // legacy reasons. assertResultString( "if(x)if(y){y();z()}else;else x()", "if(x){if(y){y();z()}}else x()"); } /** Try to minimize returns */ public void testFoldReturnsIntegration() { // if-then-else duplicate statement removal handles this case: fold("function f(){if(x)return;else return}", "function f(){}"); } public void testBug1059649() { // ensure that folding blocks with a single var node doesn't explode fold("if(x){var y=3;}var z=5", "if(x)var y=3;var z=5"); // With normalization, we no longer have this case. foldSame("if(x){var y=3;}else{var y=4;}var z=5"); fold("while(x){var y=3;}var z=5", "while(x)var y=3;var z=5"); fold("for(var i=0;i<10;i++){var y=3;}var z=5", "for(var i=0;i<10;i++)var y=3;var z=5"); fold("for(var i in x){var y=3;}var z=5", "for(var i in x)var y=3;var z=5"); fold("do{var y=3;}while(x);var z=5", "do var y=3;while(x);var z=5"); } public void testHookIfIntegration() { fold("if (false){ x = 1; } else if (cond) { x = 2; } else { x = 3; }", "x=cond?2:3"); fold("x?void 0:y()", "x||y()"); fold("!x?void 0:y()", "(!x)||y()"); fold("x?y():void 0", "x&&y()"); } public void testRemoveDuplicateStatementsIntegration() { fold("function z() {if (a) { return true }" + "else if (b) { return true }" + "else { return true }}", "function z() {return true;}"); fold("function z() {if (a()) { return true }" + "else if (b()) { return true }" + "else { return true }}", "function z() {a()||b();return true;}"); } public void testFoldLogicalOpIntegration() { test("if(x && true) z()", "x&&z()"); test("if(x && false) z()", ""); fold("if(x || 3) z()", "z()"); fold("if(x || false) z()", "x&&z()"); test("if(x==y && false) z()", ""); // TODO(user): This can be further optimized. fold("if(y() || x || 3) z()", "(y()||1)&&z()"); } public void testFoldBitwiseOpStringCompareIntegration() { assertResultString("while(-1 | 0){}", "while(1);"); } public void testVarLiftingIntegration() { fold("if(true);else var a;", "var a"); fold("if(false) foo();else var a;", "var a"); fold("if(true)var a;else;", "var a"); fold("if(false)var a;else;", "var a"); fold("if(false)var a,b;", "var b; var a"); fold("if(false){var a;var a;}", "var a"); fold("if(false)var a=function(){var b};", "var a"); fold("if(a)if(false)var a;else var b;", "var a;if(a)var b"); } public void testBug1438784() throws Exception { fold("for(var i=0;i<10;i++)if(x)x.y;", "for(var i=0;i<10;i++);"); } public void testFoldUselessWhileIntegration() { fold("while(!true) { foo() }", ""); fold("while(!false) foo() ", "while(1) foo()"); fold("while(!void 0) foo()", "while(1) foo()"); // Make sure proper empty nodes are inserted. fold("if(foo())while(false){foo()}else bar()", "foo()||bar()"); } public void testFoldUselessForIntegration() { fold("for(;!true;) { foo() }", ""); fold("for(;void 0;) { foo() }", ""); fold("for(;undefined;) { foo() }", ""); fold("for(;1;) foo()", "for(;;) foo()"); fold("for(;!void 0;) foo()", "for(;;) foo()"); // Make sure proper empty nodes are inserted. fold("if(foo())for(;false;){foo()}else bar()", "foo()||bar()"); } public void testFoldUselessDoIntegration() { test("do { foo() } while(!true);", "foo()"); fold("do { foo() } while(void 0);", "foo()"); fold("do { foo() } while(undefined);", "foo()"); fold("do { foo() } while(!void 0);", "do { foo() } while(1);"); // Make sure proper empty nodes are inserted. test("if(foo())do {foo()} while(false) else bar()", "foo()?foo():bar()"); } public void testMinimizeWhileConstantConditionIntegration() { fold("while(!false) foo()", "while(1) foo()"); fold("while(202) foo()", "while(1) foo()"); fold("while(Infinity) foo()", "while(1) foo()"); fold("while('text') foo()", "while(1) foo()"); fold("while([]) foo()", "while(1) foo()"); fold("while({}) foo()", "while(1) foo()"); fold("while(/./) foo()", "while(1) foo()"); } public void testMinimizeExpr() { test("!!true", ""); fold("!!x()", "x()"); test("!(!x()&&!y())", "x()||y()"); fold("x()||!!y()", "x()||y()"); /* This is similar to the !!true case */ fold("!!x()&&y()", "x()&&y()"); } public void testBug1509085() { PeepholeIntegrationTest oneRepetitiontest = new PeepholeIntegrationTest() { @Override protected int getNumRepetitions() { return 1; } }; oneRepetitiontest.test("x ? x() : void 0", "x&&x();"); oneRepetitiontest.foldSame("y = x ? x() : void 0"); } public void testBugIssue3() { foldSame("function foo() {" + " if(sections.length != 1) children[i] = 0;" + " else var selectedid = children[i]" + "}"); } public void testBugIssue43() { foldSame("function foo() {" + " if (a) { var b = 1; } else { a.b = 1; }" + "}"); } public void testFoldNegativeBug() { fold("while(-3){};", "while(1);"); } public void testNoNormalizeLabeledExpr() { enableNormalize(true); foldSame("var x; foo:{x = 3;}"); foldSame("var x; foo:x = 3;"); } public void testShortCircuit1() { test("1 && a()", "a()"); } public void testShortCircuit2() { test("1 && a() && 2", "a()"); } public void testShortCircuit3() { test("a() && 1 && 2", "a()"); } public void testShortCircuit4() { test("a() && (1 && b())", "a() && b()"); test("a() && 1 && b()", "a() && b()"); test("(a() && 1) && b()", "a() && b()"); } public void testMinimizeExprCondition() { fold("(x || true) && y()", "y()"); fold("(x || false) && y()", "x&&y()"); fold("(x && true) && y()", "x && y()"); fold("(x && false) && y()", ""); fold("a = x || false ? b : c", "a=x?b:c"); fold("do {x()} while((x && false) && y())", "x()"); } public void testTrueFalseFolding() { late = true; fold("x = true", "x = !0"); fold("x = false", "x = !1"); fold("x = !3", "x = !1"); fold("x = true && !0", "x = !0"); fold("x = !!!!!!!!!!!!3", "x = !0"); fold("if(!3){x()}", ""); fold("if(!!3){x()}", "x()"); } public void testCommaSplitingConstantCondition() { late = false; fold("(b=0,b=1);if(b)x=b;", "b=0;b=1;x=b;"); fold("(b=0,b=1);if(b)x=b;", "b=0;b=1;x=b;"); } public void testAvoidCommaSplitting() { late = false; fold("x(),y(),z()", "x();y();z()"); late = true; foldSame("x(),y(),z()"); } public void testObjectLiteral() { test("({})", ""); test("({a:1})", ""); test("({a:foo()})", "foo()"); test("({'a':foo()})", "foo()"); } public void testArrayLiteral() { test("([])", ""); test("([1])", ""); test("([a])", ""); test("([foo()])", "foo()"); } public void testFoldIfs1() { fold("function f() {if (x) return 1; else if (y) return 1;}", "function f() {if (x||y) return 1;}"); fold("function f() {if (x) return 1; else {if (y) return 1; else foo();}}", "function f() {if (x||y) return 1; foo();}"); } public void testFoldIfs2() { fold("function f() {if (x) { a(); } else if (y) { a() }}", "function f() {x?a():y&&a();}"); } public void testFoldHook2() { fold("function f(a) {if (!a) return a; else return a;}", "function f(a) {return a}"); } public void disable_testFoldHook1() { fold("function f(a) {return (!a)?a:a;}", "function f(a) {return a}"); } }
/* * Copyright 2010 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.List; import java.util.Set; /** * Unit tests for PeepholeOptimizationsPass. * */ public class PeepholeOptimizationsPassTest extends CompilerTestCase { private ImmutableList<AbstractPeepholeOptimization> currentPeepholePasses; @Override public void setUp() throws Exception { super.setUp(); super.enableLineNumberCheck(true); } @Override public CompilerPass getProcessor(final Compiler compiler) { return new PeepholeOptimizationsPass(compiler, currentPeepholePasses.toArray( new AbstractPeepholeOptimization[currentPeepholePasses.size()])); } @Override protected int getNumRepetitions() { // Our tests do not require multiple passes to reach a fixed-point. return 1; } /** * PeepholeOptimizationsPass should handle the case when no peephole * optimizations are turned on. */ public void testEmptyPass() { currentPeepholePasses = ImmutableList.<AbstractPeepholeOptimization>of(); testSame("var x; var y;"); } public void testOptimizationOrder() { /* * We need to make sure that: 1) We are only traversing the AST once 2) For * each node, we visit the optimizations in the client-supplied order * * To test this, we create two fake optimizations that each make an entry in * the visitationLog when they are passed a name node to optimize. * * Each entry is of the form nameX where 'name' is the name of the name node * visited and X is the identity of the optimization (1 or 2 in this case). * After the pass is run, we verify the correct ordering by querying the * log. * * Using a log, rather than, say, transforming nodes, allows us to ensure * not only that we are visiting each node but that our visits occur in the * right order (i.e. we need to make sure we're not traversing the entire * AST for the first optimization and then a second time for the second). */ final List<String> visitationLog = Lists.newArrayList(); AbstractPeepholeOptimization note1Applied = new AbstractPeepholeOptimization() { @Override public Node optimizeSubtree(Node node) { if (node.isName()) { visitationLog.add(node.getString() + "1"); } return node; } }; AbstractPeepholeOptimization note2Applied = new AbstractPeepholeOptimization() { @Override public Node optimizeSubtree(Node node) { if (node.isName()) { visitationLog.add(node.getString() + "2"); } return node; } }; currentPeepholePasses = ImmutableList.< AbstractPeepholeOptimization>of(note1Applied, note2Applied); test("var x; var y", "var x; var y"); /* * We expect the optimization order to be: "x" visited by optimization1 "x" * visited by optimization2 "y" visited by optimization1 "y" visited by * optimization2 */ assertEquals(4, visitationLog.size()); assertEquals("x1", visitationLog.get(0)); assertEquals("x2", visitationLog.get(1)); assertEquals("y1", visitationLog.get(2)); assertEquals("y2", visitationLog.get(3)); } /** * A peephole optimization that, given a subtree consisting of a VAR node, * removes children of that node named "x". */ private static class RemoveNodesNamedXUnderVarOptimization extends AbstractPeepholeOptimization { @Override public Node optimizeSubtree(Node node) { if (node.isVar()) { Set<Node> nodesToRemove = Sets.newHashSet(); for (Node child : node.children()) { if ("x".equals(child.getString())) { nodesToRemove.add(child); } } for (Node childToRemove : nodesToRemove) { node.removeChild(childToRemove); reportCodeChange(); } } return node; } } /** * A peephole optimization that, given a subtree consisting of a name node * named "x" removes that node. */ private static class RemoveNodesNamedXOptimization extends AbstractPeepholeOptimization { @Override public Node optimizeSubtree(Node node) { if (node.isName() && "x".equals(node.getString())) { node.getParent().removeChild(node); reportCodeChange(); return null; } return node; } } /** * A peephole optimization that, given a subtree consisting of a name node * named "x" whose parent is a VAR node, removes the parent VAR node. */ private static class RemoveParentVarsForNodesNamedX extends AbstractPeepholeOptimization { @Override public Node optimizeSubtree(Node node) { if (node.isName() && "x".equals(node.getString())) { Node parent = node.getParent(); if (parent.isVar()) { parent.getParent().removeChild(parent); reportCodeChange(); return null; } } return node; } } /** * A peephole optimization that, given a subtree consisting of a name node * named "y", replaces it with a name node named "x"; */ private static class RenameYToX extends AbstractPeepholeOptimization { @Override public Node optimizeSubtree(Node node) { if (node.isName() && "y".equals(node.getString())) { Node replacement = Node.newString(Token.NAME, "x"); node.getParent().replaceChild(node, replacement); reportCodeChange(); return replacement; } return node; } } public void testOptimizationRemovingSubtreeChild() { currentPeepholePasses = ImmutableList.<AbstractPeepholeOptimization>of(new RemoveNodesNamedXUnderVarOptimization()); test("var x,y;", "var y;"); test("var y,x;", "var y;"); test("var x,y,x;", "var y;"); } public void testOptimizationRemovingSubtree() { currentPeepholePasses = ImmutableList.<AbstractPeepholeOptimization>of(new RemoveNodesNamedXOptimization()); test("var x,y;", "var y;"); test("var y,x;", "var y;"); test("var x,y,x;", "var y;"); } public void testOptimizationRemovingSubtreeParent() { currentPeepholePasses = ImmutableList.<AbstractPeepholeOptimization>of(new RemoveParentVarsForNodesNamedX()); test("var x; var y", "var y"); } /** * Test the case where the first peephole optimization removes a node and the * second wants to remove (the now nonexistent) parent of that node. */ public void testOptimizationsRemoveParentAfterRemoveChild() { currentPeepholePasses = ImmutableList.<AbstractPeepholeOptimization>of( new RemoveNodesNamedXOptimization(), new RemoveParentVarsForNodesNamedX()); test("var x,y; var z;", "var y; var z;"); } public void testOptimizationReplacingNode() { currentPeepholePasses = ImmutableList.<AbstractPeepholeOptimization>of( new RenameYToX(), new RemoveParentVarsForNodesNamedX()); test("var y; var z;", "var z;"); } }
/* * Copyright 2004 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.rhino.Node; /** * Tests for PeepholeRemoveDeadCodeTest in isolation. Tests for the interaction * of multiple peephole passes are in PeepholeIntegrationTest. */ public class PeepholeRemoveDeadCodeTest extends CompilerTestCase { private static final String MATH = "/** @const */ var Math = {};" + "/** @nosideeffects */ Math.random = function(){};" + "/** @nosideeffects */ Math.sin = function(){};"; public PeepholeRemoveDeadCodeTest() { super(MATH); } @Override public void setUp() throws Exception { super.setUp(); enableLineNumberCheck(true); } @Override public CompilerPass getProcessor(final Compiler compiler) { return new CompilerPass() { @Override public void process(Node externs, Node root) { SimpleDefinitionFinder definitionFinder = new SimpleDefinitionFinder(compiler); definitionFinder.process(externs, root); new PureFunctionIdentifier(compiler, definitionFinder) .process(externs, root); PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass( compiler, new PeepholeRemoveDeadCode()); peepholePass.process(externs, root); } }; } @Override protected int getNumRepetitions() { // Reduce this to 2 if we get better expression evaluators. return 2; } private void foldSame(String js) { testSame(js); } private void fold(String js, String expected) { test(js, expected); } public void testFoldBlock() { fold("{{foo()}}", "foo()"); fold("{foo();{}}", "foo()"); fold("{{foo()}{}}", "foo()"); fold("{{foo()}{bar()}}", "foo();bar()"); fold("{if(false)foo(); {bar()}}", "bar()"); fold("{if(false)if(false)if(false)foo(); {bar()}}", "bar()"); fold("{'hi'}", ""); fold("{x==3}", ""); fold("{ (function(){x++}) }", ""); fold("function f(){return;}", "function f(){return;}"); fold("function f(){return 3;}", "function f(){return 3}"); fold("function f(){if(x)return; x=3; return; }", "function f(){if(x)return; x=3; return; }"); fold("{x=3;;;y=2;;;}", "x=3;y=2"); // Cases to test for empty block. fold("while(x()){x}", "while(x());"); fold("while(x()){x()}", "while(x())x()"); fold("for(x=0;x<100;x++){x}", "for(x=0;x<100;x++);"); fold("for(x in y){x}", "for(x in y);"); } /** Try to remove spurious blocks with multiple children */ public void testFoldBlocksWithManyChildren() { fold("function f() { if (false) {} }", "function f(){}"); fold("function f() { { if (false) {} if (true) {} {} } }", "function f(){}"); fold("{var x; var y; var z; function f() { { var a; { var b; } } } }", "var x;var y;var z;function f(){var a;var b}"); } public void testIf() { fold("if (1){ x=1; } else { x = 2;}", "x=1"); fold("if (false){ x = 1; } else { x = 2; }", "x=2"); fold("if (undefined){ x = 1; } else { x = 2; }", "x=2"); fold("if (null){ x = 1; } else { x = 2; }", "x=2"); fold("if (void 0){ x = 1; } else { x = 2; }", "x=2"); fold("if (void foo()){ x = 1; } else { x = 2; }", "foo();x=2"); fold("if (false){ x = 1; } else if (true) { x = 3; } else { x = 2; }", "x=3"); fold("if (x){ x = 1; } else if (false) { x = 3; }", "if(x)x=1"); } public void testHook() { fold("true ? a() : b()", "a()"); fold("false ? a() : b()", "b()"); fold("a() ? b() : true", "a() && b()"); fold("a() ? true : b()", "a() || b()"); fold("(a = true) ? b() : c()", "a = true, b()"); fold("(a = false) ? b() : c()", "a = false, c()"); fold("do {f()} while((a = true) ? b() : c())", "do {f()} while((a = true) , b())"); fold("do {f()} while((a = false) ? b() : c())", "do {f()} while((a = false) , c())"); fold("var x = (true) ? 1 : 0", "var x=1"); fold("var y = (true) ? ((false) ? 12 : (cond ? 1 : 2)) : 13", "var y=cond?1:2"); foldSame("var z=x?void 0:y()"); foldSame("z=x?void 0:y()"); foldSame("z*=x?void 0:y()"); foldSame("var z=x?y():void 0"); foldSame("(w?x:void 0).y=z"); foldSame("(w?x:void 0).y+=z"); fold("y = (x ? void 0 : void 0)", "y = void 0"); fold("y = (x ? f() : f())", "y = f()"); } public void testConstantConditionWithSideEffect1() { fold("if (b=true) x=1;", "b=true;x=1"); fold("if (b=/ab/) x=1;", "b=/ab/;x=1"); fold("if (b=/ab/){ x=1; } else { x=2; }", "b=/ab/;x=1"); fold("var b;b=/ab/;if(b)x=1;", "var b;b=/ab/;x=1"); foldSame("var b;b=f();if(b)x=1;"); fold("var b=/ab/;if(b)x=1;", "var b=/ab/;x=1"); foldSame("var b=f();if(b)x=1;"); foldSame("b=b++;if(b)x=b;"); fold("(b=0,b=1);if(b)x=b;", "b=0,b=1;if(b)x=b;"); fold("b=1;if(foo,b)x=b;","b=1;x=b;"); foldSame("b=1;if(foo=1,b)x=b;"); } public void testConstantConditionWithSideEffect2() { fold("(b=true)?x=1:x=2;", "b=true,x=1"); fold("(b=false)?x=1:x=2;", "b=false,x=2"); fold("if (b=/ab/) x=1;", "b=/ab/;x=1"); fold("var b;b=/ab/;(b)?x=1:x=2;", "var b;b=/ab/;x=1"); foldSame("var b;b=f();(b)?x=1:x=2;"); fold("var b=/ab/;(b)?x=1:x=2;", "var b=/ab/;x=1"); foldSame("var b=f();(b)?x=1:x=2;"); } public void testVarLifting() { fold("if(true)var a", "var a"); fold("if(false)var a", "var a"); // More var lifting tests in PeepholeIntegrationTests } public void testFoldUselessWhile() { fold("while(false) { foo() }", ""); fold("while(void 0) { foo() }", ""); fold("while(undefined) { foo() }", ""); foldSame("while(true) foo()"); fold("while(false) { var a = 0; }", "var a"); // Make sure it plays nice with minimizing fold("while(false) { foo(); continue }", ""); fold("while(0) { foo() }", ""); } public void testFoldUselessFor() { fold("for(;false;) { foo() }", ""); fold("for(;void 0;) { foo() }", ""); fold("for(;undefined;) { foo() }", ""); fold("for(;true;) foo() ", "for(;;) foo() "); foldSame("for(;;) foo()"); fold("for(;false;) { var a = 0; }", "var a"); // Make sure it plays nice with minimizing fold("for(;false;) { foo(); continue }", ""); } public void testFoldUselessDo() { fold("do { foo() } while(false);", "foo()"); fold("do { foo() } while(void 0);", "foo()"); fold("do { foo() } while(undefined);", "foo()"); fold("do { foo() } while(true);", "do { foo() } while(true);"); fold("do { var a = 0; } while(false);", "var a=0"); fold("do { var a = 0; } while(!{a:foo()});", "var a=0;foo()"); // Can't fold with break or continues. foldSame("do { foo(); continue; } while(0)"); foldSame("do { foo(); break; } while(0)"); } public void testMinimizeWhileConstantCondition() { fold("while(true) foo()", "while(true) foo()"); fold("while(0) foo()", ""); fold("while(0.0) foo()", ""); fold("while(NaN) foo()", ""); fold("while(null) foo()", ""); fold("while(undefined) foo()", ""); fold("while('') foo()", ""); } public void testFoldConstantCommaExpressions() { fold("if (true, false) {foo()}", ""); fold("if (false, true) {foo()}", "foo()"); fold("true, foo()", "foo()"); fold("(1 + 2 + ''), foo()", "foo()"); } public void testRemoveUselessOps() { // There are four place where expression results are discarded: // - a top-level expression EXPR_RESULT // - the LHS of a COMMA // - the FOR init expression // - the FOR increment expression // Known side-effect free functions calls are removed. fold("Math.random()", ""); fold("Math.random(f() + g())", "f(),g();"); fold("Math.random(f(),g(),h())", "f(),g(),h();"); // Calls to functions with unknown side-effects are are left. foldSame("f();"); foldSame("(function () { f(); })();"); // We know that this function has no side effects because of the // PureFunctionIdentifier. fold("(function () {})();", ""); // Uncalled function expressions are removed fold("(function () {});", ""); fold("(function f() {});", ""); // ... including any code they contain. fold("(function () {foo();});", ""); // Useless operators are removed. fold("+f()", "f()"); fold("a=(+f(),g())", "a=(f(),g())"); fold("a=(true,g())", "a=g()"); fold("f(),true", "f()"); fold("f() + g()", "f(),g()"); fold("for(;;+f()){}", "for(;;f()){}"); fold("for(+f();;g()){}", "for(f();;g()){}"); fold("for(;;Math.random(f(),g(),h())){}", "for(;;f(),g(),h()){}"); // The optimization cascades into conditional expressions: fold("g() && +f()", "g() && f()"); fold("g() || +f()", "g() || f()"); fold("x ? g() : +f()", "x ? g() : f()"); fold("+x()", "x()"); fold("+x() * 2", "x()"); fold("-(+x() * 2)", "x()"); fold("2 -(+x() * 2)", "x()"); fold("x().foo", "x()"); foldSame("x().foo()"); foldSame("x++"); foldSame("++x"); foldSame("x--"); foldSame("--x"); foldSame("x = 2"); foldSame("x *= 2"); // Sanity check, other expression are left alone. foldSame("function f() {}"); foldSame("var x;"); } public void testOptimizeSwitch() { fold("switch(a){}", ""); fold("switch(foo()){}", "foo()"); fold("switch(a){default:}", ""); fold("switch(a){default:break;}", ""); fold("switch(a){default:var b;break;}", "var b"); fold("switch(a){case 1: default:}", ""); fold("switch(a){default: case 1:}", ""); fold("switch(a){default: break; case 1:break;}", ""); fold("switch(a){default: var b; break; case 1: var c; break;}", "var c; var b;"); // Can't remove cases if a default exists. foldSame("function f() {switch(a){default: return; case 1: break;}}"); foldSame("function f() {switch(a){case 1: foo();}}"); foldSame("function f() {switch(a){case 3: case 2: case 1: foo();}}"); fold("function f() {switch(a){case 2: case 1: default: foo();}}", "function f() {switch(a){default: foo();}}"); fold("switch(a){case 1: default:break; case 2: foo()}", "switch(a){case 2: foo()}"); foldSame("switch(a){case 1: goo(); default:break; case 2: foo()}"); // TODO(johnlenz): merge the useless "case 2" foldSame("switch(a){case 1: goo(); case 2:break; case 3: foo()}"); // Can't remove unused code with a "var" in it. fold("switch(1){case 2: var x=0;}", "var x;"); fold("switch ('repeated') {\n" + "case 'repeated':\n" + " foo();\n" + " break;\n" + "case 'repeated':\n" + " var x=0;\n" + " break;\n" + "}", "var x; {foo();}"); // Can't remove cases if something useful is done. foldSame("switch(a){case 1: var c =2; break;}"); foldSame("function f() {switch(a){case 1: return;}}"); foldSame("x:switch(a){case 1: break x;}"); fold("switch ('foo') {\n" + "case 'foo':\n" + " foo();\n" + " break;\n" + "case 'bar':\n" + " bar();\n" + " break;\n" + "}", "{foo();}"); fold("switch ('noMatch') {\n" + "case 'foo':\n" + " foo();\n" + " break;\n" + "case 'bar':\n" + " bar();\n" + " break;\n" + "}", ""); foldSame("switch ('fallThru') {\n" + "case 'fallThru':\n" + " if (foo(123) > 0) {\n" + " foobar(1);\n" + " break;\n" + " }\n" + " foobar(2);\n" + "case 'bar':\n" + " bar();\n" + "}"); foldSame("switch ('fallThru') {\n" + "case 'fallThru':\n" + " foo();\n" + "case 'bar':\n" + " bar();\n" + "}"); foldSame("switch ('hasDefaultCase') {\n" + "case 'foo':\n" + " foo();\n" + " break;\n" + "default:\n" + " bar();\n" + " break;\n" + "}"); fold("switch ('repeated') {\n" + "case 'repeated':\n" + " foo();\n" + " break;\n" + "case 'repeated':\n" + " bar();\n" + " break;\n" + "}", "{foo();}"); fold("switch ('foo') {\n" + "case 'bar':\n" + " bar();\n" + " break;\n" + "case notConstant:\n" + " foobar();\n" + " break;\n" + "case 'foo':\n" + " foo();\n" + " break;\n" + "}", "switch ('foo') {\n" + "case notConstant:\n" + " foobar();\n" + " break;\n" + "case 'foo':\n" + " foo();\n" + " break;\n" + "}"); fold("switch (1) {\n" + "case 1:\n" + " foo();\n" + " break;\n" + "case 2:\n" + " bar();\n" + " break;\n" + "}", "{foo();}"); fold("switch (1) {\n" + "case 1.1:\n" + " foo();\n" + " break;\n" + "case 2:\n" + " bar();\n" + " break;\n" + "}", ""); foldSame("switch (0) {\n" + "case NaN:\n" + " foobar();\n" + " break;\n" + "case -0.0:\n" + " foo();\n" + " break;\n" + "case 2:\n" + " bar();\n" + " break;\n" + "}"); foldSame("switch ('\\v') {\n" + "case '\\u000B':\n" + " foo();\n" + "}"); foldSame("switch ('empty') {\n" + "case 'empty':\n" + "case 'foo':\n" + " foo();\n" + "}"); } public void testRemoveNumber() { test("3", ""); } public void testRemoveVarGet1() { test("a", ""); } public void testRemoveVarGet2() { test("var a = 1;a", "var a = 1"); } public void testRemoveNamespaceGet1() { test("var a = {};a.b", "var a = {}"); } public void testRemoveNamespaceGet2() { test("var a = {};a.b=1;a.b", "var a = {};a.b=1"); } public void testRemovePrototypeGet1() { test("var a = {};a.prototype.b", "var a = {}"); } public void testRemovePrototypeGet2() { test("var a = {};a.prototype.b = 1;a.prototype.b", "var a = {};a.prototype.b = 1"); } public void testRemoveAdd1() { test("1 + 2", ""); } public void testNoRemoveVar1() { testSame("var a = 1"); } public void testNoRemoveVar2() { testSame("var a = 1, b = 2"); } public void testNoRemoveAssign1() { testSame("a = 1"); } public void testNoRemoveAssign2() { testSame("a = b = 1"); } public void testNoRemoveAssign3() { test("1 + (a = 2)", "a = 2"); } public void testNoRemoveAssign4() { testSame("x.a = 1"); } public void testNoRemoveAssign5() { testSame("x.a = x.b = 1"); } public void testNoRemoveAssign6() { test("1 + (x.a = 2)", "x.a = 2"); } public void testNoRemoveCall1() { testSame("a()"); } public void testNoRemoveCall2() { test("a()+b()", "a(),b()"); } public void testNoRemoveCall3() { testSame("a() && b()"); } public void testNoRemoveCall4() { testSame("a() || b()"); } public void testNoRemoveCall5() { test("a() || 1", "a()"); } public void testNoRemoveCall6() { testSame("1 || a()"); } public void testNoRemoveThrow1() { testSame("function f(){throw a()}"); } public void testNoRemoveThrow2() { testSame("function f(){throw a}"); } public void testNoRemoveThrow3() { testSame("function f(){throw 10}"); } public void testRemoveInControlStructure1() { test("if(x()) 1", "x()"); } public void testRemoveInControlStructure2() { test("while(2) 1", "while(2);"); } public void testRemoveInControlStructure3() { test("for(1;2;3) 4", "for(;;);"); } public void testHook1() { test("1 ? 2 : 3", ""); } public void testHook2() { test("x ? a() : 3", "x && a()"); } public void testHook3() { test("x ? 2 : a()", "x || a()"); } public void testHook4() { testSame("x ? a() : b()"); } public void testHook5() { test("a() ? 1 : 2", "a()"); } public void testHook6() { test("a() ? b() : 2", "a() && b()"); } // TODO(johnlenz): Consider adding a post optimization pass to // convert OR into HOOK to save parentheses when the operator // precedents would require them. public void testHook7() { test("a() ? 1 : b()", "a() || b()"); } public void testHook8() { testSame("a() ? b() : c()"); } public void testShortCircuit1() { testSame("1 && a()"); } public void testShortCircuit2() { test("1 && a() && 2", "1 && a()"); } public void testShortCircuit3() { test("a() && 1 && 2", "a()"); } public void testShortCircuit4() { testSame("a() && 1 && b()"); } public void testComplex1() { test("1 && a() + b() + c()", "1 && (a(), b(), c())"); } public void testComplex2() { test("1 && (a() ? b() : 1)", "1 && a() && b()"); } public void testComplex3() { test("1 && (a() ? b() : 1 + c())", "1 && (a() ? b() : c())"); } public void testComplex4() { test("1 && (a() ? 1 : 1 + c())", "1 && (a() || c())"); } public void testComplex5() { // can't simplify LHS of short circuit statements with side effects testSame("(a() ? 1 : 1 + c()) && foo()"); } public void testNoRemoveFunctionDeclaration1() { testSame("function foo(){}"); } public void testNoRemoveFunctionDeclaration2() { testSame("var foo = function (){}"); } public void testNoSimplifyFunctionArgs1() { testSame("f(1 + 2, 3 + g())"); } public void testNoSimplifyFunctionArgs2() { testSame("1 && f(1 + 2, 3 + g())"); } public void testNoSimplifyFunctionArgs3() { testSame("1 && foo(a() ? b() : 1 + c())"); } public void testNoRemoveInherits1() { testSame("var a = {}; this.b = {}; var goog = {}; goog.inherits(b, a)"); } public void testNoRemoveInherits2() { test("var a = {}; this.b = {}; var goog = {}; goog.inherits(b, a) + 1", "var a = {}; this.b = {}; var goog = {}; goog.inherits(b, a)"); } public void testNoRemoveInherits3() { testSame("this.a = {}; var b = {}; b.inherits(a);"); } public void testNoRemoveInherits4() { test("this.a = {}; var b = {}; b.inherits(a) + 1;", "this.a = {}; var b = {}; b.inherits(a)"); } public void testRemoveFromLabel1() { test("LBL: void 0", "LBL: {}"); } public void testRemoveFromLabel2() { test("LBL: foo() + 1 + bar()", "LBL: foo(),bar()"); } public void testCall1() { test("Math.sin(0);", ""); } public void testCall2() { test("1 + Math.sin(0);", ""); } public void testNew1() { test("new Date;", ""); } public void testNew2() { test("1 + new Date;", ""); } public void testFoldAssign() { test("x=x", ""); testSame("x=xy"); testSame("x=x + 1"); testSame("x.a=x.a"); test("var y=(x=x)", "var y=x"); test("y=1 + (x=x)", "y=1 + x"); } public void testTryCatchFinally() { testSame("try {foo()} catch (e) {bar()}"); testSame("try { try {foo()} catch (e) {bar()}} catch (x) {bar()}"); test("try {var x = 1} finally {}", "var x = 1;"); testSame("try {var x = 1} finally {x()}"); test("function f() { return; try{var x = 1}finally{} }", "function f() { return; var x = 1; }"); test("try {} finally {x()}", "x()"); test("try {} catch (e) { bar()} finally {x()}", "x()"); test("try {} catch (e) { bar()}", ""); test("try {} catch (e) { var a = 0; } finally {x()}", "var a; x()"); test("try {} catch (e) {}", ""); test("try {} finally {}", ""); test("try {} catch (e) {} finally {}", ""); } public void testObjectLiteral() { test("({})", ""); test("({a:1})", ""); test("({a:foo()})", "foo()"); test("({'a':foo()})", "foo()"); } public void testArrayLiteral() { test("([])", ""); test("([1])", ""); test("([a])", ""); test("([foo()])", "foo()"); } }
/* * Copyright 2011 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Unit tests for {#link {@link PeepholeReplaceKnownMethods} * */ public class PeepholeReplaceKnownMethodsTest extends CompilerTestCase { private boolean late = true; public PeepholeReplaceKnownMethodsTest() { super(""); } @Override public void setUp() { enableLineNumberCheck(true); } @Override public CompilerPass getProcessor(final Compiler compiler) { CompilerPass peepholePass = new PeepholeOptimizationsPass(compiler, new PeepholeReplaceKnownMethods(late)); return peepholePass; } public void testStringIndexOf() { fold("x = 'abcdef'.indexOf('b')", "x = 1"); fold("x = 'abcdefbe'.indexOf('b', 2)", "x = 6"); fold("x = 'abcdef'.indexOf('bcd')", "x = 1"); fold("x = 'abcdefsdfasdfbcdassd'.indexOf('bcd', 4)", "x = 13"); fold("x = 'abcdef'.lastIndexOf('b')", "x = 1"); fold("x = 'abcdefbe'.lastIndexOf('b')", "x = 6"); fold("x = 'abcdefbe'.lastIndexOf('b', 5)", "x = 1"); // Both elements must be strings. Don't do anything if either one is not // string. fold("x = 'abc1def'.indexOf(1)", "x = 3"); fold("x = 'abcNaNdef'.indexOf(NaN)", "x = 3"); fold("x = 'abcundefineddef'.indexOf(undefined)", "x = 3"); fold("x = 'abcnulldef'.indexOf(null)", "x = 3"); fold("x = 'abctruedef'.indexOf(true)", "x = 3"); // The following test case fails with JSC_PARSE_ERROR. Hence omitted. // foldSame("x = 1.indexOf('bcd');"); foldSame("x = NaN.indexOf('bcd')"); foldSame("x = undefined.indexOf('bcd')"); foldSame("x = null.indexOf('bcd')"); foldSame("x = true.indexOf('bcd')"); foldSame("x = false.indexOf('bcd')"); // Avoid dealing with regex or other types. foldSame("x = 'abcdef'.indexOf(/b./)"); foldSame("x = 'abcdef'.indexOf({a:2})"); foldSame("x = 'abcdef'.indexOf([1,2])"); } public void testStringJoinAddSparse() { fold("x = [,,'a'].join(',')", "x = ',,a'"); } public void testNoStringJoin() { foldSame("x = [].join(',',2)"); foldSame("x = [].join(f)"); } public void testStringJoinAdd() { fold("x = ['a', 'b', 'c'].join('')", "x = \"abc\""); fold("x = [].join(',')", "x = \"\""); fold("x = ['a'].join(',')", "x = \"a\""); fold("x = ['a', 'b', 'c'].join(',')", "x = \"a,b,c\""); fold("x = ['a', foo, 'b', 'c'].join(',')", "x = [\"a\",foo,\"b,c\"].join()"); fold("x = [foo, 'a', 'b', 'c'].join(',')", "x = [foo,\"a,b,c\"].join()"); fold("x = ['a', 'b', 'c', foo].join(',')", "x = [\"a,b,c\",foo].join()"); // Works with numbers fold("x = ['a=', 5].join('')", "x = \"a=5\""); fold("x = ['a', '5'].join(7)", "x = \"a75\""); // Works on boolean fold("x = ['a=', false].join('')", "x = \"a=false\""); fold("x = ['a', '5'].join(true)", "x = \"atrue5\""); fold("x = ['a', '5'].join(false)", "x = \"afalse5\""); // Only optimize if it's a size win. fold("x = ['a', '5', 'c'].join('a very very very long chain')", "x = [\"a\",\"5\",\"c\"].join(\"a very very very long chain\")"); // TODO(user): Its possible to fold this better. foldSame("x = ['', foo].join('-')"); foldSame("x = ['', foo, ''].join()"); fold("x = ['', '', foo, ''].join(',')", "x = [',', foo, ''].join()"); fold("x = ['', '', foo, '', ''].join(',')", "x = [',', foo, ','].join()"); fold("x = ['', '', foo, '', '', bar].join(',')", "x = [',', foo, ',', bar].join()"); fold("x = [1,2,3].join('abcdef')", "x = '1abcdef2abcdef3'"); fold("x = [1,2].join()", "x = '1,2'"); fold("x = [null,undefined,''].join(',')", "x = ',,'"); fold("x = [null,undefined,0].join(',')", "x = ',,0'"); // This can be folded but we don't currently. foldSame("x = [[1,2],[3,4]].join()"); // would like: "x = '1,2,3,4'" } public void testStringJoinAdd_b1992789() { fold("x = ['a'].join('')", "x = \"a\""); fold("x = [foo()].join('')", "x = '' + foo()"); fold("[foo()].join('')", "'' + foo()"); } public void testFoldStringSubstr() { fold("x = 'abcde'.substr(0,2)", "x = 'ab'"); fold("x = 'abcde'.substr(1,2)", "x = 'bc'"); fold("x = 'abcde'['substr'](1,3)", "x = 'bcd'"); fold("x = 'abcde'.substr(2)", "x = 'cde'"); // we should be leaving negative indexes alone for now foldSame("x = 'abcde'.substr(-1)"); foldSame("x = 'abcde'.substr(1, -2)"); foldSame("x = 'abcde'.substr(1, 2, 3)"); foldSame("x = 'a'.substr(0, 2)"); } public void testFoldStringSubstring() { fold("x = 'abcde'.substring(0,2)", "x = 'ab'"); fold("x = 'abcde'.substring(1,2)", "x = 'b'"); fold("x = 'abcde'['substring'](1,3)", "x = 'bc'"); fold("x = 'abcde'.substring(2)", "x = 'cde'"); // we should be leaving negative indexes alone for now foldSame("x = 'abcde'.substring(-1)"); foldSame("x = 'abcde'.substring(1, -2)"); foldSame("x = 'abcde'.substring(1, 2, 3)"); foldSame("x = 'a'.substring(0, 2)"); } public void testFoldStringCharAt() { fold("x = 'abcde'.charAt(0)", "x = 'a'"); fold("x = 'abcde'.charAt(1)", "x = 'b'"); fold("x = 'abcde'.charAt(2)", "x = 'c'"); fold("x = 'abcde'.charAt(3)", "x = 'd'"); fold("x = 'abcde'.charAt(4)", "x = 'e'"); foldSame("x = 'abcde'.charAt(5)"); // or x = '' foldSame("x = 'abcde'.charAt(-1)"); // or x = '' foldSame("x = 'abcde'.charAt(y)"); foldSame("x = 'abcde'.charAt()"); // or x = 'a' foldSame("x = 'abcde'.charAt(0, ++z)"); // or (++z, 'a') foldSame("x = 'abcde'.charAt(null)"); // or x = 'a' foldSame("x = 'abcde'.charAt(true)"); // or x = 'b' fold("x = '\\ud834\udd1e'.charAt(0)", "x = '\\ud834'"); fold("x = '\\ud834\udd1e'.charAt(1)", "x = '\\udd1e'"); } public void testFoldStringCharCodeAt() { fold("x = 'abcde'.charCodeAt(0)", "x = 97"); fold("x = 'abcde'.charCodeAt(1)", "x = 98"); fold("x = 'abcde'.charCodeAt(2)", "x = 99"); fold("x = 'abcde'.charCodeAt(3)", "x = 100"); fold("x = 'abcde'.charCodeAt(4)", "x = 101"); foldSame("x = 'abcde'.charCodeAt(5)"); // or x = (0/0) foldSame("x = 'abcde'.charCodeAt(-1)"); // or x = (0/0) foldSame("x = 'abcde'.charCodeAt(y)"); foldSame("x = 'abcde'.charCodeAt()"); // or x = 97 foldSame("x = 'abcde'.charCodeAt(0, ++z)"); // or (++z, 97) foldSame("x = 'abcde'.charCodeAt(null)"); // or x = 97 foldSame("x = 'abcde'.charCodeAt(true)"); // or x = 98 fold("x = '\\ud834\udd1e'.charCodeAt(0)", "x = 55348"); fold("x = '\\ud834\udd1e'.charCodeAt(1)", "x = 56606"); } public void testFoldStringSplit() { late = false; fold("x = 'abcde'.split('foo')", "x = ['abcde']"); fold("x = 'abcde'.split()", "x = ['abcde']"); fold("x = 'abcde'.split(null)", "x = ['abcde']"); fold("x = 'a b c d e'.split(' ')", "x = ['a','b','c','d','e']"); fold("x = 'a b c d e'.split(' ', 0)", "x = []"); fold("x = 'abcde'.split('cd')", "x = ['ab','e']"); fold("x = 'a b c d e'.split(' ', 1)", "x = ['a']"); fold("x = 'a b c d e'.split(' ', 3)", "x = ['a','b','c']"); fold("x = 'a b c d e'.split(null, 1)", "x = ['a b c d e']"); fold("x = 'aaaaa'.split('a')", "x = ['', '', '', '', '', '']"); fold("x = 'xyx'.split('x')", "x = ['', 'y', '']"); // Empty separator fold("x = 'abcde'.split('')", "x = ['a','b','c','d','e']"); fold("x = 'abcde'.split('', 3)", "x = ['a','b','c']"); // Empty separator AND empty string fold("x = ''.split('')", "x = []"); // Separator equals string fold("x = 'aaa'.split('aaa')", "x = ['','']"); fold("x = ' '.split(' ')", "x = ['','']"); foldSame("x = 'abcde'.split(/ /)"); foldSame("x = 'abcde'.split(' ', -1)"); late = true; foldSame("x = 'a b c d e'.split(' ')"); } public void testJoinBug() { fold("var x = [].join();", "var x = '';"); fold("var x = [x].join();", "var x = '' + x;"); foldSame("var x = [x,y].join();"); foldSame("var x = [x,y,z].join();"); foldSame("shape['matrix'] = [\n" + " Number(headingCos2).toFixed(4),\n" + " Number(-headingSin2).toFixed(4),\n" + " Number(headingSin2 * yScale).toFixed(4),\n" + " Number(headingCos2 * yScale).toFixed(4),\n" + " 0,\n" + " 0\n" + " ].join()"); } public void testToUpper() { fold("'a'.toUpperCase()", "'A'"); fold("'A'.toUpperCase()", "'A'"); fold("'aBcDe'.toUpperCase()", "'ABCDE'"); } public void testToLower() { fold("'A'.toLowerCase()", "'a'"); fold("'a'.toLowerCase()", "'a'"); fold("'aBcDe'.toLowerCase()", "'abcde'"); } public void testFoldParseNumbers() { enableNormalize(); enableEcmaScript5(true); fold("x = parseInt('123')", "x = 123"); fold("x = parseInt(' 123')", "x = 123"); fold("x = parseInt('123', 10)", "x = 123"); fold("x = parseInt('0xA')", "x = 10"); fold("x = parseInt('0xA', 16)", "x = 10"); fold("x = parseInt('07', 8)", "x = 7"); fold("x = parseInt('08')", "x = 8"); fold("x = parseInt('0')", "x = 0"); fold("x = parseFloat('0')", "x = 0"); fold("x = parseFloat('1.23')", "x = 1.23"); fold("x = parseFloat('1.2300')", "x = 1.23"); fold("x = parseFloat(' 0.3333')", "x = 0.3333"); fold("x = parseFloat('0100')", "x = 100"); fold("x = parseFloat('0100.000')", "x = 100"); //Mozilla Dev Center test cases fold("x = parseInt(' 0xF', 16)", "x = 15"); fold("x = parseInt(' F', 16)", "x = 15"); fold("x = parseInt('17', 8)", "x = 15"); fold("x = parseInt('015', 10)", "x = 15"); fold("x = parseInt('1111', 2)", "x = 15"); fold("x = parseInt('12', 13)", "x = 15"); fold("x = parseInt(021, 8)", "x = 15"); fold("x = parseInt(15.99, 10)", "x = 15"); fold("x = parseFloat('3.14')", "x = 3.14"); fold("x = parseFloat(3.14)", "x = 3.14"); //Valid calls - unable to fold foldSame("x = parseInt('FXX123', 16)"); foldSame("x = parseInt('15*3', 10)"); foldSame("x = parseInt('15e2', 10)"); foldSame("x = parseInt('15px', 10)"); foldSame("x = parseInt('-0x08')"); foldSame("x = parseInt('1', -1)"); foldSame("x = parseFloat('3.14more non-digit characters')"); foldSame("x = parseFloat('314e-2')"); foldSame("x = parseFloat('0.0314E+2')"); foldSame("x = parseFloat('3.333333333333333333333333')"); //Invalid calls foldSame("x = parseInt('0xa', 10)"); foldSame("x = parseInt('')"); enableEcmaScript5(false); foldSame("x = parseInt('08')"); } @Override protected int getNumRepetitions() { // Reduce this to 2 if we get better expression evaluators. return 2; } private void foldSame(String js) { testSame(js); } private void fold(String js, String expected) { test(js, expected); } }
/* * Copyright 2011 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.rhino.Node; public class PeepholeSimplifyRegExpTest extends CompilerTestCase { public final void testWaysOfMatchingEmptyString() { testSame("/(?:)/"); test("/(?:)/i", "/(?:)/"); // We can get rid of i flag when no letters. test("/.{0}/i", "/(?:)/"); test("/[^\\0-\\uffff]{0}/", "/(?:)/"); // Cannot get rid of capturing groups. testSame("/(){0}/"); } public final void testCharsetOptimizations() { testSame("/./"); test("/[\\0-\\uffff]/", "/[\\S\\s]/"); test("/[^\\0-\\uffff]/", "/(?!)/"); test("/[^\\0-\\x40\\x42-\\uffff]/", "/A/"); test("/[0-9a-fA-F]/i", "/[\\da-f]/i"); test("/[0-9a-zA-Z_$]/i", "/[\\w$]/"); test("/[()*+\\-,]/g", "/[(--]/g"); test("/[()*+\\-,z]/g", "/[(--z]/g"); test("/[\\-\\.\\/0]/g", "/[--0]/g"); test("/[\\-\\.\\/0\\n]/g", "/[\\n\\--0]/g"); test("/[\\[\\\\\\]]/g", "/[[-\\]]/g"); test("/[\\[\\\\\\]\\^]/g", "/[[-^]/g"); test("/[\\^`_]/g", "/[\\^-`]/g"); test("/[^\\^`_]/g", "/[^^-`]/g"); test("/^(?=[^a-z])/i", "/^(?=[\\W\\d_])/"); test("/^[^a-z0-9]/i", "/^[\\W_]/"); test("/[0-FA-Z]/", "/[0-Z]/"); test("/[0-9]/", "/\\d/"); test("/[^0-9]/", "/\\D/"); testSame("/\\D/"); test("/[_a-z0-9]/i", "/\\w/"); test("/[0-9_a-z]/i", "/\\w/"); test("/[_a-z0-9]/", "/[\\d_a-z]/"); test("/[_E-Za-f0-9]/i", "/\\w/"); test("/[E-Za-f]/i", "/[a-z]/i"); test("/[_E-Za-f0-9]/", "/[\\dE-Z_a-f]/"); // Test case normalization. // U+00CA and U+00EA are E and e with ^ above test("/[\\u00ca\\u00ea]/", "/[\\xca\\xea]/"); test("/[\\u00ca\\u00ea]/i", "/\\xca/i"); // IE (at least 6, 7, and 8) do not include \xA0 in \s so when an author // explicitly includes it make sure it appears in the output. testSame("/^[\\s\\xa0]*$/"); test("/^(?:\\s|\\xA0)*$/", "/^[\\s\\xa0]*$/"); } public final void testCharsetFixup() { testSame("/[a-z]/i"); // This is the case. The below produces no output in squarefree. // (function () { // // Runs to just before the letter 'a' and starts right after 'z'. // var re = /[^\0-`{-\uffff]/i // for (var i = 0; i < 0x10000; ++i) { // var s = String.fromCharCode(i); // if (re.test(s)) { print(s + ' : ' + s.charCodeAt(0).toString(16)); } // } // })() test("/[^\\0-`{-\\uffff]/i", "/(?!)/"); // This looks a bit odd, but // /[^a-z]/i is the same as all non-word characters, all digits, and _ and // /[\W\d_]/ is the same length. test("/[^a-z]/i", "/[\\W\\d_]/"); } public final void testGroups() { testSame("/foo(bar)baz/"); } public final void testBackReferences() { testSame("/foo(bar)baz(?:\\1|\\x01)boo/"); // But when there is no group to refer to, then the back-reference *is* // the same as an octal escape. test("/foo(?:bar)baz(?:\\1|\\x01)boo/", "/foobarbaz\\x01boo/"); // \\8 is never an octal escape. If there is no 8th group, then it // is the literal character '8' test("/foo(?:bar)baz(?:\\8|8)boo/", "/foobarbaz8boo/"); // \10 can be a capturing group. test("/(1?)(2?)(3?)(4?)(5?)(6?)(7?)(8?)(9?)(A?)(B?)" + "\\12\\11\\10\\9\\8\\7\\6\\5\\4\\3\\2\\1\\0/", "/(1?)(2?)(3?)(4?)(5?)(6?)(7?)(8?)(9?)(A?)(B?)" // \\12 does not match any group, so is treated as group 1 followed // by literal 2. + "\\1(?:2)\\11\\10\\9\\8\\7\\6\\5\\4\\3\\2\\1\\0/"); // But \1 should not be emitted followed by a digit un-parenthesized. test("/(1?)(2?)(3?)(4?)(5?)(6?)(7?)(8?)(9?)(A?)(B?)(?:\\1)0/", "/(1?)(2?)(3?)(4?)(5?)(6?)(7?)(8?)(9?)(A?)(B?)\\1(?:0)/"); // \012 is never treated as a group even when there are 12 groups. test("/(1?)(2?)(3?)(4?)(5?)(6?)(7?)(8?)(9?)(A?)(B?)(C?)" + "\\012\\11\\10\\9\\8\\7\\6\\5\\4\\3\\2\\1\\0/", "/(1?)(2?)(3?)(4?)(5?)(6?)(7?)(8?)(9?)(A?)(B?)(C?)" + "\\n\\11\\10\\9\\8\\7\\6\\5\\4\\3\\2\\1\\0/"); } public final void testSingleCharAlterations() { test("/a|B|c|D/i", "/[a-d]/i"); test("/a|B|c|D/", "/[BDac]/"); test("/a|[Bc]|D/", "/[BDac]/"); test("/[aB]|[cD]/", "/[BDac]/"); test("/a|B|c|D|a|B/i", "/[a-d]/i"); // Duplicates. test("/a|A|/i", "/a?/i"); } public final void testAlterations() { testSame("/foo|bar/"); test("/Foo|BAR/i", "/foo|bar/i"); test("/Foo||BAR/", "/Foo||BAR/"); test("/Foo|BAR|/", "/Foo|BAR|/"); } public final void testNestedAlterations() { test("/foo|bar|(?:baz|boo)|far/", "/foo|bar|baz|boo|far/"); } public final void testEscapeSequencesAndNonLatinChars() { test("/\u1234/i", "/\\u1234/"); testSame("/\\u1234/"); test("/\u00A0/", "/\\xa0/"); test("/\\u00A0/", "/\\xa0/"); test("/\\u00a0/", "/\\xa0/"); } public final void testAnchors() { // m changes the meaning of anchors which is useless if there are none. testSame("/foo(?!$)/gm"); test("/./m", "/./"); test("/\\^/m", "/\\^/"); test("/[\\^]/m", "/\\^/"); testSame("/(^|foo)bar/"); testSame("/^.|.$/gm"); test("/foo(?=)$/m", "/foo$/m"); // We can get rid of the g when there are no capturing groups and the // pattern is fully anchored. test("/^foo$/g", "/^foo$/"); } public final void testRepetitions() { testSame("/a*/"); testSame("/a+/"); testSame("/a+?/"); testSame("/a?/"); testSame("/a{6}/"); testSame("/a{4,}/"); test("/a{3,}/", "/aaa+/"); testSame("/a{4,6}/"); testSame("/a{4,6}?/"); test("/(?:a?)?/", "/a?/"); test("/(?:a?)*/", "/a*/"); test("/(?:a*)?/", "/a*/"); test("/a(?:a*)?/", "/a+/"); test("/(?:a{2,3}){3,4}/", "/a{6,12}/"); test("/a{2,3}a{3,4}/", "/a{5,7}/"); testSame("/a{5,7}b{5,6}/"); test("/a{2,3}b{3,4}/", "/aaa?bbbb?/"); test("/a{3}b{3,4}/", "/aaabbbb?/"); testSame("/[a-z]{1,2}/"); test("/\\d{1,2}/", "/\\d\\d?/"); test("/a*a*/", "/a*/"); test("/a+a+/", "/aa+/"); test("/a+a*/", "/a+/"); // We don't conflate literal curly brackets with repetitions. testSame("/a\\{3,1}/"); test("/a(?:{3,1})/", "/a\\{3,1}/"); test("/a{3\\,1}/", "/a\\{3,1}/"); testSame("/a\\{3}/"); testSame("/a\\{3,}/"); testSame("/a\\{1,3}/"); // We don't over-escape curly brackets. testSame("/a{/"); testSame("/a{}/"); testSame("/a{x}/"); testSame("/a{-1}/"); testSame("/a{,3}/"); testSame("/{{[a-z]+}}/"); testSame("/{\\{0}}/"); testSame("/{\\{0?}}/"); } public final void testMoreCharsets() { test("var a = /[\\x00\\x22\\x26\\x27\\x3c\\x3e]/g", "var a = /[\\0\"&'<>]/g"); test("var b = /[\\x00\\x22\\x27\\x3c\\x3e]/g", "var b = /[\\0\"'<>]/g"); test("var c = /[\\x00\\x09-\\x0d \\x22\\x26\\x27\\x2d\\/\\x3c-\\x3e`" + "\\x85\\xa0\\u2028\\u2029]/g", "var c = /[\\0\\t-\\r \"&'/<->`\\x85\\xa0\\u2028\\u2029-]/g"); test("var d = /[\\x00\\x09-\\x0d \\x22\\x27\\x2d\\/\\x3c-\\x3e`" + "\\x85\\xa0\\u2028\\u2029]/g", "var d = /[\\0\\t-\\r \"'/<->`\\x85\\xa0\\u2028\\u2029-]/g"); test("var e = /[\\x00\\x08-\\x0d\\x22\\x26\\x27\\/\\x3c-\\x3e\\\\" + "\\x85\\u2028\\u2029]/g", "var e = /[\\0\\b-\\r\"&'/<->\\\\\\x85\\u2028\\u2029]/g"); test("var f = /[\\x00\\x08-\\x0d\\x22\\x24\\x26-\\/\\x3a\\x3c-\\x3f" + "\\x5b-\\x5e\\x7b-\\x7d\\x85\\u2028\\u2029]/g", "var f = /[\\0\\b-\\r\"$&-/:<-?[-^{-}\\x85\\u2028\\u2029]/g"); test("var g = /[\\x00\\x08-\\x0d\\x22\\x26-\\x2a\\/\\x3a-\\x3e@\\\\" + "\\x7b\\x7d\\x85\\xa0\\u2028\\u2029]/g", "var g = /[\\0\\b-\\r\"&-*/:->@\\\\{}\\x85\\xa0\\u2028\\u2029]/g"); test("var h = /^(?!-*(?:expression|(?:moz-)?binding))(?:[.#]?-?" + "(?:[_a-z0-9][_a-z0-9-]*)(?:-[_a-z][_a-z0-9-]*)*-?|-?" + "(?:[0-9]+(?:\\.[0-9]*)?|\\.[0-9])(?:[a-z]{1,2}|%)?|!important|)$/i", "var h = /^(?!-*(?:expression|(?:moz-)?binding))(?:[#.]?-?" + "\\w[\\w-]*(?:-[_a-z][\\w-]*)*-?|-?" + "(?:\\d+(?:\\.\\d*)?|\\.\\d)(?:[a-z]{1,2}|%)?|!important|)$/i"); test("var i = /^(?:(?:https?|mailto):|[^&:\\/?#]*(?:[\\/?#]|$))/i", "var i = /^(?:(?:https?|mailto):|[^#&/:?]*(?:[#/?]|$))/i"); test("var j = /^(?!style|on|action|archive|background|cite|classid" + "|codebase|data|dsync|href|longdesc|src|usemap)(?:[a-z0-9_$:-]*" + "|dir=(?:ltr|rtl))$/i", "var j = /^(?!style|on|action|archive|background|cite|classid" + "|codebase|data|dsync|href|longdesc|src|usemap)(?:[\\w$:-]*" + "|dir=(?:ltr|rtl))$/i"); test("var k = /^(?!script|style|title|textarea|xmp|no)[a-z0-9_$:-]*$/i", "var k = /^(?!script|style|title|textarea|xmp|no)[\\w$:-]*$/i"); test("var l = /<(?:!|\\/?[a-z])(?:[^>'\"]|\"[^\"]*\"|'[^']*')*>/gi", "var l = /<(?:!|\\/?[a-z])(?:[^\"'>]|\"[^\"]*\"|'[^']*')*>/gi"); } public final void testMoreRegularExpression() { testSame("/\"/"); testSame("/'/"); test("/(?:[^<\\/\"'\\s\\\\]|<(?!\\/script))+/i", "/(?:[^\\s\"'/<\\\\]|<(?!\\/script))+/i"); testSame("/-->/"); testSame("/<!--/"); testSame("/<\\/(\\w+)\\b/"); testSame("/<\\/?/"); test("/<script(?=[\\s>\\/]|$)/i", "/<script(?=[\\s/>]|$)/i"); test("/<style(?=[\\s>\\/]|$)/i", "/<style(?=[\\s/>]|$)/i"); test("/<textarea(?=[\\s>\\/]|$)/i", "/<textarea(?=[\\s/>]|$)/i"); test("/<title(?=[\\s>\\/]|$)/i", "/<title(?=[\\s/>]|$)/i"); test("/<xmp(?=[\\s>\\/]|$)/i", "/<xmp(?=[\\s/>]|$)/i"); testSame("/[\"']/"); test("/[\\\\)\\s]/", "/[\\s)\\\\]/"); test("/[\\f\\r\\n\\u2028\\u2029]/", "/[\\n\\f\\r\\u2028\\u2029]/"); test("/[\\n\\r\\f]/", "/[\\n\\f\\r]/"); testSame("/\\*\\//"); testSame("/\\//"); testSame("/\\/\\*/"); testSame("/\\/\\//"); testSame("/\\\\(?:\\r\\n?|[\\n\\f\"])/"); testSame("/\\\\(?:\\r\\n?|[\\n\\f'])/"); testSame("/\\burl\\s*\\(\\s*([\"']?)/i"); testSame("/\\s+/"); test("/^(?:[^'\\\\\\n\\r\\u2028\\u2029<]|\\\\(?:\\r\\n?|[^\\r<]" + "|<(?!\\/script))|<(?!\\/script))/i", "/^(?:[^\\n\\r'<\\\\\\u2028\\u2029]|\\\\(?:\\r\\n?|[^\\r<]" + "|<(?!\\/script))|<(?!\\/script))/i"); test("/^(?:[^\\\"\\\\\\n\\r\\u2028\\u2029<]|\\\\(?:\\r\\n?" + "|[^\\r<]|<(?!\\/script))|<(?!\\/script))/i", "/^(?:[^\\n\\r\"<\\\\\\u2028\\u2029]|\\\\(?:\\r\\n?" + "|[^\\r<]|<(?!\\/script))|<(?!\\/script))/i"); test("/^(?:[^\\[\\\\\\/<\\n\\r\\u2028\\u2029]|\\\\[^\\n\\r\\u2028\\u2029]" + "|\\\\?<(?!\\/script)|\\[(?:[^\\]\\\\<\\n\\r\\u2028\\u2029]|" + "\\\\(?:[^\\n\\r\\u2028\\u2029]))*|\\\\?<(?!\\/script)\\])/i", "/^(?:[^\\n\\r/<[\\\\\\u2028\\u2029]|\\\\." + "|\\\\?<(?!\\/script)|\\[(?:[^\\n\\r<\\\\\\]\\u2028\\u2029]|" + "\\\\.)*|\\\\?<(?!\\/script)])/i"); testSame("/^(?=>|\\s+[\\w-]+\\s*=)/"); test("/^(?=[\\/\\s>])/", "/^(?=[\\s/>])/"); test("/^(?=[^\"'\\s>])/", "/^(?=[^\\s\"'>])/"); testSame("/^/"); testSame("/^[^<]+/"); test("/^[a-z0-9:-]*(?:[a-z0-9]|$)/i", "/^[\\d:a-z-]*(?:[^\\W_]|$)/i"); testSame("/^[a-z]+/i"); testSame("/^\\s*\"/"); testSame("/^\\s*'/"); testSame("/^\\s*([a-z][\\w-]*)/i"); testSame("/^\\s*=/"); testSame("/^\\s*\\/?>/"); testSame("/^\\s+$/"); testSame("/^\\s+/"); } public final void testPrecedence() { // Repetition binds more tightly than concatenation. testSame("/ab?/"); testSame("/(?:ab)?/"); // Concatenation bind more tightly than alterations. testSame("/foo|bar/"); testSame("/f(?:oo|ba)r/"); } public final void testMalformedRegularExpressions() { test( "/(?<!foo)/", "/(?<!foo)/", // Lookbehind not valid in ES. null, // No error. CheckRegExp.MALFORMED_REGEXP); // Warning. test( "/(/", "/(/", null, // No error. CheckRegExp.MALFORMED_REGEXP); // Warning. test( "/)/", "/)/", null, // No error. CheckRegExp.MALFORMED_REGEXP); // Warning. test( "/\\uabc/", "/\\uabc/", null, // No error. CheckRegExp.MALFORMED_REGEXP); // Warning. test( "/\\uabcg/", "/\\uabcg/", null, // No error. CheckRegExp.MALFORMED_REGEXP); // Warning. } @Override protected CompilerPass getProcessor(Compiler compiler) { final CompilerPass simplifier = new PeepholeOptimizationsPass( compiler, new PeepholeSimplifyRegExp()); final CompilerPass checker = new CheckRegExp(compiler); return new CompilerPass() { @Override public void process(Node externs, Node root) { checker.process(externs, root); simplifier.process(externs, root); } }; } }
/* * Copyright 2004 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Tests for {@link PeepholeSubstituteAlternateSyntax} in isolation. * Tests for the interaction of multiple peephole passes are in * PeepholeIntegrationTest. */ public class PeepholeSubstituteAlternateSyntaxTest extends CompilerTestCase { // Externs for built-in constructors // Needed for testFoldLiteralObjectConstructors(), // testFoldLiteralArrayConstructors() and testFoldRegExp...() private static final String FOLD_CONSTANTS_TEST_EXTERNS = "var Object = function f(){};\n" + "var RegExp = function f(a){};\n" + "var Array = function f(a){};\n"; private boolean late = true; // TODO(user): Remove this when we no longer need to do string comparison. private PeepholeSubstituteAlternateSyntaxTest(boolean compareAsTree) { super(FOLD_CONSTANTS_TEST_EXTERNS, compareAsTree); } public PeepholeSubstituteAlternateSyntaxTest() { super(FOLD_CONSTANTS_TEST_EXTERNS); } @Override public void setUp() throws Exception { late = true; super.setUp(); enableLineNumberCheck(true); disableNormalize(); } @Override public CompilerPass getProcessor(final Compiler compiler) { CompilerPass peepholePass = new PeepholeOptimizationsPass(compiler, new PeepholeSubstituteAlternateSyntax(late)) .setRetraverseOnChange(false); return peepholePass; } @Override protected int getNumRepetitions() { return 1; } private void foldSame(String js) { testSame(js); } private void fold(String js, String expected) { test(js, expected); } void assertResultString(String js, String expected) { assertResultString(js, expected, false); } // TODO(user): This is same as fold() except it uses string comparison. Any // test that needs tell us where a folding is constructing an invalid AST. void assertResultString(String js, String expected, boolean normalize) { PeepholeSubstituteAlternateSyntaxTest scTest = new PeepholeSubstituteAlternateSyntaxTest(false); if (normalize) { scTest.enableNormalize(); } else { scTest.disableNormalize(); } scTest.test(js, expected); } /** Check that removing blocks with 1 child works */ public void testFoldOneChildBlocks() { late = false; fold("function f(){if(x)a();x=3}", "function f(){x&&a();x=3}"); fold("function f(){if(x){a()}x=3}", "function f(){x&&a();x=3}"); fold("function f(){if(x){return 3}}", "function f(){if(x)return 3}"); fold("function f(){if(x){a()}}", "function f(){x&&a()}"); fold("function f(){if(x){throw 1}}", "function f(){if(x)throw 1;}"); // Try it out with functions fold("function f(){if(x){foo()}}", "function f(){x&&foo()}"); fold("function f(){if(x){foo()}else{bar()}}", "function f(){x?foo():bar()}"); // Try it out with properties and methods fold("function f(){if(x){a.b=1}}", "function f(){if(x)a.b=1}"); fold("function f(){if(x){a.b*=1}}", "function f(){x&&(a.b*=1)}"); fold("function f(){if(x){a.b+=1}}", "function f(){x&&(a.b+=1)}"); fold("function f(){if(x){++a.b}}", "function f(){x&&++a.b}"); fold("function f(){if(x){a.foo()}}", "function f(){x&&a.foo()}"); // Try it out with throw/catch/finally [which should not change] fold("function f(){try{foo()}catch(e){bar(e)}finally{baz()}}", "function f(){try{foo()}catch(e){bar(e)}finally{baz()}}"); // Try it out with switch statements fold("function f(){switch(x){case 1:break}}", "function f(){switch(x){case 1:break}}"); // Do while loops stay in a block if that's where they started fold("function f(){if(e1){do foo();while(e2)}else foo2()}", "function f(){if(e1){do foo();while(e2)}else foo2()}"); // Test an obscure case with do and while fold("if(x){do{foo()}while(y)}else bar()", "if(x){do foo();while(y)}else bar()"); // Play with nested IFs fold("function f(){if(x){if(y)foo()}}", "function f(){x&&y&&foo()}"); fold("function f(){if(x){if(y)foo();else bar()}}", "function f(){x&&(y?foo():bar())}"); fold("function f(){if(x){if(y)foo()}else bar()}", "function f(){x?y&&foo():bar()}"); fold("function f(){if(x){if(y)foo();else bar()}else{baz()}}", "function f(){x?y?foo():bar():baz()}"); fold("if(e1){while(e2){if(e3){foo()}}}else{bar()}", "if(e1)while(e2)e3&&foo();else bar()"); fold("if(e1){with(e2){if(e3){foo()}}}else{bar()}", "if(e1)with(e2)e3&&foo();else bar()"); fold("if(a||b){if(c||d){var x;}}", "if(a||b)if(c||d)var x"); fold("if(x){ if(y){var x;}else{var z;} }", "if(x)if(y)var x;else var z"); // NOTE - technically we can remove the blocks since both the parent // and child have elses. But we don't since it causes ambiguities in // some cases where not all descendent ifs having elses fold("if(x){ if(y){var x;}else{var z;} }else{var w}", "if(x)if(y)var x;else var z;else var w"); fold("if (x) {var x;}else { if (y) { var y;} }", "if(x)var x;else if(y)var y"); // Here's some of the ambiguous cases fold("if(a){if(b){f1();f2();}else if(c){f3();}}else {if(d){f4();}}", "if(a)if(b){f1();f2()}else c&&f3();else d&&f4()"); fold("function f(){foo()}", "function f(){foo()}"); fold("switch(x){case y: foo()}", "switch(x){case y:foo()}"); fold("try{foo()}catch(ex){bar()}finally{baz()}", "try{foo()}catch(ex){bar()}finally{baz()}"); } /** Try to minimize returns */ public void testFoldReturns() { fold("function f(){if(x)return 1;else return 2}", "function f(){return x?1:2}"); fold("function f(){if(x)return 1;return 2}", "function f(){return x?1:2}"); fold("function f(){if(x)return;return 2}", "function f(){return x?void 0:2}"); fold("function f(){if(x)return 1+x;else return 2-x}", "function f(){return x?1+x:2-x}"); fold("function f(){if(x)return 1+x;return 2-x}", "function f(){return x?1+x:2-x}"); fold("function f(){if(x)return y += 1;else return y += 2}", "function f(){return x?(y+=1):(y+=2)}"); fold("function f(){if(x)return;else return 2-x}", "function f(){if(x);else return 2-x}"); fold("function f(){if(x)return;return 2-x}", "function f(){return x?void 0:2-x}"); fold("function f(){if(x)return x;else return}", "function f(){if(x)return x;{}}"); fold("function f(){if(x)return x;return}", "function f(){if(x)return x}"); foldSame("function f(){for(var x in y) { return x.y; } return k}"); } public void testCombineIfs1() { fold("function f() {if (x) return 1; if (y) return 1}", "function f() {if (x||y) return 1;}"); fold("function f() {if (x) return 1; if (y) foo(); else return 1}", "function f() {if ((!x)&&y) foo(); else return 1;}"); } public void testCombineIfs2() { // combinable but not yet done foldSame("function f() {if (x) throw 1; if (y) throw 1}"); // Can't combine, side-effect fold("function f(){ if (x) g(); if (y) g() }", "function f(){ x&&g(); y&&g() }"); // Can't combine, side-effect fold("function f(){ if (x) y = 0; if (y) y = 0; }", "function f(){ x&&(y = 0); y&&(y = 0); }"); } public void testCombineIfs3() { foldSame("function f() {if (x) return 1; if (y) {g();f()}}"); } /** Try to minimize assignments */ public void testFoldAssignments() { fold("function f(){if(x)y=3;else y=4;}", "function f(){y=x?3:4}"); fold("function f(){if(x)y=1+a;else y=2+a;}", "function f(){y=x?1+a:2+a}"); // and operation assignments fold("function f(){if(x)y+=1;else y+=2;}", "function f(){y+=x?1:2}"); fold("function f(){if(x)y-=1;else y-=2;}", "function f(){y-=x?1:2}"); fold("function f(){if(x)y%=1;else y%=2;}", "function f(){y%=x?1:2}"); fold("function f(){if(x)y|=1;else y|=2;}", "function f(){y|=x?1:2}"); // sanity check, don't fold if the 2 ops don't match foldSame("function f(){x ? y-=1 : y+=2}"); // sanity check, don't fold if the 2 LHS don't match foldSame("function f(){x ? y-=1 : z-=1}"); // sanity check, don't fold if there are potential effects foldSame("function f(){x ? y().a=3 : y().a=4}"); } public void testRemoveDuplicateStatements() { fold("if (a) { x = 1; x++ } else { x = 2; x++ }", "x=(a) ? 1 : 2; x++"); fold("if (a) { x = 1; x++; y += 1; z = pi; }" + " else { x = 2; x++; y += 1; z = pi; }", "x=(a) ? 1 : 2; x++; y += 1; z = pi;"); fold("function z() {" + "if (a) { foo(); return !0 } else { goo(); return !0 }" + "}", "function z() {(a) ? foo() : goo(); return !0}"); fold("function z() {if (a) { foo(); x = true; return true " + "} else { goo(); x = true; return true }}", "function z() {(a) ? foo() : goo(); x = !0; return !0}"); fold("function z() {" + " if (a) { bar(); foo(); return true }" + " else { bar(); goo(); return true }" + "}", "function z() {" + " if (a) { bar(); foo(); }" + " else { bar(); goo(); }" + " return !0;" + "}"); } public void testNotCond() { fold("function f(){if(!x)foo()}", "function f(){x||foo()}"); fold("function f(){if(!x)b=1}", "function f(){x||(b=1)}"); fold("if(!x)z=1;else if(y)z=2", "if(x){y&&(z=2);}else{z=1;}"); fold("if(x)y&&(z=2);else z=1;", "x ? y&&(z=2) : z=1"); foldSame("function f(){if(!(x=1))a.b=1}"); } public void testAndParenthesesCount() { fold("function f(){if(x||y)a.foo()}", "function f(){(x||y)&&a.foo()}"); fold("function f(){if(x.a)x.a=0}", "function f(){x.a&&(x.a=0)}"); foldSame("function f(){if(x()||y()){x()||y()}}"); } public void testFoldLogicalOpStringCompare() { // side-effects // There is two way to parse two &&'s and both are correct. assertResultString("if(foo() && false) z()", "foo()&&0&&z()"); } public void testFoldNot() { fold("while(!(x==y)){a=b;}" , "while(x!=y){a=b;}"); fold("while(!(x!=y)){a=b;}" , "while(x==y){a=b;}"); fold("while(!(x===y)){a=b;}", "while(x!==y){a=b;}"); fold("while(!(x!==y)){a=b;}", "while(x===y){a=b;}"); // Because !(x<NaN) != x>=NaN don't fold < and > cases. foldSame("while(!(x>y)){a=b;}"); foldSame("while(!(x>=y)){a=b;}"); foldSame("while(!(x<y)){a=b;}"); foldSame("while(!(x<=y)){a=b;}"); foldSame("while(!(x<=NaN)){a=b;}"); // NOT forces a boolean context fold("x = !(y() && true)", "x = !y()"); // This will be further optimized by PeepholeFoldConstants. fold("x = !true", "x = !1"); } public void testFoldRegExpConstructor() { enableNormalize(); // Cannot fold all the way to a literal because there are too few arguments. fold("x = new RegExp", "x = RegExp()"); // Empty regexp should not fold to // since that is a line comment in JS fold("x = new RegExp(\"\")", "x = RegExp(\"\")"); fold("x = new RegExp(\"\", \"i\")", "x = RegExp(\"\",\"i\")"); // Bogus flags should not fold testSame("x = RegExp(\"foobar\", \"bogus\")", PeepholeSubstituteAlternateSyntax.INVALID_REGULAR_EXPRESSION_FLAGS); // Can Fold fold("x = new RegExp(\"foobar\")", "x = /foobar/"); fold("x = RegExp(\"foobar\")", "x = /foobar/"); fold("x = new RegExp(\"foobar\", \"i\")", "x = /foobar/i"); // Make sure that escaping works fold("x = new RegExp(\"\\\\.\", \"i\")", "x = /\\./i"); fold("x = new RegExp(\"/\", \"\")", "x = /\\//"); fold("x = new RegExp(\"[/]\", \"\")", "x = /[/]/"); fold("x = new RegExp(\"///\", \"\")", "x = /\\/\\/\\//"); fold("x = new RegExp(\"\\\\\\/\", \"\")", "x = /\\//"); fold("x = new RegExp(\"\\n\")", "x = /\\n/"); fold("x = new RegExp('\\\\\\r')", "x = /\\r/"); // Don't fold really long regexp literals, because Opera 9.2's // regexp parser will explode. String longRegexp = ""; for (int i = 0; i < 200; i++) longRegexp += "x"; foldSame("x = RegExp(\"" + longRegexp + "\")"); // Shouldn't fold RegExp unnormalized because // we can't be sure that RegExp hasn't been redefined disableNormalize(); foldSame("x = new RegExp(\"foobar\")"); } public void testVersionSpecificRegExpQuirks() { enableNormalize(); // Don't fold if the flags contain 'g' enableEcmaScript5(false); fold("x = new RegExp(\"foobar\", \"g\")", "x = RegExp(\"foobar\",\"g\")"); fold("x = new RegExp(\"foobar\", \"ig\")", "x = RegExp(\"foobar\",\"ig\")"); // ... unless in ECMAScript 5 mode per section 7.8.5 of ECMAScript 5. enableEcmaScript5(true); fold("x = new RegExp(\"foobar\", \"ig\")", "x = /foobar/ig"); // Don't fold things that crash older versions of Safari and that don't work // as regex literals on other old versions of Safari enableEcmaScript5(false); fold("x = new RegExp(\"\\u2028\")", "x = RegExp(\"\\u2028\")"); fold("x = new RegExp(\"\\\\\\\\u2028\")", "x = /\\\\u2028/"); // Sunset Safari exclusions for ECMAScript 5 and later. enableEcmaScript5(true); fold("x = new RegExp(\"\\u2028\\u2029\")", "x = /\\u2028\\u2029/"); fold("x = new RegExp(\"\\\\u2028\")", "x = /\\u2028/"); fold("x = new RegExp(\"\\\\\\\\u2028\")", "x = /\\\\u2028/"); } public void testFoldRegExpConstructorStringCompare() { // Might have something to do with the internal representation of \n and how // it is used in node comparison. assertResultString("x=new RegExp(\"\\n\", \"i\")", "x=/\\n/i", true); } public void testContainsUnicodeEscape() throws Exception { assertTrue(!PeepholeSubstituteAlternateSyntax.containsUnicodeEscape("")); assertTrue(!PeepholeSubstituteAlternateSyntax.containsUnicodeEscape("foo")); assertTrue(PeepholeSubstituteAlternateSyntax.containsUnicodeEscape( "\u2028")); assertTrue(PeepholeSubstituteAlternateSyntax.containsUnicodeEscape( "\\u2028")); assertTrue( PeepholeSubstituteAlternateSyntax.containsUnicodeEscape("foo\\u2028")); assertTrue(!PeepholeSubstituteAlternateSyntax.containsUnicodeEscape( "foo\\\\u2028")); assertTrue(PeepholeSubstituteAlternateSyntax.containsUnicodeEscape( "foo\\\\u2028bar\\u2028")); } public void testFoldLiteralObjectConstructors() { enableNormalize(); // Can fold when normalized fold("x = new Object", "x = ({})"); fold("x = new Object()", "x = ({})"); fold("x = Object()", "x = ({})"); disableNormalize(); // Cannot fold above when not normalized foldSame("x = new Object"); foldSame("x = new Object()"); foldSame("x = Object()"); enableNormalize(); // Cannot fold, the constructor being used is actually a local function foldSame("x = " + "(function f(){function Object(){this.x=4};return new Object();})();"); } public void testFoldLiteralArrayConstructors() { enableNormalize(); // No arguments - can fold when normalized fold("x = new Array", "x = []"); fold("x = new Array()", "x = []"); fold("x = Array()", "x = []"); // One argument - can be fold when normalized fold("x = new Array(0)", "x = []"); fold("x = Array(0)", "x = []"); fold("x = new Array(\"a\")", "x = [\"a\"]"); fold("x = Array(\"a\")", "x = [\"a\"]"); // One argument - cannot be fold when normalized fold("x = new Array(7)", "x = Array(7)"); fold("x = Array(7)", "x = Array(7)"); fold("x = new Array(y)", "x = Array(y)"); fold("x = Array(y)", "x = Array(y)"); fold("x = new Array(foo())", "x = Array(foo())"); fold("x = Array(foo())", "x = Array(foo())"); // More than one argument - can be fold when normalized fold("x = new Array(1, 2, 3, 4)", "x = [1, 2, 3, 4]"); fold("x = Array(1, 2, 3, 4)", "x = [1, 2, 3, 4]"); fold("x = new Array('a', 1, 2, 'bc', 3, {}, 'abc')", "x = ['a', 1, 2, 'bc', 3, {}, 'abc']"); fold("x = Array('a', 1, 2, 'bc', 3, {}, 'abc')", "x = ['a', 1, 2, 'bc', 3, {}, 'abc']"); fold("x = new Array(Array(1, '2', 3, '4'))", "x = [[1, '2', 3, '4']]"); fold("x = Array(Array(1, '2', 3, '4'))", "x = [[1, '2', 3, '4']]"); fold("x = new Array(Object(), Array(\"abc\", Object(), Array(Array())))", "x = [{}, [\"abc\", {}, [[]]]]"); fold("x = new Array(Object(), Array(\"abc\", Object(), Array(Array())))", "x = [{}, [\"abc\", {}, [[]]]]"); disableNormalize(); // Cannot fold above when not normalized foldSame("x = new Array"); foldSame("x = new Array()"); foldSame("x = Array()"); foldSame("x = new Array(0)"); foldSame("x = Array(0)"); foldSame("x = new Array(\"a\")"); foldSame("x = Array(\"a\")"); foldSame("x = new Array(7)"); foldSame("x = Array(7)"); foldSame("x = new Array(foo())"); foldSame("x = Array(foo())"); foldSame("x = new Array(1, 2, 3, 4)"); foldSame("x = Array(1, 2, 3, 4)"); foldSame("x = new Array('a', 1, 2, 'bc', 3, {}, 'abc')"); foldSame("x = Array('a', 1, 2, 'bc', 3, {}, 'abc')"); foldSame("x = new Array(Array(1, '2', 3, '4'))"); foldSame("x = Array(Array(1, '2', 3, '4'))"); foldSame("x = new Array(" + "Object(), Array(\"abc\", Object(), Array(Array())))"); foldSame("x = new Array(" + "Object(), Array(\"abc\", Object(), Array(Array())))"); } public void testMinimizeExprCondition() { fold("(x ? true : false) && y()", "x&&y()"); fold("(x ? false : true) && y()", "(!x)&&y()"); fold("(x ? true : y) && y()", "(x || y)&&y()"); fold("(x ? y : false) && y()", "(x && y)&&y()"); fold("(x && true) && y()", "x && y()"); fold("(x && false) && y()", "0&&y()"); fold("(x || true) && y()", "1&&y()"); fold("(x || false) && y()", "x&&y()"); } public void testMinimizeWhileCondition() { // This test uses constant folding logic, so is only here for completeness. fold("while(!!true) foo()", "while(1) foo()"); // These test tryMinimizeCondition fold("while(!!x) foo()", "while(x) foo()"); fold("while(!(!x&&!y)) foo()", "while(x||y) foo()"); fold("while(x||!!y) foo()", "while(x||y) foo()"); fold("while(!(!!x&&y)) foo()", "while(!x||!y) foo()"); fold("while(!(!x&&y)) foo()", "while(x||!y) foo()"); fold("while(!(x||!y)) foo()", "while(!x&&y) foo()"); fold("while(!(x||y)) foo()", "while(!x&&!y) foo()"); fold("while(!(!x||y-z)) foo()", "while(x&&!(y-z)) foo()"); fold("while(!(!(x/y)||z+w)) foo()", "while(x/y&&!(z+w)) foo()"); foldSame("while(!(x+y||z)) foo()"); foldSame("while(!(x&&y*z)) foo()"); fold("while(!(!!x&&y)) foo()", "while(!x||!y) foo()"); fold("while(x&&!0) foo()", "while(x) foo()"); fold("while(x||!1) foo()", "while(x) foo()"); fold("while(!((x,y)&&z)) foo()", "while(!(x,y)||!z) foo()"); } public void testMinimizeForCondition() { // This test uses constant folding logic, so is only here for completeness. // These could be simplified to "for(;;) ..." fold("for(;!!true;) foo()", "for(;1;) foo()"); // Don't bother with FOR inits as there are normalized out. fold("for(!!true;;) foo()", "for(!0;;) foo()"); // These test tryMinimizeCondition fold("for(;!!x;) foo()", "for(;x;) foo()"); // sanity check foldSame("for(a in b) foo()"); foldSame("for(a in {}) foo()"); foldSame("for(a in []) foo()"); fold("for(a in !!true) foo()", "for(a in !0) foo()"); } public void testMinimizeCondition_example1() { // Based on a real failing code sample. fold("if(!!(f() > 20)) {foo();foo()}", "if(f() > 20){foo();foo()}"); } public void testFoldLoopBreakLate() { late = true; fold("for(;;) if (a) break", "for(;!a;);"); foldSame("for(;;) if (a) { f(); break }"); fold("for(;;) if (a) break; else f()", "for(;!a;) { { f(); } }"); fold("for(;a;) if (b) break", "for(;a && !b;);"); fold("for(;a;) { if (b) break; if (c) break; }", "for(;(a && !b);) if (c) break;"); fold("for(;(a && !b);) if (c) break;", "for(;(a && !b) && !c;);"); // 'while' is normalized to 'for' enableNormalize(true); fold("while(true) if (a) break", "for(;1&&!a;);"); } public void testFoldLoopBreakEarly() { late = false; foldSame("for(;;) if (a) break"); foldSame("for(;;) if (a) { f(); break }"); foldSame("for(;;) if (a) break; else f()"); foldSame("for(;a;) if (b) break"); foldSame("for(;a;) { if (b) break; if (c) break; }"); foldSame("while(1) if (a) break"); enableNormalize(true); foldSame("while(1) if (a) break"); } public void testFoldConditionalVarDeclaration() { fold("if(x) var y=1;else y=2", "var y=x?1:2"); fold("if(x) y=1;else var y=2", "var y=x?1:2"); foldSame("if(x) var y = 1; z = 2"); foldSame("if(x||y) y = 1; var z = 2"); foldSame("if(x) { var y = 1; print(y)} else y = 2 "); foldSame("if(x) var y = 1; else {y = 2; print(y)}"); } public void testFoldReturnResult() { fold("function f(){return false;}", "function f(){return !1}"); foldSame("function f(){return null;}"); fold("function f(){return void 0;}", "function f(){return}"); fold("function f(){return;}", "function f(){}"); foldSame("function f(){return void foo();}"); fold("function f(){return undefined;}", "function f(){return}"); fold("function f(){if(a()){return undefined;}}", "function f(){if(a()){return}}"); } public void testFoldStandardConstructors() { foldSame("new Foo('a')"); foldSame("var x = new goog.Foo(1)"); foldSame("var x = new String(1)"); foldSame("var x = new Number(1)"); foldSame("var x = new Boolean(1)"); enableNormalize(); fold("var x = new Object('a')", "var x = Object('a')"); fold("var x = new RegExp('')", "var x = RegExp('')"); fold("var x = new Error('20')", "var x = Error(\"20\")"); fold("var x = new Array(20)", "var x = Array(20)"); } public void testSubsituteReturn() { fold("function f() { while(x) { return }}", "function f() { while(x) { break }}"); foldSame("function f() { while(x) { return 5 } }"); foldSame("function f() { a: { return 5 } }"); fold("function f() { while(x) { return 5} return 5}", "function f() { while(x) { break } return 5}"); fold("function f() { while(x) { return x} return x}", "function f() { while(x) { break } return x}"); fold("function f() { while(x) { if (y) { return }}}", "function f() { while(x) { if (y) { break }}}"); fold("function f() { while(x) { if (y) { return }} return}", "function f() { while(x) { if (y) { break }}}"); fold("function f() { while(x) { if (y) { return 5 }} return 5}", "function f() { while(x) { if (y) { break }} return 5}"); // It doesn't matter if x is changed between them. We are still returning // x at whatever x value current holds. The whole x = 1 is skipped. fold("function f() { while(x) { if (y) { return x } x = 1} return x}", "function f() { while(x) { if (y) { break } x = 1} return x}"); // RemoveUnreachableCode would take care of the useless breaks. fold("function f() { while(x) { if (y) { return x } return x} return x}", "function f() { while(x) { if (y) {} break }return x}"); // A break here only breaks out of the inner loop. foldSame("function f() { while(x) { while (y) { return } } }"); foldSame("function f() { while(1) { return 7} return 5}"); foldSame("function f() {" + " try { while(x) {return f()}} catch (e) { } return f()}"); foldSame("function f() {" + " try { while(x) {return f()}} finally {alert(1)} return f()}"); // Both returns has the same handler fold("function f() {" + " try { while(x) { return f() } return f() } catch (e) { } }", "function f() {" + " try { while(x) { break } return f() } catch (e) { } }"); // We can't fold this because it'll change the order of when foo is called. foldSame("function f() {" + " try { while(x) { return foo() } } finally { alert(1) } " + " return foo()}"); // This is fine, we have no side effect in the return value. fold("function f() {" + " try { while(x) { return 1 } } finally { alert(1) } return 1}", "function f() {" + " try { while(x) { break } } finally { alert(1) } return 1}" ); foldSame("function f() { try{ return a } finally { a = 2 } return a; }"); fold( "function f() { switch(a){ case 1: return a; default: g();} return a;}", "function f() { switch(a){ case 1: break; default: g();} return a; }"); } public void testSubsituteBreakForThrow() { foldSame("function f() { while(x) { throw Error }}"); fold("function f() { while(x) { throw Error } throw Error }", "function f() { while(x) { break } throw Error}"); foldSame("function f() { while(x) { throw Error(1) } throw Error(2)}"); foldSame("function f() { while(x) { throw Error(1) } return Error(2)}"); foldSame("function f() { while(x) { throw 5 } }"); foldSame("function f() { a: { throw 5 } }"); fold("function f() { while(x) { throw 5} throw 5}", "function f() { while(x) { break } throw 5}"); fold("function f() { while(x) { throw x} throw x}", "function f() { while(x) { break } throw x}"); foldSame("function f() { while(x) { if (y) { throw Error }}}"); fold("function f() { while(x) { if (y) { throw Error }} throw Error}", "function f() { while(x) { if (y) { break }} throw Error}"); fold("function f() { while(x) { if (y) { throw 5 }} throw 5}", "function f() { while(x) { if (y) { break }} throw 5}"); // It doesn't matter if x is changed between them. We are still throwing // x at whatever x value current holds. The whole x = 1 is skipped. fold("function f() { while(x) { if (y) { throw x } x = 1} throw x}", "function f() { while(x) { if (y) { break } x = 1} throw x}"); // RemoveUnreachableCode would take care of the useless breaks. fold("function f() { while(x) { if (y) { throw x } throw x} throw x}", "function f() { while(x) { if (y) {} break }throw x}"); // A break here only breaks out of the inner loop. foldSame("function f() { while(x) { while (y) { throw Error } } }"); foldSame("function f() { while(1) { throw 7} throw 5}"); foldSame("function f() {" + " try { while(x) {throw f()}} catch (e) { } throw f()}"); foldSame("function f() {" + " try { while(x) {throw f()}} finally {alert(1)} throw f()}"); // Both throws has the same handler fold("function f() {" + " try { while(x) { throw f() } throw f() } catch (e) { } }", "function f() {" + " try { while(x) { break } throw f() } catch (e) { } }"); // We can't fold this because it'll change the order of when foo is called. foldSame("function f() {" + " try { while(x) { throw foo() } } finally { alert(1) } " + " throw foo()}"); // This is fine, we have no side effect in the throw value. fold("function f() {" + " try { while(x) { throw 1 } } finally { alert(1) } throw 1}", "function f() {" + " try { while(x) { break } } finally { alert(1) } throw 1}" ); foldSame("function f() { try{ throw a } finally { a = 2 } throw a; }"); fold( "function f() { switch(a){ case 1: throw a; default: g();} throw a;}", "function f() { switch(a){ case 1: break; default: g();} throw a; }"); } public void testRemoveDuplicateReturn() { fold("function f() { return; }", "function f(){}"); foldSame("function f() { return a; }"); fold("function f() { if (x) { return a } return a; }", "function f() { if (x) {} return a; }"); foldSame( "function f() { try { if (x) { return a } } catch(e) {} return a; }"); foldSame( "function f() { try { if (x) {} } catch(e) {} return 1; }"); // finally clauses may have side effects foldSame( "function f() { try { if (x) { return a } } finally { a++ } return a; }"); // but they don't matter if the result doesn't have side effects and can't // be affect by side-effects. fold("function f() { try { if (x) { return 1 } } finally {} return 1; }", "function f() { try { if (x) {} } finally {} return 1; }"); fold("function f() { switch(a){ case 1: return a; } return a; }", "function f() { switch(a){ case 1: } return a; }"); fold("function f() { switch(a){ " + " case 1: return a; case 2: return a; } return a; }", "function f() { switch(a){ " + " case 1: break; case 2: } return a; }"); } public void testRemoveDuplicateThrow() { foldSame("function f() { throw a; }"); fold("function f() { if (x) { throw a } throw a; }", "function f() { if (x) {} throw a; }"); foldSame( "function f() { try { if (x) {throw a} } catch(e) {} throw a; }"); foldSame( "function f() { try { if (x) {throw 1} } catch(e) {f()} throw 1; }"); foldSame( "function f() { try { if (x) {throw 1} } catch(e) {f()} throw 1; }"); foldSame( "function f() { try { if (x) {throw 1} } catch(e) {throw 1}}"); fold( "function f() { try { if (x) {throw 1} } catch(e) {throw 1} throw 1; }", "function f() { try { if (x) {throw 1} } catch(e) {} throw 1; }"); // finally clauses may have side effects foldSame( "function f() { try { if (x) { throw a } } finally { a++ } throw a; }"); // but they don't matter if the result doesn't have side effects and can't // be affect by side-effects. fold("function f() { try { if (x) { throw 1 } } finally {} throw 1; }", "function f() { try { if (x) {} } finally {} throw 1; }"); fold("function f() { switch(a){ case 1: throw a; } throw a; }", "function f() { switch(a){ case 1: } throw a; }"); fold("function f() { switch(a){ " + "case 1: throw a; case 2: throw a; } throw a; }", "function f() { switch(a){ case 1: break; case 2: } throw a; }"); } public void testNestedIfCombine() { fold("if(x)if(y){while(1){}}", "if(x&&y){while(1){}}"); fold("if(x||z)if(y){while(1){}}", "if((x||z)&&y){while(1){}}"); fold("if(x)if(y||z){while(1){}}", "if((x)&&(y||z)){while(1){}}"); foldSame("if(x||z)if(y||z){while(1){}}"); fold("if(x)if(y){if(z){while(1){}}}", "if(x&&y&&z){while(1){}}"); } public void testFoldTrueFalse() { fold("x = true", "x = !0"); fold("x = false", "x = !1"); } public void testIssue291() { fold("if (true) { f.onchange(); }", "if (1) f.onchange();"); foldSame("if (f) { f.onchange(); }"); foldSame("if (f) { f.bar(); } else { f.onchange(); }"); fold("if (f) { f.bonchange(); }", "f && f.bonchange();"); foldSame("if (f) { f['x'](); }"); } public void testUndefined() { foldSame("var x = undefined"); foldSame("function f(f) {var undefined=2;var x = undefined;}"); this.enableNormalize(); fold("var x = undefined", "var x=void 0"); foldSame( "var undefined = 1;" + "function f() {var undefined=2;var x = undefined;}"); foldSame("function f(undefined) {}"); foldSame("try {} catch(undefined) {}"); foldSame("for (undefined in {}) {}"); foldSame("undefined++;"); fold("undefined += undefined;", "undefined += void 0;"); } public void testSplitCommaExpressions() { late = false; // Don't try to split in expressions. foldSame("while (foo(), !0) boo()"); foldSame("var a = (foo(), !0);"); foldSame("a = (foo(), !0);"); // Don't try to split COMMA under LABELs. foldSame("a:a(),b()"); fold("(x=2), foo()", "x=2; foo()"); fold("foo(), boo();", "foo(); boo()"); fold("(a(), b()), (c(), d());", "a(); b(); (c(), d());"); fold("a(); b(); (c(), d());", "a(); b(); c(); d();"); fold("foo(), true", "foo();true"); fold("foo();true", "foo();1"); fold("function x(){foo(), !0}", "function x(){foo(); !0}"); fold("function x(){foo(); !0}", "function x(){foo(); 1}"); } public void testComma1() { late = false; fold("1, 2", "1; 2"); fold("1; 2", "1; 1"); late = true; foldSame("1, 2"); } public void testComma2() { late = false; test("1, a()", "1; a()"); late = true; foldSame("1, a()"); } public void testComma3() { late = false; test("1, a(), b()", "1; a(); b()"); late = true; foldSame("1, a(), b()"); } public void testComma4() { late = false; test("a(), b()", "a();b()"); late = true; foldSame("a(), b()"); } public void testComma5() { late = false; test("a(), b(), 1", "a();b();1"); late = true; foldSame("a(), b(), 1"); } public void testObjectLiteral() { test("({})", "1"); test("({a:1})", "1"); testSame("({a:foo()})"); testSame("({'a':foo()})"); } public void testArrayLiteral() { test("([])", "1"); test("([1])", "1"); test("([a])", "1"); testSame("([foo()])"); } public void testStringArraySplitting() { testSame("var x=['1','2','3','4']"); testSame("var x=['1','2','3','4','5']"); test("var x=['1','2','3','4','5','6']", "var x='123456'.split('')"); test("var x=['1','2','3','4','5','00']", "var x='1 2 3 4 5 00'.split(' ')"); test("var x=['1','2','3','4','5','6','7']", "var x='1234567'.split('')"); test("var x=['1','2','3','4','5','6','00']", "var x='1 2 3 4 5 6 00'.split(' ')"); test("var x=[' ,',',',',',',',',',',']", "var x=' ,;,;,;,;,;,'.split(';')"); test("var x=[',,',' ',',',',',',',',']", "var x=',,; ;,;,;,;,'.split(';')"); test("var x=['a,',' ',',',',',',',',']", "var x='a,; ;,;,;,;,'.split(';')"); // all possible delimiters used, leave it alone testSame("var x=[',', ' ', ';', '{', '}']"); } public void testRemoveElseCause() { test("function f() {" + " if(x) return 1;" + " else if(x) return 2;" + " else if(x) return 3 }", "function f() {" + " if(x) return 1;" + "{ if(x) return 2;" + "{ if(x) return 3 } } }"); } public void testRemoveElseCause1() { test("function f() { if (x) throw 1; else f() }", "function f() { if (x) throw 1; { f() } }"); } public void testRemoveElseCause2() { test("function f() { if (x) return 1; else f() }", "function f() { if (x) return 1; { f() } }"); test("function f() { if (x) return; else f() }", "function f() { if (x) {} else { f() } }"); // This case is handled by minimize exit points. testSame("function f() { if (x) return; f() }"); } public void testRemoveElseCause3() { testSame("function f() { a:{if (x) break a; else f() } }"); testSame("function f() { if (x) { a:{ break a } } else f() }"); testSame("function f() { if (x) a:{ break a } else f() }"); } public void testRemoveElseCause4() { testSame("function f() { if (x) { if (y) { return 1; } } else f() }"); } public void testBindToCall1() { test("(goog.bind(f))()", "f()"); test("(goog.bind(f,a))()", "f.call(a)"); test("(goog.bind(f,a,b))()", "f.call(a,b)"); test("(goog.bind(f))(a)", "f(a)"); test("(goog.bind(f,a))(b)", "f.call(a,b)"); test("(goog.bind(f,a,b))(c)", "f.call(a,b,c)"); test("(goog.partial(f))()", "f()"); test("(goog.partial(f,a))()", "f(a)"); test("(goog.partial(f,a,b))()", "f(a,b)"); test("(goog.partial(f))(a)", "f(a)"); test("(goog.partial(f,a))(b)", "f(a,b)"); test("(goog.partial(f,a,b))(c)", "f(a,b,c)"); test("((function(){}).bind())()", "((function(){}))()"); test("((function(){}).bind(a))()", "((function(){})).call(a)"); test("((function(){}).bind(a,b))()", "((function(){})).call(a,b)"); test("((function(){}).bind())(a)", "((function(){}))(a)"); test("((function(){}).bind(a))(b)", "((function(){})).call(a,b)"); test("((function(){}).bind(a,b))(c)", "((function(){})).call(a,b,c)"); // Without using type information we don't know "f" is a function. testSame("(f.bind())()"); testSame("(f.bind(a))()"); testSame("(f.bind())(a)"); testSame("(f.bind(a))(b)"); // Don't rewrite if the bind isn't the immediate call target testSame("(goog.bind(f)).call(g)"); } public void testBindToCall2() { test("(goog$bind(f))()", "f()"); test("(goog$bind(f,a))()", "f.call(a)"); test("(goog$bind(f,a,b))()", "f.call(a,b)"); test("(goog$bind(f))(a)", "f(a)"); test("(goog$bind(f,a))(b)", "f.call(a,b)"); test("(goog$bind(f,a,b))(c)", "f.call(a,b,c)"); test("(goog$partial(f))()", "f()"); test("(goog$partial(f,a))()", "f(a)"); test("(goog$partial(f,a,b))()", "f(a,b)"); test("(goog$partial(f))(a)", "f(a)"); test("(goog$partial(f,a))(b)", "f(a,b)"); test("(goog$partial(f,a,b))(c)", "f(a,b,c)"); // Don't rewrite if the bind isn't the immediate call target testSame("(goog$bind(f)).call(g)"); } public void testBindToCall3() { // TODO(johnlenz): The code generator wraps free calls with (0,...) to // prevent leaking "this", but the parser doesn't unfold it, making a // AST comparison fail. For now do a string comparison to validate the // correct code is in fact generated. // The FREE call wrapping should be moved out of the code generator // and into a denormalizing pass. new StringCompareTestCase().testBindToCall3(); } public void testSimpleFunctionCall() { test("var a = String(23)", "var a = '' + 23"); test("var a = String('hello')", "var a = '' + 'hello'"); testSame("var a = String('hello', bar());"); testSame("var a = String({valueOf: function() { return 1; }});"); } private static class StringCompareTestCase extends CompilerTestCase { StringCompareTestCase() { super("", false); } @Override protected CompilerPass getProcessor(Compiler compiler) { CompilerPass peepholePass = new PeepholeOptimizationsPass(compiler, new PeepholeSubstituteAlternateSyntax(false)); return peepholePass; } public void testBindToCall3() { test("(goog.bind(f.m))()", "(0,f.m)()"); test("(goog.bind(f.m,a))()", "f.m.call(a)"); test("(goog.bind(f.m))(a)", "(0,f.m)(a)"); test("(goog.bind(f.m,a))(b)", "f.m.call(a,b)"); test("(goog.partial(f.m))()", "(0,f.m)()"); test("(goog.partial(f.m,a))()", "(0,f.m)(a)"); test("(goog.partial(f.m))(a)", "(0,f.m)(a)"); test("(goog.partial(f.m,a))(b)", "(0,f.m)(a,b)"); // Without using type information we don't know "f" is a function. testSame("f.m.bind()()"); testSame("f.m.bind(a)()"); testSame("f.m.bind()(a)"); testSame("f.m.bind(a)(b)"); // Don't rewrite if the bind isn't the immediate call target testSame("goog.bind(f.m).call(g)"); } } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.Lists; import com.google.javascript.jscomp.CompilerOptions.TracerMode; import com.google.javascript.jscomp.PhaseOptimizer.Loop; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import junit.framework.TestCase; import java.util.List; import java.util.Random; /** * Tests for {@link PhaseOptimizer}. * @author nicksantos@google.com (Nick Santos) */ public class PhaseOptimizerTest extends TestCase { private final List<String> passesRun = Lists.newArrayList(); private PhaseOptimizer optimizer; private Compiler compiler; private PerformanceTracker tracker; @Override public void setUp() { passesRun.clear(); compiler = new Compiler(); compiler.initCompilerOptionsIfTesting(); tracker = new PerformanceTracker( new Node(Token.BLOCK), TracerMode.TIMING_ONLY); optimizer = new PhaseOptimizer(compiler, tracker, null); } public void testOneRun() { addOneTimePass("x"); assertPasses("x"); } public void testLoop1() { Loop loop = optimizer.addFixedPointLoop(); addLoopedPass(loop, "x", 0); assertPasses("x"); } public void testLoop2() { Loop loop = optimizer.addFixedPointLoop(); addLoopedPass(loop, "x", 3); assertPasses("x", "x", "x", "x"); } public void testLoop3() { Loop loop = optimizer.addFixedPointLoop(); addLoopedPass(loop, "x", 3); addLoopedPass(loop, "y", 1); assertPasses("x", "y", "x", "y", "x", "x", "y"); } public void testNotInfiniteLoop() { Loop loop = optimizer.addFixedPointLoop(); addLoopedPass(loop, "x", PhaseOptimizer.MAX_LOOPS - 1); optimizer.process(null, null); assertEquals("There should be no errors.", 0, compiler.getErrorCount()); } public void testInfiniteLoop() { Loop loop = optimizer.addFixedPointLoop(); addLoopedPass(loop, "x", PhaseOptimizer.MAX_LOOPS + 1); try { optimizer.process(null, null); fail("Expected RuntimeException"); } catch (RuntimeException e) { assertTrue(e.getMessage().contains(PhaseOptimizer.OPTIMIZE_LOOP_ERROR)); } } public void testCombined() { addOneTimePass("a"); Loop loop = optimizer.addFixedPointLoop(); addLoopedPass(loop, "x", 3); addLoopedPass(loop, "y", 1); addOneTimePass("z"); assertPasses("a", "x", "y", "x", "y", "x", "x", "y", "z"); } public void testSanityCheck() { Loop loop = optimizer.addFixedPointLoop(); addLoopedPass(loop, "x", 1); addOneTimePass("z"); optimizer.setSanityCheck( createPassFactory("sanity", createPass("sanity", 0), false)); assertPasses("x", "sanity", "x", "sanity", "z", "sanity"); } public void testConsumption1() { optimizer.consume( Lists.newArrayList( createPassFactory("a", 0, true), createPassFactory("b", 1, false), createPassFactory("c", 2, false), createPassFactory("d", 1, false), createPassFactory("e", 1, true), createPassFactory("f", 0, true))); assertPasses("a", "b", "c", "d", "b", "c", "d", "c", "b", "d", "e", "f"); } public void testConsumption2() { optimizer.consume( Lists.newArrayList( createPassFactory("a", 2, false), createPassFactory("b", 1, true), createPassFactory("c", 1, false))); assertPasses("a", "a", "a", "b", "c", "c"); } public void testConsumption3() { optimizer.consume( Lists.newArrayList( createPassFactory("a", 2, true), createPassFactory("b", 0, false), createPassFactory("c", 0, false))); assertPasses("a", "b", "c"); } public void testDuplicateLoop() { Loop loop = optimizer.addFixedPointLoop(); addLoopedPass(loop, "x", 1); try { addLoopedPass(loop, "x", 1); fail("Expected exception"); } catch (IllegalArgumentException e) {} } public void testPassOrdering() { Loop loop = optimizer.addFixedPointLoop(); List<String> optimalOrder = Lists.newArrayList( PhaseOptimizer.OPTIMAL_ORDER); Random random = new Random(); while (optimalOrder.size() > 0) { addLoopedPass( loop, optimalOrder.remove(random.nextInt(optimalOrder.size())), 0); } optimizer.process(null, null); assertEquals(PhaseOptimizer.OPTIMAL_ORDER, passesRun); } public void testProgress() { final List<Double> progressList = Lists.newArrayList(); compiler = new Compiler() { @Override void setProgress(double p, String name) { progressList.add(p); } }; compiler.initCompilerOptionsIfTesting(); optimizer = new PhaseOptimizer(compiler, null, new PhaseOptimizer.ProgressRange(0, 100)); addOneTimePass("x1"); addOneTimePass("x2"); addOneTimePass("x3"); addOneTimePass("x4"); optimizer.process(null, null); assertEquals(4, progressList.size()); assertEquals(25, Math.round(progressList.get(0))); assertEquals(50, Math.round(progressList.get(1))); assertEquals(75, Math.round(progressList.get(2))); assertEquals(100, Math.round(progressList.get(3))); } public void assertPasses(String ... names) { optimizer.process(null, null); assertEquals(Lists.newArrayList(names), passesRun); } private void addOneTimePass(String name) { optimizer.addOneTimePass( createPassFactory(name, 0, true)); } private void addLoopedPass(Loop loop, String name, int numChanges) { loop.addLoopedPass( createPassFactory(name, numChanges, false)); } private PassFactory createPassFactory( String name, int numChanges, boolean isOneTime) { return createPassFactory(name, createPass(name, numChanges), isOneTime); } private PassFactory createPassFactory( String name, final CompilerPass pass, boolean isOneTime) { return new PassFactory(name, isOneTime) { @Override protected CompilerPass create(AbstractCompiler compiler) { return pass; } }; } private CompilerPass createPass(final String name, int numChanges) { final int[] numChangesClosure = new int[] {numChanges}; return new CompilerPass() { @Override public void process(Node externs, Node root) { passesRun.add(name); if (numChangesClosure[0] > 0) { compiler.reportCodeChange(); numChangesClosure[0] = numChangesClosure[0] - 1; } } }; } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; /** * Tests for PrepareAst. * @author nicksantos@google.com (Nick Santos) */ public class PrepareAstTest extends CompilerTestCase { public PrepareAstTest() { super.enableLineNumberCheck(true); } @Override public CompilerPass getProcessor(Compiler compiler) { return null; // unused } public void testJsDocNormalization() throws Exception { Node root = parseExpectedJs( "var x = {/** @return {number} */ a: function() {}," + " c: /** @type {string} */ ('d')};"); Node objlit = root.getFirstChild().getFirstChild().getFirstChild() .getFirstChild(); assertEquals(Token.OBJECTLIT, objlit.getType()); Node firstKey = objlit.getFirstChild(); Node firstVal = firstKey.getFirstChild(); Node secondKey = firstKey.getNext(); Node secondVal = secondKey.getFirstChild(); assertNotNull(firstKey.getJSDocInfo()); assertNotNull(firstVal.getJSDocInfo()); assertNull(secondKey.getJSDocInfo()); assertNotNull(secondVal.getJSDocInfo()); } public void testFreeCall1() throws Exception { Node root = parseExpectedJs("foo();"); Node script = root.getFirstChild(); Preconditions.checkState(script.isScript()); Node firstExpr = script.getFirstChild(); Node call = firstExpr.getFirstChild(); Preconditions.checkState(call.isCall()); assertTrue(call.getBooleanProp(Node.FREE_CALL)); } public void testFreeCall2() throws Exception { Node root = parseExpectedJs("x.foo();"); Node script = root.getFirstChild(); Preconditions.checkState(script.isScript()); Node firstExpr = script.getFirstChild(); Node call = firstExpr.getFirstChild(); Preconditions.checkState(call.isCall()); assertFalse(call.getBooleanProp(Node.FREE_CALL)); } }
/* * Copyright 2006 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.rhino.Node; import com.google.javascript.jscomp.CheckLevel; import static com.google.javascript.jscomp.ProcessClosurePrimitives.BASE_CLASS_ERROR; import static com.google.javascript.jscomp.ProcessClosurePrimitives.DUPLICATE_NAMESPACE_ERROR; import static com.google.javascript.jscomp.ProcessClosurePrimitives.EXPECTED_OBJECTLIT_ERROR; import static com.google.javascript.jscomp.ProcessClosurePrimitives.FUNCTION_NAMESPACE_ERROR; import static com.google.javascript.jscomp.ProcessClosurePrimitives.INVALID_ARGUMENT_ERROR; import static com.google.javascript.jscomp.ProcessClosurePrimitives.INVALID_PROVIDE_ERROR; import static com.google.javascript.jscomp.ProcessClosurePrimitives.INVALID_STYLE_ERROR; import static com.google.javascript.jscomp.ProcessClosurePrimitives.LATE_PROVIDE_ERROR; import static com.google.javascript.jscomp.ProcessClosurePrimitives.MISSING_PROVIDE_ERROR; import static com.google.javascript.jscomp.ProcessClosurePrimitives.NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR; import static com.google.javascript.jscomp.ProcessClosurePrimitives.NULL_ARGUMENT_ERROR; import static com.google.javascript.jscomp.ProcessClosurePrimitives.TOO_MANY_ARGUMENTS_ERROR; import static com.google.javascript.jscomp.ProcessClosurePrimitives.XMODULE_REQUIRE_ERROR; import static com.google.javascript.jscomp.ProcessClosurePrimitives.INVALID_CSS_RENAMING_MAP; /** * Tests for {@link ProcessClosurePrimitives}. * */ public class ProcessClosurePrimitivesTest extends CompilerTestCase { private String additionalCode; private String additionalEndCode; private boolean addAdditionalNamespace; public ProcessClosurePrimitivesTest() { enableLineNumberCheck(true); } @Override protected void setUp() { additionalCode = null; additionalEndCode = null; addAdditionalNamespace = false; } @Override public CompilerPass getProcessor(final Compiler compiler) { if ((additionalCode == null) && (additionalEndCode == null)) { return new ProcessClosurePrimitives( compiler, null, CheckLevel.ERROR); } else { return new CompilerPass() { @Override public void process(Node externs, Node root) { // Process the original code. new ProcessClosurePrimitives(compiler, null, CheckLevel.OFF) .process(externs, root); // Inject additional code at the beginning. if (additionalCode != null) { SourceFile file = SourceFile.fromCode("additionalcode", additionalCode); Node scriptNode = root.getFirstChild(); Node newScriptNode = new CompilerInput(file).getAstRoot(compiler); if (addAdditionalNamespace) { newScriptNode.getFirstChild() .putBooleanProp(Node.IS_NAMESPACE, true); } while (newScriptNode.getLastChild() != null) { Node lastChild = newScriptNode.getLastChild(); newScriptNode.removeChild(lastChild); scriptNode.addChildBefore(lastChild, scriptNode.getFirstChild()); } } // Inject additional code at the end. if (additionalEndCode != null) { SourceFile file = SourceFile.fromCode("additionalendcode", additionalEndCode); Node scriptNode = root.getFirstChild(); Node newScriptNode = new CompilerInput(file).getAstRoot(compiler); if (addAdditionalNamespace) { newScriptNode.getFirstChild() .putBooleanProp(Node.IS_NAMESPACE, true); } while (newScriptNode.getFirstChild() != null) { Node firstChild = newScriptNode.getFirstChild(); newScriptNode.removeChild(firstChild); scriptNode.addChildToBack(firstChild); } } // Process the tree a second time. new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR) .process(externs, root); } }; } } @Override public int getNumRepetitions() { return 1; } public void testSimpleProvides() { test("goog.provide('foo');", "var foo={};"); test("goog.provide('foo.bar');", "var foo={}; foo.bar={};"); test("goog.provide('foo.bar.baz');", "var foo={}; foo.bar={}; foo.bar.baz={};"); test("goog.provide('foo.bar.baz.boo');", "var foo={}; foo.bar={}; foo.bar.baz={}; foo.bar.baz.boo={};"); test("goog.provide('goog.bar');", "goog.bar={};"); // goog is special-cased } public void testMultipleProvides() { test("goog.provide('foo.bar'); goog.provide('foo.baz');", "var foo={}; foo.bar={}; foo.baz={};"); test("goog.provide('foo.bar.baz'); goog.provide('foo.boo.foo');", "var foo={}; foo.bar={}; foo.bar.baz={}; foo.boo={}; foo.boo.foo={};"); test("goog.provide('foo.bar.baz'); goog.provide('foo.bar.boo');", "var foo={}; foo.bar={}; foo.bar.baz={}; foo.bar.boo={};"); test("goog.provide('foo.bar.baz'); goog.provide('goog.bar.boo');", "var foo={}; foo.bar={}; foo.bar.baz={}; goog.bar={}; " + "goog.bar.boo={};"); } public void testRemovalOfProvidedObjLit() { test("goog.provide('foo'); foo = 0;", "var foo = 0;"); test("goog.provide('foo'); foo = {a: 0};", "var foo = {a: 0};"); test("goog.provide('foo'); foo = function(){};", "var foo = function(){};"); test("goog.provide('foo'); var foo = 0;", "var foo = 0;"); test("goog.provide('foo'); var foo = {a: 0};", "var foo = {a: 0};"); test("goog.provide('foo'); var foo = function(){};", "var foo = function(){};"); test("goog.provide('foo.bar.Baz'); foo.bar.Baz=function(){};", "var foo={}; foo.bar={}; foo.bar.Baz=function(){};"); test("goog.provide('foo.bar.moo'); foo.bar.moo={E:1,S:2};", "var foo={}; foo.bar={}; foo.bar.moo={E:1,S:2};"); test("goog.provide('foo.bar.moo'); foo.bar.moo={E:1}; foo.bar.moo={E:2};", "var foo={}; foo.bar={}; foo.bar.moo={E:1}; foo.bar.moo={E:2};"); } public void testProvidedDeclaredFunctionError() { test("goog.provide('foo'); function foo(){}", null, FUNCTION_NAMESPACE_ERROR); } public void testRemovalMultipleAssignment1() { test("goog.provide('foo'); foo = 0; foo = 1", "var foo = 0; foo = 1;"); } public void testRemovalMultipleAssignment2() { test("goog.provide('foo'); var foo = 0; foo = 1", "var foo = 0; foo = 1;"); } public void testRemovalMultipleAssignment3() { test("goog.provide('foo'); foo = 0; var foo = 1", "foo = 0; var foo = 1;"); } public void testRemovalMultipleAssignment4() { test("goog.provide('foo.bar'); foo.bar = 0; foo.bar = 1", "var foo = {}; foo.bar = 0; foo.bar = 1"); } public void testNoRemovalFunction1() { test("goog.provide('foo'); function f(){foo = 0}", "var foo = {}; function f(){foo = 0}"); } public void testNoRemovalFunction2() { test("goog.provide('foo'); function f(){var foo = 0}", "var foo = {}; function f(){var foo = 0}"); } public void testRemovalMultipleAssignmentInIf1() { test("goog.provide('foo'); if (true) { var foo = 0 } else { foo = 1 }", "if (true) { var foo = 0 } else { foo = 1 }"); } public void testRemovalMultipleAssignmentInIf2() { test("goog.provide('foo'); if (true) { foo = 0 } else { var foo = 1 }", "if (true) { foo = 0 } else { var foo = 1 }"); } public void testRemovalMultipleAssignmentInIf3() { test("goog.provide('foo'); if (true) { foo = 0 } else { foo = 1 }", "if (true) { var foo = 0 } else { foo = 1 }"); } public void testRemovalMultipleAssignmentInIf4() { test("goog.provide('foo.bar');" + "if (true) { foo.bar = 0 } else { foo.bar = 1 }", "var foo = {}; if (true) { foo.bar = 0 } else { foo.bar = 1 }"); } public void testMultipleDeclarationError1() { String rest = "if (true) { foo.bar = 0 } else { foo.bar = 1 }"; test("goog.provide('foo.bar');" + "var foo = {};" + rest, "var foo = {};" + "var foo = {};" + rest); } public void testMultipleDeclarationError2() { test("goog.provide('foo.bar');" + "if (true) { var foo = {}; foo.bar = 0 } else { foo.bar = 1 }", "var foo = {};" + "if (true) {" + " var foo = {}; foo.bar = 0" + "} else {" + " foo.bar = 1" + "}"); } public void testMultipleDeclarationError3() { test("goog.provide('foo.bar');" + "if (true) { foo.bar = 0 } else { var foo = {}; foo.bar = 1 }", "var foo = {};" + "if (true) {" + " foo.bar = 0" + "} else {" + " var foo = {}; foo.bar = 1" + "}"); } public void testProvideAfterDeclarationError() { test("var x = 42; goog.provide('x');", "var x = 42; var x = {}"); } public void testProvideErrorCases() { test("goog.provide();", "", NULL_ARGUMENT_ERROR); test("goog.provide(5);", "", INVALID_ARGUMENT_ERROR); test("goog.provide([]);", "", INVALID_ARGUMENT_ERROR); test("goog.provide({});", "", INVALID_ARGUMENT_ERROR); test("goog.provide('foo', 'bar');", "", TOO_MANY_ARGUMENTS_ERROR); test("goog.provide('foo'); goog.provide('foo');", "", DUPLICATE_NAMESPACE_ERROR); test("goog.provide('foo.bar'); goog.provide('foo'); goog.provide('foo');", "", DUPLICATE_NAMESPACE_ERROR); } public void testRemovalOfRequires() { test("goog.provide('foo'); goog.require('foo');", "var foo={};"); test("goog.provide('foo.bar'); goog.require('foo.bar');", "var foo={}; foo.bar={};"); test("goog.provide('foo.bar.baz'); goog.require('foo.bar.baz');", "var foo={}; foo.bar={}; foo.bar.baz={};"); test("goog.provide('foo'); var x = 3; goog.require('foo'); something();", "var foo={}; var x = 3; something();"); testSame("foo.require('foo.bar');"); } public void testRequireErrorCases() { test("goog.require();", "", NULL_ARGUMENT_ERROR); test("goog.require(5);", "", INVALID_ARGUMENT_ERROR); test("goog.require([]);", "", INVALID_ARGUMENT_ERROR); test("goog.require({});", "", INVALID_ARGUMENT_ERROR); } public void testLateProvides() { test("goog.require('foo'); goog.provide('foo');", "var foo={};", LATE_PROVIDE_ERROR); test("goog.require('foo.bar'); goog.provide('foo.bar');", "var foo={}; foo.bar={};", LATE_PROVIDE_ERROR); test("goog.provide('foo.bar'); goog.require('foo'); goog.provide('foo');", "var foo={}; foo.bar={};", LATE_PROVIDE_ERROR); } public void testMissingProvides() { test("goog.require('foo');", "", MISSING_PROVIDE_ERROR); test("goog.provide('foo'); goog.require('Foo');", "var foo={};", MISSING_PROVIDE_ERROR); test("goog.provide('foo'); goog.require('foo.bar');", "var foo={};", MISSING_PROVIDE_ERROR); test("goog.provide('foo'); var EXPERIMENT_FOO = true; " + "if (EXPERIMENT_FOO) {goog.require('foo.bar');}", "var foo={}; var EXPERIMENT_FOO = true; if (EXPERIMENT_FOO) {}", MISSING_PROVIDE_ERROR); } public void testAddDependency() { test("goog.addDependency('x.js', ['A', 'B'], []);", "0"); Compiler compiler = getLastCompiler(); assertTrue(compiler.getTypeRegistry().isForwardDeclaredType("A")); assertTrue(compiler.getTypeRegistry().isForwardDeclaredType("B")); assertFalse(compiler.getTypeRegistry().isForwardDeclaredType("C")); } public void testValidSetCssNameMapping() { test("goog.setCssNameMapping({foo:'bar',\"biz\":'baz'});", ""); CssRenamingMap map = getLastCompiler().getCssRenamingMap(); assertNotNull(map); assertEquals("bar", map.get("foo")); assertEquals("baz", map.get("biz")); } public void testValidSetCssNameMappingWithType() { test("goog.setCssNameMapping({foo:'bar',\"biz\":'baz'}, 'BY_PART');", ""); CssRenamingMap map = getLastCompiler().getCssRenamingMap(); assertNotNull(map); assertEquals("bar", map.get("foo")); assertEquals("baz", map.get("biz")); test("goog.setCssNameMapping({foo:'bar',biz:'baz','biz-foo':'baz-bar'}," + " 'BY_WHOLE');", ""); map = getLastCompiler().getCssRenamingMap(); assertNotNull(map); assertEquals("bar", map.get("foo")); assertEquals("baz", map.get("biz")); assertEquals("baz-bar", map.get("biz-foo")); } public void testSetCssNameMappingNonStringValueReturnsError() { // Make sure the argument is an object literal. test("var BAR = {foo:'bar'}; goog.setCssNameMapping(BAR);", "", EXPECTED_OBJECTLIT_ERROR); test("goog.setCssNameMapping([]);", "", EXPECTED_OBJECTLIT_ERROR); test("goog.setCssNameMapping(false);", "", EXPECTED_OBJECTLIT_ERROR); test("goog.setCssNameMapping(null);", "", EXPECTED_OBJECTLIT_ERROR); test("goog.setCssNameMapping(undefined);", "", EXPECTED_OBJECTLIT_ERROR); // Make sure all values of the object literal are string literals. test("var BAR = 'bar'; goog.setCssNameMapping({foo:BAR});", "", NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR); test("goog.setCssNameMapping({foo:6});", "", NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR); test("goog.setCssNameMapping({foo:false});", "", NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR); test("goog.setCssNameMapping({foo:null});", "", NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR); test("goog.setCssNameMapping({foo:undefined});", "", NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR); } public void testSetCssNameMappingValidity() { // Make sure that the keys don't have -'s test("goog.setCssNameMapping({'a': 'b', 'a-a': 'c'})", "", null, INVALID_CSS_RENAMING_MAP); // In full mode, we check that map(a-b)=map(a)-map(b) test("goog.setCssNameMapping({'a': 'b', 'a-a': 'c'}, 'BY_WHOLE')", "", null, INVALID_CSS_RENAMING_MAP); // Unknown mapping type test("goog.setCssNameMapping({foo:'bar'}, 'UNKNOWN');", "", INVALID_STYLE_ERROR); } public void testBadCrossModuleRequire() { test( createModuleStar( "", "goog.provide('goog.ui');", "goog.require('goog.ui');"), new String[] { "", "goog.ui = {};", "" }, null, XMODULE_REQUIRE_ERROR); } public void testGoodCrossModuleRequire1() { test( createModuleStar( "goog.provide('goog.ui');", "", "goog.require('goog.ui');"), new String[] { "goog.ui = {};", "", "", }); } public void testGoodCrossModuleRequire2() { test( createModuleStar( "", "", "goog.provide('goog.ui'); goog.require('goog.ui');"), new String[] { "", "", "goog.ui = {};", }); } // Tests providing additional code with non-overlapping var namespace. public void testSimpleAdditionalProvide() { additionalCode = "goog.provide('b.B'); b.B = {};"; test("goog.provide('a.A'); a.A = {};", "var b={};b.B={};var a={};a.A={};"); } // Same as above, but with the additional code added after the original. public void testSimpleAdditionalProvideAtEnd() { additionalEndCode = "goog.provide('b.B'); b.B = {};"; test("goog.provide('a.A'); a.A = {};", "var a={};a.A={};var b={};b.B={};"); } // Tests providing additional code with non-overlapping dotted namespace. public void testSimpleDottedAdditionalProvide() { additionalCode = "goog.provide('a.b.B'); a.b.B = {};"; test("goog.provide('c.d.D'); c.d.D = {};", "var a={};a.b={};a.b.B={};var c={};c.d={};c.d.D={};"); } // Tests providing additional code with overlapping var namespace. public void testOverlappingAdditionalProvide() { additionalCode = "goog.provide('a.B'); a.B = {};"; test("goog.provide('a.A'); a.A = {};", "var a={};a.B={};a.A={};"); } // Tests providing additional code with overlapping var namespace. public void testOverlappingAdditionalProvideAtEnd() { additionalEndCode = "goog.provide('a.B'); a.B = {};"; test("goog.provide('a.A'); a.A = {};", "var a={};a.A={};a.B={};"); } // Tests providing additional code with overlapping dotted namespace. public void testOverlappingDottedAdditionalProvide() { additionalCode = "goog.provide('a.b.B'); a.b.B = {};"; test("goog.provide('a.b.C'); a.b.C = {};", "var a={};a.b={};a.b.B={};a.b.C={};"); } // Tests that a require of additional code generates no error. public void testRequireOfAdditionalProvide() { additionalCode = "goog.provide('b.B'); b.B = {};"; test("goog.require('b.B'); goog.provide('a.A'); a.A = {};", "var b={};b.B={};var a={};a.A={};"); } // Tests that a require not in additional code generates (only) one error. public void testMissingRequireWithAdditionalProvide() { additionalCode = "goog.provide('b.B'); b.B = {};"; test("goog.require('b.C'); goog.provide('a.A'); a.A = {};", "var b={};b.B={};var a={};a.A={};", MISSING_PROVIDE_ERROR); } // Tests that a require in additional code generates no error. public void testLateRequire() { additionalEndCode = "goog.require('a.A');"; test("goog.provide('a.A'); a.A = {};", "var a={};a.A={};"); } // Tests a case where code is reordered after processing provides and then // provides are processed again. public void testReorderedProvides() { additionalCode = "a.B = {};"; // as if a.B was after a.A originally addAdditionalNamespace = true; test("goog.provide('a.A'); a.A = {};", "var a={};a.B={};a.A={};"); } // Another version of above. public void testReorderedProvides2() { additionalEndCode = "a.B = {};"; addAdditionalNamespace = true; test("goog.provide('a.A'); a.A = {};", "var a={};a.A={};a.B={};"); } // Provide a name before the definition of the class providing the // parent namespace. public void testProvideOrder1() { additionalEndCode = ""; addAdditionalNamespace = false; // TODO(johnlenz): This test confirms that the constructor (a.b) isn't // improperly removed, but this result isn't really what we want as the // reassign of a.b removes the definition of "a.b.c". test("goog.provide('a.b');" + "goog.provide('a.b.c');" + "a.b.c;" + "a.b = function(x,y) {};", "var a = {};" + "a.b = {};" + "a.b.c = {};" + "a.b.c;" + "a.b = function(x,y) {};"); } // Provide a name after the definition of the class providing the // parent namespace. public void testProvideOrder2() { additionalEndCode = ""; addAdditionalNamespace = false; // TODO(johnlenz): This test confirms that the constructor (a.b) isn't // improperly removed, but this result isn't really what we want as // namespace placeholders for a.b and a.b.c remain. test("goog.provide('a.b');" + "goog.provide('a.b.c');" + "a.b = function(x,y) {};" + "a.b.c;", "var a = {};" + "a.b = {};" + "a.b.c = {};" + "a.b = function(x,y) {};" + "a.b.c;"); } // Provide a name after the definition of the class providing the // parent namespace. public void testProvideOrder3a() { test("goog.provide('a.b');" + "a.b = function(x,y) {};" + "goog.provide('a.b.c');" + "a.b.c;", "var a = {};" + "a.b = function(x,y) {};" + "a.b.c = {};" + "a.b.c;"); } public void testProvideOrder3b() { additionalEndCode = ""; addAdditionalNamespace = false; // This tests a cleanly provided name, below a function namespace. test("goog.provide('a.b');" + "a.b = function(x,y) {};" + "goog.provide('a.b.c');" + "a.b.c;", "var a = {};" + "a.b = function(x,y) {};" + "a.b.c = {};" + "a.b.c;"); } public void testProvideOrder4a() { test("goog.provide('goog.a');" + "goog.provide('goog.a.b');" + "if (x) {" + " goog.a.b = 1;" + "} else {" + " goog.a.b = 2;" + "}", "goog.a={};" + "if(x)" + " goog.a.b=1;" + "else" + " goog.a.b=2;"); } public void testProvideOrder4b() { additionalEndCode = ""; addAdditionalNamespace = false; // This tests a cleanly provided name, below a namespace. test("goog.provide('goog.a');" + "goog.provide('goog.a.b');" + "if (x) {" + " goog.a.b = 1;" + "} else {" + " goog.a.b = 2;" + "}", "goog.a={};" + "if(x)" + " goog.a.b=1;" + "else" + " goog.a.b=2;"); } public void testInvalidProvide() { test("goog.provide('a.class');", null, INVALID_PROVIDE_ERROR); } private static final String METHOD_FORMAT = "function Foo() {} Foo.prototype.method = function() { %s };"; private static final String FOO_INHERITS = "goog.inherits(Foo, BaseFoo);"; public void testInvalidBase1() { test("goog.base(this, 'method');", null, BASE_CLASS_ERROR); } public void testInvalidBase2() { test("function Foo() {}" + "Foo.method = function() {" + " goog.base(this, 'method');" + "};", null, BASE_CLASS_ERROR); } public void testInvalidBase3() { test(String.format(METHOD_FORMAT, "goog.base();"), null, BASE_CLASS_ERROR); } public void testInvalidBase4() { test(String.format(METHOD_FORMAT, "goog.base(this, 'bar');"), null, BASE_CLASS_ERROR); } public void testInvalidBase5() { test(String.format(METHOD_FORMAT, "goog.base('foo', 'method');"), null, BASE_CLASS_ERROR); } public void testInvalidBase6() { test(String.format(METHOD_FORMAT, "goog.base.call(null, this, 'method');"), null, BASE_CLASS_ERROR); } public void testInvalidBase7() { test("function Foo() { goog.base(this); }", null, BASE_CLASS_ERROR); } public void testInvalidBase8() { test("var Foo = function() { goog.base(this); }", null, BASE_CLASS_ERROR); } public void testInvalidBase9() { test("var goog = {}; goog.Foo = function() { goog.base(this); }", null, BASE_CLASS_ERROR); } public void testValidBase1() { test(String.format(METHOD_FORMAT, "goog.base(this, 'method');"), String.format(METHOD_FORMAT, "Foo.superClass_.method.call(this)")); } public void testValidBase2() { test(String.format(METHOD_FORMAT, "goog.base(this, 'method', 1, 2);"), String.format(METHOD_FORMAT, "Foo.superClass_.method.call(this, 1, 2)")); } public void testValidBase3() { test(String.format(METHOD_FORMAT, "return goog.base(this, 'method');"), String.format(METHOD_FORMAT, "return Foo.superClass_.method.call(this)")); } public void testValidBase4() { test("function Foo() { goog.base(this, 1, 2); }" + FOO_INHERITS, "function Foo() { BaseFoo.call(this, 1, 2); } " + FOO_INHERITS); } public void testValidBase5() { test("var Foo = function() { goog.base(this, 1); };" + FOO_INHERITS, "var Foo = function() { BaseFoo.call(this, 1); }; " + FOO_INHERITS); } public void testValidBase6() { test("var goog = {}; goog.Foo = function() { goog.base(this); }; " + "goog.inherits(goog.Foo, goog.BaseFoo);", "var goog = {}; goog.Foo = function() { goog.BaseFoo.call(this); }; " + "goog.inherits(goog.Foo, goog.BaseFoo);"); } public void testImplicitAndExplicitProvide() { test("var goog = {}; " + "goog.provide('goog.foo.bar'); goog.provide('goog.foo');", "var goog = {}; goog.foo = {}; goog.foo.bar = {};"); } public void testImplicitProvideInIndependentModules() { test( createModuleStar( "", "goog.provide('apps.A');", "goog.provide('apps.B');"), new String[] { "var apps = {};", "apps.A = {};", "apps.B = {};", }); } public void testImplicitProvideInIndependentModules2() { test( createModuleStar( "goog.provide('apps');", "goog.provide('apps.foo.A');", "goog.provide('apps.foo.B');"), new String[] { "var apps = {}; apps.foo = {};", "apps.foo.A = {};", "apps.foo.B = {};", }); } public void testImplicitProvideInIndependentModules3() { test( createModuleStar( "var goog = {};", "goog.provide('goog.foo.A');", "goog.provide('goog.foo.B');"), new String[] { "var goog = {}; goog.foo = {};", "goog.foo.A = {};", "goog.foo.B = {};", }); } public void testProvideInIndependentModules1() { test( createModuleStar( "goog.provide('apps');", "goog.provide('apps.foo');", "goog.provide('apps.foo.B');"), new String[] { "var apps = {}; apps.foo = {};", "", "apps.foo.B = {};", }); } public void testProvideInIndependentModules2() { // TODO(nicksantos): Make this an error. test( createModuleStar( "goog.provide('apps');", "goog.provide('apps.foo'); apps.foo = {};", "goog.provide('apps.foo.B');"), new String[] { "var apps = {};", "apps.foo = {};", "apps.foo.B = {};", }); } public void testProvideInIndependentModules2b() { // TODO(nicksantos): Make this an error. test( createModuleStar( "goog.provide('apps');", "goog.provide('apps.foo'); apps.foo = function() {};", "goog.provide('apps.foo.B');"), new String[] { "var apps = {};", "apps.foo = function() {};", "apps.foo.B = {};", }); } public void testProvideInIndependentModules3() { test( createModuleStar( "goog.provide('apps');", "goog.provide('apps.foo.B');", "goog.provide('apps.foo'); goog.require('apps.foo');"), new String[] { "var apps = {}; apps.foo = {};", "apps.foo.B = {};", "", }); } public void testProvideInIndependentModules3b() { // TODO(nicksantos): Make this an error. test( createModuleStar( "goog.provide('apps');", "goog.provide('apps.foo.B');", "goog.provide('apps.foo'); apps.foo = function() {}; " + "goog.require('apps.foo');"), new String[] { "var apps = {};", "apps.foo.B = {};", "apps.foo = function() {};", }); } public void testProvideInIndependentModules4() { // Regression test for bug 261: // http://code.google.com/p/closure-compiler/issues/detail?id=261 test( createModuleStar( "goog.provide('apps');", "goog.provide('apps.foo.bar.B');", "goog.provide('apps.foo.bar.C');"), new String[] { "var apps = {};apps.foo = {};apps.foo.bar = {}", "apps.foo.bar.B = {};", "apps.foo.bar.C = {};", }); } public void testRequireOfBaseGoog() { test("goog.require('goog');", "", MISSING_PROVIDE_ERROR); } public void testSourcePositionPreservation() { test("goog.provide('foo.bar.baz');", "var foo = {};" + "foo.bar = {};" + "foo.bar.baz = {};"); Node root = getLastCompiler().getRoot(); Node fooDecl = findQualifiedNameNode("foo", root); Node fooBarDecl = findQualifiedNameNode("foo.bar", root); Node fooBarBazDecl = findQualifiedNameNode("foo.bar.baz", root); assertEquals(1, fooDecl.getLineno()); assertEquals(14, fooDecl.getCharno()); assertEquals(1, fooBarDecl.getLineno()); assertEquals(18, fooBarDecl.getCharno()); assertEquals(1, fooBarBazDecl.getLineno()); assertEquals(22, fooBarBazDecl.getCharno()); } public void testNoStubForProvidedTypedef() { test("goog.provide('x'); /** @typedef {number} */ var x;", "var x;"); } public void testNoStubForProvidedTypedef2() { test("goog.provide('x.y'); /** @typedef {number} */ x.y;", "var x = {}; x.y;"); } public void testNoStubForProvidedTypedef4() { test("goog.provide('x.y.z'); /** @typedef {number} */ x.y.z;", "var x = {}; x.y = {}; x.y.z;"); } public void testProvideRequireSameFile() { test("goog.provide('x');\ngoog.require('x');", "var x = {};"); } }
/* * Copyright 2011 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import java.util.List; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; /** * Unit tests for {@link ProcessCommonJSModules} */ public class ProcessCommonJSModulesTest extends CompilerTestCase { public ProcessCommonJSModulesTest() { } @Override protected CompilerPass getProcessor(Compiler compiler) { return new ProcessCommonJSModules(compiler, "foo/bar/", false); } @Override protected int getNumRepetitions() { return 1; } public void testWithoutExports() { setFilename("test"); test( "var name = require('name');" + "name()", "goog.provide('module$test');" + "var module$test = {};" + "goog.require('module$name');" + "var name$$module$test = module$name;" + "name$$module$test();"); setFilename("test/sub"); test( "var name = require('mod/name');" + "(function() { name(); })();", "goog.provide('module$test$sub');" + "var module$test$sub = {};" + "goog.require('module$mod$name');" + "var name$$module$test$sub = module$mod$name;" + "(function() { name$$module$test$sub(); })();"); } public void testExports() { setFilename("test"); test( "var name = require('name');" + "exports.foo = 1;", "goog.provide('module$test');" + "var module$test = {};" + "goog.require('module$name');" + "var name$$module$test = module$name;" + "module$test.foo = 1;"); test( "var name = require('name');" + "module.exports = function() {};", "goog.provide('module$test');" + "var module$test = {};" + "goog.require('module$name');" + "var name$$module$test = module$name;" + "module$test.module$exports = function() {};" + "if(module$test.module$exports)" + "module$test=module$test.module$exports"); } public void testVarRenaming() { setFilename("test"); test( "var a = 1, b = 2;" + "(function() { var a; b = 4})()", "goog.provide('module$test');" + "var module$test = {};" + "var a$$module$test = 1, b$$module$test = 2;" + "(function() { var a; b$$module$test = 4})();"); } public void testDash() { setFilename("test-test"); test( "var name = require('name'); exports.foo = 1;", "goog.provide('module$test_test');" + "var module$test_test = {};" + "goog.require('module$name');" + "var name$$module$test_test = module$name;" + "module$test_test.foo = 1;"); } public void testModuleName() { assertEquals("module$foo$baz", ProcessCommonJSModules.toModuleName("./baz.js", "foo/bar.js")); assertEquals("module$foo$baz_bar", ProcessCommonJSModules.toModuleName("./baz-bar.js", "foo/bar.js")); assertEquals("module$baz", ProcessCommonJSModules.toModuleName("../baz.js", "foo/bar.js")); assertEquals("module$baz", ProcessCommonJSModules.toModuleName("../../baz.js", "foo/bar/abc.js")); assertEquals("module$baz", ProcessCommonJSModules.toModuleName( "../../../baz.js", "foo/bar/abc/xyz.js")); setFilename("foo/bar"); test( "var name = require('name');", "goog.provide('module$foo$bar'); var module$foo$bar = {};" + "goog.require('module$name');" + "var name$$module$foo$bar = module$name;"); test( "var name = require('./name');", "goog.provide('module$foo$bar');" + "var module$foo$bar = {};" + "goog.require('module$foo$name');" + "var name$$module$foo$bar = module$foo$name;"); } public void testGuessModuleName() { ProcessCommonJSModules pass = new ProcessCommonJSModules(null, "foo"); assertEquals("module$baz", pass.guessCJSModuleName("foo/baz.js")); assertEquals("module$baz", pass.guessCJSModuleName("foo\\baz.js")); assertEquals("module$bar$baz", pass.guessCJSModuleName("foo\\bar\\baz.js")); } public void testSortInputs() throws Exception { SourceFile a = SourceFile.fromCode("a.js", "require('b');require('c')"); SourceFile b = SourceFile.fromCode("b.js", "require('d')"); SourceFile c = SourceFile.fromCode("c.js", "require('d')"); SourceFile d = SourceFile.fromCode("d.js", "1;"); assertSortedInputs( ImmutableList.of(d, b, c, a), ImmutableList.of(a, b, c, d)); assertSortedInputs( ImmutableList.of(d, b, c, a), ImmutableList.of(d, b, c, a)); assertSortedInputs( ImmutableList.of(d, c, b, a), ImmutableList.of(d, c, b, a)); assertSortedInputs( ImmutableList.of(d, b, c, a), ImmutableList.of(d, a, b, c)); } private void assertSortedInputs( List<SourceFile> expected, List<SourceFile> shuffled) throws Exception { Compiler compiler = new Compiler(System.err); compiler.initCompilerOptionsIfTesting(); compiler.getOptions().setProcessCommonJSModules(true); compiler.getOptions().dependencyOptions.setEntryPoints( Lists.newArrayList(ProcessCommonJSModules.toModuleName("a"))); compiler.compile(Lists.newArrayList(SourceFile.fromCode("externs.js", "")), shuffled, compiler.getOptions()); List<SourceFile> result = Lists.newArrayList(); for (JSModule m : compiler.getModuleGraph().getAllModules()) { for (CompilerInput i : m.getInputs()) { result.add(i.getSourceFile()); } } assertEquals(expected, result); } }
/* * Copyright 2007 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import static com.google.javascript.jscomp.SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR; import com.google.common.collect.Maps; import com.google.javascript.jscomp.GlobalNamespace.Name; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Map; /** * @author nicksantos@google.com (Nick Santos) */ public class ProcessDefinesTest extends CompilerTestCase { public ProcessDefinesTest() { super("var externMethod;"); // ProcessDefines emits warnings if the user tries to re-define a constant, // but the constant is not defined anywhere in the binary. allowSourcelessWarnings(); } private Map<String, Node> overrides = Maps.newHashMap(); private GlobalNamespace namespace; @Override public void setUp() throws Exception { super.setUp(); overrides.clear(); } @Override protected CompilerPass getProcessor(Compiler compiler) { return new ProcessDefinesWithInjectedNamespace(compiler); } @Override protected int getNumRepetitions() { // Only do one repetition, so that we can make sure the first pass keeps // GlobalNamespace up to date. return 1; } /** * Helper for tests that expects definitions to remain unchanged, such * that {@code definitions+js} is converted to {@code definitions+expected}. */ private void testWithPrefix(String definitions, String js, String expected) { test(definitions + js, definitions + expected); } public void testBasicDefine1() { test("/** @define {boolean} */ var DEF = true", "var DEF=true"); } public void testBasicDefine2() { test("/** @define {string} */ var DEF = 'a'", "var DEF=\"a\""); } public void testBasicDefine3() { test("/** @define {number} */ var DEF = 0", "var DEF=0"); } public void testDefineBadType() { test("/** @define {Object} */ var DEF = {}", null, ProcessDefines.INVALID_DEFINE_TYPE_ERROR); } public void testDefineWithBadValue1() { test("/** @define {boolean} */ var DEF = new Boolean(true);", null, ProcessDefines.INVALID_DEFINE_INIT_ERROR); } public void testDefineWithBadValue2() { test("/** @define {string} */ var DEF = 'x' + y;", null, ProcessDefines.INVALID_DEFINE_INIT_ERROR); } public void testDefineWithDependentValue() { test("/** @define {boolean} */ var BASE = false;\n" + "/** @define {boolean} */ var DEF = !BASE;", "var BASE=false;var DEF=!BASE"); test("var a = {};\n" + "/** @define {boolean} */ a.BASE = false;\n" + "/** @define {boolean} */ a.DEF = !a.BASE;", "var a={};a.BASE=false;a.DEF=!a.BASE"); } public void testDefineWithInvalidDependentValue() { test("var BASE = false;\n" + "/** @define {boolean} */ var DEF = !BASE;", null, ProcessDefines.INVALID_DEFINE_INIT_ERROR); } public void testOverriding1() { overrides.put("DEF_OVERRIDE_TO_TRUE", new Node(Token.TRUE)); overrides.put("DEF_OVERRIDE_TO_FALSE", new Node(Token.FALSE)); test( "/** @define {boolean} */ var DEF_OVERRIDE_TO_TRUE = false;" + "/** @define {boolean} */ var DEF_OVERRIDE_TO_FALSE = true", "var DEF_OVERRIDE_TO_TRUE=true;var DEF_OVERRIDE_TO_FALSE=false"); } public void testOverriding2() { overrides.put("DEF_OVERRIDE_TO_TRUE", new Node(Token.TRUE)); String normalConst = "var DEF_OVERRIDE_TO_FALSE=true;"; testWithPrefix( normalConst, "/** @define {boolean} */ var DEF_OVERRIDE_TO_TRUE = false", "var DEF_OVERRIDE_TO_TRUE=true"); } public void testOverriding3() { overrides.put("DEF_OVERRIDE_TO_TRUE", new Node(Token.TRUE)); test( "/** @define {boolean} */ var DEF_OVERRIDE_TO_TRUE = true;", "var DEF_OVERRIDE_TO_TRUE=true"); } public void testOverridingString0() { test( "/** @define {string} */ var DEF_OVERRIDE_STRING = 'x';", "var DEF_OVERRIDE_STRING=\"x\""); } public void testOverridingString1() { test( "/** @define {string} */ var DEF_OVERRIDE_STRING = 'x' + 'y';", "var DEF_OVERRIDE_STRING=\"x\" + \"y\""); } public void testOverridingString2() { overrides.put("DEF_OVERRIDE_STRING", Node.newString("foo")); test( "/** @define {string} */ var DEF_OVERRIDE_STRING = 'x';", "var DEF_OVERRIDE_STRING=\"foo\""); } public void testOverridingString3() { overrides.put("DEF_OVERRIDE_STRING", Node.newString("foo")); test( "/** @define {string} */ var DEF_OVERRIDE_STRING = 'x' + 'y';", "var DEF_OVERRIDE_STRING=\"foo\""); } public void testMisspelledOverride() { overrides.put("DEF_BAD_OVERIDE", new Node(Token.TRUE)); test("/** @define {boolean} */ var DEF_BAD_OVERRIDE = true", "var DEF_BAD_OVERRIDE=true", null, ProcessDefines.UNKNOWN_DEFINE_WARNING); } public void testCompiledIsKnownDefine() { overrides.put("COMPILED", new Node(Token.TRUE)); testSame(""); } public void testSimpleReassign1() { test("/** @define {boolean} */ var DEF = false; DEF = true;", "var DEF=true;true"); } public void testSimpleReassign2() { test("/** @define {number|boolean} */ var DEF=false;DEF=true;DEF=3", "var DEF=3;true;3"); Name def = namespace.getNameIndex().get("DEF"); assertEquals(1, def.getRefs().size()); assertEquals(1, def.globalSets); assertNotNull(def.getDeclaration()); } public void testSimpleReassign3() { test("/** @define {boolean} */ var DEF = false;var x;x = DEF = true;", "var DEF=true;var x;x=true"); } public void testDuplicateVar() { test("/** @define {boolean} */ var DEF = false; var DEF = true;", null, VAR_MULTIPLY_DECLARED_ERROR); } public void testAssignBeforeDeclaration1() { test("DEF=false;var b=false,/** @define {boolean} */DEF=true,c=false", null, ProcessDefines.INVALID_DEFINE_INIT_ERROR); } public void testAssignBeforeDeclaration2() { overrides.put("DEF_OVERRIDE_TO_TRUE", new Node(Token.TRUE)); test( "DEF_OVERRIDE_TO_TRUE = 3;" + "/** @define {boolean|number} */ var DEF_OVERRIDE_TO_TRUE = false;", null, ProcessDefines.INVALID_DEFINE_INIT_ERROR); } public void testEmptyDeclaration() { test("/** @define {boolean} */ var DEF;", null, ProcessDefines.INVALID_DEFINE_INIT_ERROR); } public void testReassignAfterCall() { test("/** @define {boolean} */var DEF=true;externMethod();DEF=false", null, ProcessDefines.DEFINE_NOT_ASSIGNABLE_ERROR); } public void testReassignAfterRef() { test("/** @define {boolean} */var DEF=true;var x = DEF;DEF=false", null, ProcessDefines.DEFINE_NOT_ASSIGNABLE_ERROR); } public void testReassignWithExpr() { test("/** @define {boolean} */var DEF=true;var x;DEF=x=false", null, ProcessDefines.INVALID_DEFINE_INIT_ERROR); } public void testReassignAfterNonGlobalRef() { test( "/** @define {boolean} */var DEF=true;" + "var x=function(){var y=DEF}; DEF=false", "var DEF=false;var x=function(){var y=DEF};false"); Name def = namespace.getNameIndex().get("DEF"); assertEquals(2, def.getRefs().size()); assertEquals(1, def.globalSets); assertNotNull(def.getDeclaration()); } public void testReassignAfterRefInConditional() { test( "/** @define {boolean} */var DEF=true;" + "if (false) {var x=DEF} DEF=false;", null, ProcessDefines.DEFINE_NOT_ASSIGNABLE_ERROR); } public void testAssignInNonGlobalScope() { test("/** @define {boolean} */var DEF=true;function foo() {DEF=false};", null, ProcessDefines.NON_GLOBAL_DEFINE_INIT_ERROR); } public void testDeclareInNonGlobalScope() { test("function foo() {/** @define {boolean} */var DEF=true;};", null, ProcessDefines.NON_GLOBAL_DEFINE_INIT_ERROR); } public void testDefineAssignmentInLoop() { test("/** @define {boolean} */var DEF=true;var x=0;while (x) {DEF=false;}", null, ProcessDefines.NON_GLOBAL_DEFINE_INIT_ERROR); } public void testWithNoDefines() { testSame("var DEF=true;var x={};x.foo={}"); } public void testNamespacedDefine1() { test("var a = {}; /** @define {boolean} */ a.B = false; a.B = true;", "var a = {}; a.B = true; true;"); Name aDotB = namespace.getNameIndex().get("a.B"); assertEquals(1, aDotB.getRefs().size()); assertEquals(1, aDotB.globalSets); assertNotNull(aDotB.getDeclaration()); } public void testNamespacedDefine2a() { overrides.put("a.B", new Node(Token.TRUE)); test("var a = {}; /** @define {boolean} */ a.B = false;", "var a = {}; a.B = true;"); } public void testNamespacedDefine2b() { // TODO(johnlenz): We should either reject the define as invalid // or replace its value. overrides.put("a.B", new Node(Token.TRUE)); test("var a = { /** @define {boolean} */ B : false };", "var a = {B : false};", null, ProcessDefines.UNKNOWN_DEFINE_WARNING); } public void testNamespacedDefine2c() { // TODO(johnlenz): We should either reject the define as invalid // or replace its value. overrides.put("a.B", new Node(Token.TRUE)); test("var a = { /** @define {boolean} */ get B() { return false } };", "var a = {get B() { return false } };", null, ProcessDefines.UNKNOWN_DEFINE_WARNING); } public void testNamespacedDefine3() { overrides.put("a.B", new Node(Token.TRUE)); test("var a = {};", "var a = {};", null, ProcessDefines.UNKNOWN_DEFINE_WARNING); } public void testNamespacedDefine4() { overrides.put("a.B", new Node(Token.TRUE)); test("var a = {}; /** @define {boolean} */ a.B = false;", "var a = {}; a.B = true;"); } public void testOverrideAfterAlias() { test("var x; /** @define {boolean} */var DEF=true; x=DEF; DEF=false;", null, ProcessDefines.DEFINE_NOT_ASSIGNABLE_ERROR); } private class ProcessDefinesWithInjectedNamespace implements CompilerPass { private final Compiler compiler; public ProcessDefinesWithInjectedNamespace(Compiler compiler) { this.compiler = compiler; } @Override public void process(Node externs, Node js) { namespace = new GlobalNamespace(compiler, js); new ProcessDefines(compiler, overrides) .injectNamespace(namespace) .process(externs, js); } } }
/* * Copyright 2010 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.Maps; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Collections; import java.util.Map; import java.util.Set; /** * @author agrieve@google.com (Andrew Grieve) */ public class ProcessTweaksTest extends CompilerTestCase { Map<String, Node> defaultValueOverrides; boolean stripTweaks; public ProcessTweaksTest() { super("function alert(arg) {}"); } @Override public void setUp() throws Exception { super.setUp(); defaultValueOverrides = Maps.newHashMap(); stripTweaks = false; } @Override protected CompilerPass getProcessor(final Compiler compiler) { return new CompilerPass() { @Override public void process(Node externs, Node root) { ProcessTweaks processTweak = new ProcessTweaks(compiler, stripTweaks, defaultValueOverrides); processTweak.process(externs, root); if (stripTweaks) { Set<String> emptySet = Collections.emptySet(); final StripCode stripCode = new StripCode(compiler, emptySet, emptySet, emptySet, emptySet); stripCode.enableTweakStripping(); stripCode.process(externs, root); } } }; } @Override protected int getNumRepetitions() { // Only do one repetition, so that we can make sure the first pass keeps // GlobalNamespace up to date. return 1; } public void testBasicTweak1() { testSame("goog.tweak.registerBoolean('Foo', 'Description');" + "goog.tweak.getBoolean('Foo')"); } public void testBasicTweak2() { testSame("goog.tweak.registerString('Foo', 'Description');" + "goog.tweak.getString('Foo')"); } public void testBasicTweak3() { testSame("goog.tweak.registerNumber('Foo', 'Description');" + "goog.tweak.getNumber('Foo')"); } public void testBasicTweak4() { testSame("goog.tweak.registerButton('Foo', 'Description', function() {})"); } public void testBasicTweak5() { testSame("goog.tweak.registerBoolean('A.b_7', 'Description', true, " + "{ requiresRestart:false })"); } public void testBasicTweak6() { testSame("var opts = { requiresRestart:false };" + "goog.tweak.registerBoolean('Foo', 'Description', true, opts)"); } public void testNonLiteralId1() { test("goog.tweak.registerBoolean(3, 'Description')", null, ProcessTweaks.NON_LITERAL_TWEAK_ID_ERROR); } public void testNonLiteralId2() { test("goog.tweak.getBoolean('a' + 'b')", null, ProcessTweaks.NON_LITERAL_TWEAK_ID_ERROR); } public void testNonLiteralId3() { test("var CONST = 'foo'; goog.tweak.overrideDefaultValue(CONST, 3)", null, ProcessTweaks.NON_LITERAL_TWEAK_ID_ERROR); } public void testInvalidId() { test("goog.tweak.registerBoolean('Some ID', 'a')", null, ProcessTweaks.INVALID_TWEAK_ID_ERROR); } public void testInvalidDefaultValue1() { testSame("var val = true; goog.tweak.registerBoolean('Foo', 'desc', val)", ProcessTweaks.INVALID_TWEAK_DEFAULT_VALUE_WARNING); } public void testInvalidDefaultValue2() { testSame("goog.tweak.overrideDefaultValue('Foo', 3 + 1);" + "goog.tweak.registerNumber('Foo', 'desc')", ProcessTweaks.INVALID_TWEAK_DEFAULT_VALUE_WARNING); } public void testUnknownGetString() { testSame("goog.tweak.getString('huh')", ProcessTweaks.UNKNOWN_TWEAK_WARNING); } public void testUnknownGetNumber() { testSame("goog.tweak.getNumber('huh')", ProcessTweaks.UNKNOWN_TWEAK_WARNING); } public void testUnknownGetBoolean() { testSame("goog.tweak.getBoolean('huh')", ProcessTweaks.UNKNOWN_TWEAK_WARNING); } public void testUnknownOverride() { testSame("goog.tweak.overrideDefaultValue('huh', 'val')", ProcessTweaks.UNKNOWN_TWEAK_WARNING); } public void testDuplicateTweak() { test("goog.tweak.registerBoolean('TweakA', 'desc');" + "goog.tweak.registerBoolean('TweakA', 'desc')", null, ProcessTweaks.TWEAK_MULTIPLY_REGISTERED_ERROR); } public void testOverrideAfterRegister() { test("goog.tweak.registerBoolean('TweakA', 'desc');" + "goog.tweak.overrideDefaultValue('TweakA', 'val')", null, ProcessTweaks.TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR); } public void testRegisterInNonGlobalScope() { test("function foo() {goog.tweak.registerBoolean('TweakA', 'desc');};", null, ProcessTweaks.NON_GLOBAL_TWEAK_INIT_ERROR); } public void testWrongGetter1() { testSame("goog.tweak.registerBoolean('TweakA', 'desc');" + "goog.tweak.getString('TweakA')", ProcessTweaks.TWEAK_WRONG_GETTER_TYPE_WARNING); } public void testWrongGetter2() { testSame("goog.tweak.registerString('TweakA', 'desc');" + "goog.tweak.getNumber('TweakA')", ProcessTweaks.TWEAK_WRONG_GETTER_TYPE_WARNING); } public void testWrongGetter3() { testSame("goog.tweak.registerNumber('TweakA', 'desc');" + "goog.tweak.getBoolean('TweakA')", ProcessTweaks.TWEAK_WRONG_GETTER_TYPE_WARNING); } public void testWithNoTweaks() { testSame("var DEF=true;var x={};x.foo={}"); } public void testStrippingWithImplicitDefaultValues() { stripTweaks = true; test("goog.tweak.registerNumber('TweakA', 'desc');" + "goog.tweak.registerBoolean('TweakB', 'desc');" + "goog.tweak.registerString('TweakC', 'desc');" + "alert(goog.tweak.getNumber('TweakA'));" + "alert(goog.tweak.getBoolean('TweakB'));" + "alert(goog.tweak.getString('TweakC'));", "void 0; void 0; void 0; alert(0); alert(false); alert('')"); } public void testStrippingWithExplicitDefaultValues() { stripTweaks = true; test("goog.tweak.registerNumber('TweakA', 'desc', 5);" + "goog.tweak.registerBoolean('TweakB', 'desc', true);" + "goog.tweak.registerString('TweakC', 'desc', '!');" + "alert(goog.tweak.getNumber('TweakA'));" + "alert(goog.tweak.getBoolean('TweakB'));" + "alert(goog.tweak.getString('TweakC'));", "void 0; void 0; void 0; alert(5); alert(true); alert('!')"); } public void testStrippingWithInCodeOverrides() { stripTweaks = true; test("goog.tweak.overrideDefaultValue('TweakA', 5);" + "goog.tweak.overrideDefaultValue('TweakB', true);" + "goog.tweak.overrideDefaultValue('TweakC', 'bar');" + "goog.tweak.registerNumber('TweakA', 'desc');" + "goog.tweak.registerBoolean('TweakB', 'desc');" + "goog.tweak.registerString('TweakC', 'desc', 'foo');" + "alert(goog.tweak.getNumber('TweakA'));" + "alert(goog.tweak.getBoolean('TweakB'));" + "alert(goog.tweak.getString('TweakC'));", "void 0; void 0; void 0; void 0; void 0; void 0;" + "alert(5); alert(true); alert('bar');"); } public void testStrippingWithUnregisteredTweak1() { stripTweaks = true; test("alert(goog.tweak.getNumber('TweakA'));", "alert(0)", null, ProcessTweaks.UNKNOWN_TWEAK_WARNING); } public void testStrippingWithUnregisteredTweak2() { stripTweaks = true; test("alert(goog.tweak.getBoolean('TweakB'))", "alert(false)", null, ProcessTweaks.UNKNOWN_TWEAK_WARNING); } public void testStrippingWithUnregisteredTweak3() { stripTweaks = true; test("alert(goog.tweak.getString('TweakC'))", "alert('')", null, ProcessTweaks.UNKNOWN_TWEAK_WARNING); } public void testStrippingOfManuallyRegistered1() { stripTweaks = true; test("var reg = goog.tweak.getRegistry();" + "if (reg) {" + " reg.register(new goog.tweak.BooleanSetting('foo', 'desc'));" + " reg.getEntry('foo').setDefaultValue(1);" + "}", "if (null);"); } public void testOverridesWithStripping() { stripTweaks = true; defaultValueOverrides.put("TweakA", Node.newNumber(1)); defaultValueOverrides.put("TweakB", new Node(Token.FALSE)); defaultValueOverrides.put("TweakC", Node.newString("!")); test("goog.tweak.overrideDefaultValue('TweakA', 5);" + "goog.tweak.overrideDefaultValue('TweakC', 'bar');" + "goog.tweak.registerNumber('TweakA', 'desc');" + "goog.tweak.registerBoolean('TweakB', 'desc', true);" + "goog.tweak.registerString('TweakC', 'desc', 'foo');" + "alert(goog.tweak.getNumber('TweakA'));" + "alert(goog.tweak.getBoolean('TweakB'));" + "alert(goog.tweak.getString('TweakC'));", "void 0; void 0; void 0; void 0; void 0; " + "alert(1); alert(false); alert('!')"); } public void testCompilerOverridesNoStripping1() { defaultValueOverrides.put("TweakA", Node.newNumber(1)); defaultValueOverrides.put("TweakB", new Node(Token.FALSE)); defaultValueOverrides.put("TweakC", Node.newString("!")); test("goog.tweak.registerNumber('TweakA', 'desc');" + "goog.tweak.registerBoolean('TweakB', 'desc', true);" + "goog.tweak.registerString('TweakC', 'desc', 'foo');" + "var a = goog.tweak.getCompilerOverrides_()", "goog.tweak.registerNumber('TweakA', 'desc');" + "goog.tweak.registerBoolean('TweakB', 'desc', true);" + "goog.tweak.registerString('TweakC', 'desc', 'foo');" + "var a = { TweakA: 1, TweakB: false, TweakC: '!' };"); } public void testCompilerOverridesNoStripping2() { defaultValueOverrides.put("TweakA", Node.newNumber(1)); defaultValueOverrides.put("TweakB", new Node(Token.FALSE)); defaultValueOverrides.put("TweakC", Node.newString("!")); test("goog.tweak.registerNumber('TweakA', 'desc');" + "goog.tweak.registerBoolean('TweakB', 'desc', true);" + "goog.tweak.registerString('TweakC', 'desc', 'foo');" + "var a = goog.tweak.getCompilerOverrides_();" + "var b = goog.tweak.getCompilerOverrides_()", "goog.tweak.registerNumber('TweakA', 'desc');" + "goog.tweak.registerBoolean('TweakB', 'desc', true);" + "goog.tweak.registerString('TweakC', 'desc', 'foo');" + "var a = { TweakA: 1, TweakB: false, TweakC: '!' };" + "var b = { TweakA: 1, TweakB: false, TweakC: '!' };"); } public void testUnknownCompilerOverride() { allowSourcelessWarnings(); defaultValueOverrides.put("TweakA", Node.newString("!")); testSame("var a", ProcessTweaks.UNKNOWN_TWEAK_WARNING); } public void testCompilerOverrideWithWrongType() { allowSourcelessWarnings(); defaultValueOverrides.put("TweakA", Node.newString("!")); testSame("goog.tweak.registerBoolean('TweakA', 'desc')", ProcessTweaks.INVALID_TWEAK_DEFAULT_VALUE_WARNING); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.javascript.jscomp.CheckLevel; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import static com.google.javascript.jscomp.PureFunctionIdentifier.INVALID_NO_SIDE_EFFECT_ANNOTATION; import com.google.javascript.rhino.Node; import java.util.List; /** * Tests for {@link PureFunctionIdentifier} * */ public class PureFunctionIdentifierTest extends CompilerTestCase { List<String> noSideEffectCalls = Lists.newArrayList(); List<String> localResultCalls = Lists.newArrayList(); boolean regExpHaveSideEffects = true; private static String kExterns = CompilerTypeTestCase.DEFAULT_EXTERNS + "var window; window.setTimeout;" + "/**@nosideeffects*/ function externSENone(){}\n" + "/**@modifies{this}*/ function externSEThis(){}\n" + "/**@constructor\n" + " * @modifies{this}*/\n" + "function externObjSEThis(){}\n" + "/**\n" + " * @param {string} s id.\n" + " * @return {string}\n" + " * @modifies{this}\n" + " */\n" + "externObjSEThis.prototype.externObjSEThisMethod = function(s) {};" + "/**\n" + " * @param {string} s id.\n" + " * @return {string}\n" + " * @modifies{arguments}\n" + " */\n" + "externObjSEThis.prototype.externObjSEThisMethod2 = function(s) {};" + "/**@nosideeffects*/function Error(){}" + "function externSef1(){}" + "/**@nosideeffects*/function externNsef1(){}" + "var externSef2 = function(){};" + "/**@nosideeffects*/var externNsef2 = function(){};" + "var externNsef3 = /**@nosideeffects*/function(){};" + "var externObj;" + "externObj.sef1 = function(){};" + "/**@nosideeffects*/externObj.nsef1 = function(){};" + "externObj.nsef2 = /**@nosideeffects*/function(){};" + "externObj.partialFn;" + "externObj.partialSharedFn;" + "var externObj2;" + "externObj2.partialSharedFn = /**@nosideeffects*/function(){};" + "/**@constructor*/function externSefConstructor(){}" + "externSefConstructor.prototype.sefFnOfSefObj = function(){};" + "externSefConstructor.prototype.nsefFnOfSefObj = " + " /**@nosideeffects*/function(){};" + "externSefConstructor.prototype.externShared = function(){};" + "/**@constructor\n@nosideeffects*/function externNsefConstructor(){}" + "externNsefConstructor.prototype.sefFnOfNsefObj = function(){};" + "externNsefConstructor.prototype.nsefFnOfNsefObj = " + " /**@nosideeffects*/function(){};" + "externNsefConstructor.prototype.externShared = " + " /**@nosideeffects*/function(){};" + "/**@constructor\n@nosideeffects*/function externNsefConstructor2(){}" + "externNsefConstructor2.prototype.externShared = " + " /**@nosideeffects*/function(){};" + "externNsefConstructor.prototype.sharedPartialSef;" + "/**@nosideeffects*/externNsefConstructor.prototype.sharedPartialNsef;" + // An externs definition with a stub before. "/**@constructor*/function externObj3(){}" + "externObj3.prototype.propWithStubBefore;" + "/**\n" + " * @param {string} s id.\n" + " * @return {string}\n" + " * @nosideeffects\n" + " */\n" + "externObj3.prototype.propWithStubBefore = function(s) {};" + // useless JsDoc "/**\n" + " * @see {foo}\n" + " */\n" + "externObj3.prototype.propWithStubBeforeWithJSDoc;" + "/**\n" + " * @param {string} s id.\n" + " * @return {string}\n" + " * @nosideeffects\n" + " */\n" + "externObj3.prototype.propWithStubBeforeWithJSDoc = function(s) {};" + // An externs definition with a stub after. "/**@constructor*/function externObj4(){}" + "/**\n" + " * @param {string} s id.\n" + " * @return {string}\n" + " * @nosideeffects\n" + " */\n" + "externObj4.prototype.propWithStubAfter = function(s) {};" + "externObj4.prototype.propWithStubAfter;" + "/**\n" + " * @param {string} s id.\n" + " * @return {string}\n" + " * @nosideeffects\n" + " */\n" + "externObj4.prototype.propWithStubAfterWithJSDoc = function(s) {};" + // useless JsDoc "/**\n" + " * @see {foo}\n" + " */\n" + "externObj4.prototype.propWithStubAfterWithJSDoc;"; public PureFunctionIdentifierTest() { super(kExterns); enableTypeCheck(CheckLevel.ERROR); } @Override protected int getNumRepetitions() { // run pass once. return 1; } @Override protected void tearDown() throws Exception { super.tearDown(); noSideEffectCalls.clear(); localResultCalls.clear(); boolean regExpHaveSideEffects = true; } public void testIssue303() throws Exception { checkMarkedCalls( "/** @constructor */ function F() {" + " var self = this;" + " window.setTimeout(function() {" + " window.location = self.location;" + " }, 0);" + "}" + "F.prototype.setLocation = function(x) {" + " this.location = x;" + "};" + "(new F()).setLocation('http://www.google.com/');", ImmutableList.<String>of()); } public void testIssue303b() throws Exception { checkMarkedCalls( "/** @constructor */ function F() {" + " var self = this;" + " window.setTimeout(function() {" + " window.location = self.location;" + " }, 0);" + "}" + "F.prototype.setLocation = function(x) {" + " this.location = x;" + "};" + "function x() {" + " (new F()).setLocation('http://www.google.com/');" + "} window['x'] = x;", ImmutableList.<String>of()); } public void testAnnotationInExterns_new1() throws Exception { checkMarkedCalls("externSENone()", ImmutableList.<String>of("externSENone")); } public void testAnnotationInExterns_new2() throws Exception { checkMarkedCalls("externSEThis()", ImmutableList.<String>of()); } public void testAnnotationInExterns_new3() throws Exception { checkMarkedCalls("new externObjSEThis()", ImmutableList.<String>of("externObjSEThis")); } public void testAnnotationInExterns_new4() throws Exception { // The entire expression containing "externObjSEThisMethod" is considered // side-effect free in this context. checkMarkedCalls("new externObjSEThis().externObjSEThisMethod('')", ImmutableList.<String>of( "externObjSEThis", "NEW STRING externObjSEThisMethod")); } public void testAnnotationInExterns_new5() throws Exception { checkMarkedCalls( "function f() { new externObjSEThis() };" + "f();", ImmutableList.<String>of("externObjSEThis", "f")); } public void testAnnotationInExterns_new6() throws Exception { // While "externObjSEThisMethod" has modifies "this" // it does not have global side-effects with "this" is // a known local value. // TODO(johnlenz): "f" is side-effect free but we need // to propagate that "externObjSEThisMethod" is modifying // a local object. checkMarkedCalls( "function f() {" + " new externObjSEThis().externObjSEThisMethod('') " + "};" + "f();", ImmutableList.<String>of( "externObjSEThis", "NEW STRING externObjSEThisMethod")); } public void testAnnotationInExterns_new7() throws Exception { // While "externObjSEThisMethod" has modifies "this" // it does not have global side-effects with "this" is // a known local value. checkMarkedCalls( "function f() {" + " var x = new externObjSEThis(); " + " x.externObjSEThisMethod('') " + "};" + "f();", ImmutableList.<String>of("externObjSEThis")); } public void testAnnotationInExterns_new8() throws Exception { // "externObjSEThisMethod" modifies "this", the 'this' // is not a known local value, so it must be assumed it is to // have global side-effects. checkMarkedCalls( "function f(x) {" + " x.externObjSEThisMethod('') " + "};" + "f(new externObjSEThis());", ImmutableList.<String>of("externObjSEThis")); } public void testAnnotationInExterns_new9() throws Exception { // "externObjSEThisMethod" modifies "this", the 'this' // is not a known local value, so it must be assumed it is to // have global side-effects. All possible values of "x" are considered // as no intraprocedural data flow is done. checkMarkedCalls( "function f(x) {" + " x = new externObjSEThis(); " + " x.externObjSEThisMethod('') " + "};" + "f(g);", ImmutableList.<String>of("externObjSEThis")); } public void testAnnotationInExterns_new10() throws Exception { // While "externObjSEThisMethod2" only modifies it arguments // and the arguments are known local values, we don't // yet connect the dots, and "f" is consider to have // global side-effects. checkMarkedCalls( "function f() {" + " new externObjSEThis().externObjSEThisMethod2('') " + "};" + "f();", ImmutableList.<String>of("externObjSEThis")); } public void testAnnotationInExterns1() throws Exception { checkMarkedCalls("externSef1()", ImmutableList.<String>of()); } public void testAnnotationInExterns2() throws Exception { checkMarkedCalls("externSef2()", ImmutableList.<String>of()); } public void testAnnotationInExterns3() throws Exception { checkMarkedCalls("externNsef1()", ImmutableList.of("externNsef1")); } public void testAnnotationInExterns4() throws Exception { checkMarkedCalls("externNsef2()", ImmutableList.of("externNsef2")); } public void testAnnotationInExterns5() throws Exception { checkMarkedCalls("externNsef3()", ImmutableList.of("externNsef3")); } public void testNamespaceAnnotationInExterns1() throws Exception { checkMarkedCalls("externObj.sef1()", ImmutableList.<String>of()); } public void testNamespaceAnnotationInExterns2() throws Exception { checkMarkedCalls("externObj.nsef1()", ImmutableList.of("externObj.nsef1")); } public void testNamespaceAnnotationInExterns3() throws Exception { checkMarkedCalls("externObj.nsef2()", ImmutableList.of("externObj.nsef2")); } public void testNamespaceAnnotationInExterns4() throws Exception { checkMarkedCalls("externObj.partialFn()", ImmutableList.<String>of()); } public void testNamespaceAnnotationInExterns5() throws Exception { // Test that adding a second definition for a partially defined // function doesn't make us think that the function has no side // effects. String templateSrc = "var o = {}; o.<fnName> = function(){}; o.<fnName>()"; // Ensure that functions with name != "partialFn" get marked. checkMarkedCalls(templateSrc.replaceAll("<fnName>", "notPartialFn"), ImmutableList.of("o.notPartialFn")); checkMarkedCalls(templateSrc.replaceAll("<fnName>", "partialFn"), ImmutableList.<String>of()); } public void testNamespaceAnnotationInExterns6() throws Exception { checkMarkedCalls("externObj.partialSharedFn()", ImmutableList.<String>of()); } public void testConstructorAnnotationInExterns1() throws Exception { checkMarkedCalls("new externSefConstructor()", ImmutableList.<String>of()); } public void testConstructorAnnotationInExterns2() throws Exception { checkMarkedCalls("var a = new externSefConstructor();" + "a.sefFnOfSefObj()", ImmutableList.<String>of()); } public void testConstructorAnnotationInExterns3() throws Exception { checkMarkedCalls("var a = new externSefConstructor();" + "a.nsefFnOfSefObj()", ImmutableList.of("a.nsefFnOfSefObj")); } public void testConstructorAnnotationInExterns4() throws Exception { checkMarkedCalls("var a = new externSefConstructor();" + "a.externShared()", ImmutableList.<String>of()); } public void testConstructorAnnotationInExterns5() throws Exception { checkMarkedCalls("new externNsefConstructor()", ImmutableList.of("externNsefConstructor")); } public void testConstructorAnnotationInExterns6() throws Exception { checkMarkedCalls("var a = new externNsefConstructor();" + "a.sefFnOfNsefObj()", ImmutableList.of("externNsefConstructor")); } public void testConstructorAnnotationInExterns7() throws Exception { checkMarkedCalls("var a = new externNsefConstructor();" + "a.nsefFnOfNsefObj()", ImmutableList.of("externNsefConstructor", "a.nsefFnOfNsefObj")); } public void testConstructorAnnotationInExterns8() throws Exception { checkMarkedCalls("var a = new externNsefConstructor();" + "a.externShared()", ImmutableList.of("externNsefConstructor")); } public void testSharedFunctionName1() throws Exception { checkMarkedCalls("var a; " + "if (true) {" + " a = new externNsefConstructor()" + "} else {" + " a = new externSefConstructor()" + "}" + "a.externShared()", ImmutableList.of("externNsefConstructor")); } public void testSharedFunctionName2() throws Exception { // Implementation for both externNsefConstructor and externNsefConstructor2 // have no side effects. boolean broken = true; if (broken) { checkMarkedCalls("var a; " + "if (true) {" + " a = new externNsefConstructor()" + "} else {" + " a = new externNsefConstructor2()" + "}" + "a.externShared()", ImmutableList.of("externNsefConstructor", "externNsefConstructor2")); } else { checkMarkedCalls("var a; " + "if (true) {" + " a = new externNsefConstructor()" + "} else {" + " a = new externNsefConstructor2()" + "}" + "a.externShared()", ImmutableList.of("externNsefConstructor", "externNsefConstructor2", "a.externShared")); } } public void testAnnotationInExternStubs1() throws Exception { checkMarkedCalls("o.propWithStubBefore('a');", ImmutableList.<String>of("o.propWithStubBefore")); } public void testAnnotationInExternStubs1b() throws Exception { checkMarkedCalls("o.propWithStubBeforeWithJSDoc('a');", ImmutableList.<String>of("o.propWithStubBeforeWithJSDoc")); } public void testAnnotationInExternStubs2() throws Exception { checkMarkedCalls("o.propWithStubAfter('a');", ImmutableList.<String>of("o.propWithStubAfter")); } public void testAnnotationInExternStubs2b() throws Exception { checkMarkedCalls("o.propWithStubAfter('a');", ImmutableList.<String>of("o.propWithStubAfter")); } public void testAnnotationInExternStubs3() throws Exception { checkMarkedCalls("propWithAnnotatedStubAfter('a');", ImmutableList.<String>of()); } public void testAnnotationInExternStubs4() throws Exception { // An externs definition with a stub that differs from the declaration. // Verify our assumption is valid about this. String externs = "/**@constructor*/function externObj5(){}\n" + "externObj5.prototype.propWithAnnotatedStubAfter = function(s) {};\n" + "/**\n" + " * @param {string} s id.\n" + " * @return {string}\n" + " * @nosideeffects\n" + " */\n" + "externObj5.prototype.propWithAnnotatedStubAfter;\n"; List<String> expected = ImmutableList.<String>of(); testSame(externs, "o.prototype.propWithAnnotatedStubAfter", TypeValidator.DUP_VAR_DECLARATION, false); assertEquals(expected, noSideEffectCalls); noSideEffectCalls.clear(); } public void testAnnotationInExternStubs5() throws Exception { // An externs definition with a stub that differs from the declaration. // Verify our assumption is valid about this. String externs = "/**@constructor*/function externObj5(){}\n" + "/**\n" + " * @param {string} s id.\n" + " * @return {string}\n" + " * @nosideeffects\n" + " */\n" + "externObj5.prototype.propWithAnnotatedStubAfter = function(s) {};\n" + "/**\n" + " * @param {string} s id.\n" + " * @return {string}\n" + " */\n" + "externObj5.prototype.propWithAnnotatedStubAfter;\n"; List<String> expected = ImmutableList.<String>of(); testSame(externs, "o.prototype.propWithAnnotatedStubAfter", TypeValidator.DUP_VAR_DECLARATION, false); assertEquals(expected, noSideEffectCalls); noSideEffectCalls.clear(); } public void testNoSideEffectsSimple() throws Exception { String prefix = "function f(){"; String suffix = "} f()"; List<String> expected = ImmutableList.of("f"); checkMarkedCalls( prefix + "" + suffix, expected); checkMarkedCalls( prefix + "return 1" + suffix, expected); checkMarkedCalls( prefix + "return 1 + 2" + suffix, expected); // local var checkMarkedCalls( prefix + "var a = 1; return a" + suffix, expected); // mutate local var checkMarkedCalls( prefix + "var a = 1; a = 2; return a" + suffix, expected); checkMarkedCalls( prefix + "var a = 1; a = 2; return a + 1" + suffix, expected); // read from obj literal checkMarkedCalls( prefix + "var a = {foo : 1}; return a.foo" + suffix, expected); checkMarkedCalls( prefix + "var a = {foo : 1}; return a.foo + 1" + suffix, expected); // read from extern checkMarkedCalls( prefix + "return externObj" + suffix, expected); checkMarkedCalls( "function g(x) { x.foo = 3; }" /* to suppress missing property */ + prefix + "return externObj.foo" + suffix, expected); } public void testResultLocalitySimple() throws Exception { String prefix = "var g; function f(){"; String suffix = "} f()"; List<String> expected = ImmutableList.of("f"); List<String> notExpected = ImmutableList.of(); // no return checkLocalityOfMarkedCalls( prefix + "" + suffix, expected); // simple return expressions checkLocalityOfMarkedCalls( prefix + "return 1" + suffix, expected); checkLocalityOfMarkedCalls( prefix + "return 1 + 2" + suffix, expected); // global result checkLocalityOfMarkedCalls( prefix + "return g" + suffix, notExpected); // multiple returns checkLocalityOfMarkedCalls( prefix + "return 1; return 2" + suffix, expected); checkLocalityOfMarkedCalls( prefix + "return 1; return g" + suffix, notExpected); // local var, not yet. checkLocalityOfMarkedCalls( prefix + "var a = 1; return a" + suffix, notExpected); // mutate local var, not yet. checkLocalityOfMarkedCalls( prefix + "var a = 1; a = 2; return a" + suffix, notExpected); checkLocalityOfMarkedCalls( prefix + "var a = 1; a = 2; return a + 1" + suffix, expected); // read from obj literal checkLocalityOfMarkedCalls( prefix + "return {foo : 1}.foo" + suffix, notExpected); checkLocalityOfMarkedCalls( prefix + "var a = {foo : 1}; return a.foo" + suffix, notExpected); // read from extern checkLocalityOfMarkedCalls( prefix + "return externObj" + suffix, notExpected); checkLocalityOfMarkedCalls( "function inner(x) { x.foo = 3; }" /* to suppress missing property */ + prefix + "return externObj.foo" + suffix, notExpected); } public void testExternCalls() throws Exception { String prefix = "function f(){"; String suffix = "} f()"; checkMarkedCalls(prefix + "externNsef1()" + suffix, ImmutableList.of("externNsef1", "f")); checkMarkedCalls(prefix + "externObj.nsef1()" + suffix, ImmutableList.of("externObj.nsef1", "f")); checkMarkedCalls(prefix + "externSef1()" + suffix, ImmutableList.<String>of()); checkMarkedCalls(prefix + "externObj.sef1()" + suffix, ImmutableList.<String>of()); } public void testApply() throws Exception { checkMarkedCalls("function f() {return 42}" + "f.apply()", ImmutableList.of("f.apply")); } public void testCall() throws Exception { checkMarkedCalls("function f() {return 42}" + "f.call()", ImmutableList.<String>of("f.call")); } public void testInference1() throws Exception { checkMarkedCalls("function f() {return g()}" + "function g() {return 42}" + "f()", ImmutableList.of("g", "f")); } public void testInference2() throws Exception { checkMarkedCalls("var a = 1;" + "function f() {g()}" + "function g() {a=2}" + "f()", ImmutableList.<String>of()); } public void testInference3() throws Exception { checkMarkedCalls("var f = function() {return g()};" + "var g = function() {return 42};" + "f()", ImmutableList.of("g", "f")); } public void testInference4() throws Exception { checkMarkedCalls("var a = 1;" + "var f = function() {g()};" + "var g = function() {a=2};" + "f()", ImmutableList.<String>of()); } public void testInference5() throws Exception { checkMarkedCalls("var goog = {};" + "goog.f = function() {return goog.g()};" + "goog.g = function() {return 42};" + "goog.f()", ImmutableList.of("goog.g", "goog.f")); } public void testInference6() throws Exception { checkMarkedCalls("var a = 1;" + "var goog = {};" + "goog.f = function() {goog.g()};" + "goog.g = function() {a=2};" + "goog.f()", ImmutableList.<String>of()); } public void testLocalizedSideEffects1() throws Exception { // Returning a function that contains a modification of a local // is not a global side-effect. checkMarkedCalls("function f() {" + " var x = {foo : 0}; return function() {x.foo++};" + "}" + "f()", ImmutableList.<String>of("f")); } public void testLocalizedSideEffects2() throws Exception { // Calling a function that contains a modification of a local // is a global side-effect (the value has escaped). checkMarkedCalls("function f() {" + " var x = {foo : 0}; (function() {x.foo++})();" + "}" + "f()", ImmutableList.<String>of()); } public void testLocalizedSideEffects3() throws Exception { // A local that might be assigned a global value and whose properties // are modified must be considered a global side-effect. checkMarkedCalls("var g = {foo:1}; function f() {var x = g; x.foo++}" + "f()", ImmutableList.<String>of()); } public void testLocalizedSideEffects4() throws Exception { // An array is an local object, assigning a local array is not a global // side-effect. checkMarkedCalls("function f() {var x = []; x[0] = 1;}" + "f()", ImmutableList.<String>of("f")); } public void testLocalizedSideEffects5() throws Exception { // Assigning a local alias of a global is a global // side-effect. checkMarkedCalls("var g = [];function f() {var x = g; x[0] = 1;}" + "f()", ImmutableList.<String>of()); } public void testLocalizedSideEffects6() throws Exception { // Returning a local object that has been modified // is not a global side-effect. checkMarkedCalls("function f() {" + " var x = {}; x.foo = 1; return x;" + "}" + "f()", ImmutableList.<String>of("f")); } public void testLocalizedSideEffects7() throws Exception { // Returning a local object that has been modified // is not a global side-effect. checkMarkedCalls("/** @constructor A */ function A() {};" + "function f() {" + " var a = []; a[1] = 1; return a;" + "}" + "f()", ImmutableList.<String>of("f")); } public void testLocalizedSideEffects8() throws Exception { // Returning a local object that has been modified // is not a global side-effect. // TODO(johnlenz): Not yet. Propagate local object information. checkMarkedCalls("/** @constructor A */ function A() {};" + "function f() {" + " var a = new A; a.foo = 1; return a;" + "}" + "f()", ImmutableList.<String>of("A")); } public void testLocalizedSideEffects9() throws Exception { // Returning a local object that has been modified // is not a global side-effect. // TODO(johnlenz): Not yet. Propagate local object information. checkMarkedCalls("/** @constructor A */ function A() {this.x = 1};" + "function f() {" + " var a = new A; a.foo = 1; return a;" + "}" + "f()", ImmutableList.<String>of("A")); } public void testLocalizedSideEffects10() throws Exception { // Returning a local object that has been modified // is not a global side-effect. checkMarkedCalls("/** @constructor A */ function A() {};" + "A.prototype.g = function() {this.x = 1};" + "function f() {" + " var a = new A; a.g(); return a;" + "}" + "f()", ImmutableList.<String>of("A")); } public void testLocalizedSideEffects11() throws Exception { // Calling a function of a local object that taints this. checkMarkedCalls( "/** @constructor */ function A() {}" + "A.prototype.update = function() { this.x = 1; };" + "/** @constructor */ function B() { " + " this.a_ = new A();" + "}" + "B.prototype.updateA = function() {" + " var b = this.a_;" + " b.update();" + "};" + "var x = new B();" + "x.updateA();", ImmutableList.of("A", "B")); } public void testUnaryOperators1() throws Exception { checkMarkedCalls("function f() {var x = 1; x++}" + "f()", ImmutableList.of("f")); } public void testUnaryOperators2() throws Exception { checkMarkedCalls("var x = 1;" + "function f() {x++}" + "f()", ImmutableList.<String>of()); } public void testUnaryOperators3() throws Exception { checkMarkedCalls("function f() {var x = {foo : 0}; x.foo++}" + "f()", ImmutableList.<String>of("f")); } public void testUnaryOperators4() throws Exception { checkMarkedCalls("var x = {foo : 0};" + "function f() {x.foo++}" + "f()", ImmutableList.<String>of()); } public void testUnaryOperators5() throws Exception { checkMarkedCalls("function f(x) {x.foo++}" + "f({foo : 0})", ImmutableList.<String>of()); } public void testDeleteOperator1() throws Exception { checkMarkedCalls("var x = {};" + "function f() {delete x}" + "f()", ImmutableList.<String>of()); } public void testDeleteOperator2() throws Exception { checkMarkedCalls("function f() {var x = {}; delete x}" + "f()", ImmutableList.of("f")); } public void testOrOperator1() throws Exception { checkMarkedCalls("var f = externNsef1 || externNsef2;\n" + "f()", ImmutableList.<String>of()); } public void testOrOperator2() throws Exception { checkMarkedCalls("var f = function(){} || externNsef2;\n" + "f()", ImmutableList.<String>of()); } public void testOrOperator3() throws Exception { checkMarkedCalls("var f = externNsef2 || function(){};\n" + "f()", ImmutableList.<String>of()); } public void testOrOperators4() throws Exception { checkMarkedCalls("var f = function(){} || function(){};\n" + "f()", ImmutableList.<String>of()); } public void testAndOperator1() throws Exception { checkMarkedCalls("var f = externNsef1 && externNsef2;\n" + "f()", ImmutableList.<String>of()); } public void testAndOperator2() throws Exception { checkMarkedCalls("var f = function(){} && externNsef2;\n" + "f()", ImmutableList.<String>of()); } public void testAndOperator3() throws Exception { checkMarkedCalls("var f = externNsef2 && function(){};\n" + "f()", ImmutableList.<String>of()); } public void testAndOperators4() throws Exception { checkMarkedCalls("var f = function(){} && function(){};\n" + "f()", ImmutableList.<String>of()); } public void testHookOperator1() throws Exception { checkMarkedCalls("var f = true ? externNsef1 : externNsef2;\n" + "f()", ImmutableList.<String>of()); } public void testHookOperator2() throws Exception { checkMarkedCalls("var f = true ? function(){} : externNsef2;\n" + "f()", ImmutableList.<String>of()); } public void testHookOperator3() throws Exception { checkMarkedCalls("var f = true ? externNsef2 : function(){};\n" + "f()", ImmutableList.<String>of()); } public void testHookOperators4() throws Exception { checkMarkedCalls("var f = true ? function(){} : function(){};\n" + "f()", ImmutableList.<String>of()); } public void testThrow1() throws Exception { checkMarkedCalls("function f(){throw Error()};\n" + "f()", ImmutableList.<String>of("Error")); } public void testThrow2() throws Exception { checkMarkedCalls("/**@constructor*/function A(){throw Error()};\n" + "function f(){return new A()}\n" + "f()", ImmutableList.<String>of("Error")); } public void testAssignmentOverride() throws Exception { checkMarkedCalls("/**@constructor*/function A(){}\n" + "A.prototype.foo = function(){};\n" + "var a = new A;\n" + "a.foo();\n", ImmutableList.<String>of("A", "a.foo")); checkMarkedCalls("/**@constructor*/function A(){}\n" + "A.prototype.foo = function(){};\n" + "var x = 1\n" + "function f(){x = 10}\n" + "var a = new A;\n" + "a.foo = f;\n" + "a.foo();\n", ImmutableList.<String>of("A")); } public void testInheritance1() throws Exception { String source = CompilerTypeTestCase.CLOSURE_DEFS + "/**@constructor*/function I(){}\n" + "I.prototype.foo = function(){};\n" + "I.prototype.bar = function(){this.foo()};\n" + "/**@constructor\n@extends {I}*/function A(){};\n" + "goog.inherits(A, I)\n;" + "/** @override */A.prototype.foo = function(){var data=24};\n" + "var i = new I();i.foo();i.bar();\n" + "var a = new A();a.foo();a.bar();"; checkMarkedCalls(source, ImmutableList.of("this.foo", "goog.inherits", "I", "i.foo", "i.bar", "A", "a.foo", "a.bar")); } public void testInheritance2() throws Exception { String source = CompilerTypeTestCase.CLOSURE_DEFS + "/**@constructor*/function I(){}\n" + "I.prototype.foo = function(){};\n" + "I.prototype.bar = function(){this.foo()};\n" + "/**@constructor\n@extends {I}*/function A(){};\n" + "goog.inherits(A, I)\n;" + "/** @override */A.prototype.foo = function(){this.data=24};\n" + "var i = new I();i.foo();i.bar();\n" + "var a = new A();a.foo();a.bar();"; checkMarkedCalls(source, ImmutableList.of("goog.inherits", "I", "A")); } public void testCallBeforeDefinition() throws Exception { checkMarkedCalls("f(); function f(){}", ImmutableList.of("f")); checkMarkedCalls("var a = {}; a.f(); a.f = function (){}", ImmutableList.of("a.f")); } public void testConstructorThatModifiesThis1() throws Exception { String source = "/**@constructor*/function A(){this.foo = 1}\n" + "function f() {return new A}" + "f()"; checkMarkedCalls(source, ImmutableList.of("A", "f")); } public void testConstructorThatModifiesThis2() throws Exception { String source = "/**@constructor*/function A(){this.foo()}\n" + "A.prototype.foo = function(){this.data=24};\n" + "function f() {return new A}" + "f()"; checkMarkedCalls(source, ImmutableList.of("A", "f")); } public void testConstructorThatModifiesThis3() throws Exception { // test chained String source = "/**@constructor*/function A(){this.foo()}\n" + "A.prototype.foo = function(){this.bar()};\n" + "A.prototype.bar = function(){this.data=24};\n" + "function f() {return new A}" + "f()"; checkMarkedCalls(source, ImmutableList.of("A", "f")); } public void testConstructorThatModifiesThis4() throws Exception { // test ".call" notation. String source = "/**@constructor*/function A(){foo.call(this)}\n" + "function foo(){this.data=24};\n" + "function f() {return new A}" + "f()"; checkMarkedCalls(source, ImmutableList.of("A", "f")); } public void testConstructorThatModifiesGlobal1() throws Exception { String source = "var b = 0;" + "/**@constructor*/function A(){b=1};\n" + "function f() {return new A}" + "f()"; checkMarkedCalls(source, ImmutableList.<String>of()); } public void testConstructorThatModifiesGlobal2() throws Exception { String source = "var b = 0;" + "/**@constructor*/function A(){this.foo()}\n" + "A.prototype.foo = function(){b=1};\n" + "function f() {return new A}" + "f()"; checkMarkedCalls(source, ImmutableList.<String>of()); } public void testCallFunctionThatModifiesThis() throws Exception { String source = "/**@constructor*/function A(){}\n" + "A.prototype.foo = function(){this.data=24};\n" + "function f(){var a = new A; return a}\n" + "function g(){var a = new A; a.foo(); return a}\n" + "f(); g()"; checkMarkedCalls(source, ImmutableList.<String>of("A", "A", "f")); } public void testCallFunctionFOrG() throws Exception { String source = "function f(){}\n" + "function g(){}\n" + "function h(){ (f || g)() }\n" + "h()"; checkMarkedCalls(source, ImmutableList.<String>of("(f || g)", "h")); } public void testCallFunctionFOrGViaHook() throws Exception { String source = "function f(){}\n" + "function g(){}\n" + "function h(){ (false ? f : g)() }\n" + "h()"; checkMarkedCalls(source, ImmutableList.<String>of("(f : g)", "h")); } public void testCallFunctionForGorH() throws Exception { String source = "function f(){}\n" + "function g(){}\n" + "function h(){}\n" + "function i(){ (false ? f : (g || h))() }\n" + "i()"; checkMarkedCalls(source, ImmutableList.<String>of("(f : (g || h))", "i")); } public void testCallFunctionFOrGWithSideEffects() throws Exception { String source = "var x = 0;\n" + "function f(){x = 10}\n" + "function g(){}\n" + "function h(){ (f || g)() }\n" + "function i(){ (g || f)() }\n" + "function j(){ (f || f)() }\n" + "function k(){ (g || g)() }\n" + "h(); i(); j(); k()"; checkMarkedCalls(source, ImmutableList.<String>of("(g || g)", "k")); } public void testCallFunctionFOrGViaHookWithSideEffects() throws Exception { String source = "var x = 0;\n" + "function f(){x = 10}\n" + "function g(){}\n" + "function h(){ (false ? f : g)() }\n" + "function i(){ (false ? g : f)() }\n" + "function j(){ (false ? f : f)() }\n" + "function k(){ (false ? g : g)() }\n" + "h(); i(); j(); k()"; checkMarkedCalls(source, ImmutableList.<String>of("(g : g)", "k")); } public void testCallRegExpWithSideEffects() throws Exception { String source = "var x = 0;\n" + "function k(){(/a/).exec('')}\n" + "k()"; regExpHaveSideEffects = true; checkMarkedCalls(source, ImmutableList.<String>of()); regExpHaveSideEffects = false; checkMarkedCalls(source, ImmutableList.<String>of( "REGEXP STRING exec", "k")); } public void testAnonymousFunction1() throws Exception { String source = "(function (){})();"; checkMarkedCalls(source, ImmutableList.<String>of( "FUNCTION")); } public void testAnonymousFunction2() throws Exception { String source = "(Error || function (){})();"; checkMarkedCalls(source, ImmutableList.<String>of( "(Error || FUNCTION)")); } public void testAnonymousFunction3() throws Exception { String source = "var a = (Error || function (){})();"; checkMarkedCalls(source, ImmutableList.<String>of( "(Error || FUNCTION)")); } // Indirect complex function definitions aren't yet supported. public void testAnonymousFunction4() throws Exception { String source = "var a = (Error || function (){});" + "a();"; // This should be "(Error || FUNCTION)" but isn't. checkMarkedCalls(source, ImmutableList.<String>of()); } public void testInvalidAnnotation1() throws Exception { test("/** @nosideeffects */ function foo() {}", null, INVALID_NO_SIDE_EFFECT_ANNOTATION); } public void testInvalidAnnotation2() throws Exception { test("var f = /** @nosideeffects */ function() {}", null, INVALID_NO_SIDE_EFFECT_ANNOTATION); } public void testInvalidAnnotation3() throws Exception { test("/** @nosideeffects */ var f = function() {}", null, INVALID_NO_SIDE_EFFECT_ANNOTATION); } public void testInvalidAnnotation4() throws Exception { test("var f = function() {};" + "/** @nosideeffects */ f.x = function() {}", null, INVALID_NO_SIDE_EFFECT_ANNOTATION); } public void testInvalidAnnotation5() throws Exception { test("var f = function() {};" + "f.x = /** @nosideeffects */ function() {}", null, INVALID_NO_SIDE_EFFECT_ANNOTATION); } void checkMarkedCalls(String source, List<String> expected) { testSame(source); assertEquals(expected, noSideEffectCalls); noSideEffectCalls.clear(); } void checkLocalityOfMarkedCalls(String source, List<String> expected) { testSame(source); assertEquals(expected, localResultCalls); localResultCalls.clear(); } @Override protected CompilerPass getProcessor(Compiler compiler) { return new NoSideEffectCallEnumerator(compiler); } /** * Run PureFunctionIdentifier, then gather a list of calls that are * marked as having no side effects. */ private class NoSideEffectCallEnumerator extends AbstractPostOrderCallback implements CompilerPass { private final Compiler compiler; NoSideEffectCallEnumerator(Compiler compiler) { this.compiler = compiler; } @Override public void process(Node externs, Node root) { compiler.setHasRegExpGlobalReferences(regExpHaveSideEffects); SimpleDefinitionFinder defFinder = new SimpleDefinitionFinder(compiler); defFinder.process(externs, root); PureFunctionIdentifier passUnderTest = new PureFunctionIdentifier(compiler, defFinder); passUnderTest.process(externs, root); // Ensure that debug report computation works. String debugReport = passUnderTest.getDebugReport(); NodeTraversal.traverse(compiler, externs, this); NodeTraversal.traverse(compiler, root, this); } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isNew()) { if (!NodeUtil.constructorCallHasSideEffects(n)) { noSideEffectCalls.add(generateNameString(n.getFirstChild())); } } else if (n.isCall()) { if (!NodeUtil.functionCallHasSideEffects(n)) { noSideEffectCalls.add(generateNameString(n.getFirstChild())); } if (NodeUtil.callHasLocalResult(n)) { localResultCalls.add(generateNameString(n.getFirstChild())); } } } private String generateNameString(Node node) { if (node.isOr()) { return "(" + generateNameString(node.getFirstChild()) + " || " + generateNameString(node.getLastChild()) + ")"; } else if (node.isHook()) { return "(" + generateNameString(node.getFirstChild().getNext()) + " : " + generateNameString(node.getLastChild()) + ")"; } else { String result = node.getQualifiedName(); if (result == null) { if (node.isFunction()) { result = node.toString(false, false, false).trim(); } else { result = node.getFirstChild().toString(false, false, false); result += " " + node.getLastChild().toString(false, false, false); } } return result; } } } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import junit.framework.TestCase; /** * Tests for {@link RecordFunctionInformation} * */ public class RecordFunctionInformationTest extends TestCase { public void testFunction() { String g = "function g(){}"; String fAndG = "function f(){" + g + "}"; String js = "var h=" + fAndG + ";h()"; FunctionInformationMap.Builder expected = FunctionInformationMap.newBuilder(); expected.addEntry( FunctionInformationMap.Entry.newBuilder() .setId(0) .setSourceName("testcode") .setLineNumber(1) .setModuleName("") .setSize(g.length()) .setName("f::g") .setCompiledSource(g).build()); expected.addEntry( FunctionInformationMap.Entry.newBuilder() .setId(1) .setSourceName("testcode") .setLineNumber(1) .setModuleName("") .setSize(fAndG.length()) .setName("f") .setCompiledSource(fAndG).build()); expected.addModule( FunctionInformationMap.Module.newBuilder() .setName("") .setCompiledSource(js + ";").build()); test(js, expected.build()); } public void testModule() { String g = "function g(){}"; String fAndG = "function f(){" + g + "}"; String m0_js = "var h=" + fAndG + ";h()"; String sum = "function(a,b){return a+b}"; String m1_js = "var x=" + sum + "(1,2)"; FunctionInformationMap.Builder expected = FunctionInformationMap.newBuilder(); expected.addEntry( FunctionInformationMap.Entry.newBuilder() .setId(0) .setSourceName("i0") .setLineNumber(1) .setModuleName("m0") .setSize(g.length()) .setName("f::g") .setCompiledSource(g).build()); expected.addEntry( FunctionInformationMap.Entry.newBuilder() .setId(1) .setSourceName("i0") .setLineNumber(1) .setModuleName("m0") .setSize(fAndG.length()) .setName("f") .setCompiledSource(fAndG).build()); expected.addEntry( FunctionInformationMap.Entry.newBuilder() .setId(2) .setSourceName("i1") .setLineNumber(1) .setModuleName("m1") .setSize(sum.length()) .setName("<anonymous>") .setCompiledSource(sum).build()); expected.addModule( FunctionInformationMap.Module.newBuilder() .setName("m0") .setCompiledSource(m0_js + ";").build()); expected.addModule( FunctionInformationMap.Module.newBuilder() .setName("m1") .setCompiledSource(m1_js + ";").build()); test(CompilerTestCase.createModules(m0_js, m1_js), expected.build()); } public void testMotionPreservesOriginalSourceName() { String f = "function f(){}"; String g = "function g(){}"; String m0_before = f + g; String m1_before = ""; JSModule[] modules = CompilerTestCase.createModules(m0_before, m1_before); Compiler compiler = compilerFor(modules); Node root = root(compiler); Node externsRoot = externs(root); Node mainRoot = main(root); String m0_after = f; String m1_after = g; Node nodeG = mainRoot.getFirstChild().getLastChild(); mainRoot.getFirstChild().removeChild(nodeG); mainRoot.getLastChild().addChildrenToBack(nodeG.cloneTree()); FunctionInformationMap.Builder expected = FunctionInformationMap.newBuilder(); expected.addEntry( FunctionInformationMap.Entry.newBuilder() .setId(0) .setSourceName("i0") .setLineNumber(1) .setModuleName("m0") .setSize(g.length()) .setName("f") .setCompiledSource(f).build()); expected.addEntry( FunctionInformationMap.Entry.newBuilder() .setId(1) .setSourceName("i0") .setLineNumber(1) .setModuleName("m1") .setSize(g.length()) .setName("g") .setCompiledSource(g).build()); expected.addModule( FunctionInformationMap.Module.newBuilder() .setName("m0") .setCompiledSource(m0_after + ";").build()); expected.addModule( FunctionInformationMap.Module.newBuilder() .setName("m1") .setCompiledSource(m1_after + ";").build()); test(compiler, externsRoot, mainRoot, expected.build()); } private void test(String js, FunctionInformationMap expected) { Compiler compiler = new Compiler(); compiler.init(ImmutableList.of(SourceFile.fromCode("externs", "")), ImmutableList.of(SourceFile.fromCode("testcode", js)), new CompilerOptions()); test(compiler, expected); } private void test(JSModule[] modules, FunctionInformationMap expected) { test(compilerFor(modules), expected); } private void test(Compiler compiler, FunctionInformationMap expected) { Node root = root(compiler); test(compiler, externs(root), main(root), expected); } private void test(Compiler compiler, Node externsRoot, Node mainRoot, FunctionInformationMap expected) { FunctionNames functionNames = new FunctionNames(compiler); functionNames.process(externsRoot, mainRoot); RecordFunctionInformation processor = new RecordFunctionInformation(compiler, functionNames); processor.process(externsRoot, mainRoot); FunctionInformationMap result = processor.getMap(); assertEquals(expected, result); } private Compiler compilerFor(JSModule[] modules) { Compiler compiler = new Compiler(); compiler.initModules( ImmutableList.of(SourceFile.fromCode("externs", "")), Lists.newArrayList(modules), new CompilerOptions()); return compiler; } private Node root(Compiler compiler) { return compiler.parseInputs(); } private Node externs(Node root) { return root.getFirstChild(); } private Node main(Node root) { return root.getFirstChild().getNext(); } }
/* * Copyright 2006 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; public class RemoveTryCatchTest extends CompilerTestCase { public RemoveTryCatchTest() { // do not compare as tree because we use synthetic blocks super("", false); } @Override public CompilerPass getProcessor(Compiler compiler) { return new RemoveTryCatch(compiler); } @Override public int getNumRepetitions() { // Use only one repetition because test code contains JSDoc comments. return 1; } public void testRemoveTryCatch() { test("try{var a=1;}catch(ex){var b=2;}", "var b;var a=1"); test("try{var a=1;var b=2}catch(ex){var c=3;var d=4;}", "var d;var c;var a=1;var b=2"); test("try{var a=1;var b=2}catch(ex){}", "var a=1;var b=2"); } public void testRemoveTryFinally() { test("try{var a=1;}finally{var c=3;}", "var a=1;var c=3"); test("try{var a=1;var b=2}finally{var e=5;var f=6;}", "var a=1;var b=2;var e=5;var f=6"); } public void testRemoveTryCatchFinally() { test("try{var a=1;}catch(ex){var b=2;}finally{var c=3;}", "var b;var a=1;var c=3"); test("try{var a=1;var b=2}catch(ex){var c=3;var d=4;}finally{var e=5;" + "var f=6;}", "var d;var c;var a=1;var b=2;var e=5;var f=6"); } public void testPreserveTryBlockContainingReturnStatement() { testSame("function f(){var a;try{a=1;return}finally{a=2}}"); } public void testPreserveAnnotatedTryBlock() { test("/** @preserveTry */try{var a=1;}catch(ex){var b=2;}", "try{var a=1}catch(ex){var b=2}"); } public void testIfTryFinally() { test("if(x)try{y}finally{z}", "if(x){y;z}"); } public void testIfTryCatch() { test("if(x)try{y;z}catch(e){}", "if(x){y;z}"); } }
/* * Copyright 2011 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * @author johnlenz@google.com (John Lenz) */ public class RemoveUnusedClassPropertiesTest extends CompilerTestCase { private static final String EXTERNS = "var window;\n" + "function alert(a) {}\n" + "var EXT = {};" + "EXT.ext;"; public RemoveUnusedClassPropertiesTest() { super(EXTERNS); } @Override protected CompilerPass getProcessor(Compiler compiler) { return new RemoveUnusedClassProperties(compiler); } public void testSimple1() { // A property defined on "this" can be removed test("this.a = 2", "2"); test("x = (this.a = 2)", "x = 2"); testSame("this.a = 2; x = this.a;"); } public void testSimple2() { // A property defined on "this" can be removed, even when defined // as part of an expression test("this.a = 2, f()", "2, f()"); test("x = (this.a = 2, f())", "x = (2, f())"); test("x = (f(), this.a = 2)", "x = (f(), 2)"); } public void testSimple3() { // A property defined on an object other than "this" can not be removed. testSame("y.a = 2"); // but doesn't prevent the removal of the definition on 'this'. test("y.a = 2; this.a = 2", "y.a = 2; 2"); // Some use of the property "a" prevents the removal. testSame("y.a = 2; this.a = 1; alert(x.a)"); } public void testObjLit() { // A property defined on an object other than "this" can not be removed. testSame("({a:2})"); // but doesn't prevent the removal of the definition on 'this'. test("({a:0}); this.a = 1;", "({a:0});1"); // Some use of the property "a" prevents the removal. testSame("x = ({a:0}); this.a = 1; alert(x.a)"); } public void testExtern() { // A property defined in the externs is can not be removed. testSame("this.ext = 2"); } public void testExport() { // An exported property can not be removed. testSame("this.ext = 2; window['export'] = this.ext;"); testSame("function f() { this.ext = 2; } window['export'] = this.ext;"); } public void testAssignOp1() { // Properties defined using a compound assignment can be removed if the // result of the assignment expression is not immediately used. test("this.x += 2", "2"); testSame("x = (this.x += 2)"); testSame("this.x += 2; x = this.x;"); // But, of course, a later use prevents its removal. testSame("this.x += 2; x.x;"); } public void testAssignOp2() { // Properties defined using a compound assignment can be removed if the // result of the assignment expression is not immediately used. test("this.a += 2, f()", "2, f()"); test("x = (this.a += 2, f())", "x = (2, f())"); testSame("x = (f(), this.a += 2)"); } public void testInc1() { // Increments and Decrements are handled similarly to compound assignments // but need a placeholder value when replaced. test("this.x++", "0"); testSame("x = (this.x++)"); testSame("this.x++; x = this.x;"); test("--this.x", "0"); testSame("x = (--this.x)"); testSame("--this.x; x = this.x;"); } public void testInc2() { // Increments and Decrements are handled similarly to compound assignments // but need a placeholder value when replaced. test("this.a++, f()", "0, f()"); test("x = (this.a++, f())", "x = (0, f())"); testSame("x = (f(), this.a++)"); test("--this.a, f()", "0, f()"); test("x = (--this.a, f())", "x = (0, f())"); testSame("x = (f(), --this.a)"); } public void testJSCompiler_renameProperty() { // JSCompiler_renameProperty introduces a use of the property testSame("this.a = 2; x[JSCompiler_renameProperty('a')]"); testSame("this.a = 2; JSCompiler_renameProperty('a')"); } public void testForIn() { // This is the basic assumption that this pass makes: // it can remove properties even when the object is used in a FOR-IN loop test("this.y = 1;for (var a in x) { alert(x[a]) }", "1;for (var a in x) { alert(x[a]) }"); } public void testObjectKeys() { // This is the basic assumption that this pass makes: // it can remove properties even when the object are referenced test("this.y = 1;alert(Object.keys(this))", "1;alert(Object.keys(this))"); } public void testIssue730() { // Partial removal of properties can causes problems if the object is // sealed. // TODO(johnlenz): should we not allow partial removals? test( "function A() {this.foo = 0;}\n" + "function B() {this.a = new A();}\n" + "B.prototype.dostuff = function() {this.a.foo++;alert('hi');}\n" + "new B().dostuff();\n", "function A(){0}" + "function B(){this.a=new A}" + "B.prototype.dostuff=function(){this.a.foo++;alert(\"hi\")};" + "new B().dostuff();"); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.jscomp.CheckLevel; import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter; import com.google.javascript.rhino.Node; /** * Tests for {@link RemoveUnusedPrototypeProperties}. * * @author nicksantos@google.com (Nick Santos) */ public class RemoveUnusedNamesTest extends CompilerTestCase { private static final String EXTERNS = "/** @constructor */\n " + "function IFoo() { } \n" + "IFoo.prototype.bar; \n" + "/** @constructor */\n " + "var mExtern; \n" + "mExtern.bExtern; \n" + "mExtern['cExtern']; \n"; public RemoveUnusedNamesTest() { super(EXTERNS); } private boolean canRemoveExterns = false; @Override protected int getNumRepetitions() { return 1; } @Override protected CompilerPass getProcessor(final Compiler compiler) { return new CompilerPass() { @Override public void process(Node externs, Node root) { new TypeCheck(compiler, new SemanticReverseAbstractInterpreter( compiler.getCodingConvention(), compiler.getTypeRegistry()), compiler.getTypeRegistry(), CheckLevel.ERROR, CheckLevel.ERROR).processForTesting(externs, root); new RemoveUnusedNames( compiler, canRemoveExterns).process(externs, root); // Use to remove side-effect-free artifacts that are left over. new UnreachableCodeElimination(compiler, true).process(externs, root); } }; } @Override public void setUp() { canRemoveExterns = false; } public void testAnalyzeUnusedPrototypeProperties() { // Basic removal for prototype properties test("/** @constructor */ \n" + "function e(){} \n" + "e.prototype.a = function(){};" + "e.prototype.b = function(){};" + "var x = new e; x.a()", "function e(){}" + " e.prototype.a = function(){};" + "var x = new e; x.a()"); } public void testAnalyzeUnusedPrototypeProperties2() { // TODO(user): Prototype literal not yet supported. // Basic removal for prototype replacement //test("/** @constructor */ \n" + // "function e(){} \n" + // "e.prototype = {a: function(){}, b: function(){}};" + // "var x=new e; x.a()", // // "function e(){}" + // "e.prototype = {a: function(){}};" + // "var x = new e; x.a()"); } public void testAnalyzeUnusedPrototypeProperties3() { // Even if bExtern is out there somewhere. The type system tells us they // are unrelated. test("/** @constructor */ \n" + "function e(){} \n" + "e.prototype.a = function(){};" + "e.prototype.bExtern = function(){};" + "var x = new e;x.a()", "function e(){}" + "e.prototype.a = function(){};" + //"e.prototype.bExtern = function(){};" + "var x = new e; x.a()"); // TODO(user): Prototype literal not yet supported. //test("/** @constructor */ \n" + // "function e(){} \n" + // "e.prototype = {a: function(){}, bExtern: function(){}};" + // "var x = new e; x.a()", // "function e(){}" + // "e.prototype = {a: function(){}, bExtern: function(){}};" + // "var x = new e; x.a()"); } public void testAliasing() { // TODO(user): Not fully supported. } public void testStatement() { test("/**\n" + " * @fileoverview\n" + " * @notypecheck\n" + " */ \n" + "/** @constructor */" + "function e(){}" + "var x = e.prototype.method1 = function(){};" + "var y = new e; x()", "function e(){}" + "var x = function(){};" + "var y = new e; x()"); } public void testExportedMethodsByNamingConvention() { // TODO(user): Not fully supported. } public void testExportedMethodsByNamingConventionAlwaysExported() { // TODO(user): Not fully supported. } }
/* * Copyright 2006 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Tests for {@link RemoveUnusedPrototypeProperties}. * * @author nicksantos@google.com (Nick Santos) */ public class RemoveUnusedPrototypePropertiesTest extends CompilerTestCase { private static final String EXTERNS = "IFoo.prototype.bar; var mExtern; mExtern.bExtern; mExtern['cExtern'];"; private boolean canRemoveExterns = false; private boolean anchorUnusedVars = false; public RemoveUnusedPrototypePropertiesTest() { super(EXTERNS); } @Override protected CompilerPass getProcessor(Compiler compiler) { return new RemoveUnusedPrototypeProperties(compiler, canRemoveExterns, anchorUnusedVars); } @Override public void setUp() { anchorUnusedVars = false; canRemoveExterns = false; } public void testAnalyzePrototypeProperties() { // Basic removal for prototype properties test("function e(){}" + "e.prototype.a = function(){};" + "e.prototype.b = function(){};" + "var x = new e; x.a()", "function e(){}" + "e.prototype.a = function(){};" + "var x = new e; x.a()"); // Basic removal for prototype replacement test("function e(){}" + "e.prototype = {a: function(){}, b: function(){}};" + "var x=new e; x.a()", "function e(){}" + "e.prototype = {a: function(){}};" + "var x = new e; x.a()"); // Unused properties that were referenced in the externs file should not be // removed test("function e(){}" + "e.prototype.a = function(){};" + "e.prototype.bExtern = function(){};" + "var x = new e;x.a()", "function e(){}" + "e.prototype.a = function(){};" + "e.prototype.bExtern = function(){};" + "var x = new e; x.a()"); test("function e(){}" + "e.prototype = {a: function(){}, bExtern: function(){}};" + "var x = new e; x.a()", "function e(){}" + "e.prototype = {a: function(){}, bExtern: function(){}};" + "var x = new e; x.a()"); } public void testAliasing1() { // Aliasing a property is not enough for it to count as used test("function e(){}" + "e.prototype.method1 = function(){};" + "e.prototype.method2 = function(){};" + // aliases "e.prototype.alias1 = e.prototype.method1;" + "e.prototype.alias2 = e.prototype.method2;" + "var x = new e; x.method1()", "function e(){}" + "e.prototype.method1 = function(){};" + "var x = new e; x.method1()"); // Using an alias should keep it test("function e(){}" + "e.prototype.method1 = function(){};" + "e.prototype.method2 = function(){};" + // aliases "e.prototype.alias1 = e.prototype.method1;" + "e.prototype.alias2 = e.prototype.method2;" + "var x=new e; x.alias1()", "function e(){}" + "e.prototype.method1 = function(){};" + "e.prototype.alias1 = e.prototype.method1;" + "var x = new e; x.alias1()"); } public void testAliasing2() { // Aliasing a property is not enough for it to count as used test("function e(){}" + "e.prototype.method1 = function(){};" + // aliases "e.prototype.alias1 = e.prototype.method1;" + "(new e).method1()", "function e(){}" + "e.prototype.method1 = function(){};" + "(new e).method1()"); // Using an alias should keep it test("function e(){}" + "e.prototype.method1 = function(){};" + // aliases "e.prototype.alias1 = e.prototype.method1;" + "(new e).alias1()", "function e(){}" + "e.prototype.method1 = function(){};" + "e.prototype.alias1 = e.prototype.method1;" + "(new e).alias1()"); } public void testAliasing3() { // Aliasing a property is not enough for it to count as used test("function e(){}" + "e.prototype.method1 = function(){};" + "e.prototype.method2 = function(){};" + // aliases "e.prototype['alias1'] = e.prototype.method1;" + "e.prototype['alias2'] = e.prototype.method2;", "function e(){}" + "e.prototype.method1=function(){};" + "e.prototype.method2=function(){};" + "e.prototype[\"alias1\"]=e.prototype.method1;" + "e.prototype[\"alias2\"]=e.prototype.method2;"); } public void testAliasing4() { // Aliasing a property is not enough for it to count as used test("function e(){}" + "e.prototype['alias1'] = e.prototype.method1 = function(){};" + "e.prototype['alias2'] = e.prototype.method2 = function(){};", "function e(){}" + "e.prototype[\"alias1\"]=e.prototype.method1=function(){};" + "e.prototype[\"alias2\"]=e.prototype.method2=function(){};"); } public void testAliasing5() { // An exported alias must preserved any referenced values in the // referenced function. test("function e(){}" + "e.prototype.method1 = function(){this.method2()};" + "e.prototype.method2 = function(){};" + // aliases "e.prototype['alias1'] = e.prototype.method1;", "function e(){}" + "e.prototype.method1=function(){this.method2()};" + "e.prototype.method2=function(){};" + "e.prototype[\"alias1\"]=e.prototype.method1;"); } public void testAliasing6() { // An exported alias must preserved any referenced values in the // referenced function. test("function e(){}" + "e.prototype.method1 = function(){this.method2()};" + "e.prototype.method2 = function(){};" + // aliases "window['alias1'] = e.prototype.method1;", "function e(){}" + "e.prototype.method1=function(){this.method2()};" + "e.prototype.method2=function(){};" + "window['alias1']=e.prototype.method1;"); } public void testAliasing7() { // An exported alias must preserved any referenced values in the // referenced function. testSame("function e(){}" + "e.prototype['alias1'] = e.prototype.method1 = " + "function(){this.method2()};" + "e.prototype.method2 = function(){};"); } public void testStatementRestriction() { test("function e(){}" + "var x = e.prototype.method1 = function(){};" + "var y = new e; x()", "function e(){}" + "var x = e.prototype.method1 = function(){};" + "var y = new e; x()"); } public void testExportedMethodsByNamingConvention() { String classAndItsMethodAliasedAsExtern = "function Foo() {}" + "Foo.prototype.method = function() {};" + // not removed "Foo.prototype.unused = function() {};" + // removed "var _externInstance = new Foo();" + "Foo.prototype._externMethod = Foo.prototype.method"; // aliased here String compiled = "function Foo(){}" + "Foo.prototype.method = function(){};" + "var _externInstance = new Foo;" + "Foo.prototype._externMethod = Foo.prototype.method"; test(classAndItsMethodAliasedAsExtern, compiled); } public void testMethodsFromExternsFileNotExported() { canRemoveExterns = true; String classAndItsMethodAliasedAsExtern = "function Foo() {}" + "Foo.prototype.bar_ = function() {};" + "Foo.prototype.unused = function() {};" + "var instance = new Foo;" + "Foo.prototype.bar = Foo.prototype.bar_"; String compiled = "function Foo(){}" + "var instance = new Foo;"; test(classAndItsMethodAliasedAsExtern, compiled); } public void testExportedMethodsByNamingConventionAlwaysExported() { canRemoveExterns = true; String classAndItsMethodAliasedAsExtern = "function Foo() {}" + "Foo.prototype.method = function() {};" + // not removed "Foo.prototype.unused = function() {};" + // removed "var _externInstance = new Foo();" + "Foo.prototype._externMethod = Foo.prototype.method"; // aliased here String compiled = "function Foo(){}" + "Foo.prototype.method = function(){};" + "var _externInstance = new Foo;" + "Foo.prototype._externMethod = Foo.prototype.method"; test(classAndItsMethodAliasedAsExtern, compiled); } public void testExternMethodsFromExternsFile() { String classAndItsMethodAliasedAsExtern = "function Foo() {}" + "Foo.prototype.bar_ = function() {};" + // not removed "Foo.prototype.unused = function() {};" + // removed "var instance = new Foo;" + "Foo.prototype.bar = Foo.prototype.bar_"; // aliased here String compiled = "function Foo(){}" + "Foo.prototype.bar_ = function(){};" + "var instance = new Foo;" + "Foo.prototype.bar = Foo.prototype.bar_"; test(classAndItsMethodAliasedAsExtern, compiled); } public void testPropertyReferenceGraph() { // test a prototype property graph that looks like so: // b -> a, c -> b, c -> a, d -> c, e -> a, e -> f String constructor = "function Foo() {}"; String defA = "Foo.prototype.a = function() { Foo.superClass_.a.call(this); };"; String defB = "Foo.prototype.b = function() { this.a(); };"; String defC = "Foo.prototype.c = function() { " + "Foo.superClass_.c.call(this); this.b(); this.a(); };"; String defD = "Foo.prototype.d = function() { this.c(); };"; String defE = "Foo.prototype.e = function() { this.a(); this.f(); };"; String defF = "Foo.prototype.f = function() { };"; String fullClassDef = constructor + defA + defB + defC + defD + defE + defF; // ensure that all prototypes are compiled out if none are used test(fullClassDef, ""); // make sure that the right prototypes are called for each use String callA = "(new Foo()).a();"; String callB = "(new Foo()).b();"; String callC = "(new Foo()).c();"; String callD = "(new Foo()).d();"; String callE = "(new Foo()).e();"; String callF = "(new Foo()).f();"; test(fullClassDef + callA, constructor + defA + callA); test(fullClassDef + callB, constructor + defA + defB + callB); test(fullClassDef + callC, constructor + defA + defB + defC + callC); test(fullClassDef + callD, constructor + defA + defB + defC + defD + callD); test(fullClassDef + callE, constructor + defA + defE + defF + callE); test(fullClassDef + callF, constructor + defF + callF); test(fullClassDef + callA + callC, constructor + defA + defB + defC + callA + callC); test(fullClassDef + callB + callC, constructor + defA + defB + defC + callB + callC); test(fullClassDef + callA + callB + callC, constructor + defA + defB + defC + callA + callB + callC); } public void testPropertiesDefinedWithGetElem() { testSame("function Foo() {} Foo.prototype['elem'] = function() {};"); testSame("function Foo() {} Foo.prototype[1 + 1] = function() {};"); } public void testNeverRemoveImplicitlyUsedProperties() { testSame("function Foo() {} " + "Foo.prototype.length = 3; " + "Foo.prototype.toString = function() { return 'Foo'; }; " + "Foo.prototype.valueOf = function() { return 'Foo'; }; "); } public void testPropertyDefinedInBranch() { test("function Foo() {} if (true) Foo.prototype.baz = function() {};", "if (true);"); test("function Foo() {} while (true) Foo.prototype.baz = function() {};", "while (true);"); test("function Foo() {} for (;;) Foo.prototype.baz = function() {};", "for (;;);"); test("function Foo() {} do Foo.prototype.baz = function() {}; while(true);", "do; while(true);"); } public void testUsingAnonymousObjectsToDefeatRemoval() { String constructor = "function Foo() {}"; String declaration = constructor + "Foo.prototype.baz = 3;"; test(declaration, ""); testSame(declaration + "var x = {}; x.baz = 5;"); testSame(declaration + "var x = {baz: 5};"); test(declaration + "var x = {'baz': 5};", "var x = {'baz': 5};"); } public void testGlobalFunctionsInGraph() { test( "var x = function() { (new Foo).baz(); };" + "var y = function() { x(); };" + "function Foo() {}" + "Foo.prototype.baz = function() { y(); };", ""); } public void testGlobalFunctionsInGraph2() { // In this example, Foo.prototype.baz is a global reference to // Foo, and Foo has a reference to baz. So everything stays in. // TODO(nicksantos): We should be able to make the graph more fine-grained // here. Instead of Foo.prototype.bar creating a global reference to Foo, // it should create a reference from .bar to Foo. That will let us // compile this away to nothing. testSame( "var x = function() { (new Foo).baz(); };" + "var y = function() { x(); };" + "function Foo() { this.baz(); }" + "Foo.prototype.baz = function() { y(); };"); } public void testGlobalFunctionsInGraph3() { test( "var x = function() { (new Foo).baz(); };" + "var y = function() { x(); };" + "function Foo() { this.baz(); }" + "Foo.prototype.baz = function() { x(); };", "var x = function() { (new Foo).baz(); };" + "function Foo() { this.baz(); }" + "Foo.prototype.baz = function() { x(); };"); } public void testGlobalFunctionsInGraph4() { test( "var x = function() { (new Foo).baz(); };" + "var y = function() { x(); };" + "function Foo() { Foo.prototype.baz = function() { y(); }; }", ""); } public void testGlobalFunctionsInGraph5() { test( "function Foo() {}" + "Foo.prototype.methodA = function() {};" + "function x() { (new Foo).methodA(); }" + "Foo.prototype.methodB = function() { x(); };", ""); anchorUnusedVars = true; test( "function Foo() {}" + "Foo.prototype.methodA = function() {};" + "function x() { (new Foo).methodA(); }" + "Foo.prototype.methodB = function() { x(); };", "function Foo() {}" + "Foo.prototype.methodA = function() {};" + "function x() { (new Foo).methodA(); }"); } public void testGlobalFunctionsInGraph6() { testSame( "function Foo() {}" + "Foo.prototype.methodA = function() {};" + "function x() { (new Foo).methodA(); }" + "Foo.prototype.methodB = function() { x(); };" + "(new Foo).methodB();"); } public void testGlobalFunctionsInGraph7() { testSame( "function Foo() {}" + "Foo.prototype.methodA = function() {};" + "this.methodA();"); } public void testGetterBaseline() { anchorUnusedVars = true; test( "function Foo() {}" + "Foo.prototype = { " + " methodA: function() {}," + " methodB: function() { x(); }" + "};" + "function x() { (new Foo).methodA(); }", "function Foo() {}" + "Foo.prototype = { " + " methodA: function() {}" + "};" + "function x() { (new Foo).methodA(); }"); } public void testGetter1() { test( "function Foo() {}" + "Foo.prototype = { " + " get methodA() {}," + " get methodB() { x(); }" + "};" + "function x() { (new Foo).methodA; }", "function Foo() {}" + "Foo.prototype = {};"); anchorUnusedVars = true; test( "function Foo() {}" + "Foo.prototype = { " + " get methodA() {}," + " get methodB() { x(); }" + "};" + "function x() { (new Foo).methodA; }", "function Foo() {}" + "Foo.prototype = { " + " get methodA() {}" + "};" + "function x() { (new Foo).methodA; }"); } public void testGetter2() { anchorUnusedVars = true; test( "function Foo() {}" + "Foo.prototype = { " + " get methodA() {}," + " set methodA(a) {}," + " get methodB() { x(); }," + " set methodB(a) { x(); }" + "};" + "function x() { (new Foo).methodA; }", "function Foo() {}" + "Foo.prototype = { " + " get methodA() {}," + " set methodA(a) {}" + "};" + "function x() { (new Foo).methodA; }"); } public void testHook1() throws Exception { test( "/** @constructor */ function Foo() {}" + "Foo.prototype.method1 = Math.random() ?" + " function() { this.method2(); } : function() { this.method3(); };" + "Foo.prototype.method2 = function() {};" + "Foo.prototype.method3 = function() {};", ""); } public void testHook2() throws Exception { testSame( "/** @constructor */ function Foo() {}" + "Foo.prototype.method1 = Math.random() ?" + " function() { this.method2(); } : function() { this.method3(); };" + "Foo.prototype.method2 = function() {};" + "Foo.prototype.method3 = function() {};" + "(new Foo()).method1();"); } }
/* * Copyright 2004 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; public class RemoveUnusedVarsTest extends CompilerTestCase { private boolean removeGlobal; private boolean preserveFunctionExpressionNames; private boolean modifyCallSites; public RemoveUnusedVarsTest() { super("function alert() {}"); enableNormalize(); } @Override public void setUp() { removeGlobal = true; preserveFunctionExpressionNames = false; modifyCallSites = false; } @Override protected CompilerPass getProcessor(final Compiler compiler) { return new RemoveUnusedVars( compiler, removeGlobal, preserveFunctionExpressionNames, modifyCallSites); } public void testRemoveUnusedVars() { // Test lots of stuff test("var a;var b=3;var c=function(){};var x=A();var y; var z;" + "function A(){B()} function B(){C(b)} function C(){} " + "function X(){Y()} function Y(z){Z(x)} function Z(){y} " + "P=function(){A()}; " + "try{0}catch(e){a}", "var a;var b=3;A();function A(){B()}" + "function B(){C(b)}" + "function C(){}" + "P=function(){A()}" + ";try{0}catch(e){a}"); // Test removal from if {} blocks test("var i=0;var j=0;if(i>0){var k=1;}", "var i=0;if(i>0);"); // Test with for loop test("for (var i in booyah) {" + " if (i > 0) x += ', ';" + " var arg = 'foo';" + " if (arg.length > 40) {" + " var unused = 'bar';" + // this variable is unused " arg = arg.substr(0, 40) + '...';" + " }" + " x += arg;" + "}", "for(var i in booyah){if(i>0)x+=\", \";" + "var arg=\"foo\";if(arg.length>40)arg=arg.substr(0,40)+\"...\";" + "x+=arg}"); // Test with function expressions in another function call test("function A(){}" + "if(0){function B(){}}win.setTimeout(function(){A()})", "function A(){}" + "if(0);win.setTimeout(function(){A()})"); // Test with recursive functions test("function A(){A()}function B(){B()}B()", "function B(){B()}B()"); // Test with multiple var declarations. test("var x,y=2,z=3;A(x);B(z);var a,b,c=4;C()", "var x,z=3;A(x);B(z);C()"); // Test with for loop declarations test("for(var i=0,j=0;i<10;){}" + "for(var x=0,y=0;;y++){}" + "for(var a,b;;){a}" + "for(var c,d;;);" + "for(var item in items){}", "for(var i=0;i<10;);" + "for(var y=0;;y++);" + "for(var a;;)a;" + "for(;;);" + "for(var item in items);"); // Test multiple passes required test("var a,b,c,d;var e=[b,c];var x=e[3];var f=[d];print(f[0])", "var d;var f=[d];print(f[0])"); // Test proper scoping (static vs dynamic) test("var x;function A(){var x;B()}function B(){print(x)}A()", "var x;function A(){B()}function B(){print(x)}A()"); // Test closures in a return statement test("function A(){var x;return function(){print(x)}}A()", "function A(){var x;return function(){print(x)}}A()"); // Test other closures, multiple passes test("function A(){}function B(){" + "var c,d,e,f,g,h;" + "function C(){print(c)}" + "var handler=function(){print(d)};" + "var handler2=function(){handler()};" + "e=function(){print(e)};" + "if(1){function G(){print(g)}}" + "arr=[function(){print(h)}];" + "return function(){print(f)}}B()", "function B(){" + "var f,h;" + "if(1);" + "arr=[function(){print(h)}];" + "return function(){print(f)}}B()"); // Test exported names test("var a,b=1; function _A1() {this.foo(a)}", "var a;function _A1(){this.foo(a)}"); // Test undefined (i.e. externally defined) names test("undefinedVar = 1", "undefinedVar=1"); // Test unused vars with side effects test("var a,b=foo(),c=i++,d;var e=boo();var f;print(d);", "foo(); i++; var d; boo(); print(d)"); test("var a,b=foo()", "foo()"); test("var b=foo(),a", "foo()"); test("var a,b=foo(a)", "var a; foo(a);"); } public void testFunctionArgRemoval() { // remove all function arguments test("var b=function(c,d){return};b(1,2)", "var b=function(){return};b(1,2)"); // remove no function arguments testSame("var b=function(c,d){return c+d};b(1,2)"); testSame("var b=function(e,f,c,d){return c+d};b(1,2)"); // remove some function arguments test("var b=function(c,d,e,f){return c+d};b(1,2)", "var b=function(c,d){return c+d};b(1,2)"); test("var b=function(e,c,f,d,g){return c+d};b(1,2)", "var b=function(e,c,f,d){return c+d};b(1,2)"); } public void testFunctionArgRemovalFromCallSites() { this.modifyCallSites = true; // remove all function arguments test("var b=function(c,d){return};b(1,2)", "var b=function(){return};b()"); // remove no function arguments testSame("var b=function(c,d){return c+d};b(1,2)"); test("var b=function(e,f,c,d){return c+d};b(1,2)", "var b=function(c,d){return c+d};b()"); // remove some function arguments test("var b=function(c,d,e,f){return c+d};b(1,2)", "var b=function(c,d){return c+d};b(1,2)"); test("var b=function(e,c,f,d,g){return c+d};b(1,2)", "var b=function(c,d){return c+d};b(2)"); } public void testFunctionsDeadButEscaped() { testSame("function b(a) { a = 1; print(arguments[0]) }; b(6)"); testSame("function b(a) { a = 1; arguments=1; }; b(6)"); testSame("function b(a) { var c = 2; a = c; print(arguments[0]) }; b(6)"); } public void testVarInControlStructure() { test("if (true) var b = 3;", "if(true);"); test("if (true) var b = 3; else var c = 5;", "if(true);else;"); test("while (true) var b = 3;", "while(true);"); test("for (;;) var b = 3;", "for(;;);"); test("do var b = 3; while(true)", "do;while(true)"); test("with (true) var b = 3;", "with(true);"); test("f: var b = 3;","f:{}"); } public void testRValueHoisting() { test("var x = foo();", "foo()"); test("var x = {a: foo()};", "({a:foo()})"); test("var x=function y(){}", ""); } public void testModule() { test(createModules( "var unreferenced=1; function x() { foo(); }" + "function uncalled() { var x; return 2; }", "var a,b; function foo() { this.foo(a); } x()"), new String[] { "function x(){foo()}", "var a;function foo(){this.foo(a)}x()" }); } public void testRecursiveFunction1() { testSame("(function x(){return x()})()"); } public void testRecursiveFunction2() { test("var x = 3; (function x() { return x(); })();", "(function x$$1(){return x$$1()})()"); } public void testFunctionWithName1() { test("var x=function f(){};x()", "var x=function(){};x()"); preserveFunctionExpressionNames = true; testSame("var x=function f(){};x()"); } public void testFunctionWithName2() { test("foo(function bar(){})", "foo(function(){})"); preserveFunctionExpressionNames = true; testSame("foo(function bar(){})"); } public void testRemoveGlobal1() { removeGlobal = false; testSame("var x=1"); test("var y=function(x){var z;}", "var y=function(x){}"); } public void testRemoveGlobal2() { removeGlobal = false; testSame("var x=1"); test("function y(x){var z;}", "function y(x){}"); } public void testRemoveGlobal3() { removeGlobal = false; testSame("var x=1"); test("function x(){function y(x){var z;}y()}", "function x(){function y(x){}y()}"); } public void testRemoveGlobal4() { removeGlobal = false; testSame("var x=1"); test("function x(){function y(x){var z;}}", "function x(){}"); } public void testIssue168a() { test("function _a(){" + " (function(x){ _b(); })(1);" + "}" + "function _b(){" + " _a();" + "}", "function _a(){(function(){_b()})(1)}" + "function _b(){_a()}"); } public void testIssue168b() { removeGlobal = false; test("function a(){" + " (function(x){ b(); })(1);" + "}" + "function b(){" + " a();" + "}", "function a(){(function(x){b()})(1)}" + "function b(){a()}"); } public void testUnusedAssign1() { test("var x = 3; x = 5;", ""); } public void testUnusedAssign2() { test("function f(a) { a = 3; } this.x = f;", "function f(){} this.x=f"); } public void testUnusedAssign3() { // e can't be removed, so we don't try to remove the dead assign. // We might be able to improve on this case. test("try { throw ''; } catch (e) { e = 3; }", "try{throw\"\";}catch(e){e=3}"); } public void testUnusedAssign4() { test("function f(a, b) { this.foo(b); a = 3; } this.x = f;", "function f(a,b){this.foo(b);}this.x=f"); } public void testUnusedAssign5() { test("var z = function f() { f = 3; }; z();", "var z=function(){};z()"); } public void testUnusedAssign5b() { test("var z = function f() { f = alert(); }; z();", "var z=function(){alert()};z()"); } public void testUnusedAssign6() { test("var z; z = 3;", ""); } public void testUnusedAssign6b() { test("var z; z = alert();", "alert()"); } public void testUnusedAssign7() { // This loop is normalized to "var i;for(i in..." test("var a = 3; for (var i in {}) { i = a; }", // TODO(johnlenz): "i = a" should be removed here. "var a = 3; var i; for (i in {}) {i = a;}"); } public void testUnusedAssign8() { // This loop is normalized to "var i;for(i in..." test("var a = 3; for (var i in {}) { i = a; } alert(a);", // TODO(johnlenz): "i = a" should be removed here. "var a = 3; var i; for (i in {}) {i = a} alert(a);"); } public void testUnusedPropAssign1() { test("var x = {}; x.foo = 3;", ""); } public void testUnusedPropAssign1b() { test("var x = {}; x.foo = alert();", "alert()"); } public void testUnusedPropAssign2() { test("var x = {}; x['foo'] = 3;", ""); } public void testUnusedPropAssign2b() { test("var x = {}; x[alert()] = alert();", "alert(),alert()"); } public void testUnusedPropAssign3() { test("var x = {}; x['foo'] = {}; x['bar'] = 3", ""); } public void testUnusedPropAssign3b() { test("var x = {}; x[alert()] = alert(); x[alert() + alert()] = alert()", "alert(),alert();(alert() + alert()),alert()"); } public void testUnusedPropAssign4() { test("var x = {foo: 3}; x['foo'] = 5;", ""); } public void testUnusedPropAssign5() { test("var x = {foo: bar()}; x['foo'] = 5;", "var x={foo:bar()};x[\"foo\"]=5"); } public void testUnusedPropAssign6() { test("var x = function() {}; x.prototype.bar = function() {};", ""); } public void testUnusedPropAssign7() { test("var x = {}; x[x.foo] = x.bar;", ""); } public void testUnusedPropAssign7b() { testSame("var x = {}; x[x.foo] = alert(x.bar);"); } public void testUnusedPropAssign7c() { test("var x = {}; x[alert(x.foo)] = x.bar;", "var x={};x[alert(x.foo)]=x.bar"); } public void testUsedPropAssign1() { test("function f(x) { x.bar = 3; } f({});", "function f(x){x.bar=3}f({})"); } public void testUsedPropAssign2() { test("try { throw z; } catch (e) { e.bar = 3; }", "try{throw z;}catch(e){e.bar=3}"); } public void testUsedPropAssign3() { // This pass does not do flow analysis. test("var x = {}; x.foo = 3; x = bar();", "var x={};x.foo=3;x=bar()"); } public void testUsedPropAssign4() { test("var y = foo(); var x = {}; x.foo = 3; y[x.foo] = 5;", "var y=foo();var x={};x.foo=3;y[x.foo]=5"); } public void testUsedPropAssign5() { test("var y = foo(); var x = 3; y[x] = 5;", "var y=foo();var x=3;y[x]=5"); } public void testUsedPropAssign6() { test("var x = newNodeInDom(doc); x.innerHTML = 'new text';", "var x=newNodeInDom(doc);x.innerHTML=\"new text\""); } public void testUsedPropAssign7() { testSame("var x = {}; for (x in alert()) { x.foo = 3; }"); } public void testUsedPropAssign8() { testSame("for (var x in alert()) { x.foo = 3; }"); } public void testUsedPropAssign9() { testSame( "var x = {}; x.foo = newNodeInDom(doc); x.foo.innerHTML = 'new test';"); } public void testDependencies1() { test("var a = 3; var b = function() { alert(a); };", ""); } public void testDependencies1b() { test("var a = 3; var b = alert(function() { alert(a); });", "var a=3;alert(function(){alert(a)})"); } public void testDependencies1c() { test("var a = 3; var _b = function() { alert(a); };", "var a=3;var _b=function(){alert(a)}"); } public void testDependencies2() { test("var a = 3; var b = 3; b = function() { alert(a); };", ""); } public void testDependencies2b() { test("var a = 3; var b = 3; b = alert(function() { alert(a); });", "var a=3;alert(function(){alert(a)})"); } public void testDependencies2c() { testSame("var a=3;var _b=3;_b=function(){alert(a)}"); } public void testGlobalVarReferencesLocalVar() { testSame("var a=3;function f(){var b=4;a=b}alert(a + f())"); } public void testLocalVarReferencesGlobalVar1() { testSame("var a=3;function f(b, c){b=a; alert(b + c);} f();"); } public void testLocalVarReferencesGlobalVar2() { test("var a=3;function f(b, c){b=a; alert(c);} f();", "function f(b, c) { alert(c); } f();"); this.modifyCallSites = true; test("var a=3;function f(b, c){b=a; alert(c);} f();", "function f(c) { alert(c); } f();"); } public void testNestedAssign1() { test("var b = null; var a = (b = 3); alert(a);", "var a = 3; alert(a);"); } public void testNestedAssign2() { test("var a = 1; var b = 2; var c = (b = a); alert(c);", "var a = 1; var c = a; alert(c);"); } public void testNestedAssign3() { test("var b = 0; var z; z = z = b = 1; alert(b);", "var b = 0; b = 1; alert(b);"); } public void testCallSiteInteraction() { this.modifyCallSites = true; testSame("var b=function(){return};b()"); testSame("var b=function(c){return c};b(1)"); test("var b=function(c){};b.call(null, x)", "var b=function(){};b.call(null)"); test("var b=function(c){};b.apply(null, x)", "var b=function(){};b.apply(null, x)"); test("var b=function(c){return};b(1)", "var b=function(){return};b()"); test("var b=function(c){return};b(1,2)", "var b=function(){return};b()"); test("var b=function(c){return};b(1,2);b(3,4)", "var b=function(){return};b();b()"); // Here there is a unknown reference to the function so we can't // change the signature. test("var b=function(c,d){return d};b(1,2);b(3,4);b.length", "var b=function(c,d){return d};b(0,2);b(0,4);b.length"); test("var b=function(c){return};b(1,2);b(3,new x())", "var b=function(){return};b();b(new x())"); test("var b=function(c){return};b(1,2);b(new x(),4)", "var b=function(){return};b();b(new x())"); test("var b=function(c,d){return d};b(1,2);b(new x(),4)", "var b=function(c,d){return d};b(0,2);b(new x(),4)"); test("var b=function(c,d,e){return d};b(1,2,3);b(new x(),4,new x())", "var b=function(c,d){return d};b(0,2);b(new x(),4,new x())"); // Recursive calls are OK. test("var b=function(c,d){b(1,2);return d};b(3,4);b(5,6)", "var b=function(d){b(2);return d};b(4);b(6)"); testSame("var b=function(c){return arguments};b(1,2);b(3,4)"); // remove all function arguments test("var b=function(c,d){return};b(1,2)", "var b=function(){return};b()"); // remove no function arguments testSame("var b=function(c,d){return c+d};b(1,2)"); // remove some function arguments test("var b=function(e,f,c,d){return c+d};b(1,2)", "var b=function(c,d){return c+d};b()"); test("var b=function(c,d,e,f){return c+d};b(1,2)", "var b=function(c,d){return c+d};b(1,2)"); test("var b=function(e,c,f,d,g){return c+d};b(1,2)", "var b=function(c,d){return c+d};b(2)"); // multiple definitions of "b", the parameters can be removed but // the call sites are left unmodified for now. test("var b=function(c,d){};var b=function(e,f){};b(1,2)", "var b=function(){};var b=function(){};b(1,2)"); } public void testCallSiteInteraction_contructors() { this.modifyCallSites = true; // The third level tests that the functions which have already been looked // at get re-visited if they are changed by a call site removal. test("var Ctor1=function(a,b){return a};" + "var Ctor2=function(a,b){Ctor1.call(this,a,b)};" + "goog$inherits(Ctor2, Ctor1);" + "new Ctor2(1,2)", "var Ctor1=function(a){return a};" + "var Ctor2=function(a){Ctor1.call(this,a)};" + "goog$inherits(Ctor2, Ctor1);" + "new Ctor2(1)"); } public void testFunctionArgRemovalCausingInconsistency() { this.modifyCallSites = true; // Test the case where an unused argument is removed and the argument // contains a call site in its subtree (will cause the call site's parent // pointer to be null). test("var a=function(x,y){};" + "var b=function(z){};" + "a(new b, b)", "var a=function(){};" + "var b=function(){};" + "a(new b)"); } public void testRemoveUnusedVarsPossibleNpeCase() { this.modifyCallSites = true; test("var a = [];" + "var register = function(callback) {a[0] = callback};" + "register(function(transformer) {});" + "register(function(transformer) {});", "var register=function(){};register();register()"); } public void testDoNotOptimizeJSCompiler_renameProperty() { this.modifyCallSites = true; // Only the function definition can be modified, none of the call sites. test("function JSCompiler_renameProperty(a) {};" + "JSCompiler_renameProperty('a');", "function JSCompiler_renameProperty() {};" + "JSCompiler_renameProperty('a');"); } public void testDoNotOptimizeJSCompiler_ObjectPropertyString() { this.modifyCallSites = true; test("function JSCompiler_ObjectPropertyString(a, b) {};" + "JSCompiler_ObjectPropertyString(window,'b');", "function JSCompiler_ObjectPropertyString() {};" + "JSCompiler_ObjectPropertyString(window,'b');"); } public void testDoNotOptimizeSetters() { testSame("({set s(a) {}})"); } public void testRemoveSingletonClass1() { test("function goog$addSingletonGetter(a){}" + "/**@constructor*/function a(){}" + "goog$addSingletonGetter(a);", ""); } public void testRemoveInheritedClass1() { test("function goog$inherits(){}" + "/**@constructor*/function a(){}" + "/**@constructor*/function b(){}" + "goog$inherits(b,a); new a", "function a(){} new a"); } public void testRemoveInheritedClass2() { test("function goog$inherits(){}" + "function goog$mixin(){}" + "/**@constructor*/function a(){}" + "/**@constructor*/function b(){}" + "/**@constructor*/function c(){}" + "goog$inherits(b,a);" + "goog$mixin(c.prototype,b.prototype);", ""); } public void testRemoveInheritedClass3() { testSame("/**@constructor*/function a(){}" + "/**@constructor*/function b(){}" + "goog$inherits(b,a); new b"); } public void testRemoveInheritedClass4() { testSame("function goog$inherits(){}" + "/**@constructor*/function a(){}" + "/**@constructor*/function b(){}" + "goog$inherits(b,a);" + "/**@constructor*/function c(){}" + "goog$inherits(c,b); new c"); } public void testRemoveInheritedClass5() { test("function goog$inherits(){}" + "/**@constructor*/function a(){}" + "/**@constructor*/function b(){}" + "goog$inherits(b,a);" + "/**@constructor*/function c(){}" + "goog$inherits(c,b); new b", "function goog$inherits(){}" + "function a(){}" + "function b(){}" + "goog$inherits(b,a); new b"); } public void testRemoveInheritedClass6() { test("function goog$mixin(){}" + "/**@constructor*/function a(){}" + "/**@constructor*/function b(){}" + "/**@constructor*/function c(){}" + "/**@constructor*/function d(){}" + "goog$mixin(b.prototype,a.prototype);" + "goog$mixin(c.prototype,a.prototype); new c;" + "goog$mixin(d.prototype,a.prototype)", "function goog$mixin(){}" + "function a(){}" + "function c(){}" + "goog$mixin(c.prototype,a.prototype); new c"); } public void testRemoveInheritedClass7() { test("function goog$mixin(){}" + "/**@constructor*/function a(){alert(goog$mixin(a, a))}" + "/**@constructor*/function b(){}" + "goog$mixin(b.prototype,a.prototype); new a", "function goog$mixin(){}" + "function a(){alert(goog$mixin(a, a))} new a"); } public void testRemoveInheritedClass8() { test("/**@constructor*/function a(){}" + "/**@constructor*/function b(){}" + "/**@constructor*/function c(){}" + "b.inherits(a);c.mixin(b.prototype)", ""); } public void testRemoveInheritedClass9() { testSame("/**@constructor*/function a(){}" + "/**@constructor*/function b(){}" + "/**@constructor*/function c(){}" + "b.inherits(a);c.mixin(b.prototype);new c"); } public void testRemoveInheritedClass10() { test("function goog$inherits(){}" + "/**@constructor*/function a(){}" + "/**@constructor*/function b(){}" + "goog$inherits(b,a); new a;" + "var c = a; var d = a.g; new b", "function goog$inherits(){}" + "function a(){} function b(){} goog$inherits(b,a); new a; new b"); } public void testRemoveInheritedClass11() { testSame("function goog$inherits(){}" + "function goog$mixin(a,b){goog$inherits(a,b)}" + "/**@constructor*/function a(){}" + "/**@constructor*/function b(){}" + "goog$mixin(b.prototype,a.prototype);new b"); } public void testRemoveInheritedClass12() { testSame("function goog$inherits(){}" + "/**@constructor*/function a(){}" + "var b = {};" + "goog$inherits(b.foo, a)"); } public void testReflectedMethods() { this.modifyCallSites = true; testSame( "/** @constructor */" + "function Foo() {}" + "Foo.prototype.handle = function(x, y) { alert(y); };" + "var x = goog.reflect.object(Foo, {handle: 1});" + "for (var i in x) { x[i].call(x); }" + "window['Foo'] = Foo;"); } public void testIssue618_1() { this.removeGlobal = false; testSame( "function f() {\n" + " var a = [], b;\n" + " a.push(b = []);\n" + " b[0] = 1;\n" + " return a;\n" + "}"); } public void testIssue618_2() { this.removeGlobal = false; testSame( "var b;\n" + "a.push(b = []);\n" + "b[0] = 1;\n"); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Tests for {@link RenameLabels}. */ public class RenameLabelsTest extends CompilerTestCase { @Override protected CompilerPass getProcessor(Compiler compiler) { return new RenameLabels(compiler); } public void testRenameInFunction() { test("function x(){ Foo:a(); }", "function x(){ a(); }"); test("function x(){ Foo:{ a(); break Foo; } }", "function x(){ a:{ a(); break a; } }"); test("function x() { " + "Foo:{ " + "function goo() {" + "Foo: {" + "a(); " + "break Foo; " + "}" + "}" + "}" + "}", "function x(){function goo(){a:{ a(); break a; }}}"); test("function x() { " + "Foo:{ " + "function goo() {" + "Foo: {" + "a(); " + "break Foo; " + "}" + "}" + "break Foo;" + "}" + "}", "function x(){a:{function goo(){a:{ a(); break a; }} break a;}}"); } public void testRenameGlobals() { test("Foo:{a();}", "a();"); test("Foo:{a(); break Foo;}", "a:{a(); break a;}"); test("Foo:{Goo:a(); break Foo;}", "a:{a(); break a;}"); test("Foo:{Goo:while(1){a(); continue Goo; break Foo;}}", "a:{b:while(1){a(); continue b;break a;}}"); test("Foo:Goo:while(1){a(); continue Goo; break Foo;}", "a:b:while(1){a(); continue b;break a;}"); test("Foo:Bar:X:{ break Bar; }", "a:{ break a; }"); test("Foo:Bar:X:{ break Bar; break X; }", "a:b:{ break a; break b;}"); test("Foo:Bar:X:{ break Bar; break Foo; }", "a:b:{ break b; break a;}"); test("Foo:while (1){a(); break;}", "while (1){a(); break;}"); // Remove label that is not referenced. test("Foo:{a(); while (1) break;}", "a(); while (1) break;"); } public void testRenameReused() { test("foo:{break foo}; foo:{break foo}", "a:{break a};a:{break a}"); } }
/* * Copyright 2007 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Tests for {@link RenameVars}. * @see RenameVarsTest */ public class RenameLocalVarsTest extends CompilerTestCase { private static final String DEFAULT_PREFIX = ""; private String prefix = DEFAULT_PREFIX; @Override protected CompilerPass getProcessor(Compiler compiler) { return new RenameVars( compiler, prefix, true, false, false, false, null, null, null); } public void testRenameSimple() { test("function Foo(v1, v2) {return v1;} Foo();", "function Foo(a, b) {return a;} Foo();"); } public void testRenameGlobals() { testSame("var Foo; var Bar, y; function x() { Bar++; }"); } public void testRenameLocals() { test("(function (v1, v2) {}); (function (v3, v4) {});", "(function (a, b) {}); (function (a, b) {});"); test("function f1(v1, v2) {}; function f2(v3, v4) {};", "function f1(a, b) {}; function f2(a, b) {};"); } public void testRenameLocalsClashingWithGlobals() { test("function a(v1, v2) {return v1;} a();", "function a(b, c) {return b;} a();"); } public void testRenameNested() { test("function f1(v1, v2) { (function(v3, v4) {}) }", "function f1(a, b) { (function(c, d) {}) }"); test("function f1(v1, v2) { function f2(v3, v4) {} }", "function f1(a, b) { function c(d, e) {} }"); } public void testRenameWithExterns1() { String externs = "var bar; function alert() {}"; test(externs, "function foo(bar) { alert(bar); } foo(3)", "function foo(a) { alert(a); } foo(3)", null, null); } public void testRenameWithExterns2() { test("var a; function alert() {}", "function foo(bar) { alert(a);alert(bar); } foo(3);", "function foo(b) { alert(a);alert(b); } foo(3);", null, null); } public void testDoNotRenameExportedName() { test("_foo()", "_foo()"); } public void testRenameWithNameOverlap() { test("function local() { var a = 1; var b = 2; b + b; }", "function local() { var b = 1; var a = 2; a + a; }"); } public void testRenameWithPrefix1() { prefix = "PRE_"; test("function Foo(v1, v2) {return v1} Foo();", "function Foo(a, b) {return a} Foo();"); prefix = DEFAULT_PREFIX; } public void testRenameWithPrefix2() { prefix = "PRE_"; test("function Foo(v1, v2) {var v3 = v1 + v2; return v3;} Foo();", "function Foo(a, b) {var c = a + b; return c;} Foo();"); prefix = DEFAULT_PREFIX; } public void testRenameWithPrefix3() { prefix = "a"; test("function Foo() {return 1;}" + "function Bar() {" + " var a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z," + " A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,aa,ab;" + " Foo();" + "} Bar();", "function Foo() {return 1;}" + "function Bar() {" + " var a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C," + " D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,$,aa;" + " Foo();" + "} Bar();"); prefix = DEFAULT_PREFIX; } }
/* * Copyright 2005 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; /** * {@link RenameProperties} tests. * */ public class RenamePropertiesTest extends CompilerTestCase { private static final String EXTERNS = "var window;" + "prop.toString;" + "var google = { gears: { factory: {}, workerPool: {} } };"; private RenameProperties renameProperties; private static boolean generatePseudoNames = false; private static boolean useAffinity = false; private VariableMap prevUsedPropertyMap = null; public RenamePropertiesTest() { super(EXTERNS); enableNormalize(); } @Override protected void tearDown() throws Exception { super.tearDown(); prevUsedPropertyMap = null; useAffinity = false; } @Override protected int getNumRepetitions() { // The RenameProperties pass should only be run once over a parse tree. return 1; } public void testPrototypeProperties() { test("Bar.prototype.getA = function(){}; bar.getA();" + "Bar.prototype.getB = function(){};", "Bar.prototype.a = function(){}; bar.a();" + "Bar.prototype.b = function(){}"); } public void testPrototypePropertiesAsObjLitKeys1() { test("Bar.prototype = {2: function(){}, getA: function(){}}; bar[2]();", "Bar.prototype = {2: function(){}, a: function(){}}; bar[2]();"); } public void testPrototypePropertiesAsObjLitKeys2() { testSame("Bar.prototype = {get 2(){}}; bar[2];"); testSame("Bar.prototype = {get 'a'(){}}; bar['a'];"); test("Bar.prototype = {get getA(){}}; bar.getA;", "Bar.prototype = {get a(){}}; bar.a;"); } public void testPrototypePropertiesAsObjLitKeys3() { testSame("Bar.prototype = {set 2(x){}}; bar[2];"); testSame("Bar.prototype = {set 'a'(x){}}; bar['a'];"); test("Bar.prototype = {set getA(x){}}; bar.getA;", "Bar.prototype = {set a(x){}}; bar.a;"); } public void testMixedQuotedAndUnquotedObjLitKeys1() { test("Bar = {getA: function(){}, 'getB': function(){}}; bar.getA();", "Bar = {a: function(){}, 'getB': function(){}}; bar.a();"); } public void testMixedQuotedAndUnquotedObjLitKeys2() { test("Bar = {getA: function(){}, 'getB': function(){}}; bar.getA();", "Bar = {a: function(){}, 'getB': function(){}}; bar.a();"); } public void testQuotedPrototypeProperty() { testSame("Bar.prototype['getA'] = function(){}; bar['getA']();"); } public void testOverlappingOriginalAndGeneratedNames() { test("Bar.prototype = {b: function(){}, a: function(){}}; bar.b();", "Bar.prototype = {a: function(){}, b: function(){}}; bar.a();"); } public void testRenamePropertiesWithLeadingUnderscores() { test("Bar.prototype = {_getA: function(){}, _b: 0}; bar._getA();", "Bar.prototype = {a: function(){}, b: 0}; bar.a();"); } public void testPropertyAddedToObject() { test("var foo = {}; foo.prop = '';", "var foo = {}; foo.a = '';"); } public void testPropertyAddedToFunction() { test("var foo = function(){}; foo.prop = '';", "var foo = function(){}; foo.a = '';"); } public void testPropertyOfObjectOfUnknownType() { test("var foo = x(); foo.prop = '';", "var foo = x(); foo.a = '';"); } public void testSetPropertyOfThis() { test("this.prop = 'bar'", "this.a = 'bar'"); } public void testReadPropertyOfThis() { test("f(this.prop);", "f(this.a);"); } public void testObjectLiteralInLocalScope() { test("function x() { var foo = {prop1: 'bar', prop2: 'baz'}; }", "function x() { var foo = {a: 'bar', b: 'baz'}; }"); } public void testIncorrectAttemptToAccessQuotedProperty() { // The correct way to call the quoted 'getFoo' method is: bar['getFoo'](). test("Bar.prototype = {'B': 0, 'getFoo': function(){}}; bar.getFoo();", "Bar.prototype = {'B': 0, 'getFoo': function(){}}; bar.a();"); } public void testSetQuotedPropertyOfThis() { testSame("this['prop'] = 'bar';"); } public void testExternedPropertyName() { test("Bar.prototype = {toString: function(){}, foo: 0}; bar.toString();", "Bar.prototype = {toString: function(){}, a: 0}; bar.toString();"); } public void testExternedPropertyNameDefinedByObjectLiteral() { test("function x() { var foo = google.gears.factory; }", "function x() { var foo = google.gears.factory; }"); } public void testAvoidingConflictsBetweenQuotedAndUnquotedPropertyNames() { test("Bar.prototype.foo = function(){}; Bar.prototype['a'] = 0; bar.foo();", "Bar.prototype.b = function(){}; Bar.prototype['a'] = 0; bar.b();"); } public void testSamePropertyNameQuotedAndUnquoted() { test("Bar.prototype.prop = function(){}; y = {'prop': 0};", "Bar.prototype.a = function(){}; y = {'prop': 0};"); } public void testStaticAndInstanceMethodWithSameName() { test("Bar = function(){}; Bar.getA = function(){}; " + "Bar.prototype.getA = function(){}; Bar.getA(); bar.getA();", "Bar = function(){}; Bar.a = function(){}; " + "Bar.prototype.a = function(){}; Bar.a(); bar.a();"); } public void testRenamePropertiesFunctionCall1() { test("var foo = {myProp: 0}; f(foo[JSCompiler_renameProperty('myProp')]);", "var foo = {a: 0}; f(foo['a']);"); } public void testRenamePropertiesFunctionCall2() { test("var foo = {myProp: 0}; " + "f(JSCompiler_renameProperty('otherProp.myProp.someProp')); " + "foo.myProp = 1; foo.theirProp = 2; foo.yourProp = 3;", "var foo = {a: 0}; f('b.a.c'); " + "foo.a = 1; foo.d = 2; foo.e = 3;"); } public void testRemoveRenameFunctionStubs1() { test("function JSCompiler_renameProperty(x) { return x; }", ""); } public void testRemoveRenameFunctionStubs2() { test("function JSCompiler_renameProperty(x) { return x; }" + "var foo = {myProp: 0}; f(foo[JSCompiler_renameProperty('myProp')]);", "var foo = {a: 0}; f(foo['a']);"); } public void testGeneratePseudoNames() { generatePseudoNames = true; test("var foo={}; foo.bar=1; foo['abc']=2", "var foo={}; foo.$bar$=1; foo['abc']=2"); generatePseudoNames = false; } public void testModules() { String module1Js = "function Bar(){} Bar.prototype.getA=function(x){};" + "var foo;foo.getA(foo);foo.doo=foo;foo.bloo=foo;"; String module2Js = "function Far(){} Far.prototype.getB=function(x){};" + "var too;too.getB(too);too.woo=too;too.bloo=too;"; String module3Js = "function Car(){} Car.prototype.getC=function(x){};" + "var noo;noo.getC(noo);noo.zoo=noo;noo.cloo=noo;"; JSModule module1 = new JSModule("m1"); module1.add(SourceFile.fromCode("input1", module1Js)); JSModule module2 = new JSModule("m2"); module2.add(SourceFile.fromCode("input2", module2Js)); JSModule module3 = new JSModule("m3"); module3.add(SourceFile.fromCode("input3", module3Js)); JSModule[] modules = new JSModule[] { module1, module2, module3 }; Compiler compiler = compileModules("", modules); Result result = compiler.getResult(); assertTrue(result.success); assertEquals("function Bar(){}Bar.prototype.b=function(x){};" + "var foo;foo.b(foo);foo.f=foo;foo.a=foo;", compiler.toSource(module1)); assertEquals("function Far(){}Far.prototype.c=function(x){};" + "var too;too.c(too);too.g=too;too.a=too;", compiler.toSource(module2)); // Note that properties that occur most often globally get the earliest // names. The "getC" property, which doesn't occur until module 3, is // renamed to an earlier name in the alphabet than "woo", which appears // in module 2, because "getC" occurs more total times across all modules. // Might be better to give early modules the shortest names, but this is // how the pass currently works. assertEquals("function Car(){}Car.prototype.d=function(x){};" + "var noo;noo.d(noo);noo.h=noo;noo.e=noo;", compiler.toSource(module3)); } public void testPropertyAffinity() { // 'y' gets to be 'b' because it appears with z often. // Other wise, 'x' gets to be 'b' because of alphabetical ordering. useAffinity = true; test("var foo={};foo.x=1;foo.y=2;foo.z=3;" + "function f1() { foo.z; foo.z; foo.z; foo.y}" + "function f2() { foo.x}", "var foo={};foo.c=1;foo.b=2;foo.a=3;" + "function f1() { foo.a; foo.a; foo.a; foo.b}" + "function f2() { foo.c}"); test("var foo={};foo.x=1;foo.y=2;foo.z=3;" + "function f1() { foo.z; foo.z; foo.z; foo.y}" + "function f2() { foo.z; foo.z; foo.z; foo.x}", "var foo={};foo.b=1;foo.c=2;foo.a=3;" + "function f1() { foo.a; foo.a; foo.a; foo.c}" + "function f2() { foo.a; foo.a; foo.a; foo.b}"); } public void testPropertyAffinityOff() { useAffinity = false; test("var foo={};foo.x=1;foo.y=2;foo.z=3;" + "function f1() { foo.z; foo.z; foo.z; foo.y}" + "function f2() { foo.x}", "var foo={};foo.b=1;foo.c=2;foo.a=3;" + "function f1() { foo.a; foo.a; foo.a; foo.c}" + "function f2() { foo.b}"); test("var foo={};foo.x=1;foo.y=2;foo.z=3;" + "function f1() { foo.z; foo.z; foo.z; foo.y}" + "function f2() { foo.z; foo.z; foo.z; foo.x}", "var foo={};foo.b=1;foo.c=2;foo.a=3;" + "function f1() { foo.a; foo.a; foo.a; foo.c}" + "function f2() { foo.a; foo.a; foo.a; foo.b}"); } public void testPrototypePropertiesStable() { testStableRenaming( "Bar.prototype.getA = function(){}; bar.getA();" + "Bar.prototype.getB = function(){};", "Bar.prototype.a = function(){}; bar.a();" + "Bar.prototype.b = function(){}", "Bar.prototype.get = function(){}; bar.get();" + "Bar.prototype.getA = function(){}; bar.getA();" + "Bar.prototype.getB = function(){};", "Bar.prototype.c = function(){}; bar.c();" + "Bar.prototype.a = function(){}; bar.a();" + "Bar.prototype.b = function(){}"); } public void testPrototypePropertiesAsObjLitKeysStable() { testStableRenaming( "Bar.prototype = {2: function(){}, getA: function(){}}; bar[2]();", "Bar.prototype = {2: function(){}, a: function(){}}; bar[2]();", "Bar.prototype = {getB: function(){},getA: function(){}}; bar.getB();", "Bar.prototype = {b: function(){},a: function(){}}; bar.b();"); } public void testMixedQuotedAndUnquotedObjLitKeysStable() { testStableRenaming( "Bar = {getA: function(){}, 'getB': function(){}}; bar.getA();", "Bar = {a: function(){}, 'getB': function(){}}; bar.a();", "Bar = {get: function(){}, getA: function(){}, 'getB': function(){}};" + "bar.getA();bar.get();", "Bar = {b: function(){}, a: function(){}, 'getB': function(){}};" + "bar.a();bar.b();"); } public void testOverlappingOriginalAndGeneratedNamesStable() { testStableRenaming( "Bar.prototype = {b: function(){}, a: function(){}}; bar.b();", "Bar.prototype = {a: function(){}, b: function(){}}; bar.a();", "Bar.prototype = {c: function(){}, b: function(){}, a: function(){}};" + "bar.b();", "Bar.prototype = {c: function(){}, a: function(){}, b: function(){}};" + "bar.a();"); } public void testStableWithTrickyExternsChanges() { test("Bar.prototype = {b: function(){}, a: function(){}}; bar.b();", "Bar.prototype = {a: function(){}, b: function(){}}; bar.a();"); prevUsedPropertyMap = renameProperties.getPropertyMap(); String externs = EXTERNS + "prop.b;"; test(externs, "Bar.prototype = {new_f: function(){}, b: function(){}, " + "a: function(){}};bar.b();", "Bar.prototype = {c:function(){}, b:function(){}, a:function(){}};" + "bar.b();", null, null); } public void testRenamePropertiesWithLeadingUnderscoresStable() { testStableRenaming( "Bar.prototype = {_getA: function(){}, _b: 0}; bar._getA();", "Bar.prototype = {a: function(){}, b: 0}; bar.a();", "Bar.prototype = {_getA: function(){}, _c: 1, _b: 0}; bar._getA();", "Bar.prototype = {a: function(){}, c: 1, b: 0}; bar.a();"); } public void testPropertyAddedToObjectStable() { testStableRenaming("var foo = {}; foo.prop = '';", "var foo = {}; foo.a = '';", "var foo = {}; foo.prop = ''; foo.a='';", "var foo = {}; foo.a = ''; foo.b='';"); } public void testAvoidingConflictsBetQuotedAndUnquotedPropertyNamesStable() { testStableRenaming( "Bar.prototype.foo = function(){}; Bar.prototype['b'] = 0; bar.foo();", "Bar.prototype.a = function(){}; Bar.prototype['b'] = 0; bar.a();", "Bar.prototype.foo = function(){}; Bar.prototype['a'] = 0; bar.foo();", "Bar.prototype.b = function(){}; Bar.prototype['a'] = 0; bar.b();"); } public void testRenamePropertiesFunctionCallStable() { testStableRenaming( "var foo = {myProp: 0}; " + "f(JSCompiler_renameProperty('otherProp.myProp.someProp')); " + "foo.myProp = 1; foo.theirProp = 2; foo.yourProp = 3;", "var foo = {a: 0}; f('b.a.c'); " + "foo.a = 1; foo.d = 2; foo.e = 3;", "var bar = {newProp: 0}; var foo = {myProp: 0}; " + "f(JSCompiler_renameProperty('otherProp.myProp.someProp')); " + "foo.myProp = 1; foo.theirProp = 2; foo.yourProp = 3;", "var bar = {f: 0}; var foo = {a: 0}; f('b.a.c'); " + "foo.a = 1; foo.d = 2; foo.e = 3;"); } private void testStableRenaming(String input1, String expected1, String input2, String expected2) { test(input1, expected1); prevUsedPropertyMap = renameProperties.getPropertyMap(); test(input2, expected2); } private Compiler compileModules(String externs, JSModule[] modules) { SourceFile externsInput = SourceFile.fromCode("externs", externs); CompilerOptions options = new CompilerOptions(); options.propertyRenaming = PropertyRenamingPolicy.ALL_UNQUOTED; Compiler compiler = new Compiler(); compiler.compileModules( ImmutableList.of(externsInput), Lists.newArrayList(modules), options); return compiler; } @Override public CompilerPass getProcessor(Compiler compiler) { return renameProperties = new RenameProperties(compiler, useAffinity, generatePseudoNames, prevUsedPropertyMap); } }
/* * Copyright 2005 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; public class RenamePrototypesTest extends CompilerTestCase { private static final String EXTERNS = "var js_version;js_version.toString;"; private VariableMap prevUsedRenameMap; private RenamePrototypes renamePrototypes; public RenamePrototypesTest() { super(EXTERNS); enableNormalize(); } @Override public CompilerPass getProcessor(Compiler compiler) { return renamePrototypes = new RenamePrototypes(compiler, true, null, prevUsedRenameMap); } @Override protected void tearDown() throws Exception { super.tearDown(); prevUsedRenameMap = null; } @Override protected int getNumRepetitions() { // The RenamePrototypes pass should only be run once over a parse tree. return 1; } public void testRenamePrototypes1() { test("Bar.prototype={'getFoo':function(){},2:function(){}}", "Bar.prototype={'a':function(){},2:function(){}}"); } public void testRenamePrototypes2() { // Simple test("Bar.prototype.getFoo=function(){};Bar.getFoo(b);" + "Bar.prototype.getBaz=function(){}", "Bar.prototype.a=function(){};Bar.a(b);" + "Bar.prototype.b=function(){}"); test("Bar.prototype['getFoo']=function(){};Bar.getFoo(b);" + "Bar.prototype['getBaz']=function(){}", "Bar.prototype['a']=function(){};Bar.a(b);" + "Bar.prototype['b']=function(){}"); test("Bar.prototype={'getFoo':function(){},2:function(){}}", "Bar.prototype={'a':function(){},2:function(){}}"); test("Bar.prototype={'getFoo':function(){}," + "'getBar':function(){}};b.getFoo()", "Bar.prototype={'a':function(){}," + "'b':function(){}};b.a()"); test("Bar.prototype={'B':function(){}," + "'getBar':function(){}};b.getBar()", "Bar.prototype={'b':function(){}," + "'a':function(){}};b.a()"); // overlap test("Bar.prototype={'a':function(){}," + "'b':function(){}};b.b()", "Bar.prototype={'b':function(){}," + "'a':function(){}};b.a()"); // don't rename anything with a leading underscore test("Bar.prototype={'_getFoo':function(){}," + "'getBar':function(){}};b._getFoo()", "Bar.prototype={'_getFoo':function(){}," + "'a':function(){}};b._getFoo()"); // Externed methods test("Bar.prototype={'toString':function(){}," + "'getBar':function(){}};b.toString()", "Bar.prototype={'toString':function(){}," + "'a':function(){}};b.toString()"); // don't rename a method to an existing (unrenamed) property test("Bar.prototype.foo=function(){}" + ";bar.foo();bar.a", "Bar.prototype.b=function(){}" + ";bar.b();bar.a"); } public void testRenamePrototypesWithGetOrSet() { // Simple // TODO(johnlenz): Enable these for after Rhino support is added. // test("Bar.prototype={get 'getFoo'(){}}", // "Bar.prototype={get a(){}}"); // test("Bar.prototype={get 2(){}}", // "Bar.prototype={get 2(){}}"); test("Bar.prototype={get getFoo(){}}", "Bar.prototype={get a(){}}"); test("Bar.prototype={get getFoo(){}}; a.getFoo;", "Bar.prototype={get a(){}}; a.a;"); // TODO(johnlenz): Enable these for after Rhino support is added. // test("Bar.prototype={set 'getFoo'(x){}}", // "Bar.prototype={set a(x){}}"); // test("Bar.prototype={set 2(x){}}", // "Bar.prototype={set 2(x){}}"); test("Bar.prototype={set getFoo(x){}}", "Bar.prototype={set a(x){}}"); test("Bar.prototype={set getFoo(x){}}; a.getFoo;", "Bar.prototype={set a(x){}}; a.a;"); // overlap test("Bar.prototype={get a(){}," + "get b(){}};b.b()", "Bar.prototype={get b(){}," + "get a(){}};b.a()"); } /** * Test renaming private properties (end with underscores) and test to make * sure we don't rename other properties. */ public void testRenameProperties() { test("var foo; foo.prop_='bar'", "var foo;foo.a='bar'"); test("this.prop_='bar'", "this.a='bar'"); test("this.prop='bar'", "this.prop='bar'"); test("this['prop_']='bar'", "this['a']='bar'"); test("this['prop']='bar'", "this['prop']='bar'"); test("var foo={prop1_: 'bar',prop2_: 'baz'};", "var foo={a:'bar',b:'baz'}"); } /** * Tests a potential tricky interaction between prototype renaming and * property renaming. */ public void testBoth() { test("Bar.prototype.getFoo_=function(){};Bar.getFoo_(b);" + "Bar.prototype.getBaz_=function(){}", "Bar.prototype.a=function(){};Bar.a(b);" + "Bar.prototype.b=function(){}"); } public void testPropertyNameThatIsBothObjLitKeyAndPrototypeProperty() { // This test protects against regression of a bug where non-private object // literal keys were getting renamed if they clashed with custom prototype // methods. Now we don't simply don't rename in this situation, since // references like z.myprop are ambiguous. test("x.prototype.myprop=function(){};y={myprop:0};z.myprop", "x.prototype.myprop=function(){};y={myprop:0};z.myprop"); // This test shows that a property can be renamed if both the prototype // property renaming policy and the objlit key renaming policy agree that // it can be renamed. test("x.prototype.myprop_=function(){};y={myprop_:0};z.myprop_", "x.prototype.a=function(){};y={a:0};z.a"); } public void testModule() { JSModule[] modules = createModules( "function Bar(){} var foo; Bar.prototype.getFoo_=function(x){};" + "foo.getFoo_(foo);foo.doo_=foo;foo.bloo_=foo;", "function Far(){} var too; Far.prototype.getGoo_=function(x){};" + "too.getGoo_(too);too.troo_=too;too.bloo_=too;"); test(modules, new String[] { "function Bar(){}var foo; Bar.prototype.a=function(x){};" + "foo.a(foo);foo.d=foo;foo.c=foo;", "function Far(){}var too; Far.prototype.b=function(x){};" + "too.b(too);too.e=too;too.c=too;" }); } public void testStableSimple1() { testStable( "Bar.prototype.getFoo=function(){};Bar.getFoo(b);" + "Bar.prototype.getBaz=function(){}", "Bar.prototype.a=function(){};Bar.a(b);" + "Bar.prototype.b=function(){}", "Bar.prototype.getBar=function(){};Bar.getBar(b);" + "Bar.prototype.getFoo=function(){};Bar.getFoo(b);" + "Bar.prototype.getBaz=function(){}", "Bar.prototype.c=function(){};Bar.c(b);" + "Bar.prototype.a=function(){};Bar.a(b);" + "Bar.prototype.b=function(){}"); } public void testStableSimple2() { testStable( "Bar.prototype['getFoo']=function(){};Bar.getFoo(b);" + "Bar.prototype['getBaz']=function(){}", "Bar.prototype['a']=function(){};Bar.a(b);" + "Bar.prototype['b']=function(){}", "Bar.prototype['getFoo']=function(){};Bar.getFoo(b);" + "Bar.prototype['getBar']=function(){};" + "Bar.prototype['getBaz']=function(){}", "Bar.prototype['a']=function(){};Bar.a(b);" + "Bar.prototype['c']=function(){};" + "Bar.prototype['b']=function(){}"); } public void testStableSimple3() { testStable( "Bar.prototype={'getFoo':function(){}," + "'getBar':function(){}};b.getFoo()", "Bar.prototype={'a':function(){}, 'b':function(){}};b.a()", "Bar.prototype={'getFoo':function(){}," + "'getBaz':function(){},'getBar':function(){}};b.getFoo()", "Bar.prototype={'a':function(){}, " + "'c':function(){}, 'b':function(){}};b.a()"); } public void testStableOverlap() { testStable( "Bar.prototype={'a':function(){},'b':function(){}};b.b()", "Bar.prototype={'b':function(){},'a':function(){}};b.a()", "Bar.prototype={'a':function(){},'b':function(){}};b.b()", "Bar.prototype={'b':function(){},'a':function(){}};b.a()"); } public void testStableTrickyExternedMethods() { test("Bar.prototype={'toString':function(){}," + "'getBar':function(){}};b.toString()", "Bar.prototype={'toString':function(){}," + "'a':function(){}};b.toString()"); prevUsedRenameMap = renamePrototypes.getPropertyMap(); String externs = EXTERNS + "prop.a;"; test(externs, "Bar.prototype={'toString':function(){}," + "'getBar':function(){}};b.toString()", "Bar.prototype={'toString':function(){}," + "'b':function(){}};b.toString()", null, null); } public void testStable(String input1, String expected1, String input2, String expected2) { test(input1, expected1); prevUsedRenameMap = renamePrototypes.getPropertyMap(); test(input2, expected2); } }
/* * Copyright 2005 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.common.collect.ImmutableMap; import com.google.javascript.rhino.Node; import java.util.*; /** * Tests for {@link RenameVars}. */ public class RenameVarsTest extends CompilerTestCase { private static final String DEFAULT_PREFIX = ""; private String prefix = DEFAULT_PREFIX; private VariableMap previouslyUsedMap = new VariableMap(ImmutableMap.<String, String>of()); private RenameVars renameVars; private boolean withClosurePass = false; private boolean localRenamingOnly = false; private boolean preserveFunctionExpressionNames = false; private boolean useGoogleCodingConvention = true; private boolean generatePseudoNames = false; private boolean shouldShadow = false; @Override protected CodingConvention getCodingConvention() { if (useGoogleCodingConvention) { return new GoogleCodingConvention(); } else { return CodingConventions.getDefault(); } } @Override protected CompilerPass getProcessor(Compiler compiler) { if (withClosurePass) { return new ClosurePassAndRenameVars(compiler); } else { return renameVars = new RenameVars(compiler, prefix, localRenamingOnly, preserveFunctionExpressionNames, generatePseudoNames, shouldShadow, previouslyUsedMap, null, null); } } @Override protected int getNumRepetitions() { return 1; } @Override protected void setUp() throws Exception { super.setUp(); previouslyUsedMap = new VariableMap(ImmutableMap.<String, String>of()); prefix = DEFAULT_PREFIX; withClosurePass = false; localRenamingOnly = false; preserveFunctionExpressionNames = false; generatePseudoNames = false; shouldShadow = false; // TODO(johnlenz): Enable Normalize during these tests. } public void testRenameSimple() { test("function Foo(v1, v2) {return v1;} Foo();", "function a(b, c) {return b;} a();"); } public void testRenameGlobals() { test("var Foo; var Bar, y; function x() { Bar++; }", "var a; var b, c; function d() { b++; }"); } public void testRenameLocals() { test("(function (v1, v2) {}); (function (v3, v4) {});", "(function (a, b) {}); (function (a, b) {});"); test("function f1(v1, v2) {}; function f2(v3, v4) {};", "function c(a, b) {}; function d(a, b) {};"); } public void testRenameRedeclaredGlobals() { test("function f1(v1, v2) {f1()};" + "/** @suppress {duplicate} */" + "function f1(v3, v4) {f1()};", "function a(b, c) {a()};" + "function a(b, c) {a()};"); localRenamingOnly = true; test("function f1(v1, v2) {f1()};" + "/** @suppress {duplicate} */" + "function f1(v3, v4) {f1()};", "function f1(a, b) {f1()};" + "function f1(a, b) {f1()};"); } public void testRecursiveFunctions1() { test("var walk = function walk(node, aFunction) {" + " walk(node, aFunction);" + "};", "var a = function a(b, c) {" + " a(b, c);" + "};"); localRenamingOnly = true; test("var walk = function walk(node, aFunction) {" + " walk(node, aFunction);" + "};", "var walk = function walk(a, b) {" + " walk(a, b);" + "};"); } public void testRecursiveFunctions2() { preserveFunctionExpressionNames = true; test("var walk = function walk(node, aFunction) {" + " walk(node, aFunction);" + "};", "var c = function walk(a, b) {" + " walk(a, b);" + "};"); localRenamingOnly = true; test("var walk = function walk(node, aFunction) {" + " walk(node, aFunction);" + "};", "var walk = function walk(a, b) {" + " walk(a, b);" + "};"); } public void testRenameLocalsClashingWithGlobals() { test("function a(v1, v2) {return v1;} a();", "function a(b, c) {return b;} a();"); } public void testRenameNested() { test("function f1(v1, v2) { (function(v3, v4) {}) }", "function a(b, c) { (function(d, e) {}) }"); test("function f1(v1, v2) { function f2(v3, v4) {} }", "function a(b, c) { function d(e, f) {} }"); } public void testBleedingRecursiveFunctions1() { // On IE, bleeding functions will interfere with each other if // they are in the same scope. In the below example, we want to be // sure that a and b get separate names. test("var x = function a(x) { return x ? 1 : a(1); };" + "var y = function b(x) { return x ? 2 : b(2); };", "var c = function b(a) { return a ? 1 : b(1); };" + "var e = function d(a) { return a ? 2 : d(2); };"); } public void testBleedingRecursiveFunctions2() { test("function f() {" + " var x = function a(x) { return x ? 1 : a(1); };" + " var y = function b(x) { return x ? 2 : b(2); };" + "}", "function d() {" + " var e = function b(a) { return a ? 1 : b(1); };" + " var f = function a(c) { return c ? 2 : a(2); };" + "}"); } public void testBleedingRecursiveFunctions3() { test("function f() {" + " var x = function a(x) { return x ? 1 : a(1); };" + " var y = function b(x) { return x ? 2 : b(2); };" + " var z = function c(x) { return x ? y : c(2); };" + "}", "function f() {" + " var g = function c(a) { return a ? 1 : c(1); };" + " var d = function a(b) { return b ? 2 : a(2); };" + " var h = function b(e) { return e ? d : b(2); };" + "}"); } public void testRenameWithExterns1() { String externs = "var foo;"; test(externs, "var bar; foo(bar);", "var a; foo(a);", null, null); } public void testRenameWithExterns2() { String externs = "var a;"; test(externs, "var b = 5", "var b = 5", null, null); } public void testDoNotRenameExportedName() { test("_foo()", "_foo()"); } public void testRenameWithNameOverlap() { test("var a = 1; var b = 2; b + b;", "var a = 1; var b = 2; b + b;"); } public void testRenameWithPrefix1() { prefix = "PRE_"; test("function Foo(v1, v2) {return v1} Foo();", "function PRE_(a, b) {return a} PRE_();"); prefix = DEFAULT_PREFIX; } public void testRenameWithPrefix2() { prefix = "PRE_"; test("function Foo(v1, v2) {var v3 = v1 + v2; return v3;} Foo();", "function PRE_(a, b) {var c = a + b; return c;} PRE_();"); prefix = DEFAULT_PREFIX; } public void testRenameWithPrefix3() { prefix = "a"; test("function Foo() {return 1;}" + "function Bar() {" + " var a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z," + " A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,aa,ab;" + " Foo();" + "} Bar();", "function a() {return 1;}" + "function aa() {" + " var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A," + " B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,$,ba,ca;" + " a();" + "} aa();"); prefix = DEFAULT_PREFIX; } public void testNamingBasedOnOrderOfOccurrence() { test("var q,p,m,n,l,k; " + "(function (r) {}); try { } catch(s) {}; var t = q + q;", "var a,b,c,d,e,f; " + "(function(g) {}); try { } catch(h) {}; var i = a + a;" ); test("(function(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z," + "a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,$){});" + "var a4,a3,a2,a1,b4,b3,b2,b1,ab,ac,ad,fg;function foo(){};", "(function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z," + "A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,$){});" + "var aa,ba,ca,da,ea,fa,ga,ha,ia,ja,ka,la;function ma(){};"); } public void testStableRenameSimple() { VariableMap expectedVariableMap = makeVariableMap( "Foo", "a", "L 0", "b", "L 1", "c"); testRenameMap("function Foo(v1, v2) {return v1;} Foo();", "function a(b, c) {return b;} a();", expectedVariableMap); expectedVariableMap = makeVariableMap( "Foo", "a", "L 0", "b", "L 1", "c", "L 2", "d"); testRenameMapUsingOldMap("function Foo(v1, v2, v3) {return v1;} Foo();", "function a(b, c, d) {return b;} a();", expectedVariableMap); } public void testStableRenameGlobals() { VariableMap expectedVariableMap = makeVariableMap( "Foo", "a", "Bar", "b", "y", "c", "x", "d"); testRenameMap("var Foo; var Bar, y; function x() { Bar++; }", "var a; var b, c; function d() { b++; }", expectedVariableMap); expectedVariableMap = makeVariableMap( "Foo", "a", "Bar", "b", "y", "c", "x", "d", "Baz", "f", "L 0" , "e"); testRenameMapUsingOldMap( "var Foo, Baz; var Bar, y; function x(R) { return R + Bar++; }", "var a, f; var b, c; function d(e) { return e + b++; }", expectedVariableMap); } public void testStableRenameWithPointlesslyAnonymousFunctions() { VariableMap expectedVariableMap = makeVariableMap("L 0", "a", "L 1", "b"); testRenameMap("(function (v1, v2) {}); (function (v3, v4) {});", "(function (a, b) {}); (function (a, b) {});", expectedVariableMap); expectedVariableMap = makeVariableMap("L 0", "a", "L 1", "b", "L 2", "c"); testRenameMapUsingOldMap("(function (v0, v1, v2) {});" + "(function (v3, v4) {});", "(function (a, b, c) {});" + "(function (a, b) {});", expectedVariableMap); } public void testStableRenameLocalsClashingWithGlobals() { test("function a(v1, v2) {return v1;} a();", "function a(b, c) {return b;} a();"); previouslyUsedMap = renameVars.getVariableMap(); test("function bar(){return;}function a(v1, v2) {return v1;} a();", "function d(){return;}function a(b, c) {return b;} a();"); } public void testStableRenameNested() { VariableMap expectedVariableMap = makeVariableMap( "f1", "a", "L 0", "b", "L 1", "c", "L 2", "d", "L 3", "e"); testRenameMap("function f1(v1, v2) { (function(v3, v4) {}) }", "function a(b, c) { (function(d, e) {}) }", expectedVariableMap); expectedVariableMap = makeVariableMap( "f1", "a", "L 0", "b", "L 1", "c", "L 2", "d", "L 3", "e", "L 4", "f"); testRenameMapUsingOldMap( "function f1(v1, v2) { (function(v3, v4, v5) {}) }", "function a(b, c) { (function(d, e, f) {}) }", expectedVariableMap); } public void testStableRenameWithExterns1() { String externs = "var foo;"; test(externs, "var bar; foo(bar);", "var a; foo(a);", null, null); previouslyUsedMap = renameVars.getVariableMap(); test(externs, "var bar, baz; foo(bar, baz);", "var a, b; foo(a, b);", null, null); } public void testStableRenameWithExterns2() { String externs = "var a;"; test(externs, "var b = 5", "var b = 5", null, null); previouslyUsedMap = renameVars.getVariableMap(); test(externs, "var b = 5, catty = 9;", "var b = 5, c=9;", null, null); } public void testStableRenameWithNameOverlap() { test("var a = 1; var b = 2; b + b;", "var a = 1; var b = 2; b + b;"); previouslyUsedMap = renameVars.getVariableMap(); test("var a = 1; var c, b = 2; b + b;", "var a = 1; var c, b = 2; b + b;"); } public void testStableRenameWithAnonymousFunctions() { VariableMap expectedVariableMap = makeVariableMap("L 0", "a", "foo", "b"); testRenameMap("function foo(bar){return bar;}foo(function(h){return h;});", "function b(a){return a}b(function(a){return a;})", expectedVariableMap); expectedVariableMap = makeVariableMap("foo", "b", "L 0", "a", "L 1", "c"); testRenameMapUsingOldMap( "function foo(bar) {return bar;}foo(function(g,h) {return g+h;});", "function b(a){return a}b(function(a,c){return a+c;})", expectedVariableMap); } public void testStableRenameSimpleExternsChanges() { VariableMap expectedVariableMap = makeVariableMap( "Foo", "a", "L 0", "b", "L 1", "c"); testRenameMap("function Foo(v1, v2) {return v1;} Foo();", "function a(b, c) {return b;} a();", expectedVariableMap); expectedVariableMap = makeVariableMap("L 0", "b", "L 1", "c", "L 2", "a"); String externs = "var Foo;"; testRenameMapUsingOldMap(externs, "function Foo(v1, v2, v0) {return v1;} Foo();", "function Foo(b, c, a) {return b;} Foo();", expectedVariableMap); } public void testStableRenameSimpleLocalNameExterned() { test("function Foo(v1, v2) {return v1;} Foo();", "function a(b, c) {return b;} a();"); previouslyUsedMap = renameVars.getVariableMap(); String externs = "var b;"; test(externs, "function Foo(v1, v2) {return v1;} Foo(b);", "function a(d, c) {return d;} a(b);", null, null); } public void testStableRenameSimpleGlobalNameExterned() { test("function Foo(v1, v2) {return v1;} Foo();", "function a(b, c) {return b;} a();"); previouslyUsedMap = renameVars.getVariableMap(); String externs = "var Foo;"; test(externs, "function Foo(v1, v2, v0) {return v1;} Foo();", "function Foo(b, c, a) {return b;} Foo();", null, null); } public void testStableRenameWithPrefix1AndUnstableLocalNames() { prefix = "PRE_"; test("function Foo(v1, v2) {return v1} Foo();", "function PRE_(a, b) {return a} PRE_();"); previouslyUsedMap = renameVars.getVariableMap(); prefix = "PRE_"; test("function Foo(v0, v1, v2) {return v1} Foo();", "function PRE_(a, b, c) {return b} PRE_();"); } public void testStableRenameWithPrefix2() { prefix = "a"; test("function Foo() {return 1;}" + "function Bar() {" + " var a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z," + " A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,aa,ab;" + " Foo();" + "} Bar();", "function a() {return 1;}" + "function aa() {" + " var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A," + " B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,$,ba,ca;" + " a();" + "} aa();"); previouslyUsedMap = renameVars.getVariableMap(); prefix = "a"; test("function Foo() {return 1;}" + "function Baz() {return 1;}" + "function Bar() {" + " var a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z," + " A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,aa,ab;" + " Foo();" + "} Bar();", "function a() {return 1;}" + "function ab() {return 1;}" + "function aa() {" + " var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A," + " B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,$,ba,ca;" + " a();" + "} aa();"); } public void testContrivedExampleWhereConsistentRenamingIsWorse() { previouslyUsedMap = makeVariableMap( "Foo", "LongString", "L 0", "b", "L 1", "c"); test("function Foo(v1, v2) {return v1;} Foo();", "function LongString(b, c) {return b;} LongString();"); previouslyUsedMap = renameVars.getVariableMap(); VariableMap expectedVariableMap = makeVariableMap( "Foo", "LongString", "L 0", "b", "L 1", "c"); assertVariableMapsEqual(expectedVariableMap, previouslyUsedMap); } public void testExportSimpleSymbolReservesName() { test("var goog, x; goog.exportSymbol('a', x);", "var a, b; a.exportSymbol('a', b);"); withClosurePass = true; test("var goog, x; goog.exportSymbol('a', x);", "var b, c; b.exportSymbol('a', c);"); } public void testExportComplexSymbolReservesName() { test("var goog, x; goog.exportSymbol('a.b', x);", "var a, b; a.exportSymbol('a.b', b);"); withClosurePass = true; test("var goog, x; goog.exportSymbol('a.b', x);", "var b, c; b.exportSymbol('a.b', c);"); } public void testExportToNonStringDoesntExplode() { withClosurePass = true; test("var goog, a, b; goog.exportSymbol(a, b);", "var a, b, c; a.exportSymbol(b, c);"); } public void testDollarSignSuperExport1() { useGoogleCodingConvention = false; // See http://code.google.com/p/closure-compiler/issues/detail?id=32 test("var x = function($super,duper,$fantastic){}", "var c = function($super, a, b){}"); localRenamingOnly = false; test("var $super = 1", "var a = 1"); useGoogleCodingConvention = true; test("var x = function($super,duper,$fantastic){}", "var c = function($super,a,b){}"); } public void testDollarSignSuperExport2() { boolean normalizedExpectedJs = false; super.enableNormalize(false); useGoogleCodingConvention = false; // See http://code.google.com/p/closure-compiler/issues/detail?id=32 test("var x = function($super,duper,$fantastic){};" + "var y = function($super,duper){};", "var c = function($super, a, b){};" + "var d = function($super, a){};"); localRenamingOnly = false; test("var $super = 1", "var a = 1"); useGoogleCodingConvention = true; test("var x = function($super,duper,$fantastic){};" + "var y = function($super,duper){};", "var c = function($super, a, b ){};" + "var d = function($super,a){};"); super.disableNormalize(); } public void testPseudoNames() { generatePseudoNames = false; // See http://code.google.com/p/closure-compiler/issues/detail?id=32 test("var foo = function(a, b, c){}", "var d = function(a, b, c){}"); generatePseudoNames = true; test("var foo = function(a, b, c){}", "var $foo$$ = function($a$$, $b$$, $c$$){}"); test("var a = function(a, b, c){}", "var $a$$ = function($a$$, $b$$, $c$$){}"); } private void testRenameMapUsingOldMap(String input, String expected, VariableMap expectedMap) { previouslyUsedMap = renameVars.getVariableMap(); testRenameMap("", input, expected, expectedMap); } private void testRenameMapUsingOldMap(String externs, String input, String expected, VariableMap expectedMap) { previouslyUsedMap = renameVars.getVariableMap(); testRenameMap(externs, input, expected, expectedMap); } private void testRenameMap(String input, String expected, VariableMap expectedRenameMap) { testRenameMap("", input, expected, expectedRenameMap); } private void testRenameMap(String externs, String input, String expected, VariableMap expectedRenameMap) { test(externs, input, expected, null, null); VariableMap renameMap = renameVars.getVariableMap(); assertVariableMapsEqual(expectedRenameMap, renameMap); } private VariableMap makeVariableMap(String... keyValPairs) { Preconditions.checkArgument(keyValPairs.length % 2 == 0); ImmutableMap.Builder<String, String> renameMap = ImmutableMap.builder(); for (int i = 0; i < keyValPairs.length; i += 2) { renameMap.put(keyValPairs[i], keyValPairs[i + 1]); } return new VariableMap(renameMap.build()); } private static void assertVariableMapsEqual(VariableMap a, VariableMap b) { Map<String, String> ma = a.getOriginalNameToNewNameMap(); Map<String, String> mb = b.getOriginalNameToNewNameMap(); assertEquals("VariableMaps not equal", ma, mb); } private class ClosurePassAndRenameVars implements CompilerPass { private final Compiler compiler; private ClosurePassAndRenameVars(Compiler compiler) { this.compiler = compiler; } @Override public void process(Node externs, Node root) { ProcessClosurePrimitives closurePass = new ProcessClosurePrimitives( compiler, null, CheckLevel.WARNING); closurePass.process(externs, root); renameVars = new RenameVars(compiler, prefix, false, false, false, false, previouslyUsedMap, null, closurePass.getExportedVariableNames()); renameVars.process(externs, root); } } }
/* * Copyright 2011 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Unit test for {@ReorderConstantExpression} * */ public class ReorderConstantExpressionTest extends CompilerTestCase { @Override protected CompilerPass getProcessor(final Compiler compiler) { return new PeepholeOptimizationsPass(compiler, new ReorderConstantExpression()); } @Override protected void setUp() throws Exception { super.setUp(); super.enableLineNumberCheck(true); disableTypeCheck(); } public void testSymmetricOperations() throws Exception { set1Tests("=="); set2Tests("=="); set3Tests("=="); set1Tests("!="); set2Tests("!="); set3Tests("!="); set1Tests("==="); set2Tests("==="); set3Tests("==="); set1Tests("!=="); set2Tests("!=="); set3Tests("!=="); set1Tests("*"); set2Tests("*"); set3Tests("*"); } public void testRelationalOperations() throws Exception { set1Tests(">", "<"); set3Tests(">"); set1Tests("<", ">"); set3Tests("<"); set1Tests(">=", "<="); set3Tests(">="); set1Tests("<=", ">="); set3Tests("<="); } private void set1Tests(String op) throws Exception { set1Tests(op, op); } /** * This set has a mutable on the right and an Immutable on the left. * Applies for relational and symmetric operations. */ private void set1Tests(String op1, String op2) throws Exception { test("a " + op1 + " 0", "0 " + op2 + " a"); test("a " + op1 + " '0'", "'0' " + op2 + " a"); test("a " + op1 + " ''", "'' " + op2 + " a"); test("a " + op1 + " -1.0", "-1.0 " + op2 + " a"); test("function f(a){a " + op1 + " 0}", "function f(a){0 " + op2 + " a}"); test("f() " + op1 + " 0", "0 " + op2 + " f()"); test("(a + b) " + op1 + " 0", "0 " + op2 + " (a + b)"); test("(a + 1) " + op1 + " 0", "0 " + op2 + " (a + 1)"); test("x++ " + op1 + " 0", "0 " + op2 + " x++"); test("x = 0; function f(){x++; return x}; f() " + op1 + " 0", "x = 0; function f(){x++; return x}; 0 " + op2 + " f()"); } /** * This set has a mutable on the right and an Immutable on the left. * Applies only for symmetric operations. */ private void set2Tests(String op) throws Exception { test("a " + op + " NaN", "NaN " + op + " a"); test("a " + op + " Infinity", "Infinity " + op + " a"); testSame("NaN " + op + " a"); testSame("Infinity " + op + " a"); } /** * This set has an the immutable on the left already, or both non-immutable. */ private void set3Tests(String op) throws Exception { testSame("0 " + op + " a"); testSame("'0' " + op + " a"); testSame("'' " + op + " a"); testSame("-1.0 " + op + " a"); testSame("-1.0 " + op + " a"); testSame("0 " + op + " 1"); testSame("a " + op + " b"); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import static com.google.javascript.jscomp.ReplaceCssNames.UNEXPECTED_STRING_LITERAL_ERROR; import static com.google.javascript.jscomp.ReplaceCssNames.UNKNOWN_SYMBOL_WARNING; import com.google.common.collect.ImmutableMap; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Maps; import com.google.javascript.rhino.Node; import java.util.Map; import java.util.Set; /** * Tests for ReplaceCssNames.java. * */ public class ReplaceCssNamesTest extends CompilerTestCase { /** Whether to pass the map of replacements as opposed to null */ boolean useReplacementMap; /** Map of replacements to use during the test. */ Map<String, String> replacementMap = new ImmutableMap.Builder<String, String>() .put("active", "a") .put("buttonbar", "b") .put("colorswatch", "c") .put("disabled", "d") .put("elephant", "e") .put("footer", "f") .put("goog", "g") .build(); Map<String, String> replacementMapFull = new ImmutableMap.Builder<String, String>() .put("long-prefix", "h") .put("suffix1", "i") .put("unrelated-word", "k") .put("unrelated", "l") .put("long-suffix", "m") .put("long-prefix-suffix1", "h-i") .build(); CssRenamingMap renamingMap; Set<String> whitelist; Map<String, Integer> cssNames; public ReplaceCssNamesTest() { } @Override protected CompilerPass getProcessor(Compiler compiler) { return new ReplaceCssNames(compiler, cssNames, whitelist) { @Override protected CssRenamingMap getCssRenamingMap() { return useReplacementMap ? renamingMap : null; } }; } protected CssRenamingMap getPartialMap() { CssRenamingMap map = new CssRenamingMap.ByPart() { @Override public String get(String value) { return replacementMap.get(value); } }; return map; } protected CssRenamingMap getFullMap() { return new CssRenamingMap.ByWhole() { @Override public String get(String value) { return replacementMapFull.get(value); } }; } @Override protected void setUp() throws Exception { super.setUp(); super.enableLineNumberCheck(true); cssNames = Maps.newHashMap(); useReplacementMap = true; renamingMap = getPartialMap(); } @Override protected int getNumRepetitions() { // The first pass strips the goog.getCssName even if a warning is issued, // such that a subsequent pass won't issue a warning. return 1; } public void testDoNotUseReplacementMap() { useReplacementMap = false; test("var x = goog.getCssName('goog-footer-active')", "var x = 'goog-footer-active'"); test("el.className = goog.getCssName('goog-colorswatch-disabled')", "el.className = 'goog-colorswatch-disabled'"); test("setClass(goog.getCssName('active-buttonbar'))", "setClass('active-buttonbar')"); Map<String, Integer> expected = new ImmutableMap.Builder<String, Integer>() .put("goog", 2) .put("footer", 1) .put("active", 2) .put("colorswatch", 1) .put("disabled", 1) .put("buttonbar", 1) .build(); assertEquals(expected, cssNames); } public void testOneArgWithUnknownStringLiterals() { test("var x = goog.getCssName('unknown')", "var x = 'unknown'", null, UNKNOWN_SYMBOL_WARNING); test("el.className = goog.getCssName('ooo')", "el.className = 'ooo'", null, UNKNOWN_SYMBOL_WARNING); test("setClass(goog.getCssName('ab'))", "setClass('ab')", null, UNKNOWN_SYMBOL_WARNING); } public void testOneArgWithSimpleStringLiterals() { test("var x = goog.getCssName('buttonbar')", "var x = 'b'"); test("el.className = goog.getCssName('colorswatch')", "el.className = 'c'"); test("setClass(goog.getCssName('elephant'))", "setClass('e')"); Map<String, Integer> expected = new ImmutableMap.Builder<String, Integer>() .put("buttonbar", 1) .put("colorswatch", 1) .put("elephant", 1) .build(); assertEquals(expected, cssNames); } public void testOneArgWithCompositeClassNames() { test("var x = goog.getCssName('goog-footer-active')", "var x = 'g-f-a'"); test("el.className = goog.getCssName('goog-colorswatch-disabled')", "el.className = 'g-c-d'"); test("setClass(goog.getCssName('active-buttonbar'))", "setClass('a-b')"); Map<String, Integer> expected = new ImmutableMap.Builder<String, Integer>() .put("goog", 2) .put("footer", 1) .put("active", 2) .put("colorswatch", 1) .put("disabled", 1) .put("buttonbar", 1) .build(); assertEquals(expected, cssNames); } public void testOneArgWithCompositeClassNamesFull() { renamingMap = getFullMap(); test("var x = goog.getCssName('long-prefix')", "var x = 'h'"); test("var x = goog.getCssName('long-prefix-suffix1')", "var x = 'h-i'"); test("var x = goog.getCssName('unrelated')", "var x = 'l'"); test("var x = goog.getCssName('unrelated-word')", "var x = 'k'"); } public void testOneArgWithCompositeClassNamesWithUnknownParts() { test("var x = goog.getCssName('goog-header-active')", "var x = 'goog-header-active'", null, UNKNOWN_SYMBOL_WARNING); test("el.className = goog.getCssName('goog-colorswatch-focussed')", "el.className = 'goog-colorswatch-focussed'", null, UNKNOWN_SYMBOL_WARNING); test("setClass(goog.getCssName('inactive-buttonbar'))", "setClass('inactive-buttonbar')", null, UNKNOWN_SYMBOL_WARNING); } public void testTwoArgsWithStringLiterals() { test("var x = goog.getCssName('header', 'active')", null, UNEXPECTED_STRING_LITERAL_ERROR); test("el.className = goog.getCssName('footer', window)", null, ReplaceCssNames.STRING_LITERAL_EXPECTED_ERROR); test("setClass(goog.getCssName('buttonbar', 'disabled'))", null, UNEXPECTED_STRING_LITERAL_ERROR); test("setClass(goog.getCssName(goog.getCssName('buttonbar'), 'active'))", null, UNEXPECTED_STRING_LITERAL_ERROR); } public void testTwoArsWithVariableFirstArg() { test("var x = goog.getCssName(baseClass, 'active')", "var x = baseClass + '-a'"); test("el.className = goog.getCssName(this.getClass(), 'disabled')", "el.className = this.getClass() + '-d'"); test("setClass(goog.getCssName(BASE_CLASS, 'disabled'))", "setClass(BASE_CLASS + '-d')"); } public void testTwoArgsWithVariableFirstArgFull() { renamingMap = getFullMap(); test("var x = goog.getCssName(baseClass, 'long-suffix')", "var x = baseClass + '-m'"); } public void testZeroArguments() { test("goog.getCssName()", null, ReplaceCssNames.INVALID_NUM_ARGUMENTS_ERROR); } public void testManyArguments() { test("goog.getCssName('a', 'b', 'c')", null, ReplaceCssNames.INVALID_NUM_ARGUMENTS_ERROR); test("goog.getCssName('a', 'b', 'c', 'd')", null, ReplaceCssNames.INVALID_NUM_ARGUMENTS_ERROR); test("goog.getCssName('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i')", null, ReplaceCssNames.INVALID_NUM_ARGUMENTS_ERROR); } public void testNonStringArgument() { test("goog.getCssName(window);", null, ReplaceCssNames.STRING_LITERAL_EXPECTED_ERROR); test("goog.getCssName(555);", null, ReplaceCssNames.STRING_LITERAL_EXPECTED_ERROR); test("goog.getCssName([]);", null, ReplaceCssNames.STRING_LITERAL_EXPECTED_ERROR); test("goog.getCssName({});", null, ReplaceCssNames.STRING_LITERAL_EXPECTED_ERROR); test("goog.getCssName(null);", null, ReplaceCssNames.STRING_LITERAL_EXPECTED_ERROR); test("goog.getCssName(undefined);", null, ReplaceCssNames.STRING_LITERAL_EXPECTED_ERROR); test("goog.getCssName(baseClass, window);", null, ReplaceCssNames.STRING_LITERAL_EXPECTED_ERROR); test("goog.getCssName(baseClass, 555);", null, ReplaceCssNames.STRING_LITERAL_EXPECTED_ERROR); test("goog.getCssName(baseClass, []);", null, ReplaceCssNames.STRING_LITERAL_EXPECTED_ERROR); test("goog.getCssName(baseClass, {});", null, ReplaceCssNames.STRING_LITERAL_EXPECTED_ERROR); test("goog.getCssName(baseClass, null);", null, ReplaceCssNames.STRING_LITERAL_EXPECTED_ERROR); test("goog.getCssName(baseClass, undefined);", null, ReplaceCssNames.STRING_LITERAL_EXPECTED_ERROR); test("goog.getCssName('foo', 3);", null, ReplaceCssNames.STRING_LITERAL_EXPECTED_ERROR); } public void testNoSymbolMapStripsCallAndDoesntIssueWarnings() { String input = "[goog.getCssName('test'), goog.getCssName(base, 'active')]"; Compiler compiler = new Compiler(); ErrorManager errorMan = new BasicErrorManager() { @Override protected void printSummary() {} @Override public void println(CheckLevel level, JSError error) {} }; compiler.setErrorManager(errorMan); Node root = compiler.parseTestCode(input); useReplacementMap = false; ReplaceCssNames replacer = new ReplaceCssNames(compiler, null, null); replacer.process(null, root); assertEquals("[\"test\",base+\"-active\"]", compiler.toSource(root)); assertEquals("There should be no errors", 0, errorMan.getErrorCount()); assertEquals("There should be no warnings", 0, errorMan.getWarningCount()); } public void testWhitelistByPart() { whitelist = ImmutableSet.<String>of("goog", "elephant"); test("var x = goog.getCssName('goog')", "var x = 'goog'"); test("var x = goog.getCssName('elephant')", "var x = 'elephant'"); // Whitelisting happens before splitting, not after. test("var x = goog.getCssName('goog-elephant')", "var x = 'g-e'"); } public void testWhitelistByWhole() { whitelist = ImmutableSet.<String>of("long-prefix"); renamingMap = getFullMap(); test("var x = goog.getCssName('long-prefix')", "var x = 'long-prefix'"); } public void testWhitelistWithDashes() { whitelist = ImmutableSet.<String>of("goog-elephant"); test("var x = goog.getCssName('goog')", "var x = 'g'"); test("var x = goog.getCssName('elephant')", "var x = 'e'"); test("var x = goog.getCssName('goog-elephant')", "var x = 'goog-elephant'"); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.ImmutableSet; /** * Tests for {@link ReplaceIdGenerators}. * */ public class ReplaceIdGeneratorsTest extends CompilerTestCase { private boolean generatePseudoNames = false; private ReplaceIdGenerators lastPass = null; private String previousMappings = null; @Override protected CompilerPass getProcessor(final Compiler compiler) { lastPass = new ReplaceIdGenerators( compiler, new ImmutableSet.Builder<String>() .add("goog.events.getUniqueId") .add("goog.place.getUniqueId") .build(), generatePseudoNames, previousMappings); return lastPass; } @Override protected void setUp() throws Exception { super.setUp(); generatePseudoNames = false; previousMappings = null; } @Override protected int getNumRepetitions() { return 1; } public void testBackwardCompat() { test("foo.bar = goog.events.getUniqueId('foo_bar')", "foo.bar = 'a'", "foo.bar = 'foo_bar$0'"); } public void testSerialization1() { testMap("var x = goog.events.getUniqueId('xxx');\n" + "var y = goog.events.getUniqueId('yyy');\n", "var x = 'a';\n" + "var y = 'b';\n", "[goog.events.getUniqueId]\n" + "\n" + "a:testcode:1:32\n" + "b:testcode:2:32\n" + "\n"); } public void testSerialization2() { testMap("/** @consistentIdGenerator */ id = function() {};" + "f1 = id('f1');" + "f1 = id('f1')", "id = function() {};" + "f1 = 'a';" + "f1 = 'a'", "[id]\n" + "\n" + "a:f1\n" + "\n"); } public void testReusePreviousSerialization1() { previousMappings = "[goog.events.getUniqueId]\n" + "\n" + "previous1:testcode:1:32\n" + "previous2:testcode:2:32\n" + "\n" + "[goog.place.getUniqueId]\n" + "\n" + "\n"; testMap("var x = goog.events.getUniqueId('xxx');\n" + "var y = goog.events.getUniqueId('yyy');\n", "var x = 'previous1';\n" + "var y = 'previous2';\n", "[goog.events.getUniqueId]\n" + "\n" + "previous1:testcode:1:32\n" + "previous2:testcode:2:32\n" + "\n"); } public void testReusePreviousSerialization2() { previousMappings = "[goog.events.getUniqueId]\n" + "\n" + "a:testcode:1:32\n" + "b:testcode:2:32\n" + "\n" + "[goog.place.getUniqueId]\n" + "\n" + "\n"; testMap( "var x = goog.events.getUniqueId('xxx');\n" + "\n" + // new line to change location "var y = goog.events.getUniqueId('yyy');\n", "var x = 'a';\n" + "var y = 'c';\n", "[goog.events.getUniqueId]\n" + "\n" + "a:testcode:1:32\n" + "c:testcode:3:32\n" + "\n"); } public void testReusePreviousSerializationConsistent1() { previousMappings = "[id]\n" + "\n" + "a:f1\n" + "\n"; testMap( "/** @consistentIdGenerator */ id = function() {};" + "f1 = id('f1');" + "f1 = id('f1')", "id = function() {};" + "f1 = 'a';" + "f1 = 'a'", "[id]\n" + "\n" + "a:f1\n" + "\n"); } public void testSimple() { test("/** @idGenerator */ foo.getUniqueId = function() {};" + "foo.bar = foo.getUniqueId('foo_bar')", "foo.getUniqueId = function() {};" + "foo.bar = 'a'", "foo.getUniqueId = function() {};" + "foo.bar = 'foo_bar$0'"); test("/** @idGenerator */ goog.events.getUniqueId = function() {};" + "foo1 = goog.events.getUniqueId('foo1');" + "foo1 = goog.events.getUniqueId('foo1');", "goog.events.getUniqueId = function() {};" + "foo1 = 'a';" + "foo1 = 'b';", "goog.events.getUniqueId = function() {};" + "foo1 = 'foo1$0';" + "foo1 = 'foo1$1';"); } public void testSimpleConsistent() { test("/** @consistentIdGenerator */ id = function() {};" + "foo.bar = id('foo_bar')", "id = function() {};" + "foo.bar = 'a'", "id = function() {};" + "foo.bar = 'foo_bar$0'"); test("/** @consistentIdGenerator */ id = function() {};" + "f1 = id('f1');" + "f1 = id('f1')", "id = function() {};" + "f1 = 'a';" + "f1 = 'a'", "id = function() {};" + "f1 = 'f1$0';" + "f1 = 'f1$0'"); test("/** @consistentIdGenerator */ id = function() {};" + "f1 = id('f1');" + "f1 = id('f1');" + "f1 = id('f1')", "id = function() {};" + "f1 = 'a';" + "f1 = 'a';" + "f1 = 'a'", "id = function() {};" + "f1 = 'f1$0';" + "f1 = 'f1$0';" + "f1 = 'f1$0'"); } public void testSimpleStable() { testNonPseudoSupportingGenerator( "/** @stableIdGenerator */ id = function() {};" + "foo.bar = id('foo_bar')", "id = function() {};" + "foo.bar = '125lGg'"); testNonPseudoSupportingGenerator( "/** @stableIdGenerator */ id = function() {};" + "f1 = id('f1');" + "f1 = id('f1')", "id = function() {};" + "f1 = 'AAAMiw';" + "f1 = 'AAAMiw'"); } public void testVar() { test("/** @consistentIdGenerator */ var id = function() {};" + "foo.bar = id('foo_bar')", "var id = function() {};" + "foo.bar = 'a'", "var id = function() {};" + "foo.bar = 'foo_bar$0'"); testNonPseudoSupportingGenerator( "/** @stableIdGenerator */ var id = function() {};" + "foo.bar = id('foo_bar')", "var id = function() {};" + "foo.bar = '125lGg'"); } public void testObjLit() { test("/** @consistentIdGenerator */ get.id = function() {};" + "foo.bar = {a: get.id('foo_bar')}", "get.id = function() {};" + "foo.bar = {a: 'a'}", "get.id = function() {};" + "foo.bar = {a: 'foo_bar$0'}"); testNonPseudoSupportingGenerator( "/** @stableIdGenerator */ get.id = function() {};" + "foo.bar = {a: get.id('foo_bar')}", "get.id = function() {};" + "foo.bar = {a: '125lGg'}"); } public void testTwoGenerators() { test("/** @idGenerator */ var id1 = function() {};" + "/** @idGenerator */ var id2 = function() {};" + "f1 = id1('1');" + "f2 = id1('1');" + "f3 = id2('1');" + "f4 = id2('1');", "var id1 = function() {};" + "var id2 = function() {};" + "f1 = 'a';" + "f2 = 'b';" + "f3 = 'a';" + "f4 = 'b';", "var id1 = function() {};" + "var id2 = function() {};" + "f1 = '1$0';" + "f2 = '1$1';" + "f3 = '1$0';" + "f4 = '1$1';"); } public void testMixedGenerators() { test("/** @idGenerator */ var id1 = function() {};" + "/** @consistentIdGenerator */ var id2 = function() {};" + "/** @stableIdGenerator */ var id3 = function() {};" + "f1 = id1('1');" + "f2 = id1('1');" + "f3 = id2('1');" + "f4 = id2('1');" + "f5 = id3('1');" + "f6 = id3('1');", "var id1 = function() {};" + "var id2 = function() {};" + "var id3 = function() {};" + "f1 = 'a';" + "f2 = 'b';" + "f3 = 'a';" + "f4 = 'a';" + "f5 = 'AAAAMQ';" + "f6 = 'AAAAMQ';", "var id1 = function() {};" + "var id2 = function() {};" + "var id3 = function() {};" + "f1 = '1$0';" + "f2 = '1$1';" + "f3 = '1$0';" + "f4 = '1$0';" + "f5 = 'AAAAMQ';" + "f6 = 'AAAAMQ';"); } public void testLocalCall() { testSame(new String[] {"/** @idGenerator */ var id = function() {}; " + "function Foo() { id('foo'); }"}, ReplaceIdGenerators.NON_GLOBAL_ID_GENERATOR_CALL); } public void testConditionalCall() { testSame(new String[] {"/** @idGenerator */ var id = function() {}; " + "if(x) id('foo');"}, ReplaceIdGenerators.CONDITIONAL_ID_GENERATOR_CALL); test("/** @consistentIdGenerator */ var id = function() {};" + "function fb() {foo.bar = id('foo_bar')}", "var id = function() {};" + "function fb() {foo.bar = 'a'}", "var id = function() {};" + "function fb() {foo.bar = 'foo_bar$0'}"); testNonPseudoSupportingGenerator( "/** @stableIdGenerator */ var id = function() {};" + "function fb() {foo.bar = id('foo_bar')}", "var id = function() {};" + "function fb() {foo.bar = '125lGg'}"); } public void testConflictingIdGenerator() { testSame(new String[] {"/** @idGenerator \n @consistentIdGenerator \n*/" + "var id = function() {}; "}, ReplaceIdGenerators.CONFLICTING_GENERATOR_TYPE); testSame(new String[] {"/** @stableIdGenerator \n @idGenerator \n*/" + "var id = function() {}; "}, ReplaceIdGenerators.CONFLICTING_GENERATOR_TYPE); testSame(new String[] {"/** @stableIdGenerator \n @consistentIdGenerator \n*/" + "var id = function() {}; "}, ReplaceIdGenerators.CONFLICTING_GENERATOR_TYPE); test("/** @consistentIdGenerator */ var id = function() {};" + "if (x) {foo.bar = id('foo_bar')}", "var id = function() {};" + "if (x) {foo.bar = 'a'}", "var id = function() {};" + "if (x) {foo.bar = 'foo_bar$0'}"); } private void testMap(String code, String expected, String expectedMap) { test(code, expected); assertEquals(expectedMap, lastPass.getSerializedIdMappings()); } private void test(String code, String expected, String expectedPseudo) { generatePseudoNames = false; test(code, expected); generatePseudoNames = true; test(code, expectedPseudo); } private void testNonPseudoSupportingGenerator(String code, String expected) { generatePseudoNames = false; test(code, expected); generatePseudoNames = true; test(code, expected); } }
/* * Copyright 2012 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import static com.google.javascript.jscomp.JsMessage.Style.RELAX; import com.google.javascript.jscomp.JsMessage.Style; /** * Test which checks that replacer works correctly. * */ public class ReplaceMessagesForChromeTest extends CompilerTestCase { private Style style = RELAX; @Override protected CompilerPass getProcessor(Compiler compiler) { return new ReplaceMessagesForChrome(compiler, new GoogleJsMessageIdGenerator(null), false, style); } @Override protected int getNumRepetitions() { // No longer valid on the second run. return 1; } @Override protected void setUp() { style = RELAX; } public void testReplaceSimpleMessage() { test("/** @desc A simple message. */\n" + "var MSG_A = goog.getMsg('Hello world');", "var MSG_A=chrome.i18n.getMessage('8660696502365331902');"); test("/** @desc A message attached to an object. */\n" + "foo.bar.MSG_B = goog.getMsg('Goodbye world');", "foo.bar.MSG_B=chrome.i18n.getMessage('2356086230621084760');"); } public void testReplaceSinglePlaceholder() { test("/** @desc A message with one placeholder. */\n" + "var MSG_C = goog.getMsg('Hello, {$name}', {name: 'Tyler'});", "var MSG_C=chrome.i18n.getMessage('4985325380591528435', ['Tyler']);"); } public void testReplaceTwoPlaceholders() { test("/** @desc A message with two placeholders. */\n" + "var MSG_D = goog.getMsg('{$greeting}, {$name}', " + "{greeting: 'Hi', name: 'Tyler'});", "var MSG_D=chrome.i18n.getMessage('3605047247574980322', " + "['Hi', 'Tyler']);"); test("/** @desc A message with two placeholders, but their order is\n" + " * reversed in the object literal. (Shouldn't make a difference.)\n" + " */\n" + "var MSG_E = goog.getMsg('{$greeting}, {$name}!', " + "{name: 'Tyler', greeting: 'Hi'});", "var MSG_E=chrome.i18n.getMessage('691522386483664339', " + "['Hi', 'Tyler']);"); } public void testReplacePlaceholderMissingValue() { test("/** @desc A message with two placeholders, but one is missing. */\n" + "var MSG_F = goog.getMsg('{$greeting}, {$name}!', {name: 'Tyler'});", null, JsMessageVisitor.MESSAGE_TREE_MALFORMED); } public void testReplaceTwoPlaceholdersNonAlphaOrder() { test("/** @desc A message with two placeholders not in order .*/\n" + "var MSG_G = goog.getMsg('{$name}: {$greeting}', " + "{greeting: 'Salutations', name: 'Tyler'});", "var MSG_G=chrome.i18n.getMessage('7437383242562773138', " + "['Salutations', 'Tyler']);"); } public void testReplaceExternalMessage() { test("/** @desc A message that was extracted with SoyMsgExtractor. */\n" + "var MSG_EXTERNAL_1357902468 = goog.getMsg('Hello world');", "var MSG_EXTERNAL_1357902468 = chrome.i18n.getMessage('1357902468');"); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import static com.google.javascript.jscomp.JsMessage.Style.RELAX; import static com.google.javascript.jscomp.JsMessageVisitor.MESSAGE_TREE_MALFORMED; import com.google.common.collect.Maps; import com.google.javascript.jscomp.JsMessage.Style; import java.util.Map; /** * Test which checks that replacer works correctly. * */ public class ReplaceMessagesTest extends CompilerTestCase { private Map<String, JsMessage> messages; private Style style = RELAX; private boolean strictReplacement; @Override protected CompilerPass getProcessor(Compiler compiler) { return new ReplaceMessages(compiler, new SimpleMessageBundle(), false, style, strictReplacement); } @Override protected int getNumRepetitions() { // No longer valid on the second run. return 1; } @Override protected void setUp() { messages = Maps.newHashMap(); strictReplacement = false; style = RELAX; } public void testReplaceSimpleMessage() { registerMessage(new JsMessage.Builder("MSG_A") .appendStringPart("Hi\nthere") .build()); test("/** @desc d */\n" + "var MSG_A = goog.getMsg('asdf');", "var MSG_A=\"Hi\\nthere\""); } public void testNameReplacement() { registerMessage(new JsMessage.Builder("MSG_B") .appendStringPart("One ") .appendPlaceholderReference("measly") .appendStringPart(" ph") .build()); test("/** @desc d */\n" + "var MSG_B=goog.getMsg('asdf {$measly}', {measly: x});", "var MSG_B=\"One \"+ (x +\" ph\" )"); } public void testGetPropReplacement() { registerMessage(new JsMessage.Builder("MSG_C") .appendPlaceholderReference("amount") .build()); test("/** @desc d */\n" + "var MSG_C = goog.getMsg('${$amount}', {amount: a.b.amount});", "var MSG_C=a.b.amount"); } public void testFunctionCallReplacement() { registerMessage(new JsMessage.Builder("MSG_D") .appendPlaceholderReference("amount") .build()); test("/** @desc d */\n" + "var MSG_D = goog.getMsg('${$amount}', {amount: getAmt()});", "var MSG_D=getAmt()"); } public void testMethodCallReplacement() { registerMessage(new JsMessage.Builder("MSG_E") .appendPlaceholderReference("amount") .build()); test("/** @desc d */\n" + "var MSG_E = goog.getMsg('${$amount}', {amount: obj.getAmt()});", "var MSG_E=obj.getAmt()"); } public void testHookReplacement() { registerMessage(new JsMessage.Builder("MSG_F") .appendStringPart("#") .appendPlaceholderReference("amount") .appendStringPart(".") .build()); test("/** @desc d */\n" + "var MSG_F = goog.getMsg('${$amount}', {amount: (a ? b : c)});", "var MSG_F=\"#\"+((a?b:c)+\".\")"); } public void testAddReplacement() { registerMessage(new JsMessage.Builder("MSG_G") .appendPlaceholderReference("amount") .build()); test("/** @desc d */\n" + "var MSG_G = goog.getMsg('${$amount}', {amount: x + ''});", "var MSG_G=x+\"\""); } public void testPlaceholderValueReferencedTwice() { registerMessage(new JsMessage.Builder("MSG_H") .appendPlaceholderReference("dick") .appendStringPart(", ") .appendPlaceholderReference("dick") .appendStringPart(" and ") .appendPlaceholderReference("jane") .build()); test("/** @desc d */\n" + "var MSG_H = goog.getMsg('{$dick}{$jane}', {jane: x, dick: y});", "var MSG_H=y+(\", \"+(y+(\" and \"+x)))"); } public void testPlaceholderNameInLowerCamelCase() { registerMessage(new JsMessage.Builder("MSG_I") .appendStringPart("Sum: $") .appendPlaceholderReference("amtEarned") .build()); test("/** @desc d */\n" + "var MSG_I = goog.getMsg('${$amtEarned}', {amtEarned: x});", "var MSG_I=\"Sum: $\"+x"); } public void testQualifiedMessageName() { registerMessage(new JsMessage.Builder("MSG_J") .appendStringPart("One ") .appendPlaceholderReference("measly") .appendStringPart(" ph") .build()); test("/** @desc d */\n" + "a.b.c.MSG_J = goog.getMsg('asdf {$measly}', {measly: x});", "a.b.c.MSG_J=\"One \"+(x+\" ph\")"); } public void testSimpleMessageReplacementMissing() { style = Style.LEGACY; test("/** @desc d */\n" + "var MSG_E = 'd*6a0@z>t';", "var MSG_E = 'd*6a0@z>t'"); } public void testSimpleMessageReplacementMissingWithNewStyle() { test("/** @desc d */\n" + "var MSG_E = goog.getMsg('missing');", "var MSG_E = 'missing'"); } public void testStrictModeAndMessageReplacementAbsentInBundle() { strictReplacement = true; test("var MSG_E = 'Hello';", "var MSG_E = 'Hello';", ReplaceMessages.BUNDLE_DOES_NOT_HAVE_THE_MESSAGE); } public void testStrictModeAndMessageReplacementAbsentInNonEmptyBundle() { registerMessage(new JsMessage.Builder("MSG_J") .appendStringPart("One ") .appendPlaceholderReference("measly") .appendStringPart(" ph") .build()); strictReplacement = true; test("var MSG_E = 'Hello';", "var MSG_E = 'Hello';", ReplaceMessages.BUNDLE_DOES_NOT_HAVE_THE_MESSAGE); } public void testFunctionReplacementMissing() { style = Style.LEGACY; test("var MSG_F = function() {return 'asdf'};", "var MSG_F = function() {return\"asdf\"}"); } public void testFunctionWithParamReplacementMissing() { style = Style.LEGACY; test( "var MSG_G = function(measly) {return 'asdf' + measly};", "var MSG_G=function(measly){return\"asdf\"+measly}"); } public void testPlaceholderNameInLowerUnderscoreCase() { test( "var MSG_J = goog.getMsg('${$amt_earned}', {amt_earned: x});", "var MSG_J = goog.getMsg('${$amt_earned}', {amt_earned: x});", MESSAGE_TREE_MALFORMED); } public void testBadPlaceholderReferenceInReplacement() { registerMessage(new JsMessage.Builder("MSG_K") .appendPlaceholderReference("amount") .build()); test( "var MSG_K = goog.getMsg('Hi {$jane}', {jane: x});", "var MSG_K = goog.getMsg('Hi {$jane}', {jane: x});", MESSAGE_TREE_MALFORMED); } public void testLegacyStyleNoPlaceholdersVarSyntax() { registerMessage(new JsMessage.Builder("MSG_A") .appendStringPart("Hi\nthere") .build()); style = Style.LEGACY; test("var MSG_A = 'd*6a0@z>t';", "var MSG_A=\"Hi\\nthere\""); } public void testLegacyStyleNoPlaceholdersFunctionSyntax() { registerMessage(new JsMessage.Builder("MSG_B") .appendStringPart("Hi\nthere") .build()); style = Style.LEGACY; test("var MSG_B = function() {return 'asdf'};", "var MSG_B=function(){return\"Hi\\nthere\"}"); } public void testLegacyStyleOnePlaceholder() { registerMessage(new JsMessage.Builder("MSG_C") .appendStringPart("One ") .appendPlaceholderReference("measly") .appendStringPart(" ph") .build()); style = Style.LEGACY; test( "var MSG_C = function(measly) {return 'asdf' + measly};", "var MSG_C=function(measly){return\"One \"+(measly+\" ph\")}"); } public void testLegacyStyleTwoPlaceholders() { registerMessage(new JsMessage.Builder("MSG_D") .appendPlaceholderReference("dick") .appendStringPart(" and ") .appendPlaceholderReference("jane") .build()); style = Style.LEGACY; test( "var MSG_D = function(jane, dick) {return jane + dick};", "var MSG_D=function(jane,dick){return dick+(\" and \"+jane)}"); } public void testLegacyStylePlaceholderNameInLowerCamelCase() { registerMessage(new JsMessage.Builder("MSG_E") .appendStringPart("Sum: $") .appendPlaceholderReference("amtEarned") .build()); style = Style.LEGACY; test( "var MSG_E = function(amtEarned) {return amtEarned + 'x'};", "var MSG_E=function(amtEarned){return\"Sum: $\"+amtEarned}"); } public void testLegacyStylePlaceholderNameInLowerUnderscoreCase() { registerMessage(new JsMessage.Builder("MSG_F") .appendStringPart("Sum: $") .appendPlaceholderReference("amt_earned") .build()); // Placeholder named in lower-underscore case (discouraged nowadays) style = Style.LEGACY; test( "var MSG_F = function(amt_earned) {return amt_earned + 'x'};", "var MSG_F=function(amt_earned){return\"Sum: $\"+amt_earned}"); } public void testLegacyStyleBadPlaceholderReferenceInReplacemen() { registerMessage(new JsMessage.Builder("MSG_B") .appendStringPart("Ola, ") .appendPlaceholderReference("chimp") .build()); test("var MSG_B = function(chump) {return chump + 'x'};", "var MSG_B = function(chump) {return chump + 'x'};", JsMessageVisitor.MESSAGE_TREE_MALFORMED); } public void testTranslatedPlaceHolderMissMatch() { registerMessage(new JsMessage.Builder("MSG_A") .appendPlaceholderReference("a") .appendStringPart("!") .build()); test("var MSG_A = goog.getMsg('{$a}');", "var MSG_A = goog.getMsg('{$a}');", MESSAGE_TREE_MALFORMED); } public void testBadFallbackSyntax1() { test("/** @desc d */\n" + "var MSG_A = goog.getMsg('asdf');" + "var x = goog.getMsgWithFallback(MSG_A);", null, JsMessageVisitor.BAD_FALLBACK_SYNTAX); } public void testBadFallbackSyntax2() { test("var x = goog.getMsgWithFallback('abc', 'bcd');", null, JsMessageVisitor.BAD_FALLBACK_SYNTAX); } public void testBadFallbackSyntax3() { test("/** @desc d */\n" + "var MSG_A = goog.getMsg('asdf');" + "var x = goog.getMsgWithFallback(MSG_A, y);", null, JsMessageVisitor.FALLBACK_ARG_ERROR); } public void testBadFallbackSyntax4() { test("/** @desc d */\n" + "var MSG_A = goog.getMsg('asdf');" + "var x = goog.getMsgWithFallback(y, MSG_A);", null, JsMessageVisitor.FALLBACK_ARG_ERROR); } public void testUseFallback() { registerMessage(new JsMessage.Builder("MSG_B") .appendStringPart("translated") .build()); test("/** @desc d */\n" + "var MSG_A = goog.getMsg('msg A');" + "/** @desc d */\n" + "var MSG_B = goog.getMsg('msg B');" + "var x = goog.getMsgWithFallback(MSG_A, MSG_B);", "var MSG_A = 'msg A';" + "var MSG_B = 'translated';" + "var x = MSG_B;"); } public void testFallbackEmptyBundle() { test("/** @desc d */\n" + "var MSG_A = goog.getMsg('msg A');" + "/** @desc d */\n" + "var MSG_B = goog.getMsg('msg B');" + "var x = goog.getMsgWithFallback(MSG_A, MSG_B);", "var MSG_A = 'msg A';" + "var MSG_B = 'msg B';" + "var x = MSG_A;"); } public void testNoUseFallback() { registerMessage(new JsMessage.Builder("MSG_A") .appendStringPart("translated") .build()); test("/** @desc d */\n" + "var MSG_A = goog.getMsg('msg A');" + "/** @desc d */\n" + "var MSG_B = goog.getMsg('msg B');" + "var x = goog.getMsgWithFallback(MSG_A, MSG_B);", "var MSG_A = 'translated';" + "var MSG_B = 'msg B';" + "var x = MSG_A;"); } public void testNoUseFallback2() { registerMessage(new JsMessage.Builder("MSG_C") .appendStringPart("translated") .build()); test("/** @desc d */\n" + "var MSG_A = goog.getMsg('msg A');" + "/** @desc d */\n" + "var MSG_B = goog.getMsg('msg B');" + "var x = goog.getMsgWithFallback(MSG_A, MSG_B);", "var MSG_A = 'msg A';" + "var MSG_B = 'msg B';" + "var x = MSG_A;"); } private void registerMessage(JsMessage message) { messages.put(message.getKey(), message); } private class SimpleMessageBundle implements MessageBundle { @Override public JsMessage getMessage(String id) { return messages.get(id); } @Override public Iterable<JsMessage> getAllMessages() { return messages.values(); } @Override public JsMessage.IdGenerator idGenerator() { return null; } } }
/* * Copyright 2010 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.ImmutableMap; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.javascript.jscomp.ReplaceStrings.Result; import com.google.javascript.rhino.Node; import java.util.Collections; import java.util.List; import java.util.Set; /** * Tests for {@link ReplaceStrings}. * */ public class ReplaceStringsTest extends CompilerTestCase { private ReplaceStrings pass; private Set<String> reserved; private VariableMap previous; private final static String EXTERNS = "var goog = {};\n" + "goog.debug = {};\n" + "/** @constructor */\n" + "goog.debug.Trace = function() {};\n" + "goog.debug.Trace.startTracer = function (var_args) {};\n" + "/** @constructor */\n" + "goog.debug.Logger = function() {};\n" + "goog.debug.Logger.prototype.info = function(msg, opt_ex) {};\n" + "/**\n" + " * @param {string} name\n" + " * @return {!goog.debug.Logger}\n" + " */\n" + "goog.debug.Logger.getLogger = function(name){};\n"; public ReplaceStringsTest() { super(EXTERNS, true); enableNormalize(); } @Override protected CompilerOptions getOptions() { CompilerOptions options = super.getOptions(); options.setWarningLevel( DiagnosticGroups.MISSING_PROPERTIES, CheckLevel.OFF); return options; } @Override protected void setUp() throws Exception { super.setUp(); super.enableLineNumberCheck(false); super.enableTypeCheck(CheckLevel.OFF); reserved = Collections.emptySet(); previous = null; } @Override public CompilerPass getProcessor(final Compiler compiler) { List<String> names = Lists.newArrayList( "Error(?)", "goog.debug.Trace.startTracer(*)", "goog.debug.Logger.getLogger(?)", "goog.debug.Logger.prototype.info(?)" ); pass = new ReplaceStrings(compiler, "`", names, reserved, previous); return new CompilerPass() { @Override public void process(Node externs, Node js) { new CollapseProperties(compiler, true, true).process(externs, js); pass.process(externs, js); } }; } @Override public int getNumRepetitions() { // This compiler pass is not idempotent and should only be run over a // parse tree once. return 1; } public void testStable1() { previous = VariableMap.fromMap(ImmutableMap.of("previous","xyz")); testDebugStrings( "Error('xyz');", "Error('previous');", (new String[] { "previous", "xyz" })); reserved = ImmutableSet.of("a", "b", "previous"); testDebugStrings( "Error('xyz');", "Error('c');", (new String[] { "c", "xyz" })); } public void testStable2() { // Two things happen here: // 1) a previously used name "a" is not used for another string, "b" is // chosen instead. // 2) a previously used name "a" is dropped from the output map if // it isn't used. previous = VariableMap.fromMap(ImmutableMap.of("a","unused")); testDebugStrings( "Error('xyz');", "Error('b');", (new String[] { "b", "xyz" })); } public void testThrowError1() { testDebugStrings( "throw Error('xyz');", "throw Error('a');", (new String[] { "a", "xyz" })); previous = VariableMap.fromMap(ImmutableMap.of("previous","xyz")); testDebugStrings( "throw Error('xyz');", "throw Error('previous');", (new String[] { "previous", "xyz" })); } public void testThrowError2() { testDebugStrings( "throw Error('x' +\n 'yz');", "throw Error('a');", (new String[] { "a", "xyz" })); } public void testThrowError3() { testDebugStrings( "throw Error('Unhandled mail' + ' search type ' + type);", "throw Error('a' + '`' + type);", (new String[] { "a", "Unhandled mail search type `" })); } public void testThrowError4() { testDebugStrings( "/** @constructor */\n" + "var A = function() {};\n" + "A.prototype.m = function(child) {\n" + " if (this.haveChild(child)) {\n" + " throw Error('Node: ' + this.getDataPath() +\n" + " ' already has a child named ' + child);\n" + " } else if (child.parentNode) {\n" + " throw Error('Node: ' + child.getDataPath() +\n" + " ' already has a parent');\n" + " }\n" + " child.parentNode = this;\n" + "};", "var A = function(){};\n" + "A.prototype.m = function(child) {\n" + " if (this.haveChild(child)) {\n" + " throw Error('a' + '`' + this.getDataPath() + '`' + child);\n" + " } else if (child.parentNode) {\n" + " throw Error('b' + '`' + child.getDataPath());\n" + " }\n" + " child.parentNode = this;\n" + "};", (new String[] { "a", "Node: ` already has a child named `", "b", "Node: ` already has a parent", })); } public void testThrowNonStringError() { // No replacement is done when an error is neither a string literal nor // a string concatenation expression. testDebugStrings( "throw Error(x('abc'));", "throw Error(x('abc'));", (new String[] { })); } public void testThrowConstStringError() { testDebugStrings( "var AA = 'uvw', AB = 'xyz'; throw Error(AB);", "var AA = 'uvw', AB = 'xyz'; throw Error('a');", (new String [] { "a", "xyz" })); } public void testThrowNewError1() { testDebugStrings( "throw new Error('abc');", "throw new Error('a');", (new String[] { "a", "abc" })); } public void testThrowNewError2() { testDebugStrings( "throw new Error();", "throw new Error();", new String[] {}); } public void testStartTracer1() { testDebugStrings( "goog.debug.Trace.startTracer('HistoryManager.updateHistory');", "goog.debug.Trace.startTracer('a');", (new String[] { "a", "HistoryManager.updateHistory" })); } public void testStartTracer2() { testDebugStrings( "goog$debug$Trace.startTracer('HistoryManager', 'updateHistory');", "goog$debug$Trace.startTracer('a', 'b');", (new String[] { "a", "HistoryManager", "b", "updateHistory" })); } public void testStartTracer3() { testDebugStrings( "goog$debug$Trace.startTracer('ThreadlistView',\n" + " 'Updating ' + array.length + ' rows');", "goog$debug$Trace.startTracer('a', 'b' + '`' + array.length);", new String[] { "a", "ThreadlistView", "b", "Updating ` rows" }); } public void testStartTracer4() { testDebugStrings( "goog.debug.Trace.startTracer(s, 'HistoryManager.updateHistory');", "goog.debug.Trace.startTracer(s, 'a');", (new String[] { "a", "HistoryManager.updateHistory" })); } public void testLoggerInitialization() { testDebugStrings( "goog$debug$Logger$getLogger('my.app.Application');", "goog$debug$Logger$getLogger('a');", (new String[] { "a", "my.app.Application" })); } public void testLoggerOnObject1() { testDebugStrings( "var x = {};" + "x.logger_ = goog.debug.Logger.getLogger('foo');" + "x.logger_.info('Some message');", "var x$logger_ = goog.debug.Logger.getLogger('a');" + "x$logger_.info('b');", new String[] { "a", "foo", "b", "Some message"}); } // Non-matching "info" property. public void testLoggerOnObject2() { test( "var x = {};" + "x.info = function(a) {};" + "x.info('Some message');", "var x$info = function(a) {};" + "x$info('Some message');"); } // Non-matching "info" prototype property. public void testLoggerOnObject3a() { testSame( "/** @constructor */\n" + "var x = function() {};\n" + "x.prototype.info = function(a) {};" + "(new x).info('Some message');"); } // Non-matching "info" prototype property. public void testLoggerOnObject3b() { testSame( "/** @constructor */\n" + "var x = function() {};\n" + "x.prototype.info = function(a) {};" + "var y = (new x); this.info('Some message');"); } // Non-matching "info" property on "NoObject" type. public void testLoggerOnObject4() { testSame("(new x).info('Some message');"); } // Non-matching "info" property on "UnknownObject" type. public void testLoggerOnObject5() { testSame("my$Thing.logger_.info('Some message');"); } public void testLoggerOnVar() { testDebugStrings( "var logger = goog.debug.Logger.getLogger('foo');" + "logger.info('Some message');", "var logger = goog.debug.Logger.getLogger('a');" + "logger.info('b');", new String[] { "a", "foo", "b", "Some message"}); } public void testLoggerOnThis() { testDebugStrings( "function f() {" + " this.logger_ = goog.debug.Logger.getLogger('foo');" + " this.logger_.info('Some message');" + "}", "function f() {" + " this.logger_ = goog.debug.Logger.getLogger('a');" + " this.logger_.info('b');" + "}", new String[] { "a", "foo", "b", "Some message"}); } public void testRepeatedErrorString1() { testDebugStrings( "Error('abc');Error('def');Error('abc');", "Error('a');Error('b');Error('a');", (new String[] { "a", "abc", "b", "def" })); } public void testRepeatedErrorString2() { testDebugStrings( "Error('a:' + u + ', b:' + v); Error('a:' + x + ', b:' + y);", "Error('a' + '`' + u + '`' + v); Error('a' + '`' + x + '`' + y);", (new String[] { "a", "a:`, b:`" })); } public void testRepeatedErrorString3() { testDebugStrings( "var AB = 'b'; throw Error(AB); throw Error(AB);", "var AB = 'b'; throw Error('a'); throw Error('a');", (new String[] { "a", "b" })); } public void testRepeatedTracerString() { testDebugStrings( "goog$debug$Trace.startTracer('A', 'B', 'A');", "goog$debug$Trace.startTracer('a', 'b', 'a');", (new String[] { "a", "A", "b", "B" })); } public void testRepeatedLoggerString() { testDebugStrings( "goog$debug$Logger$getLogger('goog.net.XhrTransport');" + "goog$debug$Logger$getLogger('my.app.Application');" + "goog$debug$Logger$getLogger('my.app.Application');", "goog$debug$Logger$getLogger('a');" + "goog$debug$Logger$getLogger('b');" + "goog$debug$Logger$getLogger('b');", new String[] { "a", "goog.net.XhrTransport","b", "my.app.Application" }); } public void testRepeatedStringsWithDifferentMethods() { test( "throw Error('A');" + "goog$debug$Trace.startTracer('B', 'A');" + "goog$debug$Logger$getLogger('C');" + "goog$debug$Logger$getLogger('B');" + "goog$debug$Logger$getLogger('A');" + "throw Error('D');" + "throw Error('C');" + "throw Error('B');" + "throw Error('A');", "throw Error('a');" + "goog$debug$Trace.startTracer('b', 'a');" + "goog$debug$Logger$getLogger('c');" + "goog$debug$Logger$getLogger('b');" + "goog$debug$Logger$getLogger('a');" + "throw Error('d');" + "throw Error('c');" + "throw Error('b');" + "throw Error('a');"); } public void testReserved() { testDebugStrings( "throw Error('xyz');", "throw Error('a');", (new String[] { "a", "xyz" })); reserved = ImmutableSet.of("a", "b", "c"); testDebugStrings( "throw Error('xyz');", "throw Error('d');", (new String[] { "d", "xyz" })); } private void testDebugStrings(String js, String expected, String[] substitutedStrings) { // Verify that the strings are substituted correctly in the JS code. test(js, expected); List<Result> results = pass.getResult(); assertTrue(substitutedStrings.length % 2 == 0); assertEquals(substitutedStrings.length/2, results.size()); // Verify that substituted strings are decoded correctly. for (int i = 0; i < substitutedStrings.length; i += 2) { Result result = results.get(i/2); String original = substitutedStrings[i + 1]; assertEquals(original, result.original); String replacement = substitutedStrings[i]; assertEquals(replacement, result.replacement); } } }
/* * Copyright 2011 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Unit tests for {@link RescopeGlobalSymbols} * */ public class RescopeGlobalSymbolsTest extends CompilerTestCase { private final String namespace = "_"; public RescopeGlobalSymbolsTest() { } @Override protected CompilerPass getProcessor(Compiler compiler) { return new RescopeGlobalSymbols(compiler, namespace, false); } @Override protected int getNumRepetitions() { return 1; } public void testVarDeclarations() { test("var a = 1;", "_.a = 1;"); test("var a = 1, b = 2, c = 3;", "_.a = 1; _.b = 2; _.c = 3;"); test("var a = 'str', b = 1, c = { foo: 'bar' }, d = function() {};", "_.a = 'str'; _.b = 1; _.c = { foo: 'bar' }; _.d = function() {};"); test("if(1){var x = 1;}", "if(1){_.x = 1;}"); test("var x;", ""); test("var a, b = 1;", "_.b = 1"); } public void testForLoops() { test("for (var i = 0; i < 1000; i++);", "for (_.i = 0; _.i < 1000; _.i++);"); test("for (var i = 0, c = 2; i < 1000; i++);", "for (_.i = 0, _.c = 2; _.i < 1000; _.i++);"); test("for (var i = 0, c = 2, d = 3; i < 1000; i++);", "for (_.i = 0, _.c = 2, _.d = 3; _.i < 1000; _.i++);"); test("for (var i = 0, c = 2, d = 3, e = 4; i < 1000; i++);", "for (_.i = 0, _.c = 2, _.d = 3, _.e = 4; _.i < 1000; _.i++);"); test("for (var i = 0; i < 1000;)i++;", "for (_.i = 0; _.i < 1000;)_.i++;"); test("for (var i = 0,b; i < 1000;)i++;b++", "for (_.i = 0,_.b; _.i < 1000;)_.i++;_.b++"); test("var o={};for (var i in o)i++;", "_.o={};for (_.i in _.o)_.i++;"); } public void testFunctionStatements() { test("function test(){}", "_.test=function (){}"); test("if(1)function test(){}", "if(1)_.test=function (){}"); new StringCompare().testFreeCallSemantics(); } public void testDeeperScopes() { test("var a = function(b){return b}", "_.a = function(b){return b}"); test("var a = function(b){var a; return a+b}", "_.a = function(b){var a; return a+b}"); test("var a = function(a,b){return a+b}", "_.a = function(a,b){return a+b}"); test("var x=1,a = function(b){var a; return a+b+x}", "_.x=1;_.a = function(b){var a; return a+b+_.x}"); test("var x=1,a = function(b){return function(){var a;return a+b+x}}", "_.x=1;_.a = function(b){return function(){var a; return a+b+_.x}}"); } public void testTryCatch() { test("try{var a = 1}catch(e){throw e}", "try{_.a = 1}catch(e){throw e}"); } public void testShadow() { test("var _ = 1; (function () { _ = 2 })()", "_._ = 1; (function () { _._ = 2 })()"); test("function foo() { var _ = {}; _.foo = foo; _.bar = 1; }", "_.foo = function () { var _$ = {}; _$.foo = _.foo; _$.bar = 1}"); test("function foo() { var _ = {}; _.foo = foo; _.bar = 1; " + "(function() { var _ = 0;})() }", "_.foo = function () { var _$ = {}; _$.foo = _.foo; _$.bar = 1; " + "(function() { var _$ = 0;})() }"); test("function foo() { var _ = {}; _.foo = foo; _.bar = 1; " + "var _$ = 1; }", "_.foo = function () { var _$ = {}; _$.foo = _.foo; _$.bar = 1; " + "var _$$ = 1; }"); test("function foo() { var _ = {}; _.foo = foo; _.bar = 1; " + "var _$ = 1; (function() { _ = _$ })() }", "_.foo = function () { var _$ = {}; _$.foo = _.foo; _$.bar = 1; " + "var _$$ = 1; (function() { _$ = _$$ })() }"); test("function foo() { var _ = {}; _.foo = foo; _.bar = 1; " + "var _$ = 1, _$$ = 2 (function() { _ = _$ = _$$; " + "var _$, _$$$ })() }", "_.foo = function () { var _$ = {}; _$.foo = _.foo; _$.bar = 1; " + "var _$$ = 1, _$$$ = 2 (function() { _$ = _$$ = _$$$; " + "var _$$, _$$$$ })() }"); test("function foo() { var _a = 1;}", "_.foo = function () { var _a = 1;}"); // We accept this unnecessary renaming as acceptable to simplify pattern // matching in the traversal. test("function foo() { var _$a = 1;}", "_.foo = function () { var _$a$ = 1;}"); } public void testExterns() { test("var document;", "document", "window.document", null, null); test("var document;", "document.getElementsByTagName('test')", "window.document.getElementsByTagName('test')", null, null); test("var document;", "window.document.getElementsByTagName('test')", "window.document.getElementsByTagName('test')", null, null); test("var document;document.getElementsByTagName", "document.getElementsByTagName('test')", "window.document.getElementsByTagName('test')", null, null); test("var document,navigator", "document.navigator;navigator", "window.document.navigator;window.navigator", null, null); test("var iframes", "function test() { iframes.resize(); }", "_.test = function() { window.iframes.resize(); }", null, null); test("var iframes", "var foo = iframes;", "_.foo = window.iframes;", null, null); // Special names. test("var arguments, window, eval;", "arguments;window;eval;", "arguments;window;eval;", null, null); // Actually not an extern. test("", "document", "window.document", null, null); } private class StringCompare extends CompilerTestCase { StringCompare() { super("", false); } @Override protected CompilerPass getProcessor(Compiler compiler) { return new RescopeGlobalSymbols(compiler, namespace, false); } public void testFreeCallSemantics() { test("function x(){};var y=function(){var val=x()||{}}", "_.x=function(){};_.y=function(){var val=(0,_.x)()||{}}"); test("function x(){x()}", "_.x=function(){(0,_.x)()}"); } } }
/* * Copyright 2010 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.ImmutableList; import com.google.common.collect.Iterables; import com.google.common.collect.Lists; import junit.framework.TestCase; import java.util.List; /** * Tests for error message filtering. * @author nicksantos@google.com (Nick Santos) */ public class RhinoErrorReporterTest extends TestCase { private boolean reportMisplacedTypeAnnotations; @Override protected void setUp() throws Exception { reportMisplacedTypeAnnotations = false; super.setUp(); } public void testTrailingComma() throws Exception { String message = "Parse error. IE8 (and below) will parse trailing commas in " + "array and object literals incorrectly. " + "If you are targeting newer versions of JS, " + "set the appropriate language_in option."; assertError( "var x = [1,];", RhinoErrorReporter.TRAILING_COMMA, message); JSError error = assertError( "var x = {\n" + " 1: 2,\n" + "};", RhinoErrorReporter.TRAILING_COMMA, message); assertEquals(2, error.getLineNumber()); // Rhino uses the "beginning" of the line where the comma appears, // for some odd reason. assertEquals(4, error.getCharno()); } public void testMisplacedTypeAnnotation() throws Exception { reportMisplacedTypeAnnotations = false; assertNoWarningOrError("var x = /** @type {string} */ y;"); reportMisplacedTypeAnnotations = true; String message = "Type annotations are not allowed here. " + "Are you missing parentheses?"; assertWarning( "var x = /** @type {string} */ y;", RhinoErrorReporter.MISPLACED_TYPE_ANNOTATION, message); JSError error = assertWarning( "var x = /** @type {string} */ y;", RhinoErrorReporter.MISPLACED_TYPE_ANNOTATION, message); assertEquals(1, error.getLineNumber()); // Rhino uses the "beginning" of the line where the comma appears, // for some odd reason. assertEquals(0, error.getCharno()); } /** * Verifies that the compiler emits an error for the given code. */ private void assertNoWarningOrError(String code) { Compiler compiler = parseCode(code); assertEquals("Expected error", 0, compiler.getErrorCount()); assertEquals("Expected warning", 0, compiler.getErrorCount()); } /** * Verifies that the compiler emits an error for the given code. */ private JSError assertError( String code, DiagnosticType type, String description) { Compiler compiler = parseCode(code); assertEquals("Expected error", 1, compiler.getErrorCount()); JSError error = Iterables.getOnlyElement(Lists.newArrayList(compiler.getErrors())); assertEquals(type, error.getType()); assertEquals(description, error.description); return error; } /** * Verifies that the compiler emits an error for the given code. */ private JSError assertWarning( String code, DiagnosticType type, String description) { Compiler compiler = parseCode(code); assertEquals("Expected warning", 1, compiler.getWarningCount()); JSError error = Iterables.getOnlyElement(Lists.newArrayList(compiler.getWarnings())); assertEquals(type, error.getType()); assertEquals(description, error.description); return error; } private Compiler parseCode(String code) { Compiler compiler = new Compiler(); CompilerOptions options = new CompilerOptions(); if (reportMisplacedTypeAnnotations) { options.setWarningLevel( DiagnosticGroups.MISPLACED_TYPE_ANNOTATION, CheckLevel.WARNING); } List<SourceFile> externs = ImmutableList.of(); List<SourceFile> inputs = ImmutableList.of( SourceFile.fromCode("input", code)); compiler.init(externs, inputs, options); compiler.parseInputs(); return compiler; } }
/* * Copyright 2010 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; /** * Tests for {@link RuntimeTypeCheck}. * */ public class RuntimeTypeCheckTest extends CompilerTestCase { public RuntimeTypeCheckTest() { super("/** @const */ var undefined;"); enableTypeCheck(CheckLevel.WARNING); } @Override protected void setUp() { super.enableLineNumberCheck(false); enableNormalize(); } public void testValue() { testChecks("/** @param {number} i */ function f(i) {}", "function f(i) {" + " $jscomp.typecheck.checkType(i, " + " [$jscomp.typecheck.valueChecker('number')]);" + "}"); } public void testConstValue() { // User a variable that's immutable by the google coding convention, // to ensure the immutable annotations are preserved. testChecks("/** @param {number} CONST */ function f(CONST) {}", "function f(CONST) {" + " $jscomp.typecheck.checkType(CONST, " + " [$jscomp.typecheck.valueChecker('number')]);" + "}"); } public void testValueWithInnerFn() { testChecks("/** @param {number} i */ function f(i) { function g() {} }", "function f(i) {" + " function g() {}" + " $jscomp.typecheck.checkType(i, " + " [$jscomp.typecheck.valueChecker('number')]);" + "}"); } public void testNullValue() { testChecks("/** @param {null} i */ function f(i) {}", "function f(i) {" + " $jscomp.typecheck.checkType(i, [$jscomp.typecheck.nullChecker]);" + "}"); } public void testValues() { testChecks("/** @param {number} i\n@param {string} j*/ function f(i, j) {}", "function f(i, j) {" + " $jscomp.typecheck.checkType(i, " + " [$jscomp.typecheck.valueChecker('number')]);" + " $jscomp.typecheck.checkType(j, " + " [$jscomp.typecheck.valueChecker('string')]);" + "}"); } public void testSkipParamOK() { testChecks("/** @param {*} i\n@param {string} j*/ function f(i, j) {}", "function f(i, j) {" + " $jscomp.typecheck.checkType(j, " + " [$jscomp.typecheck.valueChecker('string')]);" + "}"); } public void testUnion() { testChecks("/** @param {number|string} x */ function f(x) {}", "function f(x) {" + " $jscomp.typecheck.checkType(x, [" + " $jscomp.typecheck.valueChecker('number'), " + " $jscomp.typecheck.valueChecker('string')" + "]);" + "}"); } public void testUntypedParam() { testChecks("/** ... */ function f(x) {}", "function f(x) {}"); } public void testReturn() { testChecks("/** @return {string} */ function f() { return 'x'; }", "function f() {" + " return $jscomp.typecheck.checkType('x', " + " [$jscomp.typecheck.valueChecker('string')]);" + "}"); } public void testNativeClass() { testChecks("/** @param {!String} x */ function f(x) {}", "function f(x) {" + " $jscomp.typecheck.checkType(x, " + " [$jscomp.typecheck.externClassChecker('String')]);" + "}"); } public void testQualifiedClass() { testChecks("var goog = {}; /** @constructor */goog.Foo = function() {};" + "/** @param {!goog.Foo} x */ function f(x) {}", "var goog = {}; goog.Foo = function() {};" + "goog.Foo.prototype['instance_of__goog.Foo'] = true;" + "function f(x) {" + " $jscomp.typecheck.checkType(x, " + " [$jscomp.typecheck.classChecker('goog.Foo')]);" + "}"); } public void testInnerClasses() { testChecks( "function f() { /** @constructor */ function inner() {} }" + "function g() { /** @constructor */ function inner() {} }", "function f() {" + " /** @constructor */ function inner() {}" + " inner.prototype['instance_of__inner'] = true;" + "}" + "function g() {" + " /** @constructor */ function inner$$1() {}" + " inner$$1.prototype['instance_of__inner$$1'] = true;" + "}"); } public void testInterface() { testChecks("/** @interface */function I() {}" + "/** @param {!I} i */function f(i) {}", "function I() {}" + "function f(i) {" + " $jscomp.typecheck.checkType(i, " + " [$jscomp.typecheck.interfaceChecker('I')])" + "}"); } public void testImplementedInterface() { testChecks("/** @interface */function I() {}" + "/** @param {!I} i */function f(i) {}" + "/** @constructor\n@implements {I} */function C() {}", "function I() {}" + "function f(i) {" + " $jscomp.typecheck.checkType(i, " + " [$jscomp.typecheck.interfaceChecker('I')])" + "}" + "function C() {}" + "C.prototype['instance_of__C'] = true;" + "C.prototype['implements__I'] = true;"); } public void testExtendedInterface() { testChecks("/** @interface */function I() {}" + "/** @interface\n@extends {I} */function J() {}" + "/** @param {!I} i */function f(i) {}" + "/** @constructor\n@implements {J} */function C() {}", "function I() {}" + "function J() {}" + "function f(i) {" + " $jscomp.typecheck.checkType(i, " + " [$jscomp.typecheck.interfaceChecker('I')])" + "}" + "function C() {}" + "C.prototype['instance_of__C'] = true;" + "C.prototype['implements__I'] = true;" + "C.prototype['implements__J'] = true;"); } public void testImplementedInterfaceOrdering() { testChecks("/** @interface */function I() {}" + "/** @param {!I} i */function f(i) {}" + "/** @constructor\n@implements {I} */function C() {}" + "C.prototype.f = function() {};", "function I() {}" + "function f(i) {" + " $jscomp.typecheck.checkType(i, " + " [$jscomp.typecheck.interfaceChecker('I')])" + "}" + "function C() {}" + "C.prototype['instance_of__C'] = true;" + "C.prototype['implements__I'] = true;" + "C.prototype.f = function() {};"); } public void testImplementedInterfaceOrderingGoogInherits() { testChecks("var goog = {}; goog.inherits = function(x, y) {};" + "/** @interface */function I() {}" + "/** @param {!I} i */function f(i) {}" + "/** @constructor */function B() {}" + "/** @constructor\n@extends {B}\n@implements {I} */function C() {}" + "goog.inherits(C, B);" + "C.prototype.f = function() {};", "var goog = {}; goog.inherits = function(x, y) {};" + "function I() {}" + "function f(i) {" + " $jscomp.typecheck.checkType(i, " + " [$jscomp.typecheck.interfaceChecker('I')])" + "}" + "function B() {}" + "B.prototype['instance_of__B'] = true;" + "function C() {}" + "goog.inherits(C, B);" + "C.prototype['instance_of__C'] = true;" + "C.prototype['implements__I'] = true;" + "C.prototype.f = function() {};"); } public void testInnerConstructor() { testChecks("(function() { /** @constructor */ function C() {} })()", "(function() {" + " function C() {} C.prototype['instance_of__C'] = true;" + "})()"); } public void testReturnNothing() { testChecks("function f() { return; }", "function f() { return; }"); } public void testFunctionType() { testChecks("/** @type {!Function} */function f() {}", "function f() {}"); } private void testChecks(String js, String expected) { Compiler compiler = new Compiler(); compiler.init(Lists.<SourceFile>newArrayList(), Lists.<SourceFile>newArrayList(), new CompilerOptions()); Node base = compiler.loadLibraryCode("base"); Node typeCheck = compiler.loadLibraryCode("runtime_type_check"); test(js, compiler.toSource(base) + ";" + compiler.toSource(typeCheck) + ";" + expected); } @Override protected CompilerPass getProcessor(final Compiler compiler) { return new RuntimeTypeCheck(compiler, null); } @Override protected int getNumRepetitions() { return 1; } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.jscomp.AbstractCompiler.LifeCycleStage; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; /** * @author nicksantos@google.com (Nick Santos) */ public class SanityCheckTest extends CompilerTestCase { private CompilerPass otherPass = null; public SanityCheckTest() { super("", false); } @Override public void setUp() { otherPass = null; } @Override protected int getNumRepetitions() { return 1; } @Override public CompilerPass getProcessor(final Compiler compiler) { return new CompilerPass() { @Override public void process(Node externs, Node root) { otherPass.process(externs, root); (new SanityCheck(compiler)).process(externs, root); } }; } public void testUnnormalizeNodeTypes() throws Exception { otherPass = new CompilerPass() { @Override public void process(Node externs, Node root) { getLastCompiler().reportCodeChange(); root.getFirstChild().addChildToBack( new Node(Token.IF, new Node(Token.TRUE), new Node(Token.EMPTY))); } }; boolean exceptionCaught = false; try { test("var x = 3;", "var x=3;0;0"); } catch (IllegalStateException e) { assertEquals("Expected BLOCK but was EMPTY Reference node EMPTY", e.getMessage()); exceptionCaught = true; } assertTrue(exceptionCaught); } public void testUnnormalized() throws Exception { otherPass = new CompilerPass() { @Override public void process(Node externs, Node root) { getLastCompiler().setLifeCycleStage(LifeCycleStage.NORMALIZED); } }; boolean exceptionCaught = false; try { test("while(1){}", "while(1){}"); } catch (RuntimeException e) { assertTrue(e.getMessage().contains( "Normalize constraints violated:\nWHILE node")); exceptionCaught = true; } assertTrue(exceptionCaught); } public void testConstantAnnotationMismatch() throws Exception { otherPass = new CompilerPass() { @Override public void process(Node externs, Node root) { getLastCompiler().reportCodeChange(); Node name = Node.newString(Token.NAME, "x"); name.putBooleanProp(Node.IS_CONSTANT_NAME, true); root.getFirstChild().addChildToBack(new Node(Token.EXPR_RESULT, name)); getLastCompiler().setLifeCycleStage(LifeCycleStage.NORMALIZED); } }; boolean exceptionCaught = false; try { test("var x;", "var x; x;"); } catch (RuntimeException e) { assertTrue(e.getMessage().contains( "The name x is not consistently annotated as constant.")); exceptionCaught = true; } assertTrue(exceptionCaught); } }
/* * Copyright 2010 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.Lists; import com.google.common.collect.Maps; import com.google.javascript.jscomp.CompilerOptions.AliasTransformation; import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.SourcePosition; import java.util.Collection; import java.util.List; import java.util.Map; /** * Tests for {@link ScopedAliases} * * @author robbyw@google.com (Robby Walker) */ public class ScopedAliasesTest extends CompilerTestCase { private static final String GOOG_SCOPE_START_BLOCK = "goog.scope(function() {"; private static final String GOOG_SCOPE_END_BLOCK = "});"; private static String EXTERNS = "var window;"; AliasTransformationHandler transformationHandler = CompilerOptions.NULL_ALIAS_TRANSFORMATION_HANDLER; public ScopedAliasesTest() { super(EXTERNS); } private void testScoped(String code, String expected) { test(GOOG_SCOPE_START_BLOCK + code + GOOG_SCOPE_END_BLOCK, expected); } private void testScopedNoChanges(String aliases, String code) { testScoped(aliases + code, code); } public void testOneLevel() { testScoped("var g = goog;g.dom.createElement(g.dom.TagName.DIV);", "goog.dom.createElement(goog.dom.TagName.DIV);"); } public void testTwoLevel() { testScoped("var d = goog.dom;d.createElement(d.TagName.DIV);", "goog.dom.createElement(goog.dom.TagName.DIV);"); } public void testTransitive() { testScoped("var d = goog.dom;var DIV = d.TagName.DIV;d.createElement(DIV);", "goog.dom.createElement(goog.dom.TagName.DIV);"); } public void testTransitiveInSameVar() { testScoped("var d = goog.dom, DIV = d.TagName.DIV;d.createElement(DIV);", "goog.dom.createElement(goog.dom.TagName.DIV);"); } public void testMultipleTransitive() { testScoped( "var g=goog;var d=g.dom;var t=d.TagName;var DIV=t.DIV;" + "d.createElement(DIV);", "goog.dom.createElement(goog.dom.TagName.DIV);"); } public void testFourLevel() { testScoped("var DIV = goog.dom.TagName.DIV;goog.dom.createElement(DIV);", "goog.dom.createElement(goog.dom.TagName.DIV);"); } public void testWorksInClosures() { testScoped( "var DIV = goog.dom.TagName.DIV;" + "goog.x = function() {goog.dom.createElement(DIV);};", "goog.x = function() {goog.dom.createElement(goog.dom.TagName.DIV);};"); } public void testOverridden() { // Test that the alias doesn't get unaliased when it's overridden by a // parameter. testScopedNoChanges( "var g = goog;", "goog.x = function(g) {g.z()};"); // Same for a local. testScopedNoChanges( "var g = goog;", "goog.x = function() {var g = {}; g.z()};"); } public void testTwoScopes() { test( "goog.scope(function() {var g = goog;g.method()});" + "goog.scope(function() {g.method();});", "goog.method();g.method();"); } public void testTwoSymbolsInTwoScopes() { test( "var goog = {};" + "goog.scope(function() { var g = goog; g.Foo = function() {}; });" + "goog.scope(function() { " + " var Foo = goog.Foo; goog.bar = function() { return new Foo(); };" + "});", "var goog = {};" + "goog.Foo = function() {};" + "goog.bar = function() { return new goog.Foo(); };"); } public void testAliasOfSymbolInGoogScope() { test( "var goog = {};" + "goog.scope(function() {" + " var g = goog;" + " g.Foo = function() {};" + " var Foo = g.Foo;" + " Foo.prototype.bar = function() {};" + "});", "var goog = {}; goog.Foo = function() {};" + "goog.Foo.prototype.bar = function() {};"); } public void testScopedFunctionReturnThis() { test("goog.scope(function() { " + " var g = goog; g.f = function() { return this; };" + "});", "goog.f = function() { return this; };"); } public void testScopedFunctionAssignsToVar() { test("goog.scope(function() { " + " var g = goog; g.f = function(x) { x = 3; return x; };" + "});", "goog.f = function(x) { x = 3; return x; };"); } public void testScopedFunctionThrows() { test("goog.scope(function() { " + " var g = goog; g.f = function() { throw 'error'; };" + "});", "goog.f = function() { throw 'error'; };"); } public void testPropertiesNotChanged() { testScopedNoChanges("var x = goog.dom;", "y.x();"); } public void testShadowedVar() { test("var Popup = {};" + "var OtherPopup = {};" + "goog.scope(function() {" + " var Popup = OtherPopup;" + " Popup.newMethod = function() { return new Popup(); };" + "});", "var Popup = {};" + "var OtherPopup = {};" + "OtherPopup.newMethod = function() { return new OtherPopup(); };"); } public void testShadowedScopedVar() { test("var goog = {};" + "goog.bar = {};" + "goog.scope(function() {" + " var bar = goog.bar;" + // This is bogus, because when the aliases are expanded, goog will // shadow goog.bar. " bar.newMethod = function(goog) { return goog + bar; };" + "});", "var goog={};" + "goog.bar={};" + "goog.bar.newMethod=function(goog$$1){return goog$$1 + goog.bar}"); } public void testShadowedScopedVarTwoScopes() { test("var goog = {};" + "goog.bar = {};" + "goog.scope(function() {" + " var bar = goog.bar;" + " bar.newMethod = function(goog, a) { return bar + a; };" + "});" + "goog.scope(function() {" + " var bar = goog.bar;" + " bar.newMethod2 = function(goog, b) { return bar + b; };" + "});", "var goog={};" + "goog.bar={};" + "goog.bar.newMethod=function(goog$$1, a){return goog.bar + a};" + "goog.bar.newMethod2=function(goog$$1, b){return goog.bar + b};"); } public void testUsingObjectLiteralToEscapeScoping() { // There are many ways to shoot yourself in the foot with goog.scope // and make the compiler generate bad code. We generally don't care. // // We only try to protect against accidental mis-use, not deliberate // mis-use. test( "var goog = {};" + "goog.bar = {};" + "goog.scope(function() {" + " var bar = goog.bar;" + " var baz = goog.bar.baz;" + " goog.foo = function() {" + " goog.bar = {baz: 3};" + " return baz;" + " };" + "});", "var goog = {};" + "goog.bar = {};" + "goog.foo = function(){" + " goog.bar = {baz:3};" + " return goog.bar.baz;" + "};"); } private void testTypes(String aliases, String code) { testScopedNoChanges(aliases, code); verifyTypes(); } private void verifyTypes() { Compiler lastCompiler = getLastCompiler(); new TypeVerifyingPass(lastCompiler).process(lastCompiler.externsRoot, lastCompiler.jsRoot); } public void testJsDocType() { testTypes( "var x = goog.Timer;", "" + "/** @type {x} */ types.actual;" + "/** @type {goog.Timer} */ types.expected;"); } public void testJsDocParameter() { testTypes( "var x = goog.Timer;", "" + "/** @param {x} a */ types.actual;" + "/** @param {goog.Timer} a */ types.expected;"); } public void testJsDocExtends() { testTypes( "var x = goog.Timer;", "" + "/** @extends {x} */ types.actual;" + "/** @extends {goog.Timer} */ types.expected;"); } public void testJsDocImplements() { testTypes( "var x = goog.Timer;", "" + "/** @implements {x} */ types.actual;" + "/** @implements {goog.Timer} */ types.expected;"); } public void testJsDocEnum() { testTypes( "var x = goog.Timer;", "" + "/** @enum {x} */ types.actual;" + "/** @enum {goog.Timer} */ types.expected;"); } public void testJsDocReturn() { testTypes( "var x = goog.Timer;", "" + "/** @return {x} */ types.actual;" + "/** @return {goog.Timer} */ types.expected;"); } public void testJsDocThis() { testTypes( "var x = goog.Timer;", "" + "/** @this {x} */ types.actual;" + "/** @this {goog.Timer} */ types.expected;"); } public void testJsDocThrows() { testTypes( "var x = goog.Timer;", "" + "/** @throws {x} */ types.actual;" + "/** @throws {goog.Timer} */ types.expected;"); } public void testJsDocSubType() { testTypes( "var x = goog.Timer;", "" + "/** @type {x.Enum} */ types.actual;" + "/** @type {goog.Timer.Enum} */ types.expected;"); } public void testJsDocTypedef() { testTypes( "var x = goog.Timer;", "" + "/** @typedef {x} */ types.actual;" + "/** @typedef {goog.Timer} */ types.expected;"); } public void testArrayJsDoc() { testTypes( "var x = goog.Timer;", "" + "/** @type {Array.<x>} */ types.actual;" + "/** @type {Array.<goog.Timer>} */ types.expected;"); } public void testObjectJsDoc() { testTypes( "var x = goog.Timer;", "" + "/** @type {{someKey: x}} */ types.actual;" + "/** @type {{someKey: goog.Timer}} */ types.expected;"); testTypes( "var x = goog.Timer;", "" + "/** @type {{x: number}} */ types.actual;" + "/** @type {{x: number}} */ types.expected;"); } public void testUnionJsDoc() { testTypes( "var x = goog.Timer;", "" + "/** @type {x|Object} */ types.actual;" + "/** @type {goog.Timer|Object} */ types.expected;"); } public void testFunctionJsDoc() { testTypes( "var x = goog.Timer;", "" + "/** @type {function(x) : void} */ types.actual;" + "/** @type {function(goog.Timer) : void} */ types.expected;"); testTypes( "var x = goog.Timer;", "" + "/** @type {function() : x} */ types.actual;" + "/** @type {function() : goog.Timer} */ types.expected;"); } public void testForwardJsDoc() { testScoped( "/**\n" + " * @constructor\n" + " */\n" + "foo.Foo = function() {};" + "/** @param {Foo.Bar} x */ foo.Foo.actual = function(x) {3};" + "var Foo = foo.Foo;" + "/** @constructor */ Foo.Bar = function() {};" + "/** @param {foo.Foo.Bar} x */ foo.Foo.expected = function(x) {};", "/**\n" + " * @constructor\n" + " */\n" + "foo.Foo = function() {};" + "/** @param {foo.Foo.Bar} x */ foo.Foo.actual = function(x) {3};" + "/** @constructor */ foo.Foo.Bar = function() {};" + "/** @param {foo.Foo.Bar} x */ foo.Foo.expected = function(x) {};"); verifyTypes(); } public void testTestTypes() { try { testTypes( "var x = goog.Timer;", "" + "/** @type {function() : x} */ types.actual;" + "/** @type {function() : wrong.wrong} */ types.expected;"); fail("Test types should fail here."); } catch (AssertionError e) { } } public void testNullType() { testTypes( "var x = goog.Timer;", "/** @param draggable */ types.actual;" + "/** @param draggable */ types.expected;"); } public void testIssue772() { testTypes( "var b = a.b;" + "var c = b.c;", "/** @param {c.MyType} x */ types.actual;" + "/** @param {a.b.c.MyType} x */ types.expected;"); } // TODO(robbyw): What if it's recursive? var goog = goog.dom; // FAILURE CASES private void testFailure(String code, DiagnosticType expectedError) { test(code, null, expectedError); } private void testScopedFailure(String code, DiagnosticType expectedError) { test("goog.scope(function() {" + code + "});", null, expectedError); } public void testScopedThis() { testScopedFailure("this.y = 10;", ScopedAliases.GOOG_SCOPE_REFERENCES_THIS); testScopedFailure("var x = this;", ScopedAliases.GOOG_SCOPE_REFERENCES_THIS); testScopedFailure("fn(this);", ScopedAliases.GOOG_SCOPE_REFERENCES_THIS); } public void testAliasRedefinition() { testScopedFailure("var x = goog.dom; x = goog.events;", ScopedAliases.GOOG_SCOPE_ALIAS_REDEFINED); } public void testAliasNonRedefinition() { test("var y = {}; goog.scope(function() { goog.dom = y; });", "var y = {}; goog.dom = y;"); } public void testScopedReturn() { testScopedFailure("return;", ScopedAliases.GOOG_SCOPE_USES_RETURN); testScopedFailure("var x = goog.dom; return;", ScopedAliases.GOOG_SCOPE_USES_RETURN); } public void testScopedThrow() { testScopedFailure("throw 'error';", ScopedAliases.GOOG_SCOPE_USES_THROW); } public void testUsedImproperly() { testFailure("var x = goog.scope(function() {});", ScopedAliases.GOOG_SCOPE_USED_IMPROPERLY); } public void testBadParameters() { testFailure("goog.scope()", ScopedAliases.GOOG_SCOPE_HAS_BAD_PARAMETERS); testFailure("goog.scope(10)", ScopedAliases.GOOG_SCOPE_HAS_BAD_PARAMETERS); testFailure("goog.scope(function() {}, 10)", ScopedAliases.GOOG_SCOPE_HAS_BAD_PARAMETERS); testFailure("goog.scope(function z() {})", ScopedAliases.GOOG_SCOPE_HAS_BAD_PARAMETERS); testFailure("goog.scope(function(a, b, c) {})", ScopedAliases.GOOG_SCOPE_HAS_BAD_PARAMETERS); } public void testNonAliasLocal() { testScopedFailure("var x = 10", ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL); testScopedFailure("var x = goog.dom + 10", ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL); testScopedFailure("var x = goog['dom']", ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL); testScopedFailure("var x = goog.dom, y = 10", ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL); testScopedFailure("function f() {}", ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL); } // Alias Recording Tests // TODO(tylerg) : update these to EasyMock style tests once available public void testNoGoogScope() { String fullJsCode = "var g = goog;\n g.dom.createElement(g.dom.TagName.DIV);"; TransformationHandlerSpy spy = new TransformationHandlerSpy(); transformationHandler = spy; test(fullJsCode, fullJsCode); assertTrue(spy.observedPositions.isEmpty()); } public void testRecordOneAlias() { String fullJsCode = GOOG_SCOPE_START_BLOCK + "var g = goog;\n g.dom.createElement(g.dom.TagName.DIV);\n" + GOOG_SCOPE_END_BLOCK; String expectedJsCode = "goog.dom.createElement(goog.dom.TagName.DIV);\n"; TransformationHandlerSpy spy = new TransformationHandlerSpy(); transformationHandler = spy; test(fullJsCode, expectedJsCode); assertTrue(spy.observedPositions.containsKey("testcode")); List<SourcePosition<AliasTransformation>> positions = spy.observedPositions.get("testcode"); assertEquals(1, positions.size()); verifyAliasTransformationPosition(1, 0, 2, 1, positions.get(0)); assertEquals(1, spy.constructedAliases.size()); AliasSpy aliasSpy = (AliasSpy) spy.constructedAliases.get(0); assertEquals("goog", aliasSpy.observedDefinitions.get("g")); } public void testRecordMultipleAliases() { String fullJsCode = GOOG_SCOPE_START_BLOCK + "var g = goog;\n var b= g.bar;\n var f = goog.something.foo;" + "g.dom.createElement(g.dom.TagName.DIV);\n b.foo();" + GOOG_SCOPE_END_BLOCK; String expectedJsCode = "goog.dom.createElement(goog.dom.TagName.DIV);\n goog.bar.foo();"; TransformationHandlerSpy spy = new TransformationHandlerSpy(); transformationHandler = spy; test(fullJsCode, expectedJsCode); assertTrue(spy.observedPositions.containsKey("testcode")); List<SourcePosition<AliasTransformation>> positions = spy.observedPositions.get("testcode"); assertEquals(1, positions.size()); verifyAliasTransformationPosition(1, 0, 3, 1, positions.get(0)); assertEquals(1, spy.constructedAliases.size()); AliasSpy aliasSpy = (AliasSpy) spy.constructedAliases.get(0); assertEquals("goog", aliasSpy.observedDefinitions.get("g")); assertEquals("g.bar", aliasSpy.observedDefinitions.get("b")); assertEquals("goog.something.foo", aliasSpy.observedDefinitions.get("f")); } public void testRecordAliasFromMultipleGoogScope() { String firstGoogScopeBlock = GOOG_SCOPE_START_BLOCK + "\n var g = goog;\n g.dom.createElement(g.dom.TagName.DIV);\n" + GOOG_SCOPE_END_BLOCK; String fullJsCode = firstGoogScopeBlock + "\n\nvar l = abc.def;\n\n" + GOOG_SCOPE_START_BLOCK + "\n var z = namespace.Zoo;\n z.getAnimals(l);\n" + GOOG_SCOPE_END_BLOCK; String expectedJsCode = "goog.dom.createElement(goog.dom.TagName.DIV);\n" + "\n\nvar l = abc.def;\n\n" + "\n namespace.Zoo.getAnimals(l);\n"; TransformationHandlerSpy spy = new TransformationHandlerSpy(); transformationHandler = spy; test(fullJsCode, expectedJsCode); assertTrue(spy.observedPositions.containsKey("testcode")); List<SourcePosition<AliasTransformation>> positions = spy.observedPositions.get("testcode"); assertEquals(2, positions.size()); verifyAliasTransformationPosition(1, 0, 6, 0, positions.get(0)); verifyAliasTransformationPosition(8, 0, 11, 4, positions.get(1)); assertEquals(2, spy.constructedAliases.size()); AliasSpy aliasSpy = (AliasSpy) spy.constructedAliases.get(0); assertEquals("goog", aliasSpy.observedDefinitions.get("g")); aliasSpy = (AliasSpy) spy.constructedAliases.get(1); assertEquals("namespace.Zoo", aliasSpy.observedDefinitions.get("z")); } private void verifyAliasTransformationPosition(int startLine, int startChar, int endLine, int endChar, SourcePosition<AliasTransformation> pos) { assertEquals(startLine, pos.getStartLine()); assertEquals(startChar, pos.getPositionOnStartLine()); assertTrue( "expected endline >= " + endLine + ". Found " + pos.getEndLine(), pos.getEndLine() >= endLine); assertTrue("expected endChar >= " + endChar + ". Found " + pos.getPositionOnEndLine(), pos.getPositionOnEndLine() >= endChar); } @Override protected ScopedAliases getProcessor(Compiler compiler) { return new ScopedAliases(compiler, null, transformationHandler); } private static class TransformationHandlerSpy implements AliasTransformationHandler { private final Map<String, List<SourcePosition<AliasTransformation>>> observedPositions = Maps.newHashMap(); public final List<AliasTransformation> constructedAliases = Lists.newArrayList(); @Override public AliasTransformation logAliasTransformation( String sourceFile, SourcePosition<AliasTransformation> position) { if(!observedPositions.containsKey(sourceFile)) { observedPositions.put(sourceFile, Lists.<SourcePosition<AliasTransformation>> newArrayList()); } observedPositions.get(sourceFile).add(position); AliasTransformation spy = new AliasSpy(); constructedAliases.add(spy); return spy; } } private static class AliasSpy implements AliasTransformation { public final Map<String, String> observedDefinitions = Maps.newHashMap(); @Override public void addAlias(String alias, String definition) { observedDefinitions.put(alias, definition); } } private static class TypeVerifyingPass implements CompilerPass, NodeTraversal.Callback { private final Compiler compiler; private List<Node> actualTypes = null; public TypeVerifyingPass(Compiler compiler) { this.compiler = compiler; } @Override public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root, this); } @Override public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) { return true; } @Override public void visit(NodeTraversal t, Node n, Node parent) { JSDocInfo info = n.getJSDocInfo(); if (info != null) { Collection<Node> typeNodes = info.getTypeNodes(); if (typeNodes.size() > 0) { if (actualTypes != null) { List<Node> expectedTypes = Lists.newArrayList(); for (Node typeNode : info.getTypeNodes()) { expectedTypes.add(typeNode); } assertEquals("Wrong number of JsDoc types", expectedTypes.size(), actualTypes.size()); for (int i = 0; i < expectedTypes.size(); i++) { assertNull( expectedTypes.get(i).checkTreeEquals(actualTypes.get(i))); } } else { actualTypes = Lists.newArrayList(); for (Node typeNode : info.getTypeNodes()) { actualTypes.add(typeNode); } } } } } } }
/* * Copyright 2011 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Unit tests for {@link ShadowVariables}. * * */ public class ShadowVariablesTest extends CompilerTestCase{ // Use pseudo names to make test easier to read. private boolean generatePseudoNames = false; @Override protected CompilerPass getProcessor(Compiler compiler) { return new RenameVars( compiler, "", false, false, generatePseudoNames, true, null, null, null); } @Override protected int getNumRepetitions() { return 1; } @Override protected void setUp() throws Exception { super.setUp(); generatePseudoNames = false; } public void testShadowSimple1() { test("function foo(x) { return function (y) {} }", "function b(a) { return function (a) {} }"); generatePseudoNames = true; test("function foo ( x ) { return function ( y ) {} }", "function $foo$$($x$$) { return function ($x$$) {} }"); } public void testShadowSimple2() { test("function foo(x,y) { return function (y,z) {} }", "function c(a,b) { return function (a,b) {} }"); generatePseudoNames = true; test("function foo ( x , y ) { return function ( y , z ) {} }", "function $foo$$($x$$,$y$$) { return function ($x$$,$y$$) {} }"); } /** * If we have a choice, pick out the most used variable to shadow. */ public void testShadowMostUsedVar() { generatePseudoNames = true; test("function foo () {var x ; var y ; y ; y ; y ; x ;" + " return function ( k ) {} }", "function $foo$$() {var $x$$; var $y$$; $y$$;$y$$;$y$$;$x$$;" + " return function ($y$$) {} }"); } public void testNoShadowReferencedVariables() { generatePseudoNames = true; test("function f1 () { var x ; x ; x ; x ;" + " return function f2 ( y ) {" + " return function f3 () { x } }}", "function $f1$$() { var $x$$;$x$$;$x$$;$x$$;" + " return function $f2$$($y$$) {" + " return function $f3$$() {$x$$} }}"); } public void testNoShadowGlobalVariables() { generatePseudoNames = true; test("var x ; x ; function foo () { return function ( y ) {}}", "var $x$$; $x$$; function $foo$$() { return function ($y$$) {}}"); } public void testShadowBleedInFunctionName() { generatePseudoNames = true; test("function foo () { function b ( y ) { y } b ; b ;}", "function $foo$$() { function $b$$($b$$) {$b$$} $b$$; $b$$;}"); } public void testNoShadowLessPopularName() { generatePseudoNames = true; // We make sure that y doesn't pick x as a shadow and remains to be renamed // to 'a'. // If we do shadow y with whatever x renames to (say b) we will // get 4 b's and 7 a's while currently we get 3 b's and 8 a's. // I believe this arrangement will always be better for gzipping. test("function f1 ( x ) {" + " function f2 ( y ) {} x ; x ;}" + "function f3 ( i ) {" + " var k ; var j ; j ; j ; j ; j ; j ; j ;}", "function $f1$$($x$$) {" + " function $f2$$($y$$) {} $x$$;$x$$;}" + "function $f3$$($i$$) {" + " var $k$$; var $j$$;$j$$;$j$$;$j$$;$j$$;$j$$;$j$$;}"); } public void testShadowFunctionName() { generatePseudoNames = true; test("var g = function() {" + " var x ; return function(){function y (){}}}", "var $g$$ = function() {" + " var $x$$; return function(){function $x$$(){}}}"); } public void testShadowLotsOfScopes1() { generatePseudoNames = true; test("var g = function( x ) { return function() { return function() {" + " return function() { var y }}}}", "var $g$$ = function($x$$) { return function() { return function() {" + " return function() { var $x$$ }}}}"); } public void testShadowLotsOfScopes2() { generatePseudoNames = true; // 'y' doesn't have a candidate to shadow due to upward referencing. test("var g = function( x ) { return function( y ) " + " {return function() {return function() { x }}}}", "var $g$$ = function($x$$) { return function($y$$) " + " {return function() {return function() { $x$$ }}}}"); test("var g = function( x ) { return function() " + " {return function( y ) {return function() { x }}}}", "var $g$$ = function($x$$) { return function() " + " {return function($y$$) {return function() { $x$$ }}}}"); test("var g = function( x ) { return function() " + " {return function() {return function( y ) { x }}}}", "var $g$$ = function($x$$) { return function() " + " {return function() {return function($y$$) { $x$$ }}}}"); } public void testShadowLotsOfScopes3() { generatePseudoNames = true; // 'y' doesn't have a candidate to shadow due to upward referencing. test("var g = function( x ) { return function() " + " {return function() {return function() { x }; var y }}}", "var $g$$ = function($x$$) { return function() " + " {return function() {return function() { $x$$ }; var $y$$}}}"); test("var g = function( x ) { return function() " + " {return function() {return function() { x }}; var y }}", "var $g$$ = function($x$$) { return function() " + " {return function() {return function() { $x$$ }}; var $y$$}}"); test("var g = function( x ) { return function() " + " {return function() {return function() { x }}}; var y }", "var $g$$ = function($x$$) { return function() " + " {return function() {return function() { $x$$ }}}; var $y$$}"); } public void testShadowLotsOfScopes4() { // Make sure we do get the optimal shadowing scheme where test("var g = function(x) { return function() { return function() {" + " return function(){return function(){};var m};var n};var o}}", "var b = function(a) { return function() { return function() {" + " return function(){return function(){};var a};var a};var a}}"); } public void testShadowLotsOfScopes5() { generatePseudoNames = true; test("var g = function( x ) {" + " return function() { return function() {" + " return function() { return function() {" + " x }; o };var n };var o };var p }", "var $g$$ = function($x$$) {" + " return function() { return function() {" + " return function() { return function() {" + " $x$$};$o$$};var $p$$};var $o$$};var $p$$}"); test("var g = function( x ) {" + " return function() { return function() {" + " return function() { return function() {" + " x }; p };var n };var o };var p }", "var $g$$ = function($x$$) {" + " return function() { return function() {" + " return function() { return function() {" + " $x$$};$p$$};var $o$$};var $o$$};var $p$$}"); } public void testShadowWithShadowAlready() { test("var g = function(x) { return function() { return function() {" + " return function(){return function(){x}};var p};var o};var p}", "var c = function(b) { return function() { return function() {" + " return function(){return function(){b}};var a};var a};var a}"); test("var g = function(x) { return function() { return function() {" + " return function(){return function(){x};p};var p};var o};var p}", "var c = function(b) { return function() { return function() {" + " return function(){return function(){b};a};var a};var a};var a}"); } public void testShadowBug1() { generatePseudoNames = true; test("function f ( x ) { return function( y ) {" + " return function( x ) { x + y ; }}}", "function $f$$($x$$) { return function($y$$) {" + " return function($x$$) { $x$$ + $y$$; }}}"); } public void testOptimal() { // A test for a case that wasn't optimal in a single pass algorithm. test("function f(x) { function g(y) { function h(x) {}}}", "function c(a) { function b(a) { function b(a) {}}}"); } public void testSharingAcrossInnerScopes() { test("function f() {var f=function g(){g()}; var x=function y(){y()}}", "function c() {var d=function a(){a()}; var e=function b(){b()}}"); test("function f(x) { return x ? function(y){} : function(z) {} }", "function b(a) { return a ? function(a){} : function(a) {} }"); } public void testExportedLocal1() { test("function f(a) { a();a();a(); return function($super){} }", "function b(a) { a();a();a(); return function($super){} }"); } public void testExportedLocal2() { test("function f($super) { $super();$super(); return function(a){} }", "function a($super) { $super();$super(); return function(b){} }"); } public void testBug4172539() { // All the planets must line up. When we look at the 2nd inner function, // y can shadow x, also m can shadow x as well. Now all that is left for // n to shadow is 'y'. Now because y has already shadowed x, the pseudo // name maps has already updated y gets $x$$. This mean n will be updated // with "$x$$" in the name map which is incorrect. That is the reason // why we can't update the pseudo name map on-the-fly. generatePseudoNames = true; test("function f(x) {" + " x;x;x;" + " return function (y) { y; x };" + " return function (y) {" + " y;" + " return function (m, n) {" + " m;m;m;" + " };" + " };" + "}", "function $f$$($x$$) {" + " $x$$;$x$$;$x$$;" + " return function ($y$$) { $y$$; $x$$ };" + " return function ($x$$) {" + " $x$$;" + " return function ($x$$, $y$$) {" + " $x$$;$x$$;$x$$;" + " };" + " };" + "}"); } }
/* * Copyright 2010 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.ImmutableSet; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.SideEffectsAnalysis.LocationAbstractionMode; import com.google.javascript.rhino.Node; /** * Tests for {@link SideEffectsAnalysis}. * * @author dcc@google.com (Devin Coughlin) * */ public class SideEffectsAnalysisTest extends CompilerTestCase { private static final String SHARED_EXTERNS = "var arguments = [];"; LocationAbstractionMode currentLocationAbstractionIdentifier; SideEffectsAnalysis currentAnalysis = null; Compiler currentCompiler = null; Node currentJsRoot = null; @Override protected CompilerPass getProcessor(final Compiler compiler) { currentCompiler = compiler; currentAnalysis = new SideEffectsAnalysis(compiler, currentLocationAbstractionIdentifier); return new CompilerPass() { @Override public void process(Node externs, Node root) { if (currentLocationAbstractionIdentifier == LocationAbstractionMode.VISIBILITY_BASED) { // Run var when using the visibility abstraction // because it is unsound if it fails. final VarCheck varCheck = new VarCheck(compiler); varCheck.process(externs, root); } currentAnalysis.process(externs, root); } }; } @Override public void setUp() throws Exception { super.setUp(); currentAnalysis = null; currentCompiler = null; } public void testDegenerateSafeMoves() { // Env is empty assertSafeMoveDegenerate("src: 1; env: ; dest: 3;"); // Src and env pure assertSafeMoveDegenerate("src: 1; env: 2; dest: 3;"); // Only refs assertSafeMoveDegenerate("src: 1; env: x; dest: 3;"); assertSafeMoveDegenerate("src: x; env: 1; dest: 3;"); // Only mods assertSafeMoveDegenerate("src: 1; env: x++; dest: 3;"); assertSafeMoveDegenerate("src: x++; env: 1; dest: 3;"); } public void testVisibilitySafeMoves() { // Env is empty assertSafeMoveVisibility("src: 1; env: ; dest: 3;"); // Src and env pure assertSafeMoveVisibility("src: 1; env: 2; dest: 3;"); // Only refs assertSafeMoveVisibility("var x; src: 1; env: x; dest: 3;"); assertSafeMoveVisibility("var x; src: x; env: 1; dest: 3;"); // Only mods assertSafeMoveVisibility("var x; src: 1; env: x++; dest: 3;"); assertSafeMoveVisibility("var x; src: x++; env: 1; dest: 3;"); // Source references global, env changes local assertSafeMoveVisibility( "var x;" + "function f(){" + "var y;" + "src: x;" + "env: y++;" + "dest: 3;" + "}"); // Source changes global, env refs local assertSafeMoveVisibility( "var x;" + "function f(){" + "var y;" + "src: x++;" + "env: y;" + "dest: 3;" + "}"); // Source references global, env changes local with shadowing assertSafeMoveVisibility( "var x;" + "var y;" + "function f(){" + "var y;" + "src: x;" + "env: y++;" + "dest: 3;" + "}"); // Source changes global, env refs local with shadowing assertSafeMoveVisibility( "var x;" + "var y;" + "function f(){" + "var y;" + "src: x++;" + "env: y;" + "dest: 3;" + "}"); // Source references captured local, env changes local assertSafeMoveVisibility( "function f(){" + "var x;" + "var y;" + "src: x;" + "env: y++;" + "dest: 3;" + "function inner() {" + "x" + "}" + "}"); // Source changes captured local, env refs local assertSafeMoveVisibility( "function f(){" + "var x;" + "var y;" + "src: x++;" + "env: y;" + "dest: 3;" + "function inner() {" + "x" + "}" + "}"); // Source references heap, env changes local assertSafeMoveVisibility( "var x = {};" + "function f(){" + "var y;" + "src: x.a;" + "env: y++;" + "dest: 3;" + "}"); // Source changes heap, env refs local assertSafeMoveVisibility( "var x = {};" + "function f(){" + "var y;" + "src: x.a++;" + "env: y;" + "dest: 3;" + "}"); // MOD in function expressions shouldn't count assertSafeMoveVisibility( "var x = {};" + "src: x.a;" + "env: (function() {" + "x.a++;" + "});" + "dest: 3;"); // REF in function expressions shouldn't count assertSafeMoveVisibility( "var x = {};" + "src: x.a++;" + "env: (function() {" + "x.a;" + "});" + "dest: 3;"); } public void testDegenerateUnsafeMoves() { // Unsafe to move increment across read assertUnsafeMoveDegenerate("src: x++; env: foo(y); dest: 3;"); // Unsafe to move read across increment assertUnsafeMoveDegenerate("src: foo(y); env: x++; dest: 3;"); // Unsafe to move write across write assertUnsafeMoveDegenerate("src: x = 7; env: y = 3; dest:3;"); } public void testVisibilityUnsafeMoves() { // Unsafe to move increment across read for global variables assertUnsafeMoveVisibility("var x,y; src: x++; env: y; dest: 3;"); // Unsafe to move increment across read for local variables assertUnsafeMoveVisibility("function f() {" + "var x,y; src: x++; env: y; dest: 3;" + "}"); // Unsafe to move increment across read for captured local variables assertUnsafeMoveVisibility( "function f() {" + "var x,y; src: x++; env: y; dest: 3;" + "function inner() {" + "x; y;" + "}" + "}"); // Unsafe to move increment across read for heap locations assertUnsafeMoveVisibility("var x,y; src: x.a++; env: y.b; dest: 3;"); // Unsafe to move read across increment of for global variables assertUnsafeMoveVisibility("var x,y; src: y; env: x++; dest: 3;"); // Unsafe to move read across increment for local variables assertUnsafeMoveVisibility("function f() {" + "var x,y; src: x; env: y++; dest: 3;" + "}"); // Unsafe to move read across increment for captured local variables assertUnsafeMoveVisibility( "function f() {" + "var x,y; src: x; env: y++; dest: 3;" + "function inner() {" + "x; y;" + "}" + "}"); // Unsafe to move read across increment for heap locations assertUnsafeMoveVisibility("var x,y; src: x.a; env: y.b++; dest: 3;"); // Unsafe to move write across write for globals assertUnsafeMoveVisibility("var x,y; src: x = 7; env: y = 3; dest: 3;"); // Unsafe to move write across write for local variables assertUnsafeMoveVisibility("function f() {" + "var x,y; src: x = 7; env: y = 3; dest: 3;" + "}"); // Unsafe to move write across write for captured local variables assertUnsafeMoveVisibility( "function f() {" + "var x,y; src: x = 7; env: y = 3; dest: 3;" + "function inner() {" + "x; y;" + "}" + "}"); // Unsafe to move write across write for heap locations assertUnsafeMoveVisibility("var x,y; src: x.a = 7; env: y.b = 3; dest: 3;"); } public void testVisibilityMoveCalls() { // Interprocedural side effect analysis isn't implemented yet, so any calls // should make movement unsafe, since we don't know what those calls are // doing. // TODO(dcc): implement interprocedural side effect analysis. // Source makes call, env refs global assertUnsafeMoveVisibility( "var x = {};" + "var g = function(){};" + "function f(){" + "var y;" + "src: g();" + "env: x;" + "dest: 3;" + "}"); // Source makes refs global, env makes call assertUnsafeMoveVisibility( "var x = {};" + "var g = function(){};" + "function f(){" + "var y;" + "src: x;" + "env: g();" + "dest: 3;" + "}"); } public void testVisibilityMergesParametersWithHeap() { // For now, we expect the visibility based location abstraction // to merge parameter variable locations with heap locations because // parameters can be references and modified via the arguments object. // Source changes heap, env refs parameter assertUnsafeMoveVisibility( "var x = {};" + "function f(y){" + "src: x[0]++;" + "env: y;" + "dest: 3;" + "}"); // Source refs heap, env changes parameters assertUnsafeMoveVisibility( "var x = {};" + "function f(y){" + "src: x[0];" + "env: y++;" + "dest: 3;" + "}"); // Source changes arguments explicitly, env refs parameter assertUnsafeMoveVisibility( "var x = {};" + "function f(y){" + "src: arguments[0]++;" + "env: y;" + "dest: 3;" + "}"); // Source refs arguments explicitly, env changes parameter assertUnsafeMoveVisibility( "var x = {};" + "function f(y){" + "src: arguments[0];" + "env: y++;" + "dest: 3;" + "}"); } public void testMovedSideEffectsMustHaveSameControlFlow() { // Safe to move within IF block assertSafeMoveVisibility( "var a;" + "function f() {" + "var l;" + "if (l) {" + "src: a++;" + "env: 3;" + "dest: 3;" + "}" + "}" ); // Unsafe to move between two IF blocks assertUnsafeMoveVisibility( "var a;" + "function f() {" + "var l;" + "if (l) {" + "src: a++;" + "env: 3;" + "}" + "if (l) {" + "dest: 3;" + "}" + "}" ); // Unsafe to move between then/else of same IF block assertUnsafeMoveVisibility( "var a;" + "function f() {" + "var l;" + "if (l) {" + "src: a++;" + "env: 3;" + "} else {" + "dest: 3;" + "}" + "}" ); // Safe to move within WHILE block assertSafeMoveVisibility( "var a;" + "function f() {" + "var l;" + "while (l) {" + "src: a++;" + "env: 3;" + "dest: 3;" + "}" + "}" ); // Unsafe to move within WHILE block with BREAK assertUnsafeMoveVisibility( "var a;" + "function f() {" + "var l;" + "while (l) {" + "src: a++;" + "env: l;" + "break;" + "dest: 3;" + "}" + "}" ); // Unsafe to move within WHILE block with continue assertUnsafeMoveVisibility( "var a;" + "function f() {" + "var l;" + "while (l) {" + "src: a++;" + "env: 3;" + "continue;" + "dest: 3;" + "}" + "}" ); // Unsafe to move within WHILE block with continue assertUnsafeMoveVisibility( "var a;" + "function f() {" + "var l;" + "while (l) {" + "src: a++;" + "env: 3;" + "return;" + "dest: 3;" + "}" + "}" ); // Safe to move within DO assertSafeMoveVisibility( "var a;" + "function f() {" + "var l;" + "do {" + "src: a++;" + "env: 3;" + "dest: 3;" + "} while(l)" + "}" ); // Unsafe to move outside DO assertUnsafeMoveVisibility( "var a;" + "function f() {" + "var l;" + "do {" + "src: a++;" + "env: 3;" + "} while(l)" + "dest: 3;" + "}" ); // It should be safe to move within CASE // but we disallow for now because analyzing // CASE fall-through and BREAKs is complicated. assertUnsafeMoveVisibility( "var a;" + "function f() {" + "var l;" + "switch(l) {" + "case 17:" + "src: a++;" + "env: 3;" + "dest: 3;" + "break;" + "}" + "}" ); // Unsafe to move between CASEs assertUnsafeMoveVisibility( "var a;" + "function f() {" + "var l;" + "switch(l) {" + "case 17:" + "src: a++;" + "env: 3;" + "break;" + "case 18:" + "dest: 3;" + "break;" + "}" + "}" ); // Unsafe to move between FUNCTIONs assertUnsafeMoveVisibility( "var a;" + "function f() {" + "src: a++;" + "env: 3;" + "}" + "function g() {" + "dest: 3;" + "}" ); } private SideEffectsAnalysis.AbstractMotionEnvironment environment( Node ...nodes) { return new SideEffectsAnalysis.RawMotionEnvironment( ImmutableSet.copyOf(nodes)); } private void assertMove(LocationAbstractionMode abstraction, String src, boolean expected) { SideEffectsAnalysis analysis = compileAndRun(src, abstraction); Node sourceNode = findLabeledStatement("src"); Node environmentNode = findLabeledStatement("env"); Node destinationNode = findLabeledStatement("dest"); boolean result = analysis.safeToMoveBefore(sourceNode, environment(environmentNode), destinationNode); if (expected) { assertTrue(result); } else { assertFalse(result); } } private void assertSafeMoveDegenerate(String src) { assertMove(LocationAbstractionMode.DEGENERATE, src, true); } private void assertUnsafeMoveDegenerate(String src) { assertMove(LocationAbstractionMode.DEGENERATE, src, false); } private void assertSafeMoveVisibility(String src) { assertMove(LocationAbstractionMode.VISIBILITY_BASED, src, true); } private void assertUnsafeMoveVisibility(String src) { assertMove(LocationAbstractionMode.VISIBILITY_BASED, src, false); } private SideEffectsAnalysis compileAndRun(String js, LocationAbstractionMode locationAbstractionIdentifier) { currentLocationAbstractionIdentifier = locationAbstractionIdentifier; testSame(SHARED_EXTERNS, js, null); currentJsRoot = currentCompiler.jsRoot; return currentAnalysis; } // Shamelessly stolen from NameReferenceGraphConstructionTest private Node findLabeledStatement(String label) { LabeledStatementSearcher s = new LabeledStatementSearcher(label); new NodeTraversal(currentCompiler, s).traverse(currentCompiler.jsRoot); assertNotNull("Label " + label + " should be in the source code", s.found); return s.found; } /** * Quick traversal to find a given labeled statement in the AST. * * Given "foo", finds the statement a = x in * foo: a = x; */ private class LabeledStatementSearcher extends AbstractPostOrderCallback { Node found = null; final String target; LabeledStatementSearcher(String target) { this.target = target; } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isLabel() && target.equals(n.getFirstChild().getString())) { found = n.getLastChild(); } } } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Multiset; import com.google.common.collect.Sets; import com.google.common.collect.TreeMultiset; import com.google.javascript.jscomp.DefinitionsRemover.Definition; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import java.util.Collection; import java.util.Set; /** * Tests for {@link SimpleDefinitionFinder} * */ public class SimpleDefinitionFinderTest extends CompilerTestCase { Set<String> found = Sets.newTreeSet(); @Override protected int getNumRepetitions() { // run pass once. return 1; } @Override protected void tearDown() throws Exception { super.tearDown(); found.clear(); } public void testDefineNumber() throws Exception { checkDefinitionsInJs( "var a = 1", ImmutableSet.of("DEF NAME a -> NUMBER")); checkDefinitionsInJs( "a = 1", ImmutableSet.of("DEF NAME a -> NUMBER")); checkDefinitionsInJs( "a.b = 1", ImmutableSet.of("DEF GETPROP a.b -> NUMBER")); // getelem expressions are invisible to the definition gatherer. checkDefinitionsInJs( "a[\"b\"] = 1", ImmutableSet.<String>of()); checkDefinitionsInJs( "f().b = 1", ImmutableSet.of("DEF GETPROP null -> NUMBER")); checkDefinitionsInJs( "({a : 1}); o.a", ImmutableSet.of("DEF STRING_KEY null -> NUMBER", "USE GETPROP o.a -> [NUMBER]")); // TODO(johnlenz): Fix this. checkDefinitionsInJs( "({'a' : 1}); o['a']", ImmutableSet.<String>of("DEF STRING_KEY null -> NUMBER")); checkDefinitionsInJs( "({1 : 1}); o[1]", ImmutableSet.<String>of("DEF STRING_KEY null -> NUMBER")); checkDefinitionsInJs( "var a = {b : 1}; a.b", ImmutableSet.of("DEF NAME a -> <null>", "DEF STRING_KEY null -> NUMBER", "USE NAME a -> [<null>]", "USE GETPROP a.b -> [NUMBER]")); } public void testDefineGet() throws Exception { // TODO(johnlenz): Add support for quoted properties checkDefinitionsInJs( "({get a() {}}); o.a", ImmutableSet.of("DEF GETTER_DEF null -> FUNCTION", "USE GETPROP o.a -> [FUNCTION]")); } public void testDefineSet() throws Exception { // TODO(johnlenz): Add support for quoted properties checkDefinitionsInJs( "({set a(b) {}}); o.a", ImmutableSet.of("DEF NAME b -> <null>", "DEF SETTER_DEF null -> FUNCTION", "USE GETPROP o.a -> [FUNCTION]")); } public void testDefineFunction() throws Exception { checkDefinitionsInJs( "var a = function(){}", ImmutableSet.of("DEF NAME a -> FUNCTION")); checkDefinitionsInJs( "var a = function f(){}", ImmutableSet.of("DEF NAME f -> FUNCTION", "DEF NAME a -> FUNCTION")); checkDefinitionsInJs( "function a(){}", ImmutableSet.of("DEF NAME a -> FUNCTION")); checkDefinitionsInJs( "a = function(){}", ImmutableSet.of("DEF NAME a -> FUNCTION")); checkDefinitionsInJs( "a.b = function(){}", ImmutableSet.of("DEF GETPROP a.b -> FUNCTION")); // getelem expressions are invisible to the definition gatherer. checkDefinitionsInJs( "a[\"b\"] = function(){}", ImmutableSet.<String>of()); checkDefinitionsInJs( "f().b = function(){}", ImmutableSet.of("DEF GETPROP null -> FUNCTION")); } public void testFunctionArgumentsBasic() throws Exception { checkDefinitionsInJs( "function f(a){return a}", ImmutableSet.of("DEF NAME a -> <null>", "USE NAME a -> [<null>]", "DEF NAME f -> FUNCTION")); checkDefinitionsInJs( "var a = 1; function f(a){return a}", ImmutableSet.of("DEF NAME a -> NUMBER", "DEF NAME a -> <null>", "USE NAME a -> [<null>, NUMBER]", "DEF NAME f -> FUNCTION")); } public void testFunctionArgumentsInExterns() throws Exception { final String DEF = "var f = function(arg1, arg2){}"; final String USE = "f(1, 2)"; // function arguments are definitions when they appear in source. checkDefinitionsInJs( DEF + ";" + USE, ImmutableSet.of("DEF NAME f -> FUNCTION", "DEF NAME arg1 -> <null>", "DEF NAME arg2 -> <null>", "USE NAME f -> [FUNCTION]")); // function arguments are NOT definitions when they appear in externs. checkDefinitions( DEF, USE, ImmutableSet.of("DEF NAME f -> EXTERN FUNCTION", "USE NAME f -> [EXTERN FUNCTION]")); } public void testMultipleDefinition() throws Exception { checkDefinitionsInJs( "a = 1; a = 2; a", ImmutableSet.of("DEF NAME a -> NUMBER", "USE NAME a -> [NUMBER x 2]")); checkDefinitionsInJs( "a = 1; a = 'a'; a", ImmutableSet.of("DEF NAME a -> NUMBER", "DEF NAME a -> STRING", "USE NAME a -> [NUMBER, STRING]")); checkDefinitionsInJs( "a = 1; b = 2; a = b; a", ImmutableSet.of("DEF NAME a -> <null>", "DEF NAME a -> NUMBER", "DEF NAME b -> NUMBER", "USE NAME a -> [<null>, NUMBER]", "USE NAME b -> [NUMBER]")); checkDefinitionsInJs( "a = 1; b = 2; c = b; c = a; c", ImmutableSet.of("DEF NAME a -> NUMBER", "DEF NAME b -> NUMBER", "DEF NAME c -> <null>", "USE NAME a -> [NUMBER]", "USE NAME b -> [NUMBER]", "USE NAME c -> [<null> x 2]")); checkDefinitionsInJs( "function f(){} f()", ImmutableSet.of("DEF NAME f -> FUNCTION", "USE NAME f -> [FUNCTION]")); checkDefinitionsInJs( "function f(){} f.call(null)", ImmutableSet.of("DEF NAME f -> FUNCTION", "USE NAME f -> [FUNCTION]", "USE GETPROP f.call -> [FUNCTION]")); checkDefinitionsInJs( "function f(){} f.apply(null, [])", ImmutableSet.of("DEF NAME f -> FUNCTION", "USE NAME f -> [FUNCTION]", "USE GETPROP f.apply -> [FUNCTION]")); checkDefinitionsInJs( "function f(){} f.foobar()", ImmutableSet.of("DEF NAME f -> FUNCTION", "USE NAME f -> [FUNCTION]")); checkDefinitionsInJs( "function f(){} f(); f.call(null)", ImmutableSet.of("DEF NAME f -> FUNCTION", "USE NAME f -> [FUNCTION]", "USE GETPROP f.call -> [FUNCTION]")); } public void testDefinitionInExterns() throws Exception { String externs = "var a = 1"; checkDefinitionsInExterns( externs, ImmutableSet.of("DEF NAME a -> EXTERN NUMBER")); checkDefinitions( externs, "var b = 1", ImmutableSet.of("DEF NAME a -> EXTERN NUMBER", "DEF NAME b -> NUMBER")); checkDefinitions( externs, "a = \"foo\"; a", ImmutableSet.of("DEF NAME a -> EXTERN NUMBER", "DEF NAME a -> STRING", "USE NAME a -> [EXTERN NUMBER, STRING]")); checkDefinitionsInExterns( "var a = {}; a.b = 10", ImmutableSet.of("DEF GETPROP a.b -> EXTERN NUMBER", "DEF NAME a -> EXTERN <null>", "USE NAME a -> [EXTERN <null>]")); checkDefinitionsInExterns( "var a = {}; a.b", ImmutableSet.of("DEF GETPROP a.b -> EXTERN <null>", "DEF NAME a -> EXTERN <null>", "USE NAME a -> [EXTERN <null>]")); checkDefinitions( "var a = {}", "a.b = 1", ImmutableSet.of("DEF GETPROP a.b -> NUMBER", "DEF NAME a -> EXTERN <null>", "USE NAME a -> [EXTERN <null>]")); checkDefinitions( "var a = {}", "a.b", ImmutableSet.of("DEF NAME a -> EXTERN <null>", "USE NAME a -> [EXTERN <null>]")); checkDefinitionsInExterns( externs, ImmutableSet.of("DEF NAME a -> EXTERN NUMBER")); } public void testObjectLitInExterns() { checkDefinitions( "var goog = {};" + "/** @type {number} */ goog.HYBRID;" + "/** @enum */ goog.Enum = {HYBRID: 0, ROADMAP: 1};", "goog.HYBRID; goog.Enum.ROADMAP;", ImmutableSet.of( "DEF GETPROP goog.Enum -> EXTERN <null>", "DEF GETPROP goog.HYBRID -> EXTERN <null>", "DEF NAME goog -> EXTERN <null>", "DEF STRING_KEY null -> EXTERN NUMBER", "USE GETPROP goog.Enum -> [EXTERN <null>]", "USE GETPROP goog.Enum.ROADMAP -> [EXTERN NUMBER]", "USE GETPROP goog.HYBRID -> [EXTERN <null>, EXTERN NUMBER]", "USE NAME goog -> [EXTERN <null>]")); } public void testCallInExterns() { checkDefinitionsInExterns( "var goog = {};" + "/** @constructor */ goog.Response = function() {};" + "goog.Response.prototype.get;" + "goog.Response.prototype.get().get;", ImmutableSet.of( "DEF GETPROP goog.Response -> EXTERN FUNCTION", "DEF GETPROP goog.Response.prototype.get -> EXTERN <null>", "DEF GETPROP null -> EXTERN <null>", "DEF NAME goog -> EXTERN <null>", "USE GETPROP goog.Response -> [EXTERN FUNCTION]", "USE GETPROP goog.Response.prototype.get -> [EXTERN <null> x 2]", "USE NAME goog -> [EXTERN <null>]")); } void checkDefinitionsInExterns(String externs, Set<String> expected) { checkDefinitions(externs, "", expected); } void checkDefinitionsInJs(String js, Set<String> expected) { checkDefinitions("", js, expected); } void checkDefinitions(String externs, String source, Set<String> expected) { testSame(externs, source, null); assertEquals(expected, found); found.clear(); } @Override protected CompilerPass getProcessor(Compiler compiler) { return new SimpleDefinitionEnumerator(compiler); } /** * Run SimpleDefinitionFinder, then gather a list of definitions. */ private class SimpleDefinitionEnumerator extends AbstractPostOrderCallback implements CompilerPass { private final SimpleDefinitionFinder passUnderTest; private final Compiler compiler; SimpleDefinitionEnumerator(Compiler compiler) { this.passUnderTest = new SimpleDefinitionFinder(compiler); this.compiler = compiler; } @Override public void process(Node externs, Node root) { passUnderTest.process(externs, root); NodeTraversal.traverse(compiler, externs, this); NodeTraversal.traverse(compiler, root, this); for (DefinitionSite defSite : passUnderTest.getDefinitionSites()) { Node node = defSite.node; Definition definition = defSite.definition; StringBuilder sb = new StringBuilder(); sb.append("DEF "); sb.append(Token.name(node.getType())); sb.append(" "); sb.append(node.getQualifiedName()); sb.append(" -> "); if (definition.isExtern()) { sb.append("EXTERN "); } Node rValue = definition.getRValue(); if (rValue != null) { sb.append(Token.name(rValue.getType())); } else { sb.append("<null>"); } found.add(sb.toString()); } } @Override public void visit(NodeTraversal traversal, Node node, Node parent) { Collection<Definition> defs = passUnderTest.getDefinitionsReferencedAt(node); if (defs != null) { StringBuilder sb = new StringBuilder(); sb.append("USE "); sb.append(Token.name(node.getType())); sb.append(" "); sb.append(node.getQualifiedName()); sb.append(" -> "); Multiset<String> defstrs = TreeMultiset.create(); for (Definition def : defs) { String defstr; Node rValue = def.getRValue(); if (rValue != null) { defstr = Token.name(rValue.getType()); } else { defstr = "<null>"; } if (def.isExtern()) { defstr = "EXTERN " + defstr; } defstrs.add(defstr); } sb.append(defstrs.toString()); found.add(sb.toString()); } } } }
/* * Copyright 2010 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.rhino.Node; /** * Tests for {@link SimpleFunctionAliasAnalysis}. * * @author dcc@google.com (Devin Coughlin) */ public class SimpleFunctionAliasAnalysisTest extends CompilerTestCase { private SimpleFunctionAliasAnalysis analysis; private Compiler lastCompiler; @Override protected CompilerPass getProcessor(final Compiler compiler) { return new CompilerPass() { @Override public void process(Node externs, Node root) { SimpleDefinitionFinder finder = new SimpleDefinitionFinder(compiler); finder.process(externs, root); analysis = new SimpleFunctionAliasAnalysis(); analysis.analyze(finder); lastCompiler = compiler; } }; } public void testFunctionGetIsAliased() { // Aliased by VAR assignment String source = "function A(){};\n" + "var ns = {};\n" + "ns.B = function() {};\n" + "var C = function() {}\n" + "var D = function() {}\n" + "var aliasA = A;\n" + "var aliasB = ns.B;\n" + "var aliasC = C;\n" + "D();"; compileAndRun(source); assertFunctionAliased(true, "A"); assertFunctionAliased(true, "ns.B"); assertFunctionAliased(true, "C"); assertFunctionAliased(false, "D"); // Aliased by normal assignment source = "function A(){};\n" + "var ns = {};\n" + "ns.B = function() {};\n" + "var C = function() {}\n" + "ns.D = function() {}\n" + "var aliasA;\n" + "aliasA = A;\n" + "var aliasB = {};\n" + "aliasB.foo = ns.B;\n" + "var aliasC;\n" + "aliasC = C;\n" + "ns.D();"; compileAndRun(source); assertFunctionAliased(true, "A"); assertFunctionAliased(true, "ns.B"); assertFunctionAliased(true, "C"); assertFunctionAliased(false, "ns.D"); // Aliased by passing as parameter source = "function A(){};\n" + "var ns = {};\n" + "ns.B = function() {};\n" + "var C = function() {}\n" + "function D() {}\n" + "var foo = function(a) {}\n" + "foo(A);\n" + "foo(ns.B)\n" + "foo(C);\n" + "D();"; compileAndRun(source); assertFunctionAliased(true, "A"); assertFunctionAliased(true, "ns.B"); assertFunctionAliased(true, "C"); assertFunctionAliased(false, "D"); // Not aliased by being target of call source = "function A(){};\n" + "var ns = {};\n" + "ns.B = function() {};\n" + "var C = function() {}\n" + "A();\n" + "ns.B();\n" + "C();\n"; compileAndRun(source); assertFunctionAliased(false, "A"); assertFunctionAliased(false, "ns.B"); assertFunctionAliased(false, "C"); // Not aliased by GET{PROP,ELEM} source = "function A(){};\n" + "var ns = {};\n" + "ns.B = function() {};\n" + "var C = function() {}\n" + "A.foo;\n" + "ns.B.prototype;\n" + "C[0];\n"; compileAndRun(source); assertFunctionAliased(false, "A"); assertFunctionAliased(false, "ns.B"); assertFunctionAliased(false, "C"); } public void testFunctionGetIsExposedToCallOrApply() { // Exposed to call String source = "function A(){};\n" + "function B(){};\n" + "function C(){};\n" + "var x;\n" + "A.call(x);\n" + "B.apply(x);\n" + "C();\n"; compileAndRun(source); assertFunctionExposedToCallOrApply(true, "A"); assertFunctionExposedToCallOrApply(true, "B"); assertFunctionExposedToCallOrApply(false, "C"); source = "var ns = {};" + "ns.A = function(){};\n" + "ns.B = function(){};\n" + "ns.C = function(){};\n" + "var x;\n" + "ns.A.call(x);\n" + "ns.B.apply(x);\n" + "ns.C();\n"; compileAndRun(source); assertFunctionExposedToCallOrApply(true, "ns.A"); assertFunctionExposedToCallOrApply(true, "ns.B"); assertFunctionExposedToCallOrApply(false, "ns.C"); } private void assertFunctionAliased(boolean aliasStatus, String functionName) { Node function = findFunction(functionName); assertEquals(aliasStatus, analysis.isAliased(function)); } private void assertFunctionExposedToCallOrApply(boolean exposure, String functionName) { Node function = findFunction(functionName); assertEquals(exposure, analysis.isExposedToCallOrApply(function)); } private void compileAndRun(String source) { testSame(source, source, null); } private Node findFunction(String name) { FunctionFinder f = new FunctionFinder(name); new NodeTraversal(lastCompiler, f).traverse(lastCompiler.jsRoot); assertNotNull("Couldn't find " + name, f.found); return f.found; } /** * Quick Traversal to find a given function in the AST. */ private class FunctionFinder extends AbstractPostOrderCallback { Node found = null; final String target; FunctionFinder(String target) { this.target = target; } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isFunction() && target.equals(NodeUtil.getFunctionName(n))) { found = n; } } } }
/* * Copyright 2011 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; /** * @author johnlenz@google.com (John Lenz) */ public class SourceInformationAnnotatorTest extends CompilerTestCase { @Override protected CompilerPass getProcessor(final Compiler compiler) { return new CompilerPass() { @Override public void process(Node externs, Node root) { NodeTraversal.traverse(compiler, root, new SourceInformationAnnotator("", false)); }}; } public void testPreserveAnnotatedName() { Node root = new Node(Token.SCRIPT); Node name = Node.newString("foo"); name.putProp(Node.ORIGINALNAME_PROP, "bar"); root.addChildToBack(name); NodeTraversal.traverse(null, root, new SourceInformationAnnotator("", false)); assertEquals(name.getProp(Node.ORIGINALNAME_PROP), "bar"); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.debugging.sourcemap.SourceMapConsumer; import com.google.debugging.sourcemap.SourceMapConsumerV2; import com.google.debugging.sourcemap.SourceMapTestCase; import com.google.javascript.jscomp.SourceMap.Format; import java.io.IOException; import java.util.ArrayList; import java.util.List; /** * * @author johnlenz@google.com (John Lenz) */ public class SourceMapTest extends SourceMapTestCase { public SourceMapTest() { } private List<SourceMap.LocationMapping> mappings; public void testPrefixReplacement1() throws IOException { mappings = new ArrayList<SourceMap.LocationMapping>(); // mapping can be used to remove a prefix mappings.add( new SourceMap.LocationMapping("pre/","") ); checkSourceMap2("", "pre/file1", "", "pre/file2" , "{\n" + "\"version\":2,\n" + "\"file\":\"testcode\",\n" + "\"lineCount\":1,\n" + "\"lineMaps\":[\"\"],\n" + "\"mappings\":[],\n" + "\"sources\":[\"file1\",\"file2\"],\n" + "\"names\":[]\n" + "}\n"); } public void testPrefixReplacement2() throws IOException { mappings = new ArrayList<SourceMap.LocationMapping>(); // mapping can be used to replace a prefix mappings.add( new SourceMap.LocationMapping("pre/file","src") ); checkSourceMap2("", "pre/file1", "", "pre/file2" , "{\n" + "\"version\":2,\n" + "\"file\":\"testcode\",\n" + "\"lineCount\":1,\n" + "\"lineMaps\":[\"\"],\n" + "\"mappings\":[],\n" + "\"sources\":[\"src1\",\"src2\"],\n" + "\"names\":[]\n" + "}\n"); } public void testPrefixReplacement3() throws IOException { mappings = new ArrayList<SourceMap.LocationMapping>(); // multiple mappings can be applied mappings.add( new SourceMap.LocationMapping("file1","x") ); mappings.add( new SourceMap.LocationMapping("file2","y") ); checkSourceMap2("", "file1", "", "file2" , "{\n" + "\"version\":2,\n" + "\"file\":\"testcode\",\n" + "\"lineCount\":1,\n" + "\"lineMaps\":[\"\"],\n" + "\"mappings\":[],\n" + "\"sources\":[\"x\",\"y\"],\n" + "\"names\":[]\n" + "}\n"); } public void testPrefixReplacement4() throws IOException { mappings = new ArrayList<SourceMap.LocationMapping>(); // first match wins mappings.add( new SourceMap.LocationMapping("file1","x") ); mappings.add( new SourceMap.LocationMapping("file","y") ); checkSourceMap2("", "file1", "", "file2" , "{\n" + "\"version\":2,\n" + "\"file\":\"testcode\",\n" + "\"lineCount\":1,\n" + "\"lineMaps\":[\"\"],\n" + "\"mappings\":[],\n" + "\"sources\":[\"x\",\"y2\"],\n" + "\"names\":[]\n" + "}\n"); } @Override protected CompilerOptions getCompilerOptions() { CompilerOptions options = super.getCompilerOptions(); if (mappings != null) { options.sourceMapLocationMappings = mappings; } return options; } @Override public void setUp() { super.setUp(); } private void checkSourceMap2( String js1, String file1, String js2, String file2, String expectedMap) throws IOException { RunResult result = compile(js1, file1, js2, file2); assertEquals(expectedMap, result.sourceMapFileContent); assertEquals(result.sourceMapFileContent, getSourceMap(result)); } @Override protected Format getSourceMapFormat() { return Format.V2; } @Override protected SourceMapConsumer getSourceMapConsumer() { return new SourceMapConsumerV2(); } }
/* * Copyright 2010 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.ImmutableSet; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.SpecializeModule.SpecializationState; import com.google.javascript.rhino.Node; /** * Tests for {@link SpecializeModule}. * * @author dcc@google.com (Devin Coughlin) */ public class SpecializeModuleTest extends CompilerTestCase { private static final String SHARED_EXTERNS = "var alert = function() {}"; public SpecializeModuleTest() { super(SHARED_EXTERNS); } private PassFactory inlineFunctions = new PassFactory("inlineFunctions", true) { @Override protected CompilerPass create(AbstractCompiler compiler) { return new InlineFunctions(compiler, compiler.getUniqueNameIdSupplier(), true, false, true, true, true); } }; private PassFactory removeUnusedPrototypeProperties = new PassFactory("removeUnusedPrototypeProperties", true) { @Override protected CompilerPass create(AbstractCompiler compiler) { return new RemoveUnusedPrototypeProperties(compiler, false, false); } }; private PassFactory devirtualizePrototypeMethods = new PassFactory("devirtualizePrototypeMethods", true) { @Override protected CompilerPass create(AbstractCompiler compiler) { return new DevirtualizePrototypeMethods(compiler); } }; @Override protected CompilerPass getProcessor(final Compiler compiler) { final SpecializeModule specializeModule = new SpecializeModule(compiler, devirtualizePrototypeMethods, inlineFunctions, removeUnusedPrototypeProperties); return new CompilerPass() { @Override public void process(Node externs, Node root) { specializeModule.process(externs, root); /* Make sure variables are declared before used */ new VarCheck(compiler).process(externs, root); } }; } @Override public void setUp() throws Exception { super.setUp(); enableNormalize(); } public void testSpecializeInline() { JSModule[] modules = createModuleStar( // m1 /* Recursion in A() prevents inline of A*/ "var A = function() {alert(B());A()};" + "var B = function() {return 6};" + "A();", // m2 "A();" + "B();" + "B = function() {return 7};" + "A();" + "B();" ); test(modules, new String[] { // m1 "var A = function() {alert(6);A()};" + /* Specialized A */ "A();" + "var B;", // m2 "A = function() {alert(B());A()};" + /* Unspecialized A */ "B = function() {return 6};" + /* Removed from m1, so add to m2 */ "A();" + "B();" + "B = function() {return 7};" + "A();" + "B();" }); } public void testSpecializeCascadedInline() { JSModule[] modules = createModuleStar( // m1 /* Recursion in A() prevents inline of A*/ "var A = function() {alert(B());A()};" + "var B = function() {return C()};" + "var C = function() {return 6};" + "A();", // m2 "B = function() {return 7};" + "A();"); test(modules, new String[] { // m1 "var A = function() {alert(6);A()};" + /* Specialized A */ "A();" + "var B, C;", // m2 "A = function() {alert(B());A()};" + /* Unspecialized A */ "B = function() {return C()};" + /* Removed from m1, so add to m2 */ "C = function() {return 6};" + /* Removed from m1, so add to m2 */ "B = function() {return 7};" + "A();" }); } public void testSpecializeInlineWithMultipleDependents() { JSModule[] modules = createModuleStar( // m1 /* Recursion in A() prevents inline of A*/ "var A = function() {alert(B());A()};" + "var B = function() {return 6};" + "A();", // m2 "B = function() {return 7};" + "A();", // m3 "A();" ); test(modules, new String[] { // m1 "var A = function() {alert(6);A()};" + /* Specialized A */ "A();" + "var B;", // m2 "A = function() {alert(B());A()};" + /* Unspecialized A */ "B = function() {return 6};" + /* Removed from m1, so add to m2 */ "B = function() {return 7};" + "A();", "A = function() {alert(B());A()};" + /* Unspecialized A */ "B = function() {return 6};" + /* Removed from m1, so add to m2 */ "A();", }); } public void testSpecializeInlineWithNamespaces() { JSModule[] modules = createModuleStar( // m1 "var ns = {};" + /* Recursion in A() prevents inline of A*/ "ns.A = function() {alert(B());ns.A()};" + "var B = function() {return 6};" + "ns.A();", // m2 "B = function() {return 7};" + "ns.A();"); test(modules, new String[] { // m1 "var ns = {};" + "ns.A = function() {alert(6);ns.A()};" + /* Specialized A */ "ns.A();" + "var B;", // m2 "ns.A = function() {alert(B());ns.A()};" + /* Unspecialized A */ "B = function() {return 6};" + /* Removed from m1, so add to m2 */ "B = function() {return 7};" + "ns.A();" }); } public void testSpecializeInlineWithRegularFunctions() { JSModule[] modules = createModuleStar( // m1 /* Recursion in A() prevents inline of A*/ "function A() {alert(B());A()}" + "function B() {return 6}" + "A();", // m2 "B = function() {return 7};" + "A();"); test(modules, new String[] { // m1 "function A() {alert(6);A()}" + /* Specialized A */ "A();" + "var B;", // m2 "A = function() {alert(B());A()};" + /* Unspecialized A */ "B = function() {return 6};" + /* Removed from m1, so add to m2 */ /* Start of original m2 */ "B = function() {return 7};" + "A();" }); } public void testDontSpecializeLocalNonAnonymousFunctions() { /* normalize result, but not expected */ enableNormalize(false); JSModule[] modules = createModuleStar( // m1 "(function(){var noSpecialize = " + "function() {alert(6)};noSpecialize()})()", // m2 ""); test(modules, new String[] { // m1 "(function(){var noSpecialize = " + "function() {alert(6)};noSpecialize()})()", // m2 "" }); } public void testAddDummyVarsForRemovedFunctions() { JSModule[] modules = createModuleStar( // m1 /* Recursion in A() prevents inline of A*/ "var A = function() {alert(B() + C());A()};" + "var B = function() {return 6};" + "var C = function() {return 8};" + "A();", // m2 "" + "A();"); test(modules, new String[] { // m1 "var A = function() {alert(6 + 8);A()};" + /* Specialized A */ "A();" + "var B, C;", // m2 "A = function() {alert(B() + C());A()};" + /* Unspecialized A */ "B = function() {return 6};" + /* Removed from m1, so add to m2 */ "C = function() {return 8};" + /* Removed from m1, so add to m2 */ "A();" }); } public void testSpecializeRemoveUnusedProperties() { JSModule[] modules = createModuleStar( // m1 /* Recursion in A() prevents inline of A*/ "var Foo = function(){};" + /* constructor */ "Foo.prototype.a = function() {this.a()};" + "Foo.prototype.b = function() {return 6};" + "Foo.prototype.c = function() {return 7};" + "var aliasA = Foo.prototype.a;" + // Prevents devirtualization of a "var x = new Foo();" + "x.a();", // m2 ""); test(modules, new String[] { // m1 "var Foo = function(){};" + /* constructor */ "Foo.prototype.a = function() {this.a()};" + "var aliasA = Foo.prototype.a;" + "var x = new Foo();" + "x.a();", // m2 "Foo.prototype.b = function() {return 6};" + "Foo.prototype.c = function() {return 7};" }); } public void testDontSpecializeAliasedFunctions_inline() { JSModule[] modules = createModuleStar( // m1 /* Recursion in A() prevents inline of A*/ "function A() {alert(B());A()}" + "function B() {return 6}" + "var aliasA = A;" + "A();", // m2 "B = function() {return 7};" + "B();"); test(modules, new String[] { // m1 /* Recursion in A() prevents inline of A*/ "function A() {alert(B());A()}" + "function B() {return 6}" + "var aliasA = A;" + "A();", // m2 "B = function() {return 7};" + "B();" }); } public void testDontSpecializeAliasedFunctions_remove_unused_properties() { JSModule[] modules = createModuleStar( // m1 "var Foo = function(){};" + /* constructor */ "Foo.prototype.a = function() {this.a()};" + "Foo.prototype.b = function() {return 6};" + "var aliasB = Foo.prototype.b;" + "Foo.prototype.c = function() {return 7};" + "Foo.prototype.d = function() {return 7};" + "var aliasA = Foo.prototype.a;" + // Prevents devirtualization of a "var x = new Foo();" + "x.a();" + "var aliasC = (new Foo).c", // m2 ""); test(modules, new String[] { // m1 "var Foo = function(){};" + /* constructor */ "Foo.prototype.a = function() {this.a()};" + "Foo.prototype.b = function() {return 6};" + "var aliasB = Foo.prototype.b;" + "Foo.prototype.c = function() {return 7};" + "var aliasA = Foo.prototype.a;" + // Prevents devirtualization of a "var x = new Foo();" + "x.a();" + "var aliasC = (new Foo).c", // m2 "Foo.prototype.d = function() {return 7};" }); } public void testSpecializeDevirtualizePrototypeMethods() { JSModule[] modules = createModuleStar( // m1 "/** @constructor */" + "var Foo = function(){};" + /* constructor */ "Foo.prototype.a = function() {this.a();return 7};" + "Foo.prototype.b = function() {this.a()};" + "var x = new Foo();" + "x.a();", // m2 ""); test(modules, new String[] { // m1 "var Foo = function(){};" + /* constructor */ "var JSCompiler_StaticMethods_a =" + "function(JSCompiler_StaticMethods_a$self) {" + "JSCompiler_StaticMethods_a(JSCompiler_StaticMethods_a$self);" + "return 7" + "};" + "var x = new Foo();" + "JSCompiler_StaticMethods_a(x);", // m2 "Foo.prototype.a = function() {this.a();return 7};" + "Foo.prototype.b = function() {this.a()};" }); } public void testSpecializeDevirtualizePrototypeMethodsWithInline() { JSModule[] modules = createModuleStar( // m1 "/** @constructor */" + "var Foo = function(){};" + /* constructor */ "Foo.prototype.a = function() {return 7};" + "var x = new Foo();" + "var z = x.a();", // m2 ""); test(modules, new String[] { // m1 "var Foo = function(){};" + /* constructor */ "var x = new Foo();" + "var z = 7;", // m2 "Foo.prototype.a = function() {return 7};" }); } /** * Tests for {@link SpecializeModule.SpecializationState}. */ public static class SpecializeModuleSpecializationStateTest extends CompilerTestCase { Compiler lastCompiler; SpecializationState lastState; @Override public CompilerPass getProcessor(final Compiler compiler) { lastCompiler = compiler; return new CompilerPass() { @Override public void process(Node externs, Node root) { SimpleDefinitionFinder defFinder = new SimpleDefinitionFinder(compiler); defFinder.process(externs, root); SimpleFunctionAliasAnalysis functionAliasAnalysis = new SimpleFunctionAliasAnalysis(); functionAliasAnalysis.analyze(defFinder); lastState = new SpecializationState(functionAliasAnalysis); } }; } public void testRemovedFunctions() { testSame("function F(){}\nvar G = function(a){};"); assertEquals(ImmutableSet.of(), lastState.getRemovedFunctions()); Node functionF = findFunction("F"); lastState.reportRemovedFunction(functionF, functionF.getParent()); assertEquals(ImmutableSet.of(functionF), lastState.getRemovedFunctions()); Node functionG = findFunction("F"); lastState.reportRemovedFunction(functionG, functionF.getParent()); assertEquals(ImmutableSet.of(functionF, functionG), lastState.getRemovedFunctions()); assertEquals(ImmutableSet.of(), lastState.getSpecializedFunctions()); } public void testSpecializedFunctions() { testSame("function F(){}\nvar G = function(a){};"); assertEquals(ImmutableSet.of(), lastState.getSpecializedFunctions()); Node functionF = findFunction("F"); lastState.reportSpecializedFunction(functionF); assertEquals(ImmutableSet.of(functionF), lastState.getSpecializedFunctions()); Node functionG = findFunction("F"); lastState.reportSpecializedFunction(functionG); assertEquals(ImmutableSet.of(functionF, functionG), lastState.getSpecializedFunctions()); assertEquals(ImmutableSet.of(), lastState.getRemovedFunctions()); } public void testCanFixupFunction() { testSame("function F(){}\n" + "var G = function(a){};\n" + "var ns = {};" + "ns.H = function(){};" + "var ns2 = {I : function anon1(){}};" + "(function anon2(){})();"); assertTrue(lastState.canFixupFunction(findFunction("F"))); assertTrue(lastState.canFixupFunction(findFunction("G"))); assertTrue(lastState.canFixupFunction(findFunction("ns.H"))); assertFalse(lastState.canFixupFunction(findFunction("anon1"))); assertFalse(lastState.canFixupFunction(findFunction("anon2"))); // Can't guarantee safe fixup for aliased functions testSame("function A(){}\n" + "var aliasA = A;\n"); assertFalse(lastState.canFixupFunction(findFunction("A"))); } private Node findFunction(String name) { FunctionFinder f = new FunctionFinder(name); new NodeTraversal(lastCompiler, f).traverse(lastCompiler.jsRoot); assertNotNull("Couldn't find " + name, f.found); return f.found; } /** * Quick Traversal to find a given function in the AST. */ private class FunctionFinder extends AbstractPostOrderCallback { Node found = null; final String target; FunctionFinder(String target) { this.target = target; } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isFunction() && target.equals(NodeUtil.getFunctionName(n))) { found = n; } } } } }
/* * Copyright 2011 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Unit tests for {@link StatementFusion}. * */ public class StatementFusionTest extends CompilerTestCase { @Override public void setUp() throws Exception { super.setUp(); enableLineNumberCheck(true); } @Override public CompilerPass getProcessor(final Compiler compiler) { PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass(compiler, new StatementFusion()); return peepholePass; } public void testNothingToDo() { fuseSame(""); fuseSame("a"); fuseSame("a()"); fuseSame("if(a()){}"); } public void testFoldBlockWithStatements() { fuse("a;b;c", "a,b,c"); fuse("a();b();c();", "a(),b(),c()"); fuse("a(),b();c(),d()", "a(),b(),c(),d()"); fuse("a();b(),c(),d()", "a(),b(),c(),d()"); fuse("a(),b(),c();d()", "a(),b(),c(),d()"); } public void testFoldBlockIntoIf() { fuse("a;b;c;if(x){}", "if(a,b,c,x){}"); fuse("a;b;c;if(x,y){}else{}", "if(a,b,c,x,y){}else{}"); fuse("a;b;c;if(x,y){}", "if(a,b,c,x,y){}"); fuse("a;b;c;if(x,y,z){}", "if(a,b,c,x,y,z){}"); // Can't fuse if there are statements after the IF. fuseSame("a();if(a()){}a()"); } public void testFoldBlockReturn() { fuse("a;b;c;return x", "return a,b,c,x"); fuse("a;b;c;return x+y", "return a,b,c,x+y"); // DeadAssignmentElimination would have cleaned it up anyways. fuseSame("a;b;c;return x;a;b;c"); } public void testFoldBlockThrow() { fuse("a;b;c;throw x", "throw a,b,c,x"); fuse("a;b;c;throw x+y", "throw a,b,c,x+y"); fuseSame("a;b;c;throw x;a;b;c"); } public void testFoldSwitch() { fuse("a;b;c;switch(x){}", "switch(a,b,c,x){}"); } public void testFuseIntoForIn() { fuse("a;b;c;for(x in y){}", "for(x in a,b,c,y){}"); fuseSame("a();for(var x = b() in y){}"); } public void testNoFuseIntoWhile() { fuseSame("a;b;c;while(x){}"); } public void testNoFuseIntoDo() { fuseSame("a;b;c;do{}while(x)"); } public void testNoGlobalSchopeChanges() { testSame("a,b,c"); } public void testNoFunctionBlockChanges() { testSame("function foo() { a,b,c }"); } private void fuse(String before, String after) { test("function F(){if(CONDITION){" + before + "}}", "function F(){if(CONDITION){" + after + "}}"); } private void fuseSame(String code) { fuse(code, code); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; public class StrictModeCheckTest extends CompilerTestCase { private static final String EXTERNS = "var arguments; function eval(str) {}"; private boolean noVarCheck; private boolean noCajaChecks; public StrictModeCheckTest() { super(EXTERNS); } @Override protected void setUp() throws Exception { super.setUp(); noVarCheck = false; noCajaChecks = false; } @Override protected CompilerPass getProcessor(Compiler compiler) { return new StrictModeCheck(compiler, noVarCheck, noCajaChecks); } @Override protected int getNumRepetitions() { return 1; } public void testEval() { test("function foo() { eval('a'); }", null, StrictModeCheck.EVAL_USE); } public void testEval2() { testSame("function foo(eval) {}", StrictModeCheck.EVAL_DECLARATION); } public void testEval3() { testSame("function foo() {} foo.eval = 3;"); } public void testEval4() { testSame("function foo() { var eval = 3; }", StrictModeCheck.EVAL_DECLARATION); } public void testEval5() { testSame("function eval() {}", StrictModeCheck.EVAL_DECLARATION); } public void testEval6() { testSame("try {} catch (eval) {}", StrictModeCheck.EVAL_DECLARATION); } public void testEval7() { testSame("var o = {eval: 3};"); } public void testEval8() { testSame("var a; eval: while (true) { a = 3; }"); } public void testUnknownVariable() { testSame("function foo(a) { a = b; }", StrictModeCheck.UNKNOWN_VARIABLE); } public void testUnknownVariable2() { testSame("a: while (true) { a = 3; }", StrictModeCheck.UNKNOWN_VARIABLE); } public void testUnknownVariable3() { testSame("try {} catch (ex) { ex = 3; }"); } public void testArguments() { testSame("function foo(arguments) {}", StrictModeCheck.ARGUMENTS_DECLARATION); } public void testArguments2() { testSame("function foo() { var arguments = 3; }", StrictModeCheck.ARGUMENTS_DECLARATION); } public void testArguments3() { testSame("function arguments() {}", StrictModeCheck.ARGUMENTS_DECLARATION); } public void testArguments4() { testSame("try {} catch (arguments) {}", StrictModeCheck.ARGUMENTS_DECLARATION); } public void testArguments5() { testSame("var o = {arguments: 3};"); } public void testEvalAssignment() { noCajaChecks = true; testSame("function foo() { eval = []; }", StrictModeCheck.EVAL_ASSIGNMENT); } public void testEvalAssignment2() { test("function foo() { eval = []; }", null, StrictModeCheck.EVAL_USE); } public void testAssignToArguments() { testSame("function foo() { arguments = []; }", StrictModeCheck.ARGUMENTS_ASSIGNMENT); } public void testDeleteVar() { testSame("var a; delete a", StrictModeCheck.DELETE_VARIABLE); } public void testDeleteFunction() { testSame("function a() {} delete a", StrictModeCheck.DELETE_VARIABLE); } public void testDeleteArgument() { testSame("function b(a) { delete a; }", StrictModeCheck.DELETE_VARIABLE); } public void testDeleteProperty() { testSame("function f(obj) { delete obj.a; }"); } public void testIllegalName() { test("var a__ = 3;", null, StrictModeCheck.ILLEGAL_NAME); } public void testIllegalName2() { test("function a__() {}", null, StrictModeCheck.ILLEGAL_NAME); } public void testIllegalName3() { test("function f(a__) {}", null, StrictModeCheck.ILLEGAL_NAME); } public void testIllegalName4() { test("try {} catch (a__) {}", null, StrictModeCheck.ILLEGAL_NAME); } public void testIllegalName5() { noVarCheck = true; test("var a = b__;", null, StrictModeCheck.ILLEGAL_NAME); } public void testIllegalName6() { test("function f(obj) { return obj.a__; }", null, StrictModeCheck.ILLEGAL_NAME); } public void testIllegalName7() { noCajaChecks = true; testSame("var a__ = 3;"); } public void testIllegalName8() { test("var o = {a__: 3};", null, StrictModeCheck.ILLEGAL_NAME); test("var o = {b: 3, a__: 4};", null, StrictModeCheck.ILLEGAL_NAME); test("var o = {b: 3, get a__() {}};", null, StrictModeCheck.ILLEGAL_NAME); test("var o = {b: 3, set a__(c) {}};", null, StrictModeCheck.ILLEGAL_NAME); } public void testIllegalName9() { test("a__: while (true) { var b = 3; }", null, StrictModeCheck.ILLEGAL_NAME); } public void testIllegalName10() { // Validate that number as objlit key testSame("var o = {1: 3, 2: 4};"); } public void testDuplicateObjectLiteralKey() { testSame("var o = {a: 1, b: 2, c: 3};"); testSame("var x = { get a() {}, set a(p) {} };"); testSame("var o = {a: 1, b: 2, a: 3};", StrictModeCheck.DUPLICATE_OBJECT_KEY); testSame("var x = { get a() {}, get a() {} };", StrictModeCheck.DUPLICATE_OBJECT_KEY); testSame("var x = { get a() {}, a: 1 };", StrictModeCheck.DUPLICATE_OBJECT_KEY); testSame("var x = { set a(p) {}, a: 1 };", StrictModeCheck.DUPLICATE_OBJECT_KEY); testSame( "'use strict';\n" + "function App() {}\n" + "App.prototype = {\n" + " get appData() { return this.appData_; },\n" + " set appData(data) { this.appData_ = data; }\n" + "};"); } public void testFunctionDecl() { testSame("function g() {}"); testSame("var g = function() {};"); testSame("(function() {})();"); testSame("(function() {});"); testSame(inFn("function g() {}")); testSame(inFn("var g = function() {};")); testSame(inFn("(function() {})();")); testSame(inFn("(function() {});")); test("{function g() {}}", null, StrictModeCheck.BAD_FUNCTION_DECLARATION); testSame("{var g = function () {}}"); testSame("{(function g() {})()}"); test("var x;if (x) { function g(){} }", null, StrictModeCheck.BAD_FUNCTION_DECLARATION); testSame("var x;if (x) {var g = function () {}}"); testSame("var x;if (x) {(function g() {})()}"); } public void testFunctionDecl2() { test("{function g() {}}", null, StrictModeCheck.BAD_FUNCTION_DECLARATION); } private String inFn(String body) { return "function func() {" + body + "}"; } }
/* * Copyright 2007 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.Sets; import java.util.Set; /** * Tests for {@link StripCode}. * */ public class StripCodeTest extends CompilerTestCase { private static final String EXTERNS = ""; public StripCodeTest() { super(EXTERNS, true); } /** * Creates an instance for removing logging code. * * @param compiler The Compiler * @return A new {@link StripCode} instance */ private static StripCode createLoggerInstance(Compiler compiler) { Set<String> stripTypes = Sets.newHashSet( "goog.debug.DebugWindow", "goog.debug.FancyWindow", "goog.debug.Formatter", "goog.debug.HtmlFormatter", "goog.debug.TextFormatter", "goog.debug.Logger", "goog.debug.LogManager", "goog.debug.LogRecord", "goog.net.BrowserChannel.LogSaver", "GA_GoogleDebugger"); Set<String> stripNames = Sets.newHashSet( "logger", "logger_", "debugWindow", "debugWindow_", "logFormatter_", "logBuffer_"); Set<String> stripNamePrefixes = Sets.newHashSet("trace"); Set<String> stripTypePrefixes = Sets.newHashSet("e.f.Trace"); return new StripCode(compiler, stripTypes, stripNames, stripTypePrefixes, stripNamePrefixes); } @Override public CompilerPass getProcessor(Compiler compiler) { return createLoggerInstance(compiler); } public void testLoggerDefinedInConstructor() { test("a.b.c = function() {" + " this.logger = goog.debug.Logger.getLogger('a.b.c');" + "};", "a.b.c=function(){}"); } public void testLoggerDefinedInPrototype1() { test("a.b.c = function() {};" + "a.b.c.prototype.logger = goog.debug.Logger.getLogger('a.b.c');", "a.b.c=function(){}"); } public void testLoggerDefinedInPrototype2() { test("a.b.c = function() {};" + "a.b.c.prototype = {logger: goog.debug.Logger.getLogger('a.b.c')}", "a.b.c = function() {};" + "a.b.c.prototype = {}"); } public void testLoggerDefinedInPrototype3() { test("a.b.c = function() {};" + "a.b.c.prototype = { " + " get logger() {return goog.debug.Logger.getLogger('a.b.c')}" + "}", "a.b.c = function() {};" + "a.b.c.prototype = {}"); } public void testLoggerDefinedInPrototype4() { test("a.b.c = function() {};" + "a.b.c.prototype = { " + " set logger(a) {this.x = goog.debug.Logger.getLogger('a.b.c')}" + "}", "a.b.c = function() {};" + "a.b.c.prototype = {}"); } public void testLoggerDefinedInPrototype5() { test("a.b.c = function() {};" + "a.b.c.prototype = { " + " get f() {return this.x;}," + " set f(a) {this.x = goog.debug.Logger.getLogger('a.b.c')}" + "}", "a.b.c = function() {};" + "a.b.c.prototype = { " + " get f() {return this.x;}," + " set f(a) {this.x = null}" + "}"); } public void testLoggerDefinedStatically() { test("a.b.c = function() {};" + "a.b.c.logger = goog.debug.Logger.getLogger('a.b.c');", "a.b.c=function(){}"); } public void testLoggerDefinedInObjectLiteral1() { test("a.b.c = {" + " x: 0," + " logger: goog.debug.Logger.getLogger('a.b.c')" + "};", "a.b.c={x:0}"); } public void testLoggerDefinedInObjectLiteral2() { test("a.b.c = {" + " x: 0," + " get logger() {return goog.debug.Logger.getLogger('a.b.c')}" + "};", "a.b.c={x:0}"); } public void testLoggerDefinedInObjectLiteral3() { test("a.b.c = {" + " x: null," + " get logger() {return this.x}," + " set logger(a) {this.x = goog.debug.Logger.getLogger(a)}" + "};", "a.b.c={x:null}"); } public void testLoggerDefinedInObjectLiteral4() { test("a.b.c = {" + " x: null," + " get y() {return this.x}," + " set y(a) {this.x = goog.debug.Logger.getLogger(a)}" + "};", "a.b.c = {" + " x: null," + " get y() {return this.x}," + " set y(a) {this.x = null}" + "};"); } public void testLoggerDefinedInPrototypeAndUsedInConstructor() { test("a.b.c = function(level) {" + " if (!this.logger.isLoggable(level)) {" + " this.logger.setLevel(level);" + " }" + " this.logger.log(level, 'hi');" + "};" + "a.b.c.prototype.logger = goog.debug.Logger.getLogger('a.b.c');" + "a.b.c.prototype.go = function() { this.logger.finer('x'); };", "a.b.c=function(level){if(!null);};" + "a.b.c.prototype.go=function(){}"); } public void testLoggerDefinedStaticallyAndUsedInConstructor() { test("a.b.c = function(level) {" + " if (!a.b.c.logger.isLoggable(level)) {" + " a.b.c.logger.setLevel(level);" + " }" + " a.b.c.logger.log(level, 'hi');" + "};" + "a.b.c.logger = goog.debug.Logger.getLogger('a.b.c');", "a.b.c=function(level){if(!null);}"); } public void testLoggerVarDeclaration() { test("var logger = opt_logger || goog.debug.LogManager.getRoot();", ""); } public void testLoggerMethodCallByVariableType() { test("var x = goog.debug.Logger.getLogger('a.b.c'); y.info(a); x.info(a);", "y.info(a)"); } public void testSubPropertyAccessByVariableName() { test("var x, y = goog.debug.Logger.getLogger('a.b.c');" + "var logger = x;" + "var curlevel = logger.level_ ? logger.getLevel().name : 3;", "var x;var curlevel=null?null:3"); } public void testPrefixedVariableName() { test("this.blcLogger_ = goog.debug.Logger.getLogger('a.b.c');" + "this.blcLogger_.fine('Raised dirty states.');", ""); } public void testPrefixedPropertyName() { test("a.b.c.staticLogger_ = goog.debug.Logger.getLogger('a.b.c');" + "a.b.c.staticLogger_.fine('-' + a.b.c.d_())", ""); } public void testPrefixedClassName() { test("a.b.MyLogger = function(logger) {" + " this.logger_ = logger;" + "};" + "a.b.MyLogger.prototype.shout = function(msg, opt_x) {" + " this.logger_.log(goog.debug.Logger.Level.SHOUT, msg, opt_x);" + "};", "a.b.MyLogger=function(logger){};" + "a.b.MyLogger.prototype.shout=function(msg,opt_x){}"); } public void testLoggerClassDefinition() { test("goog.debug.Logger=function(name){this.name_=name}", ""); } public void testStaticLoggerPropertyDefinition() { test("goog.debug.Logger.Level.SHOUT=" + "new goog.debug.Logger.Level(x,1200)", ""); } public void testStaticLoggerMethodDefinition() { test("goog.debug.Logger.getLogger=function(name){" + "return goog.debug.LogManager.getLogger(name)" + "};", ""); } public void testPrototypeFieldDefinition() { test("goog.debug.Logger.prototype.level_=null;", ""); } public void testPrototypeFieldDefinitionWithoutAssignment() { test("goog.debug.Logger.prototype.level_;", ""); } public void testPrototypeMethodDefinition() { test("goog.debug.Logger.prototype.addHandler=" + "function(handler){this.handlers_.push(handler)};", ""); } public void testPublicPropertyAssignment() { // We don't eliminate property assignments on vars/properties that we // remove, since the debugging classes should have setter methods instead // of public properties. testSame("rootLogger.someProperty=3"); testSame("this.blcLogger_.level=x"); testSame("goog.ui.Component.logger.prop=y"); } public void testGlobalCallWithStrippedType() { testSame("window.alert(goog.debug.Logger)"); } public void testClassDefiningCallWithStripType1() { test("goog.debug.Logger.inherits(Object)", ""); } public void testClassDefiningCallWithStripType2() { test("goog.formatter=function(){};" + "goog.inherits(goog.debug.Formatter,goog.formatter)", "goog.formatter=function(){}"); } public void testClassDefiningCallWithStripType3() { test("goog.formatter=function(){};" + "goog.inherits(goog.formatter,goog.debug.Formatter)", null, StripCode.STRIP_TYPE_INHERIT_ERROR); } public void testClassDefiningCallWithStripType4() { test("goog.formatter=function(){};" + "goog.formatter.inherits(goog.debug.Formatter)", null, StripCode.STRIP_TYPE_INHERIT_ERROR); } public void testClassDefiningCallWithStripType5() { testSame("goog.formatter=function(){};" + "goog.formatter.inherits(goog.debug.FormatterFoo)"); } public void testClassDefiningCallWithStripType6() { test("goog.formatter=function(){};" + "goog.formatter.inherits(goog.debug.Formatter.Foo)", null, StripCode.STRIP_TYPE_INHERIT_ERROR); } public void testClassDefiningCallWithStripType7() { test("goog.inherits(goog.debug.TextFormatter,goog.debug.Formatter)", ""); } public void testClassDefiningCallWithStripType8() { // listed types should be removed. test("goog.debug.DebugWindow = function(){}", ""); test("goog.inherits(goog.debug.DebugWindow,Base)", ""); // types that happen to have strip types as prefix should not be // stripped. testSame("goog.debug.DebugWindowFoo=function(){}"); testSame("goog.inherits(goog.debug.DebugWindowFoo,Base)"); testSame("goog.debug.DebugWindowFoo"); testSame("goog.debug.DebugWindowFoo=1"); // qualified subtypes should be removed. test("goog.debug.DebugWindow.Foo=function(){}", ""); test("goog.inherits(goog.debug.DebugWindow.Foo,Base)", ""); test("goog.debug.DebugWindow.Foo", ""); test("goog.debug.DebugWindow.Foo=1", ""); } public void testPropertyWithEmptyStringKey() { test("goog.format.NUMERIC_SCALES_BINARY_ = {'': 1};", "goog.format.NUMERIC_SCALES_BINARY_={\"\":1}"); } public void testVarinIf() { test("if(x)var logger=null;else foo()", "if(x);else foo()"); } public void testGetElemInIf() { test("var logger=null;if(x)logger[f];else foo()", "if(x);else foo()"); } public void testAssignInIf() { test("var logger=null;if(x)logger=1;else foo()", "if(x);else foo()"); } public void testNamePrefix() { test("a = function(traceZZZ) {}; a.prototype.traceXXX = {x: 1};" + "a.prototype.z = function() { this.traceXXX.f(); };" + "var traceYYY = 0;", "a=function(traceZZZ){};a.prototype.z=function(){}"); } public void testTypePrefix() { test("e.f.TraceXXX = function() {}; " + "e.f.TraceXXX.prototype.yyy = 2;", ""); } public void testStripCallsToStrippedNames() { test("a = function() { this.logger_ = function(msg){}; };" + "a.prototype.b = function() { this.logger_('hi'); }", "a=function(){};a.prototype.b=function(){}"); test("a = function() {};" + "a.prototype.logger_ = function(msg) {};" + "a.prototype.b = function() { this.logger_('hi'); }", "a=function(){};a.prototype.b=function(){}"); } public void testStripVarsInitializedFromStrippedNames() { test("a = function() { this.logger_ = function() { return 1; }; };" + "a.prototype.b = function() { " + " var one = this.logger_(); if (one) foo() }", "a=function(){};a.prototype.b=function(){if(null)foo()}"); } public void testReportErrorOnStripInNestedAssignment() { // Strip name test("(foo.logger_ = 7) + 8", "(foo.logger_ = 7) + 8", StripCode.STRIP_ASSIGNMENT_ERROR); // Strip namespaced type test("(goog.debug.Logger.foo = 7) + 8", "(goog.debug.Logger.foo = 7) + 8", StripCode.STRIP_ASSIGNMENT_ERROR); // Strip non-namespaced type test("(GA_GoogleDebugger.foo = 7) + 8", "(GA_GoogleDebugger.foo = 7) + 8", StripCode.STRIP_ASSIGNMENT_ERROR); } public void testNewOperatior1() { test("function foo() {} foo.bar = new goog.debug.Logger();", "function foo() {} foo.bar = null;"); } public void testNewOperatior2() { test("function foo() {} foo.bar = (new goog.debug.Logger()).foo();", "function foo() {} foo.bar = null;"); } public void testCrazyNesting1() { test("var x = {}; x[new goog.debug.Logger()] = 3;", "var x = {}; x[null] = 3;"); } public void testCrazyNesting2() { test("var x = {}; x[goog.debug.Logger.getLogger()] = 3;", "var x = {}; x[null] = 3;"); } public void testCrazyNesting3() { test("var x = function() {}; x(new goog.debug.Logger());", "var x = function() {}; x(null);"); } public void testCrazyNesting4() { test("var x = function() {}; x(goog.debug.Logger.getLogger());", "var x = function() {}; x(null);"); } public void testCrazyNesting5() { test("var x = function() {}; var y = {}; " + "var z = goog.debug.Logger.getLogger(); x(y[z['foo']]);", "var x = function() {}; var y = {}; x(y[null]);"); } }
/* * Copyright 2011 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.Iterables; import com.google.common.collect.Lists; import com.google.common.collect.Ordering; import com.google.common.collect.Sets; import com.google.javascript.jscomp.SymbolTable.Reference; import com.google.javascript.jscomp.SymbolTable.Symbol; import com.google.javascript.jscomp.SymbolTable.SymbolScope; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Token; import junit.framework.TestCase; import java.util.List; import java.util.Set; /** * @author nicksantos@google.com (Nick Santos) */ public class SymbolTableTest extends TestCase { private static final String EXTERNS = CompilerTypeTestCase.DEFAULT_EXTERNS + "\nfunction customExternFn(customExternArg) {}"; private CompilerOptions options; @Override public void setUp() throws Exception { super.setUp(); options = new CompilerOptions(); options.setCodingConvention(new ClosureCodingConvention()); CompilationLevel.SIMPLE_OPTIMIZATIONS.setOptionsForCompilationLevel( options); WarningLevel.VERBOSE.setOptionsForWarningLevel(options); options.ideMode = true; } public void testGlobalVar() throws Exception { SymbolTable table = createSymbolTable( "/** @type {number} */ var x = 5;"); assertNull(getGlobalVar(table, "y")); assertNotNull(getGlobalVar(table, "x")); assertEquals("number", getGlobalVar(table, "x").getType().toString()); // 2 == sizeof({x, *global*}) assertEquals(2, getVars(table).size()); } public void testGlobalThisReferences() throws Exception { SymbolTable table = createSymbolTable( "var x = this; function f() { return this + this + this; }"); Symbol global = getGlobalVar(table, "*global*"); assertNotNull(global); List<Reference> refs = table.getReferenceList(global); assertEquals(1, refs.size()); } public void testGlobalThisReferences2() throws Exception { // Make sure the global this is declared, even if it isn't referenced. SymbolTable table = createSymbolTable(""); Symbol global = getGlobalVar(table, "*global*"); assertNotNull(global); List<Reference> refs = table.getReferenceList(global); assertEquals(0, refs.size()); } public void testGlobalThisReferences3() throws Exception { SymbolTable table = createSymbolTable("this.foo = {}; this.foo.bar = {};"); Symbol global = getGlobalVar(table, "*global*"); assertNotNull(global); List<Reference> refs = table.getReferenceList(global); assertEquals(2, refs.size()); } public void testGlobalThisPropertyReferences() throws Exception { SymbolTable table = createSymbolTable( "/** @constructor */ function Foo() {} this.Foo;"); Symbol foo = getGlobalVar(table, "Foo"); assertNotNull(foo); List<Reference> refs = table.getReferenceList(foo); assertEquals(2, refs.size()); } public void testGlobalVarReferences() throws Exception { SymbolTable table = createSymbolTable( "/** @type {number} */ var x = 5; x = 6;"); Symbol x = getGlobalVar(table, "x"); List<Reference> refs = table.getReferenceList(x); assertEquals(2, refs.size()); assertEquals(x.getDeclaration(), refs.get(0)); assertEquals(Token.VAR, refs.get(0).getNode().getParent().getType()); assertEquals(Token.ASSIGN, refs.get(1).getNode().getParent().getType()); } public void testLocalVarReferences() throws Exception { SymbolTable table = createSymbolTable( "function f(x) { return x; }"); Symbol x = getLocalVar(table, "x"); List<Reference> refs = table.getReferenceList(x); assertEquals(2, refs.size()); assertEquals(x.getDeclaration(), refs.get(0)); assertEquals(Token.PARAM_LIST, refs.get(0).getNode().getParent().getType()); assertEquals(Token.RETURN, refs.get(1).getNode().getParent().getType()); } public void testLocalThisReferences() throws Exception { SymbolTable table = createSymbolTable( "/** @constructor */ function F() { this.foo = 3; this.bar = 5; }"); Symbol f = getGlobalVar(table, "F"); assertNotNull(f); Symbol t = table.getParameterInFunction(f, "this"); assertNotNull(t); List<Reference> refs = table.getReferenceList(t); assertEquals(2, refs.size()); } public void testLocalThisReferences2() throws Exception { SymbolTable table = createSymbolTable( "/** @constructor */ function F() {}" + "F.prototype.baz = " + " function() { this.foo = 3; this.bar = 5; };"); Symbol baz = getGlobalVar(table, "F.prototype.baz"); assertNotNull(baz); Symbol t = table.getParameterInFunction(baz, "this"); assertNotNull(t); List<Reference> refs = table.getReferenceList(t); assertEquals(2, refs.size()); } public void testLocalThisReferences3() throws Exception { SymbolTable table = createSymbolTable( "/** @constructor */ function F() {}"); Symbol baz = getGlobalVar(table, "F"); assertNotNull(baz); Symbol t = table.getParameterInFunction(baz, "this"); assertNotNull(t); List<Reference> refs = table.getReferenceList(t); assertEquals(0, refs.size()); } public void testNamespacedReferences() throws Exception { // Because the type of goog is anonymous, we build its properties into // the global scope. SymbolTable table = createSymbolTable( "var goog = {};" + "goog.dom = {};" + "goog.dom.DomHelper = function(){};"); Symbol goog = getGlobalVar(table, "goog"); assertNotNull(goog); assertEquals(3, Iterables.size(table.getReferences(goog))); Symbol googDom = getGlobalVar(table, "goog.dom"); assertNotNull(googDom); assertEquals(2, Iterables.size(table.getReferences(googDom))); Symbol googDomHelper = getGlobalVar(table, "goog.dom.DomHelper"); assertNotNull(googDomHelper); assertEquals(1, Iterables.size(table.getReferences(googDomHelper))); } public void testIncompleteNamespacedReferences() throws Exception { SymbolTable table = createSymbolTable( "/** @constructor */\n" + "goog.dom.DomHelper = function(){};\n" + "var y = goog.dom.DomHelper;\n"); Symbol goog = getGlobalVar(table, "goog"); assertNotNull(goog); assertEquals(2, table.getReferenceList(goog).size()); Symbol googDom = getGlobalVar(table, "goog.dom"); assertNotNull(googDom); assertEquals(2, table.getReferenceList(googDom).size()); Symbol googDomHelper = getGlobalVar(table, "goog.dom.DomHelper"); assertNotNull(googDomHelper); assertEquals(2, Iterables.size(table.getReferences(googDomHelper))); } public void testGlobalRichObjectReference() throws Exception { SymbolTable table = createSymbolTable( "/** @constructor */\n" + "function A(){};\n" + "/** @type {?A} */ A.prototype.b;\n" + "/** @type {A} */ var a = new A();\n" + "function g() {\n" + " return a.b ? 'x' : 'y';\n" + "}\n" + "(function() {\n" + " var x; if (x) { x = a.b.b; } else { x = a.b.c; }\n" + " return x;\n" + "})();\n"); Symbol ab = getGlobalVar(table, "a.b"); assertNull(ab); Symbol propB = getGlobalVar(table, "A.prototype.b"); assertNotNull(propB); assertEquals(5, table.getReferenceList(propB).size()); } public void testRemovalOfNamespacedReferencesOfProperties() throws Exception { SymbolTable table = createSymbolTable( "/** @constructor */ var DomHelper = function(){};" + "/** method */ DomHelper.method = function() {};"); Symbol domHelper = getGlobalVar(table, "DomHelper"); assertNotNull(domHelper); Symbol domHelperNamespacedMethod = getGlobalVar(table, "DomHelper.method"); assertEquals("method", domHelperNamespacedMethod.getName()); Symbol domHelperMethod = domHelper.getPropertyScope().getSlot("method"); assertNotNull(domHelperMethod); } public void testGoogScopeReferences() throws Exception { SymbolTable table = createSymbolTable( "var goog = {};" + "goog.scope = function() {};" + "goog.scope(function() {});"); Symbol googScope = getGlobalVar(table, "goog.scope"); assertNotNull(googScope); assertEquals(2, Iterables.size(table.getReferences(googScope))); } public void testGoogRequireReferences() throws Exception { SymbolTable table = createSymbolTable( "var goog = {};" + "goog.provide = function() {};" + "goog.require = function() {};" + "goog.provide('goog.dom');" + "goog.require('goog.dom');"); Symbol goog = getGlobalVar(table, "goog"); assertNotNull(goog); // 8 references: // 5 in code // 2 in strings // 1 created by ProcessClosurePrimitives when it processes the provide. // // NOTE(nicksantos): In the future, we may de-dupe references such // that the one in the goog.provide string and the one created by // ProcessClosurePrimitives count as the same reference. assertEquals(8, Iterables.size(table.getReferences(goog))); } public void testGoogRequireReferences2() throws Exception { options.brokenClosureRequiresLevel = CheckLevel.OFF; SymbolTable table = createSymbolTable( "foo.bar = function(){}; // definition\n" + "goog.require('foo.bar')\n"); Symbol fooBar = getGlobalVar(table, "foo.bar"); assertNotNull(fooBar); assertEquals(2, Iterables.size(table.getReferences(fooBar))); } public void testGlobalVarInExterns() throws Exception { SymbolTable table = createSymbolTable("customExternFn(1);"); Symbol fn = getGlobalVar(table, "customExternFn"); List<Reference> refs = table.getReferenceList(fn); assertEquals(2, refs.size()); SymbolScope scope = table.getEnclosingScope(refs.get(0).getNode()); assertTrue(scope.isGlobalScope()); assertEquals(SymbolTable.GLOBAL_THIS, table.getSymbolForScope(scope).getName()); } public void testLocalVarInExterns() throws Exception { SymbolTable table = createSymbolTable(""); Symbol arg = getLocalVar(table, "customExternArg"); List<Reference> refs = table.getReferenceList(arg); assertEquals(1, refs.size()); Symbol fn = getGlobalVar(table, "customExternFn"); SymbolScope scope = table.getEnclosingScope(refs.get(0).getNode()); assertFalse(scope.isGlobalScope()); assertEquals(fn, table.getSymbolForScope(scope)); } public void testSymbolsForType() throws Exception { SymbolTable table = createSymbolTable( "function random() { return 1; }" + "/** @constructor */ function Foo() {}" + "/** @constructor */ function Bar() {}" + "var x = random() ? new Foo() : new Bar();"); Symbol x = getGlobalVar(table, "x"); Symbol foo = getGlobalVar(table, "Foo"); Symbol bar = getGlobalVar(table, "Bar"); Symbol fooPrototype = getGlobalVar(table, "Foo.prototype"); Symbol fn = getGlobalVar(table, "Function"); Symbol obj = getGlobalVar(table, "Object"); assertEquals( Lists.newArrayList(foo, bar), table.getAllSymbolsForTypeOf(x)); assertEquals( Lists.newArrayList(fn), table.getAllSymbolsForTypeOf(foo)); assertEquals( Lists.newArrayList(foo), table.getAllSymbolsForTypeOf(fooPrototype)); assertEquals( foo, table.getSymbolDeclaredBy( foo.getType().toMaybeFunctionType())); } public void testStaticMethodReferences() throws Exception { SymbolTable table = createSymbolTable( "/** @constructor */ var DomHelper = function(){};" + "/** method */ DomHelper.method = function() {};" + "function f() { var x = DomHelper; x.method() + x.method(); }"); Symbol method = getGlobalVar(table, "DomHelper").getPropertyScope().getSlot("method"); assertEquals( 3, Iterables.size(table.getReferences(method))); } public void testMethodReferences() throws Exception { SymbolTable table = createSymbolTable( "/** @constructor */ var DomHelper = function(){};" + "/** method */ DomHelper.prototype.method = function() {};" + "function f() { " + " (new DomHelper()).method(); (new DomHelper()).method(); };"); Symbol method = getGlobalVar(table, "DomHelper.prototype.method"); assertEquals( 3, Iterables.size(table.getReferences(method))); } public void testSuperClassMethodReferences() throws Exception { SymbolTable table = createSymbolTable( "var goog = {};" + "goog.inherits = function(a, b) {};" + "/** @constructor */ var A = function(){};" + "/** method */ A.prototype.method = function() {};" + "/**\n" + " * @constructor\n" + " * @extends {A}\n" + " */\n" + "var B = function(){};\n" + "goog.inherits(B, A);" + "/** method */ B.prototype.method = function() {" + " B.superClass_.method();" + "};"); Symbol methodA = getGlobalVar(table, "A.prototype.method"); assertEquals( 2, Iterables.size(table.getReferences(methodA))); } public void testMethodReferencesMissingTypeInfo() throws Exception { SymbolTable table = createSymbolTable( "/**\n" + " * @constructor\n" + " * @extends {Missing}\n" + " */ var DomHelper = function(){};\n" + "/** method */ DomHelper.prototype.method = function() {\n" + " this.method();\n" + "};\n" + "function f() { " + " (new DomHelper()).method();\n" + "};"); Symbol method = getGlobalVar(table, "DomHelper.prototype.method"); assertEquals( 3, Iterables.size(table.getReferences(method))); } public void testFieldReferencesMissingTypeInfo() throws Exception { SymbolTable table = createSymbolTable( "/**\n" + " * @constructor\n" + " * @extends {Missing}\n" + " */ var DomHelper = function(){ this.prop = 1; };\n" + "/** @type {number} */ DomHelper.prototype.prop = 2;\n" + "function f() {\n" + " return (new DomHelper()).prop;\n" + "};"); Symbol prop = getGlobalVar(table, "DomHelper.prototype.prop"); assertEquals(3, table.getReferenceList(prop).size()); assertNull(getLocalVar(table, "this.prop")); } public void testFieldReferences() throws Exception { SymbolTable table = createSymbolTable( "/** @constructor */ var DomHelper = function(){" + " /** @type {number} */ this.field = 3;" + "};" + "function f() { " + " return (new DomHelper()).field + (new DomHelper()).field; };"); Symbol field = getGlobalVar(table, "DomHelper.prototype.field"); assertEquals( 3, Iterables.size(table.getReferences(field))); } public void testUndeclaredFieldReferences() throws Exception { // We do not currently create symbol table entries for undeclared fields, // but this may change in the future. SymbolTable table = createSymbolTable( "/** @constructor */ var DomHelper = function(){};" + "DomHelper.prototype.method = function() { " + " this.field = 3;" + " return x.field;" + "}"); Symbol field = getGlobalVar(table, "DomHelper.prototype.field"); assertNull(field); } public void testPrototypeReferences() throws Exception { SymbolTable table = createSymbolTable( "/** @constructor */ function DomHelper() {}" + "DomHelper.prototype.method = function() {};"); Symbol prototype = getGlobalVar(table, "DomHelper.prototype"); assertNotNull(prototype); List<Reference> refs = table.getReferenceList(prototype); // One of the refs is implicit in the declaration of the function. assertEquals(refs.toString(), 2, refs.size()); } public void testPrototypeReferences2() throws Exception { SymbolTable table = createSymbolTable( "/** @constructor */\n" + "function Snork() {}\n" + "Snork.prototype.baz = 3;\n"); Symbol prototype = getGlobalVar(table, "Snork.prototype"); assertNotNull(prototype); List<Reference> refs = table.getReferenceList(prototype); assertEquals(2, refs.size()); } public void testPrototypeReferences3() throws Exception { SymbolTable table = createSymbolTable( "/** @constructor */ function Foo() {}"); Symbol fooPrototype = getGlobalVar(table, "Foo.prototype"); assertNotNull(fooPrototype); List<Reference> refs = table.getReferenceList(fooPrototype); assertEquals(1, refs.size()); assertEquals(Token.NAME, refs.get(0).getNode().getType()); // Make sure that the ctor and its prototype are declared at the // same node. assertEquals( refs.get(0).getNode(), table.getReferenceList(getGlobalVar(table, "Foo")).get(0).getNode()); } public void testPrototypeReferences4() throws Exception { SymbolTable table = createSymbolTable( "/** @constructor */ function Foo() {}" + "Foo.prototype = {bar: 3}"); Symbol fooPrototype = getGlobalVar(table, "Foo.prototype"); assertNotNull(fooPrototype); List<Reference> refs = Lists.newArrayList( table.getReferences(fooPrototype)); assertEquals(1, refs.size()); assertEquals(Token.GETPROP, refs.get(0).getNode().getType()); assertEquals("Foo.prototype", refs.get(0).getNode().getQualifiedName()); } public void testPrototypeReferences5() throws Exception { SymbolTable table = createSymbolTable( "var goog = {}; /** @constructor */ goog.Foo = function() {};"); Symbol fooPrototype = getGlobalVar(table, "goog.Foo.prototype"); assertNotNull(fooPrototype); List<Reference> refs = table.getReferenceList(fooPrototype); assertEquals(1, refs.size()); assertEquals(Token.GETPROP, refs.get(0).getNode().getType()); // Make sure that the ctor and its prototype are declared at the // same node. assertEquals( refs.get(0).getNode(), table.getReferenceList( getGlobalVar(table, "goog.Foo")).get(0).getNode()); } public void testReferencesInJSDocType() { SymbolTable table = createSymbolTable( "/** @constructor */ function Foo() {}\n" + "/** @type {Foo} */ var x;\n" + "/** @param {Foo} x */ function f(x) {}\n" + "/** @return {function(): Foo} */ function g() {}\n" + "/**\n" + " * @constructor\n" + " * @extends {Foo}\n" + " */ function Sub() {}"); Symbol foo = getGlobalVar(table, "Foo"); assertNotNull(foo); List<Reference> refs = table.getReferenceList(foo); assertEquals(5, refs.size()); assertEquals(1, refs.get(0).getNode().getLineno()); assertEquals(29, refs.get(0).getNode().getCharno()); assertEquals(3, refs.get(0).getNode().getLength()); assertEquals(2, refs.get(1).getNode().getLineno()); assertEquals(11, refs.get(1).getNode().getCharno()); assertEquals(3, refs.get(2).getNode().getLineno()); assertEquals(12, refs.get(2).getNode().getCharno()); assertEquals(4, refs.get(3).getNode().getLineno()); assertEquals(25, refs.get(3).getNode().getCharno()); assertEquals(7, refs.get(4).getNode().getLineno()); assertEquals(13, refs.get(4).getNode().getCharno()); } public void testReferencesInJSDocType2() { SymbolTable table = createSymbolTable( "/** @param {string} x */ function f(x) {}\n"); Symbol str = getGlobalVar(table, "String"); assertNotNull(str); List<Reference> refs = table.getReferenceList(str); // We're going to pick up a lot of references from the externs, // so it's not meaningful to check the number of references. // We really want to make sure that all the references are in the externs, // except the last one. assertTrue(refs.size() > 1); int last = refs.size() - 1; for (int i = 0; i < refs.size(); i++) { Reference ref = refs.get(i); assertEquals(i != last, ref.getNode().isFromExterns()); if (!ref.getNode().isFromExterns()) { assertEquals("in1", ref.getNode().getSourceFileName()); } } } public void testReferencesInJSDocName() { String code = "/** @param {Object} x */ function f(x) {}\n"; SymbolTable table = createSymbolTable(code); Symbol x = getLocalVar(table, "x"); assertNotNull(x); List<Reference> refs = table.getReferenceList(x); assertEquals(2, refs.size()); assertEquals(code.indexOf("x) {"), refs.get(0).getNode().getCharno()); assertEquals(code.indexOf("x */"), refs.get(1).getNode().getCharno()); assertEquals("in1", refs.get(0).getNode().getSourceFileName()); } public void testLocalQualifiedNamesInLocalScopes() { SymbolTable table = createSymbolTable( "function f() { var x = {}; x.number = 3; }"); Symbol xNumber = getLocalVar(table, "x.number"); assertNotNull(xNumber); assertFalse(table.getScope(xNumber).isGlobalScope()); assertEquals("number", xNumber.getType().toString()); } public void testNaturalSymbolOrdering() { SymbolTable table = createSymbolTable( "/** @const */ var a = {};" + "/** @const */ a.b = {};" + "/** @param {number} x */ function f(x) {}"); Symbol a = getGlobalVar(table, "a"); Symbol ab = getGlobalVar(table, "a.b"); Symbol f = getGlobalVar(table, "f"); Symbol x = getLocalVar(table, "x"); Ordering<Symbol> ordering = table.getNaturalSymbolOrdering(); assertSymmetricOrdering(ordering, a, ab); assertSymmetricOrdering(ordering, a, f); assertSymmetricOrdering(ordering, f, ab); assertSymmetricOrdering(ordering, f, x); } public void testDeclarationDisagreement() { SymbolTable table = createSymbolTable( "/** @const */ var goog = goog || {};\n" + "/** @param {!Function} x */\n" + "goog.addSingletonGetter2 = function(x) {};\n" + "/** Wakka wakka wakka */\n" + "goog.addSingletonGetter = goog.addSingletonGetter2;\n" + "/** @param {!Function} x */\n" + "goog.addSingletonGetter = function(x) {};\n"); Symbol method = getGlobalVar(table, "goog.addSingletonGetter"); List<Reference> refs = table.getReferenceList(method); assertEquals(2, refs.size()); // Note that the declaration should show up second. assertEquals(7, method.getDeclaration().getNode().getLineno()); assertEquals(5, refs.get(1).getNode().getLineno()); } public void testMultipleExtends() { SymbolTable table = createSymbolTable( "/** @const */ var goog = goog || {};\n" + "goog.inherits = function(x, y) {};\n" + "/** @constructor */\n" + "goog.A = function() { this.fieldA = this.constructor; };\n" + "/** @constructor */ goog.A.FooA = function() {};\n" + "/** @return {void} */ goog.A.prototype.methodA = function() {};\n" + "/**\n" + " * @constructor\n" + " * @extends {goog.A}\n" + " */\n" + "goog.B = function() { this.fieldB = this.constructor; };\n" + "goog.inherits(goog.B, goog.A);\n" + "/** @return {void} */ goog.B.prototype.methodB = function() {};\n" + "/**\n" + " * @constructor\n" + " * @extends {goog.A}\n" + " */\n" + "goog.B2 = function() { this.fieldB = this.constructor; };\n" + "goog.inherits(goog.B2, goog.A);\n" + "/** @constructor */ goog.B2.FooB = function() {};\n" + "/** @return {void} */ goog.B2.prototype.methodB = function() {};\n" + "/**\n" + " * @constructor\n" + " * @extends {goog.B}\n" + " */\n" + "goog.C = function() { this.fieldC = this.constructor; };\n" + "goog.inherits(goog.C, goog.B);\n" + "/** @constructor */ goog.C.FooC = function() {};\n" + "/** @return {void} */ goog.C.prototype.methodC = function() {};\n"); Symbol bCtor = getGlobalVar(table, "goog.B.prototype.constructor"); assertNotNull(bCtor); List<Reference> bRefs = table.getReferenceList(bCtor); assertEquals(2, bRefs.size()); assertEquals(11, bCtor.getDeclaration().getNode().getLineno()); Symbol cCtor = getGlobalVar(table, "goog.C.prototype.constructor"); assertNotNull(cCtor); List<Reference> cRefs = table.getReferenceList(cCtor); assertEquals(2, cRefs.size()); assertEquals(26, cCtor.getDeclaration().getNode().getLineno()); } public void testJSDocAssociationWithBadNamespace() { SymbolTable table = createSymbolTable( // Notice that the declaration for "goog" is missing. // We want to recover anyway and print out what we know // about goog.Foo. "/** @constructor */ goog.Foo = function(){};"); Symbol foo = getGlobalVar(table, "goog.Foo"); assertNotNull(foo); JSDocInfo info = foo.getJSDocInfo(); assertNotNull(info); assertTrue(info.isConstructor()); } public void testMissingConstructorTag() { SymbolTable table = createSymbolTable( "function F() {" + " this.field1 = 3;" + "}" + "F.prototype.method1 = function() {" + " this.field1 = 5;" + "};" + "(new F()).method1();"); // Because the constructor tag is missing, this is going // to be missing a lot of inference. assertNull(getGlobalVar(table, "F.prototype.field1")); Symbol sym = getGlobalVar(table, "F.prototype.method1"); assertEquals(1, table.getReferenceList(sym).size()); } public void testTypeCheckingOff() { options = new CompilerOptions(); // Turning type-checking off is even worse than not annotating anything. SymbolTable table = createSymbolTable( "/** @contstructor */" + "function F() {" + " this.field1 = 3;" + "}" + "F.prototype.method1 = function() {" + " this.field1 = 5;" + "};" + "(new F()).method1();"); assertNull(getGlobalVar(table, "F.prototype.field1")); assertNull(getGlobalVar(table, "F.prototype.method1")); Symbol sym = getGlobalVar(table, "F"); assertEquals(3, table.getReferenceList(sym).size()); } public void testSuperClassReference() throws Exception { SymbolTable table = createSymbolTable( " var a = {b: {}};\n" + "/** @constructor */\n" + "a.b.BaseClass = function() {};\n" + "a.b.BaseClass.prototype.doSomething = function() {\n" + " alert('hi');\n" + "};\n" + "/**\n" + " * @constructor\n" + " * @extends {a.b.BaseClass}\n" + " */\n" + "a.b.DerivedClass = function() {};\n" + "goog.inherits(a.b.DerivedClass, a.b.BaseClass);\n" + "/** @override */\n" + "a.b.DerivedClass.prototype.doSomething = function() {\n" + " a.b.DerivedClass.superClass_.doSomething();\n" + "};\n"); Symbol bad = getGlobalVar( table, "a.b.DerivedClass.superClass_.doSomething"); assertNull(bad); Symbol good = getGlobalVar( table, "a.b.BaseClass.prototype.doSomething"); assertNotNull(good); List<Reference> refs = table.getReferenceList(good); assertEquals(2, refs.size()); assertEquals("a.b.DerivedClass.superClass_.doSomething", refs.get(1).getNode().getQualifiedName()); } public void testInnerEnum() throws Exception { SymbolTable table = createSymbolTable( "var goog = {}; goog.ui = {};" + " /** @constructor */\n" + "goog.ui.Zippy = function() {};\n" + "/** @enum {string} */\n" + "goog.ui.Zippy.EventType = { TOGGLE: 'toggle' };\n"); Symbol eventType = getGlobalVar(table, "goog.ui.Zippy.EventType"); assertNotNull(eventType); assertTrue(eventType.getType().isEnumType()); Symbol toggle = getGlobalVar(table, "goog.ui.Zippy.EventType.TOGGLE"); assertNotNull(toggle); } public void testMethodInAnonObject1() throws Exception { SymbolTable table = createSymbolTable( "var a = {}; a.b = {}; a.b.c = function() {};"); Symbol a = getGlobalVar(table, "a"); Symbol ab = getGlobalVar(table, "a.b"); Symbol abc = getGlobalVar(table, "a.b.c"); assertNotNull(abc); assertEquals(1, table.getReferenceList(abc).size()); assertEquals("{b: {c: function (): undefined}}", a.getType().toString()); assertEquals("{c: function (): undefined}", ab.getType().toString()); assertEquals("function (): undefined", abc.getType().toString()); } public void testMethodInAnonObject2() throws Exception { SymbolTable table = createSymbolTable( "var a = {b: {c: function() {}}};"); Symbol a = getGlobalVar(table, "a"); Symbol ab = getGlobalVar(table, "a.b"); Symbol abc = getGlobalVar(table, "a.b.c"); assertNotNull(abc); assertEquals(1, table.getReferenceList(abc).size()); assertEquals("{b: {c: function (): undefined}}", a.getType().toString()); assertEquals("{c: function (): undefined}", ab.getType().toString()); assertEquals("function (): undefined", abc.getType().toString()); } public void testJSDocOnlySymbol() throws Exception { SymbolTable table = createSymbolTable( "/**\n" + " * @param {number} x\n" + " * @param y\n" + " */\n" + "var a;"); Symbol x = getDocVar(table, "x"); assertNotNull(x); assertEquals("number", x.getType().toString()); assertEquals(1, table.getReferenceList(x).size()); Symbol y = getDocVar(table, "y"); assertNotNull(x); assertEquals(null, y.getType()); assertEquals(1, table.getReferenceList(y).size()); } public void testNamespaceDefinitionOrder() throws Exception { // Sometimes, weird things can happen where the files appear in // a strange order. We need to make sure we're robust against this. SymbolTable table = createSymbolTable( "/** @const */ var goog = {};\n" + "/** @constructor */ goog.dom.Foo = function() {};\n" + "/** @const */ goog.dom = {};\n"); Symbol goog = getGlobalVar(table, "goog"); Symbol dom = getGlobalVar(table, "goog.dom"); Symbol Foo = getGlobalVar(table, "goog.dom.Foo"); assertNotNull(goog); assertNotNull(dom); assertNotNull(Foo); assertEquals(dom, goog.getPropertyScope().getSlot("dom")); assertEquals(Foo, dom.getPropertyScope().getSlot("Foo")); } public void testConstructorAlias() throws Exception { SymbolTable table = createSymbolTable( "/** @constructor */ var Foo = function() {};\n" + "/** desc */ Foo.prototype.bar = function() {};\n" + "/** @constructor */ var FooAlias = Foo;\n" + "/** desc */ FooAlias.prototype.baz = function() {};\n"); Symbol foo = getGlobalVar(table, "Foo"); Symbol fooAlias = getGlobalVar(table, "FooAlias"); Symbol bar = getGlobalVar(table, "Foo.prototype.bar"); Symbol baz = getGlobalVar(table, "Foo.prototype.baz"); Symbol bazAlias = getGlobalVar(table, "FooAlias.prototype.baz"); assertNotNull(foo); assertNotNull(fooAlias); assertNotNull(bar); assertNotNull(baz); assertNull(bazAlias); Symbol barScope = table.getSymbolForScope(table.getScope(bar)); assertNotNull(barScope); Symbol bazScope = table.getSymbolForScope(table.getScope(baz)); assertNotNull(bazScope); Symbol fooPrototype = foo.getPropertyScope().getSlot("prototype"); assertNotNull(fooPrototype); assertEquals(fooPrototype, barScope); assertEquals(fooPrototype, bazScope); } public void testSymbolForScopeOfNatives() throws Exception { SymbolTable table = createSymbolTable(""); // From the externs. Symbol sliceArg = getLocalVar(table, "sliceArg"); assertNotNull(sliceArg); Symbol scope = table.getSymbolForScope(table.getScope(sliceArg)); assertNotNull(scope); assertEquals(scope, getGlobalVar(table, "String.prototype.slice")); Symbol proto = getGlobalVar(table, "String.prototype"); assertEquals( "externs1", proto.getDeclaration().getNode().getSourceFileName()); } private void assertSymmetricOrdering( Ordering<Symbol> ordering, Symbol first, Symbol second) { assertTrue(ordering.compare(first, first) == 0); assertTrue(ordering.compare(second, second) == 0); assertTrue(ordering.compare(first, second) < 0); assertTrue(ordering.compare(second, first) > 0); } private Symbol getGlobalVar(SymbolTable table, String name) { return table.getGlobalScope().getQualifiedSlot(name); } private Symbol getDocVar(SymbolTable table, String name) { for (Symbol sym : table.getAllSymbols()) { if (sym.isDocOnlyParameter() && sym.getName().equals(name)) { return sym; } } return null; } private Symbol getLocalVar(SymbolTable table, String name) { for (SymbolScope scope : table.getAllScopes()) { if (!scope.isGlobalScope() && scope.isLexicalScope() && scope.getQualifiedSlot(name) != null) { return scope.getQualifiedSlot(name); } } return null; } /** Returns all non-extern vars. */ private List<Symbol> getVars(SymbolTable table) { List<Symbol> result = Lists.newArrayList(); for (Symbol symbol : table.getAllSymbols()) { if (symbol.getDeclaration() != null && !symbol.getDeclaration().getNode().isFromExterns()) { result.add(symbol); } } return result; } private SymbolTable createSymbolTable(String input) { List<SourceFile> inputs = Lists.newArrayList( SourceFile.fromCode("in1", input)); List<SourceFile> externs = Lists.newArrayList( SourceFile.fromCode("externs1", EXTERNS)); Compiler compiler = new Compiler(); compiler.compile(externs, inputs, options); return assertSymbolTableValid(compiler.buildKnownSymbolTable()); } /** * Asserts that the symbol table meets some invariants. * Returns the same table for easy chaining. */ private SymbolTable assertSymbolTableValid(SymbolTable table) { Set<Symbol> allSymbols = Sets.newHashSet(table.getAllSymbols()); for (Symbol sym : table.getAllSymbols()) { // Make sure that grabbing the symbol's scope and looking it up // again produces the same symbol. assertEquals(sym, table.getScope(sym).getQualifiedSlot(sym.getName())); for (Reference ref : table.getReferences(sym)) { // Make sure that the symbol and reference are mutually linked. assertEquals(sym, ref.getSymbol()); } Symbol scope = table.getSymbolForScope(table.getScope(sym)); assertTrue( "The symbol's scope is a zombie scope that shouldn't exist.\n" + "Symbol: " + sym + "\n" + "Scope: " + table.getScope(sym), scope == null || allSymbols.contains(scope)); } // Make sure that the global "this" is declared at the first input root. Symbol global = getGlobalVar(table, SymbolTable.GLOBAL_THIS); assertNotNull(global); assertNotNull(global.getDeclaration()); assertEquals(Token.SCRIPT, global.getDeclaration().getNode().getType()); List<Reference> globalRefs = table.getReferenceList(global); // The main reference list should never contain the synthetic declaration // for the global root. assertFalse(globalRefs.contains(global.getDeclaration())); return table; } }
/* * Copyright 2007 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import junit.framework.TestCase; /** * Tests for {@link SyntacticScopeCreator}. * */ public class SyntacticScopeCreatorTest extends TestCase { /** * Helper to create a top-level scope from a JavaScript string */ private static Scope getScope(String js) { Compiler compiler = new Compiler(); Node root = compiler.parseTestCode(js); assertEquals(0, compiler.getErrorCount()); Scope scope = new SyntacticScopeCreator(compiler).createScope(root, null); return scope; } /** * Helper to traverse the tree creating the Scope object everywhere. */ private static void testScopes(String js, int errorCount) { Compiler compiler = new Compiler(); Node root = compiler.parseTestCode(js); NodeTraversal.traverse( compiler, root, new NodeTraversal.AbstractPostOrderCallback() { @Override public void visit(NodeTraversal t, Node n, Node parent) { t.getScope(); } }); assertEquals(errorCount, compiler.getErrorCount()); } public void testFunctionScope() { Scope scope = getScope("function foo() {}\n" + "var x = function bar(a1) {};" + "[function bar2() { var y; }];" + "if (true) { function z() {} }" ); assertTrue(scope.isDeclared("foo", false)); assertTrue(scope.isDeclared("x", false)); assertTrue(scope.isDeclared("z", false)); // The following should not be declared in this scope assertFalse(scope.isDeclared("a1", false)); assertFalse(scope.isDeclared("bar", false)); assertFalse(scope.isDeclared("bar2", false)); assertFalse(scope.isDeclared("y", false)); assertFalse(scope.isDeclared("", false)); } public void testScopeRootNode() { String js = "function foo() {\n" + " var x = 10;" + "}"; Compiler compiler = new Compiler(); Node root = compiler.parseTestCode(js); assertEquals(0, compiler.getErrorCount()); Scope globalScope = new SyntacticScopeCreator(compiler).createScope(root, null); assertEquals(root, globalScope.getRootNode()); Node fooNode = root.getFirstChild(); assertEquals(Token.FUNCTION, fooNode.getType()); Scope fooScope = new SyntacticScopeCreator(compiler).createScope(fooNode, null); assertEquals(fooNode, fooScope.getRootNode()); assertTrue(fooScope.isDeclared("x", false)); } public void testRedeclaration1() { String js = "var a; var a;"; int errors = createGlobalScopeHelper(js); assertEquals(1, errors); } public void testRedeclaration2() { String js = "var a; /** @suppress {duplicate} */ var a;"; int errors = createGlobalScopeHelper(js); assertEquals(0, errors); } public void testRedeclaration3() { String js = " /** @suppress {duplicate} */ var a; var a; "; int errors = createGlobalScopeHelper(js); assertEquals(0, errors); } public void testFunctionScopeArguments() { // A var declaration doesn't mask arguments testScopes("function f() {var arguments}", 0); testScopes("var f = function arguments() {}", 1); testScopes("var f = function (arguments) {}", 1); testScopes("function f() {try {} catch(arguments) {}}", 1); } /** * Parse the supplied JS and create the global SyntaticScope object. * @return The error count. */ private int createGlobalScopeHelper(String js) { Compiler compiler = new Compiler(); CompilerOptions options = new CompilerOptions(); options.checkSymbols = true; compiler.initOptions(options); Node root = compiler.parseTestCode(js); assertEquals(0, compiler.getErrorCount()); Scope globalScope = new SyntacticScopeCreator(compiler).createScope(root, null); assertEquals(root, globalScope.getRootNode()); return compiler.getErrorCount(); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.javascript.jscomp.ConcreteType.ConcreteFunctionType; import com.google.javascript.jscomp.ConcreteType.ConcreteInstanceType; import com.google.javascript.jscomp.CheckLevel; import com.google.javascript.jscomp.TightenTypes.ConcreteSlot; import com.google.javascript.rhino.testing.BaseJSTypeTestCase; /** * Unit test for the TightenTypes pass. * */ public class TightenTypesTest extends CompilerTestCase { private TightenTypes tt; public TightenTypesTest() { parseTypeInfo = true; enableTypeCheck(CheckLevel.WARNING); enableNormalize(true); } @Override public CompilerPass getProcessor(Compiler compiler) { return (tt = new TightenTypes(compiler)); } @Override protected int getNumRepetitions() { return 1; } @Override protected CompilerOptions getOptions() { return new CompilerOptions(); // no missing properties check } public void testTopLevelVariables() { testSame("/** @constructor */ function Foo() {}\n" + "var a = new Foo();\n" + "var b = a;\n"); assertTrue(getType("Foo").isFunction()); assertTrue(getType("a").isInstance()); assertType("function (this:Foo): ()", getType("Foo")); assertType("Foo", getType("a")); assertType("Foo", getType("b")); testSame("/** @constructor */ function Foo() {}\n" + "/** @constructor */ function Bar() {}\n" + "var a = new Foo();\n" + "a = new Bar();\n" + "var b = a;\n"); assertTrue(getType("a").isUnion()); assertType("(Bar,Foo)", getType("a")); assertType("Bar", getType("b")); } public void testNamespacedVariables() { testSame("var goog = goog || {}; goog.foo = {};\n" + "/** @constructor */ goog.foo.Foo = function() {};\n" + "goog.foo.Foo.prototype.blah = function() {};\n" + "/** @constructor */ goog.foo.Bar = function() {};\n" + "goog.foo.Bar.prototype.blah = function() {};\n" + "function bar(a) { a.blah(); }\n" + "var baz = bar;\n" + "bar(new goog.foo.Foo);\n" + "baz(new goog.foo.Bar);\n"); assertType("(goog.foo.Bar,goog.foo.Foo)", getParamType(getType("bar"), 0)); assertType("(goog.foo.Bar,goog.foo.Foo)", getParamType(getType("baz"), 0)); } public void testReturnSlot() { testSame("/** @constructor */ function Foo() {}\n" + "function bar() {\n" + " var a = new Foo();\n" + " return a;\n" + "}\n" + "var b = bar();\n"); assertType("Foo", getType("b")); } public void testParameterSlots() { testSame("/** @constructor */ function Foo() {}\n" + "/** @constructor */ function Bar() {}\n" + "function bar(a, b) {}\n" + "bar(new Foo, new Foo);\n" + "bar(new Bar, null);\n"); assertType("(Bar,Foo)", getParamType(getType("bar"), 0)); assertType("Foo", getParamType(getType("bar"), 1)); assertNull(getParamVar(getType("bar"), 2)); } public void testAliasedFunction() { testSame("/** @constructor */ function Foo() {}\n" + "/** @constructor */ function Bar() {}\n" + "function bar(a) {}\n" + "var baz = bar;\n" + "bar(new Foo);\n" + "baz(new Bar);\n"); assertType("(Bar,Foo)", getParamType(getType("bar"), 0)); assertType("(Bar,Foo)", getParamType(getType("baz"), 0)); } public void testCatchStatement() { testSame(BaseJSTypeTestCase.ALL_NATIVE_EXTERN_TYPES, "/** @constructor */ function Bar() {}\n" + "function bar() { try { } catch (e) { return e; } }\n" + "/** @constructor\n@extends{Error}*/ function ID10TError() {}\n" + "var a = bar(); throw new ID10TError();\n", null, null); assertType("(Error,EvalError,ID10TError,RangeError,ReferenceError," + "SyntaxError,TypeError,URIError)", getType("a")); } public void testConstructorParameterSlots() { testSame("/** @constructor */ function Foo() {}\n" + "/** @constructor */ function Bar() {}\n" + "/** @constructor */ function Baz(a) {}\n" + "new Baz(new Foo);\n" + "new Baz(new Bar);\n"); assertType("(Bar,Foo)", getParamType(getType("Baz"), 0)); } public void testCallSlot() { testSame("function foo() {}\n" + "function bar() {}\n" + "function baz() {}\n" + "var a = foo;\n" + "a = bar;\n" + "a();\n"); assertTrue(isCalled(getType("foo"))); assertTrue(isCalled(getType("bar"))); assertFalse(isCalled(getType("baz"))); } public void testObjectLiteralTraversal() { testSame("var foo = function() {}\n" + "function bar() { return { 'a': foo()} };\n" + "bar();"); assertTrue(isCalled(getType("foo"))); } public void testThis() { testSame("/** @constructor */ function Foo() {}\n" + "Foo.prototype.foo = function() { return this; }\n" + "var a = new Foo();\n" + "var b = a.foo();\n"); assertType("Foo", getType("a")); assertType("Foo", getType("b")); } public void testAssign() { testSame("/** @constructor */ function Foo() {}\n" + "/** @constructor */ function Bar() {}\n" + "var a = new Foo();\n" + "var b = a = new Bar();\n"); assertType("(Bar,Foo)", getType("a")); assertType("Bar", getType("b")); } public void testComma() { testSame("/** @constructor */ function Foo() {b=new Foo()}\n" + "var b;" + "/** @constructor */ function Bar() {}\n" + "var a = (new Foo, new Bar);\n"); assertType("Bar", getType("a")); assertType("Foo", getType("b")); } public void testAnd() { testSame("/** @constructor */ function Foo() {}\n" + "/** @constructor */ function Bar() {}\n" + "var a = (new Foo && new Bar);\n"); assertType("Bar", getType("a")); } public void testOr() { testSame("/** @constructor */ function Foo() {}\n" + "/** @constructor */ function Bar() {}\n" + "/** @type {Foo} */ var f = new Foo();\n" + "/** @type {Bar} */ var b = new Bar();\n" + "var a = (f || b);\n"); assertType("(Bar,Foo)", getType("a")); } public void testHook() { testSame("/** @constructor */ function Foo() {}\n" + "/** @constructor */ function Bar() {}\n" + "var a = (1+1 == 2) ? new Foo : new Bar;\n"); assertType("(Bar,Foo)", getType("a")); } public void testFunctionLiteral() { testSame("/** @constructor */ function Foo() {}\n" + "var a = (function() { return new Foo; })();\n"); assertType("Foo", getType("a")); } public void testNameLookup() { testSame("/** @constructor */ function Foo() {}\n" + "var a = new Foo;\n" + "var b = (function() { return a; })();\n"); assertType("Foo", getType("a")); assertType("Foo", getType("b")); } public void testGetProp() { testSame("/** @constructor */ function Foo() {\n" + " this.foo = new A();\n" + "}\n" + "/** @constructor */ function Bar() {\n" + " this.foo = new B();\n" + "}\n" + "/** @constructor */ function Baz() {}\n" + "/** @constructor */ function A() {}\n" + "/** @constructor */ function B() {}\n" // add the casts to make the JSType a union with null + "/** @type {Foo} */ var foo = new Foo();\n" + "/** @type {Bar} */ var bar = new Bar();\n" + "/** @type {Baz} */ var baz = new Baz();\n" // has no 'foo' + "var a = foo || bar || baz\n" + "var b = a.foo;\n"); assertType("(A,B)", getType("b")); } public void testGetPrototypeProperty() { testSame("/** @constructor */ function Foo() {};\n" + "/** @constructor */ function Bar() {};\n" + "Bar.prototype.a = new Foo();\n" + "var a = Bar.prototype.a;\n"); assertType("Foo", getType("a")); } public void testGetElem() { testSame( "/**\n" + " * @constructor\n" + " * @extends {Object}\n" + " * @param {...*} var_args\n" + " * @return {!Array}\n" + " */\n" + "function Array(var_args) {}\n", "/** @constructor */ function Foo() {}\n" + "/** @constructor */ function Bar() {}\n" + "var a = [];\n" + "a[0] = new Foo;\n" + "a[1] = new Bar;\n" + "var b = a[0];\n" + "var c = [new Foo, new Bar];\n", null); assertType("Array", getType("a")); assertType("(Array,Bar,Foo)", getType("b")); assertType("Array", getType("c")); testSame("/** @constructor */ function Foo() {}\n" + "/** @constructor */ function Bar() {}\n" + "/** @constructor */ function Baz() {\n" + " this.arr = [];\n" + "}\n" + "var b = new Baz;\n" + "b.arr[0] = new Foo;\n" + "b.arr[1] = new Bar;\n" + "var c = b.arr;\n"); assertType("Array", getType("c")); } public void testGetElem3() { testSame(BaseJSTypeTestCase.ALL_NATIVE_EXTERN_TYPES, "/** @constructor */ function Foo() {}\n" + "/** @constructor */ function Bar() {}\n" + "/** @constructor */ function Baz() {\n" + " this.arr = [];\n" + "}\n" + "function foo(anarr) {" + "}\n" + "var ar = [];\n" + "foo(ar);\n", null); assertType("Array", getType("ar")); } public void testScopeDiscovery() { testSame("function spam() {}\n" + "function foo() {}\n" + "function bar() {\n" + " return function() { foo(); };\n" + "}" + "function baz() {\n" + " return function() { bar()(); };\n" + "}" + "baz()()();\n"); assertFalse(isCalled(getType("spam"))); assertTrue(isCalled(getType("foo"))); } public void testSheqDiscovery() { testSame("function spam() {}\n" + "/** @constructor */\n" + "function Foo() {}\n" + "Foo.prototype.foo1 = function() { f1(); }\n" + "Foo.prototype.foo2 = function() { f2(); }\n" + "Foo.prototype.foo3 = function() { f3(); }\n" + "function baz(a) {\n" + " a === null || a instanceof Foo ?\n" + " Foo.prototype.foo1.call(this) :\n" + " Foo.prototype.foo2.call(this);\n" + "}\n" + "function f1() {}\n" + "function f2() {}\n" + "function f3() {}\n" + "baz(3);\n"); assertFalse(isCalled(getType("spam"))); assertFalse(isCalled(getType("f3"))); assertTrue(isCalled(getType("f1"))); assertTrue(isCalled(getType("f2"))); } public void testSubclass() { testSame("/** @constructor */\n" + "function Foo() {}\n" + "Foo.prototype.foo = function() { return this.bar; };\n" + "Foo.prototype.bar = function() { return new A(); };\n" + "/**\n" + " * @constructor\n" + " * @extends Foo\n" + " */\n" + "function Bar() {}\n" + "/** @override */\n" + "Bar.prototype.bar = function() { return new B(); };\n" + "/** @constructor */ function A() {}\n" + "/** @constructor */ function B() {}\n" + "var a = (new Foo()).foo()();\n" + "a = (new Bar()).foo()();\n"); ConcreteType fooType = getPropertyType(getFunctionPrototype(getType("Foo")), "foo"); assertType("(Bar,Foo)", getThisType(fooType)); assertType("(A,B)", getType("a")); testSame("/** @constructor */\n" + "function Foo() {}\n" + "Foo.prototype.foo = function() { return this.bar; };\n" + "Foo.prototype.bar = function() { return new A(); };\n" + "/**\n" + " * @constructor\n" + " * @extends Foo\n" + " */\n" + "function Bar() {}\n" + "/** @override */\n" + "Bar.prototype.bar = function() { return new B(); };\n" + "/** @constructor */ function A() {}\n" + "/** @constructor */ function B() {}\n" + "var a = (new Bar()).foo()();\n"); fooType = getPropertyType(getFunctionPrototype(getType("Foo")), "foo"); assertType("Bar", getThisType(fooType)); assertType("B", getType("a")); } public void testArrayAssignments() { testSame("/** @constructor */ function Foo() {}\n" + "var a = [];\n" + "function foo() { return []; }\n" + "(a.length == 0 ? a : foo())[0] = new Foo;\n" + "var b = a[0];\n" + "var c = foo()[0];\n"); assertType("(Array,Foo)", getType("b")); assertType("(Array,Foo)", getType("c")); } public void testAllPropertyReference() { testSame("/** @constructor */ function Foo() {}\n" + "Foo.prototype.prop = function() { this.prop2(); }\n" + "Foo.prototype.prop2 = function() { b = new Foo; }\n" + "var a = new Foo;\n" + "a = [][0];\n" + "function fun(a) {\n" + " return a.prop();\n" + "}\n" + "var b;\n" + "fun(a);\n" ); assertType("Foo", getType("a")); assertType("Foo", getType("b")); } public void testCallFunction() { testSame("/** @constructor */ function Foo() { this.a = new A; }\n" + "/** @constructor \n @extends Foo */ function Bar() {\n" + " Foo.call(this);\n" + "}\n" + "/** @constructor */ function A() {};\n" + "new Bar;"); assertTrue(isCalled(getType("Foo"))); assertTrue(isCalled(getType("A"))); ConcreteType fooType = getThisType(getType("Foo")); assertType("A", getPropertyType(fooType, "a")); ConcreteType barType = getThisType(getType("Bar")); assertType("A", getPropertyType(barType, "a")); } public void testCallFunctionWithArgs() { testSame("/** @constructor */ function Foo(o) { this.a = o; }\n" + "/** @constructor \n @extends Foo */ function Bar() {\n" + " Foo.call(this, new A());\n" + "}\n" + "/** @constructor */ function A() {};\n" + "var b = new Bar;"); assertTrue(isCalled(getType("Foo"))); assertTrue(isCalled(getType("A"))); ConcreteType barType = getThisType(getType("Bar")); assertType("A", getPropertyType(barType, "a")); ConcreteType fooType = getThisType(getType("Foo")); assertType("A", getPropertyType(fooType, "a")); } public void testCallPrototypeFunction() { testSame("/** @constructor */ function Foo() {}\n" + "Foo.prototype.a = function() { return new A; }\n" + "Foo.prototype.a = function() { return new A; };\n" + "/** @constructor \n @extends Foo */ function Bar() {}\n" + "/** @override */" + "Bar.prototype.a = function() { return new B; };\n" + "/** @constructor */ function A() {};\n" + "/** @constructor */ function B() {};\n" + "var ret = Foo.prototype.a.call(new Bar);"); assertType("A", getType("ret")); } public void testCallPrototypeFunctionWithArgs() { testSame("/** @constructor */ function Foo() { this.p = null }\n" + "Foo.prototype.set = function(arg) { this.p = arg; };\n" + "Foo.prototype.get = function() { return this.p; };\n" + "/** @constructor */ function A() {};\n" + "Foo.prototype.set.call(new Foo, new A);\n" + "var ret = Foo.prototype.get.call(new Foo);"); ConcreteType fooP = getFunctionPrototype(getType("Foo")); ConcreteFunctionType gFun = getPropertyType(fooP, "get").toFunction(); ConcreteFunctionType sFun = getPropertyType(fooP, "set").toFunction(); assertTrue(isCalled(sFun)); assertTrue(isCalled(gFun)); assertTrue(isCalled(getType("A"))); assertType("A", getType("ret")); } public void testSetTimeout() { testSame("/** @constructor */ function Window() {};\n" + "Window.prototype.setTimeout = function(f, t) {};\n" + "/** @type Window */ var window;", "/** @constructor*/ function A() {}\n" + "A.prototype.handle = function() { foo(); };\n" + "function foo() {}\n" + "window.setTimeout((new A).handle, 3);", null); assertTrue(isCalled(getType("foo"))); } public void testExternType() { testSame("/** @constructor */ function T() {};\n" + "/** @constructor */ function Ext() {};\n" + "/** @return {T} */\n" + "Ext.prototype.getT = function() {};\n" + "/** @type T */ Ext.prototype.prop;\n" + "/** @type Ext */ var ext;", "var b = ext.getT();\n" + "var p = ext.prop;", null); assertType("Ext", getType("ext")); assertType("T", getType("b")); assertType("T", getType("p")); } public void testExternSubTypes() { testSame("/** @constructor */ function A() {};\n" + "/** @constructor \n@extends A */ function B() {};\n" + "/** @constructor \n@extends A */ function C() {};\n" + "/** @constructor \n@extends B */ function D() {};\n" + "/** @constructor */ function Ext() {};\n" + "/** @type A */ Ext.prototype.a;\n" + "/** @type B */ Ext.prototype.b;\n" + "/** @type D */ Ext.prototype.d;\n" + "/** @return {A} */ Ext.prototype.getA = function() {};\n" + "/** @return {B} */ Ext.prototype.getB = function() {};\n", "var a = (new Ext).a;\n" + "var a2 = (new Ext).getA();\n" + "var b = (new Ext).b;\n" + "var b2 = (new Ext).getB();\n" + "var d = (new Ext).d;\n", null); assertType("(A,B,C,D)", getType("a")); assertType("(A,B,C,D)", getType("a2")); assertType("(B,D)", getType("b")); assertType("(B,D)", getType("b2")); assertType("D", getType("d")); } public void testExternSubTypesForObject() { testSame(BaseJSTypeTestCase.ALL_NATIVE_EXTERN_TYPES + "/** @constructor */ function A() {};\n" + "/** @constructor \n@extends A */ function B() {};\n" + "/** @return {Object} */ " + "Object.prototype.eval = function(code) {};\n" + "/** @type {Object} */\n" + "A.prototype.a;\n" + "/** @return {Object} */\n" + "A.prototype.b = function(){};\n", "var a = (new A).b()", null, null); assertType("(A,ActiveXObject,Array,B,Boolean,Date,Error,EvalError," + "Function,Number,Object," + "RangeError,ReferenceError,RegExp,String,SyntaxError," + "TypeError,URIError)", getType("a")); } public void testImplicitPropCall() { testSame("/** @constructor */ function Window() {};\n" + "/** @param {function()} f \n@param {number} */\n" + "Window.prototype.setTimeout = function(f, d) {};", "function foo() {};\n" + "(new Window).setTimeout(foo, 20);", null); assertTrue(isCalled(getType("foo"))); } public void testImplicitPropCallWithArgs() { testSame("/** @constructor */ function Window() {};\n" + "/** @constructor */ function EventListener() {};\n" + "/** @param {string} t\n" + " * @param {EventListener|function(Event)} f */\n" + "Window.prototype.addEventListener = function(t, f) {};\n" + "/** @constructor */ function Event() {};", "function foo(evt) {};\n" + "(new Window).addEventListener('click', foo);", null); assertTrue(isCalled(getType("foo"))); assertType("Event", getParamType(getType("foo"), 0)); } public void testUntypedImplicitCallFromProperty() { testSame("/** @constructor */ function Element() {};\n" + "/** @type {?function(Event)} */Element.prototype.onclick;\n" + "/** @constructor */ function Event() {};" + "/** @return {Event} */ Event.prototype.erv;", " function foo(evt) { return bar(evt); };\n" + "function bar(a) { return a.type() }\n" + "/** @type Object */ var ar = new Element;\n" + "ar.onclick = foo;", null); assertTrue(isCalled(getType("foo"))); assertTrue(isCalled(getType("bar"))); assertType("Event", getParamType(getType("foo"), 0)); assertType("Event", getParamType(getType("bar"), 0)); assertType("Element", getThisType(getType("foo").toFunction())); } public void testImplicitCallFromProperty() { testSame("/** @constructor */ function Element() {};\n" + "/** @type {function(this:Element,Event)} */\n" + "Element.prototype.onclick;\n" + "/** @constructor */ function Event() {};", "function foo(evt) {};\n" + "(new Element).onclick = foo;", null); assertTrue(isCalled(getType("foo"))); assertType("Event", getParamType(getType("foo"), 0)); assertType("Element", getThisType(getType("foo").toFunction())); } public void testImplicitCallFromPropertyOfUnion() { testSame("/** @constructor */ function Element() {};\n" + "/** @type {function(this:Element,Event)} */\n" + "Element.prototype.onclick;\n" + "/** @constructor */ function Event() {};", "function foo(evt) {};\n" + "(new Element).onclick = foo;", null); assertTrue(isCalled(getType("foo"))); assertType("Event", getParamType(getType("foo"), 0)); assertType("Element", getThisType(getType("foo").toFunction())); } public void testImplicitCallFromPropertyOfAllType() { testSame("/** @constructor */ function Element() {};\n" + "/** @type {function(this:Element,Event)} */\n" + "Element.prototype.onclick;\n" + "/** @constructor */ function Event() {};", "function foo(evt) {};\n" + "var elems = [];\n" + "var elem = elems[0];\n" // assign it the all type + "elem.onclick = foo;", null); assertTrue(isCalled(getType("foo"))); assertType("Event", getParamType(getType("foo"), 0)); assertType("Element", getThisType(getType("foo").toFunction())); } public void testRestrictToCast() { testSame("/** @constructor */ function Foo() {};\n" + "var a = [];\n" + "var foo = (/** @type {Foo} */ a[0]);\n" + "var u = a[0];\n" + "new Foo"); assertType("Foo", getType("foo")); assertType("(Array,Foo)", getType("u")); } public void testRestrictToInterfaceCast() { testSame("/** @constructor \n @implements Int */ function Foo() {};\n" + "/** @interface */ function Int() {};\n" + "var a = [];\n" + "var foo = (/** @type {Int} */ a[0]);\n" + "new Foo"); assertType("Foo", getType("foo")); } public void testRestrictToCastWithNonInstantiatedTypes() { testSame( "/** @constructor */ function Super() {}\n" + "/** @constructor \n @extends {Super} */ function Foo() {};\n" + "Foo.prototype.blah = function() { foofunc() };\n" + "/** @constructor \n @extends {Super} */ function Bar() {};\n" + "Bar.prototype.blah = function() { barfunc() };\n" + "function barfunc() {}\n" + "function foofunc() {}\n" + "var a = [];\n" + "var u = /** @type {Super} */ (a[0]);\n" + "u.blah()\n" + "new Foo"); assertTrue(isCalled(getType("foofunc"))); assertFalse(isCalled(getType("barfunc"))); assertType("Array", getType("a")); } public void testFunctionToString() { testSame("/** @constructor */ function Foo() {}\n" + "/** @constructor \n * @extends Foo */\n" + "function Bar() { Foo.call(this); }\n" + "var a = function(a) { return new Foo; };\n;" + "a(new Foo);\n" + "a(new Bar);\n" + "new Bar;"); assertType("function ((Bar,Foo)): Foo", getType("a")); assertType("function (this:(Bar,Foo)): ()", getType("Foo")); assertType("function (this:Bar): ()", getType("Bar")); } private void assertType(String expected, ConcreteType type) { assertEquals(expected, type.toString()); } /** Returns the type of the given variable in the top-most scope. */ private ConcreteType getType(String var) { assertNotNull(tt.getTopScope().getSlot(var)); return tt.getTopScope().getSlot(var).getType(); } /** Returns the variable for the given parameter of the given function. */ private ConcreteSlot getParamVar(ConcreteType funType, int param) { assertTrue(funType.isFunction()); return (ConcreteSlot) ((ConcreteFunctionType) funType).getParameterSlot(param); } /** Returns the type of the given parameter of the given function. */ private ConcreteType getParamType(ConcreteType funType, int param) { ConcreteSlot paramVar = getParamVar(funType, param); return (paramVar != null) ? paramVar.getType() : ConcreteType.NONE; } /** Returns the variable for the this variable of the given function. */ private ConcreteSlot getThisSlot(ConcreteType funType) { assertTrue(funType.isFunction()); return (ConcreteSlot) ((ConcreteFunctionType) funType).getThisSlot(); } /** Returns the type of the this variable of the given function. */ private ConcreteType getThisType(ConcreteType funType) { return getThisSlot(funType).getType(); } /** Returns the prototype type of the given function. */ private ConcreteType getFunctionPrototype(ConcreteType funType) { assertTrue(funType.isFunction()); return ((ConcreteFunctionType) funType).getPrototypeType(); } /** * Returns the variable for the property with the give name on the given * instance type. */ private ConcreteSlot getPropertyVar(ConcreteType instType, String name) { assertTrue(instType.isInstance()); return (ConcreteSlot) ((ConcreteInstanceType) instType).getPropertySlot(name); } /** Returns the type of the property with the give name on the given type. */ private ConcreteType getPropertyType(ConcreteType instType, String name) { return getPropertyVar(instType, name).getType(); } /** Returns whether the given function is called. */ private boolean isCalled(ConcreteType funType) { assertTrue(funType.isFunction()); ConcreteSlot callVar = (ConcreteSlot) ((ConcreteFunctionType) funType).getCallSlot(); return !callVar.getType().isNone(); } }
/* * Copyright 2011 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Unit tests for {@link TransformAMDToCJSModule} */ public class TransformAMDToCJSModuleTest extends CompilerTestCase { @Override protected CompilerPass getProcessor(Compiler compiler) { return new TransformAMDToCJSModule(compiler); } @Override protected int getNumRepetitions() { return 1; } public void testDefine() { test("define(['foo', 'bar'], function(foo, bar) { foo(bar); bar+1; })", "var foo=require('foo'); var bar=require('bar');foo(bar);bar+1"); test("define(['foo', 'bar'], function(foo, bar, baz) { foo(bar); bar+1; })", "var foo=require('foo'); var bar=require('bar');" + "var baz = null;foo(bar);bar+1"); test("define(['foo', 'bar'], function(foo, bar) { return { test: 1 } })", "var foo=require('foo'); var bar=require('bar');" + "module.exports={test:1}"); test("define(['foo', 'bar'], function(foo, bar, exports) { " + "return { test: 1 } })", "var foo=require('foo'); var bar=require('bar');" + "module.exports={test:1}"); test("define(['foo', 'bar'], function(foo, bar, exports, module) { " + "return { test: 1 } })", "var foo=require('foo'); var bar=require('bar');" + "module.exports={test:1}"); test("define(['foo', 'bar'], function(foo, bar, exports, module, baz) { " + "return { test: 1 } })", "var foo=require('foo'); var bar=require('bar');var baz = null;" + "module.exports={test:1}"); test("define(['foo', 'bar'], function(foo) { return { test: 1 } })", "var foo=require('foo'); require('bar'); module.exports={test:1}"); test("define(['foo', 'bar'], function(test) { return { test: 1 } })", "var test=require('foo'); require('bar'); module.exports={test:1}"); } public void testVarRenaming() { final String suffix = TransformAMDToCJSModule.VAR_RENAME_SUFFIX; test("var foo; define(['foo', 'bar'], function(foo, bar) { " + "foo(bar); bar+1; })", "var foo; var foo" + suffix +"0=require('foo');" + "var bar=require('bar');foo" + suffix +"0(bar);bar+1"); test("function foo() {}; define(['foo', 'bar'], " + "function(foo, bar) { foo(bar); bar+1; })", "function foo() {}; var foo" + suffix +"0=require('foo'); " + "var bar=require('bar');foo" + suffix +"0(bar);bar+1"); } public void testDefineOnlyFunction() { test("define(function() { return { test: 1 } })", "module.exports={test:1}"); test("define(function(exports, module) { return { test: 1 } })", "module.exports={test:1}"); } public void testObjectLit() { test("define({foo: 'bar'})", "exports={foo: 'bar'}"); } public void testPlugins() { test("define(['foo', 'text!foo'], function(foo, text) {})", "var foo = require('foo'); var text = null;", null, TransformAMDToCJSModule.REQUIREJS_PLUGINS_NOT_SUPPORTED_WARNING); test("define(['foo', 'text!foo?bar'], function(foo, bar) {})", "var foo = require('foo'); var bar = require('bar'); ", null, TransformAMDToCJSModule.REQUIREJS_PLUGINS_NOT_SUPPORTED_WARNING); test("define(['foo', 'text!foo?:bar'], function(foo, bar) {})", "var foo = require('foo'); var bar = null;", null, TransformAMDToCJSModule.REQUIREJS_PLUGINS_NOT_SUPPORTED_WARNING); } public void testUnsupportedForms() { testUnsupported("define()"); testUnsupported("define([], function() {}, 1)"); testUnsupported("define({}, function() {})"); testUnsupported("define('test', function() {})"); testUnsupported("define([])"); testUnsupported("define(true)"); testUnsupported("define(1)"); testNonTopLevelDefine("var x = define(function() {});"); testNonTopLevelDefine("if(define(function() {})) {}"); } public void testLocalDefine() { testSame("(function() { function define() {}; define({}); })()"); } private void testUnsupported(String js) { test(js, null, TransformAMDToCJSModule.UNSUPPORTED_DEFINE_SIGNATURE_ERROR); } private void testNonTopLevelDefine(String js) { test(js, null, TransformAMDToCJSModule.NON_TOP_LEVEL_STATEMENT_DEFINE_ERROR); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import static com.google.javascript.jscomp.TypeCheck.WRONG_ARGUMENT_COUNT; import static com.google.javascript.jscomp.FunctionTypeBuilder.OPTIONAL_ARG_AT_END; import static com.google.javascript.jscomp.FunctionTypeBuilder.VAR_ARGS_MUST_BE_LAST; import com.google.javascript.jscomp.CheckLevel; import com.google.javascript.rhino.Node; /** * Tests for function and method arity checking in TypeCheck. * @author nicksantos@google.com (Nick Santos) */ public class TypeCheckFunctionCheckTest extends CompilerTestCase { private CodingConvention convention = null; public TypeCheckFunctionCheckTest() { parseTypeInfo = true; enableTypeCheck(CheckLevel.ERROR); } @Override protected CompilerPass getProcessor(Compiler compiler) { return new CompilerPass() { @Override public void process(Node externs, Node root) {} }; } @Override protected CodingConvention getCodingConvention() { return convention; } @Override protected int getNumRepetitions() { // TypeCheck will only run once, regardless of what this returns. // We return 1 so that the framework only expects 1 warning. return 1; } @Override public void setUp() throws Exception { super.setUp(); convention = new GoogleCodingConvention(); } public void testFunctionAritySimple() { assertOk("", ""); assertOk("a", "'a'"); assertOk("a,b", "10, 20"); } public void testFunctionArityWithOptionalArgs() { assertOk("a,b,opt_c", "1,2"); assertOk("a,b,opt_c", "1,2,3"); assertOk("a,opt_b,opt_c", "1"); } public void testFunctionArityWithVarArgs() { assertOk("var_args", ""); assertOk("var_args", "1,2"); assertOk("a,b,var_args", "1,2"); assertOk("a,b,var_args", "1,2,3"); assertOk("a,b,var_args", "1,2,3,4,5"); assertOk("a,opt_b,var_args", "1"); assertOk("a,opt_b,var_args", "1,2"); assertOk("a,opt_b,var_args", "1,2,3"); assertOk("a,opt_b,var_args", "1,2,3,4,5"); } public void testWrongNumberOfArgs() { assertWarning("a,b,opt_c", "1", WRONG_ARGUMENT_COUNT); assertWarning("a,b,opt_c", "1,2,3,4", WRONG_ARGUMENT_COUNT); assertWarning("a,b", "1, 2, 3", WRONG_ARGUMENT_COUNT); assertWarning("", "1, 2, 3", WRONG_ARGUMENT_COUNT); assertWarning("a,b,c,d", "1, 2, 3", WRONG_ARGUMENT_COUNT); assertWarning("a,b,var_args", "1", WRONG_ARGUMENT_COUNT); assertWarning("a,b,opt_c,var_args", "1", WRONG_ARGUMENT_COUNT); } public void testVarArgsLast() { assertWarning("a,b,var_args,c", "1,2,3,4", VAR_ARGS_MUST_BE_LAST); } public void testOptArgsLast() { assertWarning("a,b,opt_d,c", "1, 2, 3", OPTIONAL_ARG_AT_END); assertWarning("a,b,opt_d,c", "1, 2", OPTIONAL_ARG_AT_END); } public void testFunctionsWithJsDoc1() { testSame("/** @param {*=} c */ function foo(a,b,c) {} foo(1,2);"); } public void testFunctionsWithJsDoc2() { testSame("/** @param {*=} c */ function foo(a,b,c) {} foo(1,2,3);"); } public void testFunctionsWithJsDoc3() { testSame("/** @param {*=} c \n * @param {*=} b */ " + "function foo(a,b,c) {} foo(1);"); } public void testFunctionsWithJsDoc4() { testSame("/** @param {...*} a */ var foo = function(a) {}; foo();"); } public void testFunctionsWithJsDoc5() { testSame("/** @param {...*} a */ var foo = function(a) {}; foo(1,2);"); } public void testFunctionsWithJsDoc6() { testSame("/** @param {...*} b */ var foo = function(a, b) {}; foo();", WRONG_ARGUMENT_COUNT); } public void testFunctionsWithJsDoc7() { String fooDfn = "/** @param {*} [b] */ var foo = function(b) {};"; testSame(fooDfn + "foo();"); testSame(fooDfn + "foo(1);"); testSame(fooDfn + "foo(1, 2);", WRONG_ARGUMENT_COUNT); } public void testFunctionWithDefaultCodingConvention() { convention = CodingConventions.getDefault(); testSame("var foo = function(x) {}; foo(1, 2);"); testSame("var foo = function(opt_x) {}; foo(1, 2);"); testSame("var foo = function(var_args) {}; foo(1, 2);"); } public void testMethodCalls() { final String METHOD_DEFS = "/** @constructor */\n" + "function Foo() {}" + // Methods defined in a separate functions and then added via assignment "function twoArg(arg1, arg2) {};" + "Foo.prototype.prototypeMethod = twoArg;" + "Foo.staticMethod = twoArg;" + // Constructor that specifies a return type "/**\n * @constructor\n * @return {Bar}\n */\n" + "function Bar() {}"; // Prototype method with too many arguments. testSame(METHOD_DEFS + "var f = new Foo();f.prototypeMethod(1, 2, 3);", TypeCheck.WRONG_ARGUMENT_COUNT); // Prototype method with too few arguments. testSame(METHOD_DEFS + "var f = new Foo();f.prototypeMethod(1);", TypeCheck.WRONG_ARGUMENT_COUNT); // Static method with too many arguments. testSame(METHOD_DEFS + "Foo.staticMethod(1, 2, 3);", TypeCheck.WRONG_ARGUMENT_COUNT); // Static method with too few arguments. testSame(METHOD_DEFS + "Foo.staticMethod(1);", TypeCheck.WRONG_ARGUMENT_COUNT); // Constructor calls require new keyword testSame(METHOD_DEFS + "Bar();", TypeCheck.CONSTRUCTOR_NOT_CALLABLE); // Extern constructor calls require new keyword testSame(METHOD_DEFS, "Foo();", TypeCheck.CONSTRUCTOR_NOT_CALLABLE); // Extern constructor call without new keyword testSame(METHOD_DEFS, "Bar();", null); } public void assertOk(String params, String arguments) { assertWarning(params, arguments, null); } public void assertWarning(String params, String arguments, DiagnosticType type) { testSame("function foo(" + params + ") {} foo(" + arguments + ");", type); } }
/* * Copyright 2006 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.base.Joiner; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter; import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter; import com.google.javascript.rhino.InputId; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.testing.Asserts; import java.util.Arrays; import java.util.List; import java.util.Set; /** * Tests {@link TypeCheck}. * */ public class TypeCheckTest extends CompilerTypeTestCase { private CheckLevel reportMissingOverrides = CheckLevel.WARNING; @Override public void setUp() throws Exception { super.setUp(); reportMissingOverrides = CheckLevel.WARNING; } public void testInitialTypingScope() { Scope s = new TypedScopeCreator(compiler, CodingConventions.getDefault()).createInitialScope( new Node(Token.BLOCK)); assertTypeEquals(ARRAY_FUNCTION_TYPE, s.getVar("Array").getType()); assertTypeEquals(BOOLEAN_OBJECT_FUNCTION_TYPE, s.getVar("Boolean").getType()); assertTypeEquals(DATE_FUNCTION_TYPE, s.getVar("Date").getType()); assertTypeEquals(ERROR_FUNCTION_TYPE, s.getVar("Error").getType()); assertTypeEquals(EVAL_ERROR_FUNCTION_TYPE, s.getVar("EvalError").getType()); assertTypeEquals(NUMBER_OBJECT_FUNCTION_TYPE, s.getVar("Number").getType()); assertTypeEquals(OBJECT_FUNCTION_TYPE, s.getVar("Object").getType()); assertTypeEquals(RANGE_ERROR_FUNCTION_TYPE, s.getVar("RangeError").getType()); assertTypeEquals(REFERENCE_ERROR_FUNCTION_TYPE, s.getVar("ReferenceError").getType()); assertTypeEquals(REGEXP_FUNCTION_TYPE, s.getVar("RegExp").getType()); assertTypeEquals(STRING_OBJECT_FUNCTION_TYPE, s.getVar("String").getType()); assertTypeEquals(SYNTAX_ERROR_FUNCTION_TYPE, s.getVar("SyntaxError").getType()); assertTypeEquals(TYPE_ERROR_FUNCTION_TYPE, s.getVar("TypeError").getType()); assertTypeEquals(URI_ERROR_FUNCTION_TYPE, s.getVar("URIError").getType()); } public void testPrivateType() throws Exception { testTypes( "/** @private {number} */ var x = false;", "initializing variable\n" + "found : boolean\n" + "required: number"); } public void testTypeCheck1() throws Exception { testTypes("/**@return {void}*/function foo(){ if (foo()) return; }"); } public void testTypeCheck2() throws Exception { testTypes("/**@return {void}*/function foo(){ var x=foo(); x--; }", "increment/decrement\n" + "found : undefined\n" + "required: number"); } public void testTypeCheck4() throws Exception { testTypes("/**@return {void}*/function foo(){ !foo(); }"); } public void testTypeCheck5() throws Exception { testTypes("/**@return {void}*/function foo(){ var a = +foo(); }", "sign operator\n" + "found : undefined\n" + "required: number"); } public void testTypeCheck6() throws Exception { testTypes( "/**@return {void}*/function foo(){" + "/** @type {undefined|number} */var a;if (a == foo())return;}"); } public void testTypeCheck8() throws Exception { testTypes("/**@return {void}*/function foo(){do {} while (foo());}"); } public void testTypeCheck9() throws Exception { testTypes("/**@return {void}*/function foo(){while (foo());}"); } public void testTypeCheck10() throws Exception { testTypes("/**@return {void}*/function foo(){for (;foo(););}"); } public void testTypeCheck11() throws Exception { testTypes("/**@type !Number */var a;" + "/**@type !String */var b;" + "a = b;", "assignment\n" + "found : String\n" + "required: Number"); } public void testTypeCheck12() throws Exception { testTypes("/**@return {!Object}*/function foo(){var a = 3^foo();}", "bad right operand to bitwise operator\n" + "found : Object\n" + "required: (boolean|null|number|string|undefined)"); } public void testTypeCheck13() throws Exception { testTypes("/**@type {!Number|!String}*/var i; i=/xx/;", "assignment\n" + "found : RegExp\n" + "required: (Number|String)"); } public void testTypeCheck14() throws Exception { testTypes("/**@param opt_a*/function foo(opt_a){}"); } public void testTypeCheck15() throws Exception { testTypes("/**@type {Number|null} */var x;x=null;x=10;", "assignment\n" + "found : number\n" + "required: (Number|null)"); } public void testTypeCheck16() throws Exception { testTypes("/**@type {Number|null} */var x='';", "initializing variable\n" + "found : string\n" + "required: (Number|null)"); } public void testTypeCheck17() throws Exception { testTypes("/**@return {Number}\n@param {Number} opt_foo */\n" + "function a(opt_foo){\nreturn /**@type {Number}*/(opt_foo);\n}"); } public void testTypeCheck18() throws Exception { testTypes("/**@return {RegExp}\n*/\n function a(){return new RegExp();}"); } public void testTypeCheck19() throws Exception { testTypes("/**@return {Array}\n*/\n function a(){return new Array();}"); } public void testTypeCheck20() throws Exception { testTypes("/**@return {Date}\n*/\n function a(){return new Date();}"); } public void testTypeCheckBasicDowncast() throws Exception { testTypes("/** @constructor */function foo() {}\n" + "/** @type {Object} */ var bar = new foo();\n"); } public void testTypeCheckNoDowncastToNumber() throws Exception { testTypes("/** @constructor */function foo() {}\n" + "/** @type {!Number} */ var bar = new foo();\n", "initializing variable\n" + "found : foo\n" + "required: Number"); } public void testTypeCheck21() throws Exception { testTypes("/** @type Array.<String> */var foo;"); } public void testTypeCheck22() throws Exception { testTypes("/** @param {Element|Object} p */\nfunction foo(p){}\n" + "/** @constructor */function Element(){}\n" + "/** @type {Element|Object} */var v;\n" + "foo(v);\n"); } public void testTypeCheck23() throws Exception { testTypes("/** @type {(Object,Null)} */var foo; foo = null;"); } public void testTypeCheck24() throws Exception { testTypes("/** @constructor */function MyType(){}\n" + "/** @type {(MyType,Null)} */var foo; foo = null;"); } public void testTypeCheckDefaultExterns() throws Exception { testTypes("/** @param {string} x */ function f(x) {}" + "f([].length);" , "actual parameter 1 of f does not match formal parameter\n" + "found : number\n" + "required: string"); } public void testTypeCheckCustomExterns() throws Exception { testTypes( DEFAULT_EXTERNS + "/** @type {boolean} */ Array.prototype.oogabooga;", "/** @param {string} x */ function f(x) {}" + "f([].oogabooga);" , "actual parameter 1 of f does not match formal parameter\n" + "found : boolean\n" + "required: string", false); } public void testTypeCheckCustomExterns2() throws Exception { testTypes( DEFAULT_EXTERNS + "/** @enum {string} */ var Enum = {FOO: 1, BAR: 1};", "/** @param {Enum} x */ function f(x) {} f(Enum.FOO); f(true);", "actual parameter 1 of f does not match formal parameter\n" + "found : boolean\n" + "required: Enum.<string>", false); } public void testParameterizedArray1() throws Exception { testTypes("/** @param {!Array.<number>} a\n" + "* @return {string}\n" + "*/ var f = function(a) { return a[0]; };", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testParameterizedArray2() throws Exception { testTypes("/** @param {!Array.<!Array.<number>>} a\n" + "* @return {number}\n" + "*/ var f = function(a) { return a[0]; };", "inconsistent return type\n" + "found : Array.<number>\n" + "required: number"); } public void testParameterizedArray3() throws Exception { testTypes("/** @param {!Array.<number>} a\n" + "* @return {number}\n" + "*/ var f = function(a) { a[1] = 0; return a[0]; };"); } public void testParameterizedArray4() throws Exception { testTypes("/** @param {!Array.<number>} a\n" + "*/ var f = function(a) { a[0] = 'a'; };", "assignment\n" + "found : string\n" + "required: number"); } public void testParameterizedArray5() throws Exception { testTypes("/** @param {!Array.<*>} a\n" + "*/ var f = function(a) { a[0] = 'a'; };"); } public void testParameterizedArray6() throws Exception { testTypes("/** @param {!Array.<*>} a\n" + "* @return {string}\n" + "*/ var f = function(a) { return a[0]; };", "inconsistent return type\n" + "found : *\n" + "required: string"); } public void testParameterizedArray7() throws Exception { testTypes("/** @param {?Array.<number>} a\n" + "* @return {string}\n" + "*/ var f = function(a) { return a[0]; };", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testParameterizedObject1() throws Exception { testTypes("/** @param {!Object.<number>} a\n" + "* @return {string}\n" + "*/ var f = function(a) { return a[0]; };", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testParameterizedObject2() throws Exception { testTypes("/** @param {!Object.<string,number>} a\n" + "* @return {string}\n" + "*/ var f = function(a) { return a['x']; };", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testParameterizedObject3() throws Exception { testTypes("/** @param {!Object.<number,string>} a\n" + "* @return {string}\n" + "*/ var f = function(a) { return a['x']; };", "restricted index type\n" + "found : string\n" + "required: number"); } public void testParameterizedObject4() throws Exception { testTypes("/** @enum {string} */ var E = {A: 'a', B: 'b'};\n" + "/** @param {!Object.<E,string>} a\n" + "* @return {string}\n" + "*/ var f = function(a) { return a['x']; };", "restricted index type\n" + "found : string\n" + "required: E.<string>"); } public void testParameterizedObject5() throws Exception { testTypes("/** @constructor */ function F() {" + " /** @type {Object.<number, string>} */ this.numbers = {};" + "}" + "(new F()).numbers['ten'] = '10';", "restricted index type\n" + "found : string\n" + "required: number"); } public void testUnionOfFunctionAndType() throws Exception { testTypes("/** @type {null|(function(Number):void)} */ var a;" + "/** @type {(function(Number):void)|null} */ var b = null; a = b;"); } public void testOptionalParameterComparedToUndefined() throws Exception { testTypes("/**@param opt_a {Number}*/function foo(opt_a)" + "{if (opt_a==undefined) var b = 3;}"); } public void testOptionalAllType() throws Exception { testTypes("/** @param {*} opt_x */function f(opt_x) { return opt_x }\n" + "/** @type {*} */var y;\n" + "f(y);"); } public void testOptionalUnknownNamedType() throws Exception { testTypes("/** @param {!T} opt_x\n@return {undefined} */\n" + "function f(opt_x) { return opt_x; }\n" + "/** @constructor */var T = function() {};", "inconsistent return type\n" + "found : (T|undefined)\n" + "required: undefined"); } public void testOptionalArgFunctionParam() throws Exception { testTypes("/** @param {function(number=)} a */" + "function f(a) {a()};"); } public void testOptionalArgFunctionParam2() throws Exception { testTypes("/** @param {function(number=)} a */" + "function f(a) {a(3)};"); } public void testOptionalArgFunctionParam3() throws Exception { testTypes("/** @param {function(number=)} a */" + "function f(a) {a(undefined)};"); } public void testOptionalArgFunctionParam4() throws Exception { String expectedWarning = "Function a: called with 2 argument(s). " + "Function requires at least 0 argument(s) and no more than 1 " + "argument(s)."; testTypes("/** @param {function(number=)} a */function f(a) {a(3,4)};", expectedWarning, false); } public void testOptionalArgFunctionParamError() throws Exception { String expectedWarning = "Bad type annotation. variable length argument must be last"; testTypes("/** @param {function(...[number], number=)} a */" + "function f(a) {};", expectedWarning, false); } public void testOptionalNullableArgFunctionParam() throws Exception { testTypes("/** @param {function(?number=)} a */" + "function f(a) {a()};"); } public void testOptionalNullableArgFunctionParam2() throws Exception { testTypes("/** @param {function(?number=)} a */" + "function f(a) {a(null)};"); } public void testOptionalNullableArgFunctionParam3() throws Exception { testTypes("/** @param {function(?number=)} a */" + "function f(a) {a(3)};"); } public void testOptionalArgFunctionReturn() throws Exception { testTypes("/** @return {function(number=)} */" + "function f() { return function(opt_x) { }; };" + "f()()"); } public void testOptionalArgFunctionReturn2() throws Exception { testTypes("/** @return {function(Object=)} */" + "function f() { return function(opt_x) { }; };" + "f()({})"); } public void testBooleanType() throws Exception { testTypes("/**@type {boolean} */var x = 1 < 2;"); } public void testBooleanReduction1() throws Exception { testTypes("/**@type {string} */var x; x = null || \"a\";"); } public void testBooleanReduction2() throws Exception { // It's important for the type system to recognize that in no case // can the boolean expression evaluate to a boolean value. testTypes("/** @param {string} s\n @return {string} */" + "(function(s) { return ((s == 'a') && s) || 'b'; })"); } public void testBooleanReduction3() throws Exception { testTypes("/** @param {string} s\n @return {string?} */" + "(function(s) { return s && null && 3; })"); } public void testBooleanReduction4() throws Exception { testTypes("/** @param {Object} x\n @return {Object} */" + "(function(x) { return null || x || null ; })"); } public void testBooleanReduction5() throws Exception { testTypes("/**\n" + "* @param {Array|string} x\n" + "* @return {string?}\n" + "*/\n" + "var f = function(x) {\n" + "if (!x || typeof x == 'string') {\n" + "return x;\n" + "}\n" + "return null;\n" + "};"); } public void testBooleanReduction6() throws Exception { testTypes("/**\n" + "* @param {Array|string|null} x\n" + "* @return {string?}\n" + "*/\n" + "var f = function(x) {\n" + "if (!(x && typeof x != 'string')) {\n" + "return x;\n" + "}\n" + "return null;\n" + "};"); } public void testBooleanReduction7() throws Exception { testTypes("/** @constructor */var T = function() {};\n" + "/**\n" + "* @param {Array|T} x\n" + "* @return {null}\n" + "*/\n" + "var f = function(x) {\n" + "if (!x) {\n" + "return x;\n" + "}\n" + "return null;\n" + "};"); } public void testNullAnd() throws Exception { testTypes("/** @type null */var x;\n" + "/** @type number */var r = x && x;", "initializing variable\n" + "found : null\n" + "required: number"); } public void testNullOr() throws Exception { testTypes("/** @type null */var x;\n" + "/** @type number */var r = x || x;", "initializing variable\n" + "found : null\n" + "required: number"); } public void testBooleanPreservation1() throws Exception { testTypes("/**@type {string} */var x = \"a\";" + "x = ((x == \"a\") && x) || x == \"b\";", "assignment\n" + "found : (boolean|string)\n" + "required: string"); } public void testBooleanPreservation2() throws Exception { testTypes("/**@type {string} */var x = \"a\"; x = (x == \"a\") || x;", "assignment\n" + "found : (boolean|string)\n" + "required: string"); } public void testBooleanPreservation3() throws Exception { testTypes("/** @param {Function?} x\n @return {boolean?} */" + "function f(x) { return x && x == \"a\"; }", "condition always evaluates to false\n" + "left : Function\n" + "right: string"); } public void testBooleanPreservation4() throws Exception { testTypes("/** @param {Function?|boolean} x\n @return {boolean} */" + "function f(x) { return x && x == \"a\"; }", "inconsistent return type\n" + "found : (boolean|null)\n" + "required: boolean"); } public void testTypeOfReduction1() throws Exception { testTypes("/** @param {string|number} x\n @return {string} */ " + "function f(x) { return typeof x == 'number' ? String(x) : x; }"); } public void testTypeOfReduction2() throws Exception { testTypes("/** @param {string|number} x\n @return {string} */ " + "function f(x) { return typeof x != 'string' ? String(x) : x; }"); } public void testTypeOfReduction3() throws Exception { testTypes("/** @param {number|null} x\n @return {number} */ " + "function f(x) { return typeof x == 'object' ? 1 : x; }"); } public void testTypeOfReduction4() throws Exception { testTypes("/** @param {Object|undefined} x\n @return {Object} */ " + "function f(x) { return typeof x == 'undefined' ? {} : x; }"); } public void testTypeOfReduction5() throws Exception { testTypes("/** @enum {string} */ var E = {A: 'a', B: 'b'};\n" + "/** @param {!E|number} x\n @return {string} */ " + "function f(x) { return typeof x != 'number' ? x : 'a'; }"); } public void testTypeOfReduction6() throws Exception { testTypes("/** @param {number|string} x\n@return {string} */\n" + "function f(x) {\n" + "return typeof x == 'string' && x.length == 3 ? x : 'a';\n" + "}"); } public void testTypeOfReduction7() throws Exception { testTypes("/** @return {string} */var f = function(x) { " + "return typeof x == 'number' ? x : 'a'; }", "inconsistent return type\n" + "found : (number|string)\n" + "required: string"); } public void testTypeOfReduction8() throws Exception { testClosureTypes( CLOSURE_DEFS + "/** @param {number|string} x\n@return {string} */\n" + "function f(x) {\n" + "return goog.isString(x) && x.length == 3 ? x : 'a';\n" + "}", null); } public void testTypeOfReduction9() throws Exception { testClosureTypes( CLOSURE_DEFS + "/** @param {!Array|string} x\n@return {string} */\n" + "function f(x) {\n" + "return goog.isArray(x) ? 'a' : x;\n" + "}", null); } public void testTypeOfReduction10() throws Exception { testClosureTypes( CLOSURE_DEFS + "/** @param {Array|string} x\n@return {Array} */\n" + "function f(x) {\n" + "return goog.isArray(x) ? x : [];\n" + "}", null); } public void testTypeOfReduction11() throws Exception { testClosureTypes( CLOSURE_DEFS + "/** @param {Array|string} x\n@return {Array} */\n" + "function f(x) {\n" + "return goog.isObject(x) ? x : [];\n" + "}", null); } public void testTypeOfReduction12() throws Exception { testTypes("/** @enum {string} */ var E = {A: 'a', B: 'b'};\n" + "/** @param {E|Array} x\n @return {Array} */ " + "function f(x) { return typeof x == 'object' ? x : []; }"); } public void testTypeOfReduction13() throws Exception { testClosureTypes( CLOSURE_DEFS + "/** @enum {string} */ var E = {A: 'a', B: 'b'};\n" + "/** @param {E|Array} x\n@return {Array} */ " + "function f(x) { return goog.isObject(x) ? x : []; }", null); } public void testTypeOfReduction14() throws Exception { // Don't do type inference on GETELEMs. testClosureTypes( CLOSURE_DEFS + "function f(x) { " + " return goog.isString(arguments[0]) ? arguments[0] : 0;" + "}", null); } public void testTypeOfReduction15() throws Exception { // Don't do type inference on GETELEMs. testClosureTypes( CLOSURE_DEFS + "function f(x) { " + " return typeof arguments[0] == 'string' ? arguments[0] : 0;" + "}", null); } public void testTypeOfReduction16() throws Exception { testClosureTypes( CLOSURE_DEFS + "/** @interface */ function I() {}\n" + "/**\n" + " * @param {*} x\n" + " * @return {I}\n" + " */\n" + "function f(x) { " + " if(goog.isObject(x)) {" + " return /** @type {I} */(x);" + " }" + " return null;" + "}", null); } public void testQualifiedNameReduction1() throws Exception { testTypes("var x = {}; /** @type {string?} */ x.a = 'a';\n" + "/** @return {string} */ var f = function() {\n" + "return x.a ? x.a : 'a'; }"); } public void testQualifiedNameReduction2() throws Exception { testTypes("/** @param {string?} a\n@constructor */ var T = " + "function(a) {this.a = a};\n" + "/** @return {string} */ T.prototype.f = function() {\n" + "return this.a ? this.a : 'a'; }"); } public void testQualifiedNameReduction3() throws Exception { testTypes("/** @param {string|Array} a\n@constructor */ var T = " + "function(a) {this.a = a};\n" + "/** @return {string} */ T.prototype.f = function() {\n" + "return typeof this.a == 'string' ? this.a : 'a'; }"); } public void testQualifiedNameReduction4() throws Exception { testClosureTypes( CLOSURE_DEFS + "/** @param {string|Array} a\n@constructor */ var T = " + "function(a) {this.a = a};\n" + "/** @return {string} */ T.prototype.f = function() {\n" + "return goog.isString(this.a) ? this.a : 'a'; }", null); } public void testQualifiedNameReduction5a() throws Exception { testTypes("var x = {/** @type {string} */ a:'b' };\n" + "/** @return {string} */ var f = function() {\n" + "return x.a; }"); } public void testQualifiedNameReduction5b() throws Exception { testTypes( "var x = {/** @type {number} */ a:12 };\n" + "/** @return {string} */\n" + "var f = function() {\n" + " return x.a;\n" + "}", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testQualifiedNameReduction5c() throws Exception { testTypes( "/** @return {string} */ var f = function() {\n" + "var x = {/** @type {number} */ a:0 };\n" + "return (x.a) ? (x.a) : 'a'; }", "inconsistent return type\n" + "found : (number|string)\n" + "required: string"); } public void testQualifiedNameReduction6() throws Exception { testTypes( "/** @return {string} */ var f = function() {\n" + "var x = {/** @return {string?} */ get a() {return 'a'}};\n" + "return x.a ? x.a : 'a'; }"); } public void testQualifiedNameReduction7() throws Exception { testTypes( "/** @return {string} */ var f = function() {\n" + "var x = {/** @return {number} */ get a() {return 12}};\n" + "return x.a; }", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testQualifiedNameReduction7a() throws Exception { // It would be nice to find a way to make this an error. testTypes( "/** @return {string} */ var f = function() {\n" + "var x = {get a() {return 12}};\n" + "return x.a; }"); } public void testQualifiedNameReduction8() throws Exception { testTypes( "/** @return {string} */ var f = function() {\n" + "var x = {get a() {return 'a'}};\n" + "return x.a ? x.a : 'a'; }"); } public void testQualifiedNameReduction9() throws Exception { testTypes( "/** @return {string} */ var f = function() {\n" + "var x = { /** @param {string} b */ set a(b) {}};\n" + "return x.a ? x.a : 'a'; }"); } public void testQualifiedNameReduction10() throws Exception { // TODO(johnlenz): separate setter property types from getter property // types. testTypes( "/** @return {string} */ var f = function() {\n" + "var x = { /** @param {number} b */ set a(b) {}};\n" + "return x.a ? x.a : 'a'; }", "inconsistent return type\n" + "found : (number|string)\n" + "required: string"); } public void testObjLitDef1a() throws Exception { testTypes( "var x = {/** @type {number} */ a:12 };\n" + "x.a = 'a';", "assignment to property a of x\n" + "found : string\n" + "required: number"); } public void testObjLitDef1b() throws Exception { testTypes( "function f(){" + "var x = {/** @type {number} */ a:12 };\n" + "x.a = 'a';" + "};\n" + "f();", "assignment to property a of x\n" + "found : string\n" + "required: number"); } public void testObjLitDef2a() throws Exception { testTypes( "var x = {/** @param {number} b */ set a(b){} };\n" + "x.a = 'a';", "assignment to property a of x\n" + "found : string\n" + "required: number"); } public void testObjLitDef2b() throws Exception { testTypes( "function f(){" + "var x = {/** @param {number} b */ set a(b){} };\n" + "x.a = 'a';" + "};\n" + "f();", "assignment to property a of x\n" + "found : string\n" + "required: number"); } public void testObjLitDef3a() throws Exception { testTypes( "/** @type {string} */ var y;\n" + "var x = {/** @return {number} */ get a(){} };\n" + "y = x.a;", "assignment\n" + "found : number\n" + "required: string"); } public void testObjLitDef3b() throws Exception { testTypes( "/** @type {string} */ var y;\n" + "function f(){" + "var x = {/** @return {number} */ get a(){} };\n" + "y = x.a;" + "};\n" + "f();", "assignment\n" + "found : number\n" + "required: string"); } public void testObjLitDef4() throws Exception { testTypes( "var x = {" + "/** @return {number} */ a:12 };\n", "assignment to property a of {a: function (): number}\n" + "found : number\n" + "required: function (): number"); } public void testObjLitDef5() throws Exception { testTypes( "var x = {};\n" + "/** @return {number} */ x.a = 12;\n", "assignment to property a of x\n" + "found : number\n" + "required: function (): number"); } public void testObjLitDef6() throws Exception { testTypes("var lit = /** @struct */ { 'x': 1 };", "Illegal key, the object literal is a struct"); } public void testObjLitDef7() throws Exception { testTypes("var lit = /** @dict */ { x: 1 };", "Illegal key, the object literal is a dict"); } public void testInstanceOfReduction1() throws Exception { testTypes("/** @constructor */ var T = function() {};\n" + "/** @param {T|string} x\n@return {T} */\n" + "var f = function(x) {\n" + "if (x instanceof T) { return x; } else { return new T(); }\n" + "};"); } public void testInstanceOfReduction2() throws Exception { testTypes("/** @constructor */ var T = function() {};\n" + "/** @param {!T|string} x\n@return {string} */\n" + "var f = function(x) {\n" + "if (x instanceof T) { return ''; } else { return x; }\n" + "};"); } public void testUndeclaredGlobalProperty1() throws Exception { testTypes("/** @const */ var x = {}; x.y = null;" + "function f(a) { x.y = a; }" + "/** @param {string} a */ function g(a) { }" + "function h() { g(x.y); }"); } public void testUndeclaredGlobalProperty2() throws Exception { testTypes("/** @const */ var x = {}; x.y = null;" + "function f() { x.y = 3; }" + "/** @param {string} a */ function g(a) { }" + "function h() { g(x.y); }", "actual parameter 1 of g does not match formal parameter\n" + "found : (null|number)\n" + "required: string"); } public void testLocallyInferredGlobalProperty1() throws Exception { // We used to have a bug where x.y.z leaked from f into h. testTypes( "/** @constructor */ function F() {}" + "/** @type {number} */ F.prototype.z;" + "/** @const */ var x = {}; /** @type {F} */ x.y;" + "function f() { x.y.z = 'abc'; }" + "/** @param {number} x */ function g(x) {}" + "function h() { g(x.y.z); }", "assignment to property z of F\n" + "found : string\n" + "required: number"); } public void testPropertyInferredPropagation() throws Exception { testTypes("/** @return {Object} */function f() { return {}; }\n" + "function g() { var x = f(); if (x.p) x.a = 'a'; else x.a = 'b'; }\n" + "function h() { var x = f(); x.a = false; }"); } public void testPropertyInference1() throws Exception { testTypes( "/** @constructor */ function F() { this.x_ = true; }" + "/** @return {string} */" + "F.prototype.bar = function() { if (this.x_) return this.x_; };", "inconsistent return type\n" + "found : boolean\n" + "required: string"); } public void testPropertyInference2() throws Exception { testTypes( "/** @constructor */ function F() { this.x_ = true; }" + "F.prototype.baz = function() { this.x_ = null; };" + "/** @return {string} */" + "F.prototype.bar = function() { if (this.x_) return this.x_; };", "inconsistent return type\n" + "found : boolean\n" + "required: string"); } public void testPropertyInference3() throws Exception { testTypes( "/** @constructor */ function F() { this.x_ = true; }" + "F.prototype.baz = function() { this.x_ = 3; };" + "/** @return {string} */" + "F.prototype.bar = function() { if (this.x_) return this.x_; };", "inconsistent return type\n" + "found : (boolean|number)\n" + "required: string"); } public void testPropertyInference4() throws Exception { testTypes( "/** @constructor */ function F() { }" + "F.prototype.x_ = 3;" + "/** @return {string} */" + "F.prototype.bar = function() { if (this.x_) return this.x_; };", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testPropertyInference5() throws Exception { testTypes( "/** @constructor */ function F() { }" + "F.prototype.baz = function() { this.x_ = 3; };" + "/** @return {string} */" + "F.prototype.bar = function() { if (this.x_) return this.x_; };"); } public void testPropertyInference6() throws Exception { testTypes( "/** @constructor */ function F() { }" + "(new F).x_ = 3;" + "/** @return {string} */" + "F.prototype.bar = function() { return this.x_; };"); } public void testPropertyInference7() throws Exception { testTypes( "/** @constructor */ function F() { this.x_ = true; }" + "(new F).x_ = 3;" + "/** @return {string} */" + "F.prototype.bar = function() { return this.x_; };", "inconsistent return type\n" + "found : boolean\n" + "required: string"); } public void testPropertyInference8() throws Exception { testTypes( "/** @constructor */ function F() { " + " /** @type {string} */ this.x_ = 'x';" + "}" + "(new F).x_ = 3;" + "/** @return {string} */" + "F.prototype.bar = function() { return this.x_; };", "assignment to property x_ of F\n" + "found : number\n" + "required: string"); } public void testPropertyInference9() throws Exception { testTypes( "/** @constructor */ function A() {}" + "/** @return {function(): ?} */ function f() { " + " return function() {};" + "}" + "var g = f();" + "/** @type {number} */ g.prototype.bar_ = null;", "assignment\n" + "found : null\n" + "required: number"); } public void testPropertyInference10() throws Exception { // NOTE(nicksantos): There used to be a bug where a property // on the prototype of one structural function would leak onto // the prototype of other variables with the same structural // function type. testTypes( "/** @constructor */ function A() {}" + "/** @return {function(): ?} */ function f() { " + " return function() {};" + "}" + "var g = f();" + "/** @type {number} */ g.prototype.bar_ = 1;" + "var h = f();" + "/** @type {string} */ h.prototype.bar_ = 1;", "assignment\n" + "found : number\n" + "required: string"); } public void testNoPersistentTypeInferenceForObjectProperties() throws Exception { testTypes("/** @param {Object} o\n@param {string} x */\n" + "function s1(o,x) { o.x = x; }\n" + "/** @param {Object} o\n@return {string} */\n" + "function g1(o) { return typeof o.x == 'undefined' ? '' : o.x; }\n" + "/** @param {Object} o\n@param {number} x */\n" + "function s2(o,x) { o.x = x; }\n" + "/** @param {Object} o\n@return {number} */\n" + "function g2(o) { return typeof o.x == 'undefined' ? 0 : o.x; }"); } public void testNoPersistentTypeInferenceForFunctionProperties() throws Exception { testTypes("/** @param {Function} o\n@param {string} x */\n" + "function s1(o,x) { o.x = x; }\n" + "/** @param {Function} o\n@return {string} */\n" + "function g1(o) { return typeof o.x == 'undefined' ? '' : o.x; }\n" + "/** @param {Function} o\n@param {number} x */\n" + "function s2(o,x) { o.x = x; }\n" + "/** @param {Function} o\n@return {number} */\n" + "function g2(o) { return typeof o.x == 'undefined' ? 0 : o.x; }"); } public void testObjectPropertyTypeInferredInLocalScope1() throws Exception { testTypes("/** @param {!Object} o\n@return {string} */\n" + "function f(o) { o.x = 1; return o.x; }", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testObjectPropertyTypeInferredInLocalScope2() throws Exception { testTypes("/**@param {!Object} o\n@param {number?} x\n@return {string}*/" + "function f(o, x) { o.x = 'a';\nif (x) {o.x = x;}\nreturn o.x; }", "inconsistent return type\n" + "found : (number|string)\n" + "required: string"); } public void testObjectPropertyTypeInferredInLocalScope3() throws Exception { testTypes("/**@param {!Object} o\n@param {number?} x\n@return {string}*/" + "function f(o, x) { if (x) {o.x = x;} else {o.x = 'a';}\nreturn o.x; }", "inconsistent return type\n" + "found : (number|string)\n" + "required: string"); } public void testMismatchingOverridingInferredPropertyBeforeDeclaredProperty1() throws Exception { testTypes("/** @constructor */var T = function() { this.x = ''; };\n" + "/** @type {number} */ T.prototype.x = 0;", "assignment to property x of T\n" + "found : string\n" + "required: number"); } public void testMismatchingOverridingInferredPropertyBeforeDeclaredProperty2() throws Exception { testTypes("/** @constructor */var T = function() { this.x = ''; };\n" + "/** @type {number} */ T.prototype.x;", "assignment to property x of T\n" + "found : string\n" + "required: number"); } public void testMismatchingOverridingInferredPropertyBeforeDeclaredProperty3() throws Exception { testTypes("/** @type {Object} */ var n = {};\n" + "/** @constructor */ n.T = function() { this.x = ''; };\n" + "/** @type {number} */ n.T.prototype.x = 0;", "assignment to property x of n.T\n" + "found : string\n" + "required: number"); } public void testMismatchingOverridingInferredPropertyBeforeDeclaredProperty4() throws Exception { testTypes("var n = {};\n" + "/** @constructor */ n.T = function() { this.x = ''; };\n" + "/** @type {number} */ n.T.prototype.x = 0;", "assignment to property x of n.T\n" + "found : string\n" + "required: number"); } public void testPropertyUsedBeforeDefinition1() throws Exception { testTypes("/** @constructor */ var T = function() {};\n" + "/** @return {string} */" + "T.prototype.f = function() { return this.g(); };\n" + "/** @return {number} */ T.prototype.g = function() { return 1; };\n", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testPropertyUsedBeforeDefinition2() throws Exception { testTypes("var n = {};\n" + "/** @constructor */ n.T = function() {};\n" + "/** @return {string} */" + "n.T.prototype.f = function() { return this.g(); };\n" + "/** @return {number} */ n.T.prototype.g = function() { return 1; };\n", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testAdd1() throws Exception { testTypes("/**@return {void}*/function foo(){var a = 'abc'+foo();}"); } public void testAdd2() throws Exception { testTypes("/**@return {void}*/function foo(){var a = foo()+4;}"); } public void testAdd3() throws Exception { testTypes("/** @type {string} */ var a = 'a';" + "/** @type {string} */ var b = 'b';" + "/** @type {string} */ var c = a + b;"); } public void testAdd4() throws Exception { testTypes("/** @type {number} */ var a = 5;" + "/** @type {string} */ var b = 'b';" + "/** @type {string} */ var c = a + b;"); } public void testAdd5() throws Exception { testTypes("/** @type {string} */ var a = 'a';" + "/** @type {number} */ var b = 5;" + "/** @type {string} */ var c = a + b;"); } public void testAdd6() throws Exception { testTypes("/** @type {number} */ var a = 5;" + "/** @type {number} */ var b = 5;" + "/** @type {number} */ var c = a + b;"); } public void testAdd7() throws Exception { testTypes("/** @type {number} */ var a = 5;" + "/** @type {string} */ var b = 'b';" + "/** @type {number} */ var c = a + b;", "initializing variable\n" + "found : string\n" + "required: number"); } public void testAdd8() throws Exception { testTypes("/** @type {string} */ var a = 'a';" + "/** @type {number} */ var b = 5;" + "/** @type {number} */ var c = a + b;", "initializing variable\n" + "found : string\n" + "required: number"); } public void testAdd9() throws Exception { testTypes("/** @type {number} */ var a = 5;" + "/** @type {number} */ var b = 5;" + "/** @type {string} */ var c = a + b;", "initializing variable\n" + "found : number\n" + "required: string"); } public void testAdd10() throws Exception { // d.e.f will have unknown type. testTypes( suppressMissingProperty("e", "f") + "/** @type {number} */ var a = 5;" + "/** @type {string} */ var c = a + d.e.f;"); } public void testAdd11() throws Exception { // d.e.f will have unknown type. testTypes( suppressMissingProperty("e", "f") + "/** @type {number} */ var a = 5;" + "/** @type {number} */ var c = a + d.e.f;"); } public void testAdd12() throws Exception { testTypes("/** @return {(number,string)} */ function a() { return 5; }" + "/** @type {number} */ var b = 5;" + "/** @type {boolean} */ var c = a() + b;", "initializing variable\n" + "found : (number|string)\n" + "required: boolean"); } public void testAdd13() throws Exception { testTypes("/** @type {number} */ var a = 5;" + "/** @return {(number,string)} */ function b() { return 5; }" + "/** @type {boolean} */ var c = a + b();", "initializing variable\n" + "found : (number|string)\n" + "required: boolean"); } public void testAdd14() throws Exception { testTypes("/** @type {(null,string)} */ var a = null;" + "/** @type {number} */ var b = 5;" + "/** @type {boolean} */ var c = a + b;", "initializing variable\n" + "found : (number|string)\n" + "required: boolean"); } public void testAdd15() throws Exception { testTypes("/** @type {number} */ var a = 5;" + "/** @return {(number,string)} */ function b() { return 5; }" + "/** @type {boolean} */ var c = a + b();", "initializing variable\n" + "found : (number|string)\n" + "required: boolean"); } public void testAdd16() throws Exception { testTypes("/** @type {(undefined,string)} */ var a = undefined;" + "/** @type {number} */ var b = 5;" + "/** @type {boolean} */ var c = a + b;", "initializing variable\n" + "found : (number|string)\n" + "required: boolean"); } public void testAdd17() throws Exception { testTypes("/** @type {number} */ var a = 5;" + "/** @type {(undefined,string)} */ var b = undefined;" + "/** @type {boolean} */ var c = a + b;", "initializing variable\n" + "found : (number|string)\n" + "required: boolean"); } public void testAdd18() throws Exception { testTypes("function f() {};" + "/** @type {string} */ var a = 'a';" + "/** @type {number} */ var c = a + f();", "initializing variable\n" + "found : string\n" + "required: number"); } public void testAdd19() throws Exception { testTypes("/** @param {number} opt_x\n@param {number} opt_y\n" + "@return {number} */ function f(opt_x, opt_y) {" + "return opt_x + opt_y;}"); } public void testAdd20() throws Exception { testTypes("/** @param {!Number} opt_x\n@param {!Number} opt_y\n" + "@return {number} */ function f(opt_x, opt_y) {" + "return opt_x + opt_y;}"); } public void testAdd21() throws Exception { testTypes("/** @param {Number|Boolean} opt_x\n" + "@param {number|boolean} opt_y\n" + "@return {number} */ function f(opt_x, opt_y) {" + "return opt_x + opt_y;}"); } public void testNumericComparison1() throws Exception { testTypes("/**@param {number} a*/ function f(a) {return a < 3;}"); } public void testNumericComparison2() throws Exception { testTypes("/**@param {!Object} a*/ function f(a) {return a < 3;}", "left side of numeric comparison\n" + "found : Object\n" + "required: number"); } public void testNumericComparison3() throws Exception { testTypes("/**@param {string} a*/ function f(a) {return a < 3;}"); } public void testNumericComparison4() throws Exception { testTypes("/**@param {(number,undefined)} a*/ " + "function f(a) {return a < 3;}"); } public void testNumericComparison5() throws Exception { testTypes("/**@param {*} a*/ function f(a) {return a < 3;}", "left side of numeric comparison\n" + "found : *\n" + "required: number"); } public void testNumericComparison6() throws Exception { testTypes("/**@return {void} */ function foo() { if (3 >= foo()) return; }", "right side of numeric comparison\n" + "found : undefined\n" + "required: number"); } public void testStringComparison1() throws Exception { testTypes("/**@param {string} a*/ function f(a) {return a < 'x';}"); } public void testStringComparison2() throws Exception { testTypes("/**@param {Object} a*/ function f(a) {return a < 'x';}"); } public void testStringComparison3() throws Exception { testTypes("/**@param {number} a*/ function f(a) {return a < 'x';}"); } public void testStringComparison4() throws Exception { testTypes("/**@param {string|undefined} a*/ " + "function f(a) {return a < 'x';}"); } public void testStringComparison5() throws Exception { testTypes("/**@param {*} a*/ " + "function f(a) {return a < 'x';}"); } public void testStringComparison6() throws Exception { testTypes("/**@return {void} */ " + "function foo() { if ('a' >= foo()) return; }", "right side of comparison\n" + "found : undefined\n" + "required: string"); } public void testValueOfComparison1() throws Exception { testTypes("/** @constructor */function O() {};" + "/**@override*/O.prototype.valueOf = function() { return 1; };" + "/**@param {!O} a\n@param {!O} b*/ function f(a,b) { return a < b; }"); } public void testValueOfComparison2() throws Exception { testTypes("/** @constructor */function O() {};" + "/**@override*/O.prototype.valueOf = function() { return 1; };" + "/**@param {!O} a\n@param {number} b*/" + "function f(a,b) { return a < b; }"); } public void testValueOfComparison3() throws Exception { testTypes("/** @constructor */function O() {};" + "/**@override*/O.prototype.toString = function() { return 'o'; };" + "/**@param {!O} a\n@param {string} b*/" + "function f(a,b) { return a < b; }"); } public void testGenericRelationalExpression() throws Exception { testTypes("/**@param {*} a\n@param {*} b*/ " + "function f(a,b) {return a < b;}"); } public void testInstanceof1() throws Exception { testTypes("function foo(){" + "if (bar instanceof 3)return;}", "instanceof requires an object\n" + "found : number\n" + "required: Object"); } public void testInstanceof2() throws Exception { testTypes("/**@return {void}*/function foo(){" + "if (foo() instanceof Object)return;}", "deterministic instanceof yields false\n" + "found : undefined\n" + "required: NoObject"); } public void testInstanceof3() throws Exception { testTypes("/**@return {*} */function foo(){" + "if (foo() instanceof Object)return;}"); } public void testInstanceof4() throws Exception { testTypes("/**@return {(Object|number)} */function foo(){" + "if (foo() instanceof Object)return 3;}"); } public void testInstanceof5() throws Exception { // No warning for unknown types. testTypes("/** @return {?} */ function foo(){" + "if (foo() instanceof Object)return;}"); } public void testInstanceof6() throws Exception { testTypes("/**@return {(Array|number)} */function foo(){" + "if (foo() instanceof Object)return 3;}"); } public void testInstanceOfReduction3() throws Exception { testTypes( "/** \n" + " * @param {Object} x \n" + " * @param {Function} y \n" + " * @return {boolean} \n" + " */\n" + "var f = function(x, y) {\n" + " return x instanceof y;\n" + "};"); } public void testScoping1() throws Exception { testTypes( "/**@param {string} a*/function foo(a){" + " /**@param {Array|string} a*/function bar(a){" + " if (a instanceof Array)return;" + " }" + "}"); } public void testScoping2() throws Exception { testTypes( "/** @type number */ var a;" + "function Foo() {" + " /** @type string */ var a;" + "}"); } public void testScoping3() throws Exception { testTypes("\n\n/** @type{Number}*/var b;\n/** @type{!String} */var b;", "variable b redefined with type String, original " + "definition at [testcode]:3 with type (Number|null)"); } public void testScoping4() throws Exception { testTypes("/** @type{Number}*/var b; if (true) /** @type{!String} */var b;", "variable b redefined with type String, original " + "definition at [testcode]:1 with type (Number|null)"); } public void testScoping5() throws Exception { // multiple definitions are not checked by the type checker but by a // subsequent pass testTypes("if (true) var b; var b;"); } public void testScoping6() throws Exception { // multiple definitions are not checked by the type checker but by a // subsequent pass testTypes("if (true) var b; if (true) var b;"); } public void testScoping7() throws Exception { testTypes("/** @constructor */function A() {" + " /** @type !A */this.a = null;" + "}", "assignment to property a of A\n" + "found : null\n" + "required: A"); } public void testScoping8() throws Exception { testTypes("/** @constructor */function A() {}" + "/** @constructor */function B() {" + " /** @type !A */this.a = null;" + "}", "assignment to property a of B\n" + "found : null\n" + "required: A"); } public void testScoping9() throws Exception { testTypes("/** @constructor */function B() {" + " /** @type !A */this.a = null;" + "}" + "/** @constructor */function A() {}", "assignment to property a of B\n" + "found : null\n" + "required: A"); } public void testScoping10() throws Exception { TypeCheckResult p = parseAndTypeCheckWithScope("var a = function b(){};"); // a declared, b is not assertTrue(p.scope.isDeclared("a", false)); assertFalse(p.scope.isDeclared("b", false)); // checking that a has the correct assigned type assertEquals("function (): undefined", p.scope.getVar("a").getType().toString()); } public void testScoping11() throws Exception { // named function expressions create a binding in their body only // the return is wrong but the assignment is OK since the type of b is ? testTypes( "/** @return {number} */var a = function b(){ return b };", "inconsistent return type\n" + "found : function (): number\n" + "required: number"); } public void testScoping12() throws Exception { testTypes( "/** @constructor */ function F() {}" + "/** @type {number} */ F.prototype.bar = 3;" + "/** @param {!F} f */ function g(f) {" + " /** @return {string} */" + " function h() {" + " return f.bar;" + " }" + "}", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testFunctionArguments1() throws Exception { testFunctionType( "/** @param {number} a\n@return {string} */" + "function f(a) {}", "function (number): string"); } public void testFunctionArguments2() throws Exception { testFunctionType( "/** @param {number} opt_a\n@return {string} */" + "function f(opt_a) {}", "function (number=): string"); } public void testFunctionArguments3() throws Exception { testFunctionType( "/** @param {number} b\n@return {string} */" + "function f(a,b) {}", "function (?, number): string"); } public void testFunctionArguments4() throws Exception { testFunctionType( "/** @param {number} opt_a\n@return {string} */" + "function f(a,opt_a) {}", "function (?, number=): string"); } public void testFunctionArguments5() throws Exception { testTypes( "function a(opt_a,a) {}", "optional arguments must be at the end"); } public void testFunctionArguments6() throws Exception { testTypes( "function a(var_args,a) {}", "variable length argument must be last"); } public void testFunctionArguments7() throws Exception { testTypes( "/** @param {number} opt_a\n@return {string} */" + "function a(a,opt_a,var_args) {}"); } public void testFunctionArguments8() throws Exception { testTypes( "function a(a,opt_a,var_args,b) {}", "variable length argument must be last"); } public void testFunctionArguments9() throws Exception { // testing that only one error is reported testTypes( "function a(a,opt_a,var_args,b,c) {}", "variable length argument must be last"); } public void testFunctionArguments10() throws Exception { // testing that only one error is reported testTypes( "function a(a,opt_a,b,c) {}", "optional arguments must be at the end"); } public void testFunctionArguments11() throws Exception { testTypes( "function a(a,opt_a,b,c,var_args,d) {}", "optional arguments must be at the end"); } public void testFunctionArguments12() throws Exception { testTypes("/** @param foo {String} */function bar(baz){}", "parameter foo does not appear in bar's parameter list"); } public void testFunctionArguments13() throws Exception { // verifying that the argument type have non-inferable types testTypes( "/** @return {boolean} */ function u() { return true; }" + "/** @param {boolean} b\n@return {?boolean} */" + "function f(b) { if (u()) { b = null; } return b; }", "assignment\n" + "found : null\n" + "required: boolean"); } public void testFunctionArguments14() throws Exception { testTypes( "/**\n" + " * @param {string} x\n" + " * @param {number} opt_y\n" + " * @param {boolean} var_args\n" + " */ function f(x, opt_y, var_args) {}" + "f('3'); f('3', 2); f('3', 2, true); f('3', 2, true, false);"); } public void testFunctionArguments15() throws Exception { testTypes( "/** @param {?function(*)} f */" + "function g(f) { f(1, 2); }", "Function f: called with 2 argument(s). " + "Function requires at least 1 argument(s) " + "and no more than 1 argument(s)."); } public void testFunctionArguments16() throws Exception { testTypes( "/** @param {...number} var_args */" + "function g(var_args) {} g(1, true);", "actual parameter 2 of g does not match formal parameter\n" + "found : boolean\n" + "required: (number|undefined)"); } public void testFunctionArguments17() throws Exception { testClosureTypesMultipleWarnings( "/** @param {booool|string} x */" + "function f(x) { g(x) }" + "/** @param {number} x */" + "function g(x) {}", Lists.newArrayList( "Bad type annotation. Unknown type booool", "actual parameter 1 of g does not match formal parameter\n" + "found : (booool|null|string)\n" + "required: number")); } public void testPrintFunctionName1() throws Exception { // Ensures that the function name is pretty. testTypes( "var goog = {}; goog.run = function(f) {};" + "goog.run();", "Function goog.run: called with 0 argument(s). " + "Function requires at least 1 argument(s) " + "and no more than 1 argument(s)."); } public void testPrintFunctionName2() throws Exception { testTypes( "/** @constructor */ var Foo = function() {}; " + "Foo.prototype.run = function(f) {};" + "(new Foo).run();", "Function Foo.prototype.run: called with 0 argument(s). " + "Function requires at least 1 argument(s) " + "and no more than 1 argument(s)."); } public void testFunctionInference1() throws Exception { testFunctionType( "function f(a) {}", "function (?): undefined"); } public void testFunctionInference2() throws Exception { testFunctionType( "function f(a,b) {}", "function (?, ?): undefined"); } public void testFunctionInference3() throws Exception { testFunctionType( "function f(var_args) {}", "function (...[?]): undefined"); } public void testFunctionInference4() throws Exception { testFunctionType( "function f(a,b,c,var_args) {}", "function (?, ?, ?, ...[?]): undefined"); } public void testFunctionInference5() throws Exception { testFunctionType( "/** @this Date\n@return {string} */function f(a) {}", "function (this:Date, ?): string"); } public void testFunctionInference6() throws Exception { testFunctionType( "/** @this Date\n@return {string} */function f(opt_a) {}", "function (this:Date, ?=): string"); } public void testFunctionInference7() throws Exception { testFunctionType( "/** @this Date */function f(a,b,c,var_args) {}", "function (this:Date, ?, ?, ?, ...[?]): undefined"); } public void testFunctionInference8() throws Exception { testFunctionType( "function f() {}", "function (): undefined"); } public void testFunctionInference9() throws Exception { testFunctionType( "var f = function() {};", "function (): undefined"); } public void testFunctionInference10() throws Exception { testFunctionType( "/** @this Date\n@param {boolean} b\n@return {string} */" + "var f = function(a,b) {};", "function (this:Date, ?, boolean): string"); } public void testFunctionInference11() throws Exception { testFunctionType( "var goog = {};" + "/** @return {number}*/goog.f = function(){};", "goog.f", "function (): number"); } public void testFunctionInference12() throws Exception { testFunctionType( "var goog = {};" + "goog.f = function(){};", "goog.f", "function (): undefined"); } public void testFunctionInference13() throws Exception { testFunctionType( "var goog = {};" + "/** @constructor */ goog.Foo = function(){};" + "/** @param {!goog.Foo} f */function eatFoo(f){};", "eatFoo", "function (goog.Foo): undefined"); } public void testFunctionInference14() throws Exception { testFunctionType( "var goog = {};" + "/** @constructor */ goog.Foo = function(){};" + "/** @return {!goog.Foo} */function eatFoo(){ return new goog.Foo; };", "eatFoo", "function (): goog.Foo"); } public void testFunctionInference15() throws Exception { testFunctionType( "/** @constructor */ function f() {};" + "f.prototype.foo = function(){};", "f.prototype.foo", "function (this:f): undefined"); } public void testFunctionInference16() throws Exception { testFunctionType( "/** @constructor */ function f() {};" + "f.prototype.foo = function(){};", "(new f).foo", "function (this:f): undefined"); } public void testFunctionInference17() throws Exception { testFunctionType( "/** @constructor */ function f() {}" + "function abstractMethod() {}" + "/** @param {number} x */ f.prototype.foo = abstractMethod;", "(new f).foo", "function (this:f, number): ?"); } public void testFunctionInference18() throws Exception { testFunctionType( "var goog = {};" + "/** @this {Date} */ goog.eatWithDate;", "goog.eatWithDate", "function (this:Date): ?"); } public void testFunctionInference19() throws Exception { testFunctionType( "/** @param {string} x */ var f;", "f", "function (string): ?"); } public void testFunctionInference20() throws Exception { testFunctionType( "/** @this {Date} */ var f;", "f", "function (this:Date): ?"); } public void testFunctionInference21() throws Exception { testTypes( "var f = function() { throw 'x' };" + "/** @return {boolean} */ var g = f;"); testFunctionType( "var f = function() { throw 'x' };", "f", "function (): ?"); } public void testFunctionInference22() throws Exception { testTypes( "/** @type {!Function} */ var f = function() { g(this); };" + "/** @param {boolean} x */ var g = function(x) {};"); } public void testFunctionInference23() throws Exception { // We want to make sure that 'prop' isn't declared on all objects. testTypes( "/** @type {!Function} */ var f = function() {\n" + " /** @type {number} */ this.prop = 3;\n" + "};" + "/**\n" + " * @param {Object} x\n" + " * @return {string}\n" + " */ var g = function(x) { return x.prop; };"); } public void testInnerFunction1() throws Exception { testTypes( "function f() {" + " /** @type {number} */ var x = 3;\n" + " function g() { x = null; }" + " return x;" + "}", "assignment\n" + "found : null\n" + "required: number"); } public void testInnerFunction2() throws Exception { testTypes( "/** @return {number} */\n" + "function f() {" + " var x = null;\n" + " function g() { x = 3; }" + " g();" + " return x;" + "}", "inconsistent return type\n" + "found : (null|number)\n" + "required: number"); } public void testInnerFunction3() throws Exception { testTypes( "var x = null;" + "/** @return {number} */\n" + "function f() {" + " x = 3;\n" + " /** @return {number} */\n" + " function g() { x = true; return x; }" + " return x;" + "}", "inconsistent return type\n" + "found : boolean\n" + "required: number"); } public void testInnerFunction4() throws Exception { testTypes( "var x = null;" + "/** @return {number} */\n" + "function f() {" + " x = '3';\n" + " /** @return {number} */\n" + " function g() { x = 3; return x; }" + " return x;" + "}", "inconsistent return type\n" + "found : string\n" + "required: number"); } public void testInnerFunction5() throws Exception { testTypes( "/** @return {number} */\n" + "function f() {" + " var x = 3;\n" + " /** @return {number} */" + " function g() { var x = 3;x = true; return x; }" + " return x;" + "}", "inconsistent return type\n" + "found : boolean\n" + "required: number"); } public void testInnerFunction6() throws Exception { testClosureTypes( CLOSURE_DEFS + "function f() {" + " var x = 0 || function() {};\n" + " function g() { if (goog.isFunction(x)) { x(1); } }" + " g();" + "}", "Function x: called with 1 argument(s). " + "Function requires at least 0 argument(s) " + "and no more than 0 argument(s)."); } public void testInnerFunction7() throws Exception { testClosureTypes( CLOSURE_DEFS + "function f() {" + " /** @type {number|function()} */" + " var x = 0 || function() {};\n" + " function g() { if (goog.isFunction(x)) { x(1); } }" + " g();" + "}", "Function x: called with 1 argument(s). " + "Function requires at least 0 argument(s) " + "and no more than 0 argument(s)."); } public void testInnerFunction8() throws Exception { testClosureTypes( CLOSURE_DEFS + "function f() {" + " function x() {};\n" + " function g() { if (goog.isFunction(x)) { x(1); } }" + " g();" + "}", "Function x: called with 1 argument(s). " + "Function requires at least 0 argument(s) " + "and no more than 0 argument(s)."); } public void testInnerFunction9() throws Exception { testTypes( "function f() {" + " var x = 3;\n" + " function g() { x = null; };\n" + " function h() { return x == null; }" + " return h();" + "}"); } public void testInnerFunction10() throws Exception { testTypes( "function f() {" + " /** @type {?number} */ var x = null;" + " /** @return {string} */" + " function g() {" + " if (!x) {" + " x = 1;" + " }" + " return x;" + " }" + "}", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testInnerFunction11() throws Exception { // TODO(nicksantos): This is actually bad inference, because // h sets x to null. We should fix this, but for now we do it // this way so that we don't break existing binaries. We will // need to change TypeInference#isUnflowable to fix this. testTypes( "function f() {" + " /** @type {?number} */ var x = null;" + " /** @return {number} */" + " function g() {" + " x = 1;" + " h();" + " return x;" + " }" + " function h() {" + " x = null;" + " }" + "}"); } public void testAbstractMethodHandling1() throws Exception { testTypes( "/** @type {Function} */ var abstractFn = function() {};" + "abstractFn(1);"); } public void testAbstractMethodHandling2() throws Exception { testTypes( "var abstractFn = function() {};" + "abstractFn(1);", "Function abstractFn: called with 1 argument(s). " + "Function requires at least 0 argument(s) " + "and no more than 0 argument(s)."); } public void testAbstractMethodHandling3() throws Exception { testTypes( "var goog = {};" + "/** @type {Function} */ goog.abstractFn = function() {};" + "goog.abstractFn(1);"); } public void testAbstractMethodHandling4() throws Exception { testTypes( "var goog = {};" + "goog.abstractFn = function() {};" + "goog.abstractFn(1);", "Function goog.abstractFn: called with 1 argument(s). " + "Function requires at least 0 argument(s) " + "and no more than 0 argument(s)."); } public void testAbstractMethodHandling5() throws Exception { testTypes( "/** @type {!Function} */ var abstractFn = function() {};" + "/** @param {number} x */ var f = abstractFn;" + "f('x');", "actual parameter 1 of f does not match formal parameter\n" + "found : string\n" + "required: number"); } public void testAbstractMethodHandling6() throws Exception { testTypes( "var goog = {};" + "/** @type {Function} */ goog.abstractFn = function() {};" + "/** @param {number} x */ goog.f = abstractFn;" + "goog.f('x');", "actual parameter 1 of goog.f does not match formal parameter\n" + "found : string\n" + "required: number"); } public void testMethodInference1() throws Exception { testTypes( "/** @constructor */ function F() {}" + "/** @return {number} */ F.prototype.foo = function() { return 3; };" + "/** @constructor \n * @extends {F} */ " + "function G() {}" + "/** @override */ G.prototype.foo = function() { return true; };", "inconsistent return type\n" + "found : boolean\n" + "required: number"); } public void testMethodInference2() throws Exception { testTypes( "var goog = {};" + "/** @constructor */ goog.F = function() {};" + "/** @return {number} */ goog.F.prototype.foo = " + " function() { return 3; };" + "/** @constructor \n * @extends {goog.F} */ " + "goog.G = function() {};" + "/** @override */ goog.G.prototype.foo = function() { return true; };", "inconsistent return type\n" + "found : boolean\n" + "required: number"); } public void testMethodInference3() throws Exception { testTypes( "/** @constructor */ function F() {}" + "/** @param {boolean} x \n * @return {number} */ " + "F.prototype.foo = function(x) { return 3; };" + "/** @constructor \n * @extends {F} */ " + "function G() {}" + "/** @override */ " + "G.prototype.foo = function(x) { return x; };", "inconsistent return type\n" + "found : boolean\n" + "required: number"); } public void testMethodInference4() throws Exception { testTypes( "/** @constructor */ function F() {}" + "/** @param {boolean} x \n * @return {number} */ " + "F.prototype.foo = function(x) { return 3; };" + "/** @constructor \n * @extends {F} */ " + "function G() {}" + "/** @override */ " + "G.prototype.foo = function(y) { return y; };", "inconsistent return type\n" + "found : boolean\n" + "required: number"); } public void testMethodInference5() throws Exception { testTypes( "/** @constructor */ function F() {}" + "/** @param {number} x \n * @return {string} */ " + "F.prototype.foo = function(x) { return 'x'; };" + "/** @constructor \n * @extends {F} */ " + "function G() {}" + "/** @type {number} */ G.prototype.num = 3;" + "/** @override */ " + "G.prototype.foo = function(y) { return this.num + y; };", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testMethodInference6() throws Exception { testTypes( "/** @constructor */ function F() {}" + "/** @param {number} x */ F.prototype.foo = function(x) { };" + "/** @constructor \n * @extends {F} */ " + "function G() {}" + "/** @override */ G.prototype.foo = function() { };" + "(new G()).foo(1);"); } public void testMethodInference7() throws Exception { testTypes( "/** @constructor */ function F() {}" + "F.prototype.foo = function() { };" + "/** @constructor \n * @extends {F} */ " + "function G() {}" + "/** @override */ G.prototype.foo = function(x, y) { };", "mismatch of the foo property type and the type of the property " + "it overrides from superclass F\n" + "original: function (this:F): undefined\n" + "override: function (this:G, ?, ?): undefined"); } public void testMethodInference8() throws Exception { testTypes( "/** @constructor */ function F() {}" + "F.prototype.foo = function() { };" + "/** @constructor \n * @extends {F} */ " + "function G() {}" + "/** @override */ " + "G.prototype.foo = function(opt_b, var_args) { };" + "(new G()).foo(1, 2, 3);"); } public void testMethodInference9() throws Exception { testTypes( "/** @constructor */ function F() {}" + "F.prototype.foo = function() { };" + "/** @constructor \n * @extends {F} */ " + "function G() {}" + "/** @override */ " + "G.prototype.foo = function(var_args, opt_b) { };", "variable length argument must be last"); } public void testStaticMethodDeclaration1() throws Exception { testTypes( "/** @constructor */ function F() { F.foo(true); }" + "/** @param {number} x */ F.foo = function(x) {};", "actual parameter 1 of F.foo does not match formal parameter\n" + "found : boolean\n" + "required: number"); } public void testStaticMethodDeclaration2() throws Exception { testTypes( "var goog = goog || {}; function f() { goog.foo(true); }" + "/** @param {number} x */ goog.foo = function(x) {};", "actual parameter 1 of goog.foo does not match formal parameter\n" + "found : boolean\n" + "required: number"); } public void testStaticMethodDeclaration3() throws Exception { testTypes( "var goog = goog || {}; function f() { goog.foo(true); }" + "goog.foo = function() {};", "Function goog.foo: called with 1 argument(s). Function requires " + "at least 0 argument(s) and no more than 0 argument(s)."); } public void testDuplicateStaticMethodDecl1() throws Exception { testTypes( "var goog = goog || {};" + "/** @param {number} x */ goog.foo = function(x) {};" + "/** @param {number} x */ goog.foo = function(x) {};", "variable goog.foo redefined with type function (number): undefined, " + "original definition at [testcode]:1 " + "with type function (number): undefined"); } public void testDuplicateStaticMethodDecl2() throws Exception { testTypes( "var goog = goog || {};" + "/** @param {number} x */ goog.foo = function(x) {};" + "/** @param {number} x \n * @suppress {duplicate} */ " + "goog.foo = function(x) {};"); } public void testDuplicateStaticMethodDecl3() throws Exception { testTypes( "var goog = goog || {};" + "goog.foo = function(x) {};" + "goog.foo = function(x) {};"); } public void testDuplicateStaticMethodDecl4() throws Exception { testTypes( "var goog = goog || {};" + "/** @type {Function} */ goog.foo = function(x) {};" + "goog.foo = function(x) {};"); } public void testDuplicateStaticMethodDecl5() throws Exception { testTypes( "var goog = goog || {};" + "goog.foo = function(x) {};" + "/** @return {undefined} */ goog.foo = function(x) {};", "variable goog.foo redefined with type function (?): undefined, " + "original definition at [testcode]:1 with type " + "function (?): undefined"); } public void testDuplicateStaticPropertyDecl1() throws Exception { testTypes( "var goog = goog || {};" + "/** @type {Foo} */ goog.foo;" + "/** @type {Foo} */ goog.foo;" + "/** @constructor */ function Foo() {}"); } public void testDuplicateStaticPropertyDecl2() throws Exception { testTypes( "var goog = goog || {};" + "/** @type {Foo} */ goog.foo;" + "/** @type {Foo} \n * @suppress {duplicate} */ goog.foo;" + "/** @constructor */ function Foo() {}"); } public void testDuplicateStaticPropertyDecl3() throws Exception { testTypes( "var goog = goog || {};" + "/** @type {!Foo} */ goog.foo;" + "/** @type {string} */ goog.foo;" + "/** @constructor */ function Foo() {}", "variable goog.foo redefined with type string, " + "original definition at [testcode]:1 with type Foo"); } public void testDuplicateStaticPropertyDecl4() throws Exception { testClosureTypesMultipleWarnings( "var goog = goog || {};" + "/** @type {!Foo} */ goog.foo;" + "/** @type {string} */ goog.foo = 'x';" + "/** @constructor */ function Foo() {}", Lists.newArrayList( "assignment to property foo of goog\n" + "found : string\n" + "required: Foo", "variable goog.foo redefined with type string, " + "original definition at [testcode]:1 with type Foo")); } public void testDuplicateStaticPropertyDecl5() throws Exception { testClosureTypesMultipleWarnings( "var goog = goog || {};" + "/** @type {!Foo} */ goog.foo;" + "/** @type {string}\n * @suppress {duplicate} */ goog.foo = 'x';" + "/** @constructor */ function Foo() {}", Lists.newArrayList( "assignment to property foo of goog\n" + "found : string\n" + "required: Foo", "variable goog.foo redefined with type string, " + "original definition at [testcode]:1 with type Foo")); } public void testDuplicateStaticPropertyDecl6() throws Exception { testTypes( "var goog = goog || {};" + "/** @type {string} */ goog.foo = 'y';" + "/** @type {string}\n * @suppress {duplicate} */ goog.foo = 'x';"); } public void testDuplicateStaticPropertyDecl7() throws Exception { testTypes( "var goog = goog || {};" + "/** @param {string} x */ goog.foo;" + "/** @type {function(string)} */ goog.foo;"); } public void testDuplicateStaticPropertyDecl8() throws Exception { testTypes( "var goog = goog || {};" + "/** @return {EventCopy} */ goog.foo;" + "/** @constructor */ function EventCopy() {}" + "/** @return {EventCopy} */ goog.foo;"); } public void testDuplicateStaticPropertyDecl9() throws Exception { testTypes( "var goog = goog || {};" + "/** @return {EventCopy} */ goog.foo;" + "/** @return {EventCopy} */ goog.foo;" + "/** @constructor */ function EventCopy() {}"); } public void testDuplicateStaticPropertyDec20() throws Exception { testTypes( "/**\n" + " * @fileoverview\n" + " * @suppress {duplicate}\n" + " */" + "var goog = goog || {};" + "/** @type {string} */ goog.foo = 'y';" + "/** @type {string} */ goog.foo = 'x';"); } public void testDuplicateLocalVarDecl() throws Exception { testClosureTypesMultipleWarnings( "/** @param {number} x */\n" + "function f(x) { /** @type {string} */ var x = ''; }", Lists.newArrayList( "variable x redefined with type string, original definition" + " at [testcode]:2 with type number", "initializing variable\n" + "found : string\n" + "required: number")); } public void testDuplicateInstanceMethod1() throws Exception { // If there's no jsdoc on the methods, then we treat them like // any other inferred properties. testTypes( "/** @constructor */ function F() {}" + "F.prototype.bar = function() {};" + "F.prototype.bar = function() {};"); } public void testDuplicateInstanceMethod2() throws Exception { testTypes( "/** @constructor */ function F() {}" + "/** jsdoc */ F.prototype.bar = function() {};" + "/** jsdoc */ F.prototype.bar = function() {};", "variable F.prototype.bar redefined with type " + "function (this:F): undefined, original definition at " + "[testcode]:1 with type function (this:F): undefined"); } public void testDuplicateInstanceMethod3() throws Exception { testTypes( "/** @constructor */ function F() {}" + "F.prototype.bar = function() {};" + "/** jsdoc */ F.prototype.bar = function() {};", "variable F.prototype.bar redefined with type " + "function (this:F): undefined, original definition at " + "[testcode]:1 with type function (this:F): undefined"); } public void testDuplicateInstanceMethod4() throws Exception { testTypes( "/** @constructor */ function F() {}" + "/** jsdoc */ F.prototype.bar = function() {};" + "F.prototype.bar = function() {};"); } public void testDuplicateInstanceMethod5() throws Exception { testTypes( "/** @constructor */ function F() {}" + "/** jsdoc \n * @return {number} */ F.prototype.bar = function() {" + " return 3;" + "};" + "/** jsdoc \n * @suppress {duplicate} */ " + "F.prototype.bar = function() { return ''; };", "inconsistent return type\n" + "found : string\n" + "required: number"); } public void testDuplicateInstanceMethod6() throws Exception { testTypes( "/** @constructor */ function F() {}" + "/** jsdoc \n * @return {number} */ F.prototype.bar = function() {" + " return 3;" + "};" + "/** jsdoc \n * @return {string} * \n @suppress {duplicate} */ " + "F.prototype.bar = function() { return ''; };", "assignment to property bar of F.prototype\n" + "found : function (this:F): string\n" + "required: function (this:F): number"); } public void testStubFunctionDeclaration1() throws Exception { testFunctionType( "/** @constructor */ function f() {};" + "/** @param {number} x \n * @param {string} y \n" + " * @return {number} */ f.prototype.foo;", "(new f).foo", "function (this:f, number, string): number"); } public void testStubFunctionDeclaration2() throws Exception { testExternFunctionType( // externs "/** @constructor */ function f() {};" + "/** @constructor \n * @extends {f} */ f.subclass;", "f.subclass", "function (new:f.subclass): ?"); } public void testStubFunctionDeclaration3() throws Exception { testFunctionType( "/** @constructor */ function f() {};" + "/** @return {undefined} */ f.foo;", "f.foo", "function (): undefined"); } public void testStubFunctionDeclaration4() throws Exception { testFunctionType( "/** @constructor */ function f() { " + " /** @return {number} */ this.foo;" + "}", "(new f).foo", "function (this:f): number"); } public void testStubFunctionDeclaration5() throws Exception { testFunctionType( "/** @constructor */ function f() { " + " /** @type {Function} */ this.foo;" + "}", "(new f).foo", createNullableType(U2U_CONSTRUCTOR_TYPE).toString()); } public void testStubFunctionDeclaration6() throws Exception { testFunctionType( "/** @constructor */ function f() {} " + "/** @type {Function} */ f.prototype.foo;", "(new f).foo", createNullableType(U2U_CONSTRUCTOR_TYPE).toString()); } public void testStubFunctionDeclaration7() throws Exception { testFunctionType( "/** @constructor */ function f() {} " + "/** @type {Function} */ f.prototype.foo = function() {};", "(new f).foo", createNullableType(U2U_CONSTRUCTOR_TYPE).toString()); } public void testStubFunctionDeclaration8() throws Exception { testFunctionType( "/** @type {Function} */ var f = function() {}; ", "f", createNullableType(U2U_CONSTRUCTOR_TYPE).toString()); } public void testStubFunctionDeclaration9() throws Exception { testFunctionType( "/** @type {function():number} */ var f; ", "f", "function (): number"); } public void testStubFunctionDeclaration10() throws Exception { testFunctionType( "/** @type {function(number):number} */ var f = function(x) {};", "f", "function (number): number"); } public void testNestedFunctionInference1() throws Exception { String nestedAssignOfFooAndBar = "/** @constructor */ function f() {};" + "f.prototype.foo = f.prototype.bar = function(){};"; testFunctionType(nestedAssignOfFooAndBar, "(new f).bar", "function (this:f): undefined"); } /** * Tests the type of a function definition. The function defined by * {@code functionDef} should be named {@code "f"}. */ private void testFunctionType(String functionDef, String functionType) throws Exception { testFunctionType(functionDef, "f", functionType); } /** * Tests the type of a function definition. The function defined by * {@code functionDef} should be named {@code functionName}. */ private void testFunctionType(String functionDef, String functionName, String functionType) throws Exception { // using the variable initialization check to verify the function's type testTypes( functionDef + "/** @type number */var a=" + functionName + ";", "initializing variable\n" + "found : " + functionType + "\n" + "required: number"); } /** * Tests the type of a function definition in externs. * The function defined by {@code functionDef} should be * named {@code functionName}. */ private void testExternFunctionType(String functionDef, String functionName, String functionType) throws Exception { testTypes( functionDef, "/** @type number */var a=" + functionName + ";", "initializing variable\n" + "found : " + functionType + "\n" + "required: number", false); } public void testTypeRedefinition() throws Exception { testClosureTypesMultipleWarnings("a={};/**@enum {string}*/ a.A = {ZOR:'b'};" + "/** @constructor */ a.A = function() {}", Lists.newArrayList( "variable a.A redefined with type function (new:a.A): undefined, " + "original definition at [testcode]:1 with type enum{a.A}", "assignment to property A of a\n" + "found : function (new:a.A): undefined\n" + "required: enum{a.A}")); } public void testIn1() throws Exception { testTypes("'foo' in Object"); } public void testIn2() throws Exception { testTypes("3 in Object"); } public void testIn3() throws Exception { testTypes("undefined in Object"); } public void testIn4() throws Exception { testTypes("Date in Object", "left side of 'in'\n" + "found : function (new:Date, ?=, ?=, ?=, ?=, ?=, ?=, ?=): string\n" + "required: string"); } public void testIn5() throws Exception { testTypes("'x' in null", "'in' requires an object\n" + "found : null\n" + "required: Object"); } public void testIn6() throws Exception { testTypes( "/** @param {number} x */" + "function g(x) {}" + "g(1 in {});", "actual parameter 1 of g does not match formal parameter\n" + "found : boolean\n" + "required: number"); } public void testIn7() throws Exception { // Make sure we do inference in the 'in' expression. testTypes( "/**\n" + " * @param {number} x\n" + " * @return {number}\n" + " */\n" + "function g(x) { return 5; }" + "function f() {" + " var x = {};" + " x.foo = '3';" + " return g(x.foo) in {};" + "}", "actual parameter 1 of g does not match formal parameter\n" + "found : string\n" + "required: number"); } public void testForIn1() throws Exception { testTypes( "/** @param {boolean} x */ function f(x) {}" + "for (var k in {}) {" + " f(k);" + "}", "actual parameter 1 of f does not match formal parameter\n" + "found : string\n" + "required: boolean"); } public void testForIn2() throws Exception { testTypes( "/** @param {boolean} x */ function f(x) {}" + "/** @enum {string} */ var E = {FOO: 'bar'};" + "/** @type {Object.<E, string>} */ var obj = {};" + "var k = null;" + "for (k in obj) {" + " f(k);" + "}", "actual parameter 1 of f does not match formal parameter\n" + "found : E.<string>\n" + "required: boolean"); } public void testForIn3() throws Exception { testTypes( "/** @param {boolean} x */ function f(x) {}" + "/** @type {Object.<number>} */ var obj = {};" + "for (var k in obj) {" + " f(obj[k]);" + "}", "actual parameter 1 of f does not match formal parameter\n" + "found : number\n" + "required: boolean"); } public void testForIn4() throws Exception { testTypes( "/** @param {boolean} x */ function f(x) {}" + "/** @enum {string} */ var E = {FOO: 'bar'};" + "/** @type {Object.<E, Array>} */ var obj = {};" + "for (var k in obj) {" + " f(obj[k]);" + "}", "actual parameter 1 of f does not match formal parameter\n" + "found : (Array|null)\n" + "required: boolean"); } public void testForIn5() throws Exception { testTypes( "/** @param {boolean} x */ function f(x) {}" + "/** @constructor */ var E = function(){};" + "/** @type {Object.<E, number>} */ var obj = {};" + "for (var k in obj) {" + " f(k);" + "}", "actual parameter 1 of f does not match formal parameter\n" + "found : string\n" + "required: boolean"); } // TODO(nicksantos): change this to something that makes sense. // public void testComparison1() throws Exception { // testTypes("/**@type null */var a;" + // "/**@type !Date */var b;" + // "if (a==b) {}", // "condition always evaluates to false\n" + // "left : null\n" + // "right: Date"); // } public void testComparison2() throws Exception { testTypes("/**@type number*/var a;" + "/**@type !Date */var b;" + "if (a!==b) {}", "condition always evaluates to true\n" + "left : number\n" + "right: Date"); } public void testComparison3() throws Exception { // Since null == undefined in JavaScript, this code is reasonable. testTypes("/** @type {(Object,undefined)} */var a;" + "var b = a == null"); } public void testComparison4() throws Exception { testTypes("/** @type {(!Object,undefined)} */var a;" + "/** @type {!Object} */var b;" + "var c = a == b"); } public void testComparison5() throws Exception { testTypes("/** @type null */var a;" + "/** @type null */var b;" + "a == b", "condition always evaluates to true\n" + "left : null\n" + "right: null"); } public void testComparison6() throws Exception { testTypes("/** @type null */var a;" + "/** @type null */var b;" + "a != b", "condition always evaluates to false\n" + "left : null\n" + "right: null"); } public void testComparison7() throws Exception { testTypes("var a;" + "var b;" + "a == b", "condition always evaluates to true\n" + "left : undefined\n" + "right: undefined"); } public void testComparison8() throws Exception { testTypes("/** @type {Array.<string>} */ var a = [];" + "a[0] == null || a[1] == undefined"); } public void testComparison9() throws Exception { testTypes("/** @type {Array.<undefined>} */ var a = [];" + "a[0] == null", "condition always evaluates to true\n" + "left : undefined\n" + "right: null"); } public void testComparison10() throws Exception { testTypes("/** @type {Array.<undefined>} */ var a = [];" + "a[0] === null"); } public void testComparison11() throws Exception { testTypes( "(function(){}) == 'x'", "condition always evaluates to false\n" + "left : function (): undefined\n" + "right: string"); } public void testComparison12() throws Exception { testTypes( "(function(){}) == 3", "condition always evaluates to false\n" + "left : function (): undefined\n" + "right: number"); } public void testComparison13() throws Exception { testTypes( "(function(){}) == false", "condition always evaluates to false\n" + "left : function (): undefined\n" + "right: boolean"); } public void testComparison14() throws Exception { testTypes("/** @type {function((Array|string), Object): number} */" + "function f(x, y) { return x === y; }", "inconsistent return type\n" + "found : boolean\n" + "required: number"); } public void testComparison15() throws Exception { testClosureTypes( CLOSURE_DEFS + "/** @constructor */ function F() {}" + "/**\n" + " * @param {number} x\n" + " * @constructor\n" + " * @extends {F}\n" + " */\n" + "function G(x) {}\n" + "goog.inherits(G, F);\n" + "/**\n" + " * @param {number} x\n" + " * @constructor\n" + " * @extends {G}\n" + " */\n" + "function H(x) {}\n" + "goog.inherits(H, G);\n" + "/** @param {G} x */" + "function f(x) { return x.constructor === H; }", null); } public void testDeleteOperator1() throws Exception { testTypes( "var x = {};" + "/** @return {string} */ function f() { return delete x['a']; }", "inconsistent return type\n" + "found : boolean\n" + "required: string"); } public void testDeleteOperator2() throws Exception { testTypes( "var obj = {};" + "/** \n" + " * @param {string} x\n" + " * @return {Object} */ function f(x) { return obj; }" + "/** @param {?number} x */ function g(x) {" + " if (x) { delete f(x)['a']; }" + "}", "actual parameter 1 of f does not match formal parameter\n" + "found : number\n" + "required: string"); } public void testEnumStaticMethod1() throws Exception { testTypes( "/** @enum */ var Foo = {AAA: 1};" + "/** @param {number} x */ Foo.method = function(x) {};" + "Foo.method(true);", "actual parameter 1 of Foo.method does not match formal parameter\n" + "found : boolean\n" + "required: number"); } public void testEnumStaticMethod2() throws Exception { testTypes( "/** @enum */ var Foo = {AAA: 1};" + "/** @param {number} x */ Foo.method = function(x) {};" + "function f() { Foo.method(true); }", "actual parameter 1 of Foo.method does not match formal parameter\n" + "found : boolean\n" + "required: number"); } public void testEnum1() throws Exception { testTypes("/**@enum*/var a={BB:1,CC:2};\n" + "/**@type {a}*/var d;d=a.BB;"); } public void testEnum2() throws Exception { testTypes("/**@enum*/var a={b:1}", "enum key b must be a syntactic constant"); } public void testEnum3() throws Exception { testTypes("/**@enum*/var a={BB:1,BB:2}", "variable a.BB redefined with type a.<number>, " + "original definition at [testcode]:1 with type a.<number>"); } public void testEnum4() throws Exception { testTypes("/**@enum*/var a={BB:'string'}", "assignment to property BB of enum{a}\n" + "found : string\n" + "required: number"); } public void testEnum5() throws Exception { testTypes("/**@enum {String}*/var a={BB:'string'}", "assignment to property BB of enum{a}\n" + "found : string\n" + "required: (String|null)"); } public void testEnum6() throws Exception { testTypes("/**@enum*/var a={BB:1,CC:2};\n/**@type {!Array}*/var d;d=a.BB;", "assignment\n" + "found : a.<number>\n" + "required: Array"); } public void testEnum7() throws Exception { testTypes("/** @enum */var a={AA:1,BB:2,CC:3};" + "/** @type a */var b=a.D;", "element D does not exist on this enum"); } public void testEnum8() throws Exception { testClosureTypesMultipleWarnings("/** @enum */var a=8;", Lists.newArrayList( "enum initializer must be an object literal or an enum", "initializing variable\n" + "found : number\n" + "required: enum{a}")); } public void testEnum9() throws Exception { testClosureTypesMultipleWarnings( "var goog = {};" + "/** @enum */goog.a=8;", Lists.newArrayList( "assignment to property a of goog\n" + "found : number\n" + "required: enum{goog.a}", "enum initializer must be an object literal or an enum")); } public void testEnum10() throws Exception { testTypes( "/** @enum {number} */" + "goog.K = { A : 3 };"); } public void testEnum11() throws Exception { testTypes( "/** @enum {number} */" + "goog.K = { 502 : 3 };"); } public void testEnum12() throws Exception { testTypes( "/** @enum {number} */ var a = {};" + "/** @enum */ var b = a;"); } public void testEnum13() throws Exception { testTypes( "/** @enum {number} */ var a = {};" + "/** @enum {string} */ var b = a;", "incompatible enum element types\n" + "found : number\n" + "required: string"); } public void testEnum14() throws Exception { testTypes( "/** @enum {number} */ var a = {FOO:5};" + "/** @enum */ var b = a;" + "var c = b.FOO;"); } public void testEnum15() throws Exception { testTypes( "/** @enum {number} */ var a = {FOO:5};" + "/** @enum */ var b = a;" + "var c = b.BAR;", "element BAR does not exist on this enum"); } public void testEnum16() throws Exception { testTypes("var goog = {};" + "/**@enum*/goog .a={BB:1,BB:2}", "variable goog.a.BB redefined with type goog.a.<number>, " + "original definition at [testcode]:1 with type goog.a.<number>"); } public void testEnum17() throws Exception { testTypes("var goog = {};" + "/**@enum*/goog.a={BB:'string'}", "assignment to property BB of enum{goog.a}\n" + "found : string\n" + "required: number"); } public void testEnum18() throws Exception { testTypes("/**@enum*/ var E = {A: 1, B: 2};" + "/** @param {!E} x\n@return {number} */\n" + "var f = function(x) { return x; };"); } public void testEnum19() throws Exception { testTypes("/**@enum*/ var E = {A: 1, B: 2};" + "/** @param {number} x\n@return {!E} */\n" + "var f = function(x) { return x; };", "inconsistent return type\n" + "found : number\n" + "required: E.<number>"); } public void testEnum20() throws Exception { testTypes("/**@enum*/ var E = {A: 1, B: 2}; var x = []; x[E.A] = 0;"); } public void testEnum21() throws Exception { Node n = parseAndTypeCheck( "/** @enum {string} */ var E = {A : 'a', B : 'b'};\n" + "/** @param {!E} x\n@return {!E} */ function f(x) { return x; }"); Node nodeX = n.getLastChild().getLastChild().getLastChild().getLastChild(); JSType typeE = nodeX.getJSType(); assertFalse(typeE.isObject()); assertFalse(typeE.isNullable()); } public void testEnum22() throws Exception { testTypes("/**@enum*/ var E = {A: 1, B: 2};" + "/** @param {E} x \n* @return {number} */ function f(x) {return x}"); } public void testEnum23() throws Exception { testTypes("/**@enum*/ var E = {A: 1, B: 2};" + "/** @param {E} x \n* @return {string} */ function f(x) {return x}", "inconsistent return type\n" + "found : E.<number>\n" + "required: string"); } public void testEnum24() throws Exception { testTypes("/**@enum {Object} */ var E = {A: {}};" + "/** @param {E} x \n* @return {!Object} */ function f(x) {return x}", "inconsistent return type\n" + "found : E.<(Object|null)>\n" + "required: Object"); } public void testEnum25() throws Exception { testTypes("/**@enum {!Object} */ var E = {A: {}};" + "/** @param {E} x \n* @return {!Object} */ function f(x) {return x}"); } public void testEnum26() throws Exception { testTypes("var a = {}; /**@enum*/ a.B = {A: 1, B: 2};" + "/** @param {a.B} x \n* @return {number} */ function f(x) {return x}"); } public void testEnum27() throws Exception { // x is unknown testTypes("/** @enum */ var A = {B: 1, C: 2}; " + "function f(x) { return A == x; }"); } public void testEnum28() throws Exception { // x is unknown testTypes("/** @enum */ var A = {B: 1, C: 2}; " + "function f(x) { return A.B == x; }"); } public void testEnum29() throws Exception { testTypes("/** @enum */ var A = {B: 1, C: 2}; " + "/** @return {number} */ function f() { return A; }", "inconsistent return type\n" + "found : enum{A}\n" + "required: number"); } public void testEnum30() throws Exception { testTypes("/** @enum */ var A = {B: 1, C: 2}; " + "/** @return {number} */ function f() { return A.B; }"); } public void testEnum31() throws Exception { testTypes("/** @enum */ var A = {B: 1, C: 2}; " + "/** @return {A} */ function f() { return A; }", "inconsistent return type\n" + "found : enum{A}\n" + "required: A.<number>"); } public void testEnum32() throws Exception { testTypes("/** @enum */ var A = {B: 1, C: 2}; " + "/** @return {A} */ function f() { return A.B; }"); } public void testEnum34() throws Exception { testTypes("/** @enum */ var A = {B: 1, C: 2}; " + "/** @param {number} x */ function f(x) { return x == A.B; }"); } public void testEnum35() throws Exception { testTypes("var a = a || {}; /** @enum */ a.b = {C: 1, D: 2};" + "/** @return {a.b} */ function f() { return a.b.C; }"); } public void testEnum36() throws Exception { testTypes("var a = a || {}; /** @enum */ a.b = {C: 1, D: 2};" + "/** @return {!a.b} */ function f() { return 1; }", "inconsistent return type\n" + "found : number\n" + "required: a.b.<number>"); } public void testEnum37() throws Exception { testTypes( "var goog = goog || {};" + "/** @enum {number} */ goog.a = {};" + "/** @enum */ var b = goog.a;"); } public void testEnum38() throws Exception { testTypes( "/** @enum {MyEnum} */ var MyEnum = {};" + "/** @param {MyEnum} x */ function f(x) {}", "Parse error. Cycle detected in inheritance chain " + "of type MyEnum"); } public void testEnum39() throws Exception { testTypes( "/** @enum {Number} */ var MyEnum = {FOO: new Number(1)};" + "/** @param {MyEnum} x \n * @return {number} */" + "function f(x) { return x == MyEnum.FOO && MyEnum.FOO == x; }", "inconsistent return type\n" + "found : boolean\n" + "required: number"); } public void testEnum40() throws Exception { testTypes( "/** @enum {Number} */ var MyEnum = {FOO: new Number(1)};" + "/** @param {number} x \n * @return {number} */" + "function f(x) { return x == MyEnum.FOO && MyEnum.FOO == x; }", "inconsistent return type\n" + "found : boolean\n" + "required: number"); } public void testEnum41() throws Exception { testTypes( "/** @enum {number} */ var MyEnum = {/** @const */ FOO: 1};" + "/** @return {string} */" + "function f() { return MyEnum.FOO; }", "inconsistent return type\n" + "found : MyEnum.<number>\n" + "required: string"); } public void testEnum42() throws Exception { testTypes( "/** @param {number} x */ function f(x) {}" + "/** @enum {Object} */ var MyEnum = {FOO: {newProperty: 1, b: 2}};" + "f(MyEnum.FOO.newProperty);"); } public void testAliasedEnum1() throws Exception { testTypes( "/** @enum */ var YourEnum = {FOO: 3};" + "/** @enum */ var MyEnum = YourEnum;" + "/** @param {MyEnum} x */ function f(x) {} f(MyEnum.FOO);"); } public void testAliasedEnum2() throws Exception { testTypes( "/** @enum */ var YourEnum = {FOO: 3};" + "/** @enum */ var MyEnum = YourEnum;" + "/** @param {YourEnum} x */ function f(x) {} f(MyEnum.FOO);"); } public void testAliasedEnum3() throws Exception { testTypes( "/** @enum */ var YourEnum = {FOO: 3};" + "/** @enum */ var MyEnum = YourEnum;" + "/** @param {MyEnum} x */ function f(x) {} f(YourEnum.FOO);"); } public void testAliasedEnum4() throws Exception { testTypes( "/** @enum */ var YourEnum = {FOO: 3};" + "/** @enum */ var MyEnum = YourEnum;" + "/** @param {YourEnum} x */ function f(x) {} f(YourEnum.FOO);"); } public void testAliasedEnum5() throws Exception { testTypes( "/** @enum */ var YourEnum = {FOO: 3};" + "/** @enum */ var MyEnum = YourEnum;" + "/** @param {string} x */ function f(x) {} f(MyEnum.FOO);", "actual parameter 1 of f does not match formal parameter\n" + "found : YourEnum.<number>\n" + "required: string"); } public void testBackwardsEnumUse1() throws Exception { testTypes( "/** @return {string} */ function f() { return MyEnum.FOO; }" + "/** @enum {string} */ var MyEnum = {FOO: 'x'};"); } public void testBackwardsEnumUse2() throws Exception { testTypes( "/** @return {number} */ function f() { return MyEnum.FOO; }" + "/** @enum {string} */ var MyEnum = {FOO: 'x'};", "inconsistent return type\n" + "found : MyEnum.<string>\n" + "required: number"); } public void testBackwardsEnumUse3() throws Exception { testTypes( "/** @return {string} */ function f() { return MyEnum.FOO; }" + "/** @enum {string} */ var YourEnum = {FOO: 'x'};" + "/** @enum {string} */ var MyEnum = YourEnum;"); } public void testBackwardsEnumUse4() throws Exception { testTypes( "/** @return {number} */ function f() { return MyEnum.FOO; }" + "/** @enum {string} */ var YourEnum = {FOO: 'x'};" + "/** @enum {string} */ var MyEnum = YourEnum;", "inconsistent return type\n" + "found : YourEnum.<string>\n" + "required: number"); } public void testBackwardsEnumUse5() throws Exception { testTypes( "/** @return {string} */ function f() { return MyEnum.BAR; }" + "/** @enum {string} */ var YourEnum = {FOO: 'x'};" + "/** @enum {string} */ var MyEnum = YourEnum;", "element BAR does not exist on this enum"); } public void testBackwardsTypedefUse2() throws Exception { testTypes( "/** @this {MyTypedef} */ function f() {}" + "/** @typedef {!(Date|Array)} */ var MyTypedef;"); } public void testBackwardsTypedefUse4() throws Exception { testTypes( "/** @return {MyTypedef} */ function f() { return null; }" + "/** @typedef {string} */ var MyTypedef;", "inconsistent return type\n" + "found : null\n" + "required: string"); } public void testBackwardsTypedefUse6() throws Exception { testTypes( "/** @return {goog.MyTypedef} */ function f() { return null; }" + "var goog = {};" + "/** @typedef {string} */ goog.MyTypedef;", "inconsistent return type\n" + "found : null\n" + "required: string"); } public void testBackwardsTypedefUse7() throws Exception { testTypes( "/** @return {goog.MyTypedef} */ function f() { return null; }" + "var goog = {};" + "/** @typedef {Object} */ goog.MyTypedef;"); } public void testBackwardsTypedefUse8() throws Exception { // Technically, this isn't quite right, because the JS runtime // will coerce null -> the global object. But we'll punt on that for now. testTypes( "/** @param {!Array} x */ function g(x) {}" + "/** @this {goog.MyTypedef} */ function f() { g(this); }" + "var goog = {};" + "/** @typedef {(Array|null|undefined)} */ goog.MyTypedef;"); } public void testBackwardsTypedefUse9() throws Exception { testTypes( "/** @param {!Array} x */ function g(x) {}" + "/** @this {goog.MyTypedef} */ function f() { g(this); }" + "var goog = {};" + "/** @typedef {(Error|null|undefined)} */ goog.MyTypedef;", "actual parameter 1 of g does not match formal parameter\n" + "found : Error\n" + "required: Array"); } public void testBackwardsTypedefUse10() throws Exception { testTypes( "/** @param {goog.MyEnum} x */ function g(x) {}" + "var goog = {};" + "/** @enum {goog.MyTypedef} */ goog.MyEnum = {FOO: 1};" + "/** @typedef {number} */ goog.MyTypedef;" + "g(1);", "actual parameter 1 of g does not match formal parameter\n" + "found : number\n" + "required: goog.MyEnum.<number>"); } public void testBackwardsConstructor1() throws Exception { testTypes( "function f() { (new Foo(true)); }" + "/** \n * @constructor \n * @param {number} x */" + "var Foo = function(x) {};", "actual parameter 1 of Foo does not match formal parameter\n" + "found : boolean\n" + "required: number"); } public void testBackwardsConstructor2() throws Exception { testTypes( "function f() { (new Foo(true)); }" + "/** \n * @constructor \n * @param {number} x */" + "var YourFoo = function(x) {};" + "/** \n * @constructor \n * @param {number} x */" + "var Foo = YourFoo;", "actual parameter 1 of Foo does not match formal parameter\n" + "found : boolean\n" + "required: number"); } public void testMinimalConstructorAnnotation() throws Exception { testTypes("/** @constructor */function Foo(){}"); } public void testGoodExtends1() throws Exception { // A minimal @extends example testTypes("/** @constructor */function base() {}\n" + "/** @constructor\n * @extends {base} */function derived() {}\n"); } public void testGoodExtends2() throws Exception { testTypes("/** @constructor\n * @extends base */function derived() {}\n" + "/** @constructor */function base() {}\n"); } public void testGoodExtends3() throws Exception { testTypes("/** @constructor\n * @extends {Object} */function base() {}\n" + "/** @constructor\n * @extends {base} */function derived() {}\n"); } public void testGoodExtends4() throws Exception { // Ensure that @extends actually sets the base type of a constructor // correctly. Because this isn't part of the human-readable Function // definition, we need to crawl the prototype chain (eww). Node n = parseAndTypeCheck( "var goog = {};\n" + "/** @constructor */goog.Base = function(){};\n" + "/** @constructor\n" + " * @extends {goog.Base} */goog.Derived = function(){};\n"); Node subTypeName = n.getLastChild().getLastChild().getFirstChild(); assertEquals("goog.Derived", subTypeName.getQualifiedName()); FunctionType subCtorType = (FunctionType) subTypeName.getNext().getJSType(); assertEquals("goog.Derived", subCtorType.getInstanceType().toString()); JSType superType = subCtorType.getPrototype().getImplicitPrototype(); assertEquals("goog.Base", superType.toString()); } public void testGoodExtends5() throws Exception { // we allow for the extends annotation to be placed first testTypes("/** @constructor */function base() {}\n" + "/** @extends {base}\n * @constructor */function derived() {}\n"); } public void testGoodExtends6() throws Exception { testFunctionType( CLOSURE_DEFS + "/** @constructor */function base() {}\n" + "/** @return {number} */ " + " base.prototype.foo = function() { return 1; };\n" + "/** @extends {base}\n * @constructor */function derived() {}\n" + "goog.inherits(derived, base);", "derived.superClass_.foo", "function (this:base): number"); } public void testGoodExtends7() throws Exception { testFunctionType( "Function.prototype.inherits = function(x) {};" + "/** @constructor */function base() {}\n" + "/** @extends {base}\n * @constructor */function derived() {}\n" + "derived.inherits(base);", "(new derived).constructor", "function (new:derived, ...[?]): ?"); } public void testGoodExtends8() throws Exception { testTypes("/** @constructor \n @extends {Base} */ function Sub() {}" + "/** @return {number} */ function f() { return (new Sub()).foo; }" + "/** @constructor */ function Base() {}" + "/** @type {boolean} */ Base.prototype.foo = true;", "inconsistent return type\n" + "found : boolean\n" + "required: number"); } public void testGoodExtends9() throws Exception { testTypes( "/** @constructor */ function Super() {}" + "Super.prototype.foo = function() {};" + "/** @constructor \n * @extends {Super} */ function Sub() {}" + "Sub.prototype = new Super();" + "/** @override */ Sub.prototype.foo = function() {};"); } public void testGoodExtends10() throws Exception { testTypes( "/** @constructor */ function Super() {}" + "/** @constructor \n * @extends {Super} */ function Sub() {}" + "Sub.prototype = new Super();" + "/** @return {Super} */ function foo() { return new Sub(); }"); } public void testGoodExtends11() throws Exception { testTypes( "/** @constructor */ function Super() {}" + "/** @param {boolean} x */ Super.prototype.foo = function(x) {};" + "/** @constructor \n * @extends {Super} */ function Sub() {}" + "Sub.prototype = new Super();" + "(new Sub()).foo(0);", "actual parameter 1 of Super.prototype.foo " + "does not match formal parameter\n" + "found : number\n" + "required: boolean"); } public void testGoodExtends12() throws Exception { testTypes( "/** @constructor \n * @extends {Super} */ function Sub() {}" + "/** @constructor \n * @extends {Sub} */ function Sub2() {}" + "/** @constructor */ function Super() {}" + "/** @param {Super} x */ function foo(x) {}" + "foo(new Sub2());"); } public void testGoodExtends13() throws Exception { testTypes( "/** @constructor \n * @extends {B} */ function C() {}" + "/** @constructor \n * @extends {D} */ function E() {}" + "/** @constructor \n * @extends {C} */ function D() {}" + "/** @constructor \n * @extends {A} */ function B() {}" + "/** @constructor */ function A() {}" + "/** @param {number} x */ function f(x) {} f(new E());", "actual parameter 1 of f does not match formal parameter\n" + "found : E\n" + "required: number"); } public void testGoodExtends14() throws Exception { testTypes( CLOSURE_DEFS + "/** @param {Function} f */ function g(f) {" + " /** @constructor */ function NewType() {};" + " goog.inherits(NewType, f);" + " (new NewType());" + "}"); } public void testGoodExtends15() throws Exception { testTypes( CLOSURE_DEFS + "/** @constructor */ function OldType() {}" + "/** @param {?function(new:OldType)} f */ function g(f) {" + " /**\n" + " * @constructor\n" + " * @extends {OldType}\n" + " */\n" + " function NewType() {};" + " goog.inherits(NewType, f);" + " NewType.prototype.method = function() {" + " NewType.superClass_.foo.call(this);" + " };" + "}", "Property foo never defined on OldType.prototype"); } public void testGoodExtends16() throws Exception { testTypes( CLOSURE_DEFS + "/** @param {Function} f */ function g(f) {" + " /** @constructor */ function NewType() {};" + " goog.inherits(f, NewType);" + " (new NewType());" + "}"); } public void testGoodExtends17() throws Exception { testFunctionType( "Function.prototype.inherits = function(x) {};" + "/** @constructor */function base() {}\n" + "/** @param {number} x */ base.prototype.bar = function(x) {};\n" + "/** @extends {base}\n * @constructor */function derived() {}\n" + "derived.inherits(base);", "(new derived).constructor.prototype.bar", "function (this:base, number): undefined"); } public void testBadExtends1() throws Exception { testTypes("/** @constructor */function base() {}\n" + "/** @constructor\n * @extends {not_base} */function derived() {}\n", "Bad type annotation. Unknown type not_base"); } public void testBadExtends2() throws Exception { testTypes("/** @constructor */function base() {\n" + "/** @type {!Number}*/\n" + "this.baseMember = new Number(4);\n" + "}\n" + "/** @constructor\n" + " * @extends {base} */function derived() {}\n" + "/** @param {!String} x*/\n" + "function foo(x){ }\n" + "/** @type {!derived}*/var y;\n" + "foo(y.baseMember);\n", "actual parameter 1 of foo does not match formal parameter\n" + "found : Number\n" + "required: String"); } public void testBadExtends3() throws Exception { testTypes("/** @extends {Object} */function base() {}", "@extends used without @constructor or @interface for base"); } public void testBadExtends4() throws Exception { // If there's a subclass of a class with a bad extends, // we only want to warn about the first one. testTypes( "/** @constructor \n * @extends {bad} */ function Sub() {}" + "/** @constructor \n * @extends {Sub} */ function Sub2() {}" + "/** @param {Sub} x */ function foo(x) {}" + "foo(new Sub2());", "Bad type annotation. Unknown type bad"); } public void testLateExtends() throws Exception { testTypes( CLOSURE_DEFS + "/** @constructor */ function Foo() {}\n" + "Foo.prototype.foo = function() {};\n" + "/** @constructor */function Bar() {}\n" + "goog.inherits(Foo, Bar);\n", "Missing @extends tag on type Foo"); } public void testSuperclassMatch() throws Exception { compiler.getOptions().setCodingConvention(new GoogleCodingConvention()); testTypes("/** @constructor */ var Foo = function() {};\n" + "/** @constructor \n @extends Foo */ var Bar = function() {};\n" + "Bar.inherits = function(x){};" + "Bar.inherits(Foo);\n"); } public void testSuperclassMatchWithMixin() throws Exception { compiler.getOptions().setCodingConvention(new GoogleCodingConvention()); testTypes("/** @constructor */ var Foo = function() {};\n" + "/** @constructor */ var Baz = function() {};\n" + "/** @constructor \n @extends Foo */ var Bar = function() {};\n" + "Bar.inherits = function(x){};" + "Bar.mixin = function(y){};" + "Bar.inherits(Foo);\n" + "Bar.mixin(Baz);\n"); } public void testSuperclassMismatch1() throws Exception { compiler.getOptions().setCodingConvention(new GoogleCodingConvention()); testTypes("/** @constructor */ var Foo = function() {};\n" + "/** @constructor \n @extends Object */ var Bar = function() {};\n" + "Bar.inherits = function(x){};" + "Bar.inherits(Foo);\n", "Missing @extends tag on type Bar"); } public void testSuperclassMismatch2() throws Exception { compiler.getOptions().setCodingConvention(new GoogleCodingConvention()); testTypes("/** @constructor */ var Foo = function(){};\n" + "/** @constructor */ var Bar = function(){};\n" + "Bar.inherits = function(x){};" + "Bar.inherits(Foo);", "Missing @extends tag on type Bar"); } public void testSuperClassDefinedAfterSubClass1() throws Exception { testTypes( "/** @constructor \n * @extends {Base} */ function A() {}" + "/** @constructor \n * @extends {Base} */ function B() {}" + "/** @constructor */ function Base() {}" + "/** @param {A|B} x \n * @return {B|A} */ " + "function foo(x) { return x; }"); } public void testSuperClassDefinedAfterSubClass2() throws Exception { testTypes( "/** @constructor \n * @extends {Base} */ function A() {}" + "/** @constructor \n * @extends {Base} */ function B() {}" + "/** @param {A|B} x \n * @return {B|A} */ " + "function foo(x) { return x; }" + "/** @constructor */ function Base() {}"); } public void testDirectPrototypeAssignment1() throws Exception { testTypes( "/** @constructor */ function Base() {}" + "Base.prototype.foo = 3;" + "/** @constructor \n * @extends {Base} */ function A() {}" + "A.prototype = new Base();" + "/** @return {string} */ function foo() { return (new A).foo; }", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testDirectPrototypeAssignment2() throws Exception { // This ensures that we don't attach property 'foo' onto the Base // instance object. testTypes( "/** @constructor */ function Base() {}" + "/** @constructor \n * @extends {Base} */ function A() {}" + "A.prototype = new Base();" + "A.prototype.foo = 3;" + "/** @return {string} */ function foo() { return (new Base).foo; }"); } public void testDirectPrototypeAssignment3() throws Exception { // This verifies that the compiler doesn't crash if the user // overwrites the prototype of a global variable in a local scope. testTypes( "/** @constructor */ var MainWidgetCreator = function() {};" + "/** @param {Function} ctor */" + "function createMainWidget(ctor) {" + " /** @constructor */ function tempCtor() {};" + " tempCtor.prototype = ctor.prototype;" + " MainWidgetCreator.superClass_ = ctor.prototype;" + " MainWidgetCreator.prototype = new tempCtor();" + "}"); } public void testGoodImplements1() throws Exception { testTypes("/** @interface */function Disposable() {}\n" + "/** @implements {Disposable}\n * @constructor */function f() {}"); } public void testGoodImplements2() throws Exception { testTypes("/** @interface */function Base1() {}\n" + "/** @interface */function Base2() {}\n" + "/** @constructor\n" + " * @implements {Base1}\n" + " * @implements {Base2}\n" + " */ function derived() {}"); } public void testGoodImplements3() throws Exception { testTypes("/** @interface */function Disposable() {}\n" + "/** @constructor \n @implements {Disposable} */function f() {}"); } public void testGoodImplements4() throws Exception { testTypes("var goog = {};" + "/** @type {!Function} */" + "goog.abstractMethod = function() {};" + "/** @interface */\n" + "goog.Disposable = goog.abstractMethod;" + "goog.Disposable.prototype.dispose = goog.abstractMethod;" + "/** @implements {goog.Disposable}\n * @constructor */" + "goog.SubDisposable = function() {};" + "/** @inheritDoc */ " + "goog.SubDisposable.prototype.dispose = function() {};"); } public void testGoodImplements5() throws Exception { testTypes( "/** @interface */\n" + "goog.Disposable = function() {};" + "/** @type {Function} */" + "goog.Disposable.prototype.dispose = function() {};" + "/** @implements {goog.Disposable}\n * @constructor */" + "goog.SubDisposable = function() {};" + "/** @param {number} key \n @override */ " + "goog.SubDisposable.prototype.dispose = function(key) {};"); } public void testGoodImplements6() throws Exception { testTypes( "var myNullFunction = function() {};" + "/** @interface */\n" + "goog.Disposable = function() {};" + "/** @return {number} */" + "goog.Disposable.prototype.dispose = myNullFunction;" + "/** @implements {goog.Disposable}\n * @constructor */" + "goog.SubDisposable = function() {};" + "/** @return {number} \n @override */ " + "goog.SubDisposable.prototype.dispose = function() { return 0; };"); } public void testGoodImplements7() throws Exception { testTypes( "var myNullFunction = function() {};" + "/** @interface */\n" + "goog.Disposable = function() {};" + "/** @return {number} */" + "goog.Disposable.prototype.dispose = function() {};" + "/** @implements {goog.Disposable}\n * @constructor */" + "goog.SubDisposable = function() {};" + "/** @return {number} \n @override */ " + "goog.SubDisposable.prototype.dispose = function() { return 0; };"); } public void testBadImplements1() throws Exception { testTypes("/** @interface */function Base1() {}\n" + "/** @interface */function Base2() {}\n" + "/** @constructor\n" + " * @implements {nonExistent}\n" + " * @implements {Base2}\n" + " */ function derived() {}", "Bad type annotation. Unknown type nonExistent"); } public void testBadImplements2() throws Exception { testTypes("/** @interface */function Disposable() {}\n" + "/** @implements {Disposable}\n */function f() {}", "@implements used without @constructor for f"); } public void testBadImplements3() throws Exception { testTypes( "var goog = {};" + "/** @type {!Function} */ goog.abstractMethod = function(){};" + "/** @interface */ var Disposable = goog.abstractMethod;" + "Disposable.prototype.method = goog.abstractMethod;" + "/** @implements {Disposable}\n * @constructor */function f() {}", "property method on interface Disposable is not implemented by type f"); } public void testBadImplements4() throws Exception { testTypes("/** @interface */function Disposable() {}\n" + "/** @implements {Disposable}\n * @interface */function f() {}", "f cannot implement this type; an interface can only extend, " + "but not implement interfaces"); } public void testBadImplements5() throws Exception { testTypes("/** @interface */function Disposable() {}\n" + "/** @type {number} */ Disposable.prototype.bar = function() {};", "assignment to property bar of Disposable.prototype\n" + "found : function (): undefined\n" + "required: number"); } public void testBadImplements6() throws Exception { testClosureTypesMultipleWarnings( "/** @interface */function Disposable() {}\n" + "/** @type {function()} */ Disposable.prototype.bar = 3;", Lists.newArrayList( "assignment to property bar of Disposable.prototype\n" + "found : number\n" + "required: function (): ?", "interface members can only be empty property declarations, " + "empty functions, or goog.abstractMethod")); } public void testInterfaceExtends() throws Exception { testTypes("/** @interface */function A() {}\n" + "/** @interface \n * @extends {A} */function B() {}\n" + "/** @constructor\n" + " * @implements {B}\n" + " */ function derived() {}"); } public void testBadInterfaceExtends1() throws Exception { testTypes("/** @interface \n * @extends {nonExistent} */function A() {}", "Bad type annotation. Unknown type nonExistent"); } public void testBadInterfaceExtendsNonExistentInterfaces() throws Exception { String js = "/** @interface \n" + " * @extends {nonExistent1} \n" + " * @extends {nonExistent2} \n" + " */function A() {}"; String[] expectedWarnings = { "Bad type annotation. Unknown type nonExistent1", "Bad type annotation. Unknown type nonExistent2" }; testTypes(js, expectedWarnings); } public void testBadInterfaceExtends2() throws Exception { testTypes("/** @constructor */function A() {}\n" + "/** @interface \n * @extends {A} */function B() {}", "B cannot extend this type; interfaces can only extend interfaces"); } public void testBadInterfaceExtends3() throws Exception { testTypes("/** @interface */function A() {}\n" + "/** @constructor \n * @extends {A} */function B() {}", "B cannot extend this type; constructors can only extend constructors"); } public void testBadInterfaceExtends4() throws Exception { // TODO(user): This should be detected as an error. Even if we enforce // that A cannot be used in the assignment, we should still detect the // inheritance chain as invalid. testTypes("/** @interface */function A() {}\n" + "/** @constructor */function B() {}\n" + "B.prototype = A;"); } public void testBadInterfaceExtends5() throws Exception { // TODO(user): This should be detected as an error. Even if we enforce // that A cannot be used in the assignment, we should still detect the // inheritance chain as invalid. testTypes("/** @constructor */function A() {}\n" + "/** @interface */function B() {}\n" + "B.prototype = A;"); } public void testBadImplementsAConstructor() throws Exception { testTypes("/** @constructor */function A() {}\n" + "/** @constructor \n * @implements {A} */function B() {}", "can only implement interfaces"); } public void testBadImplementsNonInterfaceType() throws Exception { testTypes("/** @constructor \n * @implements {Boolean} */function B() {}", "can only implement interfaces"); } public void testBadImplementsNonObjectType() throws Exception { testTypes("/** @constructor \n * @implements {string} */function S() {}", "can only implement interfaces"); } public void testInterfaceAssignment1() throws Exception { testTypes("/** @interface */var I = function() {};\n" + "/** @constructor\n@implements {I} */var T = function() {};\n" + "var t = new T();\n" + "/** @type {!I} */var i = t;"); } public void testInterfaceAssignment2() throws Exception { testTypes("/** @interface */var I = function() {};\n" + "/** @constructor */var T = function() {};\n" + "var t = new T();\n" + "/** @type {!I} */var i = t;", "initializing variable\n" + "found : T\n" + "required: I"); } public void testInterfaceAssignment3() throws Exception { testTypes("/** @interface */var I = function() {};\n" + "/** @constructor\n@implements {I} */var T = function() {};\n" + "var t = new T();\n" + "/** @type {I|number} */var i = t;"); } public void testInterfaceAssignment4() throws Exception { testTypes("/** @interface */var I1 = function() {};\n" + "/** @interface */var I2 = function() {};\n" + "/** @constructor\n@implements {I1} */var T = function() {};\n" + "var t = new T();\n" + "/** @type {I1|I2} */var i = t;"); } public void testInterfaceAssignment5() throws Exception { testTypes("/** @interface */var I1 = function() {};\n" + "/** @interface */var I2 = function() {};\n" + "/** @constructor\n@implements {I1}\n@implements {I2}*/" + "var T = function() {};\n" + "var t = new T();\n" + "/** @type {I1} */var i1 = t;\n" + "/** @type {I2} */var i2 = t;\n"); } public void testInterfaceAssignment6() throws Exception { testTypes("/** @interface */var I1 = function() {};\n" + "/** @interface */var I2 = function() {};\n" + "/** @constructor\n@implements {I1} */var T = function() {};\n" + "/** @type {!I1} */var i1 = new T();\n" + "/** @type {!I2} */var i2 = i1;\n", "initializing variable\n" + "found : I1\n" + "required: I2"); } public void testInterfaceAssignment7() throws Exception { testTypes("/** @interface */var I1 = function() {};\n" + "/** @interface\n@extends {I1}*/var I2 = function() {};\n" + "/** @constructor\n@implements {I2}*/var T = function() {};\n" + "var t = new T();\n" + "/** @type {I1} */var i1 = t;\n" + "/** @type {I2} */var i2 = t;\n" + "i1 = i2;\n"); } public void testInterfaceAssignment8() throws Exception { testTypes("/** @interface */var I = function() {};\n" + "/** @type {I} */var i;\n" + "/** @type {Object} */var o = i;\n" + "new Object().prototype = i.prototype;"); } public void testInterfaceAssignment9() throws Exception { testTypes("/** @interface */var I = function() {};\n" + "/** @return {I?} */function f() { return null; }\n" + "/** @type {!I} */var i = f();\n", "initializing variable\n" + "found : (I|null)\n" + "required: I"); } public void testInterfaceAssignment10() throws Exception { testTypes("/** @interface */var I1 = function() {};\n" + "/** @interface */var I2 = function() {};\n" + "/** @constructor\n@implements {I2} */var T = function() {};\n" + "/** @return {!I1|!I2} */function f() { return new T(); }\n" + "/** @type {!I1} */var i1 = f();\n", "initializing variable\n" + "found : (I1|I2)\n" + "required: I1"); } public void testInterfaceAssignment11() throws Exception { testTypes("/** @interface */var I1 = function() {};\n" + "/** @interface */var I2 = function() {};\n" + "/** @constructor */var T = function() {};\n" + "/** @return {!I1|!I2|!T} */function f() { return new T(); }\n" + "/** @type {!I1} */var i1 = f();\n", "initializing variable\n" + "found : (I1|I2|T)\n" + "required: I1"); } public void testInterfaceAssignment12() throws Exception { testTypes("/** @interface */var I = function() {};\n" + "/** @constructor\n@implements{I}*/var T1 = function() {};\n" + "/** @constructor\n@extends {T1}*/var T2 = function() {};\n" + "/** @return {I} */function f() { return new T2(); }"); } public void testInterfaceAssignment13() throws Exception { testTypes("/** @interface */var I = function() {};\n" + "/** @constructor\n@implements {I}*/var T = function() {};\n" + "/** @constructor */function Super() {};\n" + "/** @return {I} */Super.prototype.foo = " + "function() { return new T(); };\n" + "/** @constructor\n@extends {Super} */function Sub() {}\n" + "/** @override\n@return {T} */Sub.prototype.foo = " + "function() { return new T(); };\n"); } public void testGetprop1() throws Exception { testTypes("/** @return {void}*/function foo(){foo().bar;}", "No properties on this expression\n" + "found : undefined\n" + "required: Object"); } public void testGetprop2() throws Exception { testTypes("var x = null; x.alert();", "No properties on this expression\n" + "found : null\n" + "required: Object"); } public void testGetprop3() throws Exception { testTypes( "/** @constructor */ " + "function Foo() { /** @type {?Object} */ this.x = null; }" + "Foo.prototype.initX = function() { this.x = {foo: 1}; };" + "Foo.prototype.bar = function() {" + " if (this.x == null) { this.initX(); alert(this.x.foo); }" + "};"); } public void testGetprop4() throws Exception { testTypes("var x = null; x.prop = 3;", "No properties on this expression\n" + "found : null\n" + "required: Object"); } public void testSetprop1() throws Exception { // Create property on struct in the constructor testTypes("/**\n" + " * @constructor\n" + " * @struct\n" + " */\n" + "function Foo() { this.x = 123; }"); } public void testSetprop2() throws Exception { // Create property on struct outside the constructor testTypes("/**\n" + " * @constructor\n" + " * @struct\n" + " */\n" + "function Foo() {}\n" + "(new Foo()).x = 123;", "Cannot add a property to a struct instance " + "after it is constructed."); } public void testSetprop3() throws Exception { // Create property on struct outside the constructor testTypes("/**\n" + " * @constructor\n" + " * @struct\n" + " */\n" + "function Foo() {}\n" + "(function() { (new Foo()).x = 123; })();", "Cannot add a property to a struct instance " + "after it is constructed."); } public void testSetprop4() throws Exception { // Assign to existing property of struct outside the constructor testTypes("/**\n" + " * @constructor\n" + " * @struct\n" + " */\n" + "function Foo() { this.x = 123; }\n" + "(new Foo()).x = \"asdf\";"); } public void testSetprop5() throws Exception { // Create a property on union that includes a struct testTypes("/**\n" + " * @constructor\n" + " * @struct\n" + " */\n" + "function Foo() {}\n" + "(true ? new Foo() : {}).x = 123;", "Cannot add a property to a struct instance " + "after it is constructed."); } public void testSetprop6() throws Exception { // Create property on struct in another constructor testTypes("/**\n" + " * @constructor\n" + " * @struct\n" + " */\n" + "function Foo() {}\n" + "/**\n" + " * @constructor\n" + " * @param{Foo} f\n" + " */\n" + "function Bar(f) { f.x = 123; }", "Cannot add a property to a struct instance " + "after it is constructed."); } public void testSetprop7() throws Exception { //Bug b/c we require THIS when creating properties on structs for simplicity testTypes("/**\n" + " * @constructor\n" + " * @struct\n" + " */\n" + "function Foo() {\n" + " var t = this;\n" + " t.x = 123;\n" + "}", "Cannot add a property to a struct instance " + "after it is constructed."); } public void testSetprop8() throws Exception { // Create property on struct using DEC testTypes("/**\n" + " * @constructor\n" + " * @struct\n" + " */\n" + "function Foo() {}\n" + "(new Foo()).x--;", new String[] { "Property x never defined on Foo", "Cannot add a property to a struct instance " + "after it is constructed." }); } public void testSetprop9() throws Exception { // Create property on struct using ASSIGN_ADD testTypes("/**\n" + " * @constructor\n" + " * @struct\n" + " */\n" + "function Foo() {}\n" + "(new Foo()).x += 123;", new String[] { "Property x never defined on Foo", "Cannot add a property to a struct instance " + "after it is constructed." }); } public void testSetprop10() throws Exception { // Create property on object literal that is a struct testTypes("/** \n" + " * @constructor \n" + " * @struct \n" + " */ \n" + "function Square(side) { \n" + " this.side = side; \n" + "} \n" + "Square.prototype = /** @struct */ {\n" + " area: function() { return this.side * this.side; }\n" + "};\n" + "Square.prototype.id = function(x) { return x; };\n", "Cannot add a property to a struct instance " + "after it is constructed."); } public void testSetprop11() throws Exception { testTypes("/**\n" + " * @constructor\n" + " * @struct\n" + " */\n" + "function Foo() {}\n" + "function Bar() {}\n" + "Bar.prototype = new Foo();\n" + "Bar.prototype.someprop = 123;\n", "Cannot add a property to a struct instance " + "after it is constructed."); } public void testGetpropDict1() throws Exception { testTypes("/**\n" + " * @constructor\n" + " * @dict\n" + " */" + "function Dict1(){ this['prop'] = 123; }" + "/** @param{Dict1} x */" + "function takesDict(x) { return x.prop; }", "Cannot do '.' access on a dict"); } public void testGetpropDict2() throws Exception { testTypes("/**\n" + " * @constructor\n" + " * @dict\n" + " */" + "function Dict1(){ this['prop'] = 123; }" + "/**\n" + " * @constructor\n" + " * @extends {Dict1}\n" + " */" + "function Dict1kid(){ this['prop'] = 123; }" + "/** @param{Dict1kid} x */" + "function takesDict(x) { return x.prop; }", "Cannot do '.' access on a dict"); } public void testGetpropDict3() throws Exception { testTypes("/**\n" + " * @constructor\n" + " * @dict\n" + " */" + "function Dict1() { this['prop'] = 123; }" + "/** @constructor */" + "function NonDict() { this.prop = 321; }" + "/** @param{(NonDict|Dict1)} x */" + "function takesDict(x) { return x.prop; }", "Cannot do '.' access on a dict"); } public void testGetpropDict4() throws Exception { testTypes("/**\n" + " * @constructor\n" + " * @dict\n" + " */" + "function Dict1() { this['prop'] = 123; }" + "/**\n" + " * @constructor\n" + " * @struct\n" + " */" + "function Struct1() { this.prop = 123; }" + "/** @param{(Struct1|Dict1)} x */" + "function takesNothing(x) { return x.prop; }", "Cannot do '.' access on a dict"); } public void testGetpropDict5() throws Exception { testTypes("/**\n" + " * @constructor\n" + " * @dict\n" + " */" + "function Dict1(){ this.prop = 123; }", "Cannot do '.' access on a dict"); } public void testGetpropDict6() throws Exception { testTypes("/**\n" + " * @constructor\n" + " * @dict\n" + " */\n" + "function Foo() {}\n" + "function Bar() {}\n" + "Bar.prototype = new Foo();\n" + "Bar.prototype.someprop = 123;\n", "Cannot do '.' access on a dict"); } public void testGetpropDict7() throws Exception { testTypes("(/** @dict */ {'x': 123}).x = 321;", "Cannot do '.' access on a dict"); } public void testGetelemStruct1() throws Exception { testTypes("/**\n" + " * @constructor\n" + " * @struct\n" + " */" + "function Struct1(){ this.prop = 123; }" + "/** @param{Struct1} x */" + "function takesStruct(x) {" + " var z = x;" + " return z['prop'];" + "}", "Cannot do '[]' access on a struct"); } public void testGetelemStruct2() throws Exception { testTypes("/**\n" + " * @constructor\n" + " * @struct\n" + " */" + "function Struct1(){ this.prop = 123; }" + "/**\n" + " * @constructor\n" + " * @extends {Struct1}" + " */" + "function Struct1kid(){ this.prop = 123; }" + "/** @param{Struct1kid} x */" + "function takesStruct2(x) { return x['prop']; }", "Cannot do '[]' access on a struct"); } public void testGetelemStruct3() throws Exception { testTypes("/**\n" + " * @constructor\n" + " * @struct\n" + " */" + "function Struct1(){ this.prop = 123; }" + "/**\n" + " * @constructor\n" + " * @extends {Struct1}\n" + " */" + "function Struct1kid(){ this.prop = 123; }" + "var x = (new Struct1kid())['prop'];", "Cannot do '[]' access on a struct"); } public void testGetelemStruct4() throws Exception { testTypes("/**\n" + " * @constructor\n" + " * @struct\n" + " */" + "function Struct1() { this.prop = 123; }" + "/** @constructor */" + "function NonStruct() { this.prop = 321; }" + "/** @param{(NonStruct|Struct1)} x */" + "function takesStruct(x) { return x['prop']; }", "Cannot do '[]' access on a struct"); } public void testGetelemStruct5() throws Exception { testTypes("/**\n" + " * @constructor\n" + " * @struct\n" + " */" + "function Struct1() { this.prop = 123; }" + "/**\n" + " * @constructor\n" + " * @dict\n" + " */" + "function Dict1() { this['prop'] = 123; }" + "/** @param{(Struct1|Dict1)} x */" + "function takesNothing(x) { return x['prop']; }", "Cannot do '[]' access on a struct"); } public void testGetelemStruct6() throws Exception { // By casting Bar to Foo, the illegal bracket access is not detected testTypes("/** @interface */ function Foo(){}\n" + "/**\n" + " * @constructor\n" + " * @struct\n" + " * @implements {Foo}\n" + " */" + "function Bar(){ this.x = 123; }\n" + "var z = /** @type {Foo} */(new Bar)['x'];"); } public void testGetelemStruct7() throws Exception { testTypes("/**\n" + " * @constructor\n" + " * @struct\n" + " */\n" + "function Foo() {}\n" + "function Bar() {}\n" + "Bar.prototype = new Foo();\n" + "Bar.prototype['someprop'] = 123;\n", "Cannot do '[]' access on a struct"); } public void testInOnStruct() throws Exception { testTypes("/**\n" + " * @constructor\n" + " * @struct\n" + " */" + "function Foo() {}\n" + "if ('prop' in (new Foo())) {}", "Cannot use the IN operator with structs"); } public void testForinOnStruct() throws Exception { testTypes("/**\n" + " * @constructor\n" + " * @struct\n" + " */" + "function Foo() {}\n" + "for (var prop in (new Foo())) {}", "Cannot use the IN operator with structs"); } public void testArrayAccess1() throws Exception { testTypes("var a = []; var b = a['hi'];"); } public void testArrayAccess2() throws Exception { testTypes("var a = []; var b = a[[1,2]];", "array access\n" + "found : Array\n" + "required: number"); } public void testArrayAccess3() throws Exception { testTypes("var bar = [];" + "/** @return {void} */function baz(){};" + "var foo = bar[baz()];", "array access\n" + "found : undefined\n" + "required: number"); } public void testArrayAccess4() throws Exception { testTypes("/**@return {!Array}*/function foo(){};var bar = foo()[foo()];", "array access\n" + "found : Array\n" + "required: number"); } public void testArrayAccess6() throws Exception { testTypes("var bar = null[1];", "only arrays or objects can be accessed\n" + "found : null\n" + "required: Object"); } public void testArrayAccess7() throws Exception { testTypes("var bar = void 0; bar[0];", "only arrays or objects can be accessed\n" + "found : undefined\n" + "required: Object"); } public void testArrayAccess8() throws Exception { // Verifies that we don't emit two warnings, because // the var has been dereferenced after the first one. testTypes("var bar = void 0; bar[0]; bar[1];", "only arrays or objects can be accessed\n" + "found : undefined\n" + "required: Object"); } public void testArrayAccess9() throws Exception { testTypes("/** @return {?Array} */ function f() { return []; }" + "f()[{}]", "array access\n" + "found : {}\n" + "required: number"); } public void testPropAccess() throws Exception { testTypes("/** @param {*} x */var f = function(x) {\n" + "var o = String(x);\n" + "if (typeof o['a'] != 'undefined') { return o['a']; }\n" + "return null;\n" + "};"); } public void testPropAccess2() throws Exception { testTypes("var bar = void 0; bar.baz;", "No properties on this expression\n" + "found : undefined\n" + "required: Object"); } public void testPropAccess3() throws Exception { // Verifies that we don't emit two warnings, because // the var has been dereferenced after the first one. testTypes("var bar = void 0; bar.baz; bar.bax;", "No properties on this expression\n" + "found : undefined\n" + "required: Object"); } public void testPropAccess4() throws Exception { testTypes("/** @param {*} x */ function f(x) { return x['hi']; }"); } public void testSwitchCase1() throws Exception { testTypes("/**@type number*/var a;" + "/**@type string*/var b;" + "switch(a){case b:;}", "case expression doesn't match switch\n" + "found : string\n" + "required: number"); } public void testSwitchCase2() throws Exception { testTypes("var a = null; switch (typeof a) { case 'foo': }"); } public void testVar1() throws Exception { TypeCheckResult p = parseAndTypeCheckWithScope("/** @type {(string,null)} */var a = null"); assertTypeEquals(createUnionType(STRING_TYPE, NULL_TYPE), p.scope.getVar("a").getType()); } public void testVar2() throws Exception { testTypes("/** @type {Function} */ var a = function(){}"); } public void testVar3() throws Exception { TypeCheckResult p = parseAndTypeCheckWithScope("var a = 3;"); assertTypeEquals(NUMBER_TYPE, p.scope.getVar("a").getType()); } public void testVar4() throws Exception { TypeCheckResult p = parseAndTypeCheckWithScope( "var a = 3; a = 'string';"); assertTypeEquals(createUnionType(STRING_TYPE, NUMBER_TYPE), p.scope.getVar("a").getType()); } public void testVar5() throws Exception { testTypes("var goog = {};" + "/** @type string */goog.foo = 'hello';" + "/** @type number */var a = goog.foo;", "initializing variable\n" + "found : string\n" + "required: number"); } public void testVar6() throws Exception { testTypes( "function f() {" + " return function() {" + " /** @type {!Date} */" + " var a = 7;" + " };" + "}", "initializing variable\n" + "found : number\n" + "required: Date"); } public void testVar7() throws Exception { testTypes("/** @type number */var a, b;", "declaration of multiple variables with shared type information"); } public void testVar8() throws Exception { testTypes("var a, b;"); } public void testVar9() throws Exception { testTypes("/** @enum */var a;", "enum initializer must be an object literal or an enum"); } public void testVar10() throws Exception { testTypes("/** @type !Number */var foo = 'abc';", "initializing variable\n" + "found : string\n" + "required: Number"); } public void testVar11() throws Exception { testTypes("var /** @type !Date */foo = 'abc';", "initializing variable\n" + "found : string\n" + "required: Date"); } public void testVar12() throws Exception { testTypes("var /** @type !Date */foo = 'abc', " + "/** @type !RegExp */bar = 5;", new String[] { "initializing variable\n" + "found : string\n" + "required: Date", "initializing variable\n" + "found : number\n" + "required: RegExp"}); } public void testVar13() throws Exception { // this caused an NPE testTypes("var /** @type number */a,a;"); } public void testVar14() throws Exception { testTypes("/** @return {number} */ function f() { var x; return x; }", "inconsistent return type\n" + "found : undefined\n" + "required: number"); } public void testVar15() throws Exception { testTypes("/** @return {number} */" + "function f() { var x = x || {}; return x; }", "inconsistent return type\n" + "found : {}\n" + "required: number"); } public void testAssign1() throws Exception { testTypes("var goog = {};" + "/** @type number */goog.foo = 'hello';", "assignment to property foo of goog\n" + "found : string\n" + "required: number"); } public void testAssign2() throws Exception { testTypes("var goog = {};" + "/** @type number */goog.foo = 3;" + "goog.foo = 'hello';", "assignment to property foo of goog\n" + "found : string\n" + "required: number"); } public void testAssign3() throws Exception { testTypes("var goog = {};" + "/** @type number */goog.foo = 3;" + "goog.foo = 4;"); } public void testAssign4() throws Exception { testTypes("var goog = {};" + "goog.foo = 3;" + "goog.foo = 'hello';"); } public void testAssignInference() throws Exception { testTypes( "/**" + " * @param {Array} x" + " * @return {number}" + " */" + "function f(x) {" + " var y = null;" + " y = x[0];" + " if (y == null) { return 4; } else { return 6; }" + "}"); } public void testOr1() throws Exception { testTypes("/** @type number */var a;" + "/** @type number */var b;" + "a + b || undefined;"); } public void testOr2() throws Exception { testTypes("/** @type number */var a;" + "/** @type number */var b;" + "/** @type number */var c = a + b || undefined;", "initializing variable\n" + "found : (number|undefined)\n" + "required: number"); } public void testOr3() throws Exception { testTypes("/** @type {(number, undefined)} */var a;" + "/** @type number */var c = a || 3;"); } /** * Test that type inference continues with the right side, * when no short-circuiting is possible. * See bugid 1205387 for more details. */ public void testOr4() throws Exception { testTypes("/**@type {number} */var x;x=null || \"a\";", "assignment\n" + "found : string\n" + "required: number"); } /** * @see #testOr4() */ public void testOr5() throws Exception { testTypes("/**@type {number} */var x;x=undefined || \"a\";", "assignment\n" + "found : string\n" + "required: number"); } public void testAnd1() throws Exception { testTypes("/** @type number */var a;" + "/** @type number */var b;" + "a + b && undefined;"); } public void testAnd2() throws Exception { testTypes("/** @type number */var a;" + "/** @type number */var b;" + "/** @type number */var c = a + b && undefined;", "initializing variable\n" + "found : (number|undefined)\n" + "required: number"); } public void testAnd3() throws Exception { testTypes("/** @type {(!Array, undefined)} */var a;" + "/** @type number */var c = a && undefined;", "initializing variable\n" + "found : undefined\n" + "required: number"); } public void testAnd4() throws Exception { testTypes("/** @param {number} x */function f(x){};\n" + "/** @type null */var x; /** @type {number?} */var y;\n" + "if (x && y) { f(y) }"); } public void testAnd5() throws Exception { testTypes("/** @param {number} x\n@param {string} y*/function f(x,y){};\n" + "/** @type {number?} */var x; /** @type {string?} */var y;\n" + "if (x && y) { f(x, y) }"); } public void testAnd6() throws Exception { testTypes("/** @param {number} x */function f(x){};\n" + "/** @type {number|undefined} */var x;\n" + "if (x && f(x)) { f(x) }"); } public void testAnd7() throws Exception { // TODO(user): a deterministic warning should be generated for this // case since x && x is always false. The implementation of this requires // a more precise handling of a null value within a variable's type. // Currently, a null value defaults to ? which passes every check. testTypes("/** @type null */var x; if (x && x) {}"); } public void testHook() throws Exception { testTypes("/**@return {void}*/function foo(){ var x=foo()?a:b; }"); } public void testHookRestrictsType1() throws Exception { testTypes("/** @return {(string,null)} */" + "function f() { return null;}" + "/** @type {(string,null)} */ var a = f();" + "/** @type string */" + "var b = a ? a : 'default';"); } public void testHookRestrictsType2() throws Exception { testTypes("/** @type {String} */" + "var a = null;" + "/** @type null */" + "var b = a ? null : a;"); } public void testHookRestrictsType3() throws Exception { testTypes("/** @type {String} */" + "var a;" + "/** @type null */" + "var b = (!a) ? a : null;"); } public void testHookRestrictsType4() throws Exception { testTypes("/** @type {(boolean,undefined)} */" + "var a;" + "/** @type boolean */" + "var b = a != null ? a : true;"); } public void testHookRestrictsType5() throws Exception { testTypes("/** @type {(boolean,undefined)} */" + "var a;" + "/** @type {(undefined)} */" + "var b = a == null ? a : undefined;"); } public void testHookRestrictsType6() throws Exception { testTypes("/** @type {(number,null,undefined)} */" + "var a;" + "/** @type {number} */" + "var b = a == null ? 5 : a;"); } public void testHookRestrictsType7() throws Exception { testTypes("/** @type {(number,null,undefined)} */" + "var a;" + "/** @type {number} */" + "var b = a == undefined ? 5 : a;"); } public void testWhileRestrictsType1() throws Exception { testTypes("/** @param {null} x */ function g(x) {}" + "/** @param {number?} x */\n" + "function f(x) {\n" + "while (x) {\n" + "if (g(x)) { x = 1; }\n" + "x = x-1;\n}\n}", "actual parameter 1 of g does not match formal parameter\n" + "found : number\n" + "required: null"); } public void testWhileRestrictsType2() throws Exception { testTypes("/** @param {number?} x\n@return {number}*/\n" + "function f(x) {\n/** @type {number} */var y = 0;" + "while (x) {\n" + "y = x;\n" + "x = x-1;\n}\n" + "return y;}"); } public void testHigherOrderFunctions1() throws Exception { testTypes( "/** @type {function(number)} */var f;" + "f(true);", "actual parameter 1 of f does not match formal parameter\n" + "found : boolean\n" + "required: number"); } public void testHigherOrderFunctions2() throws Exception { testTypes( "/** @type {function():!Date} */var f;" + "/** @type boolean */var a = f();", "initializing variable\n" + "found : Date\n" + "required: boolean"); } public void testHigherOrderFunctions3() throws Exception { testTypes( "/** @type {function(this:Error):Date} */var f; new f", "cannot instantiate non-constructor"); } public void testHigherOrderFunctions4() throws Exception { testTypes( "/** @type {function(this:Error,...[number]):Date} */var f; new f", "cannot instantiate non-constructor"); } public void testHigherOrderFunctions5() throws Exception { testTypes( "/** @param {number} x */ function g(x) {}" + "/** @type {function(new:Error,...[number]):Date} */ var f;" + "g(new f());", "actual parameter 1 of g does not match formal parameter\n" + "found : Error\n" + "required: number"); } public void testConstructorAlias1() throws Exception { testTypes( "/** @constructor */ var Foo = function() {};" + "/** @type {number} */ Foo.prototype.bar = 3;" + "/** @constructor */ var FooAlias = Foo;" + "/** @return {string} */ function foo() { " + " return (new FooAlias()).bar; }", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testConstructorAlias2() throws Exception { testTypes( "/** @constructor */ var Foo = function() {};" + "/** @constructor */ var FooAlias = Foo;" + "/** @type {number} */ FooAlias.prototype.bar = 3;" + "/** @return {string} */ function foo() { " + " return (new Foo()).bar; }", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testConstructorAlias3() throws Exception { testTypes( "/** @constructor */ var Foo = function() {};" + "/** @type {number} */ Foo.prototype.bar = 3;" + "/** @constructor */ var FooAlias = Foo;" + "/** @return {string} */ function foo() { " + " return (new FooAlias()).bar; }", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testConstructorAlias4() throws Exception { testTypes( "/** @constructor */ var Foo = function() {};" + "var FooAlias = Foo;" + "/** @type {number} */ FooAlias.prototype.bar = 3;" + "/** @return {string} */ function foo() { " + " return (new Foo()).bar; }", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testConstructorAlias5() throws Exception { testTypes( "/** @constructor */ var Foo = function() {};" + "/** @constructor */ var FooAlias = Foo;" + "/** @return {FooAlias} */ function foo() { " + " return new Foo(); }"); } public void testConstructorAlias6() throws Exception { testTypes( "/** @constructor */ var Foo = function() {};" + "/** @constructor */ var FooAlias = Foo;" + "/** @return {Foo} */ function foo() { " + " return new FooAlias(); }"); } public void testConstructorAlias7() throws Exception { testTypes( "var goog = {};" + "/** @constructor */ goog.Foo = function() {};" + "/** @constructor */ goog.FooAlias = goog.Foo;" + "/** @return {number} */ function foo() { " + " return new goog.FooAlias(); }", "inconsistent return type\n" + "found : goog.Foo\n" + "required: number"); } public void testConstructorAlias8() throws Exception { testTypes( "var goog = {};" + "/**\n * @param {number} x \n * @constructor */ " + "goog.Foo = function(x) {};" + "/**\n * @param {number} x \n * @constructor */ " + "goog.FooAlias = goog.Foo;" + "/** @return {number} */ function foo() { " + " return new goog.FooAlias(1); }", "inconsistent return type\n" + "found : goog.Foo\n" + "required: number"); } public void testConstructorAlias9() throws Exception { testTypes( "var goog = {};" + "/**\n * @param {number} x \n * @constructor */ " + "goog.Foo = function(x) {};" + "/** @constructor */ goog.FooAlias = goog.Foo;" + "/** @return {number} */ function foo() { " + " return new goog.FooAlias(1); }", "inconsistent return type\n" + "found : goog.Foo\n" + "required: number"); } public void testConstructorAlias10() throws Exception { testTypes( "/**\n * @param {number} x \n * @constructor */ " + "var Foo = function(x) {};" + "/** @constructor */ var FooAlias = Foo;" + "/** @return {number} */ function foo() { " + " return new FooAlias(1); }", "inconsistent return type\n" + "found : Foo\n" + "required: number"); } public void testClosure1() throws Exception { testClosureTypes( CLOSURE_DEFS + "/** @type {string|undefined} */var a;" + "/** @type string */" + "var b = goog.isDef(a) ? a : 'default';", null); } public void testClosure2() throws Exception { testClosureTypes( CLOSURE_DEFS + "/** @type {string?} */var a;" + "/** @type string */" + "var b = goog.isNull(a) ? 'default' : a;", null); } public void testClosure3() throws Exception { testClosureTypes( CLOSURE_DEFS + "/** @type {string|null|undefined} */var a;" + "/** @type string */" + "var b = goog.isDefAndNotNull(a) ? a : 'default';", null); } public void testClosure4() throws Exception { testClosureTypes( CLOSURE_DEFS + "/** @type {string|undefined} */var a;" + "/** @type string */" + "var b = !goog.isDef(a) ? 'default' : a;", null); } public void testClosure5() throws Exception { testClosureTypes( CLOSURE_DEFS + "/** @type {string?} */var a;" + "/** @type string */" + "var b = !goog.isNull(a) ? a : 'default';", null); } public void testClosure6() throws Exception { testClosureTypes( CLOSURE_DEFS + "/** @type {string|null|undefined} */var a;" + "/** @type string */" + "var b = !goog.isDefAndNotNull(a) ? 'default' : a;", null); } public void testClosure7() throws Exception { testClosureTypes( CLOSURE_DEFS + "/** @type {string|null|undefined} */ var a = foo();" + "/** @type {number} */" + "var b = goog.asserts.assert(a);", "initializing variable\n" + "found : string\n" + "required: number"); } public void testReturn1() throws Exception { testTypes("/**@return {void}*/function foo(){ return 3; }", "inconsistent return type\n" + "found : number\n" + "required: undefined"); } public void testReturn2() throws Exception { testTypes("/**@return {!Number}*/function foo(){ return; }", "inconsistent return type\n" + "found : undefined\n" + "required: Number"); } public void testReturn3() throws Exception { testTypes("/**@return {!Number}*/function foo(){ return 'abc'; }", "inconsistent return type\n" + "found : string\n" + "required: Number"); } public void testReturn4() throws Exception { testTypes("/**@return {!Number}\n*/\n function a(){return new Array();}", "inconsistent return type\n" + "found : Array\n" + "required: Number"); } public void testReturn5() throws Exception { testTypes("/** @param {number} n\n" + "@constructor */function n(n){return};"); } public void testReturn6() throws Exception { testTypes( "/** @param {number} opt_a\n@return {string} */" + "function a(opt_a) { return opt_a }", "inconsistent return type\n" + "found : (number|undefined)\n" + "required: string"); } public void testReturn7() throws Exception { testTypes("/** @constructor */var A = function() {};\n" + "/** @constructor */var B = function() {};\n" + "/** @return {!B} */A.f = function() { return 1; };", "inconsistent return type\n" + "found : number\n" + "required: B"); } public void testReturn8() throws Exception { testTypes("/** @constructor */var A = function() {};\n" + "/** @constructor */var B = function() {};\n" + "/** @return {!B} */A.prototype.f = function() { return 1; };", "inconsistent return type\n" + "found : number\n" + "required: B"); } public void testInferredReturn1() throws Exception { testTypes( "function f() {} /** @param {number} x */ function g(x) {}" + "g(f());", "actual parameter 1 of g does not match formal parameter\n" + "found : undefined\n" + "required: number"); } public void testInferredReturn2() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "Foo.prototype.bar = function() {}; " + "/** @param {number} x */ function g(x) {}" + "g((new Foo()).bar());", "actual parameter 1 of g does not match formal parameter\n" + "found : undefined\n" + "required: number"); } public void testInferredReturn3() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "Foo.prototype.bar = function() {}; " + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}" + "/** @return {number} \n * @override */ " + "SubFoo.prototype.bar = function() { return 3; }; ", "mismatch of the bar property type and the type of the property " + "it overrides from superclass Foo\n" + "original: function (this:Foo): undefined\n" + "override: function (this:SubFoo): number"); } public void testInferredReturn4() throws Exception { // By design, this throws a warning. if you want global x to be // defined to some other type of function, then you need to declare it // as a greater type. testTypes( "var x = function() {};" + "x = /** @type {function(): number} */ (function() { return 3; });", "assignment\n" + "found : function (): number\n" + "required: function (): undefined"); } public void testInferredReturn5() throws Exception { // If x is local, then the function type is not declared. testTypes( "/** @return {string} */" + "function f() {" + " var x = function() {};" + " x = /** @type {function(): number} */ (function() { return 3; });" + " return x();" + "}", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testInferredReturn6() throws Exception { testTypes( "/** @return {string} */" + "function f() {" + " var x = function() {};" + " if (f()) " + " x = /** @type {function(): number} */ " + " (function() { return 3; });" + " return x();" + "}", "inconsistent return type\n" + "found : (number|undefined)\n" + "required: string"); } public void testInferredReturn7() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "/** @param {number} x */ Foo.prototype.bar = function(x) {};" + "Foo.prototype.bar = function(x) { return 3; };", "inconsistent return type\n" + "found : number\n" + "required: undefined"); } public void testInferredReturn8() throws Exception { reportMissingOverrides = CheckLevel.OFF; testTypes( "/** @constructor */ function Foo() {}" + "/** @param {number} x */ Foo.prototype.bar = function(x) {};" + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}" + "/** @param {number} x */ SubFoo.prototype.bar = " + " function(x) { return 3; }", "inconsistent return type\n" + "found : number\n" + "required: undefined"); } public void testInferredParam1() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "/** @param {number} x */ Foo.prototype.bar = function(x) {};" + "/** @param {string} x */ function f(x) {}" + "Foo.prototype.bar = function(y) { f(y); };", "actual parameter 1 of f does not match formal parameter\n" + "found : number\n" + "required: string"); } public void testInferredParam2() throws Exception { reportMissingOverrides = CheckLevel.OFF; testTypes( "/** @param {string} x */ function f(x) {}" + "/** @constructor */ function Foo() {}" + "/** @param {number} x */ Foo.prototype.bar = function(x) {};" + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}" + "/** @return {void} */ SubFoo.prototype.bar = " + " function(x) { f(x); }", "actual parameter 1 of f does not match formal parameter\n" + "found : number\n" + "required: string"); } public void testInferredParam3() throws Exception { reportMissingOverrides = CheckLevel.OFF; testTypes( "/** @param {string} x */ function f(x) {}" + "/** @constructor */ function Foo() {}" + "/** @param {number=} x */ Foo.prototype.bar = function(x) {};" + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}" + "/** @return {void} */ SubFoo.prototype.bar = " + " function(x) { f(x); }; (new SubFoo()).bar();", "actual parameter 1 of f does not match formal parameter\n" + "found : (number|undefined)\n" + "required: string"); } public void testInferredParam4() throws Exception { reportMissingOverrides = CheckLevel.OFF; testTypes( "/** @param {string} x */ function f(x) {}" + "/** @constructor */ function Foo() {}" + "/** @param {...number} x */ Foo.prototype.bar = function(x) {};" + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}" + "/** @return {void} */ SubFoo.prototype.bar = " + " function(x) { f(x); }; (new SubFoo()).bar();", "actual parameter 1 of f does not match formal parameter\n" + "found : (number|undefined)\n" + "required: string"); } public void testInferredParam5() throws Exception { reportMissingOverrides = CheckLevel.OFF; testTypes( "/** @param {string} x */ function f(x) {}" + "/** @constructor */ function Foo() {}" + "/** @param {...number} x */ Foo.prototype.bar = function(x) {};" + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}" + "/** @param {number=} x \n * @param {...number} y */ " + "SubFoo.prototype.bar = " + " function(x, y) { f(x); }; (new SubFoo()).bar();", "actual parameter 1 of f does not match formal parameter\n" + "found : (number|undefined)\n" + "required: string"); } public void testInferredParam6() throws Exception { reportMissingOverrides = CheckLevel.OFF; testTypes( "/** @param {string} x */ function f(x) {}" + "/** @constructor */ function Foo() {}" + "/** @param {number=} x */ Foo.prototype.bar = function(x) {};" + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}" + "/** @param {number=} x \n * @param {number=} y */ " + "SubFoo.prototype.bar = " + " function(x, y) { f(y); };", "actual parameter 1 of f does not match formal parameter\n" + "found : (number|undefined)\n" + "required: string"); } public void testInferredParam7() throws Exception { testTypes( "/** @param {string} x */ function f(x) {}" + "var bar = /** @type {function(number=,number=)} */ (" + " function(x, y) { f(y); });", "actual parameter 1 of f does not match formal parameter\n" + "found : (number|undefined)\n" + "required: string"); } public void testOverriddenParams1() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "/** @param {...?} var_args */" + "Foo.prototype.bar = function(var_args) {};" + "/**\n" + " * @constructor\n" + " * @extends {Foo}\n" + " */ function SubFoo() {}" + "/**\n" + " * @param {number} x\n" + " * @override\n" + " */" + "SubFoo.prototype.bar = function(x) {};"); } public void testOverriddenParams2() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "/** @type {function(...[?])} */" + "Foo.prototype.bar = function(var_args) {};" + "/**\n" + " * @constructor\n" + " * @extends {Foo}\n" + " */ function SubFoo() {}" + "/**\n" + " * @type {function(number)}\n" + " * @override\n" + " */" + "SubFoo.prototype.bar = function(x) {};"); } public void testOverriddenParams3() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "/** @param {...number} var_args */" + "Foo.prototype.bar = function(var_args) { };" + "/**\n" + " * @constructor\n" + " * @extends {Foo}\n" + " */ function SubFoo() {}" + "/**\n" + " * @param {number} x\n" + " * @override\n" + " */" + "SubFoo.prototype.bar = function(x) {};", "mismatch of the bar property type and the type of the " + "property it overrides from superclass Foo\n" + "original: function (this:Foo, ...[number]): undefined\n" + "override: function (this:SubFoo, number): undefined"); } public void testOverriddenParams4() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "/** @type {function(...[number])} */" + "Foo.prototype.bar = function(var_args) {};" + "/**\n" + " * @constructor\n" + " * @extends {Foo}\n" + " */ function SubFoo() {}" + "/**\n" + " * @type {function(number)}\n" + " * @override\n" + " */" + "SubFoo.prototype.bar = function(x) {};", "mismatch of the bar property type and the type of the " + "property it overrides from superclass Foo\n" + "original: function (...[number]): ?\n" + "override: function (number): ?"); } public void testOverriddenParams5() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "/** @param {number} x */" + "Foo.prototype.bar = function(x) { };" + "/**\n" + " * @constructor\n" + " * @extends {Foo}\n" + " */ function SubFoo() {}" + "/**\n" + " * @override\n" + " */" + "SubFoo.prototype.bar = function() {};" + "(new SubFoo()).bar();"); } public void testOverriddenParams6() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "/** @param {number} x */" + "Foo.prototype.bar = function(x) { };" + "/**\n" + " * @constructor\n" + " * @extends {Foo}\n" + " */ function SubFoo() {}" + "/**\n" + " * @override\n" + " */" + "SubFoo.prototype.bar = function() {};" + "(new SubFoo()).bar(true);", "actual parameter 1 of SubFoo.prototype.bar " + "does not match formal parameter\n" + "found : boolean\n" + "required: number"); } public void testOverriddenReturn1() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "/** @return {Object} */ Foo.prototype.bar = " + " function() { return {}; };" + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}" + "/** @return {SubFoo}\n * @override */ SubFoo.prototype.bar = " + " function() { return new Foo(); }", "inconsistent return type\n" + "found : Foo\n" + "required: (SubFoo|null)"); } public void testOverriddenReturn2() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "/** @return {SubFoo} */ Foo.prototype.bar = " + " function() { return new SubFoo(); };" + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}" + "/** @return {Foo} x\n * @override */ SubFoo.prototype.bar = " + " function() { return new SubFoo(); }", "mismatch of the bar property type and the type of the " + "property it overrides from superclass Foo\n" + "original: function (this:Foo): (SubFoo|null)\n" + "override: function (this:SubFoo): (Foo|null)"); } public void testThis1() throws Exception { testTypes("var goog = {};" + "/** @constructor */goog.A = function(){};" + "/** @return {number} */" + "goog.A.prototype.n = function() { return this };", "inconsistent return type\n" + "found : goog.A\n" + "required: number"); } public void testOverriddenProperty1() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "/** @type {Object} */" + "Foo.prototype.bar = {};" + "/**\n" + " * @constructor\n" + " * @extends {Foo}\n" + " */ function SubFoo() {}" + "/**\n" + " * @type {Array}\n" + " * @override\n" + " */" + "SubFoo.prototype.bar = [];"); } public void testOverriddenProperty2() throws Exception { testTypes( "/** @constructor */ function Foo() {" + " /** @type {Object} */" + " this.bar = {};" + "}" + "/**\n" + " * @constructor\n" + " * @extends {Foo}\n" + " */ function SubFoo() {}" + "/**\n" + " * @type {Array}\n" + " * @override\n" + " */" + "SubFoo.prototype.bar = [];"); } public void testOverriddenProperty3() throws Exception { testTypes( "/** @constructor */ function Foo() {" + "}" + "/** @type {string} */ Foo.prototype.data;" + "/**\n" + " * @constructor\n" + " * @extends {Foo}\n" + " */ function SubFoo() {}" + "/** @type {string|Object} \n @override */ " + "SubFoo.prototype.data = null;", "mismatch of the data property type and the type " + "of the property it overrides from superclass Foo\n" + "original: string\n" + "override: (Object|null|string)"); } public void testOverriddenProperty4() throws Exception { // These properties aren't declared, so there should be no warning. testTypes( "/** @constructor */ function Foo() {}" + "Foo.prototype.bar = null;" + "/**\n" + " * @constructor\n" + " * @extends {Foo}\n" + " */ function SubFoo() {}" + "SubFoo.prototype.bar = 3;"); } public void testOverriddenProperty5() throws Exception { // An override should be OK if the superclass property wasn't declared. testTypes( "/** @constructor */ function Foo() {}" + "Foo.prototype.bar = null;" + "/**\n" + " * @constructor\n" + " * @extends {Foo}\n" + " */ function SubFoo() {}" + "/** @override */ SubFoo.prototype.bar = 3;"); } public void testOverriddenProperty6() throws Exception { // The override keyword shouldn't be neccessary if the subclass property // is inferred. testTypes( "/** @constructor */ function Foo() {}" + "/** @type {?number} */ Foo.prototype.bar = null;" + "/**\n" + " * @constructor\n" + " * @extends {Foo}\n" + " */ function SubFoo() {}" + "SubFoo.prototype.bar = 3;"); } public void testThis2() throws Exception { testTypes("var goog = {};" + "/** @constructor */goog.A = function(){" + " this.foo = null;" + "};" + "/** @return {number} */" + "goog.A.prototype.n = function() { return this.foo };", "inconsistent return type\n" + "found : null\n" + "required: number"); } public void testThis3() throws Exception { testTypes("var goog = {};" + "/** @constructor */goog.A = function(){" + " this.foo = null;" + " this.foo = 5;" + "};"); } public void testThis4() throws Exception { testTypes("var goog = {};" + "/** @constructor */goog.A = function(){" + " /** @type {string?} */this.foo = null;" + "};" + "/** @return {number} */goog.A.prototype.n = function() {" + " return this.foo };", "inconsistent return type\n" + "found : (null|string)\n" + "required: number"); } public void testThis5() throws Exception { testTypes("/** @this Date\n@return {number}*/function h() { return this }", "inconsistent return type\n" + "found : Date\n" + "required: number"); } public void testThis6() throws Exception { testTypes("var goog = {};" + "/** @constructor\n@return {!Date} */" + "goog.A = function(){ return this };", "inconsistent return type\n" + "found : goog.A\n" + "required: Date"); } public void testThis7() throws Exception { testTypes("/** @constructor */function A(){};" + "/** @return {number} */A.prototype.n = function() { return this };", "inconsistent return type\n" + "found : A\n" + "required: number"); } public void testThis8() throws Exception { testTypes("/** @constructor */function A(){" + " /** @type {string?} */this.foo = null;" + "};" + "/** @return {number} */A.prototype.n = function() {" + " return this.foo };", "inconsistent return type\n" + "found : (null|string)\n" + "required: number"); } public void testThis9() throws Exception { // In A.bar, the type of {@code this} is unknown. testTypes("/** @constructor */function A(){};" + "A.prototype.foo = 3;" + "/** @return {string} */ A.bar = function() { return this.foo; };"); } public void testThis10() throws Exception { // In A.bar, the type of {@code this} is inferred from the @this tag. testTypes("/** @constructor */function A(){};" + "A.prototype.foo = 3;" + "/** @this {A}\n@return {string} */" + "A.bar = function() { return this.foo; };", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testThis11() throws Exception { testTypes( "/** @param {number} x */ function f(x) {}" + "/** @constructor */ function Ctor() {" + " /** @this {Date} */" + " this.method = function() {" + " f(this);" + " };" + "}", "actual parameter 1 of f does not match formal parameter\n" + "found : Date\n" + "required: number"); } public void testThis12() throws Exception { testTypes( "/** @param {number} x */ function f(x) {}" + "/** @constructor */ function Ctor() {}" + "Ctor.prototype['method'] = function() {" + " f(this);" + "}", "actual parameter 1 of f does not match formal parameter\n" + "found : Ctor\n" + "required: number"); } public void testThis13() throws Exception { testTypes( "/** @param {number} x */ function f(x) {}" + "/** @constructor */ function Ctor() {}" + "Ctor.prototype = {" + " method: function() {" + " f(this);" + " }" + "};", "actual parameter 1 of f does not match formal parameter\n" + "found : Ctor\n" + "required: number"); } public void testThis14() throws Exception { testTypes( "/** @param {number} x */ function f(x) {}" + "f(this.Object);", "actual parameter 1 of f does not match formal parameter\n" + "found : function (new:Object, *=): ?\n" + "required: number"); } public void testThisTypeOfFunction1() throws Exception { testTypes( "/** @type {function(this:Object)} */ function f() {}" + "f();"); } public void testThisTypeOfFunction2() throws Exception { testTypes( "/** @constructor */ function F() {}" + "/** @type {function(this:F)} */ function f() {}" + "f();", "\"function (this:F): ?\" must be called with a \"this\" type"); } public void testThisTypeOfFunction3() throws Exception { testTypes( "/** @constructor */ function F() {}" + "F.prototype.bar = function() {};" + "var f = (new F()).bar; f();", "\"function (this:F): undefined\" must be called with a \"this\" type"); } public void testThisTypeOfFunction4() throws Exception { testTypes( "/** @constructor */ function F() {}" + "F.prototype.moveTo = function(x, y) {};" + "F.prototype.lineTo = function(x, y) {};" + "function demo() {" + " var path = new F();" + " var points = [[1,1], [2,2]];" + " for (var i = 0; i < points.length; i++) {" + " (i == 0 ? path.moveTo : path.lineTo)(" + " points[i][0], points[i][1]);" + " }" + "}", "\"function (this:F, ?, ?): undefined\" " + "must be called with a \"this\" type"); } public void testGlobalThis1() throws Exception { testTypes("/** @constructor */ function Window() {}" + "/** @param {string} msg */ " + "Window.prototype.alert = function(msg) {};" + "this.alert(3);", "actual parameter 1 of Window.prototype.alert " + "does not match formal parameter\n" + "found : number\n" + "required: string"); } public void testGlobalThis2() throws Exception { // this.alert = 3 doesn't count as a declaration, so this isn't a warning. testTypes("/** @constructor */ function Bindow() {}" + "/** @param {string} msg */ " + "Bindow.prototype.alert = function(msg) {};" + "this.alert = 3;" + "(new Bindow()).alert(this.alert)"); } public void testGlobalThis2b() throws Exception { testTypes("/** @constructor */ function Bindow() {}" + "/** @param {string} msg */ " + "Bindow.prototype.alert = function(msg) {};" + "/** @return {number} */ this.alert = function() { return 3; };" + "(new Bindow()).alert(this.alert())", "actual parameter 1 of Bindow.prototype.alert " + "does not match formal parameter\n" + "found : number\n" + "required: string"); } public void testGlobalThis3() throws Exception { testTypes( "/** @param {string} msg */ " + "function alert(msg) {};" + "this.alert(3);", "actual parameter 1 of global this.alert " + "does not match formal parameter\n" + "found : number\n" + "required: string"); } public void testGlobalThis4() throws Exception { testTypes( "/** @param {string} msg */ " + "var alert = function(msg) {};" + "this.alert(3);", "actual parameter 1 of global this.alert " + "does not match formal parameter\n" + "found : number\n" + "required: string"); } public void testGlobalThis5() throws Exception { testTypes( "function f() {" + " /** @param {string} msg */ " + " var alert = function(msg) {};" + "}" + "this.alert(3);", "Property alert never defined on global this"); } public void testGlobalThis6() throws Exception { testTypes( "/** @param {string} msg */ " + "var alert = function(msg) {};" + "var x = 3;" + "x = 'msg';" + "this.alert(this.x);"); } public void testGlobalThis7() throws Exception { testTypes( "/** @constructor */ function Window() {}" + "/** @param {Window} msg */ " + "var foo = function(msg) {};" + "foo(this);"); } public void testGlobalThis8() throws Exception { testTypes( "/** @constructor */ function Window() {}" + "/** @param {number} msg */ " + "var foo = function(msg) {};" + "foo(this);", "actual parameter 1 of foo does not match formal parameter\n" + "found : global this\n" + "required: number"); } public void testGlobalThis9() throws Exception { testTypes( // Window is not marked as a constructor, so the // inheritance doesn't happen. "function Window() {}" + "Window.prototype.alert = function() {};" + "this.alert();", "Property alert never defined on global this"); } public void testControlFlowRestrictsType1() throws Exception { testTypes("/** @return {String?} */ function f() { return null; }" + "/** @type {String?} */ var a = f();" + "/** @type String */ var b = new String('foo');" + "/** @type null */ var c = null;" + "if (a) {" + " b = a;" + "} else {" + " c = a;" + "}"); } public void testControlFlowRestrictsType2() throws Exception { testTypes("/** @return {(string,null)} */ function f() { return null; }" + "/** @type {(string,null)} */ var a = f();" + "/** @type string */ var b = 'foo';" + "/** @type null */ var c = null;" + "if (a) {" + " b = a;" + "} else {" + " c = a;" + "}", "assignment\n" + "found : (null|string)\n" + "required: null"); } public void testControlFlowRestrictsType3() throws Exception { testTypes("/** @type {(string,void)} */" + "var a;" + "/** @type string */" + "var b = 'foo';" + "if (a) {" + " b = a;" + "}"); } public void testControlFlowRestrictsType4() throws Exception { testTypes("/** @param {string} a */ function f(a){}" + "/** @type {(string,undefined)} */ var a;" + "a && f(a);"); } public void testControlFlowRestrictsType5() throws Exception { testTypes("/** @param {undefined} a */ function f(a){}" + "/** @type {(!Array,undefined)} */ var a;" + "a || f(a);"); } public void testControlFlowRestrictsType6() throws Exception { testTypes("/** @param {undefined} x */ function f(x) {}" + "/** @type {(string,undefined)} */ var a;" + "a && f(a);", "actual parameter 1 of f does not match formal parameter\n" + "found : string\n" + "required: undefined"); } public void testControlFlowRestrictsType7() throws Exception { testTypes("/** @param {undefined} x */ function f(x) {}" + "/** @type {(string,undefined)} */ var a;" + "a && f(a);", "actual parameter 1 of f does not match formal parameter\n" + "found : string\n" + "required: undefined"); } public void testControlFlowRestrictsType8() throws Exception { testTypes("/** @param {undefined} a */ function f(a){}" + "/** @type {(!Array,undefined)} */ var a;" + "if (a || f(a)) {}"); } public void testControlFlowRestrictsType9() throws Exception { testTypes("/** @param {number?} x\n * @return {number}*/\n" + "var f = function(x) {\n" + "if (!x || x == 1) { return 1; } else { return x; }\n" + "};"); } public void testControlFlowRestrictsType10() throws Exception { // We should correctly infer that y will be (null|{}) because // the loop wraps around. testTypes("/** @param {number} x */ function f(x) {}" + "function g() {" + " var y = null;" + " for (var i = 0; i < 10; i++) {" + " f(y);" + " if (y != null) {" + " // y is None the first time it goes through this branch\n" + " } else {" + " y = {};" + " }" + " }" + "};", "actual parameter 1 of f does not match formal parameter\n" + "found : (null|{})\n" + "required: number"); } public void testControlFlowRestrictsType11() throws Exception { testTypes("/** @param {boolean} x */ function f(x) {}" + "function g() {" + " var y = null;" + " if (y != null) {" + " for (var i = 0; i < 10; i++) {" + " f(y);" + " }" + " }" + "};", "condition always evaluates to false\n" + "left : null\n" + "right: null"); } public void testSwitchCase3() throws Exception { testTypes("/** @type String */" + "var a = new String('foo');" + "switch (a) { case 'A': }"); } public void testSwitchCase4() throws Exception { testTypes("/** @type {(string,Null)} */" + "var a = 'foo';" + "switch (a) { case 'A':break; case null:break; }"); } public void testSwitchCase5() throws Exception { testTypes("/** @type {(String,Null)} */" + "var a = new String('foo');" + "switch (a) { case 'A':break; case null:break; }"); } public void testSwitchCase6() throws Exception { testTypes("/** @type {(Number,Null)} */" + "var a = new Number(5);" + "switch (a) { case 5:break; case null:break; }"); } public void testSwitchCase7() throws Exception { // This really tests the inference inside the case. testTypes( "/**\n" + " * @param {number} x\n" + " * @return {number}\n" + " */\n" + "function g(x) { return 5; }" + "function f() {" + " var x = {};" + " x.foo = '3';" + " switch (3) { case g(x.foo): return 3; }" + "}", "actual parameter 1 of g does not match formal parameter\n" + "found : string\n" + "required: number"); } public void testSwitchCase8() throws Exception { // This really tests the inference inside the switch clause. testTypes( "/**\n" + " * @param {number} x\n" + " * @return {number}\n" + " */\n" + "function g(x) { return 5; }" + "function f() {" + " var x = {};" + " x.foo = '3';" + " switch (g(x.foo)) { case 3: return 3; }" + "}", "actual parameter 1 of g does not match formal parameter\n" + "found : string\n" + "required: number"); } public void testNoTypeCheck1() throws Exception { testTypes("/** @notypecheck */function foo() { new 4 }"); } public void testNoTypeCheck2() throws Exception { testTypes("/** @notypecheck */var foo = function() { new 4 }"); } public void testNoTypeCheck3() throws Exception { testTypes("/** @notypecheck */var foo = function bar() { new 4 }"); } public void testNoTypeCheck4() throws Exception { testTypes("var foo;" + "/** @notypecheck */foo = function() { new 4 }"); } public void testNoTypeCheck5() throws Exception { testTypes("var foo;" + "foo = /** @notypecheck */function() { new 4 }"); } public void testNoTypeCheck6() throws Exception { testTypes("var foo;" + "/** @notypecheck */foo = function bar() { new 4 }"); } public void testNoTypeCheck7() throws Exception { testTypes("var foo;" + "foo = /** @notypecheck */function bar() { new 4 }"); } public void testNoTypeCheck8() throws Exception { testTypes("/** @fileoverview \n * @notypecheck */ var foo;" + "var bar = 3; /** @param {string} x */ function f(x) {} f(bar);"); } public void testNoTypeCheck9() throws Exception { testTypes("/** @notypecheck */ function g() { }" + " /** @type {string} */ var a = 1", "initializing variable\n" + "found : number\n" + "required: string" ); } public void testNoTypeCheck10() throws Exception { testTypes("/** @notypecheck */ function g() { }" + " function h() {/** @type {string} */ var a = 1}", "initializing variable\n" + "found : number\n" + "required: string" ); } public void testNoTypeCheck11() throws Exception { testTypes("/** @notypecheck */ function g() { }" + "/** @notypecheck */ function h() {/** @type {string} */ var a = 1}" ); } public void testNoTypeCheck12() throws Exception { testTypes("/** @notypecheck */ function g() { }" + "function h() {/** @type {string}\n * @notypecheck\n*/ var a = 1}" ); } public void testNoTypeCheck13() throws Exception { testTypes("/** @notypecheck */ function g() { }" + "function h() {/** @type {string}\n * @notypecheck\n*/ var a = 1;" + "/** @type {string}*/ var b = 1}", "initializing variable\n" + "found : number\n" + "required: string" ); } public void testNoTypeCheck14() throws Exception { testTypes("/** @fileoverview \n * @notypecheck */ function g() { }" + "g(1,2,3)"); } public void testImplicitCast() throws Exception { testTypes("/** @constructor */ function Element() {};\n" + "/** @type {string}\n" + " * @implicitCast */" + "Element.prototype.innerHTML;", "(new Element).innerHTML = new Array();", null, false); } public void testImplicitCastSubclassAccess() throws Exception { testTypes("/** @constructor */ function Element() {};\n" + "/** @type {string}\n" + " * @implicitCast */" + "Element.prototype.innerHTML;" + "/** @constructor \n @extends Element */" + "function DIVElement() {};", "(new DIVElement).innerHTML = new Array();", null, false); } public void testImplicitCastNotInExterns() throws Exception { testTypes("/** @constructor */ function Element() {};\n" + "/** @type {string}\n" + " * @implicitCast */" + "Element.prototype.innerHTML;" + "(new Element).innerHTML = new Array();", new String[] { "Illegal annotation on innerHTML. @implicitCast may only be " + "used in externs.", "assignment to property innerHTML of Element\n" + "found : Array\n" + "required: string"}); } public void testNumberNode() throws Exception { Node n = typeCheck(Node.newNumber(0)); assertTypeEquals(NUMBER_TYPE, n.getJSType()); } public void testStringNode() throws Exception { Node n = typeCheck(Node.newString("hello")); assertTypeEquals(STRING_TYPE, n.getJSType()); } public void testBooleanNodeTrue() throws Exception { Node trueNode = typeCheck(new Node(Token.TRUE)); assertTypeEquals(BOOLEAN_TYPE, trueNode.getJSType()); } public void testBooleanNodeFalse() throws Exception { Node falseNode = typeCheck(new Node(Token.FALSE)); assertTypeEquals(BOOLEAN_TYPE, falseNode.getJSType()); } public void testUndefinedNode() throws Exception { Node p = new Node(Token.ADD); Node n = Node.newString(Token.NAME, "undefined"); p.addChildToBack(n); p.addChildToBack(Node.newNumber(5)); typeCheck(p); assertTypeEquals(VOID_TYPE, n.getJSType()); } public void testNumberAutoboxing() throws Exception { testTypes("/** @type Number */var a = 4;", "initializing variable\n" + "found : number\n" + "required: (Number|null)"); } public void testNumberUnboxing() throws Exception { testTypes("/** @type number */var a = new Number(4);", "initializing variable\n" + "found : Number\n" + "required: number"); } public void testStringAutoboxing() throws Exception { testTypes("/** @type String */var a = 'hello';", "initializing variable\n" + "found : string\n" + "required: (String|null)"); } public void testStringUnboxing() throws Exception { testTypes("/** @type string */var a = new String('hello');", "initializing variable\n" + "found : String\n" + "required: string"); } public void testBooleanAutoboxing() throws Exception { testTypes("/** @type Boolean */var a = true;", "initializing variable\n" + "found : boolean\n" + "required: (Boolean|null)"); } public void testBooleanUnboxing() throws Exception { testTypes("/** @type boolean */var a = new Boolean(false);", "initializing variable\n" + "found : Boolean\n" + "required: boolean"); } public void testIIFE1() throws Exception { testTypes( "var namespace = {};" + "/** @type {number} */ namespace.prop = 3;" + "(function(ns) {" + " ns.prop = true;" + "})(namespace);", "assignment to property prop of ns\n" + "found : boolean\n" + "required: number"); } public void testIIFE2() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "(function(ctor) {" + " /** @type {boolean} */ ctor.prop = true;" + "})(Foo);" + "/** @return {number} */ function f() { return Foo.prop; }", "inconsistent return type\n" + "found : boolean\n" + "required: number"); } public void testIIFE3() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "(function(ctor) {" + " /** @type {boolean} */ ctor.prop = true;" + "})(Foo);" + "/** @param {number} x */ function f(x) {}" + "f(Foo.prop);", "actual parameter 1 of f does not match formal parameter\n" + "found : boolean\n" + "required: number"); } public void testIIFE4() throws Exception { testTypes( "/** @const */ var namespace = {};" + "(function(ns) {" + " /**\n" + " * @constructor\n" + " * @param {number} x\n" + " */\n" + " ns.Ctor = function(x) {};" + "})(namespace);" + "new namespace.Ctor(true);", "actual parameter 1 of namespace.Ctor " + "does not match formal parameter\n" + "found : boolean\n" + "required: number"); } public void testIIFE5() throws Exception { // TODO(nicksantos): This behavior is currently incorrect. // To handle this case properly, we'll need to change how we handle // type resolution. testTypes( "/** @const */ var namespace = {};" + "(function(ns) {" + " /**\n" + " * @constructor\n" + " */\n" + " ns.Ctor = function() {};" + " /** @type {boolean} */ ns.Ctor.prototype.bar = true;" + "})(namespace);" + "/** @param {namespace.Ctor} x\n" + " * @return {number} */ function f(x) { return x.bar; }", "Bad type annotation. Unknown type namespace.Ctor"); } public void testNotIIFE1() throws Exception { testTypes( "/** @param {number} x */ function f(x) {}" + "/** @param {...?} x */ function g(x) {}" + "g(function(y) { f(y); }, true);"); } public void testIssue61() throws Exception { testTypes( "var ns = {};" + "(function() {" + " /** @param {string} b */" + " ns.a = function(b) {};" + "})();" + "function d() {" + " ns.a(123);" + "}", "actual parameter 1 of ns.a does not match formal parameter\n" + "found : number\n" + "required: string"); } public void testIssue61b() throws Exception { testTypes( "var ns = {};" + "(function() {" + " /** @param {string} b */" + " ns.a = function(b) {};" + "})();" + "ns.a(123);", "actual parameter 1 of ns.a does not match formal parameter\n" + "found : number\n" + "required: string"); } public void testIssue86() throws Exception { testTypes( "/** @interface */ function I() {}" + "/** @return {number} */ I.prototype.get = function(){};" + "/** @constructor \n * @implements {I} */ function F() {}" + "/** @override */ F.prototype.get = function() { return true; };", "inconsistent return type\n" + "found : boolean\n" + "required: number"); } public void testIssue124() throws Exception { testTypes( "var t = null;" + "function test() {" + " if (t != null) { t = null; }" + " t = 1;" + "}"); } public void testIssue124b() throws Exception { testTypes( "var t = null;" + "function test() {" + " if (t != null) { t = null; }" + " t = undefined;" + "}", "condition always evaluates to false\n" + "left : (null|undefined)\n" + "right: null"); } public void testIssue259() throws Exception { testTypes( "/** @param {number} x */ function f(x) {}" + "/** @constructor */" + "var Clock = function() {" + " /** @constructor */" + " this.Date = function() {};" + " f(new this.Date());" + "};", "actual parameter 1 of f does not match formal parameter\n" + "found : this.Date\n" + "required: number"); } public void testIssue301() throws Exception { testTypes( "Array.indexOf = function() {};" + "var s = 'hello';" + "alert(s.toLowerCase.indexOf('1'));", "Property indexOf never defined on String.prototype.toLowerCase"); } public void testIssue368() throws Exception { testTypes( "/** @constructor */ function Foo(){}" + "/**\n" + " * @param {number} one\n" + " * @param {string} two\n" + " */\n" + "Foo.prototype.add = function(one, two) {};" + "/**\n" + " * @constructor\n" + " * @extends {Foo}\n" + " */\n" + "function Bar(){}" + "/** @override */\n" + "Bar.prototype.add = function(ignored) {};" + "(new Bar()).add(1, 2);", "actual parameter 2 of Bar.prototype.add does not match formal parameter\n" + "found : number\n" + "required: string"); } public void testIssue380() throws Exception { testTypes( "/** @type { function(string): {innerHTML: string} } */\n" + "document.getElementById;\n" + "var list = /** @type {!Array.<string>} */ ['hello', 'you'];\n" + "list.push('?');\n" + "document.getElementById('node').innerHTML = list.toString();", // Parse warning, but still applied. "Type annotations are not allowed here. " + "Are you missing parentheses?"); } public void testIssue483() throws Exception { testTypes( "/** @constructor */ function C() {" + " /** @type {?Array} */ this.a = [];" + "}" + "C.prototype.f = function() {" + " if (this.a.length > 0) {" + " g(this.a);" + " }" + "};" + "/** @param {number} a */ function g(a) {}", "actual parameter 1 of g does not match formal parameter\n" + "found : Array\n" + "required: number"); } public void testIssue537a() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "Foo.prototype = {method: function() {}};" + "/**\n" + " * @constructor\n" + " * @extends {Foo}\n" + " */\n" + "function Bar() {" + " Foo.call(this);" + " if (this.baz()) this.method(1);" + "}" + "Bar.prototype = {" + " baz: function() {" + " return true;" + " }" + "};" + "Bar.prototype.__proto__ = Foo.prototype;", "Function Foo.prototype.method: called with 1 argument(s). " + "Function requires at least 0 argument(s) " + "and no more than 0 argument(s)."); } public void testIssue537b() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "Foo.prototype = {method: function() {}};" + "/**\n" + " * @constructor\n" + " * @extends {Foo}\n" + " */\n" + "function Bar() {" + " Foo.call(this);" + " if (this.baz(1)) this.method();" + "}" + "Bar.prototype = {" + " baz: function() {" + " return true;" + " }" + "};" + "Bar.prototype.__proto__ = Foo.prototype;", "Function Bar.prototype.baz: called with 1 argument(s). " + "Function requires at least 0 argument(s) " + "and no more than 0 argument(s)."); } public void testIssue537c() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "/**\n" + " * @constructor\n" + " * @extends {Foo}\n" + " */\n" + "function Bar() {" + " Foo.call(this);" + " if (this.baz2()) alert(1);" + "}" + "Bar.prototype = {" + " baz: function() {" + " return true;" + " }" + "};" + "Bar.prototype.__proto__ = Foo.prototype;", "Property baz2 never defined on Bar"); } public void testIssue537d() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "Foo.prototype = {" + " /** @return {Bar} */ x: function() { new Bar(); }," + " /** @return {Foo} */ y: function() { new Bar(); }" + "};" + "/**\n" + " * @constructor\n" + " * @extends {Foo}\n" + " */\n" + "function Bar() {" + " this.xy = 3;" + "}" + "/** @return {Bar} */ function f() { return new Bar(); }" + "/** @return {Foo} */ function g() { return new Bar(); }" + "Bar.prototype = {" + " /** @return {Bar} */ x: function() { new Bar(); }," + " /** @return {Foo} */ y: function() { new Bar(); }" + "};" + "Bar.prototype.__proto__ = Foo.prototype;"); } public void testIssue586() throws Exception { testTypes( "/** @constructor */" + "var MyClass = function() {};" + "/** @param {boolean} success */" + "MyClass.prototype.fn = function(success) {};" + "MyClass.prototype.test = function() {" + " this.fn();" + " this.fn = function() {};" + "};", "Function MyClass.prototype.fn: called with 0 argument(s). " + "Function requires at least 1 argument(s) " + "and no more than 1 argument(s)."); } public void testIssue635() throws Exception { // TODO(nicksantos): Make this emit a warning, because of the 'this' type. testTypes( "/** @constructor */" + "function F() {}" + "F.prototype.bar = function() { this.baz(); };" + "F.prototype.baz = function() {};" + "/** @constructor */" + "function G() {}" + "G.prototype.bar = F.prototype.bar;"); } public void testIssue635b() throws Exception { testTypes( "/** @constructor */" + "function F() {}" + "/** @constructor */" + "function G() {}" + "/** @type {function(new:G)} */ var x = F;", "initializing variable\n" + "found : function (new:F): undefined\n" + "required: function (new:G): ?"); } public void testIssue669() throws Exception { testTypes( "/** @return {{prop1: (Object|undefined)}} */" + "function f(a) {" + " var results;" + " if (a) {" + " results = {};" + " results.prop1 = {a: 3};" + " } else {" + " results = {prop2: 3};" + " }" + " return results;" + "}"); } public void testIssue688() throws Exception { testTypes( "/** @const */ var SOME_DEFAULT =\n" + " /** @type {TwoNumbers} */ ({first: 1, second: 2});\n" + "/**\n" + "* Class defining an interface with two numbers.\n" + "* @interface\n" + "*/\n" + "function TwoNumbers() {}\n" + "/** @type number */\n" + "TwoNumbers.prototype.first;\n" + "/** @type number */\n" + "TwoNumbers.prototype.second;\n" + "/** @return {number} */ function f() { return SOME_DEFAULT; }", "inconsistent return type\n" + "found : (TwoNumbers|null)\n" + "required: number"); } public void testIssue700() throws Exception { testTypes( "/**\n" + " * @param {{text: string}} opt_data\n" + " * @return {string}\n" + " */\n" + "function temp1(opt_data) {\n" + " return opt_data.text;\n" + "}\n" + "\n" + "/**\n" + " * @param {{activity: (boolean|number|string|null|Object)}} opt_data\n" + " * @return {string}\n" + " */\n" + "function temp2(opt_data) {\n" + " /** @notypecheck */\n" + " function __inner() {\n" + " return temp1(opt_data.activity);\n" + " }\n" + " return __inner();\n" + "}\n" + "\n" + "/**\n" + " * @param {{n: number, text: string, b: boolean}} opt_data\n" + " * @return {string}\n" + " */\n" + "function temp3(opt_data) {\n" + " return 'n: ' + opt_data.n + ', t: ' + opt_data.text + '.';\n" + "}\n" + "\n" + "function callee() {\n" + " var output = temp3({\n" + " n: 0,\n" + " text: 'a string',\n" + " b: true\n" + " })\n" + " alert(output);\n" + "}\n" + "\n" + "callee();"); } public void testIssue725() throws Exception { testTypes( "/** @typedef {{name: string}} */ var RecordType1;" + "/** @typedef {{name2: string}} */ var RecordType2;" + "/** @param {RecordType1} rec */ function f(rec) {" + " alert(rec.name2);" + "}", "Property name2 never defined on rec"); } public void testIssue726() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "/** @param {number} x */ Foo.prototype.bar = function(x) {};" + "/** @return {!Function} */ " + "Foo.prototype.getDeferredBar = function() { " + " var self = this;" + " return function() {" + " self.bar(true);" + " };" + "};", "actual parameter 1 of Foo.prototype.bar does not match formal parameter\n" + "found : boolean\n" + "required: number"); } public void testIssue765() throws Exception { testTypes( "/** @constructor */" + "var AnotherType = function (parent) {" + " /** @param {string} stringParameter Description... */" + " this.doSomething = function (stringParameter) {};" + "};" + "/** @constructor */" + "var YetAnotherType = function () {" + " this.field = new AnotherType(self);" + " this.testfun=function(stringdata) {" + " this.field.doSomething(null);" + " };" + "};", "actual parameter 1 of AnotherType.doSomething " + "does not match formal parameter\n" + "found : null\n" + "required: string"); } public void testIssue783() throws Exception { testTypes( "/** @constructor */" + "var Type = function () {" + " /** @type {Type} */" + " this.me_ = this;" + "};" + "Type.prototype.doIt = function() {" + " var me = this.me_;" + " for (var i = 0; i < me.unknownProp; i++) {}" + "};", "Property unknownProp never defined on Type"); } public void testIssue791() throws Exception { testTypes( "/** @param {{func: function()}} obj */" + "function test1(obj) {}" + "var fnStruc1 = {};" + "fnStruc1.func = function() {};" + "test1(fnStruc1);"); } public void testIssue810() throws Exception { testTypes( "/** @constructor */" + "var Type = function () {" + "};" + "Type.prototype.doIt = function(obj) {" + " this.prop = obj.unknownProp;" + "};", "Property unknownProp never defined on obj"); } /** * Tests that the || operator is type checked correctly, that is of * the type of the first argument or of the second argument. See * bugid 592170 for more details. */ public void testBug592170() throws Exception { testTypes( "/** @param {Function} opt_f ... */" + "function foo(opt_f) {" + " /** @type {Function} */" + " return opt_f || function () {};" + "}", "Type annotations are not allowed here. Are you missing parentheses?"); } /** * Tests that undefined can be compared shallowly to a value of type * (number,undefined) regardless of the side on which the undefined * value is. */ public void testBug901455() throws Exception { testTypes("/** @return {(number,undefined)} */ function a() { return 3; }" + "var b = undefined === a()"); testTypes("/** @return {(number,undefined)} */ function a() { return 3; }" + "var b = a() === undefined"); } /** * Tests that the match method of strings returns nullable arrays. */ public void testBug908701() throws Exception { testTypes("/** @type {String} */var s = new String('foo');" + "var b = s.match(/a/) != null;"); } /** * Tests that named types play nicely with subtyping. */ public void testBug908625() throws Exception { testTypes("/** @constructor */function A(){}" + "/** @constructor\n * @extends A */function B(){}" + "/** @param {B} b" + "\n @return {(A,undefined)} */function foo(b){return b}"); } /** * Tests that assigning two untyped functions to a variable whose type is * inferred and calling this variable is legal. */ public void testBug911118() throws Exception { // verifying the type assigned to function expressions assigned variables Scope s = parseAndTypeCheckWithScope("var a = function(){};").scope; JSType type = s.getVar("a").getType(); assertEquals("function (): undefined", type.toString()); // verifying the bug example testTypes("function nullFunction() {};" + "var foo = nullFunction;" + "foo = function() {};" + "foo();"); } public void testBug909000() throws Exception { testTypes("/** @constructor */function A(){}\n" + "/** @param {!A} a\n" + "@return {boolean}*/\n" + "function y(a) { return a }", "inconsistent return type\n" + "found : A\n" + "required: boolean"); } public void testBug930117() throws Exception { testTypes( "/** @param {boolean} x */function f(x){}" + "f(null);", "actual parameter 1 of f does not match formal parameter\n" + "found : null\n" + "required: boolean"); } public void testBug1484445() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "/** @type {number?} */ Foo.prototype.bar = null;" + "/** @type {number?} */ Foo.prototype.baz = null;" + "/** @param {Foo} foo */" + "function f(foo) {" + " while (true) {" + " if (foo.bar == null && foo.baz == null) {" + " foo.bar;" + " }" + " }" + "}"); } public void testBug1859535() throws Exception { testTypes( "/**\n" + " * @param {Function} childCtor Child class.\n" + " * @param {Function} parentCtor Parent class.\n" + " */" + "var inherits = function(childCtor, parentCtor) {" + " /** @constructor */" + " function tempCtor() {};" + " tempCtor.prototype = parentCtor.prototype;" + " childCtor.superClass_ = parentCtor.prototype;" + " childCtor.prototype = new tempCtor();" + " /** @override */ childCtor.prototype.constructor = childCtor;" + "};" + "/**" + " * @param {Function} constructor\n" + " * @param {Object} var_args\n" + " * @return {Object}\n" + " */" + "var factory = function(constructor, var_args) {" + " /** @constructor */" + " var tempCtor = function() {};" + " tempCtor.prototype = constructor.prototype;" + " var obj = new tempCtor();" + " constructor.apply(obj, arguments);" + " return obj;" + "};"); } public void testBug1940591() throws Exception { testTypes( "/** @type {Object} */" + "var a = {};\n" + "/** @type {number} */\n" + "a.name = 0;\n" + "/**\n" + " * @param {Function} x anything.\n" + " */\n" + "a.g = function(x) { x.name = 'a'; }"); } public void testBug1942972() throws Exception { testTypes( "var google = {\n" + " gears: {\n" + " factory: {},\n" + " workerPool: {}\n" + " }\n" + "};\n" + "\n" + "google.gears = {factory: {}};\n"); } public void testBug1943776() throws Exception { testTypes( "/** @return {{foo: Array}} */" + "function bar() {" + " return {foo: []};" + "}"); } public void testBug1987544() throws Exception { testTypes( "/** @param {string} x */ function foo(x) {}" + "var duration;" + "if (true && !(duration = 3)) {" + " foo(duration);" + "}", "actual parameter 1 of foo does not match formal parameter\n" + "found : number\n" + "required: string"); } public void testBug1940769() throws Exception { testTypes( "/** @return {!Object} */ " + "function proto(obj) { return obj.prototype; }" + "/** @constructor */ function Map() {}" + "/**\n" + " * @constructor\n" + " * @extends {Map}\n" + " */" + "function Map2() { Map.call(this); };" + "Map2.prototype = proto(Map);"); } public void testBug2335992() throws Exception { testTypes( "/** @return {*} */ function f() { return 3; }" + "var x = f();" + "/** @type {string} */" + "x.y = 3;", "assignment\n" + "found : number\n" + "required: string"); } public void testBug2341812() throws Exception { testTypes( "/** @interface */" + "function EventTarget() {}" + "/** @constructor \n * @implements {EventTarget} */" + "function Node() {}" + "/** @type {number} */ Node.prototype.index;" + "/** @param {EventTarget} x \n * @return {string} */" + "function foo(x) { return x.index; }"); } public void testBug7701884() throws Exception { testTypes( "/**\n" + " * @param {Array.<T>} x\n" + " * @param {function(T)} y\n" + " * @template T\n" + " */\n" + "var forEach = function(x, y) {\n" + " for (var i = 0; i < x.length; i++) y(x[i]);\n" + "};" + "/** @param {number} x */" + "function f(x) {}" + "/** @param {?} x */" + "function h(x) {" + " var top = null;" + " forEach(x, function(z) { top = z; });" + " if (top) f(top);" + "}"); } public void testScopedConstructors1() throws Exception { testTypes( "function foo1() { " + " /** @constructor */ function Bar() { " + " /** @type {number} */ this.x = 3;" + " }" + "}" + "function foo2() { " + " /** @constructor */ function Bar() { " + " /** @type {string} */ this.x = 'y';" + " }" + " /** " + " * @param {Bar} b\n" + " * @return {number}\n" + " */" + " function baz(b) { return b.x; }" + "}", "inconsistent return type\n" + "found : string\n" + "required: number"); } public void testScopedConstructors2() throws Exception { testTypes( "/** @param {Function} f */" + "function foo1(f) {" + " /** @param {Function} g */" + " f.prototype.bar = function(g) {};" + "}"); } public void testQualifiedNameInference1() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "/** @type {number?} */ Foo.prototype.bar = null;" + "/** @type {number?} */ Foo.prototype.baz = null;" + "/** @param {Foo} foo */" + "function f(foo) {" + " while (true) {" + " if (!foo.baz) break; " + " foo.bar = null;" + " }" + // Tests a bug where this condition always evaluated to true. " return foo.bar == null;" + "}"); } public void testQualifiedNameInference2() throws Exception { testTypes( "var x = {};" + "x.y = c;" + "function f(a, b) {" + " if (a) {" + " if (b) " + " x.y = 2;" + " else " + " x.y = 1;" + " }" + " return x.y == null;" + "}"); } public void testQualifiedNameInference3() throws Exception { testTypes( "var x = {};" + "x.y = c;" + "function f(a, b) {" + " if (a) {" + " if (b) " + " x.y = 2;" + " else " + " x.y = 1;" + " }" + " return x.y == null;" + "} function g() { x.y = null; }"); } public void testQualifiedNameInference4() throws Exception { testTypes( "/** @param {string} x */ function f(x) {}\n" + "/**\n" + " * @param {?string} x \n" + " * @constructor\n" + " */" + "function Foo(x) { this.x_ = x; }\n" + "Foo.prototype.bar = function() {" + " if (this.x_) { f(this.x_); }" + "};"); } public void testQualifiedNameInference5() throws Exception { testTypes( "var ns = {}; " + "(function() { " + " /** @param {number} x */ ns.foo = function(x) {}; })();" + "(function() { ns.foo(true); })();", "actual parameter 1 of ns.foo does not match formal parameter\n" + "found : boolean\n" + "required: number"); } public void testQualifiedNameInference6() throws Exception { testTypes( "/** @const */ var ns = {}; " + "/** @param {number} x */ ns.foo = function(x) {};" + "(function() { " + " ns.foo = function(x) {};" + " ns.foo(true); " + "})();", "actual parameter 1 of ns.foo does not match formal parameter\n" + "found : boolean\n" + "required: number"); } public void testQualifiedNameInference7() throws Exception { testTypes( "var ns = {}; " + "(function() { " + " /** @constructor \n * @param {number} x */ " + " ns.Foo = function(x) {};" + " /** @param {ns.Foo} x */ function f(x) {}" + " f(new ns.Foo(true));" + "})();", "actual parameter 1 of ns.Foo does not match formal parameter\n" + "found : boolean\n" + "required: number"); } public void testQualifiedNameInference8() throws Exception { // We may need to reshuffle name resolution order so that the @param // type resolves correctly. testClosureTypesMultipleWarnings( "var ns = {}; " + "(function() { " + " /** @constructor \n * @param {number} x */ " + " ns.Foo = function(x) {};" + "})();" + "/** @param {ns.Foo} x */ function f(x) {}" + "f(new ns.Foo(true));", Lists.newArrayList( "Bad type annotation. Unknown type ns.Foo", "actual parameter 1 of ns.Foo does not match formal parameter\n" + "found : boolean\n" + "required: number")); } public void testQualifiedNameInference9() throws Exception { testTypes( "var ns = {}; " + "ns.ns2 = {}; " + "(function() { " + " /** @constructor \n * @param {number} x */ " + " ns.ns2.Foo = function(x) {};" + " /** @param {ns.ns2.Foo} x */ function f(x) {}" + " f(new ns.ns2.Foo(true));" + "})();", "actual parameter 1 of ns.ns2.Foo does not match formal parameter\n" + "found : boolean\n" + "required: number"); } public void testQualifiedNameInference10() throws Exception { testTypes( "var ns = {}; " + "ns.ns2 = {}; " + "(function() { " + " /** @interface */ " + " ns.ns2.Foo = function() {};" + " /** @constructor \n * @implements {ns.ns2.Foo} */ " + " function F() {}" + " (new F());" + "})();"); } public void testQualifiedNameInference11() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "function f() {" + " var x = new Foo();" + " x.onload = function() {" + " x.onload = null;" + " };" + "}"); } public void testQualifiedNameInference12() throws Exception { // We should be able to tell that the two 'this' properties // are different. testTypes( "/** @param {function(this:Object)} x */ function f(x) {}" + "/** @constructor */ function Foo() {" + " /** @type {number} */ this.bar = 3;" + " f(function() { this.bar = true; });" + "}"); } public void testQualifiedNameInference13() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "function f(z) {" + " var x = new Foo();" + " if (z) {" + " x.onload = function() {};" + " } else {" + " x.onload = null;" + " };" + "}"); } public void testSheqRefinedScope() throws Exception { Node n = parseAndTypeCheck( "/** @constructor */function A() {}\n" + "/** @constructor \n @extends A */ function B() {}\n" + "/** @return {number} */\n" + "B.prototype.p = function() { return 1; }\n" + "/** @param {A} a\n @param {B} b */\n" + "function f(a, b) {\n" + " b.p();\n" + " if (a === b) {\n" + " b.p();\n" + " }\n" + "}"); Node nodeC = n.getLastChild().getLastChild().getLastChild().getLastChild() .getLastChild().getLastChild(); JSType typeC = nodeC.getJSType(); assertTrue(typeC.isNumber()); Node nodeB = nodeC.getFirstChild().getFirstChild(); JSType typeB = nodeB.getJSType(); assertEquals("B", typeB.toString()); } public void testAssignToUntypedVariable() throws Exception { Node n = parseAndTypeCheck("var z; z = 1;"); Node assign = n.getLastChild().getFirstChild(); Node node = assign.getFirstChild(); assertFalse(node.getJSType().isUnknownType()); assertEquals("number", node.getJSType().toString()); } public void testAssignToUntypedProperty() throws Exception { Node n = parseAndTypeCheck( "/** @constructor */ function Foo() {}\n" + "Foo.prototype.a = 1;" + "(new Foo).a;"); Node node = n.getLastChild().getFirstChild(); assertFalse(node.getJSType().isUnknownType()); assertTrue(node.getJSType().isNumber()); } public void testNew1() throws Exception { testTypes("new 4", TypeCheck.NOT_A_CONSTRUCTOR); } public void testNew2() throws Exception { testTypes("var Math = {}; new Math()", TypeCheck.NOT_A_CONSTRUCTOR); } public void testNew3() throws Exception { testTypes("new Date()"); } public void testNew4() throws Exception { testTypes("/** @constructor */function A(){}; new A();"); } public void testNew5() throws Exception { testTypes("function A(){}; new A();", TypeCheck.NOT_A_CONSTRUCTOR); } public void testNew6() throws Exception { TypeCheckResult p = parseAndTypeCheckWithScope("/** @constructor */function A(){};" + "var a = new A();"); JSType aType = p.scope.getVar("a").getType(); assertTrue(aType instanceof ObjectType); ObjectType aObjectType = (ObjectType) aType; assertEquals("A", aObjectType.getConstructor().getReferenceName()); } public void testNew7() throws Exception { testTypes("/** @param {Function} opt_constructor */" + "function foo(opt_constructor) {" + "if (opt_constructor) { new opt_constructor; }" + "}"); } public void testNew8() throws Exception { testTypes("/** @param {Function} opt_constructor */" + "function foo(opt_constructor) {" + "new opt_constructor;" + "}"); } public void testNew9() throws Exception { testTypes("/** @param {Function} opt_constructor */" + "function foo(opt_constructor) {" + "new (opt_constructor || Array);" + "}"); } public void testNew10() throws Exception { testTypes("var goog = {};" + "/** @param {Function} opt_constructor */" + "goog.Foo = function (opt_constructor) {" + "new (opt_constructor || Array);" + "}"); } public void testNew11() throws Exception { testTypes("/** @param {Function} c1 */" + "function f(c1) {" + " var c2 = function(){};" + " c1.prototype = new c2;" + "}", TypeCheck.NOT_A_CONSTRUCTOR); } public void testNew12() throws Exception { TypeCheckResult p = parseAndTypeCheckWithScope("var a = new Array();"); Var a = p.scope.getVar("a"); assertTypeEquals(ARRAY_TYPE, a.getType()); } public void testNew13() throws Exception { TypeCheckResult p = parseAndTypeCheckWithScope( "/** @constructor */function FooBar(){};" + "var a = new FooBar();"); Var a = p.scope.getVar("a"); assertTrue(a.getType() instanceof ObjectType); assertEquals("FooBar", a.getType().toString()); } public void testNew14() throws Exception { TypeCheckResult p = parseAndTypeCheckWithScope( "/** @constructor */var FooBar = function(){};" + "var a = new FooBar();"); Var a = p.scope.getVar("a"); assertTrue(a.getType() instanceof ObjectType); assertEquals("FooBar", a.getType().toString()); } public void testNew15() throws Exception { TypeCheckResult p = parseAndTypeCheckWithScope( "var goog = {};" + "/** @constructor */goog.A = function(){};" + "var a = new goog.A();"); Var a = p.scope.getVar("a"); assertTrue(a.getType() instanceof ObjectType); assertEquals("goog.A", a.getType().toString()); } public void testNew16() throws Exception { testTypes( "/** \n" + " * @param {string} x \n" + " * @constructor \n" + " */" + "function Foo(x) {}" + "function g() { new Foo(1); }", "actual parameter 1 of Foo does not match formal parameter\n" + "found : number\n" + "required: string"); } public void testNew17() throws Exception { testTypes("var goog = {}; goog.x = 3; new goog.x", "cannot instantiate non-constructor"); } public void testNew18() throws Exception { testTypes("var goog = {};" + "/** @constructor */ goog.F = function() {};" + "/** @constructor */ goog.G = goog.F;"); } public void testName1() throws Exception { assertTypeEquals(VOID_TYPE, testNameNode("undefined")); } public void testName2() throws Exception { assertTypeEquals(OBJECT_FUNCTION_TYPE, testNameNode("Object")); } public void testName3() throws Exception { assertTypeEquals(ARRAY_FUNCTION_TYPE, testNameNode("Array")); } public void testName4() throws Exception { assertTypeEquals(DATE_FUNCTION_TYPE, testNameNode("Date")); } public void testName5() throws Exception { assertTypeEquals(REGEXP_FUNCTION_TYPE, testNameNode("RegExp")); } /** * Type checks a NAME node and retrieve its type. */ private JSType testNameNode(String name) { Node node = Node.newString(Token.NAME, name); Node parent = new Node(Token.SCRIPT, node); parent.setInputId(new InputId("code")); Node externs = new Node(Token.SCRIPT); externs.setInputId(new InputId("externs")); Node externAndJsRoot = new Node(Token.BLOCK, externs, parent); externAndJsRoot.setIsSyntheticBlock(true); makeTypeCheck().processForTesting(null, parent); return node.getJSType(); } public void testBitOperation1() throws Exception { testTypes("/**@return {void}*/function foo(){ ~foo(); }", "operator ~ cannot be applied to undefined"); } public void testBitOperation2() throws Exception { testTypes("/**@return {void}*/function foo(){var a = foo()<<3;}", "operator << cannot be applied to undefined"); } public void testBitOperation3() throws Exception { testTypes("/**@return {void}*/function foo(){var a = 3<<foo();}", "operator << cannot be applied to undefined"); } public void testBitOperation4() throws Exception { testTypes("/**@return {void}*/function foo(){var a = foo()>>>3;}", "operator >>> cannot be applied to undefined"); } public void testBitOperation5() throws Exception { testTypes("/**@return {void}*/function foo(){var a = 3>>>foo();}", "operator >>> cannot be applied to undefined"); } public void testBitOperation6() throws Exception { testTypes("/**@return {!Object}*/function foo(){var a = foo()&3;}", "bad left operand to bitwise operator\n" + "found : Object\n" + "required: (boolean|null|number|string|undefined)"); } public void testBitOperation7() throws Exception { testTypes("var x = null; x |= undefined; x &= 3; x ^= '3'; x |= true;"); } public void testBitOperation8() throws Exception { testTypes("var x = void 0; x |= new Number(3);"); } public void testBitOperation9() throws Exception { testTypes("var x = void 0; x |= {};", "bad right operand to bitwise operator\n" + "found : {}\n" + "required: (boolean|null|number|string|undefined)"); } public void testCall1() throws Exception { testTypes("3();", "number expressions are not callable"); } public void testCall2() throws Exception { testTypes("/** @param {!Number} foo*/function bar(foo){ bar('abc'); }", "actual parameter 1 of bar does not match formal parameter\n" + "found : string\n" + "required: Number"); } public void testCall3() throws Exception { // We are checking that an unresolved named type can successfully // meet with a functional type to produce a callable type. testTypes("/** @type {Function|undefined} */var opt_f;" + "/** @type {some.unknown.type} */var f1;" + "var f2 = opt_f || f1;" + "f2();", "Bad type annotation. Unknown type some.unknown.type"); } public void testCall4() throws Exception { testTypes("/**@param {!RegExp} a*/var foo = function bar(a){ bar('abc'); }", "actual parameter 1 of bar does not match formal parameter\n" + "found : string\n" + "required: RegExp"); } public void testCall5() throws Exception { testTypes("/**@param {!RegExp} a*/var foo = function bar(a){ foo('abc'); }", "actual parameter 1 of foo does not match formal parameter\n" + "found : string\n" + "required: RegExp"); } public void testCall6() throws Exception { testTypes("/** @param {!Number} foo*/function bar(foo){}" + "bar('abc');", "actual parameter 1 of bar does not match formal parameter\n" + "found : string\n" + "required: Number"); } public void testCall7() throws Exception { testTypes("/** @param {!RegExp} a*/var foo = function bar(a){};" + "foo('abc');", "actual parameter 1 of foo does not match formal parameter\n" + "found : string\n" + "required: RegExp"); } public void testCall8() throws Exception { testTypes("/** @type {Function|number} */var f;f();", "(Function|number) expressions are " + "not callable"); } public void testCall9() throws Exception { testTypes( "var goog = {};" + "/** @constructor */ goog.Foo = function() {};" + "/** @param {!goog.Foo} a */ var bar = function(a){};" + "bar('abc');", "actual parameter 1 of bar does not match formal parameter\n" + "found : string\n" + "required: goog.Foo"); } public void testCall10() throws Exception { testTypes("/** @type {Function} */var f;f();"); } public void testCall11() throws Exception { testTypes("var f = new Function(); f();"); } public void testFunctionCall1() throws Exception { testTypes( "/** @param {number} x */ var foo = function(x) {};" + "foo.call(null, 3);"); } public void testFunctionCall2() throws Exception { testTypes( "/** @param {number} x */ var foo = function(x) {};" + "foo.call(null, 'bar');", "actual parameter 2 of foo.call does not match formal parameter\n" + "found : string\n" + "required: number"); } public void testFunctionCall3() throws Exception { testTypes( "/** @param {number} x \n * @constructor */ " + "var Foo = function(x) { this.bar.call(null, x); };" + "/** @type {function(number)} */ Foo.prototype.bar;"); } public void testFunctionCall4() throws Exception { testTypes( "/** @param {string} x \n * @constructor */ " + "var Foo = function(x) { this.bar.call(null, x); };" + "/** @type {function(number)} */ Foo.prototype.bar;", "actual parameter 2 of this.bar.call " + "does not match formal parameter\n" + "found : string\n" + "required: number"); } public void testFunctionCall5() throws Exception { testTypes( "/** @param {Function} handler \n * @constructor */ " + "var Foo = function(handler) { handler.call(this, x); };"); } public void testFunctionCall6() throws Exception { testTypes( "/** @param {Function} handler \n * @constructor */ " + "var Foo = function(handler) { handler.apply(this, x); };"); } public void testFunctionCall7() throws Exception { testTypes( "/** @param {Function} handler \n * @param {Object} opt_context */ " + "var Foo = function(handler, opt_context) { " + " handler.call(opt_context, x);" + "};"); } public void testFunctionCall8() throws Exception { testTypes( "/** @param {Function} handler \n * @param {Object} opt_context */ " + "var Foo = function(handler, opt_context) { " + " handler.apply(opt_context, x);" + "};"); } public void testFunctionBind1() throws Exception { testTypes( "/** @type {function(string, number): boolean} */" + "function f(x, y) { return true; }" + "f.bind(null, 3);", "actual parameter 2 of f.bind does not match formal parameter\n" + "found : number\n" + "required: string"); } public void testFunctionBind2() throws Exception { testTypes( "/** @type {function(number): boolean} */" + "function f(x) { return true; }" + "f(f.bind(null, 3)());", "actual parameter 1 of f does not match formal parameter\n" + "found : boolean\n" + "required: number"); } public void testFunctionBind3() throws Exception { testTypes( "/** @type {function(number, string): boolean} */" + "function f(x, y) { return true; }" + "f.bind(null, 3)(true);", "actual parameter 1 of function does not match formal parameter\n" + "found : boolean\n" + "required: string"); } public void testFunctionBind4() throws Exception { testTypes( "/** @param {...number} x */" + "function f(x) {}" + "f.bind(null, 3, 3, 3)(true);", "actual parameter 1 of function does not match formal parameter\n" + "found : boolean\n" + "required: (number|undefined)"); } public void testFunctionBind5() throws Exception { testTypes( "/** @param {...number} x */" + "function f(x) {}" + "f.bind(null, true)(3, 3, 3);", "actual parameter 2 of f.bind does not match formal parameter\n" + "found : boolean\n" + "required: (number|undefined)"); } public void testGoogBind1() throws Exception { testClosureTypes( "var goog = {}; goog.bind = function(var_args) {};" + "/** @type {function(number): boolean} */" + "function f(x, y) { return true; }" + "f(goog.bind(f, null, 'x')());", "actual parameter 1 of f does not match formal parameter\n" + "found : boolean\n" + "required: number"); } public void testGoogBind2() throws Exception { // TODO(nicksantos): We do not currently type-check the arguments // of the goog.bind. testClosureTypes( "var goog = {}; goog.bind = function(var_args) {};" + "/** @type {function(boolean): boolean} */" + "function f(x, y) { return true; }" + "f(goog.bind(f, null, 'x')());", null); } public void testCast2() throws Exception { // can upcast to a base type. testTypes("/** @constructor */function base() {}\n" + "/** @constructor\n @extends {base} */function derived() {}\n" + "/** @type {base} */ var baz = new derived();\n"); } public void testCast3() throws Exception { // cannot downcast testTypes("/** @constructor */function base() {}\n" + "/** @constructor @extends {base} */function derived() {}\n" + "/** @type {!derived} */ var baz = new base();\n", "initializing variable\n" + "found : base\n" + "required: derived"); } public void testCast3a() throws Exception { // cannot downcast testTypes("/** @constructor */function Base() {}\n" + "/** @constructor @extends {Base} */function Derived() {}\n" + "var baseInstance = new Base();" + "/** @type {!Derived} */ var baz = baseInstance;\n", "initializing variable\n" + "found : Base\n" + "required: Derived"); } public void testCast4() throws Exception { // downcast must be explicit testTypes("/** @constructor */function base() {}\n" + "/** @constructor\n * @extends {base} */function derived() {}\n" + "/** @type {!derived} */ var baz = " + "/** @type {!derived} */(new base());\n"); } public void testCast5() throws Exception { // cannot explicitly cast to an unrelated type testTypes("/** @constructor */function foo() {}\n" + "/** @constructor */function bar() {}\n" + "var baz = /** @type {!foo} */(new bar);\n", "invalid cast - must be a subtype or supertype\n" + "from: bar\n" + "to : foo"); } public void testCast5a() throws Exception { // cannot explicitly cast to an unrelated type testTypes("/** @constructor */function foo() {}\n" + "/** @constructor */function bar() {}\n" + "var barInstance = new bar;\n" + "var baz = /** @type {!foo} */(barInstance);\n", "invalid cast - must be a subtype or supertype\n" + "from: bar\n" + "to : foo"); } public void testCast6() throws Exception { // can explicitly cast to a subtype or supertype testTypes("/** @constructor */function foo() {}\n" + "/** @constructor \n @extends foo */function bar() {}\n" + "var baz = /** @type {!bar} */(new bar);\n" + "var baz = /** @type {!foo} */(new foo);\n" + "var baz = /** @type {bar} */(new bar);\n" + "var baz = /** @type {foo} */(new foo);\n" + "var baz = /** @type {!foo} */(new bar);\n" + "var baz = /** @type {!bar} */(new foo);\n" + "var baz = /** @type {foo} */(new bar);\n" + "var baz = /** @type {bar} */(new foo);\n"); } public void testCast7() throws Exception { testTypes("var x = /** @type {foo} */ (new Object());", "Bad type annotation. Unknown type foo"); } public void testCast8() throws Exception { testTypes("function f() { return /** @type {foo} */ (new Object()); }", "Bad type annotation. Unknown type foo"); } public void testCast9() throws Exception { testTypes("var foo = {};" + "function f() { return /** @type {foo} */ (new Object()); }", "Bad type annotation. Unknown type foo"); } public void testCast10() throws Exception { testTypes("var foo = function() {};" + "function f() { return /** @type {foo} */ (new Object()); }", "Bad type annotation. Unknown type foo"); } public void testCast11() throws Exception { testTypes("var goog = {}; goog.foo = {};" + "function f() { return /** @type {goog.foo} */ (new Object()); }", "Bad type annotation. Unknown type goog.foo"); } public void testCast12() throws Exception { testTypes("var goog = {}; goog.foo = function() {};" + "function f() { return /** @type {goog.foo} */ (new Object()); }", "Bad type annotation. Unknown type goog.foo"); } public void testCast13() throws Exception { // Test to make sure that the forward-declaration still allows for // a warning. testClosureTypes("var goog = {}; " + "goog.addDependency('zzz.js', ['goog.foo'], []);" + "goog.foo = function() {};" + "function f() { return /** @type {goog.foo} */ (new Object()); }", "Bad type annotation. Unknown type goog.foo"); } public void testCast14() throws Exception { // Test to make sure that the forward-declaration still prevents // some warnings. testClosureTypes("var goog = {}; " + "goog.addDependency('zzz.js', ['goog.bar'], []);" + "function f() { return /** @type {goog.bar} */ (new Object()); }", null); } public void testCast15() throws Exception { // This fixes a bug where a type cast on an object literal // would cause a run-time cast exception if the node was visited // more than once. // // Some code assumes that an object literal must have a object type, // while because of the cast, it could have any type (including // a union). testTypes( "for (var i = 0; i < 10; i++) {" + "var x = /** @type {Object|number} */ ({foo: 3});" + "/** @param {number} x */ function f(x) {}" + "f(x.foo);" + "f([].foo);" + "}", "Property foo never defined on Array"); } public void testCast16() throws Exception { // A type cast should not invalidate the checks on the members testTypes( "for (var i = 0; i < 10; i++) {" + "var x = /** @type {Object|number} */ (" + " {/** @type {string} */ foo: 3});" + "}", "assignment to property foo of Object\n" + "found : number\n" + "required: string"); } public void testCast17a() throws Exception { // Mostly verifying that rhino actually understands these JsDocs. testTypes("/** @constructor */ function Foo() {} \n" + "/** @type {Foo} */ var x = /** @type {Foo} */ (y)"); testTypes("/** @constructor */ function Foo() {} \n" + "/** @type {Foo} */ var x = (/** @type {Foo} */ y)"); } public void testCast17b() throws Exception { // Mostly verifying that rhino actually understands these JsDocs. testTypes("/** @constructor */ function Foo() {} \n" + "/** @type {Foo} */ var x = /** @type {Foo} */ ({})"); } public void testCast18() throws Exception { // Mostly verifying that legacy annotations are applied // despite the parser warning. testTypes("/** @constructor */ function Foo() {} \n" + "/** @type {Foo} */ var x = (/** @type {Foo} */ {})", "Type annotations are not allowed here. " + "Are you missing parentheses?"); // Not really encourage because of possible ambiguity but it works. testTypes("/** @constructor */ function Foo() {} \n" + "/** @type {Foo} */ var x = /** @type {Foo} */ {}", "Type annotations are not allowed here. " + "Are you missing parentheses?"); } public void testCast19() throws Exception { testTypes( "var x = 'string';\n" + "/** @type {number} */\n" + "var y = /** @type {number} */(x);", "invalid cast - must be a subtype or supertype\n" + "from: string\n" + "to : number"); } public void testCast20() throws Exception { testTypes( "/** @enum {boolean|null} */\n" + "var X = {" + " AA: true," + " BB: false," + " CC: null" + "};\n" + "var y = /** @type {X} */(true);"); } public void testCast21() throws Exception { testTypes( "/** @enum {boolean|null} */\n" + "var X = {" + " AA: true," + " BB: false," + " CC: null" + "};\n" + "var value = true;\n" + "var y = /** @type {X} */(value);"); } public void testCast22() throws Exception { testTypes( "var x = null;\n" + "var y = /** @type {number} */(x);", "invalid cast - must be a subtype or supertype\n" + "from: null\n" + "to : number"); } public void testCast23() throws Exception { testTypes( "var x = null;\n" + "var y = /** @type {Number} */(x);"); } public void testCast24() throws Exception { testTypes( "var x = undefined;\n" + "var y = /** @type {number} */(x);", "invalid cast - must be a subtype or supertype\n" + "from: undefined\n" + "to : number"); } public void testCast25() throws Exception { testTypes( "var x = undefined;\n" + "var y = /** @type {number|undefined} */(x);"); } public void testCast26() throws Exception { testTypes( "function fn(dir) {\n" + " var node = dir ? 1 : 2;\n" + " fn(/** @type {number} */ (node));\n" + "}"); } public void testCast27() throws Exception { // C doesn't implement I but a subtype might. testTypes( "/** @interface */ function I() {}\n" + "/** @constructor */ function C() {}\n" + "var x = new C();\n" + "var y = /** @type {I} */(x);"); } public void testCast27a() throws Exception { // C doesn't implement I but a subtype might. testTypes( "/** @interface */ function I() {}\n" + "/** @constructor */ function C() {}\n" + "/** @type {C} */ var x ;\n" + "var y = /** @type {I} */(x);"); } public void testCast28() throws Exception { // C doesn't implement I but a subtype might. testTypes( "/** @interface */ function I() {}\n" + "/** @constructor */ function C() {}\n" + "/** @type {!I} */ var x;\n" + "var y = /** @type {C} */(x);"); } public void testCast28a() throws Exception { // C doesn't implement I but a subtype might. testTypes( "/** @interface */ function I() {}\n" + "/** @constructor */ function C() {}\n" + "/** @type {I} */ var x;\n" + "var y = /** @type {C} */(x);"); } public void testCast29a() throws Exception { // C doesn't implement the record type but a subtype might. testTypes( "/** @constructor */ function C() {}\n" + "var x = new C();\n" + "var y = /** @type {{remoteJids: Array, sessionId: string}} */(x);"); } public void testCast29b() throws Exception { // C doesn't implement the record type but a subtype might. testTypes( "/** @constructor */ function C() {}\n" + "/** @type {C} */ var x;\n" + "var y = /** @type {{prop1: Array, prop2: string}} */(x);"); } public void testCast29c() throws Exception { // C doesn't implement the record type but a subtype might. testTypes( "/** @constructor */ function C() {}\n" + "/** @type {{remoteJids: Array, sessionId: string}} */ var x ;\n" + "var y = /** @type {C} */(x);"); } public void testCast30() throws Exception { // Should be able to cast to a looser return type testTypes( "/** @constructor */ function C() {}\n" + "/** @type {function():string} */ var x ;\n" + "var y = /** @type {function():?} */(x);"); } public void testCast31() throws Exception { // Should be able to cast to a tighter parameter type testTypes( "/** @constructor */ function C() {}\n" + "/** @type {function(*)} */ var x ;\n" + "var y = /** @type {function(string)} */(x);"); } public void testCast32() throws Exception { testTypes( "/** @constructor */ function C() {}\n" + "/** @type {Object} */ var x ;\n" + "var y = /** @type {null|{length:number}} */(x);"); } public void testCast33() throws Exception { // null and void should be assignable to any type that accepts one or the // other or both. testTypes( "/** @constructor */ function C() {}\n" + "/** @type {null|undefined} */ var x ;\n" + "var y = /** @type {string?|undefined} */(x);"); testTypes( "/** @constructor */ function C() {}\n" + "/** @type {null|undefined} */ var x ;\n" + "var y = /** @type {string|undefined} */(x);"); testTypes( "/** @constructor */ function C() {}\n" + "/** @type {null|undefined} */ var x ;\n" + "var y = /** @type {string?} */(x);"); testTypes( "/** @constructor */ function C() {}\n" + "/** @type {null|undefined} */ var x ;\n" + "var y = /** @type {null} */(x);"); } public void testCast34a() throws Exception { testTypes( "/** @constructor */ function C() {}\n" + "/** @type {Object} */ var x ;\n" + "var y = /** @type {Function} */(x);"); } public void testCast34b() throws Exception { testTypes( "/** @constructor */ function C() {}\n" + "/** @type {Function} */ var x ;\n" + "var y = /** @type {Object} */(x);"); } public void testNestedCasts() throws Exception { testTypes("/** @constructor */var T = function() {};\n" + "/** @constructor */var V = function() {};\n" + "/**\n" + "* @param {boolean} b\n" + "* @return {T|V}\n" + "*/\n" + "function f(b) { return b ? new T() : new V(); }\n" + "/**\n" + "* @param {boolean} b\n" + "* @return {boolean|undefined}\n" + "*/\n" + "function g(b) { return b ? true : undefined; }\n" + "/** @return {T} */\n" + "function h() {\n" + "return /** @type {T} */ (f(/** @type {boolean} */ (g(true))));\n" + "}"); } public void testNativeCast1() throws Exception { testTypes( "/** @param {number} x */ function f(x) {}" + "f(String(true));", "actual parameter 1 of f does not match formal parameter\n" + "found : string\n" + "required: number"); } public void testNativeCast2() throws Exception { testTypes( "/** @param {string} x */ function f(x) {}" + "f(Number(true));", "actual parameter 1 of f does not match formal parameter\n" + "found : number\n" + "required: string"); } public void testNativeCast3() throws Exception { testTypes( "/** @param {number} x */ function f(x) {}" + "f(Boolean(''));", "actual parameter 1 of f does not match formal parameter\n" + "found : boolean\n" + "required: number"); } public void testNativeCast4() throws Exception { testTypes( "/** @param {number} x */ function f(x) {}" + "f(Error(''));", "actual parameter 1 of f does not match formal parameter\n" + "found : Error\n" + "required: number"); } public void testBadConstructorCall() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "Foo();", "Constructor function (new:Foo): undefined should be called " + "with the \"new\" keyword"); } public void testTypeof() throws Exception { testTypes("/**@return {void}*/function foo(){ var a = typeof foo(); }"); } public void testTypeof2() throws Exception { testTypes("function f(){ if (typeof 123 == 'numbr') return 321; }", "unknown type: numbr"); } public void testTypeof3() throws Exception { testTypes("function f() {" + "return (typeof 123 == 'number' ||" + "typeof 123 == 'string' ||" + "typeof 123 == 'boolean' ||" + "typeof 123 == 'undefined' ||" + "typeof 123 == 'function' ||" + "typeof 123 == 'object' ||" + "typeof 123 == 'unknown'); }"); } public void testConstructorType1() throws Exception { testTypes("/**@constructor*/function Foo(){}" + "/**@type{!Foo}*/var f = new Date();", "initializing variable\n" + "found : Date\n" + "required: Foo"); } public void testConstructorType2() throws Exception { testTypes("/**@constructor*/function Foo(){\n" + "/**@type{Number}*/this.bar = new Number(5);\n" + "}\n" + "/**@type{Foo}*/var f = new Foo();\n" + "/**@type{Number}*/var n = f.bar;"); } public void testConstructorType3() throws Exception { // Reverse the declaration order so that we know that Foo is getting set // even on an out-of-order declaration sequence. testTypes("/**@type{Foo}*/var f = new Foo();\n" + "/**@type{Number}*/var n = f.bar;" + "/**@constructor*/function Foo(){\n" + "/**@type{Number}*/this.bar = new Number(5);\n" + "}\n"); } public void testConstructorType4() throws Exception { testTypes("/**@constructor*/function Foo(){\n" + "/**@type{!Number}*/this.bar = new Number(5);\n" + "}\n" + "/**@type{!Foo}*/var f = new Foo();\n" + "/**@type{!String}*/var n = f.bar;", "initializing variable\n" + "found : Number\n" + "required: String"); } public void testConstructorType5() throws Exception { testTypes("/**@constructor*/function Foo(){}\n" + "if (Foo){}\n"); } public void testConstructorType6() throws Exception { testTypes("/** @constructor */\n" + "function bar() {}\n" + "function _foo() {\n" + " /** @param {bar} x */\n" + " function f(x) {}\n" + "}"); } public void testConstructorType7() throws Exception { TypeCheckResult p = parseAndTypeCheckWithScope("/** @constructor */function A(){};"); JSType type = p.scope.getVar("A").getType(); assertTrue(type instanceof FunctionType); FunctionType fType = (FunctionType) type; assertEquals("A", fType.getReferenceName()); } public void testConstructorType8() throws Exception { testTypes( "var ns = {};" + "ns.create = function() { return function() {}; };" + "/** @constructor */ ns.Foo = ns.create();" + "ns.Foo.prototype = {x: 0, y: 0};" + "/**\n" + " * @param {ns.Foo} foo\n" + " * @return {string}\n" + " */\n" + "function f(foo) {" + " return foo.x;" + "}", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testConstructorType9() throws Exception { testTypes( "var ns = {};" + "ns.create = function() { return function() {}; };" + "ns.extend = function(x) { return x; };" + "/** @constructor */ ns.Foo = ns.create();" + "ns.Foo.prototype = ns.extend({x: 0, y: 0});" + "/**\n" + " * @param {ns.Foo} foo\n" + " * @return {string}\n" + " */\n" + "function f(foo) {" + " return foo.x;" + "}"); } public void testConstructorType10() throws Exception { testTypes("/** @constructor */" + "function NonStr() {}" + "/**\n" + " * @constructor\n" + " * @struct\n" + " * @extends{NonStr}\n" + " */" + "function NonStrKid() {}", "NonStrKid cannot extend this type; " + "structs can only extend structs"); } public void testConstructorType11() throws Exception { testTypes("/** @constructor */" + "function NonDict() {}" + "/**\n" + " * @constructor\n" + " * @dict\n" + " * @extends{NonDict}\n" + " */" + "function NonDictKid() {}", "NonDictKid cannot extend this type; " + "dicts can only extend dicts"); } public void testConstructorType12() throws Exception { testTypes("/**\n" + " * @constructor\n" + " * @struct\n" + " */\n" + "function Bar() {}\n" + "Bar.prototype = {};\n", "Bar cannot extend this type; " + "structs can only extend structs"); } public void testBadStruct() throws Exception { testTypes("/** @struct */function Struct1() {}", "@struct used without @constructor for Struct1"); } public void testBadDict() throws Exception { testTypes("/** @dict */function Dict1() {}", "@dict used without @constructor for Dict1"); } public void testAnonymousPrototype1() throws Exception { testTypes( "var ns = {};" + "/** @constructor */ ns.Foo = function() {" + " this.bar(3, 5);" + "};" + "ns.Foo.prototype = {" + " bar: function(x) {}" + "};", "Function ns.Foo.prototype.bar: called with 2 argument(s). " + "Function requires at least 1 argument(s) and no more " + "than 1 argument(s)."); } public void testAnonymousPrototype2() throws Exception { testTypes( "/** @interface */ var Foo = function() {};" + "Foo.prototype = {" + " foo: function(x) {}" + "};" + "/**\n" + " * @constructor\n" + " * @implements {Foo}\n" + " */ var Bar = function() {};", "property foo on interface Foo is not implemented by type Bar"); } public void testAnonymousType1() throws Exception { testTypes("function f() { return {}; }" + "/** @constructor */\n" + "f().bar = function() {};"); } public void testAnonymousType2() throws Exception { testTypes("function f() { return {}; }" + "/** @interface */\n" + "f().bar = function() {};"); } public void testAnonymousType3() throws Exception { testTypes("function f() { return {}; }" + "/** @enum */\n" + "f().bar = {FOO: 1};"); } public void testBang1() throws Exception { testTypes("/** @param {Object} x\n@return {!Object} */\n" + "function f(x) { return x; }", "inconsistent return type\n" + "found : (Object|null)\n" + "required: Object"); } public void testBang2() throws Exception { testTypes("/** @param {Object} x\n@return {!Object} */\n" + "function f(x) { return x ? x : new Object(); }"); } public void testBang3() throws Exception { testTypes("/** @param {Object} x\n@return {!Object} */\n" + "function f(x) { return /** @type {!Object} */ (x); }"); } public void testBang4() throws Exception { testTypes("/**@param {Object} x\n@param {Object} y\n@return {boolean}*/\n" + "function f(x, y) {\n" + "if (typeof x != 'undefined') { return x == y; }\n" + "else { return x != y; }\n}"); } public void testBang5() throws Exception { testTypes("/**@param {Object} x\n@param {Object} y\n@return {boolean}*/\n" + "function f(x, y) { return !!x && x == y; }"); } public void testBang6() throws Exception { testTypes("/** @param {Object?} x\n@return {Object} */\n" + "function f(x) { return x; }"); } public void testBang7() throws Exception { testTypes("/**@param {(Object,string,null)} x\n" + "@return {(Object,string)}*/function f(x) { return x; }"); } public void testDefinePropertyOnNullableObject1() throws Exception { testTypes("/** @type {Object} */ var n = {};\n" + "/** @type {number} */ n.x = 1;\n" + "/** @return {boolean} */function f() { return n.x; }", "inconsistent return type\n" + "found : number\n" + "required: boolean"); } public void testDefinePropertyOnNullableObject2() throws Exception { testTypes("/** @constructor */ var T = function() {};\n" + "/** @param {T} t\n@return {boolean} */function f(t) {\n" + "t.x = 1; return t.x; }", "inconsistent return type\n" + "found : number\n" + "required: boolean"); } public void testUnknownConstructorInstanceType1() throws Exception { testTypes("/** @return {Array} */ function g(f) { return new f(); }"); } public void testUnknownConstructorInstanceType2() throws Exception { testTypes("function g(f) { return /** @type Array */(new f()); }"); } public void testUnknownConstructorInstanceType3() throws Exception { testTypes("function g(f) { var x = new f(); x.a = 1; return x; }"); } public void testUnknownPrototypeChain() throws Exception { testTypes("/**\n" + "* @param {Object} co\n" + " * @return {Object}\n" + " */\n" + "function inst(co) {\n" + " /** @constructor */\n" + " var c = function() {};\n" + " c.prototype = co.prototype;\n" + " return new c;\n" + "}"); } public void testNamespacedConstructor() throws Exception { Node root = parseAndTypeCheck( "var goog = {};" + "/** @constructor */ goog.MyClass = function() {};" + "/** @return {!goog.MyClass} */ " + "function foo() { return new goog.MyClass(); }"); JSType typeOfFoo = root.getLastChild().getJSType(); assert(typeOfFoo instanceof FunctionType); JSType retType = ((FunctionType) typeOfFoo).getReturnType(); assert(retType instanceof ObjectType); assertEquals("goog.MyClass", ((ObjectType) retType).getReferenceName()); } public void testComplexNamespace() throws Exception { String js = "var goog = {};" + "goog.foo = {};" + "goog.foo.bar = 5;"; TypeCheckResult p = parseAndTypeCheckWithScope(js); // goog type in the scope JSType googScopeType = p.scope.getVar("goog").getType(); assertTrue(googScopeType instanceof ObjectType); assertTrue("foo property not present on goog type", ((ObjectType) googScopeType).hasProperty("foo")); assertFalse("bar property present on goog type", ((ObjectType) googScopeType).hasProperty("bar")); // goog type on the VAR node Node varNode = p.root.getFirstChild(); assertEquals(Token.VAR, varNode.getType()); JSType googNodeType = varNode.getFirstChild().getJSType(); assertTrue(googNodeType instanceof ObjectType); // goog scope type and goog type on VAR node must be the same assertTrue(googScopeType == googNodeType); // goog type on the left of the GETPROP node (under fist ASSIGN) Node getpropFoo1 = varNode.getNext().getFirstChild().getFirstChild(); assertEquals(Token.GETPROP, getpropFoo1.getType()); assertEquals("goog", getpropFoo1.getFirstChild().getString()); JSType googGetpropFoo1Type = getpropFoo1.getFirstChild().getJSType(); assertTrue(googGetpropFoo1Type instanceof ObjectType); // still the same type as the one on the variable assertTrue(googGetpropFoo1Type == googScopeType); // the foo property should be defined on goog JSType googFooType = ((ObjectType) googScopeType).getPropertyType("foo"); assertTrue(googFooType instanceof ObjectType); // goog type on the left of the GETPROP lower level node // (under second ASSIGN) Node getpropFoo2 = varNode.getNext().getNext() .getFirstChild().getFirstChild().getFirstChild(); assertEquals(Token.GETPROP, getpropFoo2.getType()); assertEquals("goog", getpropFoo2.getFirstChild().getString()); JSType googGetpropFoo2Type = getpropFoo2.getFirstChild().getJSType(); assertTrue(googGetpropFoo2Type instanceof ObjectType); // still the same type as the one on the variable assertTrue(googGetpropFoo2Type == googScopeType); // goog.foo type on the left of the top-level GETPROP node // (under second ASSIGN) JSType googFooGetprop2Type = getpropFoo2.getJSType(); assertTrue("goog.foo incorrectly annotated in goog.foo.bar selection", googFooGetprop2Type instanceof ObjectType); ObjectType googFooGetprop2ObjectType = (ObjectType) googFooGetprop2Type; assertFalse("foo property present on goog.foo type", googFooGetprop2ObjectType.hasProperty("foo")); assertTrue("bar property not present on goog.foo type", googFooGetprop2ObjectType.hasProperty("bar")); assertTypeEquals("bar property on goog.foo type incorrectly inferred", NUMBER_TYPE, googFooGetprop2ObjectType.getPropertyType("bar")); } public void testAddingMethodsUsingPrototypeIdiomSimpleNamespace() throws Exception { Node js1Node = parseAndTypeCheck( "/** @constructor */function A() {}" + "A.prototype.m1 = 5"); ObjectType instanceType = getInstanceType(js1Node); assertEquals(NATIVE_PROPERTIES_COUNT + 1, instanceType.getPropertiesCount()); checkObjectType(instanceType, "m1", NUMBER_TYPE); } public void testAddingMethodsUsingPrototypeIdiomComplexNamespace1() throws Exception { TypeCheckResult p = parseAndTypeCheckWithScope( "var goog = {};" + "goog.A = /** @constructor */function() {};" + "/** @type number */goog.A.prototype.m1 = 5"); testAddingMethodsUsingPrototypeIdiomComplexNamespace(p); } public void testAddingMethodsUsingPrototypeIdiomComplexNamespace2() throws Exception { TypeCheckResult p = parseAndTypeCheckWithScope( "var goog = {};" + "/** @constructor */goog.A = function() {};" + "/** @type number */goog.A.prototype.m1 = 5"); testAddingMethodsUsingPrototypeIdiomComplexNamespace(p); } private void testAddingMethodsUsingPrototypeIdiomComplexNamespace( TypeCheckResult p) { ObjectType goog = (ObjectType) p.scope.getVar("goog").getType(); assertEquals(NATIVE_PROPERTIES_COUNT + 1, goog.getPropertiesCount()); JSType googA = goog.getPropertyType("A"); assertNotNull(googA); assertTrue(googA instanceof FunctionType); FunctionType googAFunction = (FunctionType) googA; ObjectType classA = googAFunction.getInstanceType(); assertEquals(NATIVE_PROPERTIES_COUNT + 1, classA.getPropertiesCount()); checkObjectType(classA, "m1", NUMBER_TYPE); } public void testAddingMethodsPrototypeIdiomAndObjectLiteralSimpleNamespace() throws Exception { Node js1Node = parseAndTypeCheck( "/** @constructor */function A() {}" + "A.prototype = {m1: 5, m2: true}"); ObjectType instanceType = getInstanceType(js1Node); assertEquals(NATIVE_PROPERTIES_COUNT + 2, instanceType.getPropertiesCount()); checkObjectType(instanceType, "m1", NUMBER_TYPE); checkObjectType(instanceType, "m2", BOOLEAN_TYPE); } public void testDontAddMethodsIfNoConstructor() throws Exception { Node js1Node = parseAndTypeCheck( "function A() {}" + "A.prototype = {m1: 5, m2: true}"); JSType functionAType = js1Node.getFirstChild().getJSType(); assertEquals("function (): undefined", functionAType.toString()); assertTypeEquals(UNKNOWN_TYPE, U2U_FUNCTION_TYPE.getPropertyType("m1")); assertTypeEquals(UNKNOWN_TYPE, U2U_FUNCTION_TYPE.getPropertyType("m2")); } public void testFunctionAssignement() throws Exception { testTypes("/**" + "* @param {string} ph0" + "* @param {string} ph1" + "* @return {string}" + "*/" + "function MSG_CALENDAR_ACCESS_ERROR(ph0, ph1) {return ''}" + "/** @type {Function} */" + "var MSG_CALENDAR_ADD_ERROR = MSG_CALENDAR_ACCESS_ERROR;"); } public void testAddMethodsPrototypeTwoWays() throws Exception { Node js1Node = parseAndTypeCheck( "/** @constructor */function A() {}" + "A.prototype = {m1: 5, m2: true};" + "A.prototype.m3 = 'third property!';"); ObjectType instanceType = getInstanceType(js1Node); assertEquals("A", instanceType.toString()); assertEquals(NATIVE_PROPERTIES_COUNT + 3, instanceType.getPropertiesCount()); checkObjectType(instanceType, "m1", NUMBER_TYPE); checkObjectType(instanceType, "m2", BOOLEAN_TYPE); checkObjectType(instanceType, "m3", STRING_TYPE); } public void testPrototypePropertyTypes() throws Exception { Node js1Node = parseAndTypeCheck( "/** @constructor */function A() {\n" + " /** @type string */ this.m1;\n" + " /** @type Object? */ this.m2 = {};\n" + " /** @type boolean */ this.m3;\n" + "}\n" + "/** @type string */ A.prototype.m4;\n" + "/** @type number */ A.prototype.m5 = 0;\n" + "/** @type boolean */ A.prototype.m6;\n"); ObjectType instanceType = getInstanceType(js1Node); assertEquals(NATIVE_PROPERTIES_COUNT + 6, instanceType.getPropertiesCount()); checkObjectType(instanceType, "m1", STRING_TYPE); checkObjectType(instanceType, "m2", createUnionType(OBJECT_TYPE, NULL_TYPE)); checkObjectType(instanceType, "m3", BOOLEAN_TYPE); checkObjectType(instanceType, "m4", STRING_TYPE); checkObjectType(instanceType, "m5", NUMBER_TYPE); checkObjectType(instanceType, "m6", BOOLEAN_TYPE); } public void testValueTypeBuiltInPrototypePropertyType() throws Exception { Node node = parseAndTypeCheck("\"x\".charAt(0)"); assertTypeEquals(STRING_TYPE, node.getFirstChild().getFirstChild().getJSType()); } public void testDeclareBuiltInConstructor() throws Exception { // Built-in prototype properties should be accessible // even if the built-in constructor is declared. Node node = parseAndTypeCheck( "/** @constructor */ var String = function(opt_str) {};\n" + "(new String(\"x\")).charAt(0)"); assertTypeEquals(STRING_TYPE, node.getLastChild().getFirstChild().getJSType()); } public void testExtendBuiltInType1() throws Exception { String externs = "/** @constructor */ var String = function(opt_str) {};\n" + "/**\n" + "* @param {number} start\n" + "* @param {number} opt_length\n" + "* @return {string}\n" + "*/\n" + "String.prototype.substr = function(start, opt_length) {};\n"; Node n1 = parseAndTypeCheck(externs + "(new String(\"x\")).substr(0,1);"); assertTypeEquals(STRING_TYPE, n1.getLastChild().getFirstChild().getJSType()); } public void testExtendBuiltInType2() throws Exception { String externs = "/** @constructor */ var String = function(opt_str) {};\n" + "/**\n" + "* @param {number} start\n" + "* @param {number} opt_length\n" + "* @return {string}\n" + "*/\n" + "String.prototype.substr = function(start, opt_length) {};\n"; Node n2 = parseAndTypeCheck(externs + "\"x\".substr(0,1);"); assertTypeEquals(STRING_TYPE, n2.getLastChild().getFirstChild().getJSType()); } public void testExtendFunction1() throws Exception { Node n = parseAndTypeCheck("/**@return {number}*/Function.prototype.f = " + "function() { return 1; };\n" + "(new Function()).f();"); JSType type = n.getLastChild().getLastChild().getJSType(); assertTypeEquals(NUMBER_TYPE, type); } public void testExtendFunction2() throws Exception { Node n = parseAndTypeCheck("/**@return {number}*/Function.prototype.f = " + "function() { return 1; };\n" + "(function() {}).f();"); JSType type = n.getLastChild().getLastChild().getJSType(); assertTypeEquals(NUMBER_TYPE, type); } public void testInheritanceCheck1() throws Exception { testTypes( "/** @constructor */function Super() {};" + "/** @constructor\n @extends {Super} */function Sub() {};" + "Sub.prototype.foo = function() {};"); } public void testInheritanceCheck2() throws Exception { testTypes( "/** @constructor */function Super() {};" + "/** @constructor\n @extends {Super} */function Sub() {};" + "/** @override */Sub.prototype.foo = function() {};", "property foo not defined on any superclass of Sub"); } public void testInheritanceCheck3() throws Exception { testTypes( "/** @constructor */function Super() {};" + "Super.prototype.foo = function() {};" + "/** @constructor\n @extends {Super} */function Sub() {};" + "Sub.prototype.foo = function() {};", "property foo already defined on superclass Super; " + "use @override to override it"); } public void testInheritanceCheck4() throws Exception { testTypes( "/** @constructor */function Super() {};" + "Super.prototype.foo = function() {};" + "/** @constructor\n @extends {Super} */function Sub() {};" + "/** @override */Sub.prototype.foo = function() {};"); } public void testInheritanceCheck5() throws Exception { testTypes( "/** @constructor */function Root() {};" + "Root.prototype.foo = function() {};" + "/** @constructor\n @extends {Root} */function Super() {};" + "/** @constructor\n @extends {Super} */function Sub() {};" + "Sub.prototype.foo = function() {};", "property foo already defined on superclass Root; " + "use @override to override it"); } public void testInheritanceCheck6() throws Exception { testTypes( "/** @constructor */function Root() {};" + "Root.prototype.foo = function() {};" + "/** @constructor\n @extends {Root} */function Super() {};" + "/** @constructor\n @extends {Super} */function Sub() {};" + "/** @override */Sub.prototype.foo = function() {};"); } public void testInheritanceCheck7() throws Exception { testTypes( "var goog = {};" + "/** @constructor */goog.Super = function() {};" + "goog.Super.prototype.foo = 3;" + "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};" + "goog.Sub.prototype.foo = 5;"); } public void testInheritanceCheck8() throws Exception { testTypes( "var goog = {};" + "/** @constructor */goog.Super = function() {};" + "goog.Super.prototype.foo = 3;" + "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};" + "/** @override */goog.Sub.prototype.foo = 5;"); } public void testInheritanceCheck9_1() throws Exception { testTypes( "/** @constructor */function Super() {};" + "Super.prototype.foo = function() { return 3; };" + "/** @constructor\n @extends {Super} */function Sub() {};" + "/** @override\n @return {number} */Sub.prototype.foo =\n" + "function() { return 1; };"); } public void testInheritanceCheck9_2() throws Exception { testTypes( "/** @constructor */function Super() {};" + "/** @return {number} */" + "Super.prototype.foo = function() { return 1; };" + "/** @constructor\n @extends {Super} */function Sub() {};" + "/** @override */Sub.prototype.foo =\n" + "function() {};"); } public void testInheritanceCheck9_3() throws Exception { testTypes( "/** @constructor */function Super() {};" + "/** @return {number} */" + "Super.prototype.foo = function() { return 1; };" + "/** @constructor\n @extends {Super} */function Sub() {};" + "/** @override\n @return {string} */Sub.prototype.foo =\n" + "function() { return \"some string\" };", "mismatch of the foo property type and the type of the property it " + "overrides from superclass Super\n" + "original: function (this:Super): number\n" + "override: function (this:Sub): string"); } public void testInheritanceCheck10_1() throws Exception { testTypes( "/** @constructor */function Root() {};" + "Root.prototype.foo = function() { return 3; };" + "/** @constructor\n @extends {Root} */function Super() {};" + "/** @constructor\n @extends {Super} */function Sub() {};" + "/** @override\n @return {number} */Sub.prototype.foo =\n" + "function() { return 1; };"); } public void testInheritanceCheck10_2() throws Exception { testTypes( "/** @constructor */function Root() {};" + "/** @return {number} */" + "Root.prototype.foo = function() { return 1; };" + "/** @constructor\n @extends {Root} */function Super() {};" + "/** @constructor\n @extends {Super} */function Sub() {};" + "/** @override */Sub.prototype.foo =\n" + "function() {};"); } public void testInheritanceCheck10_3() throws Exception { testTypes( "/** @constructor */function Root() {};" + "/** @return {number} */" + "Root.prototype.foo = function() { return 1; };" + "/** @constructor\n @extends {Root} */function Super() {};" + "/** @constructor\n @extends {Super} */function Sub() {};" + "/** @override\n @return {string} */Sub.prototype.foo =\n" + "function() { return \"some string\" };", "mismatch of the foo property type and the type of the property it " + "overrides from superclass Root\n" + "original: function (this:Root): number\n" + "override: function (this:Sub): string"); } public void testInterfaceInheritanceCheck11() throws Exception { testTypes( "/** @constructor */function Super() {};" + "/** @param {number} bar */Super.prototype.foo = function(bar) {};" + "/** @constructor\n @extends {Super} */function Sub() {};" + "/** @override\n @param {string} bar */Sub.prototype.foo =\n" + "function(bar) {};", "mismatch of the foo property type and the type of the property it " + "overrides from superclass Super\n" + "original: function (this:Super, number): undefined\n" + "override: function (this:Sub, string): undefined"); } public void testInheritanceCheck12() throws Exception { testTypes( "var goog = {};" + "/** @constructor */goog.Super = function() {};" + "goog.Super.prototype.foo = 3;" + "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};" + "/** @override */goog.Sub.prototype.foo = \"some string\";"); } public void testInheritanceCheck13() throws Exception { testTypes( "var goog = {};\n" + "/** @constructor\n @extends {goog.Missing} */function Sub() {};" + "/** @override */Sub.prototype.foo = function() {};", "Bad type annotation. Unknown type goog.Missing"); } public void testInheritanceCheck14() throws Exception { testClosureTypes( "var goog = {};\n" + "/** @constructor\n @extends {goog.Missing} */\n" + "goog.Super = function() {};\n" + "/** @constructor\n @extends {goog.Super} */function Sub() {};" + "/** @override */Sub.prototype.foo = function() {};", "Bad type annotation. Unknown type goog.Missing"); } public void testInheritanceCheck15() throws Exception { testTypes( "/** @constructor */function Super() {};" + "/** @param {number} bar */Super.prototype.foo;" + "/** @constructor\n @extends {Super} */function Sub() {};" + "/** @override\n @param {number} bar */Sub.prototype.foo =\n" + "function(bar) {};"); } public void testInheritanceCheck16() throws Exception { testTypes( "var goog = {};" + "/** @constructor */goog.Super = function() {};" + "/** @type {number} */ goog.Super.prototype.foo = 3;" + "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};" + "/** @type {number} */ goog.Sub.prototype.foo = 5;", "property foo already defined on superclass goog.Super; " + "use @override to override it"); } public void testInheritanceCheck17() throws Exception { // Make sure this warning still works, even when there's no // @override tag. reportMissingOverrides = CheckLevel.OFF; testTypes( "var goog = {};" + "/** @constructor */goog.Super = function() {};" + "/** @param {number} x */ goog.Super.prototype.foo = function(x) {};" + "/** @constructor\n @extends {goog.Super} */goog.Sub = function() {};" + "/** @param {string} x */ goog.Sub.prototype.foo = function(x) {};", "mismatch of the foo property type and the type of the property it " + "overrides from superclass goog.Super\n" + "original: function (this:goog.Super, number): undefined\n" + "override: function (this:goog.Sub, string): undefined"); } public void testInterfacePropertyOverride1() throws Exception { testTypes( "/** @interface */function Super() {};" + "/** @desc description */Super.prototype.foo = function() {};" + "/** @interface\n @extends {Super} */function Sub() {};" + "/** @desc description */Sub.prototype.foo = function() {};"); } public void testInterfacePropertyOverride2() throws Exception { testTypes( "/** @interface */function Root() {};" + "/** @desc description */Root.prototype.foo = function() {};" + "/** @interface\n @extends {Root} */function Super() {};" + "/** @interface\n @extends {Super} */function Sub() {};" + "/** @desc description */Sub.prototype.foo = function() {};"); } public void testInterfaceInheritanceCheck1() throws Exception { testTypes( "/** @interface */function Super() {};" + "/** @desc description */Super.prototype.foo = function() {};" + "/** @constructor\n @implements {Super} */function Sub() {};" + "Sub.prototype.foo = function() {};", "property foo already defined on interface Super; use @override to " + "override it"); } public void testInterfaceInheritanceCheck2() throws Exception { testTypes( "/** @interface */function Super() {};" + "/** @desc description */Super.prototype.foo = function() {};" + "/** @constructor\n @implements {Super} */function Sub() {};" + "/** @override */Sub.prototype.foo = function() {};"); } public void testInterfaceInheritanceCheck3() throws Exception { testTypes( "/** @interface */function Root() {};" + "/** @return {number} */Root.prototype.foo = function() {};" + "/** @interface\n @extends {Root} */function Super() {};" + "/** @constructor\n @implements {Super} */function Sub() {};" + "/** @return {number} */Sub.prototype.foo = function() { return 1;};", "property foo already defined on interface Root; use @override to " + "override it"); } public void testInterfaceInheritanceCheck4() throws Exception { testTypes( "/** @interface */function Root() {};" + "/** @return {number} */Root.prototype.foo = function() {};" + "/** @interface\n @extends {Root} */function Super() {};" + "/** @constructor\n @implements {Super} */function Sub() {};" + "/** @override\n * @return {number} */Sub.prototype.foo =\n" + "function() { return 1;};"); } public void testInterfaceInheritanceCheck5() throws Exception { testTypes( "/** @interface */function Super() {};" + "/** @return {string} */Super.prototype.foo = function() {};" + "/** @constructor\n @implements {Super} */function Sub() {};" + "/** @override\n @return {number} */Sub.prototype.foo =\n" + "function() { return 1; };", "mismatch of the foo property type and the type of the property it " + "overrides from interface Super\n" + "original: function (this:Super): string\n" + "override: function (this:Sub): number"); } public void testInterfaceInheritanceCheck6() throws Exception { testTypes( "/** @interface */function Root() {};" + "/** @return {string} */Root.prototype.foo = function() {};" + "/** @interface\n @extends {Root} */function Super() {};" + "/** @constructor\n @implements {Super} */function Sub() {};" + "/** @override\n @return {number} */Sub.prototype.foo =\n" + "function() { return 1; };", "mismatch of the foo property type and the type of the property it " + "overrides from interface Root\n" + "original: function (this:Root): string\n" + "override: function (this:Sub): number"); } public void testInterfaceInheritanceCheck7() throws Exception { testTypes( "/** @interface */function Super() {};" + "/** @param {number} bar */Super.prototype.foo = function(bar) {};" + "/** @constructor\n @implements {Super} */function Sub() {};" + "/** @override\n @param {string} bar */Sub.prototype.foo =\n" + "function(bar) {};", "mismatch of the foo property type and the type of the property it " + "overrides from interface Super\n" + "original: function (this:Super, number): undefined\n" + "override: function (this:Sub, string): undefined"); } public void testInterfaceInheritanceCheck8() throws Exception { testTypes( "/** @constructor\n @implements {Super} */function Sub() {};" + "/** @override */Sub.prototype.foo = function() {};", new String[] { "Bad type annotation. Unknown type Super", "property foo not defined on any superclass of Sub" }); } public void testInterfaceInheritanceCheck9() throws Exception { testTypes( "/** @interface */ function I() {}" + "/** @return {number} */ I.prototype.bar = function() {};" + "/** @constructor */ function F() {}" + "/** @return {number} */ F.prototype.bar = function() {return 3; };" + "/** @return {number} */ F.prototype.foo = function() {return 3; };" + "/** @constructor \n * @extends {F} \n * @implements {I} */ " + "function G() {}" + "/** @return {string} */ function f() { return new G().bar(); }", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testInterfaceInheritanceCheck10() throws Exception { testTypes( "/** @interface */ function I() {}" + "/** @return {number} */ I.prototype.bar = function() {};" + "/** @constructor */ function F() {}" + "/** @return {number} */ F.prototype.foo = function() {return 3; };" + "/** @constructor \n * @extends {F} \n * @implements {I} */ " + "function G() {}" + "/** @return {number} \n * @override */ " + "G.prototype.bar = G.prototype.foo;" + "/** @return {string} */ function f() { return new G().bar(); }", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testInterfaceInheritanceCheck12() throws Exception { testTypes( "/** @interface */ function I() {};\n" + "/** @type {string} */ I.prototype.foobar;\n" + "/** \n * @constructor \n * @implements {I} */\n" + "function C() {\n" + "/** \n * @type {number} */ this.foobar = 2;};\n" + "/** @type {I} */ \n var test = new C(); alert(test.foobar);", "mismatch of the foobar property type and the type of the property" + " it overrides from interface I\n" + "original: string\n" + "override: number"); } public void testInterfaceInheritanceCheck13() throws Exception { testTypes( "function abstractMethod() {};\n" + "/** @interface */var base = function() {};\n" + "/** @extends {base} \n @interface */ var Int = function() {}\n" + "/** @type {{bar : !Function}} */ var x; \n" + "/** @type {!Function} */ base.prototype.bar = abstractMethod; \n" + "/** @type {Int} */ var foo;\n" + "foo.bar();"); } public void testInterfacePropertyNotImplemented() throws Exception { testTypes( "/** @interface */function Int() {};" + "/** @desc description */Int.prototype.foo = function() {};" + "/** @constructor\n @implements {Int} */function Foo() {};", "property foo on interface Int is not implemented by type Foo"); } public void testInterfacePropertyNotImplemented2() throws Exception { testTypes( "/** @interface */function Int() {};" + "/** @desc description */Int.prototype.foo = function() {};" + "/** @interface \n @extends {Int} */function Int2() {};" + "/** @constructor\n @implements {Int2} */function Foo() {};", "property foo on interface Int is not implemented by type Foo"); } public void testStubConstructorImplementingInterface() throws Exception { // This does not throw a warning for unimplemented property because Foo is // just a stub. testTypes( // externs "/** @interface */ function Int() {}\n" + "/** @desc description */Int.prototype.foo = function() {};" + "/** @constructor \n @implements {Int} */ var Foo;\n", "", null, false); } public void testObjectLiteral() throws Exception { Node n = parseAndTypeCheck("var a = {m1: 7, m2: 'hello'}"); Node nameNode = n.getFirstChild().getFirstChild(); Node objectNode = nameNode.getFirstChild(); // node extraction assertEquals(Token.NAME, nameNode.getType()); assertEquals(Token.OBJECTLIT, objectNode.getType()); // value's type ObjectType objectType = (ObjectType) objectNode.getJSType(); assertTypeEquals(NUMBER_TYPE, objectType.getPropertyType("m1")); assertTypeEquals(STRING_TYPE, objectType.getPropertyType("m2")); // variable's type assertTypeEquals(objectType, nameNode.getJSType()); } public void testObjectLiteralDeclaration1() throws Exception { testTypes( "var x = {" + "/** @type {boolean} */ abc: true," + "/** @type {number} */ 'def': 0," + "/** @type {string} */ 3: 'fgh'" + "};"); } public void testObjectLiteralDeclaration2() throws Exception { testTypes( "var x = {" + " /** @type {boolean} */ abc: true" + "};" + "x.abc = 0;", "assignment to property abc of x\n" + "found : number\n" + "required: boolean"); } public void testObjectLiteralDeclaration3() throws Exception { testTypes( "/** @param {{foo: !Function}} x */ function f(x) {}" + "f({foo: function() {}});"); } public void testObjectLiteralDeclaration4() throws Exception { testClosureTypes( "var x = {" + " /** @param {boolean} x */ abc: function(x) {}" + "};" + "/**\n" + " * @param {string} x\n" + " * @suppress {duplicate}\n" + " */ x.abc = function(x) {};", "assignment to property abc of x\n" + "found : function (string): undefined\n" + "required: function (boolean): undefined"); // TODO(user): suppress {duplicate} currently also silence the // redefining type error in the TypeValidator. Maybe it needs // a new suppress name instead? } public void testObjectLiteralDeclaration5() throws Exception { testTypes( "var x = {" + " /** @param {boolean} x */ abc: function(x) {}" + "};" + "/**\n" + " * @param {boolean} x\n" + " * @suppress {duplicate}\n" + " */ x.abc = function(x) {};"); } public void testObjectLiteralDeclaration6() throws Exception { testTypes( "var x = {};" + "/**\n" + " * @param {boolean} x\n" + " * @suppress {duplicate}\n" + " */ x.abc = function(x) {};" + "x = {" + " /**\n" + " * @param {boolean} x\n" + " * @suppress {duplicate}\n" + " */" + " abc: function(x) {}" + "};"); } public void testObjectLiteralDeclaration7() throws Exception { testTypes( "var x = {};" + "/**\n" + " * @type {function(boolean): undefined}\n" + " */ x.abc = function(x) {};" + "x = {" + " /**\n" + " * @param {boolean} x\n" + " * @suppress {duplicate}\n" + " */" + " abc: function(x) {}" + "};"); } public void testCallDateConstructorAsFunction() throws Exception { // ECMA-262 15.9.2: When Date is called as a function rather than as a // constructor, it returns a string. Node n = parseAndTypeCheck("Date()"); assertTypeEquals(STRING_TYPE, n.getFirstChild().getFirstChild().getJSType()); } // According to ECMA-262, Error & Array function calls are equivalent to // constructor calls. public void testCallErrorConstructorAsFunction() throws Exception { Node n = parseAndTypeCheck("Error('x')"); assertTypeEquals(ERROR_TYPE, n.getFirstChild().getFirstChild().getJSType()); } public void testCallArrayConstructorAsFunction() throws Exception { Node n = parseAndTypeCheck("Array()"); assertTypeEquals(ARRAY_TYPE, n.getFirstChild().getFirstChild().getJSType()); } public void testPropertyTypeOfUnionType() throws Exception { testTypes("var a = {};" + "/** @constructor */ a.N = function() {};\n" + "a.N.prototype.p = 1;\n" + "/** @constructor */ a.S = function() {};\n" + "a.S.prototype.p = 'a';\n" + "/** @param {!a.N|!a.S} x\n@return {string} */\n" + "var f = function(x) { return x.p; };", "inconsistent return type\n" + "found : (number|string)\n" + "required: string"); } // TODO(user): We should flag these as invalid. This will probably happen // when we make sure the interface is never referenced outside of its // definition. We might want more specific and helpful error messages. //public void testWarningOnInterfacePrototype() throws Exception { // testTypes("/** @interface */ u.T = function() {};\n" + // "/** @return {number} */ u.T.prototype = function() { };", // "e of its definition"); //} // //public void testBadPropertyOnInterface1() throws Exception { // testTypes("/** @interface */ u.T = function() {};\n" + // "/** @return {number} */ u.T.f = function() { return 1;};", // "cannot reference an interface outside of its definition"); //} // //public void testBadPropertyOnInterface2() throws Exception { // testTypes("/** @interface */ function T() {};\n" + // "/** @return {number} */ T.f = function() { return 1;};", // "cannot reference an interface outside of its definition"); //} // //public void testBadPropertyOnInterface3() throws Exception { // testTypes("/** @interface */ u.T = function() {}; u.T.x", // "cannot reference an interface outside of its definition"); //} // //public void testBadPropertyOnInterface4() throws Exception { // testTypes("/** @interface */ function T() {}; T.x;", // "cannot reference an interface outside of its definition"); //} public void testAnnotatedPropertyOnInterface1() throws Exception { // For interfaces we must allow function definitions that don't have a // return statement, even though they declare a returned type. testTypes("/** @interface */ u.T = function() {};\n" + "/** @return {number} */ u.T.prototype.f = function() {};"); } public void testAnnotatedPropertyOnInterface2() throws Exception { testTypes("/** @interface */ u.T = function() {};\n" + "/** @return {number} */ u.T.prototype.f = function() { };"); } public void testAnnotatedPropertyOnInterface3() throws Exception { testTypes("/** @interface */ function T() {};\n" + "/** @return {number} */ T.prototype.f = function() { };"); } public void testAnnotatedPropertyOnInterface4() throws Exception { testTypes( CLOSURE_DEFS + "/** @interface */ function T() {};\n" + "/** @return {number} */ T.prototype.f = goog.abstractMethod;"); } // TODO(user): If we want to support this syntax we have to warn about // missing annotations. //public void testWarnUnannotatedPropertyOnInterface1() throws Exception { // testTypes("/** @interface */ u.T = function () {}; u.T.prototype.x;", // "interface property x is not annotated"); //} // //public void testWarnUnannotatedPropertyOnInterface2() throws Exception { // testTypes("/** @interface */ function T() {}; T.prototype.x;", // "interface property x is not annotated"); //} public void testWarnUnannotatedPropertyOnInterface5() throws Exception { testTypes("/** @interface */ u.T = function () {};\n" + "/** @desc x does something */u.T.prototype.x = function() {};"); } public void testWarnUnannotatedPropertyOnInterface6() throws Exception { testTypes("/** @interface */ function T() {};\n" + "/** @desc x does something */T.prototype.x = function() {};"); } // TODO(user): If we want to support this syntax we have to warn about // the invalid type of the interface member. //public void testWarnDataPropertyOnInterface1() throws Exception { // testTypes("/** @interface */ u.T = function () {};\n" + // "/** @type {number} */u.T.prototype.x;", // "interface members can only be plain functions"); //} public void testDataPropertyOnInterface1() throws Exception { testTypes("/** @interface */ function T() {};\n" + "/** @type {number} */T.prototype.x;"); } public void testDataPropertyOnInterface2() throws Exception { reportMissingOverrides = CheckLevel.OFF; testTypes("/** @interface */ function T() {};\n" + "/** @type {number} */T.prototype.x;\n" + "/** @constructor \n" + " * @implements {T} \n" + " */\n" + "function C() {}\n" + "C.prototype.x = 'foo';", "mismatch of the x property type and the type of the property it " + "overrides from interface T\n" + "original: number\n" + "override: string"); } public void testDataPropertyOnInterface3() throws Exception { testTypes("/** @interface */ function T() {};\n" + "/** @type {number} */T.prototype.x;\n" + "/** @constructor \n" + " * @implements {T} \n" + " */\n" + "function C() {}\n" + "/** @override */\n" + "C.prototype.x = 'foo';", "mismatch of the x property type and the type of the property it " + "overrides from interface T\n" + "original: number\n" + "override: string"); } public void testDataPropertyOnInterface4() throws Exception { testTypes("/** @interface */ function T() {};\n" + "/** @type {number} */T.prototype.x;\n" + "/** @constructor \n" + " * @implements {T} \n" + " */\n" + "function C() { /** @type {string} */ \n this.x = 'foo'; }\n", "mismatch of the x property type and the type of the property it " + "overrides from interface T\n" + "original: number\n" + "override: string"); } public void testWarnDataPropertyOnInterface3() throws Exception { testTypes("/** @interface */ u.T = function () {};\n" + "/** @type {number} */u.T.prototype.x = 1;", "interface members can only be empty property declarations, " + "empty functions, or goog.abstractMethod"); } public void testWarnDataPropertyOnInterface4() throws Exception { testTypes("/** @interface */ function T() {};\n" + "/** @type {number} */T.prototype.x = 1;", "interface members can only be empty property declarations, " + "empty functions, or goog.abstractMethod"); } // TODO(user): If we want to support this syntax we should warn about the // mismatching types in the two tests below. //public void testErrorMismatchingPropertyOnInterface1() throws Exception { // testTypes("/** @interface */ u.T = function () {};\n" + // "/** @param {Number} foo */u.T.prototype.x =\n" + // "/** @param {String} foo */function(foo) {};", // "found : \n" + // "required: "); //} // //public void testErrorMismatchingPropertyOnInterface2() throws Exception { // testTypes("/** @interface */ function T() {};\n" + // "/** @return {number} */T.prototype.x =\n" + // "/** @return {string} */function() {};", // "found : \n" + // "required: "); //} // TODO(user): We should warn about this (bar is missing an annotation). We // probably don't want to warn about all missing parameter annotations, but // we should be as strict as possible regarding interfaces. //public void testErrorMismatchingPropertyOnInterface3() throws Exception { // testTypes("/** @interface */ u.T = function () {};\n" + // "/** @param {Number} foo */u.T.prototype.x =\n" + // "function(foo, bar) {};", // "found : \n" + // "required: "); //} public void testErrorMismatchingPropertyOnInterface4() throws Exception { testTypes("/** @interface */ u.T = function () {};\n" + "/** @param {Number} foo */u.T.prototype.x =\n" + "function() {};", "parameter foo does not appear in u.T.prototype.x's parameter list"); } public void testErrorMismatchingPropertyOnInterface5() throws Exception { testTypes("/** @interface */ function T() {};\n" + "/** @type {number} */T.prototype.x = function() { };", "assignment to property x of T.prototype\n" + "found : function (): undefined\n" + "required: number"); } public void testErrorMismatchingPropertyOnInterface6() throws Exception { testClosureTypesMultipleWarnings( "/** @interface */ function T() {};\n" + "/** @return {number} */T.prototype.x = 1", Lists.newArrayList( "assignment to property x of T.prototype\n" + "found : number\n" + "required: function (this:T): number", "interface members can only be empty property declarations, " + "empty functions, or goog.abstractMethod")); } public void testInterfaceNonEmptyFunction() throws Exception { testTypes("/** @interface */ function T() {};\n" + "T.prototype.x = function() { return 'foo'; }", "interface member functions must have an empty body" ); } public void testDoubleNestedInterface() throws Exception { testTypes("/** @interface */ var I1 = function() {};\n" + "/** @interface */ I1.I2 = function() {};\n" + "/** @interface */ I1.I2.I3 = function() {};\n"); } public void testStaticDataPropertyOnNestedInterface() throws Exception { testTypes("/** @interface */ var I1 = function() {};\n" + "/** @interface */ I1.I2 = function() {};\n" + "/** @type {number} */ I1.I2.x = 1;\n"); } public void testInterfaceInstantiation() throws Exception { testTypes("/** @interface */var f = function(){}; new f", "cannot instantiate non-constructor"); } public void testPrototypeLoop() throws Exception { testClosureTypesMultipleWarnings( suppressMissingProperty("foo") + "/** @constructor \n * @extends {T} */var T = function() {};" + "alert((new T).foo);", Lists.newArrayList( "Parse error. Cycle detected in inheritance chain of type T", "Could not resolve type in @extends tag of T")); } public void testImplementsLoop() throws Exception { testClosureTypesMultipleWarnings( suppressMissingProperty("foo") + "/** @constructor \n * @implements {T} */var T = function() {};" + "alert((new T).foo);", Lists.newArrayList( "Parse error. Cycle detected in inheritance chain of type T")); } public void testImplementsExtendsLoop() throws Exception { testClosureTypesMultipleWarnings( suppressMissingProperty("foo") + "/** @constructor \n * @implements {F} */var G = function() {};" + "/** @constructor \n * @extends {G} */var F = function() {};" + "alert((new F).foo);", Lists.newArrayList( "Parse error. Cycle detected in inheritance chain of type F")); } public void testInterfaceExtendsLoop() throws Exception { // TODO(user): This should give a cycle in inheritance graph error, // not a cannot resolve error. testClosureTypesMultipleWarnings( suppressMissingProperty("foo") + "/** @interface \n * @extends {F} */var G = function() {};" + "/** @interface \n * @extends {G} */var F = function() {};", Lists.newArrayList( "Could not resolve type in @extends tag of G")); } public void testConversionFromInterfaceToRecursiveConstructor() throws Exception { testClosureTypesMultipleWarnings( suppressMissingProperty("foo") + "/** @interface */ var OtherType = function() {}\n" + "/** @implements {MyType} \n * @constructor */\n" + "var MyType = function() {}\n" + "/** @type {MyType} */\n" + "var x = /** @type {!OtherType} */ (new Object());", Lists.newArrayList( "Parse error. Cycle detected in inheritance chain of type MyType", "initializing variable\n" + "found : OtherType\n" + "required: (MyType|null)")); } public void testDirectPrototypeAssign() throws Exception { // For now, we just ignore @type annotations on the prototype. testTypes( "/** @constructor */ function Foo() {}" + "/** @constructor */ function Bar() {}" + "/** @type {Array} */ Bar.prototype = new Foo()"); } // In all testResolutionViaRegistry* tests, since u is unknown, u.T can only // be resolved via the registry and not via properties. public void testResolutionViaRegistry1() throws Exception { testTypes("/** @constructor */ u.T = function() {};\n" + "/** @type {(number|string)} */ u.T.prototype.a;\n" + "/**\n" + "* @param {u.T} t\n" + "* @return {string}\n" + "*/\n" + "var f = function(t) { return t.a; };", "inconsistent return type\n" + "found : (number|string)\n" + "required: string"); } public void testResolutionViaRegistry2() throws Exception { testTypes( "/** @constructor */ u.T = function() {" + " this.a = 0; };\n" + "/**\n" + "* @param {u.T} t\n" + "* @return {string}\n" + "*/\n" + "var f = function(t) { return t.a; };", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testResolutionViaRegistry3() throws Exception { testTypes("/** @constructor */ u.T = function() {};\n" + "/** @type {(number|string)} */ u.T.prototype.a = 0;\n" + "/**\n" + "* @param {u.T} t\n" + "* @return {string}\n" + "*/\n" + "var f = function(t) { return t.a; };", "inconsistent return type\n" + "found : (number|string)\n" + "required: string"); } public void testResolutionViaRegistry4() throws Exception { testTypes("/** @constructor */ u.A = function() {};\n" + "/**\n* @constructor\n* @extends {u.A}\n*/\nu.A.A = function() {}\n;" + "/**\n* @constructor\n* @extends {u.A}\n*/\nu.A.B = function() {};\n" + "var ab = new u.A.B();\n" + "/** @type {!u.A} */ var a = ab;\n" + "/** @type {!u.A.A} */ var aa = ab;\n", "initializing variable\n" + "found : u.A.B\n" + "required: u.A.A"); } public void testResolutionViaRegistry5() throws Exception { Node n = parseAndTypeCheck("/** @constructor */ u.T = function() {}; u.T"); JSType type = n.getLastChild().getLastChild().getJSType(); assertFalse(type.isUnknownType()); assertTrue(type instanceof FunctionType); assertEquals("u.T", ((FunctionType) type).getInstanceType().getReferenceName()); } public void testGatherProperyWithoutAnnotation1() throws Exception { Node n = parseAndTypeCheck("/** @constructor */ var T = function() {};" + "/** @type {!T} */var t; t.x; t;"); JSType type = n.getLastChild().getLastChild().getJSType(); assertFalse(type.isUnknownType()); assertTrue(type instanceof ObjectType); ObjectType objectType = (ObjectType) type; assertFalse(objectType.hasProperty("x")); Asserts.assertTypeCollectionEquals( Lists.newArrayList(objectType), registry.getTypesWithProperty("x")); } public void testGatherProperyWithoutAnnotation2() throws Exception { TypeCheckResult ns = parseAndTypeCheckWithScope("/** @type {!Object} */var t; t.x; t;"); Node n = ns.root; Scope s = ns.scope; JSType type = n.getLastChild().getLastChild().getJSType(); assertFalse(type.isUnknownType()); assertTypeEquals(type, OBJECT_TYPE); assertTrue(type instanceof ObjectType); ObjectType objectType = (ObjectType) type; assertFalse(objectType.hasProperty("x")); Asserts.assertTypeCollectionEquals( Lists.newArrayList(OBJECT_TYPE), registry.getTypesWithProperty("x")); } public void testFunctionMasksVariableBug() throws Exception { testTypes("var x = 4; var f = function x(b) { return b ? 1 : x(true); };", "function x masks variable (IE bug)"); } public void testDfa1() throws Exception { testTypes("var x = null;\n x = 1;\n /** @type number */ var y = x;"); } public void testDfa2() throws Exception { testTypes("function u() {}\n" + "/** @return {number} */ function f() {\nvar x = 'todo';\n" + "if (u()) { x = 1; } else { x = 2; } return x;\n}"); } public void testDfa3() throws Exception { testTypes("function u() {}\n" + "/** @return {number} */ function f() {\n" + "/** @type {number|string} */ var x = 'todo';\n" + "if (u()) { x = 1; } else { x = 2; } return x;\n}"); } public void testDfa4() throws Exception { testTypes("/** @param {Date?} d */ function f(d) {\n" + "if (!d) { return; }\n" + "/** @type {!Date} */ var e = d;\n}"); } public void testDfa5() throws Exception { testTypes("/** @return {string?} */ function u() {return 'a';}\n" + "/** @param {string?} x\n@return {string} */ function f(x) {\n" + "while (!x) { x = u(); }\nreturn x;\n}"); } public void testDfa6() throws Exception { testTypes("/** @return {Object?} */ function u() {return {};}\n" + "/** @param {Object?} x */ function f(x) {\n" + "while (x) { x = u(); if (!x) { x = u(); } }\n}"); } public void testDfa7() throws Exception { testTypes("/** @constructor */ var T = function() {};\n" + "/** @type {Date?} */ T.prototype.x = null;\n" + "/** @param {!T} t */ function f(t) {\n" + "if (!t.x) { return; }\n" + "/** @type {!Date} */ var e = t.x;\n}"); } public void testDfa8() throws Exception { testTypes("/** @constructor */ var T = function() {};\n" + "/** @type {number|string} */ T.prototype.x = '';\n" + "function u() {}\n" + "/** @param {!T} t\n@return {number} */ function f(t) {\n" + "if (u()) { t.x = 1; } else { t.x = 2; } return t.x;\n}"); } public void testDfa9() throws Exception { testTypes("function f() {\n/** @type {string?} */var x;\nx = null;\n" + "if (x == null) { return 0; } else { return 1; } }", "condition always evaluates to true\n" + "left : null\n" + "right: null"); } public void testDfa10() throws Exception { testTypes("/** @param {null} x */ function g(x) {}" + "/** @param {string?} x */function f(x) {\n" + "if (!x) { x = ''; }\n" + "if (g(x)) { return 0; } else { return 1; } }", "actual parameter 1 of g does not match formal parameter\n" + "found : string\n" + "required: null"); } public void testDfa11() throws Exception { testTypes("/** @param {string} opt_x\n@return {string} */\n" + "function f(opt_x) { if (!opt_x) { " + "throw new Error('x cannot be empty'); } return opt_x; }"); } public void testDfa12() throws Exception { testTypes("/** @param {string} x \n * @constructor \n */" + "var Bar = function(x) {};" + "/** @param {string} x */ function g(x) { return true; }" + "/** @param {string|number} opt_x */ " + "function f(opt_x) { " + " if (opt_x) { new Bar(g(opt_x) && 'x'); }" + "}", "actual parameter 1 of g does not match formal parameter\n" + "found : (number|string)\n" + "required: string"); } public void testDfa13() throws Exception { testTypes( "/**\n" + " * @param {string} x \n" + " * @param {number} y \n" + " * @param {number} z \n" + " */" + "function g(x, y, z) {}" + "function f() { " + " var x = 'a'; g(x, x = 3, x);" + "}"); } public void testTypeInferenceWithCast1() throws Exception { testTypes( "/**@return {(number,null,undefined)}*/function u(x) {return null;}" + "/**@param {number?} x\n@return {number?}*/function f(x) {return x;}" + "/**@return {number?}*/function g(x) {" + "var y = /**@type {number?}*/(u(x)); return f(y);}"); } public void testTypeInferenceWithCast2() throws Exception { testTypes( "/**@return {(number,null,undefined)}*/function u(x) {return null;}" + "/**@param {number?} x\n@return {number?}*/function f(x) {return x;}" + "/**@return {number?}*/function g(x) {" + "var y; y = /**@type {number?}*/(u(x)); return f(y);}"); } public void testTypeInferenceWithCast3() throws Exception { testTypes( "/**@return {(number,null,undefined)}*/function u(x) {return 1;}" + "/**@return {number}*/function g(x) {" + "return /**@type {number}*/(u(x));}"); } public void testTypeInferenceWithCast4() throws Exception { testTypes( "/**@return {(number,null,undefined)}*/function u(x) {return 1;}" + "/**@return {number}*/function g(x) {" + "return /**@type {number}*/(u(x)) && 1;}"); } public void testTypeInferenceWithCast5() throws Exception { testTypes( "/** @param {number} x */ function foo(x) {}" + "/** @param {{length:*}} y */ function bar(y) {" + " /** @type {string} */ y.length;" + " foo(y.length);" + "}", "actual parameter 1 of foo does not match formal parameter\n" + "found : string\n" + "required: number"); } public void testTypeInferenceWithClosure1() throws Exception { testTypes( "/** @return {boolean} */" + "function f() {" + " /** @type {?string} */ var x = null;" + " function g() { x = 'y'; } g(); " + " return x == null;" + "}"); } public void testTypeInferenceWithClosure2() throws Exception { testTypes( "/** @return {boolean} */" + "function f() {" + " /** @type {?string} */ var x = null;" + " function g() { x = 'y'; } g(); " + " return x === 3;" + "}", "condition always evaluates to false\n" + "left : (null|string)\n" + "right: number"); } public void testTypeInferenceWithNoEntry1() throws Exception { testTypes( "/** @param {number} x */ function f(x) {}" + "/** @constructor */ function Foo() {}" + "Foo.prototype.init = function() {" + " /** @type {?{baz: number}} */ this.bar = {baz: 3};" + "};" + "/**\n" + " * @extends {Foo}\n" + " * @constructor\n" + " */" + "function SubFoo() {}" + "/** Method */" + "SubFoo.prototype.method = function() {" + " for (var i = 0; i < 10; i++) {" + " f(this.bar);" + " f(this.bar.baz);" + " }" + "};", "actual parameter 1 of f does not match formal parameter\n" + "found : (null|{baz: number})\n" + "required: number"); } public void testTypeInferenceWithNoEntry2() throws Exception { testClosureTypes( CLOSURE_DEFS + "/** @param {number} x */ function f(x) {}" + "/** @param {!Object} x */ function g(x) {}" + "/** @constructor */ function Foo() {}" + "Foo.prototype.init = function() {" + " /** @type {?{baz: number}} */ this.bar = {baz: 3};" + "};" + "/**\n" + " * @extends {Foo}\n" + " * @constructor\n" + " */" + "function SubFoo() {}" + "/** Method */" + "SubFoo.prototype.method = function() {" + " for (var i = 0; i < 10; i++) {" + " f(this.bar);" + " goog.asserts.assert(this.bar);" + " g(this.bar);" + " }" + "};", "actual parameter 1 of f does not match formal parameter\n" + "found : (null|{baz: number})\n" + "required: number"); } public void testForwardPropertyReference() throws Exception { testTypes("/** @constructor */ var Foo = function() { this.init(); };" + "/** @return {string} */" + "Foo.prototype.getString = function() {" + " return this.number_;" + "};" + "Foo.prototype.init = function() {" + " /** @type {number} */" + " this.number_ = 3;" + "};", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testNoForwardTypeDeclaration() throws Exception { testTypes( "/** @param {MyType} x */ function f(x) {}", "Bad type annotation. Unknown type MyType"); } public void testNoForwardTypeDeclarationAndNoBraces() throws Exception { testTypes("/** @return The result. */ function f() {}"); } public void testForwardTypeDeclaration1() throws Exception { testClosureTypes( // malformed addDependency calls shouldn't cause a crash "goog.addDependency();" + "goog.addDependency('y', [goog]);" + "goog.addDependency('zzz.js', ['MyType'], []);" + "/** @param {MyType} x \n * @return {number} */" + "function f(x) { return 3; }", null); } public void testForwardTypeDeclaration2() throws Exception { String f = "goog.addDependency('zzz.js', ['MyType'], []);" + "/** @param {MyType} x */ function f(x) { }"; testClosureTypes(f, null); testClosureTypes(f + "f(3);", "actual parameter 1 of f does not match formal parameter\n" + "found : number\n" + "required: (MyType|null)"); } public void testForwardTypeDeclaration3() throws Exception { testClosureTypes( "goog.addDependency('zzz.js', ['MyType'], []);" + "/** @param {MyType} x */ function f(x) { return x; }" + "/** @constructor */ var MyType = function() {};" + "f(3);", "actual parameter 1 of f does not match formal parameter\n" + "found : number\n" + "required: (MyType|null)"); } public void testForwardTypeDeclaration4() throws Exception { testClosureTypes( "goog.addDependency('zzz.js', ['MyType'], []);" + "/** @param {MyType} x */ function f(x) { return x; }" + "/** @constructor */ var MyType = function() {};" + "f(new MyType());", null); } public void testForwardTypeDeclaration5() throws Exception { testClosureTypes( "goog.addDependency('zzz.js', ['MyType'], []);" + "/**\n" + " * @constructor\n" + " * @extends {MyType}\n" + " */ var YourType = function() {};" + "/** @override */ YourType.prototype.method = function() {};", "Could not resolve type in @extends tag of YourType"); } public void testForwardTypeDeclaration6() throws Exception { testClosureTypesMultipleWarnings( "goog.addDependency('zzz.js', ['MyType'], []);" + "/**\n" + " * @constructor\n" + " * @implements {MyType}\n" + " */ var YourType = function() {};" + "/** @override */ YourType.prototype.method = function() {};", Lists.newArrayList( "Could not resolve type in @implements tag of YourType", "property method not defined on any superclass of YourType")); } public void testForwardTypeDeclaration7() throws Exception { testClosureTypes( "goog.addDependency('zzz.js', ['MyType'], []);" + "/** @param {MyType=} x */" + "function f(x) { return x == undefined; }", null); } public void testForwardTypeDeclaration8() throws Exception { testClosureTypes( "goog.addDependency('zzz.js', ['MyType'], []);" + "/** @param {MyType} x */" + "function f(x) { return x.name == undefined; }", null); } public void testForwardTypeDeclaration9() throws Exception { testClosureTypes( "goog.addDependency('zzz.js', ['MyType'], []);" + "/** @param {MyType} x */" + "function f(x) { x.name = 'Bob'; }", null); } public void testForwardTypeDeclaration10() throws Exception { String f = "goog.addDependency('zzz.js', ['MyType'], []);" + "/** @param {MyType|number} x */ function f(x) { }"; testClosureTypes(f, null); testClosureTypes(f + "f(3);", null); testClosureTypes(f + "f('3');", "actual parameter 1 of f does not match formal parameter\n" + "found : string\n" + "required: (MyType|null|number)"); } public void testForwardTypeDeclaration12() throws Exception { // We assume that {Function} types can produce anything, and don't // want to type-check them. testClosureTypes( "goog.addDependency('zzz.js', ['MyType'], []);" + "/**\n" + " * @param {!Function} ctor\n" + " * @return {MyType}\n" + " */\n" + "function f(ctor) { return new ctor(); }", null); } public void testForwardTypeDeclaration13() throws Exception { // Some projects use {Function} registries to register constructors // that aren't in their binaries. We want to make sure we can pass these // around, but still do other checks on them. testClosureTypes( "goog.addDependency('zzz.js', ['MyType'], []);" + "/**\n" + " * @param {!Function} ctor\n" + " * @return {MyType}\n" + " */\n" + "function f(ctor) { return (new ctor()).impossibleProp; }", "Property impossibleProp never defined on ?"); } public void testDuplicateTypeDef() throws Exception { testTypes( "var goog = {};" + "/** @constructor */ goog.Bar = function() {};" + "/** @typedef {number} */ goog.Bar;", "variable goog.Bar redefined with type None, " + "original definition at [testcode]:1 " + "with type function (new:goog.Bar): undefined"); } public void testTypeDef1() throws Exception { testTypes( "var goog = {};" + "/** @typedef {number} */ goog.Bar;" + "/** @param {goog.Bar} x */ function f(x) {}" + "f(3);"); } public void testTypeDef2() throws Exception { testTypes( "var goog = {};" + "/** @typedef {number} */ goog.Bar;" + "/** @param {goog.Bar} x */ function f(x) {}" + "f('3');", "actual parameter 1 of f does not match formal parameter\n" + "found : string\n" + "required: number"); } public void testTypeDef3() throws Exception { testTypes( "var goog = {};" + "/** @typedef {number} */ var Bar;" + "/** @param {Bar} x */ function f(x) {}" + "f('3');", "actual parameter 1 of f does not match formal parameter\n" + "found : string\n" + "required: number"); } public void testTypeDef4() throws Exception { testTypes( "/** @constructor */ function A() {}" + "/** @constructor */ function B() {}" + "/** @typedef {(A|B)} */ var AB;" + "/** @param {AB} x */ function f(x) {}" + "f(new A()); f(new B()); f(1);", "actual parameter 1 of f does not match formal parameter\n" + "found : number\n" + "required: (A|B|null)"); } public void testTypeDef5() throws Exception { // Notice that the error message is slightly different than // the one for testTypeDef4, even though they should be the same. // This is an implementation detail necessary for NamedTypes work out // OK, and it should change if NamedTypes ever go away. testTypes( "/** @param {AB} x */ function f(x) {}" + "/** @constructor */ function A() {}" + "/** @constructor */ function B() {}" + "/** @typedef {(A|B)} */ var AB;" + "f(new A()); f(new B()); f(1);", "actual parameter 1 of f does not match formal parameter\n" + "found : number\n" + "required: (A|B|null)"); } public void testCircularTypeDef() throws Exception { testTypes( "var goog = {};" + "/** @typedef {number|Array.<goog.Bar>} */ goog.Bar;" + "/** @param {goog.Bar} x */ function f(x) {}" + "f(3); f([3]); f([[3]]);"); } public void testGetTypedPercent1() throws Exception { String js = "var id = function(x) { return x; }\n" + "var id2 = function(x) { return id(x); }"; assertEquals(50.0, getTypedPercent(js), 0.1); } public void testGetTypedPercent2() throws Exception { String js = "var x = {}; x.y = 1;"; assertEquals(100.0, getTypedPercent(js), 0.1); } public void testGetTypedPercent3() throws Exception { String js = "var f = function(x) { x.a = x.b; }"; assertEquals(50.0, getTypedPercent(js), 0.1); } public void testGetTypedPercent4() throws Exception { String js = "var n = {};\n /** @constructor */ n.T = function() {};\n" + "/** @type n.T */ var x = new n.T();"; assertEquals(100.0, getTypedPercent(js), 0.1); } public void testGetTypedPercent5() throws Exception { String js = "/** @enum {number} */ keys = {A: 1,B: 2,C: 3};"; assertEquals(100.0, getTypedPercent(js), 0.1); } public void testGetTypedPercent6() throws Exception { String js = "a = {TRUE: 1, FALSE: 0};"; assertEquals(100.0, getTypedPercent(js), 0.1); } private double getTypedPercent(String js) throws Exception { Node n = compiler.parseTestCode(js); Node externs = new Node(Token.BLOCK); Node externAndJsRoot = new Node(Token.BLOCK, externs, n); externAndJsRoot.setIsSyntheticBlock(true); TypeCheck t = makeTypeCheck(); t.processForTesting(null, n); return t.getTypedPercent(); } private ObjectType getInstanceType(Node js1Node) { JSType type = js1Node.getFirstChild().getJSType(); assertNotNull(type); assertTrue(type instanceof FunctionType); FunctionType functionType = (FunctionType) type; assertTrue(functionType.isConstructor()); return functionType.getInstanceType(); } public void testPrototypePropertyReference() throws Exception { TypeCheckResult p = parseAndTypeCheckWithScope("" + "/** @constructor */\n" + "function Foo() {}\n" + "/** @param {number} a */\n" + "Foo.prototype.bar = function(a){};\n" + "/** @param {Foo} f */\n" + "function baz(f) {\n" + " Foo.prototype.bar.call(f, 3);\n" + "}"); assertEquals(0, compiler.getErrorCount()); assertEquals(0, compiler.getWarningCount()); assertTrue(p.scope.getVar("Foo").getType() instanceof FunctionType); FunctionType fooType = (FunctionType) p.scope.getVar("Foo").getType(); assertEquals("function (this:Foo, number): undefined", fooType.getPrototype().getPropertyType("bar").toString()); } public void testResolvingNamedTypes() throws Exception { String js = "" + "/** @constructor */\n" + "var Foo = function() {}\n" + "/** @param {number} a */\n" + "Foo.prototype.foo = function(a) {\n" + " return this.baz().toString();\n" + "};\n" + "/** @return {Baz} */\n" + "Foo.prototype.baz = function() { return new Baz(); };\n" + "/** @constructor\n" + " * @extends Foo */\n" + "var Bar = function() {};" + "/** @constructor */\n" + "var Baz = function() {};"; assertEquals(100.0, getTypedPercent(js), 0.1); } public void testMissingProperty1() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "Foo.prototype.bar = function() { return this.a; };" + "Foo.prototype.baz = function() { this.a = 3; };"); } public void testMissingProperty2() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "Foo.prototype.bar = function() { return this.a; };" + "Foo.prototype.baz = function() { this.b = 3; };", "Property a never defined on Foo"); } public void testMissingProperty3() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "Foo.prototype.bar = function() { return this.a; };" + "(new Foo).a = 3;"); } public void testMissingProperty4() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "Foo.prototype.bar = function() { return this.a; };" + "(new Foo).b = 3;", "Property a never defined on Foo"); } public void testMissingProperty5() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "Foo.prototype.bar = function() { return this.a; };" + "/** @constructor */ function Bar() { this.a = 3; };", "Property a never defined on Foo"); } public void testMissingProperty6() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "Foo.prototype.bar = function() { return this.a; };" + "/** @constructor \n * @extends {Foo} */ " + "function Bar() { this.a = 3; };"); } public void testMissingProperty7() throws Exception { testTypes( "/** @param {Object} obj */" + "function foo(obj) { return obj.impossible; }", "Property impossible never defined on Object"); } public void testMissingProperty8() throws Exception { testTypes( "/** @param {Object} obj */" + "function foo(obj) { return typeof obj.impossible; }"); } public void testMissingProperty9() throws Exception { testTypes( "/** @param {Object} obj */" + "function foo(obj) { if (obj.impossible) { return true; } }"); } public void testMissingProperty10() throws Exception { testTypes( "/** @param {Object} obj */" + "function foo(obj) { while (obj.impossible) { return true; } }"); } public void testMissingProperty11() throws Exception { testTypes( "/** @param {Object} obj */" + "function foo(obj) { for (;obj.impossible;) { return true; } }"); } public void testMissingProperty12() throws Exception { testTypes( "/** @param {Object} obj */" + "function foo(obj) { do { } while (obj.impossible); }"); } public void testMissingProperty13() throws Exception { testTypes( "var goog = {}; goog.isDef = function(x) { return false; };" + "/** @param {Object} obj */" + "function foo(obj) { return goog.isDef(obj.impossible); }"); } public void testMissingProperty14() throws Exception { testTypes( "var goog = {}; goog.isDef = function(x) { return false; };" + "/** @param {Object} obj */" + "function foo(obj) { return goog.isNull(obj.impossible); }", "Property isNull never defined on goog"); } public void testMissingProperty15() throws Exception { testTypes( "/** @param {Object} x */" + "function f(x) { if (x.foo) { x.foo(); } }"); } public void testMissingProperty16() throws Exception { testTypes( "/** @param {Object} x */" + "function f(x) { x.foo(); if (x.foo) {} }", "Property foo never defined on Object"); } public void testMissingProperty17() throws Exception { testTypes( "/** @param {Object} x */" + "function f(x) { if (typeof x.foo == 'function') { x.foo(); } }"); } public void testMissingProperty18() throws Exception { testTypes( "/** @param {Object} x */" + "function f(x) { if (x.foo instanceof Function) { x.foo(); } }"); } public void testMissingProperty19() throws Exception { testTypes( "/** @param {Object} x */" + "function f(x) { if (x.bar) { if (x.foo) {} } else { x.foo(); } }", "Property foo never defined on Object"); } public void testMissingProperty20() throws Exception { testTypes( "/** @param {Object} x */" + "function f(x) { if (x.foo) { } else { x.foo(); } }", "Property foo never defined on Object"); } public void testMissingProperty21() throws Exception { testTypes( "/** @param {Object} x */" + "function f(x) { x.foo && x.foo(); }"); } public void testMissingProperty22() throws Exception { testTypes( "/** @param {Object} x \n * @return {boolean} */" + "function f(x) { return x.foo ? x.foo() : true; }"); } public void testMissingProperty23() throws Exception { testTypes( "function f(x) { x.impossible(); }", "Property impossible never defined on x"); } public void testMissingProperty24() throws Exception { testClosureTypes( "goog.addDependency('zzz.js', ['MissingType'], []);" + "/** @param {MissingType} x */" + "function f(x) { x.impossible(); }", null); } public void testMissingProperty25() throws Exception { testTypes( "/** @constructor */ var Foo = function() {};" + "Foo.prototype.bar = function() {};" + "/** @constructor */ var FooAlias = Foo;" + "(new FooAlias()).bar();"); } public void testMissingProperty26() throws Exception { testTypes( "/** @constructor */ var Foo = function() {};" + "/** @constructor */ var FooAlias = Foo;" + "FooAlias.prototype.bar = function() {};" + "(new Foo()).bar();"); } public void testMissingProperty27() throws Exception { testClosureTypes( "goog.addDependency('zzz.js', ['MissingType'], []);" + "/** @param {?MissingType} x */" + "function f(x) {" + " for (var parent = x; parent; parent = parent.getParent()) {}" + "}", null); } public void testMissingProperty28() throws Exception { testTypes( "function f(obj) {" + " /** @type {*} */ obj.foo;" + " return obj.foo;" + "}"); testTypes( "function f(obj) {" + " /** @type {*} */ obj.foo;" + " return obj.foox;" + "}", "Property foox never defined on obj"); } public void testMissingProperty29() throws Exception { // This used to emit a warning. testTypes( // externs "/** @constructor */ var Foo;" + "Foo.prototype.opera;" + "Foo.prototype.opera.postError;", "", null, false); } public void testMissingProperty30() throws Exception { testTypes( "/** @return {*} */" + "function f() {" + " return {};" + "}" + "f().a = 3;" + "/** @param {Object} y */ function g(y) { return y.a; }"); } public void testMissingProperty31() throws Exception { testTypes( "/** @return {Array|number} */" + "function f() {" + " return [];" + "}" + "f().a = 3;" + "/** @param {Array} y */ function g(y) { return y.a; }"); } public void testMissingProperty32() throws Exception { testTypes( "/** @return {Array|number} */" + "function f() {" + " return [];" + "}" + "f().a = 3;" + "/** @param {Date} y */ function g(y) { return y.a; }", "Property a never defined on Date"); } public void testMissingProperty33() throws Exception { testTypes( "/** @param {Object} x */" + "function f(x) { !x.foo || x.foo(); }"); } public void testMissingProperty34() throws Exception { testTypes( "/** @fileoverview \n * @suppress {missingProperties} */" + "/** @constructor */ function Foo() {}" + "Foo.prototype.bar = function() { return this.a; };" + "Foo.prototype.baz = function() { this.b = 3; };"); } public void testMissingProperty35() throws Exception { // Bar has specialProp defined, so Bar|Baz may have specialProp defined. testTypes( "/** @constructor */ function Foo() {}" + "/** @constructor */ function Bar() {}" + "/** @constructor */ function Baz() {}" + "/** @param {Foo|Bar} x */ function f(x) { x.specialProp = 1; }" + "/** @param {Bar|Baz} x */ function g(x) { return x.specialProp; }"); } public void testMissingProperty36() throws Exception { // Foo has baz defined, and SubFoo has bar defined, so some objects with // bar may have baz. testTypes( "/** @constructor */ function Foo() {}" + "Foo.prototype.baz = 0;" + "/** @constructor \n * @extends {Foo} */ function SubFoo() {}" + "SubFoo.prototype.bar = 0;" + "/** @param {{bar: number}} x */ function f(x) { return x.baz; }"); } public void testMissingProperty37() throws Exception { // This used to emit a missing property warning because we couldn't // determine that the inf(Foo, {isVisible:boolean}) == SubFoo. testTypes( "/** @param {{isVisible: boolean}} x */ function f(x){" + " x.isVisible = false;" + "}" + "/** @constructor */ function Foo() {}" + "/**\n" + " * @constructor \n" + " * @extends {Foo}\n" + " */ function SubFoo() {}" + "/** @type {boolean} */ SubFoo.prototype.isVisible = true;" + "/**\n" + " * @param {Foo} x\n" + " * @return {boolean}\n" + " */\n" + "function g(x) { return x.isVisible; }"); } public void testMissingProperty38() throws Exception { testTypes( "/** @constructor */ function Foo() {}" + "/** @constructor */ function Bar() {}" + "/** @return {Foo|Bar} */ function f() { return new Foo(); }" + "f().missing;", "Property missing never defined on (Bar|Foo|null)"); } public void testMissingProperty39() throws Exception { testTypes( "/** @return {string|number} */ function f() { return 3; }" + "f().length;"); } public void testMissingProperty40() throws Exception { testClosureTypes( "goog.addDependency('zzz.js', ['MissingType'], []);" + "/** @param {(Array|MissingType)} x */" + "function f(x) { x.impossible(); }", null); } public void testMissingProperty41() throws Exception { testTypes( "/** @param {(Array|Date)} x */" + "function f(x) { if (x.impossible) x.impossible(); }"); } public void testMissingProperty42() throws Exception { testTypes( "/** @param {Object} x */" + "function f(x) { " + " if (typeof x.impossible == 'undefined') throw Error();" + " return x.impossible;" + "}"); } public void testReflectObject1() throws Exception { testClosureTypes( "var goog = {}; goog.reflect = {}; " + "goog.reflect.object = function(x, y){};" + "/** @constructor */ function A() {}" + "goog.reflect.object(A, {x: 3});", null); } public void testReflectObject2() throws Exception { testClosureTypes( "var goog = {}; goog.reflect = {}; " + "goog.reflect.object = function(x, y){};" + "/** @param {string} x */ function f(x) {}" + "/** @constructor */ function A() {}" + "goog.reflect.object(A, {x: f(1 + 1)});", "actual parameter 1 of f does not match formal parameter\n" + "found : number\n" + "required: string"); } public void testLends1() throws Exception { testTypes( "function extend(x, y) {}" + "/** @constructor */ function Foo() {}" + "extend(Foo, /** @lends */ ({bar: 1}));", "Bad type annotation. missing object name in @lends tag"); } public void testLends2() throws Exception { testTypes( "function extend(x, y) {}" + "/** @constructor */ function Foo() {}" + "extend(Foo, /** @lends {Foob} */ ({bar: 1}));", "Variable Foob not declared before @lends annotation."); } public void testLends3() throws Exception { testTypes( "function extend(x, y) {}" + "/** @constructor */ function Foo() {}" + "extend(Foo, {bar: 1});" + "alert(Foo.bar);", "Property bar never defined on Foo"); } public void testLends4() throws Exception { testTypes( "function extend(x, y) {}" + "/** @constructor */ function Foo() {}" + "extend(Foo, /** @lends {Foo} */ ({bar: 1}));" + "alert(Foo.bar);"); } public void testLends5() throws Exception { testTypes( "function extend(x, y) {}" + "/** @constructor */ function Foo() {}" + "extend(Foo, {bar: 1});" + "alert((new Foo()).bar);", "Property bar never defined on Foo"); } public void testLends6() throws Exception { testTypes( "function extend(x, y) {}" + "/** @constructor */ function Foo() {}" + "extend(Foo, /** @lends {Foo.prototype} */ ({bar: 1}));" + "alert((new Foo()).bar);"); } public void testLends7() throws Exception { testTypes( "function extend(x, y) {}" + "/** @constructor */ function Foo() {}" + "extend(Foo, /** @lends {Foo.prototype|Foo} */ ({bar: 1}));", "Bad type annotation. expected closing }"); } public void testLends8() throws Exception { testTypes( "function extend(x, y) {}" + "/** @type {number} */ var Foo = 3;" + "extend(Foo, /** @lends {Foo} */ ({bar: 1}));", "May only lend properties to object types. Foo has type number."); } public void testLends9() throws Exception { testClosureTypesMultipleWarnings( "function extend(x, y) {}" + "/** @constructor */ function Foo() {}" + "extend(Foo, /** @lends {!Foo} */ ({bar: 1}));", Lists.newArrayList( "Bad type annotation. expected closing }", "Bad type annotation. missing object name in @lends tag")); } public void testLends10() throws Exception { testTypes( "function defineClass(x) { return function() {}; } " + "/** @constructor */" + "var Foo = defineClass(" + " /** @lends {Foo.prototype} */ ({/** @type {number} */ bar: 1}));" + "/** @return {string} */ function f() { return (new Foo()).bar; }", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testLends11() throws Exception { testTypes( "function defineClass(x, y) { return function() {}; } " + "/** @constructor */" + "var Foo = function() {};" + "/** @return {*} */ Foo.prototype.bar = function() { return 3; };" + "/**\n" + " * @constructor\n" + " * @extends {Foo}\n" + " */\n" + "var SubFoo = defineClass(Foo, " + " /** @lends {SubFoo.prototype} */ ({\n" + " /** @return {number} */ bar: function() { return 3; }}));" + "/** @return {string} */ function f() { return (new SubFoo()).bar(); }", "inconsistent return type\n" + "found : number\n" + "required: string"); } public void testDeclaredNativeTypeEquality() throws Exception { Node n = parseAndTypeCheck("/** @constructor */ function Object() {};"); assertTypeEquals(registry.getNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE), n.getFirstChild().getJSType()); } public void testUndefinedVar() throws Exception { Node n = parseAndTypeCheck("var undefined;"); assertTypeEquals(registry.getNativeType(JSTypeNative.VOID_TYPE), n.getFirstChild().getFirstChild().getJSType()); } public void testFlowScopeBug1() throws Exception { Node n = parseAndTypeCheck("/** @param {number} a \n" + "* @param {number} b */\n" + "function f(a, b) {\n" + "/** @type number */" + "var i = 0;" + "for (; (i + a) < b; ++i) {}}"); // check the type of the add node for i + f assertTypeEquals(registry.getNativeType(JSTypeNative.NUMBER_TYPE), n.getFirstChild().getLastChild().getLastChild().getFirstChild() .getNext().getFirstChild().getJSType()); } public void testFlowScopeBug2() throws Exception { Node n = parseAndTypeCheck("/** @constructor */ function Foo() {};\n" + "Foo.prototype.hi = false;" + "function foo(a, b) {\n" + " /** @type Array */" + " var arr;" + " /** @type number */" + " var iter;" + " for (iter = 0; iter < arr.length; ++ iter) {" + " /** @type Foo */" + " var afoo = arr[iter];" + " afoo;" + " }" + "}"); // check the type of afoo when referenced assertTypeEquals(registry.createNullableType(registry.getType("Foo")), n.getLastChild().getLastChild().getLastChild().getLastChild() .getLastChild().getLastChild().getJSType()); } public void testAddSingletonGetter() { Node n = parseAndTypeCheck( "/** @constructor */ function Foo() {};\n" + "goog.addSingletonGetter(Foo);"); ObjectType o = (ObjectType) n.getFirstChild().getJSType(); assertEquals("function (): Foo", o.getPropertyType("getInstance").toString()); assertEquals("Foo", o.getPropertyType("instance_").toString()); } public void testTypeCheckStandaloneAST() throws Exception { Node n = compiler.parseTestCode("function Foo() { }"); typeCheck(n); MemoizedScopeCreator scopeCreator = new MemoizedScopeCreator( new TypedScopeCreator(compiler)); Scope topScope = scopeCreator.createScope(n, null); Node second = compiler.parseTestCode("new Foo"); Node externs = new Node(Token.BLOCK); Node externAndJsRoot = new Node(Token.BLOCK, externs, second); externAndJsRoot.setIsSyntheticBlock(true); new TypeCheck( compiler, new SemanticReverseAbstractInterpreter( compiler.getCodingConvention(), registry), registry, topScope, scopeCreator, CheckLevel.WARNING, CheckLevel.OFF) .process(null, second); assertEquals(1, compiler.getWarningCount()); assertEquals("cannot instantiate non-constructor", compiler.getWarnings()[0].description); } public void testUpdateParameterTypeOnClosure() throws Exception { testTypes( "/**\n" + "* @constructor\n" + "* @param {*=} opt_value\n" + "* @return {?}\n" + "*/\n" + "function Object(opt_value) {}\n" + "/**\n" + "* @constructor\n" + "* @param {...*} var_args\n" + "*/\n" + "function Function(var_args) {}\n" + "/**\n" + "* @type {Function}\n" + "*/\n" + // The line below sets JSDocInfo on Object so that the type of the // argument to function f has JSDoc through its prototype chain. "Object.prototype.constructor = function() {};\n", "/**\n" + "* @param {function(): boolean} fn\n" + "*/\n" + "function f(fn) {}\n" + "f(function(g) { });\n", null, false); } public void testTemplatedThisType1() throws Exception { testTypes( "/** @constructor */\n" + "function Foo() {}\n" + "/**\n" + " * @this {T}\n" + " * @return {T}\n" + " * @template T\n" + " */\n" + "Foo.prototype.method = function() {};\n" + "/**\n" + " * @constructor\n" + " * @extends {Foo}\n" + " */\n" + "function Bar() {}\n" + "var g = new Bar().method();\n" + "/**\n" + " * @param {number} a\n" + " */\n" + "function compute(a) {};\n" + "compute(g);\n", "actual parameter 1 of compute does not match formal parameter\n" + "found : Bar\n" + "required: number"); } public void testTemplatedThisType2() throws Exception { testTypes( "/**\n" + " * @this {Array.<T>|{length:number}}\n" + " * @return {T}\n" + " * @template T\n" + " */\n" + "Array.prototype.method = function() {};\n" + "(function(){\n" + " Array.prototype.method.call(arguments);" + "})();"); } public void testTemplateType1() throws Exception { testTypes( "/**\n" + "* @param {T} x\n" + "* @param {T} y\n" + "* @param {function(this:T, ...)} z\n" + "* @template T\n" + "*/\n" + "function f(x, y, z) {}\n" + "f(this, this, function() { this });"); } public void testTemplateType2() throws Exception { // "this" types need to be coerced for ES3 style function or left // allow for ES5-strict methods. testTypes( "/**\n" + "* @param {T} x\n" + "* @param {function(this:T, ...)} y\n" + "* @template T\n" + "*/\n" + "function f(x, y) {}\n" + "f(0, function() {});"); } public void testTemplateType3() throws Exception { testTypes( "/**" + " * @param {T} v\n" + " * @param {function(T)} f\n" + " * @template T\n" + " */\n" + "function call(v, f) { f.call(null, v); }" + "/** @type {string} */ var s;" + "call(3, function(x) {" + " x = true;" + " s = x;" + "});", "assignment\n" + "found : boolean\n" + "required: string"); } public void testTemplateType4() throws Exception { testTypes( "/**" + " * @param {...T} p\n" + " * @return {T} \n" + " * @template T\n" + " */\n" + "function fn(p) { return p; }\n" + "/** @type {!Object} */ var x;" + "x = fn(3, null);", "assignment\n" + "found : (null|number)\n" + "required: Object"); } public void testTemplateType5() throws Exception { testTypes( "/**" + " * @param {Array.<T>} arr \n" + " * @param {?function(T)} f \n" + " * @return {T} \n" + " * @template T\n" + " */\n" + "function fn(arr, f) { return arr[0]; }\n" + "/** @param {Array.<number>} arr */ function g(arr) {" + " /** @type {!Object} */ var x = fn.call(null, arr, null);" + "}", "initializing variable\n" + "found : number\n" + "required: Object"); } public void disable_testBadTemplateType4() throws Exception { // TODO(johnlenz): Add a check for useless of template types. // Unless there are at least two references to a Template type in // a definition it isn't useful. testTypes( "/**\n" + "* @template T\n" + "*/\n" + "function f() {}\n" + "f();", FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format()); } public void disable_testBadTemplateType5() throws Exception { // TODO(johnlenz): Add a check for useless of template types. // Unless there are at least two references to a Template type in // a definition it isn't useful. testTypes( "/**\n" + "* @template T\n" + "* @return {T}\n" + "*/\n" + "function f() {}\n" + "f();", FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format()); } public void disable_testFunctionLiteralUndefinedThisArgument() throws Exception { // TODO(johnlenz): this was a weird error. We should add a general // restriction on what is accepted for T. Something like: // "@template T of {Object|string}" or some such. testTypes("" + "/**\n" + " * @param {function(this:T, ...)?} fn\n" + " * @param {?T} opt_obj\n" + " * @template T\n" + " */\n" + "function baz(fn, opt_obj) {}\n" + "baz(function() { this; });", "Function literal argument refers to undefined this argument"); } public void testFunctionLiteralDefinedThisArgument() throws Exception { testTypes("" + "/**\n" + " * @param {function(this:T, ...)?} fn\n" + " * @param {?T} opt_obj\n" + " * @template T\n" + " */\n" + "function baz(fn, opt_obj) {}\n" + "baz(function() { this; }, {});"); } public void testFunctionLiteralDefinedThisArgument2() throws Exception { testTypes("" + "/** @param {string} x */ function f(x) {}" + "/**\n" + " * @param {?function(this:T, ...)} fn\n" + " * @param {T=} opt_obj\n" + " * @template T\n" + " */\n" + "function baz(fn, opt_obj) {}\n" + "function g() { baz(function() { f(this.length); }, []); }", "actual parameter 1 of f does not match formal parameter\n" + "found : number\n" + "required: string"); } public void testFunctionLiteralUnreadNullThisArgument() throws Exception { testTypes("" + "/**\n" + " * @param {function(this:T, ...)?} fn\n" + " * @param {?T} opt_obj\n" + " * @template T\n" + " */\n" + "function baz(fn, opt_obj) {}\n" + "baz(function() {}, null);"); } public void testUnionTemplateThisType() throws Exception { testTypes( "/** @constructor */ function F() {}" + "/** @return {F|Array} */ function g() { return []; }" + "/** @param {F} x */ function h(x) { }" + "/**\n" + "* @param {T} x\n" + "* @param {function(this:T, ...)} y\n" + "* @template T\n" + "*/\n" + "function f(x, y) {}\n" + "f(g(), function() { h(this); });", "actual parameter 1 of h does not match formal parameter\n" + "found : (Array|F|null)\n" + "required: (F|null)"); } public void testActiveXObject() throws Exception { testTypes( "/** @type {Object} */ var x = new ActiveXObject();" + "/** @type { {impossibleProperty} } */ var y = new ActiveXObject();"); } public void testRecordType1() throws Exception { testTypes( "/** @param {{prop: number}} x */" + "function f(x) {}" + "f({});", "actual parameter 1 of f does not match formal parameter\n" + "found : {prop: (number|undefined)}\n" + "required: {prop: number}"); } public void testRecordType2() throws Exception { testTypes( "/** @param {{prop: (number|undefined)}} x */" + "function f(x) {}" + "f({});"); } public void testRecordType3() throws Exception { testTypes( "/** @param {{prop: number}} x */" + "function f(x) {}" + "f({prop: 'x'});", "actual parameter 1 of f does not match formal parameter\n" + "found : {prop: (number|string)}\n" + "required: {prop: number}"); } public void testRecordType4() throws Exception { // Notice that we do not do flow-based inference on the object type: // We don't try to prove that x.prop may not be string until x // gets passed to g. testClosureTypesMultipleWarnings( "/** @param {{prop: (number|undefined)}} x */" + "function f(x) {}" + "/** @param {{prop: (string|undefined)}} x */" + "function g(x) {}" + "var x = {}; f(x); g(x);", Lists.newArrayList( "actual parameter 1 of f does not match formal parameter\n" + "found : {prop: (number|string|undefined)}\n" + "required: {prop: (number|undefined)}", "actual parameter 1 of g does not match formal parameter\n" + "found : {prop: (number|string|undefined)}\n" + "required: {prop: (string|undefined)}")); } public void testRecordType5() throws Exception { testTypes( "/** @param {{prop: (number|undefined)}} x */" + "function f(x) {}" + "/** @param {{otherProp: (string|undefined)}} x */" + "function g(x) {}" + "var x = {}; f(x); g(x);"); } public void testRecordType6() throws Exception { testTypes( "/** @return {{prop: (number|undefined)}} x */" + "function f() { return {}; }"); } public void testRecordType7() throws Exception { testTypes( "/** @return {{prop: (number|undefined)}} x */" + "function f() { var x = {}; g(x); return x; }" + "/** @param {number} x */" + "function g(x) {}", "actual parameter 1 of g does not match formal parameter\n" + "found : {prop: (number|undefined)}\n" + "required: number"); } public void testRecordType8() throws Exception { testTypes( "/** @return {{prop: (number|string)}} x */" + "function f() { var x = {prop: 3}; g(x.prop); return x; }" + "/** @param {string} x */" + "function g(x) {}", "actual parameter 1 of g does not match formal parameter\n" + "found : number\n" + "required: string"); } public void testDuplicateRecordFields1() throws Exception { testTypes("/**" + "* @param {{x:string, x:number}} a" + "*/" + "function f(a) {};", "Parse error. Duplicate record field x"); } public void testDuplicateRecordFields2() throws Exception { testTypes("/**" + "* @param {{name:string,number:x,number:y}} a" + " */" + "function f(a) {};", new String[] {"Bad type annotation. Unknown type x", "Parse error. Duplicate record field number", "Bad type annotation. Unknown type y"}); } public void testMultipleExtendsInterface1() throws Exception { testTypes("/** @interface */ function base1() {}\n" + "/** @interface */ function base2() {}\n" + "/** @interface\n" + "* @extends {base1}\n" + "* @extends {base2}\n" + "*/\n" + "function derived() {}"); } public void testMultipleExtendsInterface2() throws Exception { testTypes( "/** @interface */function Int0() {};" + "/** @interface */function Int1() {};" + "/** @desc description */Int0.prototype.foo = function() {};" + "/** @interface \n @extends {Int0} \n @extends {Int1} */" + "function Int2() {};" + "/** @constructor\n @implements {Int2} */function Foo() {};", "property foo on interface Int0 is not implemented by type Foo"); } public void testMultipleExtendsInterface3() throws Exception { testTypes( "/** @interface */function Int0() {};" + "/** @interface */function Int1() {};" + "/** @desc description */Int1.prototype.foo = function() {};" + "/** @interface \n @extends {Int0} \n @extends {Int1} */" + "function Int2() {};" + "/** @constructor\n @implements {Int2} */function Foo() {};", "property foo on interface Int1 is not implemented by type Foo"); } public void testMultipleExtendsInterface4() throws Exception { testTypes( "/** @interface */function Int0() {};" + "/** @interface */function Int1() {};" + "/** @interface \n @extends {Int0} \n @extends {Int1} \n" + " @extends {number} */" + "function Int2() {};" + "/** @constructor\n @implements {Int2} */function Foo() {};", "Int2 @extends non-object type number"); } public void testMultipleExtendsInterface5() throws Exception { testTypes( "/** @interface */function Int0() {};" + "/** @constructor */function Int1() {};" + "/** @desc description @ return {string} x */" + "/** @interface \n @extends {Int0} \n @extends {Int1} */" + "function Int2() {};", "Int2 cannot extend this type; interfaces can only extend interfaces"); } public void testMultipleExtendsInterface6() throws Exception { testTypes( "/** @interface */function Super1() {};" + "/** @interface */function Super2() {};" + "/** @param {number} bar */Super2.prototype.foo = function(bar) {};" + "/** @interface\n @extends {Super1}\n " + "@extends {Super2} */function Sub() {};" + "/** @override\n @param {string} bar */Sub.prototype.foo =\n" + "function(bar) {};", "mismatch of the foo property type and the type of the property it " + "overrides from superclass Super2\n" + "original: function (this:Super2, number): undefined\n" + "override: function (this:Sub, string): undefined"); } public void testMultipleExtendsInterfaceAssignment() throws Exception { testTypes("/** @interface */var I1 = function() {};\n" + "/** @interface */ var I2 = function() {}\n" + "/** @interface\n@extends {I1}\n@extends {I2}*/" + "var I3 = function() {};\n" + "/** @constructor\n@implements {I3}*/var T = function() {};\n" + "var t = new T();\n" + "/** @type {I1} */var i1 = t;\n" + "/** @type {I2} */var i2 = t;\n" + "/** @type {I3} */var i3 = t;\n" + "i1 = i3;\n" + "i2 = i3;\n"); } public void testMultipleExtendsInterfaceParamPass() throws Exception { testTypes("/** @interface */var I1 = function() {};\n" + "/** @interface */ var I2 = function() {}\n" + "/** @interface\n@extends {I1}\n@extends {I2}*/" + "var I3 = function() {};\n" + "/** @constructor\n@implements {I3}*/var T = function() {};\n" + "var t = new T();\n" + "/** @param x I1 \n@param y I2\n@param z I3*/function foo(x,y,z){};\n" + "foo(t,t,t)\n"); } public void testBadMultipleExtendsClass() throws Exception { testTypes("/** @constructor */ function base1() {}\n" + "/** @constructor */ function base2() {}\n" + "/** @constructor\n" + "* @extends {base1}\n" + "* @extends {base2}\n" + "*/\n" + "function derived() {}", "Bad type annotation. type annotation incompatible " + "with other annotations"); } public void testInterfaceExtendsResolution() throws Exception { testTypes("/** @interface \n @extends {A} */ function B() {};\n" + "/** @constructor \n @implements {B} */ function C() {};\n" + "/** @interface */ function A() {};"); } public void testPropertyCanBeDefinedInObject() throws Exception { testTypes("/** @interface */ function I() {};" + "I.prototype.bar = function() {};" + "/** @type {Object} */ var foo;" + "foo.bar();"); } private void checkObjectType(ObjectType objectType, String propertyName, JSType expectedType) { assertTrue("Expected " + objectType.getReferenceName() + " to have property " + propertyName, objectType.hasProperty(propertyName)); assertTypeEquals("Expected " + objectType.getReferenceName() + "'s property " + propertyName + " to have type " + expectedType, expectedType, objectType.getPropertyType(propertyName)); } public void testExtendedInterfacePropertiesCompatibility1() throws Exception { testTypes( "/** @interface */function Int0() {};" + "/** @interface */function Int1() {};" + "/** @type {number} */" + "Int0.prototype.foo;" + "/** @type {string} */" + "Int1.prototype.foo;" + "/** @interface \n @extends {Int0} \n @extends {Int1} */" + "function Int2() {};", "Interface Int2 has a property foo with incompatible types in its " + "super interfaces Int0 and Int1"); } public void testExtendedInterfacePropertiesCompatibility2() throws Exception { testTypes( "/** @interface */function Int0() {};" + "/** @interface */function Int1() {};" + "/** @interface */function Int2() {};" + "/** @type {number} */" + "Int0.prototype.foo;" + "/** @type {string} */" + "Int1.prototype.foo;" + "/** @type {Object} */" + "Int2.prototype.foo;" + "/** @interface \n @extends {Int0} \n @extends {Int1} \n" + "@extends {Int2}*/" + "function Int3() {};", new String[] { "Interface Int3 has a property foo with incompatible types in " + "its super interfaces Int0 and Int1", "Interface Int3 has a property foo with incompatible types in " + "its super interfaces Int1 and Int2" }); } public void testExtendedInterfacePropertiesCompatibility3() throws Exception { testTypes( "/** @interface */function Int0() {};" + "/** @interface */function Int1() {};" + "/** @type {number} */" + "Int0.prototype.foo;" + "/** @type {string} */" + "Int1.prototype.foo;" + "/** @interface \n @extends {Int1} */ function Int2() {};" + "/** @interface \n @extends {Int0} \n @extends {Int2} */" + "function Int3() {};", "Interface Int3 has a property foo with incompatible types in its " + "super interfaces Int0 and Int1"); } public void testExtendedInterfacePropertiesCompatibility4() throws Exception { testTypes( "/** @interface */function Int0() {};" + "/** @interface \n @extends {Int0} */ function Int1() {};" + "/** @type {number} */" + "Int0.prototype.foo;" + "/** @interface */function Int2() {};" + "/** @interface \n @extends {Int2} */ function Int3() {};" + "/** @type {string} */" + "Int2.prototype.foo;" + "/** @interface \n @extends {Int1} \n @extends {Int3} */" + "function Int4() {};", "Interface Int4 has a property foo with incompatible types in its " + "super interfaces Int0 and Int2"); } public void testExtendedInterfacePropertiesCompatibility5() throws Exception { testTypes( "/** @interface */function Int0() {};" + "/** @interface */function Int1() {};" + "/** @type {number} */" + "Int0.prototype.foo;" + "/** @type {string} */" + "Int1.prototype.foo;" + "/** @interface \n @extends {Int1} */ function Int2() {};" + "/** @interface \n @extends {Int0} \n @extends {Int2} */" + "function Int3() {};" + "/** @interface */function Int4() {};" + "/** @type {number} */" + "Int4.prototype.foo;" + "/** @interface \n @extends {Int3} \n @extends {Int4} */" + "function Int5() {};", new String[] { "Interface Int3 has a property foo with incompatible types in its" + " super interfaces Int0 and Int1", "Interface Int5 has a property foo with incompatible types in its" + " super interfaces Int1 and Int4"}); } public void testExtendedInterfacePropertiesCompatibility6() throws Exception { testTypes( "/** @interface */function Int0() {};" + "/** @interface */function Int1() {};" + "/** @type {number} */" + "Int0.prototype.foo;" + "/** @type {string} */" + "Int1.prototype.foo;" + "/** @interface \n @extends {Int1} */ function Int2() {};" + "/** @interface \n @extends {Int0} \n @extends {Int2} */" + "function Int3() {};" + "/** @interface */function Int4() {};" + "/** @type {string} */" + "Int4.prototype.foo;" + "/** @interface \n @extends {Int3} \n @extends {Int4} */" + "function Int5() {};", "Interface Int3 has a property foo with incompatible types in its" + " super interfaces Int0 and Int1"); } public void testExtendedInterfacePropertiesCompatibility7() throws Exception { testTypes( "/** @interface */function Int0() {};" + "/** @interface */function Int1() {};" + "/** @type {number} */" + "Int0.prototype.foo;" + "/** @type {string} */" + "Int1.prototype.foo;" + "/** @interface \n @extends {Int1} */ function Int2() {};" + "/** @interface \n @extends {Int0} \n @extends {Int2} */" + "function Int3() {};" + "/** @interface */function Int4() {};" + "/** @type {Object} */" + "Int4.prototype.foo;" + "/** @interface \n @extends {Int3} \n @extends {Int4} */" + "function Int5() {};", new String[] { "Interface Int3 has a property foo with incompatible types in its" + " super interfaces Int0 and Int1", "Interface Int5 has a property foo with incompatible types in its" + " super interfaces Int1 and Int4"}); } public void testExtendedInterfacePropertiesCompatibility8() throws Exception { testTypes( "/** @interface */function Int0() {};" + "/** @interface */function Int1() {};" + "/** @type {number} */" + "Int0.prototype.foo;" + "/** @type {string} */" + "Int1.prototype.bar;" + "/** @interface \n @extends {Int1} */ function Int2() {};" + "/** @interface \n @extends {Int0} \n @extends {Int2} */" + "function Int3() {};" + "/** @interface */function Int4() {};" + "/** @type {Object} */" + "Int4.prototype.foo;" + "/** @type {Null} */" + "Int4.prototype.bar;" + "/** @interface \n @extends {Int3} \n @extends {Int4} */" + "function Int5() {};", new String[] { "Interface Int5 has a property bar with incompatible types in its" + " super interfaces Int1 and Int4", "Interface Int5 has a property foo with incompatible types in its" + " super interfaces Int0 and Int4"}); } public void testGenerics1() throws Exception { String FN_DECL = "/** \n" + " * @param {T} x \n" + " * @param {function(T):T} y \n" + " * @template T\n" + " */ \n" + "function f(x,y) { return y(x); }\n"; testTypes( FN_DECL + "/** @type {string} */" + "var out;" + "/** @type {string} */" + "var result = f('hi', function(x){ out = x; return x; });"); testTypes( FN_DECL + "/** @type {string} */" + "var out;" + "var result = f(0, function(x){ out = x; return x; });", "assignment\n" + "found : number\n" + "required: string"); testTypes( FN_DECL + "var out;" + "/** @type {string} */" + "var result = f(0, function(x){ out = x; return x; });", "assignment\n" + "found : number\n" + "required: string"); } public void testFilter0() throws Exception { testTypes( "/**\n" + " * @param {T} arr\n" + " * @return {T}\n" + " * @template T\n" + " */\n" + "var filter = function(arr){};\n" + "/** @type {!Array.<string>} */" + "var arr;\n" + "/** @type {!Array.<string>} */" + "var result = filter(arr);"); } public void testFilter1() throws Exception { testTypes( "/**\n" + " * @param {!Array.<T>} arr\n" + " * @return {!Array.<T>}\n" + " * @template T\n" + " */\n" + "var filter = function(arr){};\n" + "/** @type {!Array.<string>} */" + "var arr;\n" + "/** @type {!Array.<string>} */" + "var result = filter(arr);"); } public void testFilter2() throws Exception { testTypes( "/**\n" + " * @param {!Array.<T>} arr\n" + " * @return {!Array.<T>}\n" + " * @template T\n" + " */\n" + "var filter = function(arr){};\n" + "/** @type {!Array.<string>} */" + "var arr;\n" + "/** @type {!Array.<number>} */" + "var result = filter(arr);", "initializing variable\n" + "found : Array.<string>\n" + "required: Array.<number>"); } public void testFilter3() throws Exception { testTypes( "/**\n" + " * @param {Array.<T>} arr\n" + " * @return {Array.<T>}\n" + " * @template T\n" + " */\n" + "var filter = function(arr){};\n" + "/** @type {Array.<string>} */" + "var arr;\n" + "/** @type {Array.<number>} */" + "var result = filter(arr);", "initializing variable\n" + "found : (Array.<string>|null)\n" + "required: (Array.<number>|null)"); } public void testBackwardsInferenceGoogArrayFilter1() throws Exception { testClosureTypes( CLOSURE_DEFS + "/** @type {Array.<string>} */" + "var arr;\n" + "/** @type {!Array.<number>} */" + "var result = goog.array.filter(" + " arr," + " function(item,index,src) {return false;});", "initializing variable\n" + "found : Array.<string>\n" + "required: Array.<number>"); } public void testBackwardsInferenceGoogArrayFilter2() throws Exception { testClosureTypes( CLOSURE_DEFS + "/** @type {number} */" + "var out;" + "/** @type {Array.<string>} */" + "var arr;\n" + "var out4 = goog.array.filter(" + " arr," + " function(item,index,src) {out = item;});", "assignment\n" + "found : string\n" + "required: number"); } public void testBackwardsInferenceGoogArrayFilter3() throws Exception { testClosureTypes( CLOSURE_DEFS + "/** @type {string} */" + "var out;" + "/** @type {Array.<string>} */ var arr;\n" + "var result = goog.array.filter(" + " arr," + " function(item,index,src) {out = index;});", "assignment\n" + "found : number\n" + "required: string"); } public void testBackwardsInferenceGoogArrayFilter4() throws Exception { testClosureTypes( CLOSURE_DEFS + "/** @type {string} */" + "var out;" + "/** @type {Array.<string>} */ var arr;\n" + "var out4 = goog.array.filter(" + " arr," + " function(item,index,srcArr) {out = srcArr;});", "assignment\n" + "found : (null|{length: number})\n" + "required: string"); } public void testCatchExpression1() throws Exception { testTypes( "function fn() {" + " /** @type {number} */" + " var out = 0;" + " try {\n" + " foo();\n" + " } catch (/** @type {string} */ e) {\n" + " out = e;" + " }" + "}\n", "assignment\n" + "found : string\n" + "required: number"); } public void testCatchExpression2() throws Exception { testTypes( "function fn() {" + " /** @type {number} */" + " var out = 0;" + " /** @type {string} */" + " var e;" + " try {\n" + " foo();\n" + " } catch (e) {\n" + " out = e;" + " }" + "}\n"); } public void testParameterized1() throws Exception { testTypes( "/** @type {!Array.<string>} */" + "var arr1 = [];\n" + "/** @type {!Array.<number>} */" + "var arr2 = [];\n" + "arr1 = arr2;", "assignment\n" + "found : Array.<number>\n" + "required: Array.<string>"); } public void testParameterized2() throws Exception { testTypes( "/** @type {!Array.<string>} */" + "var arr1 = /** @type {!Array.<number>} */([]);\n", "initializing variable\n" + "found : Array.<number>\n" + "required: Array.<string>"); } public void testParameterized3() throws Exception { testTypes( "/** @type {Array.<string>} */" + "var arr1 = /** @type {!Array.<number>} */([]);\n", "initializing variable\n" + "found : Array.<number>\n" + "required: (Array.<string>|null)"); } public void testParameterized4() throws Exception { testTypes( "/** @type {Array.<string>} */" + "var arr1 = [];\n" + "/** @type {Array.<number>} */" + "var arr2 = arr1;\n", "initializing variable\n" + "found : (Array.<string>|null)\n" + "required: (Array.<number>|null)"); } public void testParameterized5() throws Exception { testTypes( "/**\n" + " * @param {Object.<T>} obj\n" + " * @return {boolean|undefined}\n" + " * @template T\n" + " */\n" + "var some = function(obj) {" + " for (var key in obj) if (obj[key]) return true;" + "};" + "/** @return {!Array} */ function f() { return []; }" + "/** @return {!Array.<string>} */ function g() { return []; }" + "some(f());\n" + "some(g());\n"); } public void testParameterizedTypeSubtypes2() throws Exception { JSType arrayOfNumber = createParameterizedType( ARRAY_TYPE, NUMBER_TYPE); JSType arrayOfString = createParameterizedType( ARRAY_TYPE, STRING_TYPE); assertFalse(arrayOfString.isSubtype(createUnionType(arrayOfNumber, NULL_VOID))); } private void testTypes(String js) throws Exception { testTypes(js, (String) null); } private void testTypes(String js, String description) throws Exception { testTypes(js, description, false); } private void testTypes(String js, DiagnosticType type) throws Exception { testTypes(js, type.format(), false); } private void testClosureTypes(String js, String description) throws Exception { testClosureTypesMultipleWarnings(js, description == null ? null : Lists.newArrayList(description)); } private void testClosureTypesMultipleWarnings( String js, List<String> descriptions) throws Exception { Node n = compiler.parseTestCode(js); Node externs = new Node(Token.BLOCK); Node externAndJsRoot = new Node(Token.BLOCK, externs, n); externAndJsRoot.setIsSyntheticBlock(true); assertEquals("parsing error: " + Joiner.on(", ").join(compiler.getErrors()), 0, compiler.getErrorCount()); // For processing goog.addDependency for forward typedefs. new ProcessClosurePrimitives(compiler, null, CheckLevel.ERROR) .process(null, n); CodingConvention convention = compiler.getCodingConvention(); new TypeCheck(compiler, new ClosureReverseAbstractInterpreter( convention, registry).append( new SemanticReverseAbstractInterpreter( convention, registry)) .getFirst(), registry) .processForTesting(null, n); assertEquals( "unexpected error(s) : " + Joiner.on(", ").join(compiler.getErrors()), 0, compiler.getErrorCount()); if (descriptions == null) { assertEquals( "unexpected warning(s) : " + Joiner.on(", ").join(compiler.getWarnings()), 0, compiler.getWarningCount()); } else { assertEquals( "unexpected warning(s) : " + Joiner.on(", ").join(compiler.getWarnings()), descriptions.size(), compiler.getWarningCount()); Set<String> actualWarningDescriptions = Sets.newHashSet(); for (int i = 0; i < descriptions.size(); i++) { actualWarningDescriptions.add(compiler.getWarnings()[i].description); } assertEquals( Sets.newHashSet(descriptions), actualWarningDescriptions); } } void testTypes(String js, String description, boolean isError) throws Exception { testTypes(DEFAULT_EXTERNS, js, description, isError); } void testTypes(String externs, String js, String description, boolean isError) throws Exception { Node n = parseAndTypeCheck(externs, js); JSError[] errors = compiler.getErrors(); if (description != null && isError) { assertTrue("expected an error", errors.length > 0); assertEquals(description, errors[0].description); errors = Arrays.asList(errors).subList(1, errors.length).toArray( new JSError[errors.length - 1]); } if (errors.length > 0) { fail("unexpected error(s):\n" + Joiner.on("\n").join(errors)); } JSError[] warnings = compiler.getWarnings(); if (description != null && !isError) { assertTrue("expected a warning", warnings.length > 0); assertEquals(description, warnings[0].description); warnings = Arrays.asList(warnings).subList(1, warnings.length).toArray( new JSError[warnings.length - 1]); } if (warnings.length > 0) { fail("unexpected warnings(s):\n" + Joiner.on("\n").join(warnings)); } } /** * Parses and type checks the JavaScript code. */ private Node parseAndTypeCheck(String js) { return parseAndTypeCheck(DEFAULT_EXTERNS, js); } private Node parseAndTypeCheck(String externs, String js) { return parseAndTypeCheckWithScope(externs, js).root; } /** * Parses and type checks the JavaScript code and returns the Scope used * whilst type checking. */ private TypeCheckResult parseAndTypeCheckWithScope(String js) { return parseAndTypeCheckWithScope(DEFAULT_EXTERNS, js); } private TypeCheckResult parseAndTypeCheckWithScope( String externs, String js) { compiler.init( Lists.newArrayList(SourceFile.fromCode("[externs]", externs)), Lists.newArrayList(SourceFile.fromCode("[testcode]", js)), compiler.getOptions()); Node n = compiler.getInput(new InputId("[testcode]")).getAstRoot(compiler); Node externsNode = compiler.getInput(new InputId("[externs]")) .getAstRoot(compiler); Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n); externAndJsRoot.setIsSyntheticBlock(true); assertEquals("parsing error: " + Joiner.on(", ").join(compiler.getErrors()), 0, compiler.getErrorCount()); Scope s = makeTypeCheck().processForTesting(externsNode, n); return new TypeCheckResult(n, s); } private Node typeCheck(Node n) { Node externsNode = new Node(Token.BLOCK); Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n); externAndJsRoot.setIsSyntheticBlock(true); makeTypeCheck().processForTesting(null, n); return n; } private TypeCheck makeTypeCheck() { return new TypeCheck( compiler, new SemanticReverseAbstractInterpreter( compiler.getCodingConvention(), registry), registry, reportMissingOverrides, CheckLevel.OFF); } void testTypes(String js, String[] warnings) throws Exception { Node n = compiler.parseTestCode(js); assertEquals(0, compiler.getErrorCount()); Node externsNode = new Node(Token.BLOCK); Node externAndJsRoot = new Node(Token.BLOCK, externsNode, n); makeTypeCheck().processForTesting(null, n); assertEquals(0, compiler.getErrorCount()); if (warnings != null) { assertEquals(warnings.length, compiler.getWarningCount()); JSError[] messages = compiler.getWarnings(); for (int i = 0; i < warnings.length && i < compiler.getWarningCount(); i++) { assertEquals(warnings[i], messages[i].description); } } else { assertEquals(0, compiler.getWarningCount()); } } String suppressMissingProperty(String ... props) { String result = "function dummy(x) { "; for (String prop : props) { result += "x." + prop + " = 3;"; } return result + "}"; } private static class TypeCheckResult { private final Node root; private final Scope scope; private TypeCheckResult(Node root, Scope scope) { this.root = root; this.scope = scope; } } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import static com.google.javascript.rhino.jstype.JSTypeNative.ALL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.CHECKED_UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.FUNCTION_INSTANCE_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NO_RESOLVED_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE; import com.google.common.base.Joiner; import com.google.common.collect.ImmutableList; import com.google.common.collect.Maps; import com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec; import com.google.javascript.jscomp.CompilerOptions.LanguageMode; import com.google.javascript.jscomp.DataFlowAnalysis.BranchedFlowState; import com.google.javascript.jscomp.type.FlowScope; import com.google.javascript.jscomp.type.ReverseAbstractInterpreter; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.jstype.EnumType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.StaticSlot; import com.google.javascript.rhino.testing.Asserts; import junit.framework.TestCase; import java.util.Map; /** * Tests {@link TypeInference}. * */ public class TypeInferenceTest extends TestCase { private Compiler compiler; private JSTypeRegistry registry; private Map<String, JSType> assumptions; private JSType assumedThisType; private FlowScope returnScope; private static final Map<String, AssertionFunctionSpec> ASSERTION_FUNCTION_MAP = Maps.newHashMap(); static { for (AssertionFunctionSpec func : new ClosureCodingConvention().getAssertionFunctions()) { ASSERTION_FUNCTION_MAP.put(func.getFunctionName(), func); } } @Override public void setUp() { compiler = new Compiler(); CompilerOptions options = new CompilerOptions(); options.setClosurePass(true); options.setLanguageIn(LanguageMode.ECMASCRIPT5); compiler.initOptions(options); registry = compiler.getTypeRegistry(); assumptions = Maps.newHashMap(); returnScope = null; } private void assumingThisType(JSType type) { assumedThisType = type; } private void assuming(String name, JSType type) { assumptions.put(name, type); } private void assuming(String name, JSTypeNative type) { assuming(name, registry.getNativeType(type)); } private void inFunction(String js) { // Parse the body of the function. String thisBlock = assumedThisType == null ? "" : "/** @this {" + assumedThisType + "} */"; Node root = compiler.parseTestCode( "(" + thisBlock + " function() {" + js + "});"); assertEquals("parsing error: " + Joiner.on(", ").join(compiler.getErrors()), 0, compiler.getErrorCount()); Node n = root.getFirstChild().getFirstChild(); // Create the scope with the assumptions. TypedScopeCreator scopeCreator = new TypedScopeCreator(compiler); Scope assumedScope = scopeCreator.createScope( n, scopeCreator.createScope(root, null)); for (Map.Entry<String,JSType> entry : assumptions.entrySet()) { assumedScope.declare(entry.getKey(), null, entry.getValue(), null, false); } // Create the control graph. ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, false); cfa.process(null, n); ControlFlowGraph<Node> cfg = cfa.getCfg(); // Create a simple reverse abstract interpreter. ReverseAbstractInterpreter rai = compiler.getReverseAbstractInterpreter(); // Do the type inference by data-flow analysis. TypeInference dfa = new TypeInference(compiler, cfg, rai, assumedScope, ASSERTION_FUNCTION_MAP); dfa.analyze(); // Get the scope of the implicit return. BranchedFlowState<FlowScope> rtnState = cfg.getImplicitReturn().getAnnotation(); returnScope = rtnState.getIn(); } private JSType getType(String name) { assertTrue("The return scope should not be null.", returnScope != null); StaticSlot<JSType> var = returnScope.getSlot(name); assertTrue("The variable " + name + " is missing from the scope.", var != null); return var.getType(); } private void verify(String name, JSType type) { Asserts.assertTypeEquals("Mismatch for " + name, type, getType(name)); } private void verify(String name, JSTypeNative type) { verify(name, registry.getNativeType(type)); } private void verifySubtypeOf(String name, JSType type) { JSType varType = getType(name); assertTrue("The variable " + name + " is missing a type.", varType != null); assertTrue("The type " + varType + " of variable " + name + " is not a subtype of " + type +".", varType.isSubtype(type)); } private void verifySubtypeOf(String name, JSTypeNative type) { verifySubtypeOf(name, registry.getNativeType(type)); } private EnumType createEnumType(String name, JSTypeNative elemType) { return createEnumType(name, registry.getNativeType(elemType)); } private EnumType createEnumType(String name, JSType elemType) { return registry.createEnumType(name, null, elemType); } private JSType createUndefinableType(JSTypeNative type) { return registry.createUnionType( registry.getNativeType(type), registry.getNativeType(VOID_TYPE)); } private JSType createNullableType(JSTypeNative type) { return createNullableType(registry.getNativeType(type)); } private JSType createNullableType(JSType type) { return registry.createNullableType(type); } private JSType createUnionType(JSTypeNative type1, JSTypeNative type2) { return registry.createUnionType( registry.getNativeType(type1), registry.getNativeType(type2)); } public void testAssumption() { assuming("x", NUMBER_TYPE); inFunction(""); verify("x", NUMBER_TYPE); } public void testVar() { inFunction("var x = 1;"); verify("x", NUMBER_TYPE); } public void testEmptyVar() { inFunction("var x;"); verify("x", VOID_TYPE); } public void testAssignment() { assuming("x", OBJECT_TYPE); inFunction("x = 1;"); verify("x", NUMBER_TYPE); } public void testExprWithinCast() { assuming("x", OBJECT_TYPE); inFunction("/** @type {string} */ (x = 1);"); verify("x", NUMBER_TYPE); } public void testGetProp() { assuming("x", createNullableType(OBJECT_TYPE)); inFunction("x.y();"); verify("x", OBJECT_TYPE); } public void testGetElemDereference() { assuming("x", createUndefinableType(OBJECT_TYPE)); inFunction("x['z'] = 3;"); verify("x", OBJECT_TYPE); } public void testIf1() { assuming("x", createNullableType(OBJECT_TYPE)); inFunction("var y = {}; if (x) { y = x; }"); verifySubtypeOf("y", OBJECT_TYPE); } public void testIf1a() { assuming("x", createNullableType(OBJECT_TYPE)); inFunction("var y = {}; if (x != null) { y = x; }"); verifySubtypeOf("y", OBJECT_TYPE); } public void testIf2() { assuming("x", createNullableType(OBJECT_TYPE)); inFunction("var y = x; if (x) { y = x; } else { y = {}; }"); verifySubtypeOf("y", OBJECT_TYPE); } public void testIf3() { assuming("x", createNullableType(OBJECT_TYPE)); inFunction("var y = 1; if (x) { y = x; }"); verify("y", createUnionType(OBJECT_TYPE, NUMBER_TYPE)); } public void testPropertyInference1() { ObjectType thisType = registry.createAnonymousObjectType(null); thisType.defineDeclaredProperty("foo", createUndefinableType(STRING_TYPE), null); assumingThisType(thisType); inFunction("var y = 1; if (this.foo) { y = this.foo; }"); verify("y", createUnionType(NUMBER_TYPE, STRING_TYPE)); } public void testPropertyInference2() { ObjectType thisType = registry.createAnonymousObjectType(null); thisType.defineDeclaredProperty("foo", createUndefinableType(STRING_TYPE), null); assumingThisType(thisType); inFunction("var y = 1; this.foo = 'x'; y = this.foo;"); verify("y", STRING_TYPE); } public void testPropertyInference3() { ObjectType thisType = registry.createAnonymousObjectType(null); thisType.defineDeclaredProperty("foo", createUndefinableType(STRING_TYPE), null); assumingThisType(thisType); inFunction("var y = 1; this.foo = x; y = this.foo;"); verify("y", CHECKED_UNKNOWN_TYPE); } public void testAssert1() { JSType startType = createNullableType(OBJECT_TYPE); assuming("x", startType); inFunction("out1 = x; goog.asserts.assert(x); out2 = x;"); verify("out1", startType); verify("out2", OBJECT_TYPE); } public void testAssert1a() { JSType startType = createNullableType(OBJECT_TYPE); assuming("x", startType); inFunction("out1 = x; goog.asserts.assert(x !== null); out2 = x;"); verify("out1", startType); verify("out2", OBJECT_TYPE); } public void testAssert2() { JSType startType = createNullableType(OBJECT_TYPE); assuming("x", startType); inFunction("goog.asserts.assert(1, x); out1 = x;"); verify("out1", startType); } public void testAssert3() { JSType startType = createNullableType(OBJECT_TYPE); assuming("x", startType); assuming("y", startType); inFunction("out1 = x; goog.asserts.assert(x && y); out2 = x; out3 = y;"); verify("out1", startType); verify("out2", OBJECT_TYPE); verify("out3", OBJECT_TYPE); } public void testAssert4() { JSType startType = createNullableType(OBJECT_TYPE); assuming("x", startType); assuming("y", startType); inFunction("out1 = x; goog.asserts.assert(x && !y); out2 = x; out3 = y;"); verify("out1", startType); verify("out2", OBJECT_TYPE); verify("out3", NULL_TYPE); } public void testAssert5() { JSType startType = createNullableType(OBJECT_TYPE); assuming("x", startType); assuming("y", startType); inFunction("goog.asserts.assert(x || y); out1 = x; out2 = y;"); verify("out1", startType); verify("out2", startType); } public void testAssert6() { JSType startType = createNullableType(OBJECT_TYPE); assuming("x.y", startType); inFunction("out1 = x.y; goog.asserts.assert(x.y); out2 = x.y;"); verify("out1", startType); verify("out2", OBJECT_TYPE); } public void testAssert7() { JSType startType = createNullableType(OBJECT_TYPE); assuming("x", startType); inFunction("out1 = x; out2 = goog.asserts.assert(x);"); verify("out1", startType); verify("out2", OBJECT_TYPE); } public void testAssert8() { JSType startType = createNullableType(OBJECT_TYPE); assuming("x", startType); inFunction("out1 = x; out2 = goog.asserts.assert(x != null);"); verify("out1", startType); verify("out2", BOOLEAN_TYPE); } public void testAssert9() { JSType startType = createNullableType(NUMBER_TYPE); assuming("x", startType); inFunction("out1 = x; out2 = goog.asserts.assert(y = x);"); verify("out1", startType); verify("out2", NUMBER_TYPE); } public void testAssert10() { JSType startType = createNullableType(OBJECT_TYPE); assuming("x", startType); assuming("y", startType); inFunction("out1 = x; out2 = goog.asserts.assert(x && y); out3 = x;"); verify("out1", startType); verify("out2", OBJECT_TYPE); verify("out3", OBJECT_TYPE); } public void testAssertNumber() { JSType startType = createNullableType(ALL_TYPE); assuming("x", startType); inFunction("out1 = x; goog.asserts.assertNumber(x); out2 = x;"); verify("out1", startType); verify("out2", NUMBER_TYPE); } public void testAssertNumber2() { // Make sure it ignores expressions. JSType startType = createNullableType(ALL_TYPE); assuming("x", startType); inFunction("goog.asserts.assertNumber(x + x); out1 = x;"); verify("out1", startType); } public void testAssertNumber3() { // Make sure it ignores expressions. JSType startType = createNullableType(ALL_TYPE); assuming("x", startType); inFunction("out1 = x; out2 = goog.asserts.assertNumber(x + x);"); verify("out1", startType); verify("out2", NUMBER_TYPE); } public void testAssertString() { JSType startType = createNullableType(ALL_TYPE); assuming("x", startType); inFunction("out1 = x; goog.asserts.assertString(x); out2 = x;"); verify("out1", startType); verify("out2", STRING_TYPE); } public void testAssertFunction() { JSType startType = createNullableType(ALL_TYPE); assuming("x", startType); inFunction("out1 = x; goog.asserts.assertFunction(x); out2 = x;"); verify("out1", startType); verifySubtypeOf("out2", FUNCTION_INSTANCE_TYPE); } public void testAssertObject() { JSType startType = createNullableType(ALL_TYPE); assuming("x", startType); inFunction("out1 = x; goog.asserts.assertObject(x); out2 = x;"); verify("out1", startType); verifySubtypeOf("out2", OBJECT_TYPE); } public void testAssertObject2() { JSType startType = createNullableType(ARRAY_TYPE); assuming("x", startType); inFunction("out1 = x; goog.asserts.assertObject(x); out2 = x;"); verify("out1", startType); verify("out2", ARRAY_TYPE); } public void testAssertObject3() { JSType startType = createNullableType(OBJECT_TYPE); assuming("x.y", startType); inFunction("out1 = x.y; goog.asserts.assertObject(x.y); out2 = x.y;"); verify("out1", startType); verify("out2", OBJECT_TYPE); } public void testAssertObject4() { JSType startType = createNullableType(ARRAY_TYPE); assuming("x", startType); inFunction("out1 = x; out2 = goog.asserts.assertObject(x);"); verify("out1", startType); verify("out2", ARRAY_TYPE); } public void testAssertObject5() { JSType startType = createNullableType(ALL_TYPE); assuming("x", startType); inFunction( "out1 = x;" + "out2 = /** @type {!Array} */ (goog.asserts.assertObject(x));"); verify("out1", startType); verify("out2", ARRAY_TYPE); } public void testAssertArray() { JSType startType = createNullableType(ALL_TYPE); assuming("x", startType); inFunction("out1 = x; goog.asserts.assertArray(x); out2 = x;"); verify("out1", startType); verifySubtypeOf("out2", ARRAY_TYPE); } public void testAssertInstanceof1() { JSType startType = createNullableType(ALL_TYPE); assuming("x", startType); inFunction("out1 = x; goog.asserts.assertInstanceof(x); out2 = x;"); verify("out1", startType); verify("out2", OBJECT_TYPE); } public void testAssertInstanceof2() { JSType startType = createNullableType(ALL_TYPE); assuming("x", startType); inFunction("out1 = x; goog.asserts.assertInstanceof(x, String); out2 = x;"); verify("out1", startType); verify("out2", STRING_OBJECT_TYPE); } public void testAssertInstanceof3() { JSType startType = registry.getNativeType(UNKNOWN_TYPE); assuming("x", startType); inFunction("out1 = x; goog.asserts.assertInstanceof(x, String); out2 = x;"); verify("out1", startType); verify("out2", UNKNOWN_TYPE); } public void testAssertInstanceof4() { JSType startType = registry.getNativeType(STRING_OBJECT_TYPE); assuming("x", startType); inFunction("out1 = x; goog.asserts.assertInstanceof(x, Object); out2 = x;"); verify("out1", startType); verify("out2", STRING_OBJECT_TYPE); } public void testAssertInstanceof5() { JSType startType = registry.getNativeType(ALL_TYPE); assuming("x", startType); inFunction( "out1 = x; goog.asserts.assertInstanceof(x, String); var r = x;"); verify("out1", startType); verify("x", STRING_OBJECT_TYPE); } public void testAssertWithIsDefAndNotNull() { JSType startType = createNullableType(NUMBER_TYPE); assuming("x", startType); inFunction( "out1 = x;" + "goog.asserts.assert(goog.isDefAndNotNull(x));" + "out2 = x;"); verify("out1", startType); verify("out2", NUMBER_TYPE); } public void testIsDefAndNoResolvedType() { JSType startType = createUndefinableType(NO_RESOLVED_TYPE); assuming("x", startType); inFunction( "out1 = x;" + "if (goog.isDef(x)) { out2a = x; out2b = x.length; out2c = x; }" + "out3 = x;" + "if (goog.isDef(x)) { out4 = x; }"); verify("out1", startType); verify("out2a", NO_RESOLVED_TYPE); verify("out2b", CHECKED_UNKNOWN_TYPE); verify("out2c", NO_RESOLVED_TYPE); verify("out3", startType); verify("out4", NO_RESOLVED_TYPE); } public void testAssertWithNotIsNull() { JSType startType = createNullableType(NUMBER_TYPE); assuming("x", startType); inFunction( "out1 = x;" + "goog.asserts.assert(!goog.isNull(x));" + "out2 = x;"); verify("out1", startType); verify("out2", NUMBER_TYPE); } public void testReturn1() { assuming("x", createNullableType(OBJECT_TYPE)); inFunction("if (x) { return x; }\nx = {};\nreturn x;"); verify("x", OBJECT_TYPE); } public void testReturn2() { assuming("x", createNullableType(NUMBER_TYPE)); inFunction("if (!x) { x = 0; }\nreturn x;"); verify("x", NUMBER_TYPE); } public void testWhile1() { assuming("x", createNullableType(NUMBER_TYPE)); inFunction("while (!x) { if (x == null) { x = 0; } else { x = 1; } }"); verify("x", NUMBER_TYPE); } public void testWhile2() { assuming("x", createNullableType(NUMBER_TYPE)); inFunction("while (!x) { x = {}; }"); verifySubtypeOf("x", createUnionType(OBJECT_TYPE, NUMBER_TYPE)); } public void testDo() { assuming("x", createNullableType(OBJECT_TYPE)); inFunction("do { x = 1; } while (!x);"); verify("x", NUMBER_TYPE); } public void testFor1() { assuming("y", NUMBER_TYPE); inFunction("var x = null; var i = null; for (i=y; !i; i=1) { x = 1; }"); verify("x", createNullableType(NUMBER_TYPE)); verify("i", NUMBER_TYPE); } public void testFor2() { assuming("y", OBJECT_TYPE); inFunction("var x = null; var i = null; for (i in y) { x = 1; }"); verify("x", createNullableType(NUMBER_TYPE)); verify("i", createNullableType(STRING_TYPE)); } public void testFor3() { assuming("y", OBJECT_TYPE); inFunction("var x = null; var i = null; for (var i in y) { x = 1; }"); verify("x", createNullableType(NUMBER_TYPE)); verify("i", createNullableType(STRING_TYPE)); } public void testFor4() { assuming("x", createNullableType(OBJECT_TYPE)); inFunction("var y = {};\n" + "if (x) { for (var i = 0; i < 10; i++) { break; } y = x; }"); verifySubtypeOf("y", OBJECT_TYPE); } public void testFor5() { assuming("y", parameterize( getNativeObjectType(ARRAY_TYPE), getNativeType(NUMBER_TYPE))); inFunction( "var x = null; for (var i = 0; i < y.length; i++) { x = y[i]; }"); verify("x", createNullableType(NUMBER_TYPE)); verify("i", NUMBER_TYPE); } public void testFor6() { assuming("y", getNativeObjectType(ARRAY_TYPE)); inFunction( "var x = null;" + "for (var i = 0; i < y.length; i++) { " + " if (y[i] == 'z') { x = y[i]; } " + "}"); verify("x", getNativeType(UNKNOWN_TYPE)); verify("i", NUMBER_TYPE); } public void testSwitch1() { assuming("x", NUMBER_TYPE); inFunction("var y = null; switch(x) {\n" + "case 1: y = 1; break;\n" + "case 2: y = {};\n" + "case 3: y = {};\n" + "default: y = 0;}"); verify("y", NUMBER_TYPE); } public void testSwitch2() { assuming("x", ALL_TYPE); inFunction("var y = null; switch (typeof x) {\n" + "case 'string':\n" + " y = x;\n" + " return;" + "default:\n" + " y = 'a';\n" + "}"); verify("y", STRING_TYPE); } public void testSwitch3() { assuming("x", createNullableType(createUnionType(NUMBER_TYPE, STRING_TYPE))); inFunction("var y; var z; switch (typeof x) {\n" + "case 'string':\n" + " y = 1; z = null;\n" + " return;\n" + "case 'number':\n" + " y = x; z = null;\n" + " return;" + "default:\n" + " y = 1; z = x;\n" + "}"); verify("y", NUMBER_TYPE); verify("z", NULL_TYPE); } public void testSwitch4() { assuming("x", ALL_TYPE); inFunction("var y = null; switch (typeof x) {\n" + "case 'string':\n" + "case 'number':\n" + " y = x;\n" + " return;\n" + "default:\n" + " y = 1;\n" + "}\n"); verify("y", createUnionType(NUMBER_TYPE, STRING_TYPE)); } public void testCall1() { assuming("x", createNullableType( registry.createFunctionType(registry.getNativeType(NUMBER_TYPE)))); inFunction("var y = x();"); verify("y", NUMBER_TYPE); } public void testNew1() { assuming("x", createNullableType( registry.getNativeType(JSTypeNative.U2U_CONSTRUCTOR_TYPE))); inFunction("var y = new x();"); verify("y", UNKNOWN_TYPE); } public void testInnerFunction1() { inFunction("var x = 1; function f() { x = null; };"); verify("x", NUMBER_TYPE); } public void testInnerFunction2() { inFunction("var x = 1; var f = function() { x = null; };"); verify("x", NUMBER_TYPE); } public void testHook() { assuming("x", createNullableType(OBJECT_TYPE)); inFunction("var y = x ? x : {};"); verifySubtypeOf("y", OBJECT_TYPE); } public void testThrow() { assuming("x", createNullableType(NUMBER_TYPE)); inFunction("var y = 1;\n" + "if (x == null) { throw new Error('x is null') }\n" + "y = x;"); verify("y", NUMBER_TYPE); } public void testTry1() { assuming("x", NUMBER_TYPE); inFunction("var y = null; try { y = null; } finally { y = x; }"); verify("y", NUMBER_TYPE); } public void testTry2() { assuming("x", NUMBER_TYPE); inFunction("var y = null;\n" + "try { } catch (e) { y = null; } finally { y = x; }"); verify("y", NUMBER_TYPE); } public void testTry3() { assuming("x", NUMBER_TYPE); inFunction("var y = null; try { y = x; } catch (e) { }"); verify("y", NUMBER_TYPE); } public void testCatch1() { inFunction("var y = null; try { foo(); } catch (e) { y = e; }"); verify("y", UNKNOWN_TYPE); } public void testCatch2() { inFunction("var y = null; var e = 3; try { foo(); } catch (e) { y = e; }"); verify("y", UNKNOWN_TYPE); } public void testUnknownType1() { inFunction("var y = 3; y = x;"); verify("y", UNKNOWN_TYPE); } public void testUnknownType2() { assuming("x", ARRAY_TYPE); inFunction("var y = 5; y = x[0];"); verify("y", UNKNOWN_TYPE); } public void testInfiniteLoop1() { assuming("x", createNullableType(OBJECT_TYPE)); inFunction("x = {}; while(x != null) { x = {}; }"); } public void testInfiniteLoop2() { assuming("x", createNullableType(OBJECT_TYPE)); inFunction("x = {}; do { x = null; } while (x == null);"); } public void testJoin1() { JSType unknownOrNull = createUnionType(NULL_TYPE, UNKNOWN_TYPE); assuming("x", BOOLEAN_TYPE); assuming("unknownOrNull", unknownOrNull); inFunction("var y; if (x) y = unknownOrNull; else y = null;"); verify("y", unknownOrNull); } public void testJoin2() { JSType unknownOrNull = createUnionType(NULL_TYPE, UNKNOWN_TYPE); assuming("x", BOOLEAN_TYPE); assuming("unknownOrNull", unknownOrNull); inFunction("var y; if (x) y = null; else y = unknownOrNull;"); verify("y", unknownOrNull); } public void testArrayLit() { assuming("x", createNullableType(OBJECT_TYPE)); inFunction("var y = 3; if (x) { x = [y = x]; }"); verify("x", createUnionType(NULL_TYPE, ARRAY_TYPE)); verify("y", createUnionType(NUMBER_TYPE, OBJECT_TYPE)); } public void testGetElem() { assuming("x", createNullableType(OBJECT_TYPE)); inFunction("var y = 3; if (x) { x = x[y = x]; }"); verify("x", UNKNOWN_TYPE); verify("y", createUnionType(NUMBER_TYPE, OBJECT_TYPE)); } public void testEnumRAI1() { JSType enumType = createEnumType("MyEnum", ARRAY_TYPE).getElementsType(); assuming("x", enumType); inFunction("var y = null; if (x) y = x;"); verify("y", createNullableType(enumType)); } public void testEnumRAI2() { JSType enumType = createEnumType("MyEnum", NUMBER_TYPE).getElementsType(); assuming("x", enumType); inFunction("var y = null; if (typeof x == 'number') y = x;"); verify("y", createNullableType(enumType)); } public void testEnumRAI3() { JSType enumType = createEnumType("MyEnum", NUMBER_TYPE).getElementsType(); assuming("x", enumType); inFunction("var y = null; if (x && typeof x == 'number') y = x;"); verify("y", createNullableType(enumType)); } public void testEnumRAI4() { JSType enumType = createEnumType("MyEnum", createUnionType(STRING_TYPE, NUMBER_TYPE)).getElementsType(); assuming("x", enumType); inFunction("var y = null; if (typeof x == 'number') y = x;"); verify("y", createNullableType(NUMBER_TYPE)); } public void testShortCircuitingAnd() { assuming("x", NUMBER_TYPE); inFunction("var y = null; if (x && (y = 3)) { }"); verify("y", createNullableType(NUMBER_TYPE)); } public void testShortCircuitingAnd2() { assuming("x", NUMBER_TYPE); inFunction("var y = null; var z = 4; if (x && (y = 3)) { z = y; }"); verify("z", NUMBER_TYPE); } public void testShortCircuitingOr() { assuming("x", NUMBER_TYPE); inFunction("var y = null; if (x || (y = 3)) { }"); verify("y", createNullableType(NUMBER_TYPE)); } public void testShortCircuitingOr2() { assuming("x", NUMBER_TYPE); inFunction("var y = null; var z = 4; if (x || (y = 3)) { z = y; }"); verify("z", createNullableType(NUMBER_TYPE)); } public void testAssignInCondition() { assuming("x", createNullableType(NUMBER_TYPE)); inFunction("var y; if (!(y = x)) { y = 3; }"); verify("y", NUMBER_TYPE); } public void testInstanceOf1() { assuming("x", OBJECT_TYPE); inFunction("var y = null; if (x instanceof String) y = x;"); verify("y", createNullableType(STRING_OBJECT_TYPE)); } public void testInstanceOf2() { assuming("x", createNullableType(OBJECT_TYPE)); inFunction("var y = 1; if (x instanceof String) y = x;"); verify("y", createUnionType(STRING_OBJECT_TYPE, NUMBER_TYPE)); } public void testInstanceOf3() { assuming("x", createUnionType(STRING_OBJECT_TYPE, NUMBER_OBJECT_TYPE)); inFunction("var y = null; if (x instanceof String) y = x;"); verify("y", createNullableType(STRING_OBJECT_TYPE)); } public void testInstanceOf4() { assuming("x", createUnionType(STRING_OBJECT_TYPE, NUMBER_OBJECT_TYPE)); inFunction("var y = null; if (x instanceof String); else y = x;"); verify("y", createNullableType(NUMBER_OBJECT_TYPE)); } public void testInstanceOf5() { assuming("x", OBJECT_TYPE); inFunction("var y = null; if (x instanceof String); else y = x;"); verify("y", createNullableType(OBJECT_TYPE)); } public void testInstanceOf6() { // Here we are using "instanceof" to restrict the unknown type to // the type of the instance. This has the following problems: // 1) The type may actually be any sub-type // 2) The type may implement any interface // After the instanceof we will require casts for methods that require // sub-type or unrelated interfaces which would not have been required // before. JSType startType = registry.getNativeType(UNKNOWN_TYPE); assuming("x", startType); inFunction("out1 = x; if (x instanceof String) out2 = x;"); verify("out1", startType); verify("out2", STRING_OBJECT_TYPE); } public void testFlattening() { for (int i = 0; i < LinkedFlowScope.MAX_DEPTH + 1; i++) { assuming("s" + i, ALL_TYPE); } assuming("b", JSTypeNative.BOOLEAN_TYPE); StringBuilder body = new StringBuilder(); body.append("if (b) {"); for (int i = 0; i < LinkedFlowScope.MAX_DEPTH + 1; i++) { body.append("s"); body.append(i); body.append(" = 1;\n"); } body.append(" } else { "); for (int i = 0; i < LinkedFlowScope.MAX_DEPTH + 1; i++) { body.append("s"); body.append(i); body.append(" = 'ONE';\n"); } body.append("}"); JSType numberORString = createUnionType(NUMBER_TYPE, STRING_TYPE); inFunction(body.toString()); for (int i = 0; i < LinkedFlowScope.MAX_DEPTH + 1; i++) { verify("s" + i, numberORString); } } public void testUnary() { assuming("x", NUMBER_TYPE); inFunction("var y = +x;"); verify("y", NUMBER_TYPE); inFunction("var z = -x;"); verify("z", NUMBER_TYPE); } public void testAdd1() { assuming("x", NUMBER_TYPE); inFunction("var y = x + 5;"); verify("y", NUMBER_TYPE); } public void testAdd2() { assuming("x", NUMBER_TYPE); inFunction("var y = x + '5';"); verify("y", STRING_TYPE); } public void testAdd3() { assuming("x", NUMBER_TYPE); inFunction("var y = '5' + x;"); verify("y", STRING_TYPE); } public void testAssignAdd() { assuming("x", NUMBER_TYPE); inFunction("x += '5';"); verify("x", STRING_TYPE); } public void testComparison() { inFunction("var x = 'foo'; var y = (x = 3) < 4;"); verify("x", NUMBER_TYPE); inFunction("var x = 'foo'; var y = (x = 3) > 4;"); verify("x", NUMBER_TYPE); inFunction("var x = 'foo'; var y = (x = 3) <= 4;"); verify("x", NUMBER_TYPE); inFunction("var x = 'foo'; var y = (x = 3) >= 4;"); verify("x", NUMBER_TYPE); } public void testThrownExpression() { inFunction("var x = 'foo'; " + "try { throw new Error(x = 3); } catch (ex) {}"); verify("x", NUMBER_TYPE); } public void testObjectLit() { inFunction("var x = {}; var out = x.a;"); verify("out", UNKNOWN_TYPE); // Shouldn't this be 'undefined'? inFunction("var x = {a:1}; var out = x.a;"); verify("out", NUMBER_TYPE); inFunction("var x = {a:1}; var out = x.a; x.a = 'string'; var out2 = x.a;"); verify("out", NUMBER_TYPE); verify("out2", STRING_TYPE); inFunction("var x = { get a() {return 1} }; var out = x.a;"); verify("out", UNKNOWN_TYPE); inFunction( "var x = {" + " /** @return {number} */ get a() {return 1}" + "};" + "var out = x.a;"); verify("out", NUMBER_TYPE); inFunction("var x = { set a(b) {} }; var out = x.a;"); verify("out", UNKNOWN_TYPE); inFunction("var x = { " + "/** @param {number} b */ set a(b) {} };" + "var out = x.a;"); verify("out", NUMBER_TYPE); } public void testCast1() { inFunction("var x = /** @type {Object} */ (this);"); verify("x", createNullableType(OBJECT_TYPE)); } public void testCast2() { inFunction( "/** @return {boolean} */" + "Object.prototype.method = function() { return true; };" + "var x = /** @type {Object} */ (this).method;"); verify( "x", registry.createFunctionType( registry.getNativeObjectType(OBJECT_TYPE), registry.getNativeType(BOOLEAN_TYPE), ImmutableList.<JSType>of() /* params */)); } public void testBackwardsInferenceCall() { inFunction( "/** @param {{foo: (number|undefined)}} x */" + "function f(x) {}" + "var y = {};" + "f(y);"); assertEquals("{foo: (number|undefined)}", getType("y").toString()); } public void testBackwardsInferenceNew() { inFunction( "/**\n" + " * @constructor\n" + " * @param {{foo: (number|undefined)}} x\n" + " */" + "function F(x) {}" + "var y = {};" + "new F(y);"); assertEquals("{foo: (number|undefined)}", getType("y").toString()); } public void testNoThisInference() { JSType thisType = createNullableType(OBJECT_TYPE); assumingThisType(thisType); inFunction("var out = 3; if (goog.isNull(this)) out = this;"); verify("out", createUnionType(OBJECT_TYPE, NUMBER_TYPE)); } public void testRecordInference() { inFunction( "/** @param {{a: (boolean|undefined)}|{b: (string|undefined)}} x */" + "function f(x) {}" + "var out = {};" + "f(out);"); assertEquals("{a: (boolean|undefined), b: (string|undefined)}", getType("out").toString()); } public void testIssue785() { inFunction("/** @param {string|{prop: (string|undefined)}} x */" + "function f(x) {}" + "var out = {};" + "f(out);"); assertEquals("{prop: (string|undefined)}", getType("out").toString()); } public void testAssertTypeofProp() { assuming("x", createNullableType(OBJECT_TYPE)); inFunction( "goog.asserts.assert(typeof x.prop != 'undefined');" + "out = x.prop;"); verify("out", CHECKED_UNKNOWN_TYPE); } private ObjectType getNativeObjectType(JSTypeNative t) { return registry.getNativeObjectType(t); } private JSType getNativeType(JSTypeNative t) { return registry.getNativeType(t); } private JSType parameterize(ObjectType objType, JSType t) { return registry.createParameterizedType(objType, t); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import static com.google.javascript.jscomp.TypeValidator.TYPE_MISMATCH_WARNING; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import com.google.common.collect.Lists; import com.google.javascript.jscomp.CheckLevel; import com.google.javascript.jscomp.TypeValidator.TypeMismatch; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import java.util.Collections; import java.util.List; /** * Tests for TypeValidator. * @author nicksantos@google.com (Nick Santos) */ public class TypeValidatorTest extends CompilerTestCase { private Compiler compiler = null; public TypeValidatorTest() { enableTypeCheck(CheckLevel.ERROR); } @Override protected CompilerPass getProcessor(final Compiler compiler) { this.compiler = compiler; return new CompilerPass() { @Override public void process(Node externs, Node n) { // Do nothing: we're in it for the type-checking. } }; } @Override public int getNumRepetitions() { return 1; } public void testBasicMismatch() throws Exception { testSame("/** @param {number} x */ function f(x) {} f('a');", TYPE_MISMATCH_WARNING); assertMismatches(Lists.newArrayList(fromNatives(STRING_TYPE, NUMBER_TYPE))); } public void testFunctionMismatch() throws Exception { testSame( "/** \n" + " * @param {function(string): number} x \n" + " * @return {function(boolean): string} \n" + " */ function f(x) { return x; }", TYPE_MISMATCH_WARNING); JSTypeRegistry registry = compiler.getTypeRegistry(); JSType string = registry.getNativeType(STRING_TYPE); JSType bool = registry.getNativeType(BOOLEAN_TYPE); JSType number = registry.getNativeType(NUMBER_TYPE); JSType firstFunction = registry.createFunctionType(number, string); JSType secondFunction = registry.createFunctionType(string, bool); assertMismatches( Lists.newArrayList( new TypeMismatch(firstFunction, secondFunction, null), fromNatives(STRING_TYPE, BOOLEAN_TYPE), fromNatives(NUMBER_TYPE, STRING_TYPE))); } public void testFunctionMismatch2() throws Exception { testSame( "/** \n" + " * @param {function(string): number} x \n" + " * @return {function(boolean): number} \n" + " */ function f(x) { return x; }", TYPE_MISMATCH_WARNING); JSTypeRegistry registry = compiler.getTypeRegistry(); JSType string = registry.getNativeType(STRING_TYPE); JSType bool = registry.getNativeType(BOOLEAN_TYPE); JSType number = registry.getNativeType(NUMBER_TYPE); JSType firstFunction = registry.createFunctionType(number, string); JSType secondFunction = registry.createFunctionType(number, bool); assertMismatches( Lists.newArrayList( new TypeMismatch(firstFunction, secondFunction, null), fromNatives(STRING_TYPE, BOOLEAN_TYPE))); } public void testNullUndefined() { testSame("/** @param {string} x */ function f(x) {}\n" + "f(/** @type {string|null|undefined} */ ('a'));", TYPE_MISMATCH_WARNING); assertMismatches(Collections.<TypeMismatch>emptyList()); } public void testSubclass() { testSame("/** @constructor */\n" + "function Super() {}\n" + "/**\n" + " * @constructor\n" + " * @extends {Super}\n" + " */\n" + "function Sub() {}\n" + "/** @param {Sub} x */ function f(x) {}\n" + "f(/** @type {Super} */ (new Sub));", TYPE_MISMATCH_WARNING); assertMismatches(Collections.<TypeMismatch>emptyList()); } private TypeMismatch fromNatives(JSTypeNative a, JSTypeNative b) { JSTypeRegistry registry = compiler.getTypeRegistry(); return new TypeMismatch( registry.getNativeType(a), registry.getNativeType(b), null); } private void assertMismatches(List<TypeMismatch> expected) { List<TypeMismatch> actual = Lists.newArrayList( compiler.getTypeValidator().getMismatches()); assertEquals(expected, actual); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import static com.google.javascript.jscomp.TypedScopeCreator.CTOR_INITIALIZER; import static com.google.javascript.jscomp.TypedScopeCreator.IFACE_INITIALIZER; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE; import com.google.common.base.Predicate; import com.google.common.collect.Lists; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.NodeTraversal.Callback; import com.google.javascript.jscomp.Scope.Var; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.EnumType; import com.google.javascript.rhino.jstype.FunctionType; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.testing.Asserts; import java.util.Deque; /** * Tests for {@link TypedScopeCreator} and {@link TypeInference}. Admittedly, * the name is a bit of a misnomer. * @author nicksantos@google.com (Nick Santos) */ public class TypedScopeCreatorTest extends CompilerTestCase { private JSTypeRegistry registry; private Scope globalScope; private Scope lastLocalScope; @Override public int getNumRepetitions() { return 1; } private final Callback callback = new AbstractPostOrderCallback() { @Override public void visit(NodeTraversal t, Node n, Node parent) { Scope s = t.getScope(); if (s.isGlobal()) { globalScope = s; } else { lastLocalScope = s; } } }; @Override public CompilerPass getProcessor(final Compiler compiler) { registry = compiler.getTypeRegistry(); return new CompilerPass() { @Override public void process(Node externs, Node root) { MemoizedScopeCreator scopeCreator = new MemoizedScopeCreator(new TypedScopeCreator(compiler)); Scope topScope = scopeCreator.createScope(root.getParent(), null); (new TypeInferencePass( compiler, compiler.getReverseAbstractInterpreter(), topScope, scopeCreator)).process(externs, root); NodeTraversal t = new NodeTraversal( compiler, callback, scopeCreator); t.traverseRoots(Lists.newArrayList(externs, root)); } }; } public void testStubProperty() { testSame("function Foo() {}; Foo.bar;"); ObjectType foo = (ObjectType) globalScope.getVar("Foo").getType(); assertFalse(foo.hasProperty("bar")); Asserts.assertTypeEquals(registry.getNativeType(UNKNOWN_TYPE), foo.getPropertyType("bar")); Asserts.assertTypeCollectionEquals( Lists.newArrayList(foo), registry.getTypesWithProperty("bar")); } public void testConstructorProperty() { testSame("var foo = {}; /** @constructor */ foo.Bar = function() {};"); ObjectType foo = (ObjectType) findNameType("foo", globalScope); assertTrue(foo.hasProperty("Bar")); assertFalse(foo.isPropertyTypeInferred("Bar")); JSType fooBar = foo.getPropertyType("Bar"); assertEquals("function (new:foo.Bar): undefined", fooBar.toString()); Asserts.assertTypeCollectionEquals( Lists.newArrayList(foo), registry.getTypesWithProperty("Bar")); } public void testPrototypePropertyMethodWithoutAnnotation() { testSame("var Foo = function Foo() {};" + "var proto = Foo.prototype = {" + " bar: function(a, b){}" + "};" + "proto.baz = function(c) {};" + "(function() { proto.baz = function() {}; })();"); ObjectType foo = (ObjectType) findNameType("Foo", globalScope); assertTrue(foo.hasProperty("prototype")); ObjectType fooProto = (ObjectType) foo.getPropertyType("prototype"); assertTrue(fooProto.hasProperty("bar")); assertEquals("function (?, ?): undefined", fooProto.getPropertyType("bar").toString()); assertTrue(fooProto.hasProperty("baz")); assertEquals("function (?): undefined", fooProto.getPropertyType("baz").toString()); } public void testEnumProperty() { testSame("var foo = {}; /** @enum */ foo.Bar = {XXX: 'xxx'};"); ObjectType foo = (ObjectType) findNameType("foo", globalScope); assertTrue(foo.hasProperty("Bar")); assertFalse(foo.isPropertyTypeInferred("Bar")); assertTrue(foo.isPropertyTypeDeclared("Bar")); JSType fooBar = foo.getPropertyType("Bar"); assertEquals("enum{foo.Bar}", fooBar.toString()); Asserts.assertTypeCollectionEquals( Lists.newArrayList(foo), registry.getTypesWithProperty("Bar")); } public void testInferredProperty1() { testSame("var foo = {}; foo.Bar = 3;"); ObjectType foo = (ObjectType) findNameType("foo", globalScope); assertTrue(foo.toString(), foo.hasProperty("Bar")); assertEquals("number", foo.getPropertyType("Bar").toString()); assertTrue(foo.isPropertyTypeInferred("Bar")); } public void testInferredProperty1a() { testSame("var foo = {}; /** @type {number} */ foo.Bar = 3;"); ObjectType foo = (ObjectType) findNameType("foo", globalScope); assertTrue(foo.toString(), foo.hasProperty("Bar")); assertEquals("number", foo.getPropertyType("Bar").toString()); assertFalse(foo.isPropertyTypeInferred("Bar")); } public void testInferredProperty2() { testSame("var foo = { Bar: 3 };"); ObjectType foo = (ObjectType) findNameType("foo", globalScope); assertTrue(foo.toString(), foo.hasProperty("Bar")); assertEquals("number", foo.getPropertyType("Bar").toString()); assertTrue(foo.isPropertyTypeInferred("Bar")); } public void testInferredProperty2b() { testSame("var foo = { /** @type {number} */ Bar: 3 };"); ObjectType foo = (ObjectType) findNameType("foo", globalScope); assertTrue(foo.toString(), foo.hasProperty("Bar")); assertEquals("number", foo.getPropertyType("Bar").toString()); assertFalse(foo.isPropertyTypeInferred("Bar")); } public void testInferredProperty2c() { testSame("var foo = { /** @return {number} */ Bar: 3 };"); ObjectType foo = (ObjectType) findNameType("foo", globalScope); assertTrue(foo.toString(), foo.hasProperty("Bar")); assertEquals("function (): number", foo.getPropertyType("Bar").toString()); assertFalse(foo.isPropertyTypeInferred("Bar")); } public void testInferredProperty3() { testSame("var foo = { /** @type {number} */ get Bar() { return 3 } };"); ObjectType foo = (ObjectType) findNameType("foo", globalScope); assertTrue(foo.toString(), foo.hasProperty("Bar")); assertEquals("?", foo.getPropertyType("Bar").toString()); assertTrue(foo.isPropertyTypeInferred("Bar")); } public void testInferredProperty4() { testSame("var foo = { /** @type {number} */ set Bar(a) {} };"); ObjectType foo = (ObjectType) findNameType("foo", globalScope); assertTrue(foo.toString(), foo.hasProperty("Bar")); assertEquals("?", foo.getPropertyType("Bar").toString()); assertTrue(foo.isPropertyTypeInferred("Bar")); } public void testInferredProperty5() { testSame("var foo = { /** @return {number} */ get Bar() { return 3 } };"); ObjectType foo = (ObjectType) findNameType("foo", globalScope); assertTrue(foo.toString(), foo.hasProperty("Bar")); assertEquals("number", foo.getPropertyType("Bar").toString()); assertFalse(foo.isPropertyTypeInferred("Bar")); } public void testInferredProperty6() { testSame("var foo = { /** @param {number} a */ set Bar(a) {} };"); ObjectType foo = (ObjectType) findNameType("foo", globalScope); assertTrue(foo.toString(), foo.hasProperty("Bar")); assertEquals("number", foo.getPropertyType("Bar").toString()); assertFalse(foo.isPropertyTypeInferred("Bar")); } public void testPrototypeInit() { testSame("/** @constructor */ var Foo = function() {};" + "Foo.prototype = {bar: 1}; var foo = new Foo();"); ObjectType foo = (ObjectType) findNameType("foo", globalScope); assertTrue(foo.hasProperty("bar")); assertEquals("number", foo.getPropertyType("bar").toString()); assertTrue(foo.isPropertyTypeInferred("bar")); } public void testBogusPrototypeInit() { // This used to cause a compiler crash. testSame("/** @const */ var goog = {}; " + "goog.F = {}; /** @const */ goog.F.prototype = {};" + "/** @constructor */ goog.F = function() {};"); } public void testInferredPrototypeProperty1() { testSame("/** @constructor */ var Foo = function() {};" + "Foo.prototype.bar = 1; var x = new Foo();"); ObjectType x = (ObjectType) findNameType("x", globalScope); assertTrue(x.hasProperty("bar")); assertEquals("number", x.getPropertyType("bar").toString()); assertTrue(x.isPropertyTypeInferred("bar")); } public void testInferredPrototypeProperty2() { testSame("/** @constructor */ var Foo = function() {};" + "Foo.prototype = {bar: 1}; var x = new Foo();"); ObjectType x = (ObjectType) findNameType("x", globalScope); assertTrue(x.hasProperty("bar")); assertEquals("number", x.getPropertyType("bar").toString()); assertTrue(x.isPropertyTypeInferred("bar")); } public void testEnum() { testSame("/** @enum */ var Foo = {BAR: 1}; var f = Foo;"); ObjectType f = (ObjectType) findNameType("f", globalScope); assertTrue(f.hasProperty("BAR")); assertEquals("Foo.<number>", f.getPropertyType("BAR").toString()); assertTrue(f instanceof EnumType); } public void testEnumElement() { testSame("/** @enum */ var Foo = {BAR: 1}; var f = Foo;"); Var bar = globalScope.getVar("Foo.BAR"); assertNotNull(bar); assertEquals("Foo.<number>", bar.getType().toString()); } public void testNamespacedEnum() { testSame("var goog = {}; goog.ui = {};" + "/** @constructor */goog.ui.Zippy = function() {};" + "/** @enum{string} */goog.ui.Zippy.EventType = { TOGGLE: 'toggle' };" + "var x = goog.ui.Zippy.EventType;" + "var y = goog.ui.Zippy.EventType.TOGGLE;"); ObjectType x = (ObjectType) findNameType("x", globalScope); assertTrue(x.isEnumType()); assertTrue(x.hasProperty("TOGGLE")); assertEquals("enum{goog.ui.Zippy.EventType}", x.getReferenceName()); ObjectType y = (ObjectType) findNameType("y", globalScope); assertTrue(y.isSubtype(getNativeType(STRING_TYPE))); assertTrue(y.isEnumElementType()); assertEquals("goog.ui.Zippy.EventType", y.getReferenceName()); } public void testEnumAlias() { testSame("/** @enum */ var Foo = {BAR: 1}; " + "/** @enum */ var FooAlias = Foo; var f = FooAlias;"); assertEquals("Foo.<number>", registry.getType("FooAlias").toString()); Asserts.assertTypeEquals(registry.getType("FooAlias"), registry.getType("Foo")); ObjectType f = (ObjectType) findNameType("f", globalScope); assertTrue(f.hasProperty("BAR")); assertEquals("Foo.<number>", f.getPropertyType("BAR").toString()); assertTrue(f instanceof EnumType); } public void testNamespacesEnumAlias() { testSame("var goog = {}; /** @enum */ goog.Foo = {BAR: 1}; " + "/** @enum */ goog.FooAlias = goog.Foo;"); assertEquals("goog.Foo.<number>", registry.getType("goog.FooAlias").toString()); Asserts.assertTypeEquals(registry.getType("goog.Foo"), registry.getType("goog.FooAlias")); } public void testCollectedFunctionStub() { testSame( "/** @constructor */ function f() { " + " /** @return {number} */ this.foo;" + "}" + "var x = new f();"); ObjectType x = (ObjectType) findNameType("x", globalScope); assertEquals("f", x.toString()); assertTrue(x.hasProperty("foo")); assertEquals("function (this:f): number", x.getPropertyType("foo").toString()); assertFalse(x.isPropertyTypeInferred("foo")); } public void testCollectedFunctionStubLocal() { testSame( "(function() {" + "/** @constructor */ function f() { " + " /** @return {number} */ this.foo;" + "}" + "var x = new f();" + "});"); ObjectType x = (ObjectType) findNameType("x", lastLocalScope); assertEquals("f", x.toString()); assertTrue(x.hasProperty("foo")); assertEquals("function (this:f): number", x.getPropertyType("foo").toString()); assertFalse(x.isPropertyTypeInferred("foo")); } public void testNamespacedFunctionStub() { testSame( "var goog = {};" + "/** @param {number} x */ goog.foo;"); ObjectType goog = (ObjectType) findNameType("goog", globalScope); assertTrue(goog.hasProperty("foo")); assertEquals("function (number): ?", goog.getPropertyType("foo").toString()); assertTrue(goog.isPropertyTypeDeclared("foo")); Asserts.assertTypeEquals(globalScope.getVar("goog.foo").getType(), goog.getPropertyType("foo")); } public void testNamespacedFunctionStubLocal() { testSame( "(function() {" + "var goog = {};" + "/** @param {number} x */ goog.foo;" + "});"); ObjectType goog = (ObjectType) findNameType("goog", lastLocalScope); assertTrue(goog.hasProperty("foo")); assertEquals("function (number): ?", goog.getPropertyType("foo").toString()); assertTrue(goog.isPropertyTypeDeclared("foo")); Asserts.assertTypeEquals(lastLocalScope.getVar("goog.foo").getType(), goog.getPropertyType("foo")); } public void testCollectedCtorProperty() { testSame( "/** @constructor */ function f() { " + " /** @type {number} */ this.foo = 3;" + "}" + "var x = new f();"); ObjectType x = (ObjectType) findNameType("x", globalScope); assertEquals("f", x.toString()); assertTrue(x.hasProperty("foo")); assertEquals("number", x.getPropertyType("foo").toString()); assertFalse(x.isPropertyTypeInferred("foo")); } public void testPropertyOnUnknownSuperClass1() { testSame( "var goog = this.foo();" + "/** @constructor \n * @extends {goog.Unknown} */" + "function Foo() {}" + "Foo.prototype.bar = 1;" + "var x = new Foo();", RhinoErrorReporter.TYPE_PARSE_ERROR); ObjectType x = (ObjectType) findNameType("x", globalScope); assertEquals("Foo", x.toString()); assertTrue(x.getImplicitPrototype().hasOwnProperty("bar")); assertEquals("?", x.getPropertyType("bar").toString()); assertTrue(x.isPropertyTypeInferred("bar")); } public void testPropertyOnUnknownSuperClass2() { testSame( "var goog = this.foo();" + "/** @constructor \n * @extends {goog.Unknown} */" + "function Foo() {}" + "Foo.prototype = {bar: 1};" + "var x = new Foo();", RhinoErrorReporter.TYPE_PARSE_ERROR); ObjectType x = (ObjectType) findNameType("x", globalScope); assertEquals("Foo", x.toString()); assertEquals("Foo.prototype", x.getImplicitPrototype().toString()); assertTrue(x.getImplicitPrototype().hasOwnProperty("bar")); assertEquals("?", x.getPropertyType("bar").toString()); assertTrue(x.isPropertyTypeInferred("bar")); } public void testMethodBeforeFunction1() throws Exception { testSame( "var y = Window.prototype;" + "Window.prototype.alert = function(message) {};" + "/** @constructor */ function Window() {}\n" + "var window = new Window(); \n" + "var x = window;"); ObjectType x = (ObjectType) findNameType("x", globalScope); assertEquals("Window", x.toString()); assertTrue(x.getImplicitPrototype().hasOwnProperty("alert")); assertEquals("function (this:Window, ?): undefined", x.getPropertyType("alert").toString()); assertTrue(x.isPropertyTypeDeclared("alert")); ObjectType y = (ObjectType) findNameType("y", globalScope); assertEquals("function (this:Window, ?): undefined", y.getPropertyType("alert").toString()); } public void testMethodBeforeFunction2() throws Exception { testSame( "var y = Window.prototype;" + "Window.prototype = {alert: function(message) {}};" + "/** @constructor */ function Window() {}\n" + "var window = new Window(); \n" + "var x = window;"); ObjectType x = (ObjectType) findNameType("x", globalScope); assertEquals("Window", x.toString()); assertTrue(x.getImplicitPrototype().hasOwnProperty("alert")); assertEquals("function (this:Window, ?): undefined", x.getPropertyType("alert").toString()); assertFalse(x.isPropertyTypeDeclared("alert")); ObjectType y = (ObjectType) findNameType("y", globalScope); assertEquals("?", y.getPropertyType("alert").toString()); } public void testAddMethodsPrototypeTwoWays() throws Exception { testSame( "/** @constructor */function A() {}" + "A.prototype = {m1: 5, m2: true};" + "A.prototype.m3 = 'third property!';" + "var x = new A();"); ObjectType instanceType = (ObjectType) findNameType("x", globalScope); assertEquals( getNativeObjectType(OBJECT_TYPE).getPropertiesCount() + 3, instanceType.getPropertiesCount()); Asserts.assertTypeEquals(getNativeType(NUMBER_TYPE), instanceType.getPropertyType("m1")); Asserts.assertTypeEquals(getNativeType(BOOLEAN_TYPE), instanceType.getPropertyType("m2")); Asserts.assertTypeEquals(getNativeType(STRING_TYPE), instanceType.getPropertyType("m3")); // Verify the prototype chain. // This is a special case where we want the anonymous object to // become a prototype. assertFalse(instanceType.hasOwnProperty("m1")); assertFalse(instanceType.hasOwnProperty("m2")); assertFalse(instanceType.hasOwnProperty("m3")); ObjectType proto1 = instanceType.getImplicitPrototype(); assertTrue(proto1.hasOwnProperty("m1")); assertTrue(proto1.hasOwnProperty("m2")); assertTrue(proto1.hasOwnProperty("m3")); ObjectType proto2 = proto1.getImplicitPrototype(); assertFalse(proto2.hasProperty("m1")); assertFalse(proto2.hasProperty("m2")); assertFalse(proto2.hasProperty("m3")); } public void testInferredVar() throws Exception { testSame("var x = 3; x = 'x'; x = true;"); Var x = globalScope.getVar("x"); assertEquals("(boolean|number|string)", x.getType().toString()); assertTrue(x.isTypeInferred()); } public void testDeclaredVar() throws Exception { testSame("/** @type {?number} */ var x = 3; var y = x;"); Var x = globalScope.getVar("x"); assertEquals("(null|number)", x.getType().toString()); assertFalse(x.isTypeInferred()); JSType y = findNameType("y", globalScope); assertEquals("(null|number)", y.toString()); } public void testPropertiesOnInterface() throws Exception { testSame("/** @interface */ var I = function() {};" + "/** @type {number} */ I.prototype.bar;" + "I.prototype.baz = function(){};"); Var i = globalScope.getVar("I"); assertEquals("function (this:I): ?", i.getType().toString()); assertTrue(i.getType().isInterface()); ObjectType iPrototype = (ObjectType) ((ObjectType) i.getType()).getPropertyType("prototype"); assertEquals("I.prototype", iPrototype.toString()); assertTrue(iPrototype.isFunctionPrototypeType()); assertEquals("number", iPrototype.getPropertyType("bar").toString()); assertEquals("function (this:I): undefined", iPrototype.getPropertyType("baz").toString()); Asserts.assertTypeEquals(iPrototype, globalScope.getVar("I.prototype").getType()); } public void testPropertiesOnInterface2() throws Exception { testSame("/** @interface */ var I = function() {};" + "I.prototype = {baz: function(){}};" + "/** @type {number} */ I.prototype.bar;"); Var i = globalScope.getVar("I"); assertEquals("function (this:I): ?", i.getType().toString()); assertTrue(i.getType().isInterface()); ObjectType iPrototype = (ObjectType) ((ObjectType) i.getType()).getPropertyType("prototype"); assertEquals("I.prototype", iPrototype.toString()); assertTrue(iPrototype.isFunctionPrototypeType()); assertEquals("number", iPrototype.getPropertyType("bar").toString()); assertEquals("function (this:I): undefined", iPrototype.getPropertyType("baz").toString()); // should not be null assertNull(globalScope.getVar("I.prototype")); // assertEquals(iPrototype, globalScope.getVar("I.prototype").getType()); } // TODO(johnlenz): A syntax for stubs using object literals? public void testStubsInExterns() { testSame( "/** @constructor */ function Extern() {}" + "Extern.prototype.bar;" + "var e = new Extern(); e.baz;", "/** @constructor */ function Foo() {}" + "Foo.prototype.bar;" + "var f = new Foo(); f.baz;", null); ObjectType e = (ObjectType) globalScope.getVar("e").getType(); assertEquals("?", e.getPropertyType("bar").toString()); assertEquals("?", e.getPropertyType("baz").toString()); ObjectType f = (ObjectType) globalScope.getVar("f").getType(); assertEquals("?", f.getPropertyType("bar").toString()); assertFalse(f.hasProperty("baz")); } public void testStubsInExterns2() { testSame( "/** @constructor */ function Extern() {}" + "/** @type {Extern} */ var myExtern;" + "/** @type {number} */ myExtern.foo;", "", null); JSType e = globalScope.getVar("myExtern").getType(); assertEquals("(Extern|null)", e.toString()); ObjectType externType = (ObjectType) e.restrictByNotNullOrUndefined(); assertTrue(globalScope.getRootNode().toStringTree(), externType.hasOwnProperty("foo")); assertTrue(externType.isPropertyTypeDeclared("foo")); assertEquals("number", externType.getPropertyType("foo").toString()); assertTrue(externType.isPropertyInExterns("foo")); } public void testStubsInExterns3() { testSame( "/** @type {number} */ myExtern.foo;" + "/** @type {Extern} */ var myExtern;" + "/** @constructor */ function Extern() {}", "", null); JSType e = globalScope.getVar("myExtern").getType(); assertEquals("(Extern|null)", e.toString()); ObjectType externType = (ObjectType) e.restrictByNotNullOrUndefined(); assertTrue(globalScope.getRootNode().toStringTree(), externType.hasOwnProperty("foo")); assertTrue(externType.isPropertyTypeDeclared("foo")); assertEquals("number", externType.getPropertyType("foo").toString()); assertTrue(externType.isPropertyInExterns("foo")); } public void testStubsInExterns4() { testSame( "Extern.prototype.foo;" + "/** @constructor */ function Extern() {}", "", null); JSType e = globalScope.getVar("Extern").getType(); assertEquals("function (new:Extern): ?", e.toString()); ObjectType externProto = ((FunctionType) e).getPrototype(); assertTrue(globalScope.getRootNode().toStringTree(), externProto.hasOwnProperty("foo")); assertTrue(externProto.isPropertyTypeInferred("foo")); assertEquals("?", externProto.getPropertyType("foo").toString()); assertTrue(externProto.isPropertyInExterns("foo")); } public void testPropertyInExterns1() { testSame( "/** @constructor */ function Extern() {}" + "/** @type {Extern} */ var extern;" + "/** @return {number} */ extern.one;", "/** @constructor */ function Normal() {}" + "/** @type {Normal} */ var normal;" + "/** @return {number} */ normal.one;", null); JSType e = globalScope.getVar("Extern").getType(); ObjectType externInstance = ((FunctionType) e).getInstanceType(); assertTrue(externInstance.hasOwnProperty("one")); assertTrue(externInstance.isPropertyTypeDeclared("one")); assertEquals("function (): number", externInstance.getPropertyType("one").toString()); JSType n = globalScope.getVar("Normal").getType(); ObjectType normalInstance = ((FunctionType) n).getInstanceType(); assertFalse(normalInstance.hasOwnProperty("one")); } public void testPropertyInExterns2() { testSame( "/** @type {Object} */ var extern;" + "/** @return {number} */ extern.one;", "/** @type {Object} */ var normal;" + "/** @return {number} */ normal.one;", null); JSType e = globalScope.getVar("extern").getType(); assertFalse(e.dereference().hasOwnProperty("one")); JSType normal = globalScope.getVar("normal").getType(); assertFalse(normal.dereference().hasOwnProperty("one")); } public void testPropertyInExterns3() { testSame( "/** @constructor \n * @param {*=} x */ function Object(x) {}" + "/** @type {number} */ Object.one;", "", null); ObjectType obj = globalScope.getVar("Object").getType().dereference(); assertTrue(obj.hasOwnProperty("one")); assertEquals("number", obj.getPropertyType("one").toString()); } public void testTypedStubsInExterns() { testSame( "/** @constructor \n * @param {*} var_args */ " + "function Function(var_args) {}" + "/** @type {!Function} */ Function.prototype.apply;", "var f = new Function();", null); ObjectType f = (ObjectType) globalScope.getVar("f").getType(); // The type of apply() on a function instance is resolved dynamically, // since apply varies with the type of the function it's called on. assertEquals( "function (?=, (Object|null)=): ?", f.getPropertyType("apply").toString()); // The type of apply() on the function prototype just takes what it was // declared with. FunctionType func = (FunctionType) globalScope.getVar("Function").getType(); assertEquals("Function", func.getPrototype().getPropertyType("apply").toString()); } public void testTypesInExterns() throws Exception { testSame( CompilerTypeTestCase.DEFAULT_EXTERNS, "", null); Var v = globalScope.getVar("Object"); FunctionType obj = (FunctionType) v.getType(); assertEquals("function (new:Object, *=): ?", obj.toString()); assertNotNull(v.getNode()); assertNotNull(v.input); } public void testPropertyDeclarationOnInstanceType() { testSame( "/** @type {!Object} */ var a = {};" + "/** @type {number} */ a.name = 0;"); assertEquals("number", globalScope.getVar("a.name").getType().toString()); ObjectType a = (ObjectType) (globalScope.getVar("a").getType()); assertFalse(a.hasProperty("name")); assertFalse(getNativeObjectType(OBJECT_TYPE).hasProperty("name")); } public void testPropertyDeclarationOnRecordType() { testSame( "/** @type {{foo: number}} */ var a = {foo: 3};" + "/** @type {number} */ a.name = 0;"); assertEquals("number", globalScope.getVar("a.name").getType().toString()); ObjectType a = (ObjectType) (globalScope.getVar("a").getType()); assertEquals("{foo: number}", a.toString()); assertFalse(a.hasProperty("name")); } public void testGlobalThis1() { testSame( "/** @constructor */ function Window() {}" + "Window.prototype.alert = function() {};" + "var x = this;"); ObjectType x = (ObjectType) (globalScope.getVar("x").getType()); FunctionType windowCtor = (FunctionType) (globalScope.getVar("Window").getType()); assertEquals("global this", x.toString()); assertTrue(x.isSubtype(windowCtor.getInstanceType())); assertFalse(x.isEquivalentTo(windowCtor.getInstanceType())); assertTrue(x.hasProperty("alert")); } public void testGlobalThis2() { testSame( "/** @constructor */ function Window() {}" + "Window.prototype = {alert: function() {}};" + "var x = this;"); ObjectType x = (ObjectType) (globalScope.getVar("x").getType()); FunctionType windowCtor = (FunctionType) (globalScope.getVar("Window").getType()); assertEquals("global this", x.toString()); assertTrue(x.isSubtype(windowCtor.getInstanceType())); assertFalse(x.isEquivalentTo(windowCtor.getInstanceType())); assertTrue(x.hasProperty("alert")); } public void testObjectLiteralCast() { // Verify that "goog.reflect.object" does not modify the types on // "A.B" testSame("/** @constructor */ A.B = function() {}\n" + "A.B.prototype.isEnabled = true;\n" + "goog.reflect.object(A.B, {isEnabled: 3})\n" + "var x = (new A.B()).isEnabled;"); assertEquals("A.B", findTokenType(Token.OBJECTLIT, globalScope).toString()); assertEquals("boolean", findNameType("x", globalScope).toString()); } public void testBadObjectLiteralCast1() { testSame("/** @constructor */ A.B = function() {}\n" + "goog.reflect.object(A.B, 1)", ClosureCodingConvention.OBJECTLIT_EXPECTED); } public void testBadObjectLiteralCast2() { testSame("goog.reflect.object(A.B, {})", TypedScopeCreator.CONSTRUCTOR_EXPECTED); } public void testConstructorNode() { testSame("var goog = {}; /** @constructor */ goog.Foo = function() {};"); ObjectType ctor = (ObjectType) (findNameType("goog.Foo", globalScope)); assertNotNull(ctor); assertTrue(ctor.isConstructor()); assertEquals("function (new:goog.Foo): undefined", ctor.toString()); } public void testForLoopIntegration() { testSame("var y = 3; for (var x = true; x; y = x) {}"); Var y = globalScope.getVar("y"); assertTrue(y.isTypeInferred()); assertEquals("(boolean|number)", y.getType().toString()); } public void testConstructorAlias() { testSame( "/** @constructor */ var Foo = function() {};" + "/** @constructor */ var FooAlias = Foo;"); assertEquals("Foo", registry.getType("FooAlias").toString()); Asserts.assertTypeEquals(registry.getType("Foo"), registry.getType("FooAlias")); } public void testNamespacedConstructorAlias() { testSame( "var goog = {};" + "/** @constructor */ goog.Foo = function() {};" + "/** @constructor */ goog.FooAlias = goog.Foo;"); assertEquals("goog.Foo", registry.getType("goog.FooAlias").toString()); Asserts.assertTypeEquals(registry.getType("goog.Foo"), registry.getType("goog.FooAlias")); } public void testTemplateType1() { testSame( "/**\n" + " * @param {function(this:T, ...)} fn\n" + " * @param {T} thisObj\n" + " * @template T\n" + " */\n" + "function bind(fn, thisObj) {}" + "/** @constructor */\n" + "function Foo() {}\n" + "/** @return {number} */\n" + "Foo.prototype.baz = function() {};\n" + "bind(function() { var g = this; var f = this.baz(); }, new Foo());"); assertEquals("Foo", findNameType("g", lastLocalScope).toString()); assertEquals("number", findNameType("f", lastLocalScope).toString()); } public void testTemplateType2() { testSame( "/**\n" + " * @param {T} x\n" + " * @return {T}\n" + " * @template T\n" + " */\n" + "function f(x) {\n" + " return x;\n" + "}" + "/** @type {string} */\n" + "var val = 'hi';\n" + "var result = f(val);"); assertEquals("string", findNameType("result", globalScope).toString()); } public void testTemplateType2a() { testSame( "/**\n" + " * @param {T} x\n" + " * @return {T|undefined}\n" + " * @template T\n" + " */\n" + "function f(x) {\n" + " return x;\n" + "}" + "/** @type {string} */\n" + "var val = 'hi';\n" + "var result = f(val);"); assertEquals("(string|undefined)", findNameType("result", globalScope).toString()); } public void testTemplateType2b() { testSame( "/**\n" + " * @param {T} x\n" + " * @return {T}\n" + " * @template T\n" + " */\n" + "function f(x) {\n" + " return x;\n" + "}" + "/** @type {string|undefined} */\n" + "var val = 'hi';\n" + "var result = f(val);"); assertEquals("(string|undefined)", findNameType("result", globalScope).toString()); } public void testTemplateType3() { testSame( "/**\n" + " * @param {T} x\n" + " * @return {T}\n" + " * @template T\n" + " */\n" + "function f(x) {\n" + " return x;\n" + "}" + "/** @type {string} */\n" + "var val1 = 'hi';\n" + "var result1 = f(val1);" + "/** @type {number} */\n" + "var val2 = 0;\n" + "var result2 = f(val2);"); assertEquals("string", findNameType("result1", globalScope).toString()); assertEquals("number", findNameType("result2", globalScope).toString()); } public void testTemplateType4() { testSame( "/**\n" + " * @param {T} x\n" + " * @return {T}\n" + " * @template T\n" + " */\n" + "function f(x) {\n" + " return x;\n" + "}" + "/** @type {!Array.<string>} */\n" + "var arr = [];\n" + "(function () {var result = f(arr);})();"); JSType resultType = findNameType("result", lastLocalScope); assertEquals("Array.<string>", resultType.toString()); } public void testTemplateType4a() { testSame( "/**\n" + " * @param {function():T} x\n" + " * @return {T}\n" + " * @template T\n" + " */\n" + "function f(x) {\n" + " return x;\n" + "}" + "/** @return {string} */\n" + "var g = function(){return 'hi'};\n" + "(function () {var result = f(g);})();"); JSType resultType = findNameType("result", lastLocalScope); assertEquals("string", resultType.toString()); } public void testTemplateType4b() { testSame( "/**\n" + " * @param {function(T):void} x\n" + " * @return {T}\n" + " * @template T\n" + " */\n" + "function f(x) {\n" + " return x;\n" + "}" + "/** @param {string} x */\n" + "var g = function(x){};\n" + "(function () {var result = f(g);})();"); JSType resultType = findNameType("result", lastLocalScope); assertEquals("string", resultType.toString()); } public void testTemplateType5() { testSame( "/**\n" + " * @param {Array.<T>} arr\n" + " * @return {!Array.<T>}\n" + " * @template T\n" + " */\n" + "function f(arr) {\n" + " return arr;\n" + "}" + "/** @type {Array.<string>} */\n" + "var arr = [];\n" + "var result = f(arr);"); assertEquals("Array.<string>", findNameTypeStr("result", globalScope)); } public void testTemplateType6() { testSame( "/**\n" + " * @param {Array.<T>|string|undefined} arr\n" + " * @return {!Array.<T>}\n" + " * @template T\n" + " */\n" + "function f(arr) {\n" + " return arr;\n" + "}" + "/** @type {Array.<string>} */\n" + "var arr = [];\n" + "var result = f(arr);"); assertEquals("Array.<string>", findNameTypeStr("result", globalScope)); } public void testTemplateType7() { testSame( "var goog = {};\n" + "goog.array = {};\n" + "/**\n" + " * @param {Array.<T>} arr\n" + " * @param {function(this:S, !T, number, !Array.<!T>):boolean} f\n" + " * @param {!S=} opt_obj\n" + " * @return {!Array.<T>}\n" + " * @template T,S\n" + " */\n" + "goog.array.filter = function(arr, f, opt_obj) {\n" + " var res = [];\n" + " for (var i = 0; i < arr.length; i++) {\n" + " if (f.call(opt_obj, arr[i], i, arr)) {\n" + " res.push(val);\n" + " }\n" + " }\n" + " return res;\n" + "}" + "/** @constructor */\n" + "function Foo() {}\n" + "/** @type {Array.<string>} */\n" + "var arr = [];\n" + "var result = goog.array.filter(arr," + " function(a,b,c) {var self=this;}, new Foo());"); assertEquals("Foo", findNameType("self", lastLocalScope).toString()); assertEquals("string", findNameType("a", lastLocalScope).toString()); assertEquals("number", findNameType("b", lastLocalScope).toString()); assertEquals("Array.<string>", findNameType("c", lastLocalScope).toString()); assertEquals("Array.<string>", findNameType("result", globalScope).toString()); } public void testTemplateType7b() { testSame( "var goog = {};\n" + "goog.array = {};\n" + "/**\n" + " * @param {Array.<T>} arr\n" + " * @param {function(this:S, !T, number, !Array.<T>):boolean} f\n" + " * @param {!S=} opt_obj\n" + " * @return {!Array.<T>}\n" + " * @template T,S\n" + " */\n" + "goog.array.filter = function(arr, f, opt_obj) {\n" + " var res = [];\n" + " for (var i = 0; i < arr.length; i++) {\n" + " if (f.call(opt_obj, arr[i], i, arr)) {\n" + " res.push(val);\n" + " }\n" + " }\n" + " return res;\n" + "}" + "/** @constructor */\n" + "function Foo() {}\n" + "/** @type {Array.<string>} */\n" + "var arr = [];\n" + "var result = goog.array.filter(arr," + " function(a,b,c) {var self=this;}, new Foo());"); assertEquals("Foo", findNameType("self", lastLocalScope).toString()); assertEquals("string", findNameType("a", lastLocalScope).toString()); assertEquals("number", findNameType("b", lastLocalScope).toString()); assertEquals("Array.<string>", findNameType("c", lastLocalScope).toString()); assertEquals("Array.<string>", findNameType("result", globalScope).toString()); } public void testTemplateType7c() { testSame( "var goog = {};\n" + "goog.array = {};\n" + "/**\n" + " * @param {Array.<T>} arr\n" + " * @param {function(this:S, T, number, Array.<T>):boolean} f\n" + " * @param {!S=} opt_obj\n" + " * @return {!Array.<T>}\n" + " * @template T,S\n" + " */\n" + "goog.array.filter = function(arr, f, opt_obj) {\n" + " var res = [];\n" + " for (var i = 0; i < arr.length; i++) {\n" + " if (f.call(opt_obj, arr[i], i, arr)) {\n" + " res.push(val);\n" + " }\n" + " }\n" + " return res;\n" + "}" + "/** @constructor */\n" + "function Foo() {}\n" + "/** @type {Array.<string>} */\n" + "var arr = [];\n" + "var result = goog.array.filter(arr," + " function(a,b,c) {var self=this;}, new Foo());"); assertEquals("Foo", findNameType("self", lastLocalScope).toString()); assertEquals("string", findNameType("a", lastLocalScope).toString()); assertEquals("number", findNameType("b", lastLocalScope).toString()); assertEquals("(Array.<string>|null)", findNameType("c", lastLocalScope).toString()); assertEquals("Array.<string>", findNameType("result", globalScope).toString()); } public void disable_testTemplateType8() { // TODO(johnlenz): somehow allow templated typedefs testSame( "/** @constructor */ NodeList = function() {};" + "/** @constructor */ Arguments = function() {};" + "var goog = {};" + "goog.array = {};" + "/**\n" + " * @typedef {Array.<T>|NodeList|Arguments|{length: number}}\n" + " * @template T\n" + " */\n" + "goog.array.ArrayLike;" + "/**\n" + " * @param {function(this:T, ...)} fn\n" + " * @param {T} thisObj\n" + " * @template T\n" + " */\n" + "function bind(fn, thisObj) {}" + "/** @constructor */\n" + "function Foo() {}\n" + "/** @return {number} */\n" + "Foo.prototype.baz = function() {};\n" + "bind(function() { var g = this; var f = this.baz(); }, new Foo());"); assertEquals("T", findNameType("g", lastLocalScope).toString()); assertTrue(findNameType("g", lastLocalScope).isEquivalentTo( registry.getType("Foo"))); assertEquals("number", findNameType("f", lastLocalScope).toString()); } public void testTemplateType9() { testSame( "/** @constructor */\n" + "function Foo() {}\n" + "/**\n" + " * @this {T}\n" + " * @return {T}\n" + " * @template T\n" + " */\n" + "Foo.prototype.method = function() {};\n" + "/**\n" + " * @constructor\n" + " * @extends {Foo}\n" + " */\n" + "function Bar() {}\n" + "\n" + "var g = new Bar().method();\n"); assertEquals("Bar", findNameType("g", globalScope).toString()); } public void testTemplateType10() { // NOTE: we would like the type within the function to remain "Foo" // we can handle this by support template type like "T extends Foo" // to provide a "minimum" type for "Foo" within the function body. testSame( "/** @constructor */\n" + "function Foo() {}\n" + "\n" + "/**\n" + " * @this {T}\n" + " * @return {T} fn\n" + " * @template T\n" + " */\n" + "Foo.prototype.method = function() {var g = this;};\n"); assertEquals("T", findNameType("g", lastLocalScope).toString()); } public void testTemplateType11() { testSame( "/**\n" + " * @this {T}\n" + " * @return {T} fn\n" + " * @template T\n" + " */\n" + "var method = function() {};\n" + "/**\n" + " * @constructor\n" + " */\n" + "function Bar() {}\n" + "\n" + "var g = method().call(new Bar());\n"); // NOTE: we would like this to be "Bar" assertEquals("?", findNameType("g", globalScope).toString()); } public void testTemplateType12() { testSame( "/** @constructor */\n" + "function Foo() {}\n" + "\n" + "/**\n" + " * @this {Array.<T>|{length:number}}\n" + " * @return {T} fn\n" + " * @template T\n" + " */\n" + "Foo.prototype.method = function() {var g = this;};\n"); assertEquals("(Array.<T>|{length: number})", findNameType("g", lastLocalScope).toString()); } public void testClosureParameterTypesWithoutJSDoc() { testSame( "/**\n" + " * @param {function(!Object)} bar\n" + " */\n" + "function foo(bar) {}\n" + "foo(function(baz) { var f = baz; })\n"); assertEquals("Object", findNameType("f", lastLocalScope).toString()); } public void testClosureParameterTypesWithJSDoc() { testSame( "/**\n" + " * @param {function(!Object)} bar\n" + " */\n" + "function foo(bar) {}\n" + "foo((/** @type {function(string)} */" + "function(baz) { var f = baz; }))\n"); assertEquals("string", findNameType("f", lastLocalScope).toString()); } public void testDuplicateExternProperty1() { testSame( "/** @constructor */ function Foo() {}" + "Foo.prototype.bar;" + "/** @type {number} */ Foo.prototype.bar; var x = (new Foo).bar;", null); assertEquals("number", findNameType("x", globalScope).toString()); } public void testDuplicateExternProperty2() { testSame( "/** @constructor */ function Foo() {}" + "/** @type {number} */ Foo.prototype.bar;" + "Foo.prototype.bar; var x = (new Foo).bar;", null); assertEquals("number", findNameType("x", globalScope).toString()); } public void testAbstractMethod() { testSame( "/** @type {!Function} */ var abstractMethod;" + "/** @constructor */ function Foo() {}" + "/** @param {number} x */ Foo.prototype.bar = abstractMethod;"); assertEquals( "Function", findNameType("abstractMethod", globalScope).toString()); FunctionType ctor = (FunctionType) findNameType("Foo", globalScope); ObjectType instance = ctor.getInstanceType(); assertEquals("Foo", instance.toString()); ObjectType proto = instance.getImplicitPrototype(); assertEquals("Foo.prototype", proto.toString()); assertEquals( "function (this:Foo, number): ?", proto.getPropertyType("bar").toString()); } public void testAbstractMethod2() { testSame( "/** @type {!Function} */ var abstractMethod;" + "/** @param {number} x */ var y = abstractMethod;"); assertEquals( "Function", findNameType("y", globalScope).toString()); assertEquals( "function (number): ?", globalScope.getVar("y").getType().toString()); } public void testAbstractMethod3() { testSame( "/** @type {!Function} */ var abstractMethod;" + "/** @param {number} x */ var y = abstractMethod; y;"); assertEquals( "function (number): ?", findNameType("y", globalScope).toString()); } public void testAbstractMethod4() { testSame( "/** @type {!Function} */ var abstractMethod;" + "/** @constructor */ function Foo() {}" + "Foo.prototype = {/** @param {number} x */ bar: abstractMethod};"); assertEquals( "Function", findNameType("abstractMethod", globalScope).toString()); FunctionType ctor = (FunctionType) findNameType("Foo", globalScope); ObjectType instance = ctor.getInstanceType(); assertEquals("Foo", instance.toString()); ObjectType proto = instance.getImplicitPrototype(); assertEquals("Foo.prototype", proto.toString()); assertEquals( // should be: "function (this:Foo, number): ?" "function (this:Foo, number): ?", proto.getPropertyType("bar").toString()); } public void testActiveXObject() { testSame( CompilerTypeTestCase.ACTIVE_X_OBJECT_DEF, "var x = new ActiveXObject();", null); assertEquals( "?", findNameType("x", globalScope).toString()); } public void testReturnTypeInference1() { testSame("function f() {}"); assertEquals( "function (): undefined", findNameType("f", globalScope).toString()); } public void testReturnTypeInference2() { testSame("/** @return {?} */ function f() {}"); assertEquals( "function (): ?", findNameType("f", globalScope).toString()); } public void testReturnTypeInference3() { testSame("function f() {x: return 3;}"); assertEquals( "function (): ?", findNameType("f", globalScope).toString()); } public void testReturnTypeInference4() { testSame("function f() { throw Error(); }"); assertEquals( "function (): ?", findNameType("f", globalScope).toString()); } public void testReturnTypeInference5() { testSame("function f() { if (true) { return 1; } }"); assertEquals( "function (): ?", findNameType("f", globalScope).toString()); } public void testLiteralTypesInferred() { testSame("null + true + false + 0 + '' + {}"); assertEquals( "null", findTokenType(Token.NULL, globalScope).toString()); assertEquals( "boolean", findTokenType(Token.TRUE, globalScope).toString()); assertEquals( "boolean", findTokenType(Token.FALSE, globalScope).toString()); assertEquals( "number", findTokenType(Token.NUMBER, globalScope).toString()); assertEquals( "string", findTokenType(Token.STRING, globalScope).toString()); assertEquals( "{}", findTokenType(Token.OBJECTLIT, globalScope).toString()); } public void testGlobalQualifiedNameInLocalScope() { testSame( "var ns = {}; " + "(function() { " + " /** @param {number} x */ ns.foo = function(x) {}; })();" + "(function() { ns.foo(3); })();"); assertNotNull(globalScope.getVar("ns.foo")); assertEquals( "function (number): undefined", globalScope.getVar("ns.foo").getType().toString()); } public void testDeclaredObjectLitProperty1() throws Exception { testSame("var x = {/** @type {number} */ y: 3};"); ObjectType xType = ObjectType.cast(globalScope.getVar("x").getType()); assertEquals( "number", xType.getPropertyType("y").toString()); assertEquals( "{y: number}", xType.toString()); } public void testDeclaredObjectLitProperty2() throws Exception { testSame("var x = {/** @param {number} z */ y: function(z){}};"); ObjectType xType = ObjectType.cast(globalScope.getVar("x").getType()); assertEquals( "function (number): undefined", xType.getPropertyType("y").toString()); assertEquals( "{y: function (number): undefined}", xType.toString()); } public void testDeclaredObjectLitProperty3() throws Exception { testSame("function f() {" + " var x = {/** @return {number} */ y: function(z){ return 3; }};" + "}"); ObjectType xType = ObjectType.cast(lastLocalScope.getVar("x").getType()); assertEquals( "function (?): number", xType.getPropertyType("y").toString()); assertEquals( "{y: function (?): number}", xType.toString()); } public void testDeclaredObjectLitProperty4() throws Exception { testSame("var x = {y: 5, /** @type {number} */ z: 3};"); ObjectType xType = ObjectType.cast(globalScope.getVar("x").getType()); assertEquals( "number", xType.getPropertyType("y").toString()); assertFalse(xType.isPropertyTypeDeclared("y")); assertTrue(xType.isPropertyTypeDeclared("z")); assertEquals( "{y: number, z: number}", xType.toString()); } public void testDeclaredObjectLitProperty5() throws Exception { testSame("var x = {/** @type {number} */ prop: 3};" + "function f() { var y = x.prop; }"); JSType yType = lastLocalScope.getVar("y").getType(); assertEquals("number", yType.toString()); } public void testDeclaredObjectLitProperty6() throws Exception { testSame("var x = {/** This is JsDoc */ prop: function(){}};"); Var prop = globalScope.getVar("x.prop"); JSType propType = prop.getType(); assertEquals("function (): undefined", propType.toString()); assertFalse(prop.isTypeInferred()); assertFalse( ObjectType.cast(globalScope.getVar("x").getType()) .isPropertyTypeInferred("prop")); } public void testInferredObjectLitProperty1() throws Exception { testSame("var x = {prop: 3};"); Var prop = globalScope.getVar("x.prop"); JSType propType = prop.getType(); assertEquals("number", propType.toString()); assertTrue(prop.isTypeInferred()); assertTrue( ObjectType.cast(globalScope.getVar("x").getType()) .isPropertyTypeInferred("prop")); } public void testInferredObjectLitProperty2() throws Exception { testSame("var x = {prop: function(){}};"); Var prop = globalScope.getVar("x.prop"); JSType propType = prop.getType(); assertEquals("function (): undefined", propType.toString()); assertTrue(prop.isTypeInferred()); assertTrue( ObjectType.cast(globalScope.getVar("x").getType()) .isPropertyTypeInferred("prop")); } public void testDeclaredConstType1() throws Exception { testSame( "/** @const */ var x = 3;" + "function f() { var y = x; }"); JSType yType = lastLocalScope.getVar("y").getType(); assertEquals("number", yType.toString()); } public void testDeclaredConstType2() throws Exception { testSame( "/** @const */ var x = {};" + "function f() { var y = x; }"); JSType yType = lastLocalScope.getVar("y").getType(); assertEquals("{}", yType.toString()); } public void testDeclaredConstType3() throws Exception { testSame( "/** @const */ var x = {};" + "/** @const */ x.z = 'hi';" + "function f() { var y = x.z; }"); JSType yType = lastLocalScope.getVar("y").getType(); assertEquals("string", yType.toString()); } public void testDeclaredConstType4() throws Exception { testSame( "/** @constructor */ function Foo() {}" + "/** @const */ Foo.prototype.z = 'hi';" + "function f() { var y = (new Foo()).z; }"); JSType yType = lastLocalScope.getVar("y").getType(); assertEquals("string", yType.toString()); ObjectType fooType = ((FunctionType) globalScope.getVar("Foo").getType()).getInstanceType(); assertTrue(fooType.isPropertyTypeDeclared("z")); } public void testDeclaredConstType5() throws Exception { testSame( "/** @const */ var goog = goog || {};" + "/** @const */ var foo = goog || {};" + "function f() { var y = goog; var z = foo; }"); JSType yType = lastLocalScope.getVar("y").getType(); assertEquals("{}", yType.toString()); JSType zType = lastLocalScope.getVar("z").getType(); assertEquals("?", zType.toString()); } public void testBadCtorInit1() throws Exception { testSame("/** @constructor */ var f;", CTOR_INITIALIZER); } public void testBadCtorInit2() throws Exception { testSame("var x = {}; /** @constructor */ x.f;", CTOR_INITIALIZER); } public void testBadIfaceInit1() throws Exception { testSame("/** @interface */ var f;", IFACE_INITIALIZER); } public void testBadIfaceInit2() throws Exception { testSame("var x = {}; /** @interface */ x.f;", IFACE_INITIALIZER); } public void testFunctionInHook() throws Exception { testSame("/** @param {number} x */ var f = Math.random() ? " + "function(x) {} : function(x) {};"); assertEquals("number", lastLocalScope.getVar("x").getType().toString()); } public void testFunctionInAnd() throws Exception { testSame("/** @param {number} x */ var f = Math.random() && " + "function(x) {};"); assertEquals("number", lastLocalScope.getVar("x").getType().toString()); } public void testFunctionInOr() throws Exception { testSame("/** @param {number} x */ var f = Math.random() || " + "function(x) {};"); assertEquals("number", lastLocalScope.getVar("x").getType().toString()); } public void testFunctionInComma() throws Exception { testSame("/** @param {number} x */ var f = (Math.random(), " + "function(x) {});"); assertEquals("number", lastLocalScope.getVar("x").getType().toString()); } public void testDeclaredCatchExpression1() { testSame( "try {} catch (e) {}"); // Note: "e" actually belongs to a inner scope but we don't // model catches as separate scopes currently. assertEquals(null, globalScope.getVar("e").getType()); } public void testDeclaredCatchExpression2() { testSame( "try {} catch (/** @type {string} */ e) {}"); // Note: "e" actually belongs to a inner scope but we don't // model catches as separate scopes currently. assertEquals("string", globalScope.getVar("e").getType().toString()); } private JSType findNameType(final String name, Scope scope) { return findTypeOnMatchedNode(new Predicate<Node>() { @Override public boolean apply(Node n) { return name.equals(n.getQualifiedName()); } }, scope); } private String findNameTypeStr(final String name, Scope scope) { return findNameType(name, scope).toString(); } private JSType findTokenType(final int type, Scope scope) { return findTypeOnMatchedNode(new Predicate<Node>() { @Override public boolean apply(Node n) { return type == n.getType(); } }, scope); } private JSType findTypeOnMatchedNode(Predicate<Node> matcher, Scope scope) { Node root = scope.getRootNode(); Deque<Node> queue = Lists.newLinkedList(); queue.push(root); while (!queue.isEmpty()) { Node current = queue.pop(); if (matcher.apply(current) && current.getJSType() != null) { return current.getJSType(); } for (Node child : current.children()) { queue.push(child); } } return null; } private JSType getNativeType(JSTypeNative type) { return registry.getNativeType(type); } private ObjectType getNativeObjectType(JSTypeNative type) { return (ObjectType) registry.getNativeType(type); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Test for {@link UnreachableCodeElimination}. * */ public class UnreachableCodeEliminationTest extends CompilerTestCase { private boolean removeNoOpStatements = true; @Override protected CompilerPass getProcessor(Compiler compiler) { return new UnreachableCodeElimination(compiler, removeNoOpStatements); } @Override public void setUp() throws Exception { super.setUp(); removeNoOpStatements = true; } public void testRemoveUnreachableCode() { // switch statement with stuff after "return" test("function foo(){switch(foo){case 1:x=1;return;break;" + "case 2:{x=2;return;break}default:}}", "function foo(){switch(foo){case 1:x=1;return;" + "case 2:{x=2}default:}}"); // if/else statements with returns test("function bar(){if(foo)x=1;else if(bar){return;x=2}" + "else{x=3;return;x=4}return 5;x=5}", "function bar(){if(foo)x=1;else if(bar){return}" + "else{x=3;return}return 5}"); // if statements without blocks test("function foo(){if(x==3)return;x=4;y++;while(y==4){return;x=3}}", "function foo(){if(x==3)return;x=4;y++;while(y==4){return}}"); // for/do/while loops test("function baz(){for(i=0;i<n;i++){x=3;break;x=4}" + "do{x=2;break;x=4}while(x==4);" + "while(i<4){x=3;return;x=6}}", "function baz(){for(i=0;i<n;){x=3;break}" + "do{x=2;break}while(x==4);" + "while(i<4){x=3;return}}"); // return statements on the same level as conditionals test("function foo(){if(x==3){return}return 5;while(y==4){x++;return;x=4}}", "function foo(){if(x==3){return}return 5}"); // return statements on the same level as conditionals test("function foo(){return 3;for(;y==4;){x++;return;x=4}}", "function foo(){return 3}"); // try/catch statements test("function foo(){try{x=3;return x+1;x=5}catch(e){x=4;return 5;x=5}}", "function foo(){try{x=3;return x+1}catch(e){x=4;return 5}}"); // try/finally statements test("function foo(){try{x=3;return x+1;x=5}finally{x=4;return 5;x=5}}", "function foo(){try{x=3;return x+1}finally{x=4;return 5}}"); // try/catch/finally statements test("function foo(){try{x=3;return x+1;x=5}catch(e){x=3;return;x=2}" + "finally{x=4;return 5;x=5}}", "function foo(){try{x=3;return x+1}catch(e){x=3;return}" + "finally{x=4;return 5}}"); // test a combination of blocks test("function foo(){x=3;if(x==4){x=5;return;x=6}else{x=7}return 5;x=3}", "function foo(){x=3;if(x==4){x=5;return}else{x=7}return 5}"); // test removing multiple statements test("function foo() { return 1; var x = 2; var y = 10; return 2;}", "function foo() { var y; var x; return 1}"); test("function foo() { return 1; x = 2; y = 10; return 2;}", "function foo(){ return 1}"); } public void testRemoveUselessNameStatements() { test("a;", ""); test("a.b;", ""); test("a.b.MyClass.prototype.memberName;", ""); } public void testRemoveUselessStrings() { test("'a';", ""); } public void testNoRemoveUseStrict() { test("'use strict';", "'use strict'"); } public void testNoRemoveUselessNameStatements() { removeNoOpStatements = false; testSame("a;"); testSame("a.b;"); testSame("a.b.MyClass.prototype.memberName;"); } public void testRemoveDo() { test("do { print(1); break } while(1)", "do { print(1); break } while(1)"); test("while(1) { break; do { print(1); break } while(1) }", "while(1) { break; do {} while(1) }"); } public void testRemoveUselessLiteralValueStatements() { test("true;", ""); test("'hi';", ""); test("if (x) 1;", ""); test("while (x) 1;", "while (x);"); test("do 1; while (x);", "do ; while (x);"); test("for (;;) 1;", "for (;;);"); test("switch(x){case 1:true;case 2:'hi';default:true}", "switch(x){case 1:case 2:default:}"); } public void testConditionalDeadCode() { test("function f() { if (1) return 5; else return 5; x = 1}", "function f() { if (1) return 5; else return 5; }"); } public void testSwitchCase() { test("function f() { switch(x) { default: return 5; foo()}}", "function f() { switch(x) { default: return 5;}}"); test("function f() { switch(x) { default: return; case 1: foo(); bar()}}", "function f() { switch(x) { default: return; case 1: foo(); bar()}}"); test("function f() { switch(x) { default: return; case 1: return 5;bar()}}", "function f() { switch(x) { default: return; case 1: return 5;}}"); } public void testTryCatchFinally() { testSame("try {foo()} catch (e) {bar()}"); testSame("try { try {foo()} catch (e) {bar()}} catch (x) {bar()}"); test("try {var x = 1} catch (e) {e()}", "try {var x = 1} finally {}"); test("try {var x = 1} catch (e) {e()} finally {x()}", " try {var x = 1} finally {x()}"); test("try {var x = 1} catch (e) {e()} finally {}", "try {var x = 1} finally {}"); testSame("try {var x = 1} finally {x()}"); testSame("try {var x = 1} finally {}"); test("function f() {return; try{var x = 1}catch(e){} }", "function f() {var x;}"); } public void testRemovalRequiresRedeclaration() { test("while(1) { break; var x = 1}", "var x; while(1) { break } "); test("while(1) { break; var x=1; var y=1}", "var y; var x; while(1) { break } "); } public void testAssignPropertyOnCreatedObject() { testSame("this.foo = 3;"); testSame("a.foo = 3;"); testSame("bar().foo = 3;"); testSame("({}).foo = bar();"); testSame("(new X()).foo = 3;"); test("({}).foo = 3;", ""); test("(function() {}).prototype.toString = function(){};", ""); test("(function() {}).prototype['toString'] = function(){};", ""); test("(function() {}).prototype[f] = function(){};", ""); } public void testUselessUnconditionalReturn() { test("function foo() { return }", " function foo() { }"); test("function foo() { return; return; x=1 }", "function foo() { }"); test("function foo() { return; return; var x=1}", "function foo() {var x}"); test("function foo() { return; function bar() {} }", "function foo() { function bar() {} }" ); testSame("function foo() { return 5 }"); test("function f() {switch (a) { case 'a': return}}", "function f() {switch (a) { case 'a': }}"); testSame("function f() {switch (a) { case 'a': case foo(): }}"); testSame("function f() {switch (a) {" + " default: return; case 'a': alert(1)}}"); testSame("function f() {switch (a) {" + " case 'a': return; default: alert(1)}}"); } public void testUnlessUnconditionalContinue() { test("for(;1;) {continue}", " for(;1;) {}"); test("for(;0;) {continue}", " for(;0;) {}"); testSame("X: for(;1;) { for(;1;) { if (x()) {continue X} x = 1}}"); test("for(;1;) { X: for(;1;) { if (x()) {continue X} }}", "for(;1;) { X: for(;1;) { if (x()) {}}}"); test("do { continue } while(1);", "do { } while(1);"); } public void testUnlessUnconditonalBreak() { test("switch (a) { case 'a': break }", "switch (a) { case 'a': }"); test("switch (a) { case 'a': break; case foo(): }", "switch (a) { case 'a': case foo(): }"); test("switch (a) { default: break; case 'a': }", "switch (a) { default: case 'a': }"); testSame("switch (a) { case 'a': alert(a); break; default: alert(a); }"); testSame("switch (a) { default: alert(a); break; case 'a': alert(a); }"); test("X: {switch (a) { case 'a': break X}}", "X: {switch (a) { case 'a': }}"); testSame("X: {switch (a) { case 'a': if (a()) {break X} a = 1}}"); test("X: {switch (a) { case 'a': if (a()) {break X}}}", "X: {switch (a) { case 'a': if (a()) {}}}"); test("X: {switch (a) { case 'a': if (a()) {break X}}}", "X: {switch (a) { case 'a': if (a()) {}}}"); testSame("do { break } while(1);"); testSame("for(;1;) { break }"); } public void testCascadedRemovalOfUnlessUnconditonalJumps() { test("switch (a) { case 'a': break; case 'b': break; case 'c': break }", "switch (a) { case 'a': break; case 'b': case 'c': }"); // Only one break removed per pass. test("switch (a) { case 'a': break; case 'b': case 'c': }", "switch (a) { case 'a': case 'b': case 'c': }"); test("function foo() {" + " switch (a) { case 'a':return; case 'b':return; case 'c':return }}", "function foo() { switch (a) { case 'a':return; case 'b': case 'c': }}"); test("function foo() {" + " switch (a) { case 'a':return; case 'b': case 'c': }}", "function foo() { switch (a) { case 'a': case 'b': case 'c': }}"); testSame("function foo() {" + "switch (a) { case 'a':return 2; case 'b':return 1}}"); } public void testIssue311() { test("function a(b) {\n" + " switch (b.v) {\n" + " case 'SWITCH':\n" + " if (b.i >= 0) {\n" + " return b.o;\n" + " } else {\n" + " return;\n" + " }\n" + " break;\n" + " }\n" + "}", "function a(b) {\n" + " switch (b.v) {\n" + " case 'SWITCH':\n" + " if (b.i >= 0) {\n" + " return b.o;\n" + " } else {\n" + " }\n" + " }\n" + "}"); } public void testIssue4177428a() { test( "f = function() {\n" + " var action;\n" + " a: {\n" + " var proto = null;\n" + " try {\n" + " proto = new Proto\n" + " } finally {\n" + " action = proto;\n" + " break a\n" + // Remove this... " }\n" + " }\n" + " alert(action)\n" + // but not this. "};", "f = function() {\n" + " var action;\n" + " a: {\n" + " var proto = null;\n" + " try {\n" + " proto = new Proto\n" + " } finally {\n" + " action = proto;\n" + " }\n" + " }\n" + " alert(action)\n" + // but not this. "};" ); } public void testIssue4177428b() { test( "f = function() {\n" + " var action;\n" + " a: {\n" + " var proto = null;\n" + " try {\n" + " try {\n" + " proto = new Proto\n" + " } finally {\n" + " action = proto;\n" + " break a\n" + // Remove this... " }\n" + " } finally {\n" + " }\n" + " }\n" + " alert(action)\n" + // but not this. "};", "f = function() {\n" + " var action;\n" + " a: {\n" + " var proto = null;\n" + " try {\n" + " try {\n" + " proto = new Proto\n" + " } finally {\n" + " action = proto;\n" + " break a\n" + // Remove this... " }\n" + " } finally {\n" + " }\n" + " }\n" + " alert(action)\n" + // but not this. "};" ); } public void testIssue4177428c() { test( "f = function() {\n" + " var action;\n" + " a: {\n" + " var proto = null;\n" + " try {\n" + " } finally {\n" + " try {\n" + " proto = new Proto\n" + " } finally {\n" + " action = proto;\n" + " break a\n" + // Remove this... " }\n" + " }\n" + " }\n" + " alert(action)\n" + // but not this. "};", "f = function() {\n" + " var action;\n" + " a: {\n" + " var proto = null;\n" + " try {\n" + " } finally {\n" + " try {\n" + " proto = new Proto\n" + " } finally {\n" + " action = proto;\n" + " }\n" + " }\n" + " }\n" + " alert(action)\n" + // but not this. "};" ); } public void testIssue4177428_continue() { test( "f = function() {\n" + " var action;\n" + " a: do {\n" + " var proto = null;\n" + " try {\n" + " proto = new Proto\n" + " } finally {\n" + " action = proto;\n" + " continue a\n" + // Remove this... " }\n" + " } while(false)\n" + " alert(action)\n" + // but not this. "};", "f = function() {\n" + " var action;\n" + " a: do {\n" + " var proto = null;\n" + " try {\n" + " proto = new Proto\n" + " } finally {\n" + " action = proto;\n" + " }\n" + " } while (false)\n" + " alert(action)\n" + "};" ); } public void testIssue4177428_return() { test( "f = function() {\n" + " var action;\n" + " a: {\n" + " var proto = null;\n" + " try {\n" + " proto = new Proto\n" + " } finally {\n" + " action = proto;\n" + " return\n" + // Remove this... " }\n" + " }\n" + " alert(action)\n" + // and this. "};", "f = function() {\n" + " var action;\n" + " a: {\n" + " var proto = null;\n" + " try {\n" + " proto = new Proto\n" + " } finally {\n" + " action = proto;\n" + " }\n" + " }\n" + "};" ); } public void testIssue4177428_multifinally() { testSame( "a: {\n" + " try {\n" + " try {\n" + " } finally {\n" + " break a;\n" + " }\n" + " } finally {\n" + " x = 1;\n" + " }\n" + "}"); } public void testIssue5215541_deadVarDeclar() { testSame("throw 1; var x"); testSame("throw 1; function x() {}"); testSame("throw 1; var x; var y;"); test("throw 1; var x = foo", "var x; throw 1"); } public void testForInLoop() { testSame("for(var x in y) {}"); } }
/* * Copyright 2005 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.rhino.Node; public class VarCheckTest extends CompilerTestCase { private static final String EXTERNS = "var window; function alert() {}"; private CheckLevel strictModuleDepErrorLevel; private boolean sanityCheck = false; private CheckLevel externValidationErrorLevel; private CompilerPass testSetupPass; public VarCheckTest() { super(EXTERNS); } @Override protected void setUp() throws Exception { super.setUp(); // Setup value set by individual tests to the appropriate defaults. super.allowExternsChanges(true); super.enableAstValidation(true); strictModuleDepErrorLevel = CheckLevel.OFF; externValidationErrorLevel = null; sanityCheck = false; testSetupPass = null; } @Override protected CompilerOptions getOptions() { CompilerOptions options = super.getOptions(); options.setWarningLevel(DiagnosticGroups.STRICT_MODULE_DEP_CHECK, strictModuleDepErrorLevel); if (externValidationErrorLevel != null) { options.setWarningLevel(DiagnosticGroups.EXTERNS_VALIDATION, externValidationErrorLevel); } return options; } @Override protected CompilerPass getProcessor(final Compiler compiler) { if (!sanityCheck) { return new CompilerPass() { @Override public void process(Node externs, Node root) { if (testSetupPass != null) { testSetupPass.process(externs, root); } new VarCheck(compiler, false).process(externs, root); if (!compiler.hasErrors()) { new VarCheck(compiler, true).process(externs, root); } } }; } return new VarCheck(compiler, sanityCheck); } @Override protected int getNumRepetitions() { // Because we synthesize externs, the second pass won't emit a warning. return 1; } public void testBreak() { testSame("a: while(1) break a;"); } public void testContinue() { testSame("a: while(1) continue a;"); } public void testReferencedVarNotDefined() { test("x = 0;", null, VarCheck.UNDEFINED_VAR_ERROR); } public void testReferencedVarDefined1() { testSame("var x, y; x=1;"); } public void testReferencedVarDefined2() { testSame("var x; function y() {x=1;}"); } public void testReferencedVarsExternallyDefined() { testSame("var x = window; alert(x);"); } public void testMultiplyDeclaredVars1() { test("var x = 1; var x = 2;", null, SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR); } public void testMultiplyDeclaredVars2() { test("var y; try { y=1 } catch (x) {}" + "try { y=1 } catch (x) {}", "var y;try{y=1}catch(x){}try{y=1}catch(x){}"); } public void testMultiplyDeclaredVars3() { test("try { var x = 1; x *=2; } catch (x) {}", null, SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR); } public void testMultiplyDeclaredVars4() { testSame("x;", "var x = 1; var x = 2;", SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR, true); } public void testVarReferenceInExterns() { testSame("asdf;", "var asdf;", VarCheck.NAME_REFERENCE_IN_EXTERNS_ERROR); } public void testCallInExterns() { testSame("yz();", "function yz() {}", VarCheck.NAME_REFERENCE_IN_EXTERNS_ERROR); } public void testPropReferenceInExterns1() { testSame("asdf.foo;", "var asdf;", VarCheck.UNDEFINED_EXTERN_VAR_ERROR); } public void testPropReferenceInExterns2() { testSame("asdf.foo;", "", VarCheck.UNDEFINED_VAR_ERROR, true); } public void testPropReferenceInExterns3() { testSame("asdf.foo;", "var asdf;", VarCheck.UNDEFINED_EXTERN_VAR_ERROR); externValidationErrorLevel = CheckLevel.ERROR; test( "asdf.foo;", "var asdf;", "", VarCheck.UNDEFINED_EXTERN_VAR_ERROR, null); externValidationErrorLevel = CheckLevel.OFF; test("asdf.foo;", "var asdf;", "var asdf;", null, null); } public void testVarInWithBlock() { test("var a = {b:5}; with (a){b;}", null, VarCheck.UNDEFINED_VAR_ERROR); } public void testValidFunctionExpr() { testSame("(function() {});"); } public void testRecursiveFunction() { testSame("(function a() { return a(); })();"); } public void testRecursiveFunction2() { testSame("var a = 3; (function a() { return a(); })();"); } public void testLegalVarReferenceBetweenModules() { testDependentModules("var x = 10;", "var y = x++;", null); } public void testMissingModuleDependencyDefault() { testIndependentModules("var x = 10;", "var y = x++;", null, VarCheck.MISSING_MODULE_DEP_ERROR); } public void testViolatedModuleDependencyDefault() { testDependentModules("var y = x++;", "var x = 10;", VarCheck.VIOLATED_MODULE_DEP_ERROR); } public void testMissingModuleDependencySkipNonStrict() { sanityCheck = true; testIndependentModules("var x = 10;", "var y = x++;", null, null); } public void testViolatedModuleDependencySkipNonStrict() { sanityCheck = true; testDependentModules("var y = x++;", "var x = 10;", null); } public void testMissingModuleDependencySkipNonStrictNotPromoted() { sanityCheck = true; strictModuleDepErrorLevel = CheckLevel.ERROR; testIndependentModules("var x = 10;", "var y = x++;", null, null); } public void testViolatedModuleDependencyNonStrictNotPromoted() { sanityCheck = true; strictModuleDepErrorLevel = CheckLevel.ERROR; testDependentModules("var y = x++;", "var x = 10;", null); } public void testDependentStrictModuleDependencyCheck() { strictModuleDepErrorLevel = CheckLevel.ERROR; testDependentModules("var f = function() {return new B();};", "var B = function() {}", VarCheck.STRICT_MODULE_DEP_ERROR); } public void testIndependentStrictModuleDependencyCheck() { strictModuleDepErrorLevel = CheckLevel.ERROR; testIndependentModules("var f = function() {return new B();};", "var B = function() {}", VarCheck.STRICT_MODULE_DEP_ERROR, null); } public void testStarStrictModuleDependencyCheck() { strictModuleDepErrorLevel = CheckLevel.WARNING; testSame(createModuleStar("function a() {}", "function b() { a(); c(); }", "function c() { a(); }"), VarCheck.STRICT_MODULE_DEP_ERROR); } public void testForwardVarReferenceInLocalScope1() { testDependentModules("var x = 10; function a() {y++;}", "var y = 11; a();", null); } public void testForwardVarReferenceInLocalScope2() { // It would be nice if this pass could use a call graph to flag this case // as an error, but it currently doesn't. testDependentModules("var x = 10; function a() {y++;} a();", "var y = 11;", null); } private void testDependentModules(String code1, String code2, DiagnosticType error) { testDependentModules(code1, code2, error, null); } private void testDependentModules(String code1, String code2, DiagnosticType error, DiagnosticType warning) { testTwoModules(code1, code2, true, error, warning); } private void testIndependentModules(String code1, String code2, DiagnosticType error, DiagnosticType warning) { testTwoModules(code1, code2, false, error, warning); } private void testTwoModules(String code1, String code2, boolean m2DependsOnm1, DiagnosticType error, DiagnosticType warning) { JSModule m1 = new JSModule("m1"); m1.add(SourceFile.fromCode("input1", code1)); JSModule m2 = new JSModule("m2"); m2.add(SourceFile.fromCode("input2", code2)); if (m2DependsOnm1) { m2.addDependency(m1); } test(new JSModule[] { m1, m2 }, new String[] { code1, code2 }, error, warning); } ////////////////////////////////////////////////////////////////////////////// // Test synthesis of externs public void testSimple() { checkSynthesizedExtern("x", "var x;"); checkSynthesizedExtern("var x", ""); } public void testSimpleSanityCheck() { sanityCheck = true; try { checkSynthesizedExtern("x", ""); } catch (RuntimeException e) { assertTrue(e.getMessage().indexOf("Unexpected variable x") != -1); } } public void testParameter() { checkSynthesizedExtern("function f(x){}", ""); } public void testLocalVar() { checkSynthesizedExtern("function f(){x}", "var x"); } public void testTwoLocalVars() { checkSynthesizedExtern("function f(){x}function g() {x}", "var x"); } public void testInnerFunctionLocalVar() { checkSynthesizedExtern("function f(){function g() {x}}", "var x"); } public void testNoCreateVarsForLabels() { checkSynthesizedExtern("x:var y", ""); } public void testVariableInNormalCodeUsedInExterns1() { checkSynthesizedExtern( "x.foo;", "var x;", "var x; x.foo;"); } public void testVariableInNormalCodeUsedInExterns2() { checkSynthesizedExtern( "x;", "var x;", "var x; x;"); } public void testVariableInNormalCodeUsedInExterns3() { checkSynthesizedExtern( "x.foo;", "function x() {}", "var x; x.foo; "); } public void testVariableInNormalCodeUsedInExterns4() { checkSynthesizedExtern( "x;", "function x() {}", "var x; x; "); } private final static class VariableTestCheck implements CompilerPass { final AbstractCompiler compiler; VariableTestCheck(AbstractCompiler compiler) { this.compiler = compiler; } @Override public void process(Node externs, Node root) { NodeTraversal.traverseRoots(compiler, Lists.newArrayList(externs, root), new AbstractPostOrderCallback() { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isName() && !parent.isFunction() && !parent.isLabel()) { assertTrue("Variable " + n.getString() + " should have be declared", t.getScope().isDeclared(n.getString(), true)); } } }); } } public void checkSynthesizedExtern( String input, String expectedExtern) { checkSynthesizedExtern("", input, expectedExtern); } public void checkSynthesizedExtern( String extern, String input, String expectedExtern) { Compiler compiler = new Compiler(); CompilerOptions options = new CompilerOptions(); options.setWarningLevel( DiagnosticGroup.forType(VarCheck.UNDEFINED_VAR_ERROR), CheckLevel.OFF); compiler.init( ImmutableList.of(SourceFile.fromCode("extern", extern)), ImmutableList.of(SourceFile.fromCode("input", input)), options); compiler.parseInputs(); assertFalse(compiler.hasErrors()); Node externsAndJs = compiler.getRoot(); Node root = externsAndJs.getLastChild(); Node rootOriginal = root.cloneTree(); Node externs = externsAndJs.getFirstChild(); Node expected = compiler.parseTestCode(expectedExtern); assertFalse(compiler.hasErrors()); (new VarCheck(compiler, sanityCheck)) .process(externs, root); if (!sanityCheck) { (new VariableTestCheck(compiler)).process(externs, root); } String externsCode = compiler.toSource(externs); String expectedCode = compiler.toSource(expected); assertEquals(expectedCode, externsCode); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.base.Charsets; import com.google.common.collect.ImmutableMap; import junit.framework.TestCase; import java.text.ParseException; import java.util.Arrays; import java.util.List; import java.util.Map; /** * Tests for {@link VariableMap}. * */ public class VariableMapTest extends TestCase { public void testCycle1() throws ParseException { cycleTest(ImmutableMap.of("AAA", "a", "BBB", "b")); cycleTest(ImmutableMap.of("AA:AA", "a", "BB:BB", "b")); cycleTest(ImmutableMap.of("AAA", "a:a", "BBB", "b:b")); } public void cycleTest(ImmutableMap<String, String> map) throws ParseException { VariableMap in = new VariableMap(map); String serialized = new String(in.toBytes(), Charsets.UTF_8); VariableMap out = VariableMap.fromBytes(serialized.getBytes()); assertMapsEquals(in.toMap(), out.toMap()); } public void assertMapsEquals( Map<String, String> expected, Map<String, String> result) { assertEquals(expected.size(), result.size()); for (String key : expected.keySet()) { assertEquals(expected.get(key), result.get(key)); } } public void testToBytes() { VariableMap vm = new VariableMap(ImmutableMap.of("AAA", "a", "BBB", "b")); String serialized = new String(vm.toBytes(), Charsets.UTF_8); assertTrue(serialized.endsWith("\n")); List<String> lines = Arrays.asList(serialized.split("\n")); assertEquals(2, lines.size()); assertTrue(lines.contains("AAA:a")); assertTrue(lines.contains("BBB:b")); } public void testFromBytes() throws ParseException { VariableMap vm = VariableMap.fromBytes("AAA:a\nBBB:b\n".getBytes()); assertEquals(2, vm.getOriginalNameToNewNameMap().size()); assertEquals("a", vm.lookupNewName("AAA")); assertEquals("b", vm.lookupNewName("BBB")); assertEquals("AAA", vm.lookupSourceName("a")); assertEquals("BBB", vm.lookupSourceName("b")); } public void testFileFormat1() { assertEqual( new VariableMap(ImmutableMap.of("x\ny", "a")).toBytes(), "x\\ny:a\n".getBytes()); assertEqual( new VariableMap(ImmutableMap.of("x:y", "a")).toBytes(), "x\\:y:a\n".getBytes()); assertEqual( new VariableMap(ImmutableMap.of("x\ny", "a")).toBytes(), "x\\ny:a\n".getBytes()); assertEqual( new VariableMap(ImmutableMap.of("x\\y", "a")).toBytes(), "x\\\\y:a\n".getBytes()); assertEqual( new VariableMap(ImmutableMap.of("\n", "a")).toBytes(), "\\n:a\n".getBytes()); assertEqual( new VariableMap(ImmutableMap.of(":", "a")).toBytes(), "\\::a\n".getBytes()); assertEqual( new VariableMap(ImmutableMap.of("\n", "a")).toBytes(), "\\n:a\n".getBytes()); assertEqual( new VariableMap(ImmutableMap.of("\\", "a")).toBytes(), "\\\\:a\n".getBytes()); } public void testFromBytesComplex1() throws ParseException { // Verify we get out what we put in. cycleTest(ImmutableMap.of("AAA[':f']", "a")); // Verify the file format is as expected. VariableMap in = new VariableMap(ImmutableMap.of("AAA[':f']", "a")); assertEqual(in.toBytes(), "AAA['\\:f']:a\n".getBytes()); } public void testFromBytesComplex2() throws ParseException { VariableMap vm = VariableMap.fromBytes("AAA['\\:f']:a\n".getBytes()); assertEquals(1, vm.getOriginalNameToNewNameMap().size()); assertEquals("a", vm.lookupNewName("AAA[':f']")); assertEquals(1, vm.getNewNameToOriginalNameMap().size()); assertEquals("AAA[':f']", vm.lookupSourceName("a")); } private void assertEqual(byte[] bytes1, byte[] bytes2) { if (bytes1 != bytes2) { assertEquals("length differs.", bytes1.length, bytes2.length); for (int i = 0; i < bytes1.length; i++) { assertEquals("byte " + i + "differs.", bytes1[i], bytes2[i]); } } } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; /** * Test that warnings are generated in appropriate cases and appropriate * cases only by VariableReferenceCheck * */ public class VariableReferenceCheckTest extends CompilerTestCase { private static final String VARIABLE_RUN = "var a = 1; var b = 2; var c = a + b, d = c;"; private boolean enableAmbiguousFunctionCheck = false; @Override public CompilerOptions getOptions() { CompilerOptions options = super.getOptions(); if (enableAmbiguousFunctionCheck) { options.setWarningLevel( DiagnosticGroups.AMBIGUOUS_FUNCTION_DECL, CheckLevel.WARNING); } return options; } @Override public CompilerPass getProcessor(Compiler compiler) { // Treats bad reads as errors, and reports bad write warnings. return new VariableReferenceCheck(compiler, CheckLevel.WARNING); } @Override public void setUp() throws Exception { super.setUp(); enableAmbiguousFunctionCheck = false; } public void testCorrectCode() { assertNoWarning("function foo(d) { (function() { d.foo(); }); d.bar(); } "); assertNoWarning("function foo() { bar(); } function bar() { foo(); } "); assertNoWarning("function f(d) { d = 3; }"); assertNoWarning(VARIABLE_RUN); assertNoWarning("function f() { " + VARIABLE_RUN + "}"); } public void testCorrectShadowing() { assertNoWarning(VARIABLE_RUN + "function f() { " + VARIABLE_RUN + "}"); } public void testCorrectRedeclare() { assertNoWarning( "function f() { if (1) { var a = 2; } else { var a = 3; } }"); } public void testCorrectRecursion() { assertNoWarning("function f() { var x = function() { x(); }; }"); } public void testCorrectCatch() { assertNoWarning("function f() { try { var x = 2; } catch (x) {} }"); } public void testRedeclare() { // Only test local scope since global scope is covered elsewhere assertRedeclare("function f() { var a = 2; var a = 3; }"); assertRedeclare("function f(a) { var a = 2; }"); } public void testEarlyReference() { assertUndeclared("function f() { a = 2; var a = 3; }"); } public void testCorrectEarlyReference() { assertNoWarning("var goog = goog || {}"); assertNoWarning("function f() { a = 2; } var a = 2;"); } public void testUnreferencedBleedingFunction() { assertNoWarning("var x = function y() {}"); } public void testReferencedBleedingFunction() { assertNoWarning("var x = function y() { return y(); }"); } public void testDoubleDeclaration() { assertRedeclare("function x(y) { if (true) { var y; } }"); } public void testDoubleDeclaration2() { assertRedeclare("function x() { var y; if (true) { var y; } }"); } public void testHoistedFunction1() { enableAmbiguousFunctionCheck = true; assertNoWarning("f(); function f() {}"); } public void testHoistedFunction2() { enableAmbiguousFunctionCheck = true; assertNoWarning("function g() { f(); function f() {} }"); } public void testNonHoistedFunction() { enableAmbiguousFunctionCheck = true; assertUndeclared("if (true) { f(); function f() {} }"); } public void testNonHoistedFunction2() { enableAmbiguousFunctionCheck = true; assertNoWarning("if (false) { function f() {} f(); }"); } public void testNonHoistedFunction3() { enableAmbiguousFunctionCheck = true; assertNoWarning("function g() { if (false) { function f() {} f(); }}"); } public void testNonHoistedFunction4() { enableAmbiguousFunctionCheck = true; assertAmbiguous("if (false) { function f() {} } f();"); } public void testNonHoistedFunction5() { enableAmbiguousFunctionCheck = true; assertAmbiguous("function g() { if (false) { function f() {} } f(); }"); } public void testNonHoistedFunction6() { enableAmbiguousFunctionCheck = true; assertUndeclared("if (false) { f(); function f() {} }"); } public void testNonHoistedFunction7() { enableAmbiguousFunctionCheck = true; assertUndeclared("function g() { if (false) { f(); function f() {} }}"); } public void testNonHoistedRecursiveFunction1() { enableAmbiguousFunctionCheck = true; assertNoWarning("if (false) { function f() { f(); }}"); } public void testNonHoistedRecursiveFunction2() { enableAmbiguousFunctionCheck = true; assertNoWarning("function g() { if (false) { function f() { f(); }}}"); } public void testNonHoistedRecursiveFunction3() { enableAmbiguousFunctionCheck = true; assertNoWarning("function g() { if (false) { function f() { f(); g(); }}}"); } public void testNoWarnInExterns1() { // Verify duplicate suppressions are properly recognized. String externs = "var google;" + "/** @suppress {duplicate} */ var google"; String code = ""; test(externs, code, code, null, null); } public void testNoWarnInExterns2() { // Verify we don't complain about early references in externs String externs = "window;" + "var window;"; String code = ""; test(externs, code, code, null, null); } /** * Expects the JS to generate one bad-read error. */ private void assertRedeclare(String js) { testSame(js, VariableReferenceCheck.REDECLARED_VARIABLE); } /** * Expects the JS to generate one bad-write warning. */ private void assertUndeclared(String js) { testSame(js, VariableReferenceCheck.UNDECLARED_REFERENCE); } /** * Expects the JS to generate one bad-write warning. */ private void assertAmbiguous(String js) { testSame(js, VariableReferenceCheck.AMBIGUOUS_FUNCTION_DECL); } /** * Expects the JS to generate no errors or warnings. */ private void assertNoWarning(String js) { testSame(js); } }
/* * Copyright 2010 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import com.google.common.base.Preconditions; import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback; import com.google.javascript.jscomp.VariableVisibilityAnalysis.VariableVisibility; import com.google.javascript.rhino.Node; /** * Tests of {@link VariableVisibilityAnalysis}. * * @author dcc@google.com (Devin Coughlin) */ public class VariableVisibilityAnalysisTest extends CompilerTestCase { private Compiler lastCompiler; private VariableVisibilityAnalysis lastAnalysis; @Override protected CompilerPass getProcessor(Compiler compiler) { lastAnalysis = new VariableVisibilityAnalysis(compiler); lastCompiler = compiler; return lastAnalysis; } public void testCapturedVariables() { String source = "global:var global;\n" + "function Outer() {\n" + " captured:var captured;\n" + " notcaptured:var notCaptured;\n" + " function Inner() {\n" + " alert(captured);" + " }\n" + "}\n"; analyze(source); assertIsCapturedLocal("captured"); assertIsUncapturedLocal("notcaptured"); } public void testGlobals() { String source = "global:var global;"; analyze(source); assertIsGlobal("global"); } public void testParameters() { String source = "function A(a,b,c) {\n" + "}\n"; analyze(source); assertIsParameter("a"); assertIsParameter("b"); assertIsParameter("c"); } public void testFunctions() { String source = "function global() {\n" + " function inner() {\n" + " }\n" + " function innerCaptured() {\n" + " (function(){innerCaptured()})()\n" + " }\n" + "}\n"; analyze(source); assertFunctionHasVisibility("global", VariableVisibility.GLOBAL); assertFunctionHasVisibility("inner", VariableVisibility.LOCAL); assertFunctionHasVisibility("innerCaptured", VariableVisibility.CAPTURED_LOCAL); } private void assertFunctionHasVisibility(String functionName, VariableVisibility visibility) { Node functionNode = searchForFunction(functionName); assertNotNull(functionNode); Node nameNode = functionNode.getFirstChild(); assertEquals(visibility, lastAnalysis.getVariableVisibility(nameNode)); } private void assertLabeledVariableHasVisibility(String label, VariableVisibility visibility) { Node labeledVariable = searchLabel(label); Preconditions.checkState(labeledVariable.isVar()); // VAR // NAME Node nameNode = labeledVariable.getFirstChild(); assertEquals(visibility, lastAnalysis.getVariableVisibility(nameNode)); } private void assertIsCapturedLocal(String label) { assertLabeledVariableHasVisibility(label, VariableVisibility.CAPTURED_LOCAL); } private void assertIsUncapturedLocal(String label) { assertLabeledVariableHasVisibility(label, VariableVisibility.LOCAL); } private void assertIsGlobal(String label) { assertLabeledVariableHasVisibility(label, VariableVisibility.GLOBAL); } private void assertIsParameter(String parameterName) { Node parameterNode = searchForParameter(parameterName); assertNotNull(parameterNode); assertEquals(VariableVisibility.PARAMETER, lastAnalysis.getVariableVisibility(parameterNode)); } private VariableVisibilityAnalysis analyze(String src) { testSame(src); return lastAnalysis; } /* * Finds a parameter NAME node with the given name in the source AST. * * Behavior is undefined if there are multiple parameters with * parameterName. */ private Node searchForParameter(final String parameterName) { Preconditions.checkArgument(parameterName != null); final Node[] foundNode = new Node[1]; AbstractPostOrderCallback findParameter = new AbstractPostOrderCallback() { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.getParent().isParamList() && parameterName.equals(n.getString())) { foundNode[0] = n; } } }; new NodeTraversal(lastCompiler, findParameter) .traverse(lastCompiler.jsRoot); return foundNode[0]; } /* * Finds a function node with the given name in the source AST. * * Behavior is undefined if there are multiple functions with * parameterName. */ private Node searchForFunction(final String functionName) { Preconditions.checkArgument(functionName != null); final Node[] foundNode = new Node[1]; AbstractPostOrderCallback findFunction = new AbstractPostOrderCallback() { @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isFunction() && functionName.equals(NodeUtil.getFunctionName(n))) { foundNode[0] = n; } } }; new NodeTraversal(lastCompiler, findFunction) .traverse(lastCompiler.jsRoot); return foundNode[0]; } // Shamelessly stolen from NameReferenceGraphConstructionTest private Node searchLabel(String label) { LabeledVariableSearcher s = new LabeledVariableSearcher(label); new NodeTraversal(lastCompiler, s).traverse(lastCompiler.jsRoot); assertNotNull("Label " + label + " should be in the source code", s.found); return s.found; } /** * Quick traversal to find a given labeled variable in the AST. * * Finds the variable for foo in: * foo: var a = ... */ private class LabeledVariableSearcher extends AbstractPostOrderCallback { Node found = null; final String target; LabeledVariableSearcher(String target) { this.target = target; } @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isLabel() && target.equals(n.getFirstChild().getString())) { // LABEL // VAR // NAME found = n.getLastChild(); } } } }
/* * Copyright 2006 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp; import static com.google.common.base.Charsets.UTF_8; import junit.framework.TestCase; import java.io.ByteArrayInputStream; import java.io.InputStream; /** * Tests {@link XtbMessageBundle}. * */ public class XtbMessageBundleTest extends TestCase { private final static String PROJECT_ID = "TestProject"; private static final String XTB = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<!DOCTYPE translationbundle SYSTEM" + " \"translationbundle.dtd\">\n" + "<translationbundle lang=\"zh-HK\">\n" + "<translation id=\"7639678437384034548\">descargar</translation>\n" + "<translation id=\"2398375912250604550\">Se han\nignorado" + " <ph name=\"NUM\"/> conversaciones.</translation>\n" + "<translation id=\"6323937743550839320\"><ph name=\"P_START\"/>Si," + " puede <ph name=\"LINK_START_1_3\"/>hacer" + " clic<ph name=\"LINK_END_1_3\"/>" + " para utilizar.<ph name=\"P_END\"/><ph name=\"P_START\"/>Esperamos" + " poder ampliar.<ph name=\"P_END\"/></translation>\n" + "<translation id=\"3945720239421293834\"></translation>\n" + "</translationbundle>"; public void test() { InputStream stream = new ByteArrayInputStream(XTB.getBytes(UTF_8)); XtbMessageBundle bundle = new XtbMessageBundle( stream, PROJECT_ID); JsMessage message = bundle.getMessage("7639678437384034548"); assertEquals("descargar", message.toString()); message = bundle.getMessage("2398375912250604550"); assertEquals("Se han\nignorado {$num} conversaciones.", message.toString()); message = bundle.getMessage("6323937743550839320"); assertEquals("{$pStart}Si, puede {$linkStart_1_3}hacer " + "clic{$linkEnd_1_3} para utilizar.{$pEnd}{$pStart}Esperamos " + "poder ampliar.{$pEnd}", message.toString()); message = bundle.getMessage("3945720239421293834"); assertEquals("", message.toString()); assertFalse(message.parts().isEmpty()); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp.deps; import com.google.common.collect.ImmutableList; import com.google.javascript.jscomp.deps.DependencyInfo; import com.google.javascript.jscomp.deps.DepsFileParser; import com.google.javascript.jscomp.ErrorManager; import com.google.javascript.jscomp.PrintStreamErrorManager; import junit.framework.TestCase; import java.util.Collections; import java.util.List; /** * Tests for {@link DepsFileParser}. * * @author agrieve@google.com (Andrew Grieve) */ public class DepsFileParserTest extends TestCase { private DepsFileParser parser; private ErrorManager errorManager; private static final String SRC_PATH = "/path/1.js"; private final List<String> EMPTY = Collections.emptyList(); @Override public void setUp() { errorManager = new PrintStreamErrorManager(System.err); parser = new DepsFileParser(errorManager); parser.setShortcutMode(true); } /** * Tests: * -Parsing of comments, * -Parsing of different styles of quotes, * -Parsing of empty arrays, * -Parsing of non-empty arrays, * -Correct recording of what was parsed. */ public void testGoodParse() { final String CONTENTS = "/*" + "goog.addDependency('no1', [], []);*//*\n" + "goog.addDependency('no2', [ ], [ ]);\n" + "*/goog.addDependency('yes1', [], []);\n" + "/* blah */goog.addDependency(\"yes2\", [], [])/* blah*/\n" + "goog.addDependency('yes3', ['a','b'], ['c']); // goog.addDependency('no3', [], []);\n" + "// goog.addDependency('no4', [], []);\n" + "goog.addDependency(\"yes4\", [], [ \"a\",'b' , 'c' ]); //no new line at EOF"; List<DependencyInfo> result = parser.parseFile(SRC_PATH, CONTENTS); ImmutableList<DependencyInfo> EXPECTED = ImmutableList.<DependencyInfo>of( new SimpleDependencyInfo("yes1", SRC_PATH, EMPTY, EMPTY), new SimpleDependencyInfo("yes2", SRC_PATH, EMPTY, EMPTY), new SimpleDependencyInfo( "yes3", SRC_PATH, ImmutableList.of("a", "b"), ImmutableList.of("c")), new SimpleDependencyInfo( "yes4", SRC_PATH, EMPTY, ImmutableList.of("a", "b", "c")) ); assertEquals(EXPECTED, result); assertEquals(0, errorManager.getErrorCount()); assertEquals(0, errorManager.getWarningCount()); } public void testTooFewArgs() { parser.parseFile(SRC_PATH, "goog.addDependency('a', []);"); assertEquals(1, errorManager.getErrorCount()); assertEquals(0, errorManager.getWarningCount()); } public void testTooManyArgs() { parser.parseFile(SRC_PATH, "goog.addDependency('a', [], [], []);"); assertEquals(1, errorManager.getErrorCount()); assertEquals(0, errorManager.getWarningCount()); } public void testShortcutMode() { List<DependencyInfo> result = parser.parseFile(SRC_PATH, "goog.addDependency('yes1', [], []); \n" + "foo();\n" + "goog.addDependency('no1', [], []);"); ImmutableList<DependencyInfo> EXPECTED = ImmutableList.<DependencyInfo>of( new SimpleDependencyInfo("yes1", SRC_PATH, EMPTY, EMPTY)); assertEquals(EXPECTED, result); } public void testNoShortcutMode() { parser.setShortcutMode(false); List<DependencyInfo> result = parser.parseFile(SRC_PATH, "goog.addDependency('yes1', [], []); \n" + "foo();\n" + "goog.addDependency('yes2', [], []);"); ImmutableList<DependencyInfo> EXPECTED = ImmutableList.<DependencyInfo>of( new SimpleDependencyInfo("yes1", SRC_PATH, EMPTY, EMPTY), new SimpleDependencyInfo("yes2", SRC_PATH, EMPTY, EMPTY)); assertEquals(EXPECTED, result); } }
/* * Copyright 2010 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp.deps; import com.google.javascript.jscomp.ErrorManager; import com.google.javascript.jscomp.PrintStreamErrorManager; import junit.framework.TestCase; import java.io.StringReader; /** * Tests for {@link JsFileLineParser}. * * @author nicksantos@google.com (Nick Santos) */ public class JsFileLineParserTest extends TestCase { TestParser parser; private ErrorManager errorManager; @Override public void setUp() { errorManager = new PrintStreamErrorManager(System.err); parser = new TestParser(errorManager); } public void testSingleLine1() { assertStrip("2", "// 1\n2"); } public void testSingleLine2() { assertStrip("2 ", "// 1\n2 // 3 // 4 \n"); } public void testMultiLine1() { assertStrip("1", "/* hi */\n1"); } public void testMultiLine2() { assertStrip("123", "1/* hi */2\n3"); } public void testMultiLine3() { assertStrip("14", "1/* hi 2\n3*/4"); } public void testMultiLine4() { assertStrip("15", "1/* hi x\ny\nz*/5"); } public void testMultiLine5() { assertStrip("1234", "1/* hi */2/**/3/*\n/** bye */4"); } public void testMultiLine6() { assertStrip("12", "1/*** hi *** 3 **/2"); } public void testMixedLine1() { assertStrip("14", "1// /** 2 **/ 3\n4"); } public void testMixedLine2() { assertStrip("1 34", "1/** // 2 **/ 3\n4"); } private void assertStrip(String expected, String input) { parser.doParse("file", new StringReader(input)); assertEquals(expected, parser.toString()); } private static class TestParser extends JsFileLineParser { StringBuilder sb = new StringBuilder(); TestParser(ErrorManager errorManager) { super(errorManager); } @Override boolean parseLine(String line) { sb.append(line); return true; } @Override public String toString() { return sb.toString(); } } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp.deps; import com.google.common.collect.ImmutableList; import com.google.javascript.jscomp.ErrorManager; import com.google.javascript.jscomp.PrintStreamErrorManager; import junit.framework.TestCase; import java.util.Collections; /** * Tests for {@link JsFileParser}. * * @author agrieve@google.com (Andrew Grieve) */ public class JsFileParserTest extends TestCase { JsFileParser parser; private ErrorManager errorManager; private static final String SRC_PATH = "a"; private static final String CLOSURE_PATH = "b"; @Override public void setUp() { errorManager = new PrintStreamErrorManager(System.err); parser = new JsFileParser(errorManager); parser.setShortcutMode(true); } /** * Tests: * -Parsing of comments, * -Parsing of different styles of quotes, * -Correct recording of what was parsed. */ public void testParseFile() { String contents = "/*" + "goog.provide('no1');*//*\n" + "goog.provide('no2');\n" + "*/goog.provide('yes1');\n" + "/* blah */goog.provide(\"yes2\")/* blah*/\n" + "goog.require('yes3'); // goog.provide('no3');\n" + "// goog.provide('no4');\n" + "goog.require(\"bar.data.SuperstarAddStarThreadActionRequestDelegate\"); " + "//no new line at EOF"; DependencyInfo expected = new SimpleDependencyInfo(CLOSURE_PATH, SRC_PATH, ImmutableList.of("yes1", "yes2"), ImmutableList.of("yes3", "bar.data.SuperstarAddStarThreadActionRequestDelegate")); DependencyInfo result = parser.parseFile(SRC_PATH, CLOSURE_PATH, contents); assertDeps(expected, result); } public void testMultiplePerLine() { String contents = "goog.provide('yes1');goog.provide('yes2');/*" + "goog.provide('no1');*/goog.provide('yes3');//goog.provide('no2');"; DependencyInfo expected = new SimpleDependencyInfo(CLOSURE_PATH, SRC_PATH, ImmutableList.of("yes1", "yes2", "yes3"), Collections.<String>emptyList()); DependencyInfo result = parser.parseFile(SRC_PATH, CLOSURE_PATH, contents); assertDeps(expected, result); } public void testShortcutMode1() { // For efficiency reasons, we stop reading after the ctor. String contents = " // hi ! \n /* this is a comment */ " + "goog.provide('yes1');\n /* and another comment */ \n" + "goog.provide('yes2'); // include this\n" + "function foo() {}\n" + "goog.provide('no1');"; DependencyInfo expected = new SimpleDependencyInfo(CLOSURE_PATH, SRC_PATH, ImmutableList.of("yes1", "yes2"), Collections.<String>emptyList()); DependencyInfo result = parser.parseFile(SRC_PATH, CLOSURE_PATH, contents); assertDeps(expected, result); } public void testShortcutMode2() { String contents = "/** goog.provide('no1'); \n" + " * goog.provide('no2');\n */\n" + "goog.provide('yes1');\n"; DependencyInfo expected = new SimpleDependencyInfo(CLOSURE_PATH, SRC_PATH, ImmutableList.of("yes1"), Collections.<String>emptyList()); DependencyInfo result = parser.parseFile(SRC_PATH, CLOSURE_PATH, contents); assertDeps(expected, result); } public void testShortcutMode3() { String contents = "/**\n" + " * goog.provide('no1');\n */\n" + "goog.provide('yes1');\n"; DependencyInfo expected = new SimpleDependencyInfo(CLOSURE_PATH, SRC_PATH, ImmutableList.of("yes1"), Collections.<String>emptyList()); DependencyInfo result = parser.parseFile(SRC_PATH, CLOSURE_PATH, contents); assertDeps(expected, result); } public void testIncludeGoog1() { String contents = "/**\n" + " * the first constant in base.js\n" + " */\n" + "var COMPILED = false;\n"; DependencyInfo expected = new SimpleDependencyInfo(CLOSURE_PATH, SRC_PATH, ImmutableList.of("goog"), Collections.<String>emptyList()); DependencyInfo result = parser.setIncludeGoogBase(true).parseFile( SRC_PATH, CLOSURE_PATH, contents); assertDeps(expected, result); } public void testIncludeGoog2() { String contents = "goog.require('bar');"; DependencyInfo expected = new SimpleDependencyInfo(CLOSURE_PATH, SRC_PATH, ImmutableList.<String>of(), ImmutableList.of("goog", "bar")); DependencyInfo result = parser.setIncludeGoogBase(true).parseFile( SRC_PATH, CLOSURE_PATH, contents); assertDeps(expected, result); } public void testIncludeGoog3() { // This guy is pretending to provide goog, but he really doesn't. String contents = "goog.provide('x');\n" + "/**\n" + " * the first constant in base.js\n" + " */\n" + "var COMPILED = false;\n"; DependencyInfo expected = new SimpleDependencyInfo(CLOSURE_PATH, SRC_PATH, ImmutableList.of("x"), ImmutableList.of("goog")); DependencyInfo result = parser.setIncludeGoogBase(true).parseFile( SRC_PATH, CLOSURE_PATH, contents); assertDeps(expected, result); } public void testIncludeGoog4() { String contents = "goog.addDependency('foo', [], []);\n"; DependencyInfo expected = new SimpleDependencyInfo(CLOSURE_PATH, SRC_PATH, ImmutableList.<String>of(), ImmutableList.of("goog")); DependencyInfo result = parser.setIncludeGoogBase(true).parseFile( SRC_PATH, CLOSURE_PATH, contents); assertDeps(expected, result); } /** Asserts the deps match without errors */ private void assertDeps(DependencyInfo expected, DependencyInfo actual) { assertEquals(expected, actual); assertEquals(0, errorManager.getErrorCount()); assertEquals(0, errorManager.getWarningCount()); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp.deps; import com.google.common.collect.Lists; import com.google.javascript.jscomp.ErrorManager; import com.google.javascript.jscomp.PrintStreamErrorManager; import com.google.javascript.jscomp.deps.JsFunctionParser.SymbolInfo; import junit.framework.TestCase; import java.util.Collection; import java.util.Iterator; /** * Tests for {@link JsFunctionParser} * * @author agrieve@google.com (Andrew Grieve) * @author ielashi@google.com (Islam El-Ashi) */ public class JsFunctionParserTest extends TestCase { private static final String SRC_PATH = "a"; private JsFunctionParser parser; private ErrorManager errorManager; private Collection<String> functions = Lists.newArrayList( "goog.require", "goog.provide"); @Override public void setUp() { errorManager = new PrintStreamErrorManager(System.err); parser = new JsFunctionParser(functions, errorManager); parser.setShortcutMode(true); } /** * Tests: * -Parsing of comments, * -Parsing of different styles of quotes, * -Correct recording of what was parsed. */ public void testParseFile() { final String CONTENTS = "/*" + "goog.provide('no1');*//*\n" + "goog.provide('no2');\n" + "*/goog.provide('yes1');\n" + "/* blah */goog.provide(\"yes2\")/* blah*/\n" + "goog.require('yes3'); // goog.provide('no3');\n" + "// goog.provide('no4');\n" + "goog.require(\"" + "bar.data.SuperstarAddStarThreadActionRequestDelegate\"); " + "//no new line at EOF"; Collection<SymbolInfo> symbols = parser.parseFile(SRC_PATH, CONTENTS); Iterator<SymbolInfo> i = symbols.iterator(); SymbolInfo symbolInfo = i.next(); assertEquals(symbolInfo.symbol, "yes1"); assertEquals(symbolInfo.functionName, "goog.provide"); symbolInfo = i.next(); assertEquals(symbolInfo.symbol, "yes2"); assertEquals(symbolInfo.functionName, "goog.provide"); symbolInfo = i.next(); assertEquals(symbolInfo.symbol, "yes3"); assertEquals(symbolInfo.functionName, "goog.require"); symbolInfo = i.next(); assertEquals(symbolInfo.symbol, "bar.data.SuperstarAddStarThreadActionRequestDelegate"); assertEquals(symbolInfo.functionName, "goog.require"); assertEquals(symbols.size(), 4); assertEquals(0, errorManager.getErrorCount()); assertEquals(0, errorManager.getWarningCount()); } public void testMultiplePerLine() { final String CONTENTS = "goog.provide('yes1');goog.provide('yes2');/*" + "goog.provide('no1');*/goog.provide('yes3');//goog.provide('no2');"; Collection<SymbolInfo> symbols = parser.parseFile(SRC_PATH, CONTENTS); Iterator<SymbolInfo> i = symbols.iterator(); SymbolInfo symbolInfo = i.next(); assertEquals(symbolInfo.symbol, "yes1"); assertEquals(symbolInfo.functionName, "goog.provide"); symbolInfo = i.next(); assertEquals(symbolInfo.symbol, "yes2"); assertEquals(symbolInfo.functionName, "goog.provide"); symbolInfo = i.next(); assertEquals(symbolInfo.symbol, "yes3"); assertEquals(symbolInfo.functionName, "goog.provide"); assertEquals(symbols.size(), 3); assertEquals(0, errorManager.getErrorCount()); assertEquals(0, errorManager.getWarningCount()); } public void testShortcutMode1() { // For efficiency reasons, we stop reading after the ctor. final String CONTENTS = " // hi ! \n /* this is a comment */ " + "goog.provide('yes1');\n /* and another comment */ \n" + "goog.provide('yes2'); // include this\n" + "function foo() {}\n" + "goog.provide('no1');"; Collection<SymbolInfo> symbols = parser.parseFile(SRC_PATH, CONTENTS); Iterator<SymbolInfo> i = symbols.iterator(); SymbolInfo symbolInfo = i.next(); assertEquals(symbolInfo.symbol, "yes1"); assertEquals(symbolInfo.functionName, "goog.provide"); symbolInfo = i.next(); assertEquals(symbolInfo.symbol, "yes2"); assertEquals(symbolInfo.functionName, "goog.provide"); assertEquals(symbols.size(), 2); assertEquals(0, errorManager.getErrorCount()); assertEquals(0, errorManager.getWarningCount()); } public void testShortcutMode2() { final String CONTENTS = "/** goog.provide('no1'); \n" + " * goog.provide('no2');\n */\n" + "goog.provide('yes1');\n"; Collection<SymbolInfo> symbols = parser.parseFile(SRC_PATH, CONTENTS); Iterator<SymbolInfo> i = symbols.iterator(); SymbolInfo symbolInfo = i.next(); assertEquals(symbolInfo.symbol, "yes1"); assertEquals(symbolInfo.functionName, "goog.provide"); assertEquals(symbols.size(), 1); assertEquals(0, errorManager.getErrorCount()); assertEquals(0, errorManager.getWarningCount()); } public void testShortcutMode3() { final String CONTENTS = "/**\n" + " * goog.provide('no1');\n */\n" + "goog.provide('yes1');\n"; Collection<SymbolInfo> symbols = parser.parseFile(SRC_PATH, CONTENTS); Iterator<SymbolInfo> i = symbols.iterator(); SymbolInfo symbolInfo = i.next(); assertEquals(symbolInfo.symbol, "yes1"); assertEquals(symbolInfo.functionName, "goog.provide"); assertEquals(0, errorManager.getErrorCount()); assertEquals(0, errorManager.getWarningCount()); } }
/* * Copyright 2010 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp.deps; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.javascript.jscomp.deps.SortedDependencies.CircularDependencyException; import junit.framework.TestCase; import java.util.List; /** * Tests for {@link SortedDependencies} * @author nicksantos@google.com (Nick Santos) */ public class SortedDependenciesTest extends TestCase { public void testSort() throws Exception { SimpleDependencyInfo a = new SimpleDependencyInfo( "a", "a", provides(), requires("b", "c")); SimpleDependencyInfo b = new SimpleDependencyInfo( "b", "b", provides("b"), requires("d")); SimpleDependencyInfo c = new SimpleDependencyInfo( "c", "c", provides("c"), requires("d")); SimpleDependencyInfo d = new SimpleDependencyInfo( "d", "d", provides("d"), requires()); SimpleDependencyInfo e = new SimpleDependencyInfo( "e", "e", provides("e"), requires()); SimpleDependencyInfo f = new SimpleDependencyInfo( "f", "f", provides("f"), requires()); assertSortedInputs( ImmutableList.of(d, b, c, a), ImmutableList.of(a, b, c, d)); assertSortedInputs( ImmutableList.of(d, b, c, a), ImmutableList.of(d, b, c, a)); assertSortedInputs( ImmutableList.of(d, c, b, a), ImmutableList.of(d, c, b, a)); assertSortedInputs( ImmutableList.of(d, b, c, a), ImmutableList.of(d, a, b, c)); assertSortedDeps( ImmutableList.of(d, b, c, a), ImmutableList.of(d, b, c, a), ImmutableList.of(a)); assertSortedDeps( ImmutableList.of(d, c), ImmutableList.of(d, c, b, a), ImmutableList.of(c)); assertSortedDeps( ImmutableList.of(d), ImmutableList.of(d, c, b, a), ImmutableList.of(d)); try { assertSortedDeps( ImmutableList.<SimpleDependencyInfo>of(), ImmutableList.of(a, b, c, d), ImmutableList.of(e)); fail("Expected an exception"); } catch (IllegalArgumentException expected) {} } public void testSort2() throws Exception { SimpleDependencyInfo ab = new SimpleDependencyInfo( "ab", "ab", provides("a", "b"), requires("d", "f")); SimpleDependencyInfo c = new SimpleDependencyInfo( "c", "c", provides("c"), requires("h")); SimpleDependencyInfo d = new SimpleDependencyInfo( "d", "d", provides("d"), requires("e", "f")); SimpleDependencyInfo ef = new SimpleDependencyInfo( "ef", "ef", provides("e", "f"), requires("g", "c")); SimpleDependencyInfo g = new SimpleDependencyInfo( "g", "g", provides("g"), requires()); SimpleDependencyInfo hi = new SimpleDependencyInfo( "hi", "hi", provides("h", "i"), requires()); assertSortedInputs( ImmutableList.of(g, hi, c, ef, d, ab), ImmutableList.of(ab, c, d, ef, g, hi)); assertSortedDeps( ImmutableList.of(g), ImmutableList.of(ab, c, d, ef, g, hi), ImmutableList.of(g)); assertSortedDeps( ImmutableList.of(g, hi, c, ef, d), ImmutableList.of(ab, c, d, ef, g, hi), ImmutableList.of(d, hi)); } public void testSort3() { SimpleDependencyInfo a = new SimpleDependencyInfo( "a", "a", provides("a"), requires("c")); SimpleDependencyInfo b = new SimpleDependencyInfo( "b", "b", provides("b"), requires("a")); SimpleDependencyInfo c = new SimpleDependencyInfo( "c", "c", provides("c"), requires("b")); try { new SortedDependencies<SimpleDependencyInfo>( Lists.newArrayList(a, b, c)); fail("expected exception"); } catch (CircularDependencyException e) { assertEquals("a -> a", e.getMessage()); } } public void testSort4() throws Exception { // Check the degenerate case. SimpleDependencyInfo a = new SimpleDependencyInfo( "a", "a", provides("a"), requires("a")); assertSortedDeps( ImmutableList.of(a), ImmutableList.of(a), ImmutableList.of(a)); } public void testSort5() throws Exception { SimpleDependencyInfo a = new SimpleDependencyInfo( "a", "a", provides("a"), requires()); SimpleDependencyInfo b = new SimpleDependencyInfo( "b", "b", provides("b"), requires()); SimpleDependencyInfo c = new SimpleDependencyInfo( "c", "c", provides("c"), requires()); assertSortedInputs( ImmutableList.of(a, b, c), ImmutableList.of(a, b, c)); assertSortedInputs( ImmutableList.of(c, b, a), ImmutableList.of(c, b, a)); } private void assertSortedInputs( List<SimpleDependencyInfo> expected, List<SimpleDependencyInfo> shuffled) throws Exception { SortedDependencies<SimpleDependencyInfo> sorted = new SortedDependencies<SimpleDependencyInfo>(shuffled); assertEquals(expected, sorted.getSortedList()); } private void assertSortedDeps( List<SimpleDependencyInfo> expected, List<SimpleDependencyInfo> shuffled, List<SimpleDependencyInfo> roots) throws Exception { SortedDependencies<SimpleDependencyInfo> sorted = new SortedDependencies<SimpleDependencyInfo>(shuffled); assertEquals(expected, sorted.getSortedDependenciesOf(roots)); } private List<String> requires(String ... strings) { return Lists.newArrayList(strings); } private List<String> provides(String ... strings) { return Lists.newArrayList(strings); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp.graph; import com.google.javascript.jscomp.graph.Graph; import com.google.javascript.jscomp.graph.GraphColoring; import com.google.javascript.jscomp.graph.LinkedUndirectedGraph; import com.google.javascript.jscomp.graph.GraphNode; import com.google.javascript.jscomp.graph.Graph.GraphEdge; import com.google.javascript.jscomp.graph.GraphColoring.Color; import com.google.javascript.jscomp.graph.GraphColoring.GreedyGraphColoring; import junit.framework.TestCase; import java.util.Comparator; /** * Tests for {@link GraphColoring}. * */ public class GraphColoringTest extends TestCase { public void testNoEdge() { Graph<String, String> graph = LinkedUndirectedGraph.create(); for (int i = 0; i < 5; i++) { graph.createNode("Node " + i); // All node with same color. GraphColoring<String, String> coloring = new GreedyGraphColoring<String, String>(graph); assertEquals(1, coloring.color()); validateColoring(graph); for (int j = 0; j < i; j++) { assertEquals("Node 0", coloring.getPartitionSuperNode("Node 0")); } } } public void testTwoNodesConnected() { Graph<String, String> graph = LinkedUndirectedGraph.create(); graph.createNode("A"); graph.createNode("B"); graph.connect("A", "--", "B"); GraphColoring<String, String> coloring = new GreedyGraphColoring<String, String>(graph); assertEquals(2, coloring.color()); validateColoring(graph); assertEquals("A", coloring.getPartitionSuperNode("A")); assertEquals("B", coloring.getPartitionSuperNode("B")); } public void testGreedy() { Graph<String, String> graph = LinkedUndirectedGraph.create(); graph.createNode("A"); graph.createNode("B"); graph.createNode("C"); graph.createNode("D"); graph.connect("A", "--", "C"); graph.connect("B", "--", "C"); graph.connect("B", "--", "D"); GraphColoring<String, String> coloring = new GreedyGraphColoring<String, String>(graph); assertEquals(2, coloring.color()); validateColoring(graph); assertEquals("A", coloring.getPartitionSuperNode("A")); assertEquals("A", coloring.getPartitionSuperNode("B")); assertEquals("C", coloring.getPartitionSuperNode("C")); } public void testFullyConnected() { final int count = 100; Graph<String, String> graph = LinkedUndirectedGraph.create(); for (int i = 0; i < count; i++) { graph.createNode("Node " + i); for (int j = 0; j < count; j++) { graph.createNode("Node " + j); if (i != j) { graph.connect("Node " + i, null, "Node " + j); } } } GraphColoring<String, String> coloring = new GreedyGraphColoring<String, String>(graph); assertEquals(count, coloring.color()); validateColoring(graph); for (int i = 0; i < count; i++) { assertEquals("Node " + i, coloring.getPartitionSuperNode("Node " + i)); } } public void testAllConnectedToOneNode() { final int count = 10; Graph<String, String> graph = LinkedUndirectedGraph.create(); graph.createNode("Center"); for (int i = 0; i < count; i++) { graph.createNode("Node " + i); graph.connect("Center", null, "Node " + i); } GraphColoring<String, String> coloring = new GreedyGraphColoring<String, String>(graph); assertEquals(2, coloring.color()); validateColoring(graph); assertEquals("Center", coloring.getPartitionSuperNode("Center")); for (int i = 0; i < count; i++) { assertEquals("Node 0", coloring.getPartitionSuperNode("Node " + i)); } } public void testTwoFullyConnected() { final int count = 100; // A graph with two disconnected disjunct cliques. Graph<String, String> graph = LinkedUndirectedGraph.create(); for (int i = 0; i < count; i++) { graph.createNode("Node Left " + i); graph.createNode("Node Right " + i); for (int j = 0; j < count; j++) { graph.createNode("Node Left " + j); graph.createNode("Node Right " + j); if (i != j) { graph.connect("Node Left " + i, null, "Node Left " + j); graph.connect("Node Right " + i, null, "Node Right " + j); } } } assertEquals(count, new GreedyGraphColoring<String, String>(graph).color()); validateColoring(graph); // Connect the two cliques. for (int i = 0; i < count; i++) { graph.connect("Node Left " + i, null, "Node Right " + i); } // Think of two exactly same graph with the same coloring side by side. // If we circularly shift the colors of one of the graph by 1, we can // connect the isomorphic nodes and still have a valid coloring in the // resulting graph. assertEquals(count, new GreedyGraphColoring<String, String>(graph).color()); validateColoring(graph); } public void testDeterministic() { // A pentagon. Graph<String, String> graph = LinkedUndirectedGraph.create(); graph.createNode("A"); graph.createNode("B"); graph.createNode("C"); graph.createNode("D"); graph.createNode("E"); graph.connect("A", "-->", "B"); graph.connect("B", "-->", "C"); graph.connect("C", "-->", "D"); graph.connect("D", "-->", "E"); graph.connect("E", "-->", "A"); Comparator<String> lexicographic = new Comparator<String>() { @Override public int compare(String o1, String o2) { return o1.toString().compareTo(o2.toString()); } }; GraphColoring<String, String> coloring = new GreedyGraphColoring<String, String>(graph, lexicographic); assertEquals(3, coloring.color()); validateColoring(graph); assertEquals("A", coloring.getPartitionSuperNode("A")); assertEquals("A", coloring.getPartitionSuperNode("C")); Comparator<String> biasD = new Comparator<String>() { @Override public int compare(String o1, String o2) { return o1.replaceAll("D", "@").compareTo(o2.replaceAll("D", "@")); } }; coloring = new GreedyGraphColoring<String, String>(graph, biasD); assertEquals(3, coloring.color()); validateColoring(graph); assertEquals("A", coloring.getPartitionSuperNode("A")); assertFalse("A".equals(coloring.getPartitionSuperNode("C"))); } /** * Validate that each node has been colored and connected nodes have different * coloring. */ private static <N, E> void validateColoring(Graph<N, E> graph) { for (GraphNode<N, E> node : graph.getNodes()) { assertTrue(node.getAnnotation() != null); } for (GraphEdge<N, E> edge : graph.getEdges()) { Color c1 = edge.getNodeA().getAnnotation(); Color c2 = edge.getNodeB().getAnnotation(); assertTrue(c1 != null); assertTrue(c2 != null); assertTrue(!c1.equals(c2)); } } }
/* * Copyright 2011 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp.graph; import com.google.common.base.Predicates; import com.google.common.collect.Lists; import junit.framework.TestCase; /** * @author nicksantos@google.com (Nick Santos) */ public class GraphPrunerTest extends TestCase { public void testThreeNodesConnected() { DiGraph<String, String> graph = LinkedDirectedGraph.create(); graph.createNode("A"); graph.createNode("B"); graph.createNode("C"); graph.connect("A", "--", "B"); graph.connect("B", "--", "C"); DiGraph<String, String> pruned = new GraphPruner<String, String>(graph).prune( Predicates.in(Lists.newArrayList("A", "C"))); assertEquals(2, pruned.getNodes().size()); assertTrue(pruned.isConnectedInDirection("A", "C")); } public void testThreeNodesDisconnected() { DiGraph<String, String> graph = LinkedDirectedGraph.create(); graph.createNode("A"); graph.createNode("B"); graph.createNode("C"); graph.connect("A", "--", "B"); graph.connect("C", "--", "B"); DiGraph<String, String> pruned = new GraphPruner<String, String>(graph).prune( Predicates.in(Lists.newArrayList("A", "C"))); assertEquals(2, pruned.getNodes().size()); assertFalse(pruned.isConnectedInDirection("A", "C")); } public void testFourNodesConnected1() { DiGraph<String, String> graph = LinkedDirectedGraph.create(); graph.createNode("A"); graph.createNode("B"); graph.createNode("C"); graph.createNode("D"); graph.connect("A", "--", "C"); graph.connect("B", "--", "C"); graph.connect("C", "--", "D"); graph.connect("A", "--", "D"); DiGraph<String, String> pruned = new GraphPruner<String, String>(graph).prune( Predicates.not(Predicates.equalTo("C"))); assertEquals(3, pruned.getNodes().size()); assertTrue(pruned.isConnectedInDirection("A", "D")); assertTrue(pruned.isConnectedInDirection("B", "D")); assertFalse(pruned.isConnectedInDirection("A", "B")); } public void testFourNodesConnected2() { DiGraph<String, String> graph = LinkedDirectedGraph.create(); graph.createNode("A"); graph.createNode("B"); graph.createNode("C"); graph.createNode("D"); graph.connect("A", "--", "B"); graph.connect("B", "--", "C"); graph.connect("C", "--", "D"); DiGraph<String, String> pruned = new GraphPruner<String, String>(graph).prune( Predicates.not(Predicates.in(Lists.newArrayList("B", "C")))); assertEquals(2, pruned.getNodes().size()); assertTrue(pruned.isConnectedInDirection("A", "D")); } public void testFiveNodesConnected() { DiGraph<String, String> graph = LinkedDirectedGraph.create(); graph.createNode("A"); graph.createNode("B"); graph.createNode("C"); graph.createNode("D"); graph.createNode("E"); graph.connect("A", "--", "B"); graph.connect("B", "--", "C"); graph.connect("C", "--", "D"); graph.connect("D", "--", "E"); graph.connect("D", "--", "B"); DiGraph<String, String> pruned = new GraphPruner<String, String>(graph).prune( Predicates.not(Predicates.in(Lists.newArrayList("B", "C", "D")))); assertEquals(2, pruned.getNodes().size()); assertTrue(pruned.isConnectedInDirection("A", "E")); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp.graph; import com.google.javascript.jscomp.graph.GraphReachability; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.DiGraph; import junit.framework.TestCase; /** * Tests for {@link GraphReachability}. * */ public class GraphReachabilityTest extends TestCase { GraphReachability<String, String> reachability = null; DiGraph<String, String> graph = null; public void testSimple() { graph = LinkedDirectedGraph.create(); graph.createNode("A"); reachability = new GraphReachability<String, String>(graph); reachability.compute("A"); assertReachable("A"); graph.createNode("B"); reachability = new GraphReachability<String, String>(graph); reachability.compute("A"); assertReachable("A"); assertNotReachable("B"); graph.connect("A", "--->", "B"); reachability = new GraphReachability<String, String>(graph); reachability.compute("B"); assertNotReachable("A"); assertReachable("B"); graph.connect("B", "--->", "A"); reachability = new GraphReachability<String, String>(graph); reachability.compute("B"); assertReachable("A"); assertReachable("B"); graph.createNode("C"); reachability = new GraphReachability<String, String>(graph); reachability.compute("A"); assertReachable("A"); assertReachable("B"); assertNotReachable("C"); graph.createNode("D"); graph.connect("C", "--->", "D"); reachability = new GraphReachability<String, String>(graph); reachability.compute("A"); assertReachable("A"); assertReachable("B"); assertNotReachable("C"); assertNotReachable("D"); reachability.recompute("C"); assertReachable("C"); assertReachable("D"); } public void assertReachable(String s) { assertSame(s + " should be reachable", graph.getNode(s).getAnnotation(), GraphReachability.REACHABLE); } public void assertNotReachable(String s) { assertNotSame(s + " should not be reachable", graph.getNode(s).getAnnotation(), GraphReachability.REACHABLE); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp.graph; import com.google.javascript.jscomp.graph.Graph; import com.google.javascript.jscomp.graph.LinkedDirectedGraph; import com.google.javascript.jscomp.graph.LinkedUndirectedGraph; import com.google.javascript.jscomp.graph.Annotatable; import com.google.javascript.jscomp.graph.Annotation; import com.google.javascript.jscomp.graph.GraphNode; import com.google.javascript.jscomp.graph.SubGraph; import com.google.javascript.jscomp.graph.DiGraph; import com.google.javascript.jscomp.graph.Graph.GraphEdge; import com.google.javascript.jscomp.graph.UndiGraph; import junit.framework.TestCase; import java.util.HashSet; import java.util.List; import java.util.Set; /** * Tests for the graph data structure. * */ public class GraphTest extends TestCase { public void testDirectedSimple() { DiGraph<String, String> graph = LinkedDirectedGraph.create(); graph.createNode("a"); graph.createNode("b"); graph.createNode("c"); graph.connect("a", "->", "b"); assertTrue(graph.hasNode("a")); assertTrue(graph.hasNode("b")); assertTrue(graph.hasNode("c")); assertFalse(graph.hasNode("d")); assertTrue(graph.isConnected("a", "b")); assertTrue(graph.isConnected("b", "a")); assertFalse(graph.isConnected("a", "c")); assertFalse(graph.isConnected("b", "c")); assertFalse(graph.isConnected("c", "a")); assertFalse(graph.isConnected("c", "b")); assertFalse(graph.isConnected("a", "a")); assertFalse(graph.isConnected("b", "b")); assertFalse(graph.isConnected("b", "c")); assertTrue(graph.isConnectedInDirection("a", "b")); assertFalse(graph.isConnectedInDirection("b", "a")); assertFalse(graph.isConnectedInDirection("a", "c")); assertFalse(graph.isConnectedInDirection("b", "c")); assertFalse(graph.isConnectedInDirection("c", "a")); assertFalse(graph.isConnectedInDirection("c", "b")); // Removal. graph.disconnect("a", "b"); assertFalse(graph.isConnected("a", "b")); assertFalse(graph.isConnected("b", "a")); // Disconnect both ways. graph.connect("a", "->", "b"); graph.connect("b", "->", "a"); graph.disconnect("a", "b"); assertFalse(graph.isConnected("a", "b")); assertFalse(graph.isConnected("b", "a")); // Disconnect one way. graph.connect("a", "->", "b"); graph.connect("b", "->", "a"); graph.disconnectInDirection("a", "b"); assertTrue(graph.isConnected("b", "a")); assertTrue(graph.isConnected("a", "b")); assertFalse(graph.isConnectedInDirection("a", "b")); assertTrue(graph.isConnectedInDirection("b", "a")); } public void testUndirectedSimple() { UndiGraph<String, String> graph = LinkedUndirectedGraph.create(); graph.createNode("a"); graph.createNode("b"); graph.createNode("c"); graph.connect("a", "--", "b"); assertTrue(graph.hasNode("a")); assertTrue(graph.hasNode("b")); assertTrue(graph.hasNode("c")); assertFalse(graph.hasNode("d")); assertTrue(graph.isConnected("a", "b")); assertTrue(graph.isConnected("b", "a")); assertFalse(graph.isConnected("a", "c")); assertFalse(graph.isConnected("b", "c")); assertFalse(graph.isConnected("c", "a")); assertFalse(graph.isConnected("c", "b")); assertFalse(graph.isConnected("a", "a")); assertFalse(graph.isConnected("b", "b")); assertFalse(graph.isConnected("b", "c")); // Removal. graph.disconnect("a", "b"); assertFalse(graph.isConnected("a", "b")); assertFalse(graph.isConnected("b", "a")); } public void testDirectedSelfLoop() { DiGraph<String, String> graph = LinkedDirectedGraph.create(); graph.createNode("a"); graph.createNode("b"); graph.connect("a", "->", "a"); assertTrue(graph.isConnected("a", "a")); assertFalse(graph.isConnected("a", "b")); assertFalse(graph.isConnected("b", "a")); assertTrue(graph.isConnectedInDirection("a", "a")); assertFalse(graph.isConnectedInDirection("a", "b")); assertFalse(graph.isConnectedInDirection("b", "a")); // Removal. graph.disconnect("a", "a"); assertFalse(graph.isConnected("a", "a")); // Disconnect both ways. graph.connect("a", "->", "a"); graph.disconnect("a", "a"); assertFalse(graph.isConnected("a", "a")); assertFalse(graph.isConnected("a", "a")); // Disconnect one way. graph.connect("a", "->", "a"); graph.disconnectInDirection("a", "a"); assertFalse(graph.isConnected("a", "a")); } public void testUndirectedSelfLoop() { UndiGraph<String, String> graph = LinkedUndirectedGraph.create(); graph.createNode("a"); graph.createNode("b"); graph.connect("a", "--", "a"); assertTrue(graph.isConnected("a", "a")); assertFalse(graph.isConnected("a", "b")); assertFalse(graph.isConnected("b", "a")); // Removal. graph.disconnect("a", "a"); assertFalse(graph.isConnected("a", "a")); } public void testDirectedInAndOutEdges() { DiGraph<String, String> graph = LinkedDirectedGraph.create(); graph.createNode("a"); graph.createNode("b"); graph.createNode("c"); graph.createNode("d"); graph.connect("a", "->", "b"); graph.connect("a", "-->", "b"); graph.connect("a", "--->", "b"); graph.connect("a", "->", "c"); graph.connect("c", "->", "d"); assertSetEquals(graph.getDirectedSuccNodes("a"), "b", "c"); assertSetEquals(graph.getDirectedPredNodes("b"), "a"); assertSetEquals(graph.getDirectedPredNodes("c"), "a"); assertListCount(graph.getDirectedSuccNodes("a"), "b", 3); // Removal. graph.disconnect("a", "b"); assertFalse(graph.isConnected("a", "b")); } public void testUndirectedNeighbors() { UndiGraph<String, String> graph = LinkedUndirectedGraph.create(); graph.createNode("a"); graph.createNode("b"); graph.createNode("c"); graph.createNode("d"); graph.connect("a", "-", "b"); graph.connect("a", "--", "b"); graph.connect("a", "---", "b"); graph.connect("a", "-", "c"); graph.connect("c", "-", "d"); assertSetEquals(graph.getNeighborNodes("a"), "b", "c"); assertSetEquals(graph.getNeighborNodes("b"), "a"); assertSetEquals(graph.getNeighborNodes("c"), "a", "d"); assertListCount(graph.getNeighborNodes("a"), "b", 3); // Removal. graph.disconnect("a", "b"); assertFalse(graph.isConnected("a", "b")); } public void testDirectedGetFirstEdge() { DiGraph<String, String> graph = LinkedDirectedGraph.create(); graph.createNode("a"); graph.createNode("b"); graph.createNode("c"); graph.connect("a", "-", "b"); assertEquals(graph.getFirstEdge("a", "b").getValue(), "-"); assertEquals(graph.getFirstEdge("b", "a").getValue(), "-"); assertNull(graph.getFirstEdge("a", "c")); } public void testUndirectedGetFirstEdge() { UndiGraph<String, String> graph = LinkedUndirectedGraph.create(); graph.createNode("a"); graph.createNode("b"); graph.createNode("c"); graph.connect("a", "-", "b"); assertEquals(graph.getFirstEdge("a", "b").getValue(), "-"); assertEquals(graph.getFirstEdge("b", "a").getValue(), "-"); assertNull(graph.getFirstEdge("a", "c")); } public void testNodeAnnotations() { Graph<String, String> graph = LinkedUndirectedGraph.create(); GraphNode<String, String> a = graph.createNode("a"); GraphNode<String, String> b = graph.createNode("b"); checkAnnotations(graph, a, b); } public void testEdgeAnnotations() { Graph<String, String> graph = LinkedUndirectedGraph.create(); graph.createNode("1"); graph.createNode("2"); graph.createNode("3"); graph.connect("1", "a", "2"); graph.connect("2", "b", "3"); GraphEdge<String, String> a = graph.getEdges("1", "2").get(0); GraphEdge<String, String> b = graph.getEdges("2", "3").get(0); checkAnnotations(graph, a, b); } private static void checkAnnotations( Graph<String, String> graph, Annotatable a, Annotatable b) { final Annotation A = new Annotation() {}; final Annotation B = new Annotation() {}; // Initially null. assertNull(a.getAnnotation()); assertNull(b.getAnnotation()); // Test basic setting. a.setAnnotation(A); b.setAnnotation(B); assertSame(A, a.getAnnotation()); assertSame(B, b.getAnnotation()); // Test clearing. graph.clearEdgeAnnotations(); graph.clearNodeAnnotations(); assertNull(a.getAnnotation()); assertNull(b.getAnnotation()); a.setAnnotation(A); b.setAnnotation(B); // Pushing clears. graph.pushEdgeAnnotations(); graph.pushNodeAnnotations(); assertNull(a.getAnnotation()); assertNull(b.getAnnotation()); a.setAnnotation(B); b.setAnnotation(B); graph.pushEdgeAnnotations(); graph.pushNodeAnnotations(); a.setAnnotation(B); b.setAnnotation(A); // Test restoring then restoring old values with pop. assertSame(B, a.getAnnotation()); assertSame(A, b.getAnnotation()); graph.popEdgeAnnotations(); graph.popNodeAnnotations(); assertSame(B, a.getAnnotation()); assertSame(B, b.getAnnotation()); graph.popEdgeAnnotations(); graph.popNodeAnnotations(); assertSame(A, a.getAnnotation()); assertSame(B, b.getAnnotation()); } public void testDegree() { testDirectedDegree(LinkedDirectedGraph.<String, String>create()); testDirectedDegree(LinkedUndirectedGraph.<String, String>create()); } public void testDirectedDegree(Graph<String, String> graph) { graph.createNode("a"); graph.createNode("b"); graph.createNode("c"); graph.createNode("d"); assertEquals(0, graph.getNodeDegree("a")); graph.connect("a", "-", "b"); assertEquals(1, graph.getNodeDegree("a")); graph.connect("b", "-", "c"); assertEquals(1, graph.getNodeDegree("a")); graph.connect("a", "-", "c"); assertEquals(2, graph.getNodeDegree("a")); graph.connect("d", "-", "a"); assertEquals(3, graph.getNodeDegree("a")); } public void testDirectedConnectIfNotFound() { testDirectedConnectIfNotFound( LinkedDirectedGraph.<String, String>create()); testDirectedConnectIfNotFound( LinkedUndirectedGraph.<String, String>create()); } public void testDirectedConnectIfNotFound(Graph<String, String> graph) { graph.createNode("a"); graph.createNode("b"); graph.connectIfNotFound("a", "-", "b"); assertEquals(1, graph.getNodeDegree("a")); graph.connectIfNotFound("a", "-", "b"); assertEquals(1, graph.getNodeDegree("a")); graph.connectIfNotFound("a", null, "b"); assertEquals(2, graph.getNodeDegree("a")); graph.connectIfNotFound("a", null, "b"); assertEquals(2, graph.getNodeDegree("a")); } public void testSimpleSubGraph() { UndiGraph<String, String> graph = LinkedUndirectedGraph.create(); graph.createNode("a"); graph.createNode("b"); graph.createNode("c"); graph.connect("a", "--", "b"); SubGraph<String, String> subGraph = graph.newSubGraph(); subGraph.addNode("a"); subGraph.addNode("b"); try { subGraph.addNode("d"); fail("SubGraph should not allow add for node that is not in graph."); } catch (IllegalArgumentException e) { // exception expected } assertFalse(subGraph.isIndependentOf("a")); assertFalse(subGraph.isIndependentOf("b")); assertTrue(subGraph.isIndependentOf("c")); } private <T extends GraphNode<String, String>> void assertListCount( List<T> list, String target, int count) { for (GraphNode<String, String> node : list) { if (node.getValue().equals(target)) { count--; } } assertTrue(count == 0); } private <T extends GraphNode<String, String>> void assertSetEquals( List<T> list, String ... targets) { Set<String> set = new HashSet<String>(); for (GraphNode<String, String> node : list) { set.add(node.getValue()); } Set<String> otherSet = new HashSet<String>(); for (String target : targets) { otherSet.add(target); } assertTrue(otherSet.equals(set)); } }
/* * Copyright 2008 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp.graph; import com.google.common.collect.HashMultiset; import com.google.common.collect.ImmutableSet; import junit.framework.Assert; import junit.framework.TestCase; import java.util.Arrays; import java.util.Collection; import java.util.Iterator; import java.util.Set; /** * Unit test for the {@link StandardUnionFind} data structure. * */ public class StandardUnionFindTest extends TestCase { private StandardUnionFind<String> union; @Override protected void setUp() { union = new StandardUnionFind<String>(); } public void testEmpty() { assertEquals(0, union.allEquivalenceClasses().size()); } public void testAdd() { union.add("foo"); union.add("bar"); assertTrue(null != union.find("foo")); assertEquals(2, union.allEquivalenceClasses().size()); } public void testUnion() { union.union("A", "B"); union.union("C", "D"); assertEquals(union.find("A"), union.find("B")); assertEquals(union.find("C"), union.find("D")); assertFalse(union.find("A").equals(union.find("D"))); } public void testSetSize() { union.union("A", "B"); union.union("B", "C"); union.union("D", "E"); union.union("F", "F"); assertEquals(3, union.findAll("A").size()); assertEquals(3, union.findAll("B").size()); assertEquals(3, union.findAll("C").size()); assertEquals(2, union.findAll("D").size()); assertEquals(1, union.findAll("F").size()); } public void testFind() { union.add("A"); union.add("B"); assertEquals("A", union.find("A")); assertEquals("B", union.find("B")); union.union("A", "B"); assertEquals(union.find("A"), union.find("B")); try { union.find("Z"); fail("find() on unknown element should not be allowed."); } catch (IllegalArgumentException e) { } } public void testAllEquivalenceClasses() { union.union("A", "B"); union.union("A", "B"); union.union("B", "A"); union.union("B", "C"); union.union("D", "E"); union.union("F", "F"); Collection<Set<String>> classes = union.allEquivalenceClasses(); assertEquals(3, classes.size()); assertContentsAnyOrder(classes, ImmutableSet.of("A", "B", "C"), ImmutableSet.of("D", "E"), ImmutableSet.of("F")); } public void testFindAll() { union.union("A", "B"); union.union("A", "B"); union.union("B", "A"); union.union("D", "E"); union.union("F", "F"); Set<String> aSet = union.findAll("A"); assertEquals(2, aSet.size()); assertTrue(aSet.contains("A")); assertTrue(aSet.contains("B")); assertFalse(aSet.contains("C")); assertFalse(aSet.contains("D")); assertFalse(aSet.contains("E")); assertFalse(aSet.contains("F")); union.union("B", "C"); assertTrue(aSet.contains("C")); assertEquals(3, aSet.size()); try { union.findAll("Z"); fail("findAll() on unknown element should not be allowed."); } catch (IllegalArgumentException e) { } } public void testFindAllIterator() { union.union("A", "B"); union.union("B", "C"); union.union("A", "B"); union.union("D", "E"); Set<String> aSet = union.findAll("A"); Iterator<String> aIter = aSet.iterator(); assertTrue(aIter.hasNext()); assertEquals("A", aIter.next()); assertEquals("B", aIter.next()); assertEquals("C", aIter.next()); assertFalse(aIter.hasNext()); Set<String> dSet = union.findAll("D"); Iterator<String> dIter = dSet.iterator(); assertTrue(dIter.hasNext()); assertEquals("D", dIter.next()); assertEquals("E", dIter.next()); assertFalse(dIter.hasNext()); } public void testFindAllSize() { union.union("A", "B"); union.union("B", "C"); assertEquals(3, union.findAll("A").size()); assertEquals(3, union.findAll("B").size()); assertEquals(3, union.findAll("C").size()); union.union("D", "E"); assertEquals(3, union.findAll("C").size()); assertEquals(2, union.findAll("D").size()); union.union("B", "E"); assertEquals(5, union.findAll("C").size()); assertEquals(5, union.findAll("D").size()); } public void testElements(){ union.union("A", "B"); union.union("B", "C"); union.union("A", "B"); union.union("D", "E"); Set<String> elements = union.elements(); assertEquals(ImmutableSet.of("A", "B", "C", "D", "E"), elements); assertFalse(elements.contains("F")); } public void testCopy() { union.union("A", "B"); union.union("B", "Z"); union.union("X", "Y"); UnionFind<String> copy = new StandardUnionFind<String>(union); assertContentsAnyOrder(copy.findAll("Z"), "A", "B", "Z"); assertContentsAnyOrder(copy.findAll("X"), "X", "Y"); } public void testChangesToCopyDontAffectOriginal() { union.union("A", "B"); union.union("X", "Y"); union.union("A", "C"); UnionFind<String> copy = new StandardUnionFind<String>(union); copy.union("A", "D"); assertContentsAnyOrder(copy.findAll("D"), "A", "B", "C", "D"); assertContentsAnyOrder(union.findAll("A"), "A", "B", "C"); assertContentsAnyOrder(copy.findAll("X"), "X", "Y"); try { union.findAll("D"); fail("D has been inserted to the original collection"); } catch (IllegalArgumentException e) { // Expected. } } public void testCheckEquivalent() { union.union("A", "B"); union.add("C"); assertTrue(union.areEquivalent("A", "B")); assertFalse(union.areEquivalent("C", "A")); assertFalse(union.areEquivalent("C", "B")); try { union.areEquivalent("A", "F"); } catch (IllegalArgumentException e) { // Expected. } } /** * Asserts that {@code actual} contains precisely the elements * {@code expected}, in any order. Both collections may contain * duplicates, and this method will only pass if the quantities are * exactly the same. */ private static void assertContentsAnyOrder( String message, Iterable<?> actual, Object... expected) { Assert.assertEquals(message, HashMultiset.create(Arrays.asList(expected)), HashMultiset.create(actual)); } /** * Variant of {@link #assertContentsAnyOrder(String,Iterable,Object...)} * using a generic message. */ private static void assertContentsAnyOrder( Iterable<?> actual, Object... expected) { assertContentsAnyOrder((String) null, actual, expected); } }
/* * Copyright 2010 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp.jsonml; import com.google.common.base.Preconditions; import com.google.javascript.jscomp.Compiler; import com.google.javascript.jscomp.CompilerPass; import com.google.javascript.jscomp.CompilerTestCase; import com.google.javascript.rhino.Token; import com.google.javascript.jscomp.jsonml.Writer; import com.google.javascript.jscomp.jsonml.JsonML; import com.google.javascript.jscomp.jsonml.JsonMLAst; import com.google.javascript.jscomp.jsonml.JsonMLUtil; import com.google.javascript.rhino.Node; import com.google.caja.parser.js.JsonMLParser; /** * Tests for parsing JsonML to AST and vice versa. * @author dhans@google.com (Daniel Hans) * */ public class JsonMLConversionTest extends CompilerTestCase { @Override public CompilerPass getProcessor(Compiler compiler) { return null; // unused } @Override public void setUp() { enableEcmaScript5(true); } private void testJsonMLToAstConversion(String js) throws Exception { JsonML jsonml = JsonMLParser.parse(js); Node root = parseExpectedJs(js); Node ast = root.getFirstChild(); Preconditions.checkState(ast.getType() == Token.SCRIPT); testJsonMLToAstConversion(ast, jsonml, js); } private void testJsonMLToAstConversion(Node astRoot, JsonML jsonmlRoot, String js) { Compiler compiler = new Compiler(); JsonMLAst ast = new JsonMLAst(jsonmlRoot); Node resultAstRoot = ast.getAstRoot(compiler); String explanation = resultAstRoot.checkTreeEquals(astRoot); assertNull("JsonML -> AST converter returned incorect result for " + js + "\n" + explanation, explanation); } private void testAstToJsonMLConverstion(Node astRoot, JsonML jsonmlRoot, String js) { JsonML resultJsonMLRoot = (new Writer()).processAst(astRoot); String explanation = JsonMLUtil.compare(resultJsonMLRoot, jsonmlRoot); assertNull("AST -> JsonML converter returned incorrect result for " + js + "\n" + explanation, explanation); } private void testConversion(String js) throws Exception { JsonML jsonml = JsonMLParser.parse(js); Node root = parseExpectedJs(js); Node ast = root.getFirstChild(); Preconditions.checkState(ast.getType() == Token.SCRIPT); testJsonMLToAstConversion(ast, jsonml, js); jsonml = JsonMLParser.parse(js); testAstToJsonMLConverstion(ast, jsonml, js); } public void testArray() throws Exception { testConversion("[,]"); testConversion("[]"); testConversion("[function (x) {}]"); testConversion("[[], [a, [], [[[]], 1], f([a])], 1];"); testConversion("x = [1, 2, 3]"); testConversion("var x = [1, 2, 3]"); testConversion("[, 1, Object(), , , 2]"); testConversion("[{x: 'abc', y: 1}]"); } public void testArray1() throws Exception { testConversion("[,]"); } public void testAssignOperators() throws Exception { testConversion("x += 1, x -= 1, x *= 1, x /= 1, x %= 1"); testConversion("x |= 1, x ^= x, x &= 0"); testConversion("x <<= 1, x >>= 1, x >>>= 1"); testConversion("y = x += 1"); } public void testCalls() throws Exception { testConversion("f()"); testConversion("f(1)"); testConversion("f('a')"); testConversion("f(true)"); testConversion("f(null)"); testConversion("f(undefined)"); testConversion("f(a + b)"); testConversion("f(g(h(a)) * h(g(u(z('a')))))"); testConversion("x = f()"); testConversion("x = f(1)"); testConversion("x = f(a + b)"); testConversion("x = f(g(h(a)) * h(g(u(z('a')))))"); testConversion("String('a')"); testConversion("Number(1)"); testConversion("Boolean(0)"); testConversion("Object()"); testConversion("Array('a', 1, false, null, Object(), String('a'))"); testConversion("(function() {})()"); testConversion("(function(x) {})(x)"); testConversion("(function(x) {var y = x << 1; return y})(x)"); testConversion("(function(x) {y = x << 1; return y})(x)"); testConversion("var x = (function(x) {y = x << 1; return y})(x)"); testConversion("var x = (function(x) {return x << 1})(x)"); testConversion("eval()"); testConversion("eval('x')"); testConversion("x = eval('x')"); testConversion("var x = eval('x')"); testConversion("eval(Template('foo${bar}baz')); var Template;"); testConversion("a.x()"); testConversion("a[x]()"); testConversion("z = a.x()"); testConversion("var z = a.x()"); testConversion("z = a[x]()"); testConversion("z = a['x']()"); testConversion("var z = a[x]()"); testConversion("var z = a['x']()"); testConversion("a.x(y)"); testConversion("a[x](y)"); testConversion("a['x'](y)"); testConversion("a[x](y, z, 'a', null, true, f(y))"); testConversion("a['x'](y, z, 'a', null, true, f(y))"); testConversion("a[b[c[d]]()].x"); testConversion("(f())()"); testConversion("(f(x))(y)"); testConversion("(f = getFn())()"); } public void testConditionals() throws Exception { testConversion("x ? y : z"); testConversion("result = x ? y : z"); } public void testDecIncOperators() throws Exception { testConversion("x--"); testConversion("--x"); testConversion("x++"); testConversion("++x"); testConversion("var y=x++, z=++x; var s=y--, r=++y;"); } public void testDelete() throws Exception { testConversion("delete a"); testConversion("delete a.x"); testConversion("delete a[0]"); testConversion("delete a.x[0]"); } public void testDirectives() throws Exception { testConversion("'use strict'"); testConversion("function foo() {'use strict'}"); testConversion("'use strict'; function foo() {'use strict'}"); } public void testDoWhile() throws Exception { // testConversion("do; while (true)"); testConversion("do {} while (true)"); testConversion("do {;} while (true)"); testConversion("do {} while (f(x, y))"); testConversion("do {} while (f(f(f(x, y))))"); testConversion("do {} while ((f(f(f(x, y))))())"); testConversion("do {2 + 3; q = 2 + 3; var v = y * z;" + "g = function(a) {true; var b = a + 1; return a * a}} while (--x)"); } public void testFor() throws Exception { testConversion("for (;true;) {;}"); testJsonMLToAstConversion("for (i = 0; i < 10; ++i) x++"); testConversion("for (i = 0; i < 10; ++i) {x++}"); testConversion("for (i = 0; i < 10; ++i) {2 + 3; q = 2 + 3; " + "var v = y * z; g = function(a) {true; var b = a + 1;" + "return a * a}}"); testConversion("for(;true;) {break}"); testConversion("for(i = 0; i < 10; ++i) {if (i > 5) {break}}"); testConversion("s: for(i = 0; i < 10; ++i) {if (i > 5) {break s}}"); testConversion("for (i = 0;true; ++i) {" + "if (i % 2) {continue} else {var x = i / 3; f(x)}}"); } public void testForIn() throws Exception { testConversion("for (var i in x) {}"); testConversion("for (var i in x) {;}"); testConversion("for (var i in x) {f(x)}"); testConversion("s: for(var i in x) {if (i > 5) {break s}}"); testConversion("for (var i in x) {if (i % 2) {" + "continue} else {var x = i / 3; f(x)}}"); testConversion("for (var i in x) {2 + 3; q = 2 + 3; var v = y * z; " + "g = function(a) {true; var b = a + 1; return a * a}}"); testConversion("for (i in x) {}"); testConversion("for (i in x) {;}"); testConversion("for (i in x) {f(x)}"); testConversion("s: for (i in x) {if (i > 5) {break s}}"); testConversion("for (i in x) {if (i % 2) {" + "continue} else {var x = i / 3; f(x)}}"); testConversion("for (i in x) {2 + 3; q = 2 + 3; var v = y * z; " + "g = function(a) {true; var b = a + 1; return a * a}}"); } public void testFunctions() throws Exception { testConversion("(function () {})"); testConversion("(function (x, y) {})"); testConversion("(function () {})()"); testConversion("(function (x, y) {})()"); testConversion("[ function f() {} ]"); testConversion("var f = function f() {};"); testConversion("for (function f() {};true;) {}"); testConversion("x = (function (x, y) {})"); testConversion("function f() {}"); testConversion("for (;true;) { function f() {} }"); testConversion("function f() {;}"); testConversion("function f() {x}"); testConversion("function f() {x;y;z}"); testConversion("function f() {{}}"); } public void testIfElse1() throws Exception { testConversion("if (true) {x = 1}"); testConversion("if (true) {x = 1} else {x = 2}"); testConversion("if (f(f(f()))) {x = 1} else {x = 2}"); testConversion("if ((f(f(f())))()) {x = 1} else {x = 2}"); testConversion("if (true) {x = 1}; x = 1;"); } public void testLabels() throws Exception { testConversion("s: ;"); testConversion("s: {;}"); testConversion("s: while(true) {;}"); testConversion("s: switch (x) {case 'a': break s;}"); } public void testLogicalExpr() throws Exception { testConversion("a && b"); testConversion("a || b"); testConversion("a && b || c"); testConversion("a && (b || c)"); testConversion("f(x) && (function (x) {" + "return x % 2 == 0 })(z) || z % 3 == 0 ? true : false"); } public void testMathExpr() throws Exception { testConversion("2 + 3 * 4"); testConversion("(2 + 3) * 4"); testConversion("2 * (3 + 4)"); } public void testMember() throws Exception { testConversion("o.x"); testConversion("a.b.c"); testConversion("a.b.c.d"); testConversion("o[x]"); testConversion("o[0]"); testConversion("o[2 + 3 * 4]"); testConversion("o[(function (x){var y = g(x) << 1; return y * x})()]"); testConversion("o[o.x]"); testConversion("o.x[x]"); testConversion("a.b[o.x]"); testConversion("a.b[1]"); testConversion("a[b[c[d]]].x"); } public void testNew() throws Exception { testConversion("new A"); testConversion("new A()"); testConversion("new A(x, y, z)"); testConversion("new A(f(x), g(y), h(z))"); testConversion("new A(x, new B(x, y), z)"); testConversion("new A(1), new B()"); testConversion("new A, B"); testConversion("x = new A(a)"); testConversion("var x = new A(a, b)"); testConversion("var x = new A(1), y = new B()"); } public void testObject0() throws Exception { // TODO(johnlenz): quoted object literal properties are not noted. // testConversion("({'a':0})"); // TODO(johnlenz): numbers are represented as strings // testConversion("({1:0})"); } public void testObject() throws Exception { testConversion("x = {}"); testConversion("var x = {}"); testConversion("x = {x: 1, y: 2}"); // testConversion("var x = {'2': 1, 'a': 2}"); // testConversion("var x = {2: 1, a: 2}"); testConversion("x = {x: null}"); testConversion("x = {a: function f() {}}"); // testConversion("x = {1: function f() {}}"); testConversion("x = {a: f()}"); // testConversion("x = {1: f()}"); testConversion("x = {a: function f() {2 + 3; q = 2 + 3; var v = y * z; " + "g = function(a) {true; var b = a + 1; return a * a}}}"); // testConversion("x = {1: function f() {2 + 3; q = 2 + 3; var v = y * z; " // + "g = function(a) {true; var b = a + 1; return a * a}}}"); testConversion("x = {get a() {return 1}}"); testConversion("x = {set a(b) {}}"); } public void testOperators() throws Exception { testConversion("x instanceof Null"); testConversion("!x instanceof A"); testConversion("!(x instanceof A)"); testConversion("'a' in x"); testConversion("if('a' in x) {f(x)}"); testConversion("undefined in A"); testConversion("!(Number(1) in [2, 3, 4])"); testConversion("true ? x : y"); testConversion("(function() {var y = 2 + 3 * 4; return y >> 1})() ? x : y"); } public void testReturnStatement() throws Exception { testConversion("x = function f() {return}"); testConversion("x = function f() {return 1}"); testConversion("x = function f() {return 2 + 3 / 4}"); testConversion("x = function f() {return function() {}}"); testConversion("x = function f() {var y = 2; " + "return function() {return y * 3}}"); testConversion("x = function f() {z = 2 + 3; " + "return (function(z) {return z * y})(z)}"); } public void testRegExp() throws Exception { testConversion("/ab/"); testConversion("/ab/g"); testConversion("x = /ab/"); testConversion("x = /ab/g"); testConversion("var x = /ab/"); testConversion("var x = /ab/g"); testConversion("function f() {" + "/ab/; var x = /ab/; (function g() {/ab/; var x = /ab/})()}"); testConversion("var f = function () {return /ab/g;}"); } public void testSimplePrograms() throws Exception { testConversion(";"); testConversion("1"); testConversion("x"); testConversion("x=1"); testConversion("{}"); testConversion("{;}"); testConversion("{x=1}"); testConversion("x='a'"); testConversion("true"); testConversion("false"); testConversion("x=true"); testConversion("x=false"); testConversion("undefined"); testConversion("x=undefined"); testConversion("null"); testConversion("x = null"); testConversion("this"); testConversion("2 + 3; q = 2 + 3; var v = y * z; " + "g = function(a) {true; var b = a + 1; return a * a}"); testConversion("a; b"); testConversion("a; b; c; d"); testConversion("x = function () {}"); testConversion("x = function f() {}"); testConversion("x = function (arg1, arg2) {}"); testConversion("x = function f(arg1, arg2) {}"); testConversion("x = function f(arg1, arg2) {1}"); testConversion("x = function f(arg1, arg2) {x}"); testConversion("x = function f(arg1, arg2) {x = 1 + 1}"); testConversion("var re = new RegExp(document.a.b.c);" + "var m = re.exec(document.a.b.c);"); } public void testSwitch() throws Exception { testConversion("switch (x) {}"); testConversion("switch (x) {case 'a':}"); testConversion("switch (x) {case 'a':case 'b':}"); testConversion("switch (x) {case 'a':case 'b': x}"); testConversion("switch (x) {case 'a':case 'b': {;}}"); testConversion("switch (x) {case 'a':case 'b': f()}"); testConversion("switch (x) {case 'x': case 'y': {;} case 'a':case 'b': f()}"); testConversion("switch (x) {case 'a': f(x)}"); testConversion("switch (x) {case 'a': {f()} {g(x)}}"); testConversion("switch (x) {case 'a': f(); g(x)}"); testConversion("switch (x) {default: ;}"); testConversion("switch (x) {default:case 'a': ;}"); testConversion("switch (x) {case 'a':case'b':default: f()}"); testConversion("switch (x) {default:f(x); g(); case 'a': ; case 'b': g(x)}"); testConversion("switch (x) {case 'a': default: {f(x); g(z)} case 'b': g(x)}"); testConversion("switch (x) {case x: {;}}"); } public void testType() throws Exception { testConversion("undefined"); testConversion("null"); testConversion("0"); testConversion("+0"); testConversion("0.0"); testConversion("3.14"); testConversion("+3.14"); testConversion("true"); testConversion("false"); } public void testThis() throws Exception { testConversion("this"); testConversion("var x = this"); testConversion("this.foo()"); testConversion("var x = this.foo()"); testConversion("this.bar"); testConversion("var x = this.bar()"); testConversion("switch(this) {}"); testConversion("x + this"); } public void testThrow() throws Exception { testConversion("throw e"); testConversion("throw 2 + 3 * 4"); testConversion("throw (function () {2 + 3; q = 2 + 3; var v = y * z; " + "g = function(a) {true; var b = a + 1; return a * a}})()"); testConversion("throw f(x)"); testConversion("throw f(f(f(x)))"); testConversion("throw (f(f(x), y))()"); } public void testTry() throws Exception { testConversion("try {} catch (e) {}"); testConversion("try {;} catch (e) {;}"); testConversion("try {var x = 0; y / x} catch (e) {f(e)}"); testConversion("try {2 + 3; q = 2 + 3; var v = y * z; " + "g = function(a) {true; var b = a + 1; h(q); return a * a}; " + "h(q)} catch (e) {f(x)}"); testConversion("try {} finally {}"); testConversion("try {;} finally {;}"); testConversion("try {var x = 0; y / x} finally {f(y)}"); testConversion("try {2 + 3; q = 2 + 3; var v = y * z; " + "g = function(a) {true; var b = a + 1; h(q); return a * a}; " + "h(q)} finally {f(x)}"); testConversion("try {} catch (e) {} finally {}"); testConversion("try {;} catch (e) {;} finally {;}"); testConversion("try {var x = 0; y / x} catch (e) {;} finally {;}"); testConversion("try {2 + 3; q = 2 + 3; var v = y * z; " + "g = function(a) {true; var b = a + 1; h(q); return a * a}; h(q)} " + "catch (e) {f(x)} finally {f(x)}"); } public void testTypeof() throws Exception { testConversion("typeof undefined"); testConversion("typeof null"); testConversion("typeof 1"); testConversion("typeof 'a'"); testConversion("typeof false"); testConversion("typeof Null()"); testConversion("typeof Number(1)"); testConversion("typeof String('a')"); testConversion("typeof Boolean(0)"); testConversion("typeof x"); testConversion("typeof new A()"); testConversion("typeof new A(x)"); testConversion("typeof f(x)"); testConversion("typeof (function() {})()"); testConversion("typeof 2 + 3 * 4"); testConversion("typeof typeof x"); testConversion("typeof typeof typeof x"); } public void testUnaryExpressions() throws Exception { testConversion("!x"); testConversion("!null"); testConversion("!3.14"); testConversion("!true"); testConversion("~x"); testConversion("~null"); testConversion("~3.14"); testConversion("~true"); testConversion("+x"); testConversion("+null"); testConversion("+3.14"); testConversion("+true"); testConversion("-x"); testConversion("-null"); testConversion("-true"); testConversion("!~+-z"); testConversion("void x"); testConversion("void null"); testConversion("void void !x"); testConversion("void (x + 1)"); } public void testVarDeclarations() throws Exception { testConversion("var x"); testConversion("var x = 1"); testConversion("var x = 1 + 1"); testConversion("var x = 'a' + 'b'"); testConversion("var x, y, z"); testConversion("var x = 2, y = 2 * x, z"); testConversion("var x = function () {}"); testConversion("var x = function f() {}"); testConversion("var x = function f(arg1, arg2) {}"); testConversion("var x = function f(arg1, arg2) {1}"); testConversion("var x = function f(arg1, arg2) {x}"); testConversion("var x = function f(arg1, arg2) {x = 2 * 3}"); testConversion("var x = function f() {var x}"); testConversion("var x = function f() {var y = (z + 2) * q}"); testConversion("var x = function f(a, b) {" + "var y = function g(a, b) {z = a + b}}"); } public void testWhile() throws Exception { testConversion("while (true) {;}"); testConversion("while (true) {f()}"); testConversion("while (f(x, y)) {break;}"); testConversion("while (f(f(f(x, y)))) {}"); testConversion("while ((f(f(f(x, y))))()) {}"); testConversion("while (x--) {2 + 3; q = 2 + 3; var v = y * z; " + "g = function(a) {true; var b = a + 1; return a * a}}"); } public void testWith() throws Exception { testConversion("with ({}) {}"); testConversion("with ({}) {;}"); testConversion("with (x) {}"); testConversion("with (x) {f(x)}"); testConversion("with ({a: function f() {}}) {f(1)}"); testConversion("with ({z: function f() {2 + 3; q = 2 + 3; var v = y * z;" + "g = function(a) {true; var b = a + 1; return a * a}}}) {f(1)}"); testConversion("with (x in X) {x++}"); } }
/* * Copyright 2010 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp.jsonml; import com.google.javascript.jscomp.jsonml.SecureCompiler; import com.google.javascript.jscomp.jsonml.JsonML; import com.google.javascript.jscomp.jsonml.JsonMLUtil; import com.google.javascript.jscomp.jsonml.SecureCompiler.Report; import junit.framework.TestCase; /** * Test class for secure compilation. * * @author dhans@google.com (Daniel Hans) * */ public class SecureCompilerTest extends TestCase { // simple correct source // var x = 1; var t = x; private static final String SIMPLE_SOURCE = "['Program',{}," + "['VarDecl',{}," + "['InitPatt',{}," + "['IdPatt',{'name':'x'}]," + "['LiteralExpr',{'type':'number','value':1}]]]," + "['VarDecl',{}," + "['InitPatt',{}," + "['IdPatt',{'name':'t'}]," + "['IdExpr',{'name':'x'}]]]]"; // syntax error source // missing InitPatt element private static final String SYNTAX_ERROR = "['Program',{}," + "['VarDecl',{}," + "['InitPatt',{}," + "['IdPatt',{'name':'x'}]," + "['LiteralExpr',{'type':'number','value':1}]]]," + "['VarDecl',{}," + "['IdPatt',{'name':'t'}]," + "['IdExpr',{'name':'x'}]]]]"; private void testSuccess(JsonML source) throws Exception { SecureCompiler compiler = new SecureCompiler(); compiler.compile(source); Report report = compiler.getReport(); assertTrue(report.isSuccessful()); assertEquals(0, report.getErrors().length); assertEquals(0, report.getWarnings().length); } private void testError(JsonML source) throws Exception { SecureCompiler compiler = new SecureCompiler(); compiler.compile(source); Report report = compiler.getReport(); assertFalse(report.isSuccessful()); } private void testString(String jsonml) throws Exception { JsonML source = JsonMLUtil.parseString(jsonml); testSuccess(source); } private void testInvalidString(String jsonml) throws Exception { JsonML source = JsonMLUtil.parseString(jsonml); testError(source); } public void testCompilerInterface() throws Exception { testString(SIMPLE_SOURCE); testInvalidString(SYNTAX_ERROR); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp.parsing; import com.google.common.collect.Sets; import com.google.javascript.jscomp.SourceFile; import com.google.javascript.jscomp.parsing.Config.LanguageMode; import com.google.javascript.jscomp.testing.TestErrorReporter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.head.CompilerEnvirons; import com.google.javascript.rhino.head.Parser; import com.google.javascript.rhino.head.ast.AstRoot; import com.google.javascript.rhino.testing.BaseJSTypeTestCase; /** * Tests {@link IRFactory}. */ public class IRFactoryTest extends BaseJSTypeTestCase { private LanguageMode mode = LanguageMode.ECMASCRIPT3; @Override protected void setUp() throws Exception { super.setUp(); mode = LanguageMode.ECMASCRIPT3; } public void testStrictScript() throws Exception { assertNull(newParse("").getDirectives()); assertEquals( Sets.newHashSet("use strict"), newParse("'use strict'").getDirectives()); } public void testArrayLiteral2() throws Exception { testNewParser("[a, , b]", "SCRIPT 1 [source_file: FileName.js] [length: 8]\n" + " EXPR_RESULT 1 [source_file: FileName.js] [length: 8]\n" + " ARRAYLIT 1 [source_file: FileName.js] [length: 8]\n" + " NAME a 1 [source_file: FileName.js] [length: 1]\n" + " EMPTY 1 [source_file: FileName.js] [length: 1]\n" + " NAME b 1 [source_file: FileName.js] [length: 1]\n"); } public void testArrayLiteral4() throws Exception { testNewParser("[,,,a,,b]", "SCRIPT 1 [source_file: FileName.js] [length: 9]\n" + " EXPR_RESULT 1 [source_file: FileName.js] [length: 9]\n" + " ARRAYLIT 1 [source_file: FileName.js] [length: 9]\n" + " EMPTY 1 [source_file: FileName.js] [length: 1]\n" + " EMPTY 1 [source_file: FileName.js] [length: 1]\n" + " EMPTY 1 [source_file: FileName.js] [length: 1]\n" + " NAME a 1 [source_file: FileName.js] [length: 1]\n" + " EMPTY 1 [source_file: FileName.js] [length: 1]\n" + " NAME b 1 [source_file: FileName.js] [length: 1]\n"); } public void testObjectLiteral() { newParse("var o = {}"); } public void testObjectLiteral2() { newParse("var o = {a: 1}"); } public void testObjectLiteral3() { newParse("var o = {a: 1, b: 2}"); } public void testObjectLiteral4() { newParse("var o = {1: 'a'}"); } public void testObjectLiteral5() { newParse("var o = {'a': 'a'}"); } public void testObjectLiteral6() { testNewParser("({1: true})", "SCRIPT 1 [source_file: FileName.js] [length: 11]\n" + " EXPR_RESULT 1 [source_file: FileName.js] [length: 10]\n" + " OBJECTLIT 1 [source_file: FileName.js] [length: 9]\n" + " STRING_KEY 1 1 [quoted: 1] [source_file: FileName.js] [length: 1]\n" + " TRUE 1 [source_file: FileName.js] [length: 4]\n"); } public void testObjectLiteral7() { mode = LanguageMode.ECMASCRIPT5; testNewParser("({get 1() {}})", "SCRIPT 1 [source_file: FileName.js] [length: 14]\n" + " EXPR_RESULT 1 [source_file: FileName.js] [length: 13]\n" + " OBJECTLIT 1 [source_file: FileName.js] [length: 12]\n" + " GETTER_DEF 1 1 [quoted: 1] [source_file: FileName.js] [length: 1]\n" + " FUNCTION 1 [source_file: FileName.js] [length: 6]\n" + " NAME 1 [source_file: FileName.js]\n" + " PARAM_LIST 1 [source_file: FileName.js]\n" + " BLOCK 1 [source_file: FileName.js] [length: 2]\n"); } public void testObjectLiteral8() { mode = LanguageMode.ECMASCRIPT5; testNewParser("({set 1(a) {}})", "SCRIPT 1 [source_file: FileName.js] [length: 15]\n" + " EXPR_RESULT 1 [source_file: FileName.js] [length: 14]\n" + " OBJECTLIT 1 [source_file: FileName.js] [length: 13]\n" + " SETTER_DEF 1 1 [quoted: 1] [source_file: FileName.js] [length: 1]\n" + " FUNCTION 1 [source_file: FileName.js] [length: 7]\n" + " NAME 1 [source_file: FileName.js]\n" + " PARAM_LIST 1 [source_file: FileName.js]\n" + " NAME a 1 [source_file: FileName.js] [length: 1]\n" + " BLOCK 1 [source_file: FileName.js] [length: 2]\n"); } // The old and new parser produce different results now with labels, and // named breaks and continues, so disable these tests. public void testLabel() { testNewParser("foo: bar", "SCRIPT 1 [source_file: FileName.js] [length: 8]\n" + " LABEL 1 [source_file: FileName.js] [length: 4]\n" + " LABEL_NAME foo 1 [source_file: FileName.js] [length: 4]\n" + " EXPR_RESULT 1 [source_file: FileName.js] [length: 3]\n" + " NAME bar 1 [source_file: FileName.js] [length: 3]\n"); } public void testLabel2() { testNewParser("l: while (f()) { if (g()) { continue l; } }", "SCRIPT 1 [source_file: FileName.js] [length: 43]\n" + " LABEL 1 [source_file: FileName.js] [length: 2]\n" + " LABEL_NAME l 1 [source_file: FileName.js] [length: 2]\n" + " WHILE 1 [source_file: FileName.js] [length: 40]\n" + " CALL 1 [source_file: FileName.js] [length: 3]\n" + " NAME f 1 [source_file: FileName.js] [length: 1]\n" + " BLOCK 1 [source_file: FileName.js] [length: 28]\n" + " IF 1 [source_file: FileName.js] [length: 24]\n" + " CALL 1 [source_file: FileName.js] [length: 3]\n" + " NAME g 1 [source_file: FileName.js] [length: 1]\n" + " BLOCK 1 [source_file: FileName.js] [length: 15]\n" + " CONTINUE 1 [source_file: FileName.js] [length: 11]\n" + " LABEL_NAME l 1 [source_file: FileName.js] [length: 1]\n"); } public void testLabel3() { testNewParser("Foo:Bar:X:{ break Bar; }", "SCRIPT 1 [source_file: FileName.js] [length: 24]\n" + " LABEL 1 [source_file: FileName.js] [length: 4]\n" + " LABEL_NAME Foo 1 [source_file: FileName.js] [length: 4]\n" + " LABEL 1 [source_file: FileName.js] [length: 4]\n" + " LABEL_NAME Bar 1 [source_file: FileName.js] [length: 4]\n" + " LABEL 1 [source_file: FileName.js] [length: 2]\n" + " LABEL_NAME X 1 [source_file: FileName.js] [length: 2]\n" + " BLOCK 1 [source_file: FileName.js] [length: 14]\n" + " BREAK 1 [source_file: FileName.js] [length: 10]\n" + " LABEL_NAME Bar 1 [source_file: FileName.js] [length: 3]\n"); } public void testNegation1() { testNewParser("-a", "SCRIPT 1 [source_file: FileName.js] [length: 2]\n" + " EXPR_RESULT 1 [source_file: FileName.js] [length: 2]\n" + " NEG 1 [source_file: FileName.js] [length: 2]\n" + " NAME a 1 [source_file: FileName.js] [length: 1]\n"); } public void testNegation2() { testNewParser("-2", "SCRIPT 1 [source_file: FileName.js] [length: 2]\n" + " EXPR_RESULT 1 [source_file: FileName.js] [length: 2]\n" + " NUMBER -2.0 1 [source_file: FileName.js] [length: 1]\n"); } public void testNegation3() { testNewParser("1 - -2", "SCRIPT 1 [source_file: FileName.js] [length: 6]\n" + " EXPR_RESULT 1 [source_file: FileName.js] [length: 6]\n" + " SUB 1 [source_file: FileName.js] [length: 6]\n" + " NUMBER 1.0 1 [source_file: FileName.js] [length: 1]\n" + " NUMBER -2.0 1 [source_file: FileName.js] [length: 1]\n"); } public void testGetter() { mode = LanguageMode.ECMASCRIPT5; testNewParser("({get a() {}})", "SCRIPT 1 [source_file: FileName.js] [length: 14]\n" + " EXPR_RESULT 1 [source_file: FileName.js] [length: 13]\n" + " OBJECTLIT 1 [source_file: FileName.js] [length: 12]\n" + " GETTER_DEF a 1 [source_file: FileName.js] [length: 1]\n" + " FUNCTION 1 [source_file: FileName.js] [length: 6]\n" + " NAME 1 [source_file: FileName.js]\n" + " PARAM_LIST 1 [source_file: FileName.js]\n" + " BLOCK 1 [source_file: FileName.js] [length: 2]\n"); } public void testSetter() { mode = LanguageMode.ECMASCRIPT5; testNewParser("({set a(x) {}})", "SCRIPT 1 [source_file: FileName.js] [length: 15]\n" + " EXPR_RESULT 1 [source_file: FileName.js] [length: 14]\n" + " OBJECTLIT 1 [source_file: FileName.js] [length: 13]\n" + " SETTER_DEF a 1 [source_file: FileName.js] [length: 1]\n" + " FUNCTION 1 [source_file: FileName.js] [length: 7]\n" + " NAME 1 [source_file: FileName.js]\n" + " PARAM_LIST 1 [source_file: FileName.js]\n" + " NAME x 1 [source_file: FileName.js] [length: 1]\n" + " BLOCK 1 [source_file: FileName.js] [length: 2]\n"); } public void testDelete1() { testNoParseError("delete a.b;"); } public void testDelete2() { testNoParseError("delete a['b'];"); } public void testDelete3() { // This is allowed in ES3 and ES5, but not in ES5/strict. There // is a strict mode check for this. testNoParseError("delete a;"); } public void testDelete4() { testParseError("delete 'x';", "Invalid delete operand. Only properties can be deleted."); } public void testCommentPositions1() { Node root = newParse("/** @param {string} x */function a(x) {};" + "/** @param {string} x */function b(x) {}"); Node a = root.getFirstChild(); Node b = root.getLastChild(); assertMarkerPosition(a, 1, 4); assertMarkerPosition(b, 1, 45); } public void testCommentPositions2() { Node root = newParse( "/* foo \n" + " bar \n" + "*/\n" + "/** @param {string} x */\n" + "function a(x) {};\n" + "\n" + "/* bar \n" + " foo \n" + " foo */\n" + "\n" + "/** @param {string} x */\n" + "function b(x) {};"); assertMarkerPosition(root.getFirstChild(), 4, 4); assertMarkerPosition(root.getFirstChild().getNext().getNext(), 11, 6); } public void testLiteralLocation() { Node root = newParse( "var d =\n" + " \"foo\";\n" + "var e =\n" + " 1;\n" + "var f = \n" + " 1.2;\n" + "var g = \n" + " 2e5;\n" + "var h = \n" + " 'bar';\n"); Node firstStmt = root.getFirstChild(); Node firstLiteral = firstStmt.getFirstChild().getFirstChild(); Node secondStmt = firstStmt.getNext(); Node secondLiteral = secondStmt.getFirstChild().getFirstChild(); Node thirdStmt = secondStmt.getNext(); Node thirdLiteral = thirdStmt.getFirstChild().getFirstChild(); Node fourthStmt = thirdStmt.getNext(); Node fourthLiteral = fourthStmt.getFirstChild().getFirstChild(); Node fifthStmt = fourthStmt.getNext(); Node fifthLiteral = fifthStmt.getFirstChild().getFirstChild(); assertNodePosition(2, 4, firstLiteral); assertNodePosition(4, 4, secondLiteral); assertNodePosition(6, 4, thirdLiteral); assertNodePosition(8, 4, fourthLiteral); assertNodePosition(10, 4, fifthLiteral); } public void testSwitchLocation() { Node root = newParse( "switch (a) {\n" + " //{\n" + " case 1:\n" + " b++;\n" + " case 2:\n" + " default:\n" + " b--;\n" + " }\n"); Node switchStmt = root.getFirstChild(); Node switchVar = switchStmt.getFirstChild(); Node firstCase = switchVar.getNext(); Node caseArg = firstCase.getFirstChild(); Node caseBody = caseArg.getNext(); Node caseExprStmt = caseBody.getFirstChild(); Node incrExpr = caseExprStmt.getFirstChild(); Node incrVar = incrExpr.getFirstChild(); Node secondCase = firstCase.getNext(); Node defaultCase = secondCase.getNext(); assertNodePosition(1, 0, switchStmt); assertNodePosition(1, 8, switchVar); assertNodePosition(3, 3, firstCase); assertNodePosition(3, 8, caseArg); assertNodePosition(3, 3, caseBody); assertNodePosition(4, 5, caseExprStmt); assertNodePosition(4, 5, incrExpr); assertNodePosition(4, 5, incrVar); assertNodePosition(5, 3, secondCase); assertNodePosition(6, 3, defaultCase); } public void testFunctionParamLocation() { Node root = newParse( "function\n" + " foo(a,\n" + " b,\n" + " c)\n" + "{}\n"); Node function = root.getFirstChild(); Node functionName = function.getFirstChild(); Node params = functionName.getNext(); Node param1 = params.getFirstChild(); Node param2 = param1.getNext(); Node param3 = param2.getNext(); Node body = params.getNext(); assertNodePosition(1, 0, function); assertNodePosition(2, 5, functionName); // params corresponds to the LP token. // Can't be on a separate line because of inferred // semicolons. assertNodePosition(2, 8, params); assertNodePosition(2, 9, param1); assertNodePosition(3, 5, param2); assertNodePosition(4, 5, param3); assertNodePosition(5, 0, body); } public void testVarDeclLocation() { Node root = newParse( "var\n" + " a =\n" + " 3\n"); Node varDecl = root.getFirstChild(); Node varName = varDecl.getFirstChild(); Node varExpr = varName.getFirstChild(); assertNodePosition(1, 0, varDecl); assertNodePosition(2, 4, 1, varName); assertNodePosition(3, 4, 1, varExpr); } public void testReturnLocation() { Node root = newParse( "function\n" + " foo(\n" + " a,\n" + " b,\n" + " c) {\n" + " return\n" + " 4;\n" + "}\n"); Node function = root.getFirstChild(); Node functionName = function.getFirstChild(); Node params = functionName.getNext(); Node body = params.getNext(); Node returnStmt = body.getFirstChild(); Node exprStmt = returnStmt.getNext(); Node returnVal = exprStmt.getFirstChild(); assertNodePosition(6, 4, returnStmt); assertNodePosition(7, 4, exprStmt); assertNodePosition(7, 4, returnVal); } public void testLinenoFor() { Node root = newParse( "for(\n" + ";\n" + ";\n" + ") {\n" + "}\n"); Node forNode = root.getFirstChild(); Node initClause= forNode.getFirstChild(); Node condClause = initClause.getNext(); Node incrClause = condClause.getNext(); assertNodePosition(1, 0, forNode); assertNodePosition(2, 0, initClause); assertNodePosition(3, 0, condClause); // TODO(bowdidge) Incorrectly gets charno position when EmptyExpression // has its absolute position on the carriage return. For now, the // line number gets reported correctly (on the next line) but the // character position is -1, so the overall line/char pair in our tree // is -1. //assertNodePosition(4, 0, incrClause); } public void testBinaryExprLocation() { Node root = newParse( "var d = a\n" + " + \n" + " b;\n" + "var\n" + " e =\n" + " a +\n" + " c;\n" + "var f = b\n" + " / c;\n"); Node firstVarDecl = root.getFirstChild(); Node firstVar = firstVarDecl.getFirstChild(); Node firstVarAdd = firstVar.getFirstChild(); Node secondVarDecl = firstVarDecl.getNext(); Node secondVar = secondVarDecl.getFirstChild(); Node secondVarAdd = secondVar.getFirstChild(); Node thirdVarDecl = secondVarDecl.getNext(); Node thirdVar = thirdVarDecl.getFirstChild(); Node thirdVarAdd = thirdVar.getFirstChild(); assertNodePosition(1, 0, firstVarDecl); assertNodePosition(1, 4, firstVar); assertNodePosition(1, 8, firstVarAdd); assertNodePosition(1, 8, firstVarAdd.getFirstChild()); assertNodePosition(3, 4, firstVarAdd.getLastChild()); assertNodePosition(4, 0, secondVarDecl); assertNodePosition(5, 4, secondVar); assertNodePosition(6, 4, secondVarAdd); assertNodePosition(6, 4, secondVarAdd.getFirstChild()); assertNodePosition(7, 4, secondVarAdd.getLastChild()); assertNodePosition(8, 0, thirdVarDecl); assertNodePosition(8, 4, thirdVar); assertNodePosition(8, 8, thirdVarAdd); assertNodePosition(8, 8, thirdVarAdd.getFirstChild()); assertNodePosition(9, 6, thirdVarAdd.getLastChild()); } public void testPrefixLocation() { Node root = newParse( "a++;\n" + "--\n" + "b;\n"); Node firstStmt = root.getFirstChild(); Node secondStmt = firstStmt.getNext(); Node firstOp = firstStmt.getFirstChild(); Node secondOp = secondStmt.getFirstChild(); assertNodePosition(1, 0, firstOp); assertNodePosition(2, 0, secondOp); } public void testIfLocation() { Node root = newParse( "if\n" + " (a == 3)\n" + "{\n" + " b = 0;\n" + "}\n" + " else\n" + "{\n" + " c = 1;\n" + "}\n"); Node ifStmt = root.getFirstChild(); Node eqClause = ifStmt.getFirstChild(); Node thenClause = eqClause.getNext(); Node elseClause = thenClause.getNext(); assertNodePosition(1, 0, ifStmt); assertNodePosition(2, 3, eqClause); assertNodePosition(3, 0, thenClause); assertNodePosition(7, 0, elseClause); } public void testTryLocation() { Node root = newParse( "try {\n" + " var x = 1;\n" + "} catch\n" + " (err)\n" + "{\n" + "} finally {\n" + " var y = 2;\n" + "}\n"); Node tryStmt = root.getFirstChild(); Node tryBlock = tryStmt.getFirstChild(); Node catchBlock = tryBlock.getNext(); Node catchVarBlock = catchBlock.getFirstChild(); Node catchVar = catchVarBlock.getFirstChild(); Node finallyBlock = catchBlock.getNext(); Node finallyStmt = finallyBlock.getFirstChild(); assertNodePosition(1, 0, tryStmt); assertNodePosition(1, 4, tryBlock); assertNodePosition(3, 2, catchVarBlock); assertNodePosition(4, 4, catchVar); assertNodePosition(3, 0, catchBlock); assertNodePosition(6, 10, finallyBlock); assertNodePosition(7, 2, finallyStmt); } public void testHookLocation() { Node root = newParse( "a\n" + "?\n" + "b\n" + ":\n" + "c\n" + ";\n"); Node hookExpr = root.getFirstChild().getFirstChild(); Node condExpr = hookExpr.getFirstChild(); Node thenExpr = condExpr.getNext(); Node elseExpr = thenExpr.getNext(); assertNodePosition(2, 0, hookExpr); assertNodePosition(1, 0, condExpr); assertNodePosition(3, 0, thenExpr); assertNodePosition(5, 0, elseExpr); } public void testLabelLocation() { Node root = newParse( "foo:\n" + "a = 1;\n" + "bar:\n" + "b = 2;\n"); Node firstStmt = root.getFirstChild(); Node secondStmt = firstStmt.getNext(); assertNodePosition(1, 0, firstStmt); assertNodePosition(3, 0, secondStmt); } public void testCompareLocation() { Node root = newParse( "a\n" + "<\n" + "b\n"); Node condClause = root.getFirstChild().getFirstChild(); Node lhs = condClause.getFirstChild(); Node rhs = lhs.getNext(); assertNodePosition(1, 0, condClause); assertNodePosition(1, 0, lhs); assertNodePosition(3, 0, rhs); } public void testEqualityLocation() { Node root = newParse( "a\n" + "==\n" + "b\n"); Node condClause = root.getFirstChild().getFirstChild(); Node lhs = condClause.getFirstChild(); Node rhs = lhs.getNext(); assertNodePosition(1, 0, condClause); assertNodePosition(1, 0, lhs); assertNodePosition(3, 0, rhs); } public void testPlusEqLocation() { Node root = newParse( "a\n" + "+=\n" + "b\n"); Node condClause = root.getFirstChild().getFirstChild(); Node lhs = condClause.getFirstChild(); Node rhs = lhs.getNext(); assertNodePosition(1, 0, condClause); assertNodePosition(1, 0, lhs); assertNodePosition(3, 0, rhs); } public void testCommaLocation() { Node root = newParse( "a,\n" + "b,\n" + "c;\n"); Node statement = root.getFirstChild(); Node comma1 = statement.getFirstChild(); Node comma2 = comma1.getFirstChild(); Node cRef = comma2.getNext(); Node aRef = comma2.getFirstChild(); Node bRef = aRef.getNext(); assertNodePosition(1, 0, comma2); assertNodePosition(1, 0, aRef); assertNodePosition(2, 0, bRef); assertNodePosition(3, 0, cRef); } public void testRegexpLocation() { Node root = newParse( "var path =\n" + "replace(\n" + "/a/g," + "'/');\n"); Node firstVarDecl = root.getFirstChild(); Node firstVar = firstVarDecl.getFirstChild(); Node callNode = firstVar.getFirstChild(); Node fnName = callNode.getFirstChild(); Node regexObject = fnName.getNext(); Node aString = regexObject.getFirstChild(); Node endRegexString = regexObject.getNext(); assertNodePosition(1, 0, firstVarDecl); assertNodePosition(1, 4, 4, firstVar); assertNodePosition(2, 0, 18, callNode); assertNodePosition(2, 0, 7, fnName); assertNodePosition(3, 0, regexObject); assertNodePosition(3, 0, aString); assertNodePosition(3, 5, endRegexString); } public void testNestedOr() { Node root = newParse( "if (a && \n" + " b() || \n" + " /* comment */\n" + " c) {\n" + "}\n" ); Node ifStmt = root.getFirstChild(); Node orClause = ifStmt.getFirstChild(); Node andClause = orClause.getFirstChild(); Node cName = andClause.getNext(); assertNodePosition(1, 0, ifStmt); assertNodePosition(1, 4, orClause); assertNodePosition(1, 4, andClause); assertNodePosition(4, 4, cName); } public void testBitwiseOps() { Node root = newParse( "if (a & \n" + " b() | \n" + " /* comment */\n" + " c) {\n" + "}\n" ); Node ifStmt = root.getFirstChild(); Node bitOr = ifStmt.getFirstChild(); Node bitAnd = bitOr.getFirstChild(); Node cName = bitAnd.getNext(); assertNodePosition(1, 0, ifStmt); assertNodePosition(1, 4, bitOr); assertNodePosition(1, 4, bitAnd); assertNodePosition(4, 4, cName); } public void testObjectLitLocation() { Node root = newParse( "var foo =\n" + "{ \n" + "'A' : 'A', \n" + "'B' : 'B', \n" + "'C' :\n" + " 'C' \n" + "};\n"); Node firstVarDecl = root.getFirstChild(); Node firstVar = firstVarDecl.getFirstChild(); Node firstObjectLit = firstVar.getFirstChild(); Node firstKey = firstObjectLit.getFirstChild(); Node firstValue = firstKey.getFirstChild(); Node secondKey = firstKey.getNext(); Node secondValue = secondKey.getFirstChild(); Node thirdKey = secondKey.getNext(); Node thirdValue = thirdKey.getFirstChild(); assertNodePosition(1, 4, firstVar); assertNodePosition(2, 0, firstObjectLit); assertNodePosition(3, 0, firstKey); assertNodePosition(3, 6, firstValue); assertNodePosition(4, 0, secondKey); assertNodePosition(4, 6, secondValue); assertNodePosition(5, 0, thirdKey); assertNodePosition(6, 4, thirdValue); } public void testTryWithoutCatchLocation() { Node root = newParse( "try {\n" + " var x = 1;\n" + "} finally {\n" + " var y = 2;\n" + "}\n"); Node tryStmt = root.getFirstChild(); Node tryBlock = tryStmt.getFirstChild(); Node catchBlock = tryBlock.getNext(); Node finallyBlock = catchBlock.getNext(); Node finallyStmt = finallyBlock.getFirstChild(); assertNodePosition(1, 0, tryStmt); assertNodePosition(1, 4, tryBlock); assertNodePosition(3, 0, catchBlock); assertNodePosition(3, 10, finallyBlock); assertNodePosition(4, 2, finallyStmt); } public void testTryWithoutFinallyLocation() { Node root = newParse( "try {\n" + " var x = 1;\n" + "} catch (ex) {\n" + " var y = 2;\n" + "}\n"); Node tryStmt = root.getFirstChild(); Node tryBlock = tryStmt.getFirstChild(); Node catchBlock = tryBlock.getNext(); Node catchStmt = catchBlock.getFirstChild(); Node exceptionVar = catchStmt.getFirstChild(); Node exceptionBlock = exceptionVar.getNext(); Node varDecl = exceptionBlock.getFirstChild(); assertNodePosition(1, 0, tryStmt); assertNodePosition(1, 4, tryBlock); assertNodePosition(3, 0, catchBlock); assertNodePosition(3, 2, catchStmt); assertNodePosition(3, 9, exceptionVar); assertNodePosition(3, 13, exceptionBlock); assertNodePosition(4, 2, varDecl); } public void testMultilineEqLocation() { Node root = newParse( "if\n" + " (((a == \n" + " 3) && \n" + " (b == 2)) || \n" + " (c == 1)) {\n" + "}\n"); Node ifStmt = root.getFirstChild(); Node orTest = ifStmt.getFirstChild(); Node andTest = orTest.getFirstChild(); Node cTest = andTest.getNext(); Node aTest = andTest.getFirstChild(); Node bTest = aTest.getNext(); assertNodePosition(1, 0, ifStmt); assertNodePosition(2, 7, orTest); assertNodePosition(2, 7, andTest); assertNodePosition(2, 7, aTest); assertNodePosition(4, 3, bTest); assertNodePosition(5, 2, cTest); } public void testMultilineBitTestLocation() { Node root = newParse( "if (\n" + " ((a \n" + " | 3 \n" + " ) == \n" + " (b \n" + " & 2)) && \n" + " ((a \n" + " ^ 0xffff) \n" + " != \n" + " (c \n" + " << 1))) {\n" + "}\n"); Node ifStmt = root.getFirstChild(); Node andTest = ifStmt.getFirstChild(); Node eqTest = andTest.getFirstChild(); Node notEqTest = eqTest.getNext(); Node bitOrTest = eqTest.getFirstChild(); Node bitAndTest = bitOrTest.getNext(); Node bitXorTest = notEqTest.getFirstChild(); Node bitShiftTest = bitXorTest.getNext(); assertNodePosition(1, 0, ifStmt); assertNodePosition(2, 8, eqTest); assertNodePosition(7, 8, notEqTest); assertNodePosition(2, 8, bitOrTest); assertNodePosition(5, 8, bitAndTest); assertNodePosition(7, 8, bitXorTest); assertNodePosition(10, 8, bitShiftTest); } public void testCallLocation() { Node root = newParse( "a.\n" + "b.\n" + "cccc(1);\n"); Node exprStmt = root.getFirstChild(); Node functionCall = exprStmt.getFirstChild(); Node functionProp = functionCall.getFirstChild(); Node firstNameComponent = functionProp.getFirstChild(); Node lastNameComponent = firstNameComponent.getNext(); Node aNameComponent = firstNameComponent.getFirstChild(); Node bNameComponent = aNameComponent.getNext(); assertNodePosition(1, 0, 13, functionCall); assertNodePosition(1, 0, 10, functionProp); // TODO(bowdidge) New Rhino doesn't keep the position of the dot handy. // New Rhino treats the location of the qualified name as the beginning of // the whole name. assertNodePosition(1, 0, 4, firstNameComponent); assertNodePosition(3, 0, 4, lastNameComponent); assertNodePosition(1, 0, 1, aNameComponent); assertNodePosition(2, 0, 1, bNameComponent); } public void testNewLocation() { Node root = newParse( "new c();\n"); Node exprStmt = root.getFirstChild(); Node newExpr = exprStmt.getFirstChild(); assertNodePosition(1, 0, 7, newExpr); } public void testNewLocationMultiLine() { Node root = newParse( "new \n" + "c();\n"); Node exprStmt = root.getFirstChild(); Node newExpr = exprStmt.getFirstChild(); assertNodePosition(1, 0, 10, newExpr); } public void testLinenoDeclaration() { Node root = newParse( "a.\n" + "b=\n" + "function() {};\n"); Node exprStmt = root.getFirstChild(); Node fnAssignment = exprStmt.getFirstChild(); Node aDotbName = fnAssignment.getFirstChild(); Node aName = aDotbName.getFirstChild(); Node bName = aName.getNext(); Node fnNode = aDotbName.getNext(); Node fnName = fnNode.getFirstChild(); assertNodePosition(1, 0, fnAssignment); // TODO(bowdidge) New Rhino doesn't keep track of the position of the dot. //assertNodePosition(1, 1, aDotbName); assertNodePosition(1, 0, aName); assertNodePosition(2, 0, bName); assertNodePosition(3, 0, fnNode); assertNodePosition(3, 8, fnName); } final String INVALID_ASSIGNMENT_TARGET = "invalid assignment target"; final String INVALID_INCREMENT_TARGET = "invalid increment target"; final String INVALID_DECREMENT_TARGET = "invalid decrement target"; final String INVALID_INC_OPERAND = "Invalid increment operand"; final String INVALID_DEC_OPERAND = "Invalid decrement operand"; public void testAssignmentValidation() { testNoParseError("x=1"); testNoParseError("x.y=1"); testNoParseError("f().y=1"); testParseError("(x||y)=1", INVALID_ASSIGNMENT_TARGET); testParseError("(x?y:z)=1", INVALID_ASSIGNMENT_TARGET); testParseError("f()=1", INVALID_ASSIGNMENT_TARGET); testNoParseError("x+=1"); testNoParseError("x.y+=1"); testNoParseError("f().y+=1"); testParseError("(x||y)+=1", INVALID_ASSIGNMENT_TARGET); testParseError("(x?y:z)+=1", INVALID_ASSIGNMENT_TARGET); testParseError("f()+=1", INVALID_ASSIGNMENT_TARGET); testParseError("f()++", INVALID_INCREMENT_TARGET); testParseError("f()--", INVALID_DECREMENT_TARGET); testParseError("++f()", INVALID_INCREMENT_TARGET); testParseError("--f()", INVALID_DECREMENT_TARGET); } private void testNoParseError(String string) { testParseError(string, (String)null); } private void testParseError(String string, String error) { testParseError(string, error == null ? null : new String[] { error }); } private void testParseError(String string, String[] errors) { Node root = newParse(string, new TestErrorReporter(errors, null)); assertTrue("unexpected warnings reported", errorReporter.hasEncounteredAllWarnings()); assertTrue("expected error were not reported", errorReporter.hasEncounteredAllErrors()); } private void assertMarkerPosition(Node n, int lineno, int charno) { int count = 0; for (JSDocInfo.Marker marker : n.getJSDocInfo().getMarkers()) { assertEquals(lineno, marker.getAnnotation().getStartLine()); assertEquals(charno, marker.getAnnotation().getPositionOnStartLine()); count++; } assertEquals(1, count); } private void assertNodePosition(int lineno, int charno, Node n) { assertEquals("Line number", lineno, n.getLineno()); assertEquals("Column position", charno, n.getCharno()); } private void assertNodePosition(int lineno, int charno, int length, Node n) { assertEquals("Line number", lineno, n.getLineno()); assertEquals("Column position", charno, n.getCharno()); assertEquals("Length", length, n.getLength()); } private void testNewParser(String code, String expected) { String actual = newParse(code).toStringTree(); assertEquals(expected, actual); } private Node newParse(String string) { return newParse(string, new TestErrorReporter(null, null)); } private Node newParse(String string, TestErrorReporter errorReporter) { CompilerEnvirons environment = new CompilerEnvirons(); environment.setRecordingComments(true); environment.setRecordingLocalJsDocComments(true); Parser p = new Parser(environment); AstRoot script = p.parse(string, null, 1); Config config = ParserRunner.createConfig(true, mode, false); Node root = IRFactory.transformTree( script, SourceFile.fromCode("FileName.js", string), string, config, errorReporter); return root; } }
/* * Copyright 2007 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp.parsing; import com.google.common.collect.Sets; import com.google.javascript.jscomp.parsing.Config.LanguageMode; import com.google.javascript.jscomp.testing.TestErrorReporter; import com.google.javascript.rhino.InputId; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.JSDocInfo.Visibility; import com.google.javascript.rhino.JSTypeExpression; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.head.CompilerEnvirons; import com.google.javascript.rhino.head.Parser; import com.google.javascript.rhino.head.Token.CommentType; import com.google.javascript.rhino.head.ast.AstRoot; import com.google.javascript.rhino.head.ast.Comment; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.ObjectType; import com.google.javascript.rhino.jstype.SimpleSourceFile; import com.google.javascript.rhino.jstype.StaticSourceFile; import com.google.javascript.rhino.testing.BaseJSTypeTestCase; import java.util.Collection; import java.util.List; import java.util.Set; public class JsDocInfoParserTest extends BaseJSTypeTestCase { private Set<String> extraAnnotations; private Set<String> extraSuppressions; private Node.FileLevelJsDocBuilder fileLevelJsDocBuilder = null; @Override public void setUp() throws Exception { super.setUp(); extraAnnotations = Sets.newHashSet( ParserRunner.createConfig(true, LanguageMode.ECMASCRIPT3, false) .annotationNames.keySet()); extraSuppressions = Sets.newHashSet( ParserRunner.createConfig(true, LanguageMode.ECMASCRIPT3, false) .suppressionNames); extraSuppressions.add("x"); extraSuppressions.add("y"); extraSuppressions.add("z"); } public void testParseTypeViaStatic1() throws Exception { Node typeNode = parseType("null"); assertTypeEquals(NULL_TYPE, typeNode); } public void testParseTypeViaStatic2() throws Exception { Node typeNode = parseType("string"); assertTypeEquals(STRING_TYPE, typeNode); } public void testParseTypeViaStatic3() throws Exception { Node typeNode = parseType("!Date"); assertTypeEquals(DATE_TYPE, typeNode); } public void testParseTypeViaStatic4() throws Exception { Node typeNode = parseType("boolean|string"); assertTypeEquals(createUnionType(BOOLEAN_TYPE, STRING_TYPE), typeNode); } public void testParseInvalidTypeViaStatic() throws Exception { Node typeNode = parseType("sometype.<anothertype"); assertNull(typeNode); } public void testParseInvalidTypeViaStatic2() throws Exception { Node typeNode = parseType(""); assertNull(typeNode); } public void testParseNamedType1() throws Exception { assertNull(parse("@type null", "Unexpected end of file")); } public void testParseNamedType2() throws Exception { JSDocInfo info = parse("@type null*/"); assertTypeEquals(NULL_TYPE, info.getType()); } public void testParseNamedType3() throws Exception { JSDocInfo info = parse("@type {string}*/"); assertTypeEquals(STRING_TYPE, info.getType()); } public void testParseNamedType4() throws Exception { // Multi-line @type. JSDocInfo info = parse("@type \n {string}*/"); assertTypeEquals(STRING_TYPE, info.getType()); } public void testParseNamedType5() throws Exception { JSDocInfo info = parse("@type {!goog.\nBar}*/"); assertTypeEquals( registry.createNamedType("goog.Bar", null, -1, -1), info.getType()); } public void testParseNamedType6() throws Exception { JSDocInfo info = parse("@type {!goog.\n * Bar.\n * Baz}*/"); assertTypeEquals( registry.createNamedType("goog.Bar.Baz", null, -1, -1), info.getType()); } public void testParseNamedTypeError1() throws Exception { // To avoid parsing ambiguities, type names must end in a '.' to // get the continuation behavior. parse("@type {!goog\n * .Bar} */", "Bad type annotation. expected closing }"); } public void testParseNamedTypeError2() throws Exception { parse("@type {!goog.\n * Bar\n * .Baz} */", "Bad type annotation. expected closing }"); } public void testTypedefType1() throws Exception { JSDocInfo info = parse("@typedef string */"); assertTrue(info.hasTypedefType()); assertTypeEquals(STRING_TYPE, info.getTypedefType()); } public void testTypedefType2() throws Exception { JSDocInfo info = parse("@typedef \n {string}*/"); assertTrue(info.hasTypedefType()); assertTypeEquals(STRING_TYPE, info.getTypedefType()); } public void testTypedefType3() throws Exception { JSDocInfo info = parse("@typedef \n {(string|number)}*/"); assertTrue(info.hasTypedefType()); assertTypeEquals( createUnionType(NUMBER_TYPE, STRING_TYPE), info.getTypedefType()); } public void testParseStringType1() throws Exception { assertTypeEquals(STRING_TYPE, parse("@type {string}*/").getType()); } public void testParseStringType2() throws Exception { assertTypeEquals(STRING_OBJECT_TYPE, parse("@type {!String}*/").getType()); } public void testParseBooleanType1() throws Exception { assertTypeEquals(BOOLEAN_TYPE, parse("@type {boolean}*/").getType()); } public void testParseBooleanType2() throws Exception { assertTypeEquals( BOOLEAN_OBJECT_TYPE, parse("@type {!Boolean}*/").getType()); } public void testParseNumberType1() throws Exception { assertTypeEquals(NUMBER_TYPE, parse("@type {number}*/").getType()); } public void testParseNumberType2() throws Exception { assertTypeEquals(NUMBER_OBJECT_TYPE, parse("@type {!Number}*/").getType()); } public void testParseNullType1() throws Exception { assertTypeEquals(NULL_TYPE, parse("@type {null}*/").getType()); } public void testParseNullType2() throws Exception { assertTypeEquals(NULL_TYPE, parse("@type {Null}*/").getType()); } public void testParseAllType1() throws Exception { testParseType("*"); } public void testParseAllType2() throws Exception { testParseType("*?", "*"); } public void testParseObjectType() throws Exception { assertTypeEquals(OBJECT_TYPE, parse("@type {!Object}*/").getType()); } public void testParseDateType() throws Exception { assertTypeEquals(DATE_TYPE, parse("@type {!Date}*/").getType()); } public void testParseFunctionType() throws Exception { assertTypeEquals( createNullableType(U2U_CONSTRUCTOR_TYPE), parse("@type {Function}*/").getType()); } public void testParseRegExpType() throws Exception { assertTypeEquals(REGEXP_TYPE, parse("@type {!RegExp}*/").getType()); } public void testParseErrorTypes() throws Exception { assertTypeEquals(ERROR_TYPE, parse("@type {!Error}*/").getType()); assertTypeEquals(URI_ERROR_TYPE, parse("@type {!URIError}*/").getType()); assertTypeEquals(EVAL_ERROR_TYPE, parse("@type {!EvalError}*/").getType()); assertTypeEquals(REFERENCE_ERROR_TYPE, parse("@type {!ReferenceError}*/").getType()); assertTypeEquals(TYPE_ERROR_TYPE, parse("@type {!TypeError}*/").getType()); assertTypeEquals( RANGE_ERROR_TYPE, parse("@type {!RangeError}*/").getType()); assertTypeEquals( SYNTAX_ERROR_TYPE, parse("@type {!SyntaxError}*/").getType()); } public void testParseUndefinedType1() throws Exception { assertTypeEquals(VOID_TYPE, parse("@type {undefined}*/").getType()); } public void testParseUndefinedType2() throws Exception { assertTypeEquals(VOID_TYPE, parse("@type {Undefined}*/").getType()); } public void testParseUndefinedType3() throws Exception { assertTypeEquals(VOID_TYPE, parse("@type {void}*/").getType()); } public void testParseParametrizedType1() throws Exception { JSDocInfo info = parse("@type !Array.<number> */"); assertTypeEquals(parameterize(ARRAY_TYPE, NUMBER_TYPE), info.getType()); } public void testParseParametrizedType2() throws Exception { JSDocInfo info = parse("@type {!Array.<number>}*/"); assertTypeEquals(parameterize(ARRAY_TYPE, NUMBER_TYPE), info.getType()); } public void testParseParametrizedType3() throws Exception { JSDocInfo info = parse("@type !Array.<(number,null)>*/"); assertTypeEquals( parameterize(ARRAY_TYPE, createUnionType(NUMBER_TYPE, NULL_TYPE)), info.getType()); } public void testParseParametrizedType4() throws Exception { JSDocInfo info = parse("@type {!Array.<(number|null)>}*/"); assertTypeEquals( parameterize(ARRAY_TYPE, createUnionType(NUMBER_TYPE, NULL_TYPE)), info.getType()); } public void testParseParametrizedType5() throws Exception { JSDocInfo info = parse("@type {!Array.<Array.<(number|null)>>}*/"); assertTypeEquals( parameterize(ARRAY_TYPE, createUnionType(NULL_TYPE, parameterize(ARRAY_TYPE, createUnionType(NUMBER_TYPE, NULL_TYPE)))), info.getType()); } public void testParseParametrizedType6() throws Exception { JSDocInfo info = parse("@type {!Array.<!Array.<(number|null)>>}*/"); assertTypeEquals( parameterize(ARRAY_TYPE, parameterize(ARRAY_TYPE, createUnionType(NUMBER_TYPE, NULL_TYPE))), info.getType()); } public void testParseParametrizedType7() throws Exception { JSDocInfo info = parse("@type {!Array.<function():Date>}*/"); assertTypeEquals( parameterize(ARRAY_TYPE, registry.createFunctionType( createUnionType(DATE_TYPE, NULL_TYPE))), info.getType()); } public void testParseParametrizedType8() throws Exception { JSDocInfo info = parse("@type {!Array.<function():!Date>}*/"); assertTypeEquals( parameterize(ARRAY_TYPE, registry.createFunctionType(DATE_TYPE)), info.getType()); } public void testParseParametrizedType9() throws Exception { JSDocInfo info = parse("@type {!Array.<Date|number>}*/"); assertTypeEquals( parameterize(ARRAY_TYPE, createUnionType(DATE_TYPE, NUMBER_TYPE, NULL_TYPE)), info.getType()); } public void testParseParametrizedType10() throws Exception { JSDocInfo info = parse("@type {!Array.<Date|number|boolean>}*/"); assertTypeEquals( parameterize(ARRAY_TYPE, createUnionType(DATE_TYPE, NUMBER_TYPE, BOOLEAN_TYPE, NULL_TYPE)), info.getType()); } public void testParseParameterizedType11() throws Exception { JSDocInfo info = parse("@type {!Object.<number>}*/"); assertTypeEquals( parameterize(OBJECT_TYPE, NUMBER_TYPE), info.getType()); assertParameterTypeEquals(NUMBER_TYPE, info.getType()); } public void testParseParameterizedType12() throws Exception { JSDocInfo info = parse("@type {!Object.<string,number>}*/"); assertTypeEquals( parameterize(OBJECT_TYPE, NUMBER_TYPE), info.getType()); assertParameterTypeEquals(NUMBER_TYPE, info.getType()); assertIndexTypeEquals(STRING_TYPE, info.getType()); } public void testParseParametrizedType13() throws Exception { JSDocInfo info = parse("@type !Array.<?> */"); assertTypeEquals(parameterize(ARRAY_TYPE, UNKNOWN_TYPE), info.getType()); } public void testParseUnionType1() throws Exception { JSDocInfo info = parse("@type {(boolean,null)}*/"); assertTypeEquals(createUnionType(BOOLEAN_TYPE, NULL_TYPE), info.getType()); } public void testParseUnionType2() throws Exception { JSDocInfo info = parse("@type {boolean|null}*/"); assertTypeEquals(createUnionType(BOOLEAN_TYPE, NULL_TYPE), info.getType()); } public void testParseUnionType3() throws Exception { JSDocInfo info = parse("@type {boolean||null}*/"); assertTypeEquals(createUnionType(BOOLEAN_TYPE, NULL_TYPE), info.getType()); } public void testParseUnionType4() throws Exception { JSDocInfo info = parse("@type {(Array.<boolean>,null)}*/"); assertTypeEquals(createUnionType( parameterize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType()); } public void testParseUnionType5() throws Exception { JSDocInfo info = parse("@type {(null, Array.<boolean>)}*/"); assertTypeEquals(createUnionType( parameterize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType()); } public void testParseUnionType6() throws Exception { JSDocInfo info = parse("@type {Array.<boolean>|null}*/"); assertTypeEquals(createUnionType( parameterize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType()); } public void testParseUnionType7() throws Exception { JSDocInfo info = parse("@type {null|Array.<boolean>}*/"); assertTypeEquals(createUnionType( parameterize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType()); } public void testParseUnionType8() throws Exception { JSDocInfo info = parse("@type {null||Array.<boolean>}*/"); assertTypeEquals(createUnionType( parameterize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType()); } public void testParseUnionType9() throws Exception { JSDocInfo info = parse("@type {Array.<boolean>||null}*/"); assertTypeEquals(createUnionType( parameterize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType()); } public void testParseUnionType10() throws Exception { parse("@type {string|}*/", "Bad type annotation. type not recognized due to syntax error"); } public void testParseUnionType11() throws Exception { parse("@type {(string,)}*/", "Bad type annotation. type not recognized due to syntax error"); } public void testParseUnionType12() throws Exception { parse("@type {()}*/", "Bad type annotation. type not recognized due to syntax error"); } public void testParseUnionType13() throws Exception { testParseType( "(function(this:Date),function(this:String):number)", "Function"); } public void testParseUnionType14() throws Exception { testParseType( "(function(...[function(number):boolean]):number)|" + "function(this:String, string):number", "Function"); } public void testParseUnionType15() throws Exception { testParseType("*|number", "*"); } public void testParseUnionType16() throws Exception { testParseType("number|*", "*"); } public void testParseUnionType17() throws Exception { testParseType("string|number|*", "*"); } public void testParseUnionType18() throws Exception { testParseType("(string,*,number)", "*"); } public void testParseUnionTypeError1() throws Exception { parse("@type {(string,|number)} */", "Bad type annotation. type not recognized due to syntax error"); } public void testParseUnknownType1() throws Exception { testParseType("?"); } public void testParseUnknownType2() throws Exception { testParseType("(?|number)", "?"); } public void testParseUnknownType3() throws Exception { testParseType("(number|?)", "?"); } public void testParseFunctionalType1() throws Exception { testParseType("function (): number"); } public void testParseFunctionalType2() throws Exception { testParseType("function (number, string): boolean"); } public void testParseFunctionalType3() throws Exception { testParseType( "function(this:Array)", "function (this:Array): ?"); } public void testParseFunctionalType4() throws Exception { testParseType("function (...[number]): boolean"); } public void testParseFunctionalType5() throws Exception { testParseType("function (number, ...[string]): boolean"); } public void testParseFunctionalType6() throws Exception { testParseType( "function (this:Date, number): (boolean|number|string)"); } public void testParseFunctionalType7() throws Exception { testParseType("function()", "function (): ?"); } public void testParseFunctionalType8() throws Exception { testParseType( "function(this:Array,...[boolean])", "function (this:Array, ...[boolean]): ?"); } public void testParseFunctionalType9() throws Exception { testParseType( "function(this:Array,!Date,...[boolean?])", "function (this:Array, Date, ...[(boolean|null)]): ?"); } public void testParseFunctionalType10() throws Exception { testParseType( "function(...[Object?]):boolean?", "function (...[(Object|null)]): (boolean|null)"); } public void testParseFunctionalType11() throws Exception { testParseType( "function(...[[number]]):[number?]", "function (...[Array]): Array"); } public void testParseFunctionalType12() throws Exception { testParseType( "function(...)", "function (...[?]): ?"); } public void testParseFunctionalType13() throws Exception { testParseType( "function(...): void", "function (...[?]): undefined"); } public void testParseFunctionalType14() throws Exception { testParseType("function (*, string, number): boolean"); } public void testParseFunctionalType15() throws Exception { testParseType("function (?, string): boolean"); } public void testParseFunctionalType16() throws Exception { testParseType("function (string, ?): ?"); } public void testParseFunctionalType17() throws Exception { testParseType("(function (?): ?|number)"); } public void testParseFunctionalType18() throws Exception { testParseType("function (?): (?|number)", "function (?): ?"); } public void testParseFunctionalType19() throws Exception { testParseType( "function(...[?]): void", "function (...[?]): undefined"); } public void testStructuralConstructor() throws Exception { JSType type = testParseType( "function (new:Object)", "function (new:Object): ?"); assertTrue(type.isConstructor()); assertFalse(type.isNominalConstructor()); } public void testNominalConstructor() throws Exception { ObjectType type = testParseType("Array", "(Array|null)").dereference(); assertTrue(type.getConstructor().isNominalConstructor()); } public void testBug1419535() throws Exception { parse("@type {function(Object, string, *)?} */"); parse("@type {function(Object, string, *)|null} */"); } public void testIssue477() throws Exception { parse("@type function */", "Bad type annotation. missing opening ("); } public void testMalformedThisAnnotation() throws Exception { parse("@this */", "Bad type annotation. type not recognized due to syntax error"); } public void testParseFunctionalTypeError1() throws Exception { parse("@type {function number):string}*/", "Bad type annotation. missing opening ("); } public void testParseFunctionalTypeError2() throws Exception { parse("@type {function( number}*/", "Bad type annotation. missing closing )"); } public void testParseFunctionalTypeError3() throws Exception { parse("@type {function(...[number], string)}*/", "Bad type annotation. variable length argument must be last"); } public void testParseFunctionalTypeError4() throws Exception { parse("@type {function(string, ...[number], boolean):string}*/", "Bad type annotation. variable length argument must be last"); } public void testParseFunctionalTypeError5() throws Exception { parse("@type {function (thi:Array)}*/", "Bad type annotation. missing closing )"); } public void testParseFunctionalTypeError6() throws Exception { resolve(parse("@type {function (this:number)}*/").getType(), "this type must be an object type"); } public void testParseFunctionalTypeError7() throws Exception { parse("@type {function(...[number)}*/", "Bad type annotation. missing closing ]"); } public void testParseFunctionalTypeError8() throws Exception { parse("@type {function(...number])}*/", "Bad type annotation. missing opening ["); } public void testParseFunctionalTypeError9() throws Exception { parse("@type {function (new:Array, this:Object)} */", "Bad type annotation. missing closing )"); } public void testParseFunctionalTypeError10() throws Exception { parse("@type {function (this:Array, new:Object)} */", "Bad type annotation. missing closing )"); } public void testParseFunctionalTypeError11() throws Exception { parse("@type {function (Array, new:Object)} */", "Bad type annotation. missing closing )"); } public void testParseFunctionalTypeError12() throws Exception { resolve(parse("@type {function (new:number)}*/").getType(), "constructed type must be an object type"); } public void testParseArrayType1() throws Exception { testParseType("[number]", "Array"); } public void testParseArrayType2() throws Exception { testParseType("[(number,boolean,[Object?])]", "Array"); } public void testParseArrayType3() throws Exception { testParseType("[[number],[string]]?", "(Array|null)"); } public void testParseArrayTypeError1() throws Exception { parse("@type {[number}*/", "Bad type annotation. missing closing ]"); } public void testParseArrayTypeError2() throws Exception { parse("@type {number]}*/", "Bad type annotation. expected closing }"); } public void testParseArrayTypeError3() throws Exception { parse("@type {[(number,boolean,Object?])]}*/", "Bad type annotation. missing closing )"); } public void testParseArrayTypeError4() throws Exception { parse("@type {(number,boolean,[Object?)]}*/", "Bad type annotation. missing closing ]"); } private JSType testParseType(String type) throws Exception { return testParseType(type, type); } private JSType testParseType( String type, String typeExpected) throws Exception { JSDocInfo info = parse("@type {" + type + "}*/"); assertNotNull(info); assertTrue(info.hasType()); JSType actual = resolve(info.getType()); assertEquals(typeExpected, actual.toString()); return actual; } public void testParseNullableModifiers1() throws Exception { JSDocInfo info = parse("@type {string?}*/"); assertTypeEquals(createNullableType(STRING_TYPE), info.getType()); } public void testParseNullableModifiers2() throws Exception { JSDocInfo info = parse("@type {!Array.<string?>}*/"); assertTypeEquals( parameterize(ARRAY_TYPE, createUnionType(STRING_TYPE, NULL_TYPE)), info.getType()); } public void testParseNullableModifiers3() throws Exception { JSDocInfo info = parse("@type {Array.<boolean>?}*/"); assertTypeEquals( createNullableType(parameterize(ARRAY_TYPE, BOOLEAN_TYPE)), info.getType()); } public void testParseNullableModifiers4() throws Exception { JSDocInfo info = parse("@type {(string,boolean)?}*/"); assertTypeEquals( createNullableType(createUnionType(STRING_TYPE, BOOLEAN_TYPE)), info.getType()); } public void testParseNullableModifiers5() throws Exception { JSDocInfo info = parse("@type {(string?,boolean)}*/"); assertTypeEquals( createUnionType(createNullableType(STRING_TYPE), BOOLEAN_TYPE), info.getType()); } public void testParseNullableModifiers6() throws Exception { JSDocInfo info = parse("@type {(string,boolean?)}*/"); assertTypeEquals( createUnionType(STRING_TYPE, createNullableType(BOOLEAN_TYPE)), info.getType()); } public void testParseNullableModifiers7() throws Exception { JSDocInfo info = parse("@type {string?|boolean}*/"); assertTypeEquals( createUnionType(createNullableType(STRING_TYPE), BOOLEAN_TYPE), info.getType()); } public void testParseNullableModifiers8() throws Exception { JSDocInfo info = parse("@type {string|boolean?}*/"); assertTypeEquals( createUnionType(STRING_TYPE, createNullableType(BOOLEAN_TYPE)), info.getType()); } public void testParseNullableModifiers9() throws Exception { JSDocInfo info = parse("@type {foo.Hello.World?}*/"); assertTypeEquals( createNullableType( registry.createNamedType( "foo.Hello.World", null, -1, -1)), info.getType()); } public void testParseOptionalModifier() throws Exception { JSDocInfo info = parse("@type {function(number=)}*/"); assertTypeEquals( registry.createFunctionType( UNKNOWN_TYPE, registry.createOptionalParameters(NUMBER_TYPE)), info.getType()); } public void testParseNewline1() throws Exception { JSDocInfo info = parse("@type {string\n* }\n*/"); assertTypeEquals(STRING_TYPE, info.getType()); } public void testParseNewline2() throws Exception { JSDocInfo info = parse("@type !Array.<\n* number\n* > */"); assertTypeEquals(parameterize(ARRAY_TYPE, NUMBER_TYPE), info.getType()); } public void testParseNewline3() throws Exception { JSDocInfo info = parse("@type !Array.<(number,\n* null)>*/"); assertTypeEquals( parameterize(ARRAY_TYPE, createUnionType(NUMBER_TYPE, NULL_TYPE)), info.getType()); } public void testParseNewline4() throws Exception { JSDocInfo info = parse("@type !Array.<(number|\n* null)>*/"); assertTypeEquals( parameterize(ARRAY_TYPE, createUnionType(NUMBER_TYPE, NULL_TYPE)), info.getType()); } public void testParseNewline5() throws Exception { JSDocInfo info = parse("@type !Array.<function(\n* )\n* :\n* Date>*/"); assertTypeEquals( parameterize(ARRAY_TYPE, registry.createFunctionType( createUnionType(DATE_TYPE, NULL_TYPE))), info.getType()); } public void testParseReturnType1() throws Exception { JSDocInfo info = parse("@return {null|string|Array.<boolean>}*/"); assertTypeEquals( createUnionType(parameterize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE, STRING_TYPE), info.getReturnType()); } public void testParseReturnType2() throws Exception { JSDocInfo info = parse("@returns {null|(string,Array.<boolean>)}*/"); assertTypeEquals( createUnionType(parameterize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE, STRING_TYPE), info.getReturnType()); } public void testParseReturnType3() throws Exception { JSDocInfo info = parse("@return {((null||Array.<boolean>,string),boolean)}*/"); assertTypeEquals( createUnionType(parameterize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE, STRING_TYPE, BOOLEAN_TYPE), info.getReturnType()); } public void testParseThisType1() throws Exception { JSDocInfo info = parse("@this {goog.foo.Bar}*/"); assertTypeEquals( registry.createNamedType("goog.foo.Bar", null, -1, -1), info.getThisType()); } public void testParseThisType2() throws Exception { JSDocInfo info = parse("@this goog.foo.Bar*/"); assertTypeEquals( registry.createNamedType("goog.foo.Bar", null, -1, -1), info.getThisType()); } public void testParseThisType3() throws Exception { parse("@type {number}\n@this goog.foo.Bar*/", "Bad type annotation. type annotation incompatible " + "with other annotations"); } public void testParseThisType4() throws Exception { resolve(parse("@this number*/").getThisType(), "@this must specify an object type"); } public void testParseThisType5() throws Exception { parse("@this {Date|Error}*/"); } public void testParseThisType6() throws Exception { resolve(parse("@this {Date|number}*/").getThisType(), "@this must specify an object type"); } public void testParseParam1() throws Exception { JSDocInfo info = parse("@param {number} index*/"); assertEquals(1, info.getParameterCount()); assertTypeEquals(NUMBER_TYPE, info.getParameterType("index")); } public void testParseParam2() throws Exception { JSDocInfo info = parse("@param index*/"); assertEquals(1, info.getParameterCount()); assertEquals(null, info.getParameterType("index")); } public void testParseParam3() throws Exception { JSDocInfo info = parse("@param {number} index useful comments*/"); assertEquals(1, info.getParameterCount()); assertTypeEquals(NUMBER_TYPE, info.getParameterType("index")); } public void testParseParam4() throws Exception { JSDocInfo info = parse("@param index useful comments*/"); assertEquals(1, info.getParameterCount()); assertEquals(null, info.getParameterType("index")); } public void testParseParam5() throws Exception { // Test for multi-line @param. JSDocInfo info = parse("@param {number} \n index */"); assertEquals(1, info.getParameterCount()); assertTypeEquals(NUMBER_TYPE, info.getParameterType("index")); } public void testParseParam6() throws Exception { // Test for multi-line @param. JSDocInfo info = parse("@param {number} \n * index */"); assertEquals(1, info.getParameterCount()); assertTypeEquals(NUMBER_TYPE, info.getParameterType("index")); } public void testParseParam7() throws Exception { // Optional @param JSDocInfo info = parse("@param {number=} index */"); assertTypeEquals( registry.createOptionalType(NUMBER_TYPE), info.getParameterType("index")); } public void testParseParam8() throws Exception { // Var args @param JSDocInfo info = parse("@param {...number} index */"); assertTypeEquals( registry.createOptionalType(NUMBER_TYPE), info.getParameterType("index")); } public void testParseParam9() throws Exception { parse("@param {...number=} index */", "Bad type annotation. expected closing }", "Bad type annotation. expecting a variable name in a @param tag"); } public void testParseParam10() throws Exception { parse("@param {...number index */", "Bad type annotation. expected closing }"); } public void testParseParam11() throws Exception { parse("@param {number= index */", "Bad type annotation. expected closing }"); } public void testParseParam12() throws Exception { JSDocInfo info = parse("@param {...number|string} index */"); assertTypeEquals( registry.createOptionalType( registry.createUnionType(STRING_TYPE, NUMBER_TYPE)), info.getParameterType("index")); } public void testParseParam13() throws Exception { JSDocInfo info = parse("@param {...(number|string)} index */"); assertTypeEquals( registry.createOptionalType( registry.createUnionType(STRING_TYPE, NUMBER_TYPE)), info.getParameterType("index")); } public void testParseParam14() throws Exception { JSDocInfo info = parse("@param {string} [index] */"); assertEquals(1, info.getParameterCount()); assertTypeEquals( registry.createOptionalType(STRING_TYPE), info.getParameterType("index")); } public void testParseParam15() throws Exception { JSDocInfo info = parse("@param {string} [index */", "Bad type annotation. missing closing ]"); assertEquals(1, info.getParameterCount()); assertTypeEquals(STRING_TYPE, info.getParameterType("index")); } public void testParseParam16() throws Exception { JSDocInfo info = parse("@param {string} index] */"); assertEquals(1, info.getParameterCount()); assertTypeEquals(STRING_TYPE, info.getParameterType("index")); } public void testParseParam17() throws Exception { JSDocInfo info = parse("@param {string=} [index] */"); assertEquals(1, info.getParameterCount()); assertTypeEquals( registry.createOptionalType(STRING_TYPE), info.getParameterType("index")); } public void testParseParam18() throws Exception { JSDocInfo info = parse("@param {...string} [index] */"); assertEquals(1, info.getParameterCount()); assertTypeEquals( registry.createOptionalType(STRING_TYPE), info.getParameterType("index")); } public void testParseParam19() throws Exception { JSDocInfo info = parse("@param {...} [index] */"); assertEquals(1, info.getParameterCount()); assertTypeEquals( registry.createOptionalType(UNKNOWN_TYPE), info.getParameterType("index")); assertTrue(info.getParameterType("index").isVarArgs()); } public void testParseParam20() throws Exception { JSDocInfo info = parse("@param {?=} index */"); assertEquals(1, info.getParameterCount()); assertTypeEquals( UNKNOWN_TYPE, info.getParameterType("index")); } public void testParseParam21() throws Exception { JSDocInfo info = parse("@param {...?} index */"); assertEquals(1, info.getParameterCount()); assertTypeEquals( UNKNOWN_TYPE, info.getParameterType("index")); assertTrue(info.getParameterType("index").isVarArgs()); } public void testParseThrows1() throws Exception { JSDocInfo info = parse("@throws {number} Some number */"); assertEquals(1, info.getThrownTypes().size()); assertTypeEquals(NUMBER_TYPE, info.getThrownTypes().get(0)); } public void testParseThrows2() throws Exception { JSDocInfo info = parse("@throws {number} Some number\n " + "*@throws {String} A string */"); assertEquals(2, info.getThrownTypes().size()); assertTypeEquals(NUMBER_TYPE, info.getThrownTypes().get(0)); } public void testParseRecordType1() throws Exception { parseFull("/** @param {{x}} n\n*/"); } public void testParseRecordType2() throws Exception { parseFull("/** @param {{z, y}} n\n*/"); } public void testParseRecordType3() throws Exception { parseFull("/** @param {{z, y, x, q, hello, thisisatest}} n\n*/"); } public void testParseRecordType4() throws Exception { parseFull("/** @param {{a, 'a', 'hello', 2, this, do, while, for}} n\n*/"); } public void testParseRecordType5() throws Exception { parseFull("/** @param {{x : hello}} n\n*/"); } public void testParseRecordType6() throws Exception { parseFull("/** @param {{'x' : hello}} n\n*/"); } public void testParseRecordType7() throws Exception { parseFull("/** @param {{'x' : !hello}} n\n*/"); } public void testParseRecordType8() throws Exception { parseFull("/** @param {{'x' : !hello, y : bar}} n\n*/"); } public void testParseRecordType9() throws Exception { parseFull("/** @param {{'x' : !hello, y : {z : bar, 3 : meh}}} n\n*/"); } public void testParseRecordType10() throws Exception { parseFull("/** @param {{__proto__ : moo}} n\n*/"); } public void testParseRecordType11() throws Exception { parseFull("/** @param {{a : b} n\n*/", "Bad type annotation. expected closing }"); } public void testParseRecordType12() throws Exception { parseFull("/** @param {{!hello : hey}} n\n*/", "Bad type annotation. type not recognized due to syntax error"); } public void testParseRecordType13() throws Exception { parseFull("/** @param {{x}|number} n\n*/"); } public void testParseRecordType14() throws Exception { parseFull("/** @param {{x : y}|number} n\n*/"); } public void testParseRecordType15() throws Exception { parseFull("/** @param {{'x' : y}|number} n\n*/"); } public void testParseRecordType16() throws Exception { parseFull("/** @param {{x, y}|number} n\n*/"); } public void testParseRecordType17() throws Exception { parseFull("/** @param {{x : hello, 'y'}|number} n\n*/"); } public void testParseRecordType18() throws Exception { parseFull("/** @param {number|{x : hello, 'y'}} n\n*/"); } public void testParseRecordType19() throws Exception { parseFull("/** @param {?{x : hello, 'y'}} n\n*/"); } public void testParseRecordType20() throws Exception { parseFull("/** @param {!{x : hello, 'y'}} n\n*/"); } public void testParseRecordType21() throws Exception { parseFull("/** @param {{x : hello, 'y'}|boolean} n\n*/"); } public void testParseRecordType22() throws Exception { parseFull("/** @param {{x : hello, 'y'}|function()} n\n*/"); } public void testParseRecordType23() throws Exception { parseFull("/** @param {{x : function(), 'y'}|function()} n\n*/"); } public void testParseParamError1() throws Exception { parseFull("/** @param\n*/", "Bad type annotation. expecting a variable name in a @param tag"); } public void testParseParamError2() throws Exception { parseFull("/** @param {Number}*/", "Bad type annotation. expecting a variable name in a @param tag"); } public void testParseParamError3() throws Exception { parseFull("/** @param {Number}\n*/", "Bad type annotation. expecting a variable name in a @param tag"); } public void testParseParamError4() throws Exception { parseFull("/** @param {Number}\n* * num */", "Bad type annotation. expecting a variable name in a @param tag"); } public void testParseParamError5() throws Exception { parse("@param {number} x \n * @param {string} x */", "Bad type annotation. duplicate variable name \"x\""); } public void testParseExtends1() throws Exception { assertTypeEquals(STRING_OBJECT_TYPE, parse("@extends String*/").getBaseType()); } public void testParseExtends2() throws Exception { JSDocInfo info = parse("@extends com.google.Foo.Bar.Hello.World*/"); assertTypeEquals( registry.createNamedType( "com.google.Foo.Bar.Hello.World", null, -1, -1), info.getBaseType()); } public void testParseExtendsGenerics() throws Exception { JSDocInfo info = parse("@extends com.google.Foo.Bar.Hello.World.<Boolean,number>*/"); assertTypeEquals( registry.createNamedType( "com.google.Foo.Bar.Hello.World", null, -1, -1), info.getBaseType()); } public void testParseImplementsGenerics() throws Exception { // we ignore things inside <> for now List<JSTypeExpression> interfaces = parse("@implements {SomeInterface.<*>} */") .getImplementedInterfaces(); assertEquals(1, interfaces.size()); assertTypeEquals(registry.createNamedType("SomeInterface", null, -1, -1), interfaces.get(0)); } public void testParseExtends4() throws Exception { assertTypeEquals(STRING_OBJECT_TYPE, parse("@extends {String}*/").getBaseType()); } public void testParseExtends5() throws Exception { assertTypeEquals(STRING_OBJECT_TYPE, parse("@extends {String*/", "Bad type annotation. expected closing }").getBaseType()); } public void testParseExtends6() throws Exception { // Multi-line extends assertTypeEquals(STRING_OBJECT_TYPE, parse("@extends \n * {String}*/").getBaseType()); } public void testParseExtendsInvalidName() throws Exception { // This looks bad, but for the time being it should be OK, as // we will not find a type with this name in the JS parsed tree. // If this is fixed in the future, change this test to check for a // warning/error message. assertTypeEquals( registry.createNamedType("some_++#%$%_UglyString", null, -1, -1), parse("@extends {some_++#%$%_UglyString} */").getBaseType()); } public void testParseExtendsNullable1() throws Exception { parse("@extends {Base?} */", "Bad type annotation. expected closing }"); } public void testParseExtendsNullable2() throws Exception { parse("@extends Base? */", "Bad type annotation. expected end of line or comment"); } public void testParseEnum1() throws Exception { assertTypeEquals(NUMBER_TYPE, parse("@enum*/").getEnumParameterType()); } public void testParseEnum2() throws Exception { assertTypeEquals(STRING_TYPE, parse("@enum {string}*/").getEnumParameterType()); } public void testParseEnum3() throws Exception { assertTypeEquals(STRING_TYPE, parse("@enum string*/").getEnumParameterType()); } public void testParseDesc1() throws Exception { assertEquals("hello world!", parse("@desc hello world!*/").getDescription()); } public void testParseDesc2() throws Exception { assertEquals("hello world!", parse("@desc hello world!\n*/").getDescription()); } public void testParseDesc3() throws Exception { assertEquals("", parse("@desc*/").getDescription()); } public void testParseDesc4() throws Exception { assertEquals("", parse("@desc\n*/").getDescription()); } public void testParseDesc5() throws Exception { assertEquals("hello world!", parse("@desc hello\nworld!\n*/").getDescription()); } public void testParseDesc6() throws Exception { assertEquals("hello world!", parse("@desc hello\n* world!\n*/").getDescription()); } public void testParseDesc7() throws Exception { assertEquals("a b c", parse("@desc a\n\nb\nc*/").getDescription()); } public void testParseDesc8() throws Exception { assertEquals("a b c d", parse("@desc a\n *b\n\n *c\n\nd*/").getDescription()); } public void testParseDesc9() throws Exception { String comment = "@desc\n.\n,\n{\n)\n}\n|\n.<\n>\n<\n?\n~\n+\n-\n;\n:\n*/"; assertEquals(". , { ) } | .< > < ? ~ + - ; :", parse(comment).getDescription()); } public void testParseDesc10() throws Exception { String comment = "@desc\n?\n?\n?\n?*/"; assertEquals("? ? ? ?", parse(comment).getDescription()); } public void testParseDesc11() throws Exception { String comment = "@desc :[]*/"; assertEquals(":[]", parse(comment).getDescription()); } public void testParseDesc12() throws Exception { String comment = "@desc\n:\n[\n]\n...*/"; assertEquals(": [ ] ...", parse(comment).getDescription()); } public void testParseMeaning1() throws Exception { assertEquals("tigers", parse("@meaning tigers */").getMeaning()); } public void testParseMeaning2() throws Exception { assertEquals("tigers and lions and bears", parse("@meaning tigers\n * and lions\n * and bears */").getMeaning()); } public void testParseMeaning3() throws Exception { JSDocInfo info = parse("@meaning tigers\n * and lions\n * @desc and bears */"); assertEquals("tigers and lions", info.getMeaning()); assertEquals("and bears", info.getDescription()); } public void testParseMeaning4() throws Exception { parse("@meaning tigers\n * @meaning and lions */", "extra @meaning tag"); } public void testParseLends1() throws Exception { JSDocInfo info = parse("@lends {name} */"); assertEquals("name", info.getLendsName()); } public void testParseLends2() throws Exception { JSDocInfo info = parse("@lends foo.bar */"); assertEquals("foo.bar", info.getLendsName()); } public void testParseLends3() throws Exception { parse("@lends {name */", "Bad type annotation. expected closing }"); } public void testParseLends4() throws Exception { parse("@lends {} */", "Bad type annotation. missing object name in @lends tag"); } public void testParseLends5() throws Exception { parse("@lends } */", "Bad type annotation. missing object name in @lends tag"); } public void testParseLends6() throws Exception { parse("@lends {string} \n * @lends {string} */", "Bad type annotation. @lends tag incompatible with other annotations"); } public void testParseLends7() throws Exception { parse("@type {string} \n * @lends {string} */", "Bad type annotation. @lends tag incompatible with other annotations"); } public void testParsePreserve() throws Exception { Node node = new Node(1); this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode(); String comment = "@preserve Foo\nBar\n\nBaz*/"; parse(comment); assertEquals(" Foo\nBar\n\nBaz", node.getJSDocInfo().getLicense()); } public void testParseLicense() throws Exception { Node node = new Node(1); this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode(); String comment = "@license Foo\nBar\n\nBaz*/"; parse(comment); assertEquals(" Foo\nBar\n\nBaz", node.getJSDocInfo().getLicense()); } public void testParseLicenseAscii() throws Exception { Node node = new Node(1); this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode(); String comment = "@license Foo\n * Bar\n\n Baz*/"; parse(comment); assertEquals(" Foo\n Bar\n\n Baz", node.getJSDocInfo().getLicense()); } public void testParseLicenseWithAnnotation() throws Exception { Node node = new Node(1); this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode(); String comment = "@license Foo \n * @author Charlie Brown */"; parse(comment); assertEquals(" Foo \n @author Charlie Brown ", node.getJSDocInfo().getLicense()); } public void testParseDefine1() throws Exception { assertTypeEquals(STRING_TYPE, parse("@define {string}*/").getType()); } public void testParseDefine2() throws Exception { assertTypeEquals(STRING_TYPE, parse("@define {string*/", "Bad type annotation. expected closing }").getType()); } public void testParseDefine3() throws Exception { JSDocInfo info = parse("@define {boolean}*/"); assertTrue(info.isConstant()); assertTrue(info.isDefine()); assertTypeEquals(BOOLEAN_TYPE, info.getType()); } public void testParseDefine4() throws Exception { assertTypeEquals(NUMBER_TYPE, parse("@define {number}*/").getType()); } public void testParseDefine5() throws Exception { assertTypeEquals(createUnionType(NUMBER_TYPE, BOOLEAN_TYPE), parse("@define {number|boolean}*/").getType()); } public void testParseDefineErrors1() throws Exception { parse("@enum {string}\n @define {string} */", "conflicting @define tag"); } public void testParseDefineErrors2() throws Exception { parse("@define {string}\n @enum {string} */", "Bad type annotation. " + "type annotation incompatible with other annotations"); } public void testParseDefineErrors3() throws Exception { parse("@const\n @define {string} */", "conflicting @define tag"); } public void testParseDefineErrors4() throws Exception { parse("@type string \n @define {string} */", "conflicting @define tag"); } public void testParseDefineErrors5() throws Exception { parse("@return {string}\n @define {string} */", "conflicting @define tag"); } public void testParseDefineErrors7() throws Exception { parse("@define {string}\n @const */", "conflicting @const tag"); } public void testParseDefineErrors8() throws Exception { parse("@define {string}\n @type string */", "Bad type annotation. " + "type annotation incompatible with other annotations"); } public void testParseNoCheck1() throws Exception { assertTrue(parse("@notypecheck*/").isNoTypeCheck()); } public void testParseNoCheck2() throws Exception { parse("@notypecheck\n@notypecheck*/", "extra @notypecheck tag"); } public void testParseOverride1() throws Exception { assertTrue(parse("@override*/").isOverride()); } public void testParseOverride2() throws Exception { parse("@override\n@override*/", "Bad type annotation. extra @override/@inheritDoc tag"); } public void testParseInheritDoc1() throws Exception { assertTrue(parse("@inheritDoc*/").isOverride()); } public void testParseInheritDoc2() throws Exception { parse("@override\n@inheritDoc*/", "Bad type annotation. extra @override/@inheritDoc tag"); } public void testParseInheritDoc3() throws Exception { parse("@inheritDoc\n@inheritDoc*/", "Bad type annotation. extra @override/@inheritDoc tag"); } public void testParseNoAlias1() throws Exception { assertTrue(parse("@noalias*/").isNoAlias()); } public void testParseNoAlias2() throws Exception { parse("@noalias\n@noalias*/", "extra @noalias tag"); } public void testParseDeprecated1() throws Exception { assertTrue(parse("@deprecated*/").isDeprecated()); } public void testParseDeprecated2() throws Exception { parse("@deprecated\n@deprecated*/", "extra @deprecated tag"); } public void testParseExport1() throws Exception { assertTrue(parse("@export*/").isExport()); } public void testParseExport2() throws Exception { parse("@export\n@export*/", "extra @export tag"); } public void testParseExpose1() throws Exception { assertTrue(parse("@expose*/").isExpose()); } public void testParseExpose2() throws Exception { parse("@expose\n@expose*/", "extra @expose tag"); } public void testParseExterns1() throws Exception { assertTrue(parseFileOverview("@externs*/").isExterns()); } public void testParseExterns2() throws Exception { parseFileOverview("@externs\n@externs*/", "extra @externs tag"); } public void testParseExterns3() throws Exception { assertNull(parse("@externs*/")); } public void testParseJavaDispatch1() throws Exception { assertTrue(parse("@javadispatch*/").isJavaDispatch()); } public void testParseJavaDispatch2() throws Exception { parse("@javadispatch\n@javadispatch*/", "extra @javadispatch tag"); } public void testParseJavaDispatch3() throws Exception { assertNull(parseFileOverview("@javadispatch*/")); } public void testParseNoCompile1() throws Exception { assertTrue(parseFileOverview("@nocompile*/").isNoCompile()); } public void testParseNoCompile2() throws Exception { parseFileOverview("@nocompile\n@nocompile*/", "extra @nocompile tag"); } public void testBugAnnotation() throws Exception { parse("@bug */"); } public void testDescriptionAnnotation() throws Exception { parse("@description */"); } public void testRegression1() throws Exception { String comment = " * @param {number} index the index of blah\n" + " * @return {boolean} whatever\n" + " * @private\n" + " */"; JSDocInfo info = parse(comment); assertEquals(1, info.getParameterCount()); assertTypeEquals(NUMBER_TYPE, info.getParameterType("index")); assertTypeEquals(BOOLEAN_TYPE, info.getReturnType()); assertEquals(Visibility.PRIVATE, info.getVisibility()); } public void testRegression2() throws Exception { String comment = " * @return {boolean} whatever\n" + " * but important\n" + " *\n" + " * @param {number} index the index of blah\n" + " * some more comments here\n" + " * @param name the name of the guy\n" + " *\n" + " * @protected\n" + " */"; JSDocInfo info = parse(comment); assertEquals(2, info.getParameterCount()); assertTypeEquals(NUMBER_TYPE, info.getParameterType("index")); assertEquals(null, info.getParameterType("name")); assertTypeEquals(BOOLEAN_TYPE, info.getReturnType()); assertEquals(Visibility.PROTECTED, info.getVisibility()); } public void testRegression3() throws Exception { String comment = " * @param mediaTag this specified whether the @media tag is ....\n" + " *\n" + "\n" + "@public\n" + " *\n" + "\n" + " **********\n" + " * @final\n" + " */"; JSDocInfo info = parse(comment); assertEquals(1, info.getParameterCount()); assertEquals(null, info.getParameterType("mediaTag")); assertEquals(Visibility.PUBLIC, info.getVisibility()); assertTrue(info.isConstant()); } public void testRegression4() throws Exception { String comment = " * @const\n" + " * @hidden\n" + " * @preserveTry\n" + " * @constructor\n" + " */"; JSDocInfo info = parse(comment); assertTrue(info.isConstant()); assertFalse(info.isDefine()); assertTrue(info.isConstructor()); assertTrue(info.isHidden()); assertTrue(info.shouldPreserveTry()); } public void testRegression5() throws Exception { String comment = "@const\n@enum {string}\n@public*/"; JSDocInfo info = parse(comment); assertTrue(info.isConstant()); assertFalse(info.isDefine()); assertTypeEquals(STRING_TYPE, info.getEnumParameterType()); assertEquals(Visibility.PUBLIC, info.getVisibility()); } public void testRegression6() throws Exception { String comment = "@hidden\n@enum\n@public*/"; JSDocInfo info = parse(comment); assertTrue(info.isHidden()); assertTypeEquals(NUMBER_TYPE, info.getEnumParameterType()); assertEquals(Visibility.PUBLIC, info.getVisibility()); } public void testRegression7() throws Exception { String comment = " * @desc description here\n" + " * @param {boolean} flag and some more description\n" + " * nicely formatted\n" + " */"; JSDocInfo info = parse(comment); assertEquals(1, info.getParameterCount()); assertTypeEquals(BOOLEAN_TYPE, info.getParameterType("flag")); assertEquals("description here", info.getDescription()); } public void testRegression8() throws Exception { String comment = " * @name random tag here\n" + " * @desc description here\n" + " *\n" + " * @param {boolean} flag and some more description\n" + " * nicely formatted\n" + " */"; JSDocInfo info = parse(comment); assertEquals(1, info.getParameterCount()); assertTypeEquals(BOOLEAN_TYPE, info.getParameterType("flag")); assertEquals("description here", info.getDescription()); } public void testRegression9() throws Exception { JSDocInfo jsdoc = parse( " * @param {string} p0 blah blah blah\n" + " */"); assertNull(jsdoc.getBaseType()); assertFalse(jsdoc.isConstant()); assertNull(jsdoc.getDescription()); assertNull(jsdoc.getEnumParameterType()); assertFalse(jsdoc.isHidden()); assertEquals(1, jsdoc.getParameterCount()); assertTypeEquals(STRING_TYPE, jsdoc.getParameterType("p0")); assertNull(jsdoc.getReturnType()); assertNull(jsdoc.getType()); assertEquals(Visibility.INHERITED, jsdoc.getVisibility()); } public void testRegression10() throws Exception { JSDocInfo jsdoc = parse( " * @param {!String} p0 blah blah blah\n" + " * @param {boolean} p1 fobar\n" + " * @return {!Date} jksjkash dshad\n" + " */"); assertNull(jsdoc.getBaseType()); assertFalse(jsdoc.isConstant()); assertNull(jsdoc.getDescription()); assertNull(jsdoc.getEnumParameterType()); assertFalse(jsdoc.isHidden()); assertEquals(2, jsdoc.getParameterCount()); assertTypeEquals(STRING_OBJECT_TYPE, jsdoc.getParameterType("p0")); assertTypeEquals(BOOLEAN_TYPE, jsdoc.getParameterType("p1")); assertTypeEquals(DATE_TYPE, jsdoc.getReturnType()); assertNull(jsdoc.getType()); assertEquals(Visibility.INHERITED, jsdoc.getVisibility()); } public void testRegression11() throws Exception { JSDocInfo jsdoc = parse( " * @constructor\n" + " */"); assertNull(jsdoc.getBaseType()); assertFalse(jsdoc.isConstant()); assertNull(jsdoc.getDescription()); assertNull(jsdoc.getEnumParameterType()); assertFalse(jsdoc.isHidden()); assertEquals(0, jsdoc.getParameterCount()); assertNull(jsdoc.getReturnType()); assertNull(jsdoc.getType()); assertEquals(Visibility.INHERITED, jsdoc.getVisibility()); } public void testRegression12() throws Exception { JSDocInfo jsdoc = parse( " * @extends FooBar\n" + " */"); assertTypeEquals(registry.createNamedType("FooBar", null, 0, 0), jsdoc.getBaseType()); assertFalse(jsdoc.isConstant()); assertNull(jsdoc.getDescription()); assertNull(jsdoc.getEnumParameterType()); assertFalse(jsdoc.isHidden()); assertEquals(0, jsdoc.getParameterCount()); assertNull(jsdoc.getReturnType()); assertNull(jsdoc.getType()); assertEquals(Visibility.INHERITED, jsdoc.getVisibility()); } public void testRegression13() throws Exception { JSDocInfo jsdoc = parse( " * @type {!RegExp}\n" + " * @protected\n" + " */"); assertNull(jsdoc.getBaseType()); assertFalse(jsdoc.isConstant()); assertNull(jsdoc.getDescription()); assertNull(jsdoc.getEnumParameterType()); assertFalse(jsdoc.isHidden()); assertEquals(0, jsdoc.getParameterCount()); assertNull(jsdoc.getReturnType()); assertTypeEquals(REGEXP_TYPE, jsdoc.getType()); assertEquals(Visibility.PROTECTED, jsdoc.getVisibility()); } public void testRegression14() throws Exception { JSDocInfo jsdoc = parse( " * @const\n" + " * @private\n" + " */"); assertNull(jsdoc.getBaseType()); assertTrue(jsdoc.isConstant()); assertNull(jsdoc.getDescription()); assertNull(jsdoc.getEnumParameterType()); assertFalse(jsdoc.isHidden()); assertEquals(0, jsdoc.getParameterCount()); assertNull(jsdoc.getReturnType()); assertNull(jsdoc.getType()); assertEquals(Visibility.PRIVATE, jsdoc.getVisibility()); } public void testRegression15() throws Exception { JSDocInfo jsdoc = parse( " * @desc Hello,\n" + " * World!\n" + " */"); assertNull(jsdoc.getBaseType()); assertFalse(jsdoc.isConstant()); assertEquals("Hello, World!", jsdoc.getDescription()); assertNull(jsdoc.getEnumParameterType()); assertFalse(jsdoc.isHidden()); assertEquals(0, jsdoc.getParameterCount()); assertNull(jsdoc.getReturnType()); assertNull(jsdoc.getType()); assertEquals(Visibility.INHERITED, jsdoc.getVisibility()); assertFalse(jsdoc.isExport()); } public void testRegression16() throws Exception { JSDocInfo jsdoc = parse( " Email is plp@foo.bar\n" + " @type {string}\n" + " */"); assertNull(jsdoc.getBaseType()); assertFalse(jsdoc.isConstant()); assertTypeEquals(STRING_TYPE, jsdoc.getType()); assertFalse(jsdoc.isHidden()); assertEquals(0, jsdoc.getParameterCount()); assertNull(jsdoc.getReturnType()); assertEquals(Visibility.INHERITED, jsdoc.getVisibility()); } public void testRegression17() throws Exception { // verifying that if no @desc is present the description is empty assertNull(parse("@private*/").getDescription()); } public void testFullRegression1() throws Exception { parseFull("/** @param (string,number) foo*/function bar(foo){}", "Bad type annotation. expecting a variable name in a @param tag"); } public void testFullRegression2() throws Exception { parseFull("/** @param {string,number) foo*/function bar(foo){}", "Bad type annotation. expected closing }", "Bad type annotation. expecting a variable name in a @param tag"); } public void testFullRegression3() throws Exception { parseFull("/**..\n*/"); } public void testBug907488() throws Exception { parse("@type {number,null} */", "Bad type annotation. expected closing }"); } public void testBug907494() throws Exception { parse("@return {Object,undefined} */", "Bad type annotation. expected closing }"); } public void testBug909468() throws Exception { parse("@extends {(x)}*/", "Bad type annotation. expecting a type name"); } public void testParseInterface() throws Exception { assertTrue(parse("@interface*/").isInterface()); } public void testParseImplicitCast1() throws Exception { assertTrue(parse("@type {string} \n * @implicitCast*/").isImplicitCast()); } public void testParseImplicitCast2() throws Exception { assertFalse(parse("@type {string}*/").isImplicitCast()); } public void testParseDuplicateImplicitCast() throws Exception { parse("@type {string} \n * @implicitCast \n * @implicitCast*/", "Bad type annotation. extra @implicitCast tag"); } public void testParseInterfaceDoubled() throws Exception { parse( "* @interface\n" + "* @interface\n" + "*/", "Bad type annotation. " + "type annotation incompatible with other annotations"); } public void testParseImplements() throws Exception { List<JSTypeExpression> interfaces = parse("@implements {SomeInterface}*/") .getImplementedInterfaces(); assertEquals(1, interfaces.size()); assertTypeEquals(registry.createNamedType("SomeInterface", null, -1, -1), interfaces.get(0)); } public void testParseImplementsTwo() throws Exception { List<JSTypeExpression> interfaces = parse( "* @implements {SomeInterface1}\n" + "* @implements {SomeInterface2}\n" + "*/") .getImplementedInterfaces(); assertEquals(2, interfaces.size()); assertTypeEquals(registry.createNamedType("SomeInterface1", null, -1, -1), interfaces.get(0)); assertTypeEquals(registry.createNamedType("SomeInterface2", null, -1, -1), interfaces.get(1)); } public void testParseImplementsSameTwice() throws Exception { parse( "* @implements {Smth}\n" + "* @implements {Smth}\n" + "*/", "Bad type annotation. duplicate @implements tag"); } public void testParseImplementsNoName() throws Exception { parse("* @implements {} */", "Bad type annotation. expecting a type name"); } public void testParseImplementsMissingRC() throws Exception { parse("* @implements {Smth */", "Bad type annotation. expected closing }"); } public void testParseImplementsNullable1() throws Exception { parse("@implements {Base?} */", "Bad type annotation. expected closing }"); } public void testParseImplementsNullable2() throws Exception { parse("@implements Base? */", "Bad type annotation. expected end of line or comment"); } public void testInterfaceExtends() throws Exception { JSDocInfo jsdoc = parse( " * @interface \n" + " * @extends {Extended} */"); assertTrue(jsdoc.isInterface()); assertEquals(1, jsdoc.getExtendedInterfacesCount()); List<JSTypeExpression> types = jsdoc.getExtendedInterfaces(); assertTypeEquals(registry.createNamedType("Extended", null, -1, -1), types.get(0)); } public void testInterfaceMultiExtends1() throws Exception { JSDocInfo jsdoc = parse( " * @interface \n" + " * @extends {Extended1} \n" + " * @extends {Extended2} */"); assertTrue(jsdoc.isInterface()); assertNull(jsdoc.getBaseType()); assertEquals(2, jsdoc.getExtendedInterfacesCount()); List<JSTypeExpression> types = jsdoc.getExtendedInterfaces(); assertTypeEquals(registry.createNamedType("Extended1", null, -1, -1), types.get(0)); assertTypeEquals(registry.createNamedType("Extended2", null, -1, -1), types.get(1)); } public void testInterfaceMultiExtends2() throws Exception { JSDocInfo jsdoc = parse( " * @extends {Extended1} \n" + " * @interface \n" + " * @extends {Extended2} \n" + " * @extends {Extended3} */"); assertTrue(jsdoc.isInterface()); assertNull(jsdoc.getBaseType()); assertEquals(3, jsdoc.getExtendedInterfacesCount()); List<JSTypeExpression> types = jsdoc.getExtendedInterfaces(); assertTypeEquals(registry.createNamedType("Extended1", null, -1, -1), types.get(0)); assertTypeEquals(registry.createNamedType("Extended2", null, -1, -1), types.get(1)); assertTypeEquals(registry.createNamedType("Extended3", null, -1, -1), types.get(2)); } public void testBadClassMultiExtends() throws Exception { parse(" * @extends {Extended1} \n" + " * @constructor \n" + " * @extends {Extended2} */", "Bad type annotation. type annotation incompatible with other " + "annotations"); } public void testBadExtendsWithNullable() throws Exception { JSDocInfo jsdoc = parse("@constructor\n * @extends {Object?} */", "Bad type annotation. expected closing }"); assertTrue(jsdoc.isConstructor()); assertTypeEquals(OBJECT_TYPE, jsdoc.getBaseType()); } public void testBadImplementsWithNullable() throws Exception { JSDocInfo jsdoc = parse("@implements {Disposable?}\n * @constructor */", "Bad type annotation. expected closing }"); assertTrue(jsdoc.isConstructor()); assertTypeEquals(registry.createNamedType("Disposable", null, -1, -1), jsdoc.getImplementedInterfaces().get(0)); } public void testBadTypeDefInterfaceAndConstructor1() throws Exception { JSDocInfo jsdoc = parse("@interface\n@constructor*/", "Bad type annotation. cannot be both an interface and a constructor"); assertTrue(jsdoc.isInterface()); } public void testBadTypeDefInterfaceAndConstructor2() throws Exception { JSDocInfo jsdoc = parse("@constructor\n@interface*/", "Bad type annotation. cannot be both an interface and a constructor"); assertTrue(jsdoc.isConstructor()); } public void testDocumentationParameter() throws Exception { JSDocInfo jsdoc = parse("@param {Number} number42 This is a description.*/", true); assertTrue(jsdoc.hasDescriptionForParameter("number42")); assertEquals("This is a description.", jsdoc.getDescriptionForParameter("number42")); } public void testMultilineDocumentationParameter() throws Exception { JSDocInfo jsdoc = parse("@param {Number} number42 This is a description" + "\n* on multiple \n* lines.*/", true); assertTrue(jsdoc.hasDescriptionForParameter("number42")); assertEquals("This is a description on multiple lines.", jsdoc.getDescriptionForParameter("number42")); } public void testDocumentationMultipleParameter() throws Exception { JSDocInfo jsdoc = parse("@param {Number} number42 This is a description." + "\n* @param {Integer} number87 This is another description.*/" , true); assertTrue(jsdoc.hasDescriptionForParameter("number42")); assertEquals("This is a description.", jsdoc.getDescriptionForParameter("number42")); assertTrue(jsdoc.hasDescriptionForParameter("number87")); assertEquals("This is another description.", jsdoc.getDescriptionForParameter("number87")); } public void testDocumentationMultipleParameter2() throws Exception { JSDocInfo jsdoc = parse("@param {number} delta = 0 results in a redraw\n" + " != 0 ..... */", true); assertTrue(jsdoc.hasDescriptionForParameter("delta")); assertEquals("= 0 results in a redraw != 0 .....", jsdoc.getDescriptionForParameter("delta")); } public void testAuthors() throws Exception { JSDocInfo jsdoc = parse("@param {Number} number42 This is a description." + "\n* @param {Integer} number87 This is another description." + "\n* @author a@google.com (A Person)" + "\n* @author b@google.com (B Person)" + "\n* @author c@google.com (C Person)*/" , true); Collection<String> authors = jsdoc.getAuthors(); assertTrue(authors != null); assertTrue(authors.size() == 3); assertContains(authors, "a@google.com (A Person)"); assertContains(authors, "b@google.com (B Person)"); assertContains(authors, "c@google.com (C Person)"); } public void testSuppress1() throws Exception { JSDocInfo info = parse("@suppress {x} */"); assertEquals(Sets.newHashSet("x"), info.getSuppressions()); } public void testSuppress2() throws Exception { JSDocInfo info = parse("@suppress {x|y|x|z} */"); assertEquals(Sets.newHashSet("x", "y", "z"), info.getSuppressions()); } public void testBadSuppress1() throws Exception { parse("@suppress {} */", "malformed @suppress tag"); } public void testBadSuppress2() throws Exception { parse("@suppress {x|} */", "malformed @suppress tag"); } public void testBadSuppress3() throws Exception { parse("@suppress {|x} */", "malformed @suppress tag"); } public void testBadSuppress4() throws Exception { parse("@suppress {x|y */", "malformed @suppress tag"); } public void testBadSuppress5() throws Exception { parse("@suppress {x,y} */", "malformed @suppress tag"); } public void testBadSuppress6() throws Exception { parse("@suppress {x} \n * @suppress {y} */", "duplicate @suppress tag"); } public void testBadSuppress7() throws Exception { parse("@suppress {impossible} */", "unknown @suppress parameter: impossible"); } public void testModifies1() throws Exception { JSDocInfo info = parse("@modifies {this} */"); assertEquals(Sets.newHashSet("this"), info.getModifies()); } public void testModifies2() throws Exception { JSDocInfo info = parse("@modifies {arguments} */"); assertEquals(Sets.newHashSet("arguments"), info.getModifies()); } public void testModifies3() throws Exception { JSDocInfo info = parse("@modifies {this|arguments} */"); assertEquals(Sets.newHashSet("this", "arguments"), info.getModifies()); } public void testModifies4() throws Exception { JSDocInfo info = parse("@param {*} x\n * @modifies {x} */"); assertEquals(Sets.newHashSet("x"), info.getModifies()); } public void testModifies5() throws Exception { JSDocInfo info = parse( "@param {*} x\n" + " * @param {*} y\n" + " * @modifies {x} */"); assertEquals(Sets.newHashSet("x"), info.getModifies()); } public void testModifies6() throws Exception { JSDocInfo info = parse( "@param {*} x\n" + " * @param {*} y\n" + " * @modifies {x|y} */"); assertEquals(Sets.newHashSet("x", "y"), info.getModifies()); } public void testBadModifies1() throws Exception { parse("@modifies {} */", "malformed @modifies tag"); } public void testBadModifies2() throws Exception { parse("@modifies {this|} */", "malformed @modifies tag"); } public void testBadModifies3() throws Exception { parse("@modifies {|this} */", "malformed @modifies tag"); } public void testBadModifies4() throws Exception { parse("@modifies {this|arguments */", "malformed @modifies tag"); } public void testBadModifies5() throws Exception { parse("@modifies {this,arguments} */", "malformed @modifies tag"); } public void testBadModifies6() throws Exception { parse("@modifies {this} \n * @modifies {this} */", "conflicting @modifies tag"); } public void testBadModifies7() throws Exception { parse("@modifies {impossible} */", "unknown @modifies parameter: impossible"); } public void testBadModifies8() throws Exception { parse("@modifies {this}\n" + "@nosideeffects */", "conflicting @nosideeffects tag"); } public void testBadModifies9() throws Exception { parse("@nosideeffects\n" + "@modifies {this} */", "conflicting @modifies tag"); } //public void testNoParseFileOverview() throws Exception { // JSDocInfo jsdoc = parseFileOverviewWithoutDoc("@fileoverview Hi mom! */"); // assertNull(jsdoc.getFileOverview()); // assertTrue(jsdoc.hasFileOverview()); //} public void testFileOverviewSingleLine() throws Exception { JSDocInfo jsdoc = parseFileOverview("@fileoverview Hi mom! */"); assertEquals("Hi mom!", jsdoc.getFileOverview()); } public void testFileOverviewMultiLine() throws Exception { JSDocInfo jsdoc = parseFileOverview("@fileoverview Pie is \n * good! */"); assertEquals("Pie is\n good!", jsdoc.getFileOverview()); } public void testFileOverviewDuplicate() throws Exception { JSDocInfo jsdoc = parseFileOverview( "@fileoverview Pie \n * @fileoverview Cake */", "extra @fileoverview tag"); } public void testReferences() throws Exception { JSDocInfo jsdoc = parse("@see A cool place!" + "\n* @see The world." + "\n* @see SomeClass#SomeMember" + "\n* @see A boring test case*/" , true); Collection<String> references = jsdoc.getReferences(); assertTrue(references != null); assertTrue(references.size() == 4); assertContains(references, "A cool place!"); assertContains(references, "The world."); assertContains(references, "SomeClass#SomeMember"); assertContains(references, "A boring test case"); } public void testSingleTags() throws Exception { JSDocInfo jsdoc = parse("@version Some old version" + "\n* @deprecated In favor of the new one!" + "\n* @return {SomeType} The most important object :-)*/" , true); assertTrue(jsdoc.isDeprecated()); assertEquals("In favor of the new one!", jsdoc.getDeprecationReason()); assertEquals("Some old version", jsdoc.getVersion()); assertEquals("The most important object :-)", jsdoc.getReturnDescription()); } public void testSingleTagsReordered() throws Exception { JSDocInfo jsdoc = parse("@deprecated In favor of the new one!" + "\n * @return {SomeType} The most important object :-)" + "\n * @version Some old version*/" , true); assertTrue(jsdoc.isDeprecated()); assertEquals("In favor of the new one!", jsdoc.getDeprecationReason()); assertEquals("Some old version", jsdoc.getVersion()); assertEquals("The most important object :-)", jsdoc.getReturnDescription()); } public void testVersionDuplication() throws Exception { parse("* @version Some old version" + "\n* @version Another version*/", true, "conflicting @version tag"); } public void testVersionMissing() throws Exception { parse("* @version */", true, "@version tag missing version information"); } public void testAuthorMissing() throws Exception { parse("* @author */", true, "@author tag missing author"); } public void testSeeMissing() throws Exception { parse("* @see */", true, "@see tag missing description"); } public void testSourceName() throws Exception { JSDocInfo jsdoc = parse("@deprecated */", true); assertEquals("testcode", jsdoc.getAssociatedNode().getSourceFileName()); } public void testParseBlockComment() throws Exception { JSDocInfo jsdoc = parse("this is a nice comment\n " + "* that is multiline \n" + "* @author abc@google.com */", true); assertEquals("this is a nice comment\nthat is multiline", jsdoc.getBlockDescription()); assertDocumentationInMarker( assertAnnotationMarker(jsdoc, "author", 2, 2), "abc@google.com", 9, 2, 23); } public void testParseBlockComment2() throws Exception { JSDocInfo jsdoc = parse("this is a nice comment\n " + "* that is *** multiline \n" + "* @author abc@google.com */", true); assertEquals("this is a nice comment\nthat is *** multiline", jsdoc.getBlockDescription()); assertDocumentationInMarker( assertAnnotationMarker(jsdoc, "author", 2, 2), "abc@google.com", 9, 2, 23); } public void testParseBlockComment3() throws Exception { JSDocInfo jsdoc = parse("\n " + "* hello world \n" + "* @author abc@google.com */", true); assertEquals("hello world", jsdoc.getBlockDescription()); assertDocumentationInMarker( assertAnnotationMarker(jsdoc, "author", 2, 2), "abc@google.com", 9, 2, 23); } public void testParseWithMarkers1() throws Exception { JSDocInfo jsdoc = parse("@author abc@google.com */", true); assertDocumentationInMarker( assertAnnotationMarker(jsdoc, "author", 0, 0), "abc@google.com", 7, 0, 21); } public void testParseWithMarkers2() throws Exception { JSDocInfo jsdoc = parse("@param {Foo} somename abc@google.com */", true); assertDocumentationInMarker( assertAnnotationMarker(jsdoc, "param", 0, 0), "abc@google.com", 21, 0, 37); } public void testParseWithMarkers3() throws Exception { JSDocInfo jsdoc = parse("@return {Foo} some long \n * multiline" + " \n * description */", true); JSDocInfo.Marker returnDoc = assertAnnotationMarker(jsdoc, "return", 0, 0); assertDocumentationInMarker(returnDoc, "some long multiline description", 13, 2, 15); assertEquals(8, returnDoc.getType().getPositionOnStartLine()); assertEquals(12, returnDoc.getType().getPositionOnEndLine()); } public void testParseWithMarkers4() throws Exception { JSDocInfo jsdoc = parse("@author foobar \n * @param {Foo} somename abc@google.com */", true); assertAnnotationMarker(jsdoc, "author", 0, 0); assertAnnotationMarker(jsdoc, "param", 1, 3); } public void testParseWithMarkers5() throws Exception { JSDocInfo jsdoc = parse("@return some long \n * multiline" + " \n * description */", true); assertDocumentationInMarker( assertAnnotationMarker(jsdoc, "return", 0, 0), "some long multiline description", 8, 2, 15); } public void testParseWithMarkers6() throws Exception { JSDocInfo jsdoc = parse("@param x some long \n * multiline" + " \n * description */", true); assertDocumentationInMarker( assertAnnotationMarker(jsdoc, "param", 0, 0), "some long multiline description", 8, 2, 15); } public void testParseWithMarkerNames1() throws Exception { JSDocInfo jsdoc = parse("@param {SomeType} name somedescription */", true); assertNameInMarker( assertAnnotationMarker(jsdoc, "param", 0, 0), "name", 0, 18); } public void testParseWithMarkerNames2() throws Exception { JSDocInfo jsdoc = parse("@param {SomeType} name somedescription \n" + "* @param {AnotherType} anothername des */", true); assertTypeInMarker( assertNameInMarker( assertAnnotationMarker(jsdoc, "param", 0, 0, 0), "name", 0, 18), "SomeType", 0, 7, 0, 16, true); assertTypeInMarker( assertNameInMarker( assertAnnotationMarker(jsdoc, "param", 1, 2, 1), "anothername", 1, 23), "AnotherType", 1, 9, 1, 21, true); } public void testParseWithMarkerNames3() throws Exception { JSDocInfo jsdoc = parse( "@param {Some.Long.Type.\n * Name} name somedescription */", true); assertTypeInMarker( assertNameInMarker( assertAnnotationMarker(jsdoc, "param", 0, 0, 0), "name", 1, 10), "Some.Long.Type.Name", 0, 7, 1, 8, true); } @SuppressWarnings("deprecation") public void testParseWithoutMarkerName() throws Exception { JSDocInfo jsdoc = parse("@author helloworld*/", true); assertNull(assertAnnotationMarker(jsdoc, "author", 0, 0).getName()); } public void testParseWithMarkerType() throws Exception { JSDocInfo jsdoc = parse("@extends {FooBar}*/", true); assertTypeInMarker( assertAnnotationMarker(jsdoc, "extends", 0, 0), "FooBar", 0, 9, 0, 16, true); } public void testParseWithMarkerType2() throws Exception { JSDocInfo jsdoc = parse("@extends FooBar*/", true); assertTypeInMarker( assertAnnotationMarker(jsdoc, "extends", 0, 0), "FooBar", 0, 9, 0, 15, false); } public void testTypeTagConflict1() throws Exception { parse("@constructor \n * @constructor */", "Bad type annotation. " + "type annotation incompatible with other annotations"); } public void testTypeTagConflict2() throws Exception { parse("@interface \n * @interface */", "Bad type annotation. " + "type annotation incompatible with other annotations"); } public void testTypeTagConflict3() throws Exception { parse("@constructor \n * @interface */", "Bad type annotation. cannot be both an interface and a constructor"); } public void testTypeTagConflict4() throws Exception { parse("@interface \n * @constructor */", "Bad type annotation. cannot be both an interface and a constructor"); } public void testTypeTagConflict5() throws Exception { parse("@interface \n * @type {string} */", "Bad type annotation. " + "type annotation incompatible with other annotations"); } public void testTypeTagConflict6() throws Exception { parse("@typedef {string} \n * @type {string} */", "Bad type annotation. " + "type annotation incompatible with other annotations"); } public void testTypeTagConflict7() throws Exception { parse("@typedef {string} \n * @constructor */", "Bad type annotation. " + "type annotation incompatible with other annotations"); } public void testTypeTagConflict8() throws Exception { parse("@typedef {string} \n * @return {boolean} */", "Bad type annotation. " + "type annotation incompatible with other annotations"); } public void testTypeTagConflict9() throws Exception { parse("@enum {string} \n * @return {boolean} */", "Bad type annotation. " + "type annotation incompatible with other annotations"); } public void testTypeTagConflict10() throws Exception { parse("@this {Object} \n * @enum {boolean} */", "Bad type annotation. " + "type annotation incompatible with other annotations"); } public void testTypeTagConflict11() throws Exception { parse("@param {Object} x \n * @type {boolean} */", "Bad type annotation. " + "type annotation incompatible with other annotations"); } public void testTypeTagConflict12() throws Exception { parse("@typedef {boolean} \n * @param {Object} x */", "Bad type annotation. " + "type annotation incompatible with other annotations"); } public void testTypeTagConflict13() throws Exception { parse("@typedef {boolean} \n * @extends {Object} */", "Bad type annotation. " + "type annotation incompatible with other annotations"); } public void testTypeTagConflict14() throws Exception { parse("@return x \n * @return y */", "Bad type annotation. " + "type annotation incompatible with other annotations"); } public void testTypeTagConflict15() throws Exception { parse("/**\n" + " * @struct\n" + " * @struct\n" + " */\n" + "function StrStr() {}", "Bad type annotation. " + "type annotation incompatible with other annotations"); } public void testTypeTagConflict16() throws Exception { parse("/**\n" + " * @struct\n" + " * @interface\n" + " */\n" + "function StrIntf() {}", "Bad type annotation. " + "type annotation incompatible with other annotations"); } public void testTypeTagConflict17() throws Exception { parse("/**\n" + " * @interface\n" + " * @struct\n" + " */\n" + "function StrIntf() {}", "Bad type annotation. " + "type annotation incompatible with other annotations"); } public void testTypeTagConflict18() throws Exception { parse("/**\n" + " * @dict\n" + " * @dict\n" + " */\n" + "function DictDict() {}", "Bad type annotation. " + "type annotation incompatible with other annotations"); } public void testTypeTagConflict19() throws Exception { parse("/**\n" + " * @dict\n" + " * @interface\n" + " */\n" + "function DictDict() {}", "Bad type annotation. " + "type annotation incompatible with other annotations"); } public void testTypeTagConflict20() throws Exception { parse("/**\n" + " * @interface\n" + " * @dict\n" + " */\n" + "function DictDict() {}", "Bad type annotation. " + "type annotation incompatible with other annotations"); } public void testTypeTagConflict21() throws Exception { parse("/**\n" + " * @private {string}\n" + " * @type {number}\n" + " */\n" + "function DictDict() {}", "Bad type annotation. " + "type annotation incompatible with other annotations"); } public void testTypeTagConflict22() throws Exception { parse("/**\n" + " * @protected {string}\n" + " * @param {string} x\n" + " */\n" + "function DictDict(x) {}", "Bad type annotation. " + "type annotation incompatible with other annotations"); } public void testTypeTagConflict23() throws Exception { parse("/**\n" + " * @public {string}\n" + " * @return {string} x\n" + " */\n" + "function DictDict() {}", "Bad type annotation. " + "type annotation incompatible with other annotations"); } public void testTypeTagConflict24() throws Exception { parse("/**\n" + " * @const {string}\n" + " * @return {string} x\n" + " */\n" + "function DictDict() {}", "Bad type annotation. " + "type annotation incompatible with other annotations"); } public void testPrivateType() throws Exception { JSDocInfo jsdoc = parse("@private {string} */"); assertTypeEquals(STRING_TYPE, jsdoc.getType()); } public void testProtectedType() throws Exception { JSDocInfo jsdoc = parse("@protected {string} */"); assertTypeEquals(STRING_TYPE, jsdoc.getType()); } public void testPublicType() throws Exception { JSDocInfo jsdoc = parse("@public {string} */"); assertTypeEquals(STRING_TYPE, jsdoc.getType()); } public void testConstType() throws Exception { JSDocInfo jsdoc = parse("@const {string} */"); assertTypeEquals(STRING_TYPE, jsdoc.getType()); } public void testStableIdGeneratorConflict() throws Exception { parse("/**\n" + " * @stableIdGenerator\n" + " * @stableIdGenerator\n" + " */\n" + "function getId() {}", "extra @stableIdGenerator tag"); } public void testParserWithTemplateTypeNameMissing() { parse("@template */", "Bad type annotation. @template tag missing type name"); } public void testParserWithTemplateDuplicated() { parse("@template T\n@template V */", "Bad type annotation. @template tag at most once"); } public void testParserWithTwoTemplates() { parse("@template T,V */"); } public void testWhitelistedNewAnnotations() { parse("@foobar */", "illegal use of unknown JSDoc tag \"foobar\"; ignoring it"); extraAnnotations.add("foobar"); parse("@foobar */"); } public void testWhitelistedConflictingAnnotation() { extraAnnotations.add("param"); JSDocInfo info = parse("@param {number} index */"); assertTypeEquals(NUMBER_TYPE, info.getParameterType("index")); } public void testNonIdentifierAnnotation() { // Try to whitelist an annotation that is not a valid JS identifier. // It should not work. extraAnnotations.add("123"); parse("@123 */", "illegal use of unknown JSDoc tag \"\"; ignoring it"); } public void testUnsupportedJsDocSyntax1() { JSDocInfo info = parse("@param {string} [accessLevel=\"author\"] The user level */", true); assertEquals(1, info.getParameterCount()); assertTypeEquals( registry.createOptionalType(STRING_TYPE), info.getParameterType("accessLevel")); assertEquals("The user level", info.getDescriptionForParameter("accessLevel")); } public void testUnsupportedJsDocSyntax2() { JSDocInfo info = parse("@param userInfo The user info. \n" + " * @param userInfo.name The name of the user */", true); assertEquals(1, info.getParameterCount()); assertEquals("The user info.", info.getDescriptionForParameter("userInfo")); } public void testWhitelistedAnnotations() { parse( "* @addon \n" + "* @augments \n" + "* @base \n" + "* @borrows \n" + "* @bug \n" + "* @class \n" + "* @config \n" + "* @constructs \n" + "* @default \n" + "* @description \n" + "* @event \n" + "* @example \n" + "* @exception \n" + "* @exec \n" + "* @externs \n" + "* @field \n" + "* @function \n" + "* @id \n" + "* @ignore \n" + "* @inner \n" + "* @lends {string} \n" + "* @link \n" + "* @member \n" + "* @memberOf \n" + "* @modName \n" + "* @mods \n" + "* @name \n" + "* @namespace \n" + "* @nocompile \n" + "* @property \n" + "* @requires \n" + "* @since \n" + "* @static \n" + "* @supported */"); } public void testGetOriginalCommentString() throws Exception { String comment = "* @desc This is a comment */"; JSDocInfo info = parse(comment); assertNull(info.getOriginalCommentString()); info = parse(comment, true /* parseDocumentation */); assertEquals(comment, info.getOriginalCommentString()); } /** * Asserts that a documentation field exists on the given marker. * * @param description The text of the documentation field expected. * @param startCharno The starting character of the text. * @param endLineno The ending line of the text. * @param endCharno The ending character of the text. * @return The marker, for chaining purposes. */ private JSDocInfo.Marker assertDocumentationInMarker(JSDocInfo.Marker marker, String description, int startCharno, int endLineno, int endCharno) { assertTrue(marker.getDescription() != null); assertEquals(description, marker.getDescription().getItem()); // Match positional information. assertEquals(marker.getAnnotation().getStartLine(), marker.getDescription().getStartLine()); assertEquals(startCharno, marker.getDescription().getPositionOnStartLine()); assertEquals(endLineno, marker.getDescription().getEndLine()); assertEquals(endCharno, marker.getDescription().getPositionOnEndLine()); return marker; } /** * Asserts that a type field exists on the given marker. * * @param typeName The name of the type expected in the type field. * @param startCharno The starting character of the type declaration. * @param hasBrackets Whether the type in the type field is expected * to have brackets. * @return The marker, for chaining purposes. */ private JSDocInfo.Marker assertTypeInMarker( JSDocInfo.Marker marker, String typeName, int startLineno, int startCharno, int endLineno, int endCharno, boolean hasBrackets) { assertTrue(marker.getType() != null); assertTrue(marker.getType().getItem().isString()); // Match the name and brackets information. String foundName = marker.getType().getItem().getString(); assertEquals(typeName, foundName); assertEquals(hasBrackets, marker.getType().hasBrackets()); // Match position information. assertEquals(startCharno, marker.getType().getPositionOnStartLine()); assertEquals(endCharno, marker.getType().getPositionOnEndLine()); assertEquals(startLineno, marker.getType().getStartLine()); assertEquals(endLineno, marker.getType().getEndLine()); return marker; } /** * Asserts that a name field exists on the given marker. * * @param name The name expected in the name field. * @param startCharno The starting character of the text. * @return The marker, for chaining purposes. */ @SuppressWarnings("deprecation") private JSDocInfo.Marker assertNameInMarker(JSDocInfo.Marker marker, String name, int startLine, int startCharno) { assertTrue(marker.getName() != null); assertEquals(name, marker.getName().getItem()); assertEquals(startCharno, marker.getName().getPositionOnStartLine()); assertEquals(startCharno + name.length(), marker.getName().getPositionOnEndLine()); assertEquals(startLine, marker.getName().getStartLine()); assertEquals(startLine, marker.getName().getEndLine()); return marker; } /** * Asserts that an annotation marker of a given annotation name * is found in the given JSDocInfo. * * @param jsdoc The JSDocInfo in which to search for the annotation marker. * @param annotationName The name/type of the annotation for which to * search. Example: "author" for an "@author" annotation. * @param startLineno The expected starting line number of the marker. * @param startCharno The expected character on the starting line. * @return The marker found, for further testing. */ private JSDocInfo.Marker assertAnnotationMarker(JSDocInfo jsdoc, String annotationName, int startLineno, int startCharno) { return assertAnnotationMarker(jsdoc, annotationName, startLineno, startCharno, 0); } /** * Asserts that the index-th annotation marker of a given annotation name * is found in the given JSDocInfo. * * @param jsdoc The JSDocInfo in which to search for the annotation marker. * @param annotationName The name/type of the annotation for which to * search. Example: "author" for an "@author" annotation. * @param startLineno The expected starting line number of the marker. * @param startCharno The expected character on the starting line. * @param index The index of the marker. * @return The marker found, for further testing. */ private JSDocInfo.Marker assertAnnotationMarker(JSDocInfo jsdoc, String annotationName, int startLineno, int startCharno, int index) { Collection<JSDocInfo.Marker> markers = jsdoc.getMarkers(); assertTrue(markers.size() > 0); int counter = 0; for (JSDocInfo.Marker marker : markers) { if (marker.getAnnotation() != null) { if (annotationName.equals(marker.getAnnotation().getItem())) { if (counter == index) { assertEquals(startLineno, marker.getAnnotation().getStartLine()); assertEquals(startCharno, marker.getAnnotation().getPositionOnStartLine()); assertEquals(startLineno, marker.getAnnotation().getEndLine()); assertEquals(startCharno + annotationName.length(), marker.getAnnotation().getPositionOnEndLine()); return marker; } counter++; } } } fail("No marker found"); return null; } private <T> void assertContains(Collection<T> collection, T item) { assertTrue(collection.contains(item)); } private void parseFull(String code, String... warnings) { CompilerEnvirons environment = new CompilerEnvirons(); TestErrorReporter testErrorReporter = new TestErrorReporter(null, warnings); environment.setErrorReporter(testErrorReporter); environment.setRecordingComments(true); environment.setRecordingLocalJsDocComments(true); Parser p = new Parser(environment, testErrorReporter); AstRoot script = p.parse(code, null, 0); Config config = new Config(extraAnnotations, extraSuppressions, true, LanguageMode.ECMASCRIPT3, false); StaticSourceFile file = new SimpleSourceFile(script.getSourceName(), false); for (Comment comment : script.getComments()) { JsDocInfoParser jsdocParser = new JsDocInfoParser( new JsDocTokenStream(comment.getValue().substring(3), comment.getLineno()), comment, null, config, testErrorReporter); jsdocParser.parse(); jsdocParser.retrieveAndResetParsedJSDocInfo(); } assertTrue("some expected warnings were not reported", testErrorReporter.hasEncounteredAllWarnings()); } @SuppressWarnings("unused") private JSDocInfo parseFileOverviewWithoutDoc(String comment, String... warnings) { return parse(comment, false, true, warnings); } private JSDocInfo parseFileOverview(String comment, String... warnings) { return parse(comment, true, true, warnings); } private JSDocInfo parse(String comment, String... warnings) { return parse(comment, false, warnings); } private JSDocInfo parse(String comment, boolean parseDocumentation, String... warnings) { return parse(comment, parseDocumentation, false, warnings); } private JSDocInfo parse(String comment, boolean parseDocumentation, boolean parseFileOverview, String... warnings) { TestErrorReporter errorReporter = new TestErrorReporter(null, warnings); Config config = new Config(extraAnnotations, extraSuppressions, parseDocumentation, LanguageMode.ECMASCRIPT3, false); StaticSourceFile file = new SimpleSourceFile("testcode", false); Node associatedNode = new Node(Token.SCRIPT); associatedNode.setInputId(new InputId(file.getName())); associatedNode.setStaticSourceFile(file); JsDocInfoParser jsdocParser = new JsDocInfoParser( stream(comment), new Comment(0, 0, CommentType.JSDOC, comment), associatedNode, config, errorReporter); if (fileLevelJsDocBuilder != null) { jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder); } jsdocParser.parse(); assertTrue("expected warnings were not reported", errorReporter.hasEncounteredAllWarnings()); if (parseFileOverview) { return jsdocParser.getFileOverviewJSDocInfo(); } else { return jsdocParser.retrieveAndResetParsedJSDocInfo(); } } private Node parseType(String typeComment) { return JsDocInfoParser.parseTypeString(typeComment); } private JsDocTokenStream stream(String source) { return new JsDocTokenStream(source, 0); } private void assertParameterTypeEquals(JSType expected, JSTypeExpression te) { assertEquals(expected, ((ObjectType) resolve(te)).getParameterType()); } private void assertIndexTypeEquals(JSType expected, JSTypeExpression te) { assertEquals(expected, ((ObjectType) resolve(te)).getIndexType()); } }
/* * Copyright 2009 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp.parsing; import static com.google.javascript.jscomp.parsing.JsDocToken.ANNOTATION; import static com.google.javascript.jscomp.parsing.JsDocToken.BANG; import static com.google.javascript.jscomp.parsing.JsDocToken.COLON; import static com.google.javascript.jscomp.parsing.JsDocToken.COMMA; import static com.google.javascript.jscomp.parsing.JsDocToken.ELLIPSIS; import static com.google.javascript.jscomp.parsing.JsDocToken.EOC; import static com.google.javascript.jscomp.parsing.JsDocToken.EOF; import static com.google.javascript.jscomp.parsing.JsDocToken.EOL; import static com.google.javascript.jscomp.parsing.JsDocToken.EQUALS; import static com.google.javascript.jscomp.parsing.JsDocToken.GT; import static com.google.javascript.jscomp.parsing.JsDocToken.LB; import static com.google.javascript.jscomp.parsing.JsDocToken.LC; import static com.google.javascript.jscomp.parsing.JsDocToken.LP; import static com.google.javascript.jscomp.parsing.JsDocToken.LT; import static com.google.javascript.jscomp.parsing.JsDocToken.PIPE; import static com.google.javascript.jscomp.parsing.JsDocToken.QMARK; import static com.google.javascript.jscomp.parsing.JsDocToken.RB; import static com.google.javascript.jscomp.parsing.JsDocToken.RC; import static com.google.javascript.jscomp.parsing.JsDocToken.RP; import static com.google.javascript.jscomp.parsing.JsDocToken.STAR; import static com.google.javascript.jscomp.parsing.JsDocToken.STRING; import com.google.common.collect.ImmutableList; import junit.framework.TestCase; import java.util.List; /** * Tests for {@link JsDocTokenStream}. */ public class JsDocTokenStreamTest extends TestCase { public void testJsDocTokenization1() throws Exception { List<JsDocToken> tokens = ImmutableList.of( STAR, ANNOTATION, LC, STRING, RC, EOL, STAR, ANNOTATION); List<String> strings = ImmutableList.of("type", "string", "private"); testJSDocTokenStream(" * @type {string}\n * @private", tokens, strings); testJSDocTokenStream(" * @type { string } \n * @private", tokens, strings); testJSDocTokenStream(" * @type { string}\n * @private", tokens, strings); testJSDocTokenStream(" * @type {string }\n * @private", tokens, strings); testJSDocTokenStream(" * @type {string}\n * @private", tokens, strings); testJSDocTokenStream(" * @type {string} \n * @private", tokens, strings); } public void testJsDocTokenization2() throws Exception { List<JsDocToken> tokens = ImmutableList.of( ANNOTATION, LC, STRING, LT, STRING, PIPE, STRING, GT, RC); List<String> strings = ImmutableList.of("param", "Array", "string", "null"); testJSDocTokenStream("@param {Array.<string|null>}", tokens, strings); testJSDocTokenStream("@param {Array.<string|null>}", tokens, strings); testJSDocTokenStream("@param {Array.<string |null>}", tokens, strings); testJSDocTokenStream(" @param {Array.<string | null>}", tokens, strings); testJSDocTokenStream(" @param {Array.<string|null >}", tokens, strings); testJSDocTokenStream("@param {Array .<string|null>}", tokens, strings); testJSDocTokenStream("@param {Array.<string|null>}", tokens, strings); testJSDocTokenStream("@param { Array.<string|null>}", tokens, strings); testJSDocTokenStream("@param {Array.<string| null>} ", tokens, strings); testJSDocTokenStream("@param {Array.<string|null>}", tokens, strings); testJSDocTokenStream(" @param { Array .< string |null > } ", tokens, strings); } public void testJsDocTokenization3() throws Exception { List<JsDocToken> tokens = ImmutableList.of( ANNOTATION, LC, STRING, LT, STRING, PIPE, STRING, GT, RC); List<String> strings = ImmutableList.of("param", "Array", "string", "null"); testJSDocTokenStream("@param {Array.<string||null>}", tokens, strings); testJSDocTokenStream("@param {Array.< string || null> }", tokens, strings); testJSDocTokenStream("@param {Array.<string || null > } ", tokens, strings); testJSDocTokenStream("@param {Array .<string ||null>}", tokens, strings); testJSDocTokenStream("@param {Array.< string||null>}", tokens, strings); testJSDocTokenStream("@param { Array.<string||null>}", tokens, strings); testJSDocTokenStream(" @param {Array.<string||null>}", tokens, strings); testJSDocTokenStream("@param { Array.<string|| null> }", tokens, strings); } public void testJsDocTokenization4() throws Exception { List<JsDocToken> tokens = ImmutableList.of( ANNOTATION, LC, STRING, LT, LP, STRING, COMMA, STRING, RP, GT, RC, EOF); List<String> strings = ImmutableList.of("param", "Array", "string", "null"); testJSDocTokenStream("@param {Array.<(string,null)>}", tokens, strings); testJSDocTokenStream("@param {Array .<(string,null)> } ", tokens, strings); testJSDocTokenStream(" @param {Array.< ( string,null)>}", tokens, strings); testJSDocTokenStream("@param {Array.<(string , null)>}", tokens, strings); testJSDocTokenStream("@param {Array.<(string, null) > } ", tokens, strings); testJSDocTokenStream("@param { Array .< (string,null)>} ", tokens, strings); } public void testJsDocTokenization5() throws Exception { List<JsDocToken> tokens = ImmutableList.of(ANNOTATION, STRING, EOC, EOF); List<String> strings = ImmutableList.of("param", "foo.Bar"); testJSDocTokenStream("@param foo.Bar*/", tokens, strings); testJSDocTokenStream(" @param foo.Bar*/", tokens, strings); testJSDocTokenStream(" @param foo.Bar */", tokens, strings); } public void testJsDocTokenization6() throws Exception { List<JsDocToken> tokens = ImmutableList.of( ANNOTATION, EOL, ANNOTATION, EOL, ANNOTATION, EOC); List<String> strings = ImmutableList.of("hidden", "static", "desc"); testJSDocTokenStream("@hidden\n@static\n@desc*/", tokens, strings); testJSDocTokenStream("@hidden\n @static\n@desc*/", tokens, strings); testJSDocTokenStream("@hidden\n@static\n @desc*/", tokens, strings); testJSDocTokenStream("@hidden\n@static\n@desc */", tokens, strings); testJSDocTokenStream(" @hidden \n@static\n @desc*/", tokens, strings); testJSDocTokenStream("@hidden\n@static \n @desc */", tokens, strings); testJSDocTokenStream("@hidden\n@static\n@desc*/", tokens, strings); testJSDocTokenStream("@hidden \n@static \n @desc*/", tokens, strings); } public void testJsDocTokenization7() throws Exception { List<JsDocToken> tokens = ImmutableList.of( ELLIPSIS, ELLIPSIS, ELLIPSIS, ELLIPSIS, ELLIPSIS, LT, EOC); List<String> strings = ImmutableList.of(); testJSDocTokenStream("................<*/", tokens, strings); testJSDocTokenStream("............... .<*/", tokens, strings); testJSDocTokenStream("................< */", tokens, strings); testJSDocTokenStream("............... .< */", tokens, strings); testJSDocTokenStream("............... .< */ ", tokens, strings); testJSDocTokenStream(" ............... .< */ ", tokens, strings); } public void testJsDocTokenization8() throws Exception { List<JsDocToken> tokens = ImmutableList.of( STAR, ANNOTATION, STRING, STRING, STRING, STRING, STRING, STRING, STRING, EOL, EOC); List<String> strings = ImmutableList.of( "param", "foo.Bar", "opt_name", "this", "parameter", "is", "a", "name"); testJSDocTokenStream( " * @param foo.Bar opt_name this parameter is a name\n" + " */", tokens, strings); testJSDocTokenStream( " * @param foo.Bar opt_name this parameter is a name \n" + " */ ", tokens, strings); } public void testJsDocTokenization9() throws Exception { List<JsDocToken> tokens = ImmutableList.of( STAR, ANNOTATION, STRING, STRING, STRING, STRING, STRING, ANNOTATION, STRING, EOL, EOC); List<String> strings = ImmutableList.of( "param", "foo.Bar", "opt_name", "this", "parameter", "does", "media", "blah"); testJSDocTokenStream( " * @param foo.Bar opt_name this parameter does @media blah\n" + " */", tokens, strings); } public void testJsDocTokenization10() throws Exception { List<JsDocToken> tokens = ImmutableList.of(STRING, GT, EOC); List<String> strings = ImmutableList.of("Array<String"); testJSDocTokenStream("Array<String>*/", tokens, strings); } public void testJsDocTokenization11() throws Exception { List<JsDocToken> tokens = ImmutableList.of( ANNOTATION, LC, STRING, QMARK, RC, EOC, EOF); List<String> strings = ImmutableList.of("param", "string"); testJSDocTokenStream("@param {string?}*/", tokens, strings); testJSDocTokenStream(" @param {string?}*/", tokens, strings); testJSDocTokenStream("@param { string?}*/", tokens, strings); testJSDocTokenStream("@param {string ?}*/", tokens, strings); testJSDocTokenStream("@param {string ? } */", tokens, strings); testJSDocTokenStream("@param { string ? }*/", tokens, strings); testJSDocTokenStream("@param {string? }*/", tokens, strings); } public void testJsDocTokenization12() throws Exception { List<JsDocToken> tokens = ImmutableList.of(STRING, ELLIPSIS, EOC); List<String> strings = ImmutableList.of("function"); testJSDocTokenStream("function ...*/", tokens, strings); } public void testJsDocTokenization13() throws Exception { List<JsDocToken> tokens = ImmutableList.of(ELLIPSIS, LB, STRING, RB, EOC); List<String> strings = ImmutableList.of("number"); testJSDocTokenStream("...[number]*/", tokens, strings); } public void testJsDocTokenization14() throws Exception { // Since ES4 type parsing only requires to parse an ellipsis when it is // followed by a comma (,) we are allowing this case to parse this way. // This is a simplification of the tokenizer, but the extra complexity is // never used. List<JsDocToken> tokens = ImmutableList.of(STRING, LB, STRING, EOC); List<String> strings = ImmutableList.of("foo", "bar..."); testJSDocTokenStream("foo[ bar...*/", tokens, strings); } public void testJsDocTokenization15() throws Exception { List<JsDocToken> tokens = ImmutableList.of( STRING, LB, STRING, COMMA, ELLIPSIS, EOC); List<String> strings = ImmutableList.of("foo", "bar"); testJSDocTokenStream("foo[ bar,...*/", tokens, strings); testJSDocTokenStream("foo[ bar ,...*/", tokens, strings); testJSDocTokenStream("foo[bar, ...*/", tokens, strings); testJSDocTokenStream("foo[ bar , ... */", tokens, strings); testJSDocTokenStream("foo [bar,... */", tokens, strings); } public void testJsDocTokenization16() throws Exception { List<JsDocToken> tokens = ImmutableList.of( STRING, COLON, COLON, COLON, ELLIPSIS, STRING, COLON, STRING, EOC); List<String> strings = ImmutableList.of("foo", "bar", "bar2"); testJSDocTokenStream("foo:::...bar:bar2*/", tokens, strings); } public void testJsDocTokenization17() throws Exception { List<JsDocToken> tokens = ImmutableList.of(STRING, EOL, EOC); List<String> strings = ImmutableList.of(".."); testJSDocTokenStream("..\n*/", tokens, strings); } public void testJsDocTokenization18() throws Exception { List<JsDocToken> tokens = ImmutableList.of(STRING, EOL, EOC); List<String> strings = ImmutableList.of("."); testJSDocTokenStream(".\n*/", tokens, strings); } public void testJsDocTokenization19() throws Exception { List<JsDocToken> tokens = ImmutableList.of(ANNOTATION, LC, STAR, RC, EOC); List<String> strings = ImmutableList.of("type", "*"); testJSDocTokenStream("@type {*}*/", tokens, strings); } public void testJsDocTokenization20() throws Exception { List<JsDocToken> tokens = ImmutableList.of( ANNOTATION, LC, BANG, STRING, RC, EOC, EOF); List<String> strings = ImmutableList.of("param", "Object"); testJSDocTokenStream("@param {!Object}*/", tokens, strings); testJSDocTokenStream(" @param {!Object}*/", tokens, strings); testJSDocTokenStream("@param {! Object}*/", tokens, strings); testJSDocTokenStream("@param { !Object}*/", tokens, strings); testJSDocTokenStream("@param {!Object } */", tokens, strings); testJSDocTokenStream("@param { ! Object }*/", tokens, strings); testJSDocTokenStream("@param {!Object }*/", tokens, strings); } public void testJsDocTokenization21() throws Exception { List<JsDocToken> tokens = ImmutableList.of( ANNOTATION, LC, STRING, EQUALS, RC, EOC, EOF); List<String> strings = ImmutableList.of("param", "Object"); testJSDocTokenStream("@param {Object=}*/", tokens, strings); testJSDocTokenStream(" @param {Object=}*/", tokens, strings); testJSDocTokenStream("@param { Object =}*/", tokens, strings); testJSDocTokenStream("@param { Object=}*/", tokens, strings); testJSDocTokenStream("@param {Object= } */", tokens, strings); testJSDocTokenStream("@param { Object = }*/", tokens, strings); testJSDocTokenStream("@param {Object= }*/", tokens, strings); } private void testJSDocTokenStream(String comment, List<JsDocToken> tokens, List<String> strings) { JsDocTokenStream stream = new JsDocTokenStream(comment, 0); int stringsIndex = 0; for (JsDocToken token : tokens) { JsDocToken readToken = stream.getJsDocToken(); // token equality if (token != readToken) { assertEquals(token, readToken); } // string equality if (token == ANNOTATION || token == STRING) { assertEquals(strings.get(stringsIndex++), stream.getString()); } } } }
/* * Copyright 2007 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp.parsing; import com.google.common.collect.ImmutableList; import com.google.javascript.jscomp.parsing.Config.LanguageMode; import com.google.javascript.jscomp.testing.TestErrorReporter; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.head.ScriptRuntime; import com.google.javascript.rhino.jstype.SimpleSourceFile; import com.google.javascript.rhino.jstype.StaticSourceFile; import com.google.javascript.rhino.testing.BaseJSTypeTestCase; import java.io.IOException; import java.util.List; import java.util.logging.Logger; public class ParserTest extends BaseJSTypeTestCase { private static final String SUSPICIOUS_COMMENT_WARNING = IRFactory.SUSPICIOUS_COMMENT_WARNING; private static final String TRAILING_COMMA_MESSAGE = ScriptRuntime.getMessage0("msg.extra.trailing.comma"); private static final String BAD_PROPERTY_MESSAGE = ScriptRuntime.getMessage0("msg.bad.prop"); private static final String MISSING_GT_MESSAGE = "Bad type annotation. " + com.google.javascript.rhino.ScriptRuntime.getMessage0( "msg.jsdoc.missing.gt"); private static final String MISPLACED_TYPE_ANNOTATION = IRFactory.MISPLACED_TYPE_ANNOTATION; private Config.LanguageMode mode; private boolean isIdeMode = false; @Override protected void setUp() throws Exception { super.setUp(); mode = LanguageMode.ECMASCRIPT3; isIdeMode = false; } public void testLinenoCharnoAssign1() throws Exception { Node assign = parse("a = b").getFirstChild().getFirstChild(); assertEquals(Token.ASSIGN, assign.getType()); assertEquals(1, assign.getLineno()); assertEquals(0, assign.getCharno()); } public void testLinenoCharnoAssign2() throws Exception { Node assign = parse("\n a.g.h.k = 45").getFirstChild().getFirstChild(); assertEquals(Token.ASSIGN, assign.getType()); assertEquals(2, assign.getLineno()); assertEquals(1, assign.getCharno()); } public void testLinenoCharnoCall() throws Exception { Node call = parse("\n foo(123);").getFirstChild().getFirstChild(); assertEquals(Token.CALL, call.getType()); assertEquals(2, call.getLineno()); assertEquals(1, call.getCharno()); } public void testLinenoCharnoGetProp1() throws Exception { Node getprop = parse("\n foo.bar").getFirstChild().getFirstChild(); assertEquals(Token.GETPROP, getprop.getType()); assertEquals(2, getprop.getLineno()); assertEquals(1, getprop.getCharno()); Node name = getprop.getFirstChild().getNext(); assertEquals(Token.STRING, name.getType()); assertEquals(2, name.getLineno()); assertEquals(5, name.getCharno()); } public void testLinenoCharnoGetProp2() throws Exception { Node getprop = parse("\n foo.\nbar").getFirstChild().getFirstChild(); assertEquals(Token.GETPROP, getprop.getType()); assertEquals(2, getprop.getLineno()); assertEquals(1, getprop.getCharno()); Node name = getprop.getFirstChild().getNext(); assertEquals(Token.STRING, name.getType()); assertEquals(3, name.getLineno()); assertEquals(0, name.getCharno()); } public void testLinenoCharnoGetelem1() throws Exception { Node call = parse("\n foo[123]").getFirstChild().getFirstChild(); assertEquals(Token.GETELEM, call.getType()); assertEquals(2, call.getLineno()); assertEquals(1, call.getCharno()); } public void testLinenoCharnoGetelem2() throws Exception { Node call = parse("\n \n foo()[123]").getFirstChild().getFirstChild(); assertEquals(Token.GETELEM, call.getType()); assertEquals(3, call.getLineno()); assertEquals(1, call.getCharno()); } public void testLinenoCharnoGetelem3() throws Exception { Node call = parse("\n \n (8 + kl)[123]").getFirstChild().getFirstChild(); assertEquals(Token.GETELEM, call.getType()); assertEquals(3, call.getLineno()); assertEquals(2, call.getCharno()); } public void testLinenoCharnoForComparison() throws Exception { Node lt = parse("for (; i < j;){}").getFirstChild().getFirstChild().getNext(); assertEquals(Token.LT, lt.getType()); assertEquals(1, lt.getLineno()); assertEquals(7, lt.getCharno()); } public void testLinenoCharnoHook() throws Exception { Node n = parse("\n a ? 9 : 0").getFirstChild().getFirstChild(); assertEquals(Token.HOOK, n.getType()); assertEquals(2, n.getLineno()); assertEquals(1, n.getCharno()); } public void testLinenoCharnoArrayLiteral() throws Exception { Node n = parse("\n [8, 9]").getFirstChild().getFirstChild(); assertEquals(Token.ARRAYLIT, n.getType()); assertEquals(2, n.getLineno()); assertEquals(2, n.getCharno()); n = n.getFirstChild(); assertEquals(Token.NUMBER, n.getType()); assertEquals(2, n.getLineno()); assertEquals(3, n.getCharno()); n = n.getNext(); assertEquals(Token.NUMBER, n.getType()); assertEquals(2, n.getLineno()); assertEquals(6, n.getCharno()); } public void testLinenoCharnoObjectLiteral() throws Exception { Node n = parse("\n\n var a = {a:0\n,b :1};") .getFirstChild().getFirstChild().getFirstChild(); assertEquals(Token.OBJECTLIT, n.getType()); assertEquals(3, n.getLineno()); assertEquals(9, n.getCharno()); Node key = n.getFirstChild(); assertEquals(Token.STRING_KEY, key.getType()); assertEquals(3, key.getLineno()); assertEquals(10, key.getCharno()); Node value = key.getFirstChild(); assertEquals(Token.NUMBER, value.getType()); assertEquals(3, value.getLineno()); assertEquals(12, value.getCharno()); key = key.getNext(); assertEquals(Token.STRING_KEY, key.getType()); assertEquals(4, key.getLineno()); assertEquals(1, key.getCharno()); value = key.getFirstChild(); assertEquals(Token.NUMBER, value.getType()); assertEquals(4, value.getLineno()); assertEquals(4, value.getCharno()); } public void testLinenoCharnoAdd() throws Exception { testLinenoCharnoBinop("+"); } public void testLinenoCharnoSub() throws Exception { testLinenoCharnoBinop("-"); } public void testLinenoCharnoMul() throws Exception { testLinenoCharnoBinop("*"); } public void testLinenoCharnoDiv() throws Exception { testLinenoCharnoBinop("/"); } public void testLinenoCharnoMod() throws Exception { testLinenoCharnoBinop("%"); } public void testLinenoCharnoShift() throws Exception { testLinenoCharnoBinop("<<"); } public void testLinenoCharnoBinaryAnd() throws Exception { testLinenoCharnoBinop("&"); } public void testLinenoCharnoAnd() throws Exception { testLinenoCharnoBinop("&&"); } public void testLinenoCharnoBinaryOr() throws Exception { testLinenoCharnoBinop("|"); } public void testLinenoCharnoOr() throws Exception { testLinenoCharnoBinop("||"); } public void testLinenoCharnoLt() throws Exception { testLinenoCharnoBinop("<"); } public void testLinenoCharnoLe() throws Exception { testLinenoCharnoBinop("<="); } public void testLinenoCharnoGt() throws Exception { testLinenoCharnoBinop(">"); } public void testLinenoCharnoGe() throws Exception { testLinenoCharnoBinop(">="); } private void testLinenoCharnoBinop(String binop) { Node op = parse("var a = 89 " + binop + " 76").getFirstChild(). getFirstChild().getFirstChild(); assertEquals(1, op.getLineno()); assertEquals(8, op.getCharno()); } public void testJSDocAttachment1() { Node varNode = parse("/** @type number */var a;").getFirstChild(); // VAR assertEquals(Token.VAR, varNode.getType()); JSDocInfo info = varNode.getJSDocInfo(); assertNotNull(info); assertTypeEquals(NUMBER_TYPE, info.getType()); // NAME Node nameNode = varNode.getFirstChild(); assertEquals(Token.NAME, nameNode.getType()); assertNull(nameNode.getJSDocInfo()); } public void testJSDocAttachment2() { Node varNode = parse("/** @type number */var a,b;").getFirstChild(); // VAR assertEquals(Token.VAR, varNode.getType()); JSDocInfo info = varNode.getJSDocInfo(); assertNotNull(info); assertTypeEquals(NUMBER_TYPE, info.getType()); // First NAME Node nameNode1 = varNode.getFirstChild(); assertEquals(Token.NAME, nameNode1.getType()); assertNull(nameNode1.getJSDocInfo()); // Second NAME Node nameNode2 = nameNode1.getNext(); assertEquals(Token.NAME, nameNode2.getType()); assertNull(nameNode2.getJSDocInfo()); } public void testJSDocAttachment3() { Node assignNode = parse( "/** @type number */goog.FOO = 5;").getFirstChild().getFirstChild(); // ASSIGN assertEquals(Token.ASSIGN, assignNode.getType()); JSDocInfo info = assignNode.getJSDocInfo(); assertNotNull(info); assertTypeEquals(NUMBER_TYPE, info.getType()); } public void testJSDocAttachment4() { Node varNode = parse( "var a, /** @define {number} */b = 5;").getFirstChild(); // ASSIGN assertEquals(Token.VAR, varNode.getType()); assertNull(varNode.getJSDocInfo()); // a Node a = varNode.getFirstChild(); assertNull(a.getJSDocInfo()); // b Node b = a.getNext(); JSDocInfo info = b.getJSDocInfo(); assertNotNull(info); assertTrue(info.isDefine()); assertTypeEquals(NUMBER_TYPE, info.getType()); } public void testJSDocAttachment5() { Node varNode = parse( "var /** @type number */a, /** @define {number} */b = 5;") .getFirstChild(); // ASSIGN assertEquals(Token.VAR, varNode.getType()); assertNull(varNode.getJSDocInfo()); // a Node a = varNode.getFirstChild(); assertNotNull(a.getJSDocInfo()); JSDocInfo info = a.getJSDocInfo(); assertNotNull(info); assertFalse(info.isDefine()); assertTypeEquals(NUMBER_TYPE, info.getType()); // b Node b = a.getNext(); info = b.getJSDocInfo(); assertNotNull(info); assertTrue(info.isDefine()); assertTypeEquals(NUMBER_TYPE, info.getType()); } /** * Tests that a JSDoc comment in an unexpected place of the code does not * propagate to following code due to {@link JSDocInfo} aggregation. */ public void testJSDocAttachment6() throws Exception { Node functionNode = parse( "var a = /** @param {number} index */5;" + "/** @return boolean */function f(index){}") .getFirstChild().getNext(); assertEquals(Token.FUNCTION, functionNode.getType()); JSDocInfo info = functionNode.getJSDocInfo(); assertNotNull(info); assertFalse(info.hasParameter("index")); assertTrue(info.hasReturnType()); assertTypeEquals(UNKNOWN_TYPE, info.getReturnType()); } public void testJSDocAttachment7() { Node varNode = parse("/** */var a;").getFirstChild(); // VAR assertEquals(Token.VAR, varNode.getType()); // NAME Node nameNode = varNode.getFirstChild(); assertEquals(Token.NAME, nameNode.getType()); assertNull(nameNode.getJSDocInfo()); } public void testJSDocAttachment8() { Node varNode = parse("/** x */var a;").getFirstChild(); // VAR assertEquals(Token.VAR, varNode.getType()); // NAME Node nameNode = varNode.getFirstChild(); assertEquals(Token.NAME, nameNode.getType()); assertNull(nameNode.getJSDocInfo()); } public void testJSDocAttachment9() { Node varNode = parse("/** \n x */var a;").getFirstChild(); // VAR assertEquals(Token.VAR, varNode.getType()); // NAME Node nameNode = varNode.getFirstChild(); assertEquals(Token.NAME, nameNode.getType()); assertNull(nameNode.getJSDocInfo()); } public void testJSDocAttachment10() { Node varNode = parse("/** x\n */var a;").getFirstChild(); // VAR assertEquals(Token.VAR, varNode.getType()); // NAME Node nameNode = varNode.getFirstChild(); assertEquals(Token.NAME, nameNode.getType()); assertNull(nameNode.getJSDocInfo()); } public void testJSDocAttachment11() { Node varNode = parse("/** @type {{x : number, 'y' : string, z}} */var a;") .getFirstChild(); // VAR assertEquals(Token.VAR, varNode.getType()); JSDocInfo info = varNode.getJSDocInfo(); assertNotNull(info); assertTypeEquals(createRecordTypeBuilder(). addProperty("x", NUMBER_TYPE, null). addProperty("y", STRING_TYPE, null). addProperty("z", UNKNOWN_TYPE, null). build(), info.getType()); // NAME Node nameNode = varNode.getFirstChild(); assertEquals(Token.NAME, nameNode.getType()); assertNull(nameNode.getJSDocInfo()); } public void testJSDocAttachment12() { Node varNode = parse("var a = {/** @type {Object} */ b: c};") .getFirstChild(); Node objectLitNode = varNode.getFirstChild().getFirstChild(); assertEquals(Token.OBJECTLIT, objectLitNode.getType()); assertNotNull(objectLitNode.getFirstChild().getJSDocInfo()); } public void testJSDocAttachment13() { Node varNode = parse("/** foo */ var a;").getFirstChild(); assertNotNull(varNode.getJSDocInfo()); } public void testJSDocAttachment14() { Node varNode = parse("/** */ var a;").getFirstChild(); assertNull(varNode.getJSDocInfo()); } public void testJSDocAttachment15() { Node varNode = parse("/** \n * \n */ var a;").getFirstChild(); assertNull(varNode.getJSDocInfo()); } public void testJSDocAttachment16() { Node exprCall = parse("/** @private */ x(); function f() {};").getFirstChild(); assertEquals(Token.EXPR_RESULT, exprCall.getType()); assertNull(exprCall.getNext().getJSDocInfo()); assertNotNull(exprCall.getFirstChild().getJSDocInfo()); } public void testIncorrectJSDocDoesNotAlterJSParsing1() throws Exception { assertNodeEquality( parse("var a = [1,2]"), parse("/** @type Array.<number*/var a = [1,2]", MISSING_GT_MESSAGE)); } public void testIncorrectJSDocDoesNotAlterJSParsing2() throws Exception { assertNodeEquality( parse("var a = [1,2]"), parse("/** @type {Array.<number}*/var a = [1,2]", MISSING_GT_MESSAGE)); } public void testIncorrectJSDocDoesNotAlterJSParsing3() throws Exception { assertNodeEquality( parse("C.prototype.say=function(nums) {alert(nums.join(','));};"), parse("/** @param {Array.<number} nums */" + "C.prototype.say=function(nums) {alert(nums.join(','));};", MISSING_GT_MESSAGE)); } public void testIncorrectJSDocDoesNotAlterJSParsing4() throws Exception { assertNodeEquality( parse("C.prototype.say=function(nums) {alert(nums.join(','));};"), parse("/** @return boolean */" + "C.prototype.say=function(nums) {alert(nums.join(','));};")); } public void testIncorrectJSDocDoesNotAlterJSParsing5() throws Exception { assertNodeEquality( parse("C.prototype.say=function(nums) {alert(nums.join(','));};"), parse("/** @param boolean this is some string*/" + "C.prototype.say=function(nums) {alert(nums.join(','));};")); } public void testIncorrectJSDocDoesNotAlterJSParsing6() throws Exception { assertNodeEquality( parse("C.prototype.say=function(nums) {alert(nums.join(','));};"), parse("/** @param {bool!*%E$} */" + "C.prototype.say=function(nums) {alert(nums.join(','));};", "Bad type annotation. expected closing }", "Bad type annotation. expecting a variable name in a @param tag")); } public void testIncorrectJSDocDoesNotAlterJSParsing7() throws Exception { assertNodeEquality( parse("C.prototype.say=function(nums) {alert(nums.join(','));};"), parse("/** @see */" + "C.prototype.say=function(nums) {alert(nums.join(','));};", "@see tag missing description")); } public void testIncorrectJSDocDoesNotAlterJSParsing8() throws Exception { assertNodeEquality( parse("C.prototype.say=function(nums) {alert(nums.join(','));};"), parse("/** @author */" + "C.prototype.say=function(nums) {alert(nums.join(','));};", "@author tag missing author")); } public void testIncorrectJSDocDoesNotAlterJSParsing9() throws Exception { assertNodeEquality( parse("C.prototype.say=function(nums) {alert(nums.join(','));};"), parse("/** @someillegaltag */" + "C.prototype.say=function(nums) {alert(nums.join(','));};", "illegal use of unknown JSDoc tag \"someillegaltag\";" + " ignoring it")); } public void testUnescapedSlashInRegexpCharClass() throws Exception { // The tokenizer without the fix for this bug throws an error. parse("var foo = /[/]/;"); parse("var foo = /[hi there/]/;"); parse("var foo = /[/yo dude]/;"); parse("var foo = /\\/[@#$/watashi/wa/suteevu/desu]/;"); } private void assertNodeEquality(Node expected, Node found) { String message = expected.checkTreeEquals(found); if (message != null) { fail(message); } } @SuppressWarnings("unchecked") public void testParse() { Node a = Node.newString(Token.NAME, "a"); a.addChildToFront(Node.newString(Token.NAME, "b")); List<ParserResult> testCases = ImmutableList.of( new ParserResult( "3;", createScript(new Node(Token.EXPR_RESULT, Node.newNumber(3.0)))), new ParserResult( "var a = b;", createScript(new Node(Token.VAR, a))), new ParserResult( "\"hell\\\no\\ world\\\n\\\n!\"", createScript(new Node(Token.EXPR_RESULT, Node.newString(Token.STRING, "hello world!"))))); for (ParserResult testCase : testCases) { assertNodeEquality(testCase.node, parse(testCase.code)); } } private Node createScript(Node n) { Node script = new Node(Token.SCRIPT); script.addChildToBack(n); return script; } public void testTrailingCommaWarning1() { parse("var a = ['foo', 'bar'];"); } public void testTrailingCommaWarning2() { parse("var a = ['foo',,'bar'];"); } public void testTrailingCommaWarning3() { parse("var a = ['foo', 'bar',];", TRAILING_COMMA_MESSAGE); mode = LanguageMode.ECMASCRIPT5; parse("var a = ['foo', 'bar',];"); } public void testTrailingCommaWarning4() { parse("var a = [,];", TRAILING_COMMA_MESSAGE); mode = LanguageMode.ECMASCRIPT5; parse("var a = [,];"); } public void testTrailingCommaWarning5() { parse("var a = {'foo': 'bar'};"); } public void testTrailingCommaWarning6() { parse("var a = {'foo': 'bar',};", TRAILING_COMMA_MESSAGE); mode = LanguageMode.ECMASCRIPT5; parse("var a = {'foo': 'bar',};"); } public void testTrailingCommaWarning7() { parseError("var a = {,};", BAD_PROPERTY_MESSAGE); } public void testSuspiciousBlockCommentWarning1() { parse("/* @type {number} */ var x = 3;", SUSPICIOUS_COMMENT_WARNING); } public void testSuspiciousBlockCommentWarning2() { parse("/* \n * @type {number} */ var x = 3;", SUSPICIOUS_COMMENT_WARNING); } public void testCatchClauseForbidden() { parseError("try { } catch (e if true) {}", "Catch clauses are not supported"); } public void testConstForbidden() { parseError("const x = 3;", "Unsupported syntax: CONST"); } public void testDestructuringAssignForbidden() { parseError("var [x, y] = foo();", "destructuring assignment forbidden"); } public void testDestructuringAssignForbidden2() { parseError("var {x, y} = foo();", "missing : after property id"); } public void testDestructuringAssignForbidden3() { parseError("var {x: x, y: y} = foo();", "destructuring assignment forbidden"); } public void testDestructuringAssignForbidden4() { parseError("[x, y] = foo();", "destructuring assignment forbidden", "invalid assignment target"); } public void testLetForbidden() { parseError("function f() { let (x = 3) { alert(x); }; }", "missing ; before statement", "syntax error"); } public void testYieldForbidden() { parseError("function f() { yield 3; }", "missing ; before statement"); } public void testBracelessFunctionForbidden() { parseError("var sq = function(x) x * x;", "missing { before function body"); } public void testGeneratorsForbidden() { parseError("var i = (x for (x in obj));", "Unsupported syntax: GENEXPR"); } public void testGettersForbidden1() { parseError("var x = {get foo() { return 3; }};", IRFactory.GETTER_ERROR_MESSAGE); } public void testGettersForbidden2() { parseError("var x = {get foo bar() { return 3; }};", "invalid property id"); } public void testGettersForbidden3() { parseError("var x = {a getter:function b() { return 3; }};", "missing : after property id", "syntax error"); } public void testGettersForbidden4() { parseError("var x = {\"a\" getter:function b() { return 3; }};", "missing : after property id", "syntax error"); } public void testGettersForbidden5() { parseError("var x = {a: 2, get foo() { return 3; }};", IRFactory.GETTER_ERROR_MESSAGE); } public void testSettersForbidden() { parseError("var x = {set foo() { return 3; }};", IRFactory.SETTER_ERROR_MESSAGE); } public void testSettersForbidden2() { parseError("var x = {a setter:function b() { return 3; }};", "missing : after property id", "syntax error"); } public void testFileOverviewJSDoc1() { Node n = parse("/** @fileoverview Hi mom! */ function Foo() {}"); assertEquals(Token.FUNCTION, n.getFirstChild().getType()); assertTrue(n.getJSDocInfo() != null); assertNull(n.getFirstChild().getJSDocInfo()); assertEquals("Hi mom!", n.getJSDocInfo().getFileOverview()); } public void testFileOverviewJSDocDoesNotHoseParsing() { assertEquals( Token.FUNCTION, parse("/** @fileoverview Hi mom! \n */ function Foo() {}") .getFirstChild().getType()); assertEquals( Token.FUNCTION, parse("/** @fileoverview Hi mom! \n * * * */ function Foo() {}") .getFirstChild().getType()); assertEquals( Token.FUNCTION, parse("/** @fileoverview \n * x */ function Foo() {}") .getFirstChild().getType()); assertEquals( Token.FUNCTION, parse("/** @fileoverview \n * x \n */ function Foo() {}") .getFirstChild().getType()); } public void testFileOverviewJSDoc2() { Node n = parse("/** @fileoverview Hi mom! */ " + "/** @constructor */ function Foo() {}"); assertTrue(n.getJSDocInfo() != null); assertEquals("Hi mom!", n.getJSDocInfo().getFileOverview()); assertTrue(n.getFirstChild().getJSDocInfo() != null); assertFalse(n.getFirstChild().getJSDocInfo().hasFileOverview()); assertTrue(n.getFirstChild().getJSDocInfo().isConstructor()); } public void testObjectLiteralDoc1() { Node n = parse("var x = {/** @type {number} */ 1: 2};"); Node objectLit = n.getFirstChild().getFirstChild().getFirstChild(); assertEquals(Token.OBJECTLIT, objectLit.getType()); Node number = objectLit.getFirstChild(); assertEquals(Token.STRING_KEY, number.getType()); assertNotNull(number.getJSDocInfo()); } public void testDuplicatedParam() { parse("function foo(x, x) {}", "Duplicate parameter name \"x\"."); } public void testGetter() { mode = LanguageMode.ECMASCRIPT3; parseError("var x = {get 1(){}};", IRFactory.GETTER_ERROR_MESSAGE); parseError("var x = {get 'a'(){}};", IRFactory.GETTER_ERROR_MESSAGE); parseError("var x = {get a(){}};", IRFactory.GETTER_ERROR_MESSAGE); mode = LanguageMode.ECMASCRIPT5; parse("var x = {get 1(){}};"); parse("var x = {get 'a'(){}};"); parse("var x = {get a(){}};"); parseError("var x = {get a(b){}};", "getters may not have parameters"); } public void testSetter() { mode = LanguageMode.ECMASCRIPT3; parseError("var x = {set 1(x){}};", IRFactory.SETTER_ERROR_MESSAGE); parseError("var x = {set 'a'(x){}};", IRFactory.SETTER_ERROR_MESSAGE); parseError("var x = {set a(x){}};", IRFactory.SETTER_ERROR_MESSAGE); mode = LanguageMode.ECMASCRIPT5; parse("var x = {set 1(x){}};"); parse("var x = {set 'a'(x){}};"); parse("var x = {set a(x){}};"); parseError("var x = {set a(){}};", "setters must have exactly one parameter"); } public void testLamestWarningEver() { // This used to be a warning. parse("var x = /** @type {undefined} */ (y);"); parse("var x = /** @type {void} */ (y);"); } public void testUnfinishedComment() { parseError("/** this is a comment ", "unterminated comment"); } public void testParseBlockDescription() { Node n = parse("/** This is a variable. */ var x;"); Node var = n.getFirstChild(); assertNotNull(var.getJSDocInfo()); assertEquals("This is a variable.", var.getJSDocInfo().getBlockDescription()); } public void testUnnamedFunctionStatement() { // Statements parseError("function() {};", "unnamed function statement"); parseError("if (true) { function() {}; }", "unnamed function statement"); parse("function f() {};"); // Expressions parse("(function f() {});"); parse("(function () {});"); } public void testReservedKeywords() { boolean isIdeMode = false; mode = LanguageMode.ECMASCRIPT3; parseError("var boolean;", "missing variable name"); parseError("function boolean() {};", "missing ( before function parameters."); parseError("boolean = 1;", "identifier is a reserved word"); parseError("class = 1;", "identifier is a reserved word"); parseError("public = 2;", "identifier is a reserved word"); mode = LanguageMode.ECMASCRIPT5; parse("var boolean;"); parse("function boolean() {};"); parse("boolean = 1;"); parseError("class = 1;", "identifier is a reserved word"); parse("public = 2;"); mode = LanguageMode.ECMASCRIPT5_STRICT; parse("var boolean;"); parse("function boolean() {};"); parse("boolean = 1;"); parseError("class = 1;", "identifier is a reserved word"); parseError("public = 2;", "identifier is a reserved word"); } public void testKeywordsAsProperties() { boolean isIdeMode = false; mode = LanguageMode.ECMASCRIPT3; parseError("var x = {function: 1};", "invalid property id"); parseError("x.function;", "missing name after . operator"); parseError("var x = {get x(){} };", IRFactory.GETTER_ERROR_MESSAGE); parseError("var x = {get function(){} };", "invalid property id"); parseError("var x = {get 'function'(){} };", IRFactory.GETTER_ERROR_MESSAGE); parseError("var x = {get 1(){} };", IRFactory.GETTER_ERROR_MESSAGE); parseError("var x = {set function(a){} };", "invalid property id"); parseError("var x = {set 'function'(a){} };", IRFactory.SETTER_ERROR_MESSAGE); parseError("var x = {set 1(a){} };", IRFactory.SETTER_ERROR_MESSAGE); parseError("var x = {class: 1};", "invalid property id"); parseError("x.class;", "missing name after . operator"); parse("var x = {let: 1};"); parse("x.let;"); parse("var x = {yield: 1};"); parse("x.yield;"); mode = LanguageMode.ECMASCRIPT5; parse("var x = {function: 1};"); parse("x.function;"); parse("var x = {get function(){} };"); parse("var x = {get 'function'(){} };"); parse("var x = {get 1(){} };"); parse("var x = {set function(a){} };"); parse("var x = {set 'function'(a){} };"); parse("var x = {set 1(a){} };"); parse("var x = {class: 1};"); parse("x.class;"); parse("var x = {let: 1};"); parse("x.let;"); parse("var x = {yield: 1};"); parse("x.yield;"); mode = LanguageMode.ECMASCRIPT5_STRICT; parse("var x = {function: 1};"); parse("x.function;"); parse("var x = {get function(){} };"); parse("var x = {get 'function'(){} };"); parse("var x = {get 1(){} };"); parse("var x = {set function(a){} };"); parse("var x = {set 'function'(a){} };"); parse("var x = {set 1(a){} };"); parse("var x = {class: 1};"); parse("x.class;"); parse("var x = {let: 1};"); parse("x.let;"); parse("var x = {yield: 1};"); parse("x.yield;"); } public void testGetPropFunctionName() { parseError("function a.b() {}", "missing ( before function parameters."); parseError("var x = function a.b() {}", "missing ( before function parameters."); } public void testGetPropFunctionNameIdeMode() { // In IDE mode, we try to fix up the tree, but sometimes // this leads to even more errors. isIdeMode = true; parseError("function a.b() {}", "missing ( before function parameters.", "missing formal parameter", "missing ) after formal parameters", "missing { before function body", "syntax error", "missing ; before statement", "missing ; before statement", "missing } after function body", "Unsupported syntax: ERROR", "Unsupported syntax: ERROR"); parseError("var x = function a.b() {}", "missing ( before function parameters.", "missing formal parameter", "missing ) after formal parameters", "missing { before function body", "syntax error", "missing ; before statement", "missing ; before statement", "missing } after function body", "Unsupported syntax: ERROR", "Unsupported syntax: ERROR"); } public void testIdeModePartialTree() { Node partialTree = parseError("function Foo() {} f.", "missing name after . operator"); assertNull(partialTree); isIdeMode = true; partialTree = parseError("function Foo() {} f.", "missing name after . operator"); assertNotNull(partialTree); } public void testForEach() { parseError( "function f(stamp, status) {\n" + " for each ( var curTiming in this.timeLog.timings ) {\n" + " if ( curTiming.callId == stamp ) {\n" + " curTiming.flag = status;\n" + " break;\n" + " }\n" + " }\n" + "};", "unsupported language extension: for each"); } public void testMisplacedTypeAnnotation1() { // misuse with COMMA parse( "var o = {};" + "/** @type {string} */ o.prop1 = 1, o.prop2 = 2;", MISPLACED_TYPE_ANNOTATION); } public void testMisplacedTypeAnnotation2() { // missing parenthese for the cast. parse( "var o = /** @type {string} */ getValue();", MISPLACED_TYPE_ANNOTATION); } public void testMisplacedTypeAnnotation3() { // missing parenthese for the cast. parse( "var o = 1 + /** @type {string} */ value;", MISPLACED_TYPE_ANNOTATION); } public void testMisplacedTypeAnnotation4() { // missing parenthese for the cast. parse( "var o = /** @type {!Array.<string>} */ ['hello', 'you'];", MISPLACED_TYPE_ANNOTATION); } public void testMisplacedTypeAnnotation5() { // missing parenthese for the cast. parse( "var o = (/** @type {!Foo} */ {});", MISPLACED_TYPE_ANNOTATION); } public void testMisplacedTypeAnnotation6() { parse("var o = /** @type {function():string} */ function() {return 'str';}", MISPLACED_TYPE_ANNOTATION); } public void testValidTypeAnnotation1() { parse("/** @type {string} */ var o = 'str';"); parse("var /** @type {string} */ o = 'str', /** @type {number} */ p = 0;"); parse("/** @type {function():string} */ function o() { return 'str'; }"); parse("var o = {}; /** @type {string} */ o.prop = 'str';"); parse("var o = {}; /** @type {string} */ o['prop'] = 'str';"); parse("var o = { /** @type {string} */ prop : 'str' };"); parse("var o = { /** @type {string} */ 'prop' : 'str' };"); parse("var o = { /** @type {string} */ 1 : 'str' };"); } public void testValidTypeAnnotation2() { mode = LanguageMode.ECMASCRIPT5; parse("var o = { /** @type {string} */ get prop() { return 'str' }};"); parse("var o = { /** @type {string} */ set prop(s) {}};"); } public void testValidTypeAnnotation3() { // These two we don't currently support in the type checker but // we would like to. parse("try {} catch (/** @type {Error} */ e) {}"); parse("function f(/** @type {string} */ a) {}"); } /** * Verify that the given code has the given parse errors. * @return If in IDE mode, returns a partial tree. */ private Node parseError(String string, String... errors) { TestErrorReporter testErrorReporter = new TestErrorReporter(errors, null); Node script = null; try { StaticSourceFile file = new SimpleSourceFile("input", false); script = ParserRunner.parse( file, string, ParserRunner.createConfig(isIdeMode, mode, false), testErrorReporter, Logger.getAnonymousLogger()).ast; } catch (IOException e) { throw new RuntimeException(e); } // verifying that all warnings were seen assertTrue(testErrorReporter.hasEncounteredAllErrors()); assertTrue(testErrorReporter.hasEncounteredAllWarnings()); return script; } private Node parse(String string, String... warnings) { TestErrorReporter testErrorReporter = new TestErrorReporter(null, warnings); Node script = null; try { StaticSourceFile file = new SimpleSourceFile("input", false); script = ParserRunner.parse( file, string, ParserRunner.createConfig(true, mode, false), testErrorReporter, Logger.getAnonymousLogger()).ast; } catch (IOException e) { throw new RuntimeException(e); } // verifying that all warnings were seen assertTrue(testErrorReporter.hasEncounteredAllErrors()); assertTrue(testErrorReporter.hasEncounteredAllWarnings()); return script; } private static class ParserResult { private final String code; private final Node node; private ParserResult(String code, Node node) { this.code = code; this.node = node; } } }
/* * Copyright 2011 The Closure Compiler Authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.google.javascript.jscomp.regex; import java.util.BitSet; import java.util.Random; import com.google.javascript.jscomp.regex.CharRanges; import junit.framework.TestCase; public class CharRangesTest extends TestCase { static final long SEED = Long.parseLong(System.getProperty( "junit.random.seed", "" + System.currentTimeMillis())); public final void testAgainstRegularImplementation() { Random rnd = new Random(SEED); for (int run = 10; --run >= 0;) { // Fill with bits in the range [0x1000, 0x3000). BitSet bs = new BitSet(); for (int i = 0x1000; --i >= 0;) { bs.set(0x1000 + rnd.nextInt(0x3000)); } // Create an equivalent sparse bit set int[] members = new int[bs.cardinality()]; for (int i = -1, k = 0; k < members.length; ++k) { members[k] = i = bs.nextSetBit(i + 1); } CharRanges sbs = CharRanges.withMembers(members); // Check all bits including past the min/max bit for (int i = 0; i < 0x5000; ++i) { if (bs.get(i) != sbs.contains(i)) { fail("sbs=" + sbs + ", bs=" + bs + ", difference at bit " + i); } } } } public final void testEmptyCharRanges() { CharRanges sbs = CharRanges.EMPTY; for (int i = -1000; i < 1000; ++i) { assertFalse(sbs.contains(i)); } assertEquals("[]", sbs.toString()); } public final void testCharRangesFactories() { CharRanges isbs = CharRanges.withMembers(new int[] { 0, 1, 4, 9 }); CharRanges isbs2 = CharRanges.withMembers(new int[] { 0, 1, 4, 9 }); assertEquals("[0x0-0x1 0x4 0x9]", isbs.toString()); CharRanges esbs = CharRanges.withMembers(new int[0]); assertEquals(isbs, isbs); assertEquals(isbs, isbs2); assertFalse(isbs.equals(esbs)); assertFalse(isbs.equals(null)); assertFalse(isbs.equals(new Object())); assertEquals(isbs.hashCode(), isbs2.hashCode()); assertFalse(isbs.hashCode() == esbs.hashCode()); } public final void testRangeConstructor() { try { CharRanges.withRanges(new int[] { 1 }); fail("Mismatched ranges"); } catch (IllegalArgumentException ex) { // pass } try { CharRanges.withRanges(new int[] { 1, 4, 4, 5 }); fail("Discontiguous ranges"); } catch (IllegalArgumentException ex) { // pass } try { CharRanges.withRanges(new int[] { 4, 5, 1, 3 }); fail("Misordered ranges"); } catch (IllegalArgumentException ex) { // pass } try { CharRanges.withRanges(new int[] { 0, 0 }); fail("Empty range"); } catch (IllegalArgumentException ex) { // pass } } public final void testDupeMembers() { CharRanges sbs1 = CharRanges.withMembers(new int[] { 0, 1, 4, 9 }); assertEquals(sbs1.toString(), "[0x0-0x1 0x4 0x9]", sbs1.toString()); CharRanges sbs2 = CharRanges.withMembers(new int[] { 9, 1, 4, 1, 0 }); assertEquals(sbs2.toString(), "[0x0-0x1 0x4 0x9]", sbs2.toString()); assertEquals(sbs1, sbs2); assertEquals(sbs1.hashCode(), sbs2.hashCode()); for (int i = -10; i < 20; ++i) { assertEquals("" + i, sbs1.contains(i), sbs2.contains(i)); } } public final void testDifference() { // 1 2 3 // 0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0 // b-a DD DD DDD D DDD // a AAAAAAAAA A A A A A AAA AAA A A // b BBB BBB BBB BBB B B BBB // a-b DD DD D D D D DDD DDD D D CharRanges a = CharRanges.withRanges(new int[] { 0x03, 0x0C, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1C, 0x1D, 0x1E, 0x21, 0x24, 0x27, 0x28, 0x29, 0x2A, 0x2B }); CharRanges b = CharRanges.withRanges(new int[] { 0x01, 0x04, 0x06, 0x09, 0x0B, 0x0E, 0x0F, 0x12, 0x1A, 0x1B, 0x1C, 0x1D, 0x21, 0x24 }); CharRanges empty = CharRanges.withMembers(new int[0]); assertEquals(empty, empty.union(empty)); assertEquals(a, a.union(empty)); assertEquals(b, empty.union(b)); CharRanges aSb = a.difference(b); assertEquals( "[0x4-0x5 0x9-0xa 0x12 0x14 0x16 0x18 0x1e-0x20 0x24-0x26 0x28 0x2a]", aSb.toString()); assertTrue(a.containsAll(aSb)); assertFalse(aSb.containsAll(a)); assertFalse(aSb.containsAll(b)); CharRanges bSa = b.difference(a); assertEquals( "[0x1-0x2 0xc-0xd 0xf-0x11 0x1a 0x21-0x23]", bSa.toString()); assertTrue(b.containsAll(bSa)); assertFalse(bSa.containsAll(a)); assertFalse(bSa.containsAll(b)); // Check that a and b not changed by operation assertEquals( "[0x3-0xb 0x12 0x14 0x16 0x18 0x1c 0x1e-0x20 0x24-0x26 0x28 0x2a]", a.toString()); assertEquals( "[0x1-0x3 0x6-0x8 0xb-0xd 0xf-0x11 0x1a 0x1c 0x21-0x23]", b.toString()); // 0 1 2 3 4 5 6 7 8 9 a b c d e f // m: * * * * * * * * * // s: * * * * * * * * // d: * * * * * CharRanges m = CharRanges.withMembers(0, 1, 2, 3, 6, 9, 0xa, 0xe, 0xf); CharRanges s = CharRanges.withMembers(2, 5, 6, 7, 0xa, 0xb, 0xd, 0xe); CharRanges d = m.difference(s); assertEquals("[0x0-0x1 0x3 0x9 0xf]", d.toString()); assertTrue(m.containsAll(d)); assertFalse(d.containsAll(m)); assertFalse(d.containsAll(s)); assertFalse(s.containsAll(d)); assertTrue(d.containsAll(d)); } public final void testUnion() { // 1 2 3 // 0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0 // AAAAAAAAA A A A A A AAA AAA A A // BBB BBB BBB BBB B B BBB // UUUUUUUUUUUUU UUUU U U U U U UUUUUUUUU U U CharRanges a = CharRanges.withRanges(new int[] { 0x03, 0x0C, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1C, 0x1D, 0x1E, 0x21, 0x24, 0x27, 0x28, 0x29, 0x2A, 0x2B }); CharRanges b = CharRanges.withRanges(new int[] { 0x01, 0x04, 0x06, 0x09, 0x0B, 0x0E, 0x0F, 0x12, 0x1A, 0x1B, 0x1C, 0x1D, 0x21, 0x24 }); CharRanges empty = CharRanges.withMembers(new int[0]); assertEquals(empty, empty.union(empty)); assertEquals(a, a.union(empty)); assertEquals(b, empty.union(b)); CharRanges aUb = a.union(b); assertEquals( "[0x1-0xd 0xf-0x12 0x14 0x16 0x18 0x1a 0x1c 0x1e-0x26 0x28 0x2a]", aUb.toString()); assertEquals(aUb, b.union(a)); assertTrue(aUb.containsAll(a)); assertTrue(aUb.containsAll(b)); assertFalse(a.containsAll(b)); assertFalse(b.containsAll(a)); assertTrue(a.containsAll(a)); assertTrue(b.containsAll(b)); assertTrue(aUb.containsAll(aUb)); // Check that a and b not changed by operation assertEquals( "[0x3-0xb 0x12 0x14 0x16 0x18 0x1c 0x1e-0x20 0x24-0x26 0x28 0x2a]", a.toString()); assertEquals( "[0x1-0x3 0x6-0x8 0xb-0xd 0xf-0x11 0x1a 0x1c 0x21-0x23]", b.toString()); } }
/* * * ***** BEGIN LICENSE BLOCK ***** * Version: MPL 1.1/GPL 2.0 * * The contents of this file are subject to the Mozilla Public License Version * 1.1 (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * http://www.mozilla.org/MPL/ * * Software distributed under the License is distributed on an "AS IS" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License * for the specific language governing rights and limitations under the * License. * * The Original Code is Rhino code, released * May 6, 1999. * * The Initial Developer of the Original Code is * Netscape Communications Corporation. * Portions created by the Initial Developer are Copyright (C) 1997-1999 * the Initial Developer. All Rights Reserved. * * Contributor(s): * John Lenz * * Alternatively, the contents of this file may be used under the terms of * the GNU General Public License Version 2 or later (the "GPL"), in which * case the provisions of the GPL are applicable instead of those above. If * you wish to allow use of your version of this file only under the terms of * the GPL and not to allow others to use your version of this file under the * MPL, indicate your decision by deleting the provisions above and replacing * them with the notice and other provisions required by the GPL. If you do * not delete the provisions above, a recipient may use your version of this * file under either the MPL or the GPL. * * ***** END LICENSE BLOCK ***** */ package com.google.javascript.rhino; import com.google.common.collect.Lists; import junit.framework.TestCase; /** * @author johnlenz@google.com (John Lenz) */ public class IRTest extends TestCase { public void testEmpty() { testIR(IR.empty(), "EMPTY\n"); } public void testFunction() { testIR(IR.function(IR.name("hi"), IR.paramList(), IR.block()), "FUNCTION hi\n" + " NAME hi\n" + " PARAM_LIST\n" + " BLOCK\n"); } public void testParamList() { testIR(IR.paramList(), "PARAM_LIST\n"); testIR(IR.paramList(IR.name("a"), IR.name("b")), "PARAM_LIST\n" + " NAME a\n" + " NAME b\n"); testIR(IR.paramList(Lists.newArrayList(IR.name("a"), IR.name("b"))), "PARAM_LIST\n" + " NAME a\n" + " NAME b\n"); } public void testBlock() { testIR(IR.block(), "BLOCK\n"); testIR(IR.block(IR.empty(), IR.empty()), "BLOCK\n" + " EMPTY\n" + " EMPTY\n"); testIR(IR.block(Lists.newArrayList(IR.empty(), IR.empty())), "BLOCK\n" + " EMPTY\n" + " EMPTY\n"); } public void testScript() { testIR(IR.script(), "SCRIPT\n"); testIR(IR.script(IR.empty(), IR.empty()), "SCRIPT\n" + " EMPTY\n" + " EMPTY\n"); testIR(IR.script(Lists.newArrayList(IR.empty(), IR.empty())), "SCRIPT\n" + " EMPTY\n" + " EMPTY\n"); } public void testScriptThrows() { boolean caught = false; try { IR.script(IR.returnNode()); } catch(IllegalStateException e) { caught = true; } assertTrue("expected exception was not seen", caught); } public void testVar() { testIR(IR.var(IR.name("a")), "VAR\n" + " NAME a\n"); testIR(IR.var(IR.name("a"), IR.trueNode()), "VAR\n" + " NAME a\n" + " TRUE\n"); } public void testReturn() { testIR(IR.returnNode(), "RETURN\n"); testIR(IR.returnNode(IR.name("a")), "RETURN\n" + " NAME a\n"); } public void testThrow() { testIR(IR.throwNode(IR.name("a")), "THROW\n" + " NAME a\n"); } public void testExprResult() { testIR(IR.exprResult(IR.name("a")), "EXPR_RESULT\n" + " NAME a\n"); } public void testIf() { testIR(IR.ifNode(IR.name("a"), IR.block()), "IF\n" + " NAME a\n" + " BLOCK\n"); testIR(IR.ifNode(IR.name("a"), IR.block(), IR.block()), "IF\n" + " NAME a\n" + " BLOCK\n" + " BLOCK\n"); } public void testIssue727_1() { testIR( IR.tryFinally( IR.block(), IR.block()), "TRY\n" + " BLOCK\n" + " BLOCK\n" + " BLOCK\n"); } public void testIssue727_2() { testIR( IR.tryCatch( IR.block(), IR.catchNode( IR.name("e"), IR.block())), "TRY\n" + " BLOCK\n" + " BLOCK\n" + " CATCH\n" + " NAME e\n" + " BLOCK\n"); } public void testIssue727_3() { testIR( IR.tryCatchFinally( IR.block(), IR.catchNode(IR.name("e"), IR.block()), IR.block()), "TRY\n" + " BLOCK\n" + " BLOCK\n" + " CATCH\n" + " NAME e\n" + " BLOCK\n" + " BLOCK\n"); } private void testIR(Node node, String expectedStructure) { assertEquals(expectedStructure, node.toStringTree()); } }
/* * * ***** BEGIN LICENSE BLOCK ***** * Version: MPL 1.1/GPL 2.0 * * The contents of this file are subject to the Mozilla Public License Version * 1.1 (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * http://www.mozilla.org/MPL/ * * Software distributed under the License is distributed on an "AS IS" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License * for the specific language governing rights and limitations under the * License. * * The Original Code is Rhino code, released * May 6, 1999. * * The Initial Developer of the Original Code is * Netscape Communications Corporation. * Portions created by the Initial Developer are Copyright (C) 1997-1999 * the Initial Developer. All Rights Reserved. * * Contributor(s): * Nick Santos * * Alternatively, the contents of this file may be used under the terms of * the GNU General Public License Version 2 or later (the "GPL"), in which * case the provisions of the GPL are applicable instead of those above. If * you wish to allow use of your version of this file only under the terms of * the GPL and not to allow others to use your version of this file under the * MPL, indicate your decision by deleting the provisions above and replacing * them with the notice and other provisions required by the GPL. If you do * not delete the provisions above, a recipient may use your version of this * file under either the MPL or the GPL. * * ***** END LICENSE BLOCK ***** */ package com.google.javascript.rhino; import static com.google.javascript.rhino.JSDocInfo.Visibility.PRIVATE; import static com.google.javascript.rhino.JSDocInfo.Visibility.PROTECTED; import static com.google.javascript.rhino.JSDocInfo.Visibility.PUBLIC; import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_OBJECT_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE; import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE; import com.google.common.collect.Sets; import com.google.javascript.rhino.jstype.JSType; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.testing.Asserts; import com.google.javascript.rhino.testing.TestErrorReporter; import junit.framework.TestCase; public class JSDocInfoTest extends TestCase { private TestErrorReporter errorReporter = new TestErrorReporter(null, null); private JSTypeRegistry registry = new JSTypeRegistry(errorReporter); private JSType getNativeType(JSTypeNative typeId) { return registry.getNativeType(typeId); } /** * Tests the assigned ordinal of the elements of the * {@link JSDocInfo.Visibility} enum. */ public void testVisibilityOrdinal() { assertEquals(0, PRIVATE.ordinal()); assertEquals(1, PROTECTED.ordinal()); assertEquals(2, PUBLIC.ordinal()); } public void testSetType() { JSDocInfo info = new JSDocInfo(); info.setType(fromString("string")); assertNull(info.getBaseType()); assertNull(info.getDescription()); assertNull(info.getEnumParameterType()); assertEquals(0, info.getParameterCount()); assertNull(info.getReturnType()); assertTypeEquals(STRING_TYPE, resolve(info.getType())); assertNull(info.getVisibility()); assertTrue(info.hasType()); assertFalse(info.isConstant()); assertFalse(info.isConstructor()); assertFalse(info.isHidden()); assertFalse(info.shouldPreserveTry()); } public void testSetTypeAndVisibility() { JSDocInfo info = new JSDocInfo(); info.setType(fromString("string")); info.setVisibility(PROTECTED); assertNull(info.getBaseType()); assertNull(info.getDescription()); assertNull(info.getEnumParameterType()); assertEquals(0, info.getParameterCount()); assertNull(info.getReturnType()); assertTypeEquals(STRING_TYPE, resolve(info.getType())); assertEquals(PROTECTED, info.getVisibility()); assertTrue(info.hasType()); assertFalse(info.isConstant()); assertFalse(info.isConstructor()); assertFalse(info.isHidden()); assertFalse(info.shouldPreserveTry()); } public void testSetReturnType() { JSDocInfo info = new JSDocInfo(); info.setReturnType(fromString("string")); assertNull(info.getBaseType()); assertNull(info.getDescription()); assertNull(info.getEnumParameterType()); assertEquals(0, info.getParameterCount()); assertTypeEquals(STRING_TYPE, resolve(info.getReturnType())); assertNull(info.getType()); assertNull(info.getVisibility()); assertFalse(info.hasType()); assertFalse(info.isConstant()); assertFalse(info.isConstructor()); assertFalse(info.isHidden()); assertFalse(info.shouldPreserveTry()); } public void testSetReturnTypeAndBaseType() { JSDocInfo info = new JSDocInfo(); info.setBaseType( new JSTypeExpression( new Node(Token.BANG, Node.newString("Number")), "")); info.setReturnType(fromString("string")); assertTypeEquals(NUMBER_OBJECT_TYPE, resolve(info.getBaseType())); assertNull(info.getDescription()); assertNull(info.getEnumParameterType()); assertEquals(0, info.getParameterCount()); assertTypeEquals(STRING_TYPE, resolve(info.getReturnType())); assertNull(info.getType()); assertNull(info.getVisibility()); assertFalse(info.hasType()); assertFalse(info.isConstant()); assertFalse(info.isConstructor()); assertFalse(info.isHidden()); assertFalse(info.shouldPreserveTry()); } public void testSetEnumParameterType() { JSDocInfo info = new JSDocInfo(); info.setEnumParameterType(fromString("string")); assertNull(info.getBaseType()); assertNull(info.getDescription()); assertTypeEquals(STRING_TYPE, resolve(info.getEnumParameterType())); assertEquals(0, info.getParameterCount()); assertNull(info.getReturnType()); assertNull(info.getType()); assertNull(info.getVisibility()); assertFalse(info.hasType()); assertFalse(info.isConstant()); assertFalse(info.isConstructor()); assertFalse(info.isHidden()); assertFalse(info.shouldPreserveTry()); } public void testMultipleSetType() { JSDocInfo info = new JSDocInfo(); info.setType(fromString("number")); try { info.setReturnType(fromString("boolean")); fail("Expected exception"); } catch (IllegalStateException e) {} try { info.setEnumParameterType(fromString("string")); fail("Expected exception"); } catch (IllegalStateException e) {} try { info.setTypedefType(fromString("string")); fail("Expected exception"); } catch (IllegalStateException e) {} assertTypeEquals(NUMBER_TYPE, resolve(info.getType())); assertNull(info.getReturnType()); assertNull(info.getEnumParameterType()); assertNull(info.getTypedefType()); assertTrue(info.hasType()); } public void testMultipleSetType2() { JSDocInfo info = new JSDocInfo(); info.setReturnType(fromString("boolean")); try { info.setType(fromString("number")); fail("Expected exception"); } catch (IllegalStateException e) {} try { info.setEnumParameterType(fromString("string")); fail("Expected exception"); } catch (IllegalStateException e) {} try { info.setTypedefType(fromString("string")); fail("Expected exception"); } catch (IllegalStateException e) {} assertTypeEquals(BOOLEAN_TYPE, resolve(info.getReturnType())); assertNull(info.getEnumParameterType()); assertNull(info.getType()); assertNull(info.getTypedefType()); assertFalse(info.hasType()); } public void testMultipleSetType3() { JSDocInfo info = new JSDocInfo(); info.setEnumParameterType(fromString("boolean")); try { info.setType(fromString("number")); fail("Expected exception"); } catch (IllegalStateException e) {} try { info.setReturnType(fromString("string")); fail("Expected exception"); } catch (IllegalStateException e) {} try { info.setTypedefType(fromString("string")); fail("Expected exception"); } catch (IllegalStateException e) {} assertNull(info.getType()); assertNull(info.getTypedefType()); assertNull(info.getReturnType()); assertTypeEquals(BOOLEAN_TYPE, resolve(info.getEnumParameterType())); } public void testSetTypedefType() { JSDocInfo info = new JSDocInfo(); info.setTypedefType(fromString("boolean")); assertTypeEquals(BOOLEAN_TYPE, resolve(info.getTypedefType())); assertTrue(info.hasTypedefType()); assertFalse(info.hasType()); assertFalse(info.hasEnumParameterType()); assertFalse(info.hasReturnType()); } public void testSetConstant() { JSDocInfo info = new JSDocInfo(); info.setConstant(true); assertFalse(info.hasType()); assertTrue(info.isConstant()); assertFalse(info.isConstructor()); assertFalse(info.isDefine()); assertFalse(info.isHidden()); assertFalse(info.shouldPreserveTry()); } public void testSetConstructor() { JSDocInfo info = new JSDocInfo(); info.setConstructor(true); assertFalse(info.isConstant()); assertTrue(info.isConstructor()); assertFalse(info.isDefine()); assertFalse(info.isHidden()); assertFalse(info.shouldPreserveTry()); } public void testSetDefine() { JSDocInfo info = new JSDocInfo(); info.setDefine(true); assertTrue(info.isConstant()); assertFalse(info.isConstructor()); assertTrue(info.isDefine()); assertFalse(info.isHidden()); assertFalse(info.shouldPreserveTry()); } public void testSetHidden() { JSDocInfo info = new JSDocInfo(); info.setHidden(true); assertFalse(info.hasType()); assertFalse(info.isConstant()); assertFalse(info.isConstructor()); assertFalse(info.isDefine()); assertTrue(info.isHidden()); assertFalse(info.shouldPreserveTry()); } public void testSetShouldPreserveTry() { JSDocInfo info = new JSDocInfo(); info.setShouldPreserveTry(true); assertFalse(info.isConstant()); assertFalse(info.isConstructor()); assertFalse(info.isDefine()); assertFalse(info.isHidden()); assertTrue(info.shouldPreserveTry()); } public void testSetNoTypeCheck() { JSDocInfo info = new JSDocInfo(); info.setNoCheck(true); assertFalse(info.isDeprecated()); assertFalse(info.isNoAlias()); assertFalse(info.isOverride()); assertTrue(info.isNoTypeCheck()); } public void testSetOverride() { JSDocInfo info = new JSDocInfo(); info.setOverride(true); assertFalse(info.isDeprecated()); assertFalse(info.isNoAlias()); assertTrue(info.isOverride()); } public void testSetExport() { JSDocInfo info = new JSDocInfo(); info.setExport(true); assertTrue(info.isExport()); } public void testSetNoAlias() { JSDocInfo info = new JSDocInfo(); info.setNoAlias(true); assertFalse(info.isDeprecated()); assertFalse(info.isOverride()); assertTrue(info.isNoAlias()); } public void testSetDeprecated() { JSDocInfo info = new JSDocInfo(); info.setDeprecated(true); assertFalse(info.isNoAlias()); assertFalse(info.isOverride()); assertTrue(info.isDeprecated()); } public void testMultipleSetFlags1() { JSDocInfo info = new JSDocInfo(); info.setConstant(true); info.setConstructor(true); info.setHidden(true); info.setShouldPreserveTry(true); assertFalse(info.hasType()); assertTrue(info.isConstant()); assertTrue(info.isConstructor()); assertFalse(info.isDefine()); assertTrue(info.isHidden()); assertTrue(info.shouldPreserveTry()); info.setHidden(false); assertTrue(info.isConstant()); assertTrue(info.isConstructor()); assertFalse(info.isDefine()); assertFalse(info.isHidden()); assertTrue(info.shouldPreserveTry()); info.setConstant(false); info.setConstructor(false); assertFalse(info.isConstant()); assertFalse(info.isConstructor()); assertFalse(info.isDefine()); assertFalse(info.isHidden()); assertTrue(info.shouldPreserveTry()); info.setConstructor(true); assertFalse(info.isConstant()); assertTrue(info.isConstructor()); assertFalse(info.isDefine()); assertFalse(info.isHidden()); assertTrue(info.shouldPreserveTry()); } public void testSetFileOverviewWithDocumentationOff() { JSDocInfo info = new JSDocInfo(); info.documentFileOverview("hi bob"); assertNull(info.getFileOverview()); } public void testSetFileOverviewWithDocumentationOn() { JSDocInfo info = new JSDocInfo(true); info.documentFileOverview("hi bob"); assertEquals("hi bob", info.getFileOverview()); } public void testSetSuppressions() { JSDocInfo info = new JSDocInfo(true); info.setSuppressions(Sets.newHashSet("sam", "bob")); assertEquals(Sets.newHashSet("bob", "sam"), info.getSuppressions()); } public void testSetModifies() { JSDocInfo info = new JSDocInfo(true); info.setModifies(Sets.newHashSet("this")); assertEquals(Sets.newHashSet("this"), info.getModifies()); info = new JSDocInfo(true); info.setModifies(Sets.newHashSet("arguments")); assertEquals(Sets.newHashSet("arguments"), info.getModifies()); } /** Gets the type expression for a simple type name. */ private JSTypeExpression fromString(String s) { return new JSTypeExpression(Node.newString(s), ""); } private JSType resolve(JSTypeExpression n, String... warnings) { errorReporter.setWarnings(warnings); return n.evaluate(null, registry); } private void assertTypeEquals(JSTypeNative a, JSType b) { assertTypeEquals(getNativeType(a), b); } private void assertTypeEquals(JSType a, JSType b) { Asserts.assertTypeEquals(a, b); } }
/* * * ***** BEGIN LICENSE BLOCK ***** * Version: MPL 1.1/GPL 2.0 * * The contents of this file are subject to the Mozilla Public License Version * 1.1 (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * http://www.mozilla.org/MPL/ * * Software distributed under the License is distributed on an "AS IS" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License * for the specific language governing rights and limitations under the * License. * * The Original Code is Rhino code, released * May 6, 1999. * * The Initial Developer of the Original Code is * Netscape Communications Corporation. * Portions created by the Initial Developer are Copyright (C) 1997-1999 * the Initial Developer. All Rights Reserved. * * Contributor(s): * Nick Santos * * Alternatively, the contents of this file may be used under the terms of * the GNU General Public License Version 2 or later (the "GPL"), in which * case the provisions of the GPL are applicable instead of those above. If * you wish to allow use of your version of this file only under the terms of * the GPL and not to allow others to use your version of this file under the * MPL, indicate your decision by deleting the provisions above and replacing * them with the notice and other provisions required by the GPL. If you do * not delete the provisions above, a recipient may use your version of this * file under either the MPL or the GPL. * * ***** END LICENSE BLOCK ***** */ package com.google.javascript.rhino; import com.google.javascript.rhino.Node.NodeMismatch; import com.google.javascript.rhino.jstype.JSTypeNative; import com.google.javascript.rhino.jstype.JSTypeRegistry; import com.google.javascript.rhino.testing.TestErrorReporter; import junit.framework.TestCase; public class NodeTest extends TestCase { public void testMergeExtractNormal() throws Exception { testMergeExtract(5, 6); testMergeExtract(456, 3423); testMergeExtract(0, 0); } public void testMergeExtractErroneous() throws Exception { assertEquals(-1, Node.mergeLineCharNo(-5, 90)); assertEquals(-1, Node.mergeLineCharNo(0, -1)); assertEquals(-1, Node.extractLineno(-1)); assertEquals(-1, Node.extractCharno(-1)); } public void testMergeOverflowGraciously() throws Exception { int linecharno = Node.mergeLineCharNo(89, 4096); assertEquals(89, Node.extractLineno(linecharno)); assertEquals(4095, Node.extractCharno(linecharno)); } public void testCheckTreeEqualsImplSame() { Node node1 = new Node(1, new Node(2)); Node node2 = new Node(1, new Node(2)); assertEquals(null, node1.checkTreeEqualsImpl(node2)); } public void testCheckTreeEqualsImplDifferentType() { Node node1 = new Node(1, new Node(2)); Node node2 = new Node(2, new Node(2)); assertEquals(new NodeMismatch(node1, node2), node1.checkTreeEqualsImpl(node2)); } public void testCheckTreeEqualsImplDifferentChildCount() { Node node1 = new Node(1, new Node(2)); Node node2 = new Node(1); assertEquals(new NodeMismatch(node1, node2), node1.checkTreeEqualsImpl(node2)); } public void testCheckTreeEqualsImplDifferentChild() { Node child1 = new Node(1); Node child2 = new Node(2); Node node1 = new Node(1, child1); Node node2 = new Node(1, child2); assertEquals(new NodeMismatch(child1, child2), node1.checkTreeEqualsImpl(node2)); } public void testCheckTreeEqualsSame() { Node node1 = new Node(1); assertEquals(null, node1.checkTreeEquals(node1)); } public void testCheckTreeEqualsStringDifferent() { Node node1 = new Node(Token.ADD); Node node2 = new Node(Token.SUB); assertNotNull(node1.checkTreeEquals(node2)); } public void testCheckTreeEqualsBooleanSame() { Node node1 = new Node(1); assertEquals(true, node1.isEquivalentTo(node1)); } public void testCheckTreeEqualsBooleanDifferent() { Node node1 = new Node(1); Node node2 = new Node(2); assertEquals(false, node1.isEquivalentTo(node2)); } public void testCheckTreeEqualsSlashVDifferent() { Node node1 = Node.newString("\u000B"); node1.putBooleanProp(Node.SLASH_V, true); Node node2 = Node.newString("\u000B"); assertEquals(false, node1.isEquivalentTo(node2)); } public void testCheckTreeEqualsImplDifferentIncProp() { Node node1 = new Node(Token.INC); node1.putIntProp(Node.INCRDECR_PROP, 1); Node node2 = new Node(Token.INC); assertNotNull(node1.checkTreeEqualsImpl(node2)); } public void testCheckTreeTypeAwareEqualsSame() { TestErrorReporter testErrorReporter = new TestErrorReporter(null, null); JSTypeRegistry registry = new JSTypeRegistry(testErrorReporter); Node node1 = Node.newString(Token.NAME, "f"); node1.setJSType(registry.getNativeType(JSTypeNative.NUMBER_TYPE)); Node node2 = Node.newString(Token.NAME, "f"); node2.setJSType(registry.getNativeType(JSTypeNative.NUMBER_TYPE)); assertTrue(node1.isEquivalentToTyped(node2)); } public void testCheckTreeTypeAwareEqualsSameNull() { TestErrorReporter testErrorReporter = new TestErrorReporter(null, null); JSTypeRegistry registry = new JSTypeRegistry(testErrorReporter); Node node1 = Node.newString(Token.NAME, "f"); Node node2 = Node.newString(Token.NAME, "f"); assertTrue(node1.isEquivalentToTyped(node2)); } public void testCheckTreeTypeAwareEqualsDifferent() { TestErrorReporter testErrorReporter = new TestErrorReporter(null, null); JSTypeRegistry registry = new JSTypeRegistry(testErrorReporter); Node node1 = Node.newString(Token.NAME, "f"); node1.setJSType(registry.getNativeType(JSTypeNative.NUMBER_TYPE)); Node node2 = Node.newString(Token.NAME, "f"); node2.setJSType(registry.getNativeType(JSTypeNative.STRING_TYPE)); assertFalse(node1.isEquivalentToTyped(node2)); } public void testCheckTreeTypeAwareEqualsDifferentNull() { TestErrorReporter testErrorReporter = new TestErrorReporter(null, null); JSTypeRegistry registry = new JSTypeRegistry(testErrorReporter); Node node1 = Node.newString(Token.NAME, "f"); node1.setJSType(registry.getNativeType(JSTypeNative.NUMBER_TYPE)); Node node2 = Node.newString(Token.NAME, "f"); assertFalse(node1.isEquivalentToTyped(node2)); } public void testVarArgs1() { assertFalse(new Node(1).isVarArgs()); } public void testVarArgs2() { Node n = new Node(1); n.setVarArgs(false); assertFalse(n.isVarArgs()); } public void testVarArgs3() { Node n = new Node(1); n.setVarArgs(true); assertTrue(n.isVarArgs()); } private void testMergeExtract(int lineno, int charno) { int linecharno = Node.mergeLineCharNo(lineno, charno); assertEquals(lineno, Node.extractLineno(linecharno)); assertEquals(charno, Node.extractCharno(linecharno)); } public void testFileLevelJSDocAppender() { Node n = new Node(1); Node.FileLevelJsDocBuilder builder = n.getJsDocBuilderForNode(); builder.append("foo"); builder.append("bar"); assertEquals("foobar", n.getJSDocInfo().getLicense()); } // TODO(johnlenz): reenable this test. public void disable_testIsQualifiedName() { assertTrue(getNode("a").isQualifiedName()); assertTrue(getNode("$").isQualifiedName()); assertTrue(getNode("_").isQualifiedName()); assertTrue(getNode("a.b").isQualifiedName()); assertTrue(getNode("a_b.cccccc$d4.x.y.zA$").isQualifiedName()); assertTrue(getNode("this.foo").isQualifiedName()); assertFalse(getNode("0").isQualifiedName()); assertFalse(getNode("[]").isQualifiedName()); assertFalse(getNode("{}").isQualifiedName()); assertFalse(getNode("''").isQualifiedName()); assertFalse(getNode("a[b]").isQualifiedName()); assertFalse(getNode("a[b].c").isQualifiedName()); assertFalse(getNode("c.a[b]").isQualifiedName()); assertFalse(getNode("a()").isQualifiedName()); assertFalse(getNode("a().b").isQualifiedName()); assertFalse(getNode("b.a()").isQualifiedName()); assertFalse(getNode("'a'").isQualifiedName()); assertFalse(getNode("/x/").isQualifiedName()); assertFalse(getNode("++x").isQualifiedName()); } public void testCloneAnnontations() { Node n = getVarRef("a"); assertFalse(n.getBooleanProp(Node.IS_CONSTANT_NAME)); n.putBooleanProp(Node.IS_CONSTANT_NAME, true); assertTrue(n.getBooleanProp(Node.IS_CONSTANT_NAME)); Node nodeClone = n.cloneNode(); assertTrue(nodeClone.getBooleanProp(Node.IS_CONSTANT_NAME)); } public void testSharedProps1() { Node n = getVarRef("A"); n.putIntProp(Node.SIDE_EFFECT_FLAGS, 5); Node m = new Node(Token.TRUE); m.clonePropsFrom(n); assertEquals(m.getPropListHeadForTesting(), n.getPropListHeadForTesting()); assertEquals(5, n.getIntProp(Node.SIDE_EFFECT_FLAGS)); assertEquals(5, m.getIntProp(Node.SIDE_EFFECT_FLAGS)); } public void testSharedProps2() { Node n = getVarRef("A"); n.putIntProp(Node.SIDE_EFFECT_FLAGS, 5); Node m = new Node(Token.TRUE); m.clonePropsFrom(n); n.putIntProp(Node.SIDE_EFFECT_FLAGS, 6); assertEquals(6, n.getIntProp(Node.SIDE_EFFECT_FLAGS)); assertEquals(5, m.getIntProp(Node.SIDE_EFFECT_FLAGS)); assertFalse( m.getPropListHeadForTesting() == n.getPropListHeadForTesting()); m.putIntProp(Node.SIDE_EFFECT_FLAGS, 7); assertEquals(6, n.getIntProp(Node.SIDE_EFFECT_FLAGS)); assertEquals(7, m.getIntProp(Node.SIDE_EFFECT_FLAGS)); } public void testSharedProps3() { Node n = getVarRef("A"); n.putIntProp(Node.SIDE_EFFECT_FLAGS, 2); n.putIntProp(Node.INCRDECR_PROP, 3); Node m = new Node(Token.TRUE); m.clonePropsFrom(n); n.putIntProp(Node.SIDE_EFFECT_FLAGS, 4); assertEquals(4, n.getIntProp(Node.SIDE_EFFECT_FLAGS)); assertEquals(2, m.getIntProp(Node.SIDE_EFFECT_FLAGS)); } public void testBooleanProp() { Node n = getVarRef("a"); n.putBooleanProp(Node.IS_CONSTANT_NAME, false); assertNull(n.lookupProperty(Node.IS_CONSTANT_NAME)); assertFalse(n.getBooleanProp(Node.IS_CONSTANT_NAME)); n.putBooleanProp(Node.IS_CONSTANT_NAME, true); assertNotNull(n.lookupProperty(Node.IS_CONSTANT_NAME)); assertTrue(n.getBooleanProp(Node.IS_CONSTANT_NAME)); n.putBooleanProp(Node.IS_CONSTANT_NAME, false); assertNull(n.lookupProperty(Node.IS_CONSTANT_NAME)); assertFalse(n.getBooleanProp(Node.IS_CONSTANT_NAME)); } // Verify that annotations on cloned nodes are properly handled. public void testCloneAnnontations2() { Node n = getVarRef("a"); n.putBooleanProp(Node.IS_CONSTANT_NAME, true); n.putBooleanProp(Node.IS_DISPATCHER, true); assertTrue(n.getBooleanProp(Node.IS_CONSTANT_NAME)); assertTrue(n.getBooleanProp(Node.IS_DISPATCHER)); Node nodeClone = n.cloneNode(); assertTrue(nodeClone.getBooleanProp(Node.IS_CONSTANT_NAME)); assertTrue(nodeClone.getBooleanProp(Node.IS_DISPATCHER)); n.putBooleanProp(Node.IS_DISPATCHER, false); assertTrue(n.getBooleanProp(Node.IS_CONSTANT_NAME)); assertFalse(n.getBooleanProp(Node.IS_DISPATCHER)); assertTrue(nodeClone.getBooleanProp(Node.IS_CONSTANT_NAME)); assertTrue(nodeClone.getBooleanProp(Node.IS_DISPATCHER)); } public void testGetIndexOfChild() { Node assign = getAssignExpr("b","c"); assertEquals(2, assign.getChildCount()); Node firstChild = assign.getFirstChild(); Node secondChild = firstChild.getNext(); assertNotNull(secondChild); assertEquals(0, assign.getIndexOfChild(firstChild)); assertEquals(1, assign.getIndexOfChild(secondChild)); assertEquals(-1, assign.getIndexOfChild(assign)); } public void testCopyInformationFrom() { Node assign = getAssignExpr("b","c"); assign.setSourceEncodedPosition(99); assign.setSourceFileForTesting("foo.js"); Node lhs = assign.getFirstChild(); lhs.copyInformationFrom(assign); assertEquals(99, lhs.getSourcePosition()); assertEquals("foo.js", lhs.getSourceFileName()); assign.setSourceEncodedPosition(101); assign.setSourceFileForTesting("bar.js"); lhs.copyInformationFrom(assign); assertEquals(99, lhs.getSourcePosition()); assertEquals("foo.js", lhs.getSourceFileName()); } public void testUseSourceInfoIfMissingFrom() { Node assign = getAssignExpr("b","c"); assign.setSourceEncodedPosition(99); assign.setSourceFileForTesting("foo.js"); Node lhs = assign.getFirstChild(); lhs.useSourceInfoIfMissingFrom(assign); assertEquals(99, lhs.getSourcePosition()); assertEquals("foo.js", lhs.getSourceFileName()); assign.setSourceEncodedPosition(101); assign.setSourceFileForTesting("bar.js"); lhs.useSourceInfoIfMissingFrom(assign); assertEquals(99, lhs.getSourcePosition()); assertEquals("foo.js", lhs.getSourceFileName()); } public void testUseSourceInfoFrom() { Node assign = getAssignExpr("b","c"); assign.setSourceEncodedPosition(99); assign.setSourceFileForTesting("foo.js"); Node lhs = assign.getFirstChild(); lhs.useSourceInfoFrom(assign); assertEquals(99, lhs.getSourcePosition()); assertEquals("foo.js", lhs.getSourceFileName()); assign.setSourceEncodedPosition(101); assign.setSourceFileForTesting("bar.js"); lhs.useSourceInfoFrom(assign); assertEquals(101, lhs.getSourcePosition()); assertEquals("bar.js", lhs.getSourceFileName()); } public void testInvalidSourceOffset() { Node string = Node.newString("a"); string.setSourceEncodedPosition(-1); assertTrue(string.getSourceOffset() < 0); string.setSourceFileForTesting("foo.js"); assertTrue(string.getSourceOffset() < 0); } public void testQualifiedName() { assertNull(IR.name("").getQualifiedName()); assertEquals("a", IR.name("a").getQualifiedName()); assertEquals( "a.b", IR.getprop(IR.name("a"), IR.string("b")).getQualifiedName()); assertEquals( "this.b", IR.getprop(IR.thisNode(), IR.string("b")).getQualifiedName()); assertNull( IR.getprop(IR.call(IR.name("a")), IR.string("b")).getQualifiedName()); } private static Node getVarRef(String name) { return Node.newString(Token.NAME, name); } private static Node getAssignExpr(String name1, String name2) { return new Node(Token.ASSIGN, getVarRef(name1), getVarRef(name2)); } private static Node getNode(String js) { /* Node root = parse("var a=(" + js + ");"); Node expr = root.getFirstChild(); Node var = expr.getFirstChild(); return var.getFirstChild(); */ return null; } private static Node parse(String string) { /* CompilerEnvirons environment = new CompilerEnvirons(); TestErrorReporter testErrorReporter = new TestErrorReporter(null, null); environment.setErrorReporter(testErrorReporter); environment.setParseJSDoc(true); Parser p = new Parser(environment, testErrorReporter); return p.parse(string, null, 0); */ return null; } }
/* * * ***** BEGIN LICENSE BLOCK ***** * Version: MPL 1.1/GPL 2.0 * * The contents of this file are subject to the Mozilla Public License Version * 1.1 (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * http://www.mozilla.org/MPL/ * * Software distributed under the License is distributed on an "AS IS" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License * for the specific language governing rights and limitations under the * License. * * The Original Code is Rhino code, released * May 6, 1999. * * The Initial Developer of the Original Code is * Netscape Communications Corporation. * Portions created by the Initial Developer are Copyright (C) 1997-1999 * the Initial Developer. All Rights Reserved. * * Contributor(s): * Nick Santos * * Alternatively, the contents of this file may be used under the terms of * the GNU General Public License Version 2 or later (the "GPL"), in which * case the provisions of the GPL are applicable instead of those above. If * you wish to allow use of your version of this file only under the terms of * the GPL and not to allow others to use your version of this file under the * MPL, indicate your decision by deleting the provisions above and replacing * them with the notice and other provisions required by the GPL. If you do * not delete the provisions above, a recipient may use your version of this * file under either the MPL or the GPL. * * ***** END LICENSE BLOCK ***** */ package com.google.javascript.rhino.jstype; import static com.google.javascript.rhino.jstype.BooleanLiteralSet.BOTH; import static com.google.javascript.rhino.jstype.BooleanLiteralSet.EMPTY; import static com.google.javascript.rhino.jstype.BooleanLiteralSet.FALSE; import static com.google.javascript.rhino.jstype.BooleanLiteralSet.TRUE; import junit.framework.TestCase; /** * Tests {@link BooleanLiteralSet}. * */ public class BooleanLiteralSetTest extends TestCase { public void testIntersection() { assertEquals(EMPTY, EMPTY.intersection(EMPTY)); assertEquals(EMPTY, EMPTY.intersection(TRUE)); assertEquals(EMPTY, EMPTY.intersection(FALSE)); assertEquals(EMPTY, EMPTY.intersection(BOTH)); assertEquals(EMPTY, TRUE.intersection(EMPTY)); assertEquals(TRUE, TRUE.intersection(TRUE)); assertEquals(EMPTY, TRUE.intersection(FALSE)); assertEquals(TRUE, TRUE.intersection(BOTH)); assertEquals(EMPTY, FALSE.intersection(EMPTY)); assertEquals(EMPTY, FALSE.intersection(TRUE)); assertEquals(FALSE, FALSE.intersection(FALSE)); assertEquals(FALSE, FALSE.intersection(BOTH)); assertEquals(EMPTY, BOTH.intersection(EMPTY)); assertEquals(TRUE, BOTH.intersection(TRUE)); assertEquals(FALSE, BOTH.intersection(FALSE)); assertEquals(BOTH, BOTH.intersection(BOTH)); } public void testUnion() { assertEquals(EMPTY, EMPTY.union(EMPTY)); assertEquals(TRUE, EMPTY.union(TRUE)); assertEquals(FALSE, EMPTY.union(FALSE)); assertEquals(BOTH, EMPTY.union(BOTH)); assertEquals(TRUE, TRUE.union(EMPTY)); assertEquals(TRUE, TRUE.union(TRUE)); assertEquals(BOTH, TRUE.union(FALSE)); assertEquals(BOTH, TRUE.union(BOTH)); assertEquals(FALSE, FALSE.union(EMPTY)); assertEquals(BOTH, FALSE.union(TRUE)); assertEquals(FALSE, FALSE.union(FALSE)); assertEquals(BOTH, FALSE.union(BOTH)); assertEquals(BOTH, BOTH.union(EMPTY)); assertEquals(BOTH, BOTH.union(TRUE)); assertEquals(BOTH, BOTH.union(FALSE)); assertEquals(BOTH, BOTH.union(BOTH)); } public void testGet() { assertEquals(TRUE, BooleanLiteralSet.get(true)); assertEquals(FALSE, BooleanLiteralSet.get(false)); } public void testContains() { assertFalse(EMPTY.contains(true)); assertFalse(EMPTY.contains(false)); assertTrue(TRUE.contains(true)); assertFalse(TRUE.contains(false)); assertFalse(FALSE.contains(true)); assertTrue(FALSE.contains(false)); assertTrue(BOTH.contains(true)); assertTrue(BOTH.contains(false)); } }
/* * * ***** BEGIN LICENSE BLOCK ***** * Version: MPL 1.1/GPL 2.0 * * The contents of this file are subject to the Mozilla Public License Version * 1.1 (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * http://www.mozilla.org/MPL/ * * Software distributed under the License is distributed on an "AS IS" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License * for the specific language governing rights and limitations under the * License. * * The Original Code is Rhino code, released * May 6, 1999. * * The Initial Developer of the Original Code is * Netscape Communications Corporation. * Portions created by the Initial Developer are Copyright (C) 1997-1999 * the Initial Developer. All Rights Reserved. * * Contributor(s): * Nick Santos * * Alternatively, the contents of this file may be used under the terms of * the GNU General Public License Version 2 or later (the "GPL"), in which * case the provisions of the GPL are applicable instead of those above. If * you wish to allow use of your version of this file only under the terms of * the GPL and not to allow others to use your version of this file under the * MPL, indicate your decision by deleting the provisions above and replacing * them with the notice and other provisions required by the GPL. If you do * not delete the provisions above, a recipient may use your version of this * file under either the MPL or the GPL. * * ***** END LICENSE BLOCK ***** */ package com.google.javascript.rhino.jstype; import com.google.javascript.rhino.testing.BaseJSTypeTestCase; /** * Tests for EnumElementTypes. * @author nicksantos@google.com (Nick Santos) */ public class EnumElementTypeTest extends BaseJSTypeTestCase { public void testSubtypeRelation() throws Exception { EnumElementType typeA = registry.createEnumType( "typeA", null, NUMBER_TYPE).getElementsType(); EnumElementType typeB = registry.createEnumType( "typeB", null, NUMBER_TYPE).getElementsType(); assertFalse(typeA.isSubtype(typeB)); assertFalse(typeB.isSubtype(typeA)); assertFalse(NUMBER_TYPE.isSubtype(typeB)); assertFalse(NUMBER_TYPE.isSubtype(typeA)); assertTrue(typeA.isSubtype(NUMBER_TYPE)); assertTrue(typeB.isSubtype(NUMBER_TYPE)); } public void testMeet() throws Exception { EnumElementType typeA = registry.createEnumType( "typeA", null, createUnionType(NUMBER_TYPE, STRING_TYPE)) .getElementsType(); JSType stringsOfA = typeA.getGreatestSubtype(STRING_TYPE); assertFalse(stringsOfA.isEmptyType()); assertEquals("typeA.<string>", stringsOfA.toString()); assertTrue(stringsOfA.isSubtype(typeA)); JSType numbersOfA = NUMBER_TYPE.getGreatestSubtype(typeA); assertFalse(numbersOfA.isEmptyType()); assertEquals("typeA.<number>", numbersOfA.toString()); assertTrue(numbersOfA.isSubtype(typeA)); } }
/* * * ***** BEGIN LICENSE BLOCK ***** * Version: MPL 1.1/GPL 2.0 * * The contents of this file are subject to the Mozilla Public License Version * 1.1 (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * http://www.mozilla.org/MPL/ * * Software distributed under the License is distributed on an "AS IS" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License * for the specific language governing rights and limitations under the * License. * * The Original Code is Rhino code, released * May 6, 1999. * * The Initial Developer of the Original Code is * Netscape Communications Corporation. * Portions created by the Initial Developer are Copyright (C) 1997-1999 * the Initial Developer. All Rights Reserved. * * Contributor(s): * Nick Santos * * Alternatively, the contents of this file may be used under the terms of * the GNU General Public License Version 2 or later (the "GPL"), in which * case the provisions of the GPL are applicable instead of those above. If * you wish to allow use of your version of this file only under the terms of * the GPL and not to allow others to use your version of this file under the * MPL, indicate your decision by deleting the provisions above and replacing * them with the notice and other provisions required by the GPL. If you do * not delete the provisions above, a recipient may use your version of this * file under either the MPL or the GPL. * * ***** END LICENSE BLOCK ***** */ package com.google.javascript.rhino.jstype; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.testing.BaseJSTypeTestCase; /** * Tests for FunctionParamBuilder. * @author nicksantos@google.com (Nick Santos) */ public class FunctionParamBuilderTest extends BaseJSTypeTestCase { public void testBuild() throws Exception { FunctionParamBuilder builder = new FunctionParamBuilder(registry); assertTrue(builder.addRequiredParams(NUMBER_TYPE)); assertTrue(builder.addOptionalParams(BOOLEAN_TYPE)); assertTrue(builder.addVarArgs(STRING_TYPE)); Node params = builder.build(); assertTypeEquals(NUMBER_TYPE, params.getFirstChild().getJSType()); assertTypeEquals(registry.createOptionalType(BOOLEAN_TYPE), params.getFirstChild().getNext().getJSType()); assertTypeEquals(registry.createOptionalType(STRING_TYPE), params.getLastChild().getJSType()); assertTrue(params.getFirstChild().getNext().isOptionalArg()); assertTrue(params.getLastChild().isVarArgs()); } }
/* * * ***** BEGIN LICENSE BLOCK ***** * Version: MPL 1.1/GPL 2.0 * * The contents of this file are subject to the Mozilla Public License Version * 1.1 (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * http://www.mozilla.org/MPL/ * * Software distributed under the License is distributed on an "AS IS" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License * for the specific language governing rights and limitations under the * License. * * The Original Code is Rhino code, released * May 6, 1999. * * The Initial Developer of the Original Code is * Netscape Communications Corporation. * Portions created by the Initial Developer are Copyright (C) 1997-1999 * the Initial Developer. All Rights Reserved. * * Contributor(s): * Nick Santos * * Alternatively, the contents of this file may be used under the terms of * the GNU General Public License Version 2 or later (the "GPL"), in which * case the provisions of the GPL are applicable instead of those above. If * you wish to allow use of your version of this file only under the terms of * the GPL and not to allow others to use your version of this file under the * MPL, indicate your decision by deleting the provisions above and replacing * them with the notice and other provisions required by the GPL. If you do * not delete the provisions above, a recipient may use your version of this * file under either the MPL or the GPL. * * ***** END LICENSE BLOCK ***** */ package com.google.javascript.rhino.jstype; import com.google.common.collect.ImmutableList; import com.google.common.collect.ImmutableSet; import com.google.common.collect.Lists; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.testing.Asserts; import com.google.javascript.rhino.testing.BaseJSTypeTestCase; /** * Tests for FunctionTypes. * @author nicksantos@google.com (Nick Santos) */ public class FunctionTypeTest extends BaseJSTypeTestCase { public void testDefaultReturnType() { FunctionType f = new FunctionBuilder(registry).build(); assertEquals(UNKNOWN_TYPE, f.getReturnType()); } public void testSupAndInfOfReturnTypes() { FunctionType retString = new FunctionBuilder(registry) .withParamsNode(registry.createParameters()) .withInferredReturnType(STRING_TYPE).build(); FunctionType retNumber = new FunctionBuilder(registry) .withParamsNode(registry.createParameters()) .withReturnType(NUMBER_TYPE).build(); assertLeastSupertype( "function (): (number|string)", retString, retNumber); assertGreatestSubtype( "function (): None", retString, retNumber); assertTrue(retString.isReturnTypeInferred()); assertFalse(retNumber.isReturnTypeInferred()); assertTrue( ((FunctionType) retString.getLeastSupertype(retNumber)) .isReturnTypeInferred()); assertTrue( ((FunctionType) retString.getGreatestSubtype(retString)) .isReturnTypeInferred()); } public void testSupAndInfOfReturnTypesWithDifferentParams() { FunctionType retString = new FunctionBuilder(registry) .withParamsNode(registry.createParameters(NUMBER_TYPE)) .withInferredReturnType(STRING_TYPE).build(); FunctionType retNumber = new FunctionBuilder(registry) .withParamsNode(registry.createParameters()) .withReturnType(NUMBER_TYPE).build(); assertLeastSupertype( "Function", retString, retNumber); assertGreatestSubtype( "function (...[*]): None", retString, retNumber); } public void testSupAndInfWithDifferentParams() { FunctionType retString = new FunctionBuilder(registry) .withParamsNode(registry.createParameters(NUMBER_TYPE)) .withReturnType(STRING_TYPE).build(); FunctionType retNumber = new FunctionBuilder(registry) .withParamsNode(registry.createParameters(STRING_TYPE)) .withReturnType(NUMBER_TYPE).build(); assertLeastSupertype( "Function", retString, retNumber); assertGreatestSubtype( "function (...[*]): None", retString, retNumber); } public void testSupAndInfWithDifferentThisTypes() { FunctionType retString = new FunctionBuilder(registry) .withParamsNode(registry.createParameters()) .withTypeOfThis(OBJECT_TYPE) .withReturnType(STRING_TYPE).build(); FunctionType retNumber = new FunctionBuilder(registry) .withParamsNode(registry.createParameters()) .withTypeOfThis(DATE_TYPE) .withReturnType(NUMBER_TYPE).build(); assertLeastSupertype( "function (this:Object): (number|string)", retString, retNumber); assertGreatestSubtype( "function (this:Date): None", retString, retNumber); } public void testSupAndInfWithDifferentThisTypes2() { FunctionType retString = new FunctionBuilder(registry) .withParamsNode(registry.createParameters()) .withTypeOfThis(ARRAY_TYPE) .withReturnType(STRING_TYPE).build(); FunctionType retNumber = new FunctionBuilder(registry) .withParamsNode(registry.createParameters()) .withTypeOfThis(DATE_TYPE) .withReturnType(NUMBER_TYPE).build(); assertLeastSupertype( "function (this:(Array|Date)): (number|string)", retString, retNumber); assertGreatestSubtype( "function (this:NoObject): None", retString, retNumber); } public void testSupAndInfOfReturnTypesWithNumOfParams() { FunctionType twoNumbers = new FunctionBuilder(registry) .withParamsNode(registry.createParameters(NUMBER_TYPE, NUMBER_TYPE)) .withReturnType(BOOLEAN_TYPE).build(); FunctionType oneNumber = new FunctionBuilder(registry) .withParamsNode(registry.createParameters(NUMBER_TYPE)) .withReturnType(BOOLEAN_TYPE).build(); assertLeastSupertype( "function (number, number): boolean", twoNumbers, oneNumber); assertGreatestSubtype( "function (number): boolean", twoNumbers, oneNumber); } public void testSubtypeWithInterfaceThisType() { FunctionType iface = registry.createInterfaceType("I", null); FunctionType ifaceReturnBoolean = new FunctionBuilder(registry) .withParamsNode(registry.createParameters()) .withTypeOfThis(iface.getInstanceType()) .withReturnType(BOOLEAN_TYPE).build(); FunctionType objReturnBoolean = new FunctionBuilder(registry) .withParamsNode(registry.createParameters()) .withTypeOfThis(OBJECT_TYPE) .withReturnType(BOOLEAN_TYPE).build(); assertTrue(objReturnBoolean.isSubtype(ifaceReturnBoolean)); } public void testOrdinaryFunctionPrototype() { FunctionType oneNumber = new FunctionBuilder(registry) .withParamsNode(registry.createParameters(NUMBER_TYPE)) .withReturnType(BOOLEAN_TYPE).build(); assertEquals(ImmutableSet.<String>of(), oneNumber.getOwnPropertyNames()); } public void testCtorWithPrototypeSet() { FunctionType ctor = registry.createConstructorType( "Foo", null, null, null, null); assertFalse(ctor.getInstanceType().isUnknownType()); Node node = new Node(Token.OBJECTLIT); ctor.defineDeclaredProperty("prototype", UNKNOWN_TYPE, node); assertTrue(ctor.getInstanceType().isUnknownType()); assertEquals(ImmutableSet.<String>of("prototype"), ctor.getOwnPropertyNames()); assertTrue(ctor.isPropertyTypeInferred("prototype")); assertTrue(ctor.getPropertyType("prototype").isUnknownType()); assertEquals(node, ctor.getPropertyNode("prototype")); } public void testEmptyFunctionTypes() { assertTrue(LEAST_FUNCTION_TYPE.isEmptyType()); assertFalse(GREATEST_FUNCTION_TYPE.isEmptyType()); } public void testInterfacePrototypeChain1() { FunctionType iface = registry.createInterfaceType("I", null); assertTypeEquals( iface.getPrototype(), iface.getInstanceType().getImplicitPrototype()); assertTypeEquals( OBJECT_TYPE, iface.getPrototype().getImplicitPrototype()); } public void testInterfacePrototypeChain2() { FunctionType iface = registry.createInterfaceType("I", null); iface.getPrototype().defineDeclaredProperty( "numberProp", NUMBER_TYPE, null); FunctionType subIface = registry.createInterfaceType("SubI", null); subIface.setExtendedInterfaces( Lists.<ObjectType>newArrayList(iface.getInstanceType())); assertTypeEquals( subIface.getPrototype(), subIface.getInstanceType().getImplicitPrototype()); assertTypeEquals( OBJECT_TYPE, subIface.getPrototype().getImplicitPrototype()); ObjectType subIfaceInst = subIface.getInstanceType(); assertTrue(subIfaceInst.hasProperty("numberProp")); assertTrue(subIfaceInst.isPropertyTypeDeclared("numberProp")); assertFalse(subIfaceInst.isPropertyTypeInferred("numberProp")); } private void assertLeastSupertype(String s, JSType t1, JSType t2) { assertEquals(s, t1.getLeastSupertype(t2).toString()); assertEquals(s, t2.getLeastSupertype(t1).toString()); } private void assertGreatestSubtype(String s, JSType t1, JSType t2) { assertEquals(s, t1.getGreatestSubtype(t2).toString()); assertEquals(s, t2.getGreatestSubtype(t1).toString()); } public void testIsEquivalentTo() { FunctionType type = new FunctionBuilder(registry).build(); assertFalse(type.equals(null)); assertTrue(type.isEquivalentTo(type)); } public void testIsEquivalentToParams() { FunctionType oneNum = new FunctionBuilder(registry) .withParamsNode(registry.createParameters(NUMBER_TYPE)) .build(); FunctionType optNum = new FunctionBuilder(registry) .withParamsNode(registry.createOptionalParameters(NUMBER_TYPE)) .build(); FunctionType varNum = new FunctionBuilder(registry) .withParamsNode(registry.createParametersWithVarArgs(NUMBER_TYPE)) .build(); Asserts.assertEquivalenceOperations(oneNum, oneNum); Asserts.assertEquivalenceOperations(optNum, optNum); Asserts.assertEquivalenceOperations(varNum, varNum); assertFalse(oneNum.isEquivalentTo(optNum)); assertFalse(oneNum.isEquivalentTo(varNum)); assertFalse(optNum.isEquivalentTo(varNum)); } public void testIsEquivalentOptAndVarArgs() { FunctionType varNum = new FunctionBuilder(registry) .withParamsNode(registry.createParametersWithVarArgs(NUMBER_TYPE)) .build(); FunctionParamBuilder builder = new FunctionParamBuilder(registry); builder.addOptionalParams(NUMBER_TYPE); builder.addVarArgs(NUMBER_TYPE); FunctionType optAndVarNum = new FunctionBuilder(registry) .withParamsNode(builder.build()) .build(); // We currently do not consider function(T=, ...T) and function(...T) // equivalent. This may change. assertFalse(varNum.isEquivalentTo(optAndVarNum)); assertFalse(optAndVarNum.isEquivalentTo(varNum)); } public void testRecursiveFunction() { ProxyObjectType loop = new ProxyObjectType(registry, NUMBER_TYPE); FunctionType fn = new FunctionBuilder(registry) .withParamsNode(registry.createParameters(loop)) .withReturnType(loop).build(); loop.setReferencedType(fn); assertEquals("function (Function): Function", fn.toString()); Asserts.assertEquivalenceOperations(fn, loop); } public void testBindSignature() { FunctionType fn = new FunctionBuilder(registry) .withTypeOfThis(DATE_TYPE) .withParamsNode(registry.createParameters(STRING_TYPE, NUMBER_TYPE)) .withReturnType(BOOLEAN_TYPE).build(); assertEquals( "function ((Date|null|undefined), string=, number=):" + " function (...[?]): boolean", fn.getPropertyType("bind").toString()); } public void testCallSignature1() { FunctionType fn = new FunctionBuilder(registry) .withTypeOfThis(DATE_TYPE) .withParamsNode(registry.createParameters(STRING_TYPE, NUMBER_TYPE)) .withReturnType(BOOLEAN_TYPE).build(); assertEquals( "function ((Date|null|undefined), string, number): boolean", fn.getPropertyType("call").toString()); } public void testCallSignature2() { FunctionType fn = new FunctionBuilder(registry) .withTypeOfThis(DATE_TYPE) .withParamsNode(registry.createParameters()) .withReturnType(BOOLEAN_TYPE).build(); assertEquals( "function ((Date|null)=): boolean", fn.getPropertyType("call").toString()); } public void testTemplatedFunctionDerivedFunctions() { FunctionType fn = new FunctionBuilder(registry) .withTypeOfThis(new TemplateType(registry, "T")) .withTemplateKeys(ImmutableList.of("T")) .withReturnType(BOOLEAN_TYPE).build(); assertEquals("[T]", fn.getPropertyType("call").getTemplateKeys().toString()); assertEquals("[T]", fn.getPropertyType("apply").getTemplateKeys().toString()); assertEquals("[T]", fn.getPropertyType("bind").getTemplateKeys().toString()); assertEquals("[T]", fn.getBindReturnType(0).getTemplateKeys().toString()); } public void testPrint() { FunctionType fn = new FunctionBuilder(registry) .withTypeOfThis(new TemplateType(registry, "T")) .withReturnType(BOOLEAN_TYPE).build(); assertEquals("function (this:T, ...[?]): boolean", fn.toString()); } public void testSetImplementsOnInterface() { FunctionType iface = registry.createInterfaceType("I", null); FunctionType subIface = registry.createInterfaceType("SubI", null); try { subIface.setImplementedInterfaces( ImmutableList.of(iface.getInstanceType())); fail("Expected exception"); } catch (UnsupportedOperationException e) { // OK } } }
/* * * ***** BEGIN LICENSE BLOCK ***** * Version: MPL 1.1/GPL 2.0 * * The contents of this file are subject to the Mozilla Public License Version * 1.1 (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * http://www.mozilla.org/MPL/ * * Software distributed under the License is distributed on an "AS IS" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License * for the specific language governing rights and limitations under the * License. * * The Original Code is Rhino code, released * May 6, 1999. * * The Initial Developer of the Original Code is * Netscape Communications Corporation. * Portions created by the Initial Developer are Copyright (C) 1997-1999 * the Initial Developer. All Rights Reserved. * * Contributor(s): * Nick Santos * * Alternatively, the contents of this file may be used under the terms of * the GNU General Public License Version 2 or later (the "GPL"), in which * case the provisions of the GPL are applicable instead of those above. If * you wish to allow use of your version of this file only under the terms of * the GPL and not to allow others to use your version of this file under the * MPL, indicate your decision by deleting the provisions above and replacing * them with the notice and other provisions required by the GPL. If you do * not delete the provisions above, a recipient may use your version of this * file under either the MPL or the GPL. * * ***** END LICENSE BLOCK ***** */ package com.google.javascript.rhino.jstype; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.SimpleErrorReporter; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.JSTypeRegistry.ResolveMode; import com.google.javascript.rhino.testing.Asserts; import com.google.javascript.rhino.testing.AbstractStaticScope; import com.google.javascript.rhino.testing.MapBasedScope; import junit.framework.TestCase; /** * Tests {@link JSTypeRegistry}. * */ public class JSTypeRegistryTest extends TestCase { // TODO(user): extend this class with more tests, as JSTypeRegistry is // now much larger public void testGetBuiltInType() { JSTypeRegistry typeRegistry = new JSTypeRegistry(null); assertTypeEquals(typeRegistry.getNativeType(JSTypeNative.BOOLEAN_TYPE), typeRegistry.getType("boolean")); } public void testGetDeclaredType() { JSTypeRegistry typeRegistry = new JSTypeRegistry(null); JSType type = typeRegistry.createAnonymousObjectType(null); String name = "Foo"; typeRegistry.declareType(name, type); assertTypeEquals(type, typeRegistry.getType(name)); // Ensure different instances are independent. JSTypeRegistry typeRegistry2 = new JSTypeRegistry(null); assertEquals(null, typeRegistry2.getType(name)); assertTypeEquals(type, typeRegistry.getType(name)); } public void testGetDeclaredTypeInNamespace() { JSTypeRegistry typeRegistry = new JSTypeRegistry(null); JSType type = typeRegistry.createAnonymousObjectType(null); String name = "a.b.Foo"; typeRegistry.declareType(name, type); assertTypeEquals(type, typeRegistry.getType(name)); assertTrue(typeRegistry.hasNamespace("a")); assertTrue(typeRegistry.hasNamespace("a.b")); } public void testPropertyOnManyTypes() { JSTypeRegistry typeRegistry = new JSTypeRegistry(null); JSType type = null; // By default the UnionTypeBuilder will treat a union of more than 20 // types as an unknown type. We don't want that for property checking // so test that the limit is higher. for (int i = 0; i < 100; i++) { type = typeRegistry.createObjectType("type: " + i, null, null); typeRegistry.registerPropertyOnType("foo", type); } assertFalse(typeRegistry.getGreatestSubtypeWithProperty(type, "foo").isUnknownType()); } public void testTypeAsNamespace() { JSTypeRegistry typeRegistry = new JSTypeRegistry(null); JSType type = typeRegistry.createAnonymousObjectType(null); String name = "a.b.Foo"; typeRegistry.declareType(name, type); assertTypeEquals(type, typeRegistry.getType(name)); type = typeRegistry.createAnonymousObjectType(null); name = "a.b.Foo.Bar"; typeRegistry.declareType(name, type); assertTypeEquals(type, typeRegistry.getType(name)); assertTrue(typeRegistry.hasNamespace("a")); assertTrue(typeRegistry.hasNamespace("a.b")); assertTrue(typeRegistry.hasNamespace("a.b.Foo")); } public void testGenerationIncrementing1() { SimpleErrorReporter reporter = new SimpleErrorReporter(); final JSTypeRegistry typeRegistry = new JSTypeRegistry(reporter); StaticScope<JSType> scope = new AbstractStaticScope<JSType>() { @Override public StaticSlot<JSType> getSlot(final String name) { return new SimpleSlot( name, typeRegistry.getNativeType(JSTypeNative.UNKNOWN_TYPE), false); } }; ObjectType namedType = (ObjectType) typeRegistry.getType(scope, "Foo", null, 0, 0); ObjectType subNamed = typeRegistry.createObjectType(typeRegistry.createObjectType(namedType)); // Subclass of named type is initially unresolved. typeRegistry.setLastGeneration(false); typeRegistry.resolveTypesInScope(scope); assertTrue(subNamed.isUnknownType()); // Subclass of named type is still unresolved, even though the named type is // now present in the registry. typeRegistry.declareType("Foo", typeRegistry.createAnonymousObjectType(null)); typeRegistry.resolveTypesInScope(scope); assertTrue(subNamed.isUnknownType()); assertNull("Unexpected errors: " + reporter.errors(), reporter.errors()); assertNull("Unexpected warnings: " + reporter.warnings(), reporter.warnings()); // After incrementing the generation, resolve works again. typeRegistry.incrementGeneration(); typeRegistry.setLastGeneration(true); typeRegistry.resolveTypesInScope(scope); assertFalse(subNamed.isUnknownType()); } public void testGenerationIncrementing2() { SimpleErrorReporter reporter = new SimpleErrorReporter(); final JSTypeRegistry typeRegistry = new JSTypeRegistry(reporter); StaticScope<JSType> scope = new AbstractStaticScope<JSType>() { @Override public StaticSlot<JSType> getSlot(final String name) { return new SimpleSlot( name, typeRegistry.getNativeType(JSTypeNative.UNKNOWN_TYPE), false); } }; ObjectType namedType = (ObjectType) typeRegistry.getType(scope, "Foo", null, 0, 0); FunctionType functionType = typeRegistry.createFunctionType(namedType); // Subclass of named type is initially unresolved. typeRegistry.setLastGeneration(false); typeRegistry.resolveTypesInScope(scope); assertTrue(functionType.getReturnType().isUnknownType()); functionType.resolve(reporter, scope); assertTrue(functionType.getReturnType().isUnknownType()); // Subclass of named type is still unresolved, even though the named type is // now present in the registry. typeRegistry.declareType("Foo", typeRegistry.createAnonymousObjectType(null)); typeRegistry.resolveTypesInScope(scope); assertTrue(functionType.getReturnType().isUnknownType()); assertNull("Unexpected errors: " + reporter.errors(), reporter.errors()); assertNull("Unexpected warnings: " + reporter.warnings(), reporter.warnings()); // After incrementing the generation, resolve works again. typeRegistry.incrementGeneration(); typeRegistry.setLastGeneration(true); typeRegistry.resolveTypesInScope(scope); assertFalse(functionType.getReturnType().isUnknownType()); } public void testTypeResolutionModes() { SimpleErrorReporter reporter = new SimpleErrorReporter(); JSTypeRegistry lazyExprRegistry = new JSTypeRegistry(reporter); lazyExprRegistry.setResolveMode(ResolveMode.LAZY_EXPRESSIONS); JSTypeRegistry lazyNameRegistry = new JSTypeRegistry(reporter); lazyNameRegistry.setResolveMode(ResolveMode.LAZY_NAMES); JSTypeRegistry immediateRegistry = new JSTypeRegistry(reporter); immediateRegistry.setResolveMode(ResolveMode.IMMEDIATE); Node expr = new Node(Token.QMARK, Node.newString("foo")); StaticScope<JSType> empty = MapBasedScope.emptyScope(); JSType type = lazyExprRegistry.createFromTypeNodes( expr, "source.js", empty); assertTrue(type instanceof UnresolvedTypeExpression); assertTrue(type.isUnknownType()); assertEquals("?", type.toString()); assertNull("Unexpected warnings: " + reporter.warnings(), reporter.warnings()); type = lazyNameRegistry.createFromTypeNodes( expr, "source.js", empty); assertTrue(type instanceof UnionType); assertTrue(type.isUnknownType()); assertEquals("(foo|null)", type.toString()); assertNull("Unexpected warnings: " + reporter.warnings(), reporter.warnings()); type = immediateRegistry.createFromTypeNodes( expr, "source.js", empty); assertTrue(type instanceof UnknownType); assertEquals("Expected warnings", 1, reporter.warnings().size()); } public void testForceResolve() { SimpleErrorReporter reporter = new SimpleErrorReporter(); JSTypeRegistry lazyExprRegistry = new JSTypeRegistry(reporter); lazyExprRegistry.setResolveMode(ResolveMode.LAZY_EXPRESSIONS); Node expr = new Node(Token.QMARK, Node.newString("foo")); StaticScope<JSType> empty = MapBasedScope.emptyScope(); JSType type = lazyExprRegistry.createFromTypeNodes( expr, "source.js", empty); assertFalse(type.isResolved()); assertTrue(type.forceResolve(reporter, empty).isResolved()); assertEquals("Expected warnings", 1, reporter.warnings().size()); } public void testAllTypeResolvesImmediately() { JSTypeRegistry lazyExprRegistry = new JSTypeRegistry( new SimpleErrorReporter()); lazyExprRegistry.setResolveMode(ResolveMode.LAZY_EXPRESSIONS); Node expr = new Node(Token.STAR); JSType type = lazyExprRegistry.createFromTypeNodes( expr, "source.js", MapBasedScope.emptyScope()); assertTrue(type instanceof AllType); } private void assertTypeEquals(JSType a, JSType b) { Asserts.assertTypeEquals(a, b); } }
/* * * ***** BEGIN LICENSE BLOCK ***** * Version: MPL 1.1/GPL 2.0 * * The contents of this file are subject to the Mozilla Public License Version * 1.1 (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * http://www.mozilla.org/MPL/ * * Software distributed under the License is distributed on an "AS IS" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License * for the specific language governing rights and limitations under the * License. * * The Original Code is Rhino code, released * May 6, 1999. * * The Initial Developer of the Original Code is * Netscape Communications Corporation. * Portions created by the Initial Developer are Copyright (C) 1997-1999 * the Initial Developer. All Rights Reserved. * * Contributor(s): * Nick Santos * * Alternatively, the contents of this file may be used under the terms of * the GNU General Public License Version 2 or later (the "GPL"), in which * case the provisions of the GPL are applicable instead of those above. If * you wish to allow use of your version of this file only under the terms of * the GPL and not to allow others to use your version of this file under the * MPL, indicate your decision by deleting the provisions above and replacing * them with the notice and other provisions required by the GPL. If you do * not delete the provisions above, a recipient may use your version of this * file under either the MPL or the GPL. * * ***** END LICENSE BLOCK ***** */ package com.google.javascript.rhino.jstype; import static com.google.javascript.rhino.jstype.TernaryValue.FALSE; import static com.google.javascript.rhino.jstype.TernaryValue.TRUE; import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN; import com.google.common.collect.ImmutableList; import com.google.common.collect.Lists; import com.google.common.collect.Sets; import com.google.javascript.rhino.JSDocInfo; import com.google.javascript.rhino.JSDocInfo.Visibility; import com.google.javascript.rhino.Node; import com.google.javascript.rhino.SimpleErrorReporter; import com.google.javascript.rhino.Token; import com.google.javascript.rhino.jstype.ArrowType; import com.google.javascript.rhino.jstype.JSType.TypePair; import com.google.javascript.rhino.jstype.RecordTypeBuilder.RecordProperty; import com.google.javascript.rhino.testing.Asserts; import com.google.javascript.rhino.testing.AbstractStaticScope; import com.google.javascript.rhino.testing.BaseJSTypeTestCase; import com.google.javascript.rhino.testing.MapBasedScope; import java.util.HashMap; import java.util.List; import java.util.Map; // TODO(nicksantos): Split some of this up into per-class unit tests. public class JSTypeTest extends BaseJSTypeTestCase { private FunctionType dateMethod; private FunctionType functionType; private NamedType unresolvedNamedType; private FunctionType googBar; private FunctionType googSubBar; private FunctionType googSubSubBar; private ObjectType googBarInst; private ObjectType googSubBarInst; private ObjectType googSubSubBarInst; private NamedType namedGoogBar; private ObjectType subclassOfUnresolvedNamedType; private FunctionType subclassCtor; private FunctionType interfaceType; private ObjectType interfaceInstType; private FunctionType subInterfaceType; private ObjectType subInterfaceInstType; private JSType recordType; private EnumType enumType; private EnumElementType elementsType; private NamedType forwardDeclaredNamedType; private static final StaticScope<JSType> EMPTY_SCOPE = MapBasedScope.emptyScope(); /** * A non exhaustive list of representative types used to test simple * properties that should hold for all types (such as the reflexivity * of subtyping). */ private List<JSType> types; @Override protected void setUp() throws Exception { super.setUp(); RecordTypeBuilder builder = new RecordTypeBuilder(registry); builder.addProperty("a", NUMBER_TYPE, null); builder.addProperty("b", STRING_TYPE, null); recordType = builder.build(); enumType = new EnumType(registry, "Enum", null, NUMBER_TYPE); elementsType = enumType.getElementsType(); functionType = new FunctionBuilder(registry) .withReturnType(NUMBER_TYPE) .build(); dateMethod = new FunctionBuilder(registry) .withParamsNode(new Node(Token.PARAM_LIST)) .withReturnType(NUMBER_TYPE) .withTypeOfThis(DATE_TYPE) .build(); unresolvedNamedType = new NamedType(registry, "not.resolved.named.type", null, -1, -1); namedGoogBar = new NamedType(registry, "goog.Bar", null, -1, -1); subclassCtor = new FunctionType(registry, null, null, createArrowType(null), null, null, true, false); subclassCtor.setPrototypeBasedOn(unresolvedNamedType); subclassOfUnresolvedNamedType = subclassCtor.getInstanceType(); interfaceType = FunctionType.forInterface(registry, "Interface", null); interfaceInstType = interfaceType.getInstanceType(); subInterfaceType = FunctionType.forInterface( registry, "SubInterface", null); subInterfaceType.setExtendedInterfaces( Lists.<ObjectType>newArrayList(interfaceInstType)); subInterfaceInstType = subInterfaceType.getInstanceType(); googBar = registry.createConstructorType( "goog.Bar", null, null, null, null); googBar.getPrototype().defineDeclaredProperty("date", DATE_TYPE, null); googBar.setImplementedInterfaces( Lists.<ObjectType>newArrayList(interfaceInstType)); googBarInst = googBar.getInstanceType(); googSubBar = registry.createConstructorType( "googSubBar", null, null, null, null); googSubBar.setPrototypeBasedOn(googBar.getInstanceType()); googSubBarInst = googSubBar.getInstanceType(); googSubSubBar = registry.createConstructorType( "googSubSubBar", null, null, null, null); googSubSubBar.setPrototypeBasedOn(googSubBar.getInstanceType()); googSubSubBarInst = googSubSubBar.getInstanceType(); final ObjectType googObject = registry.createAnonymousObjectType(null); googObject.defineDeclaredProperty("Bar", googBar, null); namedGoogBar.resolve(null, new AbstractStaticScope<JSType>() { @Override public StaticSlot<JSType> getSlot(String name) { if ("goog".equals(name)) { return new SimpleSlot("goog", googObject, false); } else { return null; } } }); assertNotNull(namedGoogBar.getImplicitPrototype()); forwardDeclaredNamedType = new NamedType(registry, "forwardDeclared", "source", 1, 0); registry.forwardDeclareType("forwardDeclared"); forwardDeclaredNamedType.resolve( new SimpleErrorReporter(), EMPTY_SCOPE); types = ImmutableList.of( NO_OBJECT_TYPE, NO_RESOLVED_TYPE, NO_TYPE, BOOLEAN_OBJECT_TYPE, BOOLEAN_TYPE, STRING_OBJECT_TYPE, STRING_TYPE, VOID_TYPE, UNKNOWN_TYPE, NULL_TYPE, NUMBER_OBJECT_TYPE, NUMBER_TYPE, DATE_TYPE, ERROR_TYPE, SYNTAX_ERROR_TYPE, dateMethod, functionType, unresolvedNamedType, googBar, googSubBar, googSubSubBar, namedGoogBar, googBar.getInstanceType(), subclassOfUnresolvedNamedType, subclassCtor, recordType, enumType, elementsType, googBar, googSubBar, forwardDeclaredNamedType); } /** * Tests the behavior of the top constructor type. */ public void testUniversalConstructorType() throws Exception { // isXxx assertFalse(U2U_CONSTRUCTOR_TYPE.isNoObjectType()); assertFalse(U2U_CONSTRUCTOR_TYPE.isNoType()); assertFalse(U2U_CONSTRUCTOR_TYPE.isArrayType()); assertFalse(U2U_CONSTRUCTOR_TYPE.isBooleanValueType()); assertFalse(U2U_CONSTRUCTOR_TYPE.isDateType()); assertFalse(U2U_CONSTRUCTOR_TYPE.isEnumElementType()); assertFalse(U2U_CONSTRUCTOR_TYPE.isNullType()); assertFalse(U2U_CONSTRUCTOR_TYPE.isNamedType()); assertFalse(U2U_CONSTRUCTOR_TYPE.isNullType()); assertFalse(U2U_CONSTRUCTOR_TYPE.isNumber()); assertFalse(U2U_CONSTRUCTOR_TYPE.isNumberObjectType()); assertFalse(U2U_CONSTRUCTOR_TYPE.isNumberValueType()); assertTrue(U2U_CONSTRUCTOR_TYPE.isObject()); assertFalse(U2U_CONSTRUCTOR_TYPE.isFunctionPrototypeType()); assertFalse(U2U_CONSTRUCTOR_TYPE.isRegexpType()); assertFalse(U2U_CONSTRUCTOR_TYPE.isString()); assertFalse(U2U_CONSTRUCTOR_TYPE.isStringObjectType()); assertFalse(U2U_CONSTRUCTOR_TYPE.isStringValueType()); assertFalse(U2U_CONSTRUCTOR_TYPE.isEnumType()); assertFalse(U2U_CONSTRUCTOR_TYPE.isUnionType()); assertFalse(U2U_CONSTRUCTOR_TYPE.isStruct()); assertFalse(U2U_CONSTRUCTOR_TYPE.isDict()); assertFalse(U2U_CONSTRUCTOR_TYPE.isAllType()); assertFalse(U2U_CONSTRUCTOR_TYPE.isVoidType()); assertTrue(U2U_CONSTRUCTOR_TYPE.isConstructor()); assertTrue(U2U_CONSTRUCTOR_TYPE.isInstanceType()); // isSubtype assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(NO_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(NO_OBJECT_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(ARRAY_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(BOOLEAN_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(DATE_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(ERROR_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(EVAL_ERROR_TYPE)); assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(functionType)); assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(recordType)); assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(NULL_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(NUMBER_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(NUMBER_OBJECT_TYPE)); assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(OBJECT_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(URI_ERROR_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(RANGE_ERROR_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(REFERENCE_ERROR_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(REGEXP_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(STRING_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(STRING_OBJECT_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(SYNTAX_ERROR_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(TYPE_ERROR_TYPE)); assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(ALL_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE.isSubtype(VOID_TYPE)); // canTestForEqualityWith assertTrue(U2U_CONSTRUCTOR_TYPE. canTestForEqualityWith(NO_TYPE)); assertTrue(U2U_CONSTRUCTOR_TYPE. canTestForEqualityWith(NO_OBJECT_TYPE)); assertTrue(U2U_CONSTRUCTOR_TYPE. canTestForEqualityWith(ALL_TYPE)); assertTrue(U2U_CONSTRUCTOR_TYPE. canTestForEqualityWith(ARRAY_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE. canTestForEqualityWith(BOOLEAN_TYPE)); assertTrue(U2U_CONSTRUCTOR_TYPE. canTestForEqualityWith(BOOLEAN_OBJECT_TYPE)); assertTrue(U2U_CONSTRUCTOR_TYPE. canTestForEqualityWith(DATE_TYPE)); assertTrue(U2U_CONSTRUCTOR_TYPE. canTestForEqualityWith(ERROR_TYPE)); assertTrue(U2U_CONSTRUCTOR_TYPE. canTestForEqualityWith(EVAL_ERROR_TYPE)); assertTrue(U2U_CONSTRUCTOR_TYPE. canTestForEqualityWith(functionType)); assertTrue(U2U_CONSTRUCTOR_TYPE. canTestForEqualityWith(recordType)); assertFalse(U2U_CONSTRUCTOR_TYPE. canTestForEqualityWith(NULL_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE. canTestForEqualityWith(NUMBER_TYPE)); assertTrue(U2U_CONSTRUCTOR_TYPE. canTestForEqualityWith(NUMBER_OBJECT_TYPE)); assertTrue(U2U_CONSTRUCTOR_TYPE. canTestForEqualityWith(OBJECT_TYPE)); assertTrue(U2U_CONSTRUCTOR_TYPE. canTestForEqualityWith(URI_ERROR_TYPE)); assertTrue(U2U_CONSTRUCTOR_TYPE. canTestForEqualityWith(RANGE_ERROR_TYPE)); assertTrue(U2U_CONSTRUCTOR_TYPE. canTestForEqualityWith(REFERENCE_ERROR_TYPE)); assertTrue(U2U_CONSTRUCTOR_TYPE. canTestForEqualityWith(REGEXP_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE. canTestForEqualityWith(STRING_TYPE)); assertTrue(U2U_CONSTRUCTOR_TYPE. canTestForEqualityWith(STRING_OBJECT_TYPE)); assertTrue(U2U_CONSTRUCTOR_TYPE. canTestForEqualityWith(SYNTAX_ERROR_TYPE)); assertTrue(U2U_CONSTRUCTOR_TYPE. canTestForEqualityWith(TYPE_ERROR_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE. canTestForEqualityWith(VOID_TYPE)); // canTestForShallowEqualityWith assertTrue(U2U_CONSTRUCTOR_TYPE. canTestForShallowEqualityWith(NO_TYPE)); assertTrue(U2U_CONSTRUCTOR_TYPE. canTestForShallowEqualityWith(NO_OBJECT_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE. canTestForShallowEqualityWith(ARRAY_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE. canTestForShallowEqualityWith(BOOLEAN_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE. canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE. canTestForShallowEqualityWith(DATE_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE. canTestForShallowEqualityWith(ERROR_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE. canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); assertTrue(U2U_CONSTRUCTOR_TYPE. canTestForShallowEqualityWith(functionType)); assertFalse(U2U_CONSTRUCTOR_TYPE. canTestForShallowEqualityWith(recordType)); assertFalse(U2U_CONSTRUCTOR_TYPE. canTestForShallowEqualityWith(NULL_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE. canTestForShallowEqualityWith(NUMBER_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE. canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); assertTrue(U2U_CONSTRUCTOR_TYPE. canTestForShallowEqualityWith(OBJECT_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE. canTestForShallowEqualityWith(URI_ERROR_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE. canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE. canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE. canTestForShallowEqualityWith(REGEXP_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE. canTestForShallowEqualityWith(STRING_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE. canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE. canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE. canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); assertTrue(U2U_CONSTRUCTOR_TYPE. canTestForShallowEqualityWith(ALL_TYPE)); assertFalse(U2U_CONSTRUCTOR_TYPE. canTestForShallowEqualityWith(VOID_TYPE)); // isNullable assertFalse(U2U_CONSTRUCTOR_TYPE.isNullable()); // isObject assertTrue(U2U_CONSTRUCTOR_TYPE.isObject()); // matchesXxx assertFalse(U2U_CONSTRUCTOR_TYPE.matchesInt32Context()); assertFalse(U2U_CONSTRUCTOR_TYPE.matchesNumberContext()); assertTrue(U2U_CONSTRUCTOR_TYPE.matchesObjectContext()); assertFalse(U2U_CONSTRUCTOR_TYPE.matchesStringContext()); assertFalse(U2U_CONSTRUCTOR_TYPE.matchesUint32Context()); // toString assertEquals("Function", U2U_CONSTRUCTOR_TYPE.toString()); assertTrue(U2U_CONSTRUCTOR_TYPE.hasDisplayName()); assertEquals("Function", U2U_CONSTRUCTOR_TYPE.getDisplayName()); // getPropertyType assertTypeEquals(UNKNOWN_TYPE, U2U_CONSTRUCTOR_TYPE.getPropertyType("anyProperty")); assertTrue(U2U_CONSTRUCTOR_TYPE.isNativeObjectType()); Asserts.assertResolvesToSame(U2U_CONSTRUCTOR_TYPE); assertTrue(U2U_CONSTRUCTOR_TYPE.isNominalConstructor()); } /** * Tests the behavior of the Bottom Object type. */ public void testNoObjectType() throws Exception { // isXxx assertTrue(NO_OBJECT_TYPE.isNoObjectType()); assertFalse(NO_OBJECT_TYPE.isNoType()); assertFalse(NO_OBJECT_TYPE.isArrayType()); assertFalse(NO_OBJECT_TYPE.isBooleanValueType()); assertFalse(NO_OBJECT_TYPE.isDateType()); assertFalse(NO_OBJECT_TYPE.isEnumElementType()); assertFalse(NO_OBJECT_TYPE.isNullType()); assertFalse(NO_OBJECT_TYPE.isNamedType()); assertFalse(NO_OBJECT_TYPE.isNullType()); assertTrue(NO_OBJECT_TYPE.isNumber()); assertFalse(NO_OBJECT_TYPE.isNumberObjectType()); assertFalse(NO_OBJECT_TYPE.isNumberValueType()); assertTrue(NO_OBJECT_TYPE.isObject()); assertFalse(NO_OBJECT_TYPE.isFunctionPrototypeType()); assertFalse(NO_OBJECT_TYPE.isRegexpType()); assertTrue(NO_OBJECT_TYPE.isString()); assertFalse(NO_OBJECT_TYPE.isStringObjectType()); assertFalse(NO_OBJECT_TYPE.isStringValueType()); assertFalse(NO_OBJECT_TYPE.isEnumType()); assertFalse(NO_OBJECT_TYPE.isUnionType()); assertFalse(NO_OBJECT_TYPE.isStruct()); assertFalse(NO_OBJECT_TYPE.isDict()); assertFalse(NO_OBJECT_TYPE.isAllType()); assertFalse(NO_OBJECT_TYPE.isVoidType()); assertTrue(NO_OBJECT_TYPE.isConstructor()); assertFalse(NO_OBJECT_TYPE.isInstanceType()); // isSubtype assertFalse(NO_OBJECT_TYPE.isSubtype(NO_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(NO_OBJECT_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(ARRAY_TYPE)); assertFalse(NO_OBJECT_TYPE.isSubtype(BOOLEAN_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(DATE_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(ERROR_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(EVAL_ERROR_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(functionType)); assertTrue(NO_OBJECT_TYPE.isSubtype(recordType)); assertFalse(NO_OBJECT_TYPE.isSubtype(NULL_TYPE)); assertFalse(NO_OBJECT_TYPE.isSubtype(NUMBER_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(NUMBER_OBJECT_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(OBJECT_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(URI_ERROR_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(RANGE_ERROR_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(REFERENCE_ERROR_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(REGEXP_TYPE)); assertFalse(NO_OBJECT_TYPE.isSubtype(STRING_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(STRING_OBJECT_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(SYNTAX_ERROR_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(TYPE_ERROR_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(ALL_TYPE)); assertFalse(NO_OBJECT_TYPE.isSubtype(VOID_TYPE)); // canTestForEqualityWith assertCannotTestForEqualityWith(NO_OBJECT_TYPE, NO_TYPE); assertCannotTestForEqualityWith(NO_OBJECT_TYPE, NO_OBJECT_TYPE); assertCanTestForEqualityWith(NO_OBJECT_TYPE, ALL_TYPE); assertCanTestForEqualityWith(NO_OBJECT_TYPE, ARRAY_TYPE); assertCanTestForEqualityWith(NO_OBJECT_TYPE, BOOLEAN_TYPE); assertCanTestForEqualityWith(NO_OBJECT_TYPE, BOOLEAN_OBJECT_TYPE); assertCanTestForEqualityWith(NO_OBJECT_TYPE, DATE_TYPE); assertCanTestForEqualityWith(NO_OBJECT_TYPE, ERROR_TYPE); assertCanTestForEqualityWith(NO_OBJECT_TYPE, EVAL_ERROR_TYPE); assertCanTestForEqualityWith(NO_OBJECT_TYPE, functionType); assertCanTestForEqualityWith(NO_OBJECT_TYPE, recordType); assertCanTestForEqualityWith(NO_OBJECT_TYPE, NULL_TYPE); assertCanTestForEqualityWith(NO_OBJECT_TYPE, NUMBER_TYPE); assertCanTestForEqualityWith(NO_OBJECT_TYPE, NUMBER_OBJECT_TYPE); assertCanTestForEqualityWith(NO_OBJECT_TYPE, OBJECT_TYPE); assertCanTestForEqualityWith(NO_OBJECT_TYPE, URI_ERROR_TYPE); assertCanTestForEqualityWith(NO_OBJECT_TYPE, RANGE_ERROR_TYPE); assertCanTestForEqualityWith(NO_OBJECT_TYPE, REFERENCE_ERROR_TYPE); assertCanTestForEqualityWith(NO_OBJECT_TYPE, REGEXP_TYPE); assertCanTestForEqualityWith(NO_OBJECT_TYPE, STRING_TYPE); assertCanTestForEqualityWith(NO_OBJECT_TYPE, STRING_OBJECT_TYPE); assertCanTestForEqualityWith(NO_OBJECT_TYPE, SYNTAX_ERROR_TYPE); assertCanTestForEqualityWith(NO_OBJECT_TYPE, TYPE_ERROR_TYPE); assertCanTestForEqualityWith(NO_OBJECT_TYPE, VOID_TYPE); // canTestForShallowEqualityWith assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(NO_TYPE)); assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE)); assertFalse(NO_OBJECT_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE)); assertTrue(NO_OBJECT_TYPE. canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(ERROR_TYPE)); assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(functionType)); assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(recordType)); assertFalse(NO_OBJECT_TYPE.canTestForShallowEqualityWith(NULL_TYPE)); assertFalse(NO_OBJECT_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); assertTrue(NO_OBJECT_TYPE. canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE)); assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); assertTrue(NO_OBJECT_TYPE. canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); assertFalse(NO_OBJECT_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); assertTrue(NO_OBJECT_TYPE. canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); assertTrue(NO_OBJECT_TYPE. canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); assertTrue(NO_OBJECT_TYPE.canTestForShallowEqualityWith(ALL_TYPE)); assertFalse(NO_OBJECT_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); // isNullable assertFalse(NO_OBJECT_TYPE.isNullable()); // isObject assertTrue(NO_OBJECT_TYPE.isObject()); // matchesXxx assertTrue(NO_OBJECT_TYPE.matchesInt32Context()); assertTrue(NO_OBJECT_TYPE.matchesNumberContext()); assertTrue(NO_OBJECT_TYPE.matchesObjectContext()); assertTrue(NO_OBJECT_TYPE.matchesStringContext()); assertTrue(NO_OBJECT_TYPE.matchesUint32Context()); // toString assertEquals("NoObject", NO_OBJECT_TYPE.toString()); assertFalse(NO_OBJECT_TYPE.hasDisplayName()); assertEquals(null, NO_OBJECT_TYPE.getDisplayName()); // getPropertyType assertTypeEquals(NO_TYPE, NO_OBJECT_TYPE.getPropertyType("anyProperty")); Asserts.assertResolvesToSame(NO_OBJECT_TYPE); assertFalse(NO_OBJECT_TYPE.isNominalConstructor()); } /** * Tests the behavior of the Bottom type. */ public void testNoType() throws Exception { // isXxx assertFalse(NO_TYPE.isNoObjectType()); assertTrue(NO_TYPE.isNoType()); assertFalse(NO_TYPE.isArrayType()); assertFalse(NO_TYPE.isBooleanValueType()); assertFalse(NO_TYPE.isDateType()); assertFalse(NO_TYPE.isEnumElementType()); assertFalse(NO_TYPE.isNullType()); assertFalse(NO_TYPE.isNamedType()); assertFalse(NO_TYPE.isNullType()); assertTrue(NO_TYPE.isNumber()); assertFalse(NO_TYPE.isNumberObjectType()); assertFalse(NO_TYPE.isNumberValueType()); assertTrue(NO_TYPE.isObject()); assertFalse(NO_TYPE.isFunctionPrototypeType()); assertFalse(NO_TYPE.isRegexpType()); assertTrue(NO_TYPE.isString()); assertFalse(NO_TYPE.isStringObjectType()); assertFalse(NO_TYPE.isStringValueType()); assertFalse(NO_TYPE.isEnumType()); assertFalse(NO_TYPE.isUnionType()); assertFalse(NO_TYPE.isStruct()); assertFalse(NO_TYPE.isDict()); assertFalse(NO_TYPE.isAllType()); assertFalse(NO_TYPE.isVoidType()); assertTrue(NO_TYPE.isConstructor()); assertFalse(NO_TYPE.isInstanceType()); // isSubtype assertTrue(NO_TYPE.isSubtype(NO_TYPE)); assertTrue(NO_TYPE.isSubtype(NO_OBJECT_TYPE)); assertTrue(NO_TYPE.isSubtype(ARRAY_TYPE)); assertTrue(NO_TYPE.isSubtype(BOOLEAN_TYPE)); assertTrue(NO_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE)); assertTrue(NO_TYPE.isSubtype(DATE_TYPE)); assertTrue(NO_TYPE.isSubtype(ERROR_TYPE)); assertTrue(NO_TYPE.isSubtype(EVAL_ERROR_TYPE)); assertTrue(NO_TYPE.isSubtype(functionType)); assertTrue(NO_TYPE.isSubtype(NULL_TYPE)); assertTrue(NO_TYPE.isSubtype(NUMBER_TYPE)); assertTrue(NO_TYPE.isSubtype(NUMBER_OBJECT_TYPE)); assertTrue(NO_TYPE.isSubtype(OBJECT_TYPE)); assertTrue(NO_TYPE.isSubtype(URI_ERROR_TYPE)); assertTrue(NO_TYPE.isSubtype(RANGE_ERROR_TYPE)); assertTrue(NO_TYPE.isSubtype(REFERENCE_ERROR_TYPE)); assertTrue(NO_TYPE.isSubtype(REGEXP_TYPE)); assertTrue(NO_TYPE.isSubtype(STRING_TYPE)); assertTrue(NO_TYPE.isSubtype(STRING_OBJECT_TYPE)); assertTrue(NO_TYPE.isSubtype(SYNTAX_ERROR_TYPE)); assertTrue(NO_TYPE.isSubtype(TYPE_ERROR_TYPE)); assertTrue(NO_TYPE.isSubtype(ALL_TYPE)); assertTrue(NO_TYPE.isSubtype(VOID_TYPE)); // canTestForEqualityWith assertCannotTestForEqualityWith(NO_TYPE, NO_TYPE); assertCannotTestForEqualityWith(NO_TYPE, NO_OBJECT_TYPE); assertCanTestForEqualityWith(NO_TYPE, ARRAY_TYPE); assertCanTestForEqualityWith(NO_TYPE, BOOLEAN_TYPE); assertCanTestForEqualityWith(NO_TYPE, BOOLEAN_OBJECT_TYPE); assertCanTestForEqualityWith(NO_TYPE, DATE_TYPE); assertCanTestForEqualityWith(NO_TYPE, ERROR_TYPE); assertCanTestForEqualityWith(NO_TYPE, EVAL_ERROR_TYPE); assertCanTestForEqualityWith(NO_TYPE, functionType); assertCanTestForEqualityWith(NO_TYPE, NULL_TYPE); assertCanTestForEqualityWith(NO_TYPE, NUMBER_TYPE); assertCanTestForEqualityWith(NO_TYPE, NUMBER_OBJECT_TYPE); assertCanTestForEqualityWith(NO_TYPE, OBJECT_TYPE); assertCanTestForEqualityWith(NO_TYPE, URI_ERROR_TYPE); assertCanTestForEqualityWith(NO_TYPE, RANGE_ERROR_TYPE); assertCanTestForEqualityWith(NO_TYPE, REFERENCE_ERROR_TYPE); assertCanTestForEqualityWith(NO_TYPE, REGEXP_TYPE); assertCanTestForEqualityWith(NO_TYPE, STRING_TYPE); assertCanTestForEqualityWith(NO_TYPE, STRING_OBJECT_TYPE); assertCanTestForEqualityWith(NO_TYPE, SYNTAX_ERROR_TYPE); assertCanTestForEqualityWith(NO_TYPE, TYPE_ERROR_TYPE); assertCanTestForEqualityWith(NO_TYPE, ALL_TYPE); assertCanTestForEqualityWith(NO_TYPE, VOID_TYPE); // canTestForShallowEqualityWith assertTrue(NO_TYPE.canTestForShallowEqualityWith(NO_TYPE)); assertTrue(NO_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); assertTrue(NO_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE)); assertTrue(NO_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE)); assertTrue(NO_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); assertTrue(NO_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); assertTrue(NO_TYPE.canTestForShallowEqualityWith(ERROR_TYPE)); assertTrue(NO_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); assertTrue(NO_TYPE.canTestForShallowEqualityWith(functionType)); assertTrue(NO_TYPE.canTestForShallowEqualityWith(NULL_TYPE)); assertTrue(NO_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); assertTrue(NO_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); assertTrue(NO_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); assertTrue(NO_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE)); assertTrue(NO_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); assertTrue(NO_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); assertTrue(NO_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); assertTrue(NO_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); assertTrue(NO_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); assertTrue(NO_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); assertTrue(NO_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); assertTrue(NO_TYPE.canTestForShallowEqualityWith(ALL_TYPE)); assertTrue(NO_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); // isNullable assertTrue(NO_TYPE.isNullable()); // isObject assertTrue(NO_TYPE.isObject()); // matchesXxx assertTrue(NO_TYPE.matchesInt32Context()); assertTrue(NO_TYPE.matchesNumberContext()); assertTrue(NO_TYPE.matchesObjectContext()); assertTrue(NO_TYPE.matchesStringContext()); assertTrue(NO_TYPE.matchesUint32Context()); // toString assertEquals("None", NO_TYPE.toString()); assertEquals(null, NO_TYPE.getDisplayName()); assertFalse(NO_TYPE.hasDisplayName()); // getPropertyType assertTypeEquals(NO_TYPE, NO_TYPE.getPropertyType("anyProperty")); Asserts.assertResolvesToSame(NO_TYPE); assertFalse(NO_TYPE.isNominalConstructor()); } /** * Tests the behavior of the unresolved Bottom type. */ public void testNoResolvedType() throws Exception { // isXxx assertFalse(NO_RESOLVED_TYPE.isNoObjectType()); assertFalse(NO_RESOLVED_TYPE.isNoType()); assertTrue(NO_RESOLVED_TYPE.isNoResolvedType()); assertFalse(NO_RESOLVED_TYPE.isArrayType()); assertFalse(NO_RESOLVED_TYPE.isBooleanValueType()); assertFalse(NO_RESOLVED_TYPE.isDateType()); assertFalse(NO_RESOLVED_TYPE.isEnumElementType()); assertFalse(NO_RESOLVED_TYPE.isNullType()); assertFalse(NO_RESOLVED_TYPE.isNamedType()); assertTrue(NO_RESOLVED_TYPE.isNumber()); assertFalse(NO_RESOLVED_TYPE.isNumberObjectType()); assertFalse(NO_RESOLVED_TYPE.isNumberValueType()); assertTrue(NO_RESOLVED_TYPE.isObject()); assertFalse(NO_RESOLVED_TYPE.isFunctionPrototypeType()); assertFalse(NO_RESOLVED_TYPE.isRegexpType()); assertTrue(NO_RESOLVED_TYPE.isString()); assertFalse(NO_RESOLVED_TYPE.isStringObjectType()); assertFalse(NO_RESOLVED_TYPE.isStringValueType()); assertFalse(NO_RESOLVED_TYPE.isEnumType()); assertFalse(NO_RESOLVED_TYPE.isUnionType()); assertFalse(NO_RESOLVED_TYPE.isStruct()); assertFalse(NO_RESOLVED_TYPE.isDict()); assertFalse(NO_RESOLVED_TYPE.isAllType()); assertFalse(NO_RESOLVED_TYPE.isVoidType()); assertTrue(NO_RESOLVED_TYPE.isConstructor()); assertFalse(NO_RESOLVED_TYPE.isInstanceType()); // isSubtype assertTrue(NO_RESOLVED_TYPE.isSubtype(NO_RESOLVED_TYPE)); assertTrue(NO_RESOLVED_TYPE.isSubtype(NO_OBJECT_TYPE)); assertTrue(NO_RESOLVED_TYPE.isSubtype(ARRAY_TYPE)); assertTrue(NO_RESOLVED_TYPE.isSubtype(BOOLEAN_TYPE)); assertTrue(NO_RESOLVED_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE)); assertTrue(NO_RESOLVED_TYPE.isSubtype(DATE_TYPE)); assertTrue(NO_RESOLVED_TYPE.isSubtype(ERROR_TYPE)); assertTrue(NO_RESOLVED_TYPE.isSubtype(EVAL_ERROR_TYPE)); assertTrue(NO_RESOLVED_TYPE.isSubtype(functionType)); assertTrue(NO_RESOLVED_TYPE.isSubtype(NULL_TYPE)); assertTrue(NO_RESOLVED_TYPE.isSubtype(NUMBER_TYPE)); assertTrue(NO_RESOLVED_TYPE.isSubtype(NUMBER_OBJECT_TYPE)); assertTrue(NO_RESOLVED_TYPE.isSubtype(OBJECT_TYPE)); assertTrue(NO_RESOLVED_TYPE.isSubtype(URI_ERROR_TYPE)); assertTrue(NO_RESOLVED_TYPE.isSubtype(RANGE_ERROR_TYPE)); assertTrue(NO_RESOLVED_TYPE.isSubtype(REFERENCE_ERROR_TYPE)); assertTrue(NO_RESOLVED_TYPE.isSubtype(REGEXP_TYPE)); assertTrue(NO_RESOLVED_TYPE.isSubtype(STRING_TYPE)); assertTrue(NO_RESOLVED_TYPE.isSubtype(STRING_OBJECT_TYPE)); assertTrue(NO_RESOLVED_TYPE.isSubtype(SYNTAX_ERROR_TYPE)); assertTrue(NO_RESOLVED_TYPE.isSubtype(TYPE_ERROR_TYPE)); assertTrue(NO_RESOLVED_TYPE.isSubtype(ALL_TYPE)); assertTrue(NO_RESOLVED_TYPE.isSubtype(VOID_TYPE)); // canTestForEqualityWith assertCanTestForEqualityWith(NO_RESOLVED_TYPE, NO_RESOLVED_TYPE); assertCanTestForEqualityWith(NO_RESOLVED_TYPE, NO_TYPE); assertCanTestForEqualityWith(NO_RESOLVED_TYPE, NO_OBJECT_TYPE); assertCanTestForEqualityWith(NO_RESOLVED_TYPE, ARRAY_TYPE); assertCanTestForEqualityWith(NO_RESOLVED_TYPE, BOOLEAN_TYPE); assertCanTestForEqualityWith(NO_RESOLVED_TYPE, BOOLEAN_OBJECT_TYPE); assertCanTestForEqualityWith(NO_RESOLVED_TYPE, DATE_TYPE); assertCanTestForEqualityWith(NO_RESOLVED_TYPE, ERROR_TYPE); assertCanTestForEqualityWith(NO_RESOLVED_TYPE, EVAL_ERROR_TYPE); assertCanTestForEqualityWith(NO_RESOLVED_TYPE, functionType); assertCanTestForEqualityWith(NO_RESOLVED_TYPE, NULL_TYPE); assertCanTestForEqualityWith(NO_RESOLVED_TYPE, NUMBER_TYPE); assertCanTestForEqualityWith(NO_RESOLVED_TYPE, NUMBER_OBJECT_TYPE); assertCanTestForEqualityWith(NO_RESOLVED_TYPE, OBJECT_TYPE); assertCanTestForEqualityWith(NO_RESOLVED_TYPE, URI_ERROR_TYPE); assertCanTestForEqualityWith(NO_RESOLVED_TYPE, RANGE_ERROR_TYPE); assertCanTestForEqualityWith(NO_RESOLVED_TYPE, REFERENCE_ERROR_TYPE); assertCanTestForEqualityWith(NO_RESOLVED_TYPE, REGEXP_TYPE); assertCanTestForEqualityWith(NO_RESOLVED_TYPE, STRING_TYPE); assertCanTestForEqualityWith(NO_RESOLVED_TYPE, STRING_OBJECT_TYPE); assertCanTestForEqualityWith(NO_RESOLVED_TYPE, SYNTAX_ERROR_TYPE); assertCanTestForEqualityWith(NO_RESOLVED_TYPE, TYPE_ERROR_TYPE); assertCanTestForEqualityWith(NO_RESOLVED_TYPE, ALL_TYPE); assertCanTestForEqualityWith(NO_RESOLVED_TYPE, VOID_TYPE); // canTestForShallowEqualityWith assertTrue( NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NO_RESOLVED_TYPE)); assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE)); assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE)); assertTrue( NO_RESOLVED_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(ERROR_TYPE)); assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(functionType)); assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NULL_TYPE)); assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); assertTrue( NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE)); assertTrue( NO_RESOLVED_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); assertTrue( NO_RESOLVED_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); assertTrue( NO_RESOLVED_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); assertTrue( NO_RESOLVED_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(ALL_TYPE)); assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); // isNullable assertTrue(NO_RESOLVED_TYPE.isNullable()); // isObject assertTrue(NO_RESOLVED_TYPE.isObject()); // matchesXxx assertTrue(NO_RESOLVED_TYPE.matchesInt32Context()); assertTrue(NO_RESOLVED_TYPE.matchesNumberContext()); assertTrue(NO_RESOLVED_TYPE.matchesObjectContext()); assertTrue(NO_RESOLVED_TYPE.matchesStringContext()); assertTrue(NO_RESOLVED_TYPE.matchesUint32Context()); // toString assertEquals("NoResolvedType", NO_RESOLVED_TYPE.toString()); assertEquals(null, NO_RESOLVED_TYPE.getDisplayName()); assertFalse(NO_RESOLVED_TYPE.hasDisplayName()); // getPropertyType assertTypeEquals(CHECKED_UNKNOWN_TYPE, NO_RESOLVED_TYPE.getPropertyType("anyProperty")); Asserts.assertResolvesToSame(NO_RESOLVED_TYPE); assertTrue(forwardDeclaredNamedType.isEmptyType()); assertTrue(forwardDeclaredNamedType.isNoResolvedType()); UnionType nullable = (UnionType) registry.createNullableType(NO_RESOLVED_TYPE); assertTypeEquals( nullable, nullable.getGreatestSubtype(NULL_TYPE)); assertTypeEquals(NO_RESOLVED_TYPE, nullable.getRestrictedUnion(NULL_TYPE)); } /** * Tests the behavior of the Array type. */ public void testArrayType() throws Exception { // isXxx assertTrue(ARRAY_TYPE.isArrayType()); assertFalse(ARRAY_TYPE.isBooleanValueType()); assertFalse(ARRAY_TYPE.isDateType()); assertFalse(ARRAY_TYPE.isEnumElementType()); assertFalse(ARRAY_TYPE.isNamedType()); assertFalse(ARRAY_TYPE.isNullType()); assertFalse(ARRAY_TYPE.isNumber()); assertFalse(ARRAY_TYPE.isNumberObjectType()); assertFalse(ARRAY_TYPE.isNumberValueType()); assertTrue(ARRAY_TYPE.isObject()); assertFalse(ARRAY_TYPE.isFunctionPrototypeType()); assertTrue(ARRAY_TYPE.getImplicitPrototype().isFunctionPrototypeType()); assertFalse(ARRAY_TYPE.isRegexpType()); assertFalse(ARRAY_TYPE.isString()); assertFalse(ARRAY_TYPE.isStringObjectType()); assertFalse(ARRAY_TYPE.isStringValueType()); assertFalse(ARRAY_TYPE.isEnumType()); assertFalse(ARRAY_TYPE.isUnionType()); assertFalse(ARRAY_TYPE.isStruct()); assertFalse(ARRAY_TYPE.isDict()); assertFalse(ARRAY_TYPE.isAllType()); assertFalse(ARRAY_TYPE.isVoidType()); assertFalse(ARRAY_TYPE.isConstructor()); assertTrue(ARRAY_TYPE.isInstanceType()); // isSubtype assertFalse(ARRAY_TYPE.isSubtype(NO_TYPE)); assertFalse(ARRAY_TYPE.isSubtype(NO_OBJECT_TYPE)); assertTrue(ARRAY_TYPE.isSubtype(ALL_TYPE)); assertFalse(ARRAY_TYPE.isSubtype(STRING_OBJECT_TYPE)); assertFalse(ARRAY_TYPE.isSubtype(NUMBER_TYPE)); assertFalse(ARRAY_TYPE.isSubtype(functionType)); assertFalse(ARRAY_TYPE.isSubtype(recordType)); assertFalse(ARRAY_TYPE.isSubtype(NULL_TYPE)); assertTrue(ARRAY_TYPE.isSubtype(OBJECT_TYPE)); assertFalse(ARRAY_TYPE.isSubtype(DATE_TYPE)); assertTrue(ARRAY_TYPE.isSubtype(unresolvedNamedType)); assertFalse(ARRAY_TYPE.isSubtype(namedGoogBar)); assertFalse(ARRAY_TYPE.isSubtype(REGEXP_TYPE)); // canBeCalled assertFalse(ARRAY_TYPE.canBeCalled()); // canTestForEqualityWith assertCanTestForEqualityWith(ARRAY_TYPE, NO_TYPE); assertCanTestForEqualityWith(ARRAY_TYPE, NO_OBJECT_TYPE); assertCanTestForEqualityWith(ARRAY_TYPE, ALL_TYPE); assertCanTestForEqualityWith(ARRAY_TYPE, STRING_OBJECT_TYPE); assertCanTestForEqualityWith(ARRAY_TYPE, NUMBER_TYPE); assertCanTestForEqualityWith(ARRAY_TYPE, functionType); assertCanTestForEqualityWith(ARRAY_TYPE, recordType); assertCannotTestForEqualityWith(ARRAY_TYPE, VOID_TYPE); assertCanTestForEqualityWith(ARRAY_TYPE, OBJECT_TYPE); assertCanTestForEqualityWith(ARRAY_TYPE, DATE_TYPE); assertCanTestForEqualityWith(ARRAY_TYPE, REGEXP_TYPE); // canTestForShallowEqualityWith assertTrue(ARRAY_TYPE.canTestForShallowEqualityWith(NO_TYPE)); assertTrue(ARRAY_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); assertTrue(ARRAY_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE)); assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE)); assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(ERROR_TYPE)); assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(functionType)); assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(recordType)); assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(NULL_TYPE)); assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); assertTrue(ARRAY_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE)); assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); assertTrue(ARRAY_TYPE.canTestForShallowEqualityWith(ALL_TYPE)); assertFalse(ARRAY_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); // isNullable assertFalse(ARRAY_TYPE.isNullable()); assertTrue(createUnionType(ARRAY_TYPE, NULL_TYPE).isNullable()); // isObject assertTrue(ARRAY_TYPE.isObject()); // getLeastSupertype assertTypeEquals(ALL_TYPE, ARRAY_TYPE.getLeastSupertype(ALL_TYPE)); assertTypeEquals(createUnionType(STRING_OBJECT_TYPE, ARRAY_TYPE), ARRAY_TYPE.getLeastSupertype(STRING_OBJECT_TYPE)); assertTypeEquals(createUnionType(NUMBER_TYPE, ARRAY_TYPE), ARRAY_TYPE.getLeastSupertype(NUMBER_TYPE)); assertTypeEquals(createUnionType(ARRAY_TYPE, functionType), ARRAY_TYPE.getLeastSupertype(functionType)); assertTypeEquals(OBJECT_TYPE, ARRAY_TYPE.getLeastSupertype(OBJECT_TYPE)); assertTypeEquals(createUnionType(DATE_TYPE, ARRAY_TYPE), ARRAY_TYPE.getLeastSupertype(DATE_TYPE)); assertTypeEquals(createUnionType(REGEXP_TYPE, ARRAY_TYPE), ARRAY_TYPE.getLeastSupertype(REGEXP_TYPE)); // getPropertyType assertEquals(17, ARRAY_TYPE.getImplicitPrototype().getPropertiesCount()); assertEquals(18, ARRAY_TYPE.getPropertiesCount()); assertReturnTypeEquals(ARRAY_TYPE, ARRAY_TYPE.getPropertyType("constructor")); assertReturnTypeEquals(STRING_TYPE, ARRAY_TYPE.getPropertyType("toString")); assertReturnTypeEquals(STRING_TYPE, ARRAY_TYPE.getPropertyType("toLocaleString")); assertReturnTypeEquals(ARRAY_TYPE, ARRAY_TYPE.getPropertyType("concat")); assertReturnTypeEquals(STRING_TYPE, ARRAY_TYPE.getPropertyType("join")); assertReturnTypeEquals(UNKNOWN_TYPE, ARRAY_TYPE.getPropertyType("pop")); assertReturnTypeEquals(NUMBER_TYPE, ARRAY_TYPE.getPropertyType("push")); assertReturnTypeEquals(ARRAY_TYPE, ARRAY_TYPE.getPropertyType("reverse")); assertReturnTypeEquals(UNKNOWN_TYPE, ARRAY_TYPE.getPropertyType("shift")); assertReturnTypeEquals(ARRAY_TYPE, ARRAY_TYPE.getPropertyType("slice")); assertReturnTypeEquals(ARRAY_TYPE, ARRAY_TYPE.getPropertyType("sort")); assertReturnTypeEquals(ARRAY_TYPE, ARRAY_TYPE.getPropertyType("splice")); assertReturnTypeEquals(NUMBER_TYPE, ARRAY_TYPE.getPropertyType("unshift")); assertTypeEquals(NUMBER_TYPE, ARRAY_TYPE.getPropertyType("length")); // isPropertyType* assertPropertyTypeDeclared(ARRAY_TYPE, "pop"); // matchesXxx assertFalse(ARRAY_TYPE.matchesInt32Context()); assertFalse(ARRAY_TYPE.matchesNumberContext()); assertTrue(ARRAY_TYPE.matchesObjectContext()); assertTrue(ARRAY_TYPE.matchesStringContext()); assertFalse(ARRAY_TYPE.matchesUint32Context()); // toString assertEquals("Array", ARRAY_TYPE.toString()); assertTrue(ARRAY_TYPE.hasDisplayName()); assertEquals("Array", ARRAY_TYPE.getDisplayName()); assertTrue(ARRAY_TYPE.isNativeObjectType()); Asserts.assertResolvesToSame(ARRAY_TYPE); assertFalse(ARRAY_TYPE.isNominalConstructor()); assertTrue(ARRAY_TYPE.getConstructor().isNominalConstructor()); } /** * Tests the behavior of the unknown type. */ public void testUnknownType() throws Exception { // isXxx assertFalse(UNKNOWN_TYPE.isArrayType()); assertFalse(UNKNOWN_TYPE.isBooleanObjectType()); assertFalse(UNKNOWN_TYPE.isBooleanValueType()); assertFalse(UNKNOWN_TYPE.isDateType()); assertFalse(UNKNOWN_TYPE.isEnumElementType()); assertFalse(UNKNOWN_TYPE.isNamedType()); assertFalse(UNKNOWN_TYPE.isNullType()); assertFalse(UNKNOWN_TYPE.isNumberObjectType()); assertFalse(UNKNOWN_TYPE.isNumberValueType()); assertTrue(UNKNOWN_TYPE.isObject()); assertFalse(UNKNOWN_TYPE.isFunctionPrototypeType()); assertFalse(UNKNOWN_TYPE.isRegexpType()); assertFalse(UNKNOWN_TYPE.isStringObjectType()); assertFalse(UNKNOWN_TYPE.isStringValueType()); assertFalse(UNKNOWN_TYPE.isEnumType()); assertFalse(UNKNOWN_TYPE.isUnionType()); assertFalse(UNKNOWN_TYPE.isStruct()); assertFalse(UNKNOWN_TYPE.isDict()); assertTrue(UNKNOWN_TYPE.isUnknownType()); assertFalse(UNKNOWN_TYPE.isVoidType()); assertFalse(UNKNOWN_TYPE.isConstructor()); assertFalse(UNKNOWN_TYPE.isInstanceType()); // autoboxesTo assertNull(UNKNOWN_TYPE.autoboxesTo()); // isSubtype assertTrue(UNKNOWN_TYPE.isSubtype(UNKNOWN_TYPE)); assertTrue(UNKNOWN_TYPE.isSubtype(STRING_TYPE)); assertTrue(UNKNOWN_TYPE.isSubtype(NUMBER_TYPE)); assertTrue(UNKNOWN_TYPE.isSubtype(functionType)); assertTrue(UNKNOWN_TYPE.isSubtype(recordType)); assertTrue(UNKNOWN_TYPE.isSubtype(NULL_TYPE)); assertTrue(UNKNOWN_TYPE.isSubtype(OBJECT_TYPE)); assertTrue(UNKNOWN_TYPE.isSubtype(DATE_TYPE)); assertTrue(UNKNOWN_TYPE.isSubtype(namedGoogBar)); assertTrue(UNKNOWN_TYPE.isSubtype(unresolvedNamedType)); assertTrue(UNKNOWN_TYPE.isSubtype(REGEXP_TYPE)); assertTrue(UNKNOWN_TYPE.isSubtype(VOID_TYPE)); // canBeCalled assertTrue(UNKNOWN_TYPE.canBeCalled()); // canTestForEqualityWith assertCanTestForEqualityWith(UNKNOWN_TYPE, UNKNOWN_TYPE); assertCanTestForEqualityWith(UNKNOWN_TYPE, STRING_TYPE); assertCanTestForEqualityWith(UNKNOWN_TYPE, NUMBER_TYPE); assertCanTestForEqualityWith(UNKNOWN_TYPE, functionType); assertCanTestForEqualityWith(UNKNOWN_TYPE, recordType); assertCanTestForEqualityWith(UNKNOWN_TYPE, VOID_TYPE); assertCanTestForEqualityWith(UNKNOWN_TYPE, OBJECT_TYPE); assertCanTestForEqualityWith(UNKNOWN_TYPE, DATE_TYPE); assertCanTestForEqualityWith(UNKNOWN_TYPE, REGEXP_TYPE); assertCanTestForEqualityWith(UNKNOWN_TYPE, BOOLEAN_TYPE); // canTestForShallowEqualityWith assertTrue(UNKNOWN_TYPE.canTestForShallowEqualityWith(UNKNOWN_TYPE)); assertTrue(UNKNOWN_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); assertTrue(UNKNOWN_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); assertTrue(UNKNOWN_TYPE.canTestForShallowEqualityWith(functionType)); assertTrue(UNKNOWN_TYPE.canTestForShallowEqualityWith(recordType)); assertTrue(UNKNOWN_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); assertTrue(UNKNOWN_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); assertTrue(UNKNOWN_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); assertTrue(UNKNOWN_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); // canHaveNullValue assertTrue(UNKNOWN_TYPE.isNullable()); // getGreatestCommonType assertTypeEquals(UNKNOWN_TYPE, UNKNOWN_TYPE.getLeastSupertype(UNKNOWN_TYPE)); assertTypeEquals(UNKNOWN_TYPE, UNKNOWN_TYPE.getLeastSupertype(STRING_TYPE)); assertTypeEquals(UNKNOWN_TYPE, UNKNOWN_TYPE.getLeastSupertype(NUMBER_TYPE)); assertTypeEquals(UNKNOWN_TYPE, UNKNOWN_TYPE.getLeastSupertype(functionType)); assertTypeEquals(UNKNOWN_TYPE, UNKNOWN_TYPE.getLeastSupertype(OBJECT_TYPE)); assertTypeEquals(UNKNOWN_TYPE, UNKNOWN_TYPE.getLeastSupertype(DATE_TYPE)); assertTypeEquals(UNKNOWN_TYPE, UNKNOWN_TYPE.getLeastSupertype(REGEXP_TYPE)); // matchesXxx assertTrue(UNKNOWN_TYPE.matchesInt32Context()); assertTrue(UNKNOWN_TYPE.matchesNumberContext()); assertTrue(UNKNOWN_TYPE.matchesObjectContext()); assertTrue(UNKNOWN_TYPE.matchesStringContext()); assertTrue(UNKNOWN_TYPE.matchesUint32Context()); // isPropertyType* assertPropertyTypeUnknown(UNKNOWN_TYPE, "XXX"); // toString assertEquals("?", UNKNOWN_TYPE.toString()); assertTrue(UNKNOWN_TYPE.hasDisplayName()); assertEquals("Unknown", UNKNOWN_TYPE.getDisplayName()); Asserts.assertResolvesToSame(UNKNOWN_TYPE); assertFalse(UNKNOWN_TYPE.isNominalConstructor()); assertEquals(UNKNOWN_TYPE, UNKNOWN_TYPE.getPropertyType("abc")); } /** * Tests the behavior of the checked unknown type. */ public void testCheckedUnknownType() throws Exception { // isPropertyType* assertPropertyTypeUnknown(CHECKED_UNKNOWN_TYPE, "XXX"); // toString assertEquals("??", CHECKED_UNKNOWN_TYPE.toString()); assertTrue(CHECKED_UNKNOWN_TYPE.hasDisplayName()); assertEquals("Unknown", CHECKED_UNKNOWN_TYPE.getDisplayName()); Asserts.assertResolvesToSame(CHECKED_UNKNOWN_TYPE); assertFalse(CHECKED_UNKNOWN_TYPE.isNominalConstructor()); assertEquals(CHECKED_UNKNOWN_TYPE, CHECKED_UNKNOWN_TYPE.getPropertyType("abc")); } /** * Tests the behavior of the unknown type. */ public void testAllType() throws Exception { // isXxx assertFalse(ALL_TYPE.isArrayType()); assertFalse(ALL_TYPE.isBooleanValueType()); assertFalse(ALL_TYPE.isDateType()); assertFalse(ALL_TYPE.isEnumElementType()); assertFalse(ALL_TYPE.isNamedType()); assertFalse(ALL_TYPE.isNullType()); assertFalse(ALL_TYPE.isNumber()); assertFalse(ALL_TYPE.isNumberObjectType()); assertFalse(ALL_TYPE.isNumberValueType()); assertFalse(ALL_TYPE.isObject()); assertFalse(ALL_TYPE.isFunctionPrototypeType()); assertFalse(ALL_TYPE.isRegexpType()); assertFalse(ALL_TYPE.isString()); assertFalse(ALL_TYPE.isStringObjectType()); assertFalse(ALL_TYPE.isStringValueType()); assertFalse(ALL_TYPE.isEnumType()); assertFalse(ALL_TYPE.isUnionType()); assertFalse(ALL_TYPE.isStruct()); assertFalse(ALL_TYPE.isDict()); assertTrue(ALL_TYPE.isAllType()); assertFalse(ALL_TYPE.isVoidType()); assertFalse(ALL_TYPE.isConstructor()); assertFalse(ALL_TYPE.isInstanceType()); // isSubtype assertFalse(ALL_TYPE.isSubtype(NO_TYPE)); assertFalse(ALL_TYPE.isSubtype(NO_OBJECT_TYPE)); assertTrue(ALL_TYPE.isSubtype(ALL_TYPE)); assertFalse(ALL_TYPE.isSubtype(STRING_OBJECT_TYPE)); assertFalse(ALL_TYPE.isSubtype(NUMBER_TYPE)); assertFalse(ALL_TYPE.isSubtype(functionType)); assertFalse(ALL_TYPE.isSubtype(recordType)); assertFalse(ALL_TYPE.isSubtype(NULL_TYPE)); assertFalse(ALL_TYPE.isSubtype(OBJECT_TYPE)); assertFalse(ALL_TYPE.isSubtype(DATE_TYPE)); assertTrue(ALL_TYPE.isSubtype(unresolvedNamedType)); assertFalse(ALL_TYPE.isSubtype(namedGoogBar)); assertFalse(ALL_TYPE.isSubtype(REGEXP_TYPE)); assertFalse(ALL_TYPE.isSubtype(VOID_TYPE)); assertTrue(ALL_TYPE.isSubtype(UNKNOWN_TYPE)); // canBeCalled assertFalse(ALL_TYPE.canBeCalled()); // canTestForEqualityWith assertCanTestForEqualityWith(ALL_TYPE, ALL_TYPE); assertCanTestForEqualityWith(ALL_TYPE, STRING_OBJECT_TYPE); assertCanTestForEqualityWith(ALL_TYPE, NUMBER_TYPE); assertCanTestForEqualityWith(ALL_TYPE, functionType); assertCanTestForEqualityWith(ALL_TYPE, recordType); assertCanTestForEqualityWith(ALL_TYPE, VOID_TYPE); assertCanTestForEqualityWith(ALL_TYPE, OBJECT_TYPE); assertCanTestForEqualityWith(ALL_TYPE, DATE_TYPE); assertCanTestForEqualityWith(ALL_TYPE, REGEXP_TYPE); // canTestForShallowEqualityWith assertTrue(ALL_TYPE.canTestForShallowEqualityWith(NO_TYPE)); assertTrue(ALL_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); assertTrue(ALL_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE)); assertTrue(ALL_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE)); assertTrue(ALL_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); assertTrue(ALL_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); assertTrue(ALL_TYPE.canTestForShallowEqualityWith(ERROR_TYPE)); assertTrue(ALL_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); assertTrue(ALL_TYPE.canTestForShallowEqualityWith(functionType)); assertTrue(ALL_TYPE.canTestForShallowEqualityWith(recordType)); assertTrue(ALL_TYPE.canTestForShallowEqualityWith(NULL_TYPE)); assertTrue(ALL_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); assertTrue(ALL_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); assertTrue(ALL_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); assertTrue(ALL_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE)); assertTrue(ALL_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); assertTrue(ALL_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); assertTrue(ALL_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); assertTrue(ALL_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); assertTrue(ALL_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); assertTrue(ALL_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); assertTrue(ALL_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); assertTrue(ALL_TYPE.canTestForShallowEqualityWith(ALL_TYPE)); assertTrue(ALL_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); // isNullable assertFalse(ALL_TYPE.isNullable()); // getLeastSupertype assertTypeEquals(ALL_TYPE, ALL_TYPE.getLeastSupertype(ALL_TYPE)); assertTypeEquals(ALL_TYPE, ALL_TYPE.getLeastSupertype(UNKNOWN_TYPE)); assertTypeEquals(ALL_TYPE, ALL_TYPE.getLeastSupertype(STRING_OBJECT_TYPE)); assertTypeEquals(ALL_TYPE, ALL_TYPE.getLeastSupertype(NUMBER_TYPE)); assertTypeEquals(ALL_TYPE, ALL_TYPE.getLeastSupertype(functionType)); assertTypeEquals(ALL_TYPE, ALL_TYPE.getLeastSupertype(OBJECT_TYPE)); assertTypeEquals(ALL_TYPE, ALL_TYPE.getLeastSupertype(DATE_TYPE)); assertTypeEquals(ALL_TYPE, ALL_TYPE.getLeastSupertype(REGEXP_TYPE)); // matchesXxx assertFalse(ALL_TYPE.matchesInt32Context()); assertFalse(ALL_TYPE.matchesNumberContext()); assertTrue(ALL_TYPE.matchesObjectContext()); assertTrue(ALL_TYPE.matchesStringContext()); assertFalse(ALL_TYPE.matchesUint32Context()); // toString assertEquals("*", ALL_TYPE.toString()); assertTrue(ALL_TYPE.hasDisplayName()); assertEquals("<Any Type>", ALL_TYPE.getDisplayName()); Asserts.assertResolvesToSame(ALL_TYPE); assertFalse(ALL_TYPE.isNominalConstructor()); } /** * Tests the behavior of the Object type (the object * at the top of the JavaScript hierarchy). */ public void testTheObjectType() throws Exception { // implicit prototype assertTypeEquals(OBJECT_PROTOTYPE, OBJECT_TYPE.getImplicitPrototype()); // isXxx assertFalse(OBJECT_TYPE.isNoObjectType()); assertFalse(OBJECT_TYPE.isNoType()); assertFalse(OBJECT_TYPE.isArrayType()); assertFalse(OBJECT_TYPE.isBooleanValueType()); assertFalse(OBJECT_TYPE.isDateType()); assertFalse(OBJECT_TYPE.isEnumElementType()); assertFalse(OBJECT_TYPE.isNullType()); assertFalse(OBJECT_TYPE.isNamedType()); assertFalse(OBJECT_TYPE.isNullType()); assertFalse(OBJECT_TYPE.isNumber()); assertFalse(OBJECT_TYPE.isNumberObjectType()); assertFalse(OBJECT_TYPE.isNumberValueType()); assertTrue(OBJECT_TYPE.isObject()); assertFalse(OBJECT_TYPE.isFunctionPrototypeType()); assertTrue(OBJECT_TYPE.getImplicitPrototype().isFunctionPrototypeType()); assertFalse(OBJECT_TYPE.isRegexpType()); assertFalse(OBJECT_TYPE.isString()); assertFalse(OBJECT_TYPE.isStringObjectType()); assertFalse(OBJECT_TYPE.isStringValueType()); assertFalse(OBJECT_TYPE.isEnumType()); assertFalse(OBJECT_TYPE.isUnionType()); assertFalse(OBJECT_TYPE.isStruct()); assertFalse(OBJECT_TYPE.isDict()); assertFalse(OBJECT_TYPE.isAllType()); assertFalse(OBJECT_TYPE.isVoidType()); assertFalse(OBJECT_TYPE.isConstructor()); assertTrue(OBJECT_TYPE.isInstanceType()); // isSubtype assertFalse(OBJECT_TYPE.isSubtype(NO_TYPE)); assertTrue(OBJECT_TYPE.isSubtype(ALL_TYPE)); assertFalse(OBJECT_TYPE.isSubtype(STRING_OBJECT_TYPE)); assertFalse(OBJECT_TYPE.isSubtype(NUMBER_TYPE)); assertFalse(OBJECT_TYPE.isSubtype(functionType)); assertFalse(OBJECT_TYPE.isSubtype(recordType)); assertFalse(OBJECT_TYPE.isSubtype(NULL_TYPE)); assertTrue(OBJECT_TYPE.isSubtype(OBJECT_TYPE)); assertFalse(OBJECT_TYPE.isSubtype(DATE_TYPE)); assertFalse(OBJECT_TYPE.isSubtype(namedGoogBar)); assertTrue(OBJECT_TYPE.isSubtype(unresolvedNamedType)); assertFalse(OBJECT_TYPE.isSubtype(REGEXP_TYPE)); assertFalse(OBJECT_TYPE.isSubtype(ARRAY_TYPE)); assertTrue(OBJECT_TYPE.isSubtype(UNKNOWN_TYPE)); // canBeCalled assertFalse(OBJECT_TYPE.canBeCalled()); // canTestForEqualityWith assertCanTestForEqualityWith(OBJECT_TYPE, ALL_TYPE); assertCanTestForEqualityWith(OBJECT_TYPE, STRING_OBJECT_TYPE); assertCanTestForEqualityWith(OBJECT_TYPE, NUMBER_TYPE); assertCanTestForEqualityWith(OBJECT_TYPE, STRING_TYPE); assertCanTestForEqualityWith(OBJECT_TYPE, BOOLEAN_TYPE); assertCanTestForEqualityWith(OBJECT_TYPE, functionType); assertCanTestForEqualityWith(OBJECT_TYPE, recordType); assertCannotTestForEqualityWith(OBJECT_TYPE, VOID_TYPE); assertCanTestForEqualityWith(OBJECT_TYPE, OBJECT_TYPE); assertCanTestForEqualityWith(OBJECT_TYPE, DATE_TYPE); assertCanTestForEqualityWith(OBJECT_TYPE, REGEXP_TYPE); assertCanTestForEqualityWith(OBJECT_TYPE, ARRAY_TYPE); assertCanTestForEqualityWith(OBJECT_TYPE, UNKNOWN_TYPE); // canTestForShallowEqualityWith assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(NO_TYPE)); assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE)); assertFalse(OBJECT_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE)); assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(ERROR_TYPE)); assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(functionType)); assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(recordType)); assertFalse(OBJECT_TYPE.canTestForShallowEqualityWith(NULL_TYPE)); assertFalse(OBJECT_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE)); assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); assertTrue(OBJECT_TYPE. canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); assertFalse(OBJECT_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(ALL_TYPE)); assertFalse(OBJECT_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); assertTrue(OBJECT_TYPE.canTestForShallowEqualityWith(UNKNOWN_TYPE)); // isNullable assertFalse(OBJECT_TYPE.isNullable()); // getLeastSupertype assertTypeEquals(ALL_TYPE, OBJECT_TYPE.getLeastSupertype(ALL_TYPE)); assertTypeEquals(OBJECT_TYPE, OBJECT_TYPE.getLeastSupertype(STRING_OBJECT_TYPE)); assertTypeEquals(createUnionType(OBJECT_TYPE, NUMBER_TYPE), OBJECT_TYPE.getLeastSupertype(NUMBER_TYPE)); assertTypeEquals(OBJECT_TYPE, OBJECT_TYPE.getLeastSupertype(functionType)); assertTypeEquals(OBJECT_TYPE, OBJECT_TYPE.getLeastSupertype(OBJECT_TYPE)); assertTypeEquals(OBJECT_TYPE, OBJECT_TYPE.getLeastSupertype(DATE_TYPE)); assertTypeEquals(OBJECT_TYPE, OBJECT_TYPE.getLeastSupertype(REGEXP_TYPE)); // getPropertyType assertEquals(7, OBJECT_TYPE.getPropertiesCount()); assertReturnTypeEquals(OBJECT_TYPE, OBJECT_TYPE.getPropertyType("constructor")); assertReturnTypeEquals(STRING_TYPE, OBJECT_TYPE.getPropertyType("toString")); assertReturnTypeEquals(STRING_TYPE, OBJECT_TYPE.getPropertyType("toLocaleString")); assertReturnTypeEquals(UNKNOWN_TYPE, OBJECT_TYPE.getPropertyType("valueOf")); assertReturnTypeEquals(BOOLEAN_TYPE, OBJECT_TYPE.getPropertyType("hasOwnProperty")); assertReturnTypeEquals(BOOLEAN_TYPE, OBJECT_TYPE.getPropertyType("isPrototypeOf")); assertReturnTypeEquals(BOOLEAN_TYPE, OBJECT_TYPE.getPropertyType("propertyIsEnumerable")); // matchesXxx assertFalse(OBJECT_TYPE.matchesInt32Context()); assertFalse(OBJECT_TYPE.matchesNumberContext()); assertTrue(OBJECT_TYPE.matchesObjectContext()); assertTrue(OBJECT_TYPE.matchesStringContext()); assertFalse(OBJECT_TYPE.matchesUint32Context()); // implicit prototype assertTypeEquals(OBJECT_PROTOTYPE, OBJECT_TYPE.getImplicitPrototype()); // toString assertEquals("Object", OBJECT_TYPE.toString()); assertTrue(OBJECT_TYPE.isNativeObjectType()); assertTrue(OBJECT_TYPE.getImplicitPrototype().isNativeObjectType()); Asserts.assertResolvesToSame(OBJECT_TYPE); assertFalse(OBJECT_TYPE.isNominalConstructor()); assertTrue(OBJECT_TYPE.getConstructor().isNominalConstructor()); } /** * Tests the behavior of the number value type. */ public void testNumberObjectType() throws Exception { // isXxx assertFalse(NUMBER_OBJECT_TYPE.isArrayType()); assertFalse(NUMBER_OBJECT_TYPE.isBooleanObjectType()); assertFalse(NUMBER_OBJECT_TYPE.isBooleanValueType()); assertFalse(NUMBER_OBJECT_TYPE.isDateType()); assertFalse(NUMBER_OBJECT_TYPE.isEnumElementType()); assertFalse(NUMBER_OBJECT_TYPE.isNamedType()); assertFalse(NUMBER_OBJECT_TYPE.isNullType()); assertTrue(NUMBER_OBJECT_TYPE.isNumber()); assertTrue(NUMBER_OBJECT_TYPE.isNumberObjectType()); assertFalse(NUMBER_OBJECT_TYPE.isNumberValueType()); assertTrue(NUMBER_OBJECT_TYPE.isObject()); assertFalse(NUMBER_OBJECT_TYPE.isFunctionPrototypeType()); assertTrue( NUMBER_OBJECT_TYPE.getImplicitPrototype().isFunctionPrototypeType()); assertFalse(NUMBER_OBJECT_TYPE.isRegexpType()); assertFalse(NUMBER_OBJECT_TYPE.isString()); assertFalse(NUMBER_OBJECT_TYPE.isStringObjectType()); assertFalse(NUMBER_OBJECT_TYPE.isStringValueType()); assertFalse(NUMBER_OBJECT_TYPE.isEnumType()); assertFalse(NUMBER_OBJECT_TYPE.isUnionType()); assertFalse(NUMBER_OBJECT_TYPE.isStruct()); assertFalse(NUMBER_OBJECT_TYPE.isDict()); assertFalse(NUMBER_OBJECT_TYPE.isAllType()); assertFalse(NUMBER_OBJECT_TYPE.isVoidType()); assertFalse(NUMBER_OBJECT_TYPE.isConstructor()); assertTrue(NUMBER_OBJECT_TYPE.isInstanceType()); // autoboxesTo assertTypeEquals(NUMBER_OBJECT_TYPE, NUMBER_TYPE.autoboxesTo()); // unboxesTo assertTypeEquals(NUMBER_TYPE, NUMBER_OBJECT_TYPE.unboxesTo()); // isSubtype assertTrue(NUMBER_OBJECT_TYPE.isSubtype(ALL_TYPE)); assertFalse(NUMBER_OBJECT_TYPE.isSubtype(STRING_OBJECT_TYPE)); assertFalse(NUMBER_OBJECT_TYPE.isSubtype(NUMBER_TYPE)); assertFalse(NUMBER_OBJECT_TYPE.isSubtype(functionType)); assertFalse(NUMBER_OBJECT_TYPE.isSubtype(NULL_TYPE)); assertTrue(NUMBER_OBJECT_TYPE.isSubtype(OBJECT_TYPE)); assertFalse(NUMBER_OBJECT_TYPE.isSubtype(DATE_TYPE)); assertTrue(NUMBER_OBJECT_TYPE.isSubtype(unresolvedNamedType)); assertFalse(NUMBER_OBJECT_TYPE.isSubtype(namedGoogBar)); assertTrue(NUMBER_OBJECT_TYPE.isSubtype( createUnionType(NUMBER_OBJECT_TYPE, NULL_TYPE))); assertFalse(NUMBER_OBJECT_TYPE.isSubtype( createUnionType(NUMBER_TYPE, NULL_TYPE))); assertTrue(NUMBER_OBJECT_TYPE.isSubtype(UNKNOWN_TYPE)); // canBeCalled assertFalse(NUMBER_OBJECT_TYPE.canBeCalled()); // canTestForEqualityWith assertCanTestForEqualityWith(NUMBER_OBJECT_TYPE, NO_TYPE); assertCanTestForEqualityWith(NUMBER_OBJECT_TYPE, NO_OBJECT_TYPE); assertCanTestForEqualityWith(NUMBER_OBJECT_TYPE, ALL_TYPE); assertCanTestForEqualityWith(NUMBER_OBJECT_TYPE, NUMBER_TYPE); assertCanTestForEqualityWith(NUMBER_OBJECT_TYPE, STRING_OBJECT_TYPE); assertCanTestForEqualityWith(NUMBER_OBJECT_TYPE, functionType); assertCanTestForEqualityWith(NUMBER_OBJECT_TYPE, elementsType); assertCannotTestForEqualityWith(NUMBER_OBJECT_TYPE, VOID_TYPE); assertCanTestForEqualityWith(NUMBER_OBJECT_TYPE, OBJECT_TYPE); assertCanTestForEqualityWith(NUMBER_OBJECT_TYPE, DATE_TYPE); assertCanTestForEqualityWith(NUMBER_OBJECT_TYPE, REGEXP_TYPE); assertCanTestForEqualityWith(NUMBER_OBJECT_TYPE, ARRAY_TYPE); // canTestForShallowEqualityWith assertTrue(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(NO_TYPE)); assertTrue(NUMBER_OBJECT_TYPE. canTestForShallowEqualityWith(NO_OBJECT_TYPE)); assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE)); assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE)); assertFalse(NUMBER_OBJECT_TYPE. canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(ERROR_TYPE)); assertFalse(NUMBER_OBJECT_TYPE. canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(functionType)); assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(NULL_TYPE)); assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); assertTrue(NUMBER_OBJECT_TYPE. canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); assertTrue(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); assertFalse(NUMBER_OBJECT_TYPE. canTestForShallowEqualityWith(URI_ERROR_TYPE)); assertFalse(NUMBER_OBJECT_TYPE. canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); assertFalse(NUMBER_OBJECT_TYPE. canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); assertFalse(NUMBER_OBJECT_TYPE. canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); assertFalse(NUMBER_OBJECT_TYPE. canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); assertFalse(NUMBER_OBJECT_TYPE. canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); assertTrue(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(ALL_TYPE)); assertFalse(NUMBER_OBJECT_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); // isNullable assertFalse(NUMBER_OBJECT_TYPE.isNullable()); // getLeastSupertype assertTypeEquals(ALL_TYPE, NUMBER_OBJECT_TYPE.getLeastSupertype(ALL_TYPE)); assertTypeEquals(createUnionType(NUMBER_OBJECT_TYPE, STRING_OBJECT_TYPE), NUMBER_OBJECT_TYPE.getLeastSupertype(STRING_OBJECT_TYPE)); assertTypeEquals(createUnionType(NUMBER_OBJECT_TYPE, NUMBER_TYPE), NUMBER_OBJECT_TYPE.getLeastSupertype(NUMBER_TYPE)); assertTypeEquals(createUnionType(NUMBER_OBJECT_TYPE, functionType), NUMBER_OBJECT_TYPE.getLeastSupertype(functionType)); assertTypeEquals(OBJECT_TYPE, NUMBER_OBJECT_TYPE.getLeastSupertype(OBJECT_TYPE)); assertTypeEquals(createUnionType(NUMBER_OBJECT_TYPE, DATE_TYPE), NUMBER_OBJECT_TYPE.getLeastSupertype(DATE_TYPE)); assertTypeEquals(createUnionType(NUMBER_OBJECT_TYPE, REGEXP_TYPE), NUMBER_OBJECT_TYPE.getLeastSupertype(REGEXP_TYPE)); // matchesXxx assertTrue(NUMBER_OBJECT_TYPE.matchesInt32Context()); assertTrue(NUMBER_OBJECT_TYPE.matchesNumberContext()); assertTrue(NUMBER_OBJECT_TYPE.matchesObjectContext()); assertTrue(NUMBER_OBJECT_TYPE.matchesStringContext()); assertTrue(NUMBER_OBJECT_TYPE.matchesUint32Context()); // toString assertEquals("Number", NUMBER_OBJECT_TYPE.toString()); assertTrue(NUMBER_OBJECT_TYPE.hasDisplayName()); assertEquals("Number", NUMBER_OBJECT_TYPE.getDisplayName()); assertTrue(NUMBER_OBJECT_TYPE.isNativeObjectType()); Asserts.assertResolvesToSame(NUMBER_OBJECT_TYPE); } /** * Tests the behavior of the number value type. */ public void testNumberValueType() throws Exception { // isXxx assertFalse(NUMBER_TYPE.isArrayType()); assertFalse(NUMBER_TYPE.isBooleanObjectType()); assertFalse(NUMBER_TYPE.isBooleanValueType()); assertFalse(NUMBER_TYPE.isDateType()); assertFalse(NUMBER_TYPE.isEnumElementType()); assertFalse(NUMBER_TYPE.isNamedType()); assertFalse(NUMBER_TYPE.isNullType()); assertTrue(NUMBER_TYPE.isNumber()); assertFalse(NUMBER_TYPE.isNumberObjectType()); assertTrue(NUMBER_TYPE.isNumberValueType()); assertFalse(NUMBER_TYPE.isFunctionPrototypeType()); assertFalse(NUMBER_TYPE.isRegexpType()); assertFalse(NUMBER_TYPE.isString()); assertFalse(NUMBER_TYPE.isStringObjectType()); assertFalse(NUMBER_TYPE.isStringValueType()); assertFalse(NUMBER_TYPE.isEnumType()); assertFalse(NUMBER_TYPE.isUnionType()); assertFalse(NUMBER_TYPE.isStruct()); assertFalse(NUMBER_TYPE.isDict()); assertFalse(NUMBER_TYPE.isAllType()); assertFalse(NUMBER_TYPE.isVoidType()); assertFalse(NUMBER_TYPE.isConstructor()); assertFalse(NUMBER_TYPE.isInstanceType()); // autoboxesTo assertTypeEquals(NUMBER_OBJECT_TYPE, NUMBER_TYPE.autoboxesTo()); // isSubtype assertTrue(NUMBER_TYPE.isSubtype(ALL_TYPE)); assertFalse(NUMBER_TYPE.isSubtype(STRING_OBJECT_TYPE)); assertTrue(NUMBER_TYPE.isSubtype(NUMBER_TYPE)); assertFalse(NUMBER_TYPE.isSubtype(functionType)); assertFalse(NUMBER_TYPE.isSubtype(NULL_TYPE)); assertFalse(NUMBER_TYPE.isSubtype(OBJECT_TYPE)); assertFalse(NUMBER_TYPE.isSubtype(DATE_TYPE)); assertTrue(NUMBER_TYPE.isSubtype(unresolvedNamedType)); assertFalse(NUMBER_TYPE.isSubtype(namedGoogBar)); assertTrue(NUMBER_TYPE.isSubtype( createUnionType(NUMBER_TYPE, NULL_TYPE))); assertTrue(NUMBER_TYPE.isSubtype(UNKNOWN_TYPE)); // canBeCalled assertFalse(NUMBER_TYPE.canBeCalled()); // canTestForEqualityWith assertCanTestForEqualityWith(NUMBER_TYPE, NO_TYPE); assertCanTestForEqualityWith(NUMBER_TYPE, NO_OBJECT_TYPE); assertCanTestForEqualityWith(NUMBER_TYPE, ALL_TYPE); assertCanTestForEqualityWith(NUMBER_TYPE, NUMBER_TYPE); assertCanTestForEqualityWith(NUMBER_TYPE, STRING_OBJECT_TYPE); assertCannotTestForEqualityWith(NUMBER_TYPE, functionType); assertCannotTestForEqualityWith(NUMBER_TYPE, VOID_TYPE); assertCanTestForEqualityWith(NUMBER_TYPE, OBJECT_TYPE); assertCanTestForEqualityWith(NUMBER_TYPE, DATE_TYPE); assertCanTestForEqualityWith(NUMBER_TYPE, REGEXP_TYPE); assertCanTestForEqualityWith(NUMBER_TYPE, ARRAY_TYPE); assertCanTestForEqualityWith(NUMBER_TYPE, UNKNOWN_TYPE); // canTestForShallowEqualityWith assertTrue(NUMBER_TYPE.canTestForShallowEqualityWith(NO_TYPE)); assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE)); assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE)); assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(ERROR_TYPE)); assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(functionType)); assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(NULL_TYPE)); assertTrue(NUMBER_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE)); assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); assertFalse(NUMBER_TYPE. canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); assertTrue(NUMBER_TYPE.canTestForShallowEqualityWith(ALL_TYPE)); assertFalse(NUMBER_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); assertTrue(NUMBER_TYPE.canTestForShallowEqualityWith(UNKNOWN_TYPE)); // isNullable assertFalse(NUMBER_TYPE.isNullable()); // getLeastSupertype assertTypeEquals(ALL_TYPE, NUMBER_TYPE.getLeastSupertype(ALL_TYPE)); assertTypeEquals(createUnionType(NUMBER_TYPE, STRING_OBJECT_TYPE), NUMBER_TYPE.getLeastSupertype(STRING_OBJECT_TYPE)); assertTypeEquals(NUMBER_TYPE, NUMBER_TYPE.getLeastSupertype(NUMBER_TYPE)); assertTypeEquals(createUnionType(NUMBER_TYPE, functionType), NUMBER_TYPE.getLeastSupertype(functionType)); assertTypeEquals(createUnionType(NUMBER_TYPE, OBJECT_TYPE), NUMBER_TYPE.getLeastSupertype(OBJECT_TYPE)); assertTypeEquals(createUnionType(NUMBER_TYPE, DATE_TYPE), NUMBER_TYPE.getLeastSupertype(DATE_TYPE)); assertTypeEquals(createUnionType(NUMBER_TYPE, REGEXP_TYPE), NUMBER_TYPE.getLeastSupertype(REGEXP_TYPE)); // matchesXxx assertTrue(NUMBER_TYPE.matchesInt32Context()); assertTrue(NUMBER_TYPE.matchesNumberContext()); assertTrue(NUMBER_TYPE.matchesObjectContext()); assertTrue(NUMBER_TYPE.matchesStringContext()); assertTrue(NUMBER_TYPE.matchesUint32Context()); // toString assertEquals("number", NUMBER_TYPE.toString()); assertTrue(NUMBER_TYPE.hasDisplayName()); assertEquals("number", NUMBER_TYPE.getDisplayName()); Asserts.assertResolvesToSame(NUMBER_TYPE); assertFalse(NUMBER_TYPE.isNominalConstructor()); } /** * Tests the behavior of the null type. */ public void testNullType() throws Exception { // isXxx assertFalse(NULL_TYPE.isArrayType()); assertFalse(NULL_TYPE.isBooleanValueType()); assertFalse(NULL_TYPE.isDateType()); assertFalse(NULL_TYPE.isEnumElementType()); assertFalse(NULL_TYPE.isNamedType()); assertTrue(NULL_TYPE.isNullType()); assertFalse(NULL_TYPE.isNumber()); assertFalse(NULL_TYPE.isNumberObjectType()); assertFalse(NULL_TYPE.isNumberValueType()); assertFalse(NULL_TYPE.isFunctionPrototypeType()); assertFalse(NULL_TYPE.isRegexpType()); assertFalse(NULL_TYPE.isString()); assertFalse(NULL_TYPE.isStringObjectType()); assertFalse(NULL_TYPE.isStringValueType()); assertFalse(NULL_TYPE.isEnumType()); assertFalse(NULL_TYPE.isUnionType()); assertFalse(NULL_TYPE.isStruct()); assertFalse(NULL_TYPE.isDict()); assertFalse(NULL_TYPE.isAllType()); assertFalse(NULL_TYPE.isVoidType()); assertFalse(NULL_TYPE.isConstructor()); assertFalse(NULL_TYPE.isInstanceType()); // autoboxesTo assertNull(NULL_TYPE.autoboxesTo()); // isSubtype assertFalse(NULL_TYPE.isSubtype(NO_OBJECT_TYPE)); assertFalse(NULL_TYPE.isSubtype(NO_TYPE)); assertTrue(NULL_TYPE.isSubtype(NULL_TYPE)); assertTrue(NULL_TYPE.isSubtype(ALL_TYPE)); assertFalse(NULL_TYPE.isSubtype(STRING_OBJECT_TYPE)); assertFalse(NULL_TYPE.isSubtype(NUMBER_TYPE)); assertFalse(NULL_TYPE.isSubtype(functionType)); assertFalse(NULL_TYPE.isSubtype(OBJECT_TYPE)); assertFalse(NULL_TYPE.isSubtype(DATE_TYPE)); assertFalse(NULL_TYPE.isSubtype(REGEXP_TYPE)); assertFalse(NULL_TYPE.isSubtype(ARRAY_TYPE)); assertTrue(NULL_TYPE.isSubtype(UNKNOWN_TYPE)); assertTrue(NULL_TYPE.isSubtype(createNullableType(NO_OBJECT_TYPE))); assertTrue(NULL_TYPE.isSubtype(createNullableType(NO_TYPE))); assertTrue(NULL_TYPE.isSubtype(createNullableType(NULL_TYPE))); assertTrue(NULL_TYPE.isSubtype(createNullableType(ALL_TYPE))); assertTrue(NULL_TYPE.isSubtype(createNullableType(STRING_OBJECT_TYPE))); assertTrue(NULL_TYPE.isSubtype(createNullableType(NUMBER_TYPE))); assertTrue(NULL_TYPE.isSubtype(createNullableType(functionType))); assertTrue(NULL_TYPE.isSubtype(createNullableType(OBJECT_TYPE))); assertTrue(NULL_TYPE.isSubtype(createNullableType(DATE_TYPE))); assertTrue(NULL_TYPE.isSubtype(createNullableType(REGEXP_TYPE))); assertTrue(NULL_TYPE.isSubtype(createNullableType(ARRAY_TYPE))); // canBeCalled assertFalse(NULL_TYPE.canBeCalled()); // canTestForEqualityWith assertCanTestForEqualityWith(NULL_TYPE, NO_TYPE); assertCanTestForEqualityWith(NULL_TYPE, NO_OBJECT_TYPE); assertCanTestForEqualityWith(NULL_TYPE, ALL_TYPE); assertCannotTestForEqualityWith(NULL_TYPE, ARRAY_TYPE); assertCannotTestForEqualityWith(NULL_TYPE, BOOLEAN_TYPE); assertCannotTestForEqualityWith(NULL_TYPE, BOOLEAN_OBJECT_TYPE); assertCannotTestForEqualityWith(NULL_TYPE, DATE_TYPE); assertCannotTestForEqualityWith(NULL_TYPE, ERROR_TYPE); assertCannotTestForEqualityWith(NULL_TYPE, EVAL_ERROR_TYPE); assertCannotTestForEqualityWith(NULL_TYPE, functionType); assertCannotTestForEqualityWith(NULL_TYPE, NULL_TYPE); assertCannotTestForEqualityWith(NULL_TYPE, NUMBER_TYPE); assertCannotTestForEqualityWith(NULL_TYPE, NUMBER_OBJECT_TYPE); assertCannotTestForEqualityWith(NULL_TYPE, OBJECT_TYPE); assertCannotTestForEqualityWith(NULL_TYPE, URI_ERROR_TYPE); assertCannotTestForEqualityWith(NULL_TYPE, RANGE_ERROR_TYPE); assertCannotTestForEqualityWith(NULL_TYPE, REFERENCE_ERROR_TYPE); assertCannotTestForEqualityWith(NULL_TYPE, REGEXP_TYPE); assertCannotTestForEqualityWith(NULL_TYPE, STRING_TYPE); assertCannotTestForEqualityWith(NULL_TYPE, STRING_OBJECT_TYPE); assertCannotTestForEqualityWith(NULL_TYPE, SYNTAX_ERROR_TYPE); assertCannotTestForEqualityWith(NULL_TYPE, TYPE_ERROR_TYPE); assertCannotTestForEqualityWith(NULL_TYPE, VOID_TYPE); // canTestForShallowEqualityWith assertTrue(NULL_TYPE.canTestForShallowEqualityWith(NO_TYPE)); assertFalse(NULL_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); assertFalse(NULL_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE)); assertFalse(NULL_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE)); assertFalse(NULL_TYPE. canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); assertFalse(NULL_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); assertFalse(NULL_TYPE.canTestForShallowEqualityWith(ERROR_TYPE)); assertFalse(NULL_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); assertFalse(NULL_TYPE.canTestForShallowEqualityWith(functionType)); assertTrue(NULL_TYPE.canTestForShallowEqualityWith(NULL_TYPE)); assertFalse(NULL_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); assertFalse(NULL_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); assertFalse(NULL_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); assertFalse(NULL_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE)); assertFalse(NULL_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); assertFalse(NULL_TYPE. canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); assertFalse(NULL_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); assertFalse(NULL_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); assertFalse(NULL_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); assertFalse(NULL_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); assertFalse(NULL_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); assertTrue(NULL_TYPE.canTestForShallowEqualityWith(ALL_TYPE)); assertFalse(NULL_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); assertTrue(NULL_TYPE.canTestForShallowEqualityWith( createNullableType(STRING_OBJECT_TYPE))); // getLeastSupertype assertTypeEquals(NULL_TYPE, NULL_TYPE.getLeastSupertype(NULL_TYPE)); assertTypeEquals(ALL_TYPE, NULL_TYPE.getLeastSupertype(ALL_TYPE)); assertTypeEquals(createNullableType(STRING_OBJECT_TYPE), NULL_TYPE.getLeastSupertype(STRING_OBJECT_TYPE)); assertTypeEquals(createNullableType(NUMBER_TYPE), NULL_TYPE.getLeastSupertype(NUMBER_TYPE)); assertTypeEquals(createNullableType(functionType), NULL_TYPE.getLeastSupertype(functionType)); assertTypeEquals(createNullableType(OBJECT_TYPE), NULL_TYPE.getLeastSupertype(OBJECT_TYPE)); assertTypeEquals(createNullableType(DATE_TYPE), NULL_TYPE.getLeastSupertype(DATE_TYPE)); assertTypeEquals(createNullableType(REGEXP_TYPE), NULL_TYPE.getLeastSupertype(REGEXP_TYPE)); // matchesXxx assertTrue(NULL_TYPE.matchesInt32Context()); assertTrue(NULL_TYPE.matchesNumberContext()); assertFalse(NULL_TYPE.matchesObjectContext()); assertTrue(NULL_TYPE.matchesStringContext()); assertTrue(NULL_TYPE.matchesUint32Context()); // matchesObjectContext assertFalse(NULL_TYPE.matchesObjectContext()); // toString assertEquals("null", NULL_TYPE.toString()); assertTrue(NULL_TYPE.hasDisplayName()); assertEquals("null", NULL_TYPE.getDisplayName()); Asserts.assertResolvesToSame(NULL_TYPE); // getGreatestSubtype assertTrue( NULL_TYPE.isSubtype( createUnionType(forwardDeclaredNamedType, NULL_TYPE))); assertTypeEquals( createUnionType(forwardDeclaredNamedType, NULL_TYPE), NULL_TYPE.getGreatestSubtype( createUnionType(forwardDeclaredNamedType, NULL_TYPE))); assertFalse(NULL_TYPE.isNominalConstructor()); assertTrue(NULL_TYPE.differsFrom(UNKNOWN_TYPE)); } /** * Tests the behavior of the Date type. */ public void testDateType() throws Exception { // isXxx assertFalse(DATE_TYPE.isArrayType()); assertFalse(DATE_TYPE.isBooleanValueType()); assertTrue(DATE_TYPE.isDateType()); assertFalse(DATE_TYPE.isEnumElementType()); assertFalse(DATE_TYPE.isNamedType()); assertFalse(DATE_TYPE.isNullType()); assertFalse(DATE_TYPE.isNumberValueType()); assertFalse(DATE_TYPE.isFunctionPrototypeType()); assertTrue(DATE_TYPE.getImplicitPrototype().isFunctionPrototypeType()); assertFalse(DATE_TYPE.isRegexpType()); assertFalse(DATE_TYPE.isStringValueType()); assertFalse(DATE_TYPE.isEnumType()); assertFalse(DATE_TYPE.isUnionType()); assertFalse(DATE_TYPE.isStruct()); assertFalse(DATE_TYPE.isDict()); assertFalse(DATE_TYPE.isAllType()); assertFalse(DATE_TYPE.isVoidType()); assertFalse(DATE_TYPE.isConstructor()); assertTrue(DATE_TYPE.isInstanceType()); // autoboxesTo assertNull(DATE_TYPE.autoboxesTo()); // isSubtype assertFalse(DATE_TYPE.isSubtype(NO_TYPE)); assertFalse(DATE_TYPE.isSubtype(NO_OBJECT_TYPE)); assertFalse(DATE_TYPE.isSubtype(ARRAY_TYPE)); assertFalse(DATE_TYPE.isSubtype(BOOLEAN_TYPE)); assertFalse(DATE_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE)); assertTrue(DATE_TYPE.isSubtype(DATE_TYPE)); assertFalse(DATE_TYPE.isSubtype(ERROR_TYPE)); assertFalse(DATE_TYPE.isSubtype(EVAL_ERROR_TYPE)); assertFalse(DATE_TYPE.isSubtype(functionType)); assertFalse(DATE_TYPE.isSubtype(NULL_TYPE)); assertFalse(DATE_TYPE.isSubtype(NUMBER_TYPE)); assertFalse(DATE_TYPE.isSubtype(NUMBER_OBJECT_TYPE)); assertTrue(DATE_TYPE.isSubtype(OBJECT_TYPE)); assertFalse(DATE_TYPE.isSubtype(URI_ERROR_TYPE)); assertFalse(DATE_TYPE.isSubtype(RANGE_ERROR_TYPE)); assertFalse(DATE_TYPE.isSubtype(REFERENCE_ERROR_TYPE)); assertFalse(DATE_TYPE.isSubtype(REGEXP_TYPE)); assertFalse(DATE_TYPE.isSubtype(STRING_TYPE)); assertFalse(DATE_TYPE.isSubtype(STRING_OBJECT_TYPE)); assertFalse(DATE_TYPE.isSubtype(SYNTAX_ERROR_TYPE)); assertFalse(DATE_TYPE.isSubtype(TYPE_ERROR_TYPE)); assertTrue(DATE_TYPE.isSubtype(ALL_TYPE)); assertFalse(DATE_TYPE.isSubtype(VOID_TYPE)); // canBeCalled assertFalse(DATE_TYPE.canBeCalled()); // canTestForEqualityWith assertCanTestForEqualityWith(DATE_TYPE, ALL_TYPE); assertCanTestForEqualityWith(DATE_TYPE, STRING_OBJECT_TYPE); assertCanTestForEqualityWith(DATE_TYPE, NUMBER_TYPE); assertCanTestForEqualityWith(DATE_TYPE, functionType); assertCannotTestForEqualityWith(DATE_TYPE, VOID_TYPE); assertCanTestForEqualityWith(DATE_TYPE, OBJECT_TYPE); assertCanTestForEqualityWith(DATE_TYPE, DATE_TYPE); assertCanTestForEqualityWith(DATE_TYPE, REGEXP_TYPE); assertCanTestForEqualityWith(DATE_TYPE, ARRAY_TYPE); // canTestForShallowEqualityWith assertTrue(DATE_TYPE.canTestForShallowEqualityWith(NO_TYPE)); assertTrue(DATE_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); assertFalse(DATE_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE)); assertFalse(DATE_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE)); assertFalse(DATE_TYPE. canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); assertTrue(DATE_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); assertFalse(DATE_TYPE.canTestForShallowEqualityWith(ERROR_TYPE)); assertFalse(DATE_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); assertFalse(DATE_TYPE.canTestForShallowEqualityWith(functionType)); assertFalse(DATE_TYPE.canTestForShallowEqualityWith(NULL_TYPE)); assertFalse(DATE_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); assertFalse(DATE_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); assertTrue(DATE_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); assertFalse(DATE_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE)); assertFalse(DATE_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); assertFalse(DATE_TYPE. canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); assertFalse(DATE_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); assertFalse(DATE_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); assertFalse(DATE_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); assertFalse(DATE_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); assertFalse(DATE_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); assertTrue(DATE_TYPE.canTestForShallowEqualityWith(ALL_TYPE)); assertFalse(DATE_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); // isNullable assertFalse(DATE_TYPE.isNullable()); assertTrue(createNullableType(DATE_TYPE).isNullable()); // getLeastSupertype assertTypeEquals(ALL_TYPE, DATE_TYPE.getLeastSupertype(ALL_TYPE)); assertTypeEquals(createUnionType(DATE_TYPE, STRING_OBJECT_TYPE), DATE_TYPE.getLeastSupertype(STRING_OBJECT_TYPE)); assertTypeEquals(createUnionType(DATE_TYPE, NUMBER_TYPE), DATE_TYPE.getLeastSupertype(NUMBER_TYPE)); assertTypeEquals(createUnionType(DATE_TYPE, functionType), DATE_TYPE.getLeastSupertype(functionType)); assertTypeEquals(OBJECT_TYPE, DATE_TYPE.getLeastSupertype(OBJECT_TYPE)); assertTypeEquals(DATE_TYPE, DATE_TYPE.getLeastSupertype(DATE_TYPE)); assertTypeEquals(createUnionType(DATE_TYPE, REGEXP_TYPE), DATE_TYPE.getLeastSupertype(REGEXP_TYPE)); // getPropertyType assertEquals(46, DATE_TYPE.getImplicitPrototype().getPropertiesCount()); assertEquals(46, DATE_TYPE.getPropertiesCount()); assertReturnTypeEquals(DATE_TYPE, DATE_TYPE.getPropertyType("constructor")); assertReturnTypeEquals(STRING_TYPE, DATE_TYPE.getPropertyType("toString")); assertReturnTypeEquals(STRING_TYPE, DATE_TYPE.getPropertyType("toDateString")); assertReturnTypeEquals(STRING_TYPE, DATE_TYPE.getPropertyType("toTimeString")); assertReturnTypeEquals(STRING_TYPE, DATE_TYPE.getPropertyType("toLocaleString")); assertReturnTypeEquals(STRING_TYPE, DATE_TYPE.getPropertyType("toLocaleDateString")); assertReturnTypeEquals(STRING_TYPE, DATE_TYPE.getPropertyType("toLocaleTimeString")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("valueOf")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getTime")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getFullYear")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getUTCFullYear")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getMonth")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getUTCMonth")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getDate")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getUTCDate")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getDay")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getUTCDay")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getHours")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getUTCHours")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getMinutes")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getUTCMinutes")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getSeconds")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getUTCSeconds")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getMilliseconds")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getUTCMilliseconds")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("getTimezoneOffset")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("setTime")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("setMilliseconds")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("setUTCMilliseconds")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("setSeconds")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("setUTCSeconds")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("setUTCSeconds")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("setMinutes")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("setUTCMinutes")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("setHours")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("setUTCHours")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("setDate")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("setUTCDate")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("setMonth")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("setUTCMonth")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("setFullYear")); assertReturnTypeEquals(NUMBER_TYPE, DATE_TYPE.getPropertyType("setUTCFullYear")); assertReturnTypeEquals(STRING_TYPE, DATE_TYPE.getPropertyType("toUTCString")); assertReturnTypeEquals(STRING_TYPE, DATE_TYPE.getPropertyType("toGMTString")); // matchesXxx assertTrue(DATE_TYPE.matchesInt32Context()); assertTrue(DATE_TYPE.matchesNumberContext()); assertTrue(DATE_TYPE.matchesObjectContext()); assertTrue(DATE_TYPE.matchesStringContext()); assertTrue(DATE_TYPE.matchesUint32Context()); // toString assertEquals("Date", DATE_TYPE.toString()); assertTrue(DATE_TYPE.hasDisplayName()); assertEquals("Date", DATE_TYPE.getDisplayName()); assertTrue(DATE_TYPE.isNativeObjectType()); Asserts.assertResolvesToSame(DATE_TYPE); assertFalse(DATE_TYPE.isNominalConstructor()); assertTrue(DATE_TYPE.getConstructor().isNominalConstructor()); } /** * Tests the behavior of the RegExp type. */ public void testRegExpType() throws Exception { // isXxx assertFalse(REGEXP_TYPE.isNoType()); assertFalse(REGEXP_TYPE.isNoObjectType()); assertFalse(REGEXP_TYPE.isArrayType()); assertFalse(REGEXP_TYPE.isBooleanValueType()); assertFalse(REGEXP_TYPE.isDateType()); assertFalse(REGEXP_TYPE.isEnumElementType()); assertFalse(REGEXP_TYPE.isNamedType()); assertFalse(REGEXP_TYPE.isNullType()); assertFalse(REGEXP_TYPE.isNumberValueType()); assertFalse(REGEXP_TYPE.isFunctionPrototypeType()); assertTrue(REGEXP_TYPE.getImplicitPrototype().isFunctionPrototypeType()); assertTrue(REGEXP_TYPE.isRegexpType()); assertFalse(REGEXP_TYPE.isStringValueType()); assertFalse(REGEXP_TYPE.isEnumType()); assertFalse(REGEXP_TYPE.isUnionType()); assertFalse(REGEXP_TYPE.isStruct()); assertFalse(REGEXP_TYPE.isDict()); assertFalse(REGEXP_TYPE.isAllType()); assertFalse(REGEXP_TYPE.isVoidType()); // autoboxesTo assertNull(REGEXP_TYPE.autoboxesTo()); // isSubtype assertFalse(REGEXP_TYPE.isSubtype(NO_TYPE)); assertFalse(REGEXP_TYPE.isSubtype(NO_OBJECT_TYPE)); assertFalse(REGEXP_TYPE.isSubtype(ARRAY_TYPE)); assertFalse(REGEXP_TYPE.isSubtype(BOOLEAN_TYPE)); assertFalse(REGEXP_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE)); assertFalse(REGEXP_TYPE.isSubtype(DATE_TYPE)); assertFalse(REGEXP_TYPE.isSubtype(ERROR_TYPE)); assertFalse(REGEXP_TYPE.isSubtype(EVAL_ERROR_TYPE)); assertFalse(REGEXP_TYPE.isSubtype(functionType)); assertFalse(REGEXP_TYPE.isSubtype(NULL_TYPE)); assertFalse(REGEXP_TYPE.isSubtype(NUMBER_TYPE)); assertFalse(REGEXP_TYPE.isSubtype(NUMBER_OBJECT_TYPE)); assertTrue(REGEXP_TYPE.isSubtype(OBJECT_TYPE)); assertFalse(REGEXP_TYPE.isSubtype(URI_ERROR_TYPE)); assertFalse(REGEXP_TYPE.isSubtype(RANGE_ERROR_TYPE)); assertFalse(REGEXP_TYPE.isSubtype(REFERENCE_ERROR_TYPE)); assertTrue(REGEXP_TYPE.isSubtype(REGEXP_TYPE)); assertFalse(REGEXP_TYPE.isSubtype(STRING_TYPE)); assertFalse(REGEXP_TYPE.isSubtype(STRING_OBJECT_TYPE)); assertFalse(REGEXP_TYPE.isSubtype(SYNTAX_ERROR_TYPE)); assertFalse(REGEXP_TYPE.isSubtype(TYPE_ERROR_TYPE)); assertTrue(REGEXP_TYPE.isSubtype(ALL_TYPE)); assertFalse(REGEXP_TYPE.isSubtype(VOID_TYPE)); // canBeCalled assertTrue(REGEXP_TYPE.canBeCalled()); // canTestForEqualityWith assertCanTestForEqualityWith(REGEXP_TYPE, ALL_TYPE); assertCanTestForEqualityWith(REGEXP_TYPE, STRING_OBJECT_TYPE); assertCanTestForEqualityWith(REGEXP_TYPE, NUMBER_TYPE); assertCanTestForEqualityWith(REGEXP_TYPE, functionType); assertCannotTestForEqualityWith(REGEXP_TYPE, VOID_TYPE); assertCanTestForEqualityWith(REGEXP_TYPE, OBJECT_TYPE); assertCanTestForEqualityWith(REGEXP_TYPE, DATE_TYPE); assertCanTestForEqualityWith(REGEXP_TYPE, REGEXP_TYPE); assertCanTestForEqualityWith(REGEXP_TYPE, ARRAY_TYPE); // canTestForShallowEqualityWith assertTrue(REGEXP_TYPE.canTestForShallowEqualityWith(NO_TYPE)); assertTrue(REGEXP_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE)); assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE)); assertFalse(REGEXP_TYPE. canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(ERROR_TYPE)); assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(functionType)); assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(NULL_TYPE)); assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); assertTrue(REGEXP_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE)); assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); assertFalse(REGEXP_TYPE. canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); assertTrue(REGEXP_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); assertTrue(REGEXP_TYPE.canTestForShallowEqualityWith(ALL_TYPE)); assertFalse(REGEXP_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); // isNullable assertFalse(REGEXP_TYPE.isNullable()); assertTrue(createNullableType(REGEXP_TYPE).isNullable()); // getLeastSupertype assertTypeEquals(ALL_TYPE, REGEXP_TYPE.getLeastSupertype(ALL_TYPE)); assertTypeEquals(createUnionType(REGEXP_TYPE, STRING_OBJECT_TYPE), REGEXP_TYPE.getLeastSupertype(STRING_OBJECT_TYPE)); assertTypeEquals(createUnionType(REGEXP_TYPE, NUMBER_TYPE), REGEXP_TYPE.getLeastSupertype(NUMBER_TYPE)); assertTypeEquals(createUnionType(REGEXP_TYPE, functionType), REGEXP_TYPE.getLeastSupertype(functionType)); assertTypeEquals(OBJECT_TYPE, REGEXP_TYPE.getLeastSupertype(OBJECT_TYPE)); assertTypeEquals(createUnionType(DATE_TYPE, REGEXP_TYPE), REGEXP_TYPE.getLeastSupertype(DATE_TYPE)); assertTypeEquals(REGEXP_TYPE, REGEXP_TYPE.getLeastSupertype(REGEXP_TYPE)); // getPropertyType assertEquals(9, REGEXP_TYPE.getImplicitPrototype().getPropertiesCount()); assertEquals(14, REGEXP_TYPE.getPropertiesCount()); assertReturnTypeEquals(REGEXP_TYPE, REGEXP_TYPE.getPropertyType("constructor")); assertReturnTypeEquals(createNullableType(ARRAY_TYPE), REGEXP_TYPE.getPropertyType("exec")); assertReturnTypeEquals(BOOLEAN_TYPE, REGEXP_TYPE.getPropertyType("test")); assertReturnTypeEquals(STRING_TYPE, REGEXP_TYPE.getPropertyType("toString")); assertTypeEquals(STRING_TYPE, REGEXP_TYPE.getPropertyType("source")); assertTypeEquals(BOOLEAN_TYPE, REGEXP_TYPE.getPropertyType("global")); assertTypeEquals(BOOLEAN_TYPE, REGEXP_TYPE.getPropertyType("ignoreCase")); assertTypeEquals(BOOLEAN_TYPE, REGEXP_TYPE.getPropertyType("multiline")); assertTypeEquals(NUMBER_TYPE, REGEXP_TYPE.getPropertyType("lastIndex")); // matchesXxx assertFalse(REGEXP_TYPE.matchesInt32Context()); assertFalse(REGEXP_TYPE.matchesNumberContext()); assertTrue(REGEXP_TYPE.matchesObjectContext()); assertTrue(REGEXP_TYPE.matchesStringContext()); assertFalse(REGEXP_TYPE.matchesUint32Context()); // toString assertEquals("RegExp", REGEXP_TYPE.toString()); assertTrue(REGEXP_TYPE.hasDisplayName()); assertEquals("RegExp", REGEXP_TYPE.getDisplayName()); assertTrue(REGEXP_TYPE.isNativeObjectType()); Asserts.assertResolvesToSame(REGEXP_TYPE); assertFalse(REGEXP_TYPE.isNominalConstructor()); assertTrue(REGEXP_TYPE.getConstructor().isNominalConstructor()); } /** * Tests the behavior of the string object type. */ public void testStringObjectType() throws Exception { // isXxx assertFalse(STRING_OBJECT_TYPE.isArrayType()); assertFalse(STRING_OBJECT_TYPE.isBooleanObjectType()); assertFalse(STRING_OBJECT_TYPE.isBooleanValueType()); assertFalse(STRING_OBJECT_TYPE.isDateType()); assertFalse(STRING_OBJECT_TYPE.isEnumElementType()); assertFalse(STRING_OBJECT_TYPE.isNamedType()); assertFalse(STRING_OBJECT_TYPE.isNullType()); assertFalse(STRING_OBJECT_TYPE.isNumber()); assertFalse(STRING_OBJECT_TYPE.isNumberObjectType()); assertFalse(STRING_OBJECT_TYPE.isNumberValueType()); assertFalse(STRING_OBJECT_TYPE.isFunctionPrototypeType()); assertTrue( STRING_OBJECT_TYPE.getImplicitPrototype().isFunctionPrototypeType()); assertFalse(STRING_OBJECT_TYPE.isRegexpType()); assertTrue(STRING_OBJECT_TYPE.isString()); assertTrue(STRING_OBJECT_TYPE.isStringObjectType()); assertFalse(STRING_OBJECT_TYPE.isStringValueType()); assertFalse(STRING_OBJECT_TYPE.isEnumType()); assertFalse(STRING_OBJECT_TYPE.isUnionType()); assertFalse(STRING_OBJECT_TYPE.isStruct()); assertFalse(STRING_OBJECT_TYPE.isDict()); assertFalse(STRING_OBJECT_TYPE.isAllType()); assertFalse(STRING_OBJECT_TYPE.isVoidType()); assertFalse(STRING_OBJECT_TYPE.isConstructor()); assertTrue(STRING_OBJECT_TYPE.isInstanceType()); // autoboxesTo assertTypeEquals(STRING_OBJECT_TYPE, STRING_TYPE.autoboxesTo()); // unboxesTo assertTypeEquals(STRING_TYPE, STRING_OBJECT_TYPE.unboxesTo()); // isSubtype assertTrue(STRING_OBJECT_TYPE.isSubtype(ALL_TYPE)); assertTrue(STRING_OBJECT_TYPE.isSubtype(STRING_OBJECT_TYPE)); assertFalse(STRING_OBJECT_TYPE.isSubtype(STRING_TYPE)); assertTrue(STRING_OBJECT_TYPE.isSubtype(OBJECT_TYPE)); assertFalse(STRING_OBJECT_TYPE.isSubtype(NUMBER_TYPE)); assertFalse(STRING_OBJECT_TYPE.isSubtype(DATE_TYPE)); assertFalse(STRING_OBJECT_TYPE.isSubtype(REGEXP_TYPE)); assertFalse(STRING_OBJECT_TYPE.isSubtype(ARRAY_TYPE)); assertFalse(STRING_OBJECT_TYPE.isSubtype(STRING_TYPE)); // canBeCalled assertFalse(STRING_OBJECT_TYPE.canBeCalled()); // canTestForEqualityWith assertCanTestForEqualityWith(STRING_OBJECT_TYPE, ALL_TYPE); assertCanTestForEqualityWith(STRING_OBJECT_TYPE, STRING_OBJECT_TYPE); assertCanTestForEqualityWith(STRING_OBJECT_TYPE, STRING_TYPE); assertCanTestForEqualityWith(STRING_OBJECT_TYPE, functionType); assertCanTestForEqualityWith(STRING_OBJECT_TYPE, OBJECT_TYPE); assertCanTestForEqualityWith(STRING_OBJECT_TYPE, NUMBER_TYPE); assertCanTestForEqualityWith(STRING_OBJECT_TYPE, BOOLEAN_TYPE); assertCanTestForEqualityWith(STRING_OBJECT_TYPE, BOOLEAN_OBJECT_TYPE); assertCanTestForEqualityWith(STRING_OBJECT_TYPE, DATE_TYPE); assertCanTestForEqualityWith(STRING_OBJECT_TYPE, REGEXP_TYPE); assertCanTestForEqualityWith(STRING_OBJECT_TYPE, ARRAY_TYPE); assertCanTestForEqualityWith(STRING_OBJECT_TYPE, UNKNOWN_TYPE); // canTestForShallowEqualityWith assertTrue(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(NO_TYPE)); assertTrue(STRING_OBJECT_TYPE. canTestForShallowEqualityWith(NO_OBJECT_TYPE)); assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE)); assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE)); assertFalse(STRING_OBJECT_TYPE. canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(ERROR_TYPE)); assertFalse(STRING_OBJECT_TYPE. canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(functionType)); assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(NULL_TYPE)); assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); assertFalse(STRING_OBJECT_TYPE. canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); assertTrue(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); assertFalse(STRING_OBJECT_TYPE. canTestForShallowEqualityWith(URI_ERROR_TYPE)); assertFalse(STRING_OBJECT_TYPE. canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); assertFalse(STRING_OBJECT_TYPE. canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); assertTrue(STRING_OBJECT_TYPE. canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); assertFalse(STRING_OBJECT_TYPE. canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); assertFalse(STRING_OBJECT_TYPE. canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); assertTrue(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(ALL_TYPE)); assertFalse(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); assertTrue(STRING_OBJECT_TYPE.canTestForShallowEqualityWith(UNKNOWN_TYPE)); // properties (ECMA-262 page 98 - 106) assertEquals(23, STRING_OBJECT_TYPE.getImplicitPrototype(). getPropertiesCount()); assertEquals(24, STRING_OBJECT_TYPE.getPropertiesCount()); assertReturnTypeEquals(STRING_TYPE, STRING_OBJECT_TYPE.getPropertyType("toString")); assertReturnTypeEquals(STRING_TYPE, STRING_OBJECT_TYPE.getPropertyType("valueOf")); assertReturnTypeEquals(STRING_TYPE, STRING_OBJECT_TYPE.getPropertyType("charAt")); assertReturnTypeEquals(NUMBER_TYPE, STRING_OBJECT_TYPE.getPropertyType("charCodeAt")); assertReturnTypeEquals(STRING_TYPE, STRING_OBJECT_TYPE.getPropertyType("concat")); assertReturnTypeEquals(NUMBER_TYPE, STRING_OBJECT_TYPE.getPropertyType("indexOf")); assertReturnTypeEquals(NUMBER_TYPE, STRING_OBJECT_TYPE.getPropertyType("lastIndexOf")); assertReturnTypeEquals(NUMBER_TYPE, STRING_OBJECT_TYPE.getPropertyType("localeCompare")); assertReturnTypeEquals(createNullableType(ARRAY_TYPE), STRING_OBJECT_TYPE.getPropertyType("match")); assertReturnTypeEquals(STRING_TYPE, STRING_OBJECT_TYPE.getPropertyType("replace")); assertReturnTypeEquals(NUMBER_TYPE, STRING_OBJECT_TYPE.getPropertyType("search")); assertReturnTypeEquals(STRING_TYPE, STRING_OBJECT_TYPE.getPropertyType("slice")); assertReturnTypeEquals(ARRAY_TYPE, STRING_OBJECT_TYPE.getPropertyType("split")); assertReturnTypeEquals(STRING_TYPE, STRING_OBJECT_TYPE.getPropertyType("substring")); assertReturnTypeEquals(STRING_TYPE, STRING_OBJECT_TYPE.getPropertyType("toLowerCase")); assertReturnTypeEquals(STRING_TYPE, STRING_OBJECT_TYPE.getPropertyType("toLocaleLowerCase")); assertReturnTypeEquals(STRING_TYPE, STRING_OBJECT_TYPE.getPropertyType("toUpperCase")); assertReturnTypeEquals(STRING_TYPE, STRING_OBJECT_TYPE.getPropertyType("toLocaleUpperCase")); assertTypeEquals(NUMBER_TYPE, STRING_OBJECT_TYPE.getPropertyType("length")); // matchesXxx assertTrue(STRING_OBJECT_TYPE.matchesInt32Context()); assertTrue(STRING_OBJECT_TYPE.matchesNumberContext()); assertTrue(STRING_OBJECT_TYPE.matchesObjectContext()); assertTrue(STRING_OBJECT_TYPE.matchesStringContext()); assertTrue(STRING_OBJECT_TYPE.matchesUint32Context()); // isNullable assertFalse(STRING_OBJECT_TYPE.isNullable()); assertTrue(createNullableType(STRING_OBJECT_TYPE).isNullable()); assertTrue(STRING_OBJECT_TYPE.isNativeObjectType()); Asserts.assertResolvesToSame(STRING_OBJECT_TYPE); assertTrue(STRING_OBJECT_TYPE.hasDisplayName()); assertEquals("String", STRING_OBJECT_TYPE.getDisplayName()); assertFalse(STRING_OBJECT_TYPE.isNominalConstructor()); assertTrue(STRING_OBJECT_TYPE.getConstructor().isNominalConstructor()); } /** * Tests the behavior of the string value type. */ public void testStringValueType() throws Exception { // isXxx assertFalse(STRING_TYPE.isArrayType()); assertFalse(STRING_TYPE.isBooleanObjectType()); assertFalse(STRING_TYPE.isBooleanValueType()); assertFalse(STRING_TYPE.isDateType()); assertFalse(STRING_TYPE.isEnumElementType()); assertFalse(STRING_TYPE.isNamedType()); assertFalse(STRING_TYPE.isNullType()); assertFalse(STRING_TYPE.isNumber()); assertFalse(STRING_TYPE.isNumberObjectType()); assertFalse(STRING_TYPE.isNumberValueType()); assertFalse(STRING_TYPE.isFunctionPrototypeType()); assertFalse(STRING_TYPE.isRegexpType()); assertTrue(STRING_TYPE.isString()); assertFalse(STRING_TYPE.isStringObjectType()); assertTrue(STRING_TYPE.isStringValueType()); assertFalse(STRING_TYPE.isEnumType()); assertFalse(STRING_TYPE.isUnionType()); assertFalse(STRING_TYPE.isStruct()); assertFalse(STRING_TYPE.isDict()); assertFalse(STRING_TYPE.isAllType()); assertFalse(STRING_TYPE.isVoidType()); assertFalse(STRING_TYPE.isConstructor()); assertFalse(STRING_TYPE.isInstanceType()); // autoboxesTo assertTypeEquals(STRING_OBJECT_TYPE, STRING_TYPE.autoboxesTo()); // unboxesTo assertTypeEquals(STRING_TYPE, STRING_OBJECT_TYPE.unboxesTo()); // isSubtype assertTrue(STRING_TYPE.isSubtype(ALL_TYPE)); assertFalse(STRING_TYPE.isSubtype(STRING_OBJECT_TYPE)); assertFalse(STRING_TYPE.isSubtype(NUMBER_TYPE)); assertFalse(STRING_TYPE.isSubtype(OBJECT_TYPE)); assertFalse(STRING_TYPE.isSubtype(NUMBER_TYPE)); assertFalse(STRING_TYPE.isSubtype(DATE_TYPE)); assertFalse(STRING_TYPE.isSubtype(REGEXP_TYPE)); assertFalse(STRING_TYPE.isSubtype(ARRAY_TYPE)); assertTrue(STRING_TYPE.isSubtype(STRING_TYPE)); assertTrue(STRING_TYPE.isSubtype(UNKNOWN_TYPE)); // canBeCalled assertFalse(STRING_TYPE.canBeCalled()); // canTestForEqualityWith assertCanTestForEqualityWith(STRING_TYPE, ALL_TYPE); assertCanTestForEqualityWith(STRING_TYPE, STRING_OBJECT_TYPE); assertCannotTestForEqualityWith(STRING_TYPE, functionType); assertCanTestForEqualityWith(STRING_TYPE, OBJECT_TYPE); assertCanTestForEqualityWith(STRING_TYPE, NUMBER_TYPE); assertCanTestForEqualityWith(STRING_TYPE, BOOLEAN_TYPE); assertCanTestForEqualityWith(STRING_TYPE, BOOLEAN_OBJECT_TYPE); assertCanTestForEqualityWith(STRING_TYPE, DATE_TYPE); assertCanTestForEqualityWith(STRING_TYPE, REGEXP_TYPE); assertCanTestForEqualityWith(STRING_TYPE, ARRAY_TYPE); assertCanTestForEqualityWith(STRING_TYPE, UNKNOWN_TYPE); // canTestForShallowEqualityWith assertTrue(STRING_TYPE.canTestForShallowEqualityWith(NO_TYPE)); assertFalse(STRING_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); assertFalse(STRING_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE)); assertFalse(STRING_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE)); assertFalse(STRING_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); assertFalse(STRING_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); assertFalse(STRING_TYPE.canTestForShallowEqualityWith(ERROR_TYPE)); assertFalse(STRING_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); assertFalse(STRING_TYPE.canTestForShallowEqualityWith(functionType)); assertFalse(STRING_TYPE.canTestForShallowEqualityWith(NULL_TYPE)); assertFalse(STRING_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); assertFalse(STRING_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); assertFalse(STRING_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); assertFalse(STRING_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE)); assertFalse(STRING_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); assertFalse(STRING_TYPE. canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); assertFalse(STRING_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); assertTrue(STRING_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); assertFalse(STRING_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); assertFalse(STRING_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); assertFalse(STRING_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); assertTrue(STRING_TYPE.canTestForShallowEqualityWith(ALL_TYPE)); assertFalse(STRING_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); assertTrue(STRING_TYPE.canTestForShallowEqualityWith(UNKNOWN_TYPE)); // matchesXxx assertTrue(STRING_TYPE.matchesInt32Context()); assertTrue(STRING_TYPE.matchesNumberContext()); assertTrue(STRING_TYPE.matchesObjectContext()); assertTrue(STRING_TYPE.matchesStringContext()); assertTrue(STRING_TYPE.matchesUint32Context()); // isNullable assertFalse(STRING_TYPE.isNullable()); assertTrue(createNullableType(STRING_TYPE).isNullable()); // toString assertEquals("string", STRING_TYPE.toString()); assertTrue(STRING_TYPE.hasDisplayName()); assertEquals("string", STRING_TYPE.getDisplayName()); // findPropertyType assertTypeEquals(NUMBER_TYPE, STRING_TYPE.findPropertyType("length")); assertEquals(null, STRING_TYPE.findPropertyType("unknownProperty")); Asserts.assertResolvesToSame(STRING_TYPE); assertFalse(STRING_TYPE.isNominalConstructor()); } private void assertPropertyTypeDeclared(ObjectType ownerType, String prop) { assertTrue(ownerType.isPropertyTypeDeclared(prop)); assertFalse(ownerType.isPropertyTypeInferred(prop)); } private void assertPropertyTypeInferred(ObjectType ownerType, String prop) { assertFalse(ownerType.isPropertyTypeDeclared(prop)); assertTrue(ownerType.isPropertyTypeInferred(prop)); } private void assertPropertyTypeUnknown(ObjectType ownerType, String prop) { assertFalse(ownerType.isPropertyTypeDeclared(prop)); assertFalse(ownerType.isPropertyTypeInferred(prop)); assertTrue(ownerType.getPropertyType(prop).isUnknownType()); } private void assertReturnTypeEquals(JSType expectedReturnType, JSType function) { assertTrue(function instanceof FunctionType); assertTypeEquals(expectedReturnType, ((FunctionType) function).getReturnType()); } /** * Tests the behavior of record types. */ public void testRecordType() throws Exception { // isXxx assertTrue(recordType.isObject()); assertFalse(recordType.isFunctionPrototypeType()); // isSubtype assertTrue(recordType.isSubtype(ALL_TYPE)); assertFalse(recordType.isSubtype(STRING_OBJECT_TYPE)); assertFalse(recordType.isSubtype(NUMBER_TYPE)); assertFalse(recordType.isSubtype(DATE_TYPE)); assertFalse(recordType.isSubtype(REGEXP_TYPE)); assertTrue(recordType.isSubtype(UNKNOWN_TYPE)); assertTrue(recordType.isSubtype(OBJECT_TYPE)); assertFalse(recordType.isSubtype(U2U_CONSTRUCTOR_TYPE)); // autoboxesTo assertNull(recordType.autoboxesTo()); // canBeCalled assertFalse(recordType.canBeCalled()); // canTestForEqualityWith assertCanTestForEqualityWith(recordType, ALL_TYPE); assertCanTestForEqualityWith(recordType, STRING_OBJECT_TYPE); assertCanTestForEqualityWith(recordType, recordType); assertCanTestForEqualityWith(recordType, functionType); assertCanTestForEqualityWith(recordType, OBJECT_TYPE); assertCanTestForEqualityWith(recordType, NUMBER_TYPE); assertCanTestForEqualityWith(recordType, DATE_TYPE); assertCanTestForEqualityWith(recordType, REGEXP_TYPE); // canTestForShallowEqualityWith assertTrue(recordType.canTestForShallowEqualityWith(NO_TYPE)); assertTrue(recordType.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); assertFalse(recordType.canTestForShallowEqualityWith(ARRAY_TYPE)); assertFalse(recordType.canTestForShallowEqualityWith(BOOLEAN_TYPE)); assertFalse(recordType. canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); assertFalse(recordType.canTestForShallowEqualityWith(DATE_TYPE)); assertFalse(recordType.canTestForShallowEqualityWith(ERROR_TYPE)); assertFalse(recordType.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); assertTrue(recordType.canTestForShallowEqualityWith(recordType)); assertFalse(recordType.canTestForShallowEqualityWith(NULL_TYPE)); assertFalse(recordType.canTestForShallowEqualityWith(NUMBER_TYPE)); assertFalse(recordType.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); assertTrue(recordType.canTestForShallowEqualityWith(OBJECT_TYPE)); assertFalse(recordType.canTestForShallowEqualityWith(URI_ERROR_TYPE)); assertFalse(recordType.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); assertFalse(recordType. canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); assertFalse(recordType.canTestForShallowEqualityWith(REGEXP_TYPE)); assertFalse(recordType.canTestForShallowEqualityWith(STRING_TYPE)); assertFalse(recordType.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); assertFalse(recordType.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); assertFalse(recordType.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); assertTrue(recordType.canTestForShallowEqualityWith(ALL_TYPE)); assertFalse(recordType.canTestForShallowEqualityWith(VOID_TYPE)); assertTrue(recordType.canTestForShallowEqualityWith(UNKNOWN_TYPE)); // matchesXxx assertFalse(recordType.matchesInt32Context()); assertFalse(recordType.matchesNumberContext()); assertTrue(recordType.matchesObjectContext()); assertFalse(recordType.matchesStringContext()); assertFalse(recordType.matchesUint32Context()); Asserts.assertResolvesToSame(recordType); } /** * Tests the behavior of the instance of Function. */ public void testFunctionInstanceType() throws Exception { FunctionType functionInst = FUNCTION_INSTANCE_TYPE; // isXxx assertTrue(functionInst.isObject()); assertFalse(functionInst.isFunctionPrototypeType()); assertTrue(functionInst.getImplicitPrototype() .isFunctionPrototypeType()); // isSubtype assertTrue(functionInst.isSubtype(ALL_TYPE)); assertFalse(functionInst.isSubtype(STRING_OBJECT_TYPE)); assertFalse(functionInst.isSubtype(NUMBER_TYPE)); assertFalse(functionInst.isSubtype(DATE_TYPE)); assertFalse(functionInst.isSubtype(REGEXP_TYPE)); assertTrue(functionInst.isSubtype(UNKNOWN_TYPE)); assertTrue(functionInst.isSubtype(U2U_CONSTRUCTOR_TYPE)); // autoboxesTo assertNull(functionInst.autoboxesTo()); // canBeCalled assertTrue(functionInst.canBeCalled()); // canTestForEqualityWith assertCanTestForEqualityWith(functionInst, ALL_TYPE); assertCanTestForEqualityWith(functionInst, STRING_OBJECT_TYPE); assertCanTestForEqualityWith(functionInst, functionInst); assertCanTestForEqualityWith(functionInst, OBJECT_TYPE); assertCannotTestForEqualityWith(functionInst, NUMBER_TYPE); assertCanTestForEqualityWith(functionInst, DATE_TYPE); assertCanTestForEqualityWith(functionInst, REGEXP_TYPE); // canTestForShallowEqualityWith assertTrue(functionInst.canTestForShallowEqualityWith(NO_TYPE)); assertTrue(functionInst.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); assertFalse(functionInst.canTestForShallowEqualityWith(ARRAY_TYPE)); assertFalse(functionInst.canTestForShallowEqualityWith(BOOLEAN_TYPE)); assertFalse(functionInst. canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); assertFalse(functionInst.canTestForShallowEqualityWith(DATE_TYPE)); assertFalse(functionInst.canTestForShallowEqualityWith(ERROR_TYPE)); assertFalse(functionInst.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); assertTrue(functionInst.canTestForShallowEqualityWith(functionInst)); assertFalse(functionInst.canTestForShallowEqualityWith(NULL_TYPE)); assertFalse(functionInst.canTestForShallowEqualityWith(NUMBER_TYPE)); assertFalse(functionInst.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); assertTrue(functionInst.canTestForShallowEqualityWith(OBJECT_TYPE)); assertFalse(functionInst.canTestForShallowEqualityWith(URI_ERROR_TYPE)); assertFalse(functionInst.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); assertFalse(functionInst. canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); assertFalse(functionInst.canTestForShallowEqualityWith(REGEXP_TYPE)); assertFalse(functionInst.canTestForShallowEqualityWith(STRING_TYPE)); assertFalse(functionInst.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); assertFalse(functionInst.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); assertFalse(functionInst.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); assertTrue(functionInst.canTestForShallowEqualityWith(ALL_TYPE)); assertFalse(functionInst.canTestForShallowEqualityWith(VOID_TYPE)); assertTrue(functionInst.canTestForShallowEqualityWith(UNKNOWN_TYPE)); // matchesXxx assertFalse(functionInst.matchesInt32Context()); assertFalse(functionInst.matchesNumberContext()); assertTrue(functionInst.matchesObjectContext()); assertFalse(functionInst.matchesStringContext()); assertFalse(functionInst.matchesUint32Context()); // hasProperty assertTrue(functionInst.hasProperty("prototype")); assertPropertyTypeInferred(functionInst, "prototype"); // misc assertTypeEquals(FUNCTION_FUNCTION_TYPE, functionInst.getConstructor()); assertTypeEquals(FUNCTION_PROTOTYPE, functionInst.getImplicitPrototype()); assertTypeEquals(functionInst, FUNCTION_FUNCTION_TYPE.getInstanceType()); Asserts.assertResolvesToSame(functionInst); } /** * Tests the behavior of functional types. */ public void testFunctionType() throws Exception { // isXxx assertTrue(functionType.isObject()); assertFalse(functionType.isFunctionPrototypeType()); assertTrue(functionType.getImplicitPrototype().getImplicitPrototype() .isFunctionPrototypeType()); // isSubtype assertTrue(functionType.isSubtype(ALL_TYPE)); assertFalse(functionType.isSubtype(STRING_OBJECT_TYPE)); assertFalse(functionType.isSubtype(NUMBER_TYPE)); assertFalse(functionType.isSubtype(DATE_TYPE)); assertFalse(functionType.isSubtype(REGEXP_TYPE)); assertTrue(functionType.isSubtype(UNKNOWN_TYPE)); assertTrue(functionType.isSubtype(U2U_CONSTRUCTOR_TYPE)); // autoboxesTo assertNull(functionType.autoboxesTo()); // canBeCalled assertTrue(functionType.canBeCalled()); // canTestForEqualityWith assertCanTestForEqualityWith(functionType, ALL_TYPE); assertCanTestForEqualityWith(functionType, STRING_OBJECT_TYPE); assertCanTestForEqualityWith(functionType, functionType); assertCanTestForEqualityWith(functionType, OBJECT_TYPE); assertCannotTestForEqualityWith(functionType, NUMBER_TYPE); assertCanTestForEqualityWith(functionType, DATE_TYPE); assertCanTestForEqualityWith(functionType, REGEXP_TYPE); // canTestForShallowEqualityWith assertTrue(functionType.canTestForShallowEqualityWith(NO_TYPE)); assertTrue(functionType.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); assertFalse(functionType.canTestForShallowEqualityWith(ARRAY_TYPE)); assertFalse(functionType.canTestForShallowEqualityWith(BOOLEAN_TYPE)); assertFalse(functionType. canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); assertFalse(functionType.canTestForShallowEqualityWith(DATE_TYPE)); assertFalse(functionType.canTestForShallowEqualityWith(ERROR_TYPE)); assertFalse(functionType.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); assertTrue(functionType.canTestForShallowEqualityWith(functionType)); assertFalse(functionType.canTestForShallowEqualityWith(NULL_TYPE)); assertFalse(functionType.canTestForShallowEqualityWith(NUMBER_TYPE)); assertFalse(functionType.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); assertTrue(functionType.canTestForShallowEqualityWith(OBJECT_TYPE)); assertFalse(functionType.canTestForShallowEqualityWith(URI_ERROR_TYPE)); assertFalse(functionType.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); assertFalse(functionType. canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); assertFalse(functionType.canTestForShallowEqualityWith(REGEXP_TYPE)); assertFalse(functionType.canTestForShallowEqualityWith(STRING_TYPE)); assertFalse(functionType.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); assertFalse(functionType.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); assertFalse(functionType.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); assertTrue(functionType.canTestForShallowEqualityWith(ALL_TYPE)); assertFalse(functionType.canTestForShallowEqualityWith(VOID_TYPE)); assertTrue(functionType.canTestForShallowEqualityWith(UNKNOWN_TYPE)); // matchesXxx assertFalse(functionType.matchesInt32Context()); assertFalse(functionType.matchesNumberContext()); assertTrue(functionType.matchesObjectContext()); assertFalse(functionType.matchesStringContext()); assertFalse(functionType.matchesUint32Context()); // hasProperty assertTrue(functionType.hasProperty("prototype")); assertPropertyTypeInferred(functionType, "prototype"); Asserts.assertResolvesToSame(functionType); assertEquals("aFunctionName", new FunctionBuilder(registry). withName("aFunctionName").build().getDisplayName()); } /** * Tests the subtyping relation of record types. */ public void testRecordTypeSubtyping() { RecordTypeBuilder builder = new RecordTypeBuilder(registry); builder.addProperty("a", NUMBER_TYPE, null); builder.addProperty("b", STRING_TYPE, null); builder.addProperty("c", STRING_TYPE, null); JSType subRecordType = builder.build(); assertTrue(subRecordType.isSubtype(recordType)); assertFalse(recordType.isSubtype(subRecordType)); builder = new RecordTypeBuilder(registry); builder.addProperty("a", OBJECT_TYPE, null); builder.addProperty("b", STRING_TYPE, null); JSType differentRecordType = builder.build(); assertFalse(differentRecordType.isSubtype(recordType)); assertFalse(recordType.isSubtype(differentRecordType)); } /** * Tests the subtyping relation of record types when an object has * an inferred property.. */ public void testRecordTypeSubtypingWithInferredProperties() { RecordTypeBuilder builder = new RecordTypeBuilder(registry); builder.addProperty("a", googSubBarInst, null); JSType record = builder.build(); ObjectType subtypeProp = registry.createAnonymousObjectType(null); subtypeProp.defineInferredProperty("a", googSubSubBarInst, null); assertTrue(subtypeProp.isSubtype(record)); assertFalse(record.isSubtype(subtypeProp)); ObjectType supertypeProp = registry.createAnonymousObjectType(null); supertypeProp.defineInferredProperty("a", googBarInst, null); assertFalse(supertypeProp.isSubtype(record)); assertFalse(record.isSubtype(supertypeProp)); ObjectType declaredSubtypeProp = registry.createAnonymousObjectType(null); declaredSubtypeProp.defineDeclaredProperty("a", googSubSubBarInst, null); assertFalse(declaredSubtypeProp.isSubtype(record)); assertFalse(record.isSubtype(declaredSubtypeProp)); } /** * Tests the getLeastSupertype method for record types. */ public void testRecordTypeLeastSuperType1() { RecordTypeBuilder builder = new RecordTypeBuilder(registry); builder.addProperty("a", NUMBER_TYPE, null); builder.addProperty("b", STRING_TYPE, null); builder.addProperty("c", STRING_TYPE, null); JSType subRecordType = builder.build(); JSType leastSupertype = recordType.getLeastSupertype(subRecordType); assertTypeEquals(leastSupertype, recordType); } public void testRecordTypeLeastSuperType2() { RecordTypeBuilder builder = new RecordTypeBuilder(registry); builder.addProperty("e", NUMBER_TYPE, null); builder.addProperty("b", STRING_TYPE, null); builder.addProperty("c", STRING_TYPE, null); JSType otherRecordType = builder.build(); assertTypeEquals( registry.createUnionType(recordType, otherRecordType), recordType.getLeastSupertype(otherRecordType)); } public void testRecordTypeLeastSuperType3() { RecordTypeBuilder builder = new RecordTypeBuilder(registry); builder.addProperty("d", NUMBER_TYPE, null); builder.addProperty("e", STRING_TYPE, null); builder.addProperty("f", STRING_TYPE, null); JSType otherRecordType = builder.build(); assertTypeEquals( registry.createUnionType(recordType, otherRecordType), recordType.getLeastSupertype(otherRecordType)); } public void testRecordTypeLeastSuperType4() { JSType leastSupertype = recordType.getLeastSupertype(OBJECT_TYPE); assertTypeEquals(leastSupertype, OBJECT_TYPE); } /** * Tests the getGreatestSubtype method for record types. */ public void testRecordTypeGreatestSubType1() { RecordTypeBuilder builder = new RecordTypeBuilder(registry); builder.addProperty("d", NUMBER_TYPE, null); builder.addProperty("e", STRING_TYPE, null); builder.addProperty("f", STRING_TYPE, null); JSType subRecordType = builder.build(); JSType subtype = recordType.getGreatestSubtype(subRecordType); builder = new RecordTypeBuilder(registry); builder.addProperty("d", NUMBER_TYPE, null); builder.addProperty("e", STRING_TYPE, null); builder.addProperty("f", STRING_TYPE, null); builder.addProperty("a", NUMBER_TYPE, null); builder.addProperty("b", STRING_TYPE, null); assertTypeEquals(subtype, builder.build()); } public void testRecordTypeGreatestSubType2() { RecordTypeBuilder builder = new RecordTypeBuilder(registry); JSType subRecordType = builder.build(); JSType subtype = recordType.getGreatestSubtype(subRecordType); builder = new RecordTypeBuilder(registry); builder.addProperty("a", NUMBER_TYPE, null); builder.addProperty("b", STRING_TYPE, null); assertTypeEquals(subtype, builder.build()); } public void testRecordTypeGreatestSubType3() { RecordTypeBuilder builder = new RecordTypeBuilder(registry); builder.addProperty("a", NUMBER_TYPE, null); builder.addProperty("b", STRING_TYPE, null); builder.addProperty("c", STRING_TYPE, null); JSType subRecordType = builder.build(); JSType subtype = recordType.getGreatestSubtype(subRecordType); builder = new RecordTypeBuilder(registry); builder.addProperty("a", NUMBER_TYPE, null); builder.addProperty("b", STRING_TYPE, null); builder.addProperty("c", STRING_TYPE, null); assertTypeEquals(subtype, builder.build()); } public void testRecordTypeGreatestSubType4() { RecordTypeBuilder builder = new RecordTypeBuilder(registry); builder.addProperty("a", STRING_TYPE, null); builder.addProperty("b", STRING_TYPE, null); builder.addProperty("c", STRING_TYPE, null); JSType subRecordType = builder.build(); JSType subtype = recordType.getGreatestSubtype(subRecordType); assertTypeEquals(subtype, NO_TYPE); } public void testRecordTypeGreatestSubType5() { RecordTypeBuilder builder = new RecordTypeBuilder(registry); builder.addProperty("a", STRING_TYPE, null); JSType recordType = builder.build(); assertTypeEquals(NO_OBJECT_TYPE, recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE)); // if Function is given a property "a" of type "string", then it's // a subtype of the record type {a: string}. U2U_CONSTRUCTOR_TYPE.defineDeclaredProperty("a", STRING_TYPE, null); assertTypeEquals(U2U_CONSTRUCTOR_TYPE, recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE)); assertTypeEquals(U2U_CONSTRUCTOR_TYPE, U2U_CONSTRUCTOR_TYPE.getGreatestSubtype(recordType)); } public void testRecordTypeGreatestSubType6() { RecordTypeBuilder builder = new RecordTypeBuilder(registry); builder.addProperty("x", UNKNOWN_TYPE, null); JSType recordType = builder.build(); assertTypeEquals(NO_OBJECT_TYPE, recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE)); // if Function is given a property "x" of type "string", then it's // also a subtype of the record type {x: ?}. U2U_CONSTRUCTOR_TYPE.defineDeclaredProperty("x", STRING_TYPE, null); assertTypeEquals(U2U_CONSTRUCTOR_TYPE, recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE)); assertTypeEquals(U2U_CONSTRUCTOR_TYPE, U2U_CONSTRUCTOR_TYPE.getGreatestSubtype(recordType)); } public void testRecordTypeGreatestSubType7() { RecordTypeBuilder builder = new RecordTypeBuilder(registry); builder.addProperty("x", NUMBER_TYPE, null); JSType recordType = builder.build(); // if Function is given a property "x" of type "string", then it's // not a subtype of the record type {x: number}. U2U_CONSTRUCTOR_TYPE.defineDeclaredProperty("x", STRING_TYPE, null); assertTypeEquals(NO_OBJECT_TYPE, recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE)); } public void testRecordTypeGreatestSubType8() { RecordTypeBuilder builder = new RecordTypeBuilder(registry); builder.addProperty("xyz", UNKNOWN_TYPE, null); JSType recordType = builder.build(); assertTypeEquals(NO_OBJECT_TYPE, recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE)); // if goog.Bar is given a property "xyz" of type "string", then it's // also a subtype of the record type {x: ?}. googBar.defineDeclaredProperty("xyz", STRING_TYPE, null); assertTypeEquals(googBar, recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE)); assertTypeEquals(googBar, U2U_CONSTRUCTOR_TYPE.getGreatestSubtype(recordType)); ObjectType googBarInst = googBar.getInstanceType(); assertTypeEquals(NO_OBJECT_TYPE, recordType.getGreatestSubtype(googBarInst)); assertTypeEquals(NO_OBJECT_TYPE, googBarInst.getGreatestSubtype(recordType)); } /** * Tests the "apply" method on the function type. */ public void testApplyOfDateMethod() { JSType applyType = dateMethod.getPropertyType("apply"); assertTrue("apply should be a function", applyType instanceof FunctionType); FunctionType applyFn = (FunctionType) applyType; assertTypeEquals("apply should have the same return type as its function", NUMBER_TYPE, applyFn.getReturnType()); Node params = applyFn.getParametersNode(); assertEquals("apply takes two args", 2, params.getChildCount()); assertTypeEquals("apply's first arg is the @this type", registry.createOptionalNullableType(DATE_TYPE), params.getFirstChild().getJSType()); assertTypeEquals("apply's second arg is an Array", registry.createOptionalNullableType(OBJECT_TYPE), params.getLastChild().getJSType()); assertTrue("apply's args must be optional", params.getFirstChild().isOptionalArg()); assertTrue("apply's args must be optional", params.getLastChild().isOptionalArg()); } /** * Tests the "call" method on the function type. */ public void testCallOfDateMethod() { JSType callType = dateMethod.getPropertyType("call"); assertTrue("call should be a function", callType instanceof FunctionType); FunctionType callFn = (FunctionType) callType; assertTypeEquals("call should have the same return type as its function", NUMBER_TYPE, callFn.getReturnType()); Node params = callFn.getParametersNode(); assertEquals("call takes one argument in this case", 1, params.getChildCount()); assertTypeEquals("call's first arg is the @this type", registry.createOptionalNullableType(DATE_TYPE), params.getFirstChild().getJSType()); assertTrue("call's args must be optional", params.getFirstChild().isOptionalArg()); } /** * Tests the representation of function types. */ public void testFunctionTypeRepresentation() { assertEquals("function (number, string): boolean", registry.createFunctionType(BOOLEAN_TYPE, false, NUMBER_TYPE, STRING_TYPE).toString()); assertEquals("function (new:Array, ...[*]): Array", ARRAY_FUNCTION_TYPE.toString()); assertEquals("function (new:Boolean, *=): boolean", BOOLEAN_OBJECT_FUNCTION_TYPE.toString()); assertEquals("function (new:Number, *=): number", NUMBER_OBJECT_FUNCTION_TYPE.toString()); assertEquals("function (new:String, *=): string", STRING_OBJECT_FUNCTION_TYPE.toString()); assertEquals("function (...[number]): boolean", registry.createFunctionType(BOOLEAN_TYPE, true, NUMBER_TYPE) .toString()); assertEquals("function (number, ...[string]): boolean", registry.createFunctionType(BOOLEAN_TYPE, true, NUMBER_TYPE, STRING_TYPE).toString()); assertEquals("function (this:Date, number): (boolean|number|string)", new FunctionBuilder(registry) .withParamsNode(registry.createParameters(NUMBER_TYPE)) .withReturnType(NUMBER_STRING_BOOLEAN) .withTypeOfThis(DATE_TYPE) .build().toString()); } /** * Tests relationships between structural function types. */ public void testFunctionTypeRelationships() { FunctionType dateMethodEmpty = new FunctionBuilder(registry) .withParamsNode(registry.createParameters()) .withTypeOfThis(DATE_TYPE).build(); FunctionType dateMethodWithParam = new FunctionBuilder(registry) .withParamsNode(registry.createOptionalParameters(NUMBER_TYPE)) .withTypeOfThis(DATE_TYPE).build(); FunctionType dateMethodWithReturn = new FunctionBuilder(registry) .withReturnType(NUMBER_TYPE) .withTypeOfThis(DATE_TYPE).build(); FunctionType stringMethodEmpty = new FunctionBuilder(registry) .withParamsNode(registry.createParameters()) .withTypeOfThis(STRING_OBJECT_TYPE).build(); FunctionType stringMethodWithParam = new FunctionBuilder(registry) .withParamsNode(registry.createOptionalParameters(NUMBER_TYPE)) .withTypeOfThis(STRING_OBJECT_TYPE).build(); FunctionType stringMethodWithReturn = new FunctionBuilder(registry) .withReturnType(NUMBER_TYPE) .withTypeOfThis(STRING_OBJECT_TYPE).build(); // One-off tests. assertFalse(stringMethodEmpty.isSubtype(dateMethodEmpty)); // Systemic tests. List<FunctionType> allFunctions = Lists.newArrayList( dateMethodEmpty, dateMethodWithParam, dateMethodWithReturn, stringMethodEmpty, stringMethodWithParam, stringMethodWithReturn); for (int i = 0; i < allFunctions.size(); i++) { for (int j = 0; j < allFunctions.size(); j++) { FunctionType typeA = allFunctions.get(i); FunctionType typeB = allFunctions.get(j); assertEquals(String.format("equals(%s, %s)", typeA, typeB), i == j, typeA.isEquivalentTo(typeB)); // For this particular set of functions, the functions are subtypes // of each other iff they have the same "this" type. assertEquals(String.format("isSubtype(%s, %s)", typeA, typeB), typeA.getTypeOfThis().isEquivalentTo(typeB.getTypeOfThis()), typeA.isSubtype(typeB)); if (i == j) { assertTypeEquals(typeA, typeA.getLeastSupertype(typeB)); assertTypeEquals(typeA, typeA.getGreatestSubtype(typeB)); } else { assertTypeEquals(String.format("sup(%s, %s)", typeA, typeB), U2U_CONSTRUCTOR_TYPE, typeA.getLeastSupertype(typeB)); assertTypeEquals(String.format("inf(%s, %s)", typeA, typeB), LEAST_FUNCTION_TYPE, typeA.getGreatestSubtype(typeB)); } } } } public void testProxiedFunctionTypeRelationships() { FunctionType dateMethodEmpty = new FunctionBuilder(registry) .withParamsNode(registry.createParameters()) .withTypeOfThis(DATE_TYPE).build().toMaybeFunctionType(); FunctionType dateMethodWithParam = new FunctionBuilder(registry) .withParamsNode(registry.createParameters(NUMBER_TYPE)) .withTypeOfThis(DATE_TYPE).build().toMaybeFunctionType(); ProxyObjectType proxyDateMethodEmpty = new ProxyObjectType(registry, dateMethodEmpty); ProxyObjectType proxyDateMethodWithParam = new ProxyObjectType(registry, dateMethodWithParam); assertTypeEquals(U2U_CONSTRUCTOR_TYPE, proxyDateMethodEmpty.getLeastSupertype(proxyDateMethodWithParam)); assertTypeEquals(LEAST_FUNCTION_TYPE, proxyDateMethodEmpty.getGreatestSubtype(proxyDateMethodWithParam)); } /** * Tests relationships between structural function types. */ public void testFunctionSubTypeRelationships() { FunctionType googBarMethod = new FunctionBuilder(registry) .withTypeOfThis(googBar).build(); FunctionType googBarParamFn = new FunctionBuilder(registry) .withParamsNode(registry.createParameters(googBar)).build(); FunctionType googBarReturnFn = new FunctionBuilder(registry) .withParamsNode(registry.createParameters()) .withReturnType(googBar).build(); FunctionType googSubBarMethod = new FunctionBuilder(registry) .withTypeOfThis(googSubBar).build(); FunctionType googSubBarParamFn = new FunctionBuilder(registry) .withParamsNode(registry.createParameters(googSubBar)).build(); FunctionType googSubBarReturnFn = new FunctionBuilder(registry) .withReturnType(googSubBar).build(); assertTrue(googBarMethod.isSubtype(googSubBarMethod)); assertTrue(googBarReturnFn.isSubtype(googSubBarReturnFn)); List<FunctionType> allFunctions = Lists.newArrayList( googBarMethod, googBarParamFn, googBarReturnFn, googSubBarMethod, googSubBarParamFn, googSubBarReturnFn); for (int i = 0; i < allFunctions.size(); i++) { for (int j = 0; j < allFunctions.size(); j++) { FunctionType typeA = allFunctions.get(i); FunctionType typeB = allFunctions.get(j); assertEquals(String.format("equals(%s, %s)", typeA, typeB), i == j, typeA.isEquivalentTo(typeB)); // TODO(nicksantos): This formulation of least subtype and greatest // supertype is a bit loose. We might want to tighten it up later. if (i == j) { assertTypeEquals(typeA, typeA.getLeastSupertype(typeB)); assertTypeEquals(typeA, typeA.getGreatestSubtype(typeB)); } else { assertTypeEquals(String.format("sup(%s, %s)", typeA, typeB), U2U_CONSTRUCTOR_TYPE, typeA.getLeastSupertype(typeB)); assertTypeEquals(String.format("inf(%s, %s)", typeA, typeB), LEAST_FUNCTION_TYPE, typeA.getGreatestSubtype(typeB)); } } } } /** * Tests that defining a property of a function's {@code prototype} adds the * property to it instance type. */ public void testFunctionPrototypeAndImplicitPrototype1() { FunctionType constructor = registry.createConstructorType("Foo", null, null, null, null); ObjectType instance = constructor.getInstanceType(); // adding one property on the prototype ObjectType prototype = (ObjectType) constructor.getPropertyType("prototype"); prototype.defineDeclaredProperty("foo", DATE_TYPE, null); assertEquals(NATIVE_PROPERTIES_COUNT + 1, instance.getPropertiesCount()); } /** * Tests that replacing a function's {@code prototype} changes the visible * properties of its instance type. */ public void testFunctionPrototypeAndImplicitPrototype2() { FunctionType constructor = registry.createConstructorType(null, null, null, null); ObjectType instance = constructor.getInstanceType(); // replacing the prototype ObjectType prototype = registry.createAnonymousObjectType(null); prototype.defineDeclaredProperty("foo", DATE_TYPE, null); constructor.defineDeclaredProperty("prototype", prototype, null); assertEquals(NATIVE_PROPERTIES_COUNT + 1, instance.getPropertiesCount()); } /** Tests assigning JsDoc on a prototype property. */ public void testJSDocOnPrototypeProperty() throws Exception { subclassCtor.setPropertyJSDocInfo("prototype", new JSDocInfo()); assertNull(subclassCtor.getOwnPropertyJSDocInfo("prototype")); } /** * Tests the behavior of the void type. */ public void testVoidType() throws Exception { // isSubtype assertTrue(VOID_TYPE.isSubtype(ALL_TYPE)); assertFalse(VOID_TYPE.isSubtype(STRING_OBJECT_TYPE)); assertFalse(VOID_TYPE.isSubtype(REGEXP_TYPE)); // autoboxesTo assertNull(VOID_TYPE.autoboxesTo()); // canTestForEqualityWith assertCanTestForEqualityWith(VOID_TYPE, ALL_TYPE); assertCannotTestForEqualityWith(VOID_TYPE, REGEXP_TYPE); // canTestForShallowEqualityWith assertTrue(VOID_TYPE.canTestForShallowEqualityWith(NO_TYPE)); assertFalse(VOID_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); assertFalse(VOID_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE)); assertFalse(VOID_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE)); assertFalse(VOID_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); assertFalse(VOID_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); assertFalse(VOID_TYPE.canTestForShallowEqualityWith(ERROR_TYPE)); assertFalse(VOID_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); assertFalse(VOID_TYPE.canTestForShallowEqualityWith(functionType)); assertFalse(VOID_TYPE.canTestForShallowEqualityWith(NULL_TYPE)); assertFalse(VOID_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); assertFalse(VOID_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); assertFalse(VOID_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); assertFalse(VOID_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE)); assertFalse(VOID_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); assertFalse(VOID_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); assertFalse(VOID_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); assertFalse(VOID_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); assertFalse(VOID_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); assertFalse(VOID_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); assertFalse(VOID_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); assertTrue(VOID_TYPE.canTestForShallowEqualityWith(ALL_TYPE)); assertTrue(VOID_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); assertTrue(VOID_TYPE.canTestForShallowEqualityWith( createUnionType(NUMBER_TYPE, VOID_TYPE))); // matchesXxx assertFalse(VOID_TYPE.matchesInt32Context()); assertFalse(VOID_TYPE.matchesNumberContext()); assertFalse(VOID_TYPE.matchesObjectContext()); assertTrue(VOID_TYPE.matchesStringContext()); assertFalse(VOID_TYPE.matchesUint32Context()); Asserts.assertResolvesToSame(VOID_TYPE); } /** * Tests the behavior of the boolean type. */ public void testBooleanValueType() throws Exception { // isXxx assertFalse(BOOLEAN_TYPE.isArrayType()); assertFalse(BOOLEAN_TYPE.isBooleanObjectType()); assertTrue(BOOLEAN_TYPE.isBooleanValueType()); assertFalse(BOOLEAN_TYPE.isDateType()); assertFalse(BOOLEAN_TYPE.isEnumElementType()); assertFalse(BOOLEAN_TYPE.isNamedType()); assertFalse(BOOLEAN_TYPE.isNullType()); assertFalse(BOOLEAN_TYPE.isNumberObjectType()); assertFalse(BOOLEAN_TYPE.isNumberValueType()); assertFalse(BOOLEAN_TYPE.isFunctionPrototypeType()); assertFalse(BOOLEAN_TYPE.isRegexpType()); assertFalse(BOOLEAN_TYPE.isStringObjectType()); assertFalse(BOOLEAN_TYPE.isStringValueType()); assertFalse(BOOLEAN_TYPE.isEnumType()); assertFalse(BOOLEAN_TYPE.isUnionType()); assertFalse(BOOLEAN_TYPE.isStruct()); assertFalse(BOOLEAN_TYPE.isDict()); assertFalse(BOOLEAN_TYPE.isAllType()); assertFalse(BOOLEAN_TYPE.isVoidType()); assertFalse(BOOLEAN_TYPE.isConstructor()); assertFalse(BOOLEAN_TYPE.isInstanceType()); // autoboxesTo assertTypeEquals(BOOLEAN_OBJECT_TYPE, BOOLEAN_TYPE.autoboxesTo()); // unboxesTo assertTypeEquals(BOOLEAN_TYPE, BOOLEAN_OBJECT_TYPE.unboxesTo()); // isSubtype assertTrue(BOOLEAN_TYPE.isSubtype(ALL_TYPE)); assertFalse(BOOLEAN_TYPE.isSubtype(STRING_OBJECT_TYPE)); assertFalse(BOOLEAN_TYPE.isSubtype(NUMBER_TYPE)); assertFalse(BOOLEAN_TYPE.isSubtype(functionType)); assertFalse(BOOLEAN_TYPE.isSubtype(NULL_TYPE)); assertFalse(BOOLEAN_TYPE.isSubtype(OBJECT_TYPE)); assertFalse(BOOLEAN_TYPE.isSubtype(DATE_TYPE)); assertTrue(BOOLEAN_TYPE.isSubtype(unresolvedNamedType)); assertFalse(BOOLEAN_TYPE.isSubtype(namedGoogBar)); assertFalse(BOOLEAN_TYPE.isSubtype(REGEXP_TYPE)); // canBeCalled assertFalse(BOOLEAN_TYPE.canBeCalled()); // canTestForEqualityWith assertCanTestForEqualityWith(BOOLEAN_TYPE, ALL_TYPE); assertCanTestForEqualityWith(BOOLEAN_TYPE, STRING_OBJECT_TYPE); assertCanTestForEqualityWith(BOOLEAN_TYPE, NUMBER_TYPE); assertCannotTestForEqualityWith(BOOLEAN_TYPE, functionType); assertCannotTestForEqualityWith(BOOLEAN_TYPE, VOID_TYPE); assertCanTestForEqualityWith(BOOLEAN_TYPE, OBJECT_TYPE); assertCanTestForEqualityWith(BOOLEAN_TYPE, DATE_TYPE); assertCanTestForEqualityWith(BOOLEAN_TYPE, REGEXP_TYPE); assertCanTestForEqualityWith(BOOLEAN_TYPE, UNKNOWN_TYPE); // canTestForShallowEqualityWith assertTrue(BOOLEAN_TYPE.canTestForShallowEqualityWith(NO_TYPE)); assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE)); assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE)); assertTrue(BOOLEAN_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE)); assertFalse(BOOLEAN_TYPE. canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(ERROR_TYPE)); assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(functionType)); assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(NULL_TYPE)); assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE)); assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); assertFalse(BOOLEAN_TYPE. canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); assertTrue(BOOLEAN_TYPE.canTestForShallowEqualityWith(ALL_TYPE)); assertFalse(BOOLEAN_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); assertTrue(BOOLEAN_TYPE.canTestForShallowEqualityWith(UNKNOWN_TYPE)); // isNullable assertFalse(BOOLEAN_TYPE.isNullable()); // matchesXxx assertTrue(BOOLEAN_TYPE.matchesInt32Context()); assertTrue(BOOLEAN_TYPE.matchesNumberContext()); assertTrue(BOOLEAN_TYPE.matchesObjectContext()); assertTrue(BOOLEAN_TYPE.matchesStringContext()); assertTrue(BOOLEAN_TYPE.matchesUint32Context()); // toString assertEquals("boolean", BOOLEAN_TYPE.toString()); assertTrue(BOOLEAN_TYPE.hasDisplayName()); assertEquals("boolean", BOOLEAN_TYPE.getDisplayName()); Asserts.assertResolvesToSame(BOOLEAN_TYPE); } /** * Tests the behavior of the Boolean type. */ public void testBooleanObjectType() throws Exception { // isXxx assertFalse(BOOLEAN_OBJECT_TYPE.isArrayType()); assertTrue(BOOLEAN_OBJECT_TYPE.isBooleanObjectType()); assertFalse(BOOLEAN_OBJECT_TYPE.isBooleanValueType()); assertFalse(BOOLEAN_OBJECT_TYPE.isDateType()); assertFalse(BOOLEAN_OBJECT_TYPE.isEnumElementType()); assertFalse(BOOLEAN_OBJECT_TYPE.isNamedType()); assertFalse(BOOLEAN_OBJECT_TYPE.isNullType()); assertFalse(BOOLEAN_OBJECT_TYPE.isNumberObjectType()); assertFalse(BOOLEAN_OBJECT_TYPE.isNumberValueType()); assertFalse(BOOLEAN_OBJECT_TYPE.isFunctionPrototypeType()); assertTrue( BOOLEAN_OBJECT_TYPE.getImplicitPrototype().isFunctionPrototypeType()); assertFalse(BOOLEAN_OBJECT_TYPE.isRegexpType()); assertFalse(BOOLEAN_OBJECT_TYPE.isStringObjectType()); assertFalse(BOOLEAN_OBJECT_TYPE.isStringValueType()); assertFalse(BOOLEAN_OBJECT_TYPE.isEnumType()); assertFalse(BOOLEAN_OBJECT_TYPE.isUnionType()); assertFalse(BOOLEAN_OBJECT_TYPE.isStruct()); assertFalse(BOOLEAN_OBJECT_TYPE.isDict()); assertFalse(BOOLEAN_OBJECT_TYPE.isAllType()); assertFalse(BOOLEAN_OBJECT_TYPE.isVoidType()); assertFalse(BOOLEAN_OBJECT_TYPE.isConstructor()); assertTrue(BOOLEAN_OBJECT_TYPE.isInstanceType()); // isSubtype assertTrue(BOOLEAN_OBJECT_TYPE.isSubtype(ALL_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(STRING_OBJECT_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(NUMBER_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(functionType)); assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(NULL_TYPE)); assertTrue(BOOLEAN_OBJECT_TYPE.isSubtype(OBJECT_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(DATE_TYPE)); assertTrue(BOOLEAN_OBJECT_TYPE.isSubtype(unresolvedNamedType)); assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(namedGoogBar)); assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(REGEXP_TYPE)); // canBeCalled assertFalse(BOOLEAN_OBJECT_TYPE.canBeCalled()); // canTestForEqualityWith assertCanTestForEqualityWith(BOOLEAN_OBJECT_TYPE, ALL_TYPE); assertCanTestForEqualityWith(BOOLEAN_OBJECT_TYPE, STRING_OBJECT_TYPE); assertCanTestForEqualityWith(BOOLEAN_OBJECT_TYPE, NUMBER_TYPE); assertCanTestForEqualityWith(BOOLEAN_OBJECT_TYPE, functionType); assertCannotTestForEqualityWith(BOOLEAN_OBJECT_TYPE, VOID_TYPE); assertCanTestForEqualityWith(BOOLEAN_OBJECT_TYPE, OBJECT_TYPE); assertCanTestForEqualityWith(BOOLEAN_OBJECT_TYPE, DATE_TYPE); assertCanTestForEqualityWith(BOOLEAN_OBJECT_TYPE, REGEXP_TYPE); // canTestForShallowEqualityWith assertTrue(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(NO_TYPE)); assertTrue(BOOLEAN_OBJECT_TYPE. canTestForShallowEqualityWith(NO_OBJECT_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE. canTestForShallowEqualityWith(BOOLEAN_TYPE)); assertTrue(BOOLEAN_OBJECT_TYPE. canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(DATE_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(ERROR_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE. canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE. canTestForShallowEqualityWith(functionType)); assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(NULL_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE. canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); assertTrue(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE. canTestForShallowEqualityWith(URI_ERROR_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE. canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE. canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(STRING_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE. canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE. canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE. canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); assertTrue(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(ALL_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE.canTestForShallowEqualityWith(VOID_TYPE)); // isNullable assertFalse(BOOLEAN_OBJECT_TYPE.isNullable()); // matchesXxx assertTrue(BOOLEAN_OBJECT_TYPE.matchesInt32Context()); assertTrue(BOOLEAN_OBJECT_TYPE.matchesNumberContext()); assertTrue(BOOLEAN_OBJECT_TYPE.matchesObjectContext()); assertTrue(BOOLEAN_OBJECT_TYPE.matchesStringContext()); assertTrue(BOOLEAN_OBJECT_TYPE.matchesUint32Context()); // toString assertEquals("Boolean", BOOLEAN_OBJECT_TYPE.toString()); assertTrue(BOOLEAN_OBJECT_TYPE.hasDisplayName()); assertEquals("Boolean", BOOLEAN_OBJECT_TYPE.getDisplayName()); assertTrue(BOOLEAN_OBJECT_TYPE.isNativeObjectType()); Asserts.assertResolvesToSame(BOOLEAN_OBJECT_TYPE); } /** * Tests the behavior of the enum type. */ public void testEnumType() throws Exception { EnumType enumType = new EnumType(registry, "Enum", null, NUMBER_TYPE); // isXxx assertFalse(enumType.isArrayType()); assertFalse(enumType.isBooleanObjectType()); assertFalse(enumType.isBooleanValueType()); assertFalse(enumType.isDateType()); assertFalse(enumType.isEnumElementType()); assertFalse(enumType.isNamedType()); assertFalse(enumType.isNullType()); assertFalse(enumType.isNumberObjectType()); assertFalse(enumType.isNumberValueType()); assertFalse(enumType.isFunctionPrototypeType()); assertFalse(enumType.isRegexpType()); assertFalse(enumType.isStringObjectType()); assertFalse(enumType.isStringValueType()); assertTrue(enumType.isEnumType()); assertFalse(enumType.isUnionType()); assertFalse(enumType.isStruct()); assertFalse(enumType.isDict()); assertFalse(enumType.isAllType()); assertFalse(enumType.isVoidType()); assertFalse(enumType.isConstructor()); assertFalse(enumType.isInstanceType()); // isSubtype assertTrue(enumType.isSubtype(ALL_TYPE)); assertFalse(enumType.isSubtype(STRING_OBJECT_TYPE)); assertFalse(enumType.isSubtype(NUMBER_TYPE)); assertFalse(enumType.isSubtype(functionType)); assertFalse(enumType.isSubtype(NULL_TYPE)); assertTrue(enumType.isSubtype(OBJECT_TYPE)); assertFalse(enumType.isSubtype(DATE_TYPE)); assertTrue(enumType.isSubtype(unresolvedNamedType)); assertFalse(enumType.isSubtype(namedGoogBar)); assertFalse(enumType.isSubtype(REGEXP_TYPE)); // canBeCalled assertFalse(enumType.canBeCalled()); // canTestForEqualityWith assertCanTestForEqualityWith(enumType, ALL_TYPE); assertCanTestForEqualityWith(enumType, STRING_OBJECT_TYPE); assertCanTestForEqualityWith(enumType, NUMBER_TYPE); assertCanTestForEqualityWith(enumType, functionType); assertCannotTestForEqualityWith(enumType, VOID_TYPE); assertCanTestForEqualityWith(enumType, OBJECT_TYPE); assertCanTestForEqualityWith(enumType, DATE_TYPE); assertCanTestForEqualityWith(enumType, REGEXP_TYPE); // canTestForShallowEqualityWith assertTrue(enumType.canTestForShallowEqualityWith(NO_TYPE)); assertTrue(enumType. canTestForShallowEqualityWith(NO_OBJECT_TYPE)); assertFalse(enumType.canTestForShallowEqualityWith(ARRAY_TYPE)); assertFalse(enumType. canTestForShallowEqualityWith(BOOLEAN_TYPE)); assertTrue(enumType. canTestForShallowEqualityWith(enumType)); assertFalse(enumType.canTestForShallowEqualityWith(DATE_TYPE)); assertFalse(enumType.canTestForShallowEqualityWith(ERROR_TYPE)); assertFalse(enumType. canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); assertFalse(enumType. canTestForShallowEqualityWith(functionType)); assertFalse(enumType.canTestForShallowEqualityWith(NULL_TYPE)); assertFalse(enumType.canTestForShallowEqualityWith(NUMBER_TYPE)); assertFalse(enumType. canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); assertTrue(enumType.canTestForShallowEqualityWith(OBJECT_TYPE)); assertFalse(enumType. canTestForShallowEqualityWith(URI_ERROR_TYPE)); assertFalse(enumType. canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); assertFalse(enumType. canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); assertFalse(enumType.canTestForShallowEqualityWith(REGEXP_TYPE)); assertFalse(enumType.canTestForShallowEqualityWith(STRING_TYPE)); assertFalse(enumType. canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); assertFalse(enumType. canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); assertFalse(enumType. canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); assertTrue(enumType.canTestForShallowEqualityWith(ALL_TYPE)); assertFalse(enumType.canTestForShallowEqualityWith(VOID_TYPE)); // isNullable assertFalse(enumType.isNullable()); // matchesXxx assertFalse(enumType.matchesInt32Context()); assertFalse(enumType.matchesNumberContext()); assertTrue(enumType.matchesObjectContext()); assertTrue(enumType.matchesStringContext()); assertFalse(enumType.matchesUint32Context()); // toString assertEquals("enum{Enum}", enumType.toString()); assertTrue(enumType.hasDisplayName()); assertEquals("Enum", enumType.getDisplayName()); assertEquals("AnotherEnum", new EnumType(registry, "AnotherEnum", null, NUMBER_TYPE).getDisplayName()); assertFalse( new EnumType(registry, null, null, NUMBER_TYPE).hasDisplayName()); Asserts.assertResolvesToSame(enumType); } /** * Tests the behavior of the enum element type. */ public void testEnumElementType() throws Exception { // isXxx assertFalse(elementsType.isArrayType()); assertFalse(elementsType.isBooleanObjectType()); assertFalse(elementsType.isBooleanValueType()); assertFalse(elementsType.isDateType()); assertTrue(elementsType.isEnumElementType()); assertFalse(elementsType.isNamedType()); assertFalse(elementsType.isNullType()); assertFalse(elementsType.isNumberObjectType()); assertFalse(elementsType.isNumberValueType()); assertFalse(elementsType.isFunctionPrototypeType()); assertFalse(elementsType.isRegexpType()); assertFalse(elementsType.isStringObjectType()); assertFalse(elementsType.isStringValueType()); assertFalse(elementsType.isEnumType()); assertFalse(elementsType.isUnionType()); assertFalse(elementsType.isStruct()); assertFalse(elementsType.isDict()); assertFalse(elementsType.isAllType()); assertFalse(elementsType.isVoidType()); assertFalse(elementsType.isConstructor()); assertFalse(elementsType.isInstanceType()); // isSubtype assertTrue(elementsType.isSubtype(ALL_TYPE)); assertFalse(elementsType.isSubtype(STRING_OBJECT_TYPE)); assertTrue(elementsType.isSubtype(NUMBER_TYPE)); assertFalse(elementsType.isSubtype(functionType)); assertFalse(elementsType.isSubtype(NULL_TYPE)); assertFalse(elementsType.isSubtype(OBJECT_TYPE)); // no more autoboxing assertFalse(elementsType.isSubtype(DATE_TYPE)); assertTrue(elementsType.isSubtype(unresolvedNamedType)); assertFalse(elementsType.isSubtype(namedGoogBar)); assertFalse(elementsType.isSubtype(REGEXP_TYPE)); // canBeCalled assertFalse(elementsType.canBeCalled()); // canTestForEqualityWith assertCanTestForEqualityWith(elementsType, ALL_TYPE); assertCanTestForEqualityWith(elementsType, STRING_OBJECT_TYPE); assertCanTestForEqualityWith(elementsType, NUMBER_TYPE); assertCanTestForEqualityWith(elementsType, NUMBER_OBJECT_TYPE); assertCanTestForEqualityWith(elementsType, elementsType); assertCannotTestForEqualityWith(elementsType, functionType); assertCannotTestForEqualityWith(elementsType, VOID_TYPE); assertCanTestForEqualityWith(elementsType, OBJECT_TYPE); assertCanTestForEqualityWith(elementsType, DATE_TYPE); assertCanTestForEqualityWith(elementsType, REGEXP_TYPE); // canTestForShallowEqualityWith assertTrue(elementsType.canTestForShallowEqualityWith(NO_TYPE)); assertFalse(elementsType. canTestForShallowEqualityWith(NO_OBJECT_TYPE)); assertFalse(elementsType.canTestForShallowEqualityWith(ARRAY_TYPE)); assertFalse(elementsType. canTestForShallowEqualityWith(BOOLEAN_TYPE)); assertTrue(elementsType. canTestForShallowEqualityWith(elementsType)); assertFalse(elementsType.canTestForShallowEqualityWith(DATE_TYPE)); assertFalse(elementsType.canTestForShallowEqualityWith(ERROR_TYPE)); assertFalse(elementsType. canTestForShallowEqualityWith(EVAL_ERROR_TYPE)); assertFalse(elementsType. canTestForShallowEqualityWith(functionType)); assertFalse(elementsType.canTestForShallowEqualityWith(NULL_TYPE)); assertTrue(elementsType.canTestForShallowEqualityWith(NUMBER_TYPE)); assertFalse(elementsType. canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE)); assertFalse(elementsType.canTestForShallowEqualityWith(OBJECT_TYPE)); assertFalse(elementsType. canTestForShallowEqualityWith(URI_ERROR_TYPE)); assertFalse(elementsType. canTestForShallowEqualityWith(RANGE_ERROR_TYPE)); assertFalse(elementsType. canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE)); assertFalse(elementsType.canTestForShallowEqualityWith(REGEXP_TYPE)); assertFalse(elementsType.canTestForShallowEqualityWith(STRING_TYPE)); assertFalse(elementsType. canTestForShallowEqualityWith(STRING_OBJECT_TYPE)); assertFalse(elementsType. canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE)); assertFalse(elementsType. canTestForShallowEqualityWith(TYPE_ERROR_TYPE)); assertTrue(elementsType.canTestForShallowEqualityWith(ALL_TYPE)); assertFalse(elementsType.canTestForShallowEqualityWith(VOID_TYPE)); // isNullable assertFalse(elementsType.isNullable()); // matchesXxx assertTrue(elementsType.matchesInt32Context()); assertTrue(elementsType.matchesNumberContext()); assertTrue(elementsType.matchesObjectContext()); assertTrue(elementsType.matchesStringContext()); assertTrue(elementsType.matchesUint32Context()); // toString assertEquals("Enum.<number>", elementsType.toString()); assertTrue(elementsType.hasDisplayName()); assertEquals("Enum", elementsType.getDisplayName()); Asserts.assertResolvesToSame(elementsType); } public void testStringEnumType() throws Exception { EnumElementType stringEnum = new EnumType(registry, "Enum", null, STRING_TYPE).getElementsType(); assertTypeEquals(UNKNOWN_TYPE, stringEnum.getPropertyType("length")); assertTypeEquals(NUMBER_TYPE, stringEnum.findPropertyType("length")); assertEquals(false, stringEnum.hasProperty("length")); assertTypeEquals(STRING_OBJECT_TYPE, stringEnum.autoboxesTo()); assertNull(stringEnum.getConstructor()); Asserts.assertResolvesToSame(stringEnum); } public void testStringObjectEnumType() throws Exception { EnumElementType stringEnum = new EnumType(registry, "Enum", null, STRING_OBJECT_TYPE) .getElementsType(); assertTypeEquals(NUMBER_TYPE, stringEnum.getPropertyType("length")); assertTypeEquals(NUMBER_TYPE, stringEnum.findPropertyType("length")); assertEquals(true, stringEnum.hasProperty("length")); assertTypeEquals(STRING_OBJECT_FUNCTION_TYPE, stringEnum.getConstructor()); } /** * Tests object types. */ public void testObjectType() throws Exception { PrototypeObjectType objectType = new PrototypeObjectType(registry, null, null); // isXxx assertFalse(objectType.isAllType()); assertFalse(objectType.isArrayType()); assertFalse(objectType.isDateType()); assertFalse(objectType.isFunctionPrototypeType()); assertTrue(objectType.getImplicitPrototype() == OBJECT_TYPE); // isSubtype assertTrue(objectType.isSubtype(ALL_TYPE)); assertFalse(objectType.isSubtype(STRING_OBJECT_TYPE)); assertFalse(objectType.isSubtype(NUMBER_TYPE)); assertFalse(objectType.isSubtype(functionType)); assertFalse(objectType.isSubtype(NULL_TYPE)); assertFalse(objectType.isSubtype(DATE_TYPE)); assertTrue(objectType.isSubtype(OBJECT_TYPE)); assertTrue(objectType.isSubtype(unresolvedNamedType)); assertFalse(objectType.isSubtype(namedGoogBar)); assertFalse(objectType.isSubtype(REGEXP_TYPE)); // autoboxesTo assertNull(objectType.autoboxesTo()); // canTestForEqualityWith assertCanTestForEqualityWith(objectType, NUMBER_TYPE); // matchesXxxContext assertFalse(objectType.matchesInt32Context()); assertFalse(objectType.matchesNumberContext()); assertTrue(objectType.matchesObjectContext()); assertFalse(objectType.matchesStringContext()); assertFalse(objectType.matchesUint32Context()); // isNullable assertFalse(objectType.isNullable()); assertTrue(createNullableType(objectType).isNullable()); // toString assertEquals("{...}", objectType.toString()); assertEquals(null, objectType.getDisplayName()); assertFalse(objectType.hasReferenceName()); assertEquals("anObject", new PrototypeObjectType(registry, "anObject", null).getDisplayName()); Asserts.assertResolvesToSame(objectType); } /** * Tests the goog.Bar type. */ public void testGoogBar() throws Exception { assertTrue(namedGoogBar.isInstanceType()); assertFalse(googBar.isInstanceType()); assertFalse(namedGoogBar.isConstructor()); assertTrue(googBar.isConstructor()); assertTrue(googBar.getInstanceType().isInstanceType()); assertTrue(namedGoogBar.getConstructor().isConstructor()); assertTrue(namedGoogBar.getImplicitPrototype().isFunctionPrototypeType()); // isSubtype assertTypeCanAssignToItself(googBar); assertTypeCanAssignToItself(namedGoogBar); googBar.isSubtype(namedGoogBar); namedGoogBar.isSubtype(googBar); assertTypeEquals(googBar, googBar); assertTypeNotEquals(googBar, googSubBar); Asserts.assertResolvesToSame(googBar); Asserts.assertResolvesToSame(googSubBar); } /** * Tests how properties are counted for object types. */ public void testObjectTypePropertiesCount() throws Exception { ObjectType sup = registry.createAnonymousObjectType(null); int nativeProperties = sup.getPropertiesCount(); sup.defineDeclaredProperty("a", DATE_TYPE, null); assertEquals(nativeProperties + 1, sup.getPropertiesCount()); sup.defineDeclaredProperty("b", DATE_TYPE, null); assertEquals(nativeProperties + 2, sup.getPropertiesCount()); ObjectType sub = registry.createObjectType(sup); assertEquals(nativeProperties + 2, sub.getPropertiesCount()); } /** * Tests how properties are defined. */ public void testDefineProperties() { ObjectType prototype = googBar.getPrototype(); ObjectType instance = googBar.getInstanceType(); assertTypeEquals(instance.getImplicitPrototype(), prototype); // Test declarations. assertTrue( prototype.defineDeclaredProperty("declared", NUMBER_TYPE, null)); assertFalse( prototype.defineDeclaredProperty("declared", NUMBER_TYPE, null)); assertFalse( instance.defineDeclaredProperty("declared", NUMBER_TYPE, null)); assertTypeEquals(NUMBER_TYPE, instance.getPropertyType("declared")); // Test inferring different types. assertTrue(prototype.defineInferredProperty("inferred1", STRING_TYPE, null)); assertTrue(prototype.defineInferredProperty("inferred1", NUMBER_TYPE, null)); assertTypeEquals( createUnionType(NUMBER_TYPE, STRING_TYPE), instance.getPropertyType("inferred1")); // Test inferring different types on different objects. assertTrue(prototype.defineInferredProperty("inferred2", STRING_TYPE, null)); assertTrue(instance.defineInferredProperty("inferred2", NUMBER_TYPE, null)); assertTypeEquals( createUnionType(NUMBER_TYPE, STRING_TYPE), instance.getPropertyType("inferred2")); // Test inferring on the supertype and declaring on the subtype. assertTrue( prototype.defineInferredProperty("prop", STRING_TYPE, null)); assertTrue( instance.defineDeclaredProperty("prop", NUMBER_TYPE, null)); assertTypeEquals(NUMBER_TYPE, instance.getPropertyType("prop")); assertTypeEquals(STRING_TYPE, prototype.getPropertyType("prop")); } /** * Tests that properties are correctly counted even when shadowing occurs. */ public void testObjectTypePropertiesCountWithShadowing() { ObjectType sup = registry.createAnonymousObjectType(null); int nativeProperties = sup.getPropertiesCount(); sup.defineDeclaredProperty("a", OBJECT_TYPE, null); assertEquals(nativeProperties + 1, sup.getPropertiesCount()); ObjectType sub = registry.createObjectType(sup); sub.defineDeclaredProperty("a", OBJECT_TYPE, null); assertEquals(nativeProperties + 1, sub.getPropertiesCount()); } /** * Tests the named type goog.Bar. */ public void testNamedGoogBar() throws Exception { // isXxx assertFalse(namedGoogBar.isFunctionPrototypeType()); assertTrue(namedGoogBar.getImplicitPrototype().isFunctionPrototypeType()); // isSubtype assertTrue(namedGoogBar.isSubtype(ALL_TYPE)); assertFalse(namedGoogBar.isSubtype(STRING_OBJECT_TYPE)); assertFalse(namedGoogBar.isSubtype(NUMBER_TYPE)); assertFalse(namedGoogBar.isSubtype(functionType)); assertFalse(namedGoogBar.isSubtype(NULL_TYPE)); assertTrue(namedGoogBar.isSubtype(OBJECT_TYPE)); assertFalse(namedGoogBar.isSubtype(DATE_TYPE)); assertTrue(namedGoogBar.isSubtype(namedGoogBar)); assertTrue(namedGoogBar.isSubtype(unresolvedNamedType)); assertFalse(namedGoogBar.isSubtype(REGEXP_TYPE)); assertFalse(namedGoogBar.isSubtype(ARRAY_TYPE)); // autoboxesTo assertNull(namedGoogBar.autoboxesTo()); // properties assertTypeEquals(DATE_TYPE, namedGoogBar.getPropertyType("date")); assertFalse(namedGoogBar.isNativeObjectType()); assertFalse(namedGoogBar.getImplicitPrototype().isNativeObjectType()); JSType resolvedNamedGoogBar = Asserts.assertValidResolve(namedGoogBar); assertNotSame(resolvedNamedGoogBar, namedGoogBar); assertSame(resolvedNamedGoogBar, googBar.getInstanceType()); } /** * Tests the prototype chaining of native objects. */ public void testPrototypeChaining() throws Exception { // equals assertTypeEquals( ARRAY_TYPE.getImplicitPrototype().getImplicitPrototype(), OBJECT_TYPE); assertTypeEquals( BOOLEAN_OBJECT_TYPE.getImplicitPrototype(). getImplicitPrototype(), OBJECT_TYPE); assertTypeEquals( DATE_TYPE.getImplicitPrototype().getImplicitPrototype(), OBJECT_TYPE); assertTypeEquals( ERROR_TYPE.getImplicitPrototype().getImplicitPrototype(), OBJECT_TYPE); assertTypeEquals( EVAL_ERROR_TYPE.getImplicitPrototype().getImplicitPrototype(), ERROR_TYPE); assertTypeEquals( NUMBER_OBJECT_TYPE.getImplicitPrototype(). getImplicitPrototype(), OBJECT_TYPE); assertTypeEquals( URI_ERROR_TYPE.getImplicitPrototype().getImplicitPrototype(), ERROR_TYPE); assertTypeEquals( RANGE_ERROR_TYPE.getImplicitPrototype().getImplicitPrototype(), ERROR_TYPE); assertTypeEquals( REFERENCE_ERROR_TYPE.getImplicitPrototype(). getImplicitPrototype(), ERROR_TYPE); assertTypeEquals( STRING_OBJECT_TYPE.getImplicitPrototype(). getImplicitPrototype(), OBJECT_TYPE); assertTypeEquals( REGEXP_TYPE.getImplicitPrototype().getImplicitPrototype(), OBJECT_TYPE); assertTypeEquals( SYNTAX_ERROR_TYPE.getImplicitPrototype(). getImplicitPrototype(), ERROR_TYPE); assertTypeEquals( TYPE_ERROR_TYPE.getImplicitPrototype(). getImplicitPrototype(), ERROR_TYPE); // not same assertNotSame(EVAL_ERROR_TYPE.getImplicitPrototype(), URI_ERROR_TYPE.getImplicitPrototype()); assertNotSame(EVAL_ERROR_TYPE.getImplicitPrototype(), RANGE_ERROR_TYPE.getImplicitPrototype()); assertNotSame(EVAL_ERROR_TYPE.getImplicitPrototype(), REFERENCE_ERROR_TYPE.getImplicitPrototype()); assertNotSame(EVAL_ERROR_TYPE.getImplicitPrototype(), SYNTAX_ERROR_TYPE.getImplicitPrototype()); assertNotSame(EVAL_ERROR_TYPE.getImplicitPrototype(), TYPE_ERROR_TYPE.getImplicitPrototype()); assertNotSame(URI_ERROR_TYPE.getImplicitPrototype(), RANGE_ERROR_TYPE.getImplicitPrototype()); assertNotSame(URI_ERROR_TYPE.getImplicitPrototype(), REFERENCE_ERROR_TYPE.getImplicitPrototype()); assertNotSame(URI_ERROR_TYPE.getImplicitPrototype(), SYNTAX_ERROR_TYPE.getImplicitPrototype()); assertNotSame(URI_ERROR_TYPE.getImplicitPrototype(), TYPE_ERROR_TYPE.getImplicitPrototype()); assertNotSame(RANGE_ERROR_TYPE.getImplicitPrototype(), REFERENCE_ERROR_TYPE.getImplicitPrototype()); assertNotSame(RANGE_ERROR_TYPE.getImplicitPrototype(), SYNTAX_ERROR_TYPE.getImplicitPrototype()); assertNotSame(RANGE_ERROR_TYPE.getImplicitPrototype(), TYPE_ERROR_TYPE.getImplicitPrototype()); assertNotSame(REFERENCE_ERROR_TYPE.getImplicitPrototype(), SYNTAX_ERROR_TYPE.getImplicitPrototype()); assertNotSame(REFERENCE_ERROR_TYPE.getImplicitPrototype(), TYPE_ERROR_TYPE.getImplicitPrototype()); assertNotSame(SYNTAX_ERROR_TYPE.getImplicitPrototype(), TYPE_ERROR_TYPE.getImplicitPrototype()); } /** * Tests that function instances have their constructor pointer back at the * function that created them. */ public void testInstanceFunctionChaining() throws Exception { // Array assertTypeEquals( ARRAY_FUNCTION_TYPE, ARRAY_TYPE.getConstructor()); // Boolean assertTypeEquals( BOOLEAN_OBJECT_FUNCTION_TYPE, BOOLEAN_OBJECT_TYPE.getConstructor()); // Date assertTypeEquals( DATE_FUNCTION_TYPE, DATE_TYPE.getConstructor()); // Error assertTypeEquals( ERROR_FUNCTION_TYPE, ERROR_TYPE.getConstructor()); // EvalError assertTypeEquals( EVAL_ERROR_FUNCTION_TYPE, EVAL_ERROR_TYPE.getConstructor()); // Number assertTypeEquals( NUMBER_OBJECT_FUNCTION_TYPE, NUMBER_OBJECT_TYPE.getConstructor()); // Object assertTypeEquals( OBJECT_FUNCTION_TYPE, OBJECT_TYPE.getConstructor()); // RangeError assertTypeEquals( RANGE_ERROR_FUNCTION_TYPE, RANGE_ERROR_TYPE.getConstructor()); // ReferenceError assertTypeEquals( REFERENCE_ERROR_FUNCTION_TYPE, REFERENCE_ERROR_TYPE.getConstructor()); // RegExp assertTypeEquals(REGEXP_FUNCTION_TYPE, REGEXP_TYPE.getConstructor()); // String assertTypeEquals( STRING_OBJECT_FUNCTION_TYPE, STRING_OBJECT_TYPE.getConstructor()); // SyntaxError assertTypeEquals( SYNTAX_ERROR_FUNCTION_TYPE, SYNTAX_ERROR_TYPE.getConstructor()); // TypeError assertTypeEquals( TYPE_ERROR_FUNCTION_TYPE, TYPE_ERROR_TYPE.getConstructor()); // URIError assertTypeEquals( URI_ERROR_FUNCTION_TYPE, URI_ERROR_TYPE.getConstructor()); } /** * Tests that the method {@link JSType#canTestForEqualityWith(JSType)} handles * special corner cases. */ @SuppressWarnings("checked") public void testCanTestForEqualityWithCornerCases() { // null == undefined is always true assertCannotTestForEqualityWith(NULL_TYPE, VOID_TYPE); // (Object,null) == undefined could be true or false UnionType nullableObject = (UnionType) createUnionType(OBJECT_TYPE, NULL_TYPE); assertCanTestForEqualityWith(nullableObject, VOID_TYPE); assertCanTestForEqualityWith(VOID_TYPE, nullableObject); } /** * Tests the {@link JSType#testForEquality(JSType)} method. */ public void testTestForEquality() { compare(TRUE, NO_OBJECT_TYPE, NO_OBJECT_TYPE); compare(UNKNOWN, ALL_TYPE, ALL_TYPE); compare(TRUE, NO_TYPE, NO_TYPE); compare(UNKNOWN, NO_RESOLVED_TYPE, NO_RESOLVED_TYPE); compare(UNKNOWN, NO_OBJECT_TYPE, NUMBER_TYPE); compare(UNKNOWN, ALL_TYPE, NUMBER_TYPE); compare(UNKNOWN, NO_TYPE, NUMBER_TYPE); compare(FALSE, NULL_TYPE, BOOLEAN_TYPE); compare(TRUE, NULL_TYPE, NULL_TYPE); compare(FALSE, NULL_TYPE, NUMBER_TYPE); compare(FALSE, NULL_TYPE, OBJECT_TYPE); compare(FALSE, NULL_TYPE, STRING_TYPE); compare(TRUE, NULL_TYPE, VOID_TYPE); compare(UNKNOWN, NULL_TYPE, createUnionType(UNKNOWN_TYPE, VOID_TYPE)); compare(UNKNOWN, NULL_TYPE, createUnionType(OBJECT_TYPE, VOID_TYPE)); compare(UNKNOWN, NULL_TYPE, unresolvedNamedType); compare(UNKNOWN, NULL_TYPE, createUnionType(unresolvedNamedType, DATE_TYPE)); compare(FALSE, VOID_TYPE, REGEXP_TYPE); compare(TRUE, VOID_TYPE, VOID_TYPE); compare(UNKNOWN, VOID_TYPE, createUnionType(REGEXP_TYPE, VOID_TYPE)); compare(UNKNOWN, NUMBER_TYPE, BOOLEAN_TYPE); compare(UNKNOWN, NUMBER_TYPE, NUMBER_TYPE); compare(UNKNOWN, NUMBER_TYPE, OBJECT_TYPE); compare(UNKNOWN, ARRAY_TYPE, BOOLEAN_TYPE); compare(UNKNOWN, OBJECT_TYPE, BOOLEAN_TYPE); compare(UNKNOWN, OBJECT_TYPE, STRING_TYPE); compare(UNKNOWN, STRING_TYPE, STRING_TYPE); compare(UNKNOWN, STRING_TYPE, BOOLEAN_TYPE); compare(UNKNOWN, STRING_TYPE, NUMBER_TYPE); compare(FALSE, STRING_TYPE, VOID_TYPE); compare(FALSE, STRING_TYPE, NULL_TYPE); compare(FALSE, STRING_TYPE, createUnionType(NULL_TYPE, VOID_TYPE)); compare(UNKNOWN, UNKNOWN_TYPE, BOOLEAN_TYPE); compare(UNKNOWN, UNKNOWN_TYPE, NULL_TYPE); compare(UNKNOWN, UNKNOWN_TYPE, VOID_TYPE); compare(FALSE, U2U_CONSTRUCTOR_TYPE, BOOLEAN_TYPE); compare(FALSE, U2U_CONSTRUCTOR_TYPE, NUMBER_TYPE); compare(FALSE, U2U_CONSTRUCTOR_TYPE, STRING_TYPE); compare(FALSE, U2U_CONSTRUCTOR_TYPE, VOID_TYPE); compare(FALSE, U2U_CONSTRUCTOR_TYPE, NULL_TYPE); compare(UNKNOWN, U2U_CONSTRUCTOR_TYPE, OBJECT_TYPE); compare(UNKNOWN, U2U_CONSTRUCTOR_TYPE, ALL_TYPE); compare(UNKNOWN, NULL_TYPE, subclassOfUnresolvedNamedType); JSType functionAndNull = createUnionType(NULL_TYPE, dateMethod); compare(UNKNOWN, functionAndNull, dateMethod); compare(UNKNOWN, NULL_TYPE, NO_TYPE); compare(UNKNOWN, VOID_TYPE, NO_TYPE); compare(UNKNOWN, NULL_TYPE, unresolvedNamedType); compare(UNKNOWN, VOID_TYPE, unresolvedNamedType); compare(TRUE, NO_TYPE, NO_TYPE); } private void compare(TernaryValue r, JSType t1, JSType t2) { assertEquals(r, t1.testForEquality(t2)); assertEquals(r, t2.testForEquality(t1)); } private void assertCanTestForEqualityWith(JSType t1, JSType t2) { assertTrue(t1.canTestForEqualityWith(t2)); assertTrue(t2.canTestForEqualityWith(t1)); } private void assertCannotTestForEqualityWith(JSType t1, JSType t2) { assertFalse(t1.canTestForEqualityWith(t2)); assertFalse(t2.canTestForEqualityWith(t1)); } /** * Tests the subtyping relationships among simple types. */ public void testSubtypingSimpleTypes() throws Exception { // Any assertTrue(NO_TYPE.isSubtype(NO_TYPE)); assertTrue(NO_TYPE.isSubtype(NO_OBJECT_TYPE)); assertTrue(NO_TYPE.isSubtype(ARRAY_TYPE)); assertTrue(NO_TYPE.isSubtype(BOOLEAN_TYPE)); assertTrue(NO_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE)); assertTrue(NO_TYPE.isSubtype(DATE_TYPE)); assertTrue(NO_TYPE.isSubtype(ERROR_TYPE)); assertTrue(NO_TYPE.isSubtype(EVAL_ERROR_TYPE)); assertTrue(NO_TYPE.isSubtype(functionType)); assertTrue(NO_TYPE.isSubtype(NULL_TYPE)); assertTrue(NO_TYPE.isSubtype(NUMBER_TYPE)); assertTrue(NO_TYPE.isSubtype(NUMBER_OBJECT_TYPE)); assertTrue(NO_TYPE.isSubtype(OBJECT_TYPE)); assertTrue(NO_TYPE.isSubtype(URI_ERROR_TYPE)); assertTrue(NO_TYPE.isSubtype(RANGE_ERROR_TYPE)); assertTrue(NO_TYPE.isSubtype(REFERENCE_ERROR_TYPE)); assertTrue(NO_TYPE.isSubtype(REGEXP_TYPE)); assertTrue(NO_TYPE.isSubtype(STRING_TYPE)); assertTrue(NO_TYPE.isSubtype(STRING_OBJECT_TYPE)); assertTrue(NO_TYPE.isSubtype(SYNTAX_ERROR_TYPE)); assertTrue(NO_TYPE.isSubtype(TYPE_ERROR_TYPE)); assertTrue(NO_TYPE.isSubtype(ALL_TYPE)); assertTrue(NO_TYPE.isSubtype(VOID_TYPE)); // AnyObject assertFalse(NO_OBJECT_TYPE.isSubtype(NO_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(NO_OBJECT_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(ARRAY_TYPE)); assertFalse(NO_OBJECT_TYPE.isSubtype(BOOLEAN_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(DATE_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(ERROR_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(EVAL_ERROR_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(functionType)); assertFalse(NO_OBJECT_TYPE.isSubtype(NULL_TYPE)); assertFalse(NO_OBJECT_TYPE.isSubtype(NUMBER_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(NUMBER_OBJECT_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(OBJECT_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(URI_ERROR_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(RANGE_ERROR_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(REFERENCE_ERROR_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(REGEXP_TYPE)); assertFalse(NO_OBJECT_TYPE.isSubtype(STRING_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(STRING_OBJECT_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(SYNTAX_ERROR_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(TYPE_ERROR_TYPE)); assertTrue(NO_OBJECT_TYPE.isSubtype(ALL_TYPE)); assertFalse(NO_OBJECT_TYPE.isSubtype(VOID_TYPE)); // Array assertFalse(ARRAY_TYPE.isSubtype(NO_TYPE)); assertFalse(ARRAY_TYPE.isSubtype(NO_OBJECT_TYPE)); assertTrue(ARRAY_TYPE.isSubtype(ARRAY_TYPE)); assertFalse(ARRAY_TYPE.isSubtype(BOOLEAN_TYPE)); assertFalse(ARRAY_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE)); assertFalse(ARRAY_TYPE.isSubtype(DATE_TYPE)); assertFalse(ARRAY_TYPE.isSubtype(ERROR_TYPE)); assertFalse(ARRAY_TYPE.isSubtype(EVAL_ERROR_TYPE)); assertFalse(ARRAY_TYPE.isSubtype(functionType)); assertFalse(ARRAY_TYPE.isSubtype(NULL_TYPE)); assertFalse(ARRAY_TYPE.isSubtype(NUMBER_TYPE)); assertFalse(ARRAY_TYPE.isSubtype(NUMBER_OBJECT_TYPE)); assertTrue(ARRAY_TYPE.isSubtype(OBJECT_TYPE)); assertFalse(ARRAY_TYPE.isSubtype(URI_ERROR_TYPE)); assertFalse(ARRAY_TYPE.isSubtype(RANGE_ERROR_TYPE)); assertFalse(ARRAY_TYPE.isSubtype(REFERENCE_ERROR_TYPE)); assertFalse(ARRAY_TYPE.isSubtype(REGEXP_TYPE)); assertFalse(ARRAY_TYPE.isSubtype(STRING_TYPE)); assertFalse(ARRAY_TYPE.isSubtype(STRING_OBJECT_TYPE)); assertFalse(ARRAY_TYPE.isSubtype(SYNTAX_ERROR_TYPE)); assertFalse(ARRAY_TYPE.isSubtype(TYPE_ERROR_TYPE)); assertTrue(ARRAY_TYPE.isSubtype(ALL_TYPE)); assertFalse(ARRAY_TYPE.isSubtype(VOID_TYPE)); // boolean assertFalse(BOOLEAN_TYPE.isSubtype(NO_TYPE)); assertFalse(BOOLEAN_TYPE.isSubtype(NO_OBJECT_TYPE)); assertFalse(BOOLEAN_TYPE.isSubtype(ARRAY_TYPE)); assertTrue(BOOLEAN_TYPE.isSubtype(BOOLEAN_TYPE)); assertFalse(BOOLEAN_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE)); assertFalse(BOOLEAN_TYPE.isSubtype(DATE_TYPE)); assertFalse(BOOLEAN_TYPE.isSubtype(ERROR_TYPE)); assertFalse(BOOLEAN_TYPE.isSubtype(EVAL_ERROR_TYPE)); assertFalse(BOOLEAN_TYPE.isSubtype(functionType)); assertFalse(BOOLEAN_TYPE.isSubtype(NULL_TYPE)); assertFalse(BOOLEAN_TYPE.isSubtype(NUMBER_TYPE)); assertFalse(BOOLEAN_TYPE.isSubtype(NUMBER_OBJECT_TYPE)); assertFalse(BOOLEAN_TYPE.isSubtype(OBJECT_TYPE)); assertFalse(BOOLEAN_TYPE.isSubtype(URI_ERROR_TYPE)); assertFalse(BOOLEAN_TYPE.isSubtype(RANGE_ERROR_TYPE)); assertFalse(BOOLEAN_TYPE.isSubtype(REFERENCE_ERROR_TYPE)); assertFalse(BOOLEAN_TYPE.isSubtype(REGEXP_TYPE)); assertFalse(BOOLEAN_TYPE.isSubtype(STRING_TYPE)); assertFalse(BOOLEAN_TYPE.isSubtype(STRING_OBJECT_TYPE)); assertFalse(BOOLEAN_TYPE.isSubtype(SYNTAX_ERROR_TYPE)); assertFalse(BOOLEAN_TYPE.isSubtype(TYPE_ERROR_TYPE)); assertTrue(BOOLEAN_TYPE.isSubtype(ALL_TYPE)); assertFalse(BOOLEAN_TYPE.isSubtype(VOID_TYPE)); // Boolean assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(NO_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(NO_OBJECT_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(ARRAY_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(BOOLEAN_TYPE)); assertTrue(BOOLEAN_OBJECT_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(DATE_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(ERROR_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(EVAL_ERROR_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(functionType)); assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(NULL_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(NUMBER_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(NUMBER_OBJECT_TYPE)); assertTrue(BOOLEAN_OBJECT_TYPE.isSubtype(OBJECT_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(URI_ERROR_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(RANGE_ERROR_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(REFERENCE_ERROR_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(REGEXP_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(STRING_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(STRING_OBJECT_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(SYNTAX_ERROR_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(TYPE_ERROR_TYPE)); assertTrue(BOOLEAN_OBJECT_TYPE.isSubtype(ALL_TYPE)); assertFalse(BOOLEAN_OBJECT_TYPE.isSubtype(VOID_TYPE)); // Date assertFalse(DATE_TYPE.isSubtype(NO_TYPE)); assertFalse(DATE_TYPE.isSubtype(NO_OBJECT_TYPE)); assertFalse(DATE_TYPE.isSubtype(ARRAY_TYPE)); assertFalse(DATE_TYPE.isSubtype(BOOLEAN_TYPE)); assertFalse(DATE_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE)); assertTrue(DATE_TYPE.isSubtype(DATE_TYPE)); assertFalse(DATE_TYPE.isSubtype(ERROR_TYPE)); assertFalse(DATE_TYPE.isSubtype(EVAL_ERROR_TYPE)); assertFalse(DATE_TYPE.isSubtype(functionType)); assertFalse(DATE_TYPE.isSubtype(NULL_TYPE)); assertFalse(DATE_TYPE.isSubtype(NUMBER_TYPE)); assertFalse(DATE_TYPE.isSubtype(NUMBER_OBJECT_TYPE)); assertTrue(DATE_TYPE.isSubtype(OBJECT_TYPE)); assertFalse(DATE_TYPE.isSubtype(URI_ERROR_TYPE)); assertFalse(DATE_TYPE.isSubtype(RANGE_ERROR_TYPE)); assertFalse(DATE_TYPE.isSubtype(REFERENCE_ERROR_TYPE)); assertFalse(DATE_TYPE.isSubtype(REGEXP_TYPE)); assertFalse(DATE_TYPE.isSubtype(STRING_TYPE)); assertFalse(DATE_TYPE.isSubtype(STRING_OBJECT_TYPE)); assertFalse(DATE_TYPE.isSubtype(SYNTAX_ERROR_TYPE)); assertFalse(DATE_TYPE.isSubtype(TYPE_ERROR_TYPE)); assertTrue(DATE_TYPE.isSubtype(ALL_TYPE)); assertFalse(DATE_TYPE.isSubtype(VOID_TYPE)); // Error assertFalse(ERROR_TYPE.isSubtype(NO_TYPE)); assertFalse(ERROR_TYPE.isSubtype(NO_OBJECT_TYPE)); assertFalse(ERROR_TYPE.isSubtype(ARRAY_TYPE)); assertFalse(ERROR_TYPE.isSubtype(BOOLEAN_TYPE)); assertFalse(ERROR_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE)); assertFalse(ERROR_TYPE.isSubtype(DATE_TYPE)); assertTrue(ERROR_TYPE.isSubtype(ERROR_TYPE)); assertFalse(ERROR_TYPE.isSubtype(EVAL_ERROR_TYPE)); assertFalse(ERROR_TYPE.isSubtype(functionType)); assertFalse(ERROR_TYPE.isSubtype(NULL_TYPE)); assertFalse(ERROR_TYPE.isSubtype(NUMBER_TYPE)); assertFalse(ERROR_TYPE.isSubtype(NUMBER_OBJECT_TYPE)); assertTrue(ERROR_TYPE.isSubtype(OBJECT_TYPE)); assertFalse(ERROR_TYPE.isSubtype(URI_ERROR_TYPE)); assertFalse(ERROR_TYPE.isSubtype(RANGE_ERROR_TYPE)); assertFalse(ERROR_TYPE.isSubtype(REFERENCE_ERROR_TYPE)); assertFalse(ERROR_TYPE.isSubtype(REGEXP_TYPE)); assertFalse(ERROR_TYPE.isSubtype(STRING_TYPE)); assertFalse(ERROR_TYPE.isSubtype(STRING_OBJECT_TYPE)); assertFalse(ERROR_TYPE.isSubtype(SYNTAX_ERROR_TYPE)); assertFalse(ERROR_TYPE.isSubtype(TYPE_ERROR_TYPE)); assertTrue(ERROR_TYPE.isSubtype(ALL_TYPE)); assertFalse(ERROR_TYPE.isSubtype(VOID_TYPE)); // EvalError assertFalse(EVAL_ERROR_TYPE.isSubtype(NO_TYPE)); assertFalse(EVAL_ERROR_TYPE.isSubtype(NO_OBJECT_TYPE)); assertFalse(EVAL_ERROR_TYPE.isSubtype(ARRAY_TYPE)); assertFalse(EVAL_ERROR_TYPE.isSubtype(BOOLEAN_TYPE)); assertFalse(EVAL_ERROR_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE)); assertFalse(ERROR_TYPE.isSubtype(DATE_TYPE)); assertTrue(EVAL_ERROR_TYPE.isSubtype(ERROR_TYPE)); assertTrue(EVAL_ERROR_TYPE.isSubtype(EVAL_ERROR_TYPE)); assertFalse(EVAL_ERROR_TYPE.isSubtype(functionType)); assertFalse(EVAL_ERROR_TYPE.isSubtype(NULL_TYPE)); assertFalse(EVAL_ERROR_TYPE.isSubtype(NUMBER_TYPE)); assertFalse(EVAL_ERROR_TYPE.isSubtype(NUMBER_OBJECT_TYPE)); assertTrue(EVAL_ERROR_TYPE.isSubtype(OBJECT_TYPE)); assertFalse(EVAL_ERROR_TYPE.isSubtype(URI_ERROR_TYPE)); assertFalse(EVAL_ERROR_TYPE.isSubtype(RANGE_ERROR_TYPE)); assertFalse(EVAL_ERROR_TYPE.isSubtype(REFERENCE_ERROR_TYPE)); assertFalse(EVAL_ERROR_TYPE.isSubtype(REGEXP_TYPE)); assertFalse(EVAL_ERROR_TYPE.isSubtype(STRING_TYPE)); assertFalse(EVAL_ERROR_TYPE.isSubtype(STRING_OBJECT_TYPE)); assertFalse(EVAL_ERROR_TYPE.isSubtype(SYNTAX_ERROR_TYPE)); assertFalse(EVAL_ERROR_TYPE.isSubtype(TYPE_ERROR_TYPE)); assertTrue(EVAL_ERROR_TYPE.isSubtype(ALL_TYPE)); assertFalse(EVAL_ERROR_TYPE.isSubtype(VOID_TYPE)); // RangeError assertTrue(RANGE_ERROR_TYPE.isSubtype(ERROR_TYPE)); // ReferenceError assertTrue(REFERENCE_ERROR_TYPE.isSubtype(ERROR_TYPE)); // TypeError assertTrue(TYPE_ERROR_TYPE.isSubtype(ERROR_TYPE)); // UriError assertTrue(URI_ERROR_TYPE.isSubtype(ERROR_TYPE)); // Unknown assertFalse(ALL_TYPE.isSubtype(NO_TYPE)); assertFalse(ALL_TYPE.isSubtype(NO_OBJECT_TYPE)); assertFalse(ALL_TYPE.isSubtype(ARRAY_TYPE)); assertFalse(ALL_TYPE.isSubtype(BOOLEAN_TYPE)); assertFalse(ALL_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE)); assertFalse(ERROR_TYPE.isSubtype(DATE_TYPE)); assertFalse(ALL_TYPE.isSubtype(ERROR_TYPE)); assertFalse(ALL_TYPE.isSubtype(EVAL_ERROR_TYPE)); assertFalse(ALL_TYPE.isSubtype(functionType)); assertFalse(ALL_TYPE.isSubtype(NULL_TYPE)); assertFalse(ALL_TYPE.isSubtype(NUMBER_TYPE)); assertFalse(ALL_TYPE.isSubtype(NUMBER_OBJECT_TYPE)); assertFalse(ALL_TYPE.isSubtype(OBJECT_TYPE)); assertFalse(ALL_TYPE.isSubtype(URI_ERROR_TYPE)); assertFalse(ALL_TYPE.isSubtype(RANGE_ERROR_TYPE)); assertFalse(ALL_TYPE.isSubtype(REFERENCE_ERROR_TYPE)); assertFalse(ALL_TYPE.isSubtype(REGEXP_TYPE)); assertFalse(ALL_TYPE.isSubtype(STRING_TYPE)); assertFalse(ALL_TYPE.isSubtype(STRING_OBJECT_TYPE)); assertFalse(ALL_TYPE.isSubtype(SYNTAX_ERROR_TYPE)); assertFalse(ALL_TYPE.isSubtype(TYPE_ERROR_TYPE)); assertTrue(ALL_TYPE.isSubtype(ALL_TYPE)); assertFalse(ALL_TYPE.isSubtype(VOID_TYPE)); } /** * Tests that the Object type is the greatest element (top) of the object * hierarchy. */ public void testSubtypingObjectTopOfObjects() throws Exception { assertTrue(OBJECT_TYPE.isSubtype(OBJECT_TYPE)); assertTrue(createUnionType(DATE_TYPE, REGEXP_TYPE).isSubtype(OBJECT_TYPE)); assertTrue(createUnionType(OBJECT_TYPE, NO_OBJECT_TYPE). isSubtype(OBJECT_TYPE)); assertTrue(functionType.isSubtype(OBJECT_TYPE)); } public void testSubtypingFunctionPrototypeType() throws Exception { FunctionType sub1 = registry.createConstructorType(null, null, null, null); sub1.setPrototypeBasedOn(googBar); FunctionType sub2 = registry.createConstructorType(null, null, null, null); sub2.setPrototypeBasedOn(googBar); ObjectType o1 = sub1.getInstanceType(); ObjectType o2 = sub2.getInstanceType(); assertFalse(o1.isSubtype(o2)); assertFalse(o1.getImplicitPrototype().isSubtype(o2.getImplicitPrototype())); assertTrue(o1.getImplicitPrototype().isSubtype(googBar)); assertTrue(o2.getImplicitPrototype().isSubtype(googBar)); } public void testSubtypingFunctionFixedArgs() throws Exception { FunctionType f1 = registry.createFunctionType(OBJECT_TYPE, false, BOOLEAN_TYPE); FunctionType f2 = registry.createFunctionType(STRING_OBJECT_TYPE, false, BOOLEAN_TYPE); assertTrue(f1.isSubtype(f1)); assertFalse(f1.isSubtype(f2)); assertTrue(f2.isSubtype(f1)); assertTrue(f2.isSubtype(f2)); assertTrue(f1.isSubtype(U2U_CONSTRUCTOR_TYPE)); assertTrue(f2.isSubtype(U2U_CONSTRUCTOR_TYPE)); assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(f1)); assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(f2)); } public void testSubtypingFunctionMultipleFixedArgs() throws Exception { FunctionType f1 = registry.createFunctionType(OBJECT_TYPE, false, EVAL_ERROR_TYPE, STRING_TYPE); FunctionType f2 = registry.createFunctionType(STRING_OBJECT_TYPE, false, ERROR_TYPE, ALL_TYPE); assertTrue(f1.isSubtype(f1)); assertFalse(f1.isSubtype(f2)); assertTrue(f2.isSubtype(f1)); assertTrue(f2.isSubtype(f2)); assertTrue(f1.isSubtype(U2U_CONSTRUCTOR_TYPE)); assertTrue(f2.isSubtype(U2U_CONSTRUCTOR_TYPE)); assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(f1)); assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(f2)); } public void testSubtypingFunctionFixedArgsNotMatching() throws Exception { FunctionType f1 = registry.createFunctionType(OBJECT_TYPE, false, EVAL_ERROR_TYPE, UNKNOWN_TYPE); FunctionType f2 = registry.createFunctionType(STRING_OBJECT_TYPE, false, ERROR_TYPE, ALL_TYPE); assertTrue(f1.isSubtype(f1)); assertFalse(f1.isSubtype(f2)); assertTrue(f2.isSubtype(f1)); assertTrue(f2.isSubtype(f2)); assertTrue(f1.isSubtype(U2U_CONSTRUCTOR_TYPE)); assertTrue(f2.isSubtype(U2U_CONSTRUCTOR_TYPE)); assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(f1)); assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(f2)); } public void testSubtypingFunctionVariableArgsOneOnly() throws Exception { // f1 = (EvalError...) -> Object FunctionType f1 = registry.createFunctionType(OBJECT_TYPE, true, EVAL_ERROR_TYPE); // f2 = (Error, Object) -> String FunctionType f2 = registry.createFunctionType(STRING_OBJECT_TYPE, false, ERROR_TYPE, OBJECT_TYPE); assertTrue(f1.isSubtype(f1)); assertFalse(f1.isSubtype(f2)); assertFalse(f2.isSubtype(f1)); assertTrue(f2.isSubtype(f2)); assertTrue(f1.isSubtype(U2U_CONSTRUCTOR_TYPE)); assertTrue(f2.isSubtype(U2U_CONSTRUCTOR_TYPE)); assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(f1)); assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(f2)); } public void testSubtypingFunctionVariableArgsBoth() throws Exception { // f1 = (UriError, EvalError, EvalError...) -> Object FunctionType f1 = registry.createFunctionType(OBJECT_TYPE, true, URI_ERROR_TYPE, EVAL_ERROR_TYPE, EVAL_ERROR_TYPE); // f2 = (Error, Object, EvalError...) -> String FunctionType f2 = registry.createFunctionType(STRING_OBJECT_TYPE, true, ERROR_TYPE, OBJECT_TYPE, EVAL_ERROR_TYPE); assertTrue(f1.isSubtype(f1)); assertFalse(f1.isSubtype(f2)); assertTrue(f2.isSubtype(f1)); assertTrue(f2.isSubtype(f2)); assertTrue(f1.isSubtype(U2U_CONSTRUCTOR_TYPE)); assertTrue(f2.isSubtype(U2U_CONSTRUCTOR_TYPE)); assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(f1)); assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(f2)); } public void testSubtypingMostGeneralFunction() throws Exception { // (EvalError, String) -> Object FunctionType f1 = registry.createFunctionType(OBJECT_TYPE, false, EVAL_ERROR_TYPE, STRING_TYPE); // (string, void) -> number FunctionType f2 = registry.createFunctionType(NUMBER_TYPE, false, STRING_TYPE, VOID_TYPE); // (Date, string, number) -> AnyObject FunctionType f3 = registry.createFunctionType(NO_OBJECT_TYPE, false, DATE_TYPE, STRING_TYPE, NUMBER_TYPE); // (Number) -> Any FunctionType f4 = registry.createFunctionType(NO_TYPE, false, NUMBER_OBJECT_TYPE); // f1 = (EvalError...) -> Object FunctionType f5 = registry.createFunctionType(OBJECT_TYPE, true, EVAL_ERROR_TYPE); // f2 = (Error, Object) -> String FunctionType f6 = registry.createFunctionType(STRING_OBJECT_TYPE, false, ERROR_TYPE, OBJECT_TYPE); // f1 = (UriError, EvalError...) -> Object FunctionType f7 = registry.createFunctionType(OBJECT_TYPE, true, URI_ERROR_TYPE, EVAL_ERROR_TYPE); // f2 = (Error, Object, EvalError...) -> String FunctionType f8 = registry.createFunctionType(STRING_OBJECT_TYPE, true, ERROR_TYPE, OBJECT_TYPE, EVAL_ERROR_TYPE); assertTrue(LEAST_FUNCTION_TYPE.isSubtype(GREATEST_FUNCTION_TYPE)); assertTrue(LEAST_FUNCTION_TYPE.isSubtype(U2U_CONSTRUCTOR_TYPE)); assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(LEAST_FUNCTION_TYPE)); assertFalse(GREATEST_FUNCTION_TYPE.isSubtype(LEAST_FUNCTION_TYPE)); assertTrue(GREATEST_FUNCTION_TYPE.isSubtype(U2U_CONSTRUCTOR_TYPE)); assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(GREATEST_FUNCTION_TYPE)); assertTrue(f1.isSubtype(GREATEST_FUNCTION_TYPE)); assertTrue(f2.isSubtype(GREATEST_FUNCTION_TYPE)); assertTrue(f3.isSubtype(GREATEST_FUNCTION_TYPE)); assertTrue(f4.isSubtype(GREATEST_FUNCTION_TYPE)); assertTrue(f5.isSubtype(GREATEST_FUNCTION_TYPE)); assertTrue(f6.isSubtype(GREATEST_FUNCTION_TYPE)); assertTrue(f7.isSubtype(GREATEST_FUNCTION_TYPE)); assertTrue(f8.isSubtype(GREATEST_FUNCTION_TYPE)); assertFalse(f1.isSubtype(LEAST_FUNCTION_TYPE)); assertFalse(f2.isSubtype(LEAST_FUNCTION_TYPE)); assertFalse(f3.isSubtype(LEAST_FUNCTION_TYPE)); assertFalse(f4.isSubtype(LEAST_FUNCTION_TYPE)); assertFalse(f5.isSubtype(LEAST_FUNCTION_TYPE)); assertFalse(f6.isSubtype(LEAST_FUNCTION_TYPE)); assertFalse(f7.isSubtype(LEAST_FUNCTION_TYPE)); assertFalse(f8.isSubtype(LEAST_FUNCTION_TYPE)); assertTrue(LEAST_FUNCTION_TYPE.isSubtype(f1)); assertTrue(LEAST_FUNCTION_TYPE.isSubtype(f2)); assertTrue(LEAST_FUNCTION_TYPE.isSubtype(f3)); assertTrue(LEAST_FUNCTION_TYPE.isSubtype(f4)); assertTrue(LEAST_FUNCTION_TYPE.isSubtype(f5)); assertTrue(LEAST_FUNCTION_TYPE.isSubtype(f6)); assertTrue(LEAST_FUNCTION_TYPE.isSubtype(f7)); assertTrue(LEAST_FUNCTION_TYPE.isSubtype(f8)); assertFalse(GREATEST_FUNCTION_TYPE.isSubtype(f1)); assertFalse(GREATEST_FUNCTION_TYPE.isSubtype(f2)); assertFalse(GREATEST_FUNCTION_TYPE.isSubtype(f3)); assertFalse(GREATEST_FUNCTION_TYPE.isSubtype(f4)); assertFalse(GREATEST_FUNCTION_TYPE.isSubtype(f5)); assertFalse(GREATEST_FUNCTION_TYPE.isSubtype(f6)); assertFalse(GREATEST_FUNCTION_TYPE.isSubtype(f7)); assertFalse(GREATEST_FUNCTION_TYPE.isSubtype(f8)); } /** * Types to test for symmetrical relationships. */ private List<JSType> getTypesToTestForSymmetry() { return Lists.newArrayList( UNKNOWN_TYPE, NULL_TYPE, VOID_TYPE, NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE, OBJECT_TYPE, U2U_CONSTRUCTOR_TYPE, LEAST_FUNCTION_TYPE, GREATEST_FUNCTION_TYPE, ALL_TYPE, NO_TYPE, NO_OBJECT_TYPE, NO_RESOLVED_TYPE, createUnionType(BOOLEAN_TYPE, STRING_TYPE), createUnionType(NUMBER_TYPE, STRING_TYPE), createUnionType(NULL_TYPE, dateMethod), createUnionType(UNKNOWN_TYPE, dateMethod), createUnionType(namedGoogBar, dateMethod), createUnionType(NULL_TYPE, unresolvedNamedType), enumType, elementsType, dateMethod, functionType, unresolvedNamedType, googBar, namedGoogBar, googBar.getInstanceType(), namedGoogBar, subclassOfUnresolvedNamedType, subclassCtor, recordType, forwardDeclaredNamedType, createUnionType(forwardDeclaredNamedType, NULL_TYPE), createParameterizedType(OBJECT_TYPE, STRING_TYPE), createParameterizedType(OBJECT_TYPE, NUMBER_TYPE), createParameterizedType(ARRAY_TYPE, STRING_TYPE), createParameterizedType(ARRAY_TYPE, NUMBER_TYPE), createUnionType( createParameterizedType(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), createUnionType( createParameterizedType(OBJECT_TYPE, BOOLEAN_TYPE), NULL_TYPE) ); } public void testSymmetryOfTestForEquality() { List<JSType> listA = getTypesToTestForSymmetry(); List<JSType> listB = getTypesToTestForSymmetry(); for (JSType typeA : listA) { for (JSType typeB : listB) { TernaryValue aOnB = typeA.testForEquality(typeB); TernaryValue bOnA = typeB.testForEquality(typeA); assertTrue( String.format("testForEquality not symmetrical:\n" + "typeA: %s\ntypeB: %s\n" + "a.testForEquality(b): %s\n" + "b.testForEquality(a): %s\n", typeA, typeB, aOnB, bOnA), aOnB == bOnA); } } } /** * Tests that getLeastSupertype is a symmetric relation. */ public void testSymmetryOfLeastSupertype() { List<JSType> listA = getTypesToTestForSymmetry(); List<JSType> listB = getTypesToTestForSymmetry(); for (JSType typeA : listA) { for (JSType typeB : listB) { JSType aOnB = typeA.getLeastSupertype(typeB); JSType bOnA = typeB.getLeastSupertype(typeA); // Use a custom assert message instead of the normal assertTypeEquals, // to make it more helpful. assertTrue( String.format("getLeastSupertype not symmetrical:\n" + "typeA: %s\ntypeB: %s\n" + "a.getLeastSupertype(b): %s\n" + "b.getLeastSupertype(a): %s\n", typeA, typeB, aOnB, bOnA), aOnB.isEquivalentTo(bOnA)); } } } public void testWeirdBug() { assertTypeNotEquals(googBar, googBar.getInstanceType()); assertFalse(googBar.isSubtype(googBar.getInstanceType())); assertFalse(googBar.getInstanceType().isSubtype(googBar)); } /** * Tests that getGreatestSubtype is a symmetric relation. */ public void testSymmetryOfGreatestSubtype() { List<JSType> listA = getTypesToTestForSymmetry(); List<JSType> listB = getTypesToTestForSymmetry(); for (JSType typeA : listA) { for (JSType typeB : listB) { JSType aOnB = typeA.getGreatestSubtype(typeB); JSType bOnA = typeB.getGreatestSubtype(typeA); // Use a custom assert message instead of the normal assertTypeEquals, // to make it more helpful. assertTrue( String.format("getGreatestSubtype not symmetrical:\n" + "typeA: %s\ntypeB: %s\n" + "a.getGreatestSubtype(b): %s\n" + "b.getGreatestSubtype(a): %s\n", typeA, typeB, aOnB, bOnA), aOnB.isEquivalentTo(bOnA)); } } } /** * Tests that getLeastSupertype is a reflexive relation. */ public void testReflexivityOfLeastSupertype() { List<JSType> list = getTypesToTestForSymmetry(); for (JSType type : list) { assertTypeEquals("getLeastSupertype not reflexive", type, type.getLeastSupertype(type)); } } /** * Tests that getGreatestSubtype is a reflexive relation. */ public void testReflexivityOfGreatestSubtype() { List<JSType> list = getTypesToTestForSymmetry(); for (JSType type : list) { assertTypeEquals("getGreatestSubtype not reflexive", type, type.getGreatestSubtype(type)); } } /** * Tests {@link JSType#getLeastSupertype(JSType)} for unresolved named types. */ public void testLeastSupertypeUnresolvedNamedType() { // (undefined,function(?):?) and ? unresolved named type JSType expected = registry.createUnionType( unresolvedNamedType, U2U_FUNCTION_TYPE); assertTypeEquals(expected, unresolvedNamedType.getLeastSupertype(U2U_FUNCTION_TYPE)); assertTypeEquals(expected, U2U_FUNCTION_TYPE.getLeastSupertype(unresolvedNamedType)); assertEquals("(function (...[?]): ?|not.resolved.named.type)", expected.toString()); } public void testLeastSupertypeUnresolvedNamedType2() { JSType expected = registry.createUnionType( unresolvedNamedType, UNKNOWN_TYPE); assertTypeEquals(expected, unresolvedNamedType.getLeastSupertype(UNKNOWN_TYPE)); assertTypeEquals(expected, UNKNOWN_TYPE.getLeastSupertype(unresolvedNamedType)); assertTypeEquals(UNKNOWN_TYPE, expected); } public void testLeastSupertypeUnresolvedNamedType3() { JSType expected = registry.createUnionType( unresolvedNamedType, CHECKED_UNKNOWN_TYPE); assertTypeEquals(expected, unresolvedNamedType.getLeastSupertype(CHECKED_UNKNOWN_TYPE)); assertTypeEquals(expected, CHECKED_UNKNOWN_TYPE.getLeastSupertype(unresolvedNamedType)); assertTypeEquals(CHECKED_UNKNOWN_TYPE, expected); } /** Tests the subclass of an unresolved named type */ public void testSubclassOfUnresolvedNamedType() { assertTrue(subclassOfUnresolvedNamedType.isUnknownType()); } /** * Tests that Proxied FunctionTypes behave the same over getLeastSupertype and * getGreatestSubtype as non proxied FunctionTypes */ public void testSupertypeOfProxiedFunctionTypes() { ObjectType fn1 = new FunctionBuilder(registry) .withParamsNode(new Node(Token.PARAM_LIST)) .withReturnType(NUMBER_TYPE) .build(); ObjectType fn2 = new FunctionBuilder(registry) .withParamsNode(new Node(Token.PARAM_LIST)) .withReturnType(STRING_TYPE) .build(); ObjectType p1 = new ProxyObjectType(registry, fn1); ObjectType p2 = new ProxyObjectType(registry, fn2); ObjectType supremum = new FunctionBuilder(registry) .withParamsNode(new Node(Token.PARAM_LIST)) .withReturnType(registry.createUnionType(STRING_TYPE, NUMBER_TYPE)) .build(); assertTypeEquals(fn1.getLeastSupertype(fn2), p1.getLeastSupertype(p2)); assertTypeEquals(supremum, fn1.getLeastSupertype(fn2)); assertTypeEquals(supremum, fn1.getLeastSupertype(p2)); assertTypeEquals(supremum, p1.getLeastSupertype(fn2)); assertTypeEquals(supremum, p1.getLeastSupertype(p2)); } public void testTypeOfThisIsProxied() { ObjectType fnType = new FunctionBuilder(registry) .withReturnType(NUMBER_TYPE).withTypeOfThis(OBJECT_TYPE).build(); ObjectType proxyType = new ProxyObjectType(registry, fnType); assertTypeEquals(fnType.getTypeOfThis(), proxyType.getTypeOfThis()); } /** * Tests the {@link NamedType#equals} function, which had a bug in it. */ public void testNamedTypeEquals() { JSTypeRegistry jst = new JSTypeRegistry(null); // test == if references are equal NamedType a = new NamedType(jst, "type1", "source", 1, 0); NamedType b = new NamedType(jst, "type1", "source", 1, 0); assertTrue(a.isEquivalentTo(b)); // test == instance of referenced type assertTrue(namedGoogBar.isEquivalentTo(googBar.getInstanceType())); assertTrue(googBar.getInstanceType().isEquivalentTo(namedGoogBar)); } /** * Tests the {@link NamedType#equals} function against other types. */ public void testNamedTypeEquals2() { // test == if references are equal NamedType a = new NamedType(registry, "typeA", "source", 1, 0); NamedType b = new NamedType(registry, "typeB", "source", 1, 0); ObjectType realA = registry.createConstructorType( "typeA", null, null, null, null).getInstanceType(); ObjectType realB = registry.createEnumType( "typeB", null, NUMBER_TYPE).getElementsType(); registry.declareType("typeA", realA); registry.declareType("typeB", realB); assertTypeEquals(a, realA); assertTypeEquals(b, realB); a.resolve(null, null); b.resolve(null, null); assertTrue(a.isResolved()); assertTrue(b.isResolved()); assertTypeEquals(a, realA); assertTypeEquals(b, realB); JSType resolvedA = Asserts.assertValidResolve(a); assertNotSame(resolvedA, a); assertSame(resolvedA, realA); JSType resolvedB = Asserts.assertValidResolve(b); assertNotSame(resolvedB, b); assertSame(resolvedB, realB); } /** * Tests the {@link NamedType#equals} function against other types * when it's forward-declared. */ public void testForwardDeclaredNamedTypeEquals() { // test == if references are equal NamedType a = new NamedType(registry, "typeA", "source", 1, 0); NamedType b = new NamedType(registry, "typeA", "source", 1, 0); registry.forwardDeclareType("typeA"); assertTypeEquals(a, b); a.resolve(null, EMPTY_SCOPE); assertTrue(a.isResolved()); assertFalse(b.isResolved()); assertTypeEquals(a, b); assertFalse(a.isEquivalentTo(UNKNOWN_TYPE)); assertFalse(b.isEquivalentTo(UNKNOWN_TYPE)); assertTrue(a.isEmptyType()); assertFalse(a.isNoType()); assertTrue(a.isNoResolvedType()); } public void testForwardDeclaredNamedType() { NamedType a = new NamedType(registry, "typeA", "source", 1, 0); registry.forwardDeclareType("typeA"); assertTypeEquals(UNKNOWN_TYPE, a.getLeastSupertype(UNKNOWN_TYPE)); assertTypeEquals(CHECKED_UNKNOWN_TYPE, a.getLeastSupertype(CHECKED_UNKNOWN_TYPE)); assertTypeEquals(UNKNOWN_TYPE, UNKNOWN_TYPE.getLeastSupertype(a)); assertTypeEquals(CHECKED_UNKNOWN_TYPE, CHECKED_UNKNOWN_TYPE.getLeastSupertype(a)); } /** * Tests {@link JSType#getGreatestSubtype(JSType)} on simple types. */ public void testGreatestSubtypeSimpleTypes() { assertTypeEquals(ARRAY_TYPE, ARRAY_TYPE.getGreatestSubtype(ALL_TYPE)); assertTypeEquals(ARRAY_TYPE, ALL_TYPE.getGreatestSubtype(ARRAY_TYPE)); assertTypeEquals(NO_OBJECT_TYPE, REGEXP_TYPE.getGreatestSubtype(NO_OBJECT_TYPE)); assertTypeEquals(NO_OBJECT_TYPE, NO_OBJECT_TYPE.getGreatestSubtype(REGEXP_TYPE)); assertTypeEquals(NO_OBJECT_TYPE, ARRAY_TYPE.getGreatestSubtype(STRING_OBJECT_TYPE)); assertTypeEquals(NO_TYPE, ARRAY_TYPE.getGreatestSubtype(NUMBER_TYPE)); assertTypeEquals(NO_OBJECT_TYPE, ARRAY_TYPE.getGreatestSubtype(functionType)); assertTypeEquals(STRING_OBJECT_TYPE, STRING_OBJECT_TYPE.getGreatestSubtype(OBJECT_TYPE)); assertTypeEquals(STRING_OBJECT_TYPE, OBJECT_TYPE.getGreatestSubtype(STRING_OBJECT_TYPE)); assertTypeEquals(NO_OBJECT_TYPE, ARRAY_TYPE.getGreatestSubtype(DATE_TYPE)); assertTypeEquals(NO_OBJECT_TYPE, ARRAY_TYPE.getGreatestSubtype(REGEXP_TYPE)); assertTypeEquals(EVAL_ERROR_TYPE, ERROR_TYPE.getGreatestSubtype(EVAL_ERROR_TYPE)); assertTypeEquals(EVAL_ERROR_TYPE, EVAL_ERROR_TYPE.getGreatestSubtype(ERROR_TYPE)); assertTypeEquals(NO_TYPE, NULL_TYPE.getGreatestSubtype(ERROR_TYPE)); assertTypeEquals(UNKNOWN_TYPE, NUMBER_TYPE.getGreatestSubtype(UNKNOWN_TYPE)); assertTypeEquals(NO_RESOLVED_TYPE, NO_OBJECT_TYPE.getGreatestSubtype(forwardDeclaredNamedType)); assertTypeEquals(NO_RESOLVED_TYPE, forwardDeclaredNamedType.getGreatestSubtype(NO_OBJECT_TYPE)); } /** * Tests that a derived class extending a type via a named type is a subtype * of it. */ public void testSubtypingDerivedExtendsNamedBaseType() throws Exception { ObjectType derived = registry.createObjectType(registry.createObjectType(namedGoogBar)); assertTrue(derived.isSubtype(googBar.getInstanceType())); } public void testNamedSubtypeChain() throws Exception { List<JSType> typeChain = Lists.newArrayList( registry.getNativeType(JSTypeNative.ALL_TYPE), registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE), registry.getNativeType(JSTypeNative.OBJECT_TYPE), googBar.getPrototype(), googBar.getInstanceType(), googSubBar.getPrototype(), googSubBar.getInstanceType(), googSubSubBar.getPrototype(), googSubSubBar.getInstanceType(), registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE)); verifySubtypeChain(typeChain); } public void testRecordSubtypeChain() throws Exception { RecordTypeBuilder builder = new RecordTypeBuilder(registry); builder.addProperty("a", STRING_TYPE, null); JSType aType = builder.build(); builder = new RecordTypeBuilder(registry); builder.addProperty("a", STRING_TYPE, null); builder.addProperty("b", STRING_TYPE, null); JSType abType = builder.build(); builder = new RecordTypeBuilder(registry); builder.addProperty("a", STRING_TYPE, null); builder.addProperty("c", STRING_TYPE, null); JSType acType = builder.build(); JSType abOrAcType = registry.createUnionType(abType, acType); builder = new RecordTypeBuilder(registry); builder.addProperty("a", STRING_TYPE, null); builder.addProperty("b", STRING_TYPE, null); builder.addProperty("c", NUMBER_TYPE, null); JSType abcType = builder.build(); List<JSType> typeChain = Lists.newArrayList( registry.getNativeType(JSTypeNative.ALL_TYPE), registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE), registry.getNativeType(JSTypeNative.OBJECT_TYPE), aType, abOrAcType, abType, abcType, registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE)); verifySubtypeChain(typeChain); } public void testRecordAndObjectChain2() throws Exception { RecordTypeBuilder builder = new RecordTypeBuilder(registry); builder.addProperty("date", DATE_TYPE, null); JSType hasDateProperty = builder.build(); List<JSType> typeChain = Lists.newArrayList( registry.getNativeType(JSTypeNative.OBJECT_TYPE), hasDateProperty, googBar.getInstanceType(), registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE)); verifySubtypeChain(typeChain); } public void testRecordAndObjectChain3() throws Exception { RecordTypeBuilder builder = new RecordTypeBuilder(registry); builder.addProperty("date", UNKNOWN_TYPE, null); JSType hasUnknownDateProperty = builder.build(); List<JSType> typeChain = Lists.newArrayList( registry.getNativeType(JSTypeNative.OBJECT_TYPE), hasUnknownDateProperty, googBar.getInstanceType(), registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE)); verifySubtypeChain(typeChain); } public void testNullableNamedTypeChain() throws Exception { List<JSType> typeChain = Lists.newArrayList( registry.getNativeType(JSTypeNative.ALL_TYPE), registry.createOptionalNullableType( registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE)), registry.createOptionalNullableType( registry.getNativeType(JSTypeNative.OBJECT_TYPE)), registry.createOptionalNullableType(googBar.getPrototype()), registry.createOptionalNullableType(googBar.getInstanceType()), registry.createNullableType(googSubBar.getPrototype()), registry.createNullableType(googSubBar.getInstanceType()), googSubSubBar.getPrototype(), googSubSubBar.getInstanceType(), registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE)); verifySubtypeChain(typeChain); } public void testEnumTypeChain() throws Exception { List<JSType> typeChain = Lists.newArrayList( registry.getNativeType(JSTypeNative.ALL_TYPE), registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE), registry.getNativeType(JSTypeNative.OBJECT_TYPE), enumType, registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE)); verifySubtypeChain(typeChain); } public void testFunctionSubtypeChain() throws Exception { List<JSType> typeChain = Lists.newArrayList( registry.getNativeType(JSTypeNative.ALL_TYPE), registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE), registry.getNativeType(JSTypeNative.OBJECT_TYPE), registry.getNativeType(JSTypeNative.FUNCTION_PROTOTYPE), registry.getNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE), dateMethod, registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE), registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE)); verifySubtypeChain(typeChain); } public void testFunctionUnionSubtypeChain() throws Exception { List<JSType> typeChain = Lists.newArrayList( createUnionType( OBJECT_TYPE, STRING_TYPE), createUnionType( GREATEST_FUNCTION_TYPE, googBarInst, STRING_TYPE), createUnionType( STRING_TYPE, registry.createFunctionType( createUnionType(STRING_TYPE, NUMBER_TYPE)), googBarInst), createUnionType( registry.createFunctionType(NUMBER_TYPE), googSubBarInst), LEAST_FUNCTION_TYPE, NO_OBJECT_TYPE, NO_TYPE); verifySubtypeChain(typeChain); } public void testConstructorSubtypeChain() throws Exception { List<JSType> typeChain = Lists.newArrayList( registry.getNativeType(JSTypeNative.ALL_TYPE), registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE), registry.getNativeType(JSTypeNative.OBJECT_TYPE), registry.getNativeType(JSTypeNative.FUNCTION_PROTOTYPE), registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE), registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE)); verifySubtypeChain(typeChain); } public void testGoogBarSubtypeChain() throws Exception { List<JSType> typeChain = Lists.newArrayList( registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE), googBar, googSubBar, googSubSubBar, registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE)); verifySubtypeChain(typeChain, false); } public void testConstructorWithArgSubtypeChain() throws Exception { FunctionType googBarArgConstructor = registry.createConstructorType( "barArg", null, registry.createParameters(googBar), null, null); FunctionType googSubBarArgConstructor = registry.createConstructorType( "subBarArg", null, registry.createParameters(googSubBar), null, null); List<JSType> typeChain = Lists.newArrayList( registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE), googBarArgConstructor, googSubBarArgConstructor, registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE)); verifySubtypeChain(typeChain, false); } public void testInterfaceInstanceSubtypeChain() throws Exception { List<JSType> typeChain = Lists.newArrayList( ALL_TYPE, OBJECT_TYPE, interfaceInstType, googBar.getPrototype(), googBarInst, googSubBar.getPrototype(), googSubBarInst, registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE)); verifySubtypeChain(typeChain); } public void testInterfaceInheritanceSubtypeChain() throws Exception { FunctionType tempType = registry.createConstructorType("goog.TempType", null, null, null, null); tempType.setImplementedInterfaces( Lists.<ObjectType>newArrayList(subInterfaceInstType)); List<JSType> typeChain = Lists.newArrayList( ALL_TYPE, OBJECT_TYPE, interfaceInstType, subInterfaceInstType, tempType.getPrototype(), tempType.getInstanceType(), registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE)); verifySubtypeChain(typeChain); } public void testAnonymousObjectChain() throws Exception { List<JSType> typeChain = Lists.newArrayList( ALL_TYPE, createNullableType(OBJECT_TYPE), OBJECT_TYPE, registry.createAnonymousObjectType(null), registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE)); verifySubtypeChain(typeChain); } public void testAnonymousEnumElementChain() throws Exception { ObjectType enumElemType = registry.createEnumType( "typeB", null, registry.createAnonymousObjectType(null)).getElementsType(); List<JSType> typeChain = Lists.newArrayList( ALL_TYPE, createNullableType(OBJECT_TYPE), OBJECT_TYPE, enumElemType, registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE)); verifySubtypeChain(typeChain); } public void testParameterizedArrayChain() throws Exception { JSType arrayOfNoType = createParameterizedType( ARRAY_TYPE, NO_TYPE); JSType arrayOfString = createParameterizedType( ARRAY_TYPE, STRING_TYPE); JSType arrayOfStringOrNumber = createParameterizedType( ARRAY_TYPE, createUnionType(STRING_TYPE, NUMBER_TYPE)); JSType arrayOfAllType = createParameterizedType( ARRAY_TYPE, ALL_TYPE); List<JSType> typeChain = Lists.newArrayList( registry.getNativeType(JSTypeNative.ALL_TYPE), registry.getNativeType(JSTypeNative.OBJECT_TYPE), arrayOfAllType, arrayOfStringOrNumber, arrayOfString, arrayOfNoType, registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE)); verifySubtypeChain(typeChain, false); } public void testParameterizedArrayChain2() throws Exception { JSType arrayOfNoType = createParameterizedType( ARRAY_TYPE, NO_TYPE); JSType arrayOfNoObjectType = createParameterizedType( ARRAY_TYPE, NO_OBJECT_TYPE); JSType arrayOfArray = createParameterizedType( ARRAY_TYPE, ARRAY_TYPE); JSType arrayOfObject = createParameterizedType( ARRAY_TYPE, OBJECT_TYPE); JSType arrayOfAllType = createParameterizedType( ARRAY_TYPE, ALL_TYPE); List<JSType> typeChain = Lists.newArrayList( registry.getNativeType(JSTypeNative.ALL_TYPE), registry.getNativeType(JSTypeNative.OBJECT_TYPE), arrayOfAllType, arrayOfObject, arrayOfArray, arrayOfNoObjectType, arrayOfNoType, registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE)); verifySubtypeChain(typeChain, false); } public void testParameterizedObjectChain() throws Exception { JSType objectOfNoType = createParameterizedType( OBJECT_TYPE, NO_TYPE); JSType objectOfString = createParameterizedType( OBJECT_TYPE, STRING_TYPE); JSType objectOfStringOrNumber = createParameterizedType( OBJECT_TYPE, createUnionType(STRING_TYPE, NUMBER_TYPE)); JSType objectOfAllType = createParameterizedType( OBJECT_TYPE, ALL_TYPE); List<JSType> typeChain = Lists.newArrayList( registry.getNativeType(JSTypeNative.ALL_TYPE), registry.getNativeType(JSTypeNative.OBJECT_TYPE), objectOfAllType, objectOfStringOrNumber, objectOfString, objectOfNoType, registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE)); verifySubtypeChain(typeChain, false); } public void testMixedParameterizedTypeChain() throws Exception { JSType arrayOfNoType = createParameterizedType( ARRAY_TYPE, NO_TYPE); JSType arrayOfString = createParameterizedType( ARRAY_TYPE, STRING_TYPE); JSType objectOfString = createParameterizedType( OBJECT_TYPE, STRING_TYPE); JSType objectOfStringOrNumber = createParameterizedType( OBJECT_TYPE, createUnionType(STRING_TYPE, NUMBER_TYPE)); JSType objectOfAllType = createParameterizedType( OBJECT_TYPE, ALL_TYPE); List<JSType> typeChain = Lists.newArrayList( registry.getNativeType(JSTypeNative.ALL_TYPE), registry.getNativeType(JSTypeNative.OBJECT_TYPE), objectOfAllType, objectOfStringOrNumber, objectOfString, arrayOfString, arrayOfNoType, registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE), registry.getNativeType(JSTypeNative.NO_TYPE)); verifySubtypeChain(typeChain, false); } public void testParameterizedTypeSubtypes() { JSType objectOfString = createParameterizedType( OBJECT_TYPE, STRING_TYPE); JSType arrayOfString = createParameterizedType( ARRAY_TYPE, STRING_TYPE); JSType arrayOfNumber = createParameterizedType( ARRAY_TYPE, NUMBER_TYPE); JSType arrayOfUnknown = createParameterizedType( ARRAY_TYPE, UNKNOWN_TYPE); assertFalse(objectOfString.isSubtype(ARRAY_TYPE)); // TODO(johnlenz): should this be false? assertTrue(ARRAY_TYPE.isSubtype(objectOfString)); assertFalse(objectOfString.isSubtype(ARRAY_TYPE)); // TODO(johnlenz): should this be false? assertTrue(ARRAY_TYPE.isSubtype(objectOfString)); assertTrue(arrayOfString.isSubtype(ARRAY_TYPE)); assertTrue(ARRAY_TYPE.isSubtype(arrayOfString)); assertTrue(arrayOfString.isSubtype(arrayOfUnknown)); assertTrue(arrayOfUnknown.isSubtype(arrayOfString)); assertFalse(arrayOfString.isSubtype(arrayOfNumber)); assertFalse(arrayOfNumber.isSubtype(arrayOfString)); assertTrue(arrayOfNumber.isSubtype(createUnionType(arrayOfNumber, NULL_VOID))); assertFalse(createUnionType(arrayOfNumber, NULL_VOID).isSubtype(arrayOfNumber)); assertFalse(arrayOfString.isSubtype(createUnionType(arrayOfNumber, NULL_VOID))); } public void testParameterizedTypeRelations() throws Exception { JSType objectOfString = createParameterizedType( OBJECT_TYPE, STRING_TYPE); JSType arrayOfString = createParameterizedType( ARRAY_TYPE, STRING_TYPE); JSType arrayOfNumber = createParameterizedType( ARRAY_TYPE, NUMBER_TYPE); JSType arrayOfUnknown = createParameterizedType( ARRAY_TYPE, UNKNOWN_TYPE); // Union and least super type cases: // // 1) alternate:Array.<string> and current:Object ==> Object // 2) alternate:Array.<string> and current:Array ==> Array // 3) alternate:Object.<string> and current:Array ==> Array|Object.<string> // 4) alternate:Object and current:Array.<string> ==> Object // 5) alternate:Array and current:Array.<string> ==> Array // 6) alternate:Array and current:Object.<string> ==> Array|Object.<string> // 7) alternate:Array.<string> and current:Array.<number> ==> Array.<?> // 8) alternate:Array.<string> and current:Array.<string> ==> Array.<string> // 9) alternate:Array.<string> and // current:Object.<string> ==> Object.<string>|Array.<string> assertTypeEquals( OBJECT_TYPE, JSType.getLeastSupertype(arrayOfString, OBJECT_TYPE)); assertTypeEquals( OBJECT_TYPE, JSType.getLeastSupertype(OBJECT_TYPE, arrayOfString)); assertTypeEquals( ARRAY_TYPE, JSType.getLeastSupertype(arrayOfString, ARRAY_TYPE)); assertTypeEquals( ARRAY_TYPE, JSType.getLeastSupertype(ARRAY_TYPE, arrayOfString)); assertEquals( "(Array|Object.<string>)", JSType.getLeastSupertype(objectOfString, ARRAY_TYPE).toString()); assertEquals( "(Array|Object.<string>)", JSType.getLeastSupertype(ARRAY_TYPE, objectOfString).toString()); assertEquals( "Array", JSType.getLeastSupertype(arrayOfString, arrayOfNumber).toString()); assertEquals( "Array", JSType.getLeastSupertype(arrayOfNumber, arrayOfString).toString()); assertTypeEquals( arrayOfString, JSType.getLeastSupertype(arrayOfString, arrayOfString)); assertEquals( "(Array.<string>|Object.<string>)", JSType.getLeastSupertype(objectOfString, arrayOfString).toString()); assertEquals( "(Array.<string>|Object.<string>)", JSType.getLeastSupertype(arrayOfString, objectOfString).toString()); assertTypeEquals( objectOfString, JSType.getGreatestSubtype(OBJECT_TYPE, objectOfString)); assertTypeEquals( objectOfString, JSType.getGreatestSubtype(objectOfString, OBJECT_TYPE)); assertTypeEquals( ARRAY_TYPE, JSType.getGreatestSubtype(objectOfString, ARRAY_TYPE)); assertTypeEquals( JSType.getGreatestSubtype(objectOfString, arrayOfString), NO_OBJECT_TYPE); assertTypeEquals( JSType.getGreatestSubtype(OBJECT_TYPE, arrayOfString), arrayOfString); } /** * Tests that the given chain of types has a total ordering defined * by the subtype relationship, with types at the top of the lattice * listed first. * * Also verifies that the infimum of any two types on the chain * is the lower type, and the supremum of any two types on the chain * is the higher type. */ public void verifySubtypeChain(List<JSType> typeChain) throws Exception { verifySubtypeChain(typeChain, true); } public void verifySubtypeChain(List<JSType> typeChain, boolean checkSubtyping) throws Exception { // Ugh. This wouldn't require so much copy-and-paste if we had a functional // programming language. for (int i = 0; i < typeChain.size(); i++) { for (int j = 0; j < typeChain.size(); j++) { JSType typeI = typeChain.get(i); JSType typeJ = typeChain.get(j); JSType namedTypeI = getNamedWrapper("TypeI", typeI); JSType namedTypeJ = getNamedWrapper("TypeJ", typeJ); JSType proxyTypeI = new ProxyObjectType(registry, typeI); JSType proxyTypeJ = new ProxyObjectType(registry, typeJ); if (i == j) { assertTrue(typeI + " should equal itself", typeI.isEquivalentTo(typeI)); assertTrue("Named " + typeI + " should equal itself", namedTypeI.isEquivalentTo(namedTypeI)); assertTrue("Proxy " + typeI + " should equal itself", proxyTypeI.isEquivalentTo(proxyTypeI)); } else { assertFalse(typeI + " should not equal " + typeJ, typeI.isEquivalentTo(typeJ)); assertFalse("Named " + typeI + " should not equal " + typeJ, namedTypeI.isEquivalentTo(namedTypeJ)); assertFalse("Proxy " + typeI + " should not equal " + typeJ, proxyTypeI.isEquivalentTo(proxyTypeJ)); } assertTrue(typeJ + " should be castable to " + typeI, typeJ.canCastTo(typeI)); assertTrue(typeJ + " should be castable to Named " + namedTypeI, typeJ.canCastTo(namedTypeI)); assertTrue(typeJ + " should be castable to Proxy " + proxyTypeI, typeJ.canCastTo(proxyTypeI)); assertTrue( "Named " + typeJ + " should be castable to " + typeI, namedTypeJ.canCastTo(typeI)); assertTrue( "Named " + typeJ + " should be castable to Named " + typeI, namedTypeJ.canCastTo(namedTypeI)); assertTrue( "Named " + typeJ + " should be castable to Proxy " + typeI, namedTypeJ.canCastTo(proxyTypeI)); assertTrue( "Proxy " + typeJ + " should be castable to " + typeI, proxyTypeJ.canCastTo(typeI)); assertTrue( "Proxy " + typeJ + " should be castable to Named " + typeI, proxyTypeJ.canCastTo(namedTypeI)); assertTrue( "Proxy " + typeJ + " should be castable to Proxy " + typeI, proxyTypeJ.canCastTo(proxyTypeI)); if (checkSubtyping) { if (i <= j) { assertTrue(typeJ + " should be a subtype of " + typeI, typeJ.isSubtype(typeI)); assertTrue( "Named " + typeJ + " should be a subtype of Named " + typeI, namedTypeJ.isSubtype(namedTypeI)); assertTrue( "Proxy " + typeJ + " should be a subtype of Proxy " + typeI, proxyTypeJ.isSubtype(proxyTypeI)); } else { assertFalse(typeJ + " should not be a subtype of " + typeI, typeJ.isSubtype(typeI)); assertFalse( "Named " + typeJ + " should not be a subtype of Named " + typeI, namedTypeJ.isSubtype(namedTypeI)); assertFalse( "Named " + typeJ + " should not be a subtype of Named " + typeI, proxyTypeJ.isSubtype(proxyTypeI)); } JSType expectedSupremum = i < j ? typeI : typeJ; JSType expectedInfimum = i > j ? typeI : typeJ; assertTypeEquals( expectedSupremum + " should be the least supertype of " + typeI + " and " + typeJ, expectedSupremum, typeI.getLeastSupertype(typeJ)); // TODO(nicksantos): Should these tests pass? //assertTypeEquals( // expectedSupremum + " should be the least supertype of Named " + // typeI + " and Named " + typeJ, // expectedSupremum, namedTypeI.getLeastSupertype(namedTypeJ)); //assertTypeEquals( // expectedSupremum + " should be the least supertype of Proxy " + // typeI + " and Proxy " + typeJ, // expectedSupremum, proxyTypeI.getLeastSupertype(proxyTypeJ)); assertTypeEquals( expectedInfimum + " should be the greatest subtype of " + typeI + " and " + typeJ, expectedInfimum, typeI.getGreatestSubtype(typeJ)); // TODO(nicksantos): Should these tests pass? //assertTypeEquals( // expectedInfimum + " should be the greatest subtype of Named " + // typeI + " and Named " + typeJ, // expectedInfimum, namedTypeI.getGreatestSubtype(namedTypeJ)); //assertTypeEquals( // expectedInfimum + " should be the greatest subtype of Proxy " + // typeI + " and Proxy " + typeJ, // expectedInfimum, proxyTypeI.getGreatestSubtype(proxyTypeJ)); } } } } JSType getNamedWrapper(String name, JSType jstype) { // Normally, there is no way to create a Named NoType alias so // avoid confusing things by doing it here.. if (!jstype.isNoType()) { NamedType namedWrapper = new NamedType( registry, name, "[testcode]", -1, -1); namedWrapper.setReferencedType(jstype); return namedWrapper; } else { return jstype; } } /** * Tests the behavior of * {@link JSType#getRestrictedTypeGivenToBooleanOutcome(boolean)}. */ @SuppressWarnings("checked") public void testRestrictedTypeGivenToBoolean() { // simple cases assertTypeEquals(BOOLEAN_TYPE, BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true)); assertTypeEquals(BOOLEAN_TYPE, BOOLEAN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false)); assertTypeEquals(NO_TYPE, NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true)); assertTypeEquals(NULL_TYPE, NULL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false)); assertTypeEquals(NUMBER_TYPE, NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(true)); assertTypeEquals(NUMBER_TYPE, NUMBER_TYPE.getRestrictedTypeGivenToBooleanOutcome(false)); assertTypeEquals(STRING_TYPE, STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(true)); assertTypeEquals(STRING_TYPE, STRING_TYPE.getRestrictedTypeGivenToBooleanOutcome(false)); assertTypeEquals(STRING_OBJECT_TYPE, STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true)); assertTypeEquals(NO_TYPE, STRING_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false)); assertTypeEquals(NO_TYPE, VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(true)); assertTypeEquals(VOID_TYPE, VOID_TYPE.getRestrictedTypeGivenToBooleanOutcome(false)); assertTypeEquals(NO_OBJECT_TYPE, NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(true)); assertTypeEquals(NO_TYPE, NO_OBJECT_TYPE.getRestrictedTypeGivenToBooleanOutcome(false)); assertTypeEquals(NO_TYPE, NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(true)); assertTypeEquals(NO_TYPE, NO_TYPE.getRestrictedTypeGivenToBooleanOutcome(false)); assertTypeEquals(ALL_TYPE, ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(true)); assertTypeEquals(ALL_TYPE, ALL_TYPE.getRestrictedTypeGivenToBooleanOutcome(false)); assertTypeEquals(CHECKED_UNKNOWN_TYPE, UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(true)); assertTypeEquals(UNKNOWN_TYPE, UNKNOWN_TYPE.getRestrictedTypeGivenToBooleanOutcome(false)); // unions UnionType nullableStringValue = (UnionType) createNullableType(STRING_TYPE); assertTypeEquals(STRING_TYPE, nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(true)); assertTypeEquals(nullableStringValue, nullableStringValue.getRestrictedTypeGivenToBooleanOutcome(false)); UnionType nullableStringObject = (UnionType) createNullableType(STRING_OBJECT_TYPE); assertTypeEquals(STRING_OBJECT_TYPE, nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(true)); assertTypeEquals(NULL_TYPE, nullableStringObject.getRestrictedTypeGivenToBooleanOutcome(false)); } public void testRegisterProperty() { int i = 0; List<JSType> allObjects = Lists.newArrayList(); for (JSType type : types) { String propName = "ALF" + i++; if (type instanceof ObjectType) { ObjectType objType = (ObjectType) type; objType.defineDeclaredProperty(propName, UNKNOWN_TYPE, null); objType.defineDeclaredProperty("allHaz", UNKNOWN_TYPE, null); assertTypeEquals(type, registry.getGreatestSubtypeWithProperty(type, propName)); List<JSType> typesWithProp = Lists.newArrayList(registry.getTypesWithProperty(propName)); String message = type.toString(); assertEquals(message, 1, typesWithProp.size()); assertTypeEquals(type, typesWithProp.get(0)); assertTypeEquals(NO_TYPE, registry.getGreatestSubtypeWithProperty(type, "GRRR")); allObjects.add(type); } } assertTypeListEquals(registry.getTypesWithProperty("GRRR"), Lists.newArrayList(NO_TYPE)); assertTypeListEquals(allObjects, registry.getTypesWithProperty("allHaz")); } public void testRegisterPropertyMemoization() { ObjectType derived1 = registry.createObjectType("d1", null, namedGoogBar); ObjectType derived2 = registry.createObjectType("d2", null, namedGoogBar); derived1.defineDeclaredProperty("propz", UNKNOWN_TYPE, null); assertTypeEquals(derived1, registry.getGreatestSubtypeWithProperty(derived1, "propz")); assertTypeEquals(NO_OBJECT_TYPE, registry.getGreatestSubtypeWithProperty(derived2, "propz")); derived2.defineDeclaredProperty("propz", UNKNOWN_TYPE, null); assertTypeEquals(derived1, registry.getGreatestSubtypeWithProperty(derived1, "propz")); assertTypeEquals(derived2, registry.getGreatestSubtypeWithProperty(derived2, "propz")); } /** * Tests * {@link JSTypeRegistry#getGreatestSubtypeWithProperty(JSType, String)}. */ public void testGreatestSubtypeWithProperty() { ObjectType foo = registry.createObjectType("foo", null, OBJECT_TYPE); ObjectType bar = registry.createObjectType("bar", null, namedGoogBar); foo.defineDeclaredProperty("propz", UNKNOWN_TYPE, null); bar.defineDeclaredProperty("propz", UNKNOWN_TYPE, null); assertTypeEquals(bar, registry.getGreatestSubtypeWithProperty(namedGoogBar, "propz")); } public void testGoodSetPrototypeBasedOn() { FunctionType fun = registry.createConstructorType( "fun", null, null, null, null); fun.setPrototypeBasedOn(unresolvedNamedType); assertTrue(fun.getInstanceType().isUnknownType()); } public void testLateSetPrototypeBasedOn() { FunctionType fun = registry.createConstructorType( "fun", null, null, null, null); assertFalse(fun.getInstanceType().isUnknownType()); fun.setPrototypeBasedOn(unresolvedNamedType); assertTrue(fun.getInstanceType().isUnknownType()); } public void testGetTypeUnderEquality1() { for (JSType type : types) { testGetTypeUnderEquality(type, type, type, type); } } public void testGetTypesUnderEquality2() { // objects can be equal to numbers testGetTypeUnderEquality( NUMBER_TYPE, OBJECT_TYPE, NUMBER_TYPE, OBJECT_TYPE); } public void testGetTypesUnderEquality3() { // null == undefined testGetTypeUnderEquality( NULL_TYPE, VOID_TYPE, NULL_TYPE, VOID_TYPE); } @SuppressWarnings("checked") public void testGetTypesUnderEquality4() { // (number,string) and number/string UnionType stringNumber = (UnionType) createUnionType(NUMBER_TYPE, STRING_TYPE); testGetTypeUnderEquality( stringNumber, STRING_TYPE, stringNumber, STRING_TYPE); testGetTypeUnderEquality( stringNumber, NUMBER_TYPE, stringNumber, NUMBER_TYPE); } public void testGetTypesUnderEquality5() { // (number,null) and undefined JSType nullUndefined = createUnionType(VOID_TYPE, NULL_TYPE); testGetTypeUnderEquality( nullUndefined, NULL_TYPE, nullUndefined, NULL_TYPE); testGetTypeUnderEquality( nullUndefined, VOID_TYPE, nullUndefined, VOID_TYPE); } public void testGetTypesUnderEquality6() { // (number,undefined,null) == null JSType optNullNumber = createUnionType(VOID_TYPE, NULL_TYPE, NUMBER_TYPE); testGetTypeUnderEquality( optNullNumber, NULL_TYPE, createUnionType(NULL_TYPE, VOID_TYPE), NULL_TYPE); } private void testGetTypeUnderEquality( JSType t1, JSType t2, JSType t1Eq, JSType t2Eq) { // creating the pairs TypePair p12 = t1.getTypesUnderEquality(t2); TypePair p21 = t2.getTypesUnderEquality(t1); // t1Eq assertTypeEquals(t1Eq, p12.typeA); assertTypeEquals(t1Eq, p21.typeB); // t2Eq assertTypeEquals(t2Eq, p12.typeB); assertTypeEquals(t2Eq, p21.typeA); } @SuppressWarnings("checked") public void testGetTypesUnderInequality1() { // objects can be not equal to numbers UnionType numberObject = (UnionType) createUnionType(NUMBER_TYPE, OBJECT_TYPE); testGetTypesUnderInequality( numberObject, NUMBER_TYPE, numberObject, NUMBER_TYPE); testGetTypesUnderInequality( numberObject, OBJECT_TYPE, numberObject, OBJECT_TYPE); } @SuppressWarnings("checked") public void testGetTypesUnderInequality2() { // null == undefined UnionType nullUndefined = (UnionType) createUnionType(VOID_TYPE, NULL_TYPE); testGetTypesUnderInequality( nullUndefined, NULL_TYPE, NO_TYPE, NO_TYPE); testGetTypesUnderInequality( nullUndefined, VOID_TYPE, NO_TYPE, NO_TYPE); } @SuppressWarnings("checked") public void testGetTypesUnderInequality3() { // (number,string) UnionType stringNumber = (UnionType) createUnionType(NUMBER_TYPE, STRING_TYPE); testGetTypesUnderInequality( stringNumber, NUMBER_TYPE, stringNumber, NUMBER_TYPE); testGetTypesUnderInequality( stringNumber, STRING_TYPE, stringNumber, STRING_TYPE); } @SuppressWarnings("checked") public void testGetTypesUnderInequality4() throws Exception { // (number,undefined,null) and null UnionType nullableOptionalNumber = (UnionType) createUnionType(NULL_TYPE, VOID_TYPE, NUMBER_TYPE); testGetTypesUnderInequality( nullableOptionalNumber, NULL_TYPE, NUMBER_TYPE, NULL_TYPE); } private void testGetTypesUnderInequality( JSType t1, JSType t2, JSType t1Eq, JSType t2Eq) { // creating the pairs TypePair p12 = t1.getTypesUnderInequality(t2); TypePair p21 = t2.getTypesUnderInequality(t1); // t1Eq assertTypeEquals(t1Eq, p12.typeA); assertTypeEquals(t1Eq, p21.typeB); // t2Eq assertTypeEquals(t2Eq, p12.typeB); assertTypeEquals(t2Eq, p21.typeA); } /** * Tests the factory method * {@link JSTypeRegistry#createRecordType}. */ public void testCreateRecordType() throws Exception { Map<String, RecordProperty> properties = new HashMap<String, RecordProperty>(); properties.put("hello", new RecordProperty(NUMBER_TYPE, null)); JSType recordType = registry.createRecordType(properties); assertEquals("{hello: number}", recordType.toString()); } /** * Tests the factory method {@link JSTypeRegistry#createOptionalType(JSType)}. */ public void testCreateOptionalType() throws Exception { // number UnionType optNumber = (UnionType) registry.createOptionalType(NUMBER_TYPE); assertUnionContains(optNumber, NUMBER_TYPE); assertUnionContains(optNumber, VOID_TYPE); // union UnionType optUnion = (UnionType) registry.createOptionalType( createUnionType(STRING_OBJECT_TYPE, DATE_TYPE)); assertUnionContains(optUnion, DATE_TYPE); assertUnionContains(optUnion, STRING_OBJECT_TYPE); assertUnionContains(optUnion, VOID_TYPE); } public void assertUnionContains(UnionType union, JSType type) { assertTrue(union + " should contain " + type, union.contains(type)); } /** * Tests the factory method * {@link JSTypeRegistry#createAnonymousObjectType}}. */ public void testCreateAnonymousObjectType() throws Exception { // anonymous ObjectType anonymous = registry.createAnonymousObjectType(null); assertTypeEquals(OBJECT_TYPE, anonymous.getImplicitPrototype()); assertNull(anonymous.getReferenceName()); assertEquals("{}", anonymous.toString()); } /** * Tests the factory method * {@link JSTypeRegistry#createAnonymousObjectType}} and adds * some properties to it. */ public void testCreateAnonymousObjectType2() throws Exception { // anonymous ObjectType anonymous = registry.createAnonymousObjectType(null); anonymous.defineDeclaredProperty( "a", NUMBER_TYPE, null); anonymous.defineDeclaredProperty( "b", NUMBER_TYPE, null); anonymous.defineDeclaredProperty( "c", NUMBER_TYPE, null); anonymous.defineDeclaredProperty( "d", NUMBER_TYPE, null); anonymous.defineDeclaredProperty( "e", NUMBER_TYPE, null); anonymous.defineDeclaredProperty( "f", NUMBER_TYPE, null); assertEquals("{a: number, b: number, c: number, d: number, ...}", anonymous.toString()); } /** * Tests the factory methods * {@link JSTypeRegistry#createObjectType(ObjectType)}} and * {@link JSTypeRegistry#createObjectType(String, Node, ObjectType)}}. */ public void testCreateObjectType() throws Exception { // simple ObjectType subDate = registry.createObjectType(DATE_TYPE.getImplicitPrototype()); assertTypeEquals(DATE_TYPE.getImplicitPrototype(), subDate.getImplicitPrototype()); assertNull(subDate.getReferenceName()); assertEquals("{...}", subDate.toString()); // name, node, prototype ObjectType subError = registry.createObjectType("Foo", null, ERROR_TYPE.getImplicitPrototype()); assertTypeEquals(ERROR_TYPE.getImplicitPrototype(), subError.getImplicitPrototype()); assertEquals("Foo", subError.getReferenceName()); } /** * Tests {@code (U2U_CONSTRUCTOR,undefined) <: (U2U_CONSTRUCTOR,undefined)}. */ @SuppressWarnings("checked") public void testBug903110() throws Exception { UnionType union = (UnionType) createUnionType(U2U_CONSTRUCTOR_TYPE, VOID_TYPE); assertTrue(VOID_TYPE.isSubtype(union)); assertTrue(U2U_CONSTRUCTOR_TYPE.isSubtype(union)); assertTrue(union.isSubtype(union)); } /** * Tests {@code U2U_FUNCTION_TYPE <: U2U_CONSTRUCTOR} and * {@code U2U_FUNCTION_TYPE <: (U2U_CONSTRUCTOR,undefined)}. */ public void testBug904123() throws Exception { assertTrue(U2U_FUNCTION_TYPE.isSubtype(U2U_CONSTRUCTOR_TYPE)); assertTrue(U2U_FUNCTION_TYPE. isSubtype(createOptionalType(U2U_CONSTRUCTOR_TYPE))); } /** * Assert that a type can assign to itself. */ private void assertTypeCanAssignToItself(JSType type) { assertTrue(type.isSubtype(type)); } /** * Tests that hasOwnProperty returns true when a property is defined directly * on a class and false if the property is defined on the supertype or not at * all. */ public void testHasOwnProperty() throws Exception { ObjectType sup = registry.createObjectType(registry.createAnonymousObjectType(null)); ObjectType sub = registry.createObjectType(sup); sup.defineProperty("base", null, false, null); sub.defineProperty("sub", null, false, null); assertTrue(sup.hasProperty("base")); assertFalse(sup.hasProperty("sub")); assertTrue(sup.hasOwnProperty("base")); assertFalse(sup.hasOwnProperty("sub")); assertFalse(sup.hasOwnProperty("none")); assertTrue(sub.hasProperty("base")); assertTrue(sub.hasProperty("sub")); assertFalse(sub.hasOwnProperty("base")); assertTrue(sub.hasOwnProperty("sub")); assertFalse(sub.hasOwnProperty("none")); } public void testNamedTypeHasOwnProperty() throws Exception { namedGoogBar.getImplicitPrototype().defineProperty("base", null, false, null); namedGoogBar.defineProperty("sub", null, false, null); assertFalse(namedGoogBar.hasOwnProperty("base")); assertTrue(namedGoogBar.hasProperty("base")); assertTrue(namedGoogBar.hasOwnProperty("sub")); assertTrue(namedGoogBar.hasProperty("sub")); } public void testInterfaceHasOwnProperty() throws Exception { interfaceInstType.defineProperty("base", null, false, null); subInterfaceInstType.defineProperty("sub", null, false, null); assertTrue(interfaceInstType.hasProperty("base")); assertFalse(interfaceInstType.hasProperty("sub")); assertTrue(interfaceInstType.hasOwnProperty("base")); assertFalse(interfaceInstType.hasOwnProperty("sub")); assertFalse(interfaceInstType.hasOwnProperty("none")); assertTrue(subInterfaceInstType.hasProperty("base")); assertTrue(subInterfaceInstType.hasProperty("sub")); assertFalse(subInterfaceInstType.hasOwnProperty("base")); assertTrue(subInterfaceInstType.hasOwnProperty("sub")); assertFalse(subInterfaceInstType.hasOwnProperty("none")); } public void testGetPropertyNames() throws Exception { ObjectType sup = registry.createObjectType(registry.createAnonymousObjectType(null)); ObjectType sub = registry.createObjectType(sup); sup.defineProperty("base", null, false, null); sub.defineProperty("sub", null, false, null); assertEquals(Sets.newHashSet("isPrototypeOf", "toLocaleString", "propertyIsEnumerable", "toString", "valueOf", "hasOwnProperty", "constructor", "base", "sub"), sub.getPropertyNames()); assertEquals(Sets.newHashSet("isPrototypeOf", "toLocaleString", "propertyIsEnumerable", "toString", "valueOf", "hasOwnProperty", "constructor", "base"), sup.getPropertyNames()); assertEquals(Sets.newHashSet(), NO_OBJECT_TYPE.getPropertyNames()); } public void testGetAndSetJSDocInfoWithNamedType() throws Exception { JSDocInfo info = new JSDocInfo(); info.setDeprecated(true); assertNull(namedGoogBar.getOwnPropertyJSDocInfo("X")); namedGoogBar.setPropertyJSDocInfo("X", info); assertTrue(namedGoogBar.getOwnPropertyJSDocInfo("X").isDeprecated()); assertPropertyTypeInferred(namedGoogBar, "X"); assertTypeEquals(UNKNOWN_TYPE, namedGoogBar.getPropertyType("X")); } public void testGetAndSetJSDocInfoWithObjectTypes() throws Exception { ObjectType sup = registry.createObjectType(registry.createAnonymousObjectType(null)); ObjectType sub = registry.createObjectType(sup); JSDocInfo deprecated = new JSDocInfo(); deprecated.setDeprecated(true); JSDocInfo privateInfo = new JSDocInfo(); privateInfo.setVisibility(Visibility.PRIVATE); sup.defineProperty("X", NUMBER_TYPE, true, null); sup.setPropertyJSDocInfo("X", privateInfo); sub.defineProperty("X", NUMBER_TYPE, true, null); sub.setPropertyJSDocInfo("X", deprecated); assertFalse(sup.getOwnPropertyJSDocInfo("X").isDeprecated()); assertEquals(Visibility.PRIVATE, sup.getOwnPropertyJSDocInfo("X").getVisibility()); assertTypeEquals(NUMBER_TYPE, sup.getPropertyType("X")); assertTrue(sub.getOwnPropertyJSDocInfo("X").isDeprecated()); assertNull(sub.getOwnPropertyJSDocInfo("X").getVisibility()); assertTypeEquals(NUMBER_TYPE, sub.getPropertyType("X")); } public void testGetAndSetJSDocInfoWithNoType() throws Exception { JSDocInfo deprecated = new JSDocInfo(); deprecated.setDeprecated(true); NO_TYPE.setPropertyJSDocInfo("X", deprecated); assertNull(NO_TYPE.getOwnPropertyJSDocInfo("X")); } public void testObjectGetSubTypes() throws Exception { assertTrue( containsType( OBJECT_FUNCTION_TYPE.getSubTypes(), googBar)); assertTrue( containsType( googBar.getSubTypes(), googSubBar)); assertFalse( containsType( googBar.getSubTypes(), googSubSubBar)); assertFalse( containsType( googSubBar.getSubTypes(), googSubBar)); assertTrue( containsType( googSubBar.getSubTypes(), googSubSubBar)); } public void testImplementingType() throws Exception { assertTrue( containsType( registry.getDirectImplementors( interfaceType.getInstanceType()), googBar)); } public void testIsTemplatedType() throws Exception { assertTrue( new TemplateType(registry, "T") .hasAnyTemplateTypes()); assertFalse( ARRAY_TYPE .hasAnyTemplateTypes()); assertTrue( registry.createParameterizedType( ARRAY_TYPE, new TemplateType(registry, "T")) .hasAnyTemplateTypes()); assertFalse( registry.createParameterizedType( ARRAY_TYPE, STRING_TYPE) .hasAnyTemplateTypes()); assertTrue( new FunctionBuilder(registry) .withReturnType(new TemplateType(registry, "T")) .build() .hasAnyTemplateTypes()); assertTrue( new FunctionBuilder(registry) .withTypeOfThis(new TemplateType(registry, "T")) .build() .hasAnyTemplateTypes()); assertFalse( new FunctionBuilder(registry) .withReturnType(STRING_TYPE) .build() .hasAnyTemplateTypes()); assertTrue( registry.createUnionType( NULL_TYPE, new TemplateType(registry, "T"), STRING_TYPE) .hasAnyTemplateTypes()); assertFalse( registry.createUnionType( NULL_TYPE, ARRAY_TYPE, STRING_TYPE) .hasAnyTemplateTypes()); } public void testTemplatizedType() throws Exception { FunctionType templatizedCtor = registry.createConstructorType( "TestingType", null, null, UNKNOWN_TYPE, ImmutableList.of("A", "B")); JSType templatizedInstance = registry.createTemplatizedType( templatizedCtor.getInstanceType(), ImmutableList.of(NUMBER_TYPE, STRING_TYPE)); assertTrue(templatizedInstance.isTemplatized()); assertTrue(templatizedInstance.hasTemplatizedType("A")); assertTrue(templatizedInstance.hasTemplatizedType("B")); assertFalse(templatizedInstance.hasTemplatizedType("C")); assertEquals(NUMBER_TYPE, templatizedInstance.getTemplatizedType("A")); assertEquals(STRING_TYPE, templatizedInstance.getTemplatizedType("B")); assertEquals(UNKNOWN_TYPE, templatizedInstance.getTemplatizedType("C")); assertEquals("TestingType.<number,string>", templatizedInstance.toString()); } public void testPartiallyTemplatizedType() throws Exception { FunctionType templatizedCtor = registry.createConstructorType( "TestingType", null, null, UNKNOWN_TYPE, ImmutableList.of("A", "B")); JSType templatizedInstance = registry.createTemplatizedType( templatizedCtor.getInstanceType(), ImmutableList.of(NUMBER_TYPE)); assertTrue(templatizedInstance.isTemplatized()); assertTrue(templatizedInstance.hasTemplatizedType("A")); assertTrue(templatizedInstance.hasTemplatizedType("B")); assertFalse(templatizedInstance.hasTemplatizedType("C")); assertEquals(NUMBER_TYPE, templatizedInstance.getTemplatizedType("A")); assertEquals(UNKNOWN_TYPE, templatizedInstance.getTemplatizedType("B")); assertEquals(UNKNOWN_TYPE, templatizedInstance.getTemplatizedType("C")); assertEquals("TestingType.<number,?>", templatizedInstance.toString()); } public void testInvalidTemplatizedType() throws Exception { FunctionType templatizedCtor = registry.createConstructorType( "TestingType", null, null, UNKNOWN_TYPE, ImmutableList.of("A", "B")); boolean exceptionThrown = false; try { JSType templatizedInstance = registry.createTemplatizedType( templatizedCtor.getInstanceType(), ImmutableList.of(NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE)); } catch (IllegalArgumentException e) { exceptionThrown = true; } assertTrue(exceptionThrown); } public void testCanCastTo() { assertTrue(ALL_TYPE.canCastTo(NULL_TYPE)); assertTrue(ALL_TYPE.canCastTo(VOID_TYPE)); assertTrue(ALL_TYPE.canCastTo(STRING_TYPE)); assertTrue(ALL_TYPE.canCastTo(NUMBER_TYPE)); assertTrue(ALL_TYPE.canCastTo(BOOLEAN_TYPE)); assertTrue(ALL_TYPE.canCastTo(OBJECT_TYPE)); assertFalse(NUMBER_TYPE.canCastTo(NULL_TYPE)); assertFalse(NUMBER_TYPE.canCastTo(VOID_TYPE)); assertFalse(NUMBER_TYPE.canCastTo(STRING_TYPE)); assertTrue(NUMBER_TYPE.canCastTo(NUMBER_TYPE)); assertFalse(NUMBER_TYPE.canCastTo(BOOLEAN_TYPE)); assertFalse(NUMBER_TYPE.canCastTo(OBJECT_TYPE)); assertFalse(STRING_TYPE.canCastTo(NULL_TYPE)); assertFalse(STRING_TYPE.canCastTo(VOID_TYPE)); assertTrue(STRING_TYPE.canCastTo(STRING_TYPE)); assertFalse(STRING_TYPE.canCastTo(NUMBER_TYPE)); assertFalse(STRING_TYPE.canCastTo(BOOLEAN_TYPE)); assertFalse(STRING_TYPE.canCastTo(OBJECT_TYPE)); assertFalse(BOOLEAN_TYPE.canCastTo(NULL_TYPE)); assertFalse(BOOLEAN_TYPE.canCastTo(VOID_TYPE)); assertFalse(BOOLEAN_TYPE.canCastTo(STRING_TYPE)); assertFalse(BOOLEAN_TYPE.canCastTo(NUMBER_TYPE)); assertTrue(BOOLEAN_TYPE.canCastTo(BOOLEAN_TYPE)); assertFalse(BOOLEAN_TYPE.canCastTo(OBJECT_TYPE)); assertFalse(OBJECT_TYPE.canCastTo(NULL_TYPE)); assertFalse(OBJECT_TYPE.canCastTo(VOID_TYPE)); assertFalse(OBJECT_TYPE.canCastTo(STRING_TYPE)); assertFalse(OBJECT_TYPE.canCastTo(NUMBER_TYPE)); assertFalse(OBJECT_TYPE.canCastTo(BOOLEAN_TYPE)); assertTrue(OBJECT_TYPE.canCastTo(OBJECT_TYPE)); assertFalse(BOOLEAN_TYPE.canCastTo(OBJECT_NUMBER_STRING)); assertFalse(OBJECT_NUMBER_STRING.canCastTo(BOOLEAN_TYPE)); assertFalse(ARRAY_TYPE.canCastTo(U2U_FUNCTION_TYPE)); assertFalse(U2U_FUNCTION_TYPE.canCastTo(ARRAY_TYPE)); assertFalse(NULL_VOID.canCastTo(ARRAY_TYPE)); assertTrue(NULL_VOID.canCastTo(createUnionType(ARRAY_TYPE, NULL_TYPE))); // We currently allow any function to be cast to any other function type assertTrue(ARRAY_FUNCTION_TYPE.canCastTo(BOOLEAN_OBJECT_FUNCTION_TYPE)); } private static boolean containsType( Iterable<? extends JSType> types, JSType type) { for (JSType alt : types) { if (alt.isEquivalentTo(type)) { return true; } } return false; } private static boolean assertTypeListEquals( Iterable<? extends JSType> typeListA, Iterable<? extends JSType> typeListB) { for (JSType alt : typeListA) { assertTrue( "List : " + typeListA + "\n" + "does not contain: " + alt, containsType(typeListA, alt)); } for (JSType alt : typeListB) { assertTrue( "List : " + typeListB + "\n" + "does not contain: " + alt, containsType(typeListB, alt)); } return false; } private ArrowType createArrowType(Node params) { return registry.createArrowType(params); } }
/* * * ***** BEGIN LICENSE BLOCK ***** * Version: MPL 1.1/GPL 2.0 * * The contents of this file are subject to the Mozilla Public License Version * 1.1 (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * http://www.mozilla.org/MPL/ * * Software distributed under the License is distributed on an "AS IS" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License * for the specific language governing rights and limitations under the * License. * * The Original Code is Rhino code, released * May 6, 1999. * * The Initial Developer of the Original Code is * Netscape Communications Corporation. * Portions created by the Initial Developer are Copyright (C) 1997-1999 * the Initial Developer. All Rights Reserved. * * Contributor(s): * Nick Santos * * Alternatively, the contents of this file may be used under the terms of * the GNU General Public License Version 2 or later (the "GPL"), in which * case the provisions of the GPL are applicable instead of those above. If * you wish to allow use of your version of this file only under the terms of * the GPL and not to allow others to use your version of this file under the * MPL, indicate your decision by deleting the provisions above and replacing * them with the notice and other provisions required by the GPL. If you do * not delete the provisions above, a recipient may use your version of this * file under either the MPL or the GPL. * * ***** END LICENSE BLOCK ***** */ package com.google.javascript.rhino.jstype; import com.google.common.collect.ImmutableMap; import com.google.javascript.rhino.testing.BaseJSTypeTestCase; import com.google.javascript.rhino.testing.MapBasedScope; /** * @author nicksantos@google.com (Nick Santos) */ public class NamedTypeTest extends BaseJSTypeTestCase { public void testNamedTypeProperties() { NamedType namedA = new NamedType(registry, "TypeA", "source", 1, 0); FunctionType ctorA = registry.createConstructorType( "TypeA", null, null, null, null); ObjectType typeA = ctorA.getInstanceType(); namedA.defineDeclaredProperty("foo", NUMBER_TYPE, null); namedA.resolve( null, new MapBasedScope( ImmutableMap.of("TypeA", ctorA))); assertTypeEquals(NUMBER_TYPE, typeA.getPropertyType("foo")); } public void testActiveXObjectResolve() { NamedType activeXObject = new NamedType(registry, "ActiveXObject", "source", 1, 0); activeXObject.resolve( null, new MapBasedScope( ImmutableMap.of("ActiveXObject", NO_OBJECT_TYPE))); assertEquals("ActiveXObject", activeXObject.toString()); assertTypeEquals(NO_OBJECT_TYPE, activeXObject.getReferencedType()); } }
/* * * ***** BEGIN LICENSE BLOCK ***** * Version: MPL 1.1/GPL 2.0 * * The contents of this file are subject to the Mozilla Public License Version * 1.1 (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * http://www.mozilla.org/MPL/ * * Software distributed under the License is distributed on an "AS IS" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License * for the specific language governing rights and limitations under the * License. * * The Original Code is Rhino code, released * May 6, 1999. * * The Initial Developer of the Original Code is * Netscape Communications Corporation. * Portions created by the Initial Developer are Copyright (C) 1997-1999 * the Initial Developer. All Rights Reserved. * * Contributor(s): * John Lenz * * Alternatively, the contents of this file may be used under the terms of * the GNU General Public License Version 2 or later (the "GPL"), in which * case the provisions of the GPL are applicable instead of those above. If * you wish to allow use of your version of this file only under the terms of * the GPL and not to allow others to use your version of this file under the * MPL, indicate your decision by deleting the provisions above and replacing * them with the notice and other provisions required by the GPL. If you do * not delete the provisions above, a recipient may use your version of this * file under either the MPL or the GPL. * * ***** END LICENSE BLOCK ***** */ package com.google.javascript.rhino.jstype; import com.google.javascript.rhino.testing.BaseJSTypeTestCase; public class ParameterizedTypeTest extends BaseJSTypeTestCase { @Override public void setUp() throws Exception { super.setUp(); } @Override protected ParameterizedType createParameterizedType( ObjectType objectType, JSType parameterType) { return registry.createParameterizedType(objectType, parameterType); } /** * Assert that a type can assign to itself. */ private void assertTypeCanAssignToItself(JSType type) { assertTrue(type.isSubtype(type)); } /** * Tests the behavior of variants type. */ @SuppressWarnings("checked") public void testParameterizedType() throws Exception { ParameterizedType arrOfString = createParameterizedType( ARRAY_TYPE, STRING_TYPE); assertTypeCanAssignToItself(arrOfString); assertTrue(arrOfString.isSubtype(ARRAY_TYPE)); assertTrue(ARRAY_TYPE.isSubtype(arrOfString)); ParameterizedType arrOfNumber = createParameterizedType( ARRAY_TYPE, NUMBER_TYPE); assertTypeCanAssignToItself(arrOfNumber); assertTrue(arrOfNumber.isSubtype(ARRAY_TYPE)); assertTrue(ARRAY_TYPE.isSubtype(arrOfNumber)); assertTrue(arrOfString.isEquivalentTo(createParameterizedType( ARRAY_TYPE, STRING_TYPE))); assertFalse(arrOfString.isEquivalentTo(ARRAY_TYPE)); assertFalse(arrOfString.isEquivalentTo(ARRAY_TYPE)); assertFalse(arrOfString.isEquivalentTo(arrOfNumber)); assertFalse(arrOfNumber.isEquivalentTo(arrOfString)); } public void testPrint1() throws Exception { ParameterizedType arrOfString = createParameterizedType( ARRAY_TYPE, STRING_TYPE); assertEquals("Array.<string>", arrOfString.toString()); } public void testPrint2() throws Exception { ParameterizedType arrOfTemplateType = createParameterizedType( ARRAY_TYPE, new TemplateType(registry, "T")); assertEquals("Array.<T>", arrOfTemplateType.toString()); } public void testPrint3() throws Exception { ParameterizedType arrOfUnknown = createParameterizedType( ARRAY_TYPE, UNKNOWN_TYPE); assertEquals("Array.<?>", arrOfUnknown.toString()); } public void testDifferentRawTypes() throws Exception { ParameterizedType arrOfNumber = createParameterizedType( ARRAY_TYPE, NUMBER_TYPE); ParameterizedType objType = createParameterizedType( OBJECT_TYPE, UNKNOWN_TYPE); assertTrue(arrOfNumber.isSubtype(objType)); assertFalse(objType.isSubtype(arrOfNumber)); } }
/* * * ***** BEGIN LICENSE BLOCK ***** * Version: MPL 1.1/GPL 2.0 * * The contents of this file are subject to the Mozilla Public License Version * 1.1 (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * http://www.mozilla.org/MPL/ * * Software distributed under the License is distributed on an "AS IS" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License * for the specific language governing rights and limitations under the * License. * * The Original Code is Rhino code, released * May 6, 1999. * * The Initial Developer of the Original Code is * Netscape Communications Corporation. * Portions created by the Initial Developer are Copyright (C) 1997-1999 * the Initial Developer. All Rights Reserved. * * Contributor(s): * Nick Santos * * Alternatively, the contents of this file may be used under the terms of * the GNU General Public License Version 2 or later (the "GPL"), in which * case the provisions of the GPL are applicable instead of those above. If * you wish to allow use of your version of this file only under the terms of * the GPL and not to allow others to use your version of this file under the * MPL, indicate your decision by deleting the provisions above and replacing * them with the notice and other provisions required by the GPL. If you do * not delete the provisions above, a recipient may use your version of this * file under either the MPL or the GPL. * * ***** END LICENSE BLOCK ***** */ package com.google.javascript.rhino.jstype; import com.google.javascript.rhino.testing.BaseJSTypeTestCase; public class PrototypeObjectTypeTest extends BaseJSTypeTestCase { public void testToString() { ObjectType type = registry.createAnonymousObjectType(null); assertEquals("{}", type.toString()); type.defineDeclaredProperty("foo", NUMBER_TYPE, null); assertEquals("{foo: number}", type.toString()); type.defineDeclaredProperty("bar", type, null); assertEquals("{bar: {...}, foo: number}", type.toString()); } }
/* * * ***** BEGIN LICENSE BLOCK ***** * Version: MPL 1.1/GPL 2.0 * * The contents of this file are subject to the Mozilla Public License Version * 1.1 (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * http://www.mozilla.org/MPL/ * * Software distributed under the License is distributed on an "AS IS" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License * for the specific language governing rights and limitations under the * License. * * The Original Code is Rhino code, released * May 6, 1999. * * The Initial Developer of the Original Code is * Netscape Communications Corporation. * Portions created by the Initial Developer are Copyright (C) 1997-1999 * the Initial Developer. All Rights Reserved. * * Contributor(s): * Nick Santos * * Alternatively, the contents of this file may be used under the terms of * the GNU General Public License Version 2 or later (the "GPL"), in which * case the provisions of the GPL are applicable instead of those above. If * you wish to allow use of your version of this file only under the terms of * the GPL and not to allow others to use your version of this file under the * MPL, indicate your decision by deleting the provisions above and replacing * them with the notice and other provisions required by the GPL. If you do * not delete the provisions above, a recipient may use your version of this * file under either the MPL or the GPL. * * ***** END LICENSE BLOCK ***** */ package com.google.javascript.rhino.jstype; import com.google.javascript.rhino.testing.Asserts; import com.google.javascript.rhino.testing.BaseJSTypeTestCase; public class RecordTypeTest extends BaseJSTypeTestCase { public void testRecursiveRecord() { ProxyObjectType loop = new ProxyObjectType(registry, NUMBER_TYPE); JSType record = new RecordTypeBuilder(registry) .addProperty("loop", loop, null) .addProperty("number", NUMBER_TYPE, null) .addProperty("string", STRING_TYPE, null) .build(); assertEquals("{loop: number, number: number, string: string}", record.toString()); loop.setReferencedType(record); assertEquals("{loop: {...}, number: number, string: string}", record.toString()); assertEquals("{loop: ?, number: number, string: string}", record.toAnnotationString()); Asserts.assertEquivalenceOperations(record, loop); } public void testLongToString() { JSType record = new RecordTypeBuilder(registry) .addProperty("a1", NUMBER_TYPE, null) .addProperty("a2", NUMBER_TYPE, null) .addProperty("a3", NUMBER_TYPE, null) .addProperty("a4", NUMBER_TYPE, null) .addProperty("a5", NUMBER_TYPE, null) .addProperty("a6", NUMBER_TYPE, null) .build(); assertEquals("{a1: number, a2: number, a3: number, a4: number, ...}", record.toString()); assertEquals( "{a1: number, a2: number, a3: number, a4: number," + " a5: number, a6: number}", record.toAnnotationString()); } public void testSupAndInf() { JSType recordA = new RecordTypeBuilder(registry) .addProperty("a", NUMBER_TYPE, null) .addProperty("b", NUMBER_TYPE, null) .build(); JSType recordC = new RecordTypeBuilder(registry) .addProperty("b", NUMBER_TYPE, null) .addProperty("c", NUMBER_TYPE, null) .build(); ProxyObjectType proxyRecordA = new ProxyObjectType(registry, recordA); ProxyObjectType proxyRecordC = new ProxyObjectType(registry, recordC); JSType aInfC = new RecordTypeBuilder(registry) .addProperty("a", NUMBER_TYPE, null) .addProperty("b", NUMBER_TYPE, null) .addProperty("c", NUMBER_TYPE, null) .build(); JSType aSupC = registry.createUnionType(recordA, recordC); Asserts.assertTypeEquals( aInfC, recordA.getGreatestSubtype(recordC)); Asserts.assertTypeEquals( aSupC, recordA.getLeastSupertype(recordC)); Asserts.assertTypeEquals( aInfC, proxyRecordA.getGreatestSubtype(proxyRecordC)); Asserts.assertTypeEquals( aSupC, proxyRecordA.getLeastSupertype(proxyRecordC)); } public void testSubtypeWithUnknowns() throws Exception { JSType recordA = new RecordTypeBuilder(registry) .addProperty("a", NUMBER_TYPE, null) .build(); JSType recordB = new RecordTypeBuilder(registry) .addProperty("a", UNKNOWN_TYPE, null) .build(); assertTrue(recordA.isSubtype(recordB)); assertTrue(recordB.isSubtype(recordA)); } public void testSubtypeWithUnknowns2() throws Exception { JSType recordA = new RecordTypeBuilder(registry) .addProperty("a", new FunctionBuilder(registry) .withReturnType(NUMBER_TYPE) .build(), null) .build(); JSType recordB = new RecordTypeBuilder(registry) .addProperty("a", new FunctionBuilder(registry) .withReturnType(UNKNOWN_TYPE) .build(), null) .build(); assertTrue(recordA.isSubtype(recordB)); assertTrue(recordB.isSubtype(recordA)); } public void testSubtypeWithFunctionProps() throws Exception { JSType recordA = new RecordTypeBuilder(registry) .addProperty("a", new FunctionBuilder(registry) .withReturnType(NUMBER_TYPE) .build(), null) .build(); JSType recordB = new RecordTypeBuilder(registry) .addProperty("a", new FunctionBuilder(registry) .withReturnType(STRING_TYPE) .build(), null) .build(); assertFalse(recordA.isSubtype(recordB)); assertFalse(recordB.isSubtype(recordA)); } public void testSubtypeWithManyProps() throws Exception { JSType recordA = new RecordTypeBuilder(registry) .addProperty("a", NUMBER_TYPE, null) .addProperty("b", NUMBER_TYPE, null) .build(); JSType recordB = new RecordTypeBuilder(registry) .addProperty("a", NUMBER_TYPE, null) .addProperty("b", STRING_TYPE, null) .build(); JSType recordC = new RecordTypeBuilder(registry) .addProperty("a", NUMBER_TYPE, null) .addProperty("b", registry.createUnionType(NUMBER_TYPE, STRING_TYPE), null) .build(); assertFalse(recordA.isSubtype(recordB)); assertFalse(recordB.isSubtype(recordA)); assertFalse(recordC.isSubtype(recordB)); assertFalse(recordB.isSubtype(recordC)); } }
/* * * ***** BEGIN LICENSE BLOCK ***** * Version: MPL 1.1/GPL 2.0 * * The contents of this file are subject to the Mozilla Public License Version * 1.1 (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * http://www.mozilla.org/MPL/ * * Software distributed under the License is distributed on an "AS IS" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License * for the specific language governing rights and limitations under the * License. * * The Original Code is Rhino code, released * May 6, 1999. * * The Initial Developer of the Original Code is * Netscape Communications Corporation. * Portions created by the Initial Developer are Copyright (C) 1997-1999 * the Initial Developer. All Rights Reserved. * * Contributor(s): * Nick Santos * * Alternatively, the contents of this file may be used under the terms of * the GNU General Public License Version 2 or later (the "GPL"), in which * case the provisions of the GPL are applicable instead of those above. If * you wish to allow use of your version of this file only under the terms of * the GPL and not to allow others to use your version of this file under the * MPL, indicate your decision by deleting the provisions above and replacing * them with the notice and other provisions required by the GPL. If you do * not delete the provisions above, a recipient may use your version of this * file under either the MPL or the GPL. * * ***** END LICENSE BLOCK ***** */ package com.google.javascript.rhino.jstype; import static com.google.javascript.rhino.jstype.TernaryValue.FALSE; import static com.google.javascript.rhino.jstype.TernaryValue.TRUE; import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN; import junit.framework.TestCase; /** * Tests the behavior of {@link TernaryValue} by verifying the truth tables * of the operations {@link TernaryValue#and(TernaryValue)}, * {@link TernaryValue#not()}, {@link TernaryValue#or(TernaryValue)} * and {@link TernaryValue#xor(TernaryValue)} as well as the * {@link TernaryValue#toBoolean(boolean)} method. * */ public class TernaryValueTest extends TestCase { public void testOrdinal() throws Exception { assertEquals(0, FALSE.ordinal()); assertEquals(1, TRUE.ordinal()); assertEquals(2, UNKNOWN.ordinal()); } public void testAnd() throws Exception { assertEquals(TRUE, TRUE.and(TRUE)); assertEquals(FALSE, TRUE.and(FALSE)); assertEquals(UNKNOWN, TRUE.and(UNKNOWN)); assertEquals(FALSE, FALSE.and(TRUE)); assertEquals(FALSE, FALSE.and(FALSE)); assertEquals(FALSE, FALSE.and(UNKNOWN)); assertEquals(UNKNOWN, UNKNOWN.and(TRUE)); assertEquals(FALSE, UNKNOWN.and(FALSE)); assertEquals(UNKNOWN, UNKNOWN.and(UNKNOWN)); } public void testNot() throws Exception { assertEquals(FALSE, TRUE.not()); assertEquals(TRUE, FALSE.not()); assertEquals(UNKNOWN, UNKNOWN.not()); } public void testOr() throws Exception { assertEquals(TRUE, TRUE.or(TRUE)); assertEquals(TRUE, TRUE.or(FALSE)); assertEquals(TRUE, TRUE.or(UNKNOWN)); assertEquals(TRUE, FALSE.or(TRUE)); assertEquals(FALSE, FALSE.or(FALSE)); assertEquals(UNKNOWN, FALSE.or(UNKNOWN)); assertEquals(TRUE, UNKNOWN.or(TRUE)); assertEquals(UNKNOWN, UNKNOWN.or(FALSE)); assertEquals(UNKNOWN, UNKNOWN.or(UNKNOWN)); } public void testXor() throws Exception { assertEquals(FALSE, TRUE.xor(TRUE)); assertEquals(TRUE, TRUE.xor(FALSE)); assertEquals(UNKNOWN, TRUE.xor(UNKNOWN)); assertEquals(TRUE, FALSE.xor(TRUE)); assertEquals(FALSE, FALSE.xor(FALSE)); assertEquals(UNKNOWN, FALSE.xor(UNKNOWN)); assertEquals(UNKNOWN, UNKNOWN.xor(TRUE)); assertEquals(UNKNOWN, UNKNOWN.xor(FALSE)); assertEquals(UNKNOWN, UNKNOWN.xor(UNKNOWN)); } public void testToBoolean() throws Exception { assertTrue(TRUE.toBoolean(true)); assertTrue(TRUE.toBoolean(false)); assertFalse(FALSE.toBoolean(true)); assertFalse(FALSE.toBoolean(false)); assertTrue(UNKNOWN.toBoolean(true)); assertFalse(UNKNOWN.toBoolean(false)); } public void testToString() { assertEquals("true", TRUE.toString()); assertEquals("false", FALSE.toString()); assertEquals("unknown", UNKNOWN.toString()); } }
/* * * ***** BEGIN LICENSE BLOCK ***** * Version: MPL 1.1/GPL 2.0 * * The contents of this file are subject to the Mozilla Public License Version * 1.1 (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * http://www.mozilla.org/MPL/ * * Software distributed under the License is distributed on an "AS IS" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License * for the specific language governing rights and limitations under the * License. * * The Original Code is Rhino code, released * May 6, 1999. * * The Initial Developer of the Original Code is * Netscape Communications Corporation. * Portions created by the Initial Developer are Copyright (C) 1997-1999 * the Initial Developer. All Rights Reserved. * * Contributor(s): * Nick Santos * * Alternatively, the contents of this file may be used under the terms of * the GNU General Public License Version 2 or later (the "GPL"), in which * case the provisions of the GPL are applicable instead of those above. If * you wish to allow use of your version of this file only under the terms of * the GPL and not to allow others to use your version of this file under the * MPL, indicate your decision by deleting the provisions above and replacing * them with the notice and other provisions required by the GPL. If you do * not delete the provisions above, a recipient may use your version of this * file under either the MPL or the GPL. * * ***** END LICENSE BLOCK ***** */ package com.google.javascript.rhino.jstype; import com.google.javascript.rhino.testing.BaseJSTypeTestCase; /** * Test for {@link UnionTypeBuilder}. * * @author nicksantos@google.com (Nick Santos) */ public class UnionTypeBuilderTest extends BaseJSTypeTestCase { public void testAllType() { assertUnion("*", ALL_TYPE); assertUnion("*", NUMBER_TYPE, ALL_TYPE); assertUnion("*", ALL_TYPE, NUMBER_TYPE); assertUnion("*", ALL_TYPE, NUMBER_TYPE, NO_TYPE); } public void testEmptyUnion() { assertUnion("None"); assertUnion("None", NO_TYPE, NO_TYPE); } public void testUnionTypes() { JSType union = registry.createUnionType(STRING_TYPE, OBJECT_TYPE); assertUnion("*", ALL_TYPE, union); assertUnion("(Object|string)", OBJECT_TYPE, union); assertUnion("(Object|string)", union, OBJECT_TYPE); assertUnion("(Object|number|string)", NUMBER_TYPE, union); assertUnion("(Object|number|string)", union, NUMBER_TYPE); assertUnion("(Object|boolean|number|string)", union, registry.createUnionType(NUMBER_TYPE, BOOLEAN_TYPE)); assertUnion("(Object|boolean|number|string)", registry.createUnionType(NUMBER_TYPE, BOOLEAN_TYPE), union); assertUnion("(Object|string)", union, STRING_OBJECT_TYPE); } public void testUnknownTypes() { JSType unresolvedNameA1 = new NamedType(registry, "not.resolved.A", null, -1, -1); JSType unresolvedNameA2 = new NamedType(registry, "not.resolved.A", null, -1, -1); JSType unresolvedNameB = new NamedType(registry, "not.resolved.B", null, -1, -1); assertUnion("?", UNKNOWN_TYPE); assertUnion("?", UNKNOWN_TYPE, UNKNOWN_TYPE); // NOTE: "(?)" means there are multiple unknown types in the union. assertUnion("?", UNKNOWN_TYPE, unresolvedNameA1); assertUnion("not.resolved.A", unresolvedNameA1, unresolvedNameA2); assertUnion("(not.resolved.A|not.resolved.B)", unresolvedNameA1, unresolvedNameB); assertUnion("(Object|not.resolved.A)", unresolvedNameA1, OBJECT_TYPE); } public void testRemovalOfDupes() { JSType stringAndObject = registry.createUnionType(STRING_TYPE, OBJECT_TYPE); assertUnion("(Object|string)", stringAndObject, STRING_OBJECT_TYPE); assertUnion("(Object|string)", STRING_OBJECT_TYPE, stringAndObject); } public void testRemovalOfDupes2() { JSType union = registry.createUnionType( EVAL_ERROR_TYPE, createFunctionWithReturn(ERROR_TYPE), ERROR_TYPE, createFunctionWithReturn(EVAL_ERROR_TYPE)); assertEquals("(Error|function (): Error)", union.toString()); } public void testRemovalOfDupes3() { JSType union = registry.createUnionType( ERROR_TYPE, createFunctionWithReturn(EVAL_ERROR_TYPE), EVAL_ERROR_TYPE, createFunctionWithReturn(ERROR_TYPE)); assertEquals("(Error|function (): Error)", union.toString()); } public void assertUnion(String expected, JSType ... types) { UnionTypeBuilder builder = new UnionTypeBuilder(registry); for (JSType type : types) { builder.addAlternate(type); } assertEquals(expected, builder.build().toString()); } public FunctionType createFunctionWithReturn(JSType type) { return new FunctionBuilder(registry) .withParamsNode(registry.createParameters()) .withReturnType(type) .build(); } }
/* * * ***** BEGIN LICENSE BLOCK ***** * Version: MPL 1.1/GPL 2.0 * * The contents of this file are subject to the Mozilla Public License Version * 1.1 (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * http://www.mozilla.org/MPL/ * * Software distributed under the License is distributed on an "AS IS" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License * for the specific language governing rights and limitations under the * License. * * The Original Code is Rhino code, released * May 6, 1999. * * The Initial Developer of the Original Code is * Netscape Communications Corporation. * Portions created by the Initial Developer are Copyright (C) 1997-1999 * the Initial Developer. All Rights Reserved. * * Contributor(s): * Nick Santos * * Alternatively, the contents of this file may be used under the terms of * the GNU General Public License Version 2 or later (the "GPL"), in which * case the provisions of the GPL are applicable instead of those above. If * you wish to allow use of your version of this file only under the terms of * the GPL and not to allow others to use your version of this file under the * MPL, indicate your decision by deleting the provisions above and replacing * them with the notice and other provisions required by the GPL. If you do * not delete the provisions above, a recipient may use your version of this * file under either the MPL or the GPL. * * ***** END LICENSE BLOCK ***** */ package com.google.javascript.rhino.jstype; import com.google.javascript.rhino.testing.BaseJSTypeTestCase; import com.google.javascript.rhino.testing.Asserts; public class UnionTypeTest extends BaseJSTypeTestCase { private NamedType unresolvedNamedType; @Override public void setUp() throws Exception { super.setUp(); unresolvedNamedType = new NamedType(registry, "not.resolved.named.type", null, -1, -1); } /** * Assert that a type can assign to itself. */ private void assertTypeCanAssignToItself(JSType type) { assertTrue(type.isSubtype(type)); } /** * Tests the behavior of variants type. */ @SuppressWarnings("checked") public void testUnionType() throws Exception { UnionType nullOrString = (UnionType) createUnionType(NULL_TYPE, STRING_OBJECT_TYPE); UnionType stringOrNull = (UnionType) createUnionType(STRING_OBJECT_TYPE, NULL_TYPE); Asserts.assertTypeEquals(nullOrString, stringOrNull); Asserts.assertTypeEquals(stringOrNull, nullOrString); assertTypeCanAssignToItself(createUnionType(VOID_TYPE, NUMBER_TYPE)); assertTypeCanAssignToItself( createUnionType(NUMBER_TYPE, STRING_TYPE, OBJECT_TYPE)); assertTypeCanAssignToItself(createUnionType(NUMBER_TYPE, BOOLEAN_TYPE)); assertTypeCanAssignToItself(createUnionType(VOID_TYPE)); UnionType nullOrUnknown = (UnionType) createUnionType(NULL_TYPE, unresolvedNamedType); assertTrue(nullOrUnknown.isUnknownType()); Asserts.assertTypeEquals(nullOrUnknown, NULL_TYPE.getLeastSupertype(nullOrUnknown)); Asserts.assertTypeEquals(nullOrUnknown, nullOrUnknown.getLeastSupertype(NULL_TYPE)); Asserts.assertTypeEquals(UNKNOWN_TYPE, NULL_TYPE.getGreatestSubtype(nullOrUnknown)); Asserts.assertTypeEquals(UNKNOWN_TYPE, nullOrUnknown.getGreatestSubtype(NULL_TYPE)); assertTrue(NULL_TYPE.differsFrom(nullOrUnknown)); assertTrue(nullOrUnknown.differsFrom(NULL_TYPE)); assertFalse(nullOrUnknown.differsFrom(unresolvedNamedType)); assertTrue(NULL_TYPE.isSubtype(nullOrUnknown)); assertTrue(unresolvedNamedType.isSubtype(nullOrUnknown)); assertTrue(nullOrUnknown.isSubtype(NULL_TYPE)); Asserts.assertTypeEquals(unresolvedNamedType, nullOrUnknown.restrictByNotNullOrUndefined()); // findPropertyType Asserts.assertTypeEquals(NUMBER_TYPE, nullOrString.findPropertyType("length")); assertEquals(null, nullOrString.findPropertyType("lengthx")); Asserts.assertResolvesToSame(nullOrString); } /** * Tests {@link JSType#getGreatestSubtype(JSType)} on union types. */ public void testGreatestSubtypeUnionTypes1() { Asserts.assertTypeEquals(NULL_TYPE, createNullableType(STRING_TYPE).getGreatestSubtype( createNullableType(NUMBER_TYPE))); } /** * Tests {@link JSType#getGreatestSubtype(JSType)} on union types. */ @SuppressWarnings("checked") public void testGreatestSubtypeUnionTypes2() { UnionType evalUriError = (UnionType) createUnionType(EVAL_ERROR_TYPE, URI_ERROR_TYPE); Asserts.assertTypeEquals(evalUriError, evalUriError.getGreatestSubtype(ERROR_TYPE)); } /** * Tests {@link JSType#getGreatestSubtype(JSType)} on union types. */ @SuppressWarnings("checked") public void testGreatestSubtypeUnionTypes3() { // (number,undefined,null) UnionType nullableOptionalNumber = (UnionType) createUnionType(NULL_TYPE, VOID_TYPE, NUMBER_TYPE); // (null,undefined) UnionType nullUndefined = (UnionType) createUnionType(VOID_TYPE, NULL_TYPE); Asserts.assertTypeEquals(nullUndefined, nullUndefined.getGreatestSubtype(nullableOptionalNumber)); Asserts.assertTypeEquals(nullUndefined, nullableOptionalNumber.getGreatestSubtype(nullUndefined)); } /** * Tests {@link JSType#getGreatestSubtype(JSType)} on union types. */ public void testGreatestSubtypeUnionTypes4() throws Exception { UnionType errUnion = (UnionType) createUnionType( NULL_TYPE, EVAL_ERROR_TYPE, URI_ERROR_TYPE); Asserts.assertTypeEquals(createUnionType(EVAL_ERROR_TYPE, URI_ERROR_TYPE), errUnion.getGreatestSubtype(ERROR_TYPE)); } /** * Tests {@link JSType#getGreatestSubtype(JSType)} on union types. */ public void testGreatestSubtypeUnionTypes5() throws Exception { JSType errUnion = createUnionType(EVAL_ERROR_TYPE, URI_ERROR_TYPE); Asserts.assertTypeEquals(NO_OBJECT_TYPE, errUnion.getGreatestSubtype(STRING_OBJECT_TYPE)); } /** * Tests subtyping of union types. */ public void testSubtypingUnionTypes() throws Exception { // subtypes assertTrue(BOOLEAN_TYPE. isSubtype(createUnionType(BOOLEAN_TYPE, STRING_TYPE))); assertTrue(createUnionType(BOOLEAN_TYPE, STRING_TYPE). isSubtype(createUnionType(BOOLEAN_TYPE, STRING_TYPE))); assertTrue(createUnionType(BOOLEAN_TYPE, STRING_TYPE). isSubtype(createUnionType(BOOLEAN_TYPE, STRING_TYPE, NULL_TYPE))); assertTrue(createUnionType(BOOLEAN_TYPE, STRING_TYPE). isSubtype(createUnionType(BOOLEAN_TYPE, STRING_TYPE, NULL_TYPE))); assertTrue(createUnionType(BOOLEAN_TYPE). isSubtype(createUnionType(BOOLEAN_TYPE, STRING_TYPE, NULL_TYPE))); assertTrue(createUnionType(STRING_TYPE). isSubtype(createUnionType(BOOLEAN_TYPE, STRING_TYPE, NULL_TYPE))); assertTrue(createUnionType(STRING_TYPE, NULL_TYPE).isSubtype(ALL_TYPE)); assertTrue(createUnionType(DATE_TYPE, REGEXP_TYPE).isSubtype(OBJECT_TYPE)); assertTrue(createUnionType(URI_ERROR_TYPE, EVAL_ERROR_TYPE). isSubtype(ERROR_TYPE)); assertTrue(createUnionType(URI_ERROR_TYPE, EVAL_ERROR_TYPE). isSubtype(OBJECT_TYPE)); // not subtypes assertFalse(createUnionType(STRING_TYPE, NULL_TYPE).isSubtype(NO_TYPE)); assertFalse(createUnionType(STRING_TYPE, NULL_TYPE). isSubtype(NO_OBJECT_TYPE)); assertFalse(createUnionType(NO_OBJECT_TYPE, NULL_TYPE). isSubtype(OBJECT_TYPE)); // defined unions assertTrue(NUMBER_TYPE.isSubtype(OBJECT_NUMBER_STRING)); assertTrue(OBJECT_TYPE.isSubtype(OBJECT_NUMBER_STRING)); assertTrue(STRING_TYPE.isSubtype(OBJECT_NUMBER_STRING)); assertTrue(NO_OBJECT_TYPE.isSubtype(OBJECT_NUMBER_STRING)); assertTrue(NUMBER_TYPE.isSubtype(NUMBER_STRING_BOOLEAN)); assertTrue(BOOLEAN_TYPE.isSubtype(NUMBER_STRING_BOOLEAN)); assertTrue(STRING_TYPE.isSubtype(NUMBER_STRING_BOOLEAN)); assertTrue(NUMBER_TYPE.isSubtype(OBJECT_NUMBER_STRING_BOOLEAN)); assertTrue(OBJECT_TYPE.isSubtype(OBJECT_NUMBER_STRING_BOOLEAN)); assertTrue(STRING_TYPE.isSubtype(OBJECT_NUMBER_STRING_BOOLEAN)); assertTrue(BOOLEAN_TYPE.isSubtype(OBJECT_NUMBER_STRING_BOOLEAN)); assertTrue(NO_OBJECT_TYPE.isSubtype(OBJECT_NUMBER_STRING_BOOLEAN)); } /** * Tests that special union types can assign to other types. Unions * containing the unknown type should be able to assign to any other * type. */ @SuppressWarnings("checked") public void testSpecialUnionCanAssignTo() throws Exception { // autoboxing quirks UnionType numbers = (UnionType) createUnionType(NUMBER_TYPE, NUMBER_OBJECT_TYPE); assertFalse(numbers.isSubtype(NUMBER_TYPE)); assertFalse(numbers.isSubtype(NUMBER_OBJECT_TYPE)); assertFalse(numbers.isSubtype(EVAL_ERROR_TYPE)); UnionType strings = (UnionType) createUnionType(STRING_OBJECT_TYPE, STRING_TYPE); assertFalse(strings.isSubtype(STRING_TYPE)); assertFalse(strings.isSubtype(STRING_OBJECT_TYPE)); assertFalse(strings.isSubtype(DATE_TYPE)); UnionType booleans = (UnionType) createUnionType(BOOLEAN_OBJECT_TYPE, BOOLEAN_TYPE); assertFalse(booleans.isSubtype(BOOLEAN_TYPE)); assertFalse(booleans.isSubtype(BOOLEAN_OBJECT_TYPE)); assertFalse(booleans.isSubtype(REGEXP_TYPE)); // unknown quirks JSType unknown = createUnionType(UNKNOWN_TYPE, DATE_TYPE); assertTrue(unknown.isSubtype(STRING_TYPE)); // all members need to be assignable to UnionType stringDate = (UnionType) createUnionType(STRING_OBJECT_TYPE, DATE_TYPE); assertTrue(stringDate.isSubtype(OBJECT_TYPE)); assertFalse(stringDate.isSubtype(STRING_OBJECT_TYPE)); assertFalse(stringDate.isSubtype(DATE_TYPE)); } /** * Tests the factory method * {@link JSTypeRegistry#createUnionType(JSType...)}. */ @SuppressWarnings("checked") public void testCreateUnionType() throws Exception { // number UnionType optNumber = (UnionType) registry.createUnionType(NUMBER_TYPE, DATE_TYPE); assertTrue(optNumber.contains(NUMBER_TYPE)); assertTrue(optNumber.contains(DATE_TYPE)); // union UnionType optUnion = (UnionType) registry.createUnionType(REGEXP_TYPE, registry.createUnionType(STRING_OBJECT_TYPE, DATE_TYPE)); assertTrue(optUnion.contains(DATE_TYPE)); assertTrue(optUnion.contains(STRING_OBJECT_TYPE)); assertTrue(optUnion.contains(REGEXP_TYPE)); } public void testUnionWithUnknown() throws Exception { assertTrue(createUnionType(UNKNOWN_TYPE, NULL_TYPE).isUnknownType()); } public void testGetRestrictedUnion1() throws Exception { UnionType numStr = (UnionType) createUnionType(NUMBER_TYPE, STRING_TYPE); Asserts.assertTypeEquals(STRING_TYPE, numStr.getRestrictedUnion(NUMBER_TYPE)); } public void testGetRestrictedUnion2() throws Exception { UnionType numStr = (UnionType) createUnionType( NULL_TYPE, EVAL_ERROR_TYPE, URI_ERROR_TYPE); Asserts.assertTypeEquals(NULL_TYPE, numStr.getRestrictedUnion(ERROR_TYPE)); } public void testIsEquivalentTo() { UnionType type = (UnionType) createUnionType(NUMBER_TYPE, STRING_TYPE); assertFalse(type.equals(null)); assertTrue(type.isEquivalentTo(type)); } public void testProxyUnionType() throws Exception { UnionType stringOrNumber = (UnionType) createUnionType(NUMBER_TYPE, STRING_TYPE); UnionType stringOrBoolean = (UnionType) createUnionType(BOOLEAN_TYPE, STRING_TYPE); assertEquals( "(boolean|number|string)", stringOrNumber.getLeastSupertype(stringOrBoolean).toString()); assertEquals( "string", stringOrNumber.getGreatestSubtype(stringOrBoolean).toString()); assertEquals( TernaryValue.UNKNOWN, stringOrNumber.testForEquality(stringOrBoolean)); assertEquals( "(number|string)", stringOrNumber.getTypesUnderEquality( stringOrBoolean).typeA.toString()); assertEquals( "string", stringOrNumber.getTypesUnderShallowEquality( stringOrBoolean).typeA.toString()); assertEquals( "(number|string)", stringOrNumber.getTypesUnderInequality( stringOrBoolean).typeA.toString()); assertEquals( "(number|string)", stringOrNumber.getTypesUnderShallowInequality( stringOrBoolean).typeA.toString()); ObjectType stringOrNumberProxy = new ProxyObjectType(registry, stringOrNumber); ObjectType stringOrBooleanProxy = new ProxyObjectType(registry, stringOrBoolean); assertEquals( "(boolean|number|string)", stringOrNumberProxy.getLeastSupertype( stringOrBooleanProxy).toString()); assertEquals( "string", stringOrNumberProxy.getGreatestSubtype( stringOrBooleanProxy).toString()); assertEquals( TernaryValue.UNKNOWN, stringOrNumberProxy.testForEquality(stringOrBooleanProxy)); assertEquals( "(number|string)", stringOrNumberProxy.getTypesUnderEquality( stringOrBooleanProxy).typeA.toString()); assertEquals( "string", stringOrNumberProxy.getTypesUnderShallowEquality( stringOrBooleanProxy).typeA.toString()); assertEquals( "(number|string)", stringOrNumberProxy.getTypesUnderInequality( stringOrBooleanProxy).typeA.toString()); assertEquals( "(number|string)", stringOrNumberProxy.getTypesUnderShallowInequality( stringOrBooleanProxy).typeA.toString()); } public void testCollapseUnion1() { assertEquals( "*", registry.createUnionType(NUMBER_TYPE, STRING_TYPE) .collapseUnion().toString()); } public void testCollapseUnion2() { assertEquals( "?", registry.createUnionType(UNKNOWN_TYPE, NUMBER_TYPE) .collapseUnion().toString()); assertEquals( "?", registry.createUnionType(NUMBER_TYPE, UNKNOWN_TYPE) .collapseUnion().toString()); } public void testCollapseUnion3() { assertEquals( "Object", registry.createUnionType(ARRAY_TYPE, DATE_TYPE) .collapseUnion().toString()); assertEquals( "Object", registry.createUnionType(ARRAY_TYPE, OBJECT_TYPE) .collapseUnion().toString()); assertEquals( "Error", registry.createUnionType(ERROR_TYPE, RANGE_ERROR_TYPE) .collapseUnion().toString()); assertEquals( "Error", registry.createUnionType(EVAL_ERROR_TYPE, RANGE_ERROR_TYPE) .collapseUnion().toString()); assertEquals( "Error", registry.createUnionType( EVAL_ERROR_TYPE, RANGE_ERROR_TYPE, TYPE_ERROR_TYPE) .collapseUnion().toString()); } public void testCollapseUnion4() { assertEquals( "*", registry.createUnionType(OBJECT_TYPE, STRING_TYPE) .collapseUnion().toString()); assertEquals( "*", registry.createUnionType(STRING_TYPE, OBJECT_TYPE) .collapseUnion().toString()); } public void testCollapseProxyUnion() { // Make sure we don't unbox the proxy. ProxyObjectType type = new ProxyObjectType(registry, OBJECT_TYPE); assertTrue(type == type.collapseUnion()); } public void testShallowEquality() { assertTrue( registry.createUnionType(ARRAY_TYPE, STRING_TYPE) .canTestForShallowEqualityWith(OBJECT_TYPE)); } }
